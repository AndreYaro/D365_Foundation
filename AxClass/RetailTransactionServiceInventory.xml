<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceInventory</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections.ObjectModel;
using System.Device.Location;
using System.Reflection;
using System.Collections.Generic;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using CRT = Microsoft.Dynamics.Commerce.Runtime;
using TS = Microsoft.Dynamics.Commerce.Runtime.TransactionService.Serialization;
using CLRSystem = System;

/// <summary>
/// The <c>RetailTransactionServiceInventory</c> implements the inventory related methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
public class RetailTransactionServiceInventory
{
    internal static const str TransactionDateAttributeName  = 'TransactionDate';

    public const str GuidStr = 'Guid';
    public const str UpdatedInAxAttributeName = 'UpdatedInAx';
    public const str MessageAttributeName = 'Message';
    public const str TrueStr = 'true';
    public const str FalseStr = 'false';
    public const str ProductRecordIdAttributeName = "ProductRecordId";
    public const str QuantityCommitModeKey = "QuantityCommitMode";
    public const str InventoryAvailableToPromiseType = "Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryAvailableToPromise";
    private const int DateFormatCode = 321;
    private const int CompleteDocumentExpiryNumDays = 7;
    private const str TransactionServiceAssemblyName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService';
    private const str TransactionServiceInventoryDocumentSearchCriteriaTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentSearchCriteria';
    private const str TransactionServiceInventoryDocumentLineSearchCriteriaTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentLineSearchCriteria';
    private const str TransactionServiceSingleInventoryDocumentSearchCriteriaTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceSingleInventoryDocumentSearchCriteria';
    private const str TransactionServiceInventoryLookupSearchCriteriaTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryLookupSearchCriteria';
    private const str TransactionServiceTransferOrderJournalDetailSearchCriteriaTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceTransferOrderJournalDetailSearchCriteria';
    private const int DefaultNumberOfDecimals = 5;
    private const str InventoryDocumentLineOriginTypeAttribute = 'InventoryDocumentLineOriginType';
    private const str AvailPhysicalSortColumnName = 'AvailPhysical';
    private const str PhysicalReservedSortColumnName = 'PhysicalReserved';
    private const str OrderedSumSortColumnName = 'OrderedSum';
    private const str LocationNameSortColumnName = 'Name';
    private const str StoreNumberSortColumnName = 'StoreNumber';
    private const str GeoDistanceSortColumnName = 'Distance';

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addUpdateFailure</Name>
				<Source><![CDATA[
    private static void addUpdateFailure(XmlElement xmlRecord, str message)
    {
        if (xmlRecord != null)
        {
            xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::FalseStr);
            xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, message);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addUpdateFailureAndGetResultContainer</Name>
				<Source><![CDATA[
    private static container addUpdateFailureAndGetResultContainer(XmlElement xmlRoot, str message, XmlDocument xmlDoc)
    {
        container           resultContainer;

        RetailTransactionServiceInventory::addUpdateFailure(xmlRoot, message);

        resultContainer = [false, message, xmlDoc.toString()];

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkerRecIdByPersonnelNumber</Name>
				<Source><![CDATA[
    private static boolean getWorkerRecIdByPersonnelNumber(Map workerMap, str personnelNumber)
    {
        HcmWorker workerTable;
        boolean workerFound = false;

        if (personnelNumber != '' && workerMap.exists(personnelNumber))
        {
            workerFound = true;
        }
        else
        {
            select firstonly1 RecId from workerTable where workerTable.PersonnelNumber == personnelNumber;

            if (workerTable)
            {
                workerMap.insert(personnelNumber, workerTable.RecId);
                workerFound = true;
            }
        }

        return workerFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkerOnInventJournal</Name>
				<Source><![CDATA[
    private static void updateWorkerOnInventJournal(Map workerMap, str personnelNumber, InventJournalTable journalTable)
    {
        boolean canUpdate = RetailTransactionServiceInventory::getWorkerRecIdByPersonnelNumber(workerMap, personnelNumber);

        if (canUpdate)
        {
            journalTable.Worker = workerMap.lookup(personnelNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkerOnInventJournalTrans</Name>
				<Source><![CDATA[
    private static void updateWorkerOnInventJournalTrans(Map workerMap, str personnelNumber, InventJournalTrans transTable)
    {
        boolean canUpdate = RetailTransactionServiceInventory::getWorkerRecIdByPersonnelNumber(workerMap, personnelNumber);

        if (canUpdate)
        {
            transTable.Worker = workerMap.lookup(personnelNumber);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructProductKey</Name>
				<Source><![CDATA[
    private static str constructProductKey(str itemId, str dataAreaId, str colorId = '', str configId = '', str sizeId = '', str styleId = '', str versionId = '')
    {
        if (!versionId)
        {
            return strFmt('%1_%2_%3_%4_%5_%6', dataAreaId, itemId, colorId, configId, sizeId, styleId);
        }

        return strFmt('%1_%2_%3_%4_%5_%6_%7', dataAreaId, itemId, colorId, configId, sizeId, styleId, versionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemLocationControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if item is location controlled and if blank receipt is allowed for this dimension.
    /// </summary>
    /// <param name = "itemId">The item identifier.</param>
    /// <returns>True if the item is location controlled, false otherwise.</returns>
    private static boolean isItemLocationControlled(ItemId itemId)
    {
        InventDimGroupFieldSetup dimFieldSetup = EcoResDimensionGroupSetup::getFieldSetupForItem(itemId, fieldNum(InventDim, wmsLocationId));
        boolean isWMSLocationRequired = dimFieldSetup && dimFieldSetup.isActive() && !dimFieldSetup.isAllowBlankReceiptEnabled();
        return isWMSLocationRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemSerialNumberActivated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if item is serial number active.
    /// </summary>
    /// <param name = "itemId">The item identifier.</param>
    /// <returns>True if the item is serial number controlled; otherwise, false.</returns>
    private static boolean isItemSerialNumberActivated(ItemId itemId)
    {
        return InventTable::find(itemid).isItemSerialNumberActivated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductRecordId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the product record identifier given the released item identifier and dimension values.
    /// If product is nonvariant, record identifier is from InventTable. Otherwise, identifier is from InventDimCombinationTable.
    /// </summary>
    /// <param name = "productMap">A dictionary that stores mappings between product record identifier and item identifier, data area identifier, and dimension values.</param>
    /// <param name = "itemId">The released item identifier.</param>
    /// <param name = "dataAreaId">The data area identifier.</param>
    /// <param name = "colorId">The color identifier.</param>
    /// <param name = "configId">The configuration identifier.</param>
    /// <param name = "sizeId">The size identifier.</param>
    /// <param name = "styleId">The style identifier.</param>
    /// <returns>The mapped product record identifier.</returns>
    [SysObsolete('Method is obsoleted to support version dimension. Callers should redirect their calls to the getProductRecordIdByDimensions method. Please file an extensibility request if other access is required.', 
                 false, 20\4\2020)]
    public static RecId getProductRecordId(Map productMap, str itemId, str dataAreaId, str colorId = '', str configId = '', str sizeId = '', str styleId = '')
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(EcoResProductVersion)))
        {
            throw error(strFmt("@SCM:EcoResProductVersionCheckIsEnabled", funcName()));
        }

        return RetailTransactionServiceInventory::getProductRecordIdByDimensionsInternal(
            productMap, 
            itemId, 
            dataAreaId, 
            colorId, 
            configId, 
            sizeId, 
            styleId,
            /*version*/ '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductRecordIdByDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the product record identifier given the released item identifier and dimension values.
    /// If product is nonvariant, record identifier is from InventTable. Otherwise, identifier is from InventDimCombinationTable.
    /// </summary>
    /// <param name = "productMap">A dictionary that stores mappings between product record identifier and item identifier, data area identifier, and dimension values.</param>
    /// <param name = "itemId">The released item identifier.</param>
    /// <param name = "dataAreaId">The data area identifier.</param>
    /// <param name = "colorId">The color identifier.</param>
    /// <param name = "configId">The configuration identifier.</param>
    /// <param name = "sizeId">The size identifier.</param>
    /// <param name = "styleId">The style identifier.</param>
    /// <param name = "versionId">The version identifier.</param>
    /// <returns>The mapped product record identifier.</returns>
    [Hookable(false)]
    public static RecId getProductRecordIdByDimensions(Map productMap, str itemId, str dataAreaId, str colorId = '', str configId = '', str sizeId = '', str styleId = '', str versionId = '')
    {
        boolean isEcoResProductVersionFeatureEnabled = isConfigurationkeyEnabled(configurationKeyNum(EcoResProductVersion));
        
        if (isEcoResProductVersionFeatureEnabled)
        {
            return RetailTransactionServiceInventory::getProductRecordIdByDimensionsInternal(
                productMap,
                itemId,
                dataAreaId,
                colorId,
                configId,
                sizeId,
                styleId,
                versionId);
        }
        else
        {
            return RetailTransactionServiceInventory::getProductRecordId(
                productMap,
                itemId,
                dataAreaId,
                colorId,
                configId,
                sizeId,
                styleId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductRecordIdByDimensionsInternal</Name>
				<Source><![CDATA[
    private static RecId getProductRecordIdByDimensionsInternal(Map productMap, str itemId, str dataAreaId, str colorId = '', str configId = '', str sizeId = '', str styleId = '', str versionId = '')
    {
        str key = RetailTransactionServiceInventory::constructProductKey(itemId, dataAreaId, colorId, configId, sizeId, styleId, versionId);

        if (productMap.exists(key))
        {
            return productMap.lookup(key);
        }

        if (colorId == '' && configId == '' && sizeId == '' && styleId == '' && versionId == '')
        {
            // non variant product. Use table InventTable.
            InventTable inventTable;
            select Product from inventTable
            where inventTable.ItemId == itemId && inventTable.DataAreaId == dataAreaId;

            if (inventTable)
            {
                productMap.insert(key, inventTable.Product);
                return inventTable.Product;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            // for variant product, search via InventDimCombination and InventDim table.
            InventDimCombination idcTable;
            InventDim inventDimTable;

            select DistinctProductVariant from idcTable
                where idcTable.ItemId == itemId
                && idcTable.DataAreaId == dataAreaId
            exists join inventDimTable
                where idcTable.InventDimId == inventDimTable.InventDimId
                && idcTable.DataAreaId == inventDimTable.DataAreaId
                && inventDimTable.ConfigId == configId
                && inventDimTable.InventColorId == colorId
                && inventDimTable.InventSizeId == sizeId
                && inventDimTable.InventStyleId == styleId
                && inventDimTable.InventVersionId == versionId;

            if (idcTable)
            {
                productMap.insert(key, idcTable.DistinctProductVariant);
                return idcTable.DistinctProductVariant;
            }
            else
            {
                return 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete a journal record from <c>InventJournalTable</c> and <c>InventJournalTrans</c> tables.
    /// </summary>
    /// <param name="_journalId">
    /// The journal ID of the journal record to be deleted.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the delete of record is successful and false otherwise.
    /// </returns>
    public static container deleteInventoryJournal(InventJournalId _journalId)
    {
        boolean             result = false;
        str                 error = "";
        InventJournalTable  inventJournal;
        InventJournalTrans  inventJournalTransaction;

        try
        {
            if (InventJournalTable::exist(_journalId))
            {
                delete_from inventJournal
                    where inventJournal.JournalId == _journalId;

                delete_from inventJournalTransaction
                    where inventJournalTransaction.JournalId == _journalId;

                result = true;
            }
            else
            {
                error = strFmt("@REX4520263", _journalId);
            }
        }
        catch(Exception::Error)
        {
            error = "@RET2382";
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryDeleteInventoryJournalError(axCallStack, "@RET2382");
        }

        return [result, error];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate XmlElement with InventDim properties for the given item.
    /// </summary>
    /// <param name="itemId">
    /// Item Id
    /// </param>
    /// <param name="inventDim">
    /// Inventory Dimension
    /// </param>
    /// <param name="xmlRecord">
    /// XmlElement to be populated
    /// </param>
    /// <param name="_languageId">
    /// Id of language in which to retrieve the dimension value name
    /// </param>
    /// <remarks>
    /// Populate XmlElement with InventDim properties for the given item.
    /// </remarks>
    public static void getInventDimValues(ItemId itemId, InventDim inventDim, XmlElement xmlRecord, LanguageId _languageId = SystemParameters::getSystemLanguageId())
    {
        EcoResColor                             ecoResColor;
        EcoResSize                              ecoResSize;
        EcoResStyle                             ecoResStyle;
        EcoResVersion                           ecoResVersion;
        EcoResConfiguration                     ecoResConfiguration;
        EcoResProductMasterColor                ecoResProductMasterColor;
        EcoResProductMasterSize                 ecoResProductMasterSize;
        EcoResProductMasterStyle                ecoResProductMasterStyle;
        EcoResProductMasterVersion              ecoResProductMasterVersion;
        EcoResProductMasterConfiguration        ecoResProductMasterConfiguration;
        EcoResProductMasterDimValueTranslation  productMasterDimValueTranslation;
        EcoResProductMaster                     ecoResProductMaster;
        InventTable                             inventTable;

        select RecId from ecoResProductMaster
            join inventTable
                where ecoResProductMaster.RecId == inventTable.Product
                && inventTable.ItemId == itemId;

        if (inventDim.InventColorId)
        {
            // Get color name
            select Name from productMasterDimValueTranslation
                where productMasterDimValueTranslation.LanguageId == _languageId
                    exists join ecoResProductMasterColor
                        where ecoResProductMasterColor.RecId == productMasterDimValueTranslation.ProductMasterDimensionValue
                        && ecoResProductMasterColor.ColorProductMaster == ecoResProductMaster.RecId
                            exists join ecoResColor
                                where ecoResProductMasterColor.Color == ecoResColor.RecId
                                && ecoResColor.Name == inventDim.InventColorId;

            xmlRecord.setAttribute('InventColorId', inventDim.InventColorId);
            xmlRecord.setAttribute('InventColorName', productMasterDimValueTranslation.Name);
        }

        if (inventDim.InventSizeId)
        {
            // Get size name
            select Name from productMasterDimValueTranslation
                where productMasterDimValueTranslation.LanguageId == _languageId
                    exists join ecoResProductMasterSize
                        where ecoResProductMasterSize.RecId == productMasterDimValueTranslation.ProductMasterDimensionValue
                        && ecoResProductMasterSize.SizeProductMaster == ecoResProductMaster.RecId
                            exists join ecoResSize
                                where ecoResProductMasterSize.Size == ecoResSize.RecId
                                && ecoResSize.Name == inventDim.InventSizeId;

            xmlRecord.setAttribute('InventSizeId', inventDim.InventSizeId);
            xmlRecord.setAttribute('InventSizeName', productMasterDimValueTranslation.Name);
        }

        if (inventDim.InventStyleId)
        {
            // Get style name (description)
            select Name from productMasterDimValueTranslation
                where productMasterDimValueTranslation.LanguageId == _languageId
                    exists join ecoResProductMasterStyle
                        where ecoResProductMasterStyle.RecId == productMasterDimValueTranslation.ProductMasterDimensionValue
                        && ecoResProductMasterStyle.StyleProductMaster == ecoResProductMaster.RecId
                            join RecId from ecoResStyle
                                where ecoResProductMasterStyle.Style == ecoResStyle.RecId
                                && ecoResStyle.Name == inventDim.InventStyleId;

            xmlRecord.setAttribute('InventStyleId', inventDim.InventStyleId);
            xmlRecord.setAttribute('InventStyleName', productMasterDimValueTranslation.Name);
        }

        if (inventDim.InventVersionId)
        {
            // Get version name (description)
            select Name from productMasterDimValueTranslation
                where productMasterDimValueTranslation.LanguageId == _languageId
                    exists join ecoResProductMasterVersion
                        where ecoResProductMasterVersion.RecId == productMasterDimValueTranslation.ProductMasterDimensionValue
                        && ecoResProductMasterVersion.ProductVersionProductMaster == ecoResProductMaster.RecId
                            exists join ecoResVersion
                                where ecoResProductMasterVersion.ProductVersion == ecoResVersion.RecId
                                && ecoResVersion.Name == inventDim.InventVersionId;

            xmlRecord.setAttribute('InventVersionId', inventDim.InventVersionId);
            xmlRecord.setAttribute('InventVersionName', productMasterDimValueTranslation.Name);
        }

        if (inventDim.ConfigId)
        {
            // Get config name (description)
            select Name from productMasterDimValueTranslation
                where productMasterDimValueTranslation.LanguageId == _languageId
                    exists join ecoResProductMasterConfiguration
                        where ecoResProductMasterConfiguration.RecId == productMasterDimValueTranslation.ProductMasterDimensionValue
                        && ecoResProductMasterConfiguration.ConfigProductMaster == ecoResProductMaster.RecId
                            exists join ecoResConfiguration
                                where ecoResProductMasterConfiguration.Configuration == ecoResConfiguration.RecId
                                && ecoResConfiguration.Name == inventDim.ConfigId;

            xmlRecord.setAttribute('ConfigId', inventDim.ConfigId);
            xmlRecord.setAttribute('ConfigName', productMasterDimValueTranslation.Name);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get an inventory journal object in XML format
    /// </summary>
    /// <param name="journalId">
    /// A journalID
    /// </param>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A container object with the details of a journal object in XML format
    /// </returns>
    /// <remarks>
    /// Get an inventory journal document in XML format
    /// </remarks>
    public static container getInventJournal(JournalId journalId, InventLocationId storeId)
    {
        #OCCRetryCount

        container inventjournalContainer = [false, "", ""]; // Status, ErrorMsg, XmlResultSet

        InventJournalTable      ijTable;
        InventJournalTrans      ijLine;
        InventDim               inventDim;
        InventTable             inventTable;
        InventDim               inventDimBlank;
        InventItemBarcode       inventItemBarcode;
        EcoResProductTranslation productTranslation;
        HcmWorker               hcmWorker;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;
        RecId                   lastRecId = 0;

        LanguageId languageId = CompanyInfo::languageId();

        try
        {
            ttsbegin;

            xmlDoc = XmlDocument::newBlank();

            select firstOnly1 RecId, JournalId, Worker, Description, InventLocationId, DataAreaId from ijTable
                where (ijTable.JournalId == journalId)
                    && (ijTable.Posted == NoYes::No)
                    && (ijTable.IsRetailCommitted == NoYes::No)
                    && (ijTable.SystemBlocked == NoYes::No)
                outer join PersonnelNumber from hcmWorker
                    where ijTable.Worker == hcmWorker.RecId;

            if (ijTable)
            {
                Map productMap = new Map(Types::String, Types::Int64);
                inventDimBlank = InventDim::findOrCreateBlank();
                xmlRoot = xmlDoc.createElement(tableStr(InventJournalTable));

                xmlRoot.setAttribute(fieldStr(InventJournalTable, JournalId), journalId);
                xmlRoot.setAttribute(fieldStr(InventJournalTable, RecId), int642str(ijTable.RecId));
                xmlRoot.setAttribute(fieldStr(InventJournalTable, InventLocationId), ijTable.InventLocationId);
                xmlRoot.setAttribute(fieldStr(InventJournalTable, Description), ijTable.Description);
                xmlRoot.setAttribute(fieldStr(InventJournalTable, DataAreaId), ijTable.DataAreaId);
                xmlRoot.setAttribute(fieldStr(HcmWorker, PersonnelNumber), hcmWorker.PersonnelNumber);

                while select RecId, ItemId, InventDimId, Counted, Worker, DataAreaId from ijLine
                    order by ijLine.RecId
                        where ijLine.JournalId == journalId
                    join inventDim where inventDim.InventDimId == ijLine.InventDimId &&
                        (inventDim.InventLocationId == storeId || (inventDim.InventLocationId == '' && ijTable.InventLocationId == storeId))
                    join ItemId, Product from inventTable where inventTable.ItemId == ijLine.ItemId
                    outer join PersonnelNumber from hcmWorker where ijLine.Worker == hcmWorker.RecId
                    outer join ItemBarCode from inventItemBarcode where inventItemBarcode.ItemId == ijLine.ItemId
                           && (inventItemBarcode.InventDimId == ijLine.InventDimId || inventItemBarcode.InventDimId == inventDimBlank.InventDimId)
                    outer join Name, Product, LanguageId from productTranslation
                        where productTranslation.Product == inventTable.Product
                            && productTranslation.LanguageId == languageId
                {
                    if (ijLine.RecId == lastRecId)
                    {
                        continue;
                    }
                    else
                    {
                        lastRecId = ijLine.RecId;
                    }

                    xmlRecord = xmlDoc.createElement(tableStr(InventJournalTrans));

                    xmlRecord.setAttribute(fieldStr(InventJournalTrans, RecId), int642str(ijLine.RecId));
                    xmlRecord.setAttribute(fieldStr(InventJournalTrans, ItemId), ijLine.ItemId);
                    xmlRecord.setAttribute(extendedTypeStr(EcoResProductName), productTranslation.Name);
                    xmlRecord.setAttribute(fieldStr(InventItemBarcode, ItemBarCode), inventItemBarcode.ItemBarCode);
                    xmlRecord.setAttribute(fieldStr(InventJournalTrans, InventDimId), ijLine.InventDimId);
                    xmlRecord.setAttribute(fieldStr(InventJournalTrans, Counted), num2str(ijLine.Counted, 0, 2, 1, 0));
                    xmlRecord.setAttribute(fieldStr(HcmWorker, PersonnelNumber), hcmWorker.PersonnelNumber);
                    xmlRecord.setAttribute(fieldStr(InventJournalTable, InventLocationId), storeId);
                    xmlRecord.setAttribute(fieldStr(InventJournalTrans, DataAreaId), ijLine.DataAreaId);

                    RecId productRecId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(
                        productMap, ijLine.ItemId, ijLine.DataAreaId, inventDim.InventColorId, inventDim.ConfigId,
                        inventDim.InventSizeId, inventDim.InventStyleId, inventDim.InventVersionId);

                    if (productRecId != 0)
                    {
                        xmlRecord.setAttribute(RetailTransactionServiceInventory::ProductRecordIdAttributeName, int642Str(productRecId));
                    }

                    xmlRecord.setAttribute(fieldStr(InventDim, InventBatchId), inventDim.InventBatchId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsLocationId), inventDim.wmsLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsPalletId), inventDim.wmsPalletId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSiteId), inventDim.InventSiteId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventLocationId), inventDim.InventLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, ConfigId), inventDim.ConfigId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSizeId), inventDim.InventSizeId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventColorId), inventDim.InventColorId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStyleId), inventDim.InventStyleId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventVersionId), inventDim.InventVersionId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), inventDim.InventSerialId);

                    xmlRecord.setAttribute(RetailTransactionServiceInventory::GuidStr, guid2str(newGuid()));
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::FalseStr);
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, '');

                    xmlRoot.appendChild(xmlRecord);
                }

                xmlDoc.appendChild(xmlRoot);

                inventjournalContainer = [true, "", xmlDoc.toString()];
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            inventjournalContainer = [false, "@RET2382"];
            ttsabort;
        }
        catch
        {
            inventjournalContainer = [false, "@RET2382"];
            ttsabort;
        }

        return inventjournalContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of inventory journals for stock counting
    /// </summary>
    /// <param name="storeId">
    /// A storeId
    /// </param>
    /// <returns>
    /// A list of inventory journals for stock counting
    /// </returns>
    public static container getInventJournals(InventLocationId storeId)
    {
        #OCCRetryCount

        container openInventJournals = [false, "", ""]; // Status, ErrorMsg, XmlResultSet
        InventJournalTable      ijTable;
        InventJournalTrans      ijTrans;
        InventDim               inventDim;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;
        HcmWorker               hcmWorker;
        str                     workerId = "";
        Map                     workerMap = new Map(Types::Record, Types::String);

        #define.InventJournalTables('InventJournalTables')

        void addXmlRecord(InventJournalTable inventJournalTable, HcmWorker workerTable, XmlDocument xmlDocument, XmlElement root)
        {
            xmlRecord = xmlDocument.createElement(tableStr(InventJournalTable));

            xmlRecord.setAttribute(fieldStr(InventJournalTable, RecId), int642str(inventJournalTable.RecId));
            xmlRecord.setAttribute(fieldStr(InventJournalTable, JournalId), inventJournalTable.JournalId);
            xmlRecord.setAttribute(fieldStr(InventJournalTable, Description), inventJournalTable.Description);
            xmlRecord.setAttribute(fieldStr(InventJournalTable, Source), inventJournalTable.Source);
            xmlRecord.setAttribute(fieldStr(InventJournalTable, InventLocationId), inventJournalTable.InventLocationId);
            xmlRecord.setAttribute(fieldStr(InventJournalTable, DataAreaId), inventJournalTable.DataAreaId);
            xmlRecord.setAttribute(fieldStr(HcmWorker, PersonnelNumber), workerTable.PersonnelNumber);
            root.appendChild(xmlRecord);
        }
        ;

        ttsbegin;

        try
        {
            xmlDoc = XmlDocument::newBlank();
            xmlRoot = xmlDoc.createElement(#InventJournalTables);

            // find Record in InventJournalTable that matches StoreId
            while select RecId, JournalId, Description, Worker, Source, InventLocationId, DataAreaId from ijTable
                where (ijTable.JournalType == InventJournalType::Count)
                    && (ijTable.InventLocationId == storeId)
                    && (ijTable.IsRetailCommitted == NoYes::No)
                    && (ijTable.Posted == NoYes::No)
                outer join PersonnelNumber from hcmWorker
                where ijTable.Worker == hcmWorker.RecId
            {
                addXmlRecord(ijTable, hcmWorker, xmlDoc, xmlRoot);
            }

            // find Record in InventJournalTable that does not match StoreId
            // but has StoreId matches with any of the product lines's StoreId.
            while select RecId, JournalId, Description, Worker, Source, InventLocationId, DataAreaId from ijTable
                where (ijTable.JournalType == InventJournalType::Count)
                    && (ijTable.InventLocationId != storeId)
                    && (ijTable.IsRetailCommitted == NoYes::No)
                    && (ijTable.Posted == NoYes::No)
                outer join PersonnelNumber from hcmWorker
                where ijTable.Worker == hcmWorker.RecId
                exists join InventDimId from ijTrans where ijTrans.JournalId == ijTable.JournalId
                join inventDim where inventDim.InventDimId == ijTrans.InventDimId && inventDim.InventLocationId == storeId
            {
                addXmlRecord(ijTable, hcmWorker, xmlDoc, xmlRoot);
            }

            xmlDoc.appendChild(xmlRoot);

            openInventJournals = [true, "", xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            openInventJournals = [false, "@RET2382"];
            ttsabort;
        }
        catch
        {
            openInventJournals = [false, "@RET2382"];
            ttsabort;
        }

        return openInventJournals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenPurchaseOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of open purchase orders for a location
    /// </summary>
    /// <param name="locationId">
    /// A locationId
    /// </param>
    /// <returns>
    /// A list of purchase orders in XML format in a container object
    /// </returns>
    public static container getOpenPurchaseOrders(InventLocationId locationId)
    {
        #OCCRetryCount

        container openPurchaseOrders = [false, "", ""]; // Status, ErrorMsg, XmlResultSet
        PurchTable              poTable;
        PurchLine               poLine;
        InventDim               inventDim;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        #define.PurchaseTables('PurchTables')

        void addXmlRecord(PurchTable purchTable, PurchLine purchLine, XmlDocument xmlDocument, XmlElement root)
        {
            xmlRecord = xmlDocument.createElement(tableStr(PurchTable));

            xmlRecord.setAttribute(fieldStr(PurchTable, RecId), int642str(purchTable.RecId));
            xmlRecord.setAttribute(fieldStr(PurchTable, PurchId), purchTable.PurchId);
            xmlRecord.setAttribute(fieldStr(PurchTable, PurchName), purchTable.PurchName);
            xmlRecord.setAttribute(fieldStr(PurchTable, PurchStatus), queryValue(purchTable.PurchStatus));
            xmlRecord.setAttribute(fieldStr(PurchTable, DeliveryDate),
                date2str(purchTable.DeliveryDate,
                    DateFormatCode,
                    DateDay::Digits2,
                    DateSeparator::Hyphen, // separator1
                    DateMonth::Digits2,
                    DateSeparator::Hyphen, // separator2
                    DateYear::Digits4,
                    DateFlags::None));
            xmlRecord.setAttribute('TOTALORDERED',num2str(PurchLine.PurchQty,0,10,1,0));
            xmlRecord.setAttribute('TOTALRECEIVED',num2str(PurchLine.PurchReceivedNow,0,10,1,0));
            xmlRecord.setAttribute('LINES',int642str(PurchLine.RecId));

            root.appendChild(xmlRecord);
        }
        ;
        ttsbegin;

        try
        {
            xmlDoc = XmlDocument::newBlank();

            xmlRoot = xmlDoc.createElement(#PurchaseTables);

            // Get purchase orders where the header Location is a match
            while select RecId, PurchId, PurchName, PurchStatus, DeliveryDate from poTable
                JOIN
                SUM(PURCHQTY), SUM(PURCHRECEIVEDNOW),count(RecId) from poLine
                    group by poTable.RecId, poTable.PurchId, poTable.PurchName, poTable.PurchStatus, poTable.DeliveryDate
                where (poTable.PurchaseType == PurchaseType::Purch)
                    && (poTable.PurchStatus != PurchStatus::Invoiced)
                    && (poTable.PurchStatus != PurchStatus::Received)
                    && (poTable.PurchStatus != PurchStatus::Canceled)
                    && (poTable.DocumentState == VersioningDocumentState::Confirmed)
                    && (poTable.InventLocationId == locationId)
                    && (poLine.PurchId == poTable.PurchId)
            {
                addXmlRecord(poTable, poLine, xmlDoc, xmlRoot);
            }

            // Get purchase orders where the location on one or more lines is a match
            while select RecId, PurchId, PurchName, PurchStatus, DeliveryDate from poTable
                where (poTable.PurchaseType == PurchaseType::Purch)
                    && (poTable.PurchStatus != PurchStatus::Invoiced)
                    && (poTable.PurchStatus != PurchStatus::Received)
                    && (poTable.PurchStatus != PurchStatus::Canceled)
                    && (poTable.DocumentState == VersioningDocumentState::Confirmed)
                    && (poTable.InventLocationId != locationId)
                join sum(PurchQty), sum(PurchReceivedNow), count(RecId) from poLine
                    where poLine.PurchId == poTable.PurchId
                join inventDim
                    group by poTable.RecId, poTable.PurchId, poTable.PurchName, poTable.PurchStatus, poTable.DeliveryDate
                where inventDim.InventDimId == poLine.InventDimId && inventDim.InventLocationId == locationId
            {
                addXmlRecord(poTable, poLine, xmlDoc, xmlRoot);
            }

            xmlDoc.appendChild(xmlRoot);

            openPurchaseOrders = [true, "", xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            openPurchaseOrders = [false, "@RET2382", ""];
            ttsabort;
        }
        catch
        {
            openPurchaseOrders = [false, "@RET2382", ""];
            ttsabort;
        }

        return openPurchaseOrders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenTransferOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a list of open transfer orders for a store
    /// </summary>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A list of open transfer orders for a store
    /// </returns>
    /// <remarks>
    /// This is to get open transfer orders
    /// </remarks>
    public static container getOpenTransferOrders(InventLocationId inventLocationId)
    {
        #OCCRetryCount

        container openTransferOrders = [false, "", ""]; // Status, ErrorMsg, XmlResultSet
        InventTransferTable     transferTable;
        InventTransferLine      transferLines;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        #define.InventTransferTables('InventTransferTables')

        ttsbegin;

        try
        {
            xmlDoc = XmlDocument::newBlank();

            xmlRoot = xmlDoc.createElement(#InventTransferTables);

            while select RecId, TransferId, InventLocationIdFrom, InventLocationIdTo, TransferStatus, ShipDate, DlvModeId, ReceiveDate from transferTable
               where ((transferTable.InventLocationIdTo == inventLocationId)
                    || (transferTable.InventLocationIdFrom == inventLocationId))
                    && (transferTable.TransferStatus != InventTransferStatus::Received)
            {
                xmlRecord = xmlDoc.createElement(tableStr(InventTransferTable));

                xmlRecord.setAttribute(fieldStr(InventTransferTable, RecId), int642str(transferTable.RecId));
                xmlRecord.setAttribute(fieldStr(InventTransferTable, TransferId), transferTable.TransferId);
                xmlRecord.setAttribute(fieldStr(InventTransferTable, InventLocationIdFrom), transferTable.InventLocationIdFrom);
                xmlRecord.setAttribute(fieldStr(InventTransferTable, InventLocationIdTo), transferTable.InventLocationIdTo);
                xmlRecord.setAttribute(fieldStr(InventTransferTable, TransferStatus), enum2str(transferTable.TransferStatus));
                xmlRecord.setAttribute(fieldStr(InventTransferTable, DlvModeId), transferTable.DlvModeId);
                xmlRecord.setAttribute(fieldStr(InventTransferTable, ShipDate),
                    date2str(transferTable.ShipDate,
                        DateFormatCode,
                        DateDay::Digits2,
                        DateSeparator::Hyphen, // separator1
                        DateMonth::Digits2,
                        DateSeparator::Hyphen, // separator2
                        DateYear::Digits4,
                        DateFlags::None));
                xmlRecord.setAttribute(fieldStr(InventTransferTable, ReceiveDate),
                    date2str(transferTable.ReceiveDate,
                        DateFormatCode,
                        DateDay::Digits2,
                        DateSeparator::Hyphen, // separator1
                        DateMonth::Digits2,
                        DateSeparator::Hyphen, // separator2
                        DateYear::Digits4,
                        DateFlags::None));

                select SUM(QTYTRANSFER), SUM(QTYSHIPPED), SUM(QTYRECEIVED), SUM(QTYSHIPNOW), SUM(QTYRECEIVENOW), SUM(QTYREMAINSHIP), SUM(QTYREMAINRECEIVE), count(RecId)
                    from transferLines
                    group by transferLines.TransferId where transferLines.TransferId == transferTable.TransferId;

                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyTransfer),num2str(transferLines.QtyTransfer,0,10,1,0));
                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyShipped),num2str(transferLines.QtyShipped,0,10,1,0));
                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyReceived),num2str(transferLines.QtyReceived,0,10,1,0));
                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyShipNow),num2str(transferLines.QtyShipNow,0,10,1,0));
                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyReceiveNow),num2str(transferLines.QtyReceiveNow,0,10,1,0));
                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyRemainShip),num2str(transferLines.QtyRemainShip,0,10,1,0));
                xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyRemainReceive),num2str(transferLines.QtyRemainReceive,0,10,1,0));
                xmlRecord.setAttribute('LINES', int642str(transferLines.RecId));
                if (transferLines.RecId == 0)
                {
                    // Set to "Draft" until order lines are committed to AX.
                    // Be careful that this hardcoded value cannot be translated as POS has dependence on it.
                    xmlRecord.setAttribute(fieldStr(InventTransferTable, TransferStatus), 'Draft');
                }
                xmlRoot.appendChild(xmlRecord);
            }

            xmlDoc.appendChild(xmlRoot);

            openTransferOrders = [true, "", xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            openTransferOrders = [false, "@RET2382"];
            ttsabort;
        }
        catch
        {
            openTransferOrders = [false, "@RET2382"];
            ttsabort;
        }

        return openTransferOrders;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInboundOutboundDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a specific inventory document by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>An inventory inbound/outbound document.</returns>
    public static container getInventoryInboundOutboundDocument(str _searchCriteriaJson)
    {
        var searchCriteria = RetailTransactionServiceInventory::getSpecificInventoryDocumentSearchCriteriaFromJson(_searchCriteriaJson);
        if (!searchCriteria)
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentSearchCriteria", ''];
        }

        str documentId = searchCriteria.DocumentId;
        RetailInventoryDocumentType documentType = searchCriteria.DocumentType;
        InventLocationId inventLocationId = searchCriteria.InventoryLocationId;

        if (!documentId || !documentType || !inventLocationId)
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentSearchCriteria", ''];
        }

        Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument sourceDocument;
        if (documentType == RetailInventoryDocumentType::TransferOrder)
        {
            sourceDocument = RetailTransactionServiceInventory::getTransferOrderInventoryDocument(documentId);
        }
        else if (documentType == RetailInventoryDocumentType::InventoryAdjustment)
        {
            sourceDocument = RetailTransactionServiceInventory::getJournalInventoryDocument(documentId);
        }
        else if (documentType == RetailInventoryDocumentType::InventoryTransfer)
        {
            sourceDocument = RetailTransactionServiceInventory::getJournalInventoryDocument(documentId);
        }
        else if (documentType == RetailInventoryDocumentType::StockCounting)
        {
            sourceDocument = RetailTransactionServiceInventory::getJournalInventoryDocument(documentId);
        }
        else
        {
            sourceDocument = RetailTransactionServiceInventory::getPurchaseOrderInventoryDocument(documentId, inventLocationId);
        }

        if (!sourceDocument)
        {
            eventSource.EventWriteInventoryDocumentNotFoundOrIsEmpty();
            return [false, "@Retail:RetailInventoryDocumentNotFoundOrIsEmpty", ''];
        }

        // Serialize results.
        System.Type[] typeArray = new System.Type[1]();
        System.Type sourceDocumentType = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument().GetType();
        typeArray.SetValue(sourceDocumentType, 0);
        str result;

        try
        {
            result = RetailTransactionServiceJsonHelper::SerializeToJson(sourceDocument, typeArray);
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsSerializationFailed();
            return [false, "@Retail:RetailInventoryDocumentSerializationFaliure", ''];
        }

        return [true, '', result];

    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryOutboundDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of outbound inventory documents by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>A list of outbound inventory documents.</returns>
    public static container getInventoryOutboundDocuments(str _searchCriteriaJson)
    {
        var searchCriteria = RetailTransactionServiceInventory::getInventoryDocumentSearchCriteriaFromJson(_searchCriteriaJson);
        if (!searchCriteria)
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentSearchCriteria", ''];
        }

        RetailInventoryDocumentStateSearchCriteria documentStateSearchCriteria = searchCriteria.DocumentState;
        if (documentStateSearchCriteria == RetailInventoryDocumentStateSearchCriteria::Active)
        {
            return RetailTransactionServiceInventory::getActiveInventoryOutboundDocuments(searchCriteria);
        }
        else if (documentStateSearchCriteria == RetailInventoryDocumentStateSearchCriteria::Complete)
        {
            return RetailTransactionServiceInventory::getCompleteInventoryOutboundDocuments(searchCriteria);
        }
        else
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentSearchCriteria", ''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInboundDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of inbound inventory documents by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>A list of inbound inventory documents.</returns>
    public static container getInventoryInboundDocuments(str _searchCriteriaJson)
    {
        var searchCriteria = RetailTransactionServiceInventory::getInventoryDocumentSearchCriteriaFromJson(_searchCriteriaJson);
        if (!searchCriteria)
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentSearchCriteria", ''];
        }

        RetailInventoryDocumentStateSearchCriteria documentStateSearchCriteria = searchCriteria.DocumentState;
        if (documentStateSearchCriteria == RetailInventoryDocumentStateSearchCriteria::Active)
        {
            return RetailTransactionServiceInventory::getActiveInventoryInboundDocuments(searchCriteria);
        }
        else if (documentStateSearchCriteria == RetailInventoryDocumentStateSearchCriteria::Complete)
        {
            return RetailTransactionServiceInventory::getCompleteInventoryInboundDocuments(searchCriteria);
        }
        else
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentSearchCriteria", ''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInboundOutboundDocumentLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a list of inbound inventory document lines by the given search criteria.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in json format.</param>
    /// <returns>A list of inbound inventory document lines.</returns>
    public static container getInventoryInboundOutboundDocumentLines(str _searchCriteriaJson)
    {
        var searchCriteria = RetailTransactionServiceInventory::getInventoryDocumentLineSearchCriteriaFromJson(_searchCriteriaJson);
        
        if (!searchCriteria)
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentLineSearchCriteria", ''];
        }

        str documentId = searchCriteria.DocumentId;
        RetailInventoryDocumentType documentType = searchCriteria.SourceDocumentType;
        if (!documentId || !documentType)
        {
            return [false, "@Retail:RetailInvalidInventoryDocumentLineSearchCriteria", ''];
        }

        System.Collections.ArrayList documentLines;
        if (documentType == RetailInventoryDocumentType::TransferOrder)
        {
            documentLines = RetailTransactionServiceInventory::getTransferOrderInventoryDocumentLines(documentId);
        }
        else if (documentType == RetailInventoryDocumentType::InventoryAdjustment)
        {
            documentLines = RetailTransactionServiceInventory::getJournalInventoryDocumentLines(documentId);
        }
        else if (documentType == RetailInventoryDocumentType::InventoryTransfer)
        {
            documentLines = RetailTransactionServiceInventory::getJournalInventoryDocumentLines(documentId);
        }
        else if (documentType == RetailInventoryDocumentType::StockCounting)
        {
            documentLines = RetailTransactionServiceInventory::getJournalInventoryDocumentLines(documentId);
        }
        else
        {
            documentLines = RetailTransactionServiceInventory::getPurchaseOrderInventoryDocumentLines(documentId);
        }

        // Serialize results.
        System.Type[] typeArray = new System.Type[1]();
        System.Type sourceDocumentType = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine().GetType();
        typeArray.SetValue(sourceDocumentType, 0);
        str results;

        try
        {
            results = RetailTransactionServiceJsonHelper::SerializeToJson(documentLines, typeArray);
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentLinesSerializationFailed();
            return [false, "@Retail:RetailInventoryDocumentLineSerializationFaliure", ''];
        }

        return [true, '', results];

    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a purchase order
    /// </summary>
    /// <param name="purchId">
    /// A purchId
    /// </param>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a purchase order in XML format
    /// </returns>
    /// <remarks>
    /// This is get an open purchase order
    /// </remarks>
    public static container getPurchaseOrder(PurchId purchId, InventLocationId inventLocationId = '')
    {
        #OCCRetryCount

        container purchaseOrder = [false, "", ""]; // Status, ErrorMsg, XmlResultSet

        PurchTable              poTable;
        PurchLine               poLine;
        InventDim               inventDim;
        InventTable             inventTable;
        EcoResProductTranslation productTranslation;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;

        LanguageId languageId = CompanyInfo::languageId();

        ttsbegin;

        try
        {
            xmlDoc = XmlDocument::newBlank();

            select firstonly1 PurchId, RecId, InventLocationId from poTable where poTable.PurchId == purchId
                && (poTable.PurchStatus != PurchStatus::Received
                    || poTable.PurchStatus != PurchStatus::Canceled);
            
            if (poTable)
            {
                Map productMap = new Map(Types::String, Types::Int64);
                xmlRoot = xmlDoc.createElement(tableStr(PurchTable));

                xmlRoot.setAttribute(fieldStr(PurchTable, PurchId), purchId);
                xmlRoot.setAttribute(fieldStr(PurchTable, RecId), int642str(poTable.RecId));

                while select RecId, ItemId, InventDimId, InventTransId, BarCode, QtyOrdered, PurchQty, PurchUnit, PurchReceivedNow, DataAreaId from poLine
                    where poLine.PurchId == purchId && poLine.IsDeleted == NoYes::No && poLine.Complete == NoYes::No
                    join inventDim
                        where inventDim.InventDimId == poLine.InventDimId && (inventDim.InventLocationId == inventLocationId || (poTable.InventLocationId == inventLocationId && inventDim.InventLocationId == ''))
                    join ItemId, Product from inventTable where inventTable.ItemId == poLine.ItemId
                    outer join Name, Product, LanguageId from productTranslation
                        where productTranslation.Product == inventTable.Product
                            && productTranslation.LanguageId == languageId
                {
                    xmlRecord = xmlDoc.createElement(tableStr(PurchLine));

                    int numberOfDecimals = DefaultNumberOfDecimals;
                    UnitOfMeasure unitOfMeasure = UnitOfMeasure::findBySymbol(poLine.PurchUnit);
                    if (unitOfMeasure.RecId)
                    {
                        numberOfDecimals = unitOfMeasure.DecimalPrecision;
                    }

                    xmlRecord.setAttribute(fieldStr(PurchLine, RecId), int642str(poLine.RecId));
                    xmlRecord.setAttribute(fieldStr(PurchLine, ItemId), poLine.ItemId);
                    xmlRecord.setAttribute(extendedTypeStr(EcoResProductName), productTranslation.Name);
                    xmlRecord.setAttribute(fieldStr(PurchLine, InventDimId), poLine.InventDimId);
                    xmlRecord.setAttribute(fieldStr(PurchLine, BarCode), poLine.BarCode);
                    xmlRecord.setAttribute(fieldStr(PurchLine, QtyOrdered), num2str(poLine.PurchQty, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(PurchLine, PurchQty), num2str(poLine.PurchQty, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(PurchLine, PurchUnit), poLine.PurchUnit);

                    xmlRecord.setAttribute(fieldStr(PurchLine, PurchReceivedNow), num2str(poLine.PurchReceivedNow, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute('ReceivedInTotal', num2str(poLine.receivedInTotal(), 0, numberOfDecimals, 1, 0));

                    RecId productRecId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(
                        productMap, poLine.ItemId, poLine.DataAreaId, inventDim.InventColorId, inventDim.ConfigId,
                        inventDim.InventSizeId, inventDim.InventStyleId, inventDim.InventVersionId);

                    if (productRecId != 0)
                    {
                        xmlRecord.setAttribute(RetailTransactionServiceInventory::ProductRecordIdAttributeName, int642Str(productRecId));
                    }

                    xmlRecord.setAttribute(fieldStr(InventDim, InventBatchId), inventDim.InventBatchId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsLocationId), inventDim.wmsLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, LicensePlateId), inventDim.LicensePlateId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStatusId), inventDim.InventStatusId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsPalletId), inventDim.wmsPalletId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSiteId), inventDim.InventSiteId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventLocationId), inventDim.InventLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, ConfigId), inventDim.ConfigId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSizeId), inventDim.InventSizeId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventColorId), inventDim.InventColorId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStyleId), inventDim.InventStyleId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventVersionId), inventDim.InventVersionId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), inventDim.InventSerialId);
                    xmlRecord.setAttribute(fieldStr(PurchLine, DataAreaId), poLine.DataAreaId);

                    xmlRecord.setAttribute(RetailTransactionServiceInventory::GuidStr, guid2str(newGuid()));
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::FalseStr);
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, '');

                    xmlRoot.appendChild(xmlRecord);
                }

                xmlDoc.appendChild(xmlRoot);
            }

            purchaseOrder = [true, "", xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            purchaseOrder = [false, "@RET2382"];
            ttsabort;
        }
        catch
        {
            purchaseOrder = [false, "@RET2382"];
            ttsabort;
        }

        return purchaseOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnLocationByInfocode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds return policy and new location for print labels
    /// </summary>
    /// <param name="_returnLocationPrintParameterXmlStr">
    /// XML string of serialized  LSRetailPosis.BusinessLogic.ReturnLocationPrintParameter object
    /// </param>
    /// <returns>
    /// Container with "Status", "ErrorMsg", "print return label" flag, "return warehouse text", "return location text", "retutn pallete text"
    /// </returns>
    public static container getReturnLocationByInfocode(str _returnLocationPrintParameterXmlStr)
    {
        InventDim                               inventDim;
        RetailStoreId                           storeId;
        ItemId                                  itemId;
        RetailInfocodeId                        infocodeId;
        RetailInformationSubcodeId              subcodeId;
        XmlDocument                             xmlDocument;
        XmlElement                              documentElement,
                                                xmlElement,
                                                xmlElementSubcodeId,
                                                xmlElementInfocodeId;
        RetailReturnPolicyHelper_SalesTransTmp  helper;
        int                                     fromLine;

        try
        {
            fromLine = Global::infologLine();

            xmlDocument = new XmlDocument();
            xmlDocument.loadXml(_returnLocationPrintParameterXmlStr);
            documentElement = xmlDocument.documentElement();

            if (documentElement)
            {
                xmlElement  = documentElement.getNamedElement('StoreId');
                storeId     = xmlElement.text();

                xmlElement  = documentElement.getNamedElement('ItemId');
                itemId      = xmlElement.text();

                xmlElement              = documentElement.getNamedElement('Codes');
                xmlElementInfocodeId    = xmlElement.getNamedElement('InfocodeId');
                xmlElementSubcodeId     = xmlElement.getNamedElement('SubcodeId');

                if (xmlElementInfocodeId && xmlElementSubcodeId)
                {
                    infocodeId  = xmlElementInfocodeId.text();
                    subcodeId   = xmlElementSubcodeId.text();

                    helper = RetailReturnPolicyHelper_SalesTransTmp::construct(RetailStoreTable::find(storeId).RecId, itemId, '', '', null);

                    if (helper.policyPrintLabels())
                    {
                        helper.initRetailReturnPolicyLine(infocodeId, subcodeId);

                        inventDim = inventDim::find(helper.getMergedInventDimId('', true));

                        if (inventDim.InventLocationId)
                        {
                            return [true, '', true, inventDim.InventLocationId, inventDim.WMSLocationId, inventDim.WMSPalletId]; //"Status", "ErrorMsg", "print return label" flag, "return warehouse text", "return location text", "return pallete text"
                        }
                    }
                }

                return [true, '', false, '', '', ''];
            }

            return [false, '', false, '', ''];
        }
        catch(Exception::Error)
        {
            return [false, RetailTransactionServiceUtilities::getInfologMessages(fromLine), false, '', ''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReturnLocationByReasonCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds return policy and new location for print labels
    /// </summary>
    /// <param name="_storeId">
    /// Transaction store id
    /// </param>
    /// <param name="_itemId">
    /// Product id
    /// </param>
    /// <param name="_reasonCodeId">
    /// Return reason code id
    /// </param>
    /// <returns>
    /// Container with "Status", "ErrorMsg", "print return label" flag, "return warehouse text", "return location text", "return pallete text"
    /// </returns>
    public static container getReturnLocationByReasonCode(RetailStoreId _storeId, ItemId _itemId, ReturnReasonCodeId _reasonCodeId)
    {
        InventDim                           inventDim;
        RetailReturnPolicyHelper_SalesLine  helper;
        int                                 fromLine;

        try
        {
            fromLine = Global::infologLine();

            helper = RetailReturnPolicyHelper_SalesLine::construct(RetailStoreTable::find(_storeId).RecId, _itemId, _reasonCodeId, null);

            if (helper.policyPrintLabels())
            {
                inventDim = InventDim::find(helper.getMergedInventDimId('', true));

                if (inventDim.InventLocationId)
                {
                    return [true, '', true, inventDim.InventLocationId, inventDim.WMSLocationId, inventDim.WMSPalletId]; //"Status", "ErrorMsg", "print return label" flag, "return warehouse text", "return location text", "return pallete text"
                }
            }

            return [true, '', false, '', '', ''];
        }
        catch(Exception::Error)
        {
            return [false, RetailTransactionServiceUtilities::getInfologMessages(fromLine), false, '', ''];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the details of a transfer order
    /// </summary>
    /// <param name="transferId">
    /// A transferId
    /// </param>
    /// <param name="inventLocationId">
    /// A inventLocationId
    /// </param>
    /// <returns>
    /// A container object containing the details of a transfer order
    /// </returns>
    /// <remarks>
    /// This is to get an open transfer order
    /// </remarks>
    public static container getTransferOrder(InventTransferId transferId, InventLocationId inventLocationId = '')
    {
        #OCCRetryCount

        container transferOrderContainer = [false, "", ""]; // Status, ErrorMsg, XmlResultSet

        InventTransferTable     transferTable;
        InventTransferLine      transferLine, transferLines;
        InventDim               inventDim, inventDimBlank;
        InventItemBarcode       inventItemBarcode;
        InventTable             inventTable;
        EcoResProductTranslation productTranslation;
        Counter                 pCounter = 0;
        XmlDocument             xmlDoc;
        XmlElement              xmlRoot;
        XmlElement              xmlRecord;
        RecId                   lastRecId = 0;

        LanguageId languageId = CompanyInfo::languageId();

        ttsbegin;

        try
        {
            xmlDoc = XmlDocument::newBlank();

            // header query
            select firstonly RecId, TransferId, InventLocationIdFrom, InventLocationIdTo, TransferStatus, ShipDate, DlvModeId from transferTable
            where
                transferTable.TransferId == transferId
                && (transferTable.InventLocationIdFrom == inventLocationId || transferTable.InventLocationIdTo == inventLocationId || inventLocationId == '');

            if (transferTable)
            {
                Map productMap = new Map(Types::String, Types::Int64);

                // aggregation query
                select SUM(QTYTRANSFER), SUM(QTYSHIPPED), SUM(QTYRECEIVED), SUM(QTYSHIPNOW), SUM(QTYRECEIVENOW), SUM(QTYREMAINSHIP), SUM(QTYREMAINRECEIVE), count(RecId) from transferLines
                where transferLines.TransferId == transferId;

                inventDimBlank = InventDim::findOrCreateBlank();
                xmlRoot = xmlDoc.createElement(tableStr(InventTransferTable));

                xmlRoot.setAttribute(fieldStr(InventTransferTable, TransferId), transferId);
                xmlRoot.setAttribute(fieldStr(InventTransferTable, TransferStatus), queryValue(transferTable.TransferStatus));
                xmlRoot.setAttribute(fieldStr(InventTransferTable, RecId), int642str(transferTable.RecId));
                xmlRoot.setAttribute(fieldStr(InventTransferTable, InventLocationIdFrom), transferTable.InventLocationIdFrom);
                xmlRoot.setAttribute(fieldStr(InventTransferTable, InventLocationIdTo), transferTable.InventLocationIdTo);
                xmlRoot.setAttribute(fieldStr(InventTransferTable, DlvModeId), transferTable.DlvModeId);
                xmlRoot.setAttribute(fieldStr(InventTransferTable, ShipDate),
                    date2Str(transferTable.ShipDate,
                        DateFormatCode,
                        DateDay::Digits2,
                        DateSeparator::Hyphen,
                        DateMonth::Digits2,
                        DateSeparator::Hyphen,
                        DateYear::Digits4,
                        DateFlags::None));
                xmlRoot.setAttribute(fieldStr(InventTransferTable, ReceiveDate),
                    date2Str(transferTable.ReceiveDate,
                        DateFormatCode,
                        DateDay::Digits2,
                        DateSeparator::Hyphen,
                        DateMonth::Digits2,
                        DateSeparator::Hyphen,
                        DateYear::Digits4,
                        DateFlags::None));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyTransfer),num2str(transferLines.QtyTransfer,0,10,1,0));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyShipped),num2str(transferLines.QtyShipped,0,10,1,0));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyReceived),num2str(transferLines.QtyReceived,0,10,1,0));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyShipNow),num2str(transferLines.QtyShipNow,0,10,1,0));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyReceiveNow),num2str(transferLines.QtyReceiveNow,0,10,1,0));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyRemainShip),num2str(transferLines.QtyRemainShip,0,10,1,0));
                xmlRoot.setAttribute(fieldStr(InventTransferLine, QtyRemainReceive),num2str(transferLines.QtyRemainReceive,0,10,1,0));
                xmlRoot.setAttribute('LINES', int642str(transferLines.RecId));

                if (transferLines.RecId == 0)
                {
                    xmlRoot.setAttribute(fieldStr(InventTransferTable, TransferStatus), 'Draft'); // set to draft until order lines are committed to AX.
                }

                while select RecId, ItemId, InventDimId, QtyTransfer, QtyShipped, QtyReceived, QtyShipNow, QtyReceiveNow, QtyRemainShip, QtyRemainReceive, UnitId, DataAreaId from transferLine
                    order by transferLine.RecId
                    where transferLine.TransferId == transferId
                    join inventDim where inventDim.InventDimId == transferLine.InventDimId
                    join ItemId, Product from inventTable where inventTable.ItemId == transferLine.ItemId
                    outer join ItemBarCode from inventItemBarcode where inventItemBarcode.ItemId == transferLine.ItemId
                           && (inventItemBarcode.InventDimId == transferLine.InventDimId || inventItemBarcode.InventDimId == inventDimBlank.InventDimId)
                    outer join Name, Product, LanguageId from productTranslation
                        where productTranslation.Product == inventTable.Product
                           && productTranslation.LanguageId == languageId
                {
                    if (transferLine.RecId == lastRecId)
                    {
                        continue;
                    }
                    else
                    {
                        lastRecId = transferLine.RecId;
                    }

                    xmlRecord = xmlDoc.createElement(tableStr(InventTransferLine));

                    xmlRecord.setAttribute(fieldStr(InventTransferLine, RecId), int642str(transferLine.RecId));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, ItemId), transferLine.ItemId);
                    xmlRecord.setAttribute(extendedTypeStr(EcoResProductName), productTranslation.Name);
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, InventDimId), transferLine.InventDimId);
                    xmlRecord.setAttribute(fieldStr(InventItemBarcode, ItemBarCode), inventItemBarcode.ItemBarCode);

                    xmlRecord.setAttribute(fieldStr(InventDim, InventBatchId), inventDim.InventBatchId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsLocationId), inventDim.wmsLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, LicensePlateId), inventDim.LicensePlateId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStatusId), inventDim.InventStatusId);
                    xmlRecord.setAttribute(fieldStr(InventDim, wmsPalletId), inventDim.wmsPalletId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSiteId), inventDim.InventSiteId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventLocationId), inventDim.InventLocationId);
                    xmlRecord.setAttribute(fieldStr(InventDim, ConfigId), inventDim.ConfigId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSizeId), inventDim.InventSizeId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventColorId), inventDim.InventColorId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventStyleId), inventDim.InventStyleId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventVersionId), inventDim.InventVersionId);
                    xmlRecord.setAttribute(fieldStr(InventDim, InventSerialId), inventDim.InventSerialId);

                    RecId productRecId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(
                        productMap, transferLine.ItemId, transferLine.DataAreaId, inventDim.InventColorId, inventDim.ConfigId,
                        inventDim.InventSizeId, inventDim.InventStyleId, inventDim.InventVersionId);

                    if (productRecId != 0)
                    {
                        xmlRecord.setAttribute(RetailTransactionServiceInventory::ProductRecordIdAttributeName, int642Str(productRecId));
                    }

                    int numberOfDecimals = DefaultNumberOfDecimals;
                    UnitOfMeasure unitOfMeasure = UnitOfMeasure::findBySymbol(transferLine.UnitId);
                    if (unitOfMeasure.RecId)
                    {
                        numberOfDecimals = unitOfMeasure.DecimalPrecision;
                    }

                    xmlRecord.setAttribute(fieldStr(InventTransferLine, UnitId), transferLine.UnitId);
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyTransfer), num2str(transferLine.QtyTransfer, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyShipped), num2str(transferLine.QtyShipped, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyReceived), num2str(transferLine.QtyReceived, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyShipNow), num2str(transferLine.QtyShipNow, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyReceiveNow), num2str(transferLine.QtyReceiveNow, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyRemainShip), num2str(transferLine.QtyRemainShip, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, QtyRemainReceive), num2str(transferLine.QtyRemainReceive, 0, numberOfDecimals, 1, 0));
                    xmlRecord.setAttribute(fieldStr(InventTransferLine, DataAreaId), transferLine.DataAreaId);

                    xmlRecord.setAttribute(RetailTransactionServiceInventory::GuidStr, guid2str(newGuid()));
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::FalseStr);
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, '');

                    xmlRoot.appendChild(xmlRecord);
                }

                xmlDoc.appendChild(xmlRoot);
            }

            transferOrderContainer = [true, "", xmlDoc.toString()];

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            transferOrderContainer = [false, "@RET2382"];
            ttsabort;
        }
        catch
        {
            transferOrderContainer = [false, "@RET2382"];
            ttsabort;
        }

        return transferOrderContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_includeNonStoreWarehouses">True to include warehouse locations that are not Retail stores, default is False.</param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookup(ItemId _itemId, RetailVariantId _variantId = '', boolean _includeNonStoreWarehouses = false)
    {
        RetailTransactionService transactionService = new RetailTransactionService();
        InventDimCombination    inventDimCombination = InventDimCombination::findVariantId(_variantId);
        InventDim               inventDim;
        InventDimParm           inventDimParm;
        InventOnhand            inventOnhand;
        RetailStoreTable        retailStoreTable;
        RetailChannelTable      retailChannelTable;
        DirPartyTable           dirPartyTable;

        container               output = [true,''];
        InventLocation          inventLocation;
        InventQty               availPhysical;

        //Add to results
        void AddToOutput(
            InventDimCombination _combination,
            InventLocation _location,
            str _name)
        {
            inventDim.clear();
            inventDim.InventSizeId      = _combination.inventDim().InventSizeId;
            inventDim.InventColorId     = _combination.inventDim().InventColorId;
            inventDim.InventStyleId     = _combination.inventDim().InventStyleId;
            inventDim.InventVersionId   = _combination.inventDim().InventVersionId;
            inventDim.ConfigId          = _combination.inventDim().ConfigId;
            inventDim.InventSiteId      = _location.InventSiteId;
            inventDim.InventLocationId  = _location.InventLocationId;

            inventDim = InventDim::findDim(inventDim);
            if (inventDim.RecId)
            {
                inventDimParm.initFromInventDim(inventDim);

                inventOnhand  = InventOnhand::newItemDim(_itemId, inventDim, inventDimParm);
                availPhysical = inventOnhand.availPhysical();

                output = conIns(output, conLen(output)+1, _itemId, _location.InventLocationId, _name, availPhysical);
            }
        }

        try
        {
            // Add inventory quantities for Stores
            while select InventLocation from retailStoreTable
                join omOperatingUnitID from retailChannelTable
                    where retailChannelTable.RecId == retailStoreTable.RecId
                join Name from dirPartyTable
                    where dirPartyTable.RecId == retailChannelTable.omOperatingUnitID
                join InventSiteId, InventLocationId from inventLocation
                    where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                    inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId
            {
                AddToOutput(
                        inventDimCombination,
                        inventLocation,
                        dirPartyTable.Name);
            }

            if (_includeNonStoreWarehouses)
            {
                // Add inventory quantities for non-store warehouses (warehouses that are not linked to a store)
                while select InventSiteId, InventLocationId, Name from inventLocation
                    notexists join RetailStoreTable
                        where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                        inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId
                {
                    AddToOutput(
                        inventDimCombination,
                        inventLocation,
                        inventLocation.Name);
                }
            }
        }
        catch
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, "@RET2382");
            throw error("@RET2382");
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookupXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_includeNonStoreWarehouses">True to include warehouse locations that are not Retail stores, default is False.</param>
    /// <returns>
    /// The status and inventory details as an XML.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookupXml(ItemId _itemId, RetailVariantId _variantId = '', boolean _includeNonStoreWarehouses = false)
    {
        return RetailTransactionServiceInventory::inventoryLookupByStoreXml(_itemId, _variantId, _includeNonStoreWarehouses, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryLookupByStoreXml</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// available physical inventory.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_includeNonStoreWarehouses">True to include warehouse locations that are not Retail stores, default is False.</param>
    /// <param name="_currentStoreId">Current store id.</param>
    /// <returns>
    /// The status and inventory details as an XML.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container inventoryLookupByStoreXml(ItemId _itemId, RetailVariantId _variantId = '', boolean _includeNonStoreWarehouses = false, RecId _currentStoreId = 0)
    {
        RetailTransactionService transactionService = new RetailTransactionService();
        InventDimCombination    inventDimCombination = InventDimCombination::findVariantId(_variantId);
        InventDim               inventDim;
        InventDimParm           inventDimParm;
        InventOnhand            inventOnhand;
        RetailStoreTable        retailStoreTable;
        RetailChannelTable      retailChannelTable;
        DirPartyTable           dirPartyTable;

        container               output = [true,''];
        InventLocation          inventLocation;
        InventQty               availPhysical;
        Map warehouseAddedAsStores = new map(Types::String, Types::String);

        System.Collections.ArrayList resultList = new System.Collections.ArrayList();
        TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();

        RetailStoreLocatorGroupOwner    storeLocatorGroupOwner;
        RetailStoreLocatorGroupMember   storeLocatorGroupMember;
        int fromLine;

        //Add to results
        void AddToOutput(
            InventDimCombination _combination,
            InventLocation _location,
            str _name,
            boolean _isWarehouse)
        {
            inventDim = RetailTransactionServiceInventory::getInventDimFromDimensions(_combination.inventDim().InventSizeId, _combination.inventDim().InventColorId, 
                _combination.inventDim().InventStyleId, _combination.inventDim().InventVersionId, _combination.inventDim().ConfigId, _location);

            inventoryInfo = new TS.InventoryInfo();
            inventDimParm.initFromInventDim(inventDim);
            inventOnhand  = InventOnhand::newItemDim(_itemId, inventDim, inventDimParm);
            availPhysical = inventOnhand.availPhysical();
            inventoryInfo.ItemId = _itemId;
            inventoryInfo.InventoryLocationId = _location.InventLocationId;
            inventoryInfo.StoreName = _name;
            inventoryInfo.InventoryAvailable = num2Str(availPhysical, 0, 16, 1, 0);
            inventoryInfo.OrderedSum = num2Str(inventOnhand.orderedSum(), 0, 16, 1, 0);
            inventoryInfo.PhysicalReserved = num2Str(inventOnhand.reservPhysical(), 0, 16, 1, 0);
            inventoryInfo.IsWarehouse = _isWarehouse;
            resultList.Add(inventoryInfo);
        }


        try
        {
            fromLine = Global::infologLine();
            if (_currentStoreId)
            {
                // Add inventory quantities for Stores that are in the current store's Fulfillment groups.
                while select InventLocation from retailStoreTable
                join omOperatingUnitID from retailChannelTable
                    where retailChannelTable.RecId == retailStoreTable.RecId
                join Name from dirPartyTable
                    where dirPartyTable.RecId == retailChannelTable.omOperatingUnitID
                join InventSiteId, InventLocationId from inventLocation
                    where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                    inventLocation.InventLocationType == InventLocationType::Standard &&
                    inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId
                join storeLocatorGroupOwner
                    where storeLocatorGroupOwner.Channel == _currentStoreId
                join storeLocatorGroupMember
                    where storeLocatorGroupMember.LocatorGroup == storeLocatorGroupOwner.LocatorGroup
                        && storeLocatorGroupMember.InventLocationId == inventLocation.InventLocationId
                        && storeLocatorGroupMember.Store != 0
                {
                    AddToOutput(
                        inventDimCombination,
                        inventLocation,
                        dirPartyTable.Name,
                        false);
                    warehouseAddedAsStores.insert(inventLocation.InventLocationId, InventLocation.DataAreaId);
                }
            }
            else
            {
                // Add inventory quantities for Stores
                while select InventLocation from retailStoreTable
                    join omOperatingUnitID from retailChannelTable
                        where retailChannelTable.RecId == retailStoreTable.RecId
                    join Name from dirPartyTable
                        where dirPartyTable.RecId == retailChannelTable.omOperatingUnitID
                    join InventSiteId, InventLocationId from inventLocation
                        where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                        inventLocation.InventLocationType == InventLocationType::Standard &&
                        inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId
                {
                    AddToOutput(
                            inventDimCombination,
                            inventLocation,
                            dirPartyTable.Name,
                            false);

                    warehouseAddedAsStores.insert(inventLocation.InventLocationId, InventLocation.DataAreaId);
                }
            }

            if (_includeNonStoreWarehouses && _currentStoreId)
            {
                // Add inventory quantities for non-store warehouses (warehouses that are not linked to a store)
                while select InventSiteId, InventLocationId, Name, DataAreaId from inventLocation
                    where inventLocation.InventLocationType == InventLocationType::Standard
                join storeLocatorGroupOwner
                    where storeLocatorGroupOwner.Channel == _currentStoreId
                join storeLocatorGroupMember
                    where storeLocatorGroupMember.LocatorGroup == storeLocatorGroupOwner.LocatorGroup
                        && storeLocatorGroupMember.InventLocationId == inventLocation.InventLocationId
                        && storeLocatorGroupMember.Store == 0
                {
                    AddToOutput(
                        inventDimCombination,
                        inventLocation,
                        inventLocation.Name,
                        true);
                }
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception ex = CLRInterop::getLastException();
            str errorMessage = ex.Message;
            str axCallStack = ex.StackTrace;
            if (ex.InnerException)
            {
                errorMessage = ex.InnerException.Message;
                axCallStack = ex.InnerException.StackTrace;
            }
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }
        catch
        {
            str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }

        // Serialize the data-contract list using the specified type list.
        System.Type[] typeArray = new System.Type[1]();
        typeArray.SetValue(inventoryInfo.GetType(), 0);
        output = [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateInventoryInfo</Name>
				<Source><![CDATA[
    /// <summary>Creates an InventoryInfo object and queries for the inventonhand.</summary>
    /// <param name="_combination">InventDimCombination object.</param>
    /// <param name="_location">Inventory Location object.</param>
    /// <param name="_name">Store or Warehouse location name.</param>
    /// <param name="_isWarehouse">True if location is a warehouse; otherwise, false.</param>
    /// <param name="_itemId">Id of the item that is being queried for.</param>
    /// <returns>An InventoryInfo object for the location and item provided.</returns>
    private static TS.InventoryInfo CreateInventoryInfo(InventDimCombination _combination, InventLocation _location, str _name, boolean _isWarehouse, ItemId _itemId)
    {
        InventDimParm           inventDimParm;
        InventOnhand            inventOnhand;
        InventQty               availPhysical;
        InventDim               inventDim, combinationInventDim;

        combinationInventDim = _combination.inventDim();
        inventDim = RetailTransactionServiceInventory::getInventDimFromDimensions(combinationInventDim.InventSizeId, combinationInventDim.InventColorId,
                combinationInventDim.InventStyleId, combinationInventDim.InventVersionId, combinationInventDim.ConfigId, _location);

        TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();
        inventDimParm.initFromInventDim(inventDim);
        inventOnhand  = InventOnhand::newItemDim(_itemId, inventDim, inventDimParm);
        availPhysical = inventOnhand.availPhysical();
        inventoryInfo.ItemId = _itemId;
        inventoryInfo.InventoryLocationId = _location.InventLocationId;
        inventoryInfo.StoreName = _name;
        inventoryInfo.InventoryAvailable = num2Str(availPhysical, 0, 16, 1, 0);
        inventoryInfo.OrderedSum = num2Str(inventOnhand.orderedSum(), 0, 16, 1, 0);
        inventoryInfo.PhysicalReserved = num2Str(inventOnhand.reservPhysical(), 0, 16, 1, 0);
        inventoryInfo.IsWarehouse = _isWarehouse;

        return inventoryInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventoryLookupByStoreV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns inventory of item _itemId for each store and warehouse in the fulfillment group of store _currentStoreId
    /// </summary>
    /// <param name = "_itemId">The inventory item to query the inventory availability of.</param>
    /// <param name = "_variantId">The variant id of the item.</param>
    /// <param name = "_currentStoreId">The current store id.</param>
    /// <param name = "_pageSkip">The first index to be returned via pagination.</param>
    /// <param name = "_pageTop">The size of the results to be returned via pagination.</param>
    /// <param name = "_includeWarehouses">True to include warehouse locations that are not Retail stores.</param>
    /// <param name = "_listCurrentStoreFirst">True to place the current store as the first store returned.</param>
    /// <returns>
    /// A container with the status and inventory details as a JSON string containing the list of InventoryInfo objects.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the method fails to check for the available physical inventory.
    /// </exception>
    internal static container InventoryLookupByStoreV2(ItemId _itemId, RetailVariantId _variantId, RecId _currentStoreId, int _pageSkip, int _pageTop, boolean _includeWarehouses, boolean _listCurrentStoreFirst)
    {
        RetailTransactionService transactionService = new RetailTransactionService();
        InventDimCombination    inventDimCombination = InventDimCombination::findVariantId(_variantId);
        RetailStoreTable        retailStoreTable;
        RetailChannelTable      retailChannelTable;
        DirPartyTable           dirPartyTable;

        InventLocation          inventLocation;

        System.Collections.ArrayList resultList = new System.Collections.ArrayList();
        TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();
        container               output = [true,''];

        RetailStoreLocatorGroupOwner    storeLocatorGroupOwner;
        RetailStoreLocatorGroupMember   storeLocatorGroupMember;

        System.Collections.ArrayList locations = new System.Collections.ArrayList();
        Set warehouseStores = new Set(Types::String);

        int pageBegin = _pageSkip < 0 ? 0 : _pageSkip;
        int pageEnd = pageBegin + _pageTop;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();
            // Query selects all inventory locations in current stores fulfillment group.
            while select InventSiteId, InventLocationId, Name, DataAreaId from inventLocation
                order by inventLocation.Name
                where inventLocation.InventLocationType == InventLocationType::Standard
            join storeLocatorGroupOwner
                where storeLocatorGroupOwner.Channel == _currentStoreId
            join storeLocatorGroupMember
                where storeLocatorGroupMember.LocatorGroup == storeLocatorGroupOwner.LocatorGroup
                    && storeLocatorGroupMember.InventLocationId == inventLocation.InventLocationId
            outer join InventLocation from retailStoreTable
                where inventLocation.InventLocationId == retailStoreTable.InventLocation
                    && inventLocation.DataAreaId == retailStoreTable.inventLocationDataAreaId
            outer join omOperatingUnitID from retailChannelTable
                where retailChannelTable.RecId == retailStoreTable.RecId
            outer join Name from dirPartyTable
                where dirPartyTable.RecId == retailChannelTable.omOperatingUnitID
            {
                // This is to prevent duplicated warehouse and store
                str warehouseStore = strFmt("%1-%2", inventLocation.InventLocationId, retailChannelTable.RecId);
                if (warehouseStores.in(warehouseStore))
                {
                    continue;
                }
                warehouseStores.add(warehouseStore);

                // The query outer joins with retailStoreTable then dirPartyTable, so we can tell if a location is a warehouse if the dirPartyTable entry is empty.
                boolean isWarehouse = storeLocatorGroupMember.Store == 0;
                str storeOrLocationName = isWarehouse || dirPartyTable.Name == null ? inventLocation.Name : dirPartyTable.Name;

                if (_includeWarehouses || !isWarehouse)
                {
                    // Information about each location is stored, but not queried for inventory at this point.
                    Struct location = new Struct("str locationName; InventLocation inventLocation; boolean isWarehouse");
                    location.value("locationName", storeOrLocationName);
                    location.value("inventLocation", inventLocation);
                    location.value("isWarehouse", isWarehouse);
      
                    boolean isCurrentStore = (retailStoreTable.RecId == _currentStoreId);
                    if (_listCurrentStoreFirst && isCurrentStore)
                    {
                        locations.insert(0, location);
                    }
                    else
                    {
                        locations.add(location);
                    }
                }
            }
   
            pageEnd = min(pageEnd, locations.Count);
            var locationsArray = locations.ToArray();

            // Pagination logic takes list of location names, and queries the inventory for the current page or those names.
            for (int i = pageBegin; i < pageEnd; i++)
            {
                Struct location = locationsArray.GetValue(i);
                inventoryInfo = RetailTransactionServiceInventory::CreateInventoryInfo(inventDimCombination, location.value("inventLocation"), location.value("locationName"),
                                                                                             location.value("isWarehouse"), _itemId);
                resultList.Add(inventoryInfo);
            }
        }
        catch (Exception::CLRError)
        {
            System.Exception ex = CLRInterop::getLastException();
            str errorMessage = ex.Message;
            str axCallStack = ex.StackTrace;
            if (ex.InnerException)
            {
                errorMessage = ex.InnerException.Message;
                axCallStack = ex.InnerException.StackTrace;
            }
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }
        catch
        {
            str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }

        // Serialize the data-contract list using the specified type list.
        System.Type[] typeArray = new System.Type[1]();
        typeArray.SetValue(inventoryInfo.GetType(), 0);
        output = [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventoryLookupByStoreV3</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns inventory of item for each store and warehouse in the fulfillment group of store in sorted manner.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in JSON format.</param>
    /// <returns>
    /// A container with the status and inventory details as a JSON string containing the list of InventoryInfo objects.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the method fails to check for the availabilities.
    /// </exception>
    internal static container InventoryLookupByStoreV3(str _searchCriteriaJson)
    {
        TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();

        FulfillmentGroupMemberLocationView fulfillmentGroupMemberLocation;
        InventWarehouseOnHandV2Entity inventWarehouseOnHand;
        TmpRetailStoreInventoryInfo tmpRetailStoreInventoryInfo;
        InventDimCombination inventDimCombination;
        InventDim inventDim;

        LogisticsAddressLatitude currentStoreLatitude;
        LogisticsAddressLongitude currentStoreLongitude;
        utcdatetime currentDateTime = DateTimeUtil::getSystemDateTime();

        System.Collections.ArrayList resultList = new System.Collections.ArrayList();
        Set warehouseStores = new Set(Types::String);

        // In sorting by distance scenario, there is implicit assumption that both the source and destination should have geo location configured in order to calculate distance value.
        // However geo location is not hard requirement for inventory, so we should handle the case when it is missing instead of throwing error.
        // When source location is missing, we will put the source store at the top of result list, and sort the rest by name in ascending order.
        boolean isDistanceSourceLocationFound = true;
        boolean isSortByDistance = true;
        GeoCoordinate currentStoreGeoCoordinate;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();
            CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria =
                RetailTransactionServiceInventory::getInventoryLookupSearchCriteriaFromJson(_searchCriteriaJson);
            if (!searchCriteria)
            {
                return [false, "@RetailInventory:InventoryLookupInvalidSearchCriteria", ''];
            }

            if (!RetailInventoryLookupUseLatestVersionToggle::instance().isEnabled())
            {
                eventSource.EventWriteInventoryLookupVersionFallback();
                return RetailTransactionServiceInventory::InventoryLookupByStoreV2(
                    searchCriteria.ItemId, searchCriteria.VariantId, searchCriteria.ChannelId,
                    searchCriteria.Paging.Skip, searchCriteria.Paging.Top,
                    searchCriteria.IncludeWarehouses, true);
            }

            eventSource.EventWriteInventoryLookupV3Begin(searchCriteria.ItemId, searchCriteria.VariantId, searchCriteria.ChannelId);

            // Check whether to sort by distance, which will be invalid scenario when current store geo location is not found.
            CRT.DataModel.SortingInfo sortingInfo = searchCriteria.Sorting;
            if (sortingInfo != null && sortingInfo.get_Count() > 0)
            {
                CLRSystem.Collections.IEnumerable sortColumns = sortingInfo.get_Columns();
                System.Collections.IEnumerator sortColumnEnumerator = sortColumns.GetEnumerator();

                // Multiple-column sorting is not supported, so honor the first one only.
                if(sortColumnEnumerator.MoveNext())
                {
                    CRT.DataModel.SortColumn sortColumn = sortColumnEnumerator.get_Current();
                    str columnName = sortColumn.get_ColumnName();
                    isSortByDistance = columnName == GeoDistanceSortColumnName;
                }
            }

            inventDimCombination = InventDimCombination::findVariantId(searchCriteria.VariantId);
            inventDim = inventDimCombination.InventDim();

            select firstonly StoreLatitude, StoreLongitude, RecId from fulfillmentGroupMemberLocation
                where fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel == searchCriteria.ChannelId
                    && fulfillmentGroupMemberLocation.StoreRecId == searchCriteria.ChannelId
                    && currentDateTime >= fulfillmentGroupMemberLocation.StoreLocationValidFrom
                    && currentDateTime <= fulfillmentGroupMemberLocation.StoreLocationValidTo;

            if (!fulfillmentGroupMemberLocation.RecId)
            {
                eventSource.EventWriteInventoryLookupCurrentStoreValidLocationSearchFailed(searchCriteria.ChannelId);
                isDistanceSourceLocationFound = false;

                // If sort by distance when current store location is missing, we will sort the non-current locations by name in ascending order instead.
                if (isSortByDistance)
                {
                    eventSource.EventWriteInventoryLookupSortOptionFallback();
                    var sortingInfoFallback = new CRT.DataModel.SortingInfo(LocationNameSortColumnName);
                    searchCriteria = new CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria(
                        searchCriteria.ItemId, searchCriteria.VariantId, searchCriteria.ChannelId, searchCriteria.IncludeWarehouses,
                        searchCriteria.Paging, sortingInfoFallback);
                }
            }
            else
            {
                currentStoreGeoCoordinate = new GeoCoordinate(fulfillmentGroupMemberLocation.StoreLatitude, fulfillmentGroupMemberLocation.StoreLongitude);
            }

            while select fulfillmentGroupMemberLocation
                where fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel == searchCriteria.ChannelId
            outer join AvailableOnHandQuantity, ReservedOnHandQuantity, OrderedQuantity from inventWarehouseOnHand
                where inventWarehouseOnHand.ItemNumber == searchCriteria.ItemId
                    && inventWarehouseOnHand.InventoryWarehouseId == fulfillmentGroupMemberLocation.InventLocationId
                    && inventWarehouseOnHand.InventorySiteId == fulfillmentGroupMemberLocation.InventSiteId
                    && inventWarehouseOnHand.ProductSizeId == inventDim.InventSizeId
                    && inventWarehouseOnHand.ProductColorId == inventDim.InventColorId
                    && inventWarehouseOnHand.ProductStyleId == inventDim.InventStyleId
                    && inventWarehouseOnHand.ProductVersionId == inventDim.InventVersionId
                    && inventWarehouseOnHand.ProductConfigurationId == inventDim.configId
            {
                boolean isWarehouse = fulfillmentGroupMemberLocation.Store == 0;
                str storeOrLocationName = isWarehouse ? fulfillmentGroupMemberLocation.InventLocationName : fulfillmentGroupMemberLocation.DirPartyName;

                eventSource.EventWriteInventoryLookupRetrievingDataBegin(storeOrLocationName, isWarehouse);

                // Skip warehouses if excluding warehouses.
                if (!searchCriteria.IncludeWarehouses && isWarehouse)
                {
                    eventSource.EventWriteInventoryLookupSkipWarehouse(storeOrLocationName, isWarehouse);
                    continue;
                }

                // In sorting by distance scenario, there is implicit assumption that both the source and destination should have geo location configured in order to calculate distance value.
                // However geo location is not hard requirement for inventory, so we should handle the case when it is missing instead of throwing error.
                // When destination location is missing, we will treat it as the farthest from the source location.
                boolean isDistanceDestinationLocationFound = true;
                GeoCoordinate geoCoordinate;
                real geoDistance = realMax();

                utcdatetime validFrom = isWarehouse ? fulfillmentGroupMemberLocation.WarehouseLocationValidFrom : fulfillmentGroupMemberLocation.StoreLocationValidFrom;
                utcdatetime validTo = isWarehouse ? fulfillmentGroupMemberLocation.WarehouseLocationValidTo : fulfillmentGroupMemberLocation.StoreLocationValidTo;
                if (!validFrom && !validTo)
                {
                    // Missing location should not block viewing inventory, so keep the records without location.
                    eventSource.EventWriteInventoryLookupValidDestinationLocationSearchFailed(storeOrLocationName, isWarehouse);
                    isDistanceDestinationLocationFound = false;
                }
                else if (currentDateTime <= validFrom || currentDateTime >= validTo)
                {
                    // Skip records whose setting exists but is out of valid time window.
                    eventSource.EventWriteInventoryLookupSkipExpiredLocation(storeOrLocationName, isWarehouse);
                    continue;
                }

                // This is to prevent duplicated warehouse and store.
                str warehouseStore = strFmt("%1-%2", fulfillmentGroupMemberLocation.InventLocationId, fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel);
                if (warehouseStores.in(warehouseStore))
                {
                    eventSource.EventWriteInventoryLookupSkipDuplicateWarehouseStore(warehouseStore);
                    continue;
                }
                warehouseStores.add(warehouseStore);

                // If sort by distance, we will always put the source store on top of the result list.
                if (isSortByDistance && fulfillmentGroupMemberLocation.Store == searchCriteria.ChannelId)
                {
                    geoDistance = realMin();
                }
                else if (isDistanceDestinationLocationFound)
                {
                    geoCoordinate = isWarehouse
                        ? new GeoCoordinate(fulfillmentGroupMemberLocation.WarehouseLatitude, fulfillmentGroupMemberLocation.WarehouseLongitude)
                        : new GeoCoordinate(fulfillmentGroupMemberLocation.StoreLatitude, fulfillmentGroupMemberLocation.StoreLongitude);

                    if (isDistanceSourceLocationFound)
                    {
                        geoDistance = geoCoordinate.GetDistanceTo(currentStoreGeoCoordinate);
                    }
                }

                tmpRetailStoreInventoryInfo.clear();

                tmpRetailStoreInventoryInfo.ItemId = searchCriteria.ItemId;
                tmpRetailStoreInventoryInfo.InventLocationId = fulfillmentGroupMemberLocation.InventLocationId;
                tmpRetailStoreInventoryInfo.StoreNumber = fulfillmentGroupMemberLocation.StoreNumber;
                tmpRetailStoreInventoryInfo.Name = storeOrLocationName;
                tmpRetailStoreInventoryInfo.IsWarehouse = isWarehouse;
                tmpRetailStoreInventoryInfo.Distance = geoDistance;

                if (inventWarehouseOnHand)
                {
                    tmpRetailStoreInventoryInfo.AvailPhysical = inventWarehouseOnHand.AvailableOnHandQuantity;
                    tmpRetailStoreInventoryInfo.PhysicalReserved = inventWarehouseOnHand.ReservedOnHandQuantity;
                    tmpRetailStoreInventoryInfo.OrderedSum = inventWarehouseOnHand.OrderedQuantity;
                }

                ttsbegin;
                tmpRetailStoreInventoryInfo.insert();
                ttscommit;

                eventSource.EventWriteInventoryLookupRetrievingDataEnd(storeOrLocationName, isWarehouse);
            }

            eventSource.EventWriteInventoryLookupSortBegin();

            QueryRun qr = RetailTransactionServiceInventory::buildInventoryLookupQueryRun(searchCriteria, false);
            // Required for temp table to work with QueryRun.
            qr.setRecord(tmpRetailStoreInventoryInfo);

            while (qr.next())
            {
                tmpRetailStoreInventoryInfo = qr.get(tableNum(TmpRetailStoreInventoryInfo));

                inventoryInfo = new TS.InventoryInfo();

                inventoryInfo.ItemId = tmpRetailStoreInventoryInfo.ItemId;
                inventoryInfo.InventoryLocationId = tmpRetailStoreInventoryInfo.InventLocationId;
                inventoryInfo.StoreName = tmpRetailStoreInventoryInfo.Name;
                inventoryInfo.IsWarehouse = tmpRetailStoreInventoryInfo.IsWarehouse;

                inventoryInfo.InventoryAvailable = num2Str(tmpRetailStoreInventoryInfo.AvailPhysical, 0, 16, 1, 0);
                inventoryInfo.OrderedSum = num2Str(tmpRetailStoreInventoryInfo.OrderedSum, 0, 16, 1, 0);
                inventoryInfo.PhysicalReserved = num2Str(tmpRetailStoreInventoryInfo.PhysicalReserved, 0, 16, 1, 0);

                resultList.Add(inventoryInfo);
            }

            eventSource.EventWriteInventoryLookupSortEnd();

            eventSource.EventWriteInventoryLookupV3End(resultList.get_Count());
        }
        catch (Exception::CLRError)
        {
            System.Exception ex = CLRInterop::getLastException();
            str errorMessage = ex.Message;
            str axCallStack = ex.StackTrace;
            if (ex.InnerException)
            {
                errorMessage = ex.InnerException.Message;
                axCallStack = ex.InnerException.StackTrace;
            }
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }
        catch
        {
            str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }

        // Serialize the data-contract list using the specified type list.
        System.Type[] typeArray = new System.Type[1]();
        typeArray.SetValue(inventoryInfo.GetType(), 0);
        return [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventoryLookupByStoreV3Optimized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns inventory of item for each store and warehouse in the fulfillment group of store in sorted manner.
    /// It improves the performance of InventoryLookupByStoreV3 method by:
    ///     - using set operations (insert_recordset and update_recordset) rather than cursor-like operations (while select)
    ///     - leveraging denormalized InventSum rather than the heavy InventWarehouseOnHandV2Entity
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria in JSON format.</param>
    /// <returns>
    /// A container with the status and inventory details as a JSON string containing the list of InventoryInfo objects.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws an error if the method fails to check for the availabilities.
    /// </exception>
    internal static container InventoryLookupByStoreV3Optimized(str _searchCriteriaJson)
    {
        TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();
        System.Collections.ArrayList resultList = new System.Collections.ArrayList();
        TmpRetailStoreInventoryInfo tmpRetailStoreInventoryInfo;
        int fromLine;

        try
        {
            fromLine = Global::infologLine();

            if (!RetailInventoryLookupUseOptimizedV3Flight::instance().isEnabled())
            {
                eventSource.EventWriteInventoryLookupV3FallbackToLegacy();
                return RetailTransactionServiceInventory::InventoryLookupByStoreV3(_searchCriteriaJson);
            }

            CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria =
                RetailTransactionServiceInventory::getInventoryLookupSearchCriteriaFromJson(_searchCriteriaJson);
            if (!searchCriteria)
            {
                return [false, "@RetailInventory:InventoryLookupInvalidSearchCriteria", ''];
            }

            if (!RetailInventoryLookupUseLatestVersionToggle::instance().isEnabled())
            {
                eventSource.EventWriteInventoryLookupVersionFallback();
                return RetailTransactionServiceInventory::InventoryLookupByStoreV2(
                    searchCriteria.ItemId, searchCriteria.VariantId, searchCriteria.ChannelId,
                    searchCriteria.Paging.Skip, searchCriteria.Paging.Top,
                    searchCriteria.IncludeWarehouses, true);
            }

            eventSource.EventWriteInventoryLookupV3Begin(searchCriteria.ItemId, searchCriteria.VariantId, searchCriteria.ChannelId);

            // Step 1: popluate basic information (including name, invent location, etc.) and location information (including geo coordinates).
            int tmpRetailStoreInventoryInfoRowCountTotal = RetailTransactionServiceInventory::initializeTmpRetailStoreInventoryInfoWithLocation(
                searchCriteria, tmpRetailStoreInventoryInfo);

            // Step 2: populate inventory availabilities.
            RetailTransactionServiceInventory::populateTmpRetailStoreInventoryInfoWithAvailabilityQty(
                searchCriteria, tmpRetailStoreInventoryInfo, tmpRetailStoreInventoryInfoRowCountTotal);

            // Step 3: calculate and populate geo distance based on coordinates, only when sorting by distance.
            boolean isSortByDistance = true;
            CRT.DataModel.SortingInfo sortingInfo = searchCriteria.Sorting;
            if (sortingInfo != null && sortingInfo.get_Count() > 0)
            {
                CLRSystem.Collections.IEnumerable sortColumns = sortingInfo.get_Columns();
                System.Collections.IEnumerator sortColumnEnumerator = sortColumns.GetEnumerator();

                if(sortColumnEnumerator.MoveNext())
                {
                    CRT.DataModel.SortColumn sortColumn = sortColumnEnumerator.get_Current();
                    str columnName = sortColumn.get_ColumnName();
                    isSortByDistance = columnName == GeoDistanceSortColumnName;
                }
            }

            if (isSortByDistance)
            {
                searchCriteria = RetailTransactionServiceInventory::populateTmpRetailStoreInventoryInfoWithGeoDistance(
                    searchCriteria, tmpRetailStoreInventoryInfo, resultList);
            }

            // Step 4: Sort and return the results.
            RetailTransactionServiceInventory::sortTmpRetailStoreInventoryInfo(
                searchCriteria, tmpRetailStoreInventoryInfo, resultList);

            eventSource.EventWriteInventoryLookupV3End(resultList.get_Count());
        }
        catch (Exception::CLRError)
        {
            System.Exception ex = CLRInterop::getLastException();
            str errorMessage = ex.Message;
            str axCallStack = ex.StackTrace;
            if (ex.InnerException)
            {
                errorMessage = ex.InnerException.Message;
                axCallStack = ex.InnerException.StackTrace;
            }
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }
        catch
        {
            str errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, errorMessage);
            return [false, errorMessage, ''];
        }

        // Serialize the data-contract list using the specified type list.
        System.Type[] typeArray = new System.Type[1]();
        typeArray.SetValue(inventoryInfo.GetType(), 0);
        return [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTmpRetailStoreInventoryInfoWithLocation</Name>
				<Source><![CDATA[
    private static int initializeTmpRetailStoreInventoryInfoWithLocation(
        CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria,
        TmpRetailStoreInventoryInfo tmpRetailStoreInventoryInfo)
    {
        const str action = 'Initializing TmpRetailStoreInventoryInfo with location';
        eventSource.EventWriteInventoryLookupV3ActionBegin(action);
        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Reset();
        stopWatch.Start();

        FulfillmentGroupMemberLocationView fulfillmentGroupMemberLocation;
        utcdatetime currentDateTime = DateTimeUtil::getSystemDateTime();
        int tmpRetailStoreInventoryInfoRowCount = 0;
        int tmpRetailStoreInventoryInfoRowCountTotal = 0;
        str itemId = searchCriteria.ItemId;

        ttsbegin;

        // Get all distinct stores in the fulfillment group with valid location.
        NoYes isWarehouse = NoYes::No;
        NoYes isLocationFound = NoYes::Yes;
        insert_recordset tmpRetailStoreInventoryInfo (
            ItemId,
            IsWarehouse,
            Name,
            StoreNumber,
            StoreRecId,
            InventLocationId,
            InventSiteId,
            IsLocationFound,
            Latitude,
            Longitude)
        select itemId, isWarehouse, DirPartyName, StoreNumber, StoreRecId, InventLocationId, InventSiteId, isLocationFound, StoreLatitude, StoreLongitude
            from fulfillmentGroupMemberLocation
            group by DirPartyName, StoreNumber, StoreRecId, InventLocationId, InventSiteId, StoreLatitude, StoreLongitude
            where fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel == searchCriteria.ChannelId
                && fulfillmentGroupMemberLocation.Store != 0
                && fulfillmentGroupMemberLocation.StoreLocationRecId != 0
                && fulfillmentGroupMemberLocation.StoreLocationValidFrom <= currentDateTime
                && fulfillmentGroupMemberLocation.StoreLocationValidTo >= currentDateTime;
        tmpRetailStoreInventoryInfoRowCount = tmpRetailStoreInventoryInfo.RowCount();
        eventSource.EventWriteInventoryLookupV3TmpInventoryInfoInserted('Stores with valid location', tmpRetailStoreInventoryInfoRowCount);
        tmpRetailStoreInventoryInfoRowCountTotal += tmpRetailStoreInventoryInfoRowCount;

        // Get all distinct stores in the fulfillment group with no location found.
        isLocationFound = NoYes::No;
        insert_recordset tmpRetailStoreInventoryInfo (
            ItemId,
            IsWarehouse,
            Name,
            StoreNumber,
            StoreRecId,
            InventLocationId,
            InventSiteId,
            IsLocationFound)
        select itemId, isWarehouse, DirPartyName, StoreNumber, StoreRecId, InventLocationId, InventSiteId, isLocationFound
            from fulfillmentGroupMemberLocation
            group by DirPartyName, StoreNumber, StoreRecId, InventLocationId, InventSiteId
            where fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel == searchCriteria.ChannelId
                && fulfillmentGroupMemberLocation.Store != 0
                && fulfillmentGroupMemberLocation.StoreLocationRecId == 0
                && fulfillmentGroupMemberLocation.StoreRecId
                && fulfillmentGroupMemberLocation.DirPartyName != null
                && fulfillmentGroupMemberLocation.StoreNumber != null;
        tmpRetailStoreInventoryInfoRowCount = tmpRetailStoreInventoryInfo.RowCount();
        eventSource.EventWriteInventoryLookupV3TmpInventoryInfoInserted('Stores with no location found', tmpRetailStoreInventoryInfoRowCount);
        tmpRetailStoreInventoryInfoRowCountTotal += tmpRetailStoreInventoryInfoRowCount;

        if (searchCriteria.IncludeWarehouses)
        {
            // Get all distinct non-store warehouses in the fulfillment group with valid location.
            isWarehouse = NoYes::Yes;
            isLocationFound = NoYes::Yes;
            insert_recordset tmpRetailStoreInventoryInfo (
                ItemId,
                IsWarehouse,
                Name,
                InventLocationId,
                InventSiteId,
                IsLocationFound,
                Latitude,
                Longitude)
            select itemId, isWarehouse, InventLocationName, InventLocationId, InventSiteId, isLocationFound, WarehouseLatitude, WarehouseLongitude
                from fulfillmentGroupMemberLocation
                group by InventLocationName, InventLocationId, InventSiteId, WarehouseLatitude, WarehouseLongitude
                where fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel == searchCriteria.ChannelId
                    && fulfillmentGroupMemberLocation.Store == 0
                    && fulfillmentGroupMemberLocation.WarehouseLoationRecId != 0
                    && fulfillmentGroupMemberLocation.WarehouseLocationValidFrom <= currentDateTime
                    && fulfillmentGroupMemberLocation.WarehouseLocationValidTo >= currentDateTime;
            tmpRetailStoreInventoryInfoRowCount = tmpRetailStoreInventoryInfo.RowCount();
            eventSource.EventWriteInventoryLookupV3TmpInventoryInfoInserted('Warehouses with valid location', tmpRetailStoreInventoryInfoRowCount);
            tmpRetailStoreInventoryInfoRowCountTotal += tmpRetailStoreInventoryInfoRowCount;

            // Get all distinct non-store warehouses in the fulfillment group with no location found.
            isLocationFound = NoYes::No;
            insert_recordset tmpRetailStoreInventoryInfo (
                ItemId,
                IsWarehouse,
                Name,
                InventLocationId,
                InventSiteId,
                IsLocationFound)
            select itemId, isWarehouse, InventLocationName, InventLocationId, InventSiteId, isLocationFound
                from fulfillmentGroupMemberLocation
                group by InventLocationName, InventLocationId, InventSiteId
                where fulfillmentGroupMemberLocation.FulfillmentGroupOwnerChannel == searchCriteria.ChannelId
                    && fulfillmentGroupMemberLocation.Store == 0
                    && fulfillmentGroupMemberLocation.WarehouseLoationRecId == 0;
            tmpRetailStoreInventoryInfoRowCount = tmpRetailStoreInventoryInfo.RowCount();
            eventSource.EventWriteInventoryLookupV3TmpInventoryInfoInserted('Warehouses with no location found', tmpRetailStoreInventoryInfoRowCount);
            tmpRetailStoreInventoryInfoRowCountTotal += tmpRetailStoreInventoryInfoRowCount;
        }

        ttscommit;

        stopWatch.Stop();
        int64 durationInMs = stopWatch.ElapsedMilliseconds;
        eventSource.EventWriteInventoryLookupV3ActionEnd(action, durationInMs);

        return tmpRetailStoreInventoryInfoRowCountTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTmpRetailStoreInventoryInfoWithAvailabilityQty</Name>
				<Source><![CDATA[
    private static void populateTmpRetailStoreInventoryInfoWithAvailabilityQty(
        CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria,
        TmpRetailStoreInventoryInfo tmpRetailStoreInventoryInfo,
        int tmpRetailStoreInventoryInfoRowCountTotal)
    {
        const str action = 'Populating TmpRetailStoreInventoryInfo with availability quantities';
        eventSource.EventWriteInventoryLookupV3ActionBegin(action);
        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Reset();
        stopWatch.Start();

        InventDimCombination inventDimCombination = InventDimCombination::findVariantId(searchCriteria.VariantId);
        InventDim inventDim = inventDimCombination.InventDim();

        // Use a threshold configuration parameter to provide the flexibility of tuning.
        // Usually we see better performance using denormalized InventSum when the number of locations grows.
        str thresholdConfigName = RetailConfigurationParameters::getNameForRetailInventoryLookupUsingInventSumThreshold();
        RetailConfigurationParameters config = RetailConfigurationParameters::findByName(thresholdConfigName);
        int threshold = config.RecId != 0 ? str2Int(config.Value) : 0; // Use 0 as the default value.

        if (tmpRetailStoreInventoryInfoRowCountTotal > threshold
            && InventUseDimOfInventSumToggle::instance().isEnabled()
            && InventUseDimOfWHSInventReserveToggle::instance().isEnabled())
        {
            const str dataSource = 'Denormalized InventSum';
            eventSource.EventWriteInventoryLookupV3PopulateTmpInventoryInfoQuantity(dataSource, threshold, tmpRetailStoreInventoryInfoRowCountTotal);

            RetailProductWarehouseInventoryOnInventSum retailProductWarehouseOnInventSum;
            RetailProductWarehouseInventoryOnWHSItemReserve retailProductWarehouseOnWHSItem;

            ttsbegin;

            update_recordset tmpRetailStoreInventoryInfo
                setting
                    AvailPhysical = retailProductWarehouseOnInventSum.PhysicalInvent,
                    OrderedSum = retailProductWarehouseOnInventSum.OrderedInTotal,
                    PhysicalReserved = retailProductWarehouseOnInventSum.PhysicalReserved
                join retailProductWarehouseOnInventSum
                    where retailProductWarehouseOnInventSum.ItemId == searchCriteria.ItemId
                        && retailProductWarehouseOnInventSum.InventLocationId == tmpRetailStoreInventoryInfo.InventLocationId
                        && retailProductWarehouseOnInventSum.InventSiteId == tmpRetailStoreInventoryInfo.InventSiteId
                        && retailProductWarehouseOnInventSum.InventSizeId == inventDim.InventSizeId
                        && retailProductWarehouseOnInventSum.InventColorId == inventDim.InventColorId
                        && retailProductWarehouseOnInventSum.InventStyleId == inventDim.InventStyleId
                        && retailProductWarehouseOnInventSum.ConfigId == inventDim.configId;

            update_recordset tmpRetailStoreInventoryInfo
                setting
                    OrderedSum = retailProductWarehouseOnWHSItem.OrderedInTotal,
                    PhysicalReserved = retailProductWarehouseOnWHSItem.PhysicalReserved
                join retailProductWarehouseOnWHSItem
                    where retailProductWarehouseOnWHSItem.ItemId == searchCriteria.ItemId
                        && retailProductWarehouseOnWHSItem.InventLocationId == tmpRetailStoreInventoryInfo.InventLocationId
                        && retailProductWarehouseOnWHSItem.InventSiteId == tmpRetailStoreInventoryInfo.InventSiteId
                        && retailProductWarehouseOnWHSItem.InventSizeId == inventDim.InventSizeId
                        && retailProductWarehouseOnWHSItem.InventColorId == inventDim.InventColorId
                        && retailProductWarehouseOnWHSItem.InventStyleId == inventDim.InventStyleId
                        && retailProductWarehouseOnWHSItem.ConfigId == inventDim.configId;

            update_recordset tmpRetailStoreInventoryInfo
                setting
                    AvailPhysical = tmpRetailStoreInventoryInfo.AvailPhysical - tmpRetailStoreInventoryInfo.PhysicalReserved;

            ttscommit;

            eventSource.EventWriteInventoryLookupV3TmpInventoryInfoQuantityPopulated(dataSource);
        }
        else
        {
            const str dataSource = 'InventWarehouseOnHandV2Entity';
            eventSource.EventWriteInventoryLookupV3PopulateTmpInventoryInfoQuantity(dataSource, threshold, tmpRetailStoreInventoryInfoRowCountTotal);

            InventWarehouseOnHandV2Entity inventWarehouseOnHand;

            ttsbegin;

            update_recordset tmpRetailStoreInventoryInfo
                setting
                    AvailPhysical = inventWarehouseOnHand.AvailableOnHandQuantity,
                    OrderedSum = inventWarehouseOnHand.OrderedQuantity,
                    PhysicalReserved = inventWarehouseOnHand.ReservedOnHandQuantity
                join  inventWarehouseOnHand
                    where inventWarehouseOnHand.ItemNumber == searchCriteria.ItemId
                        && inventWarehouseOnHand.InventoryWarehouseId == tmpRetailStoreInventoryInfo.InventLocationId
                        && inventWarehouseOnHand.InventorySiteId == tmpRetailStoreInventoryInfo.InventSiteId
                        && inventWarehouseOnHand.ProductSizeId == inventDim.InventSizeId
                        && inventWarehouseOnHand.ProductColorId == inventDim.InventColorId
                        && inventWarehouseOnHand.ProductStyleId == inventDim.InventStyleId
                        && inventWarehouseOnHand.ProductVersionId == inventDim.InventVersionId
                        && inventWarehouseOnHand.ProductConfigurationId == inventDim.configId;

            ttscommit;

            eventSource.EventWriteInventoryLookupV3TmpInventoryInfoQuantityPopulated(dataSource);
        }

        stopWatch.Stop();
        int64 durationInMs = stopWatch.ElapsedMilliseconds;
        eventSource.EventWriteInventoryLookupV3ActionEnd(action, durationInMs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTmpRetailStoreInventoryInfoWithGeoDistance</Name>
				<Source><![CDATA[
    private static CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria populateTmpRetailStoreInventoryInfoWithGeoDistance(
        CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria,
        TmpRetailStoreInventoryInfo tmpRetailStoreInventoryInfo,
        System.Collections.ArrayList resultList)
    {
        const str action = 'Populating TmpRetailStoreInventoryInfo with geo distance';
        eventSource.EventWriteInventoryLookupV3ActionBegin(action);
        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Reset();
        stopWatch.Start();

        LogisticsAddressLatitude currentStoreLatitude;
        LogisticsAddressLongitude currentStoreLongitude;

        // In sorting by distance scenario, there is implicit assumption that both the source and destination should have geo location configured in order to calculate distance value.
        // However geo location is not hard requirement for inventory, so we should handle the case when it is missing instead of throwing error.
        boolean isDistanceSourceLocationFound = true;

        // Get the current store.
        select forupdate firstonly tmpRetailStoreInventoryInfo
            where tmpRetailStoreInventoryInfo.StoreRecId == searchCriteria.ChannelId;
        isDistanceSourceLocationFound = tmpRetailStoreInventoryInfo.IsLocationFound;
        currentStoreLatitude = tmpRetailStoreInventoryInfo.Latitude;
        currentStoreLongitude = tmpRetailStoreInventoryInfo.Longitude;

        if (!isDistanceSourceLocationFound)
        {
            eventSource.EventWriteInventoryLookupCurrentStoreValidLocationSearchFailed(searchCriteria.ChannelId);

            // If sort by distance when current store location is missing, we will sort the non-current locations by name in ascending order instead.
            eventSource.EventWriteInventoryLookupSortOptionFallback();
            var sortingInfoFallback = new CRT.DataModel.SortingInfo(LocationNameSortColumnName);
            searchCriteria = new CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria(
                    searchCriteria.ItemId, searchCriteria.VariantId, searchCriteria.ChannelId, searchCriteria.IncludeWarehouses,
                    searchCriteria.Paging, sortingInfoFallback, searchCriteria.OrgUnitAvailabilitySearchCriteria);

            // Skip calculating geo distance in this case.
            return searchCriteria;
        }

        GeoCoordinate currentStoreGeoCoordinate = new GeoCoordinate(currentStoreLatitude, currentStoreLongitude);
        RecordInsertList tmpRetailStoreInventoryInfoList = new RecordInsertList(
            tableNum(TmpRetailStoreInventoryInfo),
            true, // skip insert
            true, // skip database log
            true, // skip events
            true, // skip aos validation
            true, // skip RLS validation
            tmpRetailStoreInventoryInfo); // buffer where records will be inserted

        select count(RecId) from tmpRetailStoreInventoryInfo;
        int tableCount = tmpRetailStoreInventoryInfo.RecId;

        int times = 1;
        // Calculate geo distance for the stores.
        while select tmpRetailStoreInventoryInfo
        {
            // Stop loop after all records in origin temp table are iterated. 
            // In case of endless fetch and insert caused by unknown reason, which existed once in an environment.
            if (times > tableCount)
            {
                eventSource.EventWriteInventoryLookupV3OptimizedStopLoop(tableCount);
                break;
            }

            times ++;
            boolean isWarehouse = tmpRetailStoreInventoryInfo.IsWarehouse;

            // When destination location is missing, we will treat it as the farthest from the source location.
            boolean isDistanceDestinationLocationFound = tmpRetailStoreInventoryInfo.IsLocationFound;
            GeoCoordinate geoCoordinate;
            real geoDistance = realMax();

            // If sort by distance, always put the source store on top of the result list if it is in the fulfillment group, unless org unit availability search criteria is applied.
            if (tmpRetailStoreInventoryInfo.StoreRecId == searchCriteria.ChannelId
                && searchCriteria.OrgUnitAvailabilitySearchCriteria == null && tmpRetailStoreInventoryInfo.StoreRecId != 0)
            {
                geoDistance = realMin();
            }
            else if (isDistanceDestinationLocationFound)
            {
                geoCoordinate = new GeoCoordinate(tmpRetailStoreInventoryInfo.Latitude, tmpRetailStoreInventoryInfo.Longitude);

                if (isDistanceSourceLocationFound)
                {
                    geoDistance = geoCoordinate.GetDistanceTo(currentStoreGeoCoordinate);
                }
            }
            tmpRetailStoreInventoryInfo.Distance = geoDistance;
            tmpRetailStoreInventoryInfoList.add(tmpRetailStoreInventoryInfo);
        }

        delete_from tmpRetailStoreInventoryInfo;

        // Insert new rows with geo distance.
        tmpRetailStoreInventoryInfoList.insertDatabase();

        stopWatch.Stop();
        int64 durationInMs = stopWatch.ElapsedMilliseconds;
        eventSource.EventWriteInventoryLookupV3ActionEnd(action, durationInMs);

        return searchCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sortTmpRetailStoreInventoryInfo</Name>
				<Source><![CDATA[
    private static void sortTmpRetailStoreInventoryInfo(
        CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria,
        TmpRetailStoreInventoryInfo tmpRetailStoreInventoryInfo,
        System.Collections.ArrayList resultList)
    {
        const str action = 'Sorting and paginating results';
        eventSource.EventWriteInventoryLookupV3ActionBegin(action);
        System.Diagnostics.Stopwatch stopWatch = new System.Diagnostics.Stopwatch();
        stopWatch.Reset();
        stopWatch.Start();

        QueryRun qr = RetailTransactionServiceInventory::buildInventoryLookupQueryRun(searchCriteria, true);
        // Required for temp table to work with QueryRun.
        qr.setRecord(tmpRetailStoreInventoryInfo);

        while (qr.next())
        {
            tmpRetailStoreInventoryInfo = qr.get(tableNum(TmpRetailStoreInventoryInfo));

            TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();

            inventoryInfo.ItemId = searchCriteria.ItemId;
            inventoryInfo.InventoryLocationId = tmpRetailStoreInventoryInfo.InventLocationId;
            inventoryInfo.StoreName = tmpRetailStoreInventoryInfo.Name;
            inventoryInfo.IsWarehouse = tmpRetailStoreInventoryInfo.IsWarehouse;

            inventoryInfo.InventoryAvailable = num2Str(tmpRetailStoreInventoryInfo.AvailPhysical, 0, 16, 1, 0);
            inventoryInfo.OrderedSum = num2Str(tmpRetailStoreInventoryInfo.OrderedSum, 0, 16, 1, 0);
            inventoryInfo.PhysicalReserved = num2Str(tmpRetailStoreInventoryInfo.PhysicalReserved, 0, 16, 1, 0);

            resultList.Add(inventoryInfo);
        }
        
        stopWatch.Stop();
        int64 durationInMs = stopWatch.ElapsedMilliseconds;
        eventSource.EventWriteInventoryLookupV3ActionEnd(action, durationInMs);
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetProductAvailabilityByDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get available to a product by dimensions.
    /// </summary>
    /// <param name = "_itemAvailabilityParameterXmlStr">Xml string containing the inventory availability lookup parameters.
    /// [_root]
    ///     <InventLocations>
    ///       <InventLocation Id="HOUSTON" />
    ///       <InventLocation Id="BOSTON" />
    ///     </InventLocations>
    ///     <Product Id="23456" />
    ///     <ProductDimensionCombinations>
    ///       <ProductDimensionCombination>
    ///         <ProductDimension DimensionType="Color" DimensionValue="Red"/>
    ///         <ProductDimension DimensionType="Style" DimensionValue="Men"/>
    ///       </ProductDimensionCombination>
    ///     </ProductDimensionCombinations>
    /// [/_root]
    /// </param>
    /// <returns>A container which contains status, errMsg and Serialized collection of <c>Microsoft.Dynamics.Commerce.Runtime.DataModel.OrgUnitAvailability</c>.</returns>
    public static container GetProductAvailabilityByDimensions(str _itemAvailabilityLookupParamXmlStr)
    {
        int infoLogIndex;
        container output = [false, ''];

        try
        {
            infoLogIndex = Global::infologLine();

            RetailRTSItemAvailabilityParameter itemAvailabilityParameter = RetailRTSItemAvailabilityParameter::fromXML(_itemAvailabilityLookupParamXmlStr);
            
            // for each inventory location retrieve the inventory information of the
            // product variants specified by the given product dimensions.
            str dimensionType, dimensionValue;
            System.Collections.ArrayList resultList = new System.Collections.ArrayList();

            ListEnumerator inventLocationIdEnum = itemAvailabilityParameter.parmInventLocationIdEnum();
            while (inventLocationIdEnum.moveNext())
            {
                InventLocation inventLocation;

                select InventSiteId, InventLocationId from inventLocation
                    where inventLocation.InventLocationId == inventLocationIdEnum.current();

                ListEnumerator productDimensionCombinationEnumerator = itemAvailabilityParameter.parmProductDimensionCombinationEnum();
                while (productDimensionCombinationEnumerator.moveNext())
                {
                    EcoResItemSizeName inventSizeId;
                    EcoResItemColorName inventColorId;
                    EcoResItemStyleName inventStyleId;
                    EcoResItemVersionName inventVersionId;
                    EcoResItemConfigurationName configId;

                    List productDimensionCombination = productDimensionCombinationEnumerator.current();
                    ListEnumerator productDimensionEnumerator = productDimensionCombination.getEnumerator();
                    while (productDimensionEnumerator.moveNext())
                    {
                        [dimensionType, dimensionValue] = productDimensionEnumerator.current();
                        switch (dimensionType)
                        {
                            case 'Size':
                                inventSizeId = dimensionValue;
                                break;
                            case 'Color':
                                inventColorId = dimensionValue;
                                break;
                            case 'Style':
                                inventStyleId = dimensionValue;
                                break;
                            case 'Version':
                                inventVersionId = dimensionValue;
                                break;
                            case 'Configuration':
                                configId = dimensionValue;
                                break;
                        }
                    }

                    InventDim inventDim = RetailTransactionServiceInventory::getInventDimFromDimensions(
                            inventSizeId,
                            inventColorId,
                            inventStyleId,
                            inventVersionId,
                            configId,
                            inventLocation);

                    TS.InventoryInfo variantInventoryInfo = RetailTransactionServiceInventory::getInventoryInfo(
                        itemAvailabilityParameter.parmItemId(),
                        inventDim,
                        itemAvailabilityParameter.parmIsSizeActive(),
                        itemAvailabilityParameter.parmIsColorActive(),
                        itemAvailabilityParameter.parmIsStyleActive(),
                        itemAvailabilityParameter.parmIsVersionActive(),
                        itemAvailabilityParameter.parmIsConfigActive());

                    resultList.Add(variantInventoryInfo);
                }
            }

            // Serialize the data-contract list using the specified type list.
            System.Type[] typeArray = new System.Type[1]();
            TS.InventoryInfo inventoryInfo = new TS.InventoryInfo();
            typeArray.SetValue(inventoryInfo.GetType(), 0);
            output = [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
        }
        catch(Exception::Error)
        {
            str error = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetProductAvailabilityError(axCallStack, "@RET2382");
            output = [false, error, ''];
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventDimFromDimensions</Name>
				<Source><![CDATA[
    private static InventDim getInventDimFromDimensions(
            EcoResItemSizeName _inventSizeId,
            EcoResItemColorName _inventColorId,
            EcoResItemStyleName _inventStyleId,
            EcoResItemVersionName _inventVersionId,
            EcoResItemConfigurationName _configId,
            InventLocation _location)
    {
        InventDim inventDimBuffer;
        InventDim inventDim;

        inventDimBuffer.InventSizeId      = _inventSizeId;
        inventDimBuffer.InventColorId     = _inventColorId;
        inventDimBuffer.InventStyleId     = _inventStyleId;
        inventDimBuffer.InventVersionId   = _inventVersionId;
        inventDimBuffer.ConfigId          = _configId;
        inventDimBuffer.InventSiteId      = _location.InventSiteId;
        inventDimBuffer.InventLocationId  = _location.InventLocationId;

        inventDim = InventDim::findDim(inventDimBuffer);
        if (inventDim.RecId > 0)
            return inventDim;
        else
            return inventDimBuffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory information of the item for the specified dimensions.
    /// </summary>
    /// <param name = "_itemId">The item Id.</param>
    /// <param name = "_inventDim">The inventory dimension buffer.</param>
    /// <param name = "_isSizeActive">The inventory size dimension active flag.</param>
    /// <param name = "_isColorActive">The inventory color dimension active flag.</param>
    /// <param name = "_isStyleActive">The inventory style dimension active flag.</param>
    /// <param name = "_isVersionActive">The inventory version dimension active flag.</param>
    /// <param name = "_isConfigActive">The inventory configuration dimension active flag.</param>
    /// <returns>The inventory information.</returns>
    /// <remarks>If any of the dimension is active for the item but is not set the inventory information
    /// will be aggregated based on that provided dimensions, else if all active dimensions are set and the product is not released then return null.</remarks>
    private static TS.InventoryInfo getInventoryInfo(
            ItemId _itemId,
            InventDim _inventDim,
            boolean _isSizeActive,
            boolean _isColorActive,
            boolean _isStyleActive,
            boolean _isVersionActive,
            boolean _isConfigActive)
    {
        InventDimParm inventDimParm;
        InventDimCombination inventDimCombination;
        InventQty availPhysical;
        InventOnhand inventOnhand;
        TS.InventoryInfo inventoryInfo;

        // check if the variant is released or not
        inventDimCombination = InventDimCombination::findByInventDim(_itemId, _inventDim);

        // populate inventoryInfo when the variant is released or any active dimension is not set,
        // check active dimensions is for returning summarized data
        if (inventDimCombination
            || (_isSizeActive && _inventDim.InventSizeId == '')
            || (_isColorActive && _inventDim.InventColorId == '')
            || (_isStyleActive && _inventDim.InventStyleId == '')
            || (_isVersionActive && _inventDim.InventVersionId == '')
            || (_isConfigActive && _inventDim.configId == ''))
        {
            inventoryInfo = new TS.InventoryInfo();
            inventDimParm.initFromInventDim(_inventDim);
            inventOnhand  = InventOnhand::newItemDim(_itemId, _inventDim, inventDimParm);
            availPhysical = inventOnhand.availPhysical();
            inventoryInfo.ItemId = _itemId;
            inventoryInfo.InventoryLocationId = _inventDim.InventLocationId;
            inventoryInfo.InventoryAvailable = num2Str(availPhysical, 0, 16, 1, 0);
            inventoryInfo.OrderedSum = num2Str(inventOnhand.orderedSum(), 0, 16, 1, 0);
            inventoryInfo.PhysicalReserved = num2Str(inventOnhand.reservPhysical(), 0, 16, 1, 0);
        }
        else
        {
            // return null when the variant is not released and all active dimensions are set
            inventoryInfo = null;
        }

        return inventoryInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAvailableToPromiseInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get available to promise inventory for an item at a channel.
    /// </summary>
    /// <param name = "_productId">The product identifier.</param>
    /// <param name = "_channelId">The channel identifier.</param>
    /// <param name = "_custAccount">The customer account number.</param>
    /// <param name = "_resultsMaxCount">Maximum size of result collection.</param>
    /// <returns></returns>
    public static container GetAvailableToPromiseInventory(EcoResProductRecId _productId, RetailChannelRecId _channelId, CustAccount _custAccount, int _resultsMaxCount)
    {
        InventTable             inventTable;
        InventDimCombination    inventDimCombination;
        InventLocation          inventLocation;
        InventDim               inventDim;
        RetailStoreTable        retailStoreTable;

        SalesATPSettingsMap     salesATPSettingsMap;
        SalesATPCalculation     salesATPCalculation;
        SalesTmpATP             salesTmpATP;
        container               output = [true,''];
        boolean                 success;
        str                     error = '';
        str                     atpDate;
        int                     fromLine;
        int                     resultCount = 0;

        inventTable = InventTable::findByProduct(_productId);
        inventDimCombination = InventDimCombination::findByDistinctProductVariant(_productId);

        select InventSiteId, InventLocationId from inventLocation
            join retailStoreTable
            where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                  inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId &&
                  retailStoreTable.RecId == _channelId;

        inventDim.InventSizeId      = inventDimCombination.inventDim().InventSizeId;
        inventDim.InventColorId     = inventDimCombination.inventDim().InventColorId;
        inventDim.InventStyleId     = inventDimCombination.inventDim().InventStyleId;
        inventDim.InventVersionId   = inventDimCombination.inventDim().InventVersionId;
        inventDim.ConfigId          = inventDimCombination.inventDim().ConfigId;
        inventDim.InventSiteId      = inventLocation.InventSiteId;
        inventDim.InventLocationId  = inventLocation.InventLocationId;

        inventDim = InventDim::findDim(inventDim);

        try
        {
            fromLine = Global::infologLine();
            salesATPSettingsMap = SalesATPCalculation::findSalesOrderSettings(inventTable.ItemId, inventDim.inventDimId);

            salesATPCalculation = SalesATPCalculation::newSalesCalculation(inventTable.ItemId, inventDim.inventDimId, _custAccount);
            salesATPCalculation.parmSalesATPSettingsMap(salesATPSettingsMap);
            salesTmpATP.setTmpData(salesATPCalculation.calcSalesTmpATP());

            while select ATPDate, ATPQty, Receipts, Issues, ProjectedOnhand from salesTmpATP
            {
                if (_resultsMaxCount > resultCount)
                {
                    atpDate = RetailTransactionServiceUtilities::dateToString(salesTmpATP.ATPDate);

                    output = conIns(
                        output,
                        conLen(output) + 1,
                        atpDate,
                        salesTmpATP.ATPQty,
                        salesTmpATP.Receipts,
                        salesTmpATP.Issues,
                        salesTmpATP.ProjectedOnhand
                        );

                    resultCount = resultCount + 1;
                }
                else
                {
                    break;
                }
            }
        }
        catch(Exception::Error)
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetAvailableToPromiseInventoryError(funcName(), axCallStack, "@RET2382");
            throw error("@RET2382");
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetAvailableToPromiseInventoryByWarehouse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get available to promise inventory for an item at an inventory location.
    /// </summary>
    /// <param name = "_xmlArgumentString">Xml document with arguments for ProductId, ItemId, ChannelId, LocationId, CustomerAccountNumber, PagingInfo.
    /// [_root]
    ///     [Arguments]
    ///     [ProductId][/ProductId]
    ///     [ItemId][/ItemId]
    ///     [VariantId][/VariantId]
    ///     [ChannelId][/ChannelId]
    ///     [LocationId][/LocationId]
    ///     [CustomerAccountNumber][/CustomerAccountNumber]
    ///     [PagingInfo][/PagingInfo]
    ///     [/Arguments]
    /// [/_root]
    /// </param>
    /// <returns>Serialized collection of <c>Microsoft.Dynamics.Commerce.Runtime.DataModel.ItemAvailability</c>. </returns>
    public static container GetAvailableToPromiseInventoryByWarehouse(str _xmlArgumentString)
    {
        // args
        RefRecId argProductId;
        ItemId argItemId;
        RetailVariantId argVariantId;
        RetailChannelRecId argChannelId;
        InventLocationId argLocationId;
        CustAccount argCustAccount;
        int argResultsMaxCount, argSkip;

        // args variables
        XmlElement          argsRoot;

        InventTable             inventTable;
        InventDimCombination    inventDimCombination;
        InventLocation          inventLocation;
        InventDim               inventDim;
        RetailStoreTable        retailStoreTable;

        SalesATPSettingsMap     salesATPSettingsMap;
        SalesATPCalculation     salesATPCalculation;
        SalesTmpATP             salesTmpATP;
        container               output = [true,'', ''];
        boolean                 success;
        str                     error = '';
        str                     atpDate;
        str                     inventDimid = '';
        str                     itemId = '';
        int                     resultCount = 0;

        System.Collections.ArrayList resultList = new System.Collections.ArrayList();
        Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryAvailableToPromise entry;

        // Add an ATP result to the collection.
        void addAtpResult(
            str _itemId,
            int64 _product,
            str _inventLocationId,
            real _qty,
            str _uom,
            date _date)
        {
            System.Reflection.PropertyInfo propertyInfo;
            atpDate = RetailTransactionServiceUtilities::dateToString(_date);
                   
            // Add the ATP result to the list
            entry = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryAvailableToPromise();

            propertyInfo = entry.GetType().GetProperty('ItemId');
            if(propertyInfo != null)
            {
                propertyInfo.SetValue(entry, _itemId);
            }

            propertyInfo = entry.GetType().GetProperty('ProductId');
            if(propertyInfo != null)
            {
                propertyInfo.SetValue(entry, _product);
            }

            propertyInfo = entry.GetType().GetProperty('InventoryLocationId');
            if(propertyInfo != null)
            {
                propertyInfo.SetValue(entry, _inventLocationId);
            }

            // InventorySiteId is Internal, can't be set here.
            
            propertyInfo = entry.GetType().GetProperty('AvailableQuantity');
            if(propertyInfo != null)
            {
                propertyInfo.SetValue(entry, _qty);
            }

            propertyInfo = entry.GetType().GetProperty('UnitOfMeasure');
            if(propertyInfo != null)
            {
                propertyInfo.SetValue(entry, _uom);
            }

            propertyInfo = entry.GetType().GetProperty('Date');
            if(propertyInfo != null)
            {
                propertyInfo.SetValue(entry, atpDate);
            }

            resultList.Add(entry);
        }

        //
        // Main method body
        //
        
        try
        {
            // First ensure that we can instantiate the InventoryAvailableToPromise type.
            entry = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryAvailableToPromise();

            // Parse the arguments
            argsRoot = RetailTransactionServiceUtilities::ParseRootElement(_xmlArgumentString);
            if (argsRoot != null)
            {
                argProductId = str2Int64(RetailTransactionServiceUtilities::GetValue(argsRoot, 'ProductId'));
                argItemId = RetailTransactionServiceUtilities::GetValue(argsRoot, 'ItemId');
                argVariantId = RetailTransactionServiceUtilities::GetValue(argsRoot, 'VariantId');
                argChannelId = str2Int64(RetailTransactionServiceUtilities::GetValue(argsRoot, 'ChannelId'));
                argLocationId = RetailTransactionServiceUtilities::GetValue(argsRoot, 'LocationId');
                argCustAccount = RetailTransactionServiceUtilities::GetValue(argsRoot, 'CustomerAccountNumber');
                [argSkip, argResultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsRoot.ownerDocument());
            }

            // Lookup the product.
            if (argProductId)
            {
                //Lookup by Product Id
                inventTable = InventTable::findByProduct(argProductId);
                inventDimCombination = InventDimCombination::findByDistinctProductVariant(argProductId);
            }
            else if (argItemId)
            {
                // Lookup by Item + Variant number
                inventTable = InventTable::find(argItemId);
                inventDimCombination = InventDimCombination::findVariantId(argVariantId);
            }

            if (inventTable || inventDimCombination)
            {
                if (argChannelId)
                {
                    // By Channel
                    select firstonly InventSiteId, InventLocationId from inventLocation
                    join retailStoreTable
                    where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                          inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId &&
                          retailStoreTable.RecId == argChannelId;
                }
                else if (argLocationId)
                {
                    // By InventLocation
                    inventLocation = InventLocation::find(argLocationId);
                }

                // Get InventDim
                inventDim.InventSizeId      = inventDimCombination.inventDim().InventSizeId;
                inventDim.InventColorId     = inventDimCombination.inventDim().InventColorId;
                inventDim.InventStyleId     = inventDimCombination.inventDim().InventStyleId;
                inventDim.InventVersionId   = inventDimCombination.inventDim().InventVersionId;
                inventDim.ConfigId          = inventDimCombination.inventDim().ConfigId;
                inventDim.InventSiteId      = inventLocation.InventSiteId;
                inventDim.InventLocationId  = inventLocation.InventLocationId;
                inventDim = InventDim::findOrCreate(inventDim);
                
                itemId = argItemId ? argItemId : inventTable.ItemId;

                // Calculate ATP
                salesATPSettingsMap = SalesATPCalculation::findSalesOrderSettings(itemId, inventDim.inventDimId);
                salesATPCalculation = SalesATPCalculation::newSalesCalculation(itemId, inventDim.inventDimId, argCustAccount);
                salesATPCalculation.parmSalesATPSettingsMap(salesATPSettingsMap);
                salesTmpATP.setTmpData(salesATPCalculation.calcSalesTmpATP());
            
                while select ATPDate, ATPQty, Receipts, Issues, ProjectedOnhand from salesTmpATP
                {
                    if (argResultsMaxCount > resultCount)
                    {
                        addATPResult(
                            inventTable.ItemId,
                            inventTable.Product,
                            InventLocation.InventLocationId,
                            SalesTmpATP.ATPQty,
                            inventTable.salesUnitId(),
                            salesTmpATP.ATPDate);

                        resultCount = resultCount + 1;
                    }
                    else
                    {
                        break;
                    }
                }

                // If nothing was found, then pad the results with a 'zero' result.
                if (resultCount == 0)
                {
                    addATPResult(
                        inventTable.ItemId,
                        inventTable.Product,
                        InventLocation.InventLocationId,
                        0,  // Zero available to promise quantity.
                        inventTable.salesUnitId(),
                        DateTimeUtil::date(DateTimeUtil::utcNow()));
                }
            }

            // Serialize the data-contract list using the specified type list.
            System.Type[] typeArray = new System.Type[1]();
            typeArray.SetValue(entry.GetType(), 0);
            output = [true, '', RetailTransactionServiceJsonHelper::SerializeToJson(resultList, typeArray)];
        }
        catch (Exception::Error)
        {
            error = infolog.text(Global::infologLine());
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetAvailableToPromiseInventoryError(funcName(), axCallStack, "@RET2382");
            output = [false, error];
        }
        catch (Exception::Internal)
        {
            // Trace the detailed CLR error
            System.Exception ex = CLRInterop::getLastException();

            if (ex && ex.InnerException)
            {
                if (ex.InnerException.InnerException)
                {
                    // Use inner exception if it is available as it is often more descriptive.
                    error = ex.InnerException.InnerException.Message;
                }
                else
                {
                    error = ex.InnerException.Message;
                }
            }
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetAvailableToPromiseInventoryInternalError(axCallStack, error);
            error = infolog.text(Global::infologLine());
            output = [false, error];
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventoryLookupOnDate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for initializing the fields of <c>InventDim</c> with the values of <c>InventDimCombination</c> fields. Method checks for the
    /// on hand inventory on a specific date.
    /// </summary>
    /// <param name="_itemId">
    /// <c>ItemId</c>
    /// </param>
    /// <param name="_variantId">
    /// ID of the inventDimCombination.RetailVariantId field.
    /// </param>
    /// <param name="_transDate">
    /// A <c>string</c> representing the date for the status of the inventory.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if fail to initialize the values and on check for the available physical inventory.
    /// </exception>
    public static container InventoryLookupOnDate_BR(   ItemId          _itemId,
                                                        RetailVariantId _variantId,
                                                        TransDate       _transDate)
    {
        RetailTransactionService transactionService = new RetailTransactionService();
        InventDimCombination    inventDimCombination = InventDimCombination::findVariantId(_variantId);
        InventDim               inventDim;
        InventDimParm           inventDimParm;
        InventSumDateDim        inventSumDateDim;
        RetailStoreTable        retailStoreTable;
        RetailChannelTable      retailChannelTable;
        DirPartyTable           dirPartyTable;

        container               output = [true,''];
        InventLocation          inventLocation;
        InventQty               availPhysical;

        try
        {
            while select InventLocation from retailStoreTable
                join OMOperatingUnitID from retailChannelTable
                    where retailChannelTable.RecId == retailStoreTable.RecId
                join Name from dirPartyTable
                    where dirPartyTable.RecId == retailChannelTable.omOperatingUnitID
                join InventSiteId, InventLocationId from inventLocation
                    where inventLocation.InventLocationId == retailStoreTable.InventLocation &&
                    inventLocation.DataAreaId == retailStoreTable.InventLocationDataAreaId
            {
                inventDim.InventSizeId      = inventDimCombination.inventDim().InventSizeId;
                inventDim.InventColorId     = inventDimCombination.inventDim().InventColorId;
                inventDim.InventStyleId     = inventDimCombination.inventDim().InventStyleId;
                inventDim.InventVersionId   = inventDimCombination.inventDim().InventVersionId;
                inventDim.ConfigId          = inventDimCombination.inventDim().ConfigId;
                inventDim.InventSiteId      = inventLocation.InventSiteId;
                inventDim.InventLocationId  = inventLocation.InventLocationId;

                inventDim = InventDim::findDim(inventDim);
                if (inventDim.RecId)
                {
                    inventDimParm.initFromInventDim(inventDim);

                    inventSumDateDim = inventSumDateDim::newParameters(_transDate, _itemId, inventDim, inventDimParm);
                    availPhysical = inventSumDateDim.postedQty() + inventSumDateDim.receivedQty() - inventSumDateDim.deductedQty();

                    output = conins(output, conlen(output) + 1, _itemId, inventLocation.InventLocationId, dirPartyTable.Name, availPhysical);
                }
            }
        }
        catch
        {
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryLookupError(funcName(), axCallStack, "@RET2382");
            throw error("@RET2382");
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidItemVariants</Name>
				<Source><![CDATA[
    private static boolean isValidItemVariants(
        ItemId itemId,
        EcoResConfigurationName configId,
        EcoResSizeName sizeId,
        EcoResColorName colorId,
        EcoResStyleName styleId,
        EcoResVersionName versionId)
    {
        boolean              ret = false;

        InventDim            inventDimWithoutLocation;
        InventDimCombination inventDimCombination;

        if (configId || sizeId || colorId || styleId|| versionId)
        {
            select ItemId, InventDimId from inventDimCombination
                join inventDimWithoutLocation
                where inventDimCombination.ItemId == itemId
                    && inventDimCombination.InventDimId == inventDimWithoutLocation.InventDimId
                    && inventDimWithoutLocation.ConfigId == configId
                    && inventDimWithoutLocation.InventSizeId == sizeId
                    && inventDimWithoutLocation.InventColorId == colorId
                    && inventDimWithoutLocation.InventStyleId == styleId
                    && inventDimWithoutLocation.InventVersionId == versionId;

            if (inventDimWithoutLocation)
            {
                ret = true;
            }
        }
        else
        {
            select firstonly ItemId, DistinctProductVariant from inventDimCombination
                 where inventDimCombination.ItemId == itemId && inventDimCombination.DistinctProductVariant != 0;

            if (!inventDimCombination)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update an inventory journal document in AX
    /// </summary>
    /// <param name="ijXmlStr">
    /// An XML string with inventory journal line information
    /// </param>
    /// <returns>
    /// A container object with True or False as the first element
    /// </returns>
    /// <remarks>
    /// This method is used to update the counting journal on AX
    /// </remarks>
    public static container updateInventoryJournal(str ijXmlStr)
    {
        container           resultContainer        = [false, "", ""];
        XmlDocument         ijXml;
        XmlElement          xmlRoot;

        XmlElement          xmlRecord;

        XmlNodeList         xmlRecordList;
        RecId               lineRecId, productRecId;
        ItemId              itemId;
        DataAreaId          dataAreaId;
        Qty                 qtyCounted;
        InventDimId         inventDimId;
        InventDim           inventDimIn;
        InventSiteId        siteId;
        InventLocationId    storeId;
        WMSLocationId       warehouseLocationId;
        EcoResConfigurationName     configId;
        EcoResSizeName      sizeId;
        EcoResColorName     colorId;
        EcoResStyleName     styleId;
        EcoResVersionName   versionId;
        InventSerialId      serialId;
        int                 i;

        InventJournalId     journalId;
        InventJournalTrans  ijLine;
        InventJournalTable  inventJournal;
        InventMov_Journal   inventMovement;
        int                 fromLine, currentFromLine, tmpFromLine;
        str                 error = '';
        str                 tmpError;
        str                 currentError;
        str                 personnelNumber, journalPersonnelNumber;
        str                 journalDescription;
        RetailQuantityCommitMode   quantityCommitMode;
        str                 quantityCommitModeStr;
        Map                 workerMap, productMap;

        try
        {
            fromLine = Global::infologLine();

            ijXml    = new XmlDocument();

            ijXml.loadXml(ijXmlStr);

            xmlRoot = ijXml.getNamedElement(tableStr(InventJournalTable));
            if (!xmlRoot)
            {
                // Invalid root node provided in API call
                eventSource.EventWriteInventoryNotValidRootNodeWarning(funcName(), ijXml.documentElement().name());
                return  RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(xmlRoot, "@Retail:RealTimeServiceInputRootNode", ijXml);
            }

            journalId = xmlRoot.getAttribute(fieldStr(InventJournalTable, JournalId));
            journalPersonnelNumber = xmlRoot.getAttribute(fieldStr(HcmWorker, PersonnelNumber));
            journalDescription = xmlRoot.getAttribute(fieldStr(InventJournalTable, Description));

            quantityCommitModeStr = xmlRoot.getAttribute(RetailTransactionServiceInventory::QuantityCommitModeKey);
            quantityCommitMode = str2Enum(quantityCommitMode, quantityCommitModeStr);
            eventSource.EventWriteRetailQuantityCommitMode(quantityCommitModeStr);

            inventJournal = InventJournalTable::find(journalId);
            if (!inventJournal)
            {
                return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(xmlRoot, "@RET260680", ijXml);
            }
            else if (inventJournal.Posted == NoYes::Yes)
            {
                return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(xmlRoot, "@RET260681", ijXml);
            }

            xmlRecordList = xmlRoot.childNodes();
            workerMap = new Map(Types::String, Types::Int64);
            productMap = new Map(Types::Int64, Types::AnyType);

            for (i=0; i < xmlRecordList.length(); i++)
            {
                try
                {
                    tmpError = '';
                    tmpFromLine = Global::infologLine();
                    xmlRecord = xmlRecordList.item(i);

                    productRecId = str2Int64(xmlRecord.getAttribute(RetailTransactionServiceInventory::ProductRecordIdAttributeName));
                    lineRecId = str2int64(xmlRecord.getAttribute(fieldStr(InventJournalTrans, RecId)));
                    qtyCounted = str2num(xmlRecord.getAttribute(fieldStr(InventJournalTrans, Counted)));
                    personnelNumber = xmlRecord.getAttribute(fieldStr(HcmWorker, PersonnelNumber));

                    if (lineRecId > 0)
                    {
                        // Allow update even if qty is 0, to update Qty and other properties
                        if (qtyCounted >= 0)
                        {
                            ttsbegin;
                            select firstOnly1 forupdate ijLine
                                where ijLine.RecId == lineRecId;

                            if (ijLine)
                            {
                                if (quantityCommitMode == RetailQuantityCommitMode::Assign)
                                {
                                    ijLine.Counted = qtyCounted;
                                }
                                else 
                                {
                                    ijLine.Counted += qtyCounted;
                                }
                                ijLine.Qty = decRound(ijLine.Counted, InventTable::inventDecimals(ijLine.ItemId)) - ijLine.InventOnHand;
                                ijLine.CostAmount = ijLine.calcCostAmount(ijLine.Qty);
                                RetailTransactionServiceInventory::updateWorkerOnInventJournalTrans(workerMap, personnelNumber, ijLine);

                                ijLine.update();
                            }
                            ttscommit;
                        }
                    }
                    else
                    {
                        itemId = xmlRecord.getAttribute(fieldStr(InventJournalTrans, ItemId));
                        dataAreaId = xmlRecord.getAttribute(fieldStr(InventJournalTrans, DataAreaId));
                        inventDimId = xmlRecord.getAttribute(fieldStr(InventDim, InventDimId));
                        storeId = xmlRecord.getAttribute(fieldStr(InventDim, InventLocationId));
                        siteId = InventLocation::find(storeId).InventSiteId;
                        configId = xmlRecord.getAttribute(fieldStr(InventDim, ConfigId));
                        sizeId = xmlRecord.getAttribute(fieldStr(InventDim, InventSizeId));
                        colorId = xmlRecord.getAttribute(fieldStr(InventDim, InventColorId));
                        styleId = xmlRecord.getAttribute(fieldStr(InventDim, InventStyleId));
                        versionId = xmlRecord.getAttribute(fieldStr(InventDim, InventVersionId));
                        serialId = xmlRecord.getAttribute(fieldStr(InventDim, InventSerialId));

                        if (RetailTransactionServiceInventory::isItemLocationControlled(itemId))
                        {
                            warehouseLocationId = xmlRecord.getAttribute(fieldStr(InventDim, wMSLocationId));
                            // Set the default warehouse location when location controlled item doesn't have one for counting journal to post correctly.
                            if (!warehouseLocationId)
                            {
                                warehouseLocationId = InventLocation::find(storeId).RBODefaultWMSLocationId;
                            }
                        }
                        else
                        {
                            // Reset any location set from POS for items that are not location controlled.
                            warehouseLocationId = '';
                        }

                        if (!inventDimId)
                        {
                            if (!RetailTransactionServiceInventory::isValidItemVariants(itemId, configId, sizeId, colorId, styleId, versionId))
                            {
                                RetailTransactionServiceInventory::addUpdateFailure(xmlRecord, "@SYS97674");
                                continue;
                            }

                            inventDimIn.initValue();
                            inventDimIn.InventSiteId = siteId;
                            inventDimIn.InventLocationId = storeId;
                            inventDimIn.ConfigId = configId;
                            inventDimIn.InventSizeId = sizeId;
                            inventDimIn.InventColorId = colorId;
                            inventDimIn.InventStyleId = styleId;
                            inventDimIn.InventVersionId = versionId;
                            inventDimIn.InventSerialId = serialId;
                            inventDimIn.wMSLocationId = warehouseLocationId;

                            inventDimIn = InventDim::findOrCreate(inventDimIn);

                            inventDimId = inventDimIn.InventDimId;
                        }

                        ttsbegin;
                        select firstOnly1 forupdate ijLine
                            where ijLine.JournalId == journalId
                                && ijLine.ItemId == itemId
                                && ijLine.InventDimId == inventDimId;

                        if (ijLine)
                        {
                            if (quantityCommitMode == RetailQuantityCommitMode::Assign)
                            {
                                ijLine.Counted = qtyCounted;
                            }
                            else
                            {
                                ijLine.Counted += qtyCounted;
                            }
                            ijLine.Qty = decRound(ijLine.Counted, InventTable::inventDecimals(ijLine.ItemId)) - ijLine.InventOnHand;
                            ijLine.CostAmount = ijLine.calcCostAmount(ijLine.Qty);
                            RetailTransactionServiceInventory::updateWorkerOnInventJournalTrans(workerMap, personnelNumber, ijLine);

                            ijLine.update();
                        }
                        else
                        {
                            ijLine.JournalId = journalId;
                            ijLine.JournalType = InventJournalType::Count;
                            ijLine.ItemId = itemId;
                            // Set default inventDimId if it is null.
                            ijLine.setInventDimId(inventDimId);
                            if (quantityCommitMode == RetailQuantityCommitMode::Assign)
                            {
                                ijLine.Counted = qtyCounted;
                            }
                            else
                            {
                                ijLine.Counted += qtyCounted;
                            }
                            ijLine.TransDate = DateTimeUtil::getToday(DateTimeUtil::getUserPreferredTimeZone());
                            RetailTransactionServiceInventory::updateWorkerOnInventJournalTrans(workerMap, personnelNumber, ijLine);
                            inventMovement = ijLine.inventMovement();
                            inventMovement.journalSetItemId(inventDimIn);
                            if (configId)
                            {
                                inventMovement.journalSetInventDimField(inventDimIn, fieldNum(InventDim, ConfigId));
                            }
                            if (colorId)
                            {
                                inventMovement.journalSetInventDimField(inventDimIn, fieldNum(InventDim, InventColorId));
                            }
                            if (sizeId)
                            {
                                inventMovement.journalSetInventDimField(inventDimIn, fieldNum(InventDim, InventSizeId));
                            }
                            if (styleId)
                            {
                                inventMovement.journalSetInventDimField(inventDimIn, fieldNum(InventDim, InventStyleId));
                            }
                            if (versionId)
                            {
                                inventMovement.journalSetInventDimField(inventDimIn, fieldNum(InventDim, InventVersionId));
                            }
                            if (serialId)
                            {
                                inventMovement.journalSetInventDimField(inventDimIn, fieldNum(InventDim, InventSerialId));
                            }

                            ijLine.Qty = decRound(ijLine.Counted, InventTable::inventDecimals(ijLine.ItemId)) - ijLine.InventOnHand;
                            ijLine.CostAmount = ijLine.calcCostAmount(ijLine.Qty);
                            ijLine.insert();
                        }
                        
                        ttscommit;
                    }

                    xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::TrueStr);
                    xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, '');
                }
                catch (Exception::Error)
                {
                    if (xmlRecord != null)
                    {
                        tmpError = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(tmpFromLine));
                        RetailTransactionServiceInventory::addUpdateFailure(xmlRecord, tmpError);
                        str axCallStack = con2Str(xSession::xppCallStack());
                        eventSource.EventWriteInventoryUpdateInventoryJournalError(axCallStack, "@RET2382");
                    }
                }
            }

            try
            {
                ttsbegin;
                currentError = '';
                currentFromLine = Global::infologLine();
                inventJournal = InventJournalTable::find(journalId, true);
                InventJournalTable::initTotal(inventJournal);
                inventJournal.IsRetailCommitted = NoYes::Yes;
                RetailTransactionServiceInventory::updateWorkerOnInventJournal(workerMap, journalPersonnelNumber, inventJournal);
                inventJournal.Description = journalDescription;
                inventJournal.update();
                ttscommit;
            }
            catch (Exception::Error)
            {
                if (xmlRoot != null)
                {
                    currentError = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(currentFromLine));
                    RetailTransactionServiceInventory::addUpdateFailure(xmlRoot, currentError);
                    str axCallStack = con2Str(xSession::xppCallStack());
                    eventSource.EventWriteInventoryUpdateInventoryJournalError(axCallStack, "@RET2382");
                }
            }
            resultContainer = [true, "", ijXml.toString()];
        }
        catch (Exception::Error)
        {
            error = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(fromLine));
            resultContainer = [false, error, ''];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryUpdateInventoryJournalError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrderFromXmlRecordListLegacy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the given purchase order lines. (Legacy)
    /// </summary>
    /// <param name = "_xmlRecordList">The purchase order lines.</param>
    /// <param name = "_xmlRoot">The root of the purchase order XML.</param>
    /// <param name = "_poXml">The purchase order XML document.</param>
    /// <param name = "_poRecId">The RecId of the purchase order.</param>
    /// <param name = "_packingSlipId">The packing slip id.</param>
    /// <param name = "_purchId">The purchase id.</param>
    /// <returns>A container having successful flag, error message and updated purchase order XML.</returns>
    /// <remarks>If a line failed to register, other lines will still be received.</remarks>
    private static container updatePurchaseOrderFromXmlRecordListLegacy(
        XmlNodeList _xmlRecordList,
        XmlElement _xmlRoot,
        XmlDocument _poXml,
        RecId _poRecId,
        PackingSlipId _packingSlipId,
        PurchId _purchId)
    {
        str                 tmpError;
        int                 tmpFromLine;
        RecId               lineRecId;
        Qty                 qtyReceiveNow;
        InventDimId         inventDimId;
        InventDim           inventDimIn;
        InventSiteId        siteId;
        InventLocationId    storeId;
        EcoResConfigurationName     configId;
        EcoResSizeName      sizeId;
        EcoResColorName     colorId;
        EcoResStyleName     styleId;
        EcoResVersionName   versionId;
        InventSerialId      serialId;
        WMSLocationId       wmsLocationId;
        WHSInventStatusId   inventoryStatusId;
        WHSLicensePlateId   licensePlateId;
        PurchUnit           unit;
        PurchLine           poLine;
        boolean             newLineInserted = false;
        container           resultContainer;
        str                 closeLineFlag;

        // Save the line number to be closed.
        Set closeLineNumbers = new Set(Types::Int64);
        TransDate transactionDate;
        if (_xmlRoot.hasAttribute(RetailTransactionServiceInventory::TransactionDateAttributeName))
        {
            transactionDate = str2Date(_xmlRoot.getAttribute(RetailTransactionServiceInventory::TransactionDateAttributeName), DateFormat::MDY);
        }

        PurchTable purchaseOrder = PurchTable::find(_purchId);
        XmlElement xmlRecord = _xmlRecordList.nextNode();
        while (xmlRecord)
        {
            try
            {
                tmpError = '';
                tmpFromLine = Global::infologLine();

                lineRecId = str2int64(xmlRecord.getAttribute(fieldStr(PurchLine, RecId)));
                qtyReceiveNow = str2num(xmlRecord.getAttribute(fieldStr(PurchLine, PurchReceivedNow)));
                unit = xmlRecord.getAttribute(fieldStr(PurchLine, PurchUnit));
                wmsLocationId = xmlRecord.getAttribute('wmsLocationId');
                inventoryStatusId = xmlRecord.getAttribute('InventoryStatusId');
                licensePlateId = xmlRecord.getAttribute('LicensePlateId');
                closeLineFlag = XmlRecord.getAttribute('closed');

                poLine = null;

                if (lineRecId > 0)
                {
                    poLine = PurchLine::findRecId(lineRecId, true);
                }

                // If we find the PoLine, then the line exists in AX and we can receive it.
                if (poLine != null && poLine.RecId > 0)
                {
                    if (strCmp(strUpr(closeLineFlag), 'TRUE') == 0)
                    {
                        closeLineNumbers.add(poLine.LineNumber);
                    }

                    if (qtyReceiveNow > 0)
                    {
                        ttsbegin;
                        if (poLine.PurchUnit != unit && unit != '')
                        {
                            qtyReceiveNow = InventTableModule::unitConvert(poLine.ItemId,
                                                                           ModuleInventPurchSales::Purch,
                                                                           unit,
                                                                           qtyReceiveNow,
                                                                           poLine.InventDimId);
                        }

                        InventDim newInventDim = RetailTransferOrderHandler::createInventDimForReceivingLine(
                                poLine.ItemId,
                                poLine.InventTransId,
                                inventoryStatusId,
                                wmsLocationId,
                                licensePlateId);

                        RetailTransactionServiceInventory::registerPurchaseOrderLine(xmlRecord, qtyReceiveNow, newInventDim, poLine, unit);
                        ttscommit;
                    }
                }
                else
                {
                    if (qtyReceiveNow > 0)
                    {
                        container validateResult = RetailTransactionServiceInventory::validateAddingLineToPurchaseOrder(purchaseOrder, xmlRecord, _xmlRoot, _poXml);
                        if (!conPeek(validateResult, 1))
                        {
                            return validateResult;
                        }

                        RetailTransactionServiceInventory::addLineToPurchaseOrder(purchaseOrder, xmlRecord, qtyReceiveNow, wmsLocationId, licensePlateId, inventoryStatusId);

                        newLineInserted = true;
                    }
                }

                xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::TrueStr);
                xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, '');
            }
            catch (Exception::Error)
            {
                if (xmlRecord != null)
                {
                    tmpError = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(tmpFromLine));
                    RetailTransactionServiceInventory::addUpdateFailure(xmlRecord, tmpError);
                    str axCallStack = con2Str(xSession::xppCallStack());
                    eventSource.EventWriteInventoryUpdatePurchaseOrderError(axCallStack, "@RET2382");
                }
            }

            xmlRecord = _xmlRecordList.nextNode();
        }

        if (newLineInserted)
        {
            VersioningPurchaseOrder versioningPurchaseOrder = VersioningPurchaseOrder::newPurchaseOrder(PurchTable::find(_purchId, true));
            if (versioningPurchaseOrder.getDocumentState() == VersioningDocumentState::Approved)
            {
                versioningPurchaseOrder.confirm();
            }
        }

        // process product receive now, once all lines are registered
        RetailPurchaseOrderHelper helper = RetailPurchaseOrderHelper::construct();
        helper.setPackingSlipIdForReceivingPurchaseOrder(_packingSlipId);
        helper.setCloseLineNumbers(closeLineNumbers);
        helper.setTransactionDate(transactionDate);
        SysOperationStartResult result = helper.receivePurchaseOrder(_purchId);

        // Write final results
        resultContainer = [true, "", _poXml.toString()];

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrderFromXmlRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the given purchase order lines.
    /// </summary>
    /// <param name = "_xmlRecordList">The purchase order lines.</param>
    /// <param name = "_xmlRoot">The root of the purchase order XML.</param>
    /// <param name = "_poXml">The purchase order XML document.</param>
    /// <param name = "_poRecId">The RecId of the purchase order.</param>
    /// <param name = "_packingSlipId">The packing slip id.</param>
    /// <param name = "_purchId">The purchase id.</param>
    /// <returns>A container having successful flag, error message and updated purchase order XML.</returns>
    /// <remarks>If a line failed to register, all the lines will not be received.</remarks>
    private static container updatePurchaseOrderFromXmlRecordList(
        XmlNodeList _xmlRecordList,
        XmlElement _xmlRoot,
        XmlDocument _poXml,
        RecId _poRecId,
        PackingSlipId _packingSlipId,
        PurchId _purchId)
    {
        XmlElement          xmlRecord;
        str                 tmpError;
        int                 tmpFromLine;
        RecId               lineRecId;
        Qty                 qtyReceiveNow;
        WMSLocationId       wmsLocationId;
        WHSInventStatusId   inventoryStatusId;
        WHSInventStatusId   defaultInventoryStatusId;
        WHSLicensePlateId   licensePlateId;
        PurchUnit           unit;
        PurchLine           poLine;
        boolean             newLineInserted = false;
        container           resultContainer;
        str                 closeLineFlag;

        try
        {
            ttsbegin;
            PurchTable purchaseOrder = PurchTable::find(_purchId);
            xmlRecord = _xmlRecordList.nextNode();
            TransDate transactionDate;
            if (_xmlRoot.hasAttribute(RetailTransactionServiceInventory::TransactionDateAttributeName))
            {
                transactionDate = str2Date(_xmlRoot.getAttribute(RetailTransactionServiceInventory::TransactionDateAttributeName), DateFormat::MDY);
            }

            // Save the line number to be closed.
            Set closeLineNumbers = new Set(Types::Int64);

            while (xmlRecord)
            {
                tmpError = '';
                tmpFromLine = Global::infologLine();

                lineRecId = str2int64(xmlRecord.getAttribute(fieldStr(PurchLine, RecId)));
                qtyReceiveNow = str2num(xmlRecord.getAttribute(fieldStr(PurchLine, PurchReceivedNow)));
                unit = xmlRecord.getAttribute(fieldStr(PurchLine, PurchUnit));
                wmsLocationId = xmlRecord.getAttribute('wmsLocationId');
                inventoryStatusId = xmlRecord.getAttribute('InventoryStatusId');
                licensePlateId = xmlRecord.getAttribute('LicensePlateId');
                closeLineFlag = xmlRecord.getAttribute('closed');

                poLine = null;

                if (lineRecId > 0)
                {
                    poLine = PurchLine::findRecId(lineRecId, true);
                }

                // If we find the PoLine, then the line exists in AX and we can receive it.
                if (poLine != null && poLine.RecId > 0)
                {
                    if (strCmp(strUpr(closeLineFlag), 'TRUE') == 0)
                    {
                        closeLineNumbers.add(poLine.LineNumber);
                    }

                    if (qtyReceiveNow > 0)
                    {
                        if (poLine.PurchUnit != unit && unit != '')
                        {
                            qtyReceiveNow = InventTableModule::unitConvert(poLine.ItemId,
                                                                               ModuleInventPurchSales::Purch,
                                                                               unit,
                                                                               qtyReceiveNow,
                                                                               poLine.InventDimId);
                        }

                        InventDim newInventDim = RetailTransferOrderHandler::createInventDimForReceivingLine(
                                poLine.ItemId,
                                poLine.InventTransId,
                                inventoryStatusId,
                                wmsLocationId,
                                licensePlateId);

                        RetailTransactionServiceInventory::registerPurchaseOrderLine(xmlRecord, qtyReceiveNow, newInventDim, poLine, unit);
                    }
                }
                else
                {
                    if (qtyReceiveNow > 0)
                    {
                        container validateResult = RetailTransactionServiceInventory::validateAddingLineToPurchaseOrder(purchaseOrder, xmlRecord, _xmlRoot, _poXml);
                        if (!conPeek(validateResult, 1))
                        {
                            return validateResult;
                        }

                        RetailTransactionServiceInventory::addLineToPurchaseOrder(purchaseOrder, xmlRecord, qtyReceiveNow, wmsLocationId, licensePlateId, inventoryStatusId);

                        newLineInserted = true;
                    }
                }

                xmlRecord.setAttribute(RetailTransactionServiceInventory::UpdatedInAxAttributeName, RetailTransactionServiceInventory::TrueStr);
                xmlRecord.setAttribute(RetailTransactionServiceInventory::MessageAttributeName, '');
                xmlRecord = _xmlRecordList.nextNode();
            }

            if (newLineInserted)
            {
                VersioningPurchaseOrder versioningPurchaseOrder = VersioningPurchaseOrder::newPurchaseOrder(PurchTable::find(_purchId, true));
                if (versioningPurchaseOrder.getDocumentState() == VersioningDocumentState::Approved)
                {
                    versioningPurchaseOrder.confirm();
                }
            }

            // process product receive now, once all lines are registered
            RetailPurchaseOrderHelper helper = RetailPurchaseOrderHelper::construct();
            helper.setPackingSlipIdForReceivingPurchaseOrder(_packingSlipId);
            helper.setCloseLineNumbers(closeLineNumbers);
            helper.setTransactionDate(transactionDate);
            SysOperationStartResult result = helper.receivePurchaseOrder(_purchId);

            ttscommit;

            resultContainer = [true, "", _poXml.toString()];
        }
        catch (Exception::Error)
        {
            tmpError = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(tmpFromLine));
            if (xmlRecord != null)
            {
                RetailTransactionServiceInventory::addUpdateFailure(xmlRecord, tmpError);
            }

            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryUpdatePurchaseOrderError(axCallStack, "@RET2382");
            resultContainer = [false, tmpError, ""];
        }

        // Write final results
        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAddingLineToPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if adding new line to the purchase order is allowed by configuration.
    /// </summary>
    /// <param name = "purchaseOrder">The purchase order.</param>
    /// <param name = "xmlRecord">The purchase order line.</param>
    /// <param name = "poRoot">The root of the purchase orderXML.</param>
    /// <param name = "poDocument">The purchase order XML document.</param>
    /// <returns>
    /// Returns a container with the fisrt element as true if adding is allowed,
    /// else returns a container with a false flag, error message and the purchase order xml.
    /// </returns>
    public static container validateAddingLineToPurchaseOrder(PurchTable purchaseOrder, XmlElement xmlRecord, XmlElement poRoot, XmlDocument poDocument)
    {
        container resultContainer = [true, '', ''];
        str lineOriginTypeStringValue = xmlRecord.getAttribute(InventoryDocumentLineOriginTypeAttribute);
        Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentLineOriginType lineOriginType;
        if ('' == lineOriginTypeStringValue || str2Enum(lineOriginType, lineOriginTypeStringValue) != Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentLineOriginType::Channel)
        {
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(poRoot, "@RetailInventory:InventoryChannelOriginTypeRequiredForAddingItemToPurchaseOrder", poDocument);
        }
        if (purchaseOrder.ChangeRequestRequired == NoYes::Yes)
        {
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(poRoot, "@RetailInventory:InventoryDocumentPurchaseOrderChangeRequestRequired", poDocument);
        }
        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventDimForAddingLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles registration of the new inventory dimensions record for adding new order line.
    /// </summary>
    /// <param name="storeId">
    /// The receiving store id.
    /// </param>
    /// <param name="wmsLocationId">
    /// The WHS receiving location id.
    /// </param>
    /// <param name="licensePlateId">
    /// The license plate id.
    /// </param>
    /// <param name="inventoryStatusId">
    /// The inventory status id.
    /// </param>
    /// <param name="product">
    /// The product record for the line.
    /// </param>
    /// <param name="inventDimCombination">
    /// Invent dimension for the product if this product is a variant one.
    /// </param>
    /// <param name="inventTable">
    /// Invent table for the product if this product is a distinct one.
    /// </param>
    /// <returns>
    /// Inventory dimensions.
    /// </returns>
    private static InventDim createInventDimForAddingLine(
        InventLocationId storeId,
        WMSLocationId wmsLocationId,
        WHSLicensePlateId   licensePlateId,
        WHSInventStatusId inventoryStatusId,
        EcoResDistinctProduct product,
        InventDimCombination inventDimCombination,
        InventTable inventTable)
    {
        
        InventLocation inventLocation = InventLocation::find(storeId);
        InventSiteId siteId = inventLocation.InventSiteId;
        
        ItemId itemId;
        InventDim newInventDim;
        if (!product.isDistinctProduct())
        {
            InventDim tmpInventDim = inventDimCombination.inventDim();
            newInventDim.configId = tmpInventDim.configId;
            newInventDim.InventColorId = tmpInventDim.InventColorId;
            newInventDim.InventSizeId = tmpInventDim.InventSizeId;
            newInventDim.InventStyleId = tmpInventDim.InventStyleId;
            newInventDim.InventVersionId = tmpInventDim.InventVersionId;

            itemId = inventDimCombination.ItemId;
        }
        else
        {
            itemId = InventTable.ItemId;
        }

        newInventDim.InventLocationId = storeId;
        newInventDim.InventSiteId = siteId;

        EcoResStorageDimensionGroupRecId storageTrackingDimensionGroup = InventTable::find(itemId).storageDimensionGroup();
        EcoResStorageDimensionGroupFldSetup storageDimensionGroupFldSetup = EcoResStorageDimensionGroupFldSetup::findByDimensionGroupFieldId(storageTrackingDimensionGroup, fieldNum(InventDim, WMSLocationId));
        boolean isItemLocationActive = storageDimensionGroupFldSetup.IsActive;
        if (isItemLocationActive)
        {
            // If the item is storage tracking dimension location active, we set wmsLocationId for it. Otherwise leave it blank.
            newInventDim.wmsLocationId = wmsLocationId != '' ? wmsLocationId : inventLocation.wmsLocationIdDefaultReceipt;
        }

        if (WHSInventEnabled::exist(itemId))
        {
            newInventDim.LicensePlateId = licensePlateId;
            if (inventoryStatusId == '')
            {
                inventoryStatusId = WHSInventStatus::getDefaultInventStatus(storeId).InventStatusId;
            }
            newInventDim.InventStatusId = inventoryStatusId;
        }

        newInventDim = InventDim::findOrCreate(newInventDim);
        return newInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLineToPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add a record to purchase line table with specified purchase order as its order document.
    /// </summary>
    /// <param name="purchaseOrder">
    /// The purchase order to which the line is added.
    /// </param>
    /// <param name="xmlRecord">
    /// The purchase order line.
    /// </param>
    /// <param name="qtyReceiveNow">
    /// The quantity to receive for the line.
    /// </param>
    /// <param name="wmsLocationId">
    /// The WHS receiving location id.
    /// </param>
    /// <param name="licensePlateId">
    /// The license plate id.
    /// </param>
    /// <param name="inventoryStatusId">
    /// The inventory status id.
    /// </param>
    private static void addLineToPurchaseOrder(
        PurchTable purchaseOrder,
        XmlElement xmlRecord,
        Qty qtyReceiveNow,
        WMSLocationId wmsLocationId,
        WHSLicensePlateId licensePlateId,
        WHSInventStatusId inventoryStatusId)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentLineOriginType lineOriginType;
        lineOriginType = str2Enum(lineOriginType, xmlRecord.getAttribute(InventoryDocumentLineOriginTypeAttribute));

        EcoResProductRecId productRecId = str2Int64(xmlRecord.getAttribute(fieldStr(InventTable, Product)));
        EcoResDistinctProduct product = EcoResDistinctProduct::find(productRecId);
        
        ItemId itemId;
        InventDimCombination inventDimCombination;
        InventTable inventTable;
        
        if (!product.isDistinctProduct())
        {
            inventDimCombination = InventDimCombination::findByDistinctProductVariant(productRecId);
            itemId = inventDimCombination.ItemId;
        }
        else
        {
            inventTable = InventTable::findByProduct(productRecId);
            itemId = inventTable.ItemId;
        }

        InventLocationId storeId = xmlRecord.getAttribute(fieldStr(InventDim, InventLocationId));
        // Safe handling - store id may not come, will populate from purchase table.
        if (!storeId)
        {
            storeId = purchaseOrder.InventLocationId;
        }

        InventDim newInventDim = RetailTransactionServiceInventory::createInventDimForAddingLine(
            storeId, wmsLocationId, licensePlateId, inventoryStatusId, product, inventDimCombination, inventTable);

        ttsbegin;
        // Let's update PO line.
        PurchLine poLine;

        // adding a new PO line if one doesn't exists
        poLine.initFromPurchTable(purchaseOrder);
        poLine.ItemId = itemId;
        poLine.initFromItemOrCategory(poLine.ItemId, poLine.ProcurementCategory, poLine.Name);
        poLine.initFromProductDimensions(newInventDim); // Set name, external id, bar code and variant id.
        poLine.InventDimId = newInventDim.inventDimId;
        poLine.PurchUnit = poLine.inventTable().inventUnitId();
        poLine.PurchQty = qtyReceiveNow;
        poLine.QtyOrdered = qtyReceiveNow;
        poLine.IsAddedByChannel = lineOriginType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentLineOriginType::Channel;
        PurchLine::modifyPurchQty(poLine, poLine.inventDim());
        poLine.createLine(true,   //  validation
        true,   //  initFromPurchTable
        false,  //  initFromInventTableModule
        true,   //  calcInventQty
        true,   //  searchMarkup
        true,   //  searchPrice
        false); //  ignorePurchTableInventDim
        ttscommit;

        RetailTransactionServiceInventory::registerPurchaseOrderLine(xmlRecord, qtyReceiveNow, newInventDim, poLine, poLine.PurchUnit);

        xmlRecord.setAttribute(fieldStr(PurchLine, RecId), int642Str(poLine.RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPurchaseOrderLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Register a purchase order line.
    /// </summary>
    /// <param name="xmlRecord">
    /// The purchase order line.
    /// </param>
    /// <param name="qtyReceiveNow">
    /// The quantity to receive for the line.
    /// </param>
    /// <param name="newInventDim">
    /// The invent dimension referenced by the line.
    /// </param>
    /// <param name="poLine">
    /// The purchase order line record.
    /// </param>
    /// <param name="unit">
    /// The purchase unit.
    /// </param>
    private static void registerPurchaseOrderLine(
        XmlElement xmlRecord,
        Qty qtyReceiveNow,
        InventDim newInventDim,
        PurchLine poLine,
        PurchUnit unit)
    {
        ttsbegin;
        // Select all serial number lines into a nodelist
        XmlNodeList serialNumberLineXmlRecordList = xmlRecord.selectNodes(RetailRTSSerialNumberLine::SerialNumberLineName);
        if (serialNumberLineXmlRecordList.length() > 0)
        {
            // If Channel post serial number lines back. Register per serial number line.
            XmlElement serialNumberLineXmlRecord = serialNumberLineXmlRecordList.nextNode();
            while (serialNumberLineXmlRecord)
            {
                str serialNumberLineSourceInventTransRecIdStr = serialNumberLineXmlRecord.getAttribute(RetailRTSSerialNumberLine::SourceInventTransRecIdAttribute);

                InventSerialId serialNumberLineInventSerialId = serialNumberLineXmlRecord.getAttribute(RetailRTSSerialNumberLine::InventSerialIdAttribute);
                InventQty qty = str2num(serialNumberLineXmlRecord.getAttribute(RetailRTSSerialNumberLine::QtyAttribute));

                // For purchase order overreceive scenario, there may be no source invent trans related in HQ.
                if (serialNumberLineSourceInventTransRecIdStr != '')
                {
                    RecId serialNumberLineSourceInventTransRecId = str2int64(serialNumberLineSourceInventTransRecIdStr);
                    InventTrans serialNumberLineSourceInventTrans = InventTrans::findRecId(serialNumberLineSourceInventTransRecId);

                    if (serialNumberLineSourceInventTrans.StatusReceipt == StatusReceipt::Registered)
                    {
                        // This serial number line is already registered.
                        InventDim serialNumberLineSourceInventDim = InventDim::find(serialNumberLineSourceInventTrans.inventDimId);
                        if (strCmp(serialNumberLineSourceInventDim.inventSerialId , serialNumberLineInventSerialId) == 0)
                        {
                            // If the registering serial number is the same with the registered one, we will ignore it and process the next one.
                            serialNumberLineXmlRecord = serialNumberLineXmlRecordList.nextNode();
                            continue;
                        }
                        else
                        {
                            // If the registering serial number is different with the registered one, we will deregister it and register a new one.
                            // For PO we allow POS worker to override registered serial numbers.
                            RetailTransferOrderHandler::registerTransferLine(poLine, serialNumberLineSourceInventDim, -qty, poLine.ItemId);
                        }
                    }
                }

                // Register the serial number from POS.
                newInventDim.inventSerialId = serialNumberLineInventSerialId;
                newInventDim = InventDim::findOrCreate(newInventDim);
                RetailTransferOrderHandler::registerTransferLine(poLine, newInventDim, qty, poLine.ItemId);

                serialNumberLineXmlRecord = serialNumberLineXmlRecordList.nextNode();
            }
        }
        else
        {
            // If Channel does not posted serial number lines back. Register the po line entirely.
            RetailTransferOrderHandler::registerTransferLine(poLine,
                                                                newInventDim,
                                                                InventTableModule::unitConvert(poLine.ItemId,
                                                                                            ModuleInventPurchSales::Invent,
                                                                                            unit,
                                                                                            qtyReceiveNow,
                                                                                            poLine.InventDimId),
                                                                poLine.ItemId);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetInventoryDocumentsCustomFilterRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension field ranges for custom filters of inventroy document search criteria.
    /// </summary>
    /// <param name = "_customFilters">The custom filters.</param>
    /// <param name = "_extensionRanges">List of the containers (extensionFieldName, extensionFieldValue) used to build query ranges for custom filters from extensions.</param>
    static delegate void registerGetInventoryDocumentsCustomFilterRanges(System.Collections.ICollection _customFilters, List _extensionRanges)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetInventoryDocumentsCustomDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to add custom data sources and filters to the search inventory documents.
    /// </summary>
    /// <param name = "_customFilters">The custom filters.</param>
    /// <param name = "_qbds">The search inventory documents query QueryBuildDataSource object that can be used for adding custom datasources and filters</param>
    static delegate void registerGetInventoryDocumentsCustomDataSources(System.Collections.ICollection _customFilters, QueryBuildDataSource _qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPopulateInboundActiveSourceDocumentCustomProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to populate active inventory document custom properties.
    /// </summary>
    /// <param name = "_sourceDocument">The inventory document to populate.</param>
    /// <param name = "_queryResult">The query result from the active inventory document view.</param>
    static delegate void registerPopulateInboundActiveSourceDocumentCustomProperties(CRT.DataModel.InventoryInboundOutboundSourceDocument _sourceDocument, RetailActiveInventoryDocumentsView _queryResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPopulateInboundCompleteSourceDocumentCustomProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to populate complete inventory document custom properties.
    /// </summary>
    /// <param name = "_sourceDocument">The inventory document to populate.</param>
    /// <param name = "_queryResult">The query result from the complete inventory document view.</param>
    static delegate void registerPopulateInboundCompleteSourceDocumentCustomProperties(CRT.DataModel.InventoryInboundOutboundSourceDocument _sourceDocument, RetailCompleteInventoryDocumentsView _queryResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPopulateOutboundTransferOrderCustomProperties</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to populate outbound transfer orders custom properties.
    /// </summary>
    /// <param name = "_sourceDocument">The inventory document to populate.</param>
    /// <param name = "_transferOrder">The transfer order.</param>
    /// <param name = "_aggregatedTransferLine">The aggregates of transfer order lines.</param>
    static delegate void registerPopulateOutboundTransferOrderCustomProperties(CRT.DataModel.InventoryInboundOutboundSourceDocument _sourceDocument, InventTransferTable _transferOrder, InventTransferLine _aggregatedTransferLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePurchaseOrderToBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the purchase order to be updated.
    /// </summary>
    /// <param name = "_purchId">Purchase order PurchId.</param>
    /// <param name = "_poRecId">Purchase order RecId.</param>
    /// <param name = "_driverDetails">Purchase order driver details.</param>
    /// <param name = "_vendorRef">Purchase order VendRef.</param>
    /// <param name = "_poXml">Purchase order XML document.</param>
    /// <param name = "_xmlRoot">Purchase order XML document root element.</param>
    /// <returns>
    /// Container of the validation result. If the 1st element of the container is true,
    /// the validations passed. Otherwise it failed.
    /// </returns>
    private static container validatePurchaseOrderToBeUpdated(
        PurchId _purchId,
        RecId _poRecId,
        RetailDriverDetails _driverDetails,
        VendRef _vendorRef,
        XmlDocument _poXml,
        XmlElement _xmlRoot)
    {
        PurchTable poTable;

        poTable = PurchTable::find(_purchId);
        if (!poTable)
        {
            eventSource.EventWriteInventoryPurchaseOrderNotExistWarning(_poRecId);
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(_xmlRoot, "@RET260678", _poXml);
        }
        else if (poTable.isCanceled())
        {
            eventSource.EventWriteInventoryPurchaseOrderWasCancelledWarning(_poRecId);
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(_xmlRoot, "@RET260682", _poXml);
        }
        else if (poTable.isReceived())
        {
            eventSource.EventWriteInventoryPurchaseOrderAlreadyReceivedWarning(_poRecId);
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(_xmlRoot, "@RET260683", _poXml);
        }
        else if (poTable.isInvoiced())
        {
            eventSource.EventWriteInventoryPurchaseOrderAlreadyInvoicedWarning(_poRecId);
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(_xmlRoot, "@RET260685", _poXml);
        }

        if (_driverDetails || _vendorRef)
        {
            //Return warning that we cannot save driver details and vendor ref.
            eventSource.EventWriteInventoryChangesNotSupportedWarning(_poRecId);
            return RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(_xmlRoot, "@Retail:POHeaderChangesNotSupportedErrorMessage", _poXml);
        }

        return [true, ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a purchase order
    /// </summary>
    /// <param name="poXmlStr">
    /// An XML string for Purchase Order details
    /// </param>
    /// <returns>
    /// A container object to indicate update success or failure
    /// </returns>
    /// <remarks>
    /// This method is used to update a purchase order's receive now quantity
    /// </remarks>
    public static container updatePurchaseOrder(str poXmlStr)
    {
        container           resultContainer        = [false, "", ""];
        XmlDocument         poXml;
        XmlElement          xmlRoot;
        XmlNodeList         xmlRecordList;
        RecId               poRecId;
        ItemId              itemId;
        InventDimId         inventDimId;
        InventDim           inventDimIn;
        InventSiteId        siteId;
        InventLocationId    storeId;
        EcoResConfigurationName     configId;
        EcoResSizeName      sizeId;
        EcoResColorName     colorId;
        EcoResStyleName     styleId;
        InventSerialId      serialId;
        PurchId             purchId;
        RetailDriverDetails driverDetails;
        VendRef             vendorRef;
        PackingSlipId       packingSlipId;
        int                 fromLine, currentFromLine;
        str                 error = '';
        str                 currentError;

        try
        {
            fromLine = Global::infologLine();
            poXml   = new XmlDocument();

            poXml.loadXml(poXmlStr);

            xmlRoot = poXml.getNamedElement(tableStr(PurchTable));
            if (!xmlRoot)
            {
                // Invalid root node provided in API call
                eventSource.EventWriteInventoryNotValidRootNodeWarning(funcName(), poXml.documentElement().name());
                return  RetailTransactionServiceInventory::addUpdateFailureAndGetResultContainer(xmlRoot, "@Retail:RealTimeServiceInputRootNode", poXml);
            }

            purchId = xmlRoot.getAttribute(fieldStr(PurchTable, PurchId));
            poRecId = str2int64(xmlRoot.getAttribute(fieldStr(PurchTable, RecId)));
            driverDetails = xmlRoot.getAttribute(fieldStr(PurchTable, RetailDriverDetails));
            vendorRef = xmlRoot.getAttribute(fieldStr(PurchTable, VendorRef));
            packingSlipId = xmlRoot.getAttribute(fieldStr(VendPackingSlipJour, PackingSlipId));

            resultContainer = RetailTransactionServiceInventory::validatePurchaseOrderToBeUpdated(
                purchId, poRecId, driverDetails, vendorRef, poXml, xmlRoot);
            if (!conPeek(resultContainer, 1))
            {
                return resultContainer;
            }

            // Select all purchase lines into a nodelist
            xmlRecordList = xmlRoot.selectNodes('//PurchLine');

            if (!RetailPurchaseOrderFeatureControl::isLegacyUpdatePurchaseOrderTransactionBehaviorEnabled())
            {
                resultContainer = RetailTransactionServiceInventory::updatePurchaseOrderFromXmlRecordList(
                    xmlRecordList, xmlRoot, poXml, poRecId, PackingSlipId, purchId);
            }
            else
            {
                resultContainer = RetailTransactionServiceInventory::updatePurchaseOrderFromXmlRecordListLegacy(
                    xmlRecordList, xmlRoot, poXml, poRecId, PackingSlipId, purchId);
            }
        }
        catch (Exception::Error)
        {
            error = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(fromLine));
            resultContainer = [false, error, ""];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryUpdatePurchaseOrderError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a transfer order
    /// </summary>
    /// <param name="transferOrderXmlStr">
    /// An Xml string containing details of a transfer order
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure
    /// </returns>
    /// <remarks>
    /// This allows updates for transfer order's ship now and receive now quantities
    /// </remarks>
    public static server container updateTransferOrder(str transferOrderXmlStr)
    {
        container           resultContainer        = [false, "", ""];
        int                 fromLine;

        try
        {
            fromLine = Global::infologLine();
            RetailRTSTransferOrder rtsTransferOrderObject = RetailRTSTransferOrder::fromXML(transferOrderXmlStr);

            InventTransferId transferId = rtsTransferOrderObject.paramTransferId();

            InventTransferTable toTable = InventTransferTable::find(transferId);
            if (!toTable)
            {
                throw error(strFmt("@Retail:CannotFindTransferOrder", transferId));
            }
            else if (!toTable.isEditable())
            {
                throw error(strFmt("@Retail:CannotUpdateTransferOrder", transferId));
            }

            ttsbegin;
            if (rtsTransferOrderObject.hasShipNowQuantity())
            {
                rtsTransferOrderObject.shipTransferLines();
            }
            else if (rtsTransferOrderObject.hasReceiveNowQuantity())
            {
                rtsTransferOrderObject.receiveTransferLines();
            }
            rtsTransferOrderObject.setUpdatedInAX(true);
            resultContainer = [true, '', rtsTransferOrderObject.toXML()];
            ttscommit;
        }
        catch
        {
            str error = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(fromLine));
            resultContainer = [false, error, ""];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryUpdateTransferOrderError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOrUpdateTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update a transfer order or create it if it doesn't exist.
    /// </summary>
    /// <param name="transferOrderXmlStr">
    /// An Xml string containing details of a transfer order.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    /// <remarks>
    /// This allows updates for transfer order's ship now and receive now quantities.
    /// </remarks>
    public static server container createOrUpdateTransferOrder(str transferOrderXmlStr)
    {
        int infoLogIndex;
        container resultContainer = [false, '', ''];

        try
        {
            ttsbegin;
            infoLogIndex = Global::infologLine();

            RetailRTSTransferOrder rtsTransferOrderObject = RetailRTSTransferOrder::fromXML(transferOrderXmlStr);

            InventTransferTable transferOrderTable;
            transferOrderTable = rtsTransferOrderObject.createOrUpdateTransferOrderHeader();

            // create or update transfer order lines if available.
            ListEnumerator transferLinesEnumerator = rtsTransferOrderObject.getTransferOrderLineEnumerator();
            while (transferLinesEnumerator.moveNext())
            {
                RetailRTSTransferOrderLine transferLine = transferLinesEnumerator.current();
                InventTransferLine inventTransferLine = transferLine.createOrUpdateTransferOrderLine(transferOrderTable.TransferId);
                transferLine.updatePropertiesFromTable(inventTransferLine);
            }

            resultContainer = [true, '', rtsTransferOrderObject.toXML()];
            ttscommit;
        }
        catch (Exception::Error)
        {
            str error = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryCreateOrUpdateTransferOrderError(axCallStack, "@RET2382");
            resultContainer = [false, error, ''];
        }
        
        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a list of transfer order lines.
    /// </summary>
    /// <param name="transferOrderXmlStr">
    /// An Xml string containing details of a transfer order.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container createTransferOrderLines(str transferOrderLinesXmlStr)
    {
        int infoLogIndex;
        container resultContainer = [false, '', ''];

        RetailRTSTransferOrder rtsTransferOrderObject;
        try
        {
            ttsbegin;
            infoLogIndex = Global::infologLine();
            rtsTransferOrderObject = RetailRTSTransferOrder::fromXML(transferOrderLinesXmlStr);
            InventTransferTable transferOrder = InventTransferTable::find(rtsTransferOrderObject.paramTransferId());

            if (transferOrder.RecId == 0)
            {
                throw error(strFmt("Can not create transfer order line. Transfer order identifier [%1] does not exist.", rtsTransferOrderObject.paramTransferId()));
            }

            ListEnumerator transferLineEnumerator = rtsTransferOrderObject.getTransferOrderLineEnumerator();
            while (transferLineEnumerator.moveNext())
            {
                infoLogIndex = Global::infologLine();
                RetailRTSTransferOrderLine rtsTransferOrderLineObject;
                try
                {
                    rtsTransferOrderLineObject = transferLineEnumerator.current();

                    if (rtsTransferOrderLineObject.paramRecId() != 0)
                    {
                        throw error("Can not create transfer line with user defined RecordId");
                    }

                    InventTransferLine inventTransferLine;
                    inventTransferLine = RetailRTSTransferOrderLine::createTransferOrderLine(
                            rtsTransferOrderObject.paramTransferId(),
                            rtsTransferOrderLineObject.paramProductRecordId(),
                            rtsTransferOrderLineObject.paramQtyTransfer(),
                            rtsTransferOrderLineObject.paramUnitId(),
                            rtsTransferOrderLineObject.paramInventSerialId(),
                            rtsTransferOrderLineObject.paramInventBatchId(),
                            rtsTransferOrderLineObject.paramInventoryStatusId(),
                            rtsTransferOrderLineObject.paramLicensePlateId());

                    rtsTransferOrderLineObject.updatePropertiesFromTable(inventTransferLine);
                }
                catch (Exception::Error)
                {
                    str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
                    rtsTransferOrderLineObject.setErrorMessage(errorStr);
                }
            }
            rtsTransferOrderObject.paramUpdatedInAX(true);

            resultContainer = [true, "", rtsTransferOrderObject.toXML()];
            ttscommit;
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
            RetailTransactionServiceInventory::addUpdateFailure(rtsTransferOrderObject.paramXmlRoot(), errorStr);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryCreateTransferOrderLinesError(axCallStack, "@RET2382");
            resultContainer = [false, errorStr, rtsTransferOrderObject.getSavedOrderAndConvertToXml()];
            return resultContainer;
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransferOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a list of transfer order lines.
    /// </summary>
    /// <param name="transferOrderXmlStr">
    /// An Xml string containing details of a transfer order.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container updateTransferOrderLines(str transferOrderLinesXmlStr)
    {
        int infoLogIndex;
        container resultContainer = [false, '', ''];

        RetailRTSTransferOrder rtsTransferOrderObject;
        try
        {
            ttsbegin;
            infoLogIndex = Global::infologLine();
            rtsTransferOrderObject = RetailRTSTransferOrder::fromXML(transferOrderLinesXmlStr);
            InventTransferTable transferOrder = InventTransferTable::find(rtsTransferOrderObject.paramTransferId());

            if (transferOrder.RecId == 0)
            {
                throw error(strFmt("Can not update transfer order line. Transfer order identifier [%1] does not exist.", rtsTransferOrderObject.paramTransferId()));
            }

            if (!transferOrder.isEditable())
            {
                throw error(strFmt("Can not update transfer order line. Transfer order [%1] is not editable.", rtsTransferOrderObject.paramTransferId()));
            }

            ListEnumerator transferLineEnumerator = rtsTransferOrderObject.getTransferOrderLineEnumerator();
            while (transferLineEnumerator.moveNext())
            {
                infoLogIndex = Global::infologLine();
                RetailRTSTransferOrderLine rtsTransferOrderLineObject;
                try
                {
                    rtsTransferOrderLineObject = transferLineEnumerator.current();

                    if (rtsTransferOrderLineObject.paramRecId() == 0)
                    {
                        throw error("Transfer line with RecId 0 can not be updated ");
                    }

                    if (rtsTransferOrderLineObject.paramguidId() == emptyGuid())
                    {
                        throw error("Transfer line with empty guid can not be updated ");
                    }

                    InventTransferLine inventTransferLine;
                    // if the transfer order line already exists update the line.
                    inventTransferLine = InventTransferLine::findRecId(rtsTransferOrderLineObject.paramRecId(), true);

                    // Update quantites
                    if (inventTransferLine.UnitId != rtsTransferOrderLineObject.paramUnitId() && rtsTransferOrderLineObject.paramUnitId() != '')
                    {
                        inventTransferLine.QtyTransfer = InventTableModule::unitConvert(inventTransferLine.ItemId,
                                                                                        ModuleInventPurchSales::Invent,
                                                                                        rtsTransferOrderLineObject.paramUnitId(),
                                                                                        rtsTransferOrderLineObject.paramQtyTransfer(),
                                                                                        inventTransferLine.InventDimId);

                        inventTransferLine.QtyReceiveNow += InventTableModule::unitConvert(inventTransferLine.ItemId,
                                                                                           ModuleInventPurchSales::Invent,
                                                                                           rtsTransferOrderLineObject.paramUnitId(),
                                                                                           rtsTransferOrderLineObject.paramQtyReceiveNow(),
                                                                                           inventTransferLine.InventDimId);

                        inventTransferLine.QtyShipNow += InventTableModule::unitConvert(inventTransferLine.ItemId,
                                                                                        ModuleInventPurchSales::Invent,
                                                                                        rtsTransferOrderLineObject.paramUnitId(),
                                                                                        rtsTransferOrderLineObject.paramQtyShipNow(),
                                                                                        inventTransferLine.InventDimId);
                    }
                    else
                    {
                        inventTransferLine.QtyTransfer = rtsTransferOrderLineObject.paramQtyTransfer();
                        inventTransferLine.QtyReceiveNow += rtsTransferOrderLineObject.paramQtyReceiveNow();
                        inventTransferLine.QtyShipNow += rtsTransferOrderLineObject.paramQtyShipNow();
                    }

                    // updated remaining quantities based on updated transfer qty
                    InventMovement::bufferSetRemainQty(inventTransferLine, InventMovSubType::None);
                    InventMovement::bufferSetRemainQty(inventTransferLine, InventMovSubType::TransferOrderTransitFrom);
                    inventTransferLine.update();

                    rtsTransferOrderLineObject.updatePropertiesFromTable(inventTransferLine);
                }
                catch (Exception::Error)
                {
                    str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
                    rtsTransferOrderLineObject.setErrorMessage(errorStr);
                }
            }
            rtsTransferOrderObject.paramUpdatedInAX(true);
            resultContainer = [true, "", rtsTransferOrderObject.toXML()];
            ttscommit;
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
            RetailTransactionServiceInventory::addUpdateFailure(rtsTransferOrderObject.paramXmlRoot(), errorStr);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryUpdateTransferOrderLinesError(axCallStack, "@RET2382");
            resultContainer = [false, errorStr, rtsTransferOrderObject.getSavedOrderAndConvertToXml()];
            return resultContainer;
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransferOrderLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a list of transfer order lines.
    /// </summary>
    /// <param name="transferOrderXmlStr">
    /// An Xml string containing details of a transfer order.
    /// </param>
    /// <returns>
    /// A container object to indicate success or failure.
    /// </returns>
    public static server container deleteTransferOrderLines(str transferOrderLinesXmlStr)
    {
        int infoLogIndex;
        container resultContainer = [false, '', ''];

        RetailRTSTransferOrder rtsTransferOrderObject;
        try
        {
            ttsbegin;
            infoLogIndex = Global::infologLine();
            rtsTransferOrderObject = RetailRTSTransferOrder::fromXML(transferOrderLinesXmlStr);
            InventTransferTable transferOrder = InventTransferTable::find(rtsTransferOrderObject.paramTransferId());

            if (transferOrder.RecId == 0)
            {
                throw error(strFmt("Can not delete transfer order line. Transfer order identifier [%1] does not exist.", rtsTransferOrderObject.paramTransferId()));
            }

            if (!transferOrder.isEditable())
            {
                throw error(strFmt("Can not delete transfer order line. Transfer order [%1] is not editable.", rtsTransferOrderObject.paramTransferId()));
            }

            ListEnumerator transferLineEnumerator = rtsTransferOrderObject.getTransferOrderLineEnumerator();
            while (transferLineEnumerator.moveNext())
            {
                infoLogIndex = Global::infologLine();
                RetailRTSTransferOrderLine rtsTransferOrderLineObject;
                try
                {
                    rtsTransferOrderLineObject = transferLineEnumerator.current();

                    if (rtsTransferOrderLineObject.paramRecId() == 0)
                    {
                        throw error("Transfer line with RecId 0 can not be deleted");
                    }

                    if (rtsTransferOrderLineObject.paramguidId() == emptyGuid())
                    {
                        throw error("Transfer line with empty guid can not be deleted");
                    }

                    InventTransferLine inventTransferLine;
                    // if the transfer order line already exists update the line.
                    inventTransferLine = InventTransferLine::findRecId(rtsTransferOrderLineObject.paramRecId(), true);
                    
                    // validate if line can be deleted
                    if (!inventTransferLine.validateDelete())
                    {
                        throw error("Transfer line with can not be deleted");
                    }

                    inventTransferLine.delete();

                    rtsTransferOrderLineObject.updatePropertiesFromTable(inventTransferLine);
                }
                catch (Exception::Error)
                {
                    str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
                    rtsTransferOrderLineObject.setErrorMessage(errorStr);
                }
            }

            resultContainer = [true, "", rtsTransferOrderObject.toXML()];
            ttscommit;
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(infoLogIndex));
            RetailTransactionServiceInventory::addUpdateFailure(rtsTransferOrderObject.paramXmlRoot(), errorStr);
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryDeleteTransferOrderLinesError(axCallStack, "@RET2382");
            resultContainer = [false, errorStr, rtsTransferOrderObject.getSavedOrderAndConvertToXml()];
            return resultContainer;
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the specified transfer order.
    /// </summary>
    /// <param name="transferId">
    /// The transfer order Id.
    /// </param>
    /// <returns>
    /// Returns a container in this containing status of the deletion as boolean flag and the error messgae if any delete error occurs.
    /// [operationResultStatusBoolean, errorMessage]
    /// </returns>
    public static server container deleteTransferOrder(InventTransferId transferId)
    {
        container resultContainer = [false, ''];

        int logBaseLine = Global::infologLine();

        try
        {
            ttsbegin;
            InventTransferTable inventTransferTable = InventTransferTable::find(transferId, true);

            if (!inventTransferTable.RecId)
            {
                throw error(strFmt("@Retail:CannotFindTransferOrder", transferId));
            }

            // check if the transfer order can be deleted.
            if (inventTransferTable.validateDelete())
            {
                inventTransferTable.delete();
                resultContainer = [true, '', ''];
            }
            else
            {
                throw error(strFmt("@Retail:TransferOrderDeleteErrorMsg", transferId));
            }
            ttscommit;
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(logBaseLine));
            resultContainer = [false, errorStr];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryDeleteTransferOrderError(axCallStack, "@RET2382");
        }
        
        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirmPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms the approved purchase order.
    /// </summary>
    /// <param name="purchId">
    /// The purch Id.
    /// </param>
    /// <returns>
    /// Returns a container in this containing status of the confirmation as boolean flag and the error messgae if any confirmation error occurs.
    /// [operationResultStatusBoolean, errorMessage]
    /// </returns>
    public static server container confirmPurchaseOrder(PurchId purchId)
    {
        container resultContainer = [false, ''];
        PurchTable purchTable;
        int logBaseLine;

        try
        {
            ttsBegin;
            logBaseLine = Global::infologLine();

            purchTable = PurchTable::find(purchId, true);

            if (!purchTable.RecId)
            {
                throw error(strFmt("@Retail:NotValidPurchaseOrderIdError", purchId));
            }

            if (RetailInventoryConfirmPurchaseOrderWithFormLetterFlight::instance().isEnabled())
            {
                PurchFormLetter formLetter = PurchFormLetter::construct(DocumentStatus::PurchaseOrder);
                formLetter.update(purchTable, purchId);
            }
            else
            {
                purchTable.DocumentState = VersioningDocumentState::Confirmed;
                purchTable.update();
            }

            resultContainer = [true, ''];
                       
            ttsCommit;
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(logBaseLine));
            resultContainer = [false, errorStr];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryConfirmPurchaseOrderError(axCallStack, purchTable.RecId, "@RET2382");
        }
        
        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCommentOnTransferOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a comment to the specified transfer order.
    /// </summary>
    /// <param name = "_transferId">The transfer order identifier.</param>
    /// <param name = "_commentedBy">The staff commenting on the transfer order.</param>
    /// <param name = "_comment">The transfer order comment.</param>
    /// <returns>The comment </returns>
    /// <remarks>
    /// The xml that contains the comment has this format
    /// <![CDATA[
    /// <Comments>
    ///   <Comment Text="comment string" AuthorStaffId="StaffId" AuthorName="commenter's name" RecordId="5678" CreatedDateTime="" />
    /// </Comments>
    /// ]]]]><![CDATA[>
    /// </remarks>
    public static server container addCommentOnTransferOrder(InventTransferId _transferId, RetailStaffId _commentedBy, str _comment)
    {
        container resultContainer = [false, ''];
        int logBaseLine;

        try
        {
            logBaseLine = Global::infologLine();
            str tranferCommentXmlStr = RetailRTSTransferOrder::addComment(_transferId, _commentedBy, _comment);
            resultContainer = [true, '', tranferCommentXmlStr];
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(logBaseLine));
            resultContainer = [false, errorStr];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryAddCommentOnTransferOrderError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderComments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets all the comment made on the specified transfer order.
    /// </summary>
    /// <param name = "_transferId">The transfer order identifier.</param>
    /// <returns>A container containing the result of the operation and
    /// and the list of comment objects in xml format.</returns>
    /// <remarks>
    /// The xml that contains the comments has this format
    /// <![CDATA[
    /// <Comments>
    ///   <Comment Text="comment string one" CommentedBy="StaffId1" RecordId="5678" CreatedDateTime="" />
    ///   <Comment Text="comment string two" CommentedBy="StaffId2" RecordId="5679" CreatedDateTime="" />
    /// </Comments>
    /// ]]]]><![CDATA[>
    /// </remarks>
    public static server container getTransferOrderComments(InventTransferId _transferId)
    {
        container resultContainer = [false, ''];
        int logBaseLine;

        try
        {
            logBaseLine = Global::infologLine();

            str transferOrderCommentsXmlStr = RetailRTSTransferOrder::getComments(_transferId);

            resultContainer = [true, '', transferOrderCommentsXmlStr];
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(logBaseLine));
            resultContainer = [false, errorStr];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetTransferOrderCommentsError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of transfer order journal for the specified order.
    /// </summary>
    /// <param name = "_transferOrderId">The transfer order Id.</param>
    /// <returns>The collection of transfer order journal headers in xml format</returns>
    public static server container getTransferOrderJournals(str _transferOrderId)
    {
        container resultContainer = [false, ''];
        int logBaseLine;

        try
        {
            logBaseLine = Global::infologLine();

            XmlDocument journalDoc = RetailRTSTransferOrder::getTransferOrderJournals(_transferOrderId);
            str transferJournalsXmlStr = journalDoc.toString();

            resultContainer = [true, '', transferJournalsXmlStr];
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(logBaseLine));
            resultContainer = [false, errorStr];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetTransferOrderJournalsError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournalDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transfer order journal detail for the specified transfer journal voucher Id.
    /// </summary>
    /// <param name = "_transferOrderId">The transfer order Id.</param>
    /// <param name = "_voucherId">The voucher Id of the transfer journal being retrieved.</param>
    /// <returns>A containier [resultStatus, errorMessage, transferJournalDetailXmlStr]</returns>
    /// <remarks>
    /// The xml that contains the transfer journal detail has this format
    /// <![CDATA[
    ///   <TransferOrderJournal TransferId="10000" VoucherId="00001" UpdatedByWorker="00012" TransferDate="" >
    ///         <TransferOrderJournalLine ItemId="122" ProductName="item one" InventColorId="Red" InventSizeId="" InventStyleId="" InventVersionId="" ConfigId="" QtyShipped="1" />
    ///         <TransferOrderJournalLine ItemId="123" ProductName="item two" InventColorId="" InventSizeId="XL" InventStyleId="" InventVersionId="" ConfigId="" QtyShipped="1" />
    ///   </TransferOrderJournal>
    /// ]]]]><![CDATA[>
    /// </remarks>
    public static server container getTransferOrderJournalDetail(str _transferOrderId, str _voucherId)
    {
        return RetailTransactionServiceInventory::getTransferOrderJournalDetailInternal(_transferOrderId, _voucherId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournalDetailV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transfer order journal detail.
    /// </summary>
    /// <param name = "_searchCriteriaJson">The search criteria.</param>
    /// <returns>A containier [resultStatus, errorMessage, transferJournalDetailXmlStr]</returns>
    internal static server container getTransferOrderJournalDetailV2(str _searchCriteriaJson)
    {
        CRT.TransactionService.TransactionServiceTransferOrderJournalDetailSearchCriteria searchCriteria =
                RetailTransactionServiceInventory::getTransferOrderJournalDetailSearchCriteriaFromJson(_searchCriteriaJson);
        if (!searchCriteria)
        {
            return [false, "@RetailInventory:TransferOrderJournalDetailInvalidSearchCriteria", ''];
        }
        
        return RetailTransactionServiceInventory::getTransferOrderJournalDetailInternal(searchCriteria.OrderId, searchCriteria.VoucherId, searchCriteria.LanguageId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournalDetailInternal</Name>
				<Source><![CDATA[
    private static server container getTransferOrderJournalDetailInternal(str _transferOrderId, str _voucherId, str _languageId = '')
    {
        container resultContainer = [false, ''];
        int logBaseLine;

        try
        {
            logBaseLine = Global::infologLine();

            XmlDocument journalDoc = RetailRTSTransferOrder::getTransferOrderJournalDetailInternal(_transferOrderId, _voucherId, _languageId);
            str transferJournalDetailXmlStr = journalDoc.toString();

            resultContainer = [true, '', transferJournalDetailXmlStr];
        }
        catch (Exception::Error)
        {
            str errorStr = strFmt("@RET2382" + RetailTransactionServiceUtilities::getInfologMessages(logBaseLine));
            resultContainer = [false, errorStr];
            str axCallStack = con2Str(xSession::xppCallStack());
            eventSource.EventWriteInventoryGetTransferOrderJournalDetailError(axCallStack, "@RET2382");
        }

        return resultContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSpecificInventoryDocumentSearchCriteriaFromJson</Name>
				<Source><![CDATA[
    private static CRT.TransactionService.TransactionServiceSingleInventoryDocumentSearchCriteria getSpecificInventoryDocumentSearchCriteriaFromJson(str _searchCriteriaJson)
    {
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type searchCriteriaType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceSingleInventoryDocumentSearchCriteriaTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of RCSU version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CRT.TransactionService.TransactionServiceSingleInventoryDocumentSearchCriteria searchCriteria = Newtonsoft.Json.JsonConvert::DeserializeObject(_searchCriteriaJson, searchCriteriaType, settings);

            return searchCriteria;
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsDeserializationFailed();
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryDocumentSearchCriteriaFromJson</Name>
				<Source><![CDATA[
    private static CRT.TransactionService.TransactionServiceInventoryDocumentSearchCriteria getInventoryDocumentSearchCriteriaFromJson(str _searchCriteriaJson)
    {
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type searchCriteriaType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceInventoryDocumentSearchCriteriaTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of RCSU version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless constructor
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CRT.TransactionService.TransactionServiceInventoryDocumentSearchCriteria searchCriteria = Newtonsoft.Json.JsonConvert::DeserializeObject(_searchCriteriaJson, searchCriteriaType, settings);

            return searchCriteria;
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsDeserializationFailed();
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryDocumentLineSearchCriteriaFromJson</Name>
				<Source><![CDATA[
    private static CRT.TransactionService.TransactionServiceInventoryDocumentLineSearchCriteria getInventoryDocumentLineSearchCriteriaFromJson(str _searchCriteriaJson)
    {
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type searchCriteriaType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceInventoryDocumentLineSearchCriteriaTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of RCSU version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor.
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CRT.TransactionService.TransactionServiceInventoryDocumentLineSearchCriteria searchCriteria = Newtonsoft.Json.JsonConvert::DeserializeObject(_searchCriteriaJson, searchCriteriaType, settings);

            return searchCriteria;
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentLinesDeserializationFailed();
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventoryLookupSearchCriteriaFromJson</Name>
				<Source><![CDATA[
    private static CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria getInventoryLookupSearchCriteriaFromJson(str _searchCriteriaJson)
    {
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type searchCriteriaType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceInventoryLookupSearchCriteriaTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of RCSU version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor.
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria = Newtonsoft.Json.JsonConvert::DeserializeObject(_searchCriteriaJson, searchCriteriaType, settings);

            return searchCriteria;
        }
        catch
        {
            eventSource.EventWriteInventoryLookupSearchCriteriaDeserializationFailed(_searchCriteriaJson);
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderJournalDetailSearchCriteriaFromJson</Name>
				<Source><![CDATA[
    private static CRT.TransactionService.TransactionServiceTransferOrderJournalDetailSearchCriteria getTransferOrderJournalDetailSearchCriteriaFromJson(str _searchCriteriaJson)
    {
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type searchCriteriaType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceTransferOrderJournalDetailSearchCriteriaTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of RCSU version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor.
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CRT.TransactionService.TransactionServiceTransferOrderJournalDetailSearchCriteria searchCriteria = Newtonsoft.Json.JsonConvert::DeserializeObject(_searchCriteriaJson, searchCriteriaType, settings);

            return searchCriteria;
        }
        catch
        {
            eventSource.EventWriteTransferOrderJournalDetailSearchCriteriaDeserializationFailed(_searchCriteriaJson);
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveInventoryInboundDocuments</Name>
				<Source><![CDATA[
    private static container getActiveInventoryInboundDocuments(Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentSearchCriteria _searchCriteria)
    {
        InventLocationId receivingWarehouse = _searchCriteria.InventLocationId;
        str documentId = _searchCriteria.DocumentId;

        System.Collections.ArrayList inventoryDocuments = new System.Collections.ArrayList();

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(RetailActiveInventoryDocumentsView));
        qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, Receiver)).value(receivingWarehouse);
        qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, Sender)).value(_searchCriteria.SenderWarehouse);

        if (documentId)
        {
            qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, DocumentId)).value(documentId);
        }

        str sender = _searchCriteria.SenderWarehouse;
        if (sender)
        {
            qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, Sender)).value(strFmt('*%1*', queryValue(sender)));
        }

        str description = _searchCriteria.Description;
        if (description)
        {
            qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, Description)).value(strFmt('*%1*', queryValue(description)));
        }


        qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyRemain), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyReceived), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyShipped), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyRemainShip), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, LineCount), SelectionField::Count);

        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, Sender));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, Receiver));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, ShipDate));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, ReceiveDate));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, RecordId));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, DocumentId));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, HeaderDlvMode));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, DocumentType));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, DocumentCreatedDateTime));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, DocumentTypeId));
        qbds.addGroupByField(fieldNum(RetailActiveInventoryDocumentsView, Description));

        qbds.addSortField(fieldNum(RetailActiveInventoryDocumentsView, DocumentCreatedDateTime), SortOrder::Descending);

        CLRSystem.Collections.IEnumerable documentTypes = _searchCriteria.get_DocumentTypes();
        boolean hasStockCounting = false;

        if (documentTypes && _searchCriteria.get_DocumentTypes().get_Count() > 0)
        {
            System.Collections.IEnumerator documentTypesEnumerator = documentTypes.GetEnumerator();
            while (documentTypesEnumerator.MoveNext())
            {
                CRT.DataModel.InventorySourceDocumentType currentValue = documentTypesEnumerator.get_Current();
                qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, DocumentType)).value(queryValue(currentValue));
                if (currentValue == CRT.DataModel.InventorySourceDocumentType::StockCounting)
                {
                    hasStockCounting = true;
                }
            }
        }
        else
        {
            // if document types is null or empty, then search TransferOrder and PurchaseOrder
            qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, DocumentType)).value(queryValue(RetailInventoryDocumentType::TransferOrder));
            qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, DocumentType)).value(queryValue(RetailInventoryDocumentType::PurchaseOrder));
        }

        if (!hasStockCounting)
        {
            qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyOrdered), SelectionField::Sum);
        }
        else
        {
            RetailParameters retailParameters = RetailParameters::find();
            if (retailParameters.HideSystemInventoryInStockCount == NoYes::No)
            {
                qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyOrdered), SelectionField::Sum);
            }
        }

        CLRSystem.Collections.IEnumerable documentTypeIds = _searchCriteria.get_DocumentTypeIds();

        if (documentTypeIds && _searchCriteria.get_DocumentTypeIds().get_Count() > 0)
        {
            System.Collections.IEnumerator documentTypeIdsEnumerator = documentTypeIds.GetEnumerator();
            while (documentTypeIdsEnumerator.MoveNext())
            {
                str currentValue = documentTypeIdsEnumerator.get_Current();
                qbds.addRange(fieldNum(RetailActiveInventoryDocumentsView, DocumentTypeId)).value(queryValue(currentValue));
            }
        }

        RetailTransactionServiceInventory::applyCustomFiltersToQueryBuildDataSource(_searchCriteria, qbds);
       
        QueryRun queryRun = new QueryRun(query);
        queryRun.enablePositionPaging(true);
        queryRun.addPageRange(_searchCriteria.Skip + 1, _searchCriteria.Top);

        while (queryRun.next())
        {
            RetailActiveInventoryDocumentsView activeDocument = queryRun.get(tableNum(RetailActiveInventoryDocumentsView));
            var inventoryDocument = RetailTransactionServiceInventory::populateActiveInventoryDocumentEntity(activeDocument);
            RetailTransactionServiceInventory::registerPopulateInboundActiveSourceDocumentCustomProperties(inventoryDocument, activeDocument);
            inventoryDocuments.Add(inventoryDocument);
        }

        // Serialize results.
        System.Type[] typeArray = new System.Type[1]();
        System.Type sourceDocumentType = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument().GetType();
        typeArray.SetValue(sourceDocumentType, 0);
        str results;

        try
        {
            results = RetailTransactionServiceJsonHelper::SerializeToJson(inventoryDocuments, typeArray);
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsSerializationFailed();
            return [false, "@Retail:RetailInventoryDocumentSerializationFaliure", ''];
        }

        return [true, '', results];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActiveInventoryOutboundDocuments</Name>
				<Source><![CDATA[
    private static container getActiveInventoryOutboundDocuments(Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentSearchCriteria _searchCriteria)
    {
        InventLocationId shippingWarehouse = _searchCriteria.InventLocationId;
        str documentId = _searchCriteria.DocumentId;

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(InventTransferTable));
        qbds.addRange(fieldNum(InventTransferTable, InventLocationIdFrom)).value(shippingWarehouse);
        qbds.addRange(fieldNum(InventTransferTable, TransferStatus)).value(enum2Str(InventTransferStatus::Created));

        if (documentId)
        {
            qbds.addRange(fieldNum(InventTransferTable, TransferId)).value(documentId);
        }

        str receiver = _searchCriteria.ReceiverWarehouse;
        if (receiver)
        {
            qbds.addRange(fieldNum(InventTransferTable, InventLocationIdTo)).value(receiver);
        }

        qbds.addGroupByField(fieldNum(InventTransferTable, InventLocationIdFrom));
        qbds.addGroupByField(fieldNum(InventTransferTable, InventLocationIdTo));
        qbds.addGroupByField(fieldNum(InventTransferTable, ShipDate));
        qbds.addGroupByField(fieldNum(InventTransferTable, ReceiveDate));
        qbds.addGroupByField(fieldNum(InventTransferTable, RecId));
        qbds.addGroupByField(fieldNum(InventTransferTable, TransferId));
        qbds.addGroupByField(fieldNum(InventTransferTable, DlvModeId));
        qbds.addGroupByField(fieldNum(InventTransferTable, CreatedDateTime));

        qbds.addSortField(fieldNum(InventTransferTable, CreatedDateTime), SortOrder::Descending);

        QueryBuildDataSource lineQbds = qbds.addDataSource(tableNum(InventTransferLine));
        lineQbds.joinMode(JoinMode::InnerJoin);
        lineQbds.relations(true);

        lineQbds.addSelectionField(fieldNum(InventTransferLine, QtyTransfer), SelectionField::Sum);
        lineQbds.addSelectionField(fieldNum(InventTransferLine, QtyReceived), SelectionField::Sum);
        lineQbds.addSelectionField(fieldNum(InventTransferLine, QtyShipped), SelectionField::Sum);
        lineQbds.addSelectionField(fieldNum(InventTransferLine, QtyRemainShip), SelectionField::Sum);
        lineQbds.addSelectionField(fieldNum(InventTransferLine, RecId), SelectionField::Count);

        RetailTransactionServiceInventory::applyCustomFiltersToQueryBuildDataSource(_searchCriteria, qbds);

        QueryRun queryRun = new QueryRun(query);
        queryRun.enablePositionPaging(true);
        queryRun.addPageRange(_searchCriteria.Skip + 1, _searchCriteria.Top);

        System.Collections.ArrayList inventoryDocuments = new System.Collections.ArrayList();
        while (queryRun.next())
        {
            InventTransferTable transferHeader = queryRun.get(tableNum(InventTransferTable));
            InventTransferLine transferLine = queryRun.get(tableNum(InventTransferLine));

            var inventoryDocument = RetailTransactionServiceInventory::populateTransferOrderInventoryDocument(transferHeader, transferLine);
            RetailTransactionServiceInventory::registerPopulateOutboundTransferOrderCustomProperties(inventoryDocument, transferHeader, transferLine);
            inventoryDocuments.Add(inventoryDocument);
        }

        // Serialize results.
        System.Type[] typeArray = new System.Type[1]();
        System.Type sourceDocumentType = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument().GetType();
        typeArray.SetValue(sourceDocumentType, 0);
        str results;

        try
        {
            results = RetailTransactionServiceJsonHelper::SerializeToJson(inventoryDocuments, typeArray);
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsSerializationFailed();
            return [false, "@Retail:RetailInventoryDocumentSerializationFaliure", ''];
        }
        return [true, '', results];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompleteInventoryInboundDocuments</Name>
				<Source><![CDATA[
    private static container getCompleteInventoryInboundDocuments(Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentSearchCriteria _searchCriteria)
    {
        InventLocationId receivingWarehouse = _searchCriteria.InventLocationId;

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(RetailCompleteInventoryDocumentsView));
        qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, Receiver)).value(receivingWarehouse);

        str documentId = _searchCriteria.DocumentId;
        if (documentId)
        {
            qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, DocumentId)).value(documentId);
        }
        
        str sender = _searchCriteria.SenderWarehouse;
        if (sender)
        {
            qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, Sender)).value(strFmt('*%1*', queryValue(sender)));
        }

        str description = _searchCriteria.Description;
        if (description)
        {
            qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, Description)).value(strFmt('*%1*', queryValue(description)));
        }
       
        // Exclude documents with receive date older than one week.
        utcdatetime cutOffDate = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -CompleteDocumentExpiryNumDays);
        qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, LastReceiveDate)).value(strFmt('(%2 >= %1)', 
            date2StrXpp(utcDateTime2SystemDateTime(cutOffDate)), 
            fieldStr(RetailCompleteInventoryDocumentsView, LastReceiveDate)));

        qbds.addSelectionField(fieldNum(RetailCompleteInventoryDocumentsView, QtyReceived), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(RetailCompleteInventoryDocumentsView, QtyShipped), SelectionField::Sum);
        qbds.addSelectionField(fieldNum(RetailCompleteInventoryDocumentsView, LineCount), SelectionField::Count);

        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, Sender));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, Receiver));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, ShipDate));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, ReceiveDate));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, LastReceiveDate));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, RecordId));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, DocumentId));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, HeaderDlvMode));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, DocumentType));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, DocumentTypeId));
        qbds.addGroupByField(fieldNum(RetailCompleteInventoryDocumentsView, Description));

        qbds.addSortField(fieldNum(RetailCompleteInventoryDocumentsView, LastReceiveDate), SortOrder::Descending);

        CLRSystem.Collections.IEnumerable documentTypes = _searchCriteria.get_DocumentTypes();
        boolean hasStockCounting = false;

        if (documentTypes && _searchCriteria.get_DocumentTypes().get_Count() > 0)
        {
            System.Collections.IEnumerator documentTypesEnumerator = documentTypes.GetEnumerator();
            while (documentTypesEnumerator.MoveNext())
            {
                CRT.DataModel.InventorySourceDocumentType currentValue = documentTypesEnumerator.get_Current();
                qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, DocumentType)).value(queryValue(currentValue));
                if (currentValue == CRT.DataModel.InventorySourceDocumentType::StockCounting)
                {
                    hasStockCounting = true;
                }
            }
        }
        else
        {
            // if document types is null or empty, then the default search type are TransferOrder and PurchaseOrder
            qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, DocumentType)).value(queryValue(RetailInventoryDocumentType::TransferOrder));
            qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, DocumentType)).value(queryValue(RetailInventoryDocumentType::PurchaseOrder));
        }

        if (!hasStockCounting)
        {
            qbds.addSelectionField(fieldNum(RetailCompleteInventoryDocumentsView, QtyOrdered), SelectionField::Sum);
        }
        else
        {
            RetailParameters retailParameters = RetailParameters::find();
            if (retailParameters.HideSystemInventoryInStockCount == NoYes::No)
            {
                qbds.addSelectionField(fieldNum(RetailActiveInventoryDocumentsView, QtyOrdered), SelectionField::Sum);
            }
        }

        CLRSystem.Collections.IEnumerable documentTypeIds = _searchCriteria.get_DocumentTypeIds();

        if (documentTypeIds && _searchCriteria.get_DocumentTypeIds().get_Count() > 0)
        {
            System.Collections.IEnumerator documentTypeIdsEnumerator = documentTypeIds.GetEnumerator();
            while (documentTypeIdsEnumerator.MoveNext())
            {
                str currentTypeID = documentTypeIdsEnumerator.get_Current();
                qbds.addRange(fieldNum(RetailCompleteInventoryDocumentsView, DocumentTypeId)).value(currentTypeID);
            }
        }

        RetailTransactionServiceInventory::applyCustomFiltersToQueryBuildDataSource(_searchCriteria, qbds);

        QueryRun queryRun = new QueryRun(query);
        queryRun.enablePositionPaging(true);
        queryRun.addPageRange(_searchCriteria.Skip + 1, _searchCriteria.Top);

        System.Collections.ArrayList inventoryDocuments = new System.Collections.ArrayList();
        while (queryRun.next())
        {
            RetailCompleteInventoryDocumentsView completeDocument = queryRun.get(tableNum(RetailCompleteInventoryDocumentsView));
            
            var inventoryDocument = RetailTransactionServiceInventory::populateCompleteInventoryDocumentEntity(completeDocument);
            RetailTransactionServiceInventory::registerPopulateInboundCompleteSourceDocumentCustomProperties(inventoryDocument, completeDocument);
            inventoryDocuments.Add(inventoryDocument);
        }

        // Serialize results.
        System.Type[] typeArray = new System.Type[1]();
        System.Type sourceDocumentType = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument().GetType();
        typeArray.SetValue(sourceDocumentType, 0);
        str results;

        try
        {
            results = RetailTransactionServiceJsonHelper::SerializeToJson(inventoryDocuments, typeArray);
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsSerializationFailed();
            return [false, "@Retail:RetailInventoryDocumentSerializationFaliure", ''];
        }

        return [true, '', results];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompleteInventoryOutboundDocuments</Name>
				<Source><![CDATA[
    private static container getCompleteInventoryOutboundDocuments(Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentSearchCriteria _searchCriteria)
    {
        InventLocationId shippingWarehouse = _searchCriteria.InventLocationId;
        str documentId = _searchCriteria.DocumentId;

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(InventTransferTable));
        qbds.addRange(fieldNum(InventTransferTable, InventLocationIdFrom)).value(shippingWarehouse);
        qbds.addRange(fieldNum(InventTransferTable, TransferStatus)).value(queryValue(InventTransferStatus::Shipped));
        qbds.addRange(fieldNum(InventTransferTable, TransferStatus)).value(queryValue(InventTransferStatus::Received));

        if (documentId)
        {
            qbds.addRange(fieldNum(InventTransferTable, TransferId)).value(documentId);
        }

        str receiver = _searchCriteria.ReceiverWarehouse;
        if (receiver)
        {
            qbds.addRange(fieldNum(InventTransferTable, InventLocationIdTo)).value(receiver);
        }


        qbds.addGroupByField(fieldNum(InventTransferTable, InventLocationIdFrom));
        qbds.addGroupByField(fieldNum(InventTransferTable, InventLocationIdTo));
        qbds.addGroupByField(fieldNum(InventTransferTable, ShipDate));
        qbds.addGroupByField(fieldNum(InventTransferTable, ReceiveDate));
        qbds.addGroupByField(fieldNum(InventTransferTable, RecId));
        qbds.addGroupByField(fieldNum(InventTransferTable, TransferId));
        qbds.addGroupByField(fieldNum(InventTransferTable, DlvModeId));

        QueryBuildDataSource lineQbds = qbds.addDataSource(tableNum(InventTransferLine));
        lineQbds.fetchMode(QueryFetchMode::One2Many);
        lineQbds.joinMode(JoinMode::InnerJoin);
        lineQbds.relations(true);

        QueryBuildDataSource originQbds = lineQbds.addDataSource(tableNum(InventTransOrigin));
        originQbds.fetchMode(QueryFetchMode::One2One);
        originQbds.joinMode(JoinMode::InnerJoin);
        originQbds.relations(false);
        originQbds.addLink(fieldNum(InventTransferLine, InventTransId), fieldNum(InventTransOrigin, InventTransId));

        QueryBuildDataSource inventTransQbds = originQbds.addDataSource(tableNum(InventTrans));
        inventTransQbds.fetchMode(QueryFetchMode::One2One);
        inventTransQbds.joinMode(JoinMode::InnerJoin);
        inventTransQbds.relations(true);

        // Exclude outbound documents which have ship date longer than a week ago.
        var cutOffDate = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -CompleteDocumentExpiryNumDays);
        inventTransQbds.addRange(fieldNum(InventTrans, DatePhysical)).value(strFmt('(%2 >= %1)',
            date2StrXpp(utcDateTime2SystemDateTime(cutOffDate)),
            fieldStr(InventTrans, DatePhysical)
        ));

        inventTransQbds.addSelectionField(fieldNum(InventTrans, DatePhysical), SelectionField::Max);

        RetailTransactionServiceInventory::applyCustomFiltersToQueryBuildDataSource(_searchCriteria, qbds);

        QueryRun queryRun = new QueryRun(query);
        queryRun.enablePositionPaging(true);
        queryRun.addPageRange(_searchCriteria.Skip + 1, _searchCriteria.Top);

        System.Collections.ArrayList inventoryDocuments = new System.Collections.ArrayList();
        while (queryRun.next())
        {
            InventTransferTable transferHeader = queryRun.get(tableNum(InventTransferTable));
            
            InventTransferLine transferLine;
            select sum(QtyTransfer), sum(QtyShipped), sum(QtyReceived), sum(QtyRemainShip), count(RecId) from transferLine
                where transferLine.TransferId == transferHeader.TransferId;

            InventTrans maxInventTrans = queryRun.get(tableNum(InventTrans));

            var inventoryDocument = RetailTransactionServiceInventory::populateTransferOrderInventoryDocument(transferHeader, transferLine, maxInventTrans);
            RetailTransactionServiceInventory::registerPopulateOutboundTransferOrderCustomProperties(inventoryDocument, transferHeader, transferLine);
            inventoryDocuments.Add(inventoryDocument);
        }

        // Serialize results.
        System.Type[] typeArray = new System.Type[1]();
        System.Type sourceDocumentType = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument().GetType();
        typeArray.SetValue(sourceDocumentType, 0);
        str results;

        try
        {
            results = RetailTransactionServiceJsonHelper::SerializeToJson(inventoryDocuments, typeArray);
        }
        catch
        {
            eventSource.EventWriteInventoryDocumentsSerializationFailed();
            return [false, "@Retail:RetailInventoryDocumentSerializationFaliure", ''];
        }
        return [true, '', results];
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateActiveInventoryDocumentEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a <c>RetailActiveInventoryDocumentsView</c> entity, return the CRT representation of that document.
    /// </summary>
    /// <param name = "_queryResult">The entity.</param>
    /// <param name= "_isInbound">Boolean value indicating whether the document is inbound or outbound.</param>
    /// <returns>The CRT representation of the entity.</returns>
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument populateActiveInventoryDocumentEntity(RetailActiveInventoryDocumentsView _queryResult)
    {
        var document = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument();

        document.DataAreaId = _queryResult.DataAreaId;
        document.RecordId = _queryResult.RecordId;
        document.DocumentId = _queryResult.DocumentId;
        document.Sender = _queryResult.Sender;
        document.Receiver = _queryResult.Receiver;
        document.DocumentType = _queryResult.DocumentType;
        document.Status = RetailTransactionServiceInventory::calculateInventoryDocumentStatus(_queryResult.DocumentId, _queryResult.RecId, _queryResult.Receiver, _queryResult.DocumentType);
        document.DeliveryMode = _queryResult.HeaderDlvMode;
        document.TotalLines = _queryResult.LineCount;
        document.DocumentTypeId = _queryResult.DocumentTypeId;
        document.Description = _queryResult.Description;

        System.DateTime shipDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_queryResult.ShipDate, 0));
        /* We need to explicitly specify the TimeSpan value to Zero,
        or the default constructor will use local server's time zone info do the convert from DateTime to DateTimeOffset,
        that will result in an incorrect time value.
        e.g: 2020-03-20 12:00AM will be converted to 2020-03-20 12:00AM +08:00 if use a default constructor and the server is in a UTC+8 timezone.
        Same for the ShipDate. */
        document.ShipDate = new System.DateTimeOffset(shipDate, System.TimeSpan::Zero);

        System.DateTime receiveDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_queryResult.ReceiveDate, 0));
        document.ReceiveDate = new System.DateTimeOffset(receiveDate, System.TimeSpan::Zero);

        document.TotalQuantityShipped = _queryResult.QtyShipped;
        document.TotalQuantityReceived = _queryResult.QtyReceived;

        InventLocation receivingWarehouse = InventLocation::find(document.Receiver);
        document.ReceiverDetails = receivingWarehouse.Name;

        if (_queryResult.DocumentType == RetailInventoryDocumentType::TransferOrder)
        {
            InventLocation shippingWarehouse = InventLocation::find(document.Sender);
            document.SenderDetails = shippingWarehouse.Name;

            document.TotalQuantityOrdered = _queryResult.QtyOrdered;
            document.TotalQuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(_queryResult.QtyOrdered, _queryResult.QtyShipped, _queryResult.QtyRemainShip);
        }
        else
        {
            PurchTable purchaseOrder = PurchTable::find(document.DocumentId);
            document.SenderDetails = purchaseOrder.OrderAccount;

            document.IsChangeAllowed = new CLRSystem.Nullable<boolean>(purchaseOrder.ChangeRequestRequired == NoYes::No);
            
            document.TotalQuantityOrdered = _queryResult.QtyOrdered;
            document.TotalQuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(document.TotalQuantityOrdered, _queryResult.QtyReceived, _queryResult.QtyRemain);
        }

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentEntity(document);

        return document;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventoryorderCancelledQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the cancelled quantity for inventory transfer/purchase order.
    /// </summary>
    /// <param name = "quantityOrdered">The total ordered quantity.</param>
    /// <param name = "quantityCompleted">The completed quantity: QuantityShipped for transfer order and QuantityReceived for purchase order.</param>
    /// <param name = "quantityRemain">The remained quantity.</param>
    /// <returns>The total cancelled quantity for current source document.</returns>
    private static Qty calculateInventoryorderCancelledQuantity(Qty quantityOrdered, Qty quantityCompleted, Qty quantityRemained)
    {
        return quantityOrdered - quantityCompleted - quantityRemained;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCompleteInventoryDocumentEntity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a <c>RetailCompleteInventoryDocumentsView</c> entity, return the CRT representation of that document.
    /// </summary>
    /// <param name = "_queryResult">The entity.</param>
    /// <param name= "_isInbound">Boolean value indicating whether the document is inbound or outbound.</param>
    /// <returns>The CRT representation of the entity.</returns>
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument populateCompleteInventoryDocumentEntity(RetailCompleteInventoryDocumentsView _queryResult)
    {
        var document = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument();

        document.DataAreaId = _queryResult.DataAreaId;
        document.RecordId = _queryResult.RecordId;
        document.DocumentId = _queryResult.DocumentId;
        document.Sender = _queryResult.Sender;
        document.Receiver = _queryResult.Receiver;
        document.DocumentType = _queryResult.DocumentType;
        document.Status = RetailTransactionServiceInventory::calculateInventoryDocumentStatus(_queryResult.DocumentId, _queryResult.RecId, _queryResult.Receiver, _queryResult.DocumentType);
        document.DeliveryMode = _queryResult.HeaderDlvMode;
        document.DocumentTypeId = _queryResult.DocumentTypeId;
        document.Description = _queryResult.Description;

        System.DateTime shipDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_queryResult.ShipDate, 0));
        /* We need to explicitly specify the TimeSpan value to Zero,
        or the default constructor will use local server's time zone info do the convert from DateTime to DateTimeOffset,
        that will result in an incorrect time value.
        e.g: 2020-03-20 12:00AM will be converted to 2020-03-20 12:00AM +08:00 if use a default constructor and the server is in a UTC+8 timezone.
        Same for the ShipDate. */
        document.ShipDate = new System.DateTimeOffset(shipDate, System.TimeSpan::Zero);

        System.DateTime receiveDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_queryResult.LastReceiveDate, 0));
        document.ReceiveDate = new System.DateTimeOffset(receiveDate, System.TimeSpan::Zero);
        document.TotalQuantityShipped = _queryResult.QtyShipped;
        document.TotalQuantityReceived = _queryResult.QtyReceived;
        document.TotalLines = _queryResult.LineCount;

        InventLocation receivingWarehouse = InventLocation::find(document.Receiver);
        document.ReceiverDetails = receivingWarehouse.Name;

        if (_queryResult.DocumentType == RetailInventoryDocumentType::TransferOrder)
        {
            InventLocation shippingWarehouse = InventLocation::find(document.Sender);
            document.SenderDetails = shippingWarehouse.Name;

            document.TotalQuantityOrdered = _queryResult.QtyOrdered;
            document.TotalQuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(_queryResult.QtyOrdered, _queryResult.QtyShipped, 0);
        }
        else
        {
            PurchTable purchaseOrder = PurchTable::find(document.DocumentId);
            document.SenderDetails = purchaseOrder.OrderAccount;

            document.IsChangeAllowed =  new CLRSystem.Nullable<boolean>(purchaseOrder.ChangeRequestRequired == NoYes::No);
            
            document.TotalQuantityOrdered = _queryResult.QtyOrdered;
            document.TotalQuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(document.TotalQuantityOrdered, _queryResult.QtyReceived, 0);
        }

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentEntity(document);

        return document;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePurchaseOrderInventoryDocument</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument populatePurchaseOrderInventoryDocument(PurchTable _purchaseOrder, PurchLine _purchaseLine, InventLocationId _inventLocationId, VendInvoiceTrans _vendInvoiceTrans, VendPackingSlipTrans _vendPackingSlipTrans)
    {
        var document = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument();

        document.DataAreaId = _purchaseOrder.DataAreaId;
        document.RecordId = _purchaseOrder.RecId;
        document.DocumentId = _purchaseOrder.PurchId;
        document.Sender = _purchaseOrder.PurchName;
        document.Receiver = _inventLocationId;
        document.DocumentType = RetailInventoryDocumentType::PurchaseOrder;
        document.Status = RetailTransactionServiceInventory::calculateInventoryDocumentStatus(document.DocumentId, document.RecordId, document.Receiver, document.DocumentType);
        document.DeliveryMode = _purchaseOrder.DlvMode;
        document.ReceiveDate = new System.DateTimeOffset(Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_purchaseOrder.AccountingDate, 0)));
        document.ShipDate = new System.DateTimeOffset(Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_purchaseOrder.DeliveryDate, 0)));

        PurchTable purchaseOrder = PurchTable::find(document.DocumentId);
        document.SenderDetails = purchaseOrder.OrderAccount;

        InventLocation receivingWarehouse = InventLocation::find(document.Receiver);
        document.ReceiverDetails = receivingWarehouse.Name;

        document.TotalQuantityShipped = 0;
        document.TotalQuantityReceived = _vendInvoiceTrans.QtyPhysical + _vendPackingSlipTrans.Qty;

        document.TotalQuantityOrdered = _purchaseLine.QtyOrdered;
        document.TotalQuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(document.TotalQuantityOrdered, document.TotalQuantityReceived, _purchaseLine.RemainInventPhysical);

        document.TotalLines = _purchaseLine.RecId;
        document.IsChangeAllowed = new CLRSystem.Nullable<boolean>(purchaseOrder.ChangeRequestRequired == NoYes::No);

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentEntity(document);

        return document;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateJournalInventoryDocument</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument populateJournalInventoryDocument(InventJournalTable _inventJournal, InventJournalTrans _inventJournalTrans)
    {
        var document = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument();

        document.DataAreaId = _inventJournal.DataAreaId;
        document.RecordId = _inventJournal.RecId;
        document.DocumentId = _inventJournal.JournalId;
        document.Sender = _inventJournal.InventLocationId;
        document.Receiver = _inventJournal.InventLocationId;

        if (_inventJournal.JournalType == InventJournalType::LossProfit || _inventJournal.JournalType == InventJournalType::Movement)
        {
            document.DocumentType = RetailInventoryDocumentType::InventoryAdjustment;
        }
        else if (_inventJournal.JournalType == InventJournalType::Transfer)
        {
            document.DocumentType = RetailInventoryDocumentType::InventoryTransfer;
        }
        else if (_inventJournal.JournalType == InventJournalType::Count)
        {
            document.DocumentType = RetailInventoryDocumentType::StockCounting;
        }

        if (_inventJournal.JournalType == InventJournalType::Count)
        {
            RetailParameters retailParameters = RetailParameters::find();
            if (retailParameters.HideSystemInventoryInStockCount == NoYes::Yes)
            {
                document.TotalQuantityOrdered = 0;
            }
            else
            {
                document.TotalQuantityOrdered = _inventJournalTrans.InventOnHand;
            }
        }
        else 
        {
            document.TotalQuantityOrdered = _inventJournalTrans.Qty;
        }

        document.Status = RetailTransactionServiceInventory::calculateInventoryDocumentStatus(document.DocumentId, document.RecordId, document.Receiver, document.DocumentType);
        document.DeliveryMode = "";
        document.DocumentTypeId = _inventJournal.JournalNameId;
        document.Description = _inventJournal.Description;

        System.DateTime postDate = Global::utcDateTime2SystemDateTime(_inventJournal.PostedDateTime);

        document.ReceiveDate = new System.DateTimeOffset(postDate, System.TimeSpan::Zero);
        document.ShipDate = new System.DateTimeOffset(postDate, System.TimeSpan::Zero);
        document.DocumentTypeId = _inventJournal.JournalNameId;
        document.StaffId = HcmWorker::find(_inventJournal.Worker).PersonnelNumber;

        InventLocation receivingWarehouse = InventLocation::find(document.Receiver);
        document.ReceiverDetails = receivingWarehouse.Name;

        document.TotalQuantityShipped = _inventJournalTrans.Qty;
        document.TotalQuantityReceived = _inventJournalTrans.Counted;

        document.TotalLines = _inventJournalTrans.RecId;
        document.IsChangeAllowed = new CLRSystem.Nullable<boolean>(true);

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentEntity(document);

        return document;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTransferOrderInventoryDocument</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument populateTransferOrderInventoryDocument(InventTransferTable _transferOrder, InventTransferLine _transferLine, InventTrans _maxInventTrans = null)
    {
        var document = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument();

        document.DataAreaId = _transferOrder.DataAreaId;
        document.RecordId = _transferOrder.RecId;
        document.DocumentId = _transferOrder.TransferId;
        document.Sender = _transferOrder.InventLocationIdFrom;
        document.Receiver = _transferOrder.InventLocationIdTo;
        document.DocumentType = RetailInventoryDocumentType::TransferOrder;
        document.Status = RetailTransactionServiceInventory::calculateInventoryDocumentStatus(document.DocumentId, document.RecordId, document.Receiver, document.DocumentType);
        document.DeliveryMode = _transferOrder.DlvModeId;

        System.DateTime receiveDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_transferOrder.ReceiveDate, 0));
        /* We need to explicitly specify the TimeSpan value to Zero,
        or the default constructor will use local server's time zone info do the convert from DateTime to DateTimeOffset,
        that will result in an incorrect time value.
        e.g: 2020-03-20 12:00AM will be converted to 2020-03-20 12:00AM +08:00 if use a default constructor and the server is in a UTC+8 timezone.
        Same for the ShipDate. */
        document.ReceiveDate = new System.DateTimeOffset(receiveDate, System.TimeSpan::Zero);
        System.DateTime shipDate;
        if (_maxInventTrans)
        {
            shipDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_maxInventTrans.DatePhysical, 0));
        }
        else
        {
            shipDate = Global::utcDateTime2SystemDateTime(DateTimeUtil::newDateTime(_transferOrder.ShipDate, 0));
        }
        document.ShipDate = new System.DateTimeOffset(shipDate, System.TimeSpan::Zero);

        InventLocation shippingWarehouse = InventLocation::find(document.Sender);
        document.SenderDetails = shippingWarehouse.Name;

        InventLocation receivingWarehouse = InventLocation::find(document.Receiver);
        document.ReceiverDetails = receivingWarehouse.Name;

        document.TotalQuantityShipped = _transferLine.QtyShipped;
        document.TotalQuantityReceived = _transferLine.QtyReceived;
        document.TotalQuantityOrdered = _transferLine.QtyTransfer;
        document.TotalLines = _transferLine.RecId;
        document.TotalQuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(_transferLine.QtyTransfer, _transferLine.QtyShipped, _transferLine.QtyRemainShip);

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentEntity(document);

        return document;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventoryDocumentStatus</Name>
				<Source><![CDATA[
    private static RetailInventoryDocumentStatus calculateInventoryDocumentStatus(str _documentId, int64 _recId, InventLocationId _inventLocationId, RetailInventoryDocumentType _documentType)
    {
        if (_documentType == RetailInventoryDocumentType::TransferOrder)
        {
            return RetailTransactionServiceInventory::calculateTransferOrderDocumentStatus(_documentId, _recId);
        }
        else if (_documentType == RetailInventoryDocumentType::InventoryAdjustment)
        {
            return RetailTransactionServiceInventory::calculateInventoryJournalDocumentStatus(_documentId, _recId);
        }
        else if (_documentType == RetailInventoryDocumentType::InventoryTransfer)
        {
            return RetailTransactionServiceInventory::calculateInventoryJournalDocumentStatus(_documentId, _recId);
        }
        else if (_documentType == RetailInventoryDocumentType::StockCounting)
        {
            return RetailTransactionServiceInventory::calculateInventoryJournalDocumentStatus(_documentId, _recId);
        }
        else
        {
            return RetailTransactionServiceInventory::calculatePurchaseOrderDocumentStatus(_documentId, _recId, _inventLocationId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransferOrderDocumentStatus</Name>
				<Source><![CDATA[
    private static RetailInventoryDocumentStatus calculateTransferOrderDocumentStatus(str _documentId, int64 _recId)
    {
        RetailTransferOrderInventoryDocumentView document;
        select firstonly sum(QtyTransfer), sum(QtyShipped), sum(QtyReceived), sum(QtyRemainShip), sum(QtyRemainReceive), documentId from document
            group by document.DocumentId
            where document.DocumentId == _documentId;

        if (!document)
        {
            eventSource.EventWriteCalculateInventoryDocumentStatusFailed(enum2Str(RetailInventoryDocumentType::TransferOrder), _recId);
            throw Exception::Error;
        }
        else if (document.QtyRemainReceive <= 0)
        {
            return RetailInventoryDocumentStatus::Received;
        }
        else if (document.QtyReceived > 0)
        {
            return RetailInventoryDocumentStatus::PartiallyReceived;
        }
        else if (document.QtyRemainShip <= 0)
        {
            return RetailInventoryDocumentStatus::Shipped;
        }
        else if (document.QtyShipped > 0)
        {
            return RetailInventoryDocumentStatus::PartiallyShipped;
        }
        else
        {
            return RetailInventoryDocumentStatus::Requested;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateInventoryJournalDocumentStatus</Name>
				<Source><![CDATA[
    private static RetailInventoryDocumentStatus calculateInventoryJournalDocumentStatus(str _documentId, int64 _recId)
    {
        InventJournalTable inventJournal;
        select firstonly Posted, JournalId from inventJournal
            where inventJournal.JournalId == _documentId;

        if (!inventJournal)
        {
            eventSource.EventWriteCalculateInventoryDocumentStatusFailed(enum2Str(RetailInventoryDocumentType::InventoryAdjustment), _recId);
            throw Exception::Error;
        }
        else if (inventJournal.Posted == NoYes::Yes)
        {
            return RetailInventoryDocumentStatus::Posted;
        }
        else if (inventJournal.IsRetailCommitted == NoYes::Yes)
        {
            return RetailInventoryDocumentStatus::Committed;
        }
        else
        {
            return RetailInventoryDocumentStatus::Requested;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePurchaseOrderDocumentStatus</Name>
				<Source><![CDATA[
    private static RetailInventoryDocumentStatus calculatePurchaseOrderDocumentStatus(str _documentId, int64 _recId, InventLocationId _inventLocationId)
    {
        RetailPurchaseOrderInventoryDocumentView document;

        select firstonly sum(QtyOrdered), sum(QtyReceived), sum(QtyRemain) from document
            group by document.DocumentId, document.DocumentState
            where document.DocumentId == _documentId
            && document.InventLocationId == _inventLocationId;
       

        if (!document)
        {
            eventSource.EventWriteCalculateInventoryDocumentStatusFailed(enum2Str(RetailInventoryDocumentType::PurchaseOrder), _recId);
            throw Exception::Error;
        }
        else if (document.QtyReceived > 0)
        {
            if (document.QtyRemain > 0)
            {
                return RetailInventoryDocumentStatus::PartiallyReceived;
            }
            else
            {
                return RetailInventoryDocumentStatus::Received;
            }
        }
        else if (document.QtyRemain > 0)
        {
            // document.QtyReceived must be 0 here, otherwise the above else if would have executed.
            if (document.DocumentState == VersioningDocumentState::Approved)
            {
                return RetailInventoryDocumentStatus::Created;
            }
            else
            {
                return RetailInventoryDocumentStatus::Requested;
            }
        }
        else
        {
            // Nothing has been received and there is nothing else to receive. The document must be cancelled.
            return RetailInventoryDocumentStatus::Cancelled;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderInventoryDocument</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument getTransferOrderInventoryDocument(str _documentId)
    {
        InventTransferTable transferOrder;
        InventTransferLine transferLine;

        select firstonly transferOrder
                group by transferOrder.TransferId, transferOrder.RecId, transferOrder.InventLocationIdFrom, transferOrder.InventLocationIdTo,
                transferOrder.DlvModeId, transferOrder.ReceiveDate, transferOrder.ShipDate
                where transferOrder.TransferId == _documentId
            join sum(QtyTransfer), sum(QtyShipped), sum(QtyReceived), sum(QtyRemainShip), count(RecId) from transferLine
                where transferLine.TransferId == transferOrder.TransferId;

        if (!transferOrder)
        {
            return null;
        }
        
        return RetailTransactionServiceInventory::populateTransferOrderInventoryDocument(transferOrder, transferLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseOrderInventoryDocument</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument getPurchaseOrderInventoryDocument(str _documentId, InventLocationId _inventLocationId)
    {
        PurchTable purchaseOrder;
        PurchLine purchaseLine;
        InventDim inventDim;
        VendInvoiceTrans vendInvoiceTrans;
        VendPackingSlipTrans vendPackingSlipTrans;

        select firstonly purchaseOrder
            group by purchaseOrder.RecId, purchaseOrder.PurchId, purchaseOrder.PurchName, purchaseOrder.DlvMode, purchaseOrder.DeliveryDate, purchaseOrder.AccountingDate
                where purchaseOrder.PurchId == _documentId
            join sum(RemainInventPhysical), sum(QtyOrdered), count(RecId) from purchaseLine
                where purchaseLine.PurchId == purchaseOrder.PurchId
            join inventDim
                where inventDim.InventDimId == purchaseLine.InventDimId
                && inventDim.InventLocationId == _inventLocationId
            outer join sum(QtyPhysical) from vendInvoiceTrans
                where vendInvoiceTrans.InventTransId == purchaseLine.InventTransId
            outer join sum(Qty) from vendPackingSlipTrans
                where vendPackingSlipTrans.InventTransId == purchaseLine.InventTransId;

        if (!purchaseOrder)
        {
            return null;
        }
        
        return RetailTransactionServiceInventory::populatePurchaseOrderInventoryDocument(purchaseOrder, purchaseLine, _inventLocationId, vendInvoiceTrans, vendPackingSlipTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalInventoryDocument</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument getJournalInventoryDocument(str _documentId)
    {
        InventJournalTable inventJournal;
        InventJournalTrans inventJournalTrans;
        InventDim inventDim;

        select firstonly inventJournal
            group by inventJournal.DataAreaId, inventJournal.RecId, inventJournal.JournalId, inventJournal.InventLocationId, inventJournal.PostedDateTime, inventJournal.JournalNameId, inventJournal.JournalType, inventJournal.Description, InventJournal.Worker
                where inventJournal.JournalId == _documentId
            outer join sum(Qty), sum(Counted), sum(InventOnhand), count(RecId) from inventJournalTrans
                where inventJournalTrans.JournalId == inventJournal.JournalId;

        if (!inventJournal)
        {
            return null;
        }
        
        return RetailTransactionServiceInventory::populateJournalInventoryDocument(inventJournal, inventJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferOrderInventoryDocumentLines</Name>
				<Source><![CDATA[
    private static System.Collections.ArrayList getTransferOrderInventoryDocumentLines(str _documentId)
    {
        var transferOrderLines = new System.Collections.ArrayList();

        InventTransferTable transferOrder;
        InventTransferLine transferLine;
        InventDim inventDim;
        while select transferOrder
                where transferOrder.TransferId == _documentId
            join transferLine
                where transferOrder.TransferId == transferLine.TransferId
            join inventDim
                where transferLine.InventDimId == inventDim.InventDimId

        {
            var documentLine = RetailTransactionServiceInventory::convertTransferOrderLineToInventoryDocumentLine(transferOrder, transferLine, inventDim);
            transferOrderLines.Add(documentLine);
        }

        return transferOrderLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalInventoryDocumentLines</Name>
				<Source><![CDATA[
    private static System.Collections.ArrayList getJournalInventoryDocumentLines(str _documentId)
    {
        var inventoryJournalLines = new System.Collections.ArrayList();

        InventJournalTable inventoryJournal;
        InventJournalTrans inventoryJournalTrans;
        InventDim inventDim;
        while select inventoryJournal
                where inventoryJournal.JournalId == _documentId
            join inventoryJournalTrans
                where inventoryJournal.JournalId == inventoryJournalTrans.JournalId
            join inventDim
                where inventoryJournalTrans.InventDimId == inventDim.InventDimId

        {
            var documentLine = RetailTransactionServiceInventory::convertInventJournalTransToInventoryDocumentLine(inventoryJournal, inventoryJournalTrans, inventDim);
            inventoryJournalLines.Add(documentLine);
        }

        return inventoryJournalLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertInventJournalTransToInventoryDocumentLine</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine convertInventJournalTransToInventoryDocumentLine(InventJournalTable inventJournal, InventJournalTrans inventJournalTrans, InventDim _inventDim)
    {
        var documentLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine();
        InventDim toInventDim;

        // Values from the header.
        documentLine.DataAreaId = inventJournal.DataAreaId;
        documentLine.DocumentId = inventJournal.JournalId;
        documentLine.DocumentRecordId = inventJournal.RecId;
        if (inventJournal.JournalType == InventJournalType::Transfer)
        {
            documentLine.DocumentType = RetailInventoryDocumentType::InventoryTransfer;
        }
        else if (inventJournal.JournalType == InventJournalType::Count)
        {
            documentLine.DocumentType = RetailInventoryDocumentType::StockCounting;
        }
        else
        {
            documentLine.DocumentType = RetailInventoryDocumentType::InventoryAdjustment;
        }
        
        documentLine.Receiver = inventJournal.InventLocationId;

        // Values from the line.
        documentLine.LineNumber = inventJournalTrans.LineNum;
        documentLine.RecordId = inventJournalTrans.RecId;
        documentLine.ItemId = inventJournalTrans.ItemId;
        documentLine.ItemName = inventJournalTrans.itemName();

        InventTableModule inventTableModule = InventTableModule::find(inventJournalTrans.ItemId, ModuleInventPurchSales::Invent, false);
        UnitOfMeasureSymbol inventoryUnitId = inventTableModule.UnitId;
        documentLine.UnitId = inventoryUnitId;
        if (inventJournal.JournalType == InventJournalType::Count)
        {
            RetailParameters retailParameters = RetailParameters::find();
            if (retailParameters.HideSystemInventoryInStockCount == NoYes::Yes)
            {
                documentLine.QuantityOrdered = 0;
            }
            else
            {
                documentLine.QuantityOrdered = inventJournalTrans.InventOnHand;
            }
        }
        else
        {
            documentLine.QuantityOrdered = inventJournalTrans.Qty;
        }

        documentLine.QuantityReceived = inventJournalTrans.Counted;
        documentLine.LocationId = _inventDim.wmsLocationId;
        documentLine.ProductId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(new Map(Types::String, Types::Int64), inventJournalTrans.ItemId,
             inventJournalTrans.DataAreaId, _inventDim.InventColorId, _inventDim.configId, _inventDim.InventSizeId, _inventDim.InventStyleId, _inventDim.InventVersionId);

        if (inventJournalTrans.ToInventDimId)
        {
            select toInventDim where toInventDim.InventDimId == inventJournalTrans.ToInventDimId;

            if (toInventDim)
            {
                documentLine.ToInventoryDimensionId = inventJournalTrans.ToInventDimId;
                documentLine.ToProductId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(new Map(Types::String, Types::Int64), inventJournalTrans.ItemId,
                          inventJournalTrans.DataAreaId, toInventDim.InventColorId, toInventDim.configId, toInventDim.InventSizeId, toInventDim.InventStyleId, toInventDim.InventVersionId);
                documentLine.ToLocationId = toInventDim.wmsLocationId;
                
                if (documentLine.ProductId != documentLine.ToProductId)
                {
                    documentLine.Status = Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentLineStatus::ReadOnly;
                }
            }
        }

        if (RetailTransactionServiceInventory::isItemSerialNumberActivated(inventJournalTrans.ItemId))
        {
            documentLine.SerialNumberLines = RetailTransactionServiceInventory::populateInventJournalSerialNumberLines(inventJournalTrans, documentLine);
        }
        else
        {
            documentLine.SerialNumberLines = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine[0]();
        }

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentLineEntity(documentLine);

        return documentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInventJournalSerialNumberLines</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine[] populateInventJournalSerialNumberLines(InventJournalTrans _inventJournalLine, Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _documentLine)
    {
        var serialNumberLines = new System.Collections.ArrayList();
        RetailJournalLineSerialNumberView serialNumber;

        if (_inventJournalLine.Qty > 0)
        {
            while select serialNumber
                where serialNumber.JournalId == _inventJournalLine.JournalId
                    && serialNumber.LineNum == _inventJournalLine.LineNum
                    && (serialNumber.ReferenceCategory == InventTransType::InventLossProfit
                        || serialNumber.ReferenceCategory == InventTransType::InventTransfer
                        || serialNumber.ReferenceCategory == InventTransType::InventTransaction)
                    && (serialNumber.StatusReceipt == StatusReceipt::Ordered
                        || serialNumber.StatusReceipt == StatusReceipt::Registered
                        || serialNumber.StatusReceipt == StatusReceipt::Purchased)
            {
                var serialNumberLine = RetailTransactionServiceInventory::convertInventJournalSerialNumberLine(_inventJournalLine, serialNumber, _documentLine);
                serialNumberLines.Add(serialNumberLine);
            }
        }
        else
        {
            while select serialNumber
                where serialNumber.JournalId == _inventJournalLine.JournalId
                    && serialNumber.LineNum == _inventJournalLine.LineNum
                    && (serialNumber.ReferenceCategory == InventTransType::InventLossProfit
                        || serialNumber.ReferenceCategory == InventTransType::InventTransfer
                        || serialNumber.ReferenceCategory == InventTransType::InventTransaction)
                        && (serialNumber.StatusIssue == StatusIssue::Sold
                        || serialNumber.StatusIssue == StatusIssue::Picked
                        || serialNumber.StatusIssue == StatusIssue::Deducted)
            {
                var serialNumberLine = RetailTransactionServiceInventory::convertInventJournalSerialNumberLine(_inventJournalLine, serialNumber, _documentLine);
                serialNumberLines.Add(serialNumberLine);
            }
        }

        return serialNumberLines.ToArray(new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine().GetType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertInventJournalSerialNumberLine</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine convertInventJournalSerialNumberLine(InventJournalTrans _inventJournalLine, RetailJournalLineSerialNumberView _serialNumber, Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _documentLine)
    {
        var serialNumberLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine();
        serialNumberLine.SourceDocumentType = _documentLine.DocumentType;
        serialNumberLine.SourceDocumentId = _inventJournalLine.JournalId;
        serialNumberLine.DocumentLineRecordId = _inventJournalLine.RecId;
        serialNumberLine.InventTransRecordId = _serialNumber.InventTransRecId;
        serialNumberLine.Quantity = abs(_serialNumber.Quantity);
        serialNumberLine.SerialNumber = _serialNumber.InventSerialId;
        serialNumberLine.Status = RetailTransactionServiceInventory::calculateReceiptSerialLineStatus(_serialNumber.StatusReceipt);
        serialNumberLine.DataAreaId = _serialNumber.DataAreaId;
        serialNumberLine.ProductId = _documentLine.ProductId;

        return serialNumberLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertTransferOrderLineToInventoryDocumentLine</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine convertTransferOrderLineToInventoryDocumentLine(InventTransferTable _transferOrder, InventTransferLine _transferLine, InventDim _inventDim)
    {
        var documentLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine();

        // Values from the header.
        documentLine.DataAreaId = _transferOrder.DataAreaId;
        documentLine.DocumentId = _transferOrder.TransferId;
        documentLine.DocumentRecordId = _transferOrder.RecId;
        documentLine.DocumentType = RetailInventoryDocumentType::TransferOrder;
        documentLine.Receiver = _transferOrder.InventLocationIdTo;

        // Values from the line.
        documentLine.LineNumber = _transferLine.LineNum;
        documentLine.RecordId = _transferLine.RecId;
        documentLine.ItemId = _transferLine.ItemId;
        documentLine.ItemName = _transferLine.itemName();

        InventTableModule inventTableModule = InventTableModule::find(_transferLine.ItemId, ModuleInventPurchSales::Invent, false);
        UnitOfMeasureSymbol inventoryUnitId = inventTableModule.UnitId;
        documentLine.UnitId = inventoryUnitId;
        documentLine.QuantityOrdered = _transferLine.QtyTransfer;
        documentLine.QuantityReceived = _transferLine.QtyReceived;
        documentLine.QuantityShipped = _transferLine.QtyShipped;
        // In over shipped scenario, the QuantityCancelled may be a minus, HQ will keep this value and let channel handle with it.
        documentLine.QuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(_transferLine.QtyTransfer, _transferLine.QtyShipped, _transferLine.QtyRemainShip);
        documentLine.OverDeliveryPercentage = _transferLine.OverDeliveryPct;
        documentLine.UnderDeliveryPercentage = _transferLine.UnderDeliveryPct;
        documentLine.LocationId = _inventDim.wmsLocationId;
        documentLine.ProductId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(new Map(Types::String, Types::Int64), _transferLine.ItemId,
             _transferLine.DataAreaId, _inventDim.InventColorId, _inventDim.configId, _inventDim.InventSizeId, _inventDim.InventStyleId, _inventDim.InventVersionId);

        if (RetailTransactionServiceInventory::isItemSerialNumberActivated(_transferLine.ItemId))
        {
            documentLine.SerialNumberLines = RetailTransactionServiceInventory::populateTransferOrderSerialNumberLines(_transferLine, documentLine);
        }
        else
        {
            documentLine.SerialNumberLines = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine[0]();
        }

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentLineEntity(documentLine);

        return documentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTransferOrderSerialNumberLines</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine[] populateTransferOrderSerialNumberLines(InventTransferLine _transferLine, Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _documentLine)
    {
        var serialNumberLines = new System.Collections.ArrayList();
        RetailTransferOrderLineSerialNumberView serialNumber;

        while select serialNumber
            where serialNumber.TransferId == _transferLine.TransferId
                && serialNumber.LineNum == _transferLine.LineNum
                && serialNumber.ReferenceCategory == InventTransType::TransferOrderReceive
                && (serialNumber.StatusReceipt == StatusReceipt::Ordered
                    || serialNumber.StatusReceipt == StatusReceipt::Registered
                    || serialNumber.StatusReceipt == StatusReceipt::Purchased)
        {
            var serialNumberLine = RetailTransactionServiceInventory::convertTransferOrderSerialNumberLine(_transferLine, serialNumber, _documentLine);
            serialNumberLines.Add(serialNumberLine);
        }

        return serialNumberLines.ToArray(new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine().GetType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertTransferOrderSerialNumberLine</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine convertTransferOrderSerialNumberLine(InventTransferLine _transferLine, RetailTransferOrderLineSerialNumberView _serialNumber, Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _documentLine)
    {
        var serialNumberLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine();
        serialNumberLine.SourceDocumentType = Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::TransferOrder;
        serialNumberLine.SourceDocumentId = _transferLine.TransferId;
        serialNumberLine.DocumentLineRecordId = _transferLine.RecId;
        serialNumberLine.InventTransRecordId = _serialNumber.InventTransRecId;
        serialNumberLine.Quantity = _serialNumber.Quantity;
        serialNumberLine.SerialNumber = _serialNumber.InventSerialId;
        serialNumberLine.Status = RetailTransactionServiceInventory::calculateReceiptSerialLineStatus(_serialNumber.StatusReceipt);
        serialNumberLine.DataAreaId = _serialNumber.DataAreaId;
        serialNumberLine.ProductId = _documentLine.ProductId;

        return serialNumberLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseOrderInventoryDocumentLines</Name>
				<Source><![CDATA[
    private static System.Collections.ArrayList getPurchaseOrderInventoryDocumentLines (str _documentId)
    {
        var purchaseOrderLines = new System.Collections.ArrayList();

        PurchTable purchTable;
        PurchLine purchLine;
        InventDim inventDim;
        while select purchTable
                where purchTable.PurchId == _documentId
            join purchLine
                where purchLine.PurchId == purchTable.PurchId && purchLine.IsDeleted == NoYes::No
            join inventDim
                where inventDim.inventDimId == purchLine.InventDimId
        {
            var documentLine = RetailTransactionServiceInventory::convertPurchaseOrderLineToInventoryDocumentLine(purchTable, purchLine, inventDim);
            purchaseOrderLines.Add(documentLine);
        }

        return purchaseOrderLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertPurchaseOrderLineToInventoryDocumentLine</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine convertPurchaseOrderLineToInventoryDocumentLine(PurchTable _purchTable, PurchLine _purchLine, InventDim _inventDim)
    {
        var documentLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine();

        documentLine.DataAreaId = _purchTable.DataAreaId;
        documentLine.DocumentId = _purchTable.PurchId;
        documentLine.DocumentRecordId = _purchTable.RecId;
        documentLine.DocumentType = RetailInventoryDocumentType::PurchaseOrder;

        // Values from the line.
        documentLine.LineNumber = _purchLine.LineNumber;
        documentLine.RecordId = _purchLine.RecId;
        documentLine.ItemId = _purchLine.ItemId;
        documentLine.ItemName = _purchLine.itemName();
        documentLine.Receiver = _inventDim.InventLocationId;
        
        InventTableModule inventTableModule = InventTableModule::find(_purchLine.ItemId, ModuleInventPurchSales::Invent, false);
        UnitOfMeasureSymbol inventoryUnitId = inventTableModule.UnitId;
        documentLine.UnitId = inventoryUnitId;
        documentLine.QuantityOrdered = _purchLine.QtyOrdered;
        Qty quantityReceived = _purchLine.receivedInventInTotal();
        documentLine.QuantityReceived = quantityReceived;
        documentLine.QuantityShipped = 0; // Not applicable for purchase orders.
        documentLine.QuantityCancelled = RetailTransactionServiceInventory::calculateInventoryOrderCancelledQuantity(documentLine.QuantityOrdered, quantityReceived, _purchLine.RemainInventPhysical);
        documentLine.OverDeliveryPercentage = _purchLine.overDeliveryPct();
        documentLine.UnderDeliveryPercentage = _purchLine.underDeliveryPct();
        documentLine.LocationId = _inventDim.wmsLocationId;
        documentLine.ProductId = RetailTransactionServiceInventory::getProductRecordIdByDimensions(new Map(Types::String, Types::Int64), _purchLine.ItemId,
             _purchLine.DataAreaId, _inventDim.InventColorId, _inventDim.configId, _inventDim.InventSizeId, _inventDim.InventStyleId, _inventDim.InventVersionId);

        if (RetailTransactionServiceInventory::isItemSerialNumberActivated(_purchLine.ItemId))
        {
            documentLine.SerialNumberLines = RetailTransactionServiceInventory::populatePurchaseOrderSerialNumberLines(_purchLine, documentLine);
        }
        else
        {
            documentLine.SerialNumberLines = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine[0]();
        }

        RetailTransactionServiceInventory::attachNoteToInventoryDocumentLineEntity(documentLine);

        return documentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePurchaseOrderSerialNumberLines</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine[] populatePurchaseOrderSerialNumberLines(PurchLine _purchLine, Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _documentLine)
    {
        var serialNumberLines = new System.Collections.ArrayList();
        RetailPurchaseOrderLineSerialNumberView serialNumber;

        while select serialNumber
            where serialNumber.PurchId == _purchLine.PurchId
                && serialNumber.LineNumber == _purchLine.LineNumber
                && serialNumber.ReferenceCategory == InventTransType::Purch
                && (serialNumber.StatusReceipt == StatusReceipt::Ordered
                    || serialNumber.StatusReceipt == StatusReceipt::Registered
                    || serialNumber.StatusReceipt == StatusReceipt::Received)
        {
            var serialNumberLine = RetailTransactionServiceInventory::convertPurchaseOrderSerialNumberLine(_purchLine, serialNumber, _documentLine);
            serialNumberLines.Add(serialNumberLine);
        }

        return serialNumberLines.ToArray(new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine().GetType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertPurchaseOrderSerialNumberLine</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine convertPurchaseOrderSerialNumberLine(PurchLine _purchLine, RetailPurchaseOrderLineSerialNumberView _serialNumber, Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _documentLine)
    {
        var serialNumberLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryDocumentSourceSerialNumberLine();
        serialNumberLine.SourceDocumentType = Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::PurchaseOrder;
        serialNumberLine.SourceDocumentId = _purchLine.PurchId;
        serialNumberLine.DocumentLineRecordId = _purchLine.RecId;
        serialNumberLine.InventTransRecordId = _serialNumber.InventTransRecId;
        serialNumberLine.Quantity = _serialNumber.Quantity;
        serialNumberLine.SerialNumber = _serialNumber.InventSerialId;
        serialNumberLine.Status = RetailTransactionServiceInventory::calculateReceiptSerialLineStatus(_serialNumber.StatusReceipt);
        serialNumberLine.DataAreaId = _serialNumber.DataAreaId;
        serialNumberLine.ProductId = _documentLine.ProductId;

        return serialNumberLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateReceiptSerialLineStatus</Name>
				<Source><![CDATA[
    private static Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySerialNumberLineStatus calculateReceiptSerialLineStatus(StatusReceipt _statusReceipt)
    {
        switch (_statusReceipt)
        {
            case StatusReceipt::Purchased: // For transfer order
            case StatusReceipt::Received: // For purchase order.
                return Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySerialNumberLineStatus::Registered;
            default:
                return Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySerialNumberLineStatus::NotRegistered;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>attachNoteToInventoryDocumentEntity</Name>
				<Source><![CDATA[
    private static void attachNoteToInventoryDocumentEntity(Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocument _sourceDocument)
    {
        DocuRef docuRef;

        if (_sourceDocument.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::TransferOrder)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocument.DataAreaId, tableNum(InventTransferTable), _sourceDocument.RecordId);
        }
        else if (_sourceDocument.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::PurchaseOrder)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocument.DataAreaId, tableNum(PurchTable), _sourceDocument.RecordId);
        }
        else if (_sourceDocument.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::InventoryAdjustment)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocument.DataAreaId, tableNum(InventJournalTable), _sourceDocument.RecordId);
        }
        else if (_sourceDocument.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::InventoryTransfer)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocument.DataAreaId, tableNum(InventJournalTable), _sourceDocument.RecordId);
        }

        if (docuRef)
        {
            _sourceDocument.Note = docuRef.Notes;
            _sourceDocument.NoteModifiedByStaffId = HcmWorker::findByPerson(docuRef.Party).PersonnelNumber;
            System.DateTime noteModifiedDateTime = Global::utcDateTime2SystemDateTime(docuRef.ModifiedDateTime);
            _sourceDocument.NoteModifiedDateTime = new System.DateTimeOffset(noteModifiedDateTime, System.TimeSpan::Zero);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>attachNoteToInventoryDocumentLineEntity</Name>
				<Source><![CDATA[
    private static void attachNoteToInventoryDocumentLineEntity(Microsoft.Dynamics.Commerce.Runtime.DataModel.InventoryInboundOutboundSourceDocumentLine _sourceDocumentLine)
    {
        DocuRef docuRef;

        if(_sourceDocumentLine.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::TransferOrder)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocumentLine.DataAreaId, tableNum(InventTransferLine), _sourceDocumentLine.RecordId);
        }
        else if(_sourceDocumentLine.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::PurchaseOrder)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocumentLine.DataAreaId, tableNum(PurchLine), _sourceDocumentLine.RecordId);
        }
        else if (_sourceDocumentLine.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::InventoryAdjustment)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocumentLine.DataAreaId, tableNum(InventJournalTrans), _sourceDocumentLine.RecordId);
        }
        else if (_sourceDocumentLine.DocumentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.InventorySourceDocumentType::InventoryTransfer)
        {
            docuRef = RetailTransactionServiceInventory::findNoteByTableIdRecId(_sourceDocumentLine.DataAreaId, tableNum(InventJournalTrans), _sourceDocumentLine.RecordId);
        }

        if(docuRef)
        {
            _sourceDocumentLine.Note = docuRef.Notes;
            _sourceDocumentLine.NoteModifiedByStaffId = HcmWorker::findByPerson(docuRef.Party).PersonnelNumber;
            System.DateTime noteModifiedDateTime = Global::utcDateTime2SystemDateTime(docuRef.ModifiedDateTime);
            _sourceDocumentLine.NoteModifiedDateTime = new System.DateTimeOffset(noteModifiedDateTime, System.TimeSpan::Zero);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNoteByTableIdRecId</Name>
				<Source><![CDATA[
    private static DocuRef findNoteByTableIdRecId(DataAreaId refDataareaId, TableId refTableId, RecId refRecId)
    {
        DocuRef     docuRef;
        
        refTableId = DocuRef::GetRootTableID(refTableId);
        select firstonly docuRef
                    order by docuRef.ModifiedDateTime desc
                    where docuRef.RefCompanyId  == refDataareaId    &&
                          docuRef.RefTableId    == refTableId       &&
                          docuRef.RefRecId      == refRecId;

        return docuRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventoryLookupQueryRun</Name>
				<Source><![CDATA[
    private static QueryRun buildInventoryLookupQueryRun(CRT.TransactionService.TransactionServiceInventoryLookupSearchCriteria searchCriteria, boolean useOrgUnitAvailabilitySearchCriteria)
    {
        CRT.DataModel.PagingInfo pagingInfo = searchCriteria.Paging;
        CRT.DataModel.SortingInfo sortingInfo = searchCriteria.Sorting;

        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(TmpRetailStoreInventoryInfo));

        // Add filters
        if (useOrgUnitAvailabilitySearchCriteria && searchCriteria.OrgUnitAvailabilitySearchCriteria != null)
        {
            if (searchCriteria.OrgUnitAvailabilitySearchCriteria.OrgUnitNumber)
            {
                qbds.addRange(fieldNum(TmpRetailStoreInventoryInfo, StoreNumber)).value(strFmt('*%1*', queryValue(searchCriteria.OrgUnitAvailabilitySearchCriteria.OrgUnitNumber)));
            }

            if (searchCriteria.OrgUnitAvailabilitySearchCriteria.OrgUnitName)
            {
                qbds.addRange(fieldNum(TmpRetailStoreInventoryInfo, Name)).value(strFmt('*%1*', queryValue(searchCriteria.OrgUnitAvailabilitySearchCriteria.OrgUnitName)));
            }
        }

        // Implement sorting.
        int sortColumnsCount = sortingInfo != null ? sortingInfo.get_Count() : 0;
        if (sortColumnsCount > 0)
        {
            CLRSystem.Collections.IEnumerable sortColumns = sortingInfo.get_Columns();
            System.Collections.IEnumerator sortColumnEnumerator = sortColumns.GetEnumerator();
            while (sortColumnEnumerator.MoveNext())
            {
                CRT.DataModel.SortColumn sortColumn = sortColumnEnumerator.get_Current();
                str columnName = sortColumn.get_ColumnName();

                boolean isDescending = sortColumn.get_IsDescending();
                SortOrder sortOrder = isDescending ? SortOrder::Descending : SortOrder::Ascending;

                switch(columnName)
                {
                    case AvailPhysicalSortColumnName:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, AvailPhysical), SortOrder);
                        break;
                    case PhysicalReservedSortColumnName:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, PhysicalReserved), SortOrder);
                        break;
                    case OrderedSumSortColumnName:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, OrderedSum), SortOrder);
                        break;
                    case LocationNameSortColumnName:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, Name), SortOrder);
                        break;
                    case StoreNumberSortColumnName:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, StoreNumber), SortOrder);
                        break;
                    case GeoDistanceSortColumnName:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, Distance), sortOrder);
                        break;
                    default:
                        qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, Distance), SortOrder::Ascending);
                        break;
                }
            }
        }
        else
        {
            // By default, sort by geo distance in ascending order.
            qbds.addOrderByField(fieldNum(TmpRetailStoreInventoryInfo, Distance), SortOrder::Ascending);
        }

        // Implement pagination.
        QueryRun qr = new QueryRun(query);
        qr.enablePositionPaging(true);
        // Translate "skip" to AX 1-based starting position.
        qr.addPageRange(pagingInfo.Skip <= 0 ? 1 : pagingInfo.Skip + 1, pagingInfo.Top);

        return qr;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyCustomFiltersToQueryBuildDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies custom filters from extensions to the QueryBuildDataSource.
    /// </summary>
    /// <param name = "_searchCriteria">The search criteria.</param>
    /// <param name = "_qbds">The search journal query QueryBuildDataSource object that can be used for adding custom datasources and filters.</param>
    private static void applyCustomFiltersToQueryBuildDataSource(Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceInventoryDocumentSearchCriteria _searchCriteria, QueryBuildDataSource _qbds)
    {
        if (_searchCriteria.CustomFilters)
        {
            List extensionRanges = new List(Types::Container);
            System.Collections.ICollection customFilters = _searchCriteria.CustomFilters as System.Collections.ICollection;

            // Extensible: Gather custom filters from extensions
            RetailTransactionServiceInventory::registerGetInventoryDocumentsCustomFilterRanges(customFilters, extensionRanges);
          
            // Internal: Apply custom filters as query ranges
            RetailTransactionServiceInventory::addExtensionFieldRangeValue(_qbds, extensionRanges);

            // Extensible: Call extension point to add custom data sources and filters
            RetailTransactionServiceInventory::registerGetInventoryDocumentsCustomDataSources(customFilters, _qbds);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExtensionFieldRangeValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the extension fields range values.
    /// </summary>
    /// <param name = "_qbds">The search inventory documents query QueryBuildDataSource object that can be used for adding custom datasources and filters.</param>
    /// <param name = "_extensionRanges">List of the containers (extensionFieldName, extensionFieldValue) used to build query ranges for custom filters from extensions.</param>
    private static void addExtensionFieldRangeValue(QueryBuildDataSource _qbds, List _extensionRanges)
    {
        ListEnumerator extensionRangeEnumerator = _extensionRanges.getEnumerator();
        while (extensionRangeEnumerator.moveNext())
        {
            str extensionFieldName;
            str extensionFieldValue;

            [extensionFieldName, extensionFieldValue] = extensionRangeEnumerator.current();
            int extensionFieldId = fieldName2Id(_qbds.table(), extensionFieldName);
            if (extensionFieldId)
            {
                _qbds.addRange(extensionFieldId).value(extensionFieldValue);
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>