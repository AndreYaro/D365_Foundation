<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ChargeSourceDocLineItem</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ChargeSourceDocLineItem</c> class provides information to handle the distributions and
/// subledger journal account entries for a <c>MarkupTrans</c> object.
/// </summary>
[
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductOrder), SourceDocumentLine_ProductOrder::PurchaseOrderTotalsChargeLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductOrder), SourceDocumentLine_ProductOrder::PurchaseOrderChargeLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ProductRequisition), SourceDocumentLine_ProductRequisition::PurchaseRequisitionChargeLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_CustomerInvoice), SourceDocumentLine_CustomerInvoice::CustomerInvoiceChargeLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_CustomerInvoice), SourceDocumentLine_CustomerInvoice::CustomerInvoiceLineChargeLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_VendorInvoice), SourceDocumentLine_VendorInvoice::VendorInvoiceTotalsChargeLine),
SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_VendorInvoice), SourceDocumentLine_VendorInvoice::VendorInvoiceChargeLine)
]
public class ChargeSourceDocLineItem extends SourceDocumentLineItem implements
    SourceDocumentLineItemICharge,
    SourceDocumentLineItemIFinalize,
    SourceDocLineItemICustInvJournalizing,
    SourceDocumentIClearChildLineItemList
{
    MarkupTable         markupTable;
    MarkupTrans         markupTrans;
    Amount              actualChargeAmount;
    Amount              expectedChargeAmount;
    Amount              varianceChargeAmount;
    boolean             actualChargeCalculated;
    boolean             matchingListInitialized;
    boolean             isMarkupTableInitialized;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateLegalEntityRecId</Name>
				<Source><![CDATA[
    protected LegalEntityRecId calculateLegalEntityRecId()
    {
        return CompanyInfo::current();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSourceDocumentAmountMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the amount map for the line.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>SourceDocumentAmountMap</c> class.
    /// </returns>
    /// <remarks>
    /// This map is cached in the <c>SourceDocumentLineItem.parmSourceDocumentAmountMap</c> method. All
    /// consumers must use that method to retrieve the map because it will call this method as necessary.
    /// </remarks>
    public SourceDocumentAmountMap calculateSourceDocumentAmountMap()
    {
        SourceDocumentAmountMap                     sourceDocumentAmountMap = SourceDocumentAmountMap::construct();
        SourceDocumentAmount                        sourceDocumentAmount;
        boolean                                     includesTax;
        ChargeDebitCredit                           chargeDebitCredit;

        includesTax             = this.includesTax();

        this.initializeAmounts();

        chargeDebitCredit = ChargeDebitCredit::construct(this.parmMarkupTable());

        MarkupTable localMarkupTable = this.parmMarkupTable() as MarkupTable;

        // markups specified this way are considered rebates and should be tracked as negatives
        // the logic can be moved to ChargeDebitCredit once all countries return true for isLegalEntityInConsolidatedCountryRegion
        // as of right now, the markuptrans needs to be passed in order for the checks to go through properly
        if ((markupTrans.TransTableId == tableNum(CustInvoiceTable) || markupTrans.TransTableId == tableNum(CustInvoiceJour)
            || (markupTrans.TransTableId == tableNum(CustInvoiceLine) && SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
            || (markupTrans.TransTableId == tableNum(CustInvoiceTrans) && SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
            ) && (localMarkupTable.CustType == MarkupType::LedgerAccount && localMarkupTable.VendType == MarkupType::CustVend))
        {
            actualChargeAmount = -actualChargeAmount;
            varianceChargeAmount = -varianceChargeAmount;
        }

        sourceDocumentAmount = SourceDocumentAmount::newFromParameters(sourceDocumentLine, chargeDebitCredit.amount(actualChargeAmount - varianceChargeAmount), MonetaryAmount::Charge, includesTax);
        sourceDocumentAmountMap.insert(sourceDocumentAmount);

        if (varianceChargeAmount)
        {
            sourceDocumentAmount = SourceDocumentAmount::newFromParameters(sourceDocumentLine, chargeDebitCredit.amount(varianceChargeAmount), MonetaryAmount::ChargeVariance, includesTax);
            sourceDocumentAmountMap.insert(sourceDocumentAmount);
        }

        return sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMainAccDerivationInputChanged</Name>
				<Source><![CDATA[
    public boolean hasMainAccDerivationInputChanged()
    {
        boolean hasChanged;

        if (this.parmMarkupTrans().TransTableId == tableNum(VendInvoiceInfoLine) && this.parmParentSourceDocumentLineItem() && this.parmParentSourceDocumentLineItem().hasMainAccDerivationInputChanged())
        {
            hasChanged = true;   // if a parent has changed, then the children will as well.
        }
        else
        {
            hasChanged = super();
        }

        return hasChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMatchedMainAccDerivationInputChanged</Name>
				<Source><![CDATA[
    public boolean hasMatchedMainAccDerivationInputChanged()
    {
        boolean hasChanged;

        if (this.parmMarkupTrans().TransTableId == tableNum(VendInvoiceInfoLine) && this.parmParentSourceDocumentLineItem() && this.parmParentSourceDocumentLineItem().hasMatchedMainAccDerivationInputChanged())
        {
            hasChanged = true;   // if a parent has changed, then the children will as well.
        }
        else
        {
            hasChanged = super();
        }

        return hasChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includesTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the transaction amount includes tax amount.
    /// </summary>
    /// <returns>
    /// true if the transaction amount includes tax; otherwise, false.
    /// </returns>
    private boolean includesTax()
    {
        PurchTable              purchTable;
        PurchLine               purchLine;
        VendInvoiceInfoTable    vendInvoiceInfoTable;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        VendInvoiceInfoLine     vendInvoiceInfoLine;
        VendInvoiceMap          vendInvoiceMap;
        CustInvoiceTable        custInvoiceTable;
        boolean                 includesTax;

        // <GTE>
        CustInvoiceTrans        custInvoiceTrans;
        Incltax                 isGTEInclTax;
        boolean                 isGTEEnabled = TaxSolutionScopeIntegrationUtil::isCompanyEnabled();

        if (isGTEEnabled)
        {
            isGTEInclTax = TransTaxInformationHelper::findOrCreateTransTaxInformation(markupTrans.TransTableId, markupTrans.TransRecId).InclTax;
        }
        // </GTE>

        switch (markupTrans.TransTableId)
        {
            case tableNum(PurchLine):
                purchLine = markupTrans.parentRecord();
                purchTable = purchLine.purchTable();

                if ((!isGTEEnabled && purchTable.InclTax)
                    // <GTE>
                    || (isGTEEnabled && isGTEInclTax))
                    // </GTE>
                {
                    includesTax = true;
                }
                break;

            case tableNum(PurchTable):
                purchTable = markupTrans.parentRecord();

                if (purchTable.InclTax)
                {
                    includesTax = true;
                }
                break;

            case tableNum(VendInvoiceInfoTable):
                vendInvoiceInfoTable = markupTrans.parentRecord();
                vendInvoiceMap = vendInvoiceInfoTable;

                if (vendInvoiceMap.isInclTax())
                {
                    includesTax = true;
                }
                break;

            case tableNum(VendInvoiceInfoSubTable):
                vendInvoiceInfoSubTable = markupTrans.parentRecord();
                vendInvoiceInfoTable = vendInvoiceInfoSubTable.vendInvoiceInfoTable();
                vendInvoiceMap = vendInvoiceInfoTable;

                if (vendInvoiceMap.isInclTax())
                {
                    includesTax = true;
                }
                break;

            case tableNum(VendInvoiceInfoLine):
                vendInvoiceInfoLine = markupTrans.parentRecord();
                vendInvoiceInfoTable = vendInvoiceInfoLine.vendInvoiceInfoTable();
                vendInvoiceMap = vendInvoiceInfoTable;

                if ((!isGTEEnabled && vendInvoiceMap.isInclTax())
                    // <GTE>
                    || (isGTEEnabled && isGTEInclTax))
                    // </GTE>
                {
                    includesTax = true;
                }
                break;

            case tableNum(PurchReqTable), tableNum(PurchReqLine):
                includesTax = false;
                break;

            case tableNum(CustInvoiceTable):
                custInvoiceTable = markupTrans.parentRecord();

                if (custInvoiceTable.InclTax)
                {
                    includesTax = true;
                }
                else
                {
                    includesTax = false;
                }
                break;

            default:
                if (markupTrans.TransTableId == tableNum(CustInvoiceLine) && SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                {
                    // <GTE>
                    if (isGTEEnabled && isGTEInclTax)
                    {
                        includesTax = true;
                    }
                    else
                    {
                        // </GTE>
                        includesTax = false;
                        // <GTE>
                    }
                    // </GTE>
                }
                else
                {
                    if (isGTEEnabled && markupTrans.TransTableId == tableNum(CustInvoiceTrans))
                    {
                        custInvoiceTrans = markupTrans.parentRecord();
                        if (!custInvoiceTrans.salesId && isGTEInclTax)
                        {
                            includesTax = true;
                            break;
                        }
                    }

                    if (TaxParameters::find().JournalInclTax)
                    {
                        includesTax = true;
                    }
                }
        }

        return includesTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeAmounts</Name>
				<Source><![CDATA[
    public void initializeAmounts()
    {
        Object                                      object;
        SourceDocumentIChargeSource                 iChargeSource;
        Amount                                      inputAmount;
        boolean                                     isTaxIncluded;
        SourceDocumentAmountMap                     sourceDocumentAmountMap = SourceDocumentAmountMap::construct();
        boolean                                     changeAmountSign;
        Qty                                         inputQty;
        VendInvoiceInfoLine                         vendInvoiceInfoLine;
        VendInvoiceInfoSubTable                     vendInvoiceInfoSubTable;
        ChargeSourceDocLineItem                     referencedSourceDocumentLineItem;
        SourceDocumentLineMatchingListEnumerator    sourceDocumentLineMatchingListEnumerator;
        SourceDocumentLineMatching                  sourceDocumentLineMatching;
        MarkupTrans                                 referencedMarkupTrans;
        PurchLine                                   purchLine;
        boolean                                     isInterCompanyMarkup = true;
        SourceDocumentIPurchaseOrder                sourceDocumentIPurchaseOrder;

        // <GTE>
        PurchLine           purchLineGTE;
        VendInvoiceInfoLine vendInvoiceInfoLineGTE;
        CustInvoiceLine     custInvoiceLineGTE;
        CustInvoiceTrans    custInvoiceTransGTE;
        ITaxDocument        taxDocumentObj;
        ITaxableDocument    taxableDocument;
        ITaxDocumentLine    taxDocumentLineObj;
        TaxAmountCur        inclusiveTaxAmountForCharge;
        // </GTE>

        if (! actualChargeCalculated)
        {
            object = this.getDataProvider();

            if (object is SourceDocumentIChargeSource)
            {
                iChargeSource = object as SourceDocumentIChargeSource;
                iChargeSource.parmChargeSource(markupTrans);
                inputAmount     = iChargeSource.parmChargeInputAmount();
                inputQty        = iChargeSource.parmChargeQuantity();
                isTaxIncluded   = iChargeSource.parmIsTaxInChargeInputAmountIncluded();

                sourceDocumentIPurchaseOrder = iDataProviderInternal as SourceDocumentIPurchaseOrder;
                if (sourceDocumentIPurchaseOrder != null)
                {
                    isInterCompanyMarkup = sourceDocumentIPurchaseOrder.parmPurchTable().isInterCompanyOrder();
                }

                // <GEERU>
                if (inputQty || (markupTrans.TransTableId != tableNum(VendInvoiceInfoLine)))
                {
                    actualChargeAmount = Markup::calcMarkupAmount(
                                                markupTrans,
                                                inputQty,
                                                inputAmount,
                                                0,
                                                isTaxIncluded,
                                                NoYes::No,
                                                markupTrans.CurrencyCode,
                                                markupTrans.TransDate,
                                                0,
                                                0,
                                                null,
                                                true, //_calcTax_RU
                                                isInterCompanyMarkup);
                }
                // </GEERU>

                // <GTE>
                if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
                    && SysDictTable::isTableMapped(tableNum(SalesPurchJournalLine), markupTrans.TransTableId)
                    && TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(markupTrans).InclTax)
                {
                    switch (markupTrans.TransTableId)
                    {
                        case tableNum(PurchLine):
                            purchLineGTE = PurchLine::findRecId(markupTrans.TransRecId);
                            taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(purchLineGTE.purchTable()));
                            break;
                        
                        case tableNum(VendInvoiceInfoLine):
                            vendInvoiceInfoLineGTE = VendInvoiceInfoLine::findRecId(markupTrans.TransRecId);
                            taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(vendInvoiceInfoLineGTE.vendInvoiceInfoTable()));
                            break;

                        case tableNum(CustInvoiceLine):
                            custInvoiceLineGTE = CustInvoiceLine::find(markupTrans.TransRecId);
                            taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custInvoiceLineGTE.custInvoiceTable()));
                            break;

                        default:
                            break;
                    }

                    if (taxableDocument)
                    {
                        taxDocumentObj = TaxBusinessService::calculateTax(taxableDocument);
                        if (taxDocumentObj)
                        {
                            taxDocumentLineObj = taxDocumentObj.findLineBySource(markupTrans.TableId, markupTrans.RecId);
                            if (taxDocumentLineObj)
                            {
                                inclusiveTaxAmountForCharge = taxDocumentLineObj.getInclTax().value();
                                if (sign(actualChargeAmount) == sign(inclusiveTaxAmountForCharge))
                                {
                                    inclusiveTaxAmountForCharge = inclusiveTaxAmountForCharge * -1;
                                }
                                actualChargeAmount += inclusiveTaxAmountForCharge;
                            }
                        }
                    }
                }
                // </GTE>
            }

            // If the charge is already posted, use the real posted amount.
            if (markupTrans.Posted)
            {
                // The posted sign can be different from the original charge sign if the original document amount is on the credit side.
                if (markupTrans.Posted * actualChargeAmount < 0)
                {
                    changeAmountSign = true;
                }

                TaxAmount taxAmount;
                if (markupTrans.TransTableId == tableNum(VendInvoiceTrans)
                    && markupTrans.TaxAmount)
                {
                    taxAmount = markupTrans.TaxAmount;
                }

                actualChargeAmount = markupTrans.Posted - taxAmount;
            }

            actualChargeCalculated = true;

            this.initSourceDocumentLineMatchingList();

            if (sourceDocumentLineMatchingList && sourceDocumentLineMatchingList.elements() > 0)
            {
                inputAmount = 0.0;

                sourceDocumentLineMatchingListEnumerator = sourceDocumentLineMatchingList.getEnumerator();
                sourceDocumentLineMatchingListEnumerator.moveNext();
                sourceDocumentLineMatching = sourceDocumentLineMatchingListEnumerator.current();
                referencedSourceDocumentLineItem = sourceDocumentLineMatching.parmIndependentSourceDocumentLineItem();
                referencedMarkupTrans = referencedSourceDocumentLineItem.parmSourceDocumentLine().getSourceDocumentLineImplementation();

                if (referencedMarkupTrans.MarkupCategory != MarkupCategory::Fixed)
                {
                    // need to find the expected amount for this invoice line as the invoice qty and unit price might differ from the po
                    if (markupTrans.TransTableId == tableNum(VendInvoiceInfoSubTable))
                    {
                        vendInvoiceInfoSubTable = VendInvoiceInfoSubTable::findRecId(markupTrans.TransRecId);
                        while select ParmId, TableRefId, OrigPurchId, ReceiveNow from vendInvoiceInfoLine
                            join purchLine where
                            vendInvoiceInfoLine.ParmId == vendInvoiceInfoSubTable.ParmId &&
                            vendInvoiceInfoLine.TableRefId == vendInvoiceInfoSubTable.TableRefId &&
                            vendInvoiceInfoLine.OrigPurchId == vendInvoiceInfoSubTable.OrigPurchId &&
                            purchLine.RecId == vendInvoiceInfoLine.PurchLineRecId
                        {
                            purchLine.LineAmount = purchLine.calcLineAmount(vendInvoiceInfoLine.ReceiveNow);
                            inputAmount += purchLine.LineAmount;
                        }
                    }
                    else if (markupTrans.TransTableId == tableNum(VendInvoiceInfoLine))
                    {
                        vendInvoiceInfoLine = VendInvoiceInfoLine::findRecId(markupTrans.TransRecId);
                        purchLine = vendInvoiceInfoLine.purchLine();
                        purchLine.LineAmount = purchLine.calcLineAmount(vendInvoiceInfoLine.ReceiveNow);
                        inputAmount = purchLine.LineAmount;
                        inputQty = vendInvoiceInfoLine.ReceiveNow;
                    }
                }

                // Misc charge variances should never be created for PO charges, therefore this logic does not need to be run under those scenarios
                if (markupTrans.TransTableId != tableNum(PurchLine))
                {
                    object = referencedSourceDocumentLineItem.getDataProvider();
                    if (object is SourceDocumentIChargeSource)
                    {
                        iChargeSource       = object as SourceDocumentIChargeSource;
                        isTaxIncluded       = iChargeSource.parmIsTaxInChargeInputAmountIncluded();
                    }

                    if (referencedMarkupTrans.MarkupCategory == MarkupCategory::Fixed &&
                        (referencedMarkupTrans.TransTableId == tableNum(PurchTable) || referencedMarkupTrans.TransTableId == tableNum(PurchLine)))
                    {
                        // A fixed markup on an invoice must relieve the entire PO markup at the first oppurtunity
                        // <GEERU>
                        expectedChargeAmount = Markup::calcMarkupAmount(referencedMarkupTrans, inputQty, referencedMarkupTrans.Value,  0, isTaxIncluded,
                                                        NoYes::No,
                                                        markupTrans.CurrencyCode,
                                                        markupTrans.TransDate,
                                                        0,
                                                        0,
                                                        null,
                                                        true //_calcTax_RU
                                                        );
                        // </GEERU>
                    }
                    else if (markupTrans.CorrectedMarkupTrans != 0)
                    {
                        // corrections may be for a different amount but it is not a variance so the expected is always the same as the actual
                        expectedChargeAmount = actualChargeAmount;
                    }
                    else if (markupTrans.useValueFromReferencedIntercompanyPercentPurchaseLineCharge(referencedMarkupTrans))
                    {
                        expectedChargeAmount = markupTrans.InterCompanyMarkupValue;
                    }
                    else
                    {
                        // <GEERU>
                        expectedChargeAmount = Markup::calcMarkupAmount(referencedMarkupTrans, inputQty, inputAmount, 0, isTaxIncluded,
                                                        NoYes::No,
                                                        markupTrans.CurrencyCode,
                                                        markupTrans.TransDate,
                                                        0,
                                                        0,
                                                        null,
                                                        true //_calcTax_RU
                                                        );
                        // </GEERU>
                    }

                    varianceChargeAmount = actualChargeAmount - expectedChargeAmount;
                }
            }

            if  (changeAmountSign)
            {
                actualChargeAmount = actualChargeAmount * -1;
                varianceChargeAmount = varianceChargeAmount * -1;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeExchangeRates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the exchange rates.
    /// </summary>
    protected void initializeExchangeRates()
    {
        ExchangeRateHelper          exchangeRateHelper;

        if (markupTrans.CurrencyCode == markupTrans.parentCurrencyCode())
        {
            var dataProvider = this.getDataProvider();

            if (dataProvider is SourceDocumentIChargeSource)
            {
                SourceDocumentIChargeSource chargeSource = dataProvider as SourceDocumentIChargeSource;
                exchRate1 = chargeSource.parmExchangeRate1();
                exchRate2 = chargeSource.parmExchangeRate2();

                if (dataProvider is SourceDocumentIReportingExchRate)
                {
                    SourceDocumentIReportingExchRate reportingExchRate = dataProvider as SourceDocumentIReportingExchRate;
                    reportingCurrencyexchRate1 = reportingExchRate.parmReportingCurrencyExchangeRate1();
                }
            }
            else
            {
                super();
            }
        }
        else
        {
            exchangeRateHelper = ExchangeRateHelper::newExchangeDate(Ledger::current(), markupTrans.CurrencyCode, markupTrans.parmExchangeRateDate());
            exchRate1 = exchangeRateHelper.getExchangeRate1();
            exchRate2 = exchangeRateHelper.getExchangeRate2();
        }

        exchangeRateInitialized = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the instance variables.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    ///    The source document line implementation table.
    /// </param>
    /// <param name="_additionalInformation">
    /// A map to hold buffers of pre initiliazed objects need by the framework to the source document.
    /// </param>
    protected void initializeImplementation(SourceDocumentLineImplementation _sourceDocumentLineImplementation, Map _additionalInformation = null)
    {
        markupTrans = _sourceDocumentLineImplementation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOriginSourceDocumentLineItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes original <c>MarkupTrans</c> to be used for dimension derivation and allocation.
    /// </summary>
    /// <remarks>
    /// In cases where there is no origin, this will return a null <c>SourceDocumentLineItem</c>.
    /// </remarks>
    protected void initOriginSourceDocumentLineItem()
    {
        MarkupTrans                 originMarkupTrans;
        boolean                     useOriginIfExists;
        boolean                     isOriginCopied;

        isOriginCopied = true;

        switch (markupTrans.TransTableId)
        {
            case tableNum(PurchTable) :
            case tableNum(PurchLine) :
                originMarkupTrans = this.initOriginForPurchaseTableAndLine();

                // Use origin in cases of credit note defaulting from Vendor Invoice
                switch (originMarkupTrans.TransTableId)
                {
                    case tableNum(VendInvoiceJour):
                    case tableNum(VendInvoiceTrans):
                    useOriginIfExists = true;
                    isOriginCopied = false;
                        break;
                }

            default :
                break;
        }

        if (useOriginIfExists && originMarkupTrans.RecId != 0 && originMarkupTrans.SourceDocumentLine != 0)
        {
            originSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLineImplementation(originMarkupTrans);
            isCopyOfOriginSourceDocumentLineItem = isOriginCopied;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineMatchingList</Name>
				<Source><![CDATA[
    protected void initSourceDocumentLineMatchingList()
    {
        PurchLine                                   purchLine;
        MarkupTrans                                 referencedMarkupTrans;
        SourceDocumentAmountMap                     sourceDocumentAmountMap = SourceDocumentAmountMap::construct();
        PurchLine                                   orderLine;
        PurchReqLineRefId                           purchReqLineRefId;
        PurchDeliverySchedule                       purchDeliverySchedule;

        if (matchingListInitialized)
        {
            return;
        }

        switch (markupTrans.TransTableId)
        {
            case tableNum(PurchLine):
                purchLine = PurchLine::findRecId(markupTrans.TransRecId);

                if (purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine && purchLine.PurchReqId != '')
                {
                    // for delivery schedule line need to find the commercial order line to get
                    // reference to purchase requisition line
                    select RecId from purchDeliverySchedule
                        where purchDeliverySchedule.DeliveryLine == purchLine.InventTransId
                        join PurchReqLineRefId from orderLine
                            where orderLine.InventTransId == purchDeliverySchedule.OrderLine;

                    if (orderLine)
                    {
                         purchReqLineRefId = orderLine.PurchReqLineRefId;
                    }
                }
                else if (purchLine.PurchReqLineRefId)
                {
                    purchReqLineRefId = purchLine.PurchReqLineRefId;
                }

                if (purchReqLineRefId
                    && markupTrans.OrigTableId == tableNum(PurchReqLine))
                {
                    select firstonly referencedMarkupTrans
                        where referencedMarkupTrans.TransTableId == markupTrans.OrigTableId
                           && referencedMarkupTrans.TransRecId   == markupTrans.OrigRecId
                            && referencedMarkupTrans.LineNum     == markupTrans.LineNum;
                }
                break;

            case tableNum(CustInvoiceTable):
                // corrections are based on a matched markup similar to invoices beiong matched to a PO
                select firstonly referencedMarkupTrans
                    where referencedMarkupTrans.RecId == markupTrans.CorrectedMarkupTrans;
                break;

            case tableNum(VendInvoiceInfoSubTable):
            case tableNum(VendInvoiceInfoLine):
                referencedMarkupTrans = markupTrans.findOrig();

                if (referencedMarkupTrans.isBOERelated())
                {
                    // While the charge is on BOE journal, there is no distribution and source document line for it.
                    // Skip the reference here, otherwise it will throw null reference exception as it cannot generate SDF object.
                    referencedMarkupTrans = null;
                }
                break;

            default:
                if (markupTrans.TransTableId == tableNum(CustInvoiceLine) && SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                {
                    // corrections are based on a matched markup similar to invoices beiong matched to a PO
                    select firstonly referencedMarkupTrans
                       where referencedMarkupTrans.RecId == markupTrans.CorrectedMarkupTrans;
                }
        }

        if (referencedMarkupTrans.RecId != 0)
        {
            referencedMarkupTrans.SourceDocumentLine = this.getMarkupTransSourceDocumentLine(referencedMarkupTrans);

            sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this, referencedMarkupTrans);
            matchingListInitialized = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupTransSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the source document line reference from the charge.
    /// </summary>
    /// <param name = "_referencedMarkupTrans">A charge for which to lookup the source document line.</param>
    /// <returns>A <c>SourceDocumentLineRefRecId</c> reference of the <c>MarkupTrans</c> table buffer.</returns>
    /// <remarks>
    /// In intercompany scenario there exists a concept of virtual charge upon intercompany sales order invoice posting, see MarkupTrans.getICSOOrigChargeFromICPOVirtualCharge.
    /// This means that posting of intercompany sales order invoice an additional markupTrans will be created for the purchase line reference.
    /// When trying to post original order in the chain we only lookup the newly created virtual charge, which doesn't carry sourcedocumentLine reference.
    /// SourceDocumentLine reference is not set on the virtual charge because we don't want to instantiate a source document line for virtual charge and incorrectly calculate tax.
    /// However, when trying to post the original order in chain we need to lookup the original charge to obtain sourceDocumenline reference.
    /// This method tries to perform this lookup as a form of consistency check so that sourceDocumentLine reference can be found.
    /// Final error can still occur in case user doesn't have security permissions for both companies in intercompany chain, then crossCompany will fail. Error has
    /// been improved to indicate to user which company user doesn't have access to.
    /// </remarks>
    private SourceDocumentLineRefRecId getMarkupTransSourceDocumentLine(MarkupTrans _referencedMarkupTrans)
    {
        SourceDocumentLineRefRecId currentSourceDocumentLine = _referencedMarkupTrans.SourceDocumentLine;

        using (var activityContext = this.logger().purchSourceDocumentLineChargeActivities().charge(_referencedMarkupTrans))
        {
            if (currentSourceDocumentLine != 0)
            {
                return currentSourceDocumentLine;
            }

            if (this.isPurchaseLineIntercompanyCharge(_referencedMarkupTrans))
            {
                MarkupTrans originalMarkupTrans;
                select firstonly RecId, SourceDocumentLine from originalMarkupTrans
                    where originalMarkupTrans.TransTableId ==  _referencedMarkupTrans.TransTableId
                        && originalMarkupTrans.TransRecId == _referencedMarkupTrans.TransRecId
                        && originalMarkupTrans.InterCompanyCompanyId == _referencedMarkupTrans.InterCompanyCompanyId
                        && originalMarkupTrans.SourceDocumentLine != 0;

                activityContext
                    .addCustomProperty(
                        PurchChargeSourceDocumentLineActivities::OriginalMarkupRecordIdProperty,
                        int642Str(originalMarkupTrans.RecId))
                    .addCustomProperty(
                        PurchChargeSourceDocumentLineActivities::OriginalMarkupSourceDocumentLineProperty,
                        int642Str(originalMarkupTrans.SourceDocumentLine));

                if (!originalMarkupTrans.SourceDocumentLine)
                {
                    throw error(strFmt("@SCM:MarkupTransICSOConsistencyCheckSecurityError", _referencedMarkupTrans.InterCompanyCompanyId));
                }
                currentSourceDocumentLine = originalMarkupTrans.SourceDocumentLine;
            }
        }
        return currentSourceDocumentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseLineIntercompanyCharge</Name>
				<Source><![CDATA[
    private boolean isPurchaseLineIntercompanyCharge(MarkupTrans _referencedMarkupTrans)
    {
        return _referencedMarkupTrans.InterCompanyCompanyId
            && _referencedMarkupTrans.TransTableId == tableNum(PurchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustBillingClassification</Name>
				<Source><![CDATA[
    public RefRecId parmCustBillingClassification()
    {
        CustInvoiceTable    localCustInvoiceTable;
        CustInvoiceJour     localCustInvoiceJour;

        switch (markupTrans.TransTableId)
        {
            case tableNum(CustInvoiceTable):
                localCustInvoiceTable = CustInvoiceTable::findRecId(markupTrans.TransRecId);
                break;

            case tableNum(CustInvoiceJour):
                select firstonly CustBillingClassification from localCustInvoiceTable
                    join InvoiceId, InvoiceDate, NumberSequenceGroup from localCustInvoiceJour
                            where localCustInvoiceJour.InvoiceId == localCustInvoiceTable.InvoiceId
                                && localCustInvoiceJour.InvoiceDate == localCustInvoiceTable.InvoiceDate
                                && localCustInvoiceJour.NumberSequenceGroup == localCustInvoiceTable.NumberSequenceGroup
                                && markupTrans.TransTableId == localCustInvoiceJour.TableId
                                && markupTrans.TransRecId == localCustInvoiceJour.RecId
                                && markupTrans.RecId == markupTrans.RecId;
                break;
        }

        return localCustInvoiceTable.CustBillingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustBillingCode</Name>
				<Source><![CDATA[
    public RefRecId parmCustBillingCode()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDescription</Name>
				<Source><![CDATA[
    public Description parmDescription()
    {
        DictTable               dictTable;
        str                     chargeLineLabel;
        str                     spaceDelimiter;
        Description             description;

        dictTable = new DictTable(tableNum(MarkupTrans));
        chargeLineLabel = dictTable.label();
        spaceDelimiter = ' ';
        description = chargeLineLabel + spaceDelimiter + markupTrans.MarkupCode;

        return description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmForInterestAdjustment</Name>
				<Source><![CDATA[
    public NoYes parmForInterestAdjustment()
    {
        NoYes forInterestAdjustment = NoYes::No;
        CustInvoiceTable localCustInvoiceTable;

        if (markupTrans.TransTableId == tableNum(CustInvoiceTable))
        {
            localCustInvoiceTable = CustInvoiceTable::findRecId(markupTrans.TransRecId);
            forInterestAdjustment = localCustInvoiceTable.ForInterestAdjustment;
        }

        return forInterestAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDocumentLineEditable</Name>
				<Source><![CDATA[
    public boolean parmIsDocumentLineEditable()
    {
        boolean         editable;

        switch (markupTrans.TransTableId)
        {
            case tableNum(CustInvoiceLine):
                editable = this.parmParentSourceDocumentLineItem().parmIsDocumentLineEditable();
                break;

            default:
                editable = super();
        }

        return editable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineNum</Name>
				<Source><![CDATA[
    public LineNum parmLineNum()
    {
        LineNum lineNum;

        if ((markupTrans.TransTableId == tableNum(CustInvoiceLine) || markupTrans.TransTableId == tableNum(CustInvoiceTrans)) &&
            sourceDocumentLine.ParentSourceDocumentLine &&
            SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
        {
            lineNum = this.parmParentSourceDocumentLineItem().parmLineNum();
        }
        else
        {
            lineNum = super();
        }

        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupTable</Name>
				<Source><![CDATA[
    public Common parmMarkupTable()
    {
        if (!isMarkupTableInitialized)
        {
            markupTable = markupTrans.markupTable();
            isMarkupTableInitialized = true;
        }

        return markupTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupTrans</Name>
				<Source><![CDATA[
    public MarkupTrans parmMarkupTrans()
    {
        return markupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupCode</Name>
				<Source><![CDATA[
    public str parmMarkupCode()
    {
        return markupTrans.MarkupCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocLineFinalizedDate</Name>
				<Source><![CDATA[
    public AccountingDate parmSourceDocLineFinalizedDate()
    {
        AccountingDate                  accountingDate;
        SourceDocumentLineItemIFinalize sourceDocumentLineIFinalize;
        SourceDocumentIFinalize         sourceDocumentIFinalize;

        if (this.parmParentSourceDocumentLineItem() &&
            this.parmParentSourceDocumentLineItem() is SourceDocumentLineItemIFinalize)
        {
            sourceDocumentLineIFinalize = this.parmParentSourceDocumentLineItem() as SourceDocumentLineItemIFinalize;
            accountingDate = sourceDocumentLineIFinalize.parmSourceDocLineFinalizedDate();
        }
        else
        {
            if (this.parmSourceDocument() is SourceDocumentIFinalize)
            {
                sourceDocumentIFinalize = this.parmSourceDocument() as SourceDocumentIFinalize;
                accountingDate = sourceDocumentIFinalize.parmSourceDocumentFinalizedDate();
            }
        }

        if (!accountingDate)
        {
            throw error (Error::wrongUseOfFunction(funcName()));
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmTransactionCurrencyCode()
    {
        return markupTrans.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOriginForPurchaseTableAndLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes origin <c>MarkupTrans</c> to be used for dimension derivation and allocation.
    /// </summary>
    /// <returns>
    /// The <c>MarkupTrans</c> used for dimension derivation and allocation.
    /// </returns>
    /// <remarks>
    /// This is the <c>MarkupTrans</c> associated with a Purchase Order document header and lines.
    /// </remarks>
    protected MarkupTrans initOriginForPurchaseTableAndLine()
    {
        MarkupTrans originMarkupTrans;

        if (markupTrans.OrigRecId != 0 &&
            (this.parmSourceDocumentLineMatchingList() == null || this.parmSourceDocumentLineMatchingList().elements() == 0))
        {
            select originMarkupTrans
                where originMarkupTrans.TransRecId == markupTrans.OrigRecId
                   && originMarkupTrans.TransTableId == markupTrans.OrigTableId
                   && originMarkupTrans.LineNum == markupTrans.LineNum;
        }

        return originMarkupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUseOriginLineDistForChildAmount</Name>
				<Source><![CDATA[
    public boolean canUseOriginLineDistForChildAmount()
    {
        boolean     isHeaderCharge;

        switch (MarkupTrans.TransTableId)
        {
            case tableNum(PurchTable):
                isHeaderCharge = true;
                break;

            default:
                isHeaderCharge = false;
                break;
        }

        return isHeaderCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializingSourceDocumentHeaderLineTypesMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// An event handler delegate for the initalizing the <c>SourceDocument</c> line types map.
    /// </summary>
    /// <param name="_typesMap">
    /// A map containing the types of lines a source document header can represent.
    /// </param>
    [SubscribesTo(classstr(SourceDocument), staticdelegatestr(SourceDocument, initializingSourceDocumentHeaderLineTypesMap))]
    static void initializingSourceDocumentHeaderLineTypesMap(Map _typesMap)
    {
        _typesMap.insert(tableNum(MarkupTrans), NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldResolveMainAccount</Name>
				<Source><![CDATA[
    public boolean shouldResolveMainAccount()
    {
        return markupTable.isMarkupOfTypeLedgerLedger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setChildSourceDocumentLineItemListToNull</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set childSourceDocumentLineItemList to null
    /// </summary>
    [Hookable(false)]
    public void setChildSourceDocumentLineItemListToNull()
    {
        childSourceDocumentLineItemList = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logger</Name>
				<Source><![CDATA[
    private PurchInstrumentationLogger logger()
    {
        return PurchInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>