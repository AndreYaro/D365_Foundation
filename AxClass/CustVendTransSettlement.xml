<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendTransSettlement</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendTransSettlement</c> class is used to manage a collection of <c>CustVendTrans</c>
/// records and <c>CustVendSettlement</c> records. These are managed to enable posting as a group and
/// optimize setting of the settlement group field on the <c>CustTransSettlement</c> table.
/// </summary>
abstract public class CustVendTransSettlement
{
    Map custVendTransSettlementMap;

    Map voucherProcessed;
    Map voucherToBeProcessed;
    Map settlementEntriesMap;
    CustSettleJournalizingEntries custSettleJournalizingEntries;
    LedgerVoucher ledgerVoucher;

    protected DataAreaId specCompany;
    protected TableId specTable;
    protected RecId specRecId;

    List custVendTransSettlementList;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified CustVendSettlement record to the collection.
    /// </summary>
    /// <param name="_custVendSettlement">
    /// The CustVendSettlement record to add to the collection.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group placeholder of the record being added.
    /// </param>
    /// <param name="_ledgerTransType">
    /// The ledger transaction type of the record being added.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map; optional.
    /// </param>
    /// <param name="_reversedRecId">
    /// RecId of reversed <c>custVendSettlemnet</c>.
    /// </param>
    /// <remarks>
    /// Use this method when the transaction record already exists and only
    /// a settlement record needs to be created.
    /// </remarks>
    public void addSettlement(CustVendSettlement _custVendSettlement,
        Counter _settlementGroupPlaceHolder,
        LedgerTransType _ledgerTransType,
        CustVendSettlement _previousCustVendSettlement = null
        ,RefRecId           _reversedRecId = 0
        )
    {
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>
        ;
        // Add the records to the collection
        // <GEERU><GEECZ>
        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]))
        {
        // </GEECZ></GEERU>
            this.addToCollection(null, _custVendSettlement, _settlementGroupPlaceHolder, _ledgerTransType, false, false, _previousCustVendSettlement);
        // <GEERU>
        }
        else
        {
            this.addToCollection(null, _custVendSettlement, _settlementGroupPlaceHolder, _ledgerTransType, false, false, _previousCustVendSettlement, _reversedRecId);
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToCollection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the CustVendTrans record and CustVendSettlement record to the collection.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record to add to the collection.
    /// </param>
    /// <param name="_custVendSettlement">
    /// The CustVendSettlement record to add to the collection.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group placeholder of the record being added.
    /// </param>
    /// <param name="_ledgerTransType">
    /// The ledger transaction type of the record being added.
    /// </param>
    /// <param name="_doesCustVendTransExists">
    /// true if the CustVendTrans record is specified; otherwise, false.
    /// </param>
    /// <param name="_updateOffsetRecIdDuringPost">
    /// true if the CustVendSettlement record needs to have the OffsetRecId field updated during posting; other, false.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map; optional.
    /// </param>
    /// <param name="_reversedRecId">
    /// RecId of reversed <c>custVendSettlemnet</c>.
    /// </param>
    protected void addToCollection(
        CustVendTrans _custVendTrans,
        CustVendSettlement _custVendSettlement,
        Counter _settlementGroupPlaceHolder,
        LedgerTransType _ledgerTransType,
        boolean _doesCustVendTransExists,
        boolean _updateOffsetRecIdDuringPost = false,
        CustVendSettlement _previousCustVendSettlement = null
        ,RefRecId            _reversedRecId               = 0
        )
    {
        // <GEERU>
        #ISOCountryRegionCodes
        // </GEERU>

        Counter sequenceNumber = 1;     // used to make the key value unique
        CompanyId company;
        ;

        Debug::assert(_settlementGroupPlaceHolder != 0);
        Debug::assert(_doesCustVendTransExists ? _custVendTrans.Voucher != '' : true);
        // The settlement group should always be blank, this is set during post.
        Debug::assert(_custVendSettlement.SettlementGroup == 0);

        company = _custVendSettlement.company();

        // There could be duplicate records with same settlermentGroup and ledgerTransType for
        // example for posting profile differences and when penny difference is treated as cash discount,
        // so the nextSequence part of the key is required to make the key unique.
        while (custVendTransSettlementMap.exists([company, _settlementGroupPlaceHolder, _ledgerTransType, sequenceNumber]))
        {
            sequenceNumber++;
        }
        // <GEERU><GEECZ>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]))
        {
            custVendTransSettlementMap.insert([company, _settlementGroupPlaceHolder, _ledgerTransType, sequenceNumber],
                                              [_doesCustVendTransExists, _custVendTrans, _custVendSettlement, _updateOffsetRecIdDuringPost, 0, _previousCustVendSettlement, _reversedRecId]);
        }
        else
        {
        // </GEECZ></GEERU>
            custVendTransSettlementMap.insert([company, _settlementGroupPlaceHolder, _ledgerTransType, sequenceNumber],
                                              [_doesCustVendTransExists, _custVendTrans, _custVendSettlement, _updateOffsetRecIdDuringPost, 0, _previousCustVendSettlement]);
        // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransAndDefaultSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the <c>CustVendTrans</c> record and a default <c>CustVendSettlement</c> record to the
    ///    collection.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    The <c>CustVendTrans</c> record to add to the collection.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    ///    The settlement group placeholder for the record being added.
    /// </param>
    /// <param name="_setOffsetRecId">
    ///    A Boolean value that indicates whether the <c>CustVendSettlement</c> record must have the
    ///    <c>OffsetRecId</c> field updated during posting; optional.
    /// </param>
    /// <remarks>
    ///    The <c>CustVendSettlement</c> record is initialized with values from the <c>CustVendTrans</c>
    ///    record.
    /// </remarks>
    public void addTransAndDefaultSettlement(CustVendTrans _custVendTrans,
        Counter _settlementGroupPlaceHolder,
        boolean _setOffsetRecId = false)
    {
        CustVendSettlement custVendSettlement = this.initCustVendSettlementMap(_custVendTrans.company());

        CustVendTransReportingCurrencyInitializer initializer = CustVendTransReportingCurrencyInitializer::newForTransaction(_custVendTrans);

        // If a reporting currency has been defined but no reporting information given,
        // then default from system rates so that settlement records will receive reporting currency amounts.
        if (this.shouldInitializeReportingCurrency(_custVendTrans, initializer.getReportingCurrencyForTransaction()))
        {
            if (_custVendTrans.getReportingCombinedExchangeRate() == 0.0)
            {
                initializer.initSystemReportingExchRate();
            }

            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::current(_custVendTrans.company())),
                _custVendTrans.TransDate);

            _custVendTrans.setExchangeHelperReportingExchRate(currencyExchangeHelper);

            _custVendTrans.ReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                _custVendTrans.CurrencyCode,
                _custVendTrans.AmountCur);

            _custVendTrans.SettleAmountReporting = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(
                _custVendTrans.CurrencyCode,
                _custVendTrans.SettleAmountCur);
        }

        custVendSettlement.CustVendSettlement::initFromCustVendTrans(_custVendTrans);

        this.addTransAndSettlement(_custVendTrans, custVendSettlement, _settlementGroupPlaceHolder, _setOffsetRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInitializeReportingCurrency</Name>
				<Source><![CDATA[
    private boolean shouldInitializeReportingCurrency(
        CustVendTrans _custVendTrans,
        CurrencyCode _reportingCurrency)
    {
        boolean shouldInitializeReportingCurrency;

        if (_reportingCurrency != ''
            && _custVendTrans.ReportingCurrencyCrossRate == 0.0
            && _custVendTrans.ReportingCurrencyAmount == 0.0)
        {
            shouldInitializeReportingCurrency = true;
        }

        return shouldInitializeReportingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransAndSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the CustVendTrans record and CustVendSettlement record to the collection.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record to add to the collection.
    /// </param>
    /// <param name="_custVendSettlement">
    /// The CustVendSettlement record to add to the collection.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group placeholder of the record being added.
    /// </param>
    /// <param name="_setOffsetRecId">
    /// A boolean value that indicates if the CustVendSettlement record needs to have the OffsetRecId
    /// field updated during posting.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map; optional.
    /// </param>
    public void addTransAndSettlement(CustVendTrans _custVendTrans,
        CustVendSettlement _custVendSettlement,
        Counter _settlementGroupPlaceHolder,
        boolean _setOffsetRecId = false,
        CustVendSettlement _previousCustVendSettlement = null)
    {
        // Add the records to the map
        this.addToCollection(_custVendTrans, _custVendSettlement, _settlementGroupPlaceHolder, _custVendTrans.TransType, true, _setOffsetRecId, _previousCustVendSettlement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the specified <c>CustVendTransOpen</c> record and moves the associated
    ///    <c>CustVendTransCashDisc</c> records to the specified <c>CustVendSettlement</c> record.
    /// </summary>
    /// <param name="_custVendTransOpenRecIdToDelete">
    ///    The record ID of the <c>CustVendTransOpen</c> record that will be deleted.
    /// </param>
    /// <param name="_custVendSettlement">
    ///    The <c>CustVendSettlement</c> record to move <c>CustVendTransCashDisc</c> records.
    /// </param>
    abstract protected void deleteCustVendTransOpen(RecId _custVendTransOpenRecIdToDelete, CustVendSettlement _custVendSettlement)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSettlementForCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the CustVendSettlement record for the CustVendTrans record and settlement group.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record that is associated with the CustVendSettlement record to find.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group to find.
    /// </param>
    /// <param name="_offsetRecId">
    /// The offset record ID to find.
    /// </param>
    /// <returns>
    /// The specific instance of the CustVendSettlement record; otherwise, an empty record.
    /// </returns>
    public CustVendSettlement findSettlementForCustVendTrans(
        CustVendTrans _custVendTrans,
        Counter _settlementGroupPlaceHolder,
        RecId _offsetRecId)
    {
        CustVendSettlement  custVendSettlement;
        CustVendTrans       mapCustVendTrans;
        boolean             custVendTransExists;
        Counter             sequenceNumber = 1;
        ;

        custVendSettlement = this.initCustVendSettlementMap(_custVendTrans.company());

        // Find the settlement record in the map
        while (custVendTransSettlementMap.exists([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]))
        {
            [custVendTransExists, mapCustVendTrans, custVendSettlement] =
                custVendTransSettlementMap.lookup([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]);

            // check if transRecId and OffsetRecId match
            if (_custVendTrans.RecId == custVendSettlement.TransRecId
                && _offsetRecId == custVendSettlement.OffsetRecId)
            {
                break;
            }
            else
            {
                sequenceNumber++;

                // The previous lookup() call set values in the buffer, so it needs to be cleared.
                custVendSettlement.clear();
            }
        }

        return custVendSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransAndSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>CustVendTrans</c> and <c>CustVendSettlement</c> record for the <c>CustVendTrans</c>
    /// record and settlement group.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The <c>CustVendTrans</c> record to find.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group to find.
    /// </param>
    /// <param name="_offsetRecId">
    /// The offset record ID to find.
    /// </param>
    /// <returns>
    /// A container that contains the <c>CustVendTrans</c> and <c>CustVendSettlement</c> records;
    /// otherwise, a container that contains empty records.
    /// </returns>
    public container findTransAndSettlement(
        CustVendTrans _custVendTrans,
        Counter _settlementGroupPlaceHolder,
        RecId _offsetRecId)
    {
        // Add the records to the map
        CompanyId company;
        LedgerTransType ledgerTransType;
        Counter sequenceNumber = 1;     // used to make the key value unique
        boolean doesCustVendTransExist = true;
        CustVendSettlement  custVendSettlement;
        CustVendTrans       custVendTrans;
        ;

        ledgerTransType = _custVendTrans.TransType;

        Debug::assert(_settlementGroupPlaceHolder != 0);
        Debug::assert(doesCustVendTransExist ? _custVendTrans.Voucher != '' : true);

        company = _custVendTrans.company();
        custVendSettlement = this.initCustVendSettlementMap(_custVendTrans.company());
        custVendTrans = this.initCustVendTransMap(_custVendTrans.company());

        // There could be duplicate records with same settlermentGroup and ledgerTransType for
        // example for posting profile differences and when penny difference is treated as cash discount,
        // so the nextSequence part of the key is required to make the key unique.
        while (custVendTransSettlementMap.exists([company, _settlementGroupPlaceHolder, ledgerTransType, sequenceNumber]))
        {
            [doesCustVendTransExist, custVendTrans, custVendSettlement] =
                custVendTransSettlementMap.lookup([_custVendTrans.company(), _settlementGroupPlaceHolder, ledgerTransType, sequenceNumber]);

            // check if transRecId and OffsetRecId match
            if (_custVendTrans.RecId == custVendSettlement.TransRecId
                && _offsetRecId == custVendSettlement.OffsetRecId)
            {
                // found the correct record
                break;
            }
            else
            {
                sequenceNumber++;

                // The previous lookup() call set values in the buffer, so it needs to be cleared.
                custVendSettlement.clear();
                custVendTrans.clear();
            }
        }

        return[custVendTrans, custVendSettlement];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendSettlementTmp_W</Name>
				<Source><![CDATA[
    public CustVendSettlement getCustVendSettlementTmp_W(CustVendTrans _custVendTrans)
    {
        MapEnumerator       transSettlementMapEnumerator;
        CustVendTrans       custVendTrans;
        CustVendSettlement  custVendSettlement;
        CompanyId           mapCompany;
        boolean             custVendTransExists;

        CustVendSettlement  tmpCustVensSettlement = CustVendTransStatic::construct(_custVendTrans).custVendSettlement();
        ;

        tmpCustVensSettlement.setTmp();

        transSettlementMapEnumerator = new MapEnumerator(custVendTransSettlementMap);

        while (transSettlementMapEnumerator.moveNext())
        {
            [ mapCompany ] = transSettlementMapEnumerator.currentKey();

            if (mapCompany == _custVendTrans.company())
            {
                [ custVendTransExists, custVendTrans, custVendSettlement ] = transSettlementMapEnumerator.currentValue();

                tmpCustVensSettlement.data(custVendSettlement);
                tmpCustVensSettlement.doInsert();
            }
        }

        return tmpCustVensSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransSettlementList_MX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>List</c> with settlement collection references.
    /// </summary>
    /// <returns>
    /// The <c>List</c> with settlement collection references.
    /// </returns>
    public List getCustVendTransSettlementList_MX()
    {
        return custVendTransSettlementList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTransTmp_W</Name>
				<Source><![CDATA[
    public CustVendTrans getCustVendTransTmp_W(CustVendTrans _custVendTrans)
    {
        MapEnumerator       transSettlementMapEnumerator;
        CustVendTrans       custVendTrans;
        CompanyId           mapCompany;
        boolean             custVendTransExists;

        CustVendTrans       tmpCustVensTrans = CustVendTransStatic::construct(_custVendTrans).custVendTrans();
        ;

        tmpCustVensTrans.setTmp();

        transSettlementMapEnumerator = new MapEnumerator(custVendTransSettlementMap);

        while (transSettlementMapEnumerator.moveNext())
        {
            [ mapCompany ] = transSettlementMapEnumerator.currentKey();

            if (mapCompany == _custVendTrans.company())
            {
                [ custVendTransExists, custVendTrans ] = transSettlementMapEnumerator.currentValue();

                tmpCustVensTrans.data(custVendTrans);
                tmpCustVensTrans.doInsert();
            }
        }

        return tmpCustVensTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSettledAmounts_W</Name>
				<Source><![CDATA[
    public container getSettledAmounts_W(CustVendTrans  _custVendTrans,
                                         TransDate      _transDate = dateMax())
    {
        MapEnumerator       transSettlementMapEnumerator;
        CustVendTrans       custVendTrans;
        CustVendSettlement  custVendSettlement;
        CompanyId           mapCompany;
        boolean             custVendTransExists;

        AmountCur           settleAmountCur;
        AmountMST           settleAmountAccounting;
        AmountMSTSecondary  settleAmountReporting;

        transSettlementMapEnumerator = new MapEnumerator(custVendTransSettlementMap);

        while (transSettlementMapEnumerator.moveNext())
        {
            [ mapCompany ] = transSettlementMapEnumerator.currentKey();

            if (mapCompany == _custVendTrans.company())
            {
                [ custVendTransExists, custVendTrans, custVendSettlement ] = transSettlementMapEnumerator.currentValue();

                if (custVendSettlement.TransRecId == _custVendTrans.RecId &&
                    custVendSettlement.TransDate  <= _transDate)
                {
                    settleAmountCur         += custVendSettlement.SettleAmountCur;
                    settleAmountAccounting  += custVendSettlement.SettleAmountMST       - custVendSettlement.ExchAdjustment;
                    settleAmountReporting   += custVendSettlement.SettleAmountReporting - custVendSettlement.ExchAdjustmentReporting;
                }
            }
        }

        return [settleAmountCur, settleAmountAccounting, settleAmountReporting];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendSettlementMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a properly initialized CustVendSettlement map.
    /// </summary>
    /// <param name="_company">
    /// The company used to initialize the record.
    /// </param>
    /// <returns>
    /// A CustVendSettlement map.
    /// </returns>
    /// <remarks>
    /// This is an abstract method.
    /// </remarks>
    abstract protected CustVendSettlement initCustVendSettlementMap(dataAreaId _company)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVendTransMap</Name>
				<Source><![CDATA[
    abstract protected CustVendTrans initCustVendTransMap(DataAreaId _company)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustVendSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a CustVendSettlement record into the database.
    /// </summary>
    /// <param name="_custVendSettlement">
    /// The CustVendSettlement record to insert.
    /// </param>
    /// <param name="_settlementGroupMap">
    /// The map object that contains the settlement group.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group for the CustVendSettlement record.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map.
    /// </param>
    /// <param name="_reversedRecId">
    /// RecId of reversed <c>custVendSettlemnet</c>.
    /// </param>
    /// <remarks>
    /// This method inserts elements in the passed in map.
    /// </remarks>
    protected void insertCustVendSettlement(CustVendSettlement _custVendSettlement,
        Map _settlementGroupMap,
        Counter _settlementGroupPlaceHolder,
        CustVendSettlement _previousCustVendSettlement = null,
        RefRecId _reversedRecId = 0)
    {
        #ISOCountryRegionCodes

        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        CustVendSettlement custVendSettlementLocal;

        if (countryRegion_RUCZ)
        {
            custVendSettlementLocal = _custVendSettlement.data();
        }

        // The settlementGroup in the map key is a placeholder settlementGroup.  The real settlementGroup
        // in the CustVendSettlement record is the RecId of the first record inserted with the place
        // holder settlement group.
        if (_settlementGroupMap.exists(_settlementGroupPlaceHolder))
        {
            // retrieve the current settlement group
            _custVendSettlement.SettlementGroup = _settlementGroupMap.lookup(_settlementGroupPlaceHolder);
        }

        _custVendSettlement.insert();

        //Insert settlement lines.
        this.insertSettlementLines(_custVendSettlement, _previousCustVendSettlement);

        // Replace the SettlementGroup with the RecId after the record is inserted
        if (_custVendSettlement.SettlementGroup == 0)
        {
            // use the RecId of the first record as the settlement group.
            _custVendSettlement.SettlementGroup = _custVendSettlement.RecId;
            _custVendSettlement.update();

            // Update the settlement group for the rest of the records to use.
            _settlementGroupMap.insert(_settlementGroupPlaceHolder, _custVendSettlement.SettlementGroup);

            if (TaxWithholdParameters_IN::needReverseTDSForVendor())
            {
                this.updateWHTReversedVendTransSettleGroup_IN(_settlementGroupPlaceHolder, _custVendSettlement.SettlementGroup);
            }
        }

        if (_custVendSettlement.SettlementGroup == 0)
        {
            this.logEmptySettlementGroup(_custVendSettlement, _settlementGroupMap, _settlementGroupPlaceHolder);
        }

        // link two settlement records
        if (countryRegion_RUCZ)
        {
            if (_reversedRecId)
            {
                select firstonly forupdate custVendSettlementLocal
                    where custVendSettlementLocal.RecId == _reversedRecId;

                custVendSettlementLocal.ReversedRecId_RU = _custVendSettlement.RecId;
                custVendSettlementLocal.update();

                _custVendSettlement.ReversedRecId_RU = _reversedRecId;
                _custVendSettlement.ReverseTrans_RU  = NoYes::Yes;
                _custVendSettlement.ReportingDate_RU = custVendSettlementLocal.TransDate;
                _custVendSettlement.update();
            }
            else
            {
                CustVendTransPostingLog_RU postingLog;

                select firstonly TransDate from postingLog
                    where ((postingLog.TransRecId  == _custVendSettlement.TransRecId
                        &&  postingLog.OffSetRecId == _custVendSettlement.OffsetRecId)
                        || (postingLog.OffSetRecId == _custVendSettlement.TransRecId
                        &&  postingLog.TransRecId  == _custVendSettlement.OffsetRecId))
                        && postingLog.Reversed;

                if (postingLog.TransDate)
                {
                    _custVendSettlement.ReportingDate_RU = postingLog.TransDate;
                    _custVendSettlement.update();
                }
            }
        }

        custVendTransSettlementList.addEnd([_custVendSettlement.TableId, _custVendSettlement.RecId, _custVendSettlement.company()]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logEmptySettlementGroup</Name>
				<Source><![CDATA[
    private void logEmptySettlementGroup(CustVendSettlement _custVendSettlement,
        Map _settlementGroupMap,
        Counter _settlementGroupPlaceHolder)
    {
        boolean wasPlaceholderFound = _settlementGroupMap.exists(_settlementGroupPlaceHolder);

        SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(CustVendInstrumentationConstants::SourceNameSettleTransactions);

        SysInstrumentationEventDataJsonSerializer jsonSerializer = new SysInstrumentationEventDataJsonSerializer();
        jsonSerializer.setValue(CustVendInstrumentationConstants::Exception, CustVendInstrumentationConstants::SettlementEntryNoSettlementGroup);
        jsonSerializer.setValue(CustVendInstrumentationConstants::SettlementEntrySettlementGroupPlaceholder, int2Str(_settlementGroupPlaceHolder));
        jsonSerializer.setValue(CustVendInstrumentationConstants::SettlementEntryWasPlaceholderFound, int2Str(wasPlaceholderFound));

        jsonSerializer.setValue(fieldStr(CustVendSettlement, RecId), int642Str(_custVendSettlement.RecId));
        jsonSerializer.setValue(fieldStr(CustVendSettlement, TransRecId), int642Str(_custVendSettlement.TransRecId));
        jsonSerializer.setValue(fieldStr(CustVendSettlement, OffsetRecId), int642Str(_custVendSettlement.OffsetRecId));
        jsonSerializer.setValue(fieldStr(CustVendSettlement, CanBeReversed), int2Str(_custVendSettlement.CanBeReversed));

        logger.logWarning(jsonSerializer.toString());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a <c>CustVendTrans</c> record into the database.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    The <c>CustVendTrans</c> record to insert.
    /// </param>
    /// <param name="_settlementGroupPlaceholder">
    ///    The placeholder value for the <c>OffsetRecId</c> field.
    /// </param>
    /// <param name="_updateOffsetRecId">
    ///    A Boolean value that determines whether the <c>CustVendTrans</c> table must have the
    ///    <c>OffsetRecId</c> field updated during posting.
    /// </param>
    /// <param name="_offsetRecIdMap">
    ///    A map that contains the values to set on the <c>OffsetRecId</c> field.
    /// </param>
    /// <remarks>
    ///    This method updates or inserts elements in the passed in map.
    /// </remarks>
    protected void insertCustVendTrans(CustVendTrans _custVendTrans,
        Counter _settlementGroupPlaceholder,
        boolean _updateOffsetRecId,
        Map _offsetRecIdMap)
    {
        boolean     offsetRecIdMapExists;
        RecId       firstOffsetRecId;
        Voucher     firstVoucher;
        RecId       secondOffsetRecId;
        Voucher     secondVoucher;
        DataAreaId  firstRecDataAreaId;

        // <GEERU><GEECZ>
        FactureJour_RU  factureJour;
        TaxTrans        taxTrans;
        #ISOCountryRegionCodes
        boolean                 countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        // </GEECZ></GEERU>
         // <GIN>
        CustVendTrans_W         custVendTrans_W;
        TaxWithholdTrans_IN     taxWithholdTrans;
        TaxWithholdTrans_IN     taxWithholdTransLoc;
        boolean                 countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>

        // check if need to set the offsetRecId and set the value value from map.
        if (_updateOffsetRecId)
        {
            if (_offsetRecIdMap.exists([_settlementGroupPlaceholder, _custVendTrans.TransType]))
            {
                offsetRecIdMapExists = true;
                [firstOffsetRecId, firstVoucher, secondOffsetRecId, secondVoucher, firstRecDataAreaId] = _offsetRecIdMap.lookup([_settlementGroupPlaceholder, _custVendTrans.TransType]);

                // Assert if both first and second values are set
                Debug::assert((firstOffsetRecId == 0) || (secondOffsetRecId == 0));

                // the OffsetRecId on the CustVendTrans should be set to first value
                _custVendTrans.OffsetRecId = firstOffsetRecId;
                _custVendTrans.LastSettleVoucher = firstVoucher;
            }
        }

        // <GIN>
        if (countryRegion_IN
            && TaxWithholdParameters_IN::checkTaxParameters())
        {
            select firstonly Voucher, TaxWithholdAmountOrigin, TaxType from  taxWithholdTrans
                where taxWithholdTrans.Voucher      == _custVendTrans.Voucher
                    && taxWithholdTrans.TransDate    == _custVendTrans.TransDate;

            if (taxWithholdTrans.Voucher)
            {
                select sum(TaxWithholdAmountCur) from  taxWithholdTransLoc
                    where taxWithholdTransLoc.Voucher      == _custVendTrans.Voucher
                        && taxWithholdTransLoc.TransDate    == _custVendTrans.TransDate;

                custVendTrans_W = _custVendTrans.CustVendTrans::getCustVendTrans_W();
                custVendTrans_W.TaxWithholdAmountOrigin_IN = taxWithholdTrans.TaxWithholdAmountOrigin;
                if (taxWithholdTrans.TaxType == TaxWithholdCodeType_IN::TDS)
                {
                    custVendTrans_W.tdsAmount_IN = taxWithholdTransLoc.TaxWithholdAmountCur;
                }
                else
                {
                    custVendTrans_W.tcsAmount_IN =  taxWithholdTransLoc.TaxWithholdAmountCur;
                }
                _custVendTrans.CustVendTrans::packCustVendTrans_W(custVendTrans_W);
            }
        }
        // </GIN>

        _custVendTrans.insert();

        if (_custVendTrans.TableId == tableNum(CustTrans))
        {
            CustTransIdRef::insertForCustTrans(_custVendTrans, _custVendTrans.Voucher, CustTransRefType::Other);
        }

        // check if need to set the offsetRecId and
        if (_updateOffsetRecId)
        {
            if (offsetRecIdMapExists)
            {
                // If the map exists the first value should already be set, so set to the second value to the transaction rec id.
                _offsetRecIdMap.insert([_settlementGroupPlaceholder, _custVendTrans.TransType], [firstOffsetRecId, firstVoucher, _custVendTrans.RecId, _custVendTrans.Voucher, firstRecDataAreaId]);
            }
            else
            {
                // If the map doesn't exist create a map element.
                _offsetRecIdMap.insert([_settlementGroupPlaceholder, _custVendTrans.TransType], [_custVendTrans.RecId, _custVendTrans.Voucher, 0, '', _custVendTrans.company()]);
            }
        }

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            update_recordset factureJour
                setting CustVendTransRecId = _custVendTrans.RecId
                    where factureJour.CustVendTransRecId    == _settlementGroupPlaceholder
                       && factureJour.Voucher               == _custVendTrans.Voucher;

            update_recordset taxTrans
                setting SourceRecId = _custVendTrans.RecId
                    where taxTrans.SourceRecId      == _settlementGroupPlaceholder
                       && taxTrans.SourceTableId    == _custVendTrans.TableId
                       && taxTrans.Voucher          == _custVendTrans.Voucher;
        }
        // </GEECZ></GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSettlementLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a <c>CustSettlementLine</c> record.
    /// </summary>
    /// <param name="_custVendSettlement">
    ///    The current <c>CustVendSettlement</c> map.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    ///    The settled <c>CustVendSettlement</c> map.
    /// </param>
    protected void insertSettlementLines(CustVendSettlement _custVendSettlement,
        CustVendSettlement _previousCustVendSettlement = null)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>markCustVendTransOpenForDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the specified CustVendTransOpen record to be deleted.
    /// </summary>
    /// <param name="_custVendTransOpenToDelete">
    /// The record ID of the CustVendTransOpen record that will be deleted.
    /// </param>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record that is associated with the CustVendTransOpen record to delete.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group associated with the CustVendTransOpen record to delete.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map.
    /// </param>
    /// <returns>
    /// true if record to be deleted was found; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The CustVendTransOpen record is not deleted until the post method is called.
    /// When this method returns false the record is not found, the calling program will be responsible for deleting the record.
    /// </remarks>
    public boolean markCustVendTransOpenForDelete(
        RecId _custVendTransOpenToDelete,
        CustVendTrans _custVendTrans,
        Counter _settlementGroupPlaceHolder,
        CustVendSettlement _previousCustVendSettlement = null)
    {
        CustVendSettlement  custVendSettlement;
        CustVendTrans       custVendTransFromTheMap;
        boolean             custVendTransExists;
        boolean             updateOffsetRecId;
        Counter             sequenceNumber = 1;
        boolean             updateComplete = false;
        RefRecId            custVendTransOpenToDeleteFromTheMap;
        boolean             isCorrectSettlementRecordRetrievedFromTheMap;
        boolean             isCorrectTransOpenRecordRetrievedFromTheMap;

        // Find the correct CustVendTransOpen and CustVendSettlement records in the map
        while (custVendTransSettlementMap.exists([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]))
        {
            [custVendTransExists, custVendTransFromTheMap, custVendSettlement, updateOffsetRecId, custVendTransOpenToDeleteFromTheMap] =
                custVendTransSettlementMap.lookup([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]);

            isCorrectSettlementRecordRetrievedFromTheMap =
                _custVendTrans.RecId == custVendSettlement.TransRecId
                    && _custVendTrans.OffsetRecId == custVendSettlement.OffsetRecId;

            isCorrectTransOpenRecordRetrievedFromTheMap =
                custVendTransOpenToDeleteFromTheMap == 0
                    || (custVendTransOpenToDeleteFromTheMap == _custVendTransOpenToDelete);

            if (isCorrectSettlementRecordRetrievedFromTheMap
                && isCorrectTransOpenRecordRetrievedFromTheMap)
            {
                // update the map with the CustVendTransCashDiscRefRecId
                custVendTransSettlementMap.insert(
                    [_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber],
                    [custVendTransExists, custVendTransFromTheMap, custVendSettlement, updateOffsetRecId, _custVendTransOpenToDelete, _previousCustVendSettlement]);

                updateComplete = true;
                break;
            }

            Debug::assert(!updateComplete);
            sequenceNumber++;
        }

        return updateComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyTransAndSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the CustVendTrans record and CustVendSettlement record.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record to update.
    /// </param>
    /// <param name="_custVendSettlement">
    /// The specific CustVendSettlement to update.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group placeholder used to find the record to update.
    /// </param>
    /// <param name="_offsetRecId">
    /// The offset record ID to find.
    /// </param>
    /// <param name="_modifyTrans">
    /// Indicates whether the CustVendTrans record should be modified.
    /// </param>
    /// <param name="_modifySettlement">
    /// Indicates whether the CustVendSettlement record should be modified.
    /// </param>
    public void modifyTransAndSettlement(
        CustVendTrans _custVendTrans,
        CustVendSettlement _custVendSettlement,
        Counter _settlementGroupPlaceHolder,
        RecId _offsetRecId,
        boolean _modifyTrans = true,
        boolean _modifySettlement = true)
    {
        CustVendSettlement  mapCustVendSettlement;
        CustVendTrans       mapCustVendTrans;
        CustVendSettlement  prevCustVendSettlement;
        CustVendSettlement  insertCustVendSettlement;
        CustVendTrans       insertCustVendTrans;
        boolean             custVendTransExists;
        boolean             updateOffsetRecId;
        Counter             sequenceNumber = 1;
        boolean             updateComplete = false;
        RefRecId            mapCustVendTransOpenToDelete;
        ;

        if (_modifyTrans == false && _modifySettlement == false)
        {
            Debug::assert(false);
            return;
        }

        // Find the settlement record in the map to update
        while (custVendTransSettlementMap.exists([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]))
        {
            [custVendTransExists, mapCustVendTrans, mapCustVendSettlement, updateOffsetRecId, mapCustVendTransOpenToDelete, prevCustVendSettlement] =
                custVendTransSettlementMap.lookup([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]);

            // check if Settlement record for the correct transaction
            if (_custVendTrans.RecId == mapCustVendSettlement.TransRecId
                && _offsetRecId == mapCustVendSettlement.OffsetRecId)
            {
                insertCustVendTrans = _modifyTrans ? _custVendTrans : mapCustVendTrans;
                insertCustVendSettlement = _modifySettlement ? _custVendSettlement : mapCustVendSettlement;

                // update the map with settlement record and CustVendTransCashDiscRefRecId
                if (insertCustVendSettlement.SettleAmountCur != 0)
                {
                    custVendTransSettlementMap.insert(
                        [_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber],
                        [custVendTransExists, insertCustVendTrans, insertCustVendSettlement, updateOffsetRecId, mapCustVendTransOpenToDelete, prevCustVendSettlement]);
                }
                else
                {
                    // settled amount is zero, so remove the records
                    custVendTransSettlementMap.remove([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]);
                }
                updateComplete = true;
                break;
            }
            else
            {
                sequenceNumber++;
            }
        }

        Debug::assert(updateComplete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        ;

        // The key container has the following elements:
        //      Company (CompanyId data type)
        //      SettlementGroupPlaceHolder (Counter data type)
        //      LedgerTransType (LedgerTransType data type)
        //      SequenceNumber (Counter data type) - This is needed because the other parts
        //          of the key will not always create a unique key value.
        // The value container has the following elements:
        //      CustVendTransExists (boolean data type) - true if CustTrans or VendTrans record exist; otherwise fale.
        //      CustVendTrans table buffer
        //      CustVendSettlement table buffer
        //      OffsetRecIdIndicator (boolean data type) - If set to true this indicates the
        //          OffsetRecId field on Settlement record should be updated during post.
        //      CustVendTransOpenToDelete (RefRecId data type) - If set to value other than zero
        //          this indicates the CustVendTransOpen records that have this RefRecId must be deleted.

        custVendTransSettlementMap = new Map(Types::Container,Types::Container);

        settlementEntriesMap = new Map(Types::Record, Types::Class);
        voucherProcessed     = new Map(Types::String, Types::Integer);
        voucherToBeProcessed = new Map(Types::String, Types::Record);

        custVendTransSettlementList = new List(Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustSettleJournalizingEntries</Name>
				<Source><![CDATA[
    public CustSettleJournalizingEntries parmCustSettleJournalizingEntries(CustSettleJournalizingEntries _custSettleJournalizingEntries = custSettleJournalizingEntries)
    {
        custSettleJournalizingEntries = _custSettleJournalizingEntries;

        return custSettleJournalizingEntries;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTransSettlementMap_IN</Name>
				<Source><![CDATA[
    public Map parmCustVendTransSettlementMap_IN(Map _custVendTransSettlementMap = custVendTransSettlementMap)
    {
        custVendTransSettlementMap = _custVendTransSettlementMap;
        return custVendTransSettlementMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementEntires</Name>
				<Source><![CDATA[
    public Map parmSettlementEntires(Map _settlementEntries = settlementEntriesMap)
    {
        settlementEntriesMap = _settlementEntries;

        return settlementEntriesMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherProcessed</Name>
				<Source><![CDATA[
    public Map parmVoucherProcessed(Map _voucherProcessed = voucherProcessed)
    {
        voucherProcessed = _voucherProcessed;

        return voucherProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherToBeProcessed</Name>
				<Source><![CDATA[
    public Map parmVoucherToBeProcessed(Map _voucherToBeProcessed = voucherToBeProcessed)
    {
        voucherToBeProcessed = _voucherToBeProcessed;

        return voucherToBeProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts all the <c>CustVendTrans</c> records and the <c>CustVendSettlement</c> records.
    /// </summary>
    public void post()
    {
        MapEnumerator       transSettlementMapEnumerator;
        CustVendTrans       custVendTrans;
        CustVendSettlement  custVendSettlement;
        CustVendSettlement  previousCustVendSettlement;
        CompanyId           mapCompany;
        CompanyId           currentCompany;
        boolean             custVendTransExists;
        Counter             settlementGroupPlaceHolder;
        Map                 offsetRecIdMap;
        MapEnumerator       offsetRecMapEnumerator;
        boolean             updateOffsetRecId;
        RecId               firstOffsetRecId;
        Voucher             firstVoucher;
        RecId               secondOffsetRecId;
        Voucher             secondVoucher;
        Map                 settlementGroupMap;
        boolean             more;
        RefRecId            custVendTransOpenRecIdToDelete;
        CompanyId           transCompany;

        CustVendTrans                       custVendTransCredit;
        LedgerVoucherObject                 ledgerVoucherObject;

        // <GEERU><GEECZ>
        RefRecId            reversedRecId;
        #ISOCountryRegionCodes
        boolean             countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);
        // </GEECZ></GEERU>

        // must be within an existing database transaction
        Debug::assert(appl.ttsLevel() > 0);

        // create a map to store offset recid that need to be set
        offsetRecIdMap = new Map(Types::Container, Types::Container);

        // create a map to store the mapping of the placeholder settlement group to the actual settlement group.
        settlementGroupMap = new Map(Types::Int64, Types::Int64);

        transSettlementMapEnumerator = new MapEnumerator(custVendTransSettlementMap);
        more = transSettlementMapEnumerator.moveNext();

        if (more)
        {
            [mapCompany, settlementGroupPlaceHolder] = transSettlementMapEnumerator.currentKey();
            currentCompany = mapCompany;
        }

        while (more)
        {
            // minimize number of times we invoke changeCompany for better performance
            changecompany(currentCompany)
            {
                while (currentCompany == mapCompany && more)
                {
                    // <GEERU><GEECZ>
                    if (!countryRegion_RUCZ)
                    {
                    // </GEECZ></GEERU>
                        [custVendTransExists, custVendTrans, custVendSettlement, updateOffsetRecId, custVendTransOpenRecIdToDelete,previousCustVendSettlement] = transSettlementMapEnumerator.currentValue();
                    // <GEERU>
                    }
                    else
                    {
                        [custVendTransExists, custVendTrans, custVendSettlement, updateOffsetRecId, custVendTransOpenRecIdToDelete,previousCustVendSettlement, reversedRecId] = transSettlementMapEnumerator.currentValue();
                    }
                    // </GEERU>

                    // If there is a CustVendTrans in the map, insert and set the TransRecId and
                    // OffsetRecId fields on the associated CustVendSettlement record.
                    if (custVendTransExists)
                    {
                        this.insertCustVendTrans(custVendTrans, settlementGroupPlaceHolder, updateOffsetRecId, offsetRecIdMap);

                        custVendSettlement.OffsetRecId = custVendTrans.OffsetRecId;
                        custVendSettlement.TransRecId = custVendTrans.RecId;
                        custVendSettlement.OffsetTransVoucher = custVendTrans.LastSettleVoucher;

                        if ( isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) &&
                            LedgerParameters::find().JournalizingDefinitionEnableValue == NoYes::Yes &&
                             ledgerVoucher                                                &&
                            !voucherProcessed.exists(custVendTrans.Voucher)               &&
                             voucherToBeProcessed.exists(custVendTrans.Voucher)           &&
                             custSettleJournalizingEntries)
                        {
                             custVendTransCredit = voucherToBeProcessed.lookup(custVendTrans.Voucher);
                             ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(custVendTrans.Voucher, custVendTrans.TransDate, CurrentOperationsTax::Current);
                             custSettleJournalizingEntries.parseVoucherEntries(ledgerVoucherObject, custVendTransCredit);
                             voucherProcessed.insert(custVendTrans.Voucher, 1);
                        }
                    }

                    if (custVendTransOpenRecIdToDelete != 0)
                    {
                        custVendSettlement.ClosedDate = custVendSettlement.TransDate;
                    }

                    this.insertSettlement(custVendSettlement, settlementGroupMap, settlementGroupPlaceHolder, previousCustVendSettlement, reversedRecId);

                    this.deleteCustVendTransOpen(custVendTransOpenRecIdToDelete, custVendSettlement);

                    // read the next record
                    more = transSettlementMapEnumerator.moveNext();
                    if (more)
                    {
                        [mapCompany, settlementGroupPlaceHolder] = transSettlementMapEnumerator.currentKey();
                    }
                }

                currentCompany = mapCompany;
            }
        }

        // Second pass to update any offsetRecId on CustVendTrans and CustVendSettlement
        offsetRecMapEnumerator = new MapEnumerator(offsetRecIdMap);

        while (offsetRecMapEnumerator.moveNext())
        {
            [firstOffsetRecId, firstVoucher, secondOffsetRecId, secondVoucher, transCompany] = offsetRecMapEnumerator.currentValue();

            Debug::assert((firstOffsetRecId != 0) || (secondOffsetRecId != 0));
            Debug::assert(transCompany != '');

            this.updateTransSettlementOffsetRecId(firstOffsetRecId, secondOffsetRecId, secondVoucher, transCompany);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSettlement</Name>
				<Source><![CDATA[
	/// <summary>
    ///		Inserts a <c>CustVendSettlement</c> record into the database.
    /// </summary>
    /// <param name = "_custVendSettlement">
    ///		The CustVendSettlement record to insert.
	/// </param>
    /// <param name = "_settlementGroupMap">
    ///		The map object that contains the settlement group.
	/// </param>
    /// <param name = "_settlementGroupPlaceHolder">
    ///		The placeholder settlement group for the CustVendSettlement record.
	/// </param>
    /// <param name = "_previousCustVendSettlement">
    ///		The settled CustVendSettlement record.
	/// </param>
    /// <param name = "_reversedRecId">
    ///		RecId of reversed <c>CustVendSettlement</c>.
	/// </param>
    protected void insertSettlement(CustVendSettlement _custVendSettlement, Map _settlementGroupMap, Counter _settlementGroupPlaceHolder, CustVendSettlement _previousCustVendSettlement, RefRecId _reversedRecId)
    {
        #ISOCountryRegionCodes
        boolean countryRegion_RUCZ = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoCZ]);

        // <GEERU><GEECZ>
        if (countryRegion_RUCZ)
        {
            // </GEECZ></GEERU>
			this.insertCustVendSettlement(_custVendSettlement, _settlementGroupMap, _settlementGroupPlaceHolder, _previousCustVendSettlement, _reversedRecId);
            // <GEERU>
        }
        else
        {
            if (this.useLocalizedCustVendSettlementInsert(_custVendSettlement, _settlementGroupMap, _settlementGroupPlaceHolder, _previousCustVendSettlement))
            {
                this.insertCustVendSettlementLocalized(_custVendSettlement, _settlementGroupMap, _settlementGroupPlaceHolder, _previousCustVendSettlement);
            }
            else
            {
                this.insertCustVendSettlement(_custVendSettlement, _settlementGroupMap, _settlementGroupPlaceHolder, _previousCustVendSettlement);
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>useLocalizedCustVendSettlementInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the record for settlement is country/region specific.
    /// </summary>
    /// <param name="_custVendSettlement">
    /// The CustVendSettlement record to insert.
    /// </param>
    /// <param name="_settlementGroupMap">
    /// The map object that contains the settlement group.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group for the CustVendSettlement record.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map.
    /// </param>
    /// <returns>
    /// true if the record for settlement is country/region specific; otherwise, false.
    /// </returns>
    protected boolean useLocalizedCustVendSettlementInsert(
		CustVendSettlement _custVendSettlement, 
		Map _settlementGroupMap, 
		Counter _settlementGroupPlaceHolder, 
		CustVendSettlement _previousCustVendSettlement)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustVendSettlementLocalized</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a CustVendSettlement localized record into the database.
    /// </summary>
    /// <param name="_custVendSettlement">
    /// The CustVendSettlement record to insert.
    /// </param>
    /// <param name="_settlementGroupMap">
    /// The map object that contains the settlement group.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The placeholder settlement group for the CustVendSettlement record.
    /// </param>
    /// <param name="_previousCustVendSettlement">
    /// The settled <c>CustVendSettlement</c> map.
    /// </param>
    protected void insertCustVendSettlementLocalized(
		CustVendSettlement _custVendSettlement, 
		Map _settlementGroupMap, 
		Counter _settlementGroupPlaceHolder, 
		CustVendSettlement _previousCustVendSettlement)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the ledgerVoucher.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The <c>LedgerVoucher</c> object.
    /// </param>
    public void setLedgerVoucher(LedgerVoucher _ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOriginator</Name>
				<Source><![CDATA[
    public void setOriginator(DataAreaId _specCompany, TableId _specTable, RecId _specRecId)
    {
        specCompany = _specCompany;
        specTable = _specTable;
        specRecId = _specRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrevExchRateTrans_W</Name>
				<Source><![CDATA[
    #define.transPos(2)
    public void updatePrevExchRateTrans_W(CustVendTrans _lastExchAdjTrans, TransDate _postingDate, ExchRate _exchRateAccounting, ExchRate _exchRateReporting)
    {
        MapEnumerator       transSettlementMapEnumerator;
        CustVendTrans       exchRateTrans;
        CompanyId           mapCompany;
        boolean             custVendTransExists;
        container           key, value;

        if (_lastExchAdjTrans.TransDate == _postingDate)
        {
            transSettlementMapEnumerator = new MapEnumerator(custVendTransSettlementMap);

            while (transSettlementMapEnumerator.moveNext())
            {
                key   = transSettlementMapEnumerator.currentKey();
                value = transSettlementMapEnumerator.currentValue();

                [mapCompany] = key;

                if (mapCompany == _lastExchAdjTrans.company())
                {
                    [custVendTransExists, exchRateTrans] = value;

                    if (exchRateTrans.LastSettleVoucher == _lastExchAdjTrans.LastSettleVoucher    &&
                       (exchRateTrans.TransType         == LedgerTransType::ExchAdjustment        ||
                        exchRateTrans.TransType         == LedgerTransType::AdvanceAdjustment_RU) &&
                        exchRateTrans.TransDate         == _postingDate                           &&
                        exchRateTrans.AccountNum        == _lastExchAdjTrans.AccountNum           &&
                        exchRateTrans.Invoice           == _lastExchAdjTrans.Invoice              &&
                        exchRateTrans.LastExchAdj       == exchRateTrans.TransDate                &&
                       (exchRateTrans.ExchAdjustmentUnrealized                                    ||
                        exchRateTrans.ReportingExchAdjustmentUnrealized)                          &&
                       !exchRateTrans.LastExchAdjVoucher                                          &&
                      (!exchRateTrans.LastExchAdjRate                                             ||
                       !exchRateTrans.LastExchAdjRateReporting))
                    {
                        if (exchRateTrans.ExchAdjustmentUnrealized && !exchRateTrans.LastExchAdjRate)
                        {
                            exchRateTrans.LastExchAdjRate = _exchRateAccounting;
                        }

                        if (exchRateTrans.ReportingExchAdjustmentUnrealized && !exchRateTrans.LastExchAdjRateReporting)
                        {
                            exchRateTrans.LastExchAdjRateReporting = _exchRateReporting;
                        }

                        value = conPoke(value, #transPos, exchRateTrans);

                        custVendTransSettlementMap.insert(key, value);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSettlementForCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the CustVendSettlement record.
    /// </summary>
    /// <param name="_custVendTrans">
    /// The CustVendTrans record that is associated with the CustVendSettlement record to update.
    /// </param>
    /// <param name="_custVendSettlement">
    /// The specific CustVendSettlement to update.
    /// </param>
    /// <param name="_settlementGroupPlaceHolder">
    /// The settlement group placeholder used to find the record to update.
    /// </param>
    /// <param name="_offsetRecId">
    /// The offset record ID to find.
    /// </param>
    public void updateSettlementForCustVendTrans(
        CustVendTrans _custVendTrans,
        CustVendSettlement _custVendSettlement,
        Counter _settlementGroupPlaceHolder,
        RecId _offsetRecId)
    {
        CustVendSettlement  mapCustVendSettlement;
        CustVendTrans       mapCustVendTrans;
        CustVendSettlement  prevCustVendSettlement;
        boolean             custVendTransExists;
        boolean             updateOffsetRecId;
        Counter             sequenceNumber = 1;
        boolean             updateComplete = false;
        RefRecId            mapCustVendTransOpenToDelete;
        ;

        // Find the settlement record in the map to update
        while (custVendTransSettlementMap.exists([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]))
        {
            [custVendTransExists, mapCustVendTrans, mapCustVendSettlement, updateOffsetRecId, mapCustVendTransOpenToDelete, prevCustVendSettlement] =
                custVendTransSettlementMap.lookup([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber]);

            // check if Settlement record for the correct transaction
            if (_custVendTrans.RecId == mapCustVendSettlement.TransRecId
                && _offsetRecId == mapCustVendSettlement.OffsetRecId)
            {
                // update the map with settlement record and CustVendTransCashDiscRefRecId
                custVendTransSettlementMap.insert([_custVendTrans.company(), _settlementGroupPlaceHolder, _custVendTrans.TransType, sequenceNumber],
                                                  [custVendTransExists, mapCustVendTrans, _custVendSettlement, updateOffsetRecId, mapCustVendTransOpenToDelete, prevCustVendSettlement]);

                updateComplete = true;
                break;
            }
            else
            {
                sequenceNumber++;
            }
        }

        Debug::assert(updateComplete);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransSettlementOffsetRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the OffsetRecId field on the CustVendTrans table and CustVendSettlement table.
    /// </summary>
    /// <param name="_recIdOfTransaction">
    /// The record ID of the transaction to update.
    /// </param>
    /// <param name="_offsetRecId">
    /// The record ID value used to update the OffsetRecId field.
    /// </param>
    /// <param name="_offsetVoucher">
    /// The voucher value used to update the LastSettleVoucher field and OffsetTransVoucher field.
    /// </param>
    /// <param name="_companyOfTransaction">
    /// The company of the records to update.
    /// </param>
    abstract protected void updateTransSettlementOffsetRecId(
        RefRecId _recIdOfTransaction,
        RefRecId _offsetRecId,
        Voucher _offsetVoucher,
        CompanyId _companyOfTransaction)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendTransSettlement construct(SysModule _module)
    {
        CustVendTransSettlement custVendTransSettlement;
        ;

        switch (_module)
        {
            case SysModule::Cust :
                custVendTransSettlement = new CustTransSettlement();
                break;

            case SysModule::Vend :
                custVendTransSettlement = new VendTransSettlement();
                break;

            default :
                throw error(Error::wrongUseOfFunction(funcname()));
        }

        return custVendTransSettlement;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>