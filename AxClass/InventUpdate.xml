<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpdate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventUpdate</c> class is the engine in the inventory module that updates the status of
///    inventory transactions. The class brings inventory transactions from one status to another.
/// </summary>
/// <remarks>
///    Each status has its own class to do the update. The
///    <c>
///       InventUpdate
///    </c>
///     class and the
///    <c>
///       InventMovement
///    </c>
///     class are closely connected. The
///    <c>
///       InventUpdate
///    </c>
///     class uses the
///    <c>
///       InventMovement
///    </c>
///     class as a data carrier to update inventory transactions. By using the
///    <c>
///       StatusReceipt
///    </c>
///     enumeration value and the
///    <c>
///       StatusIssue
///    </c>
///     enumeration value, inventory transactions can be updated to following statuses.
///    <list type="table">
///       <item>
///          <description>None</description><description>None</description>
///       </item>
///       <item>
///          <description>Purchased</description><description>Sold</description>
///       </item>
///       <item>
///          <description>Received</description><description>Deducted</description>
///       </item>
///       <item>
///          <description>Registered</description><description>Picked</description>
///       </item>
///       <item>
///          <description>Arrived</description><description>ReservPhysical</description>
///       </item>
///       <item>
///          <description>Ordered</description><description>ReservOrdered</description>
///       </item>
///       <item>
///          <description>QuotationReceipt</description><description>OnOrder</description>
///       </item>
///       <item>
///          <description /><description>QuotationIssue</description>
///       </item>
///    </list>
///    Special behavior of various transactions must be put in the
///    <c>
///       InventMovement
///    </c>
///     class. The
///    <c>
///       InventUpdate
///    </c>
///     class is a generic engine that can be used for any inventory transaction type and calls methods on
///    the
///    <c>
///       InventMovement
///    </c>
///     classes. See the
///    <c>
///       SalesFormLetter_PackingSlip.updateInventory
///    </c>
///     method for an example of how this class is used.
/// </remarks>
public class InventUpdate
{
    // new parameters

    InventMovement                  movement;
    AmountMST                       projCostAmountMST;

    // <GEERU>
    AmountMSTSecondary      projCostAmountMstSecCur;
    // </GEERU>
    // internal init

    boolean                         allowReserveOrdered;
    boolean                         allowReservePhysical;
    boolean                         allowReserveByDate;
    boolean                         allowReserveReversed;
    boolean                         allowNegativePhysical;
    boolean                         allowNegativeFinancial;
    boolean                         allowReserveReduction;
    boolean                         allowAutoReserveDim;
    InventPhysicalReduction         physicalReduction;

    // internal update flag

    boolean                         postingPhysical;
    boolean                         postingFinancial;
    boolean                         postingPhysicalRevenue;
    boolean                         postingPhysicalCharge;
    boolean                         postingFinancialCharge;
    boolean                         updateForSubParmLine;
    boolean                         preferFullPhysicalTrackingDim;

    InventDim                       inventDimQuarantine; // Used when creating a quarantine order
    boolean                         burdenItem;
    boolean                         wmsMovement;

    List                            issueTransList;             // sorted list of InventTrans records in the order they should be issue updated
    ListEnumerator                  issueTransListEnumerator;   // enumerator for above list. Holds current position
    List                            receiptTransList;           // sorted list of InventTrans records in the order they should be receive updated
    ListEnumerator                  receiptTransListEnumerator; // enumerator for above list. Holds current position
    RefRecId                        preferedInventTransRecId;   // RecId of InventTrans record that should be put first in receiptTransList; optional

    private List                    customInventTransList;
    private boolean                 customInventTransListInitialized = false;
    private Map                     customInventTransMap;

    InventReceiptForTestRegistrator inventReceiptForTestRegistrator; // Quality management receipt registrator
    // <GEERU>
    TransLinkCache_RU       transLinkCache_RU;
    Num                     documentStornoId;
    boolean                 needTransIDTransit;

    #ISOCountryRegionCodes
    // </GEERU>
    boolean                 allowReservePhysicalUpdateForAllMarked;
    TransDate               exchangeRateDate;

    boolean                 skipInventTransSumUp;

    WHSLocationMixingConstraintCheckSkip whsLocationMixingConstraintCheckSkip; 
    private boolean         whsSuppressPhysicalRereservationOnNonWorkEnabledIssues;

    // Delay warning message since reserve again is skipped.
    protected boolean       skipReserveAgainstAvailableOnhandForCWItem = false;

    private boolean isWHSReservePhysicalReserveOrderedQtyOrderByDateV2FlightEnabled = WHSReservePhysicalReserveOrderedQtyOrderByDateV2Flight::instance().isEnabled();    

    private WHSDispositionCode  dispositionCode;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmCustomInventTransIssueList</Name>
				<Source><![CDATA[
    final protected List parmCustomInventTransIssueList()
    {
        return customInventTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustomInventTransListInitialized</Name>
				<Source><![CDATA[
    final protected boolean parmCustomInventTransListInitialized()
    {
        return customInventTransListInitialized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionIssueQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory quantity that can be issued from the specified <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction record.</param>
    /// <param name = "_remainingQuantity">Remaining quantity available for the issue.</param>
    /// <returns>The inventory quantity that can be issued from the specified <c>InventTrans</c> record.</returns>
    /// <remarks>The quantity passed to this method must not be positive.</remarks>
    internal InventQty transactionIssueQuantity(InventTrans _inventTrans, InventQty _remainingQuantity)
    {
        if (_remainingQuantity > 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!customInventTransMap)
        {
            if (_inventTrans.Qty < _remainingQuantity)
            {
                return _remainingQuantity;
            }

            return _inventTrans.Qty;
        }

        if (!customInventTransMap.exists(_inventTrans.RecId))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Catch weight is not supported in the scenario where selected invent trans list is used.
        InventQty customQuantity = customInventTransMap.lookup(_inventTrans.RecId);
        this.validateInventQtyFromCustomInventTransList(_inventTrans, _remainingQuantity, customQuantity);

        return customQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionIssueCWQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the catch weight quantity that can be issued from the specified <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction record.</param>
    /// <param name = "_remainingCWQuantity">Remaining catch weight quantity available for the issue.</param>
    /// <returns>The catch weight quantity that can be issued from the specified <c>InventTrans</c> record.</returns>
    /// <remarks>The catch weight quantity passed to this method must not be positive.</remarks>
    internal PdsCWInventQty transactionIssueCWQuantity(InventTrans _inventTrans, PdsCWInventQty _remainingCWQuantity)
    {
        if (_remainingCWQuantity > 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_inventTrans.PdsCWQty < _remainingCWQuantity)
        {
            return _remainingCWQuantity;
        }
        return _inventTrans.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionIssueSplitQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory quantity that should be split from the specified issue <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction record.</param>
    /// <param name = "_updateNowQuantity">The inventory quantity to update.</param>
    /// <param name = "_remainingQuantity">Remaining quantity available for the issue.</param>
    /// <returns>The inventory quantity that should be split from the specified <c>InventTrans</c> record.</returns>
    /// <remarks>
    ///     - The quantity passed to this method must not be positive.
    ///     - This method is used to determine the quantity to split from the inventory transaction which should be equal to the update now quantity
    ///     unless the split is happening because the catch weight update now quantity is less than the remaining catch weight quantity in which case,
    ///     the remaining inventory quantity should be used for the split.
    /// </remarks>
    internal InventQty transactionIssueSplitQuantity(InventTrans _inventTrans, InventQty _updateNowQuantity, InventQty _remainingQuantity)
    {
        if (_remainingQuantity > 0 || _updateNowQuantity > 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // We should honor the update now quantity, if the quantity is specified in the custom inventTrans list.
        if (this.parmCustomInventTransListInitialized())
        {
            return _updateNowQuantity;
        }

        return _remainingQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInventQtyFromCustomInventTransList</Name>
				<Source><![CDATA[
    private void validateInventQtyFromCustomInventTransList(InventTrans _inventTrans, InventQty _remainingQuantity, InventQty _customQuantity)
    {
        if (_customQuantity < _inventTrans.Qty 
            || _customQuantity < _remainingQuantity)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionReceiptQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the inventory quantity that can be received from the specified <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction record.</param>
    /// <param name = "_remainingQuantity">Remaining quantity available for the receipt.</param>
    /// <returns>The inventory quantity that can be received from the specified <c>InventTrans</c> record.</returns>
    /// <remarks>The quantity passed to this method must not be negative.</remarks>
    internal InventQty transactionReceiptQuantity(InventTrans _inventTrans, InventQty _remainingQuantity)
    {
        if (_remainingQuantity < 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (!customInventTransMap)
        {
            if (_remainingQuantity < _inventTrans.Qty)
            {
                return _remainingQuantity;
            }
            
            return _inventTrans.Qty;
        }

        if (!customInventTransMap.exists(_inventTrans.RecId))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // Catch weight is not supported in the scenario where selected invent trans list is used.
        InventQty customQuantity = customInventTransMap.lookup(_inventTrans.RecId);
        this.validateReceiptQuantityFromCustomInventTransList(_inventTrans, _remainingQuantity, customQuantity);

        return customQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateReceiptQuantityFromCustomInventTransList</Name>
				<Source><![CDATA[
    private void validateReceiptQuantityFromCustomInventTransList(InventTrans _inventTrans, InventQty _remainingQuantity, InventQty _customQuantity)
    {
        if (_customQuantity > _inventTrans.Qty
            || _customQuantity > _remainingQuantity)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyCustomInventTransUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the inventory transaction update has been successful when using the custom inventory transactions list to issue.
    /// </summary>
    /// <param name = "_remainingQuantity">Remaining quantity available for the update.</param>
    final protected void verifyCustomInventTransUpdate(InventQty _remainingQuantity)
    {   
        if (this.parmCustomInventTransListInitialized() && (issueTransListEnumerator.moveNext() || _remainingQuantity))
        {
            InventUpdateCustomInventTransListTelemetryLogger::logInvalidTotalCustomInventTransQuantity(this, funcName(), _remainingQuantity);
            
            throw error("@SCM:CustomInventTransListQtyNotMatchingUpdateQty");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomInventTransReceiptUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the inventory transaction update has exhausted the custom inventory transactions list to receive 
    /// and that's no remaining quantity.
    /// </summary>
    /// <param name = "_remainingQuantity">Remaining quantity available for the update.</param>
    final protected void validateCustomInventTransReceiptUpdate(InventQty _remainingQuantity)
    {
        if (this.parmCustomInventTransListInitialized())
        {
            if (receiptTransListEnumerator.moveNext() || _remainingQuantity)
            {
                InventUpdateCustomInventTransListTelemetryLogger::logInvalidTotalCustomInventTransQuantity(this, funcName(), _remainingQuantity);
            
                throw error("@SCM:CustomInventTransListQtyNotMatchingUpdateQty");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustomInventTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the custom list of the specific inventory transaction records to be used for updating the quantity.
    /// </summary>
    /// <param name = "_customInventTransList">List of the <c>InventUpdateCustomTransReceiptListItem</c> instances.</param>
    [Hookable(false)]
    final public void initializeCustomInventTransList(List _customInventTransList)
    {
        if (!_customInventTransList)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        //Fail fast if the custom list contains CW items.
        this.verifyInventTransItemIsNotCW();
        
        customInventTransList = _customInventTransList;
        customInventTransListInitialized = true;

        InventUpdateCustomInventTransListTelemetryLogger::logCustomInventTransListInitialized(this, funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyInventTransItemIsNotCW</Name>
				<Source><![CDATA[
    private void verifyInventTransItemIsNotCW()
    {
        if (movement.pdsCWItem())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomIssueInventTrans</Name>
				<Source><![CDATA[
    internal boolean validateCustomIssueInventTrans(
        StatusIssue                             _fromStatus,
        StatusIssue                             _toStatus,
        InventDimId                             _inventDimId,
        InventDim                               _inventDimCriteria,
        InventDimParm                           _inventDimParm,
        InventTransChildType                    _inventTransChildType,
        InventTransChildRefId                   _inventTransChildRefId,
        InventUpdateCustomTransIssueListItem    _listItem)
    {
        boolean result = (_listItem.inventQty                       < 0
                          && _listItem.inventTrans.TransChildType   == _inventTransChildType
                          && _listItem.inventTrans.TransChildRefId  == _inventTransChildRefId
                          && _listItem.inventTrans.StatusIssue      >= _fromStatus
                          && _listItem.inventTrans.StatusIssue      <= _toStatus
                          && _listItem.inventTrans.StatusReceipt    == StatusReceipt::None
                          && _listItem.inventTrans.InventTransOrigin== movement.inventTransOriginId()
                          && !customInventTransMap.exists(_listItem.inventTrans.RecId));

        if (!result)
        {
            return false;
        }

        if (_inventDimParm.isAllFlagNo())
        {
            return result;
        }

        if (_inventDimId && _inventDimParm.isAllFlagYes())
        {
            return result && _listItem.inventTrans.inventDimId == _inventDimId;
        }

        InventDim inventDimRequired = InventDim::find(_listItem.inventTrans.InventDimId);
        result = result && InventDim::isInventDimParmEqual(inventDimRequired, _inventDimCriteria, _inventDimParm);;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalOnHandChanging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains logic that needs to be executed whenever physical on hand is about to change.
    /// </summary>
    /// <param name="_context">
    /// The context of the physical on hand change.
    /// </param>
    /// <param name="_args">
    /// The information that describes the changes to the physical on hand.
    /// </param>
    /// <remarks>
    /// There is no guarantee that the method will be called for each auto generated
    /// batch/serial number when automatic generation of batches/serial numbers is enabled.
    /// </remarks>
    delegate void physicalOnHandChanging(Object _context, InventPhysicalOnHandChangeArgs _args)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>raiseOnHandChangingOnPhysicalStatusUpd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Raises, if necessary, the physical on hand changing event when an inventory transaction
    /// is about to move from/to one of the physical statuses.
    /// </summary>
    /// <param name="_inventTrans">
    /// The inventory transaction record.
    /// </param>
    /// <param name="_origInventInventTrans">
    /// The original inventory transaction record; optional.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimension values of the inventory transaction; optional.
    /// </param>
    /// <param name="_origInventDim">
    /// The inventory dimension values of the original inventory transaction; optional.
    /// </param>
    /// <remarks>
    /// The physical on hand changing event will only be fired if necessary.
    /// The event will not be raised if the item is a service item
    /// or if the inventory status changes from a physical status (e.g. picked) to another physical status (e.g. packed).
    /// </remarks>
    [Hookable(true)]
    protected void raiseOnHandChangingOnPhysicalStatusUpd(
        InventTrans _inventTrans,
        InventTrans _origInventInventTrans = _inventTrans.orig(),
        InventDim   _inventDim = null,
        InventDim   _origInventDim = null)
    {
        InventDim       inventDim;
        InventQty       deltaQty;
        PdsCWInventQty  deltaCWQty;

        int inventTransChangeSign = _inventTrans.physicalStatusUpdateSign(_origInventInventTrans);

        if (inventTransChangeSign != 0) // physical to estimated or estimated to physical
        {
            if (inventTransChangeSign > 0) // estimated to physical
            {
                // When transaction changes from non-physical to physical status then physical on hand changes on the new dimensions
                inventDim   = prmisDefault(_inventDim) ? _inventTrans.inventDim() : _inventDim;
                deltaQty    = _inventTrans.Qty;
                deltaCWQty  = _inventTrans.PdsCWQty;
            }
            else // physical to estimated
            {
                // Otherwise physical on hand changes on the original dimensions
                inventDim   = prmisDefault(_origInventDim) ? _origInventInventTrans.inventDim() : _origInventDim;
                deltaQty    = -_origInventInventTrans.Qty;
                deltaCWQty  = -_origInventInventTrans.PdsCWQty;
            }

            InventTable inventTable = movement.inventTable();

            if (inventTable.inventItemType().mustInventBeControlled())
            {
                InventPhysicalOnHandChangeArgs physicalOnHandChangeArgs = InventPhysicalOnHandChangeArgs::newStandardWithInventTransDeltaQuantities(inventTable, inventDim,  deltaQty, deltaCWQty, _inventTrans, _origInventInventTrans);
                physicalOnHandChangeArgs.parmWMSPickingRouteID(_inventTrans.PickingRouteID);
                physicalOnHandChangeArgs.parmDispositionCode(dispositionCode);
                this.physicalOnHandChanging(this, physicalOnHandChangeArgs);
                WHSAllowedContainerType::validateContainerTypeLPOnLocationProfile(physicalOnHandChangeArgs);
            }
        }
        else if (_origInventInventTrans.isIncludedInPhysicalInventory())
        {
            // the scenario where we are changing quantity on a transaction that is already in a physical status is not supported currently
            Debug::assert(_inventTrans.Qty == _origInventInventTrans.Qty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowChangeConsistentDim</Name>
				<Source><![CDATA[
    protected boolean allowChangeConsistentDim()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeleteOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether current operation is delete operation.
    /// </summary>
    /// <returns>true if the current operation is delete operation; otherwise, false.</returns>
    public boolean isDeleteOperation()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sum up the inventory transactions if possible.
    /// </summary>
    /// <param name="_inventTransId">
    /// The <c>InventTransId</c> ID of the origin for which transactions should be summed up.
    /// </param>
    public static void sumUpTransactions(InventTransId _inventTransId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        Set                 deletedTransactions;

        if (!InventParameters::find().AddTransact)
        {
            return;
        }

        deletedTransactions = new Set(Types::Int64);

        while select forupdate inventTrans
        exists join inventTransOrigin
            where inventTransOrigin.recId           == inventTrans.InventTransOrigin
            &&    inventTransOrigin.InventTransId   == _inventTransId
        {
            if (!deletedTransactions.in(inventTrans.RecId))
            {
                inventTrans.updateSumUp(NoYes::No, false, deletedTransactions);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowChangeDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicate whether changing dimensions is allowed by verifying that the on hand in the
    ///    source dimensions will not become negative (if negative inventory is not allowed).
    /// </summary>
    /// <param name="_inventOnHandQty">
    ///    An on hand quantity class instance based on the source inventory dimensions.
    /// </param>
    /// <param name="_inventTrans">
    ///    An inventory transaction updated to the new inventory dimensions.
    /// </param>
    /// <param name="_inventDim">
    ///    A source inventory dimensions record buffer.
    /// </param>
    /// <param name="_physicalUpdate">
    ///    A Boolean value specifying whether a physical update is taking place; optional.
    /// </param>
    /// <param name="_transactionDeleted">
    ///    A Boolean value specifying whether the transaction is being deleted; optional.
    /// </param>
    /// <returns>
    ///    true if the change can proceed; otherwise, raises an infolog error and returns false.
    /// </returns>
    protected boolean allowChangeDim(
        InventOnHandQty _inventOnHandQty,
        InventTrans     _inventTrans,
        InventDim       _inventDim,
        boolean         _physicalUpdate = false
        ,
        boolean         _transactionDeleted = false
        )
    {
        Query                   queryInventTrans;
        QueryBuildDataSource    inventTransDataSource;
        QueryBuildDataSource    inventDimDataSource;
        InventDimParm           inventDimParm;
        InventTransOrigin       inventTransOrigin;

        inventTransOrigin = InventTransOrigin::find(_inventTrans.InventTransOrigin);

        if (!allowNegativePhysical
        && inventTransOrigin.ReferenceCategory != InventTransType::WHSWork
        && inventTransOrigin.ReferenceCategory != InventTransType::WHSContainer
        )
        {
            if (_inventOnHandQty.whsParmItemUsesWHS())
            {
                return WHSInvent::checkDimChangeReceipt(_inventTrans, _inventDim, _transactionDeleted);
            }
            else
            {
                // If we are refining dimensions in a physical update (specifying additional dimensions
                // rather than changing them), then the on hand of the source dimension will be the same
                // after the change.
                if (   !_physicalUpdate
                    || !this.isRefiningDimension(_inventTrans, _inventDim))
                {
                    // Ensure that the on hand left in the source dimensions will not be negative
                    if (_inventOnHandQty.availOrdered() < _inventTrans.Qty)
                    {
                        setPrefix(_inventDim.preFix());

                        movement.inventDimGroupSetup().inventDimParmActivePhysicalInventory(inventDimParm);

                        queryInventTrans = new Query();
                        queryInventTrans.addDataSource(tableNum(InventTrans));
                        inventTransDataSource = queryInventTrans.dataSourceTable(tableNum(InventTrans));
                        inventTransDataSource.addRange(fieldNum(InventTrans, ItemId)).value(_inventTrans.ItemId);
                        inventTransDataSource.addRange(fieldNum(InventTrans, StatusIssue)).value(strFmt('%1', StatusIssue::ReservOrdered));

                        inventTransDataSource.addDataSource(tableNum(InventDim));
                        inventDimDataSource = queryInventTrans.dataSourceTable(tableNum(InventDim));
                        inventDimDataSource.addLink(fieldNum(InventTrans, InventDimId), fieldNum(InventDim,InventDimId));
                        inventDimParm.queryAddRangeValue(inventDimDataSource, _inventDim);

                        checkFailed(strFmt("@SYS86376", StatusIssue::ReservOrdered, _inventTrans.ItemId),'appldoc://forms/inventonhanditem',_inventTrans.infoActionInventTrans(queryInventTrans));

                        return false;
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEstimatedUnit</Name>
				<Source><![CDATA[
    protected UnitQty calcEstimatedUnit(InventQty _estimated)
    {
        UnitQty estimatedUnit;

        if (movement.mustBeUnitControlled())
        {
            estimatedUnit  = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(movement.itemId(),
                                                                                                   movement.inventDimId(),
                                                                                                   _estimated,
                                                                                                   movement.inventTable().inventUnitId(),
                                                                                                   movement.transUnitId(),
                                                                                                   NoYes::Yes);

            estimatedUnit  = decRound(estimatedUnit, UnitOfMeasure::unitOfMeasureDecimalPrecision(
                UnitOfMeasure::unitOfMeasureIdBySymbol(movement.transUnitId())));
        }
        else
        {
            estimatedUnit  = _estimated;
        }

        return estimatedUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipProductDimensionCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls whether it is safe to skip checking product dimension values.
    /// </summary>
    /// <returns>
    /// True if the dimensions were already verified and we can assume they are valid. False otherwise.
    /// </returns>
    public boolean canSkipProductDimensionCheck()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeInventTransReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the relationship references of the inventory transaction originator related to the movement.
    /// </summary>
    public void changeInventTransReferences()
    {
        InventMovement          movement_Orig;
        InventTransOriginId     inventTransOriginId;
        InventTransOriginId     assemblyInventTransOriginId;
        InventTransOriginId     transferInventTransOriginId;

        movement_Orig = movement.newMovement_Orig();

        if (!movement_Orig)
        {
            return;
        }

        if (movement.assetId() != movement_Orig.assetId())
        {
            AssetInventTrans::changeAssetId(movement.inventTransOriginId(), movement_Orig.assetId(), movement.assetId(), movement.assetBookId());
        }

        inventTransOriginId = movement.inventTransOriginId();
        assemblyInventTransOriginId = movement.assemblyInventTransOriginId();

        if (assemblyInventTransOriginId != movement_Orig.assemblyInventTransOriginId())
        {
            InventTransOriginAssemblyComponent::writeAssemblyRefId(inventTransOriginId, assemblyInventTransOriginId);
        }

        if (movement.transferDirection() != InventDirection::None)
        {
            transferInventTransOriginId = movement.transferInventTransOriginId();

            if (transferInventTransOriginId != movement_Orig.transferInventTransOriginId())
            {
                if (movement.transferDirection() == InventDirection::Issue)
                {
                    InventTransOriginTransfer::writeTransferRefId(inventTransOriginId, transferInventTransOriginId, movement.inventTable().Product, InventTransOrigin::find(inventTransOriginId).ReferenceCategory);
                }
                else if (movement.transferDirection() == InventDirection::Receipt)
                {
                    InventTransOriginTransfer::writeTransferRefId(transferInventTransOriginId, inventTransOriginId, movement.inventTable().Product, InventTransOrigin::find(inventTransOriginId).ReferenceCategory);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLocationMixingConstraint</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the location profile setup of the given inventory dimensions.
    /// </summary>
    /// <param name="_inventDim">
    ///    The inventory dimensions to check.
    /// </param>
    /// <returns>
    ///    true if the location profile restrictions are met; otherwise, false.
    /// </returns>
    protected boolean checkLocationMixingConstraint(InventDim _inventDim)
    {
        boolean result = true;
        WHSLocationMixingConstraintValidator locationMixingValidator;

        // check receipts only
        if (movement && movement.transQty() > 0)
        {
            locationMixingValidator = WHSLocationMixingConstraintValidator::newFromReceiptItemDim(movement.itemId(), _inventDim);
            locationMixingValidator.parmCheckWork(false);
            locationMixingValidator.parmLocationMixingConstraintCheckSkip(this.parmWhsLocationMixingConstraintCheckSkip());
            result = locationMixingValidator.validatePhysicalReceipt();
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventUpdateBlockedItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks if an item is blocked for inventory updates.
    /// </summary>
    /// <param name="_itemId">
    ///    Item ID to check.
    /// </param>
    /// <returns>
    ///    true if the item is not blocked; otherwise, false.
    /// </returns>
    protected boolean checkInventUpdateBlockedItem(ItemId _itemId)
    {        
        if (InventUpdateBlockedItem::isItemBlocked(_itemId))
        {
            return checkFailed("@SCM:MessageWarning_InventUpdateBlockedItem");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>originCreateContract</Name>
				<Source><![CDATA[
    private InventTransOriginCreateContract originCreateContract()
    {
        return InventTransOriginCreateContract::newFromMovement(movement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransOriginForMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory transaction originator for the movement and relationship references.
    /// </summary>
    /// <returns>The initialized inventory transaction originator.</returns>
    protected InventTransOriginId initializeInventTransOriginForMovement()
    {
        InventTransOriginId inventTransOriginId = movement.inventTransOriginId();

        if (!inventTransOriginId)
        {
            inventTransOriginId = InventTransOrigin::createOrigin(this.originCreateContract()).RecId;

            movement.inventTransOriginId(inventTransOriginId);
            movement.createOriginOwnerRelationship();
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventTransOriginAndReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the inventory transaction originator for the movement and relationship references.
    /// </summary>
    public void createInventTransOriginAndReferences()
    {
        InventTransOriginId inventTransOriginId = this.initializeInventTransOriginForMovement();

        // Create asset reference
        if (movement.assetId())
        {
            AssetInventTrans::createTransId(movement.assetId(),movement.assetBookId(),movement.inventTransOriginId());
        }

        if (movement.transferDirection() != InventDirection::None)
        {
            InventTransOriginId transferInventTransOriginId = movement.transferInventTransOriginId();

            //only try to create the relationship if it is not already created
            if (transferInventTransOriginId && inventTransOriginId && !movement.inventTransOriginTransferId())
            {
                if (movement.transferDirection() == InventDirection::Issue)
                {
                    InventTransOriginTransfer::writeTransferRefId(
                        inventTransOriginId, 
                        transferInventTransOriginId, 
                        movement.inventTable().Product, 
                        InventTransOrigin::find(inventTransOriginId).ReferenceCategory);
                }
                else if (movement.transferDirection() == InventDirection::Receipt)
                {
                    InventTransOriginTransfer::writeTransferRefId(
                        transferInventTransOriginId, 
                        inventTransOriginId, 
                        movement.inventTable().Product, 
                        InventTransOrigin::find(inventTransOriginId).ReferenceCategory);
                }
            }
        }

        InventTransOriginId assemblyInventTransOriginId = movement.assemblyInventTransOriginId();

        if (assemblyInventTransOriginId)
        {
            InventTransOriginAssemblyComponent::writeAssemblyRefId(inventTransOriginId, assemblyInventTransOriginId);
        }

        Set componentInventTransOriginIds = movement.componentInventTransOriginIds();

        if (componentInventTransOriginIds)
        {
            SetEnumerator se = componentInventTransOriginIds.getEnumerator();
            while (se.moveNext())
            {
                InventTransOriginAssemblyComponent::writeAssemblyRefId(se.current(), inventTransOriginId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInventTransOriginAndReferences</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the inventory transaction originator and related relationship references.
    /// </summary>
    public void deleteInventTransOriginAndReferences()
    {
        InventMovement          movement_Orig;

        movement_Orig = movement.newMovement_Orig();

        // The user could change Asset on the line manually and trigger "Delete" action, so the original movement should be used
        if (movement_Orig && movement_Orig.assetId())
        {
            AssetInventTrans::deleteTransId(movement_Orig.assetId(),movement.inventTransOriginId());
        }

        movement.deleteInventTransOriginAndReferences();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionFromDefaultAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Wraps the <c>LedgerDimensionFacade::serviceCreateLedgerDimension</c> method.
    /// </summary>
    /// <param name="_defaultAccount">
    ///    The ID of the <c>DimensionAttributeValueCombination</c> record that represents the default account.
    /// </param>
    /// <param name="_defaultDimension">
    ///    The ID of a default dimension set to use; optional;
    /// </param>
    /// <returns>
    ///    The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    /// <remarks>
    ///    Calling this method with empty default account will not throw an exception.
    /// </remarks>
    protected LedgerDimensionAccount getLedgerDimensionFromDefaultAccount(
        LedgerDimensionDefaultAccount   _defaultAccount,
        DimensionDefault                _defaultDimension)
    {
        if (!_defaultAccount)
        {
            return 0;
        }

        return LedgerDimensionFacade::serviceCreateLedgerDimension(_defaultAccount, _defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextInventTransToIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the next <c>InventTrans</c> record from the sorted list of transactions to issue.
    /// </summary>
    /// <param name="_inventTrans">
    /// The buffer in which the record is placed.
    /// </param>
    /// <returns>
    /// true if a record is found; otherwise, false.
    /// </returns>
    /// <remarks>If the list has not been initialized then it advances the the inventory transaction to the next record.</remarks>
    public boolean getNextInventTransToIssue(InventTrans _inventTrans)
    {
        InventTrans inventTrans;

        if (!issueTransList)
        {
            next _inventTrans;

            if (_inventTrans)
            {
                return true;
            }

            return false;
        }

        if (!issueTransListEnumerator)
        {
            issueTransListEnumerator = issueTransList.getEnumerator();
        }

        if (!issueTransListEnumerator.moveNext())
        {
            _inventTrans.clear();
            return false;
        }

        inventTrans = issueTransListEnumerator.current();
        // passing the record through the list makes it loose its connection to the recordViewCache,
        // so the record needs to be re-selected from the viewCache before updating it
        select firstonly forupdate _inventTrans
            where _inventTrans.InventTransOrigin    == inventTrans.InventTransOrigin
               && _inventTrans.RecId                == inventTrans.RecId;

        if (!_inventTrans.RecId)
        {
            _inventTrans.clear();
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextInventTransToReceive</Name>
				<Source><![CDATA[
    public boolean getNextInventTransToReceive(InventTrans _inventTrans)
    {
        InventTrans inventTrans;

        if (!receiptTransList)
        {
            next _inventTrans;

            if (_inventTrans)
            {
                return true;
            }

            return false;
        }

        if (!receiptTransListEnumerator)
        {
            receiptTransListEnumerator = receiptTransList.getEnumerator();
        }

        if (!receiptTransListEnumerator.moveNext())
        {
            _inventTrans.clear();
            return false;
        }

        inventTrans = receiptTransListEnumerator.current();
        // passing the record through the list makes it loose its connection to the recordViewCache,
        // so the record needs to be re-selected from the viewCache before updating it
        select firstonly forupdate _inventTrans
            where _inventTrans.InventTransOrigin    == inventTrans.InventTransOrigin
               && _inventTrans.RecId                == inventTrans.RecId;

        if (!_inventTrans.RecId)
        {
            _inventTrans.clear();
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransPosting</Name>
				<Source><![CDATA[
    protected InventTransPosting initInventTransPosting()
    {
        InventTransPosting      inventTransPosting;

        inventTransPosting.ItemId               = movement.itemId();
        inventTransPosting.InventTransOrigin    = movement.inventTransOriginId();
        inventTransPosting.DefaultDimension     = movement.defaultDimension();

        return inventTransPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipInventTransForDifferentSites</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether <c>InventTrans</c> records with different sites should be skipped
    /// </summary>
    /// <param name="_inventTrans">Inventory transaction record.</param>
    /// <returns>true if the record should be skipped; otherwise, false.</returns>
    protected boolean skipInventTransForDifferentSites(InventTrans _inventTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransToIssueList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a sorted list with transactions to issue.
    /// </summary>
    /// <param name="_fromStatus">
    /// The first issue status to include.
    /// </param>
    /// <param name="_toStatus">
    /// The last issue status to include.
    /// </param>
    /// <param name="_inventDimId">
    /// The exact inventory dimension ID if known; otherwise, an empty string.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> record identifying the required inventory dimension values.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> records identifying which inventory dimensions are required.
    /// </param>
    /// <param name="_inventTransChildType">
    /// The required <c>TransChildType</c> value for transactions.
    /// </param>
    /// <param name="_inventTransChildRefId">
    /// The required <c>TransChildRefId</c> value for transactions.
    /// </param>
    public void initInventTransToIssueList(
        StatusIssue             _fromStatus,
        StatusIssue             _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId)
    {
        if (this.parmCustomInventTransListInitialized())
        {
            this.initializeInventTransToIssueListWithCustomInventTransList(_fromStatus,
                                                                           _toStatus,
                                                                           _inventDimId,
                                                                           _inventDimCriteria,
                                                                           _inventDimParm,
                                                                           _inventTransChildType,
                                                                           _inventTransChildRefId);
        }
        else
        {
            this.initializeInventTransToIssueListFromDatabase(_fromStatus,
                                                              _toStatus,
                                                              _inventDimId,
                                                              _inventDimCriteria,
                                                              _inventDimParm,
                                                              _inventTransChildType,
                                                              _inventTransChildRefId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransToIssueListWithCustomInventTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a list with transactions to issue using the custom inventory transactions to issue list.
    /// </summary>
    /// <param name="_fromStatus">
    /// The first issue status to include.
    /// </param>
    /// <param name="_toStatus">
    /// The last issue status to include.
    /// </param>
    /// <param name="_inventDimId">
    /// The exact inventory dimension ID if known; otherwise, an empty string.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> record identifying the required inventory dimension values.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> records identifying which inventory dimensions are required.
    /// </param>
    /// <param name="_inventTransChildType">
    /// The required <c>TransChildType</c> value for transactions.
    /// </param>
    /// <param name="_inventTransChildRefId">
    /// The required <c>TransChildRefId</c> value for transactions.
    /// </param>
   final protected void initializeInventTransToIssueListWithCustomInventTransList(
        StatusIssue             _fromStatus,
        StatusIssue             _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId)
    {
        ListEnumerator enumerator = customInventTransList.getEnumerator();
        issueTransList = new List(Types::Record);
        customInventTransMap = new Map(Types::Int64, Types::Real);

        while (enumerator.moveNext())
        {
            InventUpdateCustomTransIssueListItem tmpInventTransItem = enumerator.current();

            if (this.validateCustomIssueInventTrans(_fromStatus,
                                                    _toStatus,
                                                    _inventDimId,
                                                    _inventDimCriteria,
                                                    _inventDimParm,
                                                    _inventTransChildType,
                                                    _inventTransChildRefId,
                                                    tmpInventTransItem))
            {
                issueTransList.addEnd(tmpInventTransItem.inventTrans);
                customInventTransMap.insert(tmpInventTransItem.inventTrans.RecId, tmpInventTransItem.inventQty);
            }
            else
            {
                InventUpdateCustomInventTransListTelemetryLogger::logInvalidCustomInventTrans(this, funcName(), tmpInventTransItem.inventTrans, tmpInventTransItem.inventQty);
                throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        InventUpdateCustomInventTransListTelemetryLogger::logTransListInitializedFromCustomList(this, funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeInventTransInIssueList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an inventory transaction should be included in the issue list.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction.</param>
    /// <returns>true if the inventory transaction should be included; otherwise, false.</returns>
    protected boolean includeInventTransInIssueList(InventTrans _inventTrans)
    {
        return !this.skipInventTransForDifferentSites(_inventTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransToIssueListFromDatabase</Name>
				<Source><![CDATA[
    private void initializeInventTransToIssueListFromDatabase(
        StatusIssue             _fromStatus,
        StatusIssue             _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId)
    {
        // Add the specified inventTrans to the list.
        void addInventTransToList(InventTrans _inventTrans)
        {
            if (this.includeInventTransInIssueList(_inventTrans))
            {
                issueTransList.addEnd(_inventTrans);
            }
        }

        // build a sorted list matching required dimensions.
        void buildIssueTransListSpecifiedDimension()
        {
            InventTrans     inventTransIssue;
            InventDim       inventDim;

            while select forupdate forceplaceholders inventTransIssue
                order by StatusIssue,InventDimId, Qty // sort by quantity to minimize splitting of transactions
                where inventTransIssue.InventTransOrigin    == movement.inventTransOriginId()
                   && inventTransIssue.TransChildType       == _inventTransChildType
                   && inventTransIssue.TransChildRefId      == _inventTransChildRefId
                   && inventTransIssue.StatusIssue          >= _fromStatus
                   && inventTransIssue.StatusIssue          <= _toStatus
                   && inventTransIssue.StatusReceipt        == StatusReceipt::None
                   && inventTransIssue.RecId                != preferedInventTransRecId
                #inventDimExistsJoin(inventTransIssue.InventDimId, inventDim, _inventDimCriteria, _inventDimParm)
            {
                addInventTransToList(inventTransIssue);
            }
        }

        // build a sorted list matching required inventDimId.
        void buildIssueTransListSpecifiedDimId()
        {
            InventTrans     inventTransIssue;

            while select forupdate inventTransIssue
                order by StatusIssue,InventDimId, Qty // sort by quantity to minimize splitting of transactions
                where inventTransIssue.InventTransOrigin    == movement.inventTransOriginId()
                   && inventTransIssue.TransChildType       == _inventTransChildType
                   && inventTransIssue.TransChildRefId      == _inventTransChildRefId
                   && inventTransIssue.StatusIssue          >= _fromStatus
                   && inventTransIssue.StatusIssue          <= _toStatus
                   && inventTransIssue.StatusReceipt        == StatusReceipt::None
                   && inventTransIssue.RecId                != preferedInventTransRecId
                   && inventTransIssue.InventDimId          == _inventDimId
            {
                addInventTransToList(inventTransIssue);
            }
        }

        // build a sorted list matching all dimensions.
        void buildIssueTransListAllDimension()
        {
            InventTrans     inventTransIssue;
            boolean transAddedToIssueList = false;

            if (this.checkProjInventOrderIssueListForQuarantineContextAndFlightEnabled())
            {   
                transAddedToIssueList = this.initializeInventTransToIssueListFromDatabaseForProject(_inventTransChildType, _inventTransChildRefId, _fromStatus, _toStatus);
            }

            if (!transAddedToIssueList)
            {
                while select forupdate inventTransIssue
                    order by StatusIssue,InventDimId, Qty // sort by quantity to minimize splitting of transactions
                    where inventTransIssue.InventTransOrigin    == movement.inventTransOriginId()
                       && inventTransIssue.TransChildType       == _inventTransChildType
                       && inventTransIssue.TransChildRefId      == _inventTransChildRefId
                       && inventTransIssue.StatusIssue          >= _fromStatus
                       && inventTransIssue.StatusIssue          <= _toStatus
                       && inventTransIssue.StatusReceipt        == StatusReceipt::None
                       && inventTransIssue.RecId                != preferedInventTransRecId
                {
                    addInventTransToList(inventTransIssue);
                }
            }
        }

        // Find the preferred inventTrans record and puts it first in list.
        void addPreferedInventTrans()
        {
            InventTrans     inventTransIssue;
            if (!preferedInventTransRecId)
            {
                return;
            }
            inventTransIssue = InventTrans::findRecId(preferedInventTransRecId, true);
            if (inventTransIssue.RecId)
            {
                issueTransList.addStart(inventTransIssue);
            }
        }

        issueTransList = new List(Types::Record);
        issueTransListEnumerator = null;    // reset the enumerator to ensure an enumerator for an old list doesn't get reused.

        if (_inventDimParm.isAllFlagNo())
        {
            buildIssueTransListAllDimension();
        }
        else if (_inventDimId && _inventDimParm.isAllFlagYes())
        {
            buildIssueTransListSpecifiedDimId();
        }
        else
        {
            buildIssueTransListSpecifiedDimension();
        }
        addPreferedInventTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjInventOrderIssueListForQuarantineContextAndFlightEnabled</Name>
				<Source><![CDATA[
    private boolean checkProjInventOrderIssueListForQuarantineContextAndFlightEnabled()
    {
        // This method will return true only if flight ProjReorderInventIssueListForQuarantineOrderFlight is on
        // context.parmRefInventTransOrigin() is set in InventQuarantineUpdEnd only if the flight is on 
        ProjInventOrderIssueListForQuarantineContext context = ProjInventOrderIssueListForQuarantineContext::current();
        if (context && context.parmRefInventTransOrigin())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransToIssueListFromDatabaseForProject</Name>
				<Source><![CDATA[
    private boolean initializeInventTransToIssueListFromDatabaseForProject(InventTransChildType _inventTransChildType,
                                                                      InventTransChildRefId _inventTransChildRefId, 
                                                                      StatusIssue _fromStatus,
                                                                      StatusIssue _toStatus)
    {
        ProjInventOrderIssueListForQuarantineContext context = ProjInventOrderIssueListForQuarantineContext::current();
        boolean transAddedToIssueList = false;
        InventTrans inventTransIssue;

        // After partial product receipt there are multiple records in InventTrans with the same InventTransOrigin. 
        // All the transactions that have the same InventTransOrigin and same Issue and receipt status need to be added to the issueTransList
        // The following query ensures that the InventTrans record referencing the quarantine order is added to the list first for 
        // processing by the end quarantine routine

        select firstonly forupdate inventTransIssue
            where inventTransIssue.InventTransOrigin == movement.inventTransOriginId()
                && inventTransIssue.TransChildType == _inventTransChildType
                && inventTransIssue.TransChildRefId == _inventTransChildRefId
                && inventTransIssue.StatusIssue >= _fromStatus
                && inventTransIssue.StatusIssue <= _toStatus
                && inventTransIssue.StatusReceipt == StatusReceipt::None
                && inventTransIssue.RecId != preferedInventTransRecId
                && inventTransIssue.ProjId != ''
                && inventTransIssue.MarkingRefInventTransOrigin == context.parmRefInventTransOrigin();
        if (inventTransIssue)
        {
            this.addInventTransToListForProject(inventTransIssue);
            transAddedToIssueList = true;
        }

        // Following loop adds all the other transactions that follow the conditions except the one added by the previous query to the issueTransList
        while select forupdate inventTransIssue
            order by StatusIssue, InventDimId, Qty // sort by quantity to minimize splitting of transactions
            where inventTransIssue.InventTransOrigin == movement.inventTransOriginId()
                && inventTransIssue.TransChildType == _inventTransChildType
                && inventTransIssue.TransChildRefId == _inventTransChildRefId
                && inventTransIssue.StatusIssue >= _fromStatus
                && inventTransIssue.StatusIssue <= _toStatus
                && inventTransIssue.StatusReceipt == StatusReceipt::None
                && inventTransIssue.RecId != preferedInventTransRecId
                && inventTransIssue.ProjId != ''
                && inventTransIssue.MarkingRefInventTransOrigin != context.parmRefInventTransOrigin()
        {
            this.addInventTransToListForProject(inventTransIssue);
            transAddedToIssueList = true;
        }

        return transAddedToIssueList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInventTransToListForProject</Name>
				<Source><![CDATA[
    private void addInventTransToListForProject(InventTrans _inventTrans)
    {
        if (this.includeInventTransInIssueList(_inventTrans))
        {
            issueTransList.addEnd(_inventTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransToReceiveList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a sorted list with inventory transactions to receive.
    /// </summary>
    /// <param name="_fromStatus">
    /// The first receipt status to include.
    /// </param>
    /// <param name="_toStatus">
    /// The last receipt status to include.
    /// </param>
    /// <param name="_inventDimId">
    /// The exact inventory dimension ID if known; otherwise, an empty string.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// An <c>InventDim</c> record identifying the required inventory dimension values.
    /// </param>
    /// <param name="_inventDimParm">
    /// An <c>InventDimParm</c> records identifying which inventory dimensions are required.
    /// </param>
    /// <param name="_inventTransChildType">
    /// The required <c>TransChildType</c> value for transactions.
    /// </param>
    /// <param name="_inventTransChildRefId">
    /// The required <c>TransChildRefId</c> value for transactions.
    /// </param>
    /// <param name="_maxQty">
    /// The maximal inventory quantity to receive.
    /// </param>
    /// <param name="_addRecordsNotMatchingCriteria">
    /// A Boolean parameter that specifies if inventory transactions that do not match specified criteria should be included anyway.
    /// </param>
    public void initInventTransToReceiveList(
        StatusReceipt           _fromStatus,
        StatusReceipt           _toStatus,
        InventDimId             _inventDimId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm,
        InventTransChildType    _inventTransChildType,
        InventTransChildRefId   _inventTransChildRefId,
        InventQty               _maxQty,
        boolean                 _addRecordsNotMatchingCriteria = false)
    {
        receiptTransListEnumerator = null;    // reset the enumerator to ensure an enumerator for an old list doesn't get reused.

        InventTransReceiveListParameters parameters = InventTransReceiveListParameters::construct();
        
        parameters.fromStatus = _fromStatus;
        parameters.toStatus = _toStatus;
        parameters.inventDimId = _inventDimId;
        parameters.inventDimCriteria = _inventDimCriteria;
        parameters.inventDimParm = _inventDimParm;
        parameters.inventTransChildType = _inventTransChildType;
        parameters.inventTransChildRefId = _inventTransChildRefId;
        parameters.maxQty = _maxQty;
        parameters.addRecordsNotMatchingCriteria = _addRecordsNotMatchingCriteria;

        // Ignore prefer full physical tracking dimension if tracking dimension from batch or serial allow blank receipt
        if (parameters.FromStatus == StatusReceipt::Registered
        &&  parameters.ToStatus   == StatusReceipt::Registered
        && (!parameters.inventDimId || parameters.inventDimParm.isAllFlagNo())
        && EcoResTrackingDimGroupSetupCache::isBlankReceiptAllowedForBatchOrSerialDimension(movement.inventDimGroupSetup().getTrackingDimensionGroup()))
        {
            parameters.preferFullPhysicalTrackingDim = false;
        }
        else
        {
            parameters.preferFullPhysicalTrackingDim = this.parmPreferFullPhysicalTrackingDim();
        }

        parameters.movement = movement;
        parameters.preferedInventTransRecId = preferedInventTransRecId;

        if (customInventTransListInitialized)
        {
            this.initializeInventTransToReceiveListWithCustomInventTransList(parameters);
        }
        else
        {
            InventTransReceiveList inventTransReceiveList = InventTransReceiveList::newFromParameters(parameters);

            receiptTransList = inventTransReceiveList.convertMapToList();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransToReceiveListWithCustomInventTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a list with transactions to receive using the custom inventory transactions to receive list.
    /// </summary>
    /// <param name="_parameters">
    /// An instance of <c>InventTransReceiveListParameters</c>.
    /// </param>
    final protected void initializeInventTransToReceiveListWithCustomInventTransList(InventTransReceiveListParameters _parameters)
    {
        ListEnumerator enumerator = customInventTransList.getEnumerator();
        receiptTransList = new List(Types::Record);
        customInventTransMap = new Map(Types::Int64, Types::Real);

        while (enumerator.moveNext())
        {
            InventUpdateCustomTransReceiptListItem tmpInventTransItem = enumerator.current();

            if (this.validateCustomReceiptInventTrans(tmpInventTransItem, _parameters))
            {
                receiptTransList.addEnd(tmpInventTransItem.inventTrans);
                customInventTransMap.insert(tmpInventTransItem.inventTrans.RecId, tmpInventTransItem.inventQty);
            }
            else
            {
                InventUpdateCustomInventTransListTelemetryLogger::logInvalidCustomInventTrans(this, funcName(), tmpInventTransItem.inventTrans, tmpInventTransItem.inventQty);
                throw error(Error::wrongUseOfFunction(funcName()));
            }
        }

        InventUpdateCustomInventTransListTelemetryLogger::logTransListInitializedFromCustomList(this, funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCustomReceiptInventTrans</Name>
				<Source><![CDATA[
    internal boolean validateCustomReceiptInventTrans(InventUpdateCustomTransReceiptListItem _listItem, InventTransReceiveListParameters _parameters)
    {
        boolean result = (_listItem.inventQty                           > 0
                            && _listItem.inventTrans.TransChildType     == _parameters.inventTransChildType
                            && _listItem.inventTrans.TransChildRefId    == _parameters.inventTransChildRefId
                            && _listItem.inventTrans.StatusReceipt      >= _parameters.fromStatus
                            && _listItem.inventTrans.StatusReceipt      <= _parameters.toStatus
                            && _listItem.inventTrans.StatusIssue        == StatusIssue::None
                            && _listItem.inventTrans.InventTransOrigin  == movement.inventTransOriginId()
                            && (_parameters.loadId == '' || _listItem.inventTrans.LoadId == _parameters.loadId)
                            && !customInventTransMap.exists(_listItem.inventTrans.RecId));

        if (!result || !_parameters.inventDimId || _parameters.inventDimParm.isAllFlagNo())
        {
            return result;
        }

        if (_parameters.inventDimId && _parameters.inventDimParm.isAllFlagYes())
        {
            return result && (_listItem.inventTrans.inventDimId == _parameters.inventDimId || _parameters.addRecordsNotMatchingCriteria);
        }

        InventDim inventDimRequired = InventDim::find(_listItem.inventTrans.InventDimId);
        return result && (InventDim::isInventDimParmEqual(inventDimRequired, _parameters.inventDimCriteria, _parameters.inventDimParm)
                            || _parameters.addRecordsNotMatchingCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    protected void initUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRefiningDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determine whether the dimension within an inventory transaction is refining
    ///    the inventory dimension record specified
    /// </summary>
    /// <param name="_inventTrans">
    ///    An inventory transaction containing an inventory dimension to verify.
    /// </param>
    /// <param name="_inventDim">
    ///    An inventory dimension.
    /// </param>
    /// <returns>
    ///    true if the inventory dimension of the inventory transaction is refining the
    ///    inventory dimension specified as parameter, based on the fields defined by
    ///    the item inventory dimension group setup of the movement;
    ///    otherwise, false.
    /// </returns>
    /// <remarks>
    ///    An inventory dimension B will refine an inventory dimension A if all the
    ///    active non-empty field values specified by A have the same value in B.
    ///    B may in turn specify additional values that A has empty.
    /// </remarks>
    protected boolean isRefiningDimension(
        InventTrans     _inventTrans,
        InventDim       _inventDim)
    {
        InventDimGroupSetup     inventDimGroupSetup;
        InventDim               inventDimNew;
        boolean                 refiningDimension = false;

        inventDimGroupSetup = movement.inventDimGroupSetup();
        if (inventDimGroupSetup)
        {
            inventDimNew = _inventTrans.inventDim();
            if (inventDimNew.isRefiningDimension(inventDimGroupSetup, _inventDim))
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>movement</Name>
				<Source><![CDATA[
    public InventMovement movement(InventMovement _movement = movement)
    {
        movement = _movement;
        return movement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    protected void new(InventMovement _inventMovement)
    {
        movement        = _inventMovement;

        if (!movement || !movement.itemId())
        {
            throw error("@SYS25157");
        }
       
        if ((!movement.allowInventoryUpdateWhenInventTransIdIsEmpty() || !this.isDeleteOperation()) && !movement.transId())
        {
            // In case of aggregation of inventory trans, a transId is not available at the time when InventUpdate is instantiated.
            if (!isConfigurationkeyEnabled(configurationKeyNum(Retail))
                || !RetailParameters::find().AggregateBeforePosting
                // Same behavior as non aggregated
            || RetailStatementFeatureControl::isNotAggregateInventoryReservationEnabled())
            {
                movement.logUnexpectedLotIdNotSpecified(funcName());
                throw error("@SYS17272");
            }
        }

        burdenItem = false;

        // <GEERU>
        if (movement.parmCompanyCountryRegion().isCountryRegionRU())
        {
            transLinkCache_RU =  TransLinkCache_RU::newFromInventUpdate();
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreferFullPhysicalTrackingDim</Name>
				<Source><![CDATA[
    public boolean parmPreferFullPhysicalTrackingDim(boolean _preferFullPhysicalTrackingDim = preferFullPhysicalTrackingDim)
    {
        preferFullPhysicalTrackingDim =  _preferFullPhysicalTrackingDim;
        
        return preferFullPhysicalTrackingDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateForSubParmLine</Name>
				<Source><![CDATA[
    public boolean parmUpdateForSubParmLine(NoYes _updateForSubParmLine = updateForSubParmLine)
    {
        updateForSubParmLine =  _updateForSubParmLine;
        
        return updateForSubParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowAutoReserveDim</Name>
				<Source><![CDATA[
    public boolean parmAllowAutoReserveDim(boolean _ok = allowAutoReserveDim)
    {
        allowAutoReserveDim = _ok;
        return allowAutoReserveDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowNegativeFinancial</Name>
				<Source><![CDATA[
    public InventNegativeFinancial parmAllowNegativeFinancial(InventNegativeFinancial _ok = allowNegativeFinancial)
    {
        allowNegativeFinancial = _ok;
        return allowNegativeFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowNegativePhysical</Name>
				<Source><![CDATA[
    public InventNegativePhysical parmAllowNegativePhysical(InventNegativePhysical _ok = allowNegativePhysical)
    {
        allowNegativePhysical = _ok;
        return allowNegativePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowReserveByDate</Name>
				<Source><![CDATA[
    public boolean parmAllowReserveByDate(boolean _ok = allowReserveByDate)
    {
        allowReserveByDate = _ok;
        return allowReserveByDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowReserveOrdered</Name>
				<Source><![CDATA[
    public boolean parmAllowReserveOrdered(boolean _allowReserveOrdered = allowReserveOrdered)
    {
        allowReserveOrdered = _allowReserveOrdered;
        return allowReserveOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowReservePhysical</Name>
				<Source><![CDATA[
    public boolean parmAllowReservePhysical(boolean _ok = allowReservePhysical)
    {
        allowReservePhysical = _ok;
        return allowReservePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowReservePhysUpdateForAllMarked</Name>
				<Source><![CDATA[
    public boolean parmAllowReservePhysUpdateForAllMarked(boolean _allowReservePhysicalUpdateForAllMarked = allowReservePhysicalUpdateForAllMarked)
    {
        allowReservePhysicalUpdateForAllMarked = _allowReservePhysicalUpdateForAllMarked;

        return allowReservePhysicalUpdateForAllMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowReserveReduction</Name>
				<Source><![CDATA[
    public boolean parmAllowReserveReduction(boolean _ok = allowReserveReduction)
    {
        allowReserveReduction = _ok;
        return allowReserveReduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowReserveReversed</Name>
				<Source><![CDATA[
    public boolean parmAllowReserveReversed(boolean _ok = allowReserveReversed)
    {
        allowReserveReversed = _ok;
        return allowReserveReversed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBurdenItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the burdenItem parameter.
    /// </summary>
    /// <param name="_burdenItem">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The burdenItem parameter.
    /// </returns>
    /// <remarks>
    /// This method also updates the movement's burden item parameter.
    /// <syntax>
    /// public Enum parmBurdenItem(Enum _burdenItem)
    /// </syntax>
    /// </remarks>
    public boolean parmBurdenItem(boolean _burdenItem = burdenItem)
    {
        burdenItem = _burdenItem;
        movement.parmBurdenItem(burdenItem);

        return burdenItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentStornoId_RU</Name>
				<Source><![CDATA[
    public Num parmDocumentStornoId_RU(Num _documentStornoId = documentStornoId)
    {
        documentStornoId = _documentStornoId;
        return documentStornoId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRateDate</Name>
				<Source><![CDATA[
    public TransDate parmExchangeRateDate(TransDate _exchangeRateDate = exchangeRateDate)
    {
        exchangeRateDate = _exchangeRateDate;
        return exchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimQuarantine</Name>
				<Source><![CDATA[
    public InventDim parmInventDimQuarantine(InventDim _inventDimQuarantine = inventDimQuarantine)
    {
        inventDimQuarantine = _inventDimQuarantine;
        return inventDimQuarantine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventReceiptForTestRegistrator</Name>
				<Source><![CDATA[
    public InventReceiptForTestRegistrator parmInventReceiptForTestRegistrator(InventReceiptForTestRegistrator _inventReceiptForTestRegistrator = inventReceiptForTestRegistrator)
    {
        inventReceiptForTestRegistrator = _inventReceiptForTestRegistrator;

        return inventReceiptForTestRegistrator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNeedTransIdTransit_RU</Name>
				<Source><![CDATA[
    public boolean parmNeedTransIdTransit_RU(boolean _needTransIDTransit = needTransIDTransit)
    {
        needTransIDTransit = _needTransIDTransit;
        return needTransIDTransit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPhysicalReduction</Name>
				<Source><![CDATA[
    public InventPhysicalReduction parmPhysicalReduction(InventPhysicalReduction _physicalReduction = physicalReduction)
    {
        physicalReduction = _physicalReduction;
        return physicalReduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreferedInventTransRecId</Name>
				<Source><![CDATA[
    public RefRecId parmPreferedInventTransRecId(RefRecId _preferedInventTransRecId = preferedInventTransRecId)
    {
        preferedInventTransRecId = _preferedInventTransRecId;
        return preferedInventTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCostAmountMST</Name>
				<Source><![CDATA[
    public AmountCur  parmProjCostAmountMST(AmountMST  _projCostAmountMST = projCostAmountMST)
    {
        projCostAmountMST = _projCostAmountMST;
        return projCostAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjCostAmountMSTSecCur_RU</Name>
				<Source><![CDATA[
    AmountCur parmProjCostAmountMSTSecCur_RU(AmountMSTSecondary _projCostAmountMSTSecCur = projCostAmountMSTSecCur)
    {
        projCostAmountMSTSecCur = _projCostAmountMSTSecCur;
        return projCostAmountMSTSecCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransLinkCache_RU</Name>
				<Source><![CDATA[
    final public TransLinkCache_RU parmTransLinkCache_RU(TransLinkCache_RU _transLinkCache = transLinkCache_RU)
    {
        transLinkCache_RU = _transLinkCache;
        return transLinkCache_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWhsLocationMixingConstraintCheckSkip</Name>
				<Source><![CDATA[
    public WhsLocationMixingConstraintCheckSkip parmWhsLocationMixingConstraintCheckSkip(WhsLocationMixingConstraintCheckSkip _whsLocationMixingConstraintCheckSkip = whsLocationMixingConstraintCheckSkip)
    {
        whsLocationMixingConstraintCheckSkip = _whsLocationMixingConstraintCheckSkip;

        return whsLocationMixingConstraintCheckSkip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWmsMovement</Name>
				<Source><![CDATA[
    public boolean parmWmsMovement(boolean _wmsMovement = wmsMovement)
    {
        wmsMovement = _wmsMovement;
        return wmsMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDispositionCode</Name>
				<Source><![CDATA[
   internal WhsLoadLineInventoryReceiptId parmDispositionCode(WHSDispositionCode _dispositionCode = dispositionCode)
   {
       dispositionCode = _dispositionCode;

       return dispositionCode;
   }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustInventoryQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts inventory quantity for the movement.
    /// </summary>
    /// <param name="_inventQtyAdjustment">
    ///    The quantity to adjust in inventory unit.
    /// </param>
    /// <param name="_inventDimId">
    ///    The preferred inventory dimension to adjust the inventory quantity for; optional.
    /// </param>
    public void pdsAdjustInventoryQuantity(
        InventQty   _inventQtyAdjustment,
        InventDimId _inventDimId = movement.inventDimId())
    {
        InventUpd_ChangeDimension   inventUpd_ChangeDimension;
        InventDimParm               inventDimParm;

        if (movement.pdsCWItem() && _inventQtyAdjustment)
        {
            movement.pdsAdjustInventoryQuantity(_inventQtyAdjustment);
            // We would never want to attempt to auto reserve, since the change dimension below only looks at on order.
            movement.parmAutoReserveWhenAdjustingCatchWeight(false);
            movement.pdsUpdateBufferWithAdjustedQuantity(_inventDimId);

            // If we had to increase the ordered quantity then a zero CW transaction has been created
            // The adjustment transaction has inventMovement dimension.
            // We need to change the dimension so the transaction will be collapsed into the reserved non-zero CW transaction
            if (_inventDimId != movement.inventDimId() && _inventQtyAdjustment < 0)
            {
                inventDimParm.initFromInventDim(movement.inventdim());
                inventUpd_ChangeDimension = InventUpd_ChangeDimension::newParameters(movement, movement.inventdim(), inventDimParm,
                                            InventDim::find(_inventDimId), _inventQtyAdjustment);
                inventUpd_ChangeDimension.parmOnlySelectOnOrder(true);
                inventUpd_ChangeDimension.updateNow();
            }

            // Flush movement's cached InventTransIdSum object since quantity was updated by external process
            movement.transIdSum(true);

            if (FormDataUtil::isFormDataSource(movement.buffer()))
            {
                InventUpdate::refreshCallerDatasource(FormDataUtil::getFormDataSource(movement.buffer()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCalculateInventoryQuantityAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity in inventory unit that has to be adjusted for the current movement because
    /// of the update.
    /// </summary>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_cwActualQuantity">
    /// The actual quantity in catch weight unit.
    /// </param>
    /// <param name="_actualQuantity">
    /// The actual quantity in inventory unit.
    /// </param>
    /// <param name="_cwUpdatedQuantity">
    /// The updated quantity in catch weight unit.
    /// </param>
    /// <param name="_updatedQuantity">
    /// The updated quantity in inventory unit.
    /// </param>
    /// <returns>
    /// The quantity in inventory unit that has to be adjusted for the current movement because of the
    /// update.
    /// </returns>
    /// This method suggests the inventory quantity that needs to be adjusted in order to keep the remainder inventory quantity in the range
    /// between minimal and maximal allowed inventory quantity for the remain catch weight quantity. This is also applied to the case when
    /// remaining catch weight quantity is zero. In this case this method will suggest to adjust the leftover inventory quantity. This will
    /// allow to get rid on inventory transactions with 0 catch weight quantity.
    public InventQty pdsCalculateInventoryQuantityAdjustment(
        ItemId          _itemId,
        PdsCWInventQty  _cwActualQuantity,
        InventQty       _actualQuantity,
        PdsCWInventQty  _cwUpdatedQuantity,
        InventQty       _updatedQuantity)
    {
        return _updatedQuantity - PdsCatchWeight::adjustSplitInventQty(
            _itemId,
            _cwActualQuantity,
            _actualQuantity,
            _cwUpdatedQuantity,
            _updatedQuantity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingFinancial</Name>
				<Source><![CDATA[
    public boolean postingFinancial(boolean _posting = postingFinancial)
    {
        postingFinancial = _posting;
        return postingFinancial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingFinancialCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if financial charge is posted.
    /// </summary>
    /// <param name="_posting">
    /// Set to true if financial charge is posted.
    /// </param>
    /// <returns>
    /// true if financial charges is posted; otherwise, false.
    /// </returns>
    public boolean postingFinancialCharge(boolean _posting = postingFinancialCharge)
    {
        postingFinancialCharge = _posting;
        return postingFinancialCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysical</Name>
				<Source><![CDATA[
    public boolean postingPhysical(boolean _posting = postingPhysical)
    {
        postingPhysical = _posting;
        return postingPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalCharge</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if physical charge is posted.
    /// </summary>
    /// <param name="_posting">
    /// Set to true if physical charge is posted.
    /// </param>
    /// <returns>
    /// true if physical charge is posted; otherwise, false.
    /// </returns>
    public boolean postingPhysicalCharge(boolean _posting = postingPhysicalCharge)
    {
        postingPhysicalCharge = _posting;
        return postingPhysicalCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingPhysicalRevenue</Name>
				<Source><![CDATA[
    public boolean postingPhysicalRevenue(boolean _posting = postingPhysicalRevenue)
    {
        postingPhysicalRevenue = _posting;
        return postingPhysicalRevenue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParmAllowDefault</Name>
				<Source><![CDATA[
    protected void setParmAllowDefault()
    {
        InventModelGroup inventModelGroup = movement.inventModelGroup();
        InventLocation   inventLocation = InventLocation::find(movement.inventLocationId());

        this.parmAllowReservePhysical(true);
        this.parmAllowAutoReserveDim(true);
        this.parmAllowReserveOrdered(InventParameters::find().ReserveOnOrdered);
        this.parmAllowReserveByDate(inventModelGroup.ReserveByDate);
        this.parmAllowReserveReversed(inventModelGroup.ReserveReversed);

        if (!movement.inventTable().inventItemType().mustInventBeControlled() || movement.mustDoAutoLossProfitEstimate())
        {
            this.parmAllowNegativeFinancial(true);
            this.parmAllowNegativePhysical(true);
        }
        else
        {
            boolean negativeFinancial = (inventModelGroup.NegativeFinancial || (inventLocation && inventLocation.RetailInventNegFinancial));
            boolean negativePhysical  = (inventModelGroup.NegativePhysical  || (inventLocation && inventLocation.RetailInventNegPhysical));

            this.parmAllowNegativeFinancial(negativeFinancial);
            this.parmAllowNegativePhysical(negativePhysical);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVirtuelProjReferenceTransOriginId</Name>
				<Source><![CDATA[
    protected void setVirtuelProjReferenceTransOriginId (InventTransOriginId _markingRefInventTransOrigin)
    {
        InventMovement      mov;

        if (movement.mustDoAutoLossProfitEstimate())
        {
            mov = InventMovement::constructNoThrow(InventTrans::findByInventTransOrigin(_markingRefInventTransOrigin));
            if (mov && mov.isVirtuel())
            {
                movement.parmInventTransOriginIdRef_virtuel(_markingRefInventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransIssueOnDimReserveChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the issue inventory transaction when the reserved dimension is changed.
    /// </summary>
    /// <param name = "_inventTransIssue">The issue inventory transaction.</param>
    /// <param name = "_fromInventDim">The from dimension.</param>
    /// <param name = "_toInventDim">The to dimension.</param>
    /// <param name = "_isPhysicalReservation">Boolean specifying whether the quantities are physically reserved.</param>
    /// <param name = "_qtyReserve">The quantity.</param>
    /// <param name = "_cwQty">The catch weight quantity.</param>
    /// <returns>A container with remaining quantity and catch weight quantity.</returns>
    protected container updateInventTransIssueOnDimReserveChange(
        InventTrans _inventTransIssue, 
        InventDim _fromInventDim, 
        InventDim _toInventDim, 
        boolean _isPhysicalReservation,
        InventQty _qtyReserve, 
        PdsCWInventQty _cwQty) 
    {
        if (_qtyReserve < -_inventTransIssue.Qty)
        {
            _inventTransIssue.updateSplit(-_qtyReserve, -_cwQty);
        }

        if (_isPhysicalReservation)
        {
            _inventTransIssue.StatusIssue = StatusIssue::ReservPhysical;
        }

        _inventTransIssue.InventDimId = _toInventDim.InventDimId;

        if (#PdsEnabled && _toInventDim.inventBatchId && InventBatchDispCheckOnDimReserveChangeFlight::instance().isEnabled())
        {
            InventBatch inventBatch = InventBatch::find(_toInventDim.inventBatchId, _inventTransIssue.ItemId);

            if (inventBatch && inventBatch.PdsDispositionCode)
            {
                PdsBatchDispCheck_Reserve pdsBatchDispCheck = PdsBatchDispCheck_Reserve::construct();
                if (!pdsBatchDispCheck.validateTransCheck(_inventTransIssue))
                {
                    throw error(strFmt("@SCM:InventBatchDispBlock", _toInventDim.inventBatchId));
                }
            }
        }

        InventUpdate::updateTransDimTransferReceipt(movement, _inventTransIssue, _toInventDim);

        _inventTransIssue.update();

        _qtyReserve  += _inventTransIssue.Qty;
        _cwQty += _inventTransIssue.PdsCWQty;

        if (_inventTransIssue.TransChildType != InventTransChildType::None)
        {
            InventTransChildReference::newFromInventTrans(_inventTransIssue).updateReferenceQuantity(_fromInventDim.inventDimId, _toInventDim.inventDimId, _isPhysicalReservation, _inventTransIssue.Qty, _inventTransIssue.PdsCWQty);
        }

        _inventTransIssue.updateSumUp();

        return [_qtyReserve, _cwQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimReserveChange</Name>
				<Source><![CDATA[
    protected container updateDimReserveChange(
        InventDim           _toInventDim,
        InventDim           _fromInventDim,
        InventQty           _qtyReserv,
        boolean             _reserveAsPhysical,
        InventTransOriginId _markingRefInventTransOrigin = 0,
        PdsCWInventQty      _cwQty = 0
        )
    {
        InventTrans         inventTransIssue;
        Integer             caseCount;
        PdsCWInventQty      cwQty = _cwQty;

        if ((!this.parmAllowReserveOrdered() && !_markingRefInventTransOrigin)// always change reserved transaction if marked transaction
        ||  !this.parmAllowAutoReserveDim()
        ||  (_qtyReserv <= 0)
        ||  (_toInventDim.InventDimId == _fromInventDim.InventDimId)
        ||  movement.mustBeQuarantineControlled())
        {
            if (this.movement().isItemWHSEnabled())
            {
                this.validateDimensionsChange(_toInventDim, _fromInventDim, _qtyReserv, _markingRefInventTransOrigin, _cwQty);
            }
            return [_qtyReserv,_cwQty];
        }

        if (!_toInventDim.InventDimId || ! _fromInventDim.InventDimId)
        {
            throw error(strFmt("@SYS19378",funcName()));
        }

        // Checking for ordered reserved inventory to change is
        // completely different with WHS controlled items
        if (this.movement().isItemWHSEnabled() 
            && _toInventDim.inventLocation().WHSEnabled)
        {
            return this.whsUpdateDimReserveChange(_toInventDim, _fromInventDim, _qtyReserv, _reserveAsPhysical, _markingRefInventTransOrigin, _cwQty);
        }

        InventDimFixed changeDimFixed = InventDimFixedClass::inventDimFieldsDifferent(_toInventDim, _fromInventDim);

        while (caseCount < 2 && _qtyReserv > 0)
        {
            caseCount++;

            while select forupdate inventTransIssue
                index StatusItemIdx
                where inventTransIssue.ItemId              == movement.itemId()
                   && inventTransIssue.ValueOpen           == InventTransOpen::Yes
                   && inventTransIssue.StatusReceipt       == StatusReceipt::None
                   && inventTransIssue.StatusIssue         == StatusIssue::ReservOrdered
                   && inventTransIssue.InventDimId         == _fromInventDim.InventDimId
                   && inventTransIssue.InventTransOrigin   != movement.inventTransOriginId()
            {
                if (!inventTransIssue.MarkingRefInventTransOrigin ||
                    inventTransIssue.MarkingRefInventTransOrigin   == movement.inventTransOriginId())
                { 
                    // Kept separate due to problem with recordViewCache
                    if (changeDimFixed & inventTransIssue.InventDimFixed != 0)
                    {
                        if (caseCount == 2)
                        {
                            if (!allowNegativePhysical)
                            {
                                //since the transaction was fixed on different dimensions than the ones in the _toInventDim we include the fixed dimensions in the on-hand check
                                InventOnHandQty inventOnHandQty = InventOnHandQty::newEstimatedUpdate(movement, _fromInventDim, inventTransIssue.InventDimFixed);
                                if (inventOnHandQty.availOrdered() - _qtyReserv < 0)
                                {
                                    InventTransOrigin inventTransOriginIssue = inventTransIssue.inventTransOrigin();
                                    setPrefix(#preFixField(inventTransOriginIssue,ReferenceCategory));
                                    setPrefix(#preFixField(inventTransOriginIssue,ReferenceId));
                                    throw error("@SYS54454");
                                }
                            }
                            break;
                        }
                    }
                    else
                    {
                        [_qtyReserv, cwQty] = this.updateInventTransIssueOnDimReserveChange(inventTransIssue, _fromInventDim, _toInventDim, _reserveAsPhysical, _qtyReserv, cwQty);

                        if (!_qtyReserv)
                        {
                            break;
                        }
                    }
                }
            }
        }

        return [_qtyReserv, cwQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimReservePhysical</Name>
				<Source><![CDATA[
    public InventQty updateDimReservePhysical(
        InventDim           _inventDim,
        InventQty           _qtyReserv,
        InventTransOriginId _markingRefInventTransOrigin = 0,
        PdsCWInventQty      _cwQty = 0
        )
    {
        InventTrans         inventTransIssue;
        InventDimFixed      changeDimFixed;
        Integer             caseCount;
        WMSOrder            wmsOrder;

        InventDimParm       inventDimParm;
        InventDimParm       inventDimParmActivePrimaryDim;
        InventDim           inventDim;
        InventDim           inventDimCriteria;
        InventDim           inventDimFrom;
        InventTrans         inventTrans;
        ProjId              projId;

        boolean             ok;

        PdsCWInventQty      cwQty = _cwQty;

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail))
            && !_inventDim.InventDimId)
        {
            _inventDim.InventDimId = InventDim::inventDimIdBlank();
            InventDim::findOrCreate(_inventDim);
        }

        if ((this.parmAllowReserveOrdered() || _markingRefInventTransOrigin)   && // always reserve physical for marked transactions
             this.parmAllowAutoReserveDim()                         &&
            ! movement.mustBeQuarantineControlled()                 &&
             _qtyReserv > 0)
        {
            if (!_inventDim.InventDimId)
            {
                throw error(strFmt("@SYS19378",funcName()));
            }

            // Checking for ordered reserved inventory to change to physical reserved is
            // completely different with WHS controlled items
            if (WHSInventEnabled::exist(movement.itemId()) 
                && (WHSUseSplitQtyOnCWTransactionSplitForWHSItemOnNonWHSWarehouseFlight::instance().isEnabled()
                    // These conditions below allow skipping whs specific reservation for CW item on non-whs enabled warehouse
                    || (_inventDim.inventLocation().WHSEnabled
                        || !PdsGlobal::pdsIsCWItem(movement.itemId()))))
            {
                return this.reservePhysicalReserveOrderedQuantities(_inventDim, _qtyReserv, cwQty, _markingRefInventTransOrigin);
            }

            if (_markingRefInventTransOrigin)
            {
                caseCount = -1;
            }

            while (caseCount < 2 && _qtyReserv > 0)
            {
                caseCount++;

                switch (caseCount)
                {
                    case 0:
                        inventDimCriteria.data(_inventDim);
                        inventDimParm.initFromInventDim(_inventDim);
                        break;
                    case 1:
                        inventDimCriteria.data(_inventDim);
                        movement.inventDimGroupSetup().inventDimParmActive(inventDimParm);
                        break;
                    case 2:
                        movement.inventDimGroupSetup().inventDimParmActivePrimaryDimension(inventDimParmActivePrimaryDim);
                        /*
                            If all active dimensions are primary there is no need to do a second select with the same criteria.

                            If they are not the same, for performance reasons, we do not modify the inventDimCriteria to clear
                            non-primary fields but instead let the inventDimParm control the filtering.
                        */
                        if (inventDimParmActivePrimaryDim.equal(inventDimParm))
                        {
                            continue;
                        }
                        inventDimParm.data(inventDimParmActivePrimaryDim);
                        break;
                }

                if (_markingRefInventTransOrigin)
                {
                    //If there is a projID associated with _markingRefInventTransOrigin then pass inventDimId to update inventTransIssue
                    select projId from inventTrans where inventTrans.InventTransOrigin == _markingRefInventTransOrigin;
                    if(inventTrans.ProjId && !inventTransIssue && ProjPurchPOPostingWithAutoBatchEnabledFlight::instance().isEnabled())
                    {
                        select forceplaceholders forupdate inventTransIssue
                        order by inventTransIssue.TransChildRefId desc
                        where inventTransIssue.ItemId                       == movement.itemId()
                            && inventTransIssue.ValueOpen                    == InventTransOpen::Yes
                            && inventTransIssue.StatusReceipt                == StatusReceipt::None
                            && inventTransIssue.StatusIssue                  == StatusIssue::ReservOrdered
                            && inventTransIssue.InventTransOrigin            == _markingRefInventTransOrigin
                            && inventTransIssue.MarkingRefInventTransOrigin  == movement.inventTransOriginId()
                            && inventTransIssue.inventDimId                  == movement.inventDimId();
                    }
                    else
                    {
                        select forceplaceholders forupdate inventTransIssue
                        order by inventTransIssue.TransChildRefId desc
                        where inventTransIssue.ItemId                       == movement.itemId()
                            && inventTransIssue.ValueOpen                    == InventTransOpen::Yes
                            && inventTransIssue.StatusReceipt                == StatusReceipt::None
                            && inventTransIssue.StatusIssue                  == StatusIssue::ReservOrdered
                            && inventTransIssue.InventTransOrigin            == _markingRefInventTransOrigin
                            && inventTransIssue.MarkingRefInventTransOrigin  == movement.inventTransOriginId()
                    #inventDimExistsJoin(inventTransIssue.InventDimId,inventDim,inventDimCriteria,inventDimParm);
                    }
                }
                else if (!movement.isReturnScrap())
                {
                    select forceplaceholders forupdate inventTransIssue
                        order by DateStatus
                        where inventTransIssue.ItemId                       == movement.itemId()
                           && inventTransIssue.ValueOpen                    == InventTransOpen::Yes
                           && inventTransIssue.StatusReceipt                == StatusReceipt::None
                           && inventTransIssue.StatusIssue                  == StatusIssue::ReservOrdered
                           && inventTransIssue.InventTransOrigin            != movement.inventTransOriginId()
                           && (this.parmAllowReservePhysUpdateForAllMarked()
                           ||  inventTransIssue.MarkingRefInventTransOrigin  == 0)
                    #inventDimExistsJoin(inventTransIssue.InventDimId,inventDim,inventDimCriteria,inventDimParm);
                }

                while (inventTransIssue)
                {
                    inventDimFrom   = InventDim::find(inventTransIssue.InventDimId);
                    changeDimFixed  = InventDimFixedClass::inventDimFieldsDifferent(_inventDim, inventDimFrom, (caseCount == 3 ? true : false));

                    ok = true;
                    if (changeDimFixed & inventTransIssue.InventDimFixed != 0)
                    {
                        ok = false;
                    }
                    else if (inventTransIssue.TransChildType != InventTransChildType::None)
                    {
                        ok = InventTransChildReference::newFromInventTrans(inventTransIssue).canUpdateReferenceQuantity(inventDimFrom.inventDimId,_inventDim.inventDimId,-1*min(-inventTransIssue.Qty,_qtyReserv),-1*min(-inventTransIssue.PdsCWQty,_cwQty));
                    }

                    if (ok)
                    {
                        [_qtyReserv, cwQty] = this.updateInventTransIssue(inventTransIssue, _inventDim, inventDimFrom, _qtyReserv, cwQty);

                        if (! _qtyReserv)
                        {
                            break;
                        }
                    }

                    next inventTransIssue;
                }
            }
        }
        return _qtyReserv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransIssue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the issue <c>InventTrans</c> record based on the passed arguments.
    /// </summary>
    /// <param name = "_inventTransIssue">
    /// The issue transaction record to be updated.
    /// </param>
    /// <param name = "_inventDim">
    /// <c>InventDim</c> record associated with the issue transaction.
    /// </param>
    /// <param name = "_inventDimFrom">
    /// The original <c>InventDim</c> record.
    /// </param>
    /// <param name = "_qtyReserv">
    /// The reserved quantity.
    /// </param>
    /// <param name = "_cwQty">
    /// The catch weight qty.
    /// </param>
    /// <returns>
    /// A container with both the updated cumulated reserved and the cumulated catch weight quantities.
    /// </returns>
    protected container updateInventTransIssue(InventTrans _inventTransIssue, InventDim _inventDim, InventDim _inventDimFrom, InventQty _qtyReserv, PdsCWInventQty _cwQty)
    {
        if (_qtyReserv < -_inventTransIssue.Qty)
        {
            _inventTransIssue.updateSplit(-_qtyReserv, -_cwQty);
        }

        _inventTransIssue.StatusIssue    = StatusIssue::ReservPhysical;
        _inventTransIssue.InventDimId    = _inventDim.InventDimId;

        InventUpdate::updateTransDimTransferReceipt(movement, _inventTransIssue, _inventDim);

        _inventTransIssue.update();

        _qtyReserv += _inventTransIssue.Qty;

        _cwQty += _inventTransIssue.PdsCWQty;

        if (_inventTransIssue.TransChildType != InventTransChildType::None)
        {
            InventTransChildReference::newFromInventTrans(_inventTransIssue).updateReferenceQuantity(_inventDimFrom.inventDimId, _inventDim.inventDimId, true, _inventTransIssue.Qty, _inventTransIssue.PdsCWQty);
        }

        _inventTransIssue.updateSumUp();

        return [_qtyReserv, _cwQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDimTransferIssueReceipt</Name>
				<Source><![CDATA[
    protected InventQty updateDimTransferIssueReceipt(
        InventMovement      _movementTransfer,
        InventDim           _toInventDim,
        InventDim           _fromInventDim,
        InventQty           _qtyReserv,
        boolean             _reserveAsPhysical,
        PdsCWInventQty      _cwQty = 0
        )
    {
        InventTrans         inventTransIssue;

        PdsCWInventQty      cwQty = _cwQty;

        if (_toInventDim.InventDimId != _fromInventDim.InventDimId || _reserveAsPhysical)
        {
            if (!_toInventDim.InventDimId || !_fromInventDim.InventDimId || !_movementTransfer)
            {
                throw error(strFmt("@SYS19378",funcName()));
            }

            if (_qtyReserv > 0)
            {
                while select forupdate inventTransIssue
                    order by StatusIssue,InventDimId
                    where inventTransIssue.InventTransOrigin == _movementTransfer.inventTransOriginId()
                       && inventTransIssue.InventDimId       == _fromInventDim.InventDimId
                       && inventTransIssue.StatusReceipt     == StatusReceipt::None
                       && inventTransIssue.StatusIssue       > StatusIssue::ReservPhysical
                {
                    if (_qtyReserv < -inventTransIssue.Qty)
                    {
                        inventTransIssue.updateSplit(-_qtyReserv, -cwQty);
                    }

                    if (_reserveAsPhysical && inventTransIssue.StatusIssue == StatusIssue::ReservOrdered)
                    {
                        inventTransIssue.StatusIssue = StatusIssue::ReservPhysical;
                    }

                    inventTransIssue.InventDimId = _toInventDim.InventDimId;

                    InventUpdate::updateTransDimTransferReceipt(_movementTransfer,inventTransIssue,_toInventDim);

                    inventTransIssue.update();

                    _qtyReserv  += inventTransIssue.Qty;

                    cwQty += inventTransIssue.PdsCWQty;

                    inventTransIssue.updateSumUp();

                    if (!_qtyReserv)
                    {
                        break;
                    }
                }
            }
        }
        return _qtyReserv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEstimated</Name>
				<Source><![CDATA[
    protected void updateEstimated(
        InventQty       _estimated,
        UnitQty         _estimatedUnit,
        PdsCWInventQty _cwQty = 0
        )
    {
        InventMovement          parentMovement;
        InventUpd_Estimated     inventUpd_Estimated;

        if (_estimated|| _cwQty)
        {
            parentMovement = movement.parentMovement();
            parentMovement.addRemainPhysical(_estimated);
            parentMovement.addRemainPhysicalUnit(_estimatedUnit);

            parentMovement.pdsCWAddRemainPhysical(_cwQty);

            inventUpd_Estimated = InventUpd_Estimated::newInventMovement(parentMovement);
            inventUpd_Estimated.updateNow();

            parentMovement.updateDoBuffer();

            if (inventUpd_Estimated)
            {
                inventUpd_Estimated.updateReservation();
            }

            if (FormDataUtil::isFormDataSource(parentMovement.buffer()))
            {
                InventUpdate::refreshCallerDatasource(FormDataUtil::getFormDataSource(parentMovement.buffer()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransPosting</Name>
				<Source><![CDATA[
    protected void updateInventTransPosting(
        TransDate       _transDate,
        Voucher         _voucher)
    {
        InventTransPosting      inventTransPosting = this.initInventTransPosting();

        inventTransPosting.TransDate            = _transDate;
        inventTransPosting.Voucher              = _voucher;
        inventTransPosting.ProjId               = movement.projId();

        if (postingPhysical && movement.createInventTransPosting())
        {
            if (movement.mustBeBookedPhysically())
            {
                inventTransPosting.LedgerDimension          = this.getLedgerDimensionFromDefaultAccount(
                                                                    movement.accountPhysical(),
                                                                    movement.defaultDimension());
                inventTransPosting.OffsetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                    movement.offsetAccountPhysical(),
                                                                    movement.defaultDimension());

                inventTransPosting.PostingType              = movement.postingPhysical();
                inventTransPosting.PostingTypeOffset        = movement.postingOffsetPhysical();

                this.validateLedgerDimension(inventTransPosting.LedgerDimension, inventTransPosting.PostingType);
                this.validateLedgerDimension(inventTransPosting.OffsetLedgerDimension, inventTransPosting.PostingTypeOffset);
            }

            inventTransPosting.InventTransPostingType   = InventTransPostingType::Physical;

            inventTransPosting.IsPosted                 = movement.mustBeBookedPhysically();
            inventTransPosting.TransBeginTime           = InventCostUpdateGlobal::Instance().parmTransBeginTime();
            if (!InventTransPosting::existByNaturalKey(inventTransPosting))
            {
                this.persistInventTransPosting(inventTransPosting);
            }
        }

        if (postingFinancial && movement.createInventTransPosting())
        {
            if (movement.mustBeBookedBalanceSheet())
            {
                inventTransPosting.LedgerDimension          = this.getLedgerDimensionFromDefaultAccount(
                                                                    movement.accountBalanceSheet(),
                                                                    movement.defaultDimension());
                inventTransPosting.PostingType              = movement.postingBalanceSheet();

                this.validateLedgerDimension(inventTransPosting.LedgerDimension, inventTransPosting.PostingType);
            }

            if (movement.mustBeBookedOperations())
            {
                inventTransPosting.OffsetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                    movement.accountOperations(),
                                                                    movement.defaultDimension());
                inventTransPosting.PostingTypeOffset        = movement.postingOperations();

                this.validateLedgerDimension(inventTransPosting.OffsetLedgerDimension, inventTransPosting.PostingTypeOffset);
            }

            inventTransPosting.InventTransPostingType   = InventTransPostingType::Financial;

            inventTransPosting.IsPosted                 = movement.mustBeBookedFinancially();
            inventTransPosting.TransBeginTime           = InventCostUpdateGlobal::Instance().parmTransBeginTime();
            if (!InventTransPosting::existByNaturalKey(inventTransPosting))
            {
                this.persistInventTransPosting(inventTransPosting);
            }
        }

        if (postingPhysicalRevenue && movement.createInventTransPosting())
        {
            inventTransPosting.LedgerDimension          = this.getLedgerDimensionFromDefaultAccount(
                                                                movement.accountPhysicalRevenue(),
                                                                movement.defaultDimension());
            inventTransPosting.PostingType              = movement.postingPhysicalRevenue();

            inventTransPosting.OffsetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                movement.accountPhysicalRevenueOffset(),
                                                                movement.defaultDimension());
            inventTransPosting.PostingTypeOffset        = movement.postingPhysicalRevenueOffset();

            this.validateLedgerDimension(inventTransPosting.LedgerDimension, inventTransPosting.PostingType);
            this.validateLedgerDimension(inventTransPosting.OffsetLedgerDimension, inventTransPosting.PostingTypeOffset);

            inventTransPosting.InventTransPostingType   = InventTransPostingType::PhysicalRevenue;

            inventTransPosting.IsPosted                 = NoYes::Yes;
            inventTransPosting.TransBeginTime           = InventCostUpdateGlobal::Instance().parmTransBeginTime();
            if (!InventTransPosting::existByNaturalKey(inventTransPosting))
            {
                this.persistInventTransPosting(inventTransPosting);
            }
        }
        if (postingPhysicalCharge && movement.createInventTransPosting())
        {
            inventTransPosting.LedgerDimension          = this.getLedgerDimensionFromDefaultAccount(
                                                                movement.offsetAccountPhysical(),
                                                                movement.defaultDimension());
            inventTransPosting.PostingType              = movement.postingOffsetPhysical();

            inventTransPosting.OffsetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                movement.accountStockVariation(),
                                                                movement.defaultDimension());
            inventTransPosting.PostingTypeOffset        = movement.postingStockVariation();

            this.validateLedgerDimension(inventTransPosting.LedgerDimension, inventTransPosting.PostingType);
            this.validateLedgerDimension(inventTransPosting.OffsetLedgerDimension, inventTransPosting.PostingTypeOffset);

            inventTransPosting.InventTransPostingType   = InventTransPostingType::PhysicalCharge;

            inventTransPosting.IsPosted                 = movement.mustBeBookedPhysically();

            if (!InventTransPosting::existByNaturalKey(inventTransPosting))
            {
                this.persistInventTransPosting(inventTransPosting);
            }
        }

        if (postingFinancialCharge && movement.createInventTransPosting())
        {
            inventTransPosting.LedgerDimension          = this.getLedgerDimensionFromDefaultAccount(
                                                                movement.accountOperations(),
                                                                movement.defaultDimension());
            inventTransPosting.PostingType              = movement.postingOperations();

            inventTransPosting.OffsetLedgerDimension    = this.getLedgerDimensionFromDefaultAccount(
                                                                movement.accountStockVariation(),
                                                                movement.defaultDimension());
            inventTransPosting.PostingTypeOffset        = movement.postingStockVariation();

            this.validateLedgerDimension(inventTransPosting.LedgerDimension, inventTransPosting.PostingType);
            this.validateLedgerDimension(inventTransPosting.OffsetLedgerDimension, inventTransPosting.PostingTypeOffset);

            inventTransPosting.InventTransPostingType   = InventTransPostingType::FinancialCharge;

            inventTransPosting.IsPosted                 = NoYes::Yes;

            if (!InventTransPosting::existByNaturalKey(inventTransPosting))
            {
                this.persistInventTransPosting(inventTransPosting);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransReturn</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the return information for the <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">
    /// The <c>InventTrans</c> record selected to update return information.
    /// </param>
    /// <param name = "_movement">
    /// The <c>InventMovement</c> instatnce which is a sales object.
    /// </param>
    public void updateInventTransReturn(InventTrans _inventTrans, InventMovement _movement)
    {
        InventDimGroupSetup itemDimGroupSetup = InventDimGroupSetup::newItemId(_inventTrans.ItemId);
        InventDim           inventDim = _inventTrans.inventDim();
        InventDim           inventDimOrigin = _inventTrans.orig().inventDim();

        if (InventDim::isInventDimEqualFinancialDim(itemDimGroupSetup, inventDimOrigin, inventDim))
        {
            return;
        }

        if (_inventTrans.ReturnInventTransOrigin && _movement is InventMov_Sales)
        {
            InventDim       existsInventDim;
            InventDimParm   financialDimParm;
            InventDimParm   dimParm;
            InventDimParm   originDimParm;
  
            financialDimParm.initFromInventDimFieldList(itemDimGroupSetup.activeFinancialInventoryFields());
            dimParm.initFromInventDim(inventDim);
            originDimParm.initFromInventDim(inventDimOrigin);

            InventTrans returningInventTrans;
            boolean isCWItem = PdsGlobal::pdsIsCWItem(_inventTrans.ItemId);

            select firstonly forupdate InventDimId, ReturnInventTransOrigin from returningInventTrans
                where returningInventTrans.InventTransOrigin       == _inventTrans.ReturnInventTransOrigin
                   && returningInventTrans.ReturnInventTransOrigin == _inventTrans.InventTransOrigin
                   && returningInventTrans.inventDimId             != _inventTrans.inventDimId
                   && returningInventTrans.Qty                     == -_inventTrans.Qty
                   && (!isCWItem
                   ||  (isCWItem
                   &&   returningInventTrans.PdsCWQty              == -_inventTrans.PdsCWQty))
            #InventDimExistsJoin(returningInventTrans.InventDimId, existsInventDim, inventDimOrigin, InventDimParm::andParms(financialDimParm, originDimParm));

            if (returningInventTrans.inventDimId)
            {
                InventTrans newReturnInventTrans;

                select firstonly forupdate newReturnInventTrans
                    where newReturnInventTrans.InventTransOrigin == _inventTrans.returnInventTransOrigin
                       && !newReturnInventTrans.ReturnInventTransOrigin
                       && newReturnInventTrans.Qty               <= -_inventTrans.Qty
                       && (!isCWItem
                       ||  (isCWItem
                       &&   newReturnInventTrans.PdsCWQty        <= -_inventTrans.PdsCWQty))
                #InventDimExistsJoin(newReturnInventTrans.InventDimId, existsInventDim, inventDim, InventDimParm::andParms(financialDimParm, dimParm));

                if (newReturnInventTrans.RecId)
                {
                    ReturningInventTrans.ReturnInventTransOrigin = 0;
                    ReturningInventTrans.doUpdate();

                    if (isCWItem ? newReturnInventTrans.PdsCWQty < -_inventTrans.PdsCWQty : newReturnInventTrans.Qty < -_inventTrans.Qty)
                    {
                        InventSplitTrans splitTrans = new InventSplitTrans();
                        splitTrans.update(newReturnInventTrans, -_inventTrans.Qty, -_inventTrans.PdsCWQty);
                    }
                    
                    newReturnInventTrans.ReturnInventTransOrigin = _inventTrans.inventTransOrigin;
                    newReturnInventTrans.doUpdate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>persistInventTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Persists the inventory transaction posting table record to the database.
    /// </summary>
    /// <param name="_inventTransPosting">
    /// An inventory transaction posting table record that needs to be persisted.
    /// </param>
    protected void persistInventTransPosting(InventTransPosting _inventTransPosting)
    {
        _inventTransPosting.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveAgain</Name>
				<Source><![CDATA[
    protected void updateReserveAgain(
        InventDimId                 _dimId,
        InventQty                   _qtyReserv,
        InventTransOriginIdMarked   _inventTransOriginIdMarked,
        PdsCWInventQty              _cwQty = 0
        )
    {
        InventTrans inventTransIssue;

        PdsCWInventQty cwQty = _cwQty;

        if (_qtyReserv > 0)
        {
            while select forupdate inventTransIssue
                index StatusItemIdx
                where inventTransIssue.ItemId                      == movement.itemId()
                   && inventTransIssue.ValueOpen                   == InventTransOpen::Yes
                   && inventTransIssue.StatusReceipt               == StatusReceipt::None
                   && inventTransIssue.StatusIssue                 == StatusIssue::ReservOrdered
                   && inventTransIssue.InventDimId                 == _dimId
                   && inventTransIssue.InventTransOrigin           != movement.inventTransOriginId()
                   && ((inventTransIssue.InventTransOrigin              == _inventTransOriginIdMarked   && _inventTransOriginIdMarked != 0)     // Original transaction marked - so find related marked
                   ||  (inventTransIssue.MarkingRefInventTransOrigin    == 0                            && _inventTransOriginIdMarked == 0))    // Original transaction not marked - so find not marked
            {
                if (_qtyReserv < -inventTransIssue.Qty)
                {
                    inventTransIssue.updateSplit(-_qtyReserv, -cwQty);
                }

                this.updateReserveAgainTrans(inventTransIssue);

                _qtyReserv  += inventTransIssue.Qty;

                cwQty += inventTransIssue.PdsCWQty;

                if (_qtyReserv <= 0)
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveAgainTrans</Name>
				<Source><![CDATA[
    protected void updateReserveAgainTrans(InventTrans _inventTrans)
    {
        InventUpd_Reservation   tmpReservation;
        InventMovement          tmpMovement     = _inventTrans.inventMovement();

        InventDim               inventDimCriteria;
        InventDimParm           inventDimParm;

        PdsCWInventQty          cwQty = 0;

        inventDimCriteria = _inventTrans.inventDim();
        inventDimParm.setAllInventDim();

        cwQty = _inventTrans.PdsCWQty;

        tmpReservation = InventUpd_Reservation::newWithMarking(
                                                    tmpMovement,
                                                    inventDimCriteria,
                                                    inventDimParm,
                                                    _inventTrans.InventDimFixed,
                                                    _inventTrans.MarkingRefInventTransOrigin,
                                                    -_inventTrans.Qty,
                                                    true,
                                                    false,
                                                    -cwQty
                                                    );
        tmpReservation.updateNow();

        InventDimFixedClass::inventDimFixed2InventDimParm(_inventTrans.InventDimFixed,inventDimParm);
        tmpReservation = InventUpd_Reservation::newWithMarking(
                                                    tmpMovement,
                                                    inventDimCriteria,
                                                    inventDimParm,
                                                    _inventTrans.InventDimFixed,
                                                    _inventTrans.MarkingRefInventTransOrigin,
                                                    _inventTrans.Qty,
                                                    true,
                                                    false,
                                                    cwQty
                                                    );
        tmpReservation.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransDimIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Synchronizes the reservation transaction with new inventory dimensions.
    /// </summary>
    /// <param name="_inventTrans">
    ///    The <c>inventTrans</c> records.
    /// </param>
    /// <param name="_fromInventDim">
    ///    The original <c>InventDim</c> record.
    /// </param>
    /// <param name="_toInventDim">
    ///    The new <c>InventDim</c> record to which the transaction is synchronized.
    /// </param>
    /// <param name="_changeQty">
    ///    The specified quantity to synchronize.
    /// </param>
    /// <param name="_forceUpdate">
    ///    A Boolean value that indicates whether to update the <c>InventTrans</c> record.
    /// </param>
    /// <param name="_cwQty">
    /// The specified catch weight quantity which has to be synchronized.
    /// </param>
    /// <param name="_switchDimReservation">
    ///  Boolean value that indicates whether to switch reservation for the <c>InventTrans</c> record, optional.
    /// </param>
    /// <returns>
    /// true if the quantity which was successfully synchronized to the specified new dimensions;
    /// otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The records must exist in the database.
    /// </remarks>
    public container updateTransDimIssue(
        InventTrans     _inventTrans,
        InventDim       _fromInventDim,
        InventDim       _toInventDim,
        InventQty       _changeQty,
        boolean         _forceUpdate = false,
        PdsCWInventQty  _cwQty = 0,
        boolean         _switchDimReservation = true
        )
    {
        InventOnHandQty inventOnHandQty;
        InventQty       qtyOK;
        InventQty       availQty;
        boolean         reserveAgain;
        boolean         checkReserveOnOrderedQty;
        InventTrans     inventTransSplit;
        InventQty       splitQty;

        PdsCWInventQty  cwSplitQty;
        InventQty       tmpQty;
        PdsCWInventQty  cwTmpQty;
        PdsCWInventQty  cwQtyOK;
        PdsCWInventQty  cwReservedQty;
        boolean         useDispStatus;
        boolean         dispStatusAvail;

        void updateTotalMovementReleasedReservationQty(InventTrans inventTrans, InventMovement movementOrigin)
        {
            InventQty   totalReleasedReservationQty;

            // Add to the total quantity which cannot be reserved due to dimension change on the movement
            if (inventTrans.StatusIssue == StatusIssue::OnOrder)
            {
                // increase overall released reservation quantity for current movement.
                totalReleasedReservationQty = movementOrigin.parmReleasedReservationQty() + abs(inventTrans.Qty);

                // set released reservation quantity for current movement.
                movementOrigin.parmReleasedReservationQty(totalReleasedReservationQty);
            }
        }

        void tryToReserveAgainstCatchWeightAvailableOnhand(
            InventTrans     inventTrans,
            InventMovement  movementOrigin,
            InventOnHandQty inventOnhandQtyOrigin,
            boolean         allowNegativePhysicalCheck)
        {
            PdsCWAvailReservation   availQtyForReservation;
            InventQty               availPhysicalReservedQty = 0;
            RecId                   inventTransRecId;
            boolean                 canReserveAgainstReserveOrdered = true;
            
            if (inventOnhandQtyOrigin.PdsCWAvailReservation(false) > 0)
            {
                availQtyForReservation = inventOnhandQtyOrigin.PdsCWAvailReservation(false);

                if (-inventTrans.PdsCWQty > availQtyForReservation)
                {
                    inventTransRecId = inventTrans.RecId;

                    inventTrans.updateSplit(PdsCatchWeight::inventQty(inventTrans.ItemId,
                                                                      -availQtyForReservation,
                                                                      '',
                                                                      PdsCatchWeightItem::find(inventTrans.ItemId).PdsCWUnitId), -availQtyForReservation);
                }
                else
                {
                    canReserveAgainstReserveOrdered = false;
                }

                movementOrigin.transIdSum().setInventTransStatus(inventTrans, StatusReceipt::None, StatusIssue::ReservPhysical);
                inventTrans.update();

                availPhysicalReservedQty = inventTrans.Qty;
                cwReservedQty = inventTrans.PdsCWQty;

                inventOnHandQty.addReservationCheck(allowNegativePhysicalCheck);
            }

            if (allowReserveOrdered && canReserveAgainstReserveOrdered && inventOnHandQty.PdsCWAvailReservation(true) + cwReservedQty > 0)
            {
                if (inventTransRecId)
                {
                    inventTrans = InventTrans::findRecId(inventTransRecId, true);
                }

                availQtyForReservation = inventOnHandQty.PdsCWAvailReservation(true) + cwReservedQty;

                if (-inventTrans.PdsCWQty > availQtyForReservation)
                {
                    inventTrans.updateSplit(PdsCatchWeight::inventQty(inventTrans.ItemId, -availQtyForReservation + cwReservedQty,
                                                                    '',
                                                                    PdsCatchWeightItem::find(inventTrans.ItemId).PdsCWUnitId), 
                                                                    -availQtyForReservation + cwReservedQty);
                }

                movementOrigin.transIdSum().setInventTransStatus(inventTrans, StatusReceipt::None, StatusIssue::ReservOrdered);
                inventTrans.update();
                inventOnHandQty.addReservationCheck(allowNegativePhysicalCheck);
            }
        }

        void tryToReserveAgainstAvailableOnhand(
            InventTrans     inventTrans,
            InventMovement  movementOrigin,
            InventOnHandQty inventOnhandQtyOrigin,
            boolean         allowNegativePhysicalCheck, 
            boolean         _useCWAvailableQuantities)
        {
            
            if (_useCWAvailableQuantities)
            {
                skipReserveAgainstAvailableOnhandForCWItem = true;
            }
            else
            {
                InventQty   availPhysicalReservedQty = 0;
                InventQty   availQtyForReservation;
                RecId       inventTransRecId;
                boolean     canReserveAgainstReserveOrdered = true;

                if (inventOnhandQtyOrigin.availReservation(false) > 0)
                {
                    availQtyForReservation = inventOnhandQtyOrigin.availReservation(false);

                    if (-inventTrans.Qty > availQtyForReservation)
                    {
                        inventTransRecId = inventTrans.RecId;

                        inventTrans.updateSplit(-availQtyForReservation, -inventOnHandQty.pdsCWAvailReservation(false));
                    }
                    else
                    {
                        canReserveAgainstReserveOrdered = false;
                    }

                    movementOrigin.transIdSum().setInventTransStatus(inventTrans, StatusReceipt::None, StatusIssue::ReservPhysical);
                    inventTrans.update();

                    availPhysicalReservedQty = inventTrans.Qty;
                    cwReservedQty = _inventTrans.PdsCWQty;

                    inventOnHandQty.addReservationCheck(allowNegativePhysicalCheck);
                }

                if (allowReserveOrdered && canReserveAgainstReserveOrdered && inventOnHandQty.availReservation(true) + availPhysicalReservedQty > 0)
                {
                    if (inventTransRecId)
                    {
                        inventTrans = InventTrans::findRecId(inventTransRecId, true);
                    }

                    availQtyForReservation = inventOnHandQty.availReservation(true) + availPhysicalReservedQty;

                    if (-inventTrans.Qty > availQtyForReservation)
                    {
                        inventTrans.updateSplit(-availQtyForReservation, -inventOnHandQty.pdsCWAvailReservation(true) + cwReservedQty);
                    }

                    movementOrigin.transIdSum().setInventTransStatus(inventTrans, StatusReceipt::None, StatusIssue::ReservOrdered);
                    inventTrans.update();
                    inventOnHandQty.addReservationCheck(allowNegativePhysicalCheck);
                }

                if (inventTransRecId)
                {
                    _inventTrans = InventTrans::findRecId(inventTransRecId, true);
                }
            }
        }

        if (_inventTrans.InventDimId != _toInventDim.InventDimId)
        {
            // For updating work inventTrans, need to call special WHS method
            // Return to skip all of this base method
            if (this.movement().transType() == InventTransType::WHSWork)
            {
                return this.updateIssueWorkTransactionDimensions(_inventTrans, _fromInventDim, _toInventDim, _changeQty, _cwQty);
            }

            if (!this.checkInventDimChangeOnInventTransUpdate(_fromInventDim, _toInventDim))
            {
                throw error("@SYS18447");
            }

            if (_inventTrans.Qty < _changeQty)
            {
                _inventTrans.updateSplit(_changeQty, _cwQty);
            }

            boolean isItemWHS = this.movement().isItemWHSEnabled();
            boolean isItemWHSAndCW = (isItemWHS && this.movement().pdsCWItem());

            if (_inventTrans.StatusIssue == StatusIssue::ReservPhysical
            ||  _inventTrans.StatusIssue == StatusIssue::ReservOrdered)
            {
                if (InventDim::mustCheckDimChange(movement.inventDimGroupSetup(), _fromInventDim, _toInventDim)
                    && !(isItemWHS && this.whsCanUpdateInventDimWithoutReservationChange(movement.itemId(), _fromInventDim, _toInventDim)))
                {
                    inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement, _toInventDim);

                    useDispStatus = #PdsShelfEnabled
                        && _toInventDim.InventBatchId
                        && hasFieldAccess(
                                tableNum(InventBatch),
                                fieldNum(InventBatch,PdsDispositionCode),
                                AccessType::View);

                    dispStatusAvail = useDispStatus
                        && InventBatch::find(
                            _toInventDim.InventBatchId,
                            movement.itemId()).pdsDispositionStatus() != PdsStatus::Unavailable;

                    // dimension switch for whs+cw items is not supported
                    boolean tryToSwitchDimensions = isItemWHSAndCW ? false : _switchDimReservation;

                    // dimension switch for warehouse item with allowing negative physical is skipped
                    if (tryToSwitchDimensions &&
                        allowNegativePhysical &&
                        isItemWHS)
                    {
                        tryToSwitchDimensions = false;
                    }

                    // Skip dimension switch for warehouse item which status issue is reserved physical
                    // Becasue this item has done reservation on location level previously
                    // But trying to pick registration with the specific dimension (wms location/batch/serial number) currently
                    InventUpdNeedSwitchDimForWHSItemContext context = InventUpdNeedSwitchDimForWHSItemContext::current();

                    boolean inventUpdNeedSwitchDimForWHSItemFlightEnabled = InventUpdNeedSwitchDimForWHSItemFlight::instance().isEnabled();

                    if ( tryToSwitchDimensions
                      && isItemWHS
                      && _inventTrans.StatusIssue == StatusIssue::ReservPhysical
                      && context != null && context.parmNeedCheckSwitchDimForWHSItemFromPicking()
                      && inventUpdNeedSwitchDimForWHSItemFlightEnabled
                      && inventOnHandQty.availReservation(false) <  -_inventTrans.Qty) // The warehouse item is not enough onhand for reversation
                    {
                        tryToSwitchDimensions = this.isSwitchDimForWhsItemNeeded(this.movement().inventTable(), _fromInventDim, _toInventDim);
                    }

                    // try to make a complete dimension id switch
                    if (tryToSwitchDimensions &&
                        ((_inventTrans.StatusIssue              ==  StatusIssue::ReservPhysical   &&
                         inventOnHandQty.availReservation(false) <  -_inventTrans.Qty)           ||
                        (_inventTrans.StatusIssue              ==  StatusIssue::ReservOrdered    &&
                         inventOnHandQty.availReservation(true)  <  -_inventTrans.Qty)
                        || (useDispStatus && !dispStatusAvail))
                        )
                    {
                        if ((_inventTrans.StatusIssue        ==  StatusIssue::ReservPhysical   &&
                             inventOnHandQty.reservPhysical()  >= -_inventTrans.Qty)           ||
                            (_inventTrans.StatusIssue        ==  StatusIssue::ReservOrdered    &&
                             inventOnHandQty.reservOrdered()   >= -_inventTrans.Qty)
                            || (useDispStatus && !dispStatusAvail)
                            )
                        {
                            // make switch between reservations
                            splitQty = _inventTrans.Qty;
                            cwSplitQty = _inventTrans.PdsCWQty;

                            if (InventUpd_ChangeDimension::updateTransSwitchDim(_inventTrans, _fromInventDim, _toInventDim))
                            {
                                return [splitQty, cwSplitQty];
                            }
                        }
                        else
                        {
                            if (_inventTrans.StatusIssue ==  StatusIssue::ReservPhysical)
                            {
                                splitQty = inventOnHandQty.reservPhysical();
                                cwSplitQty =inventOnHandQty.pdsCWReservPhysical();
                            }
                            else // inventTrans.StatusIssue always equals to StatusIssue::ReservOrdered
                            {
                                splitQty = inventOnHandQty.reservOrdered();
                                cwSplitQty = inventOnHandQty.pdsCWReservOrdered();
                            }

                            if (splitQty)
                            {
                                inventTransSplit = _inventTrans.updateSplit(-splitQty, -cwSplitQty);

                                // Can make a complete dimension id switch with splitQty and cwSplitQty.
                                [tmpQty,cwTmpQty] = this.updateTransDimIssue(_inventTrans, _fromInventDim, _toInventDim, _inventTrans.Qty, _forceUpdate, _inventTrans.PdsCWQty, true);
                                qtyOK += tmpQty;
                                cwQtyOK += cwTmpQty;

                                // Can't make a dimension id switch with the remain.
                                [tmpQty,cwTmpQty] = this.updateTransDimIssue(inventTransSplit, _fromInventDim, _toInventDim, inventTransSplit.Qty, _forceUpdate , _inventTrans.PdsCWQty, false);
                                qtyOK += tmpQty;
                                cwQtyOK += cwTmpQty;

                                return [qtyOK,cwQtyOK];
                            }
                        }
                    }//end dimension switch

                    if (_inventTrans.StatusIssue == StatusIssue::ReservPhysical)
                    {
                        checkReserveOnOrderedQty = false;
                    }
                    else // inventTrans.StatusIssue always equals to StatusIssue::ReservOrdered
                    {
                        checkReserveOnOrderedQty = allowReserveOrdered;
                    }

                    // Is quantity available on new dimensions
                    if (! allowReserveReduction)
                    {
                        if (!inventOnHandQty.checkReservation(_inventTrans.Qty, allowNegativePhysical, checkReserveOnOrderedQty, 0, _inventTrans.PdsCWQty))
                        {
                            throw error("@SYS18447");
                        }

                        inventOnHandQty.addReservationCheck(allowNegativePhysical);
                    }
                    else
                    {
                        boolean isAvailQtyForReservationBelowTransQty;
                        if (isItemWHSAndCW)
                        {
                            isAvailQtyForReservationBelowTransQty = (inventOnHandQty.pdsCWAvailReservation(checkReserveOnOrderedQty) < -_inventTrans.PdsCWQty);
                        }
                        else
                        {
                            isAvailQtyForReservationBelowTransQty = (inventOnHandQty.availReservation(checkReserveOnOrderedQty) < -_inventTrans.Qty);
                        }

                        if (isAvailQtyForReservationBelowTransQty
                        || (useDispStatus && !dispStatusAvail))
                        {
                            movement.transIdSum().setInventTransStatus(_inventTrans,StatusReceipt::None,StatusIssue::OnOrder);

                            // The transaction status has been changed to StatusIssue::OnOrder.
                            // This code must try to reserve against current transaction one more time.
                            reserveAgain = useDispStatus ? dispStatusAvail : true;
                        }
                    }

                    // give quantity to another issue
                    if (_inventTrans.orig().StatusIssue == StatusIssue::ReservPhysical)
                    {
                        boolean updateDimReservePhysicalToAnotherIssue = true;

                        // The transaction status has been changed to OnOrder status
                        // Becasue the warehouse item has been reserved physical already, there is no need to reserve physical to another issue
                        if ( !tryToSwitchDimensions
                          && _inventTrans.StatusIssue == StatusIssue::OnOrder
                          && context != null && context.parmNeedCheckSwitchDimForWHSItemFromPicking()
                          && inventUpdNeedSwitchDimForWHSItemFlightEnabled)
                        {
                            // orig reserved physical has enough physical
                            updateDimReservePhysicalToAnotherIssue = false;
                        }

                        if (updateDimReservePhysicalToAnotherIssue)
                        {
                            this.updateDimReservePhysical(InventDim::find(_inventTrans.InventDimId), -_inventTrans.Qty, 0, -_inventTrans.PdsCWQty);
                        }
                    }
                }
            }
            else if (_inventTrans.StatusIssue == StatusIssue::OnOrder
                     && !_inventTrans.MarkingRefInventTransOrigin
                     && ((!movement.pdsCWItem() && _inventTrans.Qty) || _inventTrans.PdsCWQty)
                     && movement.canAutoReserveOnorderChangeInventDim())
            {
                reserveAgain = true;
            }

            // update transaction with the new dimensions
            _inventTrans.InventDimId = _toInventDim.InventDimId;
            InventUpdate::updateTransDimTransferReceipt(movement, _inventTrans, _toInventDim);
            _inventTrans.update();

            qtyOK   = _inventTrans.Qty;
            cwQtyOK = _inventTrans.PdsCWQty;

            //  if reserveAgain equals to true than inventTrans.StatusIssue always equals to StatusIssue::OnOrder
            if (reserveAgain)
            {
                inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement, _toInventDim);
                    
                inventOnHandQty.parmAdvancedCriteria(InventReservationCriteriaBuilder::newMovement(movement).buildCriteria());
                
                tryToReserveAgainstAvailableOnhand(_inventTrans, movement, inventOnHandQty, allowNegativePhysical, isItemWHSAndCW);

                updateTotalMovementReleasedReservationQty(_inventTrans, movement);
            }
            else
            if (_inventTrans.StatusIssue == StatusIssue::ReservOrdered)
            {
                inventOnHandQty = InventOnHandQty::newEstimatedUpdate(movement, _toInventDim);

                inventOnHandQty.parmAdvancedCriteria(InventReservationCriteriaBuilder::newMovement(movement).buildCriteria());
                
                if (inventOnHandQty.availReservation(false) > 0)
                {
                    // for a wmsitem, on a non-whs enabled warehouse or license plate control is not enabled from location profile, the license plate should be blank and physical.
                    // so to avoid conflict with other on-hand checks added we need to set this.
                    if (_toInventDim.wMSLocationId
                        && movement.isItemWHSEnabled()
                        && (!_toInventDim.inventLocation().WHSEnabled || !_toInventDim.wmsLocation().whsLocationProfile().LPControlled)
                        && InventUpdReservationWHSMarkLicensePlateFlagFlight::instance().isEnabled())
                    {
                        inventOnHandQty.parmInventDimParm().LicensePlateFlag = NoYes::Yes;
                    }
                    
                    inventOnHandQty.addReservationCheck(allowNegativePhysical);

                    availQty = inventOnHandQty.availReservation(false);

                    if (-_inventTrans.Qty > availQty)
                    {
                        _inventTrans.updateSplit(-availQty, -inventOnHandQty.pdsCWAvailReservation(false));
                    }

                    movement.transIdSum().setInventTransStatus(_inventTrans, StatusReceipt::None, StatusIssue::ReservPhysical);
                    _inventTrans.update();
                }
            }

            _inventTrans.updateSumUp();

            // If item is catch weight enabled we do not need to validate load line consistency for weight only transaction.
            if (isItemWHS && (!movement.pdsCWItem() || _inventTrans.PdsCWQty || _cwQty))
            {
                movement.checkWHSLoadLineInventTransConsistency();
            }
        }
        else
        {
            if (_forceUpdate)
            {
                _inventTrans.update();
            }

            qtyOK   = max(_inventTrans.Qty, _changeQty);
            cwQtyOK = max(_inventTrans.PdsCWQty, _cwQty);
        }
        return [qtyOK, cwQtyOK];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransDimReceipt</Name>
				<Source><![CDATA[
    public container updateTransDimReceipt(
        InventTrans     _inventTrans,
        InventDim       _fromInventDim, // Must have RecId
        InventDim       _toInventDim,
        InventQty       _changeQty,
        boolean         _forceUpdate = false,
        boolean         _physicalUpdate = false,
        PdsCWInventQty  _cwQty=0
        )
    {
        InventQty       qtyOK;

        PdsCWInventQty  cwQtyOK;
        InventBlockingInventStatusSync  inventBlockingInventStatusSync;

        if (_inventTrans.InventDimId != _toInventDim.InventDimId)
        {
            inventBlockingInventStatusSync = InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, _changeQty, _cwQty, _fromInventDim, _toInventDim);
            inventBlockingInventStatusSync.preSync();

            if (_inventTrans.Qty > _changeQty)
            {
                _inventTrans.updateSplit(_changeQty, _cwQty);
            }
            _inventTrans.InventDimId = _toInventDim.InventDimId;
            this.updateInventTransReturn(_inventTrans, movement);

            this.writeInventTrans(_inventTrans, _inventTrans.orig(), _physicalUpdate);
                      
            qtyOK = _inventTrans.Qty;
            cwQtyOK = _inventTrans.PdsCWQty;

            _inventTrans.updateSumUp();

            inventBlockingInventStatusSync.postSync();
        }
        else
        {
            if (_forceUpdate)
            {
                this.writeInventTrans(_inventTrans, _inventTrans.orig(), _physicalUpdate);
            }

            qtyOK = min(_inventTrans.Qty, _changeQty);
            cwQtyOK = _cwQty;
            cwQtyOK = min(_inventTrans.PdsCWQty, cwQtyOK);
        }

        return [qtyOK,cwQtyOK];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountLedger(CostAmount _costAmount = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updCostAmountPhysical</Name>
				<Source><![CDATA[
    public CostAmount updCostAmountPhysical(CostAmount _costAmount = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updOperationsAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updOperationsAmountLedger(CostAmount _costAmount = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updPhysicalAmountLedger(CostAmount _costAmount = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updPhysicalRevenueAmountLedger</Name>
				<Source><![CDATA[
    public CostAmount updPhysicalRevenueAmountLedger(AmountMSTPhysicalRevenue _amountMST = 0)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsForceReserveAgain</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserve the inventory again.
    /// </summary>
    /// <param name="_fromInventDim">
    /// The original <c>InventDim</c> record.
    /// </param>
    /// <param name="_toInventDim">
    /// The new <c>InventDim</c> record.
    /// </param>
    /// <param name="_storageRecId">
    /// The storage dimension Rec Id.
    /// </param>
    /// <returns>
    /// true if inventory can be reserved again, otherwise false.
    /// </returns>
    boolean whsForceReserveAgain(InventDim      _fromInventDim,  // Must have RecId
                                 InventDim      _toInventDim,    // Must have RecId
                                 RefRecId       _storageRecId)
    {
        List                                hierarchyList;
        WHSReservationHierarchyElementData  hierarchyElementData;
        ListEnumerator                      le;
        FieldId                             fieldId;
        boolean                             ret = false;

        if (EcoResStorageDimensionGroup::find(_storageRecId).IsWarehouseWHSEnabled)
        {
            hierarchyList = WHSReservationHierarchyProvider::construct()
                                .getDimListAllFromInventTable(movement.inventTable(), WHSReservationHierarchySortOrder::BottomUp);
            le = hierarchyList.getEnumerator();

            // Check each dimension combination.  If a mismatch (other than extra blank
            // rows in the from inventdim), force a reserve again
            while (le.moveNext())
            {
                hierarchyElementData = le.current();

                fieldId = hierarchyElementData.parmDimensionFieldId();
                if (_fromInventDim.(fieldId)  &&
                    (_fromInventDim.(fieldId) != _toInventDim.(fieldId)))
                {
                    ret = true;
                    break;
                }
            }
        }
        else
        {
            ret = true;
        }

        if (ret)
        {
            ret = this.projExecuteReserveAgain();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsUpdateDimReserveChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Special check for WHS due to the reservation hierarchy.
    /// </summary>
    /// <param name="_toInventDim">
    /// The new <c>InventDim</c> record.
    /// </param>
    /// <param name="_fromInventDim">
    /// The original <c>InventDim</c> records.
    /// </param>
    /// <param name="_qtyReserv">
    /// The reserved quantity.
    /// </param>
    /// <param name="_reserveAsPhysical">
    /// True if reserve physical is set, otherwise false.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The marked transaction.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity.
    /// </param>
    /// <returns>
    /// A container with the reserved and catch weight quantities.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Cannot change dimensions because ordered reserved inventory already exists.
    /// </exception>
    protected container whsUpdateDimReserveChange(
        InventDim           _toInventDim,
        InventDim           _fromInventDim,
        InventQty           _qtyReserv,
        boolean             _reserveAsPhysical,
        InventTransOriginId _markingRefInventTransOrigin,
        PdsCWInventQty      _cwQty)
    {
        InventTrans                         inventTransIssue;
        InventDim                           inventDim;
        InventQty                           qtyReserv   = _qtyReserv;
        PdsCWInventQty                      cwQtyReserv = _cwQty;
        InventDim                           tmpInventDimCriteria;
        InventDim                           inventDimIssue;
        InventMovement                      inventMovementIssue;

        boolean dimHasChanged = this.validateDimensionsChange(_toInventDim, _fromInventDim, _qtyReserv, _markingRefInventTransOrigin, _cwQty);
        
        Map crossDockPlannedPerDemand = new Map(Types::Int64, Types::Class); // InventTransOriginRecId -> WHSCrossDockPlanned
        Map crossDockQtyPerDemand = new Map(Types::Int64, Types::Real); // InventTransOriginRecId -> Real        

        InventQty qtyReservLeftForCrossDocking = _qtyReserv;

        if (((_markingRefInventTransOrigin &&  dimHasChanged) ||  _reserveAsPhysical)
            &&  !WHSInvent::isTransTypeWHSMovement(movement.transType()))
        {
            tmpInventDimCriteria = _markingRefInventTransOrigin && dimHasChanged ? _fromInventDim : _toInventDim;

            if (_markingRefInventTransOrigin || !movement.isReturnScrap())
            {
                inventTransIssue = this.whsSelectInventTransIssue(_markingRefInventTransOrigin, tmpInventDimCriteria);
            }

            WHSCrossDockingPlanned crossDockPlanned;   
            boolean validForCrossDock;
            InventHandlingQty crossDockQty;

            while (inventTransIssue)
            {
                if (this.mustSuppressPhysicalReregistration(_reserveAsPhysical, inventTransIssue))
                {
                    next inventTransIssue;
                    continue;
                }

                if (movement.pdsCWItem())
                {
                    if (cwQtyReserv < -inventTransIssue.PdsCWQty)
                    {
                        InventHandlingQty splitWeight;

                        if (WHSUseSplitQtyOnCWTransactionSplitForWHSItemOnNonWHSWarehouseFlight::instance().isEnabled() 
                            && !inventTransIssue.inventDim().inventLocation().WHSEnabled)
                        {
                            // Reserve full weight in case of non whs warehouse
                            splitWeight = qtyReserv;
                        }
                        else
                        {
                            // Calculate min weight for the cwQty because we should always reserve at min weight.
                            splitWeight = WHSInvent::defaultCatchWeightReserveQuantity(inventTransIssue.ItemId, cwQtyReserv);
                        }

                        inventTransIssue.updateSplit(-splitWeight, -cwQtyReserv);
                    }
                }
                else
                {
                    if (!crossDockPlanned && this.mustVerifyPlannedCrossDocking(inventTransIssue, _reserveAsPhysical))
                    {                        
                        crossDockPlanned = WHSCrossDockingPlanned::newFromCommon(inventTransIssue);
                    }

                    if (crossDockPlanned)
                    {
                        validForCrossDock = crossDockPlanned.verifyPlannedCrossDocking(inventTransIssue, _toInventDim, qtyReserv);
                    }

                    if (qtyReserv < -inventTransIssue.Qty)
                    {
                        inventTransIssue.updateSplit(-qtyReserv, -cwQtyReserv);
                    }
                }

                if (_reserveAsPhysical)
                {
                    inventTransIssue.StatusIssue = StatusIssue::ReservPhysical;

                    InventDim inventDimAboveLocation;
                    inventDimAboveLocation.data(_toInventDim);
                    inventDimAboveLocation.clearLocationAndBelowDim(inventTransIssue.ItemId);
                    inventDimAboveLocation = InventDim::findOrCreate(inventDimAboveLocation);

                    this.whsSynchronizeIssueDimPhysical(inventTransIssue,
                                                    _toInventDim,
                                                    inventDimAboveLocation,
                                                    WHSInventEnabled::exist(inventTransIssue.ItemId) && _toInventDim.inventLocation().whsEnabled);
                }
                else if (inventTransIssue.MarkingRefInventTransOrigin && dimHasChanged)
                {
                    if (InventTransOrigin::find(inventTransIssue.MarkingRefInventTransOrigin).isTransfer())
                    {
                        inventDimIssue = inventTransIssue.inventMovement().getInventDimForIssueTransFromReceipt(_toInventDim, _toInventDim);
                        inventTransIssue.inventDimId = inventDimIssue.inventDimId;
                    }
					else
                    {
						inventTransIssue.InventDimId = _toInventDim.InventDimId;
                    }
                    InventUpdate::updateTransDimTransferReceipt(inventMovementIssue, inventTransIssue, _toInventDim);
                }

                inventTransIssue.update();

                if (validForCrossDock)
                {
                    // Issue quantity will be negative but we want possitive qty to create cross docking work.
                    crossDockQty -= inventTransIssue.Qty;
                }

                qtyReserv  += inventTransIssue.Qty;

                cwQtyReserv += inventTransIssue.PdsCWQty;

                inventTransIssue.updateSumUp();

                if (!qtyReserv)
                {
                    break;
                }

                next inventTransIssue;
            }

            if (crossDockQty)
            {
                // Use existing instance of the cross docking class because it has been built on the inventTransIssue transaction in the loop.
                crossDockPlanned.parmInventDim(_toInventDim);
                crossDockPlanned.createCrossDockingWork(crossDockQty, movement.transType());
            }
        }

        return [qtyReserv, cwQtyReserv];
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsSelectInventTransIssue</Name>
				<Source><![CDATA[
    protected InventTrans whsSelectInventTransIssue(
        InventTransOriginId _markingRefInventTransOrigin,
        InventDim           _inventDimCriteria)
    {
        InventTrans inventTransIssue;     

        SysDaQueryObject queryObject = WHSInventUpdateDimReserveChangeSysDaBuilder::buildQueryObjectForMarkedIssueTrans(
            inventTransIssue,
            movement.itemId(),
            movement.inventTransOriginId(),
            _markingRefInventTransOrigin,
            _inventDimCriteria);

        new SysDaFindStatement().find(new SysDaFindObject(queryObject));
        return inventTransIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSuppressPhysicalReregistration</Name>
				<Source><![CDATA[
    protected boolean mustSuppressPhysicalReregistration(boolean _reserveAsPhysical, InventTrans _inventTrans)
    {
        return _reserveAsPhysical && 
                whsSuppressPhysicalRereservationOnNonWorkEnabledIssues &&
                this.whsMustSuppressPhysicalReregistrationOnInventTransType(_inventTrans.inventTransOrigin().ReferenceCategory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDimensionsChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Special check for dimension change for WHS item.
    /// </summary>
    /// <param name="_toInventDim">
    /// The new <c>InventDim</c> record.
    /// </param>
    /// <param name="_fromInventDim">
    /// The original <c>InventDim</c> records.
    /// </param>
    /// <param name="_qtyReserv">
    /// The reserved quantity.
    /// </param>
    /// <param name="_markingRefInventTransOrigin">
    /// The marked transaction.
    /// </param>
    /// <param name="_cwQty">
    /// The catch weight quantity.
    /// </param>
    /// <returns>
    /// true if dimension change is valid otherwise false.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Cannot change dimensions because ordered reserved inventory already exists.
    /// </exception>
    protected boolean validateDimensionsChange(
        InventDim           _toInventDim,
        InventDim           _fromInventDim,
        InventQty           _qtyReserv,
        InventTransOriginId _markingRefInventTransOrigin,
        PdsCWInventQty      _cwQty)
    {
        InventTrans                         inventTransIssue;
        boolean                             dimHasChanged;
        InventDim                           loopInventDimFrom;

        boolean mustDoAutoLossProfit = movement.mustDoAutoLossProfitEstimate();

        // If Negative Physical allowed, only check for dimension changes on project orders with no solidified movement.
        if ((!movement.pdsCWItem() ? _qtyReserv : _cwQty) && (!allowNegativePhysical || mustDoAutoLossProfit))
        {
            // Loop through the old inventory dimensions, checking to see if the dimension is different
            // in the new dimension.
            // Note that if the old dimension was blank and the new dimension was filled in, this has
            // no effect on ordered reserved inventory as the dimension just became "more specific".
            List hierarchyList = WHSReservationHierarchyProvider::construct()
                                    .getDimListAllFromInventTable(movement.inventTable(), WHSReservationHierarchySortOrder::BottomUp);
            ListEnumerator le = hierarchyList.getEnumerator();

            loopInventDimFrom.initFromInventDim(_fromInventDim, InventDim::dimProductDimensionEnabledFieldList());
            
            while (le.moveNext())
            {
                WHSReservationHierarchyElementData hierarchyElementData = le.current();

                FieldId dimFieldId = hierarchyElementData.parmDimensionFieldId();
                loopInventDimFrom.(dimFieldId) = _fromInventDim.(dimFieldId);

                dimHasChanged = dimHasChanged || (_fromInventDim.(dimFieldId) && _fromInventDim.(dimFieldId) != _toInventDim.(dimFieldId));

                if (dimHasChanged && !allowNegativePhysical)
                {
                    loopInventDimFrom = InventDim::findOrCreate(loopInventDimFrom);

                    // Check to see if any ordered reserved transactions at this level in the hierarchy
                    select firstonly RecId, MarkingRefInventTransOrigin from inventTransIssue
                        where inventTransIssue.ItemId                       == movement.itemId()
                            && inventTransIssue.ValueOpen                   == InventTransOpen::Yes
                            && inventTransIssue.StatusReceipt               == StatusReceipt::None
                            && inventTransIssue.StatusIssue                 == StatusIssue::ReservOrdered
                            && inventTransIssue.InventDimId                 == loopInventDimFrom.InventDimId
                            && inventTransIssue.InventTransOrigin           != movement.inventTransOriginId()
                            && ((inventTransIssue.InventTransOrigin           == _markingRefInventTransOrigin &&  inventTransIssue.MarkingRefInventTransOrigin == movement.inventTransOriginId())
                             || (!inventTransIssue.MarkingRefInventTransOrigin &&  !_markingRefInventTransOrigin));

                    if (inventTransIssue.RecId != 0)
                    {
                        if (inventTransIssue.MarkingRefInventTransOrigin && !WHSInvent::checkOriginDimChange(InventTrans::findRecId(inventTransIssue.RecId), _toInventDim))
                        {
                            throw error("@SYS54456");
                        }

                        // Check to make sure there is enough inventory despite the dim switch
                        InventHandlingQty qtyToCheck = movement.pdsCWItem() ? _cwQty : _qtyReserv;
                        
                        if (WHSInventOnHand::getOrderedAvailHandlingQty(movement.itemId(), loopInventDimFrom, true, false) - qtyToCheck < 0)
                        {
                            throw error("@WAX4094");
                        }
                    }
                }
                // For orders with an auto loss/profit issue transaction, once a changed dimension is found, stop looping over dimensions.
                else if (dimHasChanged && mustDoAutoLossProfit)
                {
                    break;
                }
            }
        }

        return dimHasChanged;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsMustSuppressPhysicalReregistrationOnInventTransType</Name>
				<Source><![CDATA[
    private boolean whsMustSuppressPhysicalReregistrationOnInventTransType(InventTransType _inventTransType)
    {
        return !WhsInvent::canInventTransTypeHaveWork(_inventTransType) && _inventTransType != InventTransType::Blocking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustVerifyPlannedCrossDocking</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if creation and verification of planned cross dock can be done.
    /// </summary>
    /// <param name = "_inventTransIssue">The inventory transaction record.</param>
    /// <param name = "_reserveAsPhysical">true if reserve physical is set; otherwise false.</param>
    /// <returns>true if creation and verification of planned cross dock can be done; otherwise false.</returns>
    protected boolean mustVerifyPlannedCrossDocking(
        InventTrans _inventTransIssue,
        boolean     _reserveAsPhysical)
    {
        return _inventTransIssue.MarkingRefInventTransOrigin && _reserveAsPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsUpdateDimReservePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handle order reserved inventory for WHS items
    /// </summary>
    /// <param name="_inventDim">
    /// The inventory dimensions.
    /// </param>
    /// <param name="_qtyReserv">
    /// The reserved quantity.
    /// </param>
    /// <param name="_inventRefTransId">
    /// The marked transaction, if applicable.
    /// </param>
    /// <returns>
    /// The updated reserved quantity.
    /// </returns>
    [SysObsolete('Method is obsoleted to support catch weight items. Please file an extensibility request if access is required.', false, 30\9\2019)]
    protected InventQty whsUpdateDimReservePhysical(
        InventDim           _inventDim,
        InventQty           _qtyReserv,
        InventTransOriginId _inventRefTransId = 0)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), movement.itemid());

        return this.physicallyReserveReserveOrderedQuantities(_inventDim, _qtyReserv, 0, _inventRefTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservePhysicalReserveOrderedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves physical the reserved ordered quantities.
    /// </summary>
    /// <param name="_inventDim">
    /// The inventory dimensions.
    /// </param>
    /// <param name="_qtyReserv">
    /// A quantity to reserve.
    /// </param>
    /// <param name="_cwQtyReserv">
    /// A catch weight quantity to reserve.
    /// </param>
    /// <param name="_inventRefTransId">
    /// The marked transaction, if applicable.
    /// </param>
    /// <returns>
    /// The updated reserved quantity.
    /// </returns>
    [Hookable(false)]
    final internal InventQty reservePhysicalReserveOrderedQuantities(
        InventDim           _inventDim,
        InventQty           _qtyReserv,
        PdsCWInventQty      _cwQtyReserv,
        InventTransOriginId _inventRefTransId)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), movement.itemId(), _cwQtyReserv))
        {
            return this.whsUpdateDimReservePhysical(_inventDim, _qtyReserv, _inventRefTransId);
        }
        return this.physicallyReserveReserveOrderedQuantities(_inventDim, _qtyReserv, _cwQtyReserv, _inventRefTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectInventTransIssueWithRefTransId</Name>
				<Source><![CDATA[
    protected InventTrans selectInventTransIssueWithRefTransId(
        InventTransOriginId _inventRefTransId,
        InventDim           _inventDimCriteria)
    {
        InventTrans inventTransIssue;

        select forceplaceholders forupdate inventTransIssue
            where inventTransIssue.ItemId                       == movement.itemId()
                && inventTransIssue.ValueOpen                   == InventTransOpen::Yes
                && inventTransIssue.StatusReceipt               == StatusReceipt::None
                && inventTransIssue.StatusIssue                 == StatusIssue::ReservOrdered
                && inventTransIssue.InventTransOrigin           == _inventRefTransId
                && inventTransIssue.MarkingRefInventTransOrigin == movement.inventTransOriginId()
                && inventTransIssue.InventDimId                 == _inventDimCriteria.inventDimId;

        return inventTransIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectInventTransIssueWithoutRefTransId</Name>
				<Source><![CDATA[
    protected InventTrans selectInventTransIssueWithoutRefTransId(
        InventDim           _inventDimCriteria,
        InventTransOriginId _markingRefInventTransOrigin = 0)
    {
        InventTrans inventTransIssue;

        if (isWHSReservePhysicalReserveOrderedQtyOrderByDateV2FlightEnabled)
        {
            select forceplaceholders forupdate inventTransIssue
                order by inventTransIssue.DateExpected asc
                where inventTransIssue.ItemId                       == movement.itemId()
                    && inventTransIssue.ValueOpen                   == InventTransOpen::Yes
                    && inventTransIssue.StatusReceipt               == StatusReceipt::None
                    && inventTransIssue.StatusIssue                 == StatusIssue::ReservOrdered
                    && inventTransIssue.InventTransOrigin           != movement.inventTransOriginId()
                    && inventTransIssue.MarkingRefInventTransOrigin == _markingRefInventTransOrigin
                    && inventTransIssue.InventDimId                 == _inventDimCriteria.inventDimId;
        }
        else
        {
            select forceplaceholders forupdate inventTransIssue
                where inventTransIssue.ItemId                       == movement.itemId()
                    && inventTransIssue.ValueOpen                   == InventTransOpen::Yes
                    && inventTransIssue.StatusReceipt               == StatusReceipt::None
                    && inventTransIssue.StatusIssue                 == StatusIssue::ReservOrdered
                    && inventTransIssue.InventTransOrigin           != movement.inventTransOriginId()
                    && inventTransIssue.MarkingRefInventTransOrigin == _markingRefInventTransOrigin
                    && inventTransIssue.InventDimId                 == _inventDimCriteria.inventDimId;
        }

        return inventTransIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicallyReserveReserveOrderedQuantities</Name>
				<Source><![CDATA[
    protected InventQty physicallyReserveReserveOrderedQuantities(
        InventDim           _inventDim,
        InventQty           _qtyReserv,
        PdsCWInventQty      _cwQtyReserv,
        InventTransOriginId _inventRefTransId)
    {
        InventTrans                         inventTransIssue;
        InventDimParm                       inventDimParm;
        InventDim                           inventDimCriteria;
        InventDim                           inventDimLoop;
        InventDim                           inventDimAboveLocation;
        List                                hierarchyList;
        WHSReservationHierarchyElementData  hierarchyElementData;
        ListEnumerator                      le;
        FieldId                             dimFieldId;
        boolean                             inventLocationWHSEnabled;
        WHSCrossDockingPlanned              crossDockPlanned;
        InventHandlingQty                   crossDockQty;

        InventQty       qtyReserv   = _qtyReserv;
        PdsCWInventQty  cwQtyReserv = _cwQtyReserv;

        // Skip if work or if inventory status is not reservable
        if (movement.transType() != InventTransType::WHSWork
            &&  movement.transType() != InventTransType::WHSContainer
            &&  (!movement.pdsCWItem() ? qtyReserv : cwQtyReserv))
        {
            inventLocationWHSEnabled = _inventDim.inventLocation().WHSEnabled;
            buf2Buf(_inventDim, inventDimAboveLocation);
            inventDimAboveLocation.clearLocationAndBelowDim(movement.itemId());
            inventDimAboveLocation = InventDim::findOrCreate(inventDimAboveLocation);

            hierarchyList = WHSReservationHierarchyProvider::construct()
                                .getDimListAllFromInventTable(movement.inventTable(), WHSReservationHierarchySortOrder::BottomUp);
            le = hierarchyList.getEnumerator();

            buf2Buf(_inventDim, inventDimLoop);
            inventDimParm.setAllInventDim();

            Set inventTransOriginIssueIdsForWHSLoadLineCheck = new Set(Types::Int64);

            // Loop through all levels of the hierarchy, building an inventdim at each stage and
            // looking for matching inventtrans records that are order reserved
            while (le.moveNext())
            {
                hierarchyElementData = le.current();
                dimFieldId = hierarchyElementData.parmDimensionFieldId();

                if (inventDimLoop.(dimFieldId))
                {
                    inventDimCriteria = InventDim::findOrCreate(inventDimLoop);

                    if (_inventRefTransId)
                    {
                        inventTransIssue = this.selectInventTransIssueWithRefTransId(_inventRefTransId, inventDimCriteria);
                    }
                    else if (!movement.isReturnScrap())
                    {
                        inventTransIssue = this.selectInventTransIssueWithoutRefTransId(inventDimCriteria);
                    }

                    while (inventTransIssue)
                    {
                        if (!this.canPhysicallyReserveReserveOrderedQuantities(inventTransIssue))
                        {
                            next inventTransIssue;
                            continue;
                        }

                        boolean validForCrossDock;

                        if (!movement.pdsCWItem())
                        {
                            if (!crossDockPlanned 
								&& inventTransIssue.MarkingRefInventTransOrigin)
                            {
                                crossDockPlanned = WHSCrossDockingPlanned::newFromCommon(inventTransIssue);
                            }

                            if (crossDockPlanned)
                            {
                                validForCrossDock = crossDockPlanned.verifyPlannedCrossDocking(inventTransIssue, _inventDim, _qtyReserv);
                            }

                            if (qtyReserv < -inventTransIssue.Qty)
                            {
                                inventTransIssue.updateSplit(-qtyReserv, -cwQtyReserv);
                            }
                        }
                        else
                        {
                            if (cwQtyReserv < -inventTransIssue.PdsCWQty)
                            {
                                InventHandlingQty splitWeight;

                                if (WHSUseSplitQtyOnCWTransactionSplitForWHSItemOnNonWHSWarehouseFlight::instance().isEnabled() 
                                    && !inventTransIssue.inventDim().inventLocation().WHSEnabled)
                                {
                                    // Reserve full weight in case of non whs warehouse
                                    splitWeight = qtyReserv;
                                }
                                else
                                {
                                    // Calculate min weight for the cwQty because we should always reserve at min weight.
                                    splitWeight = WHSInvent::defaultCatchWeightReserveQuantity(inventTransIssue.ItemId, cwQtyReserv);
                                }

                                inventTransIssue.updateSplit(-splitWeight, -cwQtyReserv);
                            }
                        }

                        inventTransIssue.StatusIssue = StatusIssue::ReservPhysical;

                        this.whsSynchronizeIssueDimPhysical(inventTransIssue, _inventDim, inventDimAboveLocation, inventLocationWHSEnabled);

                        inventTransIssue.update();

                        inventTransOriginIssueIdsForWHSLoadLineCheck.add(inventTransIssue.InventTransOrigin);
                        
                        if (validForCrossDock
							&& inventTransIssue.MarkingRefInventTransOrigin)
                        {
                            crossDockQty -= inventTransIssue.Qty;
                        }

                        qtyReserv   += inventTransIssue.Qty;
                        cwQtyReserv += inventTransIssue.PdsCWQty;
    
                        inventTransIssue.updateSumUp();

                        if (! qtyReserv
                            || (movement.pdsCWItem() && !cwQtyReserv))
                        {
                            break;
                        }

                        next inventTransIssue;
                    }

                    inventDimLoop.clearField(dimFieldId);
                }

                if (!qtyReserv 
                    || (movement.pdsCWItem() && !cwQtyReserv))
                {
                    break;
                }
            }

            this.physicallyReserveReserveOrderedCheckWHSLoadLineInventTransConsistency(inventTransOriginIssueIdsForWHSLoadLineCheck);
        }

        if (crossDockPlanned != null && crossDockQty && !movement.pdsCWItem())
        {
            crossDockPlanned.parmInventDim(_inventDim);
            crossDockPlanned.createCrossDockingWork(crossDockQty, movement.transType());
        }

        return qtyReserv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPhysicallyReserveReserveOrderedQuantities</Name>
				<Source><![CDATA[
    protected boolean canPhysicallyReserveReserveOrderedQuantities(InventTrans _inventTrans)
    {
        return !whsSuppressPhysicalRereservationOnNonWorkEnabledIssues
               || !this.whsMustSuppressPhysicalReregistrationOnInventTransType(_inventTrans.inventTransOrigin().ReferenceCategory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWHSLoadLineInventTransConsistency</Name>
				<Source><![CDATA[
    [SysObsolete('Use the physicallyReserveReserveOrderedCheckWHSLoadLineInventTransConsistency method instead of it.', true, 23\03\2023)]
    protected void checkWHSLoadLineInventTransConsistency(InventTrans _inventTransIssue)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicallyReserveReserveOrderedCheckWHSLoadLineInventTransConsistency</Name>
				<Source><![CDATA[
    protected void physicallyReserveReserveOrderedCheckWHSLoadLineInventTransConsistency(Set _inventTransOriginIssueIdsForWHSLoadLineCheck)
    {
        if (_inventTransOriginIssueIdsForWHSLoadLineCheck)
        {
            SetEnumerator se = _inventTransOriginIssueIdsForWHSLoadLineCheck.getEnumerator();
            while (se.moveNext())
            {
                InventTransOrigin inventTransOrigin = InventTransOrigin::find(se.current());
                InventMovement inventMovementIssue = inventTransOrigin.inventMovement(InventDirection::Issue, false);
                if (inventMovementIssue
                    && inventMovementIssue.isItemWHSEnabled())
                {
                    inventMovementIssue.checkWHSLoadLineInventTransConsistency();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIssueWorkTransactionDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Change work dimensions for WHS.
    /// </summary>
    /// <param name="_inventTrans">
    /// The <c>inventTrans</c> records.
    /// </param>
    /// <param name="_fromInventDim">
    /// The original <c>InventDim</c> record.
    /// </param>
    /// <param name="_toInventDim">
    /// The new <c>InventDim</c> record to which the transaction is synchronized.
    /// </param>
    /// <param name="_qty">
    /// The specified quantity.
    /// </param>
    /// <param name="_cwQty">
    /// The specified catch weight quantity.
    /// </param>
    /// <returns>
    /// A container containing the updated quantity and the updated catch weight quantity.
    /// </returns>
    /// <remarks>
    /// Do not use the standard routine as it doesn't account
    /// for the unique way WHS reserves inventory for work.
    /// Also, work dim changes don't allow dim changes when not enough quantity
    /// is available, it fails the transaction unless the entire quantity passed
    /// in is available in the new dimension.
    /// This assumes this is only a work type inventTrans record, do NOT use for
    ///  anything else.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Quantity cannot be reserved because there is not enough inventory available.
    /// </exception>
    [Hookable(false)]
    final internal container updateIssueWorkTransactionDimensions(
        InventTrans         _inventTrans,
        InventDim           _fromInventDim,
        InventDim           _toInventDim,  // must have RecId
        InventQty           _qty,
        PdsCWInventQty      _cwQty)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), movement.itemId(), _cwQty))
        {
            InventQty       qty;
            PdsInventQty    cwQty;

            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), movement.itemId());

            [qty, cwQty] = this.updateIssueWorkTransactionDimensionsForQuantities(_inventTrans, _fromInventDim, _toInventDim, _qty, 0);

            WHSCatchWeightConfigurationKeyManager::instance().executedNonCatchWeightQuantityLogic(funcName(), cwQty);

            return [qty, 0];
        }

        return this.updateIssueWorkTransactionDimensionsForQuantities(_inventTrans, _fromInventDim, _toInventDim, _qty, _cwQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIssueWorkTransactionDimensionsForQuantities</Name>
				<Source><![CDATA[
    private container updateIssueWorkTransactionDimensionsForQuantities(
        InventTrans         _inventTrans,
        InventDim           _fromInventDim,
        InventDim           _toInventDim,  // must have RecId
        InventQty           _qty,
        PdsCWInventQty      _cwQty)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), movement.itemId(), _cwQty, _qty);
        
        FieldId                             fieldId;
        InventDim                           inventDim;
        WHSInventReserve                    whsInventReserve;
        CreatedTransactionId                ttsId;
        WHSInventReserveDeltaView           deltaView;
        InventDimGroupSetup                 inventDimGroupSetup;
        WHSReservationHierarchyElementData  hierarchyElementData;
        ListEnumerator                      le;

        ttsbegin;

        if (InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_inventTrans.ItemId))
        {
            ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();
        }

        inventDimGroupSetup = movement.inventDimGroupSetup();

        buf2Buf(_toInventDim, inventDim);

        // Checking inventory is not needed if item and location allows negative physical
        if (!InventTable::find(_inventTrans.ItemId).whsAllowPhysNeg() ||
            !_toInventDim.wmsLocation().whsLocationProfile().AllowNegative)
        {
            le = WHSReservationHierarchyProvider::construct().getDimListAllFromInventTable(_inventTrans.inventTable(), WHSReservationHierarchySortOrder::BottomUp).getEnumerator();

            // Check each dimension combination to see if quantity is available
            // when new dim has a field filled and the old dim does not
            while (le.moveNext())
            {
                hierarchyElementData = le.current();

                fieldId = hierarchyElementData.parmDimensionFieldId();
                if (!_fromInventDim.(fieldId) && _toInventDim.(fieldId))
                {
                    // check just the single row in WHSInventReserve for available quantity
                    // Don't care about ordered reserved for WHS work
                    inventDim = InventDim::findOrCreate(inventDim);

                    whsInventReserve = WHSInventReserve::find(_inventTrans.ItemId, inventDim.inventDimId);

                    if (ttsId)
                    {
                        // Add Sum Delta in
                        select SumOfAvailPhysical, SumOfCWAvailPhysical from deltaView
                            where deltaView.ItemId        == _inventTrans.ItemId
                            &&    deltaView.ttsId         == ttsId
                            &&    deltaView.InventDimId   == inventDim.InventDimId;

                        whsInventReserve.AvailPhysical      += deltaView.SumOfAvailPhysical;
                        whsInventReserve.CWAvailPhysical    += deltaView.SumOfCWAvailPhysical;
                    }

                    if (!PdsGlobal::pdsIsCWItem(_inventTrans.ItemId))
                    {
                        if (whsInventReserve.AvailPhysical < -_qty)
                        {
                            throw error(strFmt("@SYS54812", -_qty, whsInventReserve.AvailPhysical));
                        }
                    }
                    else
                    {
                        if (whsInventReserve.CWAvailPhysical < -_cwQty)
                        {
                            throw error(strFmt("@SYS54812", -_cwQty, whsInventReserve.CWAvailPhysical));
                        }
                    }
                }

                inventDim.clearField(fieldId);
            }
        }

        // Quantities are negative (less than = more)
        if (_inventTrans.Qty < _qty || _inventTrans.PdsCWQty < _cwQty)
        {
            _inventTrans.updateSplit(_qty, _cwQty);
        }

        _inventTrans.InventDimId = _toInventDim.InventDimId;
        _inventTrans.update();

        ttscommit;

        return [_qty, _cwQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeInventTrans</Name>
				<Source><![CDATA[
    public void writeInventTrans(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_orig,
        boolean         _physicalUpdate)
    {
        InventOnHandQty inventOnHandQty;

        InventDimId     reserveAgainDimId;

        InventDim       fromInventDim;
        InventDim       toInventDim;

        InventQty       qtyRemain;
        InventBatch     inventBatch;
        InventBatchId   inventBatchId;

        PdsCWInventQty  cwQty = 0;
        PdsCWInventQty  cwRemain;
        InventMovement  movementTransfer;

        WHSInventStatusReservationHandler   inventStatusReservationHandler;

        cwQty = _inventTrans.PdsCWQty;

        if (!this.checkInventUpdateBlockedItem(_inventTrans.ItemId))
        {
            throw error("@SYS18447");
        }

        if (_physicalUpdate)
        {
            if (!this.checkLocationMixingConstraint(_inventTrans.inventDim()))
            {
                throw error("@SYS18447");
            }
        }

        if (!this.checkInventDimOnInventTransWrite(_inventTrans, _inventTrans_orig))
        {
            throw error("@SYS18447");
        }

        if (!_inventTrans.InventTransOrigin)
        {
            _inventTrans.InventTransOrigin = movement.inventTransOriginId();
        }

        if (_inventTrans.Qty > 0)
        {
            toInventDim  = InventDim::find(_inventTrans.InventDimId);

            if (_physicalUpdate)
            {
                movement.updateSerialNumReceipt(_inventTrans,_inventTrans_orig,toInventDim);
            }

            movementTransfer = movement.newMovement_TransferIssueReceive();
            if (movementTransfer)
            {
                if (_inventTrans.InventDimId != _inventTrans_orig.InventDimId && _inventTrans_orig || _physicalUpdate)
                {
                    this.updateDimTransferIssueReceipt(movementTransfer,toInventDim,InventDim::find(_inventTrans_orig.InventDimId), _inventTrans.Qty, _physicalUpdate, cwQty);
                }
            }

            if (_inventTrans.orig() && _inventTrans.InventDimId != _inventTrans.orig().InventDimId)// Do not use inventTrans_orig as it may not match content in database
            {
                fromInventDim = InventDim::find(_inventTrans.orig().InventDimId);

                if (InventLocation::find(fromInventDim.InventLocationId).AllowMarkingReservationRemoval != WHSAllowMarkingReservationRemoval::None)
                {
                    inventStatusReservationHandler = WHSInventStatusReservationHandler::newStandard(_inventTrans, movement, fromInventDim, toInventDim);
                    inventStatusReservationHandler.removeTransReservationMarking();
                }

                if (InventDimFixedClass::inventDimFieldsDifferent(fromInventDim, toInventDim) &
                    InventDimFixedClass::initPrimaryDim(movement.inventDimGroupSetup()) != 0 &&
                    InventDim::mustCheckDimChange(movement.inventDimGroupSetup(), fromInventDim, toInventDim))
                {
                    if (_inventTrans.orig().isUpdatedEstimated())
                    {
                        inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement,fromInventDim);
                        if (!this.allowChangeDim(inventOnHandQty, _inventTrans, fromInventDim, _physicalUpdate))
                        {
                            throw error("@SYS54456");
                        }
                    }
                    else if (!_inventTrans.orig().isUpdatedQuotation())
                    {
                        inventOnHandQty = InventOnHandQty::newPhysicalUpdate(movement,fromInventDim);
                        if (! inventOnHandQty.checkItemDraw(-_inventTrans.Qty, allowNegativePhysical, true, -_inventTrans.PdsCWQty))
                        {
                             throw error("@SYS54456");
                        }
                    }

                    if (_physicalUpdate)
                    {
                        this.updateDimReservePhysical(toInventDim, _inventTrans.Qty, _inventTrans.MarkingRefInventTransOrigin, cwQty);
                    }

                    // Dimensions do not need re-reserved for some WHS transactions
                    if (this.whsForceReserveAgain(fromInventDim, toInventDim, EcoResStorageDimensionGroupItem::findByItem(movement.inventTable().DataAreaId, movement.itemId()).StorageDimensionGroup))
                    {
                        reserveAgainDimId = fromInventDim.InventDimId;
                    }
                }
                else
                {
                    [qtyRemain,cwRemain] = this.updateDimReserveChange(
                                                    toInventDim,
                                                    fromInventDim,
                                                    _inventTrans.Qty,
                                                    _physicalUpdate,
                                                    _inventTrans.MarkingRefInventTransOrigin
                                                    , cwQty
                                                    );

                    if (_physicalUpdate)
                    {
                        this.updateDimReservePhysical(
                                        toInventDim,
                                        qtyRemain,
                                        _inventTrans.MarkingRefInventTransOrigin,
                                        cwRemain
                                        );
                    }
                }
            }
            else if (_physicalUpdate)
            {
                this.updateDimReservePhysical(
                                toInventDim,
                                _inventTrans.Qty,
                                _inventTrans.MarkingRefInventTransOrigin,
                                cwQty
                                );
            }
        }
        else
        if (_inventTrans_orig && _inventTrans.InventDimId != _inventTrans_orig.InventDimId)
        {
            InventUpdate::updateTransDimTransferReceipt(movement,_inventTrans,null);
        }

        inventBatchId = _inventTrans.inventBatchId();
        if (inventBatchId != '' && movement.pdsCanHaveBatchInheritance())
        {
            inventBatch = InventBatch::find(inventBatchId, _inventTrans.ItemId, true);
            movement.pdsInheritBatchData(inventBatch, _inventTrans);
            if (!inventBatch.validateWrite())
            {
                throw error("@PSC353");
            }
            inventBatch.update();
        }

        this.persistInventTrans(_inventTrans);

        if (inventStatusReservationHandler)
        {
            inventStatusReservationHandler.onReceiptTransWritten();
        }

        if ((_inventTrans_orig.StatusReceipt == StatusReceipt::Ordered      ||
             _inventTrans_orig.StatusReceipt == StatusReceipt::Arrived)     &&
            (_inventTrans.StatusReceipt      == StatusReceipt::Registered   ||
             _inventTrans.StatusReceipt      == StatusReceipt::Received))
        {
            // Register receipt with quality management
            inventReceiptForTestRegistrator = InventReceiptForTestRegistrator::registerReceipt(
                inventReceiptForTestRegistrator,
                _inventTrans);

            if (movement.mustCreateQuarantineOrder())
            {
                // Set InventDim for quarantine if the item is quarantine controlled and some previous logic
                // (e.g., in source document handling) hasn't set it yet
                if (movement.mustBeQuarantineControlled() && !this.parmInventDimQuarantine().InventDimId)
                {
                    this.parmInventDimQuarantine(_inventTrans.inventDim());
                }
                
                if (inventReceiptForTestRegistrator)
                {
                    inventReceiptForTestRegistrator.parmMustBeQuarantineControlled(movement.mustBeQuarantineControlled());
                }
                movement.createQuarantineOrder(this,_inventTrans,_inventTrans.StatusReceipt == StatusReceipt::Registered ? _inventTrans.DateInvent : _inventTrans.DatePhysical);
            }
        }

        if (reserveAgainDimId)
        {
            this.updateReserveAgain(
                    reserveAgainDimId,
                    _inventTrans.Qty,
                    _inventTrans.MarkingRefInventTransOrigin,
                    _inventTrans.PdsCWQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>persistInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Persists the inventory transaction table record to the database.
    /// </summary>
    /// <param name="_inventTrans">
    /// An inventory transaction table record that needs to be persisted.
    /// </param>
    protected void persistInventTrans(InventTrans _inventTrans)
    {
        if (_inventTrans.RecId)
        {
            _inventTrans.update(NoYes::No, NoYes::No, movement.inventDimIdTransferIssue());
        }
        else
        {
            _inventTrans.insert(NoYes::No, movement.inventDimIdTransferIssue());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePopulateAutoInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepopulates dimensions for the auto dimension assignment.
    /// </summary>
    /// <param name = "_inventTrans">The transaction.</param>
    /// <param name = "_inventDim">The dimensions to update.</param>
    /// <param name = "_physicalUpdate">A Boolean value to identify if the movement is doing physical update.</param>
    /// <returns>true if the dimension was changed; otherwise, false.</returns>
    protected boolean prePopulateAutoInventDim(InventTrans _inventTrans, InventDim _inventDim, boolean _physicalUpdate)
    {
        boolean ret;

        // <GEERU>
        if (!_inventDim.InventOwnerId_RU)
        {
            InventOwner_RU::createAndAssignOwner(movement, _inventDim, _physicalUpdate);
            if (_inventDim.InventOwnerId_RU)
            {
                ret = true;
            }
        }
        // </GEERU>
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeInventTransAutoDim</Name>
				<Source><![CDATA[
    protected void writeInventTransAutoDim(
        InventTrans     _inventTrans,
        InventTrans     _inventTrans_Orig,
        boolean         _physicalUpdate)
    {
        InventNumGroup  inventNumGroupBatch;
        InventNumGroup  inventNumGroupSerial;
        InventBatch     inventBatch;
        InventDim       inventDim;

        boolean         createBatch;
        boolean         createSerial;

        using (CostInventTransFinancialInventDimUpdateValidationSkipSingleton flag = CostInventTransFinancialInventDimUpdateValidationSkipSingleton::instance())
        {
            flag.parmSkip(_inventTrans_Orig == null || _inventTrans_Orig.StatusIssue > StatusIssue::Deducted
                || _inventTrans_Orig.StatusReceipt > StatusReceipt::Received);
        
            if (!_inventTrans.InventTransOrigin)
            {
                _inventTrans.InventTransOrigin = movement.inventTransOriginId();
            }

            if (_inventTrans.Qty > 0)
            {
                inventDim = _inventTrans.inventDim();
                if (this.prePopulateAutoInventDim(_inventTrans, inventDim, _physicalUpdate))
                {
                    _inventTrans.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;

                    if (_inventTrans.RecId)
                    {
                        _inventTrans.update();
                    }
                    else
                    {
                        _inventTrans.insert();
                    }
                }

                InventTransAutoCreateDimCheck autoCreateDimCheck = InventTransAutoCreateDimCheck::newFromMovementDim(movement, inventDim, _physicalUpdate);

                if (autoCreateDimCheck.mustAutoCreateSerial())
                {
                    createSerial = true;
                    inventNumGroupSerial = InventNumGroup::find(movement.inventTable().SerialNumGroupId);
                }

                if (autoCreateDimCheck.mustAutoCreateBatch())
                {
                    createBatch = true;
                    inventNumGroupBatch = InventNumGroup::find(movement.inventTable().BatchNumGroupId);
                }
            }

            if (createBatch || createSerial)
            {
                if (_inventTrans.RecId)
                {
                    _inventTrans.update();
                }
                else
                {
                    _inventTrans.insert();
                }

                RecId recIdBatch = _inventTrans.RecId;
                RecId recIdSerial = _inventTrans.RecId;
                InventQty qtyBatch = _inventTrans.Qty;

                if (movement.pdsCWItem() && inventNumGroupBatch.PerQty > 0)
                {
                    throw error(strFmt("@PDS116", fieldPName(InventTable,BatchNumGroupId)));
                }

                while (qtyBatch > 0)
                {
                    if (createBatch)
                    {
                        if (_inventTrans.Qty > inventNumGroupBatch.PerQty && inventNumGroupBatch.PerQty > 0)
                        {
                            recIdBatch = _inventTrans.RecId;
                            _inventTrans.updateSplit(inventNumGroupBatch.PerQty);
                        }

                        inventDim.InventBatchId = this.generateBatchNumber(inventNumGroupBatch, movement.batchProdDate(_inventTrans));

                        if (! inventDim.InventBatchId)
                        {
                            throw error(strFmt("@SYS54023",inventNumGroupBatch.NumGroupId));
                        }

                        InventBatch::createFromMovement(inventDim.InventBatchId, movement, _inventTrans);
                    }

                    InventQty qtySerial = _inventTrans.Qty;
                    while (qtySerial > 0)
                    {
                        if (createSerial)
                        {
                            if (_inventTrans.Qty > inventNumGroupSerial.PerQty && inventNumGroupSerial.PerQty > 0)
                            {
                                recIdSerial = _inventTrans.RecId;
                                _inventTrans.updateSplit(inventNumGroupSerial.PerQty);
                            }

                            inventDim.InventSerialId = this.generateSerialNumber(inventNumGroupSerial, movement.serialProdDate(_inventTrans));
                            if (! inventDim.InventSerialId)
                            {
                                throw error(strFmt("@SYS54023",inventNumGroupSerial.NumGroupId));
                            }
                        }

                        _inventTrans.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;

                        InventUpdateProcessReceiptTransactionListsCache::cacheInstance();
                        this.writeInventTrans(_inventTrans,_inventTrans_Orig,_physicalUpdate);
                        InventUpdateProcessReceiptTransactionListsCache::processCacheValue();

                        qtyBatch   -= _inventTrans.Qty;
                        qtySerial  -= _inventTrans.Qty;

                        if (createSerial && qtySerial > 0)
                        {
                            _inventTrans = InventTrans::findRecIdTransOriginId(recIdSerial,_inventTrans.InventTransOrigin,true);
                        }
                    }
                    if (createBatch && qtyBatch > 0)
                    {
                        _inventTrans = InventTrans::findRecIdTransOriginId(recIdBatch,_inventTrans.InventTransOrigin,true);
                    }
                }
            }
            else
            {
                InventUpdateProcessReceiptTransactionListsCache::cacheInstance();
                this.writeInventTrans(_inventTrans,_inventTrans_Orig,_physicalUpdate);                
                InventUpdateProcessReceiptTransactionListsCache::processCacheValue();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateBatchNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new batch number.
    /// </summary>
    /// <param name = "_inventNumGroup">The number sequence group for batch numbers.</param>
    /// <param name = "_prodDate">The production date.</param>
    /// <returns>The batch number</returns>
    protected InventBatchId generateBatchNumber(InventNumGroup _inventNumGroup, InventBatchProdDate _prodDate)
    {
        return _inventNumGroup.buildNumberParameters(
            _prodDate,
            movement.transRefId(),
            movement.transId(),
            extendedTypeNum(InventBatchId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateSerialNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a new serial number.
    /// </summary>
    /// <param name = "_inventNumGroup">The number sequence group for serial numbers.</param>
    /// <param name = "_prodDate">The production date.</param>
    /// <returns>The serial number</returns>
    protected InventSerialId generateSerialNumber(InventNumGroup _inventNumGroup, InventSerialProdDate _prodDate)
    {
        return _inventNumGroup.buildNumberParameters(
            _prodDate,
            movement.transRefId(),
            movement.transId(),
            extendedTypeNum(InventSerialId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemPostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that an item transaction may be posted on a given transaction date.
    /// </summary>
    /// <param name="_itemId">
    ///    The item ID of the item that is validated.
    /// </param>
    /// <param name="_transDate">
    ///    The transaction date that is validated.
    /// </param>
    /// <returns>
    ///    true if an item transaction may be posted on the given date; otherwise, false.
    /// </returns>
    static public boolean checkItemPostingDate(
        ItemId          _itemId,
        TransDate       _transDate)
    {
        boolean ret = true;

        if (!InventClosing::checkOpen(_transDate))
        {
            ret = false;
        }

        // <GEERU>
        if (! InventStdCostConv::checkItemPostingDate(_itemId, _transDate, InventTransCurrency_RU::PrimaryCur))
        {
            ret = false;
        }
        if (! InventStdCostConv::checkItemPostingDate(_itemId, _transDate, InventTransCurrency_RU::SecondaryCur))
        // </GEERU>
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialReturn</Name>
				<Source><![CDATA[
    static public Integer financialReturn()
    {
        #define.return(2)

        return #return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newChangeTransDim</Name>
				<Source><![CDATA[
    static public InventUpdate newChangeTransDim(InventMovement  _movement)
    {
        InventUpdate inventUpdate = new InventUpdate(_movement);

        inventUpdate.setParmAllowDefault();

        return inventUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalReturn</Name>
				<Source><![CDATA[
    static public Integer physicalReturn()
    {
        #define.return(1)

        return #return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshCallerDatasource</Name>
				<Source><![CDATA[
    static protected void refreshCallerDatasource(FormDataSource _datasource)
    {
        if (_datasource)
        {
            _datasource.reread();
            _datasource.refresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransDimTransferReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory dimensions on receipt transactions based on the new dimensions from issue transactions for issue/receipt transactions that are considered a transfer.
    /// </summary>
    /// <param name = "_movement">The movement for the issue transaction.</param>
    /// <param name = "_inventTransIssue">The issue transaction.</param>
    /// <param name = "_inventDimIssueNew">The new inventory dimensions for the issue transaction.</param>
    /// <param name = "_info">A Boolean that determines if an infolog should be displayed if all dimensions could not be synchronized.</param>
    public static void updateTransDimTransferReceipt(
        InventMovement  _movement,
        InventTrans     _inventTransIssue,
        InventDim       _inventDimIssueNew,
        boolean         _info = true)
    {
        InventDim       inventDimReceiptOrig;
        InventDim       inventDimReceiptNew;

        InventDimParm   inventDimParm;

        InventMovement  movementParent;
        InventMovement  movementIssue;
        InventMovement  movementReceipt;
        boolean         tmpLP;

        if (!_movement)
        {
            return;
        }

        if (_movement.inventTransOriginId() != _inventTransIssue.InventTransOrigin)
        {
            _movement = _inventTransIssue.inventMovement(true);
        }

        if (!_movement)
        {
            return;
        }
        if (_movement.mustUseParentMovToDimTransferReceipt())
        {
            movementParent = _movement.parentMovement();
            if (movementParent)
            {
                movementIssue = movementParent.newMovement_TransferIssue();
            }
        }
        else
        {
            movementIssue = _movement.newMovement_TransferIssue();
        }

        if (! movementIssue)
        {
            return;
        }

        movementReceipt = movementIssue.newMovement_TransferReceipt();
        if (! movementReceipt)
        {
            return;
        }

        if (! _inventDimIssueNew.RecId)
        {
            _inventDimIssueNew = InventDim::find(_inventTransIssue.InventDimId);
        }

        inventDimReceiptOrig = InventDim::find(_inventTransIssue.orig().InventDimId);
        inventDimReceiptOrig = movementReceipt.mergeTransDimTransferReceipt(inventDimReceiptOrig);
        inventDimReceiptOrig = InventDim::findOrCreate(inventDimReceiptOrig);

        inventDimReceiptNew.data(_inventDimIssueNew);
        inventDimReceiptNew = movementReceipt.mergeTransDimTransferReceipt(inventDimReceiptNew);
        // Create dummy LP for receiving location once batch is specified.
        // This is expected to only get hit with transfer orders.
        // Skip if item is catch weight enabled, as the dummy LP is not needed.
        if (!inventDimReceiptNew.LicensePlateId
            && !PdsGlobal::pdsIsCWItem(_inventTransIssue.ItemId)
            && WHSInventEnabled::exist(_inventTransIssue.ItemId))
        {
            inventDimReceiptNew = WHSInvent::fillLicensePlateForTransferReceipt(inventDimReceiptNew, _movement.inventTable());
            if (inventDimReceiptNew.LicensePlateId)
            {
                tmpLP = true;
            }
        }

        InventUpdate::whsClearLPIfDestinationLocNotLPControlled(_inventTransIssue.ItemId, inventDimReceiptNew);

        inventDimReceiptNew = InventDim::findOrCreate(inventDimReceiptNew);

        if (inventDimReceiptOrig.InventDimId != inventDimReceiptNew.InventDimId)
        {
            _movement.inventDimGroupSetup().inventDimParmActive(inventDimParm);

            // Modify the inventDimParm to correctly reflect what dims will match
            if (tmpLP)
            {
                inventDimParm.LicensePlateFlag = NoYes::No;

                // Sometimes the receipt inventTrans will have been correctly updated with batch, other times it isn't
                // Set the batch flag on the inventDimParm to No when batches will not match.
                if (_inventTransIssue.orig().inventDim().InventBatchId  != inventDimReceiptNew.InventBatchId &&
                    inventDimReceiptOrig.InventBatchId                  == inventDimReceiptNew.InventBatchId)
                {
                    inventDimParm.InventBatchIdFlag = NoYes::No;
                }
            }
            else if (inventDimParm.LicensePlateFlag == NoYes::Yes                       &&
                     inventDimReceiptOrig.LicensePlateId == ''                          &&
                     !PdsGlobal::pdsIsCWItem(_inventTransIssue.ItemId)                  &&
                     WHSInventEnabled::exist(_inventTransIssue.ItemId)                  &&
                     inventDimReceiptNew.wmsLocation().whsLocationIsLPControlled())
            {
                // Need to set LicensePlateFlag to no in current cancel marking or unpick process if dummy LP may be already be assigned in previous marking or pick process
                // when we have any inventory dimension below license plate
                if (WHSReservationHierarchyProvider::construct().getDimFieldIdForBottomHierarchyLevel(_movement.inventTable()) != fieldNum(InventDim, LicensePlateId))
                {
                    inventDimParm.LicensePlateFlag = NoYes::No;
                }
            }

            InventUpdateProcessReceiptTransactionListsCache cacheInstance = InventUpdateProcessReceiptTransactionListsCache::getInstanceFromCache();
            if (cacheInstance)
            {
                // Keep the data in the parameters list of this static instance, it will be delayed to process to avoid recursive calling
                cacheInstance.insert(movementReceipt,
                    [inventDimReceiptOrig, inventDimParm, inventDimReceiptNew, -_inventTransIssue.Qty, -_inventTransIssue.PdsCWQty, _info]);                 
            }
            else
            {
                InventUpdate::processReceiptTransactionsForTransIssueQtyHelper(movementReceipt,
                                                                               inventDimReceiptOrig,
                                                                               inventDimParm,
                                                                               inventDimReceiptNew,
                                                                               -_inventTransIssue.Qty,
                                                                               -_inventTransIssue.PdsCWQty,
                                                                               _info);                
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsClearLPIfDestinationLocNotLPControlled</Name>
				<Source><![CDATA[
    private static void whsClearLPIfDestinationLocNotLPControlled(ItemId _itemId, InventDim _inventDimReceiptNew)
    {
        if (!WHSInventEnabled::exist(_itemId))
        {
            return;
        }

        if (_inventDimReceiptNew.LicensePlateId && !_inventDimReceiptNew.wmsLocation().whsLocationIsLPControlled())
        {
            _inventDimReceiptNew.LicensePlateId = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReceiptTransactionsForTransIssueQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the receipt <c>InventTrans</c> records for the transaction issue quantity
    /// based on the passed arguments and returns the remaining quantity after the update.
    /// </summary>
    /// <param name = "_movementReceipt">
    /// The receipt <c>InventMovement</c> record.
    /// </param>
    /// <param name = "_inventDimReceiptOrig">
    /// The original <c>InventDim</c> for the issue transaction.
    /// </param>
    /// <param name = "_inventDimParm">
    /// The <c>InventDimParm</c> record used to find the receipt transaction.
    /// </param>
    /// <param name = "_inventDimReceiptNew">
    /// The new <c>InventDim</c> record for the issue transaction.
    /// </param>
    /// <param name = "_qtyRemain">
    /// The remaining quantity of the issue transaction.
    /// </param>
    /// <param name = "_cwQtyRemain">
    /// The catch weight quantity of the issue transaction.
    /// </param>
    /// <returns>
    /// The remaining quantity after the update.
    /// </returns>
    protected static InventQty processReceiptTransactionsForTransIssueQty(InventMovement _movementReceipt,
                                                                        InventDim _inventDimReceiptOrig,
                                                                        InventDimParm _inventDimParm,
                                                                        InventDim _inventDimReceiptNew,
                                                                        InventQty _qtyRemain,
                                                                        PdsCWInventQty _cwQtyRemain)
    {
        InventTrans inventTransReceipt;
        InventUpd_Estimated inventUpdate;
        InventDim inventDimReceipt;
        InventQty tmpQty;
        PdsCWInventQty cwTmpQty;

        while (_qtyRemain > 0)
        {
            select forupdate inventTransReceipt
                    where inventTransReceipt.InventTransOrigin  == _movementReceipt.inventTransOriginId()
                       && inventTransReceipt.StatusIssue        == StatusIssue::None
                       && inventTransReceipt.StatusReceipt      == StatusReceipt::Ordered
                       && inventTransReceipt.TransChildType     == InventTransChildType::None
                #inventDimExistsJoin(inventTransReceipt.inventDimId, inventDimReceipt, _inventDimReceiptOrig, _inventDimParm);

            if (inventTransReceipt.RecId)
            {
                if (!inventUpdate)
                {
                    inventUpdate = InventUpd_Estimated::newInventMovement(_movementReceipt);
                    if (!inventUpdate.checkNonChangeableTrans(_inventDimReceiptNew, _inventDimReceiptOrig))
                    {
                        throw error("@SYS18447");
                    }
                }

                [tmpQty, cwTmpQty] = inventUpdate.updateTransDimReceipt(inventTransReceipt,
                                                                        _inventDimReceiptOrig,
                                                                        _inventDimReceiptNew,
                                                                        _qtyRemain,
                                                                        false,
                                                                        false,
                                                                        _cwQtyRemain);
                _qtyRemain -= tmpQty;
                _cwQtyRemain -= cwTmpQty;
            }
            else
            {
                break;
            }
        }
        return _qtyRemain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipInventTransSumUp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value that determines if <c>InventTrans</c> records should be summed together.
    /// </summary>
    /// <param name="_skipInventTransSumUp">
    /// Determines if <c>InventTrans</c> records should be summed together; optional.
    /// </param>
    /// <returns>
    /// true if the records will not be summed up; otherwise, false.
    /// </returns>
    public boolean parmSkipInventTransSumUp(boolean _skipInventTransSumUp = skipInventTransSumUp)
    {
        skipInventTransSumUp = _skipInventTransSumUp;

        return skipInventTransSumUp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsSynchronizeIssueDimPhysical</Name>
				<Source><![CDATA[
    private void whsSynchronizeIssueDimPhysical(
        InventTrans     _issueInventTrans,
        InventDim       _issueInventDim,
        InventDim       _issueInventDimAboveLocation,
        boolean         _isWarehouseWHSEnabled)
    {
        InventMovement  issueMovement;
        InventDim       issueTransInventDim;

        // Return early to avoid costly calls
        if (!_isWarehouseWHSEnabled
            && _issueInventTrans.inventDimId == _issueInventDim.inventDimId)
        {
            return;
        }

        issueMovement = _issueInventTrans.inventMovement();

        issueTransInventDim = issueMovement.getInventDimForReservedTransPhysChange(_isWarehouseWHSEnabled, _issueInventDim, _issueInventDimAboveLocation);

        if (issueTransInventDim.inventDimId != _issueInventTrans.inventDimId)
        {
            _issueInventTrans.inventDimId = issueTransInventDim.inventDimId;
            InventUpdate::updateTransDimTransferReceipt(issueMovement, _issueInventTrans, issueTransInventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsCanUpdateInventDimWithoutReservationChange</Name>
				<Source><![CDATA[
    private boolean whsCanUpdateInventDimWithoutReservationChange(ItemId _itemId, InventDim _fromInventDim, InventDim _toInventDim)
    {
        InventTable item = InventTable::find(_itemId);

        boolean ret = !WhsReservationHierarchyInventDimUtil::isLocationOrBelowSpecified(item, _toInventDim);

        if (ret)
        {
            List fieldsAboveLocation = WHSReservationHierarchyInventDimUtil::hierarchyList2FieldIdList(
            WHSReservationHierarchyProvider::construct()
                .getDimListAboveLocationFromInventTable(item, WHSReservationHierarchySortOrder::TopDown));
            ret = ret && InventDim::isInventDimEqual(_fromInventDim, _toInventDim, fieldsAboveLocation);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    void validateLedgerDimension(LedgerDimensionAccount _ledgerDimensionAccount, InventPostingType _inventPostingType)
    {
        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && !_ledgerDimensionAccount)
        {
            throw error(strFmt("@SCM:MissingPostingProfileError", _inventPostingType, movement.inventTable().ItemId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimOnInventTransWrite</Name>
				<Source><![CDATA[
    private boolean checkInventDimOnInventTransWrite(InventTrans _inventTrans, InventTrans _inventTransOrig)
    {
        if (_inventTransOrig && _inventTrans.InventDimId != _inventTransOrig.InventDimId)
        {
            return this.checkInventDimChangeOnInventTransUpdate(_inventTransOrig.inventDim(), _inventTrans.inventDim());
        }

        return this.checkInventDimOnInventTransInsert(_inventTrans.inventDim());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimChangeOnInventTransUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether it is allowed to update an inventory transaction with the specified inventory dimensions.
    /// </summary>
    /// <param name="_inventDimOrig">The inventory dimension values that were assigned to the inventory transaction prior to the inventory update.</param>
    /// <param name="_inventDim">The inventory dimension values that will be assigned to the inventory transaction after the inventory update.</param>
    /// <returns>true if it is allowed to update an inventory transaction with the specified inventory dimensions; otherwise, false.</returns>
    /// <remarks>
    /// It is expected that the inventory dimension values are in sync with the InventDimId values
    /// because the method will return true if _inventDimFrom.InventDimId == _inventDimTo.InventDimId.
    /// The method does not need to be called during an update of an inventory transaction if the inventory dimensions are not being changed.
    /// </remarks>
    public boolean checkInventDimChangeOnInventTransUpdate(InventDim _inventDimOrig, InventDim _inventDim)
    {
        if (_inventDimOrig.InventDimId == _inventDim.InventDimId)
        {
            return true;
        }

        if (!this.allowChangeConsistentDim()
            && !InventDim::checkUpdateConsistent(movement.inventDimGroupSetup(), _inventDimOrig, _inventDim))
        {
            return false;
        }

        if (!movement.checkUpdateInventOwnerId(_inventDim, _inventDimOrig))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsAdjustInventDimFromMovementTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventDimId whsAdjustInventDimFromMovementTransaction(InventDimId _inventDimId)
    {
        InventDim inventDim;
        InventDim origInventDim = InventDim::find(_inventDimId);

        inventDim.initFromInventDim(origInventDim);
        inventDim.clearLicensePlateIfInvalid();
        inventDim = InventDim::findOrCreate(inventDim);

        return inventDim.inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventDimOnInventTransInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether it is allowed to insert an inventory transaction with the specified inventory dimensions.
    /// </summary>
    /// <param name="_inventDim">The inventory dimension values assigned to the new inventory transaction.</param>
    /// <returns>true if it is allowed to insert an inventory transaction with the specified inventory dimensions; otherwise, false.</returns>
    /// <remarks>
    /// The method does not need to be called for new inventory transactions where the inventory dimensions are already known to be valid.
    /// E.g. when splitting an existing inventory transaction.
    /// </remarks>
    protected boolean checkInventDimOnInventTransInsert(InventDim _inventDim)
    {
        if (!movement.checkUpdateInventOwnerId(_inventDim))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReceiptTransactionsForTransIssueQtyHelper</Name>
				<Source><![CDATA[
    /// <summary>
    /// This is helper method to process the receipt <c>InventTrans</c> records for the transaction issue quantity
    /// based on the passed arguments and returns the remaining quantity after the update.
    /// </summary>
    /// <param name = "_movementReceipt">
    /// The receipt <c>InventMovement</c> object.
    /// </param>
    /// <param name = "_inventDimReceiptOrig">
    /// The original <c>InventDim</c> for the issue transaction.
    /// </param>
    /// <param name = "_inventDimParm">
    /// The <c>InventDimParm</c> record used to find the receipt transaction.
    /// </param>
    /// <param name = "_inventDimReceiptNew">
    /// The new <c>InventDim</c> record for the issue transaction.
    /// </param>
    /// <param name = "_qtyRemain">
    /// The remaining quantity of the issue transaction.
    /// </param>
    /// <param name = "_cwQtyRemain">
    /// The catch weight quantity of the issue transaction.
    /// </param>
    /// <param name = "_info">
    /// A boolean that determines if an infolog should be displayed if all dimensions could not be synchronized.
    /// </param>
    [Hookable(false)]
    internal static void processReceiptTransactionsForTransIssueQtyHelper(InventMovement _movementReceipt,
                                                                          InventDim      _inventDimReceiptOrig,
                                                                          InventDimParm  _inventDimParm,
                                                                          InventDim      _inventDimReceiptNew,
                                                                          InventQty      _qtyRemain,
                                                                          PdsCWInventQty _cwQtyRemain,
                                                                          boolean        _info)
  {
        InventQty qtyRemain = InventUpdate::processReceiptTransactionsForTransIssueQty(_movementReceipt,
                                                                                       _inventDimReceiptOrig,
                                                                                       _inventDimParm,
                                                                                       _inventDimReceiptNew,
                                                                                       _qtyRemain,
                                                                                       _cwQtyRemain);

        if (qtyRemain && _info && _movementReceipt.mustShowMarkingWarningOnUpdate())
        {
            setPrefix(_inventDimReceiptNew.preFix());
            info("@SYS68020");
            info(strFmt("@SYS68021",qtyRemain));
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWhsSuppressPhysicalRereservationOnNonWorkEnabledIssues</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmWhsSuppressPhysicalRereservationOnNonWorkEnabledIssues(boolean _whsSuppressPhysicalRereservationOnNonWorkEnabledIssues = whsSuppressPhysicalRereservationOnNonWorkEnabledIssues)
    {
        whsSuppressPhysicalRereservationOnNonWorkEnabledIssues = _whsSuppressPhysicalRereservationOnNonWorkEnabledIssues;

        return whsSuppressPhysicalRereservationOnNonWorkEnabledIssues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates or creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    [Hookable(false)]
    public void updateOwnerRelationship()
    {
        movement.createOriginOwnerRelationship();
    }

]]></Source>
			</Method>
			<Method>
				<Name>projExecuteReserveAgain</Name>
				<Source><![CDATA[
    private boolean projExecuteReserveAgain()
    {
        boolean executeReserveAgain = true;

        if (movement.projId()
            && movement is InventMov_Purch
            && movement.mustDoAutoLossProfitEstimate()
            && ProjPODimensionsChangeFlight::instance().isEnabled())
        {
            executeReserveAgain = false;
        }

        return executeReserveAgain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSwitchDimForWhsItemNeeded</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    protected boolean isSwitchDimForWhsItemNeeded(InventTable _inventTable, InventDim _fromInventDim, InventDim _toInventDimDim)
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>