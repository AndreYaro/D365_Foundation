<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCdxPurgeHistory</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;
/// <summary>
/// Retail CDX purge history data.
/// </summary>
class RetailCdxPurgeHistory extends RunBaseBatch implements BatchRetryable
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog box can be shown and the parameters can be changed, but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class two times with the
    ///    same parameters is not always possible. If the <c>RunBaseBatch.canGoBatch</c> method is false, this
    ///    method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Caption shown in batch job form.
    /// </summary>
    /// <returns>Returns instance of <c>ClassDescription</c>.</returns>
    public ClassDescription caption()
    {
        return "@Retail:CdxPurgeHistoryBatchCaption";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// Launch CDX purge history data.
    /// </summary>
    /// <param name = "_args">Class argument. Not used.</param>
    public static void main(Args _args)
    {
        RefRecId batchId;
        RetailCdxPurgeHistory purgeHistory = new RetailCdxPurgeHistory();
        RetailConnParameters schedulerParameter;
        FormDataSource ds;

        if (purgeHistory.prompt())
        {
            purgeHistory.runOperation();
        }

        BatchInfo batchInfo = purgeHistory.batchInfo();

        if (batchInfo && batchInfo.hasBatchHeader())
        {
            batchId = batchInfo.parmBatchHeader().parmBatchHeaderId();

            if (batchId)
            {
                ttsbegin;

                schedulerParameter = RetailConnParameters::find(true);
                schedulerParameter.BatchJobId = batchId;
                schedulerParameter.update();

                ttscommit;

                if (_args && _args.dataset() == tableNum(RetailConnParameters) && _args.record() && FormDataUtil::getFormDataSource(_args.record()))
                {
                    ds = FormDataUtil::getFormDataSource(_args.record());
                    ds.reread();
                    ds.rereadReferenceDataSources();
                    ds.refresh();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes CDX purge history data.
    /// </summary>
    public void run()
    {
        RetailCDXMonDataRetentionDays retentionDays = RetailConnParameters::find().MonitoringRetentionDays;

         // if retention is set, the minimum should be 3 days
        retentionDays = retentionDays > 0 ? max(retentionDays, 3) : 0;
        utcdatetime cutOffDateTime = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -retentionDays);

        ApplicationEventSource::EventWriteRetailCDXPurgeHistoryStart(retentionDays, datetime2Str(cutOffDateTime));

        if (retentionDays)
        {
            // RetailCDXUploadSession
            RetailCdxPurgeHistory::deleteUploadSessions(cutOffDateTime);

            // RetailCDXDownloadSession and RetailCDXDownloadSessionDataStore
            RetailCdxPurgeHistory::deleteDownloadSessionRelatedData(cutOffDateTime);
        }

        if (!RetailCdxFeatureControl::IsPurgeUnusedUploadPathDisabled())
        {
            RetailCdxPurgeHistory::deleteUnusedUploadPath();
        }

        if (this.shouldPurgeRetailOfflineTerminalStateData())
        {
            RetailCdxPurgeHistory::deleteRetailOfflineTerminalStateData();
        }

        RetailCdxPurgeHistory::PurgeOldSearchPublishingSessions(cutOffDateTime);
        RetailCdxPurgeHistory::UpdateTimedOutSearchPublishingSessions();
        RetailCdxPurgeHistory::deleteOrphanRetailCDXUploadSessionTracker();
        RetailCdxPurgeHistory::purgeOrphanPropagationHistoryRecords();
        ApplicationEventSource::EventWriteRetailCDXPurgeHistoryStop(retentionDays, datetime2Str(cutOffDateTime));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method returns a value indicating if the <c>RetailCdxPurgeHistory</c>
    /// class can be run in a new session.
    /// </summary>
    /// <returns>true if the the class <c>RetailCdxPurgeHistory</c> can
    ///  be run in a new session; otherwise, false.</returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPurgeRetailOfflineTerminalStateData</Name>
				<Source><![CDATA[
    internal boolean shouldPurgeRetailOfflineTerminalStateData()
    {
        return RetailCdxFeatureControl::IsPurgeRetailOfflineTerminalStateDataEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldDeleteUsingTopN</Name>
				<Source><![CDATA[
    private static boolean shouldDeleteUsingTopN()
    {
        // Check if kernel flag is not disabled, and if our flag is enabled.
        return !isFlightEnabled("DisableSupportTopOnDeleteFromQueries")
        && RetailCdxDeleteFromUsingTopNFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSessionDataStoreForOrphanedOfflineDbs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete download sessions for offline databases not linked to any terminal.
    /// </summary>
    /// <param name = "cutOffDateTime">The datetime as marker to specify old download sessions.</param>
    /// <returns>The number of download sessions deleted.</returns>
    private static int64 deleteSessionDataStoreForOrphanedOfflineDbs(utcdatetime cutOffDateTime)
    {
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;
        RetailConnDatabaseProfile dataStore;
        RetailTerminalTable retailTerminalTable;
        int64 purgedSessionDataStoreCount;

        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 downloadSessionDataStore
                    where downloadSessionDataStore.ModifiedDateTime < cutOffDateTime
                exists join dataStore
                    where dataStore.DataStoreType == RetailCdxDataStoreType::OfflineDatabase
                notexists join retailTerminalTable
                    where dataStore.RecId == retailTerminalTable.OfflineDatabaseProfile;

                purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();
            }
            while (downloadSessionDataStore.RowCount() > 0);
        }
        else
        {
            delete_from downloadSessionDataStore
                where downloadSessionDataStore.ModifiedDateTime < cutOffDateTime
            exists join dataStore
                where dataStore.DataStoreType == RetailCdxDataStoreType::OfflineDatabase
            notexists join retailTerminalTable
                where dataStore.RecId == retailTerminalTable.OfflineDatabaseProfile;
        }

        purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();
        return purgedSessionDataStoreCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDownloadSessionRelatedData</Name>
				<Source><![CDATA[
    private static void deleteDownloadSessionRelatedData(utcdatetime cutOffDateTime)
    {
        // remove all processed records from RetailCDXDownloadSessionDataStore
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;
        int64 purgedSessionDataStoreCount, purgedSessionCount, failedPurgeSessionCount;
        str errMsg;
        System.Exception ex;

        ApplicationEventSource::EventWriteRetailCDXPurgeDownloadSessionHistoryStart(purgedSessionDataStoreCount, purgedSessionCount, failedPurgeSessionCount, errMsg);

        try
        {
            if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
            {
                do
                {
                    delete_from firstonly1000 downloadSessionDataStore
                          where (downloadSessionDataStore.Status == RetailCDXDownloadSessionStatus::Applied
                              || downloadSessionDataStore.Status == RetailCDXDownloadSessionStatus::Canceled)
                             && downloadSessionDataStore.ModifiedDateTime < cutOffDateTime;

                    purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();
                }
                while (downloadSessionDataStore.RowCount() > 0);
            }
            else
            {
                delete_from downloadSessionDataStore
                      where (downloadSessionDataStore.Status == RetailCDXDownloadSessionStatus::Applied
                          || downloadSessionDataStore.Status == RetailCDXDownloadSessionStatus::Canceled)
                         && downloadSessionDataStore.ModifiedDateTime < cutOffDateTime;
            }

            purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();

            RetailConnDatabaseProfile   unusedDefaultDatabase;
            RetailConnSchedulerJobTable schedulerJobTable;
            RetailScaleUnit scaleUnit;

            select unusedDefaultDatabase
                where unusedDefaultDatabase.Name == RetailCDXConstants::RetailCdxDataGroup_DefaultName;

            select firstOnly RecId from scaleUnit;

            // Delete download sessions for Default database if there is already a CSU
            if (unusedDefaultDatabase && scaleUnit && !unusedDefaultDatabase.ConnectionString)
            {
                if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
                {
                    do
                    {
                        delete_from firstonly1000 downloadSessionDataStore
                            where downloadSessionDataStore.DataStore == unusedDefaultDatabase.RecId
                            && downloadSessionDataStore.ModifiedDateTime < cutOffDateTime;

                        purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();
                    }
                    while (downloadSessionDataStore.RowCount() > 0);
                }
                else
                {
                    delete_from downloadSessionDataStore
                        where downloadSessionDataStore.DataStore == unusedDefaultDatabase.RecId
                        && downloadSessionDataStore.ModifiedDateTime < cutOffDateTime;
                }
            }

            purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();

            RetailCDXDownloadSession downloadSession;

            // Delete download sessions associated with non-existing scheduler jobs
            if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
            {
                do
                {
                    delete_from firstonly1000 downloadSessionDataStore
                        exists join downloadSession
                            where downloadSession.RecId == downloadSessionDataStore.Session
                            notexists join schedulerJobTable
                                where schedulerJobTable.JobId == downloadSession.JobId;

                    purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();
                }
                while (downloadSessionDataStore.RowCount() > 0);
            }
            else
            {
                delete_from downloadSessionDataStore
                    exists join downloadSession
                        where downloadSession.RecId == downloadSessionDataStore.Session
                        notexists join schedulerJobTable
                            where schedulerJobTable.JobId == downloadSession.JobId;
            }

            purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();

            // Addind purgedSessionDataStoreCount to Delete download sessions for offline databases not linked to any terminal.
            purgedSessionDataStoreCount += RetailCdxPurgeHistory::deleteSessionDataStoreForOrphanedOfflineDbs(cutOffDateTime);

            // find the cutoff datetime that is applicable for each job
            while select JobId, DataGroup
                from downloadSession
                group by downloadSession.JobID, downloadSession.DataGroup
                where downloadSession.Status == RetailCDXDownloadSessionStatus::Available ||
                      downloadSession.Status == RetailCDXDownloadSessionStatus::NoData
            {
                RetailCDXDownloadSession downloadSessionMax;
                utcdatetime jobCutOffDateTime = cutOffDateTime;

                select maxof(Session)
                    from downloadSessionMax
                    where downloadSessionMax.IsScheduledFullPackage == NoYes::Yes
                       && downloadSessionMax.Status == RetailCDXDownloadSessionStatus::Available
                       && downloadSessionMax.JobId == downloadSession.JobId
                       && downloadSessionMax.DataGroup == downloadSession.DataGroup;
    
                RetailCDXSessionNumber  maxSession = downloadSessionMax.Session;
                
                // If there is a full sync for that job ID and data group
                if (maxSession)
                {
                    select ModifiedDateTime
                        from downloadSessionMax
                        where downloadSessionMax.Session == maxSession;

                    // If the last full sync is beyond cut off datetime, we push the cut off further to avoid deleting delta syncs after the full sync
                    jobCutOffDateTime = downloadSessionMax.ModifiedDateTime < cutOffDateTime ? downloadSessionMax.ModifiedDateTime : cutOffDateTime;

                    RetailCDXDownloadSession downloadSessionBeforeFullSync;

                    // If there is a full sync, we can delete all expired download session datastore regardless of their status
                    if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
                    {
                        do
                        {
                            delete_from firstonly1000 downloadSessionDataStore
                                where downloadSessionDataStore.ModifiedDateTime < jobCutOffDateTime
                                exists join downloadSessionBeforeFullSync
                                    where downloadSessionBeforeFullSync.RecId == downloadSessionDataStore.Session
                                    && downloadSessionBeforeFullSync.Session < maxSession
                                    && downloadSessionBeforeFullSync.JobId == downloadSession.JobId
                                    && downloadSessionBeforeFullSync.DataGroup == downloadSession.DataGroup;

                            purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();
                        }
                        while (downloadSessionDataStore.RowCount() > 0);
                    }
                    else
                    {
                        delete_from downloadSessionDataStore
                            where downloadSessionDataStore.ModifiedDateTime < jobCutOffDateTime
                            exists join downloadSessionBeforeFullSync
                                where downloadSessionBeforeFullSync.RecId == downloadSessionDataStore.Session
                                && downloadSessionBeforeFullSync.Session < maxSession
                                && downloadSessionBeforeFullSync.JobId == downloadSession.JobId
                                && downloadSessionBeforeFullSync.DataGroup == downloadSession.DataGroup;
                    }

                    purgedSessionDataStoreCount += downloadSessionDataStore.RowCount();

                    // RetailCdxDownloadSession
                    int purgedSessionCountPerJob, failedPurgeSessionCountPerJob;

                    [purgedSessionCountPerJob, failedPurgeSessionCountPerJob, errMsg] = RetailCdxPurgeHistory::deleteDownloadSessions(downloadSession.JobID, downloadSession.DataGroup, jobCutOffDateTime);

                    purgedSessionCount += purgedSessionCountPerJob;
                    failedPurgeSessionCount += failedPurgeSessionCountPerJob;
                }
            }
        }
        catch (ex)
        {
            errMsg = ex.ToString();
        }
        finally
        {
            ApplicationEventSource::EventWriteRetailCDXPurgeDownloadSessionHistoryStop(purgedSessionDataStoreCount, purgedSessionCount, failedPurgeSessionCount, errMsg);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUploadSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete expired upload session data packages from blob storage. Any package created before "cutOffDateTime" is deleted.
    /// </summary>
    /// <param name = "cutOffDateTime">The datetime as marker to specify old upload sessions.</param>
    private static void deleteUploadSessions(utcdatetime cutOffDateTime)
    {
        RetailCDXUploadSession uploadSession;
        RetailConnDatabaseProfile dataStore;
        RetailCDXChangeRefTable2 sessionToDelete;
        str errMsg;
        System.Exception ex;
        int64 purgedSessionCount, failedPurgeSessionCount;

        // upload sessions
        ApplicationEventSource::EventWriteRetailCDXPurgeUploadSessionHistoryStart(purgedSessionCount, failedPurgeSessionCount, errMsg);

        while select UploadPath, RecId
            from uploadSession
            where (uploadSession.Status == RetailCDXUploadSessionStatus::Applied
                || uploadSession.Status == RetailCDXUploadSessionStatus::Canceled
                || uploadSession.Status == RetailCDXUploadSessionStatus::ReadFailed)
               && uploadSession.ModifiedDateTime < cutOffDateTime
            join RecId
            from dataStore
              where uploadSession.DataStore == dataStore.RecId
        {
            try
            {
                RetailCdxPurgeHistory::deleteSessionPackageFromBlob(uploadSession.RecId, uploadSession.DataGroup == 0 ? dataStore.DataGroup : uploadSession.DataGroup, RetailCDXDownloadUpload::Upload, uploadSession.UploadPath, sessionToDelete);
            }
            catch (ex)
            {
                failedPurgeSessionCount++;
                errMsg = ex.toString();
            }
        }

        // remove all upload sessions whose data store does not exist, because RetailCDXUploadSession does not have a cascade delete relation with RetailConnDatabaseProfile
        while select UploadPath, RecId
            from uploadSession
            notexists join dataStore
              where uploadSession.DataStore == dataStore.RecId
        {
            try
            {
                RetailCdxPurgeHistory::deleteSessionPackageFromBlob(uploadSession.RecId, uploadSession.DataGroup , RetailCDXDownloadUpload::Upload, uploadSession.UploadPath, sessionToDelete);
            }
            catch (ex)
            {
                failedPurgeSessionCount++;
                errMsg = ex.toString();
            }
        }

        try
        {
            if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
            {
                do
                {
                    delete_from firstonly1000 uploadSession
                      exists join sessionToDelete
                        where sessionToDelete.RefTableID == tableNum(RetailCDXUploadSession)
                           && sessionToDelete.RefRecID == uploadSession.RecId;

                    purgedSessionCount += uploadSession.RowCount();
                }
                while (uploadSession.RowCount() > 0);
            }
            else
            {
                delete_from uploadSession
                  exists join sessionToDelete
                    where sessionToDelete.RefTableID == tableNum(RetailCDXUploadSession)
                       && sessionToDelete.RefRecID == uploadSession.RecId;
            }

            purgedSessionCount += uploadSession.RowCount();

            if (sessionToDelete)
            {
                sessionToDelete.dispose();
            }

            if (failedPurgeSessionCount > 0)
            {
                Global::warning(strFmt("@Retail:CdxPackageStorageCleanUpUploadErrorMessage", errMsg));
            }
        }
        catch (ex)
        {
            errMsg = ex.ToString();
        }
        finally
        {
            ApplicationEventSource::EventWriteRetailCDXPurgeUploadSessionHistoryStop(purgedSessionCount, failedPurgeSessionCount, errMsg);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDownloadSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete expired download session data packages from blob storage.
    /// Any package created before "cutOffDateTime" is deleted, so long the package has been fully applied to all of its target channel databases.
    /// </summary>
    /// <param name = "jobId">The job Id that will delete expired download sessions.</param>
    /// <param name = "cutOffDateTime">The datetime as marker to specify old download sessions.</param>
    /// <returns>Container contains deletedDownloadSessionCountPerJob, failedToDeleteDownloadSessiohnCountPerJob, lastErrorMessage.</returns>
    private static container deleteDownloadSessions(RetailConnJobId jobId, RetailCDXDataGroupRefRecId dataGroupRecId, utcdatetime cutOffDateTime)
    {
        RetailCDXDownloadSessionDataStore downloadSessionDataStore;
        RetailCDXDownloadSession downloadSession;
        RetailCDXChangeRefTable2 sessionToDelete;
        str errMsg;
        System.Exception ex;
        int64 purgeSessionCountPerJob, failedPurgeSessiohnCountPerJob;
        int noDataRetentionDays = 3;
        utcdatetime noDataCutOffDateTime = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -noDataRetentionDays);

        // delete "No data" sessions
        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 downloadSession
                    where downloadSession.JobID == jobId
                        && downloadSession.DataGroup == dataGroupRecId
                        && downloadSession.Status == RetailCDXDownloadSessionStatus::NoData
                        && downloadSession.ModifiedDateTime < min(cutOffDateTime, noDataCutOffDatetime);

                purgeSessionCountPerJob += downloadSession.RowCount();
            } while (downloadSession.RowCount() > 0);
        }
        else
        {
            delete_from downloadSession
                where downloadSession.JobID == jobId
                    && downloadSession.DataGroup == dataGroupRecId
                    && downloadSession.Status == RetailCDXDownloadSessionStatus::NoData
                    && downloadSession.ModifiedDateTime < min(cutOffDateTime, noDataCutOffDatetime);
        }

        purgeSessionCountPerJob += downloadSession.RowCount();

        // download sessions
        // only delete the download sessions that all its target channel databases have consumed the package.
        while select DataGroup, DataFileOutputPath, RecId
            from downloadSession
            where downloadSession.JobID == jobId
               && downloadSession.DataGroup == dataGroupRecId
               && downloadSession.ModifiedDateTime < cutOffDateTime
            notexists join downloadSessionDataStore
            where downloadSession.RecId == downloadSessionDataStore.Session
        {
            // only catch CLR error and throw it to batch job log.
            try
            {
                RetailCdxPurgeHistory::deleteSessionPackageFromBlob(downloadSession.RecId, downloadSession.DataGroup, RetailCDXDownloadUpload::Download, downloadSession.DataFileOutputPath, sessionToDelete);
            }
            catch (ex)
            {
                failedPurgeSessiohnCountPerJob++;
                errMsg = ex.toString();
            }
        }

        // delete all download session older than cutoff datetime
        // cannot be "Started" which means CDX is still working on it.
        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 downloadSession
                    where downloadSession.DataGroup == dataGroupRecId
                        exists join sessionToDelete
                        where sessionToDelete.RefTableID == tableNum(RetailCDXDownloadSession)
                           && sessionToDelete.RefRecID == downloadSession.RecId;

                purgeSessionCountPerJob += downloadSession.RowCount();
            }
            while (downloadSession.RowCount() > 0);
        }
        else
        {
            delete_from downloadSession
                where downloadSession.DataGroup == dataGroupRecId
                    exists join sessionToDelete
                    where sessionToDelete.RefTableID == tableNum(RetailCDXDownloadSession)
                       && sessionToDelete.RefRecID == downloadSession.RecId;
        }

        purgeSessionCountPerJob += downloadSession.RowCount();

        if (sessionToDelete)
        {
            sessionToDelete.dispose();
        }

        if (failedPurgeSessiohnCountPerJob > 0)
        {
            Global::warning(strFmt("@Retail:CdxPackageStorageCleanUpDownloadErrorMessage", errMsg));
        }

        return [purgeSessionCountPerJob, failedPurgeSessiohnCountPerJob, errMsg];
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSessionPackageFromBlob</Name>
				<Source><![CDATA[
    private static void deleteSessionPackageFromBlob(RefRecId sessionRecId, RetailCDXDataGroupRefRecId dataGroupRecId, RetailCDXDownloadUpload direction, RetailCDXFilePathOrGuid fileIdOrFullPath, RetailCDXChangeRefTable2 sessionReadyToDelete)
    {
        RetailCDXPackageStore::deletePackage(dataGroupRecId, direction, fileIdOrFullPath);

        TableId tableId = direction == RetailCDXDownloadUpload::Download ? tableNum(RetailCDXDownloadSession) : tableNum(RetailCDXUploadSession);

        sessionReadyToDelete.initValue();
        sessionReadyToDelete.RefTableID = tableId;
        sessionReadyToDelete.RefRecID = sessionRecId;
        sessionReadyToDelete.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteUnusedUploadPath</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete unused upload path from blob storage.
    /// Any package created before "cutOffDateTime" is deleted.
    /// </summary>
    private static void deleteUnusedUploadPath()
    {
        str errMsg;
        System.Exception ex;
        int64 failedPurgeUnusedUploadPath;
        Counter countOfRecordsToDelete;

        // RetailCdxUploadUrlHistory, default retention days is 2
        int unusedPathRetentionDays = RetailCdxFeatureControl::getUnusedUploadPathRetentionDays();

        utcdatetime cutOffDateTime = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -1 * unusedPathRetentionDays);

        // any path that had not been used in the upload session will be deleted
        do
        {
            RetailCdxUploadPathHistory retailCdxUploadPathHistory;
            RetailCDXChangeRefTable2   uploadPathToDeleteTempTable;
            RetailCDXUploadSession     retailCDXUploadSession;

            countOfRecordsToDelete  = 0;
            RecordInsertList unusedUploadPathRecordInsertList = new RecordInsertList(uploadPathToDeleteTempTable.TableId, false, false, false, false, false, uploadPathToDeleteTempTable);
 
            while select DataGroup, UploadPath from retailCdxUploadPathHistory
                where retailCdxUploadPathHistory.CreatedDateTime < cutOffDateTime
                notexists join retailCDXUploadSession where retailCdxUploadPathHistory.UploadPath == retailCDXUploadSession.UploadPath
            {
                try
                {
                    RetailCDXPackageStore::deletePackage(retailCdxUploadPathHistory.DataGroup, RetailCDXDownloadUpload::Upload, retailCdxUploadPathHistory.UploadPath);

                    uploadPathToDeleteTempTable.initValue();

                    uploadPathToDeleteTempTable.RefTableID = tableNum(RetailCdxUploadPathHistory);
                    uploadPathToDeleteTempTable.RefRecID   = retailCdxUploadPathHistory.RecId;

                    unusedUploadPathRecordInsertList.add(uploadPathToDeleteTempTable);
 
                    countOfRecordsToDelete++;
 
                    if (countOfRecordsToDelete >= 4999)
                    {
                        break;
                    }
                }
                catch (ex)
                {
                    failedPurgeUnusedUploadPath++;
                    errMsg = ex.toString();
                }
            }
 
            if (countOfRecordsToDelete > 0)
            {
                try
                {
                    unusedUploadPathRecordInsertList.insertDatabase();

                    delete_from retailCdxUploadPathHistory
                        exists join uploadPathToDeleteTempTable
                        where uploadPathToDeleteTempTable.RefTableID == tableNum(RetailCdxUploadPathHistory)
                           && uploadPathToDeleteTempTable.RefRecID == retailCdxUploadPathHistory.RecId;
                }
                catch (ex)
                {
                    failedPurgeUnusedUploadPath++;
                    errMsg = ex.ToString();
                }
            }
        }
        while (countOfRecordsToDelete > 0);

        if (failedPurgeUnusedUploadPath > 0)
        {
            Global::warning(strFmt("@Retail:CdxPackageStorageCleanUpUploadErrorMessage", errMsg));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRetailOfflineTerminalStateData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes retail offline terminal state data.
    /// </summary>
    private static void deleteRetailOfflineTerminalStateData()
    {
        RetailOfflineTerminalStateData retailOfflineTerminalStateData;
        RetailOfflineTerminalState retailOfflineTerminalState;

        // Delete terminal data which is more than two days old and not latest.
        while select TerminalId, maxof(CreatedDateTime) from retailOfflineTerminalStateData group by retailOfflineTerminalStateData.TerminalId
        {
            RetailOfflineTerminalStateData  stateDataDelete;

            if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
            {
                do
                {
                    delete_from firstonly1000 stateDataDelete
                        where stateDataDelete.TerminalId == retailOfflineTerminalStateData.TerminalId &&
                        stateDataDelete.CreatedDateTime != retailOfflineTerminalStateData.CreatedDateTime;
                }
                while (stateDataDelete.RowCount() > 0);
            }
            else
            {
                delete_from stateDataDelete
                    where stateDataDelete.TerminalId == retailOfflineTerminalStateData.TerminalId &&
                    stateDataDelete.CreatedDateTime != retailOfflineTerminalStateData.CreatedDateTime;
            }
        }

        // Delete terminal data which is already serialized to RetailOfflineTerminalState table.
        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 retailOfflineTerminalStateData
                exists join retailOfflineTerminalState
                    where retailOfflineTerminalState.RetailOfflineTerminalStateData == retailOfflineTerminalStateData.RecId;
            }
            while (retailOfflineTerminalStateData.RowCount() > 0);
        }
        else
        {
            delete_from retailOfflineTerminalStateData
            exists join retailOfflineTerminalState
                where retailOfflineTerminalState.RetailOfflineTerminalStateData == retailOfflineTerminalStateData.RecId;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOrphanRetailCDXUploadSessionTracker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes orphaned/old records in RetailCDXUploadSessionTracker table.
    /// </summary>
    private static void deleteOrphanRetailCDXUploadSessionTracker()
    {
        RetailCDXUploadSessionTracker retailCDXUploadSessionTracker;

        // Records in RetailCDXUploadSessionTracker are deleted after the corresponding session is processed by the batch task (RetailCDXDataUpload_AX7)
        // This is just to make sure we delete any orphaned/old record which may not have been deleted by RetailCDXDataUpload_AX7
        // because of termination of the batch task etc...
        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 retailCDXUploadSessionTracker
                    where retailCDXUploadSessionTracker.CreatedDateTime < DateTimeUtil::addDays(DateTimeUtil::utcNow(), -7);
            }
            while (retailCDXUploadSessionTracker.RowCount() > 0);
        }
        else
        {
            delete_from retailCDXUploadSessionTracker
                where retailCDXUploadSessionTracker.CreatedDateTime < DateTimeUtil::addDays(DateTimeUtil::utcNow(), -7);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>PurgeOldSearchPublishingSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Purges old search publishing sessions.
    /// </summary>
    /// <param name = "cutOffDateTime">The datetime as marker to specify old sessions.</param>
    private static void PurgeOldSearchPublishingSessions(utcdatetime cutOffDateTime)
    {
        RetailSearchPublishingSessionData publishSession;

        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 publishSession
                    where publishSession.ModifiedDateTime < cutOffDateTime &&
                        publishSession.Status != RetailSearchPublishingSessionStatus::Queued &&
                        publishSession.Status != RetailSearchPublishingSessionStatus::InProgress;
            } while (publishSession.RowCount() > 0);
        }
        else
        {
            delete_from publishSession
                where publishSession.ModifiedDateTime < cutOffDateTime &&
                    publishSession.Status != RetailSearchPublishingSessionStatus::Queued &&
                    publishSession.Status != RetailSearchPublishingSessionStatus::InProgress;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purgeOrphanPropagationHistoryRecords</Name>
				<Source><![CDATA[
    private static void purgeOrphanPropagationHistoryRecords()
    {
        RetailCDXPropagatedHistoryTable propagationHistoryTable;
        RetailCDXDataGroup retailCDXDataGroup;
        if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
        {
            do
            {
                delete_from firstonly1000 propagationHistoryTable
                    notexists join retailCDXDataGroup
                    where retailCDXDataGroup.RecId == propagationHistoryTable.DataGroup;
            } while (propagationHistoryTable.RowCount() > 0);
        }
        else
        {
            delete_from firstonly1000 propagationHistoryTable
                notexists join retailCDXDataGroup
                where retailCDXDataGroup.RecId == propagationHistoryTable.DataGroup;
        }

        container tableHistoryToDelete;
        while select RefTableId, DataGroup from propagationHistoryTable
            group propagationHistoryTable.RefTableId, propagationHistoryTable.DataGroup
        {
            RetailCDXDataGroup datagroup = RetailCDXDataGroup::find(propagationHistoryTable.DataGroup);
            container dataDistributionQueries = RetailCdxDataDistributionQuery::getCacheBasedDataDistributionQueries(propagationHistoryTable.RefTableId, datagroup.ChannelSchema);
            boolean configuredForPropagationOptimization = false;
            for (int i=1; i <= conLen(dataDistributionQueries); i++)
            {
                RetailCdxDataDistributionQuery dataDistributionQuery = conPeek(dataDistributionQueries, i);
                Query query = new Query(dataDistributionQuery.PackedQuery);
                QueryBuildDataSource fullSyncFilteredRecordsTempTableDS = query.dataSourceTable(tableNum(RetailTmpCDXDataDistributionFilteredRecords));

                // if the node does not have parent node then it will not have filteredRecordsTempTableDS
                if (fullSyncFilteredRecordsTempTableDS)
                {
                    int parentNodeId = str2Int(fullSyncFilteredRecordsTempTableDS.rangeField(fieldNum(RetailTmpCDXDataDistributionFilteredRecords, NodeID)).value());
                    RetailCdxDataDistributionQuery parentDataDistributionQuery = RetailCdxDataDistributionQuery::find(parentNodeId, datagroup.ChannelSchema, true);
                    configuredForPropagationOptimization = parentDataDistributionQuery.IsOptimizedPropagation;
                }

                if (configuredForPropagationOptimization)
                {
                    break;
                }
            }

            if (!configuredForPropagationOptimization)
            {
                tableHistoryToDelete += [[propagationHistoryTable.RefTableId, datagroup.RecId]];
            }
        }

        for (int i=1; i <= conLen(tableHistoryToDelete); i++)
        {
            int tid; int64 dataGroupRecId;

            [tid, dataGroupRecId] = conPeek(tableHistoryToDelete, i);
            if (RetailCdxPurgeHistory::shouldDeleteUsingTopN())
            {
                do
                {
                    delete_from firstonly1000 propagationHistoryTable
                        where propagationHistoryTable.RefTableId == tid &&
                            propagationHistoryTable.DataGroup == dataGroupRecId;
                }
                while (propagationHistoryTable.RowCount() > 0);
            }
            else
            {
                delete_from propagationHistoryTable
                    where propagationHistoryTable.RefTableId == tid &&
                      propagationHistoryTable.DataGroup == dataGroupRecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>UpdateTimedOutSearchPublishingSessions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the session that were not modified for some time.
    /// </summary>
    private static void UpdateTimedOutSearchPublishingSessions()
    {
        RetailSearchPublishingSessionData publishSession;
        utcdatetime cutOffDateTime = DateTimeUtil::addDays(DateTimeUtil::utcNow(), -1);

        // Time out long running session.
        update_recordset publishSession
            setting Status = RetailSearchPublishingSessionStatus::TimedOut
            where  publishSession.ModifiedDateTime < cutOffDateTime &&
                publishSession.Status == RetailSearchPublishingSessionStatus::InProgress; 
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>