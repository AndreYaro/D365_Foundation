<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCREndOrder</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>MCREndOrder</c> class performs the end order functionality on a sales order.
/// </summary>
class MCREndOrder
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canMoveToBePicked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves the sales order status to the to be picked status if payments
    /// don't need to be submitted.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order for which the status should be changed.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The related sales order totals record.
    /// </param>
    /// <returns>
    /// true if the status should be changed to the to be picked status;
    /// otherwise, false.
    /// </returns>
    public static boolean canMoveToBePicked(SalesTable _salesTable, MCRSalesOrderTotals _salesOrderTotals)
    {
        boolean moveToBePicked = false;

        // If no payments, submit the order when there is no amount and the order is not on hold.
        if (!MCRCustPaymTable::findByRefRecIDRefTableID(_salesTable.RecId, _salesTable.TableId))
        {
            if ((_salesOrderTotals.getTotalOrder()          == 0)
                || (_salesTable.mcrSalesTable().Continuitychild
                && _salesOrderTotals.getContinuityPayNow()  == 0)
                && !MCRHoldCodeTrans::findActiveOrderHolds(_salesTable.SalesId))
            {
                moveToBePicked = true;
            }
        }

        if (moveToBePicked)
        {
            ttsBegin;
            _salesTable.selectForUpdate(true);
            SalesTable::MCRUpdateSalesStatus(_salesTable, SalesStatus::Backorder, NoYes::No);
            ttsCommit;
        }

        return moveToBePicked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>closeRecap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the order recap screen should close based on the
    /// new payment statuses.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record for which to validate the status of the recap screen.
    /// </param>
    /// <param name="_custPaymTotals">
    /// The customer payment totals record to use in validating whether the recap screen should
    /// close or not.
    /// </param>
    /// <returns>
    ///  An <c>MCRORderRecap</c> status that specifies whether the order is in balance or not.
    /// </returns>
    /// <remarks>
    /// Need to check for over credit limit because if an
    /// order has 2 payments, 1 is over credit and 1
    /// is on check hold this method will be called.
    /// If that is the case, then we do not want to close
    /// order recap.
    /// </remarks>
    public static MCROrderRecapStatus closeRecap(SalesTable _salesTable, MCRCustPaymTotals _custPaymTotals)
    {
        AmountCur   numOfPayments = 0;
        boolean     isOutofBalance;
        MCRSalesTable mcrSalesTable = _salesTable.mcrSalesTable();

        // Check the fields on the sales table.
        isOutofBalance = (mcrSalesTable.PaymOutOfBalance != MCRPaymOutOfBalance::None
                            && mcrSalesTable.OutOfBalanceReleased == MCROutOfBalanceReleaseType::None);

        // If it is out of balance then leave the form open.
        if (isOutofBalance)
        {
            return MCROrderRecapStatus::OpenError;
        }

        // If there were declined payments and it is not a future order.
        if (!_custPaymTotals.allPaymentsApproved(true) && !_salesTable.mcrIsOrderInFuture())
        {
            return MCROrderRecapStatus::OpenNoAuth;
        }

        if (MCRCustPaymTable::existsValidUnpostedPrepayAmount(_salesTable.TableId, _salesTable.RecId))
        {
            error('@MCR:SalesOrderRecapRetryMessage');

            return MCROrderRecapStatus::OpenError;
        }

        return MCROrderRecapStatus::CloseAuth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>continuityOrderProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes continuity payments that relate to the sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The current sales order.
    /// </param>
    /// <param name="_custPaymTotals">
    /// The <c>MCRCustPaymTotals</c> object.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The <c>MCRSalesOrderTotals</c> object.
    /// </param>
    public static void continuityOrderProcessing(SalesTable _salesTable,
                                                    MCRCustPaymTotals _custPaymTotals,
                                                    MCRSalesOrderTotals _salesOrderTotals)
    {
        MCRContinuityCustHeader     mcrContinuityCustHeader;

        mcrContinuityCustHeader = MCRContinuityCustHeader::findbySalesId(_salesTable.SalesId, false);

        // If authorization was successful and if the order is a continuity order
        // that is a pay all now scenario, copy the payment record for the continuitycustheader
        // with the continuity amount.
        if (mcrContinuityCustHeader.BillUpFront)
        {
            MCRCustPaymTable::continuityPaymProcessing(_custPaymTotals.allPaymentsApproved(),
                                                        _salesTable,
                                                        mcrContinuityCustHeader);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the specified sales order.
    /// </summary>
    /// <param name="_salesID">
    /// The <c>SalesId</c> of the sales order that should be ended.
    /// </param>
    /// <param name="_allowUserInput">
    /// A <c> Boolean</c> value that defines whether to allow user input when ending the order or not; optional.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The <c>MCRSalesOrderTotals</c> object to be used in ending the sales order; optional.
    /// </param>
    /// <param name="isOrderCancellation">
    /// A <c>Boolean</c> value defining whether the order is to be cancelled or not; optional.
    /// </param>
    /// <returns>
    /// true if the order ends successfully; otherwise, false.
    /// </returns>
    public static boolean endOrder(SalesID _salesID, boolean _allowUserInput = false,
                                        MCRSalesOrderTotals _salesOrderTotals = Null,
                                        boolean isOrderCancellation = false)
    {
        return MCREndOrder::endOrderForExternalGiftCard(_salesID, _allowUserInput, _salesOrderTotals, isOrderCancellation, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentNotRequired</Name>
				<Source><![CDATA[
    [Replaceable]
    protected static boolean isPaymentNotRequired(SalesTable _salesTable)
    {
        // Not requiring payments for:
        // Projects
        if (_salesTable.ProjId)
        {
            SalesTable::MCRUpdateSalesStatus(_salesTable, SalesStatus::Backorder, NoYes::Yes);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endOrderForExternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the specified sales order.
    /// </summary>
    /// <param name="_salesID">
    /// The <c>SalesId</c> of the sales order that should be ended.
    /// </param>
    /// <param name="_allowUserInput">
    /// A <c> Boolean</c> value that defines whether to allow user input when ending the order or not; optional.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The <c>MCRSalesOrderTotals</c> object to be used in ending the sales order; optional.
    /// </param>
    /// <param name="isOrderCancellation">
    /// A <c>Boolean</c> value defining whether the order is to be cancelled or not; optional.
    /// </param>
    /// <param name="_externalGiftCardMap">The map of external gift cards to be used in processing external gift card payment; optional.</param>
    /// <returns>
    /// true if the order ends successfully; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public static boolean endOrderForExternalGiftCard(SalesID _salesID, boolean _allowUserInput = false,
                                    MCRSalesOrderTotals _salesOrderTotals = Null,
                                    boolean isOrderCancellation = false,
                                    Map _externalGiftCardMap = null)
    {
        SalesTable                      salesTable;
        MCRCustPaymTotals               mcrCustPaymTotals;
        boolean                         retVal = true;
        MCRSalesTable                   mcrSalesTable;
        MCRCustTable                    mcrCustTable;

        setprefix("@MCR10404");

        salesTable = SalesTable::find(_salesID, true);

        if (MCREndOrder::isPaymentNotRequired(salesTable))
        {
            return true;
        }

        // Get the order totals if they are not already calculated.
        if (!_salesOrderTotals)
        {
            _salesOrderTotals = new MCRSalesOrderTotals(salesTable);
        }

        // Verify that sales order may be ended
        if (!MCREndOrder::validate(salesTable, true, _salesOrderTotals))
        {
            warning(strfmt("@MCR10879", salesTable.SalesId) );  // not ended
            return false;
        }

        // Only continue with the order if no active holds exists.
        if (!MCRHoldCodeTrans::findActiveOrderHolds(salesTable.SalesId))
        {
            // Can order be moved to in processing.
            if (!MCREndOrder::canMoveToBePicked(salesTable, _salesOrderTotals))
            {
                SalesTable::MCRUpdateSalesStatus(salesTable, SalesStatus::Backorder, NoYes::No);

                // Submit payments for authorization.
                mcrCustPaymTotals = MCRCustPaymTotals::construct(salesTable.TableId,
                                                                    salesTable.RecId,
                                                                    _salesOrderTotals);
                if (_externalGiftCardMap != null && _externalGiftCardMap.elements() > 0)
                {
                    mcrCustPaymTotals.paramExternalGiftCardMap(_externalGiftCardMap);
                }

                // If flight RetailPreventUpdateOfSalesHeaderPostingProfileFlight is enabled,
                // then update of salesTable's posting profile should be skipped.
                if (!RetailPreventUpdateOfSalesHeaderPostingProfileFlight::instance().isEnabled())
                {
                    // Determine the correct posting profile
                    MCREndOrder::setPostingProfile(salesTable);
                }

                retVal = MCREndOrder::submitOrderPayments(salesTable,
                                                            _salesOrderTotals,
                                                            mcrCustPaymTotals,
                                                            _allowUserInput);

                // only run logic if there are not already an error.
                if (retVal)
                {
                    salesTable.reread();

                    // We just submitted,
                    // but are there any credit card payments still considered "Not submitted"?
                    // This can be an expected result, and not an error
                    // (e.g. for future orders that will be submitted in the future)
                    // but we must still mark the order as OrderStopped = Yes.
                    if (MCRCustPaymTable::hasUnsubmittedCreditCardPayment(salesTable.RecId, salesTable.TableId))
                    {
                        SalesTable::MCRUpdateSalesStatus(salesTable, SalesStatus::Backorder, NoYes::Yes);
                    }
                    else
                    {
                        retVal = MCREndOrder::postPaymentSubmissionProcessing(salesTable,
                                                                                mcrCustPaymTotals,
                                                                                _salesOrderTotals,
                                                                                isOrderCancellation);
                    }
                }
                else
                {
                    // set the Do Not Process flag to false
                    SalesTable::MCRUpdateSalesStatus(salesTable, SalesStatus::Backorder, NoYes::Yes);
                    // Void authorizations for all payments in the Order
                    MCREndOrder::voidOrderPaymentsAuth(salesTable,
                                                        mcrCustPaymTotals);
                }
            }

            mcrSalesTable = salesTable.mcrSalesTable();
            if (retVal
                &&  MCRInstallmentPlanSalesTable::existSalesId(salesTable.SalesId))
            {
                mcrSalesTable.InstallmentOrderSubmitted = NoYes::Yes;
                ttsBegin;
                salesTable.mcrPackMCRSalesTable(mcrSalesTable);
                salesTable.update();
                ttsCommit;
            }

            if (retVal && mcrSalesTable.SourceId)
            {
                ttsBegin;
                mcrCustTable = MCRCustTable::findByCustAccount(salesTable.CustAccount, true);
                if (mcrCustTable)
                {
                    mcrCustTable.SourceIDLastOrdered = mcrSalesTable.SourceId;
                    mcrCustTable.doUpdate();
                }
                ttsCommit;
            }
        }
        else
        {
            // Order is on Hold.
            warning("@MCR10322");  // not ended
            Box::warning("@MCR10322");
            retVal = false;
        }
        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fraudEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether or not fraud has occurred in the sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record to check for fraud.
    /// </param>
    public static void fraudEngine(SalesTable _salesTable)
    {
        boolean             custFraudulent = false;
        CustTable           custTable;
        MCRCustTable        mcrCustTable;
        MCRHoldCodeTrans    mcrHoldCodeTrans;

        // There is no need to do fraud checking on a continuity child.
        if (_salesTable.mcrSalesTable().Continuitychild == NoYes::Yes)
        {
            return;
        }

        if (MCROrderParameters::find().MCRFraudCheck == NoYes::Yes) // checks that Fraud check is turned on.
        {
            // If the order has not already been checked for fraud hold, check if the customer is on fraud hold
            // or the sales order vilates any fraud rules.
            if (!MCRFraudCheckEngine::checkFraudAlreadyApplied(_salesTable.Salesid))
            {
                select firstonly AccountNum from custTable
                    where custTable.AccountNum == _salesTable.CustAccount
                    join CustStatus from mcrCustTable
                    where mcrCustTable.CustTable == custTable.RecId;
                // check if customer is already set to fraudulent.
                if (mcrCustTable.CustStatus != MCRCustStatus::Fraudulent) // Checks that the customer has not been put on fraud hold.
                {
                    custFraudulent = MCRFraudCheckEngine::FraudCheckEngineExecute(_salesTable);
                }
                else
                {
                    custFraudulent = true;  // sets the fraud status to true.
                }
            }
        }

        // Log the fraud detection and put the order on hold.
        if (custFraudulent)
        {
            mcrHoldCodeTrans.insertFraudHold(_salesTable);  // put order on hold.
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ftcEventsProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes FTC events.
    /// </summary>
    /// <param name="_isPaymAuthSuccessful">
    /// A <c>Boolean</c> value that specifies whether or not the payment authorization was successful.
    /// </param>
    /// <param name="_salesId">
    /// The <c>SalesId</c> of the sales order that has related FTC events to process.
    /// </param>
    /// <param name="_paymStatus">
    /// The payment status of the order.
    /// </param>
    /// <param name="_salesStatus">
    /// The sales status of the order.
    /// </param>
    public static void ftcEventsProcessing(boolean _isPaymAuthSuccessful,
                                            SalesId _salesId,
                                            MCRCustPaymStatus _paymStatus,
                                            SalesStatus _salesStatus)
    {
        if (_isPaymAuthSuccessful)
        {
            if (!MCRHoldCodeTrans::findActiveOrderHolds(_salesId)
            && _salesStatus == SalesStatus::Backorder)
            {
                // If the clock was never started for this sales order or
                // if the most recent event was a clock stopped.
                if (MCROrderEventTable::shouldClockStart(_salesId))
                {
                    MCREndOrder::writeFTCEvents(_salesId, MCROrderEventType::FTCClockStarted);
                }
            }
            else
            {
                if (MCROrderEventTable::shouldClockStop(_salesId))
                {
                    MCREndOrder::writeFTCEvents(_salesId, MCROrderEventType::FTCClockStopped);
                }
            }
        }
        else if (_paymStatus == MCRCustPaymStatus::Declined)
        {
            // If payment was declined write a clock stopped event if the clock was already
            // not stopped and if it was started.
            if (MCROrderEventTable::shouldClockStop(_salesId))
            {
                MCREndOrder::writeFTCEvents(_salesId, MCROrderEventType::FTCClockStopped);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateEventsAndLetters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Starts the FTC logging process for the current sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order.
    /// </param>
    /// <param name="_custPaymTotals">
    /// The <c>MCRCustPaymTotals</c> object.
    /// </param>
    /// <param name="isOrderCancellation">
    /// A Boolean value to indicate whether this was called from order cancellation.
    /// </param>
    public static void generateEventsAndLetters(SalesTable _salesTable,
                                                MCRCustPaymTotals _custPaymTotals,
                                                boolean isOrderCancellation = false)
    {
        // If Sales Type is sales order and the order is not a cancelled order
        // call ftcEventsProcessing to decide what FTC events to write.
        if (_salesTable.SalesStatus != SalesStatus::Canceled
            && _salesTable.SalesType == SalesType::Sales)
        {
            MCREndOrder::ftcEventsProcessing(_custPaymTotals.allPaymentsApproved(),
                                                _salesTable.SalesId,
                                                _custPaymTotals.getOverallPaymStatus(),
                                                _salesTable.SalesStatus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderRecap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits an order from the <c>MCRSalesOrderRecap</c> form.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order to be submitted.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The order total object related to the sales order; optional.
    /// </param>
    /// <param name="isOrderCancellation">
    /// A <c>Boolean</c> value that defines whether or not the order is set for cancellation; optional.
    /// </param>
    /// <returns>
    /// The <c>MCROrderRecapStatus</c> of the order after processing.
    /// </returns>
    public static MCROrderRecapStatus orderRecap(SalesTable _salesTable,
                                                    MCRSalesOrderTotals _salesOrderTotals = null,
                                                    boolean isOrderCancellation = false)
    {
        return MCREndOrder::orderRecapForExternalGiftCard(_salesTable, _salesOrderTotals, isOrderCancellation, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipPaymentsSubmission</Name>
				<Source><![CDATA[
    [Replaceable]
    protected static boolean shouldSkipPaymentsSubmission(SalesTable _salesTable)
    {
        // Not requiring payments for:
        // Projects or Intercompany orders
        if (MCROrderParameters::findCallCenterOrderParameters(
            fieldNum(RetailMCRChannelTable, MCREnableOrderCompletion),
            _salesTable.retailSalesTable().RetailChannel) && _salesTable.ProjId)
        {
            SalesTable::MCRUpdateSalesStatus(_salesTable, SalesStatus::Backorder, NoYes::Yes);
            return true;
        }
        else if (_salesTable.InterCompanyOrder)
        {
            if (RetailPaymentsEnablePaymentProcessingForInterCompanyOrdersFlight::instance().isEnabled() &&
                _salesTable.SalesType == SalesType::ReturnItem)
            {
                return false;
            }

            SalesTable::MCRUpdateSalesStatus(_salesTable, SalesStatus::Backorder, NoYes::No);

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>orderRecapForExternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits an order from the <c>MCRSalesOrderRecap</c> form.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order to be submitted.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The order total object related to the sales order; optional.
    /// </param>
    /// <param name="isOrderCancellation">
    /// A <c>Boolean</c> value that defines whether or not the order is set for cancellation; optional.
    /// </param>
    /// <param name="_externalGiftCardMap">The map of external gift cards to be used in processing external gift card payment; optional.</param>
    /// <returns>
    /// The <c>MCROrderRecapStatus</c> of the order after processing.
    /// </returns>
    [Hookable(false)]
    public static MCROrderRecapStatus orderRecapForExternalGiftCard(SalesTable _salesTable,
                                                    MCRSalesOrderTotals _salesOrderTotals = null,
                                                    boolean isOrderCancellation = false,
                                                    Map _externalGiftCardMap = null)
    {
        MCRCustPaymTotals   mcrCustPaymTotals;
        SalesTable          salesTableCurrent;

        if (MCREndOrder::shouldSkipPaymentsSubmission(_salesTable))
        {
            return MCROrderRecapStatus::Close;
        }

        // Only need to process if the order type is sales or return.
        if (_salesTable.SalesType != SalesType::Sales
            && _salesTable.SalesType != SalesType::ReturnItem
            && _salesTable.SalesType != SalesType::Subscription)
        {
            // return status of close
            return MCROrderRecapStatus::Close;
        }

        salesTableCurrent = SalesTable::find(_salesTable.SalesId);

        if (salesTableCurrent.SalesStatus == SalesStatus::Canceled
            && !MCRCustPaymTable::exists(_salesTable.TableId, _salesTable.RecId))
        {
            // return close, since no more processing needed.
            return MCROrderRecapStatus::Close;
        }

        mcrCustPaymTotals = MCRCustPaymTotals::construct(_salesTable.TableId,
                                                            _salesTable.RecId,
                                                            _salesOrderTotals);

        try
        {
            // Prompt the user to allow over-/underpayment.  If allowed (or if
            //  not applicable), then end the order.
            if (mcrCustPaymTotals.promptOverUnderPaym())
            {
                RetailSharedParameters retailSharedParameters = RetailSharedParameters::find();
                boolean isAdvancedExternalGiftCardFeatureEnabled =
                    retailSharedParameters && retailSharedParameters.EnableAdvancedExternalGiftCard? true: false;

                // NOTE: To ensure that current extensions work as expected we first call the MCREndOrder::endOrder
                // After which we call the new method MCREndOrder::endOrderForExternalGiftCard.
                if (!isAdvancedExternalGiftCardFeatureEnabled
                        && MCREndOrder::endOrder(_salesTable.SalesId, true, _salesOrderTotals, isOrderCancellation))
                {
                    _salesTable.reread();
                    return MCREndOrder::closeRecap(_salesTable, mcrCustPaymTotals);
                }
                else if (isAdvancedExternalGiftCardFeatureEnabled
                    && MCREndOrder::endOrderForExternalGiftCard(_salesTable.SalesId, true, _salesOrderTotals, isOrderCancellation, _externalGiftCardMap))
                {
                    _salesTable.reread();
                    return MCREndOrder::closeRecap(_salesTable, mcrCustPaymTotals);
                }
                else
                {
                    _salesTable.reread();
                    // If order on fraud hold and not cleared, we will close the recap form.
                    // We also close the recap form if there is a check On hold. The _ignore flag will bypass validation for Checks,
                    // closing the form without changing the stop error resulted from the hold
                    if (_salesTable.mcrFraudHold(false, true) || mcrCustPaymTotals.allPaymentsApproved(true))
                    {
                        return MCROrderRecapStatus::Close;
                    }
                }
            }

            return MCROrderRecapStatus::OpenError;
        }
        catch
        {
            // Continue executing this method if an exception is thrown
            // Some data might have been updated before the exception was thrown --
            // always re-execute the query to obtain the updated data.
            Global::exceptionTextFallThrough();
        }

        // Final return, should not be executed.
        return MCROrderRecapStatus::Close;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPaymentSubmissionProcessing</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the order after the payments have been submitted.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record that needs to be processed.
    /// </param>
    /// <param name="_mcrCustPaymTotals">
    /// The customer payment totals related to the sales order.
    /// </param>
    /// <param name="_mcrSalesOrderTotals">
    /// The sales order totals object related to the sales order.
    /// </param>
    /// <param name="isOrderCancellation">
    /// A <c>Boolean</c> value defining whether the order is to be cancelled or not; optional.
    /// </param>
    /// <returns>
    /// true if the post payment processing completes successfully; otherwise, false.
    /// </returns>
    public static boolean postPaymentSubmissionProcessing(SalesTable _salesTable,
                                                            MCRCustPaymTotals _mcrCustPaymTotals,
                                                            MCRSalesOrderTotals _mcrSalesOrderTotals,
                                                            boolean isOrderCancellation = false)
    {
        boolean                     retVal = true;

        if (_salesTable.mcrSalesTable().ContinuityOrder)
        {
            MCREndOrder::continuityOrderProcessing(_salesTable, _mcrCustPaymTotals, _mcrSalesOrderTotals);
        }

        MCREndOrder::generateEventsAndLetters(_salesTable, _mcrCustPaymTotals, isOrderCancellation);

        _salesTable.reread();

        if (MCRPaymentReview::shouldRefund(_mcrCustPaymTotals))
        {
            MCRPaymentReview::generateRefund(_salesTable, _mcrCustPaymTotals);
            
            // Generated refund will get processed only if the flight is enabled.
            if (RetailPaymentProcessGeneratedRefundFlight::instance().isEnabled())
            {
                _mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostOnlyPrepays);
            }

            _salesTable.reread();
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Sets the posting profile of the sales order if it is
    /// different.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> buffer to update the posting profile.
    /// </param>
    public static void setPostingProfile(SalesTable _salesTable)
    {
        PostingProfile  newProfile;
        SalesTable      salesTableUpdate = _salesTable;

        newProfile = SalesTable::mcrCalculatePostingProfile(salesTableUpdate, false);

        if (salesTableUpdate.PostingProfile != newProfile)
        {
            ttsBegin;
            salesTableUpdate.selectForUpdate(true);
            salesTableUpdate.reread();
            salesTableUpdate.PostingProfile = newProfile;
            salesTableUpdate.update();
            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>submitOrderPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Submits payments for the installment plan and
    /// payments at the order level.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order record that has payments to be submitted.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The alses order totals object related to the sales order.
    /// </param>
    /// <param name="_mcrCustPaymTotals">
    /// The customer payment totals for the customer on the sales order.
    /// </param>
    /// <param name="_allowUserInput">
    /// A <c> Boolean</c> value that defines whether to allow user input when ending the order or not; optional.
    /// </param>
    /// <returns>
    /// true if order payments are submitted successfully; otherwise, false.
    /// </returns>
    public static boolean submitOrderPayments(SalesTable _salesTable,
                                                MCRSalesOrderTotals _salesOrderTotals,
                                                MCRCustPaymTotals _mcrCustPaymTotals,
                                                boolean _allowUserInput)
    {
        CustPaymSchedLine               custPaymSchedLine;
        MCRCustPaymTotals               mcrCustPaymTotals_Installment;
        MCRInstallmentPlanSalesTable    mcrInstallmentPlanSalesTable;

        // Submit payments for authorization.
        if (!mcrCustPaymTotals::submitPaymFutureOrder(_salesTable.RecId))
        {
            // If future orders are enabled, and this payment should not be submitted yet
            // because the order is in the future, then we can safely stop here
            // and tell the caller the submission was successful (because
            // there was nothing to submit at this time).
            return true;
        }

        boolean retVal;
        if (MCRCustPaymTotals::arePaymentsSubmitable(_salesTable.RecId))
        {
            mcrInstallmentPlanSalesTable = MCRInstallmentPlanSalesTable::findSalesId(_salesTable.SalesId);
            if (mcrInstallmentPlanSalesTable
                && MCROrderparameters::find().InstallmentAuth == MCRInstallmentAuth::OrderDate)
            {
                custPaymSchedLine = CustPaymSchedLine::MCRFindFirstIntallmentSchedLine(_salesTable.SalesId, mcrInstallmentPlanSalesTable.PaymSchedId);
                if (custPaymSchedLine)
                {
                    mcrCustPaymTotals_Installment = MCRCustPaymTotals::construct(custPaymSchedLine.TableId, custPaymSchedLine.RecId);
                    // Process installment payment
                    retVal = mcrCustPaymTotals_Installment.processPayments(MCRProcessPaymAction::PostOnlyPrepays);
                }
            }
            // Process header payments.
            retVal = _mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostOnlyPrepays, _allowUserInput);
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidOrderPaymentsAuth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Voids Authorizations for all credit card payments in the order
    /// When one of the payments is decliend, we use this method to
    /// revert all payment authorizations for the same sales order
    /// as a new percentage composition will be needed across the
    /// split payment.
    /// </summary>
    /// <param name = "salesTable">The Sales Table Record buffer.</param>
    /// <param name = "mcrCustPaymTotals">the Payments on the Order.</param>
    public static void voidOrderPaymentsAuth(SalesTable salesTable,
                                             MCRCustPaymTotals mcrCustPaymTotals)
    {
        MCRCustPaymTable                mcrCustPaymTable;
        CreditCardAuthTrans             creditCardAuthTrans;
        ReasonCode                      reasonCode;

        CreditCardAuthTrans::updateExpiredApproval(salesTable.SalesId);

        while select creditCardAuthTrans
              where creditCardAuthTrans.SalesId == salesTable.SalesId &&
                    creditCardAuthTrans.ApprovalType == CreditCardOperation::Authorize &&
                    !creditCardAuthTrans.ApprovalExpired &&
                    !creditCardAuthTrans.ApprovalVoid &&
                    creditCardAuthTrans.ProcessorStatus == CreditCardProcessorStatus::Approved
        {
            // Void  Credit Card Pre-Authorization with Payment Service
            CreditCardProcess::mcrDoVoidPreAuth(creditCardAuthTrans);

            // Update MCRCustPaymTable and generate Payment event.
            MCRCustPaymTable::cancelPaym(creditCardAuthTrans.MCRPaymRecId, "Void", false, false);
            mcrCustPaymTable = MCRCustPaymTable::findByRecID(creditCardAuthTrans.MCRPaymRecId, true);
            if (mcrCustPaymTable)
            {
                ttsbegin;
                mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
                mcrCustPaymTable.update();
                ttscommit;
            }

            // Generate ftcEvents
            MCREndOrder::generateEventsAndLetters(salesTable, mcrCustPaymTotals, false);
            salesTable.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a sales order may be ended.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order to be validated.
    /// </param>
    /// <param name="_showErrors">
    /// A <c>Boolean</c> value that defines whether errors should be shown or not; optional.
    /// </param>
    /// <param name="_salesOrderTotals">
    /// The sales order total object related to the sales order.
    /// </param>
    /// <returns>
    /// true if okay to end; otherwise, false.
    /// </returns>
    public static boolean validate(SalesTable _salesTable,
                                    boolean _showErrors = true,
                                    MCRSalesOrderTotals _salesOrderTotals = Null)
    {
        MCRCustPaymTotals       mcrCustPaymTotals;
        MCRCustPaymTable        mcrCustPaymRec;
        SalesLine               salesLine;
        MCRContinuityCustHeader MCRContinuityCustHeader;
        MCRSalesTable           mcrSalesTable = _salesTable.mcrSalesTable();

        setprefix("@MCR10404");

        // Only sales orders of type "Sales order" or "Returned item" may be
        // submitted.
        if (_salesTable.SalesType != SalesType::Sales
            && _salesTable.SalesType != SalesType::ReturnItem
            && _salesTable.SalesType != SalesType::Subscription)
        {
            if (_showErrors)
            {
                error(strfmt("@MCR11881",
                        enum2str(SalesType::Sales),
                        enum2str(SalesType::ReturnItem),
                        _salesTable.SalesId,
                        enum2str(_salesTable.SalesType)));
            }

            return false;
        }

        // status must be "open order" and has active order holds
        if ((_salesTable.SalesStatus != SalesStatus::Backorder && MCRHoldCodeTrans::findActiveOrderHolds(_salesTable.SalesId))
            || _salesTable.SalesStatus == SalesStatus::Canceled)
        {
            if (_showErrors)
            {
                error(strfmt("@MCR10877",
                        enum2str(SalesStatus::Backorder),
                        enum2str(_salesTable.SalesStatus)));
            }

            return false;
        }

        // If a sales order has a payment record that has an amount of zero
        // delete the record, provided it is not a continuity child.
        if (!mcrSalesTable.Continuitychild)
        {
            if (mcrSalesTable.ContinuityOrder == NoYes::Yes)
            {
                if (mcrSalesTable.ContinuityLineEval == MCRContinuityLineEval::PayAllLater)
                {
                    while select RecId from mcrCustPaymRec
                        where mcrCustPaymRec.RefRecId       == _salesTable.RecId
                            && mcrCustPaymRec.RefTableId    == _salesTable.TableId
                            && mcrCustPaymRec.Amount        == 0.0
                    {
                        MCRCustPaymTable::cancelPaym(mcrCustPaymRec.RecId);
                    }
                }
                // Loop over all bill up front continuity parents paid on
                // a payment schedule.
                while select SalesId, InventTransID from salesLine
                    where salesLine.SalesId == _salesTable.SalesId
                    join MCRContinuityCustHeader
                        where MCRContinuityCustHeader.InventTransId == salesLine.InventTransId
                        && MCRContinuityCustHeader.BillUpFront
                        && MCRContinuityCustHeader.PaymentScheduleId
                {
                    MCRContinuityCustHeader::recalcPaymentSchedLines(MCRContinuityCustHeader);
                }
            }
        }

        // Update payment amounts, so that an accurate total payment amount can
        //  be validated.
        mcrCustPaymTotals = MCRCustPaymTotals::construct(_salesTable.TableId, _salesTable.RecId, _salesOrderTotals);

        mcrCustPaymTotals.recalculatePaymAmounts();

        // Returns true if the fraud scores are higher than the minimum score allowed.
        MCREndOrder::fraudEngine(_salesTable);
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeFTCEvents</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes an FTC event with <c>SalesId</c> and the event type.
    /// </summary>
    /// <param name="_salesID">
    /// The <c>SalesId</c> of the sales order for which an event type must be created.
    /// </param>
    /// <param name="_MCROrderEventType">
    /// The event type that should be used on the FTC event.
    /// </param>
    public static void writeFTCEvents(SalesID _salesID, MCROrderEventType _MCROrderEventType)
    {
        MCROrderEventTable       mcrOrderEventTable;

        mcrOrderEventTable.insertFTCEvent(_salesID, _MCROrderEventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesOrderContainsZeroAmountPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether sales order contains a payment with 0 amount.
    /// </summary>
    /// <param name = "_SalesTable">
    /// sales table buffer.
    /// </param>
    /// <returns>
    /// True, if sales order contains payment with zero amount. Else, false.
    /// </returns>
    internal static boolean isSalesOrderContainsZeroAmountPayment(SalesTable _SalesTable)
    {
        MCRCustPaymTable mcrCustPaymLocal;

        select firstonly RecId from mcrCustPaymLocal
            where mcrCustPaymLocal.RefTableId == _SalesTable.TableId
               && mcrCustPaymLocal.RefRecId == _SalesTable.RecId
               && mcrCustPaymLocal.Status == MCRCustPaymStatus::NotSubmitted
               && mcrCustPaymLocal.Amount == 0;

        return mcrCustPaymLocal.RecId != 0;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>