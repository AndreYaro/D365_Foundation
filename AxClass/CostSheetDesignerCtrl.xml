<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CostSheetDesignerCtrl</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CostSheetDesignerCtrl
{
    #resAppl

    ImageListAppl_CostSheet     imageList;

    FormRun                     formRun;
    FormTreeControl             tree;
    FormDataSource              costSheetNodeTableDatasource;
    FormDataSource              costSheetCalculationBasisDatasource;
    FormDataSource              costSheetCalculationFactorDatasource;

    Map                         treeNodeStatus;
    Map                         treeNodeIdx2CostSheetNodeId;

    CostSheetId                 sheetId;
    CostSheet                   costSheet;
    CostSheetNode               currentNode;
    List                        clipboardPackedNodeList;
    CostSheetNodeId             newNodeId;
    int                         treePrevKeyDown;
    int                         treeLastDragOverIdx;
    int                         treeDraggedIdx;

    List                        selectedBOMCostGroupList;

    Dialog                      createNodeDialog;

    container                   originalPackedSheet;

    CostSheetLock               costSheetLock;
    boolean                     isReadOnly;

    const int                   contextMenuCut      = 1;
    const int                   contextMenuCopy     = 2;
    const int                   contextMenuPaste    = 3;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addStringFieldToDialog</Name>
				<Source><![CDATA[
    private DialogField addStringFieldToDialog(IdentifierName _name, str _label)
    {
        DialogField field = createNodeDialog.addField(_name);
        FormBuildStringControl control = field.control();
        control.label(_label);
        return field;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCopyNode</Name>
				<Source><![CDATA[
    public void actionCopyNode(int _sourceNodeIdx = 0)
    {
        if (!this.canCopyNode(_sourceNodeIdx))
        {
            return;
        }

        this.clearClipboard();

        if (_sourceNodeIdx)
        {
            if (_sourceNodeIdx != tree.getRoot())
            {
                clipboardPackedNodeList.addEnd(costSheet.findNode(this.treeNodeIdx2CostSheetNodeId(_sourceNodeIdx)).pack());
            }
        }
        else
        {
            int treeNodeIdx = tree.getFirstSelected();

            while (treeNodeIdx)
            {
                if (treeNodeIdx != tree.getRoot())
                {
                    clipboardPackedNodeList.addEnd(costSheet.findNode(this.treeNodeIdx2CostSheetNodeId(treeNodeIdx)).pack());
                }

                treeNodeIdx = tree.getNextSelected(treeNodeIdx);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCreateNode</Name>
				<Source><![CDATA[
    public void actionCreateNode()
    {
        #define.List(1)
        CostSheetNodeTable          costSheetNodeTable;
        CostSheetNodeCode           newCostSheetNodeCode;
        CostSheetNodeDescription    newCostSheetNodeDescription;
        SetEnumerator               nodeTypeEnumerator;

        if (!this.canCreateNode() ||
        (createNodeDialog != null && !createNodeDialog.closed())) // only one "Create new node" dialog may be open at any time
        {
            return;
        }

        CostSheetNodeId targetNodeId = this.treeNodeIdx2CostSheetNodeId(tree.getSelection());
        if (targetNodeId == 0)
        {
            return;
        }

        CostSheetNode targetNode = costSheet.findNode(targetNodeId);
        Set validNodeTypeSet = targetNode.validSubnodeTypeSet();
        CostSheetNode targetParentNode = costSheet.findNodeParent(targetNode);
        if (targetParentNode)
        {
            validNodeTypeSet = Set::union(validNodeTypeSet, targetParentNode.validSubnodeTypeSet());
        }

        CostSheetNodeType newCostSheetNodeType = CostSheetNodeType::Undefined;
        if (validNodeTypeSet.elements() == 1) // there is only one node type to select from - the dialog is not needed (e.g. a Price is created under the root node)
        {
            nodeTypeEnumerator = validNodeTypeSet.getEnumerator();
            nodeTypeEnumerator.moveNext();
            newCostSheetNodeType = nodeTypeEnumerator.current();
        }
        else
        {
            createNodeDialog = new Dialog("@SYS104690", this);
            DialogField dlgCostSheetNodeType = createNodeDialog.addField(enumStr(CostSheetNodeType));
            // customizing the combobox
            FormBuildComboBoxControl formComboBoxControl = dlgCostSheetNodeType.control();
            formComboBoxControl.enumType(0);
            formComboBoxControl.label("@SYS104691");
            formComboBoxControl.comboType(#List);
            formComboBoxControl.items(validNodeTypeSet.elements());

            Map comboBoxItem2NodeTypeMap = new Map(Types::Integer, Types::Enum);
            int comboBoxItemNumber = 1;
            nodeTypeEnumerator = validNodeTypeSet.getEnumerator();
            while (nodeTypeEnumerator.moveNext())
            {
                CostSheetNodeType validNodeType = nodeTypeEnumerator.current();
                formComboBoxControl.item(comboBoxItemNumber);
                formComboBoxControl.text(enum2str(validNodeType));
                comboBoxItem2NodeTypeMap.insert(comboBoxItemNumber, validNodeType);
                comboBoxItemNumber++;
            }

            DialogField dlgCostSheetNodeCode = this.addStringFieldToDialog(extendedTypeStr(CostSheetNodeCode), "@SYS6908");
            DialogField dlgCostSheetNodeDescription = this.addStringFieldToDialog(extendedTypeStr(CostSheetNodeDescription), "@SYS25589");

            if (createNodeDialog.run())
            {
                int selectedValue = dlgCostSheetNodeType.value() + 1;
                newCostSheetNodeType = comboBoxItem2NodeTypeMap.lookup(selectedValue);
                newCostSheetNodeCode = dlgCostSheetNodeCode.value();
                newCostSheetNodeDescription = dlgCostSheetNodeDescription.value();
            }
        }

        if (newCostSheetNodeType != CostSheetNodeType::Undefined)
        {
            costSheetNodeTable.clear();
            costSheetNodeTable.SheetId = costSheet.getSheetId();
            costSheetNodeTable.NodeId = this.newNodeId();
            costSheetNodeTable.Code   = (newCostSheetNodeCode ? newCostSheetNodeCode : enum2str(newCostSheetNodeType));
            costSheetNodeTable.Description = newCostSheetNodeDescription;
            costSheetNodeTable.Type   = newCostSheetNodeType;
            
            if (newCostSheetNodeType != CostSheetNodeType::Price)
            {
                costSheetNodeTable.PriceType = targetNode.getCostType();
            }

            this.addCostSheetNode(CostSheetNode::construct(costSheetNodeTable, 0, CostSheetModeStrategyEdit::construct()),
                               treeLastDragOverIdx ? treeLastDragOverIdx : tree.getSelection());
            formRun.selectionChangeHelper(tree.getSelection());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionCutNode</Name>
				<Source><![CDATA[
    public void actionCutNode(int _sourceNodeIdx = 0)
    {
        if (!this.canCutNode(_sourceNodeIdx))
        {
            return;
        }

        this.actionCopyNode(_sourceNodeIdx);
        this.actionDeleteNode(_sourceNodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionDeleteNode</Name>
				<Source><![CDATA[
    public void actionDeleteNode(int _sourceNodeIdx = 0)
    {
        CostSheetNode       selectedNode;
        CostSheetNode       parentOfSelectedNode;

        if (!this.canDeleteNode(_sourceNodeIdx))
        {
            return;
        }

        Set removedNodeIdSet = new Set(Types::Integer);

        if (_sourceNodeIdx)
        {
            if (_sourceNodeIdx != tree.getRoot())
            {
                selectedNode = costSheet.findNode(this.treeNodeIdx2CostSheetNodeId(_sourceNodeIdx));
                if (selectedNode)
                {
                    parentOfSelectedNode = costSheet.findNodeParent(selectedNode);

                    if (parentOfSelectedNode != null)
                    {
                        removedNodeIdSet = Set::union(removedNodeIdSet, costSheet.removeSubnode(parentOfSelectedNode, selectedNode));
                    }
                }
            }
        }
        else
        {
            int treeNodeIdx = tree.getFirstSelected();
            while (treeNodeIdx)
            {
                if (treeNodeIdx != tree.getRoot())
                {
                    selectedNode = costSheet.findNode(this.treeNodeIdx2CostSheetNodeId(treeNodeIdx));
                    if (selectedNode)
                    {
                        parentOfSelectedNode = costSheet.findNodeParent(selectedNode);

                        if (parentOfSelectedNode != null)
                        {
                            removedNodeIdSet = Set::union(removedNodeIdSet, costSheet.removeSubnode(parentOfSelectedNode, selectedNode));
                        }
                    }
                }

                treeNodeIdx = tree.getNextSelected(treeNodeIdx);
            }
        }

        SetEnumerator removedNodeEnumerator = removedNodeIdSet.getEnumerator();
        while (removedNodeEnumerator.moveNext())
        {
            CostSheetNodeId removedNodeId = removedNodeEnumerator.current();
            int removedTreeNodeIdx = this.costSheetNodeId2TreeNodeIdx(removedNodeId);

            if (removedTreeNodeIdx != 0)
            {
                tree.delete(removedTreeNodeIdx);
                treeNodeStatus.remove(removedTreeNodeIdx);
                treeNodeIdx2CostSheetNodeId.remove(removedTreeNodeIdx);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>actionPasteNode</Name>
				<Source><![CDATA[
    public void actionPasteNode(int _targetNodeIdx = tree.getSelection())
    {
        boolean clipboardEmpty = clipboardPackedNodeList == null || clipboardPackedNodeList.elements() == 0;

        if (!this.canPasteNode() || clipboardEmpty)
        {
            return;
        }

        ListEnumerator clipboardEnumerator = clipboardPackedNodeList.getEnumerator();

        while (clipboardEnumerator.moveNext())
        {
            CostSheetNode clipboardCostSheetNode = CostSheetNode::create(clipboardEnumerator.current());
            newNodeId = CostSheet::nextNodeId(clipboardCostSheetNode.resetNodeId(this.newNodeId()));

            this.addCostSheetNode(clipboardCostSheetNode, _targetNodeIdx);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateCostSheetCalculationFactor</Name>
				<Source><![CDATA[
    public void activateCostSheetCalculationFactor()
    {
        Args args = new Args();

        args.record(costSheetCalculationFactorDatasource.cursor());
        args.parmObject(costSheet);

        new MenuFunction(menuitemActionStr(InventPriceCalcFactorActivation), MenuItemType::Action).run(args);

        costSheetCalculationFactorDatasource.research();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCostSheetNode</Name>
				<Source><![CDATA[
    boolean addCostSheetNode(CostSheetNode _newCostSheetNode, int _targetIdx)
    {
        CostSheetNode      targetNode;
        int                 newTreeNodeIdx;
        CostSheetNode      targetParentNode;

        if (_targetIdx <= 0)
        {
            return false;
        }

        CostSheetNodeId targetNodeId = this.treeNodeIdx2CostSheetNodeId(_targetIdx);

        if (targetNodeId > 0)
        {
            targetNode = costSheet.findNode(targetNodeId);
            if (targetNode)
            {
                targetParentNode = costSheet.findNodeParent(targetNode);
            }
        }

        if (targetNode == null)
        {
            return false;
        }

        this.formRunLock();
        boolean added = false;
        if (targetNode.canHaveSubnode(_newCostSheetNode))
        {
            costSheet.addSubnode(targetNode, _newCostSheetNode);
            this.setNode(_targetIdx, targetNode.hasSubnodes());

            if (treeNodeStatus.exists(_targetIdx))
            {
                newTreeNodeIdx = tree.add(_targetIdx,
                                      0,
                                      _newCostSheetNode.toString(),
                                      imageList.image(_newCostSheetNode.getImage()));

                this.setNode(newTreeNodeIdx, _newCostSheetNode.hasSubnodes());
                treeNodeIdx2CostSheetNodeId.insert(newTreeNodeIdx, _newCostSheetNode.getNodeId());
                treeNodeStatus.insert(_targetIdx, 1);
            }
            else
            {
                tree.expand(_targetIdx);
            }

            added = true;
        }
        else if (targetParentNode && targetParentNode.canHaveSubnode(_newCostSheetNode))
        {
            costSheet.addSubnode(targetParentNode, _newCostSheetNode, this.treeNodeIdx2CostSheetNodeId(_targetIdx));
            int targetParentNodeIdx = this.costSheetNodeId2TreeNodeIdx(targetParentNode.getNodeId());
            this.setNode(targetParentNodeIdx, targetParentNode.hasSubnodes());

            if (treeNodeStatus.exists(targetParentNodeIdx))
            {
                newTreeNodeIdx = tree.add(targetParentNodeIdx,
                                      _targetIdx,
                                      _newCostSheetNode.toString(),
                                      imageList.image(_newCostSheetNode.getImage()));

                this.setNode(newTreeNodeIdx, _newCostSheetNode.hasSubnodes());
                treeNodeIdx2CostSheetNodeId.insert(newTreeNodeIdx, _newCostSheetNode.getNodeId());
                treeNodeStatus.insert(targetParentNodeIdx, 1);
            }
            else
            {
                tree.expand(targetParentNodeIdx);
            }

            added = true;
        }

        if (added)
        {
            tree.select(this.costSheetNodeId2TreeNodeIdx(_newCostSheetNode.getNodeId()));
            this.updateCurrentNode();
        }

        this.formRunUnLock();

        return added;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOneNode</Name>
				<Source><![CDATA[
    protected void buildOneNode(int _parentTreeNodeIdx)
    {
        int                     newTreeNodeIdx;

        if (_parentTreeNodeIdx)
        {
            CostSheetNodeComposite parentNode = costSheet.findNode(this.treeNodeIdx2CostSheetNodeId(_parentTreeNodeIdx));
            ListEnumerator subnodeEnumerator = parentNode.getSubnodeEnumerator();
            while (subnodeEnumerator.moveNext())
            {
                CostSheetNode subnode = subnodeEnumerator.current();

                newTreeNodeIdx = tree.add(_parentTreeNodeIdx,
                                      0,
                                      subnode.toString(),
                                      imageList.image(subnode.getImage()));

                this.setNode(newTreeNodeIdx, subnode.hasSubnodes());

                treeNodeIdx2CostSheetNodeId.insert(newTreeNodeIdx, subnode.getNodeId());
            }
            treeNodeStatus.insert(_parentTreeNodeIdx, 1);
        }
        else
        {
            newTreeNodeIdx = tree.add(0,
                                  0,
                                  costSheet.getRootNode().toString(),
                                  imageList.image(costSheet.getRootNode().getImage()));

            this.setNode(newTreeNodeIdx, costSheet.getRootNode().hasSubnodes());

            treeNodeIdx2CostSheetNodeId.insert(newTreeNodeIdx, costSheet.getRootNode().getNodeId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCopyNode</Name>
				<Source><![CDATA[
    protected boolean canCopyNode(int _sourceNodeIdx = 0)
    {
        boolean ret;

        if (isReadOnly)
        {
            return false;
        }

        if (_sourceNodeIdx)
        {
            ret = _sourceNodeIdx != tree.getRoot();
        }
        else
        {
            ret = !(tree.getSelectedCount() == 1
             && tree.getSelection() == tree.getRoot());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateNode</Name>
				<Source><![CDATA[
    public boolean canCreateNode(int _sourceNodeIdx = 0)
    {
        if (isReadOnly)
        {
            return false;
        }

        boolean ret = _sourceNodeIdx ? true : tree.getSelectedCount() == 1;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCutNode</Name>
				<Source><![CDATA[
    protected boolean canCutNode(int _sourceNodeIdx = 0)
    {
        boolean ret;

        if (isReadOnly)
        {
            return false;
        }

        if (_sourceNodeIdx)
        {
            ret = _sourceNodeIdx != tree.getRoot();
        }
        else
        {
            ret = !(tree.getSelectedCount() == 1
             && tree.getSelection() == tree.getRoot());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteNode</Name>
				<Source><![CDATA[
    public boolean canDeleteNode(int _sourceNodeIdx = 0)
    {
        boolean ret;

        if (isReadOnly)
        {
            return false;
        }

        if (_sourceNodeIdx)
        {
            ret = _sourceNodeIdx != tree.getRoot();
        }
        else
        {
            ret = !(tree.getSelectedCount() == 1
             && tree.getSelection() == tree.getRoot());
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPasteNode</Name>
				<Source><![CDATA[
    protected boolean canPasteNode()
    {
        if (isReadOnly)
        {
            return false;
        }

        boolean ret = clipboardPackedNodeList
       && clipboardPackedNodeList.elements() > 0;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearClipboard</Name>
				<Source><![CDATA[
    public void clearClipboard()
    {
        clipboardPackedNodeList = new List(Types::Container);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTree</Name>
				<Source><![CDATA[
    public void clearTree()
    {
        tree.deleteAll();

        treeNodeStatus  = new Map(Types::Integer, Types::Integer);
        treeNodeIdx2CostSheetNodeId = new Map(Types::Integer, Types::Integer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>costSheetClose</Name>
				<Source><![CDATA[
    public void costSheetClose()
    {
        if (!isReadOnly)
        {
            costSheetLock.releaseLock();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costSheetIsModified</Name>
				<Source><![CDATA[
    public boolean costSheetIsModified()
    {
        return !costSheet.equal(CostSheet::create(originalPackedSheet));
    }

]]></Source>
			</Method>
			<Method>
				<Name>costSheetNodeId2TreeNodeIdx</Name>
				<Source><![CDATA[
    public int costSheetNodeId2TreeNodeIdx(CostSheetNodeId _nodeId)
    {
        int             treeNodeIdx;

        MapEnumerator enumerator = treeNodeIdx2CostSheetNodeId.getEnumerator();

        while (enumerator.moveNext())
        {
            if (enumerator.currentValue() == _nodeId)
            {
                treeNodeIdx = enumerator.currentKey();
                break;
            }
        }

        return treeNodeIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costSheetSave</Name>
				<Source><![CDATA[
    public boolean costSheetSave()
    {
        if (costSheetLock.hasValidLock())
        {
            this.updateCurrentNode();

            if (!costSheet.validate())
            {
                return checkFailed("@SYS104692");
            }

            originalPackedSheet = costSheet.pack();

            CostSheet::saveServer(originalPackedSheet);

            info("@SYS104696");

            return true;
        }
        else
        {
            return checkFailed("@SCM:CostingSheetSaveFailNoLock");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>costSheetValidate</Name>
				<Source><![CDATA[
    public boolean costSheetValidate()
    {
        boolean ret;

        this.updateCurrentNode();

        infolog.infoActionObject(this);

        if (costSheet.validate())
        {
            info("@SYS104693");
            ret = true;
        }
        else
        {
            ret = checkFailed("@SYS104692");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createContextMenu</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Add custom actions in the context menu for tree nodes.
    /// </summary>
    /// <returns>Context menu object.</returns>
    public ContextMenu createContextMenu()
    {
        ContextMenu menu = new ContextMenu();
        List options = new List(types::Class);

        if (this.canCutNode())
        {
            options.addEnd(ContextMenuOption::Create("@SYS63236",contextMenuCut));
        }

        if (this.canCopyNode())
        {
            options.addEnd(ContextMenuOption::Create("@SYS80350",contextMenuCopy));
        }

        if (this.canPasteNode())
        {
            options.addEnd(ContextMenuOption::Create("@SYS63237",contextMenuPaste));
        }

        menu.ContextMenuOptions(options);

        return menu;
    }

]]></Source>
			</Method>
			<Method>
				<Name>disableDatasources</Name>
				<Source><![CDATA[
    protected void disableDatasources()
    {
        costSheetNodeTableDatasource.allowCreate(false);
        costSheetNodeTableDatasource.allowEdit(false);
        costSheetNodeTableDatasource.allowDelete(false);

        costSheetCalculationBasisDatasource.allowCreate(false);
        costSheetCalculationBasisDatasource.allowEdit(false);
        costSheetCalculationBasisDatasource.allowDelete(false);

        costSheetCalculationFactorDatasource.allowCreate(false);
        costSheetCalculationFactorDatasource.allowEdit(false);
        costSheetCalculationFactorDatasource.allowDelete(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCalculationBasisSubtype</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets and gets the subtype values for the indirect cost basis lines.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the value.
    /// </param>
    /// <param name="_costSheetCalculationBasis">
    ///    The table buffer that represents the indirect cost basis line.
    /// </param>
    /// <param name="_subtype">
    ///    The subtype to assign to the basis line.
    /// </param>
    /// <returns>
    ///    The subtype of the indirect cost basis line.
    /// </returns>
    public CostCalculationSubtypeName editCalculationBasisSubtype(
        boolean                     _set,
        CostSheetCalculationBasis   _costSheetCalculationBasis,
        CostCalculationSubtypeName  _subtype)
    {
        if (!SysDictClass::isSuperclass(classIdGet(currentNode), classNum(CostSheetNodeCalculation)))
        {
            return '';
        }

        CostSheetNodeCalculation currentCalculationNode = currentNode;
        CostCalculationSubtypeName basisSubtype = currentCalculationNode.editBasisSubtype(_set, _costSheetCalculationBasis, _subtype);

        return basisSubtype;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCalculationSubtype</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets and gets the subtype values for the indirect cost nodes.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether to set the value.
    /// </param>
    /// <param name="_costSheetNodeTable">
    ///    The table buffer that represents the indirect cost node.
    /// </param>
    /// <param name="_subtype">
    ///    The subtype to assign to the indirect cost.
    /// </param>
    /// <returns>
    ///    The subtype of the indirect cost.
    /// </returns>
    public CostCalculationSubtypeName editCalculationSubtype(
        boolean                     _set,
        CostSheetNodeTable          _costSheetNodeTable,
        CostCalculationSubtypeName  _subtype)
    {
        if (!SysDictClass::isSuperclass(classIdGet(currentNode), classNum(CostSheetNodeCalculation)))
        {
            return '';
        }

        CostSheetNodeCalculation currentCalculationNode = currentNode;
        CostCalculationSubtypeName subtype = currentCalculationNode.editSubtype(_set, _costSheetNodeTable, _subtype);

        return subtype;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandNode</Name>
				<Source><![CDATA[
    public void expandNode(int _treeNodeIdx)
    {
        this.formRunLock();
        if (!treeNodeStatus.exists(_treeNodeIdx))
        {
            this.buildOneNode(_treeNodeIdx);
        }
        this.formRunUnLock();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formRunLock</Name>
				<Source><![CDATA[
    protected void formRunLock()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>formRunUnLock</Name>
				<Source><![CDATA[
    protected void formRunUnLock()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBasisCandidatesTmpTable</Name>
				<Source><![CDATA[
    public CostSheetTmpNodeTable getBasisCandidatesTmpTable()
    {
        CostSheetTmpNodeTable  costSheetTmpNodeTable;

        if (currentNode)
        {
            ListEnumerator nodeEnumerator = costSheet.getNodeEnumerator(CostSheetNodeListType::All);
            while (nodeEnumerator.moveNext())
            {
                CostSheetNode costSheetNode = nodeEnumerator.current();

                if (currentNode.getNodeId() != costSheetNode.getNodeId() &&
                !costSheet.isDescendantOf(currentNode, costSheetNode) &&
                currentNode.getCostType() == costSheetNode.getCostType()) // include only valid candidates for calculation basis
                {
                    costSheetTmpNodeTable.clear();
                    costSheetTmpNodeTable.Code = costSheetNode.getCode();
                    costSheetTmpNodeTable.Description = costSheetNode.getDescription();
                    costSheetTmpNodeTable.insert();
                }
            }
        }

        return costSheetTmpNodeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentCostType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a <c>CostPriceType</c> enumeration value that represents the branch of the costing sheet for
    ///    the current node.
    /// </summary>
    /// <returns>
    ///    A value in the <c>CostPriceType</c> enumeration.
    /// </returns>
    public CostPriceType getCurrentCostType()
    {
        CostPriceType costType = CostPriceType::Undefined;

        if (currentNode)
        {
            costType = currentNode.getCostType();
        }

        return costType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentNodeType</Name>
				<Source><![CDATA[
    public CostSheetNodeType getCurrentNodeType()
    {
        CostSheetNodeType nodeType = CostSheetNodeType::Undefined;

        if (currentNode)
        {
            nodeType = currentNode.getType();
        }

        return nodeType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormRun</Name>
				<Source><![CDATA[
    public FormRun getFormRun()
    {
        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageList</Name>
				<Source><![CDATA[
    public Imagelist imageList()
    {
        if (!imageList)
        {
            imageList = new ImageListAppl_CostSheet();
        }
        return imageList.imageList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init()
    {
        selectedBOMCostGroupList = new List(Types::Record);

        if (isReadOnly)
        {
            this.disableDatasources();
        }
        else
        {
            // Try to lock the costing sheet right before initializing it from the database.
            // If anybody is being editing it, the costing sheet will be loaded right after he realeases the lock.
            costSheetLock = CostSheetLock::construct();
            costSheetLock.holdLock();
        }

        costSheet = CostSheet::create(CostSheet::buildPackedServer(sheetId, CostSheetModeStrategyEdit::construct().pack()));
        originalPackedSheet = costSheet.pack();

        newNodeId = CostSheet::nextNodeId(costSheet.getMaxNodeId());

        tree.setImagelist(this.imageList());
        this.clearTree();
        this.expandNode(0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateComboBox</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates combobox with subtype values of the available indirect costs.
    /// </summary>
    /// <param name="_formControl">
    ///    The form combobox control.
    /// </param>
    public void populateComboBox(FormComboBoxControl _formControl)
    {
        if (!SysDictClass::isSuperclass(classIdGet(currentNode), classNum(CostSheetNodeCalculation)))
        {
            return;
        }

        CostSheetNodeCalculation currentCalculationNode = currentNode;
        currentCalculationNode.populateSubtype(_formControl);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newNodeId</Name>
				<Source><![CDATA[
    protected CostSheetNodeId newNodeId()
    {
        CostSheetNodeId ret = newNodeId;

        newNodeId += 1;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostSheetCalculationBasisDatasource</Name>
				<Source><![CDATA[
    public FormDataSource parmCostSheetCalculationBasisDatasource(FormDataSource _costSheetCalculationBasisDatasource = costSheetCalculationBasisDatasource)
    {
        costSheetCalculationBasisDatasource = _costSheetCalculationBasisDatasource;

        return costSheetCalculationBasisDatasource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostSheetCalculationFactorDatasource</Name>
				<Source><![CDATA[
    public FormDataSource parmCostSheetCalculationFactorDatasource(FormDataSource _costSheetCalculationFactorDatasource = costSheetCalculationFactorDatasource)
    {
        costSheetCalculationFactorDatasource = _costSheetCalculationFactorDatasource;

        return costSheetCalculationFactorDatasource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostSheetNodeTableDatasource</Name>
				<Source><![CDATA[
    public FormDataSource parmCostSheetNodeTableDatasource(FormDataSource _costSheetNodeTableDatasource = costSheetNodeTableDatasource)
    {
        costSheetNodeTableDatasource = _costSheetNodeTableDatasource;

        return costSheetNodeTableDatasource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFormRun</Name>
				<Source><![CDATA[
    public FormRun parmFormRun(FormRun _formRun = formRun)
    {
        formRun = _formRun;

        return formRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReadOnly</Name>
				<Source><![CDATA[
    public boolean parmReadOnly(boolean _readOnly = isReadOnly)
    {
        isReadOnly = _readOnly;

        return isReadOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSheetId</Name>
				<Source><![CDATA[
    public CostSheetId parmSheetId(CostSheetId _sheetId = sheetId)
    {
        sheetId = _sheetId;

        return sheetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTree</Name>
				<Source><![CDATA[
    public FormTreeControl parmTree(FormTreeControl _tree = tree)
    {
        tree = _tree;

        return tree;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveDatasourcesToNode</Name>
				<Source><![CDATA[
    private void saveDatasourcesToNode(CostSheetNode _node)
    {
        CostSheetNodeTable costSheetNodeTable = costSheetNodeTableDatasource ? costSheetNodeTableDatasource.cursor() : null;
        CostSheetCalculationBasis costSheetCalculationBasis = costSheetCalculationBasisDatasource ? costSheetCalculationBasisDatasource.cursor() : null;
        CostSheetCalculationFactor costSheetCalculationFactor = costSheetCalculationFactorDatasource ? costSheetCalculationFactorDatasource.cursor() : null;

        if (_node &&
        costSheetNodeTableDatasource &&
        costSheetCalculationBasisDatasource &&
        costSheetCalculationFactorDatasource)
        {
            _node.editCommon(tableNum(CostSheetNodeTable), true, costSheetNodeTable);
            _node.editCommon(tableNum(CostSheetCalculationBasis), true, costSheetCalculationBasis);
            _node.editCommon(tableNum(CostSheetCalculationFactor), true, costSheetCalculationFactor);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveNodeToDataSources</Name>
				<Source><![CDATA[
    private void saveNodeToDataSources(CostSheetNode _node)
    {
        CostSheetNodeTable costSheetNodeTable = costSheetNodeTableDatasource ? costSheetNodeTableDatasource.cursor() : null;
        CostSheetCalculationBasis costSheetCalculationBasis = costSheetCalculationBasisDatasource ? costSheetCalculationBasisDatasource.cursor() : null;
        CostSheetCalculationFactor costSheetCalculationFactor = costSheetCalculationFactorDatasource ? costSheetCalculationFactorDatasource.cursor() : null;

        if (costSheetNodeTableDatasource)
        {
            delete_from costSheetNodeTable;
            if (_node)
            {
                costSheetNodeTable.data(_node.editCommon(tableNum(CostSheetNodeTable)));
                costSheetNodeTable.insert();
            }
            costSheetNodeTableDatasource.research();
        }

        if (costSheetCalculationBasisDatasource)
        {
            delete_from costSheetCalculationBasis;
            if (_node)
            {
                costSheetCalculationBasis.setTmpData(_node.editCommon(tableNum(CostSheetCalculationBasis), false, costSheetCalculationBasis));
            }
            costSheetCalculationBasisDatasource.research();

            if (!costSheetCalculationBasis.RecId)
            {
                costSheetCalculationBasisDatasource.create(); // make the cursor visible even if there are no records
            }
        }

        if (costSheetCalculationFactorDatasource)
        {
            delete_from costSheetCalculationFactor;
            if (_node)
            {
                costSheetCalculationFactor.setTmpData(_node.editCommon(tableNum(CostSheetCalculationFactor), false, costSheetCalculationFactor));
            }
            costSheetCalculationFactorDatasource.research();

            if (!costSheetCalculationFactor.RecId)
            {
                costSheetCalculationFactorDatasource.create(); // make the cursor visible even if there are no records
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectContextMenuOption</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the context menu selection and calls the appropriate action method.
    /// </summary>
    /// <param name = "selectedOption">selected MenuOptionId provided by the override method</param>
    public void selectContextMenuOption(int selectedOption)
    {
        switch (selectedOption)
        {
            case contextMenuCut:
                this.actionCutNode();
                break;
            case contextMenuCopy:
                this.actionCopyNode();
                break;
            case contextMenuPaste:
                this.actionPasteNode();
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectTreeNode</Name>
				<Source><![CDATA[
    public void selectTreeNode(int _treeNodeIdx)
    {
        this.saveDatasourcesToNode(currentNode);

        CostSheetNodeId nodeId = this.treeNodeIdx2CostSheetNodeId(_treeNodeIdx);
        currentNode = costSheet.findNode(nodeId);

        this.saveNodeToDataSources(currentNode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNode</Name>
				<Source><![CDATA[
    protected void setNode(int _treeNodeIdx, boolean _children)
    {
        FormTreeItem treeItem = tree.getItem(_treeNodeIdx);
        treeItem.children(_children);

        tree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>treeNodeIdx2CostSheetNodeId</Name>
				<Source><![CDATA[
    public CostSheetNodeId treeNodeIdx2CostSheetNodeId(int _treeNodeIdx)
    {
        CostSheetNodeId    nodeId;

        if (_treeNodeIdx > 0 && treeNodeIdx2CostSheetNodeId.exists(_treeNodeIdx))
        {
            nodeId = treeNodeIdx2CostSheetNodeId.lookup(_treeNodeIdx);
        }

        return nodeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCurrentNode</Name>
				<Source><![CDATA[
    public void updateCurrentNode()
    {
        if (currentNode != null)
        {
            this.saveDatasourcesToNode(currentNode);
            // Save the node back to the datasources because the logic in the node classes
            // could change the values in the node, for example the code
            this.saveNodeToDataSources(currentNode);
            currentNode.update(costSheet.findNodeParent(currentNode));
            this.updateTreeNode(currentNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTreeNode</Name>
				<Source><![CDATA[
    private void updateTreeNode(CostSheetNode _node)
    {
        FormTreeItem            currentTreeItem = tree.getItem(this.costSheetNodeId2TreeNodeIdx(_node.getNodeId()));

        if (currentTreeItem)
        {
            currentTreeItem.text(_node.toString());
            tree.setItem(currentTreeItem);

            if (_node.hasSubnodes())
            {
                CostSheetNodeComposite compositeNode = _node;
                ListEnumerator subnodeEnum = compositeNode.getSubnodeEnumerator();
                while (subnodeEnum.moveNext())
                {
                    this.updateTreeNode(subnodeEnum.current());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrentNode</Name>
				<Source><![CDATA[
    public boolean validateCurrentNode()
    {
        if (currentNode == null)
        {
            return false;
        }

        return this.validateNode(currentNode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFactorPerItem</Name>
				<Source><![CDATA[
    public boolean validateFactorPerItem(NoYes _factorPerItem)
    {
        boolean                     ret;

        if (!SysDictClass::isSuperclass(classIdGet(currentNode), classNum(CostSheetNodeCalculation)))
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        CostSheetNodeCalculation costSheetNodeCalculaton = currentNode;

        // Allow turning off only if no factors have relations to items or item groups
        this.updateCurrentNode();

        if (_factorPerItem == NoYes::No && costSheetNodeCalculaton.hasFactorsPerItem())
        {
            ret = checkFailed(strFmt("@SYS112783",
                                 "@SYS17743",
                                 "@SYS14437"));
        }
        else
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNode</Name>
				<Source><![CDATA[
    public boolean validateNode(CostSheetNode _node)
    {
        boolean                 retVal = true;
        CostSheetNode           parentNode = _node.getParentNode(costSheet);

        if (parentNode != null && !parentNode.canHaveSubnode(_node))
        {
            retVal = false;
            info(strFmt("@SYS153412", _node.toString(), parentNode.toString()));
        }

        if (_node.hasSubnodes())
        {
            CostSheetNodeComposite composite = _node;
            ListEnumerator subnodeEnum = composite.getSubnodeEnumerator();
            while (subnodeEnum.moveNext())
            {
                retVal = retVal && this.validateNode(subnodeEnum.current());
            }
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CostSheetDesignerCtrl construct()
    {
        return new CostSheetDesignerCtrl();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>CostSheetDesignerCtrl</c> class.
    /// </summary>
    /// <param name="_sheetId">
    /// The costing sheet ID.
    /// </param>
    /// <param name="_formRun">
    /// The <c>FormRun</c> object.
    /// </param>
    /// <param name="_tree">
    /// The tree control instance.
    /// </param>
    /// <param name="_costSheetNodeTableDatasource">
    /// The form data source that represents the costing sheet node data.
    /// </param>
    /// <param name="_costSheetCalculationBasisDatasource">
    /// The form data source that represents costing sheet node basis data.
    /// </param>
    /// <param name="_costSheetCalculationFactorDatasource">
    /// The form data source that represents costing sheet node factors data.
    /// </param>
    /// <param name="_readOnly">
    /// A Boolean value that indicates whether the costing sheet must be used in read-only mode.
    /// </param>
    /// <returns>
    /// An initialized instance of the <c>CostSheetDesignerCtrl</c> class.
    /// </returns>
    public static CostSheetDesignerCtrl newParameters(
    CostSheetId     _sheetId,
    FormRun         _formRun,
    FormTreeControl _tree,
    FormDataSource  _costSheetNodeTableDatasource,
    FormDataSource  _costSheetCalculationBasisDatasource,
    FormDataSource  _costSheetCalculationFactorDatasource,
    boolean         _readOnly)
    {
        CostSheetDesignerCtrl costSheetDesignerCtrl =  CostSheetDesignerCtrl::construct();

        costSheetDesignerCtrl.parmSheetId(_sheetId);
        costSheetDesignerCtrl.parmFormRun(_formRun);
        costSheetDesignerCtrl.parmTree(_tree);
        costSheetDesignerCtrl.parmCostSheetNodeTableDatasource(_costSheetNodeTableDatasource);
        costSheetDesignerCtrl.parmCostSheetCalculationBasisDatasource(_costSheetCalculationBasisDatasource);
        costSheetDesignerCtrl.parmCostSheetCalculationFactorDatasource(_costSheetCalculationFactorDatasource);
        costSheetDesignerCtrl.parmReadOnly(_readOnly);

        costSheetDesignerCtrl.init();

        return costSheetDesignerCtrl;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>