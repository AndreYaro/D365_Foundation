<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvPostExpenseHeader</Name>
	<SourceCode>
		<Declaration><![CDATA[
class TrvPostExpenseHeader
{
    TrvExpTable                 trvExpTable;
    NumberSequenceCode          voucherSeriesCode;
    Voucher                     voucherNumber;
    RefRecId                    refAccountingEventRecId;
    const ExchRate companyCurrencyExchRate = 100;
    static boolean isTrvApplyCashAdvanceMappingFlightEnabled = TrvExpenseHelper::isTrvApplyCashAdvanceMappingFlightEnabled();
    static boolean isProjOpsIntegrationEnabled = ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>deleteTrvAccountingDistributions</Name>
				<Source><![CDATA[
    private void deleteTrvAccountingDistributions()
    {
        TrvAccountingDistribution   trvAccountingDistribution;
        AccountingDistribution      accountingDistribution;

        delete_from trvAccountingDistribution
            exists join accountingDistribution
                where accountingDistribution.RecId == trvAccountingDistribution.AccountingDistribution
                   && accountingDistribution.SourceDocumentHeader == trvExpTable.SourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPersonalExpensesOnly</Name>
				<Source><![CDATA[
    //Check whether the expense report has only employee-paid persnal expense lines
    protected boolean hasPersonalExpensesOnly()
    {
        TrvParameters   trvParameters = TrvParameters::find();
        TrvExpTrans     trvExpTrans;

        if (trvParameters.PersonalPaidBy == TrvPersonalPaidBy::Employee)
        {
            // Assume there is at least an expense line, as empty expense report is not allowed to submit
            select firstonly RecId from trvExpTrans where trvExpTrans.ExpType != TrvExpType::Personal
                && trvExpTrans.TrvExpTable == trvExpTable.RecId;

            if (!trvExpTrans)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(TrvExpTable _trvExpTable)
    {
        trvExpTable = _trvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherSeries</Name>
				<Source><![CDATA[
    internal NumberSequenceCode parmVoucherSeries(
        NumberSequenceCode _voucherSeriesCode = voucherSeriesCode)
    {
        voucherSeriesCode = _voucherSeriesCode;
        return voucherSeriesCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherNumber</Name>
				<Source><![CDATA[
    internal Voucher parmVoucherNumber(
        Voucher _voucherNumber = voucherNumber)
    {
        voucherNumber = _voucherNumber;
        return voucherNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the accounting event reference.
    /// </summary>
    /// <param name = "_accountingEventRecId">The accounting event reference.</param>
    /// <returns>The accounting event reference.</returns>
    internal RefRecId parmAccountingEvent(
        RefRecId _accountingEventRecId = refAccountingEventRecId)
    {
        refAccountingEventRecId = _accountingEventRecId;
        return refAccountingEventRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logExpenseReportInfo</Name>
				<Source><![CDATA[
    private void logExpenseReportInfo(str _methodName)
    {
        TrvExpTrans trvExpTrans;

        select firstonly RecId, InterCompanyLE, ProjId, CostType from trvExpTrans
                    where trvExpTrans.ExpNumber == trvExpTable.ExpNumber;

        str stringvalue = strFmt("@Expense:ExpenseInfoBeforePosting", trvExpTable.ExpNumber, trvExpTrans.RecId, trvExpTrans.InterCompanyLE, trvExpTrans.ProjId, trvExpTrans.CostType, _methodName);
                
        TrvInstrumentationHelper::logExpenseOperationsInformation(stringvalue, classStr(TrvPostExpenseHeader));
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Main posting logic. post the whole expense report.
    /// </summary>
    /// <returns>
    /// True if posting successfully. Otherwise false.
    /// </returns>
    public boolean post()
    {
        boolean isPostingSuccessful = true;

        this.logExpenseReportInfo('validatePost');
        isPostingSuccessful = this.validatePost();

        this.logExpenseReportInfo('updateExpenseStatus');
        // Handle the special case that the expense report has nothing to post, i.e. all expense lines are personal and paid by employee
        if (isPostingSuccessful && this.hasPersonalExpensesOnly())
        {
            ttsbegin;
            this.updateExpenseStatus();
            ttscommit;
            return true;
        }

        if (isPostingSuccessful)
        {
            ttsbegin;
            this.logExpenseReportInfo('processMileageLines');
            // Update Mileage Information
            isPostingSuccessful = isPostingSuccessful && this.processMileageLines();

            this.logExpenseReportInfo('validatePostForBudgetCheck');
            // Perform budget check again, as the mileage posting might change the expense line amount
            isPostingSuccessful = isPostingSuccessful && TrvBudgetCheckHelper::validatePostForBudgetCheck(trvExpTable);

            // The TrvRebalanceMileageCashAdavanceOnPostingFlight when set to false will allow correct mapping of expense mileage lines with cash advance.
            // As Mileage calculations occurs after the expense report is approved, thus the redistribution of cash advance related tables must be taken.
            if(!TrvExpenseHelper::isTrvRebalanceMileageCashAdavanceOnPostingFlightEnabled())
            {
                if (TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled() &&
                trvExpTable.existsAnyExpenseLineForGivenOwner(TrvCostOwner::Employee))
                {
                    TrvExpCashAdvanceMappingHelper::createTrvAccountingDistribution(trvExpTable.RecId, tableNum(TrvExpTable));
                }
                else
                {
                    TrvSubmitExpenseReportToWorkflow::updateTrvAccDisctributions(trvExpTable);
                }
            }

            this.logExpenseReportInfo('processCashAdvanceLines');
            // Update Cash Advance
            if (TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled() && isTrvApplyCashAdvanceMappingFlightEnabled)
            {
                isPostingSuccessful = isPostingSuccessful && this.processCashAdvanceLinesUsingMapping();
            }
            else
            {
                isPostingSuccessful = isPostingSuccessful && this.processCashAdvanceLines();
            }

            this.logExpenseReportInfo('processTaxRecovery');
            if (isPostingSuccessful)
            {
                this.processTaxRecovery();
            }

            this.logExpenseReportInfo('postSourceDocument');
            // Post SourceDocument
            isPostingSuccessful = isPostingSuccessful && this.postSourceDocument();

            this.logExpenseReportInfo('deleteTrvAccountingDistributions');
            if (isPostingSuccessful)
            {
                this.deleteTrvAccountingDistributions();
            }

            this.logExpenseReportInfo('updateExpenseStatus');
            // Update status of trvExpTable and trvExpTrans to posted
            isPostingSuccessful = isPostingSuccessful && this.updateExpenseStatus();

            if (isPostingSuccessful)
            {
                TrvExpTrans trvExpTrans;
                select firstonly RecId, InterCompanyLE, ProjId, CostType from trvExpTrans
                    where trvExpTrans.ExpNumber == trvExpTable.ExpNumber;

                str stringvalue = strFmt("@Expense:ExpenseInfoAftersuccessfulPosting", trvExpTable.ExpNumber, trvExpTrans.RecId, trvExpTrans.InterCompanyLE, trvExpTrans.ProjId, trvExpTrans.CostType);
                
                TrvInstrumentationHelper::logExpenseOperationsInformation(stringvalue, classStr(TrvPostExpenseHeader));

                ttscommit;
            }
            else
            {
                ttsabort;
            }
        }
        return isPostingSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjectAccountingDistributionAmount</Name>
				<Source><![CDATA[
    private void validateProjectAccountingDistributionAmount()
    {
        AccountingDistribution  accountingDistribution;
        TrvExpTrans trvExpTrans;
        ProjectAccountingDistribution projectAccountingDistribution;

        while select trvExptrans where trvExptrans.ExpNumber == trvExpTable.ExpNumber
        {
            if (trvExptrans.ProjId != '')
            {
                select RecId, TransactionCurrencyAmount from accountingDistribution
                   join RecId, SourceDocumentLine, ProjId, InterCompanyLE, CostType from trvExpTrans
                      where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
                      accountingDistribution.SourceDocumentLine == trvExpTrans.SourceDocumentLine;

                select RecId, TransactionCurrencyAmount from projectAccountingDistribution
                   where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;
                if (projectAccountingDistribution.TransactionCurrencyAmount != accountingDistribution.TransactionCurrencyAmount)
                {
                    str stringvalue = strFmt("@Expense:ExpenseInfoBeforeProcessSubledger", trvExpTable.ExpNumber, trvExpTrans.RecId, trvExpTrans.InterCompanyLE, trvExpTrans.ProjId, trvExpTrans.CostType, projectAccountingDistribution.TransactionCurrencyAmount, accountingDistribution.TransactionCurrencyAmount);
                
                    TrvInstrumentationHelper::logExpenseOperationsInformation(stringvalue, classStr(TrvPostExpenseHeader));
                }
                else
                {
                    str stringvalue = strFmt("@Expense:ExpenseInfoBeforeProcessSubledgerWhenAmountIsEqual", accountingDistribution.RecId);

                    TrvInstrumentationHelper::logExpenseOperationsInformation(stringvalue, classStr(TrvPostExpenseHeader));
                
                }

                if (!projectAccountingDistribution.RecId)
                {
                    str stringvalue = strFmt("@Expense:ProjaAccountingDistributionMissing", accountingDistribution.RecId);
                
                    TrvInstrumentationHelper::logExpenseOperationsInformation(stringvalue, classStr(TrvPostExpenseHeader));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSourceDocument</Name>
				<Source><![CDATA[
    //Post to General Ledger
    protected boolean postSourceDocument()
    {
        AccountingDistribution  accountingDistribution;
        TrvExpTrans             trvExpTrans;
        str                     postedVoucherNumbers;

        TrvPostExpenseHeader::updateExpenseLinesWithPostingDetails(trvExpTable, voucherSeriesCode);

        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(trvExpTable, false, SourceDocumentAccountingStatus::Completed);

        this.postTax();

        this.validateProjectAccountingDistributionAmount();
        
        TrvPostExpenseHeader::processSubLedger(trvExpTable, voucherNumber, voucherSeriesCode);

        if (TrvParameters::find().UseInterCompanyExpense)
        {
            this.processIntercompany();
        }

        TransactionLog::create(TransactionLogType::ExpenseReport, strFmt("%1, %2", trvExpTable.ExpNumber, trvExpTable.employeeName()));

        while select AccountingLegalEntity from accountingDistribution group by AccountingLegalEntity
            where accountingDistribution.SourceDocumentHeader == trvExpTable.SourceDocumentHeader
            && accountingDistribution.AccountingLegalEntity != CompanyInfo::current()
        {
            changecompany(CompanyInfo::findRecId(accountingDistribution.AccountingLegalEntity).DataArea)
            {
                TransactionLog::create(TransactionLogType::ExpenseReport, strFmt("%1, %2", trvExpTable.ExpNumber, trvExpTable.employeeName()));
            }
        }

        // Collect the voucher numbers across all expense lines
        while select Voucher from trvExpTrans
            group by Voucher
            where trvExpTrans.TrvExpTable == trvExpTable.RecId
                && trvExpTrans.LineType != TrvExpLineType::ItemizedHeader
                && trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
        {
            if (strLRTrim(postedVoucherNumbers) == "")
            {
                postedVoucherNumbers = trvExpTrans.Voucher;
            }
            else
            {
                postedVoucherNumbers = strFmt("%1, %2", postedVoucherNumbers, trvExpTrans.Voucher);
            }
        }

        info(strFmt("@SYS328581", trvExpTable.ExpNumber, postedVoucherNumbers));

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTax</Name>
				<Source><![CDATA[
    private void postTax()
    {
        TrvExpTrans                 trvExpTrans;

        while select trvExpTrans where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
            trvExpTrans.TaxGroup !='' &&
            trvExpTrans.TaxItemGroup != '' &&
            trvExpTrans.LineType != TrvExpLineType::ItemizedHeader &&
            trvExpTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
        {
            TrvTaxDocumentExpense trvTaxDocumentExpense = TrvTaxDocumentExpense::newTrvExpTrans(trvExpTrans);

            TaxPost taxPost = TaxPost::newForSourceType(TaxSourceType::Expense, trvTaxDocumentExpense, true);
            taxPost.parmExchRate(trvExpTrans.ExchangeRate);

            if (Ledger::isReportingCurrencySameAsAccountingCurrencyForLegalEntity(trvExpTrans.LegalEntity))
            {
                taxPost.parmReportingCurrencyExchRate(trvExpTrans.ExchangeRate);
			}

            TransDate postingDate = TrvExpenseTransHelper::getPostingDate(trvExpTrans.SourceDocumentLine, trvExpTrans.TransDate);

            LedgerVoucher ledgerVoucher = LedgerVoucher::newLedgerPost(
                DetailSummary::Detail,
                SysModule::Ledger,
                voucherSeriesCode);

            LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(trvExpTrans.Voucher,
                                                    postingDate,
                                                    SysModule::Ledger);
            ledgerVoucher.addVoucher(ledgerVoucherObject);

            boolean isIntercompanyTaxTransEnabled = TrvExpenseHelper::isIntercompanyTaxTransEnabled();

            TrvLegalEntity taxCompany = !isIntercompanyTaxTransEnabled ? TrvExpTrans::getLegalEntityForTax(trvExpTrans) : curExt();

            CompanyInfo foundDataArea = CompanyInfo::findDataArea(taxCompany);

            if(foundDataArea)
            {
                changecompany(taxCompany)
                {
                    taxPost.updateAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));
                }
            }
            else
            {
                throw error("@Expense:InvalidExpenseInterCompanyLE");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCashAdvanceLinesUsingMapping</Name>
				<Source><![CDATA[
    protected boolean processCashAdvanceLinesUsingMapping()
    {
        TrvCashAdvance trvCashAdvanceLocal;
        TrvExpCashAdvanceMapping trvExpCashAdvanceMapping;
        TrvExpTrans trvExpTransLocal;

        while select forupdate trvCashAdvanceLocal
            join trvExpCashAdvanceMapping
            where trvCashAdvanceLocal.RecId == trvExpCashAdvanceMapping.CashAdvanceRecId
                exists join trvExpTransLocal
                where trvExpCashAdvanceMapping.ExpLineRecId == trvExpTransLocal.RecId
                   && trvExpTransLocal.TrvExpTable == trvExpTable.RecId
        {
            trvCashAdvanceLocal.deductBalanceMST(trvExpCashAdvanceMapping.AmountMST);
            trvCashAdvanceLocal.doUpdate();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCashAdvanceLines</Name>
				<Source><![CDATA[
    //update balance of Cash Advance, mapped to trvexptrans
    protected boolean processCashAdvanceLines()
    {
        TrvCashAdvance trvCashAdvance;
        TrvAccountingDistribution   trvAccountingDistribution;
        AccountingDistribution      accountingDistribution;
        AmountMST                   oldBalanceMST;

        // Reduce cash advance balance for amount used in distributions
        while select CashAdvance, AdvanceAmount, AdvanceAmountMST, RecId from trvAccountingDistribution
            where trvAccountingDistribution.FullySplit == NoYes::Yes
        join RecId, SourceDocumentHeader from accountingDistribution
            where accountingDistribution.RecId == trvAccountingDistribution.AccountingDistribution
               && accountingDistribution.SourceDocumentHeader == trvExpTable.SourceDocumentHeader
        {
            trvCashAdvance = TrvCashAdvance::findRecId(trvAccountingDistribution.CashAdvance, true);
            if (trvCashAdvance.RecId)
            {
                oldBalanceMST = trvCashAdvance.BalanceMST;
                trvCashAdvance.BalanceMST -= trvAccountingDistribution.AdvanceAmountMST;
                if (oldBalanceMST > 0)
                {
                    AmountCur calculatedBalance = ((trvCashAdvance.Balance / oldBalanceMST) * trvCashAdvance.BalanceMST);
                    trvCashAdvance.Balance = CurrencyExchange::round(calculatedBalance, trvCashAdvance.CurrencyCode);;
                }
                else
                {
                    trvCashAdvance.Balance = 0.0;
                }

                if (trvCashAdvance.BalanceMST < 0)
                {
                    trvCashAdvance.BalanceMST = 0.0;
                    trvCashAdvance.Balance = 0.0;
                }
                trvCashAdvance.doUpdate();
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIntercompany</Name>
				<Source><![CDATA[
    private void processIntercompany()
    {
        TrvExpTrans                         trvExpTrans;
        ProjectRevenueHeader                revenueHeader;
        Map                                 amountPerCurrency;
        Amount                              amount;
        ProjIntercompanyParameters          interParam;
        ProjIntercompanyInvoiceOrigExpense  expense;
        TransDate                           transDate;

        amountPerCurrency = new Map(Types::String, Types::Container);
        while select trvExpTrans
            where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
                  trvExpTrans.InterCompanyLE != '' &&
                  trvExpTrans.InterCompanyLE != trvExpTrans.ReferenceDataAreaId &&
                  trvExpTrans.ProjId != ''
            exists join interParam
            where interParam.BorrowingLegalEntity == trvExpTrans.InterCompanyLE &&
                  interParam.WIPRevenue == true
        {
            transDate = TrvExpenseTransHelper::getUpdatedAccountingDate(trvExpTrans.RecId);

            expense = ProjIntercompanyInvoiceOrigExpense::construct(trvExpTrans);
            if (amountPerCurrency.exists(expense.getCurrencyCode()))
            {
                amount = amountPerCurrency.lookup(expense.getCurrencyCode());
            }
            else
            {
                amount = 0;
            }
            amount += expense.getAmountCur();
            if (amount != 0)
            {
                amountPerCurrency.insert(expense.getCurrencyCode(), [amount, transDate, trvExpTrans.TableId, trvExpTrans.RecId]);
            }
        }

        revenueHeader = TrvPostExpenseHeader::processProjectRevenue(amountPerCurrency, trvExpTable);

        if (revenueHeader && !isProjOpsIntegrationEnabled)
        {
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(revenueHeader, false, SourceDocumentAccountingStatus::Completed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processProjectRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the project related revenue for the expense line.
    /// </summary>
    /// <param name = "_amountPerCurrency">Map holding the amount per currency.</param>
    /// <param name = "_trvExpTable">Expense report buffer.</param>
    /// <returns>Project revenue header table instance.</returns>
    public static ProjectRevenueHeader processProjectRevenue(Map _amountPerCurrency, TrvExpTable _trvExpTable)
    {
        ProjectRevenueHeader                revenueHeader;
        MapEnumerator                       amountPerCurrencyEnum;
        ProjectRevenueLine                  revenueLine;

        if (_amountPerCurrency.elements() > 0)
        {
            select firstonly RecId, SourceDocumentHeader, ReferenceSourceDocumentHeader from revenueHeader
                where revenueHeader.ReferenceSourceDocumentHeader == _trvExpTable.SourceDocumentHeader
                    && revenueHeader.IsIntercompany == true;

            if (!revenueHeader)
            {
                revenueHeader.ReferenceSourceDocumentHeader = _trvExpTable.SourceDocumentHeader;
                revenueHeader.IsIntercompany = true;
                revenueHeader.insert();
            }

            amountPerCurrencyEnum = _amountPerCurrency.getEnumerator();
            while (amountPerCurrencyEnum.moveNext())
            {
                revenueLine.clear();
                revenueLine.AccountingLegalEntity       = CompanyInfo::current();
                revenueLine.ProjectRevenueHeader        = revenueHeader.RecId;
                revenueLine.TransactionCurrencyAmount   = conPeek(amountPerCurrencyEnum.currentValue(), 1);
                revenueLine.Currency                    = Currency::find(amountPerCurrencyEnum.currentKey()).RecId;
                revenueLine.AccountingDate              = conPeek(amountPerCurrencyEnum.currentValue(), 2);
                revenueLine.RefTableId                  = conPeek(amountPerCurrencyEnum.currentValue(), 3);
                revenueLine.RefRecId                    = conPeek(amountPerCurrencyEnum.currentValue(), 4);
                revenueLine.insert();
            }
        }

        return revenueHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processMileageLines</Name>
				<Source><![CDATA[
    protected boolean processMileageLines()
    {
        TrvPost::updateAllMileageLines(tableNum(TrvExpTable),trvExpTable.ExpNumber);
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxRecovery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax recovery records for the expense report.
    /// </summary>
    void processTaxRecovery()
    {
        TrvParameters trvParameters = TrvParameters::find();
        TrvExpTrans trvExpTransForRecovery;
        TrvExpSubCategory trvExpSubCategory;

        // persists tax recovery
        if (TrvParametersTableHelper::isTaxRecoveryEnabled(trvParameters))
        {
            while select trvExpTransForRecovery where trvExpTransForRecovery.TrvExpTable == trvExpTable.RecId &&
                    trvExpTransForRecovery.ExpType != TrvExpType::Advance &&
                    trvExpTransForRecovery.ExpType != TrvExpType::Personal &&
                    trvExpTransForRecovery.LineType != TrvExpLineType::ItemizedHeader &&
                    trvExpTransForRecovery.SplitLineType != TrvExpSplitLineType::SplitHeader &&
                    trvExpTransForRecovery.ApprovalStatus != TrvAppStatus::Ledger
            {
                if (trvExpTransForRecovery.LineType == TrvExpLineType::ItemizedLine)
                    select firstonly RecId from trvExpSubCategory where trvExpSubCategory.RecId == trvExpTransForRecovery.SubCategoryRecId;

                if (!(trvExpSubCategory.RecId && trvExpSubCategory.excludeFromRecovery()))
                    TrvPost::createTaxRecoveryItem(trvExpTransForRecovery);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpenseLineVoucher</Name>
				<Source><![CDATA[
    //update voucherNumber of expense lines
    protected void updateExpenseLineVoucher()
    {
        TrvExpTrans trvExpTrans;

        trvExpTrans.skipDataMethods(true);

        //update all expense lines, except the ones already posted
        update_recordset trvExpTrans
        setting
            Voucher = voucherNumber
        where trvExpTrans.TrvExpTable == trvExpTable.RecId
            && trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpenseStatus</Name>
				<Source><![CDATA[
    //update status of expense header and lines to posted
    protected boolean updateExpenseStatus()
    {
        TrvExpTrans trvExpTrans;

        trvExpTrans.skipDataMethods(true);

        // Update all expense lines
        update_recordset trvExpTrans
        setting
            ApprovalStatus = TrvAppStatus::Ledger
        where trvExpTrans.TrvExpTable == trvExpTable.RecId;

        // Clear parent recid for new mileage lines genereated during posting.
        // we dont' support itemization for mileage
        update_recordset trvExpTrans
        setting
            ParentRecId = 0
        where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
            trvExpTrans.ExpType == TrvExpType::Transport &&
            trvExpTrans.ParentRecId != 0;

        //Update credit card transaction posting status
        TrvPBSMaindata trvPBSMainData;

        update_recordset trvPBSMainData
            setting Posted = NoYes::Yes
            where trvPBSMainData.TravelNo == trvExpTable.ExpNumber;

        trvExpTable = TrvExpTable::findRecId(trvExpTable.RecId, true);
        trvExpTable.ApprovalStatus = TrvAppStatus::Ledger;
        trvExpTable.PostedDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        trvExpTable.doUpdate();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePost</Name>
				<Source><![CDATA[
    //Check whether trvExpTable is valid to post
    protected boolean validatePost()
    {
        TrvExpTrans                 trvExpTrans;
        TrvPayMethod                trvPayMethod;
        boolean                     isValidToPost = true;
        NumberSequenceReference     numberSequenceReference;
        
        ExpenseInstrumentationLogger    instrumentationlogger = ExpenseInstrumentationLogger::createLogger(classStr(TrvPostExpenseHeader));
        
        if (!trvExpTable)
        {
            return false;
        }

        if (trvExpTable.ApprovalStatus != TrvAppStatus::Ready && trvExpTable.ApprovalStatus != TrvAppStatus::Approved)
        {
            return false;
        }

        if (TrvRemoveExtraSDLForExpenseReportFlight::instance().isEnabled())
        {
            TrvExpTable::checkAndRemoveExtraSDL(trvExpTable.SourceDocumentHeader);
        }
        
        AccountingDistribution accountingDistribution;

        while select RecId from accountingDistribution
            join RecId, SourceDocumentLine, ProjId, InterCompanyLE, CostType from trvExpTrans
                where trvExpTrans.TrvExpTable == trvExpTable.RecId &&
                accountingDistribution.SourceDocumentLine == trvExpTrans.SourceDocumentLine
        {
            ProjectAccountingDistribution projectAccountingDistribution;

            select RecId from projectAccountingDistribution
                where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId;

            if (trvExpTrans.ProjId)
            {
                ProjTable projTable;
                select firstonly DataAreaId from ProjTable
                where projTable.ProjId == trvExpTrans.ProjId;

                if (projectAccountingDistribution.RecId == 0 && accountingDistribution.RecId != 0 && projTable.DataAreaId == trvExpTrans.InterCompanyLE)
                {
                    instrumentationLogger.logError(strFmt("@Expense:ExpenseInfoAfterPostingFailure", trvExpTable.ExpNumber, trvExpTrans.RecId, trvExpTrans.InterCompanyLE, trvExpTrans.ProjId, trvExpTrans.CostType));

                    if (TrvProjDistributionValidationFeature::isEnabled())
                    {
                        error(strFmt("@SYS11217",trvExpTrans.ProjId));
                        return false;
                    }
                }
            }
        }

        numberSequenceReference = TrvParameters::numRefExpenseVoucher();

        if (numberSequenceReference.RecId == 0)
        {
            error("@SYS305186");
            return false;
        }
        voucherSeriesCode = numberSequenceReference.numberSequenceTable().NumberSequence;

        Debug::assert(voucherSeriesCode != '');

        select firstonly RecId from trvExpTrans where trvExpTrans.ApprovalStatus != TrvAppStatus::Approved &&
                                        trvExpTrans.ApprovalStatus != TrvAppStatus::Ready &&
                                        trvExpTrans.ApprovalStatus != TrvAppStatus::Ledger &&
                                        trvExpTrans.TrvExpTable == trvExpTable.RecId;
        if (trvExpTrans)
        {
            error("@SYS305187");
            return false;
        }

        //check offset account number
        while select RecId from trvPayMethod where
            (trvPayMethod.PostMethod == TrvPostMethod::None ||
            (trvPayMethod.PostMethod != TrvPostMethod::None &&
                        trvPayMethod.PostMethod != TrvPostMethod::Employee && trvPayMethod.OffsetLedgerDimension==0))
            exists join trvExpTrans
            where trvExpTrans.PayMethod == trvPayMethod.PayMethod
            && trvExpTrans.TrvExpTable == trvExpTable.RecId
        {
            error(strFmt("@Expense:PostExpensePayMethodError",trvPayMethod.PayMethod));
            isValidToPost = false;
        }

        return isValidToPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates transaction text to use when generating <c>VendTrans</c>, <c>CustTrans</c>, or
    /// <c>BankTrans</c> records from a given expense transaction.
    /// </summary>
    /// <param name="_trvExpTrans">
    /// An expense transaction.
    /// </param>
    /// <returns>
    /// The transaction text.
    /// </returns>
    public static TransactionTextLarge getTransactionTxt(TrvExpTrans _trvExpTrans)
    {
        TransactionTxt          transactionTxt;
        TransactionTextLarge    transTxt;

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        transactionTxt.setFormLetter("@SYS101289");
        transactionTxt.setKey1(_trvExpTrans.ExpNumber);
        transactionTxt.setKey2(HcmWorker::find(_trvExpTrans.CreatingWorker).PersonnelNumber);
        transactionTxt.setKey3(_trvExpTrans.Description);
        transactionTxt.setType(LedgerTransTxt::Expense);

        transTxt = transactionTxt.txt();

        return transTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSameSign</Name>
				<Source><![CDATA[
    static private boolean isSameSign(real r1, real r2)
    {
        return ((r1<0 && r2<0) || (r1>0 && r2>0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAccountingEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the accounting event recId.
    /// </summary>
    /// <param name = "_subledgerJournalEntryRecId">The subledgerJournalEntry reference</param>
    /// <returns>The accounting event recId</returns>
    public RefRecId findAccountingEvent(RefRecId _subledgerJournalEntryRecId)
    {
        AccountingEvent accountingEvent;
        SubledgerJournalEntry subledgerJournalEntry;
        
        select firstonly RecId from accountingEvent
            join RecId, AccountingEvent from subledgerJournalEntry
               where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
               && subledgerJournalEntry.RecId == _subledgerJournalEntryRecId;

        return accountingEvent.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSubLedgerTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate necessary vendor transaction, customer transaction and/or bank transaction for a given SubledgerJournalAccountEntry
    /// </summary>
    /// <param name="_subledgerJournalAccountEntry">
    /// A SubledgerJournalAccountEntry
    /// </param>
    /// <param name="_accountingDistribution">
    /// An accounting distribution record
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The number sequence used to generate voucher number
    /// </param>
    /// <param name="_trvExpTable">
    /// Expense report header details.
    /// </param>
    static void postSubLedgerTransactions(SubledgerJournalAccountEntry _subledgerJournalAccountEntry, AccountingDistribution _accountingDistribution, NumberSequenceCode _voucherSeriesCode, TrvExpTable _trvExpTable)
    {
        ExpenseInstrumentationLogger instrumentationlogger = ExpenseInstrumentationLogger::createLogger(classStr(TrvPostExpenseHeader));
        SubledgerJournalAccountEntry subledgerJournalAccountEntry  = _subledgerJournalAccountEntry;
        AccountingDistribution accountingDistribution = _accountingDistribution;

        if (!subledgerJournalAccountEntry || !accountingDistribution || _voucherSeriesCode == '')
        {
            return;
        }

        if (subledgerJournalAccountEntry.PostingType != LedgerPostingType::VendBalance &&
            subledgerJournalAccountEntry.PostingType != LedgerPostingType::CustBalance &&
            subledgerJournalAccountEntry.PostingType != LedgerPostingType::Bank)
        {
            return;
        }

        // Find corresponding sourceDocumentLine for given accountingDistribution
        SourceDocumentLine sourceDocumentLine;

        select firstonly RecId, SourceRelationType from sourceDocumentLine
            where  sourceDocumentLine.RecId == accountingDistribution.SourceDocumentLine;

        Debug::assert(sourceDocumentLine.RecId != 0);

        if(!sourceDocumentLine.RecId)
        {
            instrumentationLogger.logWarning(strFmt("@Expense:SourceDocumentLineNotFound", _trvExpTable.ExpNumber, accountingDistribution.RecId));
        }
        
        TrvExpTrans trvExpTrans;

        // Find trvExpTrans from sourceDocumentLine
        if (sourceDocumentLine.SourceRelationType == tableNum(TrvExpTrans))
        {
            trvExpTrans = TrvExpTrans::findBySourceDocumentLine(sourceDocumentLine.RecId);
        }
        else if (sourceDocumentLine.SourceRelationType == tableNum(TaxTrans))
        {
            boolean isIntercompanyTaxTransEnabled = TrvExpenseHelper::isIntercompanyTaxTransEnabled();
            TaxTrans taxTrans;

            changeCompany(!isIntercompanyTaxTransEnabled ? CompanyInfo::getDataArea(accountingDistribution.AccountingLegalEntity) : curext())
            {
                taxTrans = TaxTrans::findBySourceDocumentLine(sourceDocumentLine.RecId);
            }

            if (!taxTrans.RecId)
            {
                instrumentationLogger.logError(strFmt("@Expense:TaxTransNotFound", _trvExpTable.ExpNumber, accountingDistribution.RecId));
            }
            
            Debug::assert(taxTrans.SourceTableId == tableNum(TrvExpTrans));
            trvExpTrans = TrvExpTrans::find(taxTrans.SourceRecId);
        }
        else if (sourceDocumentLine.SourceRelationType == tableNum(TaxUncommitted))
        {
            TaxUncommitted taxUncommitted;

            changeCompany(CompanyInfo::getDataArea(accountingDistribution.AccountingLegalEntity))
            {
                taxUncommitted = TaxUncommitted::findBySourceDocumentLine(sourceDocumentLine.RecId);
            }
            
            Debug::assert(taxUncommitted.SourceTableId == tableNum(TrvExpTrans));
            trvExpTrans = TrvExpTrans::find(taxUncommitted.SourceRecId);
        }

        Debug::assert(trvExpTrans.RecId != 0);
        if (trvExpTrans.ApprovalStatus == TrvAppStatus::Ledger)
        {
            return;
        }

        // initialize posting variables
        TrvPostExpenseHeader postHeader = new TrvPostExpenseHeader(_trvExpTable);
        postHeader.parmVoucherSeries(_voucherSeriesCode);
        postHeader.parmVoucherNumber(trvExpTrans.Voucher);

        TransDate transDate;
        if (TrvParameters::find().IsAllowUpdateAccountingDate && accountingDistribution.AccountingDate)
        {
            transDate = accountingDistribution.AccountingDate;
        }
        else
        {
            transDate = trvExpTrans.TransDate;
        }

        boolean isSameSign = TrvPostExpenseHeader::isSameSign(accountingDistribution.TransactionCurrencyAmount,subledgerJournalAccountEntry.TransactionCurrencyAmount);

        // Determine where this is main SubledgerJournalAccountEntry or offset/balancing SubledgerJournalAccountEntry
        boolean isMainSLJAE = trvExpTrans.ExpType != TrvExpType::Advance ? isSameSign : !isSameSign;

        if (trvExpTrans.ExpType != TrvExpType::Advance
             && !isTrvApplyCashAdvanceMappingFlightEnabled)
        {
            // Looking for an entry in TrvAccountingDistribution for this expense distribution
            TrvAccountingDistribution trvAccountingDistribution;

            select firstOnly RecId from trvAccountingDistribution
                where trvAccountingDistribution.AccountingDistribution == _accountingDistribution.RecId
                    || trvAccountingDistribution.ReferenceAccountingDistribution == _accountingDistribution.RecId;
            if (trvAccountingDistribution.RecId != 0)
            {
                // No transactions should be created for expense line distributions that has consumed Cash advance requests
                return;
            }
        }

        // Get customer, vendor or bank account
        LedgerJournalAC expensePostAccount;
        LedgerJournalACType expensePostAcountType;
        if (isMainSLJAE)
        {
            //This is main SLJAE Line, that means
            //Expense type is personal, and worker is mapped to customer/vendor/bank, OR
            //Expense type is cash advance, and account type is set to customer/vendor/bank
            TrvPartyEmployeeRelationship trvEmpSetup;

            if (trvExpTrans.ExpType == TrvExpType::Personal)
            {
                trvEmpSetup = TrvPartyEmployeeRelationship::find(trvExpTrans.CreatingWorker);
                if (trvEmpSetup.AccountType == LedgerJournalACType::Vend || trvEmpSetup.AccountType == LedgerJournalACType::Cust)
                {
                    expensePostAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvEmpSetup.LedgerDimension);
                    expensePostAcountType = trvEmpSetup.AccountType;
                }

                if (trvEmpSetup.AccountType == LedgerJournalACType::Bank)
                {
                    expensePostAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvEmpSetup.LedgerDimension);
                    expensePostAcountType = trvEmpSetup.AccountType;
                }
            }
            else if (trvExpTrans.ExpType == TrvExpType::Advance)
            {
                TrvCashAdvance trvCashAdvance = TrvCashAdvance::findRecId(trvExpTrans.CashAdvanceRecId);
                if (trvCashAdvance)
                {
                    if (trvCashAdvance.AdvanceLedgerDimension &&
                        (trvCashAdvance.AccountType == LedgerJournalACType::Cust || trvCashAdvance.AccountType == LedgerJournalACType::Vend || trvCashAdvance.AccountType == LedgerJournalACType::Bank))
                    {
                        expensePostAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvCashAdvance.AdvanceLedgerDimension);
                        expensePostAcountType = trvCashAdvance.AccountType;
                    }
                }
                else
                {
                    TrvExchSetup trvExchSetup = TrvExchSetup::find(trvCashAdvance.CurrencyCode);
                    if (trvExchSetup.AccountType == LedgerJournalACType::Cust || trvExchSetup.AccountType == LedgerJournalACType::Vend)
                    {
                        expensePostAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvExchSetup.AdvanceAccountLedgerDimension);
                        expensePostAcountType = trvExchSetup.AccountType;
                    }
                    if (trvExchSetup.AccountType == LedgerJournalACType::Bank)
                    {
                        expensePostAccount = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvExchSetup.AdvanceAccountLedgerDimension);
                        expensePostAcountType = trvExchSetup.AccountType;
                    }
                }
            }
        }
        else
        {
            //This is offset SLJAE Line, that means
            //Paymethod offset account type is vend, OR
            //Paymethod offset account type is worker, and worker is mapped to customer or vendor
            //These details are already stored earlier into expense line, so read from there
            expensePostAccount = trvExpTrans.PostAccount;
            expensePostAcountType = trvExpTrans.PostAccountType;
        }

        // Getting Amount Currency based on the isSameSign
        AmountCur amountCur;

        if (isTrvApplyCashAdvanceMappingFlightEnabled)
        {
            amountCur = _subledgerJournalAccountEntry.TransactionCurrencyAmount;
        }
        else
        {
            amountCur = isSameSign ? accountingDistribution.TransactionCurrencyAmount: -accountingDistribution.TransactionCurrencyAmount;
        }
        TransactionTextLarge transTxt = TrvPostExpenseHeader::getTransactionTxt(trvExpTrans);
        CurrencyCode companyCurrency = Ledger::accountingCurrency(trvExpTrans.LegalEntity);
        boolean isTaxDistribution = (accountingDistribution.MonetaryAmount == MonetaryAmount::Tax || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxNonRecoverable || accountingDistribution.MonetaryAmount == MonetaryAmount::TaxVariance);
        boolean updateToCompanyCurrency = true;

        AmountCur transactionAmount;
        CurrencyCode transactionCurrency;
        ExchRate transactionExchangeRate;
        if (!trvExpTrans.isCreditCardTransaction())
        {
             // Update exchange rate and currency based on bank's currency if exchange code is same.
             if (subledgerJournalAccountEntry.PostingType == LedgerPostingType::Bank)
             {
                 CurrencyCode bankAccountCurr = BankAccountTable::find(expensePostAccount).CurrencyCode;
                 // if the bank currency is same as transaction currency, then use exchange rate from trvexptrans.
                 if (bankAccountCurr == trvExpTrans.ExchangeCode)
                 {
                     transactionCurrency = bankAccountCurr;
                     transactionExchangeRate = trvExpTrans.ExchangeRate;
                     transactionAmount = amountCur;
                     //Don't convert to company currency so set the flag to false.
                     updateToCompanyCurrency = false;
                 }
             }
             
             // For manual expenses with offset other than bank, convert the amount to company currency/vendor currency
             if(updateToCompanyCurrency)
            {
                // Feature flag for posting the vendor invoice in Vendor Currency
                if(FeatureStateProvider::isFeatureEnabled(TrvVendorCurrencyPostingForCashExpFeature::instance()))
                {
                    CurrencyCode vendorCurrency = TrvPostExpenseHeader::getVendorCurrencyFromExpenseLine(trvExpTrans);
                    transactionCurrency = vendorCurrency;
                    transactionAmount = TrvPostExpenseHeader::calculateAmountInVendorCurrency(vendorCurrency,
                     companyCurrency,
                     trvExpTrans.ExchangeCode,
                     amountCur,
                     trvExpTrans.ExchangeRate);
                    transactionExchangeRate = TrvPostExpenseHeader::calculateTransactionExchangeRate(vendorCurrency,
                     companyCurrency,
                     trvExpTrans.ExchangeCode,
                     trvExpTrans.ExchangeRate,
                     amountCur,
                     transactionAmount);
                }
                else
                {
                    transactionCurrency = companyCurrency;
                    transactionAmount = CurrencyExchangeHelper::amountCur2MST(amountCur, trvExpTrans.ExchangeCode, trvExpTrans.ExchangeRate);
                    transactionExchangeRate = 100;
                }
            }
             
        }
        else
        {
            // Credit card currency is TrvExpTrans.ExchangeCode, Credit card transaction currency is TrvExpTrans.CreditCardTransactionCurrency
            // Credit card currency is different from company currency
            if (trvExpTrans.ExchangeCode != companyCurrency)
            {
                if (trvExpTrans.ExchangeCode == trvExpTrans.CreditCardTransactionCurrency)
                {
                    transactionAmount = amountCur;
                    transactionCurrency = trvExpTrans.ExchangeCode;
                    transactionExchangeRate = trvExpTrans.ExchangeRate;
                }
                else if (trvExpTrans.CreditCardTransactionCurrency == companyCurrency)
                {
                    // Credit card currency is A, credit card transaction currency is B, company currency is B
                    if (isTaxDistribution)
                    {
                        transactionAmount = amountCur;
                    }
                    else
                    {
                        transactionAmount = isSameSign ? trvExpTrans.AmountCurr : - trvExpTrans.AmountCurr;
                    }

                    transactionCurrency = trvExpTrans.ExchangeCode;
                    if (trvExpTrans.AmountCurr == 0)
                    {
                        throw error(strFmt("@ExpenseManagement:ZeroAmountInfolog", fieldPName(TrvExpTrans, AmountCurr)));
                    }
                    transactionExchangeRate = (trvExpTrans.amountMST / trvExpTrans.AmountCurr) * 100;
                }
                else
                {
                    // Credit card currency is A, credit card transaction currency is B, company currency is C
                    if (trvExpTrans.CreditCardTransactionCurrencyAmount == 0)
                    {
                        throw error(strFmt("@ExpenseManagement:ZeroAmountInfolog", fieldPName(TrvExpTrans, CreditCardTransactionCurrencyAmount)));
                    }

                    if (isTaxDistribution)
                    {
                        transactionAmount = amountCur;
                    }
                    else
                    {
                        transactionAmount = trvExpTrans.AmountCurr * (amountCur / trvExpTrans.CreditCardTransactionCurrencyAmount);
                    }

                    transactionCurrency = trvExpTrans.ExchangeCode;

                    if (trvExpTrans.AmountCurr == 0)
                    {
                        throw error(strFmt("@ExpenseManagement:ZeroAmountInfolog", fieldPName(TrvExpTrans, AmountCurr)));
                    }
                    transactionExchangeRate = trvExpTrans.ExchangeRate * (trvExpTrans.CreditCardTransactionCurrencyAmount / trvExpTrans.AmountCurr);
                }
            }
            else
            {
                if (trvExpTrans.ExchangeCode == trvExpTrans.CreditCardTransactionCurrency)
                {
                    // Credit card currency is A, credit card transaction currency is A, company currency is A
                    transactionAmount = amountCur;
                    transactionCurrency = trvExpTrans.ExchangeCode;
                    transactionExchangeRate = trvExpTrans.ExchangeRate;
                }
                else
                {
                    // Credit card currency is A, credit card transaction currency is B, company currency is A
                    if (trvExpTrans.CreditCardTransactionCurrencyAmount == 0)
                    {
                        throw error(strFmt("@ExpenseManagement:ZeroAmountInfolog", fieldPName(TrvExpTrans, CreditCardTransactionCurrencyAmount)));
                    }
					
					transactionAmount = trvExpTrans.AmountCurr * (amountCur / trvExpTrans.CreditCardTransactionCurrencyAmount);
                    transactionCurrency = trvExpTrans.ExchangeCode;
                    transactionExchangeRate = 100;
                }
            }
        }

        // Check whether this is tax related distribution
        AccountingDistribution accountingDistributionChild;

        if (accountingDistribution.MonetaryAmount != MonetaryAmount::Tax)
        {
            select RecId from accountingDistributionChild
                where accountingDistributionChild.ParentDistribution == accountingDistribution.RecId
                && (accountingDistributionChild.MonetaryAmount == MonetaryAmount::Tax 
                    || accountingDistributionChild.MonetaryAmount == MonetaryAmount::TaxNonRecoverable 
                    || accountingDistributionChild.MonetaryAmount == MonetaryAmount::TaxVariance)
                    && accountingDistributionChild.SourceDocumentHeader == accountingDistribution.SourceDocumentHeader;
        }

        boolean taxRelatedDistribution = false;

        if (isTaxDistribution || accountingDistributionChild.RecId != 0)
        {
            taxRelatedDistribution = true;
        }

        if ((TrvParameters::isAllowGroupingForPostTransEnabled() || taxRelatedDistribution) && (!isMainSLJAE))
        {
            // Get customer, vendor or bank account
            if (!postHeader.postSubledgerWithGrouping(trvExpTrans.RecId,
                expensePostAccount, expensePostAcountType,
                subledgerJournalAccountEntry.GeneralJournalAccountEntry,
                subledgerJournalAccountEntry.LedgerDimension,
                subledgerJournalAccountEntry.PostingType,
                accountingDistribution.AccountingDate,
                transactionAmount,
                transactionCurrency,
                transactionExchangeRate,
                taxRelatedDistribution))
            {
                throw error(strFmt("@Expense:ExpenseReportPostError", _trvExpTable.ExpNumber));
            }
            return;
        }
        
        RefRecId activeAccountingEventId = postHeader.findAccountingEvent(subledgerJournalAccountEntry.SubledgerJournalEntry);
        
        postHeader.parmAccountingEvent(activeAccountingEventId);

        postHeader.postSubledgerWithoutGrouping(trvExpTrans.RecId,
                subledgerJournalAccountEntry.LedgerDimension,
                subledgerJournalAccountEntry.PostingType,
                transDate,
                expensePostAccount,
                transactionAmount,
                transactionCurrency,
                transactionExchangeRate,
                transTxt);

    }

]]></Source>
			</Method>
			<Method>
				<Name>postSubledgerWithGrouping</Name>
				<Source><![CDATA[
    // Handles posting of subledger when the parameter for grouping transactions is on
    public boolean postSubledgerWithGrouping(
        RefRecId _expTransRecId,
        LedgerJournalAC _expensePostAccount,
        LedgerJournalACType _expensePostAcountType,
        RefRecId _gjaeRecId,
        LedgerDimensionAccount _ledgerDimension,
        LedgerPostingType _ledgerPostingType,
        AccountingDate _accountingDate,
        AmountCur _transactionAmount,
        CurrencyCode _transactionCurrency,
        ExchRate _transactionExchangeRate,
        boolean _taxRelatedDistribution)
    {
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        TrvGroupedTransactionDetails groupedTransactionDetails;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        TrvDateStd groupedTransactionsDate;
        TrvExpPaymentDetails expPaymentDetails;
        InvoiceId invoiceId;
        boolean result = true;

        
        // Fetch transaction date from related SubLedgerVoucherGeneralJournalEntry
        select AccountingDate from subledgerVoucherGeneralJournalEntry
            join GeneralJournalEntry, RecId from generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalAccountEntry.RecId == _gjaeRecId;

        groupedTransactionsDate = subledgerVoucherGeneralJournalEntry.AccountingDate;

        // When the voucher transactions are not created which would happen during Scheduled batch mode we then use accounting distribution date.
        if (groupedTransactionsDate == dateNull())
        {
            groupedTransactionsDate = _accountingDate;
        }


        boolean isTaxRelatedWithGroupingOff = _taxRelatedDistribution && !TrvParameters::isAllowGroupingForPostTransEnabled();

        if (isTaxRelatedWithGroupingOff)
        {
            groupedTransactionDetails = TrvGroupedTransactionDetails::findGroupedTransactionDetails(
                    this.trvExpTable.RecId,
                    _expensePostAccount,
                    _expensePostAcountType,
                    groupedTransactionsDate,
                    _transactionCurrency, 
                    _transactionExchangeRate,
                    _expTransRecId,
                    true);
        }
        else
        {
            if (TrvTransGroupByRepExchRateFeature::isEnabled())
            {
                groupedTransactionDetails = TrvGroupedTransactionDetails::findGroupedTransWithRepExchRate(
                        this.trvExpTable.RecId,
                        _expensePostAccount,
                        _expensePostAcountType,
                        groupedTransactionsDate,
                        _transactionCurrency,
                        _transactionExchangeRate,
                        TrvPostExpenseHeader::getCurrencyExchRate(_expTransRecId, _transactionAmount),
                        true);
            }
            else
            {
                groupedTransactionDetails = TrvGroupedTransactionDetails::findGroupedTransactionDetailsWithOutExpense(
                        this.trvExpTable.RecId,
                        _expensePostAccount,
                        _expensePostAcountType,
                        groupedTransactionsDate,
                        _transactionCurrency,
                        _transactionExchangeRate,
                        true);
            }
        }
        // Store the transaction amount against relevant account & account type
        if (groupedTransactionDetails)
        {
            groupedTransactionDetails.AmountMST += _transactionAmount;
            groupedTransactionDetails.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(groupedTransactionDetails.DefaultDimension,
                                                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_ledgerDimension));
            groupedTransactionDetails.update();

            if (!expPaymentDetails)
            {
                // create new payment details for the expense transaction
                // using the invoice from the groupedTransactionDetails we are updating
                invoiceId = TrvExpPaymentDetails::createPaymentInfoForInvoice(this.trvExpTable.RecId, _expTransRecId, groupedTransactionDetails.InvoiceId);
            }
        }
        else
        {
            if (expPaymentDetails)
            {
                invoiceId = expPaymentDetails.InvoiceId;
            }
            else
            {
                // Create payment information for expense transaction record,
                // this will generate the invoiceID fore the expense transaction
                invoiceId = TrvExpPaymentDetails::createPaymentInfoForInvoice(this.trvExpTable.RecId, _expTransRecId, '');
            }

            if (invoiceId)
            {
                groupedTransactionDetails.TrvExpTable = this.trvExpTable.RecId;
                groupedTransactionDetails.PostAccountType = _expensePostAcountType;
                groupedTransactionDetails.PostAccount = _expensePostAccount;
                groupedTransactionDetails.AmountMST = _transactionAmount;
                groupedTransactionDetails.TransactionCurrency = _transactionCurrency;
                groupedTransactionDetails.ExchangeRate = _transactionExchangeRate;
                groupedTransactionDetails.Voucher = this.VoucherNumber;
                groupedTransactionDetails.PostingType = _ledgerPostingType;
                groupedTransactionDetails.TransDate = groupedTransactionsDate;
                groupedTransactionDetails.InvoiceId = invoiceId;
                groupedTransactionDetails.DefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_ledgerDimension);
                //Continuing to use the old method getReportingCurrencyExchRate. There should be a better way of doing it, but not incorporating it to avoid the risk of breaking the grouping flow creating multiple invoices when there should only be one.
                if (isTaxRelatedWithGroupingOff || TrvParameters::isAllowGroupingForPostTransEnabled())
                {
                    groupedTransactionDetails.TrvExpTrans = _expTransRecId;
                    groupedTransactionDetails.RepExchangeRate = TrvPostExpenseHeader::getReportingCurrencyExchRate(_expTransRecId);
                }
                groupedTransactionDetails.insert();
            }
            else
            {
                // invoice creation failed, posting has failed
                result = false;
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSubledgerWithoutGrouping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles posting to the subledger with no grouping
    /// </summary>
    /// <param name="_expTransRecId">
    /// Transaction record id of expense line distribution
    /// </param>
    /// <param name="_ledgerDimension">
    /// Ledger dimension account id of expense line distribution.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// Ledger posting type of expense line distribution.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date of expense line distribution.
    /// </param>
    /// <param name="_expensePostAccount">
    /// Ledger journal account id of expense line distribution.
    /// </param>
    /// <param name="_transactionAmount">
    /// Transaction amount of expense line distribution.
    /// </param>
    /// <param name="_transactionCurrency">
    /// Transaction currency of expense line distribution.
    /// </param>
    /// <param name="_transactionExchangeRate">
    /// Exchange rate of expense line distribution.
    /// </param>
    /// <param name="_transTxt">
    /// Transaction text of expense line distribution.
    /// </param>
    public void postSubledgerWithoutGrouping(
        RefRecId _expTransRecId,
        LedgerDimensionAccount _ledgerDimension,
        LedgerPostingType _ledgerPostingType,
        TransDate _transDate,
        LedgerJournalAC _expensePostAccount,
        AmountCur _transactionAmount,
        CurrencyCode _transactionCurrency,
        ExchRate _transactionExchangeRate,
        TransactionTextLarge _transTxt)
    {
        LedgerVoucher ledgerVoucher;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerTransTxt ledgerTransTxt = LedgerTransTxt::None;
        InvoiceId invoiceId;
        List dimensionSources;

        // Create ledgerVoucher, to be used by custVendVoucher
        // ledgerVoucher is the old interface to post to GL. We do not really post to GL here, i.e. not calling ledgerVoucher.end
        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Ledger, this.voucherSeriesCode);

        ledgerVoucherObject = LedgerVoucherObject::newVoucher(this.voucherNumber,
                                                            _transDate,
                                                            SysModule::Ledger);
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        dimensionSources = new List(Types::Class);
        // Get dimensions from primary account
        dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getLedgerDimensionSpecifiers(_ledgerDimension, true));

        // Create and update the payment information for this expense and get the invoice id.
        invoiceId = TrvExpPaymentDetails::createPaymentInfoForInvoice(this.trvExpTable.RecId, _expTransRecId, invoiceId);
        if (!invoiceId)
        {
            // invoice creation failed, posting has failed
            throw error(strFmt("@Expense:ExpenseReportPostError", this.trvExpTable.ExpNumber));
        }


        // posting vendTrans or custTrans using custVendVoucher
        if (_ledgerPostingType == LedgerPostingType::VendBalance ||
            _ledgerPostingType == LedgerPostingType::CustBalance)
        {
            RefRecId activeAccountingEventId = this.parmAccountingEvent();

            TrvPostExpenseHeader::postCustVendTransactionsV2(
                this.trvExpTable,
                _ledgerPostingType,
                dimensionSources,
                _expensePostAccount,
                _transactionAmount,
                _transactionCurrency,
                _transDate,
                _transactionExchangeRate,
                this.voucherNumber,
                _transTxt,
                invoiceId,
                ledgerVoucher,
                activeAccountingEventId);
        }

        // posting bankTrans using bankVoucher
        if (_ledgerPostingType == LedgerPostingType::Bank)
        {
            TrvPostExpenseHeader::postBankTransactions(
                dimensionSources,
                _expensePostAccount,
                _transactionAmount,
                _transactionCurrency,
                _transTxt,
                _transDate,
                _transactionExchangeRate,
                _expTransRecId,
                ledgerVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVendTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post customer and vendor related transactions.
    /// </summary>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// Ledger posting type of expense line distribution.
    /// </param>
    /// <param name="_dimensionSources">
    /// List of dimension sources.
    /// </param>
    /// <param name="_custVendAccount">
    /// Customer or vendor account id.
    /// </param>
    /// <param name="_transactionAmount">
    /// Transaction amount of expense line distribution.
    /// </param>
    /// <param name="_transactionCurrency">
    /// Transaction currency of expense line distribution.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date of expense line distribution.
    /// </param>
    /// <param name="_exchRate">
    /// Exchange rate of expense line distribution.
    /// </param>
    /// <param name="_voucherNum">
    /// Voucher number of expense line distribution.
    /// </param>
    /// <param name="_transTxt">
    /// Transaction text of expense line distribution.
    /// </param>
    /// <param name="_invoiceId">
    /// Invoice id of expense line distribution.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher instance.
    /// </param>
    [SysObsolete("This method has been made obsolete, please use TrvPostExpenseHeader::postCustVendTransactionsV2 instead.", false, 19\10\2020)]
    public static void postCustVendTransactions(TrvExpTable _trvExpTable,
                                                LedgerPostingType _ledgerPostingType,
                                                List _dimensionSources,
                                                CustVendAC _custVendAccount,
                                                AmountCur _transactionAmount,
                                                CurrencyCode _transactionCurrency,
                                                TrvDateStd _transDate,
                                                ExchRate _exchRate,
                                                Voucher _voucherNum,
                                                TransTxt _transTxt,
                                                InvoiceId _invoiceId,
                                                LedgerVoucher _ledgerVoucher)
    {
        DimensionDefault    defaultDimension;
        SysModule           module;
        LedgerTransTxt      ledgerTransTxt = LedgerTransTxt::None;
        PostingProfile      postingProfile = '';
        CustVoucher         custVoucher;
        VendTrans           vendTrans;
        CustTrans           custTrans;

        if (_ledgerPostingType == LedgerPostingType::VendBalance)
        {
            module = SysModule::Vend;
            // Get dimensions based from vendor account
            _dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(VendTable::find(_custVendAccount).DefaultDimension));
            defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(_dimensionSources);
        }
        else
        {
            module = SysModule::Cust;
        }

        // Initialize custVendVoucher
        CustVendVoucher custVendVoucher = CustVendVoucher::construct(module,
                                                                    _custVendAccount,
                                                                    _transactionAmount,
                                                                    _transactionCurrency,
                                                                    ledgerTransTxt,
                                                                    defaultDimension,
                                                                    postingProfile,
                                                                    _ledgerPostingType,
                                                                    '',
                                                                    SettlementType::None,
                                                                    HcmWorker::userId2Worker(curUserId()),
                                                                    NoYes::Yes,
                                                                    '',
                                                                    dateNull(),
                                                                    0,
                                                                    dateNull(),
                                                                    _trvExpTable);


        if (!TrvPostExpenseHeader::hasCashAdvanceReference(_trvExpTable.SourceDocumentHeader))
        {
            // provide the active AccountingEvent's ID to the voucher class
            RefRecId activeAccountingEventId = _trvExpTable.getActiveAccountingEventRecId(_voucherNum);
            
            if (activeAccountingEventId)
            {
                custVendVoucher.parmAccountingEventReference(activeAccountingEventId);
            }
            else
            {
                throw error(strFmt("@Expense:InvalidAccountingEvent", _trvExpTable.ExpNumber));
            }
   
        }

        TrvPostExpenseHeader trvPostExpenseHeader = new TrvPostExpenseHeader(_trvExpTable);

        custVendVoucher = trvPostExpenseHeader.setCommonCustVendVoucherFields(custVendVoucher,
                                                                              _trvExpTable,
                                                                              _transDate,
                                                                              _exchRate,
                                                                              _voucherNum,
                                                                              _transTxt,
                                                                              _invoiceId);

        custVendVoucher = trvPostExpenseHeader.setVendSpecificCustVendVoucherFields(custVendVoucher,
                                                                                    module,
                                                                                    _custVendAccount);


        if (module == SysModule::Cust)
        {
            custVoucher = custVendVoucher;
            custVoucher.setTransRef(CustTransRefType::Invoice, _invoiceId );
        }

        // Post custVendVoucher
        if (custVendVoucher.validate())
        {
            if (module == SysModule::Vend)
            {
                trvPostExpenseHeader.vendVoucherPost(custVendVoucher, _ledgerVoucher, vendTrans);
            }
            else
            {
                trvPostExpenseHeader.custVoucherPost(custVendVoucher, _ledgerVoucher, custTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVendTransactionsV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post customer and vendor related transactions.
    /// </summary>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// Ledger posting type of expense line distribution.
    /// </param>
    /// <param name="_dimensionSources">
    /// List of dimension sources.
    /// </param>
    /// <param name="_custVendAccount">
    /// Customer or vendor account id.
    /// </param>
    /// <param name="_transactionAmount">
    /// Transaction amount of expense line distribution.
    /// </param>
    /// <param name="_transactionCurrency">
    /// Transaction currency of expense line distribution.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date of expense line distribution.
    /// </param>
    /// <param name="_exchRate">
    /// Exchange rate of expense line distribution.
    /// </param>
    /// <param name="_voucherNum">
    /// Voucher number of expense line distribution.
    /// </param>
    /// <param name="_transTxt">
    /// Transaction text of expense line distribution.
    /// </param>
    /// <param name="_invoiceId">
    /// Invoice id of expense line distribution.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher instance.
    /// </param>
    /// <param name="_activeAccountingEventId">
    /// accountingEvent instance.
    /// </param>
    public static void postCustVendTransactionsV2(TrvExpTable _trvExpTable,
                                                LedgerPostingType _ledgerPostingType,
                                                List _dimensionSources,
                                                CustVendAC _custVendAccount,
                                                AmountCur _transactionAmount,
                                                CurrencyCode _transactionCurrency,
                                                TrvDateStd _transDate,
                                                ExchRate _exchRate,
                                                Voucher _voucherNum,
                                                TransactionTextLarge _transTxt,
                                                InvoiceId _invoiceId,
                                                LedgerVoucher _ledgerVoucher,
                                                RefRecId _activeAccountingEventId = 0)
    {
        DimensionDefault    defaultDimension;
        SysModule           module;
        LedgerTransTxt      ledgerTransTxt = LedgerTransTxt::None;
        PostingProfile      postingProfile = '';
        CustVoucher         custVoucher;
        VendTrans           vendTrans;
        CustTrans           custTrans;

        if (_ledgerPostingType == LedgerPostingType::VendBalance)
        {
            module = SysModule::Vend;
            // Get dimensions based from vendor account
            _dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(VendTable::find(_custVendAccount).DefaultDimension));
            defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(_dimensionSources);
        }
        else
        {
            module = SysModule::Cust;
        }

        // Initialize custVendVoucher
        CustVendVoucher custVendVoucher = CustVendVoucher::construct(module,
                                                                    _custVendAccount,
                                                                    _transactionAmount,
                                                                    _transactionCurrency,
                                                                    ledgerTransTxt,
                                                                    defaultDimension,
                                                                    postingProfile,
                                                                    _ledgerPostingType,
                                                                    '',
                                                                    SettlementType::None,
                                                                    HcmWorker::userId2Worker(curUserId()),
                                                                    NoYes::Yes,
                                                                    '',
                                                                    dateNull(),
                                                                    0,
                                                                    dateNull(),
                                                                    _trvExpTable);

        if (!TrvPostExpenseHeader::hasCashAdvanceReference(_trvExpTable.SourceDocumentHeader))
        {
            // provide the active AccountingEvent's ID to the voucher class
            RefRecId activeAccountingEventId = !_activeAccountingEventId? _trvExpTable.getActiveAccountingEventRecId(_voucherNum) : _activeAccountingEventId;

            if (!activeAccountingEventId)
            {
                throw error(strFmt("@Expense:InvalidAccountingEvent", _trvExpTable.ExpNumber));
            }

            custVendVoucher.parmAccountingEventReference(activeAccountingEventId);

        }
        
        TrvPostExpenseHeader trvPostExpenseHeader = new TrvPostExpenseHeader(_trvExpTable);

        custVendVoucher = trvPostExpenseHeader.setCommonCustVendVoucherFields(custVendVoucher,
                                                                              _trvExpTable,
                                                                              _transDate,
                                                                              _exchRate,
                                                                              _voucherNum,
                                                                              _transTxt,
                                                                              _invoiceId);

        custVendVoucher = trvPostExpenseHeader.setVendSpecificCustVendVoucherFields(custVendVoucher,
                                                                                    module,
                                                                                    _custVendAccount);


        if (module == SysModule::Cust)
        {
            custVoucher = custVendVoucher;
            custVoucher.setTransRef(CustTransRefType::Invoice, _invoiceId );
        }

        // Post custVendVoucher
        if (custVendVoucher.validate())
        {
            if (module == SysModule::Vend)
            {
                trvPostExpenseHeader.vendVoucherPost(custVendVoucher, _ledgerVoucher, vendTrans);
            }
            else
            {
                trvPostExpenseHeader.custVoucherPost(custVendVoucher, _ledgerVoucher, custTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVendTransWithExpTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post customer and vendor related transactions with expense line reference.
    /// </summary>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// Ledger posting type of expense line distribution.
    /// </param>
    /// <param name="_dimensionSources">
    /// List of dimension sources.
    /// </param>
    /// <param name="_custVendAccount">
    /// Customer or vendor account id.
    /// </param>
    /// <param name="_transactionAmount">
    /// Transaction amount of expense line distribution.
    /// </param>
    /// <param name="_transactionCurrency">
    /// Transaction currency of expense line distribution.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date of expense line distribution.
    /// </param>
    /// <param name="_exchRate">
    /// Exchange rate of expense line distribution.
    /// </param>
    /// <param name="_voucherNum">
    /// Voucher number of expense line distribution.
    /// </param>
    /// <param name="_transTxt">
    /// Transaction text of expense line distribution.
    /// </param>
    /// <param name="_invoiceId">
    /// Invoice id of expense line distribution.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher instance.
    /// </param>
    /// <param name="_trvExpTransRecId">
    /// Expense line recId.
    /// </param>
    /// <param name="_activeAccountingEventId">
    /// accountingEvent instance.
    /// </param>
    public static void postCustVendTransWithExpTrans(TrvExpTable _trvExpTable,
                                                LedgerPostingType _ledgerPostingType,
                                                List _dimensionSources,
                                                CustVendAC _custVendAccount,
                                                AmountCur _transactionAmount,
                                                CurrencyCode _transactionCurrency,
                                                TrvDateStd _transDate,
                                                ExchRate _exchRate,
                                                Voucher _voucherNum,
                                                TransactionTextLarge _transTxt,
                                                InvoiceId _invoiceId,
                                                LedgerVoucher _ledgerVoucher,
                                                RefRecId _trvExpTransRecId,
                                                RefRecId _activeAccountingEventId = 0)
    {
        DimensionDefault    defaultDimension;
        SysModule           module;
        LedgerTransTxt      ledgerTransTxt = LedgerTransTxt::None;
        PostingProfile      postingProfile = '';
        CustVoucher         custVoucher;
        VendTrans           vendTrans;
        CustTrans           custTrans;

        if (_ledgerPostingType == LedgerPostingType::VendBalance)
        {
            module = SysModule::Vend;
            // Get dimensions based from vendor account
            _dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(VendTable::find(_custVendAccount).DefaultDimension));
            defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(_dimensionSources);
        }
        else
        {
            module = SysModule::Cust;
        }

        // Initialize custVendVoucher
        CustVendVoucher custVendVoucher = CustVendVoucher::construct(module,
                                                                    _custVendAccount,
                                                                    _transactionAmount,
                                                                    _transactionCurrency,
                                                                    ledgerTransTxt,
                                                                    defaultDimension,
                                                                    postingProfile,
                                                                    _ledgerPostingType,
                                                                    '',
                                                                    SettlementType::None,
                                                                    HcmWorker::userId2Worker(curUserId()),
                                                                    NoYes::Yes,
                                                                    '',
                                                                    dateNull(),
                                                                    0,
                                                                    dateNull(),
                                                                    _trvExpTable);

        if (!TrvPostExpenseHeader::hasCashAdvanceReference(_trvExpTable.SourceDocumentHeader))
        {
            // provide the active AccountingEvent's ID to the voucher class
            RefRecId activeAccountingEventId = !_activeAccountingEventId? _trvExpTable.getActiveAccountingEventRecId(_voucherNum) : _activeAccountingEventId;

            if (activeAccountingEventId)
            {
                custVendVoucher.parmAccountingEventReference(activeAccountingEventId);
            }
            else
            {
                throw error(strFmt("@Expense:InvalidAccountingEvent", _trvExpTable.ExpNumber));
            }
        }

        if (TrvParameters::isAllowGroupingForPostTransEnabled())
        {
            custVendVoucher.parmReportingCurrencyExchRate(TrvPostExpenseHeader::getCurrencyExchRate(_trvExpTransRecId, _transactionAmount));
        }
        
        TrvPostExpenseHeader trvPostExpenseHeader = new TrvPostExpenseHeader(_trvExpTable);

        custVendVoucher = trvPostExpenseHeader.setCommonCustVendVoucherFields(custVendVoucher,
                                                                              _trvExpTable,
                                                                              _transDate,
                                                                              _exchRate,
                                                                              _voucherNum,
                                                                              _transTxt,
                                                                              _invoiceId);

        custVendVoucher = trvPostExpenseHeader.setVendSpecificCustVendVoucherFields(custVendVoucher,
                                                                                    module,
                                                                                    _custVendAccount);


        if (module == SysModule::Cust)
        {
            custVoucher = custVendVoucher;
            custVoucher.setTransRef(CustTransRefType::Invoice, _invoiceId );
        }

        // Post custVendVoucher
        if (custVendVoucher.validate())
        {
            if (module == SysModule::Vend)
            {
                trvPostExpenseHeader.vendVoucherPost(custVendVoucher, _ledgerVoucher, vendTrans);
            }
            else
            {
                trvPostExpenseHeader.custVoucherPost(custVendVoucher, _ledgerVoucher, custTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVoucherPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the customer voucher.
    /// </summary>
    /// <param name = "_custVendVoucher">The <c>CustVendVoucher</c> object.</param>
    /// <param name = "_ledgerVoucher">The ledger posting journal to use for ledger posting.</param>
    /// <param name = "_custTrans">The Map object that contains the value of customer transaction.</param>
    protected void custVoucherPost(CustVendVoucher _custVendVoucher, LedgerVoucher _ledgerVoucher, CustTrans _custTrans)
    {
        _custVendVoucher.post(_ledgerVoucher, _custTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendVoucherPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the vendor voucher.
    /// </summary>
    /// <param name = "_custVendVoucher">The <c>CustVendVoucher</c> object.</param>
    /// <param name = "_ledgerVoucher">The ledger posting journal to use for ledger posting.</param>
    /// <param name = "_vendTrans">The Map object that contains the value of vendor transaction.</param>
    protected void vendVoucherPost(CustVendVoucher _custVendVoucher, LedgerVoucher _ledgerVoucher, VendTrans _vendTrans)
    {
        _custVendVoucher.post(_ledgerVoucher, _vendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCommonCustVendVoucherFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets common <c>CustVendVoucher</c> object fields.
    /// </summary>
    /// <param name="_custVendVoucher">
    /// The <c>CustVendVoucher</c> object.
    /// </param>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date of expense line distribution.
    /// </param>
    /// <param name="_exchRate">
    /// Exchange rate of expense line distribution.
    /// </param>
    /// <param name="_voucherNum">
    /// Voucher number of expense line distribution.
    /// </param>
    /// <param name="_transTxt">
    /// Transaction text of expense line distribution.
    /// </param>
    /// <param name="_invoiceId">
    /// Invoice id of expense line distribution.
    /// </param>
    /// <returns>
    /// The common <c>CustVendVoucher</c> object fields.
    /// </returns>
    [Wrappable(true)]
    protected final CustVendVoucher setCommonCustVendVoucherFields(
        CustVendVoucher _custVendVoucher,                                                                         
        TrvExpTable _trvExpTable,
        TrvDateStd _transDate,
        ExchRate _exchRate,
        Voucher _voucherNum,
        TransactionTextLarge _transTxt,
        InvoiceId _invoiceId)
    {
        _custVendVoucher.parmTransDate(_transDate);
        _custVendVoucher.parmExchRate(_exchRate);
        if (Ledger::accountingCurrency(_trvExpTable.LegalEntity) == Ledger::reportingCurrency(_trvExpTable.LegalEntity))
        {
            _custVendVoucher.parmReportingCurrencyExchRate(_exchRate);
        }
        _custVendVoucher.parmTransVoucher(_voucherNum);
        _custVendVoucher.parmTransTxt(_transTxt);
        _custVendVoucher.parmDocumentDate(_trvExpTable.trvReportDate());
        _custVendVoucher.parmDocumentNum(_trvExpTable.ExpNumber);
        _custVendVoucher.parmInvoiceId(_invoiceId);
        _custVendVoucher.parmCustVendNegInstStatus(CustVendNegInstStatus::Invoiced);

        _custVendVoucher.parmApproved(NoYes::Yes);
        _custVendVoucher.parmApprover(HcmWorkerLookup::currentWorker());

        return _custVendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendSpecificCustVendVoucherFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets Vendor specific <c>CustVendVoucher</c> object fields.
    /// </summary>
    /// <param name="_custVendVoucher">
    /// The <c>CustVendVoucher</c> object.
    /// </param>
    /// <param name="_module">
    /// System Module type.
    /// </param>
    /// <param name="_custVendAccount">
    /// Customer or vendor account id.
    /// </param>
    /// <returns>
    /// The Vend Specific <c>CustVendVoucher</c> object fields.
    /// </returns>
    [Wrappable(true)]
    protected final CustVendVoucher setVendSpecificCustVendVoucherFields(
        CustVendVoucher _custVendVoucher,
        SysModule _module,
        CustVendAC _custVendAccount)
    {
        if (_module == SysModule::Vend)
        {
            VendTable vendTable = VendTable::find(_custVendAccount);
            if (vendTable)
            {
                _custVendVoucher.parmPaymId(vendTable.PaymId);
                _custVendVoucher.parmPaymMode(vendTable.PaymMode);
                _custVendVoucher.parmPaymTermId(vendTable.PaymTermId);
                _custVendVoucher.parmPaymSpec(vendTable.PaymSpec);
                _custVendVoucher.parmThirdPartyBankAccountId(vendtable.BankAccount);
                _custVendVoucher.parmTransType(LedgerTransType::Vend);
            }
        }

        return _custVendVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postBankTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post bank related transactions.
    /// </summary>
    /// <param name="_dimensionSources">
    /// List of dimension sources.
    /// </param>
    /// <param name="_bankAccountId">
    /// Bank account id.
    /// </param>
    /// <param name="_transactionAmount">
    /// Transaction amount of expense line distribution.
    /// </param>
    /// <param name="_transactionCurrency">
    /// Transaction currency of expense line distribution.
    /// </param>
    /// <param name="_transTxt">
    /// Transaction text of expense line distribution.
    /// </param>
    /// <param name="_transDate">
    /// Transaction date of expense line distribution.
    /// </param>
    /// <param name="_exchRate">
    /// Exchange rate of expense line distribution.
    /// </param>
    /// <param name="_trvExpTransRecId">
    /// Expense line RecId.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// Ledger voucher instance.
    /// </param>
    public static void postBankTransactions(List _dimensionSources,
        CompanyBankAccountId _bankAccountId,
        AmountCur _transactionAmount,
        CurrencyCode _transactionCurrency,
        TransactionTextLarge _transTxt,
        TrvDateStd _transDate,
        ExchRate _exchRate,
        RefRecId _trvExpTransRecId,
        LedgerVoucher _ledgerVoucher)
    {
        DimensionDefault    defaultDimension;
        BankVoucher         bankVoucher;
        CustExchRate        reportingCurrencyExchRate;

        Debug::assert(_bankAccountId != '');

        // Get dimensions based from bank account
        _dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(BankAccountTable::find(_bankAccountId).DefaultDimension));
        defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(_dimensionSources);

        if (TrvParameters::isAllowGroupingForPostTransEnabled())
        {
            reportingCurrencyExchRate = TrvPostExpenseHeader::getCurrencyExchRate(_trvExpTransRecId, _transactionAmount);
        }

        // Create new BankAccountTrans
        bankVoucher = BankVoucher::newBankVoucher(
            _transactionAmount,
            _transactionCurrency,
            _bankAccountId,
            '',
            '',
            '',
            _transTxt,
            LedgerPostingType::Bank,
            defaultDimension,
            BankAccountTable::findLedgerDimension(_bankAccountId),
            '',
            _exchRate,
            0,
            UnknownNoYes::Unknown,
            reportingCurrencyExchRate
            );

        bankVoucher.parmTransDate(_transDate);
        bankVoucher.parmReasonRefRecID(0);
        bankVoucher.parmJournalType(LedgerJournalType::Daily);
        bankVoucher.parmReconcile(NoYes::No);
        bankVoucher.parmSourceTableId(tableNum(TrvExpTrans));
        bankVoucher.parmSourceRecId(_trvExpTransRecId);

        bankVoucher.post(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSubLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the necessary vendor transaction, customer transaction, or bank transaction for a given
    /// posted expense document and voucher number.
    /// </summary>
    /// <param name="_trvExpTable">
    /// A posted expense header.
    /// </param>
    /// <param name="_voucherNumber">
    /// The voucher number.
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The number sequence that is used to generate the voucher number.
    /// </param>
    /// <remarks>
    /// The source document framework does not generate <c>VendTrans</c>, <c>CustTrans</c>, or
    /// <c>BankTrans</c> records.This is handled explicitly by walking through the generated
    /// <c>SubledgerJournalAccountEntry</c> record after posting to the general ledger by using source
    /// document framework.
    /// </remarks>
    static void processSubLedger(TrvExpTable _trvExpTable, Voucher _voucherNumber, NumberSequenceCode _voucherSeriesCode)
    {
        SubledgerJournalEntry           subledgerJournalEntry;
        SubledgerJournalAccountEntry    subledgerJournalAccountEntry;
        AccountingEvent                 accountingEvent;

        if (strLRTrim(_voucherNumber) != '')
        {
            // Line level posting - select all subledgerJournalAccountEntry for a given expense header and voucher number
            while select * from subledgerJournalAccountEntry
                exists join  subledgerJournalEntry
                    where subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalEntry.RecId
                        && subledgerJournalEntry.Voucher == _voucherNumber
                exists join accountingEvent
                    where subledgerJournalEntry.AccountingEvent == accountingEvent.RecId &&
                        accountingEvent.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            {
                TrvPostExpenseHeader::processSubLedgerTransactions(_trvExpTable, subledgerJournalAccountEntry, _voucherSeriesCode);
            }
        }
        else
        {
            // Header level posting - select all subledgerJournalAccountEntry for a given expense header
            while select * from subledgerJournalAccountEntry
                exists join  subledgerJournalEntry
                    where subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalEntry.RecId
                exists join accountingEvent
                    where subledgerJournalEntry.AccountingEvent == accountingEvent.RecId
                        && accountingEvent.SourceDocumentHeader == _trvExpTable.SourceDocumentHeader
            {
                TrvPostExpenseHeader::processSubLedgerTransactions(_trvExpTable, subledgerJournalAccountEntry, _voucherSeriesCode);
            }
        }

        TrvPostExpenseHeader::postGroupedAccountTransactions(_trvExpTable, _voucherSeriesCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSubLedgerTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the sub ledger transactions for each related accounting distribution.
    /// </summary>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_subledgerJournalAccountEntry">
    /// SubledgerJournalAccountEntry table instance.
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The number sequence used for expense posting.
    /// </param>
    public static void processSubLedgerTransactions(TrvExpTable _trvExpTable, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, NumberSequenceCode _voucherSeriesCode)
    {
        AccountingDistribution                      accountingDistribution;
        SubledgerJournalAccountEntryDistribution    subledgerJournalAccountEntryDistribution;
        TrvExpTrans                                 approvedExpense;

        if (_subledgerJournalAccountEntry.PostingType == LedgerPostingType::VendBalance ||
                _subledgerJournalAccountEntry.PostingType == LedgerPostingType::CustBalance ||
                _subledgerJournalAccountEntry.PostingType == LedgerPostingType::Bank)
        {
            if (!isTrvApplyCashAdvanceMappingFlightEnabled)
            {
                // select and process all Accounting Distribution
                while select accountingDistribution
                    exists join subledgerJournalAccountEntryDistribution
                        where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
                            && subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry  == _subledgerJournalAccountEntry.RecId
                {
                    TrvPostExpenseHeader::postSubLedgerTransactions(_subledgerJournalAccountEntry, accountingDistribution, _voucherSeriesCode, _trvExpTable);
                }
            }
            else
            {
                if (!_subledgerJournalAccountEntry.IsCorrection)
                {
                    select accountingDistribution
                        exists join subledgerJournalAccountEntryDistribution
                            where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
                                && subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry  == _subledgerJournalAccountEntry.RecId;

                    TrvPostExpenseHeader::postSubLedgerTransactions(_subledgerJournalAccountEntry, accountingDistribution, _voucherSeriesCode, _trvExpTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExpenseLinesWithPostingDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the expense line with its posting account, account type and voucher number.
    /// </summary>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// Expense voucher series code.
    /// </param>
    public static void updateExpenseLinesWithPostingDetails(TrvExpTable _trvExpTable, NumberSequenceCode _voucherSeriesCode)
    {
        TrvExpTrans                     trvExpTrans;
        container                       accountDetails;
        LedgerJournalAcType             expenseAccountType;
        LedgerJournalAC                 expenseAccountNumber;

        Map assigned = new Map(Types::AnyType, Types::AnyType);
        assigned.insert(LedgerJournalACType::Vend, new Map(Types::String, Types::String));
        assigned.insert(LedgerJournalACType::Cust, new Map(Types::String, Types::String));
        assigned.insert(LedgerJournalACType::Bank, new Map(Types::String, Types::String));
        assigned.insert(LedgerJournalACType::Ledger, new Map(Types::String, Types::String));


        // Figure out vendor(s), customer(s), Bank(s) for each expense line and update the account, account type & voucher
        while select forUpdate trvExpTrans
            where trvExpTrans.TrvExpTable == _trvExpTable.RecId
        {
            if (trvExpTrans.ApprovalStatus == TrvAppStatus::Ledger)
            {
                continue;
            }

            // Retrieve and update post account & account type
            accountDetails = TrvPostExpenseHeader::getExpenseLinePostAccountDetails(trvExpTrans);
            expenseAccountType = conPeek(accountDetails, 1);
            expenseAccountNumber = conPeek(accountDetails, 2);

            trvExpTrans.PostAccountType = expenseAccountType;
            trvExpTrans.PostAccount = expenseAccountNumber;

            // retry a maximum of #RetryNum times to ensure that any unhandled transient errors in voucher# assignment are accounted for
            #OCCRetryCount
            NumberSeq numberSeq;            
            try
            {
                ttsbegin;

                Map tempMap;
                numberSeq = null;

                if (TrvParameters::isAllowGroupingForPostTransEnabled() && assigned.exists(expenseAccountType))
                {
                    if (assigned.lookup(expenseAccountType).exists(expenseAccountNumber))
                    {
                        trvExpTrans.Voucher = assigned.lookup(expenseAccountType).lookup(expenseAccountNumber);
                    }
                    else
                    {
                        numberSeq = NumberSeq::newGetVoucherFromCode(_voucherSeriesCode, NumberSeqScopeFactory::createDataAreaScope(), true);
                        trvExpTrans.Voucher = numberSeq.voucher();
                        tempMap = assigned.lookup(expenseAccountType);
                    }
                }
                else
                {
                    numberSeq = NumberSeq::newGetVoucherFromCode(_voucherSeriesCode, NumberSeqScopeFactory::createDataAreaScope(), true);
                    trvExpTrans.Voucher = numberSeq.voucher();
                }

                trvExpTrans.update(false);

                if (numberSeq)
                {
                    numberSeq.used();
                }

                if (tempMap)
                {
                    tempMap.insert(expenseAccountNumber, trvExpTrans.Voucher);
                }

                ttscommit;
            }
            catch (Exception::Warning)
            {
                ttsabort;

                if (numberSeq)
                {
                    numberSeq.abort();
                }

                if (xSession::currentRetryCount() < #RetryNum)
                {
                    retry;
                }
                else
                {
                    throw Exception::Warning;
                }
            }             
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpenseLinePostAccountDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get expense line posting account and posting account type.
    /// </summary>
    /// <param name="_trvExpTrans">
    /// Expense line table instance.
    /// </param>
    /// <returns>
    /// Container with posting account number and posting account type.
    /// </returns>
    public static container getExpenseLinePostAccountDetails(TrvExpTrans _trvExpTrans)
    {
        TrvExpTrans                                 trvExpTrans = _trvExpTrans;
        TrvPartyEmployeeRelationship                trvEmpSetup;
        TrvPayMethod                                trvPayMethod;
        LedgerJournalAcType                         accountType;
        CustVendAC                                  accountNumber;

        trvPayMethod = TrvPayMethod::find(trvExpTrans.PayMethod);
        if (trvPayMethod.PostMethod == TrvPostMethod::Vendor)
        {
            accountNumber = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvPayMethod.parmOffsetLedgerDimension());
            accountType = LedgerJournalACType::Vend;
        }

        if (trvPayMethod.PostMethod == TrvPostMethod::Bank)
        {
            accountNumber = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvPayMethod.parmOffsetLedgerDimension());
            accountType = LedgerJournalACType::Bank;
        }

        if (trvPayMethod.PostMethod == TrvPostMethod::Ledger)
        {
            accountNumber = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvPayMethod.parmOffsetLedgerDimension());
            accountType = LedgerJournalACType::Ledger;
        }

        if (trvPayMethod.PostMethod == TrvPostMethod::Employee)
        {
            trvEmpSetup = TrvPartyEmployeeRelationship::find(trvExpTrans.CreatingWorker);
            if (trvEmpSetup.AccountType == LedgerJournalACType::Vend || trvEmpSetup.AccountType == LedgerJournalACType::Cust
                || trvEmpSetup.AccountType == LedgerJournalACType::Bank || trvEmpSetup.AccountType == LedgerJournalACType::Ledger)
            {
                accountNumber = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(trvEmpSetup.LedgerDimension);
                accountType = trvEmpSetup.AccountType;
            }
        }
        return [accountType, accountNumber];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderTransactionTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates transaction text to use when generating <c>VendTrans</c>, <c>CustTrans</c>, or
    /// <c>BankTrans</c> records from a given expense transaction.
    /// </summary>
    /// <param name="_trvExpTable">
    /// An expense transaction.
    /// </param>
    /// <returns>
    /// The transaction text.
    /// </returns>
    public static TransactionTextLarge getHeaderTransactionTxt(TrvExpTable _trvExpTable)
    {
        TransactionTxt          transactionTxt;
        TransactionTextLarge    transTxt;
        TrvExpTable             trvExpTable = _trvExpTable;

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        transactionTxt.setFormLetter("@SYS102764");
        transactionTxt.setKey1(trvExpTable.ExpNumber);
        transactionTxt.setKey2(HcmWorker::find(trvExpTable.CreatingWorker).PersonnelNumber);
        transactionTxt.setType(LedgerTransTxt::Expense);

        transTxt = transactionTxt.txt();
        return transTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postGroupedAccountTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the grouped account transactions.
    /// </summary>
    /// <param name="_trvExpTable">
    /// Expense report table instance.
    /// </param>
    /// <param name="_voucherSeriesCode">
    /// The number sequence used for expense posting.
    /// </param>
    public static void postGroupedAccountTransactions(TrvExpTable _trvExpTable, NumberSequenceCode _voucherSeriesCode)
    {
        LedgerVoucher                               ledgerVoucher;
        LedgerVoucherObject                         ledgerVoucherObject;
        TrvGroupedTransactionDetails                trvGroupedTransactionDetails;
        List                                        dimensionSources;
        LedgerTransTxt                              ledgerTransTxt = LedgerTransTxt::None;
        TransactionTextLarge                        transTxt = TrvPostExpenseHeader::getHeaderTransactionTxt(_trvExpTable);

        while select forUpdate trvGroupedTransactionDetails
            where trvGroupedTransactionDetails.TrvExpTable == _trvExpTable.RecId
        {
            // Create ledgerVoucher, to be used by custVendVoucher
            // ledgerVoucher is the old interface to post to GL. We do not really post to GL here, i.e. not calling ledgerVoucher.end
            ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::Ledger, _voucherSeriesCode);

            ledgerVoucherObject = LedgerVoucherObject::newVoucher(trvGroupedTransactionDetails.Voucher, trvGroupedTransactionDetails.TransDate, SysModule::Ledger);
            ledgerVoucher.addVoucher(ledgerVoucherObject);

            dimensionSources = new List(Types::Class);
            dimensionSources.addEnd(LedgerDimensionDefaultingEngine::getDefaultDimensionSpecifiers(trvGroupedTransactionDetails.DefaultDimension));

            // posting vendTrans or custTrans using custVendVoucher
            if (trvGroupedTransactionDetails.PostingType == LedgerPostingType::VendBalance ||
                trvGroupedTransactionDetails.PostingType == LedgerPostingType::CustBalance)
            {
                RefRecId accountingEvent = TrvPostExpenseHeader::getAccountingEventRef(trvGroupedTransactionDetails, _trvExpTable.SourceDocumentHeader);

                if (TrvTransGroupByRepExchRateFeature::isEnabled())
                {
                    TrvPostExpenseHeader::postCustVendTransWithExpTrans(_trvExpTable,
                                                               trvGroupedTransactionDetails.PostingType,
                                                               dimensionSources,
                                                               trvGroupedTransactionDetails.PostAccount,
                                                               trvGroupedTransactionDetails.AmountMST,
                                                               trvGroupedTransactionDetails.TransactionCurrency,
                                                               trvGroupedTransactionDetails.TransDate,
                                                               trvGroupedTransactionDetails.ExchangeRate,
                                                               trvGroupedTransactionDetails.Voucher,
                                                               transTxt,
                                                               trvGroupedTransactionDetails.InvoiceId,
                                                               ledgerVoucher,
                                                               trvGroupedTransactionDetails.TrvExpTrans,
                                                               accountingEvent);
                }
                else
                {
                    TrvPostExpenseHeader::postCustVendTransactionsV2(_trvExpTable,
                                                                   trvGroupedTransactionDetails.PostingType,
                                                                   dimensionSources,
                                                                   trvGroupedTransactionDetails.PostAccount,
                                                                   trvGroupedTransactionDetails.AmountMST,
                                                                   trvGroupedTransactionDetails.TransactionCurrency,
                                                                   trvGroupedTransactionDetails.TransDate,
                                                                   trvGroupedTransactionDetails.ExchangeRate,
                                                                   trvGroupedTransactionDetails.Voucher,
                                                                   transTxt,
                                                                   trvGroupedTransactionDetails.InvoiceId,
                                                                   ledgerVoucher,
                                                                   accountingEvent);
                }
            }

            if (trvGroupedTransactionDetails.PostingType == LedgerPostingType::Bank)
            {
                TrvPostExpenseHeader::postBankTransactions(dimensionSources,
                                                           trvGroupedTransactionDetails.PostAccount,
                                                           trvGroupedTransactionDetails.AmountMST,
                                                           trvGroupedTransactionDetails.TransactionCurrency,
                                                           transTxt,
                                                           trvGroupedTransactionDetails.TransDate,
                                                           trvGroupedTransactionDetails.ExchangeRate,
                                                           trvGroupedTransactionDetails.TrvExpTrans,
                                                           ledgerVoucher);
            }
            trvGroupedTransactionDetails.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingEventRef</Name>
				<Source><![CDATA[
    public static RefRecId getAccountingEventRef(TrvGroupedTransactionDetails _trvGroupedTransactionDetails, RefRecId _sourceDocumentHeader)
    {
        TrvAccountingEventVoucher accountingEventVoucher;
       
        select AccountingEvent from accountingEventVoucher
                    where accountingEventVoucher.Voucher == _trvGroupedTransactionDetails.Voucher
                    &&    accountingEventVoucher.SourceDocumentHeader == _sourceDocumentHeader;

        AccountingEventRecId accountingEventRecId = accountingEventVoucher.AccountingEvent;

        if (!accountingEventRecId)
        {
            TrvInstrumentationHelper::logExpenseOperationsInformation(
                                                                      strFmt("@Expense:AccountingEventMissing", _sourceDocumentHeader, tableStr(TrvAccountingEventVoucher)),
                                                                      staticMethodStr(TrvPostExpenseHeader, getAccountingEventRef)
                                                                     );
            SubledgerJournalEntry subledgerJournalEntry;
            AccountingEvent accountingEvent;

            select firstonly accountingevent from subledgerJournalEntry
                        where subledgerJournalEntry.Voucher == _trvGroupedTransactionDetails.Voucher
                            && subledgerJournalEntry.DocumentDate == _trvGroupedTransactionDetails.TransDate
                            && subledgerJournalEntry.VoucherDataAreaId == curExt();

            select firstonly accountingEvent
                    where accountingEvent.RecId == subledgerJournalEntry.AccountingEvent
                        &&  accountingEvent.State != AccountingEventState::Complete;
            
            // upgrade data will have no events, so create one
            if (accountingEvent == null)
            {
                TrvInstrumentationHelper::logExpenseOperationsInformation(
                                                                      strFmt("@Expense:AccountingEventMissing", _sourceDocumentHeader, tableStr(AccountingEvent)),
                                                                      staticMethodStr(TrvPostExpenseHeader, getAccountingEventRef)
                                                                     );
                SourceDocumentHeader sourceDocumentHeader = SourceDocumentHeader::find(_sourceDocumentHeader);

                accountingEvent.Type = AccountingEventType::Original;
                accountingEvent.SourceDocumentHeader = _sourceDocumentHeader;
                accountingEvent.AccountingDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

                if (sourceDocumentHeader.AccountingStatus != SourceDocumentAccountingStatus::Completed)
                {
                    accountingEvent.State = AccountingEventState::Started;
                }
                else
                {
                    accountingEvent.State = AccountingEventState::Complete;
                }

                accountingEvent.insert();
            }

            accountingEventRecId = accountingEvent.RecId;
        }

        return accountingEventRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasCashAdvanceReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the expense has been used for cash advance settlement.
    /// </summary>
    /// <param name = "_sourceDocumentHeader">
    /// Source document header reference for current expense transaction.
    /// </param>
    /// <returns>true, if expense has been considered for cash advance settlement otherwise false </returns>
    public static boolean hasCashAdvanceReference(RefRecId  _sourceDocumentHeader)
    {
        TrvAccountingDistribution   trvAccountingDistribution;
        AccountingDistribution      accountingDistribution;
        SourceDocumentLine          sourceDocumentLine;
        TrvExpTrans                 trvExpTrans;
        TrvPayMethod                trvPaymentMethod;
        boolean                     hasReference;

        select firstonly RecId from sourceDocumentLine
            where sourceDocumentLine.SourceDocumentHeader == _sourceDocumentHeader
        join RecId from trvExpTrans
            where trvExpTrans.SourceDocumentLine == sourceDocumentLine.RecId
        join RecId from trvPaymentMethod
            where trvPaymentMethod.PayMethod == trvExpTrans.PayMethod
            && trvPaymentMethod.CostOwner == TrvCostOwner::Employee;

        if (sourceDocumentLine.RecId)
        {
            select firstonly RecId from trvAccountingDistribution
                where trvAccountingDistribution.CashAdvance != 0
                && trvAccountingDistribution.FullySplit == NoYes::Yes
            join RecId from accountingDistribution
                where accountingDistribution.RecId == trvAccountingDistribution.AccountingDistribution
                && accountingDistribution.SourceDocumentHeader == _sourceDocumentHeader;

            hasReference = trvAccountingDistribution.RecId ? true : false;
        }

        return hasReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingCurrencyExchRate</Name>
				<Source><![CDATA[
    public static CustExchRate getReportingCurrencyExchRate(RefRecId _trvExpTransRecId, boolean _useAccountinDate = false)
    {
        TrvExpTrans trvExpTrans;
        CurrencyExchangeRate exchangeRate;
        const AmountCur ZeroCheck = 0;
        const Factor ExchangeRateDefaultFactor = 100;

        if (TrvTransGroupByRepExchRateFeature::isEnabled())
        {
            select firstonly * from trvExpTrans
                where trvExpTrans.RecId == _trvExpTransRecId;

            if (trvExpTrans.ExchangeCode && !_useAccountinDate)
            {
                Ledger ledger = Ledger::findByLegalEntity(trvExpTrans.LegalEntity);

                if (ledger.ReportingCurrency)
                {
                    if (ledger.ReportingCurrency == Ledger::accountingCurrency(trvExpTrans.LegalEntity))
                    {
                        exchangeRate = trvExpTrans.ExchangeRate;
                    }
                    else if (trvExpTrans.isCreditCardTransaction() &&
							ledger.ReportingCurrency == trvExpTrans.CreditCardTransactionCurrency &&
                            trvExpTrans.AmountCurr != ZeroCheck)
                    {
                        exchangeRate = (trvExpTrans.CreditCardTransactionCurrencyAmount / trvExpTrans.AmountCurr) * ExchangeRateDefaultFactor;
                    }
					else
                    {
						ExchangeRateHelper helper = ExchangeRateHelper::newExchangeDate(ledger.RecId, trvExpTrans.ExchangeCode, trvExpTrans.TransDate);
						helper.parmToCurrency(ledger.ReportingCurrency);
						helper.parmExchangeRateTypeRecId(ledger.ReportingCurrencyExchangeRateType);
						exchangeRate = helper.getExchangeRate1();
                    }
                }
            }
        }

        return exchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchRate</Name>
				<Source><![CDATA[
    public static CustExchRate getCurrencyExchRate(RefRecId _trvExpTransRecId, AmountCur transactionCurrencyAmount)
    {
        TrvExpTrans trvExpTrans;
        CurrencyExchangeRate exchangeRate;
        const AmountCur ZeroCheck = 0;
        const Factor ExchangeRateDefaultFactor = 100;    
            select firstonly * from trvExpTrans
                    where trvExpTrans.RecId == _trvExpTransRecId;    
        if (trvExpTrans != null)
        {
            Ledger ledger = Ledger::findByLegalEntity(trvExpTrans.LegalEntity);
            CurrencyExchange currExch = CurrencyExchange::construct();
            CurrencyCalculationResults reportingAmount = currExch.calculateCurrencyToCurrencyAmounts(trvExpTrans.ExchangeCode,ledger.ReportingCurrency, trvExpTrans.AmountCurr);
            Amount reportingCurrencyAmount = reportingAmount.getUnroundedAmount();
            if(transactionCurrencyAmount != ZeroCheck)
            {
                exchangeRate = abs(reportingCurrencyAmount/transactionCurrencyAmount * ExchangeRateDefaultFactor);  
            }
            else
            {
                throw error("@Expense:TransactionCurrencyAmountNull");
            }
        }
        else
        {
             throw error("@Expense:TrvExpTransNotFound");
        }
        return exchangeRate;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendorCurrencyFromExpenseLine</Name>
				<Source><![CDATA[
    public static CurrencyCode getVendorCurrencyFromExpenseLine(TrvExpTrans trvExpTrans)
    {
        container vendAccDetails = TrvPostExpenseHeader::getExpenseLinePostAccountDetails(trvExpTrans);
        CurrencyCode vendorCurrCode = VendTable::find(conPeek(vendAccDetails,2)).Currency;
        if(!vendorCurrCode)
        {
            throw error("@Expense:VendorCurrencyFromExpenseLineNotFound");
        }
        return vendorCurrCode;

    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAmountInVendorCurrency</Name>
				<Source><![CDATA[
    public static AmountCur calculateAmountInVendorCurrency(
        CurrencyCode vendorCurrency,
        CurrencyCode companyCurrency,
        CurrencyCode transactionCurrency,
        AmountCur transactionAmount,
        ExchRate txnCurToCompCurExchRate)
    {
        // Convert Txn Amount from Txn Currency to company currency
        AmountCur companyCurrencyAmount = transactionAmount * (txnCurToCompCurExchRate / 100);

        if(vendorCurrency != companyCurrency)
        {
            if(vendorCurrency == transactionCurrency)
            {
                return transactionAmount;
            }

            // convert Txn amount from company currency to vendor currency
            CurrencyExchange currExch = CurrencyExchange::construct();
            CurrencyCalculationResults vendorCurrencyAmounts = currExch.calculateCurrencyToCurrencyAmounts(companyCurrency, vendorCurrency, companyCurrencyAmount);
            return vendorCurrencyAmounts.getUnroundedAmount();
        }

        return companyCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTransactionExchangeRate</Name>
				<Source><![CDATA[
    public static ExchRate calculateTransactionExchangeRate(
        CurrencyCode vendorCurrency,
        CurrencyCode companyCurrency,
        CurrencyCode transactionCurrency,
        ExchRate txnCurToCompCurExchRate,
        AmountCur txnCurAmount,
        AmountCur vendorCurAmount)
    {
        if(vendorCurrency == companyCurrency)
        {
            return companyCurrencyExchRate;
        }
        
        if(vendorCurrency == transactionCurrency)
        {
            return txnCurToCompCurExchRate;
        }

        return abs(vendorCurAmount == 0 ? companyCurrencyExchRate : txnCurToCompCurExchRate * (txnCurAmount / vendorCurAmount));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>