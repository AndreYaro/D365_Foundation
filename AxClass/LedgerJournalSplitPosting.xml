<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalSplitPosting</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerJournalSplitPosting</c> class supports the breakdown of voucher feature.
/// </summary>
class LedgerJournalSplitPosting
{
    LedgerJournalTrans          ledgerJournalTransMain;
    LedgerJournalTable          ledgerJournalTableMain;
    boolean                     mainAccountIsOffsetAccount;
    TmpLedgerJournalSplitHeader tmpLedgerJournalSplitHeader;
    TmpLedgerJournalSplitLines  tmpLedgerJournalSplitLines;
    TaxModuleType               taxModuleType;
    TransDate                   transDate;
    CurrencyCode                currencyCode;
    AmountCur                   originalAmountCur;
    TaxAmountCur                origTaxAmountCur;
    TaxWorkRegulation           taxWorkRegulationLines;
    TmpTaxWorkTrans             tmpTaxWorkTrans;
    RecId                       deletedOffsetRecId[];
    Counter                     numOfDeletedOffsetRecId;
    RecId                       deletedOriginalRecId[];
    Counter                     numOfDeletedOriginalRecId;
    RecId                       lastRecId;
    boolean                     journalAmountInclTax;

    #localmacro.CurrentList
        ledgerJournalTransMain,
        mainAccountIsOffsetAccount,
        taxModuleType,
        transDate,
        currencyCode,
        originalAmountCur,
        numOfDeletedOffsetRecId,
        numOfDeletedOriginalRecId,
        lastRecId,
        journalAmountInclTax
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustOffsetAccountIfEmpty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust the offset account, when it is empty.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">The <c>TmpLedgerJournalSplitHeader</c> record.</param>
    /// <param name = "_tmpLedgerJournalSplitLines">The <c>TmpLedgerJournalSplitLines</c> record.</param>
    /// <returns></returns>
    public boolean adjustOffsetAccountIfEmpty(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader, TmpLedgerJournalSplitLines _tmpLedgerJournalSplitLines)
    {
        if ((ledgerJournalTransMain.AccountType == LedgerJournalACType::Vend ||
            ledgerJournalTransMain.AccountType == LedgerJournalACType::Cust ||
            ledgerJournalTransMain.AccountType == LedgerJournalACType::Bank ||
            (ledgerJournalTransMain.AccountType == LedgerJournalACType::Ledger &&
            ledgerJournalTableMain.JournalType == LedgerJournalType::Approval)) &&
            ledgerJournalTransMain.OffsetAccountType == LedgerJournalACType::Ledger &&
            _tmpLedgerJournalSplitHeader.TaxAmountCur == 0)
        {
            ledgerJournalTransMain.OffsetLedgerDimension = _tmpLedgerJournalSplitLines.LedgerDimension;
            this.taxGroupModified(_tmpLedgerJournalSplitHeader);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTaxInLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the taxes for the line.
    /// </summary>
    /// <param name="_tmpLedgerJournalSplitLines">
    /// A <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    /// <param name="_tmpLedgerJournalSplitHeader">
    /// A <c>TmpLedgerJournalSplitHeader</c> record; optional.
    /// </param>
    /// <returns>
    /// The total amount allocated.
    /// </returns>
    AmountCur adjustTaxInLine(TmpLedgerJournalSplitLines _tmpLedgerJournalSplitLines, TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader = null)
    {
        AmountCur totalAmountAllocated;

        if (_tmpLedgerJournalSplitHeader.NetAmountCur)
        {
            this.insertTaxFromNewLine(_tmpLedgerJournalSplitLines, _tmpLedgerJournalSplitHeader);

            RecId adjustRecordId;
            AmountCur largestAmountCur;
            AmountCur amountAllocated;
            AmountCur taxAmountCurOrig = this.totalTaxPerLine(_tmpLedgerJournalSplitLines);
            AmountCur amountShare = _tmpLedgerJournalSplitLines.amountCur() / _tmpLedgerJournalSplitHeader.NetAmountCur;
            AmountCur amountToAllocate = CurrencyExchangeHelper::amount(_tmpLedgerJournalSplitHeader.TaxAmountCur * amountShare, currencyCode);

            totalAmountAllocated += amountToAllocate;

            if (taxAmountCurOrig)
            {
                while select forupdate taxWorkRegulationLines
                    where taxWorkRegulationLines.HeadingTableId == _tmpLedgerJournalSplitLines.TableId
                        && taxWorkRegulationLines.HeadingRecId == _tmpLedgerJournalSplitLines.RecId
                {
                    AmountCur newTaxAmount = (taxWorkRegulationLines.TaxRegulationAmountCur / taxAmountCurOrig) * amountToAllocate;
                    newTaxAmount = CurrencyExchangeHelper::amount(newTaxAmount, currencyCode);
                    taxWorkRegulationLines.TaxRegulationAmountCur = newTaxAmount;
                    taxWorkRegulationLines.update();
                    amountAllocated += newTaxAmount;

                    if (abs(newTaxAmount) > largestAmountCur)
                    {
                        largestAmountCur = abs(newTaxAmount);
                        adjustRecordId = taxWorkRegulationLines.RecId;
                    }
                }

                AmountCur amountMissing = amountToAllocate - amountAllocated;
                if (amountMissing)
                {
                    select forupdate taxWorkRegulationLines
                        where taxWorkRegulationLines.RecId == adjustRecordId;

                    taxWorkRegulationLines.TaxRegulationAmountCur += amountMissing;
                    taxWorkRegulationLines.update();
                }
            }
        }
        else
        {
            delete_from taxWorkRegulationLines
                where taxWorkRegulationLines.HeadingTableId == _tmpLedgerJournalSplitLines.TableId
                   && taxWorkRegulationLines.HeadingRecId == _tmpLedgerJournalSplitLines.OriginalRecId;
        }

        return totalAmountAllocated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>amountDifference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the amount difference.
    /// </summary>
    /// <returns>
    /// Zero.
    /// </returns>
    AmountCur amountDifference()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAmountExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the amount minus taxes for the specified journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The amount minus taxes for the specified journal line.
    /// </returns>
    TaxAmountCur calcAmountExclTax(LedgerJournalTrans _ledgerJournalTrans)
    {
        AmountCur amountExclTaxCur;

        if (_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax == NoYes::Yes)
        {
            TaxCalculation taxCalculation = LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, false, _ledgerJournalTrans);

            amountExclTaxCur = taxCalculation.getOriginForSourceLine(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);

            if (amountExclTaxCur && TaxParameters::find().TaxLessCashDisc)
            {
                amountExclTaxCur += -_ledgerJournalTrans.CashDiscAmount;
            }
        }

        return amountExclTaxCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmountFromExcl</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for the specified journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// The total tax amount for the specified journal line.
    /// </returns>
    TaxAmountCur calcTaxAmountFromExcl(LedgerJournalTrans _ledgerJournalTrans)
    {
        return _ledgerJournalTrans.totalTaxAmountSingleLine(true, false, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmountFromGross</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the net amount and tax amount for the specified journal line.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void calcTaxAmountFromGross(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        TransDate taxCalculationDate = (ledgerJournalTransMain.DocumentDate && TaxParameters::find().TaxCalculationDateType == TaxCalculationDateType::DocumentDate)
                                            ? ledgerJournalTransMain.DocumentDate : transDate;

        if (TaxParameters::find().TaxLessCashDisc && _tmpLedgerJournalSplitHeader.GrosAmountCur)
        {
            DiscPct cashDiscPercent = CashDisc::findByCompany(curext(), ledgerJournalTransMain.CashDiscCode).Percent;

            if (_tmpLedgerJournalSplitHeader.TaxGroup && _tmpLedgerJournalSplitHeader.TaxItemGroup)
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = Tax::baseAmountExclTax(_tmpLedgerJournalSplitHeader.TaxGroup,
                                                                                    _tmpLedgerJournalSplitHeader.TaxItemGroup,
                                                                                    taxCalculationDate,
                                                                                    currencyCode,
                                                                                    _tmpLedgerJournalSplitHeader.GrosAmountCur,
                                                                                    taxModuleType,
                                                                                    0,
                                                                                    '',
                                                                                    '',
                                                                                    TaxDirection::OutgoingTax,
                                                                                    ledgerJournalTableMain.LedgerJournalInclTax ? cashDiscPercent : 0);
            }
            else
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = 0;
            }

            _tmpLedgerJournalSplitHeader.NetAmountCur += (originalAmountCur ? _tmpLedgerJournalSplitHeader.CashDiscAmount * (abs(_tmpLedgerJournalSplitHeader.GrosAmountCur) / abs(originalAmountCur)) : 0);

            if (!_tmpLedgerJournalSplitHeader.NetAmountCur)
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = _tmpLedgerJournalSplitHeader.GrosAmountCur;
            }

            _tmpLedgerJournalSplitHeader.TaxAmountCur = _tmpLedgerJournalSplitHeader.GrosAmountCur - _tmpLedgerJournalSplitHeader.NetAmountCur;
            _tmpLedgerJournalSplitHeader.TaxAmountCur += (originalAmountCur ? _tmpLedgerJournalSplitHeader.CashDiscAmount * (abs(_tmpLedgerJournalSplitHeader.GrosAmountCur) / abs(originalAmountCur)) : 0);

            if (originalAmountCur)
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur -= CurrencyExchangeHelper::amount(_tmpLedgerJournalSplitHeader.CashDiscAmount * (abs(_tmpLedgerJournalSplitHeader.GrosAmountCur) / abs(originalAmountCur)), currencyCode);
            }
        }
        else
        {
            if (_tmpLedgerJournalSplitHeader.TaxGroup && _tmpLedgerJournalSplitHeader.TaxItemGroup)
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = Tax::baseAmountExclTax(_tmpLedgerJournalSplitHeader.TaxGroup,
                                                                                    _tmpLedgerJournalSplitHeader.TaxItemGroup,
                                                                                    taxCalculationDate,
                                                                                    currencyCode,
                                                                                    _tmpLedgerJournalSplitHeader.GrosAmountCur,
                                                                                    taxModuleType);
            }
            else
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = _tmpLedgerJournalSplitHeader.GrosAmountCur;
            }

            _tmpLedgerJournalSplitHeader.TaxAmountCur = _tmpLedgerJournalSplitHeader.GrosAmountCur - _tmpLedgerJournalSplitHeader.NetAmountCur;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxAmountPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does nothing.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    void calcTaxAmountPosted(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectDeletedRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Records that the specified transaction is deleted.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitLines">
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    void collectDeletedRecId(TmpLedgerJournalSplitLines _tmpLedgerJournalSplitLines)
    {
        if (_tmpLedgerJournalSplitLines.OffsetRecId)
        {
            numOfDeletedOffsetRecId++;
            deletedOffsetRecId[numOfDeletedOffsetRecId] = _tmpLedgerJournalSplitLines.OffsetRecId;
        }

        if (_tmpLedgerJournalSplitLines.OriginalRecId)
        {
            numOfDeletedOriginalRecId++;
            deletedOriginalRecId[numOfDeletedOriginalRecId] = _tmpLedgerJournalSplitLines.OriginalRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a journal header.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void deleteHeader(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        while select forupdate tmpLedgerJournalSplitLines where tmpLedgerJournalSplitLines.LineNum == _tmpLedgerJournalSplitHeader.LineNum
        {
            this.collectDeletedRecId(tmpLedgerJournalSplitLines);
            tmpLedgerJournalSplitLines.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a journal line.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitLines">
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    void deleteLine(TmpLedgerJournalSplitLines _tmpLedgerJournalSplitLines)
    {
        this.collectDeletedRecId(_tmpLedgerJournalSplitLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineModuleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the <c>TaxModuleType</c> enumeration value.
    /// </summary>
    protected void determineModuleType()
    {
        switch (ledgerJournalTransMain.AccountType)
        {
            case LedgerJournalACType::Cust :
                taxModuleType = TaxModuleType::Sales;
                break;

            case LedgerJournalACType::Vend :
                taxModuleType = TaxModuleType::Purch;
                break;

            case LedgerJournalACType::Ledger :
                if (ledgerJournalTransMain.parmOffsetLedgerDimension())
                {
                    switch (ledgerJournalTransMain.OffsetAccountType)
                    {
                        case LedgerJournalACType::Cust :
                            taxModuleType = TaxModuleType::Sales;
                            originalAmountCur = -originalAmountCur;
                            mainAccountIsOffsetAccount = true;
                            break;

                        case LedgerJournalACType::Vend :
                            taxModuleType = TaxModuleType::Purch;
                            originalAmountCur = -originalAmountCur;
                            mainAccountIsOffsetAccount = true;
                            break;

                        case LedgerJournalACType::Bank :
                            taxModuleType = TaxModuleType::Voucher;
                            originalAmountCur = -originalAmountCur;
                            mainAccountIsOffsetAccount = true;
                            break;

                        // <GEERU>
                        case LedgerJournalACType::RCash :
                            taxModuleType = TaxModuleType::Voucher;
                            originalAmountCur = -originalAmountCur;
                            mainAccountIsOffsetAccount = true;
                            break;
                        // </GEERU>

                        case LedgerJournalACType::Ledger :
                            taxModuleType = TaxModuleType::Voucher;
                            originalAmountCur = 0;
                            break;

                        default :
                            taxModuleType = TaxModuleType::Voucher;
                    }
                }
                else
                {
                    taxModuleType = TaxModuleType::Voucher;
                    originalAmountCur = 0;
                }
                break;

            default :
                taxModuleType = TaxModuleType::Voucher;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillHeaderRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates a <c>TmpLedgerJournalSplitHeader</c> record with the specified journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_taxAmountCur">
    /// The tax maount.
    /// </param>
    /// <param name = "_lineNum">
    /// A line number.
    /// </param>
    /// <param name = "_isOffset">
    /// Determines if the transaction is an offset.
    /// </param>
    public void fillHeaderRecord(
        LedgerJournalTrans _ledgerJournalTrans,
        AmountCur _taxAmountCur,
        LineNum _lineNum,
        boolean _isOffset)
    {
        AmountCur lineAmount;

        lineAmount = _ledgerJournalTrans.amount();
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger &&
            _isOffset)
        {
            lineAmount = -_ledgerJournalTrans.amount();
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            select forupdate tmpLedgerJournalSplitHeader
            where tmpLedgerJournalSplitHeader.TaxGroup     == _ledgerJournalTrans.TaxGroup &&
                  tmpLedgerJournalSplitHeader.TaxItemGroup == _ledgerJournalTrans.TaxItemGroup &&
                  tmpLedgerJournalSplitHeader.TaxCode      == _ledgerJournalTrans.TaxCode;

            if (tmpLedgerJournalSplitHeader)
            {
                tmpLedgerJournalSplitHeader.TaxAmountCur   += _taxAmountCur;
                tmpLedgerJournalSplitHeader.CashDiscAmount = _ledgerJournalTrans.CashDiscAmount;

                if (!_ledgerJournalTrans.TaxCode)
                {
                    if (journalAmountInclTax)
                    {
                        tmpLedgerJournalSplitHeader.GrosAmountCur += lineAmount;
                        tmpLedgerJournalSplitHeader.NetAmountCur = tmpLedgerJournalSplitHeader.GrosAmountCur - tmpLedgerJournalSplitHeader.TaxAmountCur;
                    }
                    else
                    {
                        tmpLedgerJournalSplitHeader.NetAmountCur += lineAmount;
                        tmpLedgerJournalSplitHeader.GrosAmountCur = tmpLedgerJournalSplitHeader.NetAmountCur + tmpLedgerJournalSplitHeader.TaxAmountCur;
                    }
                }

                tmpLedgerJournalSplitHeader.update();
            }
            else
            {
                tmpLedgerJournalSplitHeader.LineNum        = _lineNum;
                tmpLedgerJournalSplitHeader.TaxAmountCur   = _taxAmountCur;
                tmpLedgerJournalSplitHeader.CashDiscAmount = _ledgerJournalTrans.CashDiscAmount;

                if (_ledgerJournalTrans.TaxCode)
                {
                    tmpLedgerJournalSplitHeader.TaxCode = _ledgerJournalTrans.TaxCode;
                }
                else
                {
                    tmpLedgerJournalSplitHeader.TaxGroup        = _ledgerJournalTrans.TaxGroup;
                    tmpLedgerJournalSplitHeader.TaxItemGroup    = _ledgerJournalTrans.TaxItemGroup;

                    if (journalAmountInclTax)
                    {
                        tmpLedgerJournalSplitHeader.GrosAmountCur = lineAmount;
                        tmpLedgerJournalSplitHeader.NetAmountCur = tmpLedgerJournalSplitHeader.GrosAmountCur - tmpLedgerJournalSplitHeader.TaxAmountCur;
                    }
                    else
                    {
                        tmpLedgerJournalSplitHeader.NetAmountCur = lineAmount;
                        tmpLedgerJournalSplitHeader.GrosAmountCur  = tmpLedgerJournalSplitHeader.NetAmountCur + tmpLedgerJournalSplitHeader.TaxAmountCur;
                    }
                }

                tmpLedgerJournalSplitHeader.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the specified <c>LedgerJournalTrans</c> record with values from the breakdown temp table records.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_tmpLedgerJournalSplitLines">
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void fillLedgerJournalTrans(LedgerJournalTrans          _ledgerJournalTrans,
                                TmpLedgerJournalSplitLines  _tmpLedgerJournalSplitLines,
                                TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        TaxAmountCur        taxAmountCur;
        TaxWorkRegulation   taxWorkRegulation;
        LedgerJournalTable  ledgerJournalTable;

        _ledgerJournalTrans.TaxGroup           = _tmpLedgerJournalSplitHeader.TaxGroup;
        _ledgerJournalTrans.TaxItemGroup       = _tmpLedgerJournalSplitHeader.TaxItemGroup;
        _ledgerJournalTrans.TaxCode            = _tmpLedgerJournalSplitHeader.TaxCode;
        _ledgerJournalTrans.Txt                = _tmpLedgerJournalSplitLines.TransTxt;

        _ledgerJournalTrans.AccountType = LedgerJournalACType::Ledger;
        _ledgerJournalTrans.parmLedgerDimension(_tmpLedgerJournalSplitLines.LedgerDimension);
        _ledgerJournalTrans.DefaultDimension = 0;

        _ledgerJournalTrans.AmountCurCredit    = _tmpLedgerJournalSplitLines.AmountCurCredit;
        _ledgerJournalTrans.AmountCurDebit     = _tmpLedgerJournalSplitLines.AmountCurDebit;

        _ledgerJournalTrans.OffsetAccountType  = LedgerJournalACType::Ledger;
        _ledgerJournalTrans.parmOffsetLedgerDimension(0);
        _ledgerJournalTrans.OffsetDefaultDimension = 0;

        _ledgerJournalTrans.PoolRecId          = 0;

        delete_from taxWorkRegulation
        where taxWorkRegulation.HeadingTableId == _ledgerJournalTrans.TableId
           && taxWorkRegulation.HeadingRecId == _ledgerJournalTrans.RecId;

        if (_tmpLedgerJournalSplitHeader.TaxCode)
        {
            _ledgerJournalTrans.TaxGroup           = '';
            _ledgerJournalTrans.TaxItemGroup       = '';
        }
        else
        {
            select sum(TaxRegulationAmountCur)
            from taxWorkRegulationLines
            where taxWorkRegulationLines.HeadingTableId == _tmpLedgerJournalSplitLines.TableId
               && taxWorkRegulationLines.HeadingRecId == _tmpLedgerJournalSplitLines.RecId;

            // remove taxes - since the header was split existing taxes will be invalid
            // and the tax engine will not recalculate unless existing taxes are deleted.
            ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
            TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);

            using (TaxIntegrationTaxCalculationNoDelayContext taxCalculationNoDelayContext = TaxIntegrationTaxCalculationNoDelayContext::getInstance())
            {
                taxAmountCur = this.calcTaxAmountFromExcl(_ledgerJournalTrans);
            }

            if (taxAmountCur &&
                taxAmountCur != taxWorkRegulationLines.TaxRegulationAmountCur)
            {
                taxAmountCur = 0;

                this.adjustTaxInLine(_tmpLedgerJournalSplitLines, _tmpLedgerJournalSplitHeader);

                while select taxWorkRegulationLines
                where taxWorkRegulationLines.HeadingTableId == _tmpLedgerJournalSplitLines.TableId
                   && taxWorkRegulationLines.HeadingRecId == _tmpLedgerJournalSplitLines.RecId
                {
                    taxAmountCur += taxWorkRegulationLines.TaxRegulationAmountCur;
                    taxWorkRegulation = taxWorkRegulationLines.data();
                    taxWorkRegulation.HeadingTableId = _ledgerJournalTrans.TableId;
                    taxWorkRegulation.HeadingRecId = _ledgerJournalTrans.RecId;
                    taxWorkRegulation.insert();
                }
            }
            if (journalAmountInclTax)
            {
                if (taxAmountCur && _ledgerJournalTrans.AmountCurCredit)
                {
                    _ledgerJournalTrans.AmountCurCredit -= taxAmountCur;
                }

                if (taxAmountCur && _ledgerJournalTrans.AmountCurDebit)
                {
                    _ledgerJournalTrans.AmountCurDebit += taxAmountCur;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>TmpLedgerJournalSplitLines</c> record with values from the specified journal line.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <param name = "_offsetRecord">
    /// Determines if the transaction is an offset.
    /// </param>
    /// <param name = "_lineNum">
    /// The line number
    /// </param>
    /// <returns>
    /// The tax amount.
    /// </returns>
    public AmountCur fillLines(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _offsetRecord,
        LineNum _lineNum)
    {
        AmountCur amountCurExclTax;
        AmountCur amountCurInclTax;
        AmountCur taxAmountCur;

        LedgerDimensionAccount ledgerDimension;

        AmountCur lineAmount = _ledgerJournalTrans.amount();
        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger && !_offsetRecord)
        {
            ledgerDimension = _ledgerJournalTrans.parmLedgerDimension();
        }
        else if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger && _offsetRecord)
        {
            if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                ledgerDimension = _ledgerJournalTrans.parmOffsetLedgerDimension();
            }
            lineAmount = -_ledgerJournalTrans.amount();
        }
        else if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            ledgerDimension = _ledgerJournalTrans.parmOffsetLedgerDimension();
            lineAmount = -_ledgerJournalTrans.amount();
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            if (ledgerDimension || ledgerJournalTableMain.JournalType == LedgerJournalType::Approval)
            {
                // the account has to be set
                tmpLedgerJournalSplitLines.clear();

                if (_offsetRecord)
                {
                    tmpLedgerJournalSplitLines.OffsetRecId = _ledgerJournalTrans.RecId;
                }
                else
                {
                    tmpLedgerJournalSplitLines.OriginalRecId = _ledgerJournalTrans.RecId;
                }

                tmpLedgerJournalSplitLines.LineNum = _lineNum;
                tmpLedgerJournalSplitLines.LedgerDimension = ledgerDimension;
                tmpLedgerJournalSplitLines.TransTxt = _ledgerJournalTrans.Txt;
            }

            if (_ledgerJournalTrans.TaxCode)
            {
                amountCurInclTax = lineAmount;
                amountCurExclTax = amountCurInclTax;
                taxAmountCur     = amountCurInclTax;
            }
            else
            {
                this.transferTaxWorkRegulation(
                    _ledgerJournalTrans.TableId,
                    _ledgerJournalTrans.RecId,
                    tmpLedgerJournalSplitLines.TableId,
                    tmpLedgerJournalSplitLines.RecId);

                if (journalAmountInclTax)
                {
                    amountCurInclTax = lineAmount;
                    amountCurExclTax = this.calcAmountExclTax(_ledgerJournalTrans);
                    if (!amountCurExclTax)
                    {
                        // no tax calculated so these are the same value.
                        amountCurExclTax = amountCurInclTax;
                    }
                }
                else
                {
                    amountCurExclTax = lineAmount;
                    amountCurInclTax = lineAmount + this.calcTaxAmountFromExcl(_ledgerJournalTrans);
                }

                if (_ledgerJournalTrans.TaxGroup && _ledgerJournalTrans.TaxItemGroup)
                {
                    taxAmountCur = TaxWorkRegulation::correctedTaxAmount(tableNum(LedgerJournalTrans), _ledgerJournalTrans.RecId);

                    if ((journalAmountInclTax) && (taxAmountCur))
                    {
                        amountCurExclTax = lineAmount - taxAmountCur;
                    }
                }

                if (!taxAmountCur)
                {
                    taxAmountCur = amountCurInclTax - amountCurExclTax;
                }
            }

            if (ledgerDimension || ledgerJournalTableMain.JournalType == LedgerJournalType::Approval)
            {
                // the account has to be set
                if ((_ledgerJournalTrans.AmountCurCredit && _offsetRecord) || (_ledgerJournalTrans.AmountCurDebit && !_offsetRecord))
                {
                    tmpLedgerJournalSplitLines.AmountCurDebit = amountCurExclTax;
                }
                else
                {
                    tmpLedgerJournalSplitLines.AmountCurCredit = -amountCurExclTax;
                }

                tmpLedgerJournalSplitLines.insert();
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTaxWorkRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the <c>TaxWorkRegulation</c> table for the specified table and record ID.
    /// </summary>
    /// <param name = "_tableId">
    /// The table identifier.
    /// </param>
    /// <param name = "_recId">
    /// The record identifier.
    /// </param>
    void fillTaxWorkRegulation(TableId _tableId, RecId _recId)
    {
        delete_from taxWorkRegulationLines
            where taxWorkRegulationLines.HeadingTableId == _tableId
               && taxWorkRegulationLines.HeadingRecId == _recId;

        while select tmpTaxWorkTrans
            where  tmpTaxWorkTrans.TaxDirection != TaxDirection::UseTax
        {
            taxWorkRegulationLines.clear();
            taxWorkRegulationLines.HeadingTableId   = _tableId;
            taxWorkRegulationLines.HeadingRecId     = _recId;
            taxWorkRegulationLines.TaxCode          = tmpTaxWorkTrans.TaxCode;
            taxWorkRegulationLines.TaxDirection     = tmpTaxWorkTrans.TaxDirection;
            taxWorkRegulationLines.TaxRegulationAmountCur = tmpTaxWorkTrans.transactionCurrencyTaxAmount();
            taxWorkRegulationLines.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineNum</Name>
				<Source><![CDATA[
    LineNum getLineNum(TaxGroup     _taxGroup,
                       TaxItemGroup _taxItemGroup,
                       TaxCode      _taxCode)
    {
        TmpLedgerJournalSplitHeader tmpLedgerJournalSplitHeaderLocal;
        LineNum                     lineNum;

        tmpLedgerJournalSplitHeaderLocal.setTmpData(tmpLedgerJournalSplitHeader);

        select firstonly tmpLedgerJournalSplitHeaderLocal
        where tmpLedgerJournalSplitHeaderLocal.TaxGroup     == _taxGroup &&
              tmpLedgerJournalSplitHeaderLocal.TaxItemGroup == _taxItemGroup &&
              tmpLedgerJournalSplitHeaderLocal.TaxCode      == _taxCode;

        if (tmpLedgerJournalSplitHeaderLocal)
        {
            lineNum = tmpLedgerJournalSplitHeaderLocal.LineNum;
        }

        return lineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOriginalAmountCur</Name>
				<Source><![CDATA[
    AmountCur getOriginalAmountCur(LedgerJournalTrans _ledgerJournalTrans)
    {
        return _ledgerJournalTrans.amount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>grosAmountModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Recalculate net and tax amounts for the specified header.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void grosAmountModified(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        if (_tmpLedgerJournalSplitHeader.TaxCode)
        {
            _tmpLedgerJournalSplitHeader.GrosAmountCur = 0;
            _tmpLedgerJournalSplitHeader.NetAmountCur = 0;
        }
        else
        {
            this.calcTaxAmountFromGross(_tmpLedgerJournalSplitHeader);
        }

        if (_tmpLedgerJournalSplitHeader.RecId)
        {
            _tmpLedgerJournalSplitHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the instance with information from the specified journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name = "_voucher">
    /// The voucher string.
    /// </param>
    public void initFromJournal(LedgerJournalTable _ledgerJournalTable, Voucher _voucher)
    {
        LedgerJournalTrans  ledgerJournalTransLines;
        AmountCur           taxAmountCur;
        LineNum             lineNum = 1;
        LineNum             lineNumHeader;

        ledgerJournalTableMain.data(_ledgerJournalTable);
        ledgerJournalTransMain = this.mainAccount(ledgerJournalTableMain.JournalNum, _voucher);

        this.initializeJournalTaxCalculation(_ledgerJournalTable);

        journalAmountInclTax = ledgerJournalTransMain.ledgerJournalTable().LedgerJournalInclTax;
        this.calcTaxAmountPosted(ledgerJournalTransMain);
        originalAmountCur = this.getOriginalAmountCur(ledgerJournalTransMain);
        currencyCode      = ledgerJournalTransMain.CurrencyCode;
        transDate         = ledgerJournalTransMain.TransDate;

        this.determineModuleType();

        while select ledgerJournalTransLines
            where ledgerJournalTransLines.JournalNum == ledgerJournalTableMain.JournalNum &&
                ledgerJournalTransLines.Voucher == _voucher
        {
            if (this.useTrans(ledgerJournalTransLines))
            {
                if (ledgerJournalTransLines.AccountType  == LedgerJournalACType::Ledger)
                {
                    lineNumHeader = this.getLineNum(ledgerJournalTransLines.TaxGroup,
                                                    ledgerJournalTransLines.TaxItemGroup,
                                                    ledgerJournalTransLines.TaxCode);

                    if (!lineNumHeader)
                    {
                        lineNum++;
                        lineNumHeader = lineNum;
                    }

                    taxAmountCur = this.fillLines(ledgerJournalTransLines, false, lineNumHeader);
                    this.fillHeaderRecord(ledgerJournalTransLines, taxAmountCur, lineNumHeader, false);
                }

                if (ledgerJournalTransLines.OffsetLedgerDimension &&
                    ledgerJournalTransLines.OffsetAccountType == LedgerJournalACType::Ledger &&
                   (ledgerJournalTransLines.ledgerJournalTable().JournalType != LedgerJournalType::Approval))
                {
                    // the offset account does not have to be set
                    lineNum++;

                    if (ledgerJournalTransLines.AccountType ==  LedgerJournalACType::Ledger)
                    {
                        ledgerJournalTransLines.TaxGroup = '';
                        ledgerJournalTransLines.TaxItemGroup = '';
                        ledgerJournalTransLines.TaxCode = '';
                    }

                    lineNumHeader = this.getLineNum(ledgerJournalTransLines.TaxGroup,
                                                    ledgerJournalTransLines.TaxItemGroup,
                                                    ledgerJournalTransLines.TaxCode);
                    if (!lineNumHeader)
                    {
                        lineNum++;
                        lineNumHeader = lineNum;
                    }

                    taxAmountCur = this.fillLines(ledgerJournalTransLines, true, lineNumHeader);

                    if (ledgerJournalTransLines.AccountType == LedgerJournalACType::Ledger && ledgerJournalTransLines.OffsetAccountType == LedgerJournalACType::Ledger)
                    {
                        // if ledger to ledger then tax is always on the primary amount not the offset.
                        taxAmountCur = 0;
                    }

                    this.fillHeaderRecord(ledgerJournalTransLines, taxAmountCur, lineNumHeader, true);
                }

                // Collecting the Original Tax amount to use it in the outer scope
                origTaxAmountCur = taxAmountCur;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeJournalTaxCalculation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the tax calculations for the journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">The <c>LedgerJournalTable</c> table record to initialize tax calculations for.</param>
    protected final void initializeJournalTaxCalculation(LedgerJournalTable _ledgerJournalTable)
    {
        // Out of the box imports of journal transactions do not calculate taxes.  Perform a check here to detect
        // this condition, and calculate taxes for the journal if required.
        if (!_ledgerJournalTable.isTaxCalculatedForAllJournalTrans())
        {
            TaxVoucherService::calculateTaxForJournal(_ledgerJournalTable.JournalNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes values on the header record.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record to initialize.
    /// </param>
    void initValueHeader(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        AmountCur amountCur;

        _tmpLedgerJournalSplitHeader.CashDiscAmount = ledgerJournalTransMain.CashDiscAmount;

        if (this.journalAmountInclTax())
        {
            amountCur = this.originalAmountCur() + this.totalGrosAmountCur() + this.amountDifference();
        }
        else
        {
            amountCur = this.originalAmountCur() + this.totalNetAmountCur() + this.amountDifference();
        }

        if (ledgerJournalTransMain.TaxCode)
        {
            _tmpLedgerJournalSplitHeader.TaxCode = ledgerJournalTransMain.TaxCode;
            _tmpLedgerJournalSplitHeader.TaxAmountCur = -amountCur;
        }
        else
        {
            _tmpLedgerJournalSplitHeader.GrosAmountCur = -amountCur;
            _tmpLedgerJournalSplitHeader.NetAmountCur = -amountCur;

            if (ledgerJournalTransMain.TaxGroup)
            {
                _tmpLedgerJournalSplitHeader.TaxGroup = ledgerJournalTransMain.TaxGroup;
            }

            if (ledgerJournalTransMain.TaxItemGroup)
            {
                _tmpLedgerJournalSplitHeader.TaxItemGroup = ledgerJournalTransMain.TaxItemGroup;
            }
            else
            {
                _tmpLedgerJournalSplitHeader.TaxItemGroup = TaxParameters::find().TaxItemGroup;
            }

            if (this.journalAmountInclTax())
            {
                this.calcTaxAmountFromGross(_tmpLedgerJournalSplitHeader);
            }
            else
            {
                this.netAmountModified(_tmpLedgerJournalSplitHeader);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValueLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the amounts on the line.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    /// <param name = "_tmpLedgerJournalSplitLines">
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    void initValueLine(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader,
                       TmpLedgerJournalSplitLines  _tmpLedgerJournalSplitLines)
    {
        AmountCur amountCurToSplit;

        if (_tmpLedgerJournalSplitHeader.TaxCode)
        {
            amountCurToSplit = _tmpLedgerJournalSplitHeader.TaxAmountCur;
        }
        else
        {
            amountCurToSplit = _tmpLedgerJournalSplitHeader.NetAmountCur;
        }

        _tmpLedgerJournalSplitLines.TransTxt        = ledgerJournalTransMain.Txt;

        AmountCur oldAmountLines = this.totalAmountLines(_tmpLedgerJournalSplitHeader.LineNum);
        AmountCur amountCur = amountCurToSplit - oldAmountLines;

        if (ledgerJournalTransMain.AmountCurDebit)
        {
            _tmpLedgerJournalSplitLines.AmountCurCredit = sign(ledgerJournalTransMain.AmountCurDebit) * abs(amountCur);
            _tmpLedgerJournalSplitLines.AmountCurDebit  = 0.0;
        }
        else
        {
            _tmpLedgerJournalSplitLines.AmountCurCredit = 0.0;
            _tmpLedgerJournalSplitLines.AmountCurDebit  = sign(ledgerJournalTransMain.AmountCurCredit) * abs(amountCur);
        }

        AmountCur newAmountLines = oldAmountLines + (_tmpLedgerJournalSplitLines.AmountCurDebit - _tmpLedgerJournalSplitLines.AmountCurCredit);

        if (amountCurToSplit - newAmountLines != 0.0)
        {
            if (ledgerJournalTransMain.AmountCurDebit != 0.0)
            {
                _tmpLedgerJournalSplitLines.AmountCurCredit = 0.0;
                _tmpLedgerJournalSplitLines.AmountCurDebit = sign(ledgerJournalTransMain.AmountCurDebit) * abs(amountCur);
            }
            else
            {
                _tmpLedgerJournalSplitLines.AmountCurCredit = sign(ledgerJournalTransMain.AmountCurCredit) * abs(amountCur);
                _tmpLedgerJournalSplitLines.AmountCurDebit = 0.0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxFromNewLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into the <c>TaxWorkRegulation</c> table for the journal line.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitLines">
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void insertTaxFromNewLine(TmpLedgerJournalSplitLines    _tmpLedgerJournalSplitLines,
                              TmpLedgerJournalSplitHeader   _tmpLedgerJournalSplitHeader)
    {
        LedgerJournalTrans tmpLedgerJournalTrans;
        TaxCalculation taxCalculation;

        tmpLedgerJournalTrans.JournalNum         = ledgerJournalTransMain.JournalNum;
        tmpLedgerJournalTrans.Voucher            = ledgerJournalTransMain.Voucher;
        tmpLedgerJournalTrans.TransDate          = ledgerJournalTransMain.TransDate;
        tmpLedgerJournalTrans.ExchRate           = ledgerJournalTransMain.ExchRate;
        tmpLedgerJournalTrans.ExchRateSecond     = ledgerJournalTransMain.ExchRateSecond;
        tmpLedgerJournalTrans.Triangulation      = ledgerJournalTransMain.Triangulation;
        tmpLedgerJournalTrans.CurrencyCode       = currencyCode;
        tmpLedgerJournalTrans.TaxGroup           = _tmpLedgerJournalSplitHeader.TaxGroup;
        tmpLedgerJournalTrans.TaxItemGroup       = _tmpLedgerJournalSplitHeader.TaxItemGroup;
        if (TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(ledgerJournalTransMain.ledgerJournalTable().JournalType))
        {
            LedgerJournalTransTaxExtension tmpLedgerJournalTransTaxExtension = tmpLedgerJournalTrans.ledgerJournalTransTaxExtension();
            LedgerJournalTransTaxExtension mainLedgerJournalTransTaxExtension = ledgerJournalTransMain.ledgerJournalTransTaxExtension();
            tmpLedgerJournalTransTaxExtension.OverrideSalesTax = mainLedgerJournalTransTaxExtension.OverrideSalesTax;
            tmpLedgerJournalTrans.packExtensionTable(tmpLedgerJournalTransTaxExtension);
        }
        tmpLedgerJournalTrans.Txt                = _tmpLedgerJournalSplitLines.TransTxt;

        tmpLedgerJournalTrans.AccountType = LedgerJournalACType::Ledger;
        tmpLedgerJournalTrans.parmLedgerDimension(_tmpLedgerJournalSplitLines.LedgerDimension);
        tmpLedgerJournalTrans.DefaultDimension = 0;

        tmpLedgerJournalTrans.AmountCurCredit    = _tmpLedgerJournalSplitLines.AmountCurCredit;
        tmpLedgerJournalTrans.AmountCurDebit     = _tmpLedgerJournalSplitLines.AmountCurDebit;

        tmpLedgerJournalTrans.OffsetAccountType  = LedgerJournalACType::Ledger;
        tmpLedgerJournalTrans.parmOffsetLedgerDimension(0);
        tmpLedgerJournalTrans.OffsetDefaultDimension = 0;

        // empty string passed for voucher so that tax only calculates tax on this new line.
        taxCalculation = LedgerJournalTrans::getTaxInstance(tmpLedgerJournalTrans.JournalNum, '', tmpLedgerJournalTrans.Invoice, false, tmpLedgerJournalTrans);

        tmpTaxWorkTrans = taxCalculation.tmpTaxWorkTrans();

        this.fillTaxWorkRegulation(_tmpLedgerJournalSplitLines.TableId, _tmpLedgerJournalSplitLines.RecId);

        delete_from tmpTaxWorkTrans
            where tmpTaxWorkTrans.HeadingRecId == _tmpLedgerJournalSplitLines.RecId
                && tmpTaxWorkTrans.HeadingTableId == _tmpLedgerJournalSplitLines.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalAmountInclTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the journalAmountInclTax value.
    /// </summary>
    /// <returns>
    /// The journalAmountInclTax value.
    /// </returns>
    boolean journalAmountInclTax()
    {
        return journalAmountInclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the last record ID.
    /// </summary>
    /// <param name = "_recId">
    /// A record ID.
    /// </param>
    /// <returns>
    /// The record ID of a <c>LedgerJournalTrans</c> record.
    /// </returns>
    final RecId lastRecId(RecId _recId = lastRecId)
    {
        lastRecId = _recId;
        return lastRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>LedgerJournalTrans</c> record for the specified journal and voucher.
    /// </summary>
    /// <param name = "_ledgerJournalId">
    /// The journal number.
    /// </param>
    /// <param name = "_voucher">
    /// The voucher number.
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalTrans</c> record for the specified journal and voucher.
    /// </returns>
    LedgerJournalTrans mainAccount(LedgerJournalId _ledgerJournalId,
                                   Voucher    _voucher)
    {
        return LedgerJournalTrans::mainAccount(_ledgerJournalId, _voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>netAmountModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amounts when the Net amounts changes.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void netAmountModified(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        AmountCur taxAmountCur;
        TransDate taxCalculationDate = transDate;
        VendCashDiscAmount discAmount;
        DiscPct cashDiscPercent;
        CashDisc cashDisc;

        if (_tmpLedgerJournalSplitHeader.TaxCode)
        {
            _tmpLedgerJournalSplitHeader.NetAmountCur = 0;
        }
        else
        {
            taxCalculationDate = (ledgerJournalTransMain.DocumentDate &&
                                  TaxParameters::find().TaxCalculationDateType == TaxCalculationDateType::DocumentDate)?
                                  ledgerJournalTransMain.DocumentDate:transDate;

            if (TaxParameters::find().TaxLessCashDisc)
            {
                cashDiscPercent = CashDisc::findByCompany(curext(), ledgerJournalTransMain.CashDiscCode).Percent;
                discAmount = -cashDisc.discAmountOnInvoice(ledgerJournalTransMain.CurrencyCode, abs(_tmpLedgerJournalSplitHeader.NetAmountCur), cashDiscPercent);
            }
            else
            {
                discAmount = 0;
            }

            if (_tmpLedgerJournalSplitHeader.TaxGroup && _tmpLedgerJournalSplitHeader.TaxItemGroup)
            {
                taxAmountCur = Tax::calcTaxAmount(_tmpLedgerJournalSplitHeader.TaxGroup,
                                                  _tmpLedgerJournalSplitHeader.TaxItemGroup,
                                                  taxCalculationDate,
                                                  currencyCode,
                                                  _tmpLedgerJournalSplitHeader.NetAmountCur + discAmount,
                                                  taxModuleType);
            }

            _tmpLedgerJournalSplitHeader.TaxAmountCur = taxAmountCur;
            _tmpLedgerJournalSplitHeader.GrosAmountCur = _tmpLedgerJournalSplitHeader.NetAmountCur + taxAmountCur;
        }

        if (_tmpLedgerJournalSplitHeader.RecId)
        {
            _tmpLedgerJournalSplitHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        // Only attempt setting the table buffer as an InMemory table when the config key is enabled, because
        // otherwise the table buffer is already a TempDB table, and changing to InMemory is not allowed.
        if (isConfigurationkeyEnabled(configurationkeynum(LedgerBasicSalesTax)))
        {
            taxWorkRegulationLines.setTmp();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>originalAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the originalAmountCur value.
    /// </summary>
    /// <returns>
    /// The originalAmountCur value.
    /// </returns>
    AmountCur originalAmountCur()
    {
        return originalAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        int     i;
        List    listTmpLedgerJournalSplitHeader = new List(Types::Record);
        List    listTmpLedgerJournalSplitLines  = new List(Types::Record);
        List    listTaxWorkRegulationLines      = new List(Types::Record);
        List    listTmpTaxWorkTrans             = new List(Types::Record);
        List    listDeletedOffset               = new List(typeName2Type(extendedTypeStr(RecId)));
        List    listDeletedOriginal             = new List(typeName2Type(extendedTypeStr(RecId)));

        while   select  tmpLedgerJournalSplitHeader
            order by RecId
        {
            listTmpLedgerJournalSplitHeader.addEnd(tmpLedgerJournalSplitHeader.data());
        }

        while   select  tmpLedgerJournalSplitLines
            order by RecId
        {
            listTmpLedgerJournalSplitLines.addEnd(tmpLedgerJournalSplitLines.data());
        }

        while   select  taxWorkRegulationLines
            order by RecId
        {
            listTaxWorkRegulationLines.addEnd(taxWorkRegulationLines.data());
        }

        while   select  tmpTaxWorkTrans
        {
            listTmpTaxWorkTrans.addEnd(tmpTaxWorkTrans.data());
        }

        for (i = 1; i <= numOfDeletedOffsetRecId; i = i + 1)
        {
            listDeletedOffset.addEnd(deletedOffsetRecId[i]);
        }
        for (i = 1; i <= numOfDeletedOriginalRecId; i = i + 1)
        {
            listDeletedOriginal.addEnd(deletedOriginalRecId[i]);
        }

        return [#CurrentList,
                listTmpLedgerJournalSplitHeader.pack(),
                listTmpLedgerJournalSplitLines.pack(),
                listTaxWorkRegulationLines.pack(),
                listTmpTaxWorkTrans.pack(),
                listDeletedOffset.pack(),
                listDeletedOriginal.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>showUpdateJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if updates should be allowed.
    /// </summary>
    /// <returns>
    /// true if updates should be allowed; otherwise, false.
    /// </returns>
    boolean showUpdateJournal()
    {
        boolean ok = true;
        while select tmpLedgerJournalSplitHeader
        {
            if (tmpLedgerJournalSplitHeader.amountToSplit() - this.totalAmountLines(tmpLedgerJournalSplitHeader.LineNum))
            {
                return false;
            }

            if (tmpLedgerJournalSplitHeader.TaxCode)
            {
                ok = this.validateAccountNumLines(tmpLedgerJournalSplitHeader, false);
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the tax amount is modified.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void taxAmountModified(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        if (!_tmpLedgerJournalSplitHeader.TaxCode)
        {
            if (TaxParameters::find().TaxLessCashDisc)
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = _tmpLedgerJournalSplitHeader.GrosAmountCur - _tmpLedgerJournalSplitHeader.TaxAmountCur +
                        (originalAmountCur ? _tmpLedgerJournalSplitHeader.CashDiscAmount * (abs(_tmpLedgerJournalSplitHeader.GrosAmountCur)/abs(originalAmountCur)) : 0);
            }
            else
            {
                _tmpLedgerJournalSplitHeader.NetAmountCur = _tmpLedgerJournalSplitHeader.GrosAmountCur - _tmpLedgerJournalSplitHeader.TaxAmountCur;
            }
        }

        if (_tmpLedgerJournalSplitHeader.RecId)
        {
            _tmpLedgerJournalSplitHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the posted tax amount.
    /// </summary>
    /// <returns>
    /// Zero.
    /// </returns>
    AmountCur taxAmountPosted()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCodeInHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there is a tax code on the header.
    /// </summary>
    /// <param name = "_lineNum">
    /// The line number.
    /// </param>
    /// <returns>
    /// true if there is a tax code on the header; otherwise, false.
    /// </returns>
    boolean taxCodeInHeader(LineNum _lineNum)
    {
        select firstonly TaxCode from tmpLedgerJournalSplitHeader
            where tmpLedgerJournalSplitHeader.LineNum == _lineNum;

        if (tmpLedgerJournalSplitHeader.TaxCode)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxGroupModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates amounts when the tax group is modified.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    void taxGroupModified(TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader)
    {
        if (_tmpLedgerJournalSplitHeader.TaxCode)
        {
            _tmpLedgerJournalSplitHeader.GrosAmountCur = 0;
            _tmpLedgerJournalSplitHeader.NetAmountCur = 0;
        }
        else
        {
            if (journalAmountInclTax)
            {
                this.calcTaxAmountFromGross(_tmpLedgerJournalSplitHeader);
            }
            else
            {
                this.netAmountModified(_tmpLedgerJournalSplitHeader);
            }
        }

        if (_tmpLedgerJournalSplitHeader.RecId)
        {
            _tmpLedgerJournalSplitHeader.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpLedgerJournalSplitHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>TmpLedgerJournalSplitHeader</c> record.
    /// </summary>
    /// <returns>
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </returns>
    TmpLedgerJournalSplitHeader tmpLedgerJournalSplitHeader()
    {
        return tmpLedgerJournalSplitHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpLedgerJournalSplitLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the <c>TmpLedgerJournalSplitLines</c> record.
    /// </summary>
    /// <returns>
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </returns>
    TmpLedgerJournalSplitLines tmpLedgerJournalSplitLines()
    {
        return tmpLedgerJournalSplitLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmountLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount on the specified line.
    /// </summary>
    /// <param name = "_lineNum">
    /// The line number.
    /// </param>
    /// <returns>
    /// The total amount on the line.
    /// </returns>
    AmountCur totalAmountLines(LineNum _lineNum)
    {
        select sum(AmountCurCredit), sum(AmountCurDebit) from tmpLedgerJournalSplitLines
            where tmpLedgerJournalSplitLines.LineNum == _lineNum;

        return tmpLedgerJournalSplitLines.AmountCurDebit - tmpLedgerJournalSplitLines.AmountCurCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalGrosAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount.
    /// </summary>
    /// <returns>
    /// The total amount.
    /// </returns>
    AmountCur totalGrosAmountCur()
    {
        AmountCur amountCur;

        while select tmpLedgerJournalSplitHeader
        {
            if (tmpLedgerJournalSplitHeader.TaxCode)
            {
                amountCur += tmpLedgerJournalSplitHeader.TaxAmountCur;
            }
            else
            {
                amountCur += tmpLedgerJournalSplitHeader.GrosAmountCur;
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalNetAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total Net amount.
    /// </summary>
    /// <returns>
    /// The total Net amount.
    /// </returns>
    AmountCur totalNetAmountCur()
    {
        AmountCur amountCur;

        while select tmpLedgerJournalSplitHeader
        {
            amountCur += tmpLedgerJournalSplitHeader.amountToSplit();
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total amount in transaction currency.
    /// </summary>
    /// <returns>
    /// The total amount in transaction currency.
    /// </returns>
    AmountCur totalTaxAmountCur()
    {
        select sum(TaxAmountCur) from tmpLedgerJournalSplitHeader;

        return tmpLedgerJournalSplitHeader.TaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalTaxPerLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the total tax for the specified line.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitLines">
    /// The <c>TmpLedgerJournalSplitLines</c> record.
    /// </param>
    /// <returns>
    /// The total tax for the specified line.
    /// </returns>
    AmountCur totalTaxPerLine(TmpLedgerJournalSplitLines _tmpLedgerJournalSplitLines)
    {
        select sum(TaxRegulationAmountCur) from taxWorkRegulationLines
            where taxWorkRegulationLines.HeadingTableId == _tmpLedgerJournalSplitLines.TableId
               && taxWorkRegulationLines.HeadingRecId == _tmpLedgerJournalSplitLines.RecId;

        return taxWorkRegulationLines.TaxRegulationAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferTaxWorkRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies <c>TaxWorkRegulation</c> records.
    /// </summary>
    /// <param name = "_fromTableId">
    /// The table identifier to copy from.
    /// </param>
    /// <param name = "_fromRecId">
    /// The record identifier to copy from.
    /// </param>
    /// <param name = "_toTableId">
    /// The table identifier to copy to.
    /// </param>
    /// <param name = "_toRecId">
    /// The record identifier to copy to.
    /// </param>
    public void transferTaxWorkRegulation(TableId _fromTableId, RecId _fromRecId, TableId _toTableId, RecId _toRecId)
    {
        TaxWorkRegulation taxWorkRegulation;

        if ((_toTableId != 0) && (_toRecId != 0))
        {
            ttsbegin;

            while   select  taxWorkRegulation
                    where   taxWorkRegulation.HeadingTableId == _fromTableId
                       &&   taxWorkRegulation.HeadingRecId == _fromRecId
            {
                taxWorkRegulationLines.data(taxWorkRegulation);
                taxWorkRegulationLines.HeadingTableId = _toTableId;
                taxWorkRegulationLines.HeadingRecId = _toRecId;
                taxWorkRegulationLines.insert();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the specified container contents.
    /// </summary>
    /// <param name = "packedClass">
    /// A container with the contents of a <c>LedgerJournalSplitPosting</c> class.
    /// </param>
    public void unpack(container packedClass)
    {
        ListIterator    li;
        container       conTmpLedgerJournalSplitHeader;
        container       conTmpLedgerJournalSplitLines;
        container       conTaxWorkRegulationLines;
        container       conTmpTaxWorkTrans;
        container       conDeletedOffset;
        container       conDeletedOriginal;
        RecId           recIDOld;

        List            listTmpLedgerJournalSplitHeader;
        List            listTmpLedgerJournalSplitLines;
        List            listTaxWorkRegulationLines;
        List            listTmpTaxWorkTrans;
        List            listDeletedOffset;
        List            listDeletedOriginal;

        int             i;

        [#CurrentList,
         conTmpLedgerJournalSplitHeader,
         conTmpLedgerJournalSplitLines,
         conTaxWorkRegulationLines,
         conTmpTaxWorkTrans,
         conDeletedOffset,
         conDeletedOriginal] = packedClass;

        listTmpLedgerJournalSplitHeader = List::create(conTmpLedgerJournalSplitHeader);
        listTmpLedgerJournalSplitLines  = List::create(conTmpLedgerJournalSplitLines);
        listTaxWorkRegulationLines      = List::create(conTaxWorkRegulationLines);
        listTmpTaxWorkTrans             = List::create(conTmpTaxWorkTrans);
        listDeletedOffset               = List::create(conDeletedOffset);
        listDeletedOriginal             = List::create(conDeletedOriginal);

        li = new ListIterator(listTmpLedgerJournalSplitHeader);
        li.begin();
        while (li.more())
        {
            tmpLedgerJournalSplitHeader.data(li.value());
            tmpLedgerJournalSplitHeader.RecId = 0;
            tmpLedgerJournalSplitHeader.doInsert();
            li.next();
        }

        li = new ListIterator(listTaxWorkRegulationLines);
        li.begin();
        while (li.more())
        {
            taxWorkRegulationLines.data(li.value());
            taxWorkRegulationLines.RecId = 0;
            taxWorkRegulationLines.doInsert();
            li.next();
        }

        li = new ListIterator(listTmpTaxWorkTrans);
        li.begin();
        while (li.more())
        {
            tmpTaxWorkTrans.data(li.value());
            tmpTaxWorkTrans.RecId = 0;
            tmpTaxWorkTrans.doInsert();
            li.next();
        }

        li = new ListIterator(listTmpLedgerJournalSplitLines);
        li.begin();
        while (li.more())
        {
            tmpLedgerJournalSplitLines.data(li.value());

            recIDOld = tmpLedgerJournalSplitLines.RecId;

            tmpLedgerJournalSplitLines.RecId = 0;
            tmpLedgerJournalSplitLines.doInsert();

            if (tmpLedgerJournalSplitLines.RecId != recIDOld)
            {
                update_recordset taxWorkRegulationLines
                    setting HeadingRecId = tmpLedgerJournalSplitLines.RecId
                    where taxWorkRegulationLines.HeadingTableId == tmpLedgerJournalSplitLines.TableId
                       && taxWorkRegulationLines.HeadingRecId == recIDOld;
                update_recordset tmpTaxWorkTrans
                    setting HeadingRecId = tmpLedgerJournalSplitLines.RecId
                    where  tmpTaxWorkTrans.HeadingRecId == recIDOld;
            }

            li.next();
        }

        li = new ListIterator(listDeletedOffset);
        li.begin();
        for (i = 1; li.more() ; i = i + 1)
        {
            deletedOffsetRecId[i] = li.value();
            li.next();
        }

        li = new ListIterator(listDeletedOriginal);
        li.begin();
        for (i = 1; li.more() ; i = i + 1)
        {
            deletedOriginalRecId[i] = li.value();
            li.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the ledger journal with the information from the class.
    /// </summary>
    void updateLedgerJournal()
    {
        LedgerJournalTrans   ledgerJournalTrans;
        LedgerJournalTrans   ledgerJournalTransOffset;
        AmountCur            totalAmountCur;
        AmountCur            amountMissing;
        Counter              idx;
        LineNum              lineNum;
        LineNum              lineNumNext;
        AmountCur            amountCur;
        AmountCur            amountToAllocate;
        AmountCur            highestAmountCur = -1;
        RecId                ledgerJournalTransRecID;

        boolean isFinTagConfigurationSetForPrimary = FinTagConfiguration::isFinTagConfigurationSet(ledgerJournalTransMain.Company);
        boolean isFinTagConfigurationSetForOffset = FinTagConfiguration::isFinTagConfigurationSet(ledgerJournalTransMain.getOffsetCompany());

        ttsbegin;

        TaxUncommitted::deleteForDocumentHeader(ledgerJournalTableMain.TableId, ledgerJournalTableMain.RecId, false, false);

        if (ledgerJournalTransMain)
        {
            if (mainAccountIsOffsetAccount)
            {
                ledgerJournalTrans = ledgerJournalTransMain.data();

                ledgerJournalTrans.AccountType = ledgerJournalTrans.OffsetAccountType;
                ledgerJournalTrans.parmLedgerDimension(ledgerJournalTrans.parmOffsetLedgerDimension());
                ledgerJournalTrans.DefaultDimension = ledgerJournalTrans.OffsetDefaultDimension;

                ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
                ledgerJournalTrans.parmOffsetLedgerDimension(0);
                ledgerJournalTrans.OffsetDefaultDimension = 0;

                amountCur = ledgerJournalTrans.AmountCurDebit;
                ledgerJournalTrans.AmountCurDebit = ledgerJournalTrans.AmountCurCredit;
                ledgerJournalTrans.AmountCurCredit = amountCur;
                ledgerJournalTrans.TaxItemGroup      = '';
                ledgerJournalTrans.TaxCode  = '';
                ledgerJournalTrans.CashDiscAmount = -ledgerJournalTrans.CashDiscAmount;

                if (isFinTagConfigurationSetForOffset)
                {
                    ledgerJournalTrans.FinTag = ledgerJournalTrans.OffsetFinTag;
                }

                ledgerJournalTrans.insert();
            }

            if (ledgerJournalTransMain.AccountType != LedgerJournalACType::Ledger)
            {
                select firstonly forupdate ledgerJournalTransOffset
                where ledgerJournalTransOffset.JournalNum == ledgerJournalTransMain.JournalNum &&
                      ledgerJournalTransOffset.Voucher    == ledgerJournalTransMain.Voucher    &&
                      ledgerJournalTransOffset.RecId      == ledgerJournalTransMain.RecId;
                ledgerJournalTransOffset.TaxCode           = '';
                ledgerJournalTransOffset.TaxItemGroup      = ledgerJournalTransMain.TaxItemGroup;
                ledgerJournalTransOffset.update();
            }

            this.lastRecId(ledgerJournalTransMain.RecId);
            for (idx = 1; idx <= numOfDeletedOffsetRecId; idx++)
            {
                select firstonly forupdate ledgerJournalTransOffset
                where ledgerJournalTransOffset.JournalNum == ledgerJournalTransMain.JournalNum &&
                      ledgerJournalTransOffset.Voucher    == ledgerJournalTransMain.Voucher    &&
                      ledgerJournalTransOffset.RecId      == deletedOffsetRecId[idx];

                if (ledgerJournalTransOffset)
                {
                    ledgerJournalTransOffset.OffsetAccountType = LedgerJournalACType::Ledger;
                    ledgerJournalTransOffset.parmOffsetLedgerDimension(0);
                    ledgerJournalTransOffset.OffsetDefaultDimension = 0;

                    ledgerJournalTransOffset.TaxCode           = '';
                    ledgerJournalTransOffset.TaxItemGroup      = '';
                    ledgerJournalTransOffset.update();
                }
            }

            for (idx = 1; idx <= numOfDeletedOriginalRecId; idx++)
            {
                if (deletedOriginalRecId[idx] != ledgerJournalTransMain.RecId)
                {
                    select firstonly forupdate ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == ledgerJournalTransMain.JournalNum &&
                          ledgerJournalTrans.Voucher    == ledgerJournalTransMain.Voucher    &&
                          ledgerJournalTrans.RecId      == deletedOriginalRecId[idx];
                    if (ledgerJournalTrans)
                    {
                        ledgerJournalTrans.delete();
                    }
                }
            }

            // These variables are used to track the journal line with the largest total tax transaction amount
            // if an adjustment needs to be made where the calculated tax totals do not equal the user inputted
            // tax total of the breakdown header entries.
            TaxAmount largestTaxAmount;
            RecId largestTaxAmountLedgerJournalTransRecordId;

            while select tmpLedgerJournalSplitHeader
            {
                totalAmountCur = 0;

                while select tmpLedgerJournalSplitLines
                    where tmpLedgerJournalSplitHeader.LineNum == tmpLedgerJournalSplitLines.LineNum
                {
                    if (tmpLedgerJournalSplitLines.OffsetRecId)
                    {
                        select firstonly forupdate ledgerJournalTransOffset
                        where ledgerJournalTransOffset.JournalNum == ledgerJournalTransMain.JournalNum &&
                              ledgerJournalTransOffset.Voucher    == ledgerJournalTransMain.Voucher    &&
                              ledgerJournalTransOffset.RecId      == tmpLedgerJournalSplitLines.OffsetRecId;

                        if (ledgerJournalTransOffset)
                        {
                            ledgerJournalTransOffset.OffsetAccountType = LedgerJournalACType::Ledger;
                            ledgerJournalTransOffset.parmOffsetLedgerDimension(0);
                            ledgerJournalTransOffset.OffsetDefaultDimension = 0;
                            ledgerJournalTransOffset.update();
                        }
                    }

                    ledgerJournalTrans.clear();
                    if (tmpLedgerJournalSplitLines.OriginalRecId)
                    {
                        select firstonly forupdate ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTransMain.JournalNum &&
                              ledgerJournalTrans.Voucher    == ledgerJournalTransMain.Voucher    &&
                              ledgerJournalTrans.RecId      == tmpLedgerJournalSplitLines.OriginalRecId;
                    }

                    if (!ledgerJournalTrans)
                    {
                        lineNum = (select   maxof(LineNum)
                                    from    ledgerJournalTrans
                                    where   ledgerJournalTrans.JournalNum == ledgerJournalTransMain.JournalNum  &&
                                            ledgerJournalTrans.Voucher    == ledgerJournalTransMain.Voucher).LineNum;
                        lineNumNext = (select  minof(LineNum)
                                    from    ledgerJournalTrans
                                    where   ledgerJournalTrans.JournalNum == ledgerJournalTransMain.JournalNum  &&
                                            ledgerJournalTrans.LineNum    >  lineNum).LineNum;
                        ledgerJournalTrans = ledgerJournalTransMain.data();

                        if (lineNumNext)
                        {
                            ledgerJournalTrans.LineNum = lineNum + (lineNumNext - lineNum) / 2;
                        }
                        else
                        {
                            ledgerJournalTrans.LineNum = lineNum + 1;
                        }

                        this.updateSpecialFields(ledgerJournalTrans);

                        ledgerJournalTrans.CashDiscAmount = 0;

                        boolean isSplittingOffSetAccount = ledgerJournalTransMain.OffsetAccountType == LedgerJournalACType::Ledger;
                        if (isSplittingOffSetAccount)
                        {
                            if (isFinTagConfigurationSetForOffset)
                            {
                                ledgerJournalTrans.FinTag = ledgerJournalTransMain.OffsetFinTag;
                            }
                        }
                        else
                        {
                            if (isFinTagConfigurationSetForPrimary)
                            {
                                ledgerJournalTrans.FinTag = ledgerJournalTransMain.FinTag;
                            }
                        }

                        ledgerJournalTrans.insert();
                        this.lastRecId(ledgerJournalTrans.RecId);
                    }

                    this.fillLedgerJournalTrans(
                        ledgerJournalTrans,
                        tmpLedgerJournalSplitLines,
                        tmpLedgerJournalSplitHeader);

                    ledgerJournalTrans.update();

                    // determine which record has the highest amount so any adjustment
                    // is made to it instead of just the last one.
                    if (abs(ledgerJournalTrans.amount()) > abs(highestAmountCur))
                    {
                        highestAmountCur = ledgerJournalTrans.amount();
                        ledgerJournalTransRecID = ledgerJournalTrans.RecId;
                    }

                    // Track the journal line which has the highest tax amount in the event any tax adjustment
                    // needs to be made to adjust the total tax amount.
                    if (ledgerJournalTrans.isTaxable())
                    {
                        TaxAmount totalTaxAmountForLine = ledgerJournalTrans.totalTaxAmountSingleLine(true, false, true);

                        if (abs(totalTaxAmountForLine) > abs(largestTaxAmount))
                        {
                            largestTaxAmount = totalTaxAmountForLine;
                            largestTaxAmountLedgerJournalTransRecordId = ledgerJournalTrans.RecId;
                        }
                    }

                    totalAmountCur += ledgerJournalTrans.amount();
                }

                if (tmpLedgerJournalSplitHeader.TaxCode)
                {
                    amountToAllocate = tmpLedgerJournalSplitHeader.TaxAmountCur;
                }
                else
                {
                    if (journalAmountInclTax)
                    {
                        amountToAllocate = tmpLedgerJournalSplitHeader.GrosAmountCur;
                    }
                    else
                    {
                        amountToAllocate = tmpLedgerJournalSplitHeader.NetAmountCur;
                    }
                }
                if (totalAmountCur != amountToAllocate)
                {
                    amountMissing = amountToAllocate - totalAmountCur;

                    select firstonly forupdate ledgerJournalTrans
                        where ledgerJournalTrans.RecId == ledgerJournalTransRecID;

                    if (ledgerJournalTrans.AmountCurDebit)
                    {
                        ledgerJournalTrans.AmountCurDebit += amountMissing;
                        ledgerJournalTrans.update();
                    }

                    if (ledgerJournalTrans.AmountCurCredit)
                    {
                        ledgerJournalTrans.AmountCurCredit -= amountMissing;
                        ledgerJournalTrans.update();
                    }
                }
            }

            // The line tax amounts are calculated by the tax engine for each individual
            // breakdown line.  Due to rounding variances, the individual line tax amounts
            // when summarized can differ from the header level tax amount to allocate specified.
            // To account for this, we adjust the line with the largest amount by the difference
            // of the header value, and the summarized line values.
            if (largestTaxAmountLedgerJournalTransRecordId)
            {
                select firstonly ledgerJournalTrans
                    where ledgerJournalTrans.RecId == largestTaxAmountLedgerJournalTransRecordId;

                this.adjustTaxLineSummarizedBalanceDifference(ledgerJournalTrans);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTaxLineSummarizedBalanceDifference</Name>
				<Source><![CDATA[
    private void adjustTaxLineSummarizedBalanceDifference(
        LedgerJournalTrans _ledgerJournalTransToAdjust)
    {
        // Retrieve the summarized tax amount specified, and the calculated tax lines amounts for totals comparison
        TaxAmount taxAmountToAllocate = this.totalTaxAmountCur();
        TaxAmount taxAmountAllocated = this.getTotalTaxCalculatedAmount();
        
        if (taxAmountToAllocate && taxAmountAllocated && (taxAmountAllocated != taxAmountToAllocate))
        {
            TaxAmount difference = (taxAmountToAllocate - taxAmountAllocated);

            // Retrieve the calculated tax amount for the journal line to adjust.
            TaxAmount calculatedTaxAmount = this.calcTaxAmountFromExcl(_ledgerJournalTransToAdjust);

            TaxAmount adjustedTaxAmount = calculatedTaxAmount + difference;

            // Adjust the existing tax adjustment by the difference of the header amount and the summarized
            // tax line allocated amounts.
            LedgerJournalEngine_Server::correctTaxAmount(
                _ledgerJournalTransToAdjust,
                adjustedTaxAmount);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalTaxCalculatedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total tax amount for the journal voucher/invoice.
    /// </summary>
    /// <returns>The total tax amount for the journal voucher/invoice.</returns>
    private TaxAmount getTotalTaxCalculatedAmount()
    {
        TaxCalculation taxCalculation = LedgerJournalTrans::getTaxInstance(ledgerJournalTransMain.JournalNum, ledgerJournalTransMain.Voucher, ledgerJournalTransMain.Invoice, true);

        return taxCalculation.totalTaxAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSpecialFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does nothing.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    protected void updateSpecialFields(LedgerJournalTrans _ledgerJournalTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the transaction should be used or not.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <returns>
    /// true.
    /// </returns>
    protected boolean useTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAccountNumLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the split lines.
    /// </summary>
    /// <param name = "_tmpLedgerJournalSplitHeader">
    /// The <c>TmpLedgerJournalSplitHeader</c> record.
    /// </param>
    /// <param name = "_showError">
    /// Determines if error messages should be shown; optional.
    /// </param>
    /// <returns>
    /// true if the lines are in a valid state; otherwise, false.
    /// </returns>
    boolean validateAccountNumLines(
        TmpLedgerJournalSplitHeader _tmpLedgerJournalSplitHeader,
        boolean                     _showError = true)
    {
        boolean ok = true;
        boolean ret = true;

        while select tmpLedgerJournalSplitLines
            where tmpLedgerJournalSplitLines.LineNum == _tmpLedgerJournalSplitHeader.LineNum
        {
            if (_tmpLedgerJournalSplitHeader.TaxCode)
            {
                ok = TaxLedgerAccountGroup::ledgerDimensionExistInGroup(TaxTable::find(tmpLedgerJournalSplitHeader.TaxCode).TaxAccountGroup,
                                                                        tmpLedgerJournalSplitLines.LedgerDimension);
                if (!ok)
                {
                    if (_showError)
                    {
                        return checkFailed(strFmt("@SYS50905", LedgerDimensionFacade::getMainAccountFromLedgerDimension(tmpLedgerJournalSplitLines.LedgerDimension).MainAccountId));
                    }
                    else
                    {
                        return false;
                    }
                }
            }

            ret = ret && ok;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the ledger dimension for the specified line.
    /// </summary>
    /// <param name = "_lineNum">
    /// The line number
    /// </param>
    /// <param name = "_ledgerDimension">
    /// The ledger dimension value.
    /// </param>
    /// <returns>
    /// true if the ledger dimension is in a valid state; otherwise, false.
    /// </returns>
    boolean validateLedgerDimension(
        LineNum                 _lineNum,
        LedgerDimensionAccount  _ledgerDimension)
    {
        boolean ok = true;

        select tmpLedgerJournalSplitHeader where tmpLedgerJournalSplitHeader.LineNum == _lineNum;

        if (tmpLedgerJournalSplitHeader.TaxCode)
        {
            ok = TaxLedgerAccountGroup::ledgerDimensionExistInGroup(TaxTable::find(tmpLedgerJournalSplitHeader.TaxCode).TaxAccountGroup,
                                                            _ledgerDimension);
            if (!ok)
            {
                return checkFailed(strFmt("@SYS50905", LedgerDimensionFacade::getMainAccountFromLedgerDimension(_ledgerDimension).MainAccountId));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    boolean validateWrite(TmpLedgerJournalSplitLines _tmpLedgerJournalSplitLines)
    {
        return this.validateLedgerDimension(_tmpLedgerJournalSplitLines.LineNum,
                                            _tmpLedgerJournalSplitLines.LedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>voucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the voucher.
    /// </summary>
    /// <returns>
    /// The voucher.
    /// </returns>
    Voucher voucher()
    {
        return ledgerJournalTransMain.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerJournalServer</Name>
				<Source><![CDATA[
    static void updateLedgerJournalServer(LedgerJournalType _ledgerJournalType, container _packedClass)
    {
        LedgerJournalSplitPosting ledgerJournalSplitPosting;

        if (_ledgerJournalType == LedgerJournalType::Approval)
        {
            ledgerJournalSplitPosting = LedgerJournalSplitPostingApprove::construct();
        }
        else
        {
            ledgerJournalSplitPosting = LedgerJournalSplitPosting::construct();
        }
        ledgerJournalSplitPosting.unpack(_packedClass);
        ledgerJournalSplitPosting.updateLedgerJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerJournalSplitPosting</c> object.
    /// </summary>
    /// <returns>A new instance of the <c>LedgerJournalSplitPosting</c> object.</returns>
    public static LedgerJournalSplitPosting construct()
    {
        return new LedgerJournalSplitPosting();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>