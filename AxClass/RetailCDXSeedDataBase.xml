<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCDXSeedDataBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class RetailCDXSeedDataBase
{
    private RetailCDXSeedDataLogger logger;
    boolean isExecutedFromUI = false;
    private boolean updateSubjobsOnly = false;
    str defaultChannelTableSchemaName = 'ax';
    str resourceSchemaName;
    private RefRecId channelSchemaRecID = -1;
    XmlNode jobs;
    XmlNode subjobs;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the <c>RetailCDXSeedDataBase</c> class
    /// </summary>
    public void new()
    {
        logger = new RetailCDXSeedDataLogger(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Call this wrapper method to insert cdx related seed data into database.
    /// </summary>
    public void run()
    {
        System.Exception ex;
        try
        {
            logger.logCDXInitializeSchedulerStart();

            ttsbegin;

            // If running in the mode to update subjobs only, make sure there is already an schema and not running with delete existing configuration
            if (this.paramUpdateSubjobsOnly() && this.getChannelSchemaRecID() && !this.shouldClearPreviousSeedData())
            {
                this.initialize();
                this.createSubjobs();
                RetailCDXCodeGen::generate(this.getChannelSchemaRecID());
            }
            else
            {
                RetailConnChannelSchema::InsertDefault();

                if (this.shouldClearPreviousSeedData())
                {
                    this.clearTables();
                }

                this.initialize();
                this.createJobs();
                this.createSubjobs();

                RetailCDXSessionIDGenerator::initialize();

                if (this.getChannelSchemaRecID())
                {
                    RetailCDXCodeGen::generate(this.getChannelSchemaRecID());
                }

                this.setupRecurringBatchJob();
            }
            ttscommit;
        }
        catch (ex)
        {
            logger.logCDXInitializeSchedulerFailure(ex);
            throw error(ex.Message);
        }
        finally
        {
            logger.logCDXInitializeSchedulerStop(ex);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes RetailCDXSeedData.
    /// </summary>
    /// <remarks>This method is made public for test purpose only</remarks>
    public void initialize()
    {
        str cdxSeedDataXml = this.getCoreCDXSeedDataXmlStr();

        List cdxSeedDataExtensionXmls = this.getCDXExtensionXmlList();

        this.initializeFromArgs(cdxSeedDataXml, cdxSeedDataExtensionXmls);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCDXExtensionXmlList</Name>
				<Source><![CDATA[
    private List getCDXExtensionXmlList()
    {
        List cdxSeedDataExtensionResources = this.getCDXSeedDataExtensionResources();
        List cdxSeedDataExtensionXmls = new List(Types::String);

        ListEnumerator extensionResourceEnumerator = cdxSeedDataExtensionResources.getEnumerator();
        while (extensionResourceEnumerator.moveNext())
        {
            str cdxSeedDataExtensionXml = this.retrieveXmlStrFromResource(extensionResourceEnumerator.current());

            if (cdxSeedDataExtensionXml)
            {
                cdxSeedDataExtensionXmls.addEnd(cdxSeedDataExtensionXml);
            }
        }

        return cdxSeedDataExtensionXmls;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCoreCDXSeedDataXmlStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the core CDX seed data definition.
    /// </summary>
    /// <returns>The CDX definition</returns>
    /// <remarks>Note that changing this may affect test cases. Since we use it to inject test CDX definition xml string.</remarks>
    private str getCoreCDXSeedDataXmlStr()
    {
        return this.retrieveXmlStrFromResource(this.getCoreCDXSeedDataResource());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromArgs</Name>
				<Source><![CDATA[
    protected void initializeFromArgs(str cdxSeedDataXml, List cdxSeedDataExtensionXmls)
    {
        str xsd = this.retrieveXmlStrFromResource(this.getXSDSchemaResource());

        if (cdxSeedDataExtensionXmls)
        {
            ListEnumerator extensionXmlEnumerator = cdxSeedDataExtensionXmls.getEnumerator();

            while (extensionXmlEnumerator.moveNext())
            {
                str cdxSeedDataExtensionXml = extensionXmlEnumerator.current();

                if (cdxSeedDataExtensionXml)
                {
                    cdxSeedDataXml = this.combineCDXSeedDataResources(cdxSeedDataXml, cdxSeedDataExtensionXml);
                }
            }
        }
        
        this.validateXmlUsingXsd(cdxSeedDataXml, xsd);
        this.loadDataFromXmlStr(cdxSeedDataXml);
        this.setupSchema();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromSeedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes RetailCDXSeedData exclude the extension seed data
    /// </summary>
    internal void initializeFromSeedData()
    {
        str cdxSeedDataXml = this.getCoreCDXSeedDataXmlStr();
        this.initializeFromArgs(cdxSeedDataXml, null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldClearPreviousSeedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether to clear the previous CDX seed data configuration.
    /// </summary>
    /// <returns>True if previous seed data configuration should be deleted; false otherwise.</returns>
    internal abstract boolean shouldClearPreviousSeedData()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJobs</Name>
				<Source><![CDATA[
    protected void createJobs()
    {
        XmlNodeList list = jobs.childNodes();
        for (int i = 0; i < list.length(); i++)
        {
            XmlElement e = list.item(i);
            str id = this.getAttrFromXmlElement(e, 'Id');

            str description = this.getJobDescription(e, id);

            boolean isUpload = this.getIsUploadAttr(e);

            RetailCDXEntityTypeBase entityType = this.getEntityType(e);

            RetailConnSchedulerJobTable job;
            select forupdate firstonly job where job.JobId == id;
            if (job)
            {
                job.Description = description;
                job.RetailConnChannelSchema = this.getChannelSchemaRecID();
                job.IsUpload = isUpload;
                job.EntityType = entityType;
                job.update();
            }
            else
            {
                job.initValue();
                job.JobId = id;
                job.Description = description;
                job.RetailConnChannelSchema = this.getChannelSchemaRecID();
                job.IsUpload = isUpload;
                job.EntityType = entityType;
                job.insert();
            }
            this.createJobSchedule(job);
        }
        
        this.setupCDXDataGroup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJobSchedule</Name>
				<Source><![CDATA[
    protected void createJobSchedule(RetailConnSchedulerJobTable job)
    {
        // Insert schedule for the current job.
        RetailConnSchedule schedule;
        select firstonly schedule where schedule.Name == job.jobId;
        if (!schedule)
        {
            // Insert schedule if not found.
            schedule.initValue();
            schedule.Name = job.jobId;
            schedule.Description = job.description;
            schedule.Active = NoYes::Yes;
            if (job.IsUpload)
            {
                schedule.ScheduleType = RetailCDXDownloadUpload::Upload;
            }
            else
            {
                schedule.ScheduleType = RetailCDXDownloadUpload::Download;
            }

            schedule.insert();
        }

        // Insert job and schedule mapping for the current job.
        RetailConnScheduleJobMapping jobMapping;
        select firstonly jobMapping where jobMapping.ScheduleRecId == schedule.RecId && jobMapping.SchedulerJobId == job.jobId;
        if (!jobMapping)
        {
            // Insert job and schedule mapping if not found.
            jobMapping.initValue();
            jobMapping.ScheduleRecId = schedule.RecId;
            jobMapping.SchedulerJobId = job.jobId;
            jobMapping.insert();
        }

        if (!job.IsUpload)
        {
            // If current job is a download job, append the current job to all jobs schedule.
            Name fullSyncScheduleName = this.getFullSyncScheduleName();
            select firstonly RecId from schedule where schedule.Name == fullSyncScheduleName;
            if (!schedule)
            {
                // Insert all jobs schedule if not found.
                schedule.initValue();
                schedule.Name = fullSyncScheduleName;
                schedule.Description = this.getFullSyncScheduleDescription();
                schedule.ScheduleType = RetailCDXDownloadUpload::Download;
                schedule.Active = NoYes::Yes;
                schedule.insert();
            }

            select firstonly jobMapping where jobMapping.ScheduleRecId == schedule.RecId && jobMapping.SchedulerJobId == job.jobId;
            if (!jobMapping)
            {
                // Insert current job and all jobs schedule mapping if not found.
                jobMapping.initValue();
                jobMapping.ScheduleRecId = schedule.RecId;
                jobMapping.SchedulerJobId = job.jobId;
                jobMapping.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSyncScheduleName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the schedule name used for running all download jobs at the same time.
    /// </summary>
    /// <returns>The name of the schedule.</returns>
    protected abstract Name getFullSyncScheduleName()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullSyncScheduleDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets description of the schedule used that will be used for running all download jobs at the same time.
    /// </summary>
    /// <returns>The description of the schedule.</returns>
    protected abstract Description getFullSyncScheduleDescription()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubjobs</Name>
				<Source><![CDATA[
    protected void createSubjobs()
    {
        container createdSubjobIds;
        container createdSubjobTableNames;
        container createdSubjobTargetTableNames;

        XmlNodeList list = subjobs.childNodes();
        for (int i = 0 ; i < list.length(); i++)
        {
            XmlElement subjob = list.item(i);

            // Fill AX side info.
            str subjobId = this.getAttrFromXmlElement(subjob, 'Id');
            str axTableName = this.getAttrFromXmlElement(subjob, 'AxTableName');
            str targetTableName = this.getAttrFromXmlElement(subjob, 'TargetTableName', false);
            boolean allowSkipDataSync = this.getAllowSkipDataSyncAttr(subjob);
            boolean foundSubjob = conFind(createdSubjobIds, subjobId) != 0;
            boolean foundTable = conFind(createdSubjobTableNames, axTableName) != 0;
            boolean foundTargetTable = conFind(createdSubjobTargetTableNames, targetTableName) != 0;

            str channelDBSchema = this.getAttrFromXmlElement(subjob, 'TargetTableSchema', false);
            channelDBSchema = channelDBSchema == '' ? defaultChannelTableSchemaName : channelDBSchema;
            RetailDateFilterField dateFilterField = this.getAttrFromXmlElement(subjob, 'DateFilterField', false);

            if (foundSubjob)
            {
                throw Global::error(strFmt('@Retail:CDXSeedDataDuplicateSubjob', subjobId));
            }

            if (foundTable)
            {
                throw Global::error(strFmt('@Retail:CDXSeedDataDuplicateSubjobTable', axTableName));
            }

            if (foundTargetTable)
            {
                throw Global::error(strFmt('@Retail:CDXSeedDataDuplicateSubjobTargetTable', targetTableName));
            }

            container allFields = this.getXmlElementsContent(subjob, 'AxFields', true);

            container axFields = this.getAxFieldNames(allFields);

            // Fill channel side info.
            str channelTableName = System.String::IsNullOrEmpty(targetTableName) ? strUpr(axTableName) : targetTableName;
            str channelTableFullName = strUpr(channelDBSchema + '.' + channelTableName);
            container channelFields = this.getChannelFieldNames(allFields);

            container channelExtensionFullTableNames = this.getChannelExtensionFullTableNames(subjob, channelTableFullName);

            // Fill job id containier.
            XmlElement scheduledByJobs = subjob.getNamedElement('ScheduledByJobs');
            container scheduledByJobIds;
            container processedJobIds;
            if (scheduledByJobs)
            {
                scheduledByJobIds = this.getXmlElementsContent(subjob, 'ScheduledByJobs');
            }

            // Fields for upload jobs only
            boolean isUpload = this.getIsUploadAttr(subjob);
            str repCntFieldName;

            if (IsUpload)
            {
                repCntFieldName = this.getAttrFromXmlElement(subjob, 'ReplicationCounterFieldName');

                if (!repCntFieldName)
                {
                    Global::error(strfmt("@Retail:RetailCDXMissingReplicationCounterFieldName", subjobId));
                }

                if (scheduledByJobs)
                {
                    // Only process job id if they are present in the seed data.
                    // here get rid of the prefix 'P-' for upload job because in RetailCDXSeedDataSubJob it will be included
                    for (int x = 1; x <= conLen(scheduledByJobIds); x++)
                    {
                        str tmp = conPeek(scheduledByJobIds, x);
                        int pos = strFind(tmp, 'P-', 1, strLen(subjobId));
                        tmp = strDel(tmp, pos, 2);
                        processedJobIds += tmp;
                    }
                }
            }
            else
            {
                processedJobIds = scheduledByJobIds;
            }

            RetailCDXSeedDataSubJob subjobCreation = new RetailCDXSeedDataSubJob();

            subjobCreation.paramJobIDs(processedJobIds);
            subjobCreation.paramSubJobID(subjobId);
            subjobCreation.paramSubJobName(subjobId);
            subjobCreation.paramChannelTableSchemaName(channelDBSchema);
            subjobCreation.paramChannelTableName(channelTableName);
            subjobCreation.paramAXTableName(axTableName);
            subjobCreation.paramChannelFieldNames(channelFields);
            subjobCreation.paramAXFieldNames(axFields);
            subjobCreation.paramChannelSchema(this.getChannelSchemaRecID());
            subjobCreation.paramFullChannelExtensionTableNames(channelExtensionFullTableNames);
            subjobCreation.paramDateFilterField(dateFilterField);
            subjobCreation.paramUpdateSubjobsOnly(this.paramUpdateSubjobsOnly());
            subjobCreation.paramAllowSkipDataSync(allowSkipDataSync);

            if (isUpload)
            {
                if (conFind(axFields, 'RecId') != 0)
                {
                    throw Global::error(strFmt('@Retail:CDXSeedDataFieldListUploadJobRecIdErr', subjobId));
                }

                subjobCreation.paramIsUpload(isUpload);
                subjobCreation.paramReplicationCounterFieldName(repCntFieldName);
            }
            else
            {
                if ((conFind(axFields, 'RecId') == 0) && (conFind(channelFields, 'RecId') == 0))
                {
                    throw Global::error(strFmt('@Retail:CDXSeedDataFieldListDownloadJobRecIdErr', subjobId));
                }
            }

            // check that the customer has not explicitly mapped DataAreaId as only the seed data initializer is supposed to take care of DataAreaId mapping.
            if (conFind(axFields, 'DataAreaID') != 0)
            {
                // For subjob %1, DataAreaID cannot be included in field lists.
                throw Global::error(strFmt('@Retail:CDXSeedDataFieldListDataAreaIdSubjobError', subjobId));
            }

            subjobCreation.run();

            createdSubjobIds += subjobId;
            createdSubjobTableNames += axTableName;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelExtensionFullTableNames</Name>
				<Source><![CDATA[
    private container getChannelExtensionFullTableNames(XmlElement subjob, str targetTableFullName)
    {
        XmlElement axFields = subjob.getNamedElement('AxFields');
        XmlNodeList fields = axFields.childNodes();
        container result;

        targetTableFullName = strUpr(targetTableFullName);

        for (int i = 0; i < fields.length(); i++)
        {
            XmlElement field = fields.item(i);
            str fullTableName = strUpr(field.getAttribute('TargetTableSchema') + '.' + field.getAttribute('TargetTableName'));
            if (fullTableName != '.' && fullTableName != targetTableFullName && !conFind(result, fullTableName))
            {
                result += fullTableName;
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSubjobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns all subjob XML node in seed data. For test only.
    /// </summary>
    /// <returns>Subjob XML node in seed data.</returns>
    /// <remarks>This method is exposed for test purpose only</remarks>
    public XmlNode getSubjobs()
    {
        return this.subjobs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAxFieldNames</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the Ax field name of all the fields in axFields.
    /// </summary>
    /// <param name = "axFields">The ax fields</param>
    /// <returns>Returns a container which has the ax field name of the fields sp.</returns>
    /// <remarks>This method is made public for test purpose only</remarks>
    public container getAxFieldNames(container axFields)
    {
        container result;
        for (int i = 1; i <= conLen(axFields) - 1; i += 2)
        {
            str fieldName = conPeek(axFields, i);
            result += fieldName;
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelFieldNames</Name>
				<Source><![CDATA[
    private container getChannelFieldNames(container axFields)
    {
        container result;
        boolean   useSameCaseToField = !RetailCdxFeatureControl::IsMatchSubjobToFieldCaseWithFromFieldDisabled();

        for (int i = 1; i <= conLen(axFields) - 1; i += 2)
        {
            str fieldName = conPeek(axFields, i);
            str toName = conPeek(axFields, i + 1);

            if (System.String::IsNullOrEmpty(toName))
            {
                result += useSameCaseToField ? fieldName : strUpr(fieldName);
            }
            else
            {
                result += toName;
            }

        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChannelSchemaRecID</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the internal retail channel schema RecID.
    /// </summary>
    /// <returns>A <c>RefRecId</c> value.</returns>
    public RefRecId getChannelSchemaRecID()
    {
        RetailConnChannelSchema channelSchema;

        if (this.channelSchemaRecID == -1)
        {
            select firstOnly RecId from channelSchema where channelSchema.SchemaName == this.getSchemaName();
            this.channelSchemaRecID = channelSchema.RecId;
        }

        return this.channelSchemaRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveXmlStrFromResource</Name>
				<Source><![CDATA[
    protected str retrieveXmlStrFromResource(str src)
    {
        resourceNode node = SysResource::getResourceNode(src);
        container content = SysResource::getResourceNodeData(node);
        str xml = conPeek(content, 1);
        return xml;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateXmlUsingXsd</Name>
				<Source><![CDATA[
    protected void validateXmlUsingXsd(str xml, str xsd)
    {
        XmlReader reader = XmlTextReader::newXml(xml);
        XmlSchemaValidationError xmlError = reader.validate(xsd);
        if (xmlError)
        {
            throw Global::error(xmlError.message());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadDataFromXmlStr</Name>
				<Source><![CDATA[
    protected void loadDataFromXmlStr(str xml)
    {
        XmlDocument doc = new XmlDocument();
        doc.loadXml(xml);

        XmlElement root = doc.getNamedElement('RetailCdxSeedData');
        resourceSchemaName = this.getAttrFromXmlElement(root, 'Name');
        defaultChannelTableSchemaName = this.getAttrFromXmlElement(root, 'ChannelDBSchema');

        jobs = root.getNamedElement('Jobs');
        subjobs = root.getNamedElement('Subjobs');
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupSchema</Name>
				<Source><![CDATA[
    protected void setupSchema()
    {
        RetailConnChannelSchema channelSchema;
        select firstOnly RecId from channelSchema where channelSchema.SchemaName == resourceSchemaName;
        if (!channelSchema)
        {
            this.insertChannelSchema();
            select firstOnly RecId from channelSchema where channelSchema.SchemaName == resourceSchemaName;
            if (!channelSchema)
            {
                throw Global::error(strFmt("@RET4040124", resourceSchemaName));
            }
        }

        channelSchemaRecID = channelSchema.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupCDXDataGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the configuration related to the CDX Data Group.
    /// </summary>
    protected abstract void setupCDXDataGroup()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCDXSeedDataExtensionResources</Name>
				<Source><![CDATA[
    protected List getCDXSeedDataExtensionResources()
    {
        List resources = new List(Types::String);
        this.registerCDXSeedDataExtension(this.getCoreCDXSeedDataResource(), resources);

        return resources;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getXSDSchemaResource</Name>
				<Source><![CDATA[
    protected abstract ResourceName getXSDSchemaResource()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCoreCDXSeedDataResource</Name>
				<Source><![CDATA[
    protected abstract ResourceName getCoreCDXSeedDataResource()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSchemaName</Name>
				<Source><![CDATA[
    public abstract ResourceName getSchemaName()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRecurringBatchJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set up recurring batch job for CDX schedule job.
    /// </summary>
    protected void setupRecurringBatchJob()
    {
        // Intentionally left blank because by default no recurring batch job is needed.
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertChannelSchema</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts channel schema in <c>RetailConnChannelSchema</c>.
    /// </summary>
    protected void insertChannelSchema()
    {
        RetailConnChannelSchema::InsertDefault();
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerCDXSeedDataExtension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension CDX seed data job and subjob definitions.
    /// </summary>
    /// <param name = "originalCDXSeedDataResource">The resource str of the CDX seed data that is being extended.</param>
    /// <param name = "resources">Resource list objet that is used to return the CDX seed data extension resource str retrieved using resourceStr function.
    /// Add the CDX seed data extension resource name to this object.</param>
    /// <remarks> Should check if the original CDX seed data resource name argument matches the resource name of the seed data that
    /// is being extended before adding the name of the extension resource string to the resources list object.</remarks>
    delegate void registerCDXSeedDataExtension(str originalCDXSeedDataResource, List resources)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>combineCDXSeedDataResources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Combines the default CDX job and subjob definition with the extended job/subjob definition.
    /// </summary>
    /// <param name = "cdxSeedData">The default CDX seed data definition xml.</param>
    /// <param name = "cdxSeedDataExtension">The extended seed data definition xml.</param>
    /// <returns>The combined CDX seed data definition xml.</returns>
    protected str combineCDXSeedDataResources(str cdxSeedData, str cdxSeedDataExtension)
    {
        XmlDocument cdxSeedDataDoc = XmlDocument::newXml(cdxSeedData);
        XmlDocument cdxSeedDataExtensionDoc = XmlDocument::newXml(cdxSeedDataExtension);

        XmlElement root = cdxSeedDataDoc.getNamedElement('RetailCdxSeedData');
        XmlNode coreJobs = root.getNamedElement('Jobs');
        XmlNode coreSubJobs = root.getNamedElement('Subjobs');

        XmlElement extensionRoot = cdxSeedDataExtensionDoc.getNamedElement('RetailCdxSeedData');
        XmlNode extensionJobs = extensionRoot.getNamedElement('Jobs');
        XmlNode extensionSubjobs = extensionRoot.getNamedElement('Subjobs');

        // Combine the Jobs section.
        if (extensionJobs)
        {
            XMLNodeListIterator jobEnumerator = new XMLNodeListIterator(extensionJobs.selectNodes('Job'));
            while (jobEnumerator.more())
            {
                XmlElement extensionJob = jobEnumerator.value();
                str jobId = this.getIdAttribute(extensionJob);
                XmlElement coreJob = this.selectNodeByAttributeValue(coreJobs, 'Job', 'Id', jobId);
                coreJob = this.addExtensionOrUpdateExisting(coreJobs, coreJob, extensionJob);
                jobEnumerator.next();
            }
        }

        // Combine SubJobs section
        if (extensionSubJobs)
        {
            XMLNodeListIterator subJobEumerator = new XMLNodeListIterator(extensionSubJobs.selectNodes('Subjob'));
            while (subJobEumerator.more())
            {
                XmlElement extensionSubJob = subJobEumerator.value();
                str subJobId = this.getIdAttribute(extensionSubJob);
                XmlElement coreSubJob = this.selectNodeByAttributeValue(coreSubJobs, 'Subjob', 'Id', subJobId);

                RetailConnTableName axTableName = this.getAttrFromXmlElement(extensionSubJob, 'AxTableName', false);
                if (axTableName == '')
                {
                    axTableName = this.getAttrFromXmlElement(coreSubJob, 'AxTableName');
                }

                boolean isNewSubJob = coreSubJob == null;
                boolean isUploadSubjob = isNewSubJob ? this.getIsUploadAttr(extensionSubJob) : this.getIsUploadAttr(coreSubJob);

                // backward compat.: upload subjobs extensions override the original definition (e.g. target table is replaced with the target table defined by ext)
                // to allow upload subjobs extensions to behave closer to what download subjob extensions do, we check whether the user set property OverrideTarget
                // this is by default true (backward compat), and if they don't want to override target table, but use it as an extension, they can set it to false
                boolean overrideTarget = this.getBoolAttr(extensionSubJob, 'OverrideTarget', true);

                if (!isUploadSubjob)
                {
                    // download jobs never override
                    overrideTarget = false;
                }

                if (isNewSubJob || (overrideTarget))
                {
                    coreSubJob = this.addExtensionOrUpdateExisting(coreSubJobs, coreSubJob, extensionSubJob);
                }

                // Update ScheduledByJobs records.
                XmlElement extensionScheduledByJobs = extensionSubJob.selectSingleNode('ScheduledByJobs');
                if (extensionScheduledByJobs)
                {
                    XmlElement scheduledByJobs = coreSubJob.selectSingleNode('ScheduledByJobs');
                    scheduledByJobs = this.addExtensionOrUpdateExisting(coreSubJob, scheduledByJobs, extensionScheduledByJobs);

                    XMLNodeListIterator scheduledByJobsEnumerator = new XMLNodeListIterator(extensionScheduledByJobs.selectNodes('ScheduledByJob'));
                    while (scheduledByJobsEnumerator.more())
                    {
                        XmlElement extensionScheduledByJob = scheduledByJobsEnumerator.value();
                        str jobId = extensionScheduledByJob.firstChild().text();
                        XmlElement coreScheduledByJob = scheduledByJobs.selectSingleNode(strFmt('ScheduledByJob[. = "%1"]', jobId));

                        coreScheduledByJob = this.addExtensionOrUpdateExisting(scheduledByJobs, coreScheduledByJob, extensionScheduledByJob); // Add the new scheduledByJob extension record

                        scheduledByJobsEnumerator.next();
                    }
                }

                // Combine field mappings in the SubJob
                XmlElement extensionAxFields = extensionSubJob.selectSingleNode('AxFields'); // Select the node that contains the extension field list.
                if (extensionAxFields)
                {
                    XmlElement coreAxFields = coreSubJob.selectSingleNode('AxFields'); // Select the parent node that contains the default field list.
                    coreAxFields = this.addExtensionOrUpdateExisting(coreSubJob, coreAxFields, extensionAxFields); // Adds the node that contain the field list if it doesnt exist already.

                    XMLNodeListIterator fieldEnumerator = new XMLNodeListIterator(extensionAxFields.selectNodes('Field'));
                    while (fieldEnumerator.more())
                    {
                        XmlElement fieldExt = fieldEnumerator.value();
                        str fieldName = this.getAttrFromXmlElement(fieldExt, 'Name', true);
                        XmlElement coreField = this.selectNodeByAttributeValue(coreAxFields, 'Field', 'Name', fieldName);
                        boolean isNewFieldMapping = coreField == null;
                        str targetSchema;
                        str targetTableName;

                        str toFieldName = this.getAttrFromXmlElement(fieldExt, 'ToName', false);
                        boolean isNameOverride = (toFieldName != '' && toFieldName != fieldName);

                        // If it's core subjob being modified by extensions,
                        // and the field name is being changed,
                        // and the feature control is not disabled,
                        // and the extension field belongs to an unique index, then throw the exception
                        if (!isNewSubJob
                            && isNameOverride
                            && !RetailCdxFeatureControl::IsUniqueIndexFieldMappingExtensionPreventionDisabled()
                            && RetailConnReplicationUtilities::IsFieldInUniqueIndex(axTableName, fieldName))
                        {
                            throw Global::error(strFmt("@Retail:RetailValidateOverrideIndexFieldsInSchedulerSubJobs", fieldName, axTableName));
                        }

                        // Adds the extension field to the seed data.
                        coreField = this.addExtensionOrUpdateExisting(coreAxFields, coreField, fieldExt);

                        // for extensions that define new fields onto an existing subjob, first we add the new fields to the subjob
                        // then we make sure we track the table from which those fields come/go
                        // backward compat.: upload subjobs extensions that defined TargetTable replace the original target table
                        // we keep that behavior (i.e. not add those here, because if they are added here they will become extension tables)
                        // unless they set the flag to not override target
                        if (!isNewSubJob && isNewFieldMapping && !overrideTarget)
                        {
                            targetSchema = extensionSubJob.getAttribute('TargetTableSchema');
                            targetTableName = extensionSubJob.getAttribute('TargetTableName');
                            targetTableName = targetTableName == '' ? coreSubJob.getAttribute('AxTableName') : targetTableName;
                            coreField.setAttribute('TargetTableSchema', strUpr(targetSchema));
                            coreField.setAttribute('TargetTableName', strUpr(targetTableName));
                        }

                        fieldEnumerator.next();
                    }
                }
                subJobEumerator.next();
            }
        }

        return cdxSeedDataDoc.toString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectNodeByAttributeValue</Name>
				<Source><![CDATA[
    private XmlElement selectNodeByAttributeValue(XmlElement node, str nodeName, str attributeName, str attributeValue, boolean caseSensitive = false)
    {
        if (caseSensitive)
        {
            return node.selectSingleNode(strFmt('%1[@%2="%3"]', nodeName, attributeName, attributeValue));
        }
        else
        {
            // using the translate xpath function since lower-case function is not supported in xpath v1.
            return node.selectSingleNode(strFmt('%1[translate(@%2,\'ABCDEFGHIJKLMNOPQRSTUVWXYZ\',\'abcdefghijklmnopqrstuvwxyz\')="%3"]', nodeName, attributeName, strLwr(attributeValue)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExtensionOrUpdateExisting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts new CDX seed data nodes or updates the default CDX seed data node with the attributes in the extension node.
    /// </summary>
    /// <param name = "coreNodeParent">The parent node where the new node will be added to.</param>
    /// <param name = "coreNode">The existing record whose attributes will be updated by the extension node attributes.
    /// If this node is empty the extension node will be inserted to the parent node.
    /// </param>
    /// <param name = "extensionNode">The extension CDX seed data node.</param>
    /// <returns>
    /// Returns the new or updated node.
    /// </returns>
    private XmlElement addExtensionOrUpdateExisting(XmlElement coreNodeParent, XmlElement coreNode, XmlElement extensionNode)
    {
        if(coreNode == null) // if the node that matched the new extension record is null insert the extension node.
        {
            coreNode = coreNodeParent.ownerDocument().createElement(extensionNode.name());

            // Set the text only if the element is a ScheduleByJob element.
            // Checking this condition prevents the text value of ScheduledByJob element from being set on its parent node ScheduledByJobs as well.
            if (extensionNode.name() == 'ScheduledByJob')
            {
                coreNode.text(extensionNode.text());
            }
            coreNodeParent.appendChild(coreNode);
        }

        this.updateAttributes(coreNode, extensionNode);
        return coreNode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAttributes</Name>
				<Source><![CDATA[
    private void updateAttributes(XmlElement coreNode, XmlElement extensionNode)
    {
        // update the attributes
        for (int i= 0; i < extensionNode.attributes().length(); i++)
        {
            str attrib = extensionNode.attributes().item(i).name();
            str value = extensionNode.getAttribute(attrib);
            coreNode.setAttribute(attrib, value);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJobDescription</Name>
				<Source><![CDATA[
    protected str getJobDescription(XmlElement e, str jobId)
    {
        str labelId = this.getAttrFromXmlElement(e, 'DescriptionLabelId', false);
        LanguageId langId = CompanyInfo::languageId();
        str value = SysLabel::labelId2String(labelId, langId);
        if (System.String::IsNullOrEmpty(value))
        {
            value = this.getAttrFromXmlElement(e, 'Description');
            return System.String::IsNullOrEmpty(value) ? jobId : value;
        }

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIdAttribute</Name>
				<Source><![CDATA[
    protected str getIdAttribute(XmlElement e)
    {
        return this.getAttrFromXmlElement(e, 'Id', true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getXmlElementsContent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get entry list in xml element.
    /// </summary>
    /// <parameter>
    /// fromAttr - whether to retrieve from attribute or inner text.
    /// xe - element that contains a list
    /// tag - tag name
        /// </parameter>
    public container getXmlElementsContent(XmlElement xe, str tag, boolean fromAttr = false)
    {
        XmlElement e = xe.getNamedElement(tag);
        if (!e)
        {
            throw Global::error(strFmt('@Retail:CDXSeedDataMissingElement', tag, xe.name()));
        }

        container result;
        XmlNodeList list = e.childNodes();
        for (int i = 0; i < list.length(); i++)
        {
            XmlElement n = list.item(i);

            str name;
            str toName;

            if (fromAttr)
            {
                name = this.getAttrFromXmlElement(n, 'Name');
                toName = this.getAttrFromXmlElement(n, 'ToName', false);
            }
            else
            {
                // read from inner text
                name = n.text();
            }

            if (conFind(result, name) == 0)
            {
                result += name;
                if (fromAttr)
                {
                    // when read from attribute, add the optional ToName right after Name
                    // hence the result from attritubte [Name_1, ToName_1, Name_2, ToName_2, ...]
                    // whereas the result from inner text [Name_1, Name_2, Name_3, ...]
                    result += toName;
                }
            }
            else
            {
                throw Global::error(strFmt('@Retail:CDXSeedDataDuplicateEntry', tag));
            }
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsUploadAttr</Name>
				<Source><![CDATA[
    public boolean getIsUploadAttr(XmlElement xe)
    {
        return this.getBoolAttr(xe, 'IsUpload', false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllowSkipDataSyncAttr</Name>
				<Source><![CDATA[
    internal boolean getAllowSkipDataSyncAttr(XmlElement xe)
    {
        return this.getBoolAttr(xe, 'AllowSkipDataSync', false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBoolAttr</Name>
				<Source><![CDATA[
    public boolean getBoolAttr(XmlElement xe, str attrName, boolean defaultValue)
    {
        if (xe)
        {
            str value = this.getAttrFromXmlElement(xe, attrName, false);
            if (value)
            {
                return strUpr(value) == 'TRUE';
            }
        }
        return defaultValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAttrFromXmlElement</Name>
				<Source><![CDATA[
    public str getAttrFromXmlElement(XmlElement xe, str attr, boolean isRequired = true)
    {
        str result = "";

        XmlNamedNodeMap nm = xe.attributes();
        XmlNode n = nm.getNamedItem(attr);

        if (n)
        {
            result = n.value();
        }
        else
        {
            if (isRequired)
            {
                throw Global::error(strFmt("@Retail:CDXSeedDataMissingAttribute", attr, xe.name()));
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramIsExecutedFromUI</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the flag which indicates if the call is made from UI.
    /// </summary>
    /// <param name = "_isExecutedFromUI">The flag indicating origin of the call.</param>
    /// <returns>True if executed from UI; false otherwise.</returns>
    internal boolean paramIsExecutedFromUI(boolean _isExecutedFromUI = isExecutedFromUI)
    {
        isExecutedFromUI = _isExecutedFromUI;
        return _isExecutedFromUI;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramUpdateSubjobsOnly</Name>
				<Source><![CDATA[
    internal boolean paramUpdateSubjobsOnly(boolean _updateSubjobsOnly = updateSubjobsOnly)
    {
        updateSubjobsOnly = _updateSubjobsOnly;
        return _updateSubjobsOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clean up existing data in CDX tables.
    /// </summary>
    public void clearTables()
    {
        RetailConnLocationDesignTable retailConnLocationDesignTable;
        RetailConnLocationDesignTableField retailConnLocationDesignTableField;
        RetailConnSchedulerJobLine retailConnSchedulerJobLine;
        RetailConnSchedulerJobTable retailConnSchedulerJobTable;
        RetailConnSchedulerSubjobFieldList retailConnSchedulerSubjobFieldList;
        RetailConnSchedulerSubjobTable retailConnSchedulerSubjobTable;
        RetailConnScheduleJobMapping retailConnScheduleJobMapping;
        RetailCDXDateFilterField retailCDXDateFilterField;

        RefRecId schemaRecId = this.getChannelSchemaRecID();
        if (schemaRecId != 0)
        {
            delete_from retailConnLocationDesignTable
                where retailConnLocationDesignTable.RetailConnChannelSchema == schemaRecId;
            delete_from retailConnLocationDesignTableField
                where retailConnLocationDesignTableField.RetailConnChannelSchema == schemaRecId;

            delete_from retailConnSchedulerJobLine
            exists join retailConnSchedulerJobTable
            where retailConnSchedulerJobLine.jobId == retailConnSchedulerJobTable.JobId
                && retailConnSchedulerJobTable.RetailConnChannelSchema == schemaRecId;

            delete_from retailConnSchedulerSubjobFieldList
            exists join retailConnSchedulerSubjobTable
            where retailConnSchedulerSubjobFieldList.SubjobId == retailConnSchedulerSubjobTable.subJobId
                && retailConnSchedulerSubjobTable.RetailConnChannelSchema == schemaRecId;

            delete_from retailConnSchedulerSubjobTable
                where retailConnSchedulerSubjobTable.RetailConnChannelSchema == schemaRecId;

            retailConnSchedulerJobTable.skipDeleteActions(true);
            delete_from retailConnSchedulerJobTable
                where retailConnSchedulerJobTable.RetailConnChannelSchema == schemaRecId;

            delete_from retailCDXDateFilterField
                where retailCDXDateFilterField.RetailConnChannelSchema == schemaRecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAllSeedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clear all CDX seed data from AX database.
    /// </summary>
    public static void clearAllSeedData()
    {
        RetailConnSchedulerJobTable schedulerJob;
        RetailConnSchedulerSubjobTable schedulerSubJob;
        RetailConnSchedulerJobLine schedulerJobLine;
        RetailConnSchedulerSubjobFieldList fieldList;
        RetailConnLocationDesignTable designTable;
        RetailConnLocationDesignTableField designTableField;
        RetailConnScheduleJobMapping scheduleJobMapping;
        RetailCDXScheduleDataGroup scheduleDataGroup;
        RetailConnSchedule schedule;
        RetailCDXChangeTrackingSQL ctSql;
        RetailCDXChangeTrackingQueue ctQueue;
        RetailCdxChannelSpecificTable channelSpecificTable;
        RetailCdxDataDistributionQuery ddQuery;
        RetailCdxDataDistributionQueryFilter ddFileter;
        RetailConnChannelSchema channelSchema;

        delete_from schedulerJobLine;
        delete_from schedulerJob;
        delete_from fieldList;
        delete_from schedulerSubJob;
        delete_from designTable;
        delete_from designTableField;
        delete_from scheduleJobMapping;
        delete_from scheduleDataGroup;
        delete_from schedule;
        delete_from ctSql;
        delete_from ctQueue;
        delete_from channelSpecificTable;
        delete_from ddQuery;
        delete_from ddFileter;
        delete_from channelSchema;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSeedDataSchedulerJobsSubjobs</Name>
				<Source><![CDATA[
    private static Map GetSeedDataSchedulerJobsSubjobs()
    {
        RetailCDXSeedDataAX7 seed = new RetailCDXSeedDataAX7(true);
        seed.initializeFromSeedData();
      
        XmlNodeList subjobs = seed.getSubjobs().childNodes();
        Map seedDataJobSubjobMap  = new Map(Types::String, Types::Container);
      
        for (int i = 0; i < subjobs.length(); i++)
        {
            XmlElement subjob = subjobs.item(i);
            str subjobId = seed.getAttrFromXmlElement(subjob, 'Id');
            str axTableName = seed.getAttrFromXmlElement(subjob, 'AxTableName');
            TableId tid = tableName2id(axTableName);
            DictTable dt = new DictTable(tid);
            // if table is disabled by configuration key, skip it.
            if (!dt.enabled())
            {
                continue;
            }

            XmlElement scheduledByJobs = subjob.getNamedElement('ScheduledByJobs');
            if (scheduledByJobs)
            {
                container scheduledByJobIds = seed.getXmlElementsContent(subjob, 'ScheduledByJobs');
                for (int x = 1; x <= conLen(scheduledByJobIds); x++)
                {
                    str jobId = conPeek(scheduledByJobIds, x);
                    if (seedDataJobSubjobMap.exists(jobId))
                    {
                        container subjobCon = seedDataJobSubjobMap.lookup(jobId);
                        subjobCon += subjobId;
                        seedDataJobSubjobMap.insert(jobId, subjobCon);
                    }
                    else
                    {
                        seedDataJobSubjobMap.insert(jobId, [subjobId]);
                    }
                }
            }
        }

        return seedDataJobSubjobMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDbSchedulerJobsSubjobs</Name>
				<Source><![CDATA[
    private static Map GetDbSchedulerJobsSubjobs(RefRecId _channelSchemaRecId, RefRecId _scheduleRecId = 0)
    {
        RetailConnScheduleJobMapping scheduleJobMapping;
        RetailConnSchedulerJobTable job;
        RetailConnSchedulerSubjobTable subjob;
        RetailConnSchedulerJobLine jobLine;
        RetailCDXScheduleDataGroup scheduleDataGroup;
        RetailCDXDataGroup dataGroup;
            
        Map dbJobSubjobMap = new Map(Types::String, Types::Container);

        while select SchedulerJobId from scheduleJobMapping
            group by SchedulerJobId
            where scheduleJobMapping.Enabled == NoYes::Yes
                && (_scheduleRecId == 0 || scheduleJobMapping.ScheduleRecId == _scheduleRecId)
            exists join job
                where job.jobId == scheduleJobMapping.SchedulerJobId
                    && job.RetailConnChannelSchema == _channelSchemaRecId
            exists join scheduleDataGroup
                where scheduleDataGroup.Schedule == scheduleJobMapping.ScheduleRecId
            exists join dataGroup
                where dataGroup.RecId == scheduleDataGroup.DataGroup
                    && dataGroup.ChannelSchema == _channelSchemaRecId
        {
            container dbSubjobCon;

            while select subJobId from jobLine
                where jobLine.jobId == scheduleJobMapping.SchedulerJobId
                    && jobLine.enabled   == NoYes::Yes
                exists join subjob
                    where subjob.subJobId == jobLine.subJobId
                        && subjob.RetailConnChannelSchema == _channelSchemaRecId
            {
                dbSubjobCon += jobLine.subJobId;
            }
            dbJobSubjobMap.insert(scheduleJobMapping.SchedulerJobId, dbSubjobCon);
        }
        
        return dbJobSubjobMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetMissingSubjobsFromJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of missing scheduler sub jobs from scheduler job.
    /// </summary>
    /// <param name = "_scheduleRecId">The schedule rec id used to filter the schedules in a scheduler job mapping. If not specified all schedules are returned</param>
    /// <returns>The list of missing sub jobs from scheduler job.</returns>
    internal static container GetMissingSubjobsFromJob(RefRecId _scheduleRecId = 0)
    {
        int position = 1;
        container dbMissingSubJob;
        RetailConnChannelSchema channelSchema;
        
        #RetailCDX

        select firstOnly RecId from channelSchema
            where channelSchema.SchemaName == #AX7SchemaName
            && channelSchema.SchemaType == RetailConnChannelSchemaTypeEnum::AX7;
        
        Map dbJobSubjobMap =  RetailCDXSeedDataBase::GetDbSchedulerJobsSubjobs(channelSchema.RecId, _scheduleRecId);
        Map seedDataJobSubjobMap = RetailCDXSeedDataBase::GetSeedDataSchedulerJobsSubjobs();
        MapEnumerator dbJobSubjobMapEnumerator = dbJobSubjobMap.getEnumerator();

        while (dbJobSubjobMapEnumerator.moveNext())
        {
            RetailConnJobId jobId = dbJobSubjobMapEnumerator.currentKey();
            container dbSubjobCon = dbJobSubjobMapEnumerator.currentValue();
            if (seedDataJobSubjobMap.exists(jobId))
            {
                container seedDataSubjobCon = seedDataJobSubjobMap.lookup(jobId);
                for (int x = 1; x <= conLen(seedDataSubjobCon); x++)
                {
                    RetailConnSubJobId subjobId = conPeek(seedDataSubjobCon, x);
                    if (conFind(dbSubjobCon, subjobId) == 0)
                    {
                        RetailConnJobId customJobId;
                        RetailConnSchedulerJobLine jobLine;
                        RetailConnSchedulerJobTable job;
        
                        while select jobId from jobLine
                            where jobLine.subJobId == subjobId
                                && jobLine.enabled   == NoYes::Yes
                            exists join job
                                where job.jobId == jobLine.jobId
                                    && job.RetailConnChannelSchema == channelSchema.RecId
                        {
                            if (!seedDataJobSubjobMap.exists(jobLine.jobId))
                            {
                                customJobId = jobLine.jobId;
                                break;
                            }
                        }

                        dbMissingSubJob = conIns(dbMissingSubJob, position, [jobId, subjobId, customJobId]);
                        position++;
                    }
                }
            }
            
        }
        
        return dbMissingSubJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEntityType</Name>
				<Source><![CDATA[
    private RetailCDXEntityTypeBase getEntityType(XmlElement xe)
    {
        str value;

        if (xe)
        {
            value = this.getAttrFromXmlElement(xe, 'EntityType', false);
        }

        if (value)
        {
            return symbol2Enum(enumNum(RetailCDXEntityTypeBase), value);
        }
        else
        {
            // If entity type is not set, return default value of the enum.
            return RetailCDXEntityTypeBase::None;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>