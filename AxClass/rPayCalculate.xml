<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>rPayCalculate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Classs for payroll procedure calculation.
/// </summary>
class rPayCalculate
{
    RPayModuleControl    payModuleControl;
    ReportPeriod_RU      payPeriod, payPeriodVirtual;
    ReportPeriod_RU      correctedPeriod, calcPeriod;
    RHRMEmplTable        emplTable;
    RPayAmount           sumCounter,initialSumCounter;
    Common               sourceTable;
    RPayCounterCalcTable payCounterCalcTable;
    RPayCounterTable     payCounterTable;
    RPayModuleTable      payModuleTable;
    RPaySeqTable         paySeqTable;
    RPayTrans            payTrans;
    QueryRun             queryRun;
    boolean              needCheckModuleCalculate;
    boolean              needUpdateTrans;
    container            linesSum,
                         linesTotal;
    TransDate            transDate;
    boolean              profilesChecked;
    boolean              profilesCheckedOk;
    #timeConstants
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calc_AverageEarn</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_AverageEarn()
    {
        ReportPeriod_RU calcDate = this.payPeriodStart();

        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayAverageEarnEngine::getAverageEarn(emplTable.EmployeeId,
                                                     payCounterCalcTable.NumFrom,
                                                     calcDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_BaseTotal</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_BaseTotal()
    {
        ReportPeriod_RU  rateDate,
                         periodEndDate,
                         currentPeriod;
        RPayCounterUnit  to;
        RPayCounterTable payCounterTbl;
        RPayAmount       amount;
        ;
        rateDate = this.payPeriodStart();
        if (date2num(rateDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        to = payCounterCalcTable.NumTo ? payCounterCalcTable.NumTo : payCounterCalcTable.NumFrom;
        while select payCounterTbl
            where payCounterTbl.CounterUnit >= payCounterCalcTable.NumFrom &&
                  payCounterTbl.CounterUnit <= to
        {
            if (! payCounterTbl.paySeqTable().payModuleTable().ConfigurationKeyId ||
                payCounterTbl.paySeqTable().PayModuleCode == payCounterTable.paySeqTable().PayModuleCode)
            {
                switch (payCounterCalcTable.PayCalcSumMetod)
                {
                    case RPayCalcSumMetod::OnlyPeriod:
                        periodEndDate = this.payPeriodEnd(rateDate,payCounterCalcTable.PayPeriodFrequency);
                        break;
                    case RPayCalcSumMetod::FromPeriod:
                        periodEndDate = payPeriod;
                        break;
                    case RPayCalcSumMetod::FromEmpl:
                        rateDate = endmth(emplTable.PayEmploymentDate);
                        periodEndDate = payPeriod;
                        break;
                }
                for (currentPeriod = rateDate ; currentPeriod <= periodEndDate ; currentPeriod = endmth(nextMth(currentPeriod)))
                {
                    amount += this.calculateCounter(payCounterTbl, currentPeriod);
                }
            }
            else
            {
                throw error("@RUP904" + payCounterTbl.CounterUnit + "@RUP905");
            }
        }
        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_CalcLineSum</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_CalcLineSum()
    {
        return conPeek(linesSum,str2int(payCounterCalcTable.NumFrom));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_CalcLineTotal</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_CalcLineTotal()
    {
        return conPeek(linesTotal,str2int(payCounterCalcTable.NumFrom));
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_Constant</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_Constant()
    {
        return  str2num(payCounterCalcTable.NumFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_CostType</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_CostType()
    {
        ReportPeriod_RU rateDate,
                        periodEndDate;
        RPayCostType    to;
        ;
        rateDate = this.payPeriodStart();
        if (date2num(rateDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        to = payCounterCalcTable.NumTo ? payCounterCalcTable.NumTo : payCounterCalcTable.NumFrom;
        switch (payCounterCalcTable.PayCalcSumMetod)
        {
            case RPayCalcSumMetod::OnlyPeriod:
                periodEndDate = this.payPeriodEnd(rateDate, payCounterCalcTable.PayPeriodFrequency);
                break;
            case RPayCalcSumMetod::FromPeriod:
                periodEndDate = payPeriod;
                break;
            case RPayCalcSumMetod::FromEmpl:
                rateDate = endmth(emplTable.PayEmploymentDate);
                periodEndDate = payPeriod;
                break;
        }
        select sum(Amount)  from payTrans
            where payTrans.Emplid          == emplTable.EmployeeId            &&
                  payTrans.PayCtype        >= payCounterCalcTable.NumFrom &&
                  payTrans.PayCtype        <= to                          &&
                  payTrans.PayPeriod       >= rateDate                    &&
                  payTrans.PayPeriod       <= periodEndDate               &&
                  payTrans.CorrectedPeriod == payTrans.PayPeriod;

        return payTrans.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_FactDays</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_FactDays()
    {
        ReportPeriod_RU calcDate = this.payPeriodStart();

        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayTblTrans::realDayHour(calcDate,
                                         this.getEmplTable().EmployeeId,
                                         RPayDayHourCalc::Day,
                                         payCounterCalcTable.NumFrom,
                                         '',
                                         true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_FactDaysGroup</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_FactDaysGroup()
    {
        ReportPeriod_RU calcDate;
        ;
        calcDate = this.payPeriodStart();
        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayTblTrans::realDayHourGroup(calcDate,
                                              this.getEmplTable().EmployeeId,
                                              RPayDayHourCalc::Day,
                                              payCounterCalcTable.NumFrom,
                                              true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_FactHours</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_FactHours()
    {
        ReportPeriod_RU calcDate;
        ;
        calcDate = this.payPeriodStart();
        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayTblTrans::realDayHour(calcDate,
                                         this.getEmplTable().EmployeeId,
                                         RPayDayHourCalc::Hour,
                                         payCounterCalcTable.NumFrom,
                                         '',
                                         true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_FactHoursGroup</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_FactHoursGroup()
    {
        ReportPeriod_RU calcDate;
        ;
        calcDate = this.payPeriodStart();
        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayTblTrans::realDayHourGroup(calcDate,
                                              this.getEmplTable().EmployeeId,
                                              RPayDayHourCalc::Hour,
                                              payCounterCalcTable.NumFrom,
                                              true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_Rate</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_Rate()
    {
        ReportPeriod_RU         rateDate;
        RPayRateTable           payRateTable;
        RPayRateCallContext     context;
        ;
        rateDate = this.transDateStart();
        if (date2num(rateDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        payRateTable = RPayRateTable::find(payCounterCalcTable.NumFrom);
        context = new RPayRateCallContext();
        context.parmRateDate(rateDate);
        context.parmEmployeeId(emplTable.EmployeeId);
        context.parmCriterion(sumCounter);
        return payRateTable.getValue(context);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_RegDays</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_RegDays()
    {
        ReportPeriod_RU calcDate = this.payPeriodStart();

        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayCalendarTable::mthWorkDays(RPayEmplTblSum::payCalendarId(this.getEmplTable().EmployeeId, calcDate),
                                              calcDate,
                                              payCounterCalcTable.NumFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_RegDaysGroup</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_RegDaysGroup()
    {
        ReportPeriod_RU calcDate = this.payPeriodStart();

        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayCalendarTable::mthWorkDaysTimeGroup(RPayEmplTblSum::payCalendarId(this.getEmplTable().EmployeeId, calcDate),
                                                       calcDate,
                                                       payCounterCalcTable.NumFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_RegHours</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_RegHours()
    {
        ReportPeriod_RU calcDate = this.payPeriodStart();

        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayCalendarTable::mthWorkHours(RPayEmplTblSum::payCalendarId(this.getEmplTable().EmployeeId, calcDate),
                                               calcDate,
                                               payCounterCalcTable.NumFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_RegHoursGroup</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected real calc_RegHoursGroup()
    {
        ReportPeriod_RU calcDate = this.payPeriodStart();

        if (date2num(calcDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }

        return RPayCalendarTable::mthWorkHoursTimeGroup(RPayEmplTblSum::payCalendarId(this.getEmplTable().EmployeeId, calcDate),
                                                        calcDate,
                                                        payCounterCalcTable.NumFrom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc_Seniority</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calc_Seniority()
    {
        ReportPeriod_RU calculateDate;
        TransDate       currentDate,
                        seniorityDate;
        int             i;
        ;
        calculateDate = this.payPeriodStart();
        if (date2num(calculateDate) == #financialDaysPerMonth)
        {
            warning("@RUP388");
        }
        calculateDate = mkDate(1,mthOfYr(calculateDate),year(calculateDate));
        seniorityDate = str2DateDMY(RPayParmEmplTrans::find(emplTable.EmployeeId, payCounterCalcTable.NumFrom).Contents);
        if (seniorityDate)
        {
            for (currentDate = seniorityDate ; currentDate <= calculateDate ; currentDate = nextMth(currentDate))
            {
                i++;
            }
        }
        return i;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCommon</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs calculation.
    /// </summary>
    /// <param name="_paySequence">
    /// The calculation sequence.
    /// </param>
    /// <param name="_errorMessage">
    /// If yes error message will be shown.
    /// </param>
    /// <exception cref="Exception::Info">
    /// Calculation has not completed.
    /// </exception>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void calcCommon(RPaySequence _paySequence  = 0,
                              NoYes        _errorMessage = NoYes::No)
    {
        ;
        if (needCheckModuleCalculate)
        {
            if (! this.canModuleCalculate())
            {
                throw info("@RUP387");
            }
        }

        this.checkPostingProfiles(true);

        if (emplTable.checkEmplBeforeCalc(payPeriod, _errorMessage))
        {
            this.initTransDate(emplTable.EmployeeId);

            while select paySeqTable
                where paySeqTable.PayModuleCode == payModuleTable.PayModuleCode &&
                      (paySeqTable.Scanning     == _paySequence                 ||
                      (_paySequence ? false : true))
            {
                this.calcSequence();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCounter</Name>
				<Source><![CDATA[
    #define.firstLine(1)
    #define.calcMetodprefix("Calc_")
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void calcCounter()
    {
        RPayAmount  sumLine;
        int         errorNumber;

        boolean criterionOK(int _criterion,real _value)
        {
            switch (_criterion)
            {
                case RPayCriterion::EqualZero:
                    return (_value == 0);
                case RPayCriterion::InequalZero:
                    return (_value != 0);
                case RPayCriterion::LessZero:
                    return (_value < 0);
                case RPayCriterion::MoreZero:
                    return (_value  > 0);
                case RPayCriterion::LessEqualZero:
                    return (_value <= 0);
                case RPayCriterion::MoreEqualZero:
                    return (_value >= 0);
            }
            return true;
        }

        void nextLine(Integer _nextLine)
        {
            select firstonly payCounterCalcTable index CountLineIdx
                 where payCounterCalcTable.CounterUnit == payCounterTable.CounterUnit &&
                       payCounterCalcTable.LineNo      == _nextLine;
        }

        container conInsExt(container _con, int _lineNo, RPayAmount _amount)
        {
            while (conLen(_con) && (conLen(_con) < _lineNo))
            {
                _con += 0;
            }

            _con = conPoke(_con, _lineNo, _amount);

            return _con;
        }
        ;
        calcPeriod = payPeriod;
        sumCounter = initialSumCounter;
        this.setInitValue(0);
        linesSum   = conNull();
        linesTotal = conNull();
        nextLine(#firstLine);
        setPrefix(payCounterTable.Name);
        while (payCounterCalcTable.RecId)
        {
            errorNumber = infolog.num();
            if (criterionOK(payCounterCalcTable.BeforeCriterion,sumCounter))
            {
                if (payCounterCalcTable.Zero)
                    sumCounter = 0;
                if (payCounterCalcTable.Stop)
                    break;
                if (payCounterCalcTable.Ignore)
                {
                    if (conLen(linesSum) < payCounterCalcTable.LineNo)
                    {
                        linesSum   = conInsExt(linesSum, payCounterCalcTable.LineNo, 0);
                    }
                    if (conLen(linesTotal) < payCounterCalcTable.LineNo)
                    {
                        linesTotal = conInsExt(linesTotal, payCounterCalcTable.LineNo, 0);
                    }
                    nextline(payCounterCalcTable.LineNo + 1);
                    continue;
                }
            }
            payModuleControl.payCounterCalcTable(payCounterCalcTable);
            sumLine = str2num(payModuleControl.callMethod(this,#calcMetodprefix));

            linesSum = conInsExt(linesSum, payCounterCalcTable.LineNo, sumLine);
            if (criterionOK(payCounterCalcTable.LineCriterion,sumLine))
            {
                switch (payCounterCalcTable.Operator)
                {
                    case RpayOperator::Plus:
                        sumCounter += sumLine;
                        break;
                    case RpayOperator::Minus:
                        sumCounter -= sumLine;
                        break;
                    case RpayOperator::Multiplication:
                        sumCounter = sumCounter * sumLine;
                        break;
                    case RpayOperator::Division:
                        if (sumLine)
                        {
                            sumCounter = sumCounter / sumLine;
                        }
                        else
                        {
                            sumCounter = 0;
                        }
                        break;
                    default:
                            sumCounter = sumLine;
                }
            }

            if (sumCounter)
            {
                sumCounter = this.round(sumCounter);
            }

            linesTotal = conInsExt(linesTotal, payCounterCalcTable.LineNo, sumCounter);
            if (errorNumber != infolog.num())
            {
                warning(strFmt("@RUP1225",emplTable.EmployeeId));
                break;
            }
            nextLine(payCounterCalcTable.LineNoTo);
        }
        sumCounter = CurrencyExchangeHelper::amount(sumCounter);
        if (payCounterTable.Output && this.needUpdatePayTrans())
        {
            this.updatePayTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEmpl</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void calcEmpl(RHRMEmplId _emplId, RPaySequence _paySequence=0)
    {
        QueryBuildDataSource qbd;
        QueryBuildRange      qbr;
        RHRMEmplTable            emplTbl;

        needCheckModuleCalculate = false;
        setPrefix(payModuleTable.PayModuleName);

        this.payPeriod(RPayParameters::payPeriod(_emplId));
        payPeriodVirtual = this.payPeriod();

        if (payModuleTable.NeedDeleteBeforeCalc)
        {
            ttsbegin;

            this.deletePayTrans(_emplId);

            ttscommit;
        }
        qbd = queryRun.query().dataSourceTable(tableNum(RHRMEmplTable));
        if (! qbd.findRange(fieldNum(RHRMEmplTable, EmployeeId)))
        {
            qbr = qbd.addRange(fieldNum(RHRMEmplTable, EmployeeId));
            qbr.value(_emplId);
        }
        while (queryRun.next())
        {
            emplTbl = queryRun.get(tableNum(RHRMEmplTable));
            if (emplTbl.EmployeeId == _emplId)
            {
                this.setSourceTable(emplTbl);
                this.calcCommon(_paySequence,NoYes::Yes);
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPeriod</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected ReportPeriod_RU calcPeriod()
    {
        return calcPeriod ? calcPeriod : payPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcQuery</Name>
				<Source><![CDATA[
    #AviFiles
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void calcQuery(RPaySequence _paySequence=0)
    {
        SysOperationProgress    sysOperationProgress;
        int                     total,errorNumber;
        RPayModuleCalculate     payModuleCalculate = new RPayModuleCalculate();
        ;
        setPrefix(payModuleTable.PayModuleName);
        if (needCheckModuleCalculate && ! this.canModuleCalculate())
        {
            throw info("@RUP387");
        }

        if (payModuleTable.PayModuleSost == RPayModuleSost::Calculate)
        {
            payModuleCalculate.calculateAllModule();
            if (! queryRun.interactive())
                return;
        }
        if (queryRun.prompt())
        {
            ttsbegin;

            errorNumber = infolog.num();

            payModuleTable = RPayModuleTable::find(payModuleTable.PayModuleCode, true);

            payModuleTable.PayModuleSost = RPayModuleSost::NoCalculate;
            payModuleTable.update();

            if (! payModuleControl.updateModuleSost())
            {
                throw info("@RUP387");
            }

            if (payModuleTable.NeedDeleteBeforeCalc)
            {
                this.deletePayTrans();  // PS56412 Fix01
            }
            if (errorNumber < infolog.num())
            {
                ttsabort;
                warning("@RUP387");
                return;
            }

            sysOperationProgress = new SysOperationProgress();
            sysOperationProgress.setCaption("@RUP371" + payModuleTable.PayModuleName);
            sysOperationProgress.setAnimation(#AviUpdate);
            total = SysQuery::countTotal(queryRun);
            sysOperationProgress.setTotal(total);
            queryRun.reset();
            errorNumber = infolog.num(Exception::Warning) + infolog.num(Exception::Error) +
                          infolog.num(Exception::Deadlock) + infolog.num(Exception::Internal);

            while (queryRun.next())
            {
                this.setSourceTable(queryRun.get(payModuleControl.sourceTableId()));

                this.payPeriod(RPayParameters::payPeriod(emplTable.EmployeeId));

                if (payModuleTable.NeedDeleteBeforeCalc &&
                    this.payPeriod() > RPayParameters::payPeriod())
                {
                    delete_from payTrans
                        where payTrans.Emplid        == emplTable.EmployeeId             &&
                              payTrans.PayPeriod     == this.payPeriod()             &&
                              payTrans.PayModuleCode == payModuleTable.PayModuleCode &&
                              payTrans.SourceTableId                                 &&
                              payTrans.SourceRecId                                   &&
                              payTrans.PayPeriod     == payTrans.CorrectedPeriod;
                }

                this.calcCommon(_paySequence);
                sysOperationProgress.setText("@RUP372" + emplTable.EmployeeId);
                sysOperationProgress.incCount();
            }

            if (errorNumber == (infolog.num(Exception::Warning) + infolog.num(Exception::Error) +
                                infolog.num(Exception::Deadlock) + infolog.num(Exception::Internal)))
            {
                ttsbegin;
                payModuleTable.PayModuleSost = RPayModuleSost::Calculate;
                payModuleTable.update();
                ttscommit;
            }
            else
            {
                warning("@RUP387");
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcSequence</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void calcSequence()
    {
        setPrefix(paySeqTable.Name);
        while select payCounterTable index ScanningIdx
              where payCounterTable.Scanning == paySeqTable.Scanning
        {
            this.calcCounter();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateCounter</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calculateCounter(RPayCounterTable _payCounterTable,
                                          ReportPeriod_RU  _rateDate = payPeriod)
    {
        RPayModuleTable payModuleTbl;
        RPayCalculate   payCalc;
        RPayQty         amount;
        payModuleTbl = _payCounterTable.paySeqTable().payModuleTable();
        switch (_payCounterTable.CounterType)
        {
            case RPayCounterType::Calculate:
                payCalc = payModuleTbl.payCalculate();
                if (payModuleTbl.ConfigurationKeyId)
                {
                    payCalc.setSourceTable(this.setSourceTable());
                }
                else
                {
                    payCalc.setSourceTable(emplTable);
                }
                payCalc.setSeqTable(_payCounterTable.paySeqTable());
                payCalc.setCounterTable(_payCounterTable);
                payCalc.needUpdatePayTrans(false);
                payCalc.payPeriod(_rateDate);
                payCalc.initInstanceCounter(this);
                payCalc.calcCounter();
                amount = payCalc.getCurrentValue();
                break;
            case RPayCounterType::Fund:
                amount = this.calculateFund(_payCounterTable.CounterUnit,_rateDate, emplTable.EmployeeId);
                break;
        }
        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFund</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount calculateFund(RPayCounterUnit _payCounterUnit,
                                       ReportPeriod_RU _payPeriod = RPayParameters::payPeriod(),
                                       RHRMEmplId      _emplId    = '')
    {
        calcPeriod = correctedPeriod ? correctedPeriod : _payPeriod;

        return  RPayTrans::calculateFundByPayPeriodCorrectedPeriod(_payCounterUnit, _payPeriod, calcPeriod, _emplId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canModuleCalculate</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean canModuleCalculate()
    {
        if (! payModuleControl.canModuleCalculate())
        {
            return false;
        }
        needCheckModuleCalculate = false;
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostingProfiles</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void checkPostingProfiles(boolean _checkBeforeCalc)
    {
        if (_checkBeforeCalc)
        {
            if (! profilesChecked)
            {
                profilesChecked   = true;
                profilesCheckedOk = RPayPostingProfileCheck::checkCurrentProfiles('', '', '', '', false, false);
            }
        }
        else if (! profilesCheckedOk)
        {
            RPayPostingProfileCheck::checkCurrentProfiles(payTrans.PayCtype, '', payTrans.Emplid, '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the corrected period.
    /// </summary>
    /// <param name="_correctedPeriod">
    /// The corrected period, set if specified.
    /// </param>
    /// <returns>
    /// Corredted period.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ReportPeriod_RU correctedPeriod(ReportPeriod_RU _correctedPeriod = correctedPeriod)
    {
        ;
        correctedPeriod = _correctedPeriod;

        return correctedPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePayTrans</Name>
				<Source><![CDATA[
    // PS56412 Fix01
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void deletePayTrans(RHRMEmplId _emplId = '')
    {
        RPayEmplParameters      emplParameters;
        ;

        if (_emplId)
        {
            delete_from payTrans
                where payTrans.PayPeriod     == payPeriod                    &&
                      payTrans.PayModuleCode == payModuleTable.PayModuleCode &&
                      payTrans.SourceTableId                                 &&
                      payTrans.SourceRecId                                   &&
                      payTrans.Emplid        == _emplId                      &&
                      payTrans.PayPeriod     == payTrans.CorrectedPeriod;
        }
        else
        {
            delete_from payTrans
                    where payTrans.PayPeriod     == payPeriod                    &&
                          payTrans.PayModuleCode == payModuleTable.PayModuleCode &&
                          payTrans.SourceTableId                                 &&
                          payTrans.SourceRecId                                   &&
                          payTrans.PayPeriod     == payTrans.CorrectedPeriod
                notexists join emplParameters
                    where emplParameters.EmplId  == payTrans.Emplid;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentValue</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RPayQty getCurrentValue()
    {
        return sumCounter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmplTable</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RHRMEmplTable getEmplTable()
    {
        return emplTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInstanceCounter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes counter.
    /// </summary>
    /// <param name="_caller">
    /// Parent procedure.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void initInstanceCounter(RPayCalculate _caller)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPayTransValue</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void initPayTransValue()
    {
        RPayCounterCalcTable payCounterCalcTbl;
        RPayCounterTable     payCounterTbl;
        RPayModuleTable      payModuleTbl;
        RPaySeqTable         paySeqTbl;

        ;
        payCounterCalcTbl = payModuleControl.payCounterCalcTable();
        payCounterTbl     = payCounterCalcTbl.payCounterTable();
        paySeqTbl         = payCounterTbl.paySeqTable();
        payModuleTbl      = paySeqTbl.payModuleTable();

        payTrans.SourceDate      = (payModuleTbl.SourceDate ? payModuleTbl.SourceDate : payPeriod );
        payTrans.PayPeriod       = payPeriodVirtual;
        payTrans.CorrectedPeriod = calcPeriod ? calcPeriod : payPeriod;
        payTrans.TransDate       = (transDate ? transDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        if (payCounterTbl.Output)
        {
            payTrans.PayCtype   =  payCounterTbl.Output;
        }
        payTrans.initFromEmplTable(emplTable);

        if (RPayTable::find(payCounterTbl.Output).PayChargeType == RPayChargeType::AddSum)
        {
            payTrans.Amount = sumCounter;
        }
        else
        {
            payTrans.Amount = - sumCounter;
        }

        payTrans.PayModuleCode = payModuleTbl.PayModuleCode;
        payTrans.Scanning      = paySeqTbl.Scanning;
        payTrans.CounterUnit   = payCounterTbl.CounterUnit;
        payTrans.SourceTableId = sourceTable.TableId;
        payTrans.SourceRecId   = sourceTable.RecId;

        if (! payTrans.LedgerDimension || ! payTrans.OffsetLedgerDimension)
        {
            this.checkPostingProfiles(false);
        }

        payTrans.updatePosting();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransDate</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void initTransDate(RHRMEmplId _emplId)
    {
        ;

        transDate = payModuleTable.SetTransDateToCalcDate ?
                    RPayParameters::calcDate(_emplId) :
                    (payModuleTable.TransDate ? payModuleTable.TransDate : payPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkerProcedure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines that procedure calculates data for worker.
    /// </summary>
    /// <returns>
    /// True if procedure calculates data for worker.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean isWorkerProcedure()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needCommonCalculate</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean needCommonCalculate(RPayPeriodFrequency _periodFrequency)
    {
        switch (_periodFrequency)
        {
            case RPayPeriodFrequency::None,
                 RPayPeriodFrequency::Month    :
                break;

            case RPayPeriodFrequency::Quarter  :
                if (payPeriod != dateEndQtr(payPeriod))
                    return false;
                break;

            case RPayPeriodFrequency::HalfYear :
                if (payPeriod != dateStartYr(nextYr(payPeriod)) - 1 &&
                    payPeriod != dateEndQtr(nextQtr(dateStartYr(payPeriod))))
                {
                    return false;
                }
                break;

            case RPayPeriodFrequency::Year     :
                if (payPeriod != dateStartYr(nextYr(payPeriod)) - 1)
                {
                    return false;
                }
                break;

            default :
                throw info("@RUP387");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needUpdatePayTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if payroll lines should be updated.
    /// </summary>
    /// <param name="_needUpdateTrans">
    /// If true, payroll lines should should be updated, set if specified.
    /// </param>
    /// <returns>
    /// True, if payroll lines should be updated.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public boolean needUpdatePayTrans(boolean _needUpdateTrans = needUpdateTrans)
    {
        ;
        needUpdateTrans = _needUpdateTrans;
        return needUpdateTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the instance of a class.
    /// </summary>
    /// <param name="_payModuleTable">
    /// The calculation procedures table record.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void new(RPayModuleTable _payModuleTable)
    {
        ;
        payModuleControl         = _payModuleTable.payModuleControl();
        payModuleTable           = _payModuleTable;
        payPeriod                = RPayParameters::payPeriod();
        payPeriodVirtual         = payPeriod;
        queryRun                 = payModuleControl.queryRun();
        needCheckModuleCalculate = true;
        initialSumCounter        = 0;
        needUpdateTrans          = true;
        transDate                = _payModuleTable.SetTransDateToCalcDate ?
                                   RPayParameters::calcDate() :
                                   (_payModuleTable.TransDate ? _payModuleTable.TransDate : payPeriod);
        queryRun.interactive(NoYes::No);
    }

]]></Source>
			</Method>
			<Method>
				<Name>payPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the payroll caclulation period.
    /// </summary>
    /// <param name="_payPeriod">
    /// The payroll calculation period, set if specified.
    /// </param>
    /// <returns>
    /// The payroll calculation period.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public ReportPeriod_RU payPeriod(ReportPeriod_RU _payPeriod = payPeriod)
    {
        ;
        payPeriod = _payPeriod;
        if (transDate < dateStartMth(payPeriod) || transDate > payPeriod)
        {
            transDate = payPeriod;
        }
        return payPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payPeriodEnd</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected ReportPeriod_RU payPeriodEnd(ReportPeriod_RU    _payPeriod = payPeriod,
                                           RPayPeriodFrequency _rPayPeriodFrequency = payCounterCalcTable.PayPeriodFrequency)
    {
        int             i, tmpLag;
        ReportPeriod_RU endPeriod = _payPeriod;
        ;
        switch (_rPayPeriodFrequency)
        {
            case RPayPeriodFrequency::Month    :
                tmpLag = 1;
                break;
            case RPayPeriodFrequency::Quarter  :
                tmpLag = #monthsPerQuarter;
                break;
            case RPayPeriodFrequency::HalfYear :
                tmpLag = #monthsPerHalfYear;
                break;
            case RPayPeriodFrequency::Year     :
                tmpLag = #monthsPerYear;
                break;
            default:
                tmpLag = 0;
                break;
        }
        for (i = 1; i <= tmpLag - 1 ; i ++)
        {
            endPeriod = endmth(nextMth(endPeriod));
        }
        return (endPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>payPeriodStart</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected ReportPeriod_RU payPeriodStart(ReportPeriod_RU _payPeriod = payPeriod)
    {
        int             i, tmpLag;
        ReportPeriod_RU startPeriod = _payPeriod;
        ;
        switch (payCounterCalcTable.PayPeriodFrequency)
        {
            case RPayPeriodFrequency::Month    :
                tmpLag = 1;
                break;
            case RPayPeriodFrequency::Quarter  :
                tmpLag = #monthsPerQuarter;
                break;
            case RPayPeriodFrequency::HalfYear :
                tmpLag = #monthsPerHalfYear;
                break;
            case RPayPeriodFrequency::Year     :
                tmpLag = #monthsPerYear;
                break;
            default:
                tmpLag = 0;
                break;
        }
        if (tmpLag)
        {
            startPeriod = endmth(mkDate(dayOfMth(startPeriod),((mthOfYr(startPeriod) div tmpLag) * tmpLag +
                          (mthOfYr(startPeriod) mod tmpLag ? 1 : (1 - tmpLag))),year(startPeriod)));
        }

        tmpLag = payCounterCalcTable.PeriodLag*tmpLag;
        if (tmpLag >= 0)
        {
            for (i=1; i <= abs(tmpLag); i++)
            {
                startPeriod = nextMth(startPeriod);
            }
        }
        else
        {
            for (i=1; i <= abs(tmpLag); i++)
            {
                startPeriod = prevMth(startPeriod);
            }
        }
        return endmth(startPeriod);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public QueryRun  queryRun(QueryRun _queryRun = queryRun)
    {
        ;
        queryRun = _queryRun;
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>round</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected RPayAmount round(RPayAmount _amount)
    {
        RPayAmount  amount = _amount;
        ;
        if (! _amount)
        {
            return 0;
        }

        if (payCounterCalcTable.Minimum)
        {
            amount = min(_amount, payCounterCalcTable.Minimum);
        }

        if (payCounterCalcTable.Maximum)
        {
            amount = max(_amount, payCounterCalcTable.Maximum);
        }
        if (payCounterCalcTable.RoundoffType)
        {
            switch (payCounterCalcTable.RoundoffType)
            {
                case RPayRoundoffType::Ordinary:
                    amount = round(_amount, payCounterCalcTable.RoundOff);
                    break;
                case RPayRoundoffType::RoundDown:
                    amount = roundDown(_amount, payCounterCalcTable.RoundOff);
                    break;
                case RPayRoundoffType::RoundUp:
                    amount = roundUp(_amount, payCounterCalcTable.RoundOff);
                    break;
            }
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCounterTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets counter table record.
    /// </summary>
    /// <param name="_payCounterTable">
    /// The counter table record, set if specified.
    /// </param>
    /// <returns>
    /// The counter table record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RPayCounterTable setCounterTable(RPayCounterTable _payCounterTable = payCounterTable)
    {
        ;
        payCounterTable = _payCounterTable.data();
        return payCounterTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEmplTable</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void setEmplTable(Common _common)
    {
        ;
        emplTable = _common.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInitValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the initial value.
    /// </summary>
    /// <param name="value">
    /// The value.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void setInitValue(RPayQty value = 0)
    {
        ;
        initialSumCounter = value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSeqTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the sequence of calculation table record.
    /// </summary>
    /// <param name="_paySeqTable">
    /// The sequence of calculation table record, set if specified.
    /// </param>
    /// <returns>
    /// The sequence of calculation table record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RPaySeqTable setSeqTable(RPaySeqTable _paySeqTable = paySeqTable)
    {
        ;
        paySeqTable = _paySeqTable.data();
        return paySeqTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the calculation source table record.
    /// </summary>
    /// <param name="_common">
    /// The source record, set if specified.
    /// </param>
    /// <returns>
    /// The source record.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public Common setSourceTable(Common _common = sourceTable)
    {
        sourceTable = _common.data();
        this.setEmplTable(sourceTable);
        return sourceTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDateStart</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected TransDate transDateStart(TransDate _transDate = transDate)
    {
        int        i, tmpLag;
        TransDate  transDateStart = _transDate;
        ;
        switch (payCounterCalcTable.PayPeriodFrequency)
        {
            case RPayPeriodFrequency::Month    :
                tmpLag = 1;
                break;
            case RPayPeriodFrequency::Quarter  :
                tmpLag = #monthsPerQuarter;
                break;
            case RPayPeriodFrequency::HalfYear :
                tmpLag = #monthsPerHalfYear;
                break;
            case RPayPeriodFrequency::Year     :
                tmpLag = #monthsPerYear;
                break;
            default:
                tmpLag = 0;
                break;
        }
        if (tmpLag)
        {
            transDateStart =  mkDate(dayOfMth(transDateStart),((mthOfYr(transDateStart) div tmpLag) * tmpLag +
                                     (mthOfYr(transDateStart) mod tmpLag ? 1 : (1 - tmpLag))),year(transDateStart));
        }

        tmpLag = payCounterCalcTable.PeriodLag * tmpLag;
        if (tmpLag >= 0)
        {
            for (i=1; i <= abs(tmpLag); i++)
            {
                transDateStart = nextMth(transDateStart);
            }
        }
        else
        {
            for (i=1; i <= abs(tmpLag); i++)
            {
                transDateStart = prevMth(transDateStart);
            }
        }

        if (_transDate == endmth(_transDate))
            return endmth(transDateStart);

        return transDateStart;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePayTrans</Name>
				<Source><![CDATA[
    #RpayModuleName
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void updatePayTrans(TransDate _calcTransDate = dateNull())
    {
        RPayModuleTable rPayModuleTable = RPayModuleTable::find(#ModuleNameTax);
        ;
        ttsbegin;
        select forupdate payTrans index SourceIdx
            where payTrans.PayPeriod        == payPeriodVirtual             &&
                  payTrans.PayModuleCode    == payModuleTable.PayModuleCode &&
                  payTrans.Scanning         == paySeqTable.Scanning         &&
                  payTrans.CounterUnit      == payCounterTable.CounterUnit  &&
                  payTrans.SourceTableId    == sourceTable.TableId          &&
                  payTrans.SourceRecId      == sourceTable.RecId            &&
                  payTrans.Emplid           == emplTable.EmployeeId         &&
                  payTrans.CalcTransDate    == _calcTransDate               &&
                  payTrans.CorrectedPeriod  == this.calcPeriod();

        if (payTrans.RecId)
        {
            if (sumCounter)
            {
                this.initPayTransValue();
                if (payModuleTable.PayModuleGroupId < rPayModuleTable.PayModuleGroupId)
                {
                    payTrans.update();
                }
                else
                {
                    if (payTrans.checkClosedModule())
                    {
                        payTrans.doUpdate();
                    }
                }
            }
            else
            {
                if (payModuleTable.PayModuleGroupId < rPayModuleTable.PayModuleGroupId)
                {
                    payTrans.delete();
                }
                else
                {
                    if (payTrans.checkClosedModule())
                    {
                        payTrans.doDelete();
                    }
                }
            }
        }
        else if (sumCounter)
        {
            this.initPayTransValue();
            if (payModuleTable.PayModuleGroupId < rPayModuleTable.PayModuleGroupId)
            {
                payTrans.insert();
            }
            else
            {
                if (payTrans.checkClosedModule())
                {
                    payTrans.doInsert();
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>
