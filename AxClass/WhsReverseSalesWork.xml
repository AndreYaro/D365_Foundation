<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WhsReverseSalesWork</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsReverseSalesWork</c> class is used to reverse sales order work.
/// </summary>
public class WhsReverseSalesWork extends RunBase
{
    Common              common;
    WHSLoadTable        loadTable;
    WHSWaveTable        waveTable;
    WHSReverseWorkMode  mode;
    str                 specifiedLocation;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkWorkHeaders</Name>
				<Source><![CDATA[
    private void checkWorkHeaders()
    {
        WHSWorkLine             workLine;
        str                     loadIdList;
        WHSWorkId               prevWorkId;
        WHSLoadTable            tmpLoadTable;
        WHSWorkLine             tmpWHSWorkLine;

        // Check for work headers associated with multiple loads if reversing by load
        if (loadTable)
        {
            while select workLine
                group by workLine.WorkId, workLine.LoadId
                join LoadId from tmpLoadTable
                where workLine.LoadId == tmpLoadTable.LoadId &&
                      workLine.LoadId != loadTable.LoadId    &&
                      workLine.LoadId != ''
                    exists join tmpWHSWorkLine
                    where tmpWHSWorkLine.WorkId == workLine.WorkId &&
                          tmpWHSWorkLine.LoadId == loadTable.LoadId
            {
                if (prevWorkId == workLine.WorkId)
                {
                    continue;
                }

                loadIdList += workLine.LoadId + ", ";
                prevWorkId = workLine.WorkId;
            }

            if (loadIdList)
            {
                loadIdList = subStr(loadIdList, 1, strLen(loadIdList) - 2);
                throw error(strFmt("@WAX2236", prevWorkId, loadTable.LoadId, loadIdList));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkLines</Name>
				<Source><![CDATA[
    private void checkWorkLines()
    {
		//MoveToLocation and MoveUsingLocDirectives for a closed work creates a new open work. Order-committed reservation can't be set back in this case since reservation is on the work line.
		if (mode == WHSReverseWorkMode::MoveToLocation ||
			mode == WHSReverseWorkMode::MoveUsingLocDirectives)
		{
            WHSWorkLine		workLine;
            WHSWorkTable	workTable;

            select firstonly TableId from workTable
            where  (loadTable.LoadId && workTable.LoadId  == loadTable.LoadId)
				|| (waveTable.WaveId && workTable.WaveId  == waveTable.WaveId)
                && (workTable.WorkStatus	== WHSWorkStatus::InProcess
                ||  workTable.WorkStatus	== WHSWorkStatus::Closed)
            exists join workLine
            where  workLine.WorkId		== workTable.WorkId
                && workLine.WorkStatus  == WHSWorkStatus::Closed
                && workLine.WorkType	== WHSWorkType::Pick
                && workLine.OrderCommittedInventDimId;

            if (workTable)
            {
                throw error("@WAX:ReverseWorkOrderCommittedError");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSpecifyLocationWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new work to move a license plate to a new location based on an existing work line.
    /// </summary>
    /// <param name="_workTable">
    /// The existing work header.
    /// </param>
    /// <param name="_workLine">
    /// The existing work line.
    /// </param>
    /// <param name="_putLocation">
    /// The new location.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions.
    /// </param>
    /// <returns>
    /// A container with the ID for the created work, and a license plate ID.
    /// </returns>
    public container createSpecifyLocationWork(WHSWorkTable    _workTable,
                                               WHSWorkLine     _workLine,
                                               WMSLocationId   _putLocation,
                                               InventDim       _inventDim)
    {
        if (!_putLocation || !_inventDim.wMSLocationId)
        {
            throw error("@WAX912");
        }

        WHSUserId userId = WHSParameters::find().GenericWorkUserId;

        if (!userId)
        {
            throw error("@WAX2758");
        }

        boolean useInventSumDeltaFindQty = _workTable.WorkStatus == WHSWorkStatus::Closed;

        WHSWorkId           workId;
        WHSLicensePlateId   licensePlateId = this.getLicensePlateForReverseWork(_workTable);

        if (_inventDim.LicensePlateId)
        {
            // If we have specified a license plate, create the movement for the entire license plate.
            workId = WHSWorkCreateMovementBasic::createBasicLicensePlateMovementWork(userId,
                                                                                    licensePlateId,
                                                                                    _inventDim,
                                                                                    _putLocation,
                                                                                    useInventSumDeltaFindQty,
                                                                                    this.parmExecuteWork());
        }
        else
        {
            // Otherwise, move the specific item quantity
            workId = WHSWorkCreateMovementBasic::createBasicMovementWork(userId,
                                                                        _workLine.ItemId,
                                                                        _workLine.QtyWork,
                                                                        _workLine.UnitId,
                                                                        _inventDim,
                                                                        _inventDim.LicensePlateId,
                                                                        _inventDim.WMSLocationId,
                                                                        _putLocation,
                                                                        licensePlateId,
                                                                        _inventDim.InventStatusId,
                                                                        _inventDim.InventStatusId,
                                                                        useInventSumDeltaFindQty,
                                                                        this.parmExecuteWork());
        }

        return [workId, licensePlateId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCommon</Name>
				<Source><![CDATA[
    public Common parmCommon(Common _common = common)
    {
        common = _common;

        return common;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverses the work for a specified wave or load
    /// </summary>
    /// <param name="_mode">
    /// The mode of work reversal
    /// </param>
    /// <param name="_location">
    /// The specified <c>WMSLocationId</c> value
    /// </param>
    //This is the main entry to the class.
    public void reverseWork(WHSReverseWorkMode _mode, str _location)
    {
        WHSWorkTable            workTable;

        if (!this.validate())
        {
            return;
        }

        if ((_mode == WHSReverseWorkMode::AutoMoveToLocation ||
             _mode == WHSReverseWorkMode::MoveToLocation)
            && !_location)
        {
            throw error("@WAX2237");
        }

        // Set global values.
        mode = _mode;
        specifiedLocation = _location;

        ttsbegin;
        this.checkWorkHeaders();
        this.checkWorkLines();

        // Go to the whs work load link table to find the work table records associated with the load
        while select workTable
            where ((loadTable.LoadId     && workTable.LoadId  == loadTable.LoadId)     ||
                   (waveTable.WaveId     && workTable.WaveId  == waveTable.WaveId))    &&
                  workTable.WorkStatus   != WHSWorkStatus::Cancelled
        {
            WHSWorkLine workLineWithOnHand;

            switch (workTable.WorkStatus)
            {
                case WHSWorkStatus::Open:
                case WHSWorkStatus::Combined:
                case WHSWorkStatus::PendingReview:
                case WHSWorkStatus::Skipped:
                    // If the work is not closed then cancel as if the cancel work button had been pressed
                    WHSWorkTable::cancelWork(workTable.WorkId, false);
                    break;

                case WHSWorkStatus::InProcess:
                    workLineWithOnHand = this.getWorkLineWithOnHandForWork(workTable);

                    if (WHSWorkTable::cancelWork(workTable.WorkId, false))
                    {
                        if (this.canCreateWorkToMoveItemsBack(workTable))
                        {
                            this.createWorkToMoveItemsBack(workTable, workLineWithOnHand);
                        }
                    }
                    break;

                case WHSWorkStatus::Closed:                    
                    if (!workTable.isOriginForConsolidatedWork()) // We do not want to unpick lines from origin work - that's done through consolidated work
                    {
                        workLineWithOnHand = this.getWorkLineWithOnHandForWork(workTable);

                        if (this.canReverseWorkLines(workLineWithOnHand))
                        {
                            this.reverseWorkLines(workTable);
                        }
                        else
                        {
                            throw error("@SYS18447");
                        }

                        if (this.canCreateWorkToMoveItemsBack(workTable))
                        {
                            this.createWorkToMoveItemsBack(workTable, workLineWithOnHand);
                        }
                        else
                        {
                            // Throw here if validation failed so that we roll back the reversal of work lines above.
                            throw error("@SYS18447");
                        }
                    }
                    this.setCancelWorkStatus(workTable.WorkId);
                    break;
            }

            if (WHSWorkTable::find(workTable.WorkId).WorkStatus == WHSWorkStatus::Cancelled)
            {
                WHSContainerTable::deleteRelatedToWorkContainersCreatedByContainerization(workTable.WorkId);
                
                if (WHSReverseSalesWorkDependentSortTransactionsDeletedFlight::instance().isEnabled())
                {
                    WHSOutboundSortPositionTrans::deleteSortPositionTransForReversedWork(workTable.WorkId);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCancelWorkStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the work's status to canceled.
    /// </summary>
    /// <param name="_workId">
    /// The ID of the work.
    /// </param>
    void setCancelWorkStatus(WHSWorkId _workId)
    {
        WHSWorkTable    workTable;

        ttsbegin;

        workTable = WHSWorkTable::find(_workId, true);

        if (workTable)
        {
            workTable.WorkStatus = WHSWorkStatus::Cancelled;
            workTable.WorkCancelledByUser      = curUserId();
            workTable.WorkCancelledUTCDateTime = DateTimeUtil::utcNow();
            workTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that only sales transactions are included on the selected load or wave record
    /// </summary>
    private void validateTransType()
    {
        WHSLoadLine loadLine;
        WHSWaveLine waveLine;

        switch (common.TableId)
        {
            case tableNum(WHSLoadTable):
                loadTable = common;

                select firstonly loadLine
                    where loadLine.LoadId           == loadTable.LoadId
                        && loadLine.InventTransType != InventTransType::Sales;

                if (loadLine)
                {
                    throw error("@WAX4743");
                }
                break;
            case tableNum(WHSWaveTable):
                waveTable = common;

                select firstonly waveLine
                    where waveLine.WaveId           == waveTable.WaveId
                        && waveLine.WorkTransType   != WHSWorkTransType::Sales;

                if (waveLine)
                {
                    throw error("@WAX4743");
                }
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoCWTagItemsExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that no catch weight tag enabled items exist on the load or wave. 
    /// </summary>
    private void validateNoCWTagItemsExist()
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().isEnabled())
        {
            return;
        }

        WHSLoadLine loadLine;
        WHSInventTable whsInventTable;
        WHSCatchWeightItemHandlingPolicy itemHandlingPolicy;

        switch (common.TableId)
        {
            case tableNum(WHSLoadTable):
                loadTable = common;

                select firstonly RecId from loadLine
                    where loadLine.LoadId == loadTable.LoadId
                    exists join whsInventTable
                        where whsInventTable.ItemId == loadLine.ItemId
                    exists join itemHandlingPolicy
                        where itemHandlingPolicy.PolicyName == whsInventTable.CatchWeightItemHandlingPolicyName
                            && itemHandlingPolicy.CatchWeightTagTracking == NoYes::Yes;

                if (loadLine.RecId)
                {
                    throw error("@WAX:Error_WHSReverseWorkFeatureDoesNotSupportCW");
                }
                break;

            case tableNum(WHSWaveTable):
                waveTable = common;
                WHSWaveLine waveLine;

                select firstonly RecId from waveLine
                    where waveLine.WaveId == waveTable.WaveId
                    exists join loadLine
                        where loadLine.ShipmentId == waveLine.ShipmentId
                    exists join whsInventTable
                        where whsInventTable.ItemId == loadLine.ItemId
                    exists join itemHandlingPolicy
                        where itemHandlingPolicy.PolicyName == whsInventTable.CatchWeightItemHandlingPolicyName
                            && itemHandlingPolicy.CatchWeightTagTracking == NoYes::Yes;

                if (waveLine.RecId)
                {
                    throw error("@WAX:Error_WHSReverseWorkFeatureDoesNotSupportCW");
                }
                break;

            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static WHSReverseSalesWork construct()
    {
        return new WHSReverseSalesWork();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructor method of the class with common record as parameter.
    /// </summary>
    /// <param name="_common">
    /// Common record.
    /// </param>
    /// <returns>
    /// <c>WHSReverseSalesWork</c> class instance.
    /// </returns>
    public static WHSReverseSalesWork newStandard(Common _common)
    {
        WHSReverseSalesWork whsReverseSalesWork = WHSReverseSalesWork::construct();

        whsReverseSalesWork.parmCommon(_common);

        return whsReverseSalesWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unPick</Name>
				<Source><![CDATA[
    private void unPick(SalesLine _salesLine, WHSInventQtyWork _inventQtyWork)
    {
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        Qty                     quantityUnpicked;

        ttsbegin;

        while select InventDimId, Qty, PdsCWQty from inventTrans
            exists join inventTransOrigin
                where inventTrans.InventTransOrigin     == inventTransOrigin.RecId
                    && inventTransOrigin.InventTransId  == _salesLine.InventTransId
                    && inventTrans.StatusIssue          == StatusIssue::Picked
                    && inventTrans.StatusReceipt        == StatusReceipt::None
        {
            WHSInvent::pickQuantities(_salesLine, inventTrans.InventDimId, inventTrans.Qty, inventTrans.PdsCWQty, null, UnknownNoYes::No /*No reserve*/);
            // Subtract since inventTrans.Qty is negative for sales issues.
            quantityUnpicked -= PdsGlobal::pdsIsCWItem(_salesLine.ItemId) ? inventTrans.PdsCWQty : inventTrans.Qty;
        }

        if (quantityUnpicked != _inventQtyWork)
        {
            throw error(strFmt("@SYP4881563", "@WAX2738"));
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>Main</Name>
				<Source><![CDATA[
    public static void Main(Args _args)
    {
        //This class is referenced by Action Menu Item: WhsReverseSalesWork, so it needs to have a Main method.
        throw error('not implemented');
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkLineWithOnHandForWork</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the work line that contains the details of where the goods are physically located.
    /// </summary>
    /// <param name = "_workTable">Work order being reversed.</param>
    /// <returns>A work line.</returns>
    /// <remarks>
    /// This method needs to be called prior to the work lines being cancelled, since it relies on <c>getNextOppositeWorkLineFromWorkLine</c>
    /// </remarks>
    private WHSWorkLine getWorkLineWithOnHandForWork(WHSWorkTable _workTable)
    {
        WHSWorkLine lastPutLine = WHSWorkTable::getLastClosedPutWorkLine(_workTable.WorkId);
        WHSWorkLine nextPickLine = WHSWorkLine::getNextOppositeWorkLineFromWorkLine(lastPutLine);
        WHSWorkLine workLineWithOnHand = nextPickLine ? nextPickLine : lastPutLine;

        return workLineWithOnHand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateWorkToMoveItemsBack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a work to "re-shelve" the canceled inventory or move it to a specified location can be created.
    /// </summary>
    /// <param name="_workTable"> The work table to create work for.</param>
    /// <returns>true if the work can be created; otherwise, false.</returns>
    private boolean canCreateWorkToMoveItemsBack(WHSWorkTable  _workTable)
    {
        return !this.isSerialNumberCaptured(_workTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkToMoveItemsBack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create work to "re-shelve" the canceled inventory or move it to a specified location.
    /// </summary>
    /// <param name="_workTable">The work table to create work for.</param>
    /// <param name="_workLineWithOnHand">The work line that contains details of where the goods are physically located.</param>
    /// <returns>The <c>WHSWorkId</c> of the created work.</returns>
    protected WHSWorkId createWorkToMoveItemsBack(WHSWorkTable  _workTable, WHSWorkLine _workLineWithOnHand)
    {
        WHSWorkId           workId;
        WHSLicensePlateId   licensePlateIdForReverseWork = this.getLicensePlateForReverseWork(_workTable);

        InventDim inventDim = _workLineWithOnHand.inventDim();
        inventDim.InventSiteId = _workTable.InventSiteId;
        inventDim.InventLocationId = _workTable.InventLocationId;
        inventDim.wMSLocationId = _workLineWithOnHand.WMSLocationId;
        if (inventDim.wmsLocation().whsLocationIsLPControlled())
        {
            inventDim.LicensePlateId = licensePlateIdForReverseWork;
        }
        inventDim = InventDim::findOrCreate(inventDim);

        switch (mode)
        {
            case WHSReverseWorkMode::MoveToLocation:
            case WHSReverseWorkMode::MoveUsingLocDirectives:
                WHSTmpMovementWork tmpMovementWork;
                tmpMovementWork.InventDimId = inventDim.InventDimId;
                tmpMovementWork.Qty         = _workLineWithOnHand.InventQtyWork;
                tmpMovementWork.UnitID      = WHSCatchWeightHelper::inventHandlingUnitId(_workLineWithOnHand.ItemId);

                WHSWorkCreateMovement workCreate = WHSWorkCreate::construct(tmpMovementWork);
                workCreate.parmStartLocationId(_workLineWithOnHand.WMSLocationId);
                workCreate.parmTargetLicensePlateId(licensePlateIdForReverseWork);

                if (mode == WHSReverseWorkMode::MoveToLocation)
                {
                    workCreate.parmEndLocationId(specifiedLocation);

                    // finalPutLocation is used to store the put location for movement work when doing "Reverse work"
                    // with moving to specific location
                    workCreate.parmFinalPutLocation(specifiedLocation);
                    workCreate.parmIsReverseWorkMovementToLocation(true);
                }

                workId = workCreate.createWork();
                break;

            case WHSReverseWorkMode::AutoMoveToLocation:
                // We create work for the entire license plate.
                WHSLicensePlateId licensePlateId;
                [workId, licensePlateId] = this.createSpecifyLocationWork(_workTable, _workLineWithOnHand, specifiedLocation, inventDim);
                break;
        }

        if (workId)
        {
            info(strFmt("@WAX3849", workId));
        }

        return workId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSerialNumberCaptured</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if a serial number has been captured for the work.
    /// </summary>
    /// <param name="_workTable">
    /// The work table.
    /// </param>
    /// <returns>
    /// true if one serial number is captured; otherwise, false.
    /// </returns>
    private boolean isSerialNumberCaptured(WHSWorkTable  _workTable)
    {
        boolean canItemCaptureSerialsAtPickOrPack(ItemId _itemId)
        {
            WHSRFWhenToCapture captureSerial = whsInventTable::captureSerial(_itemId);

            return captureSerial == WHSRFWhenToCapture::Picking
                || captureSerial == WHSRFWhenToCapture::Packing;
        }

        if (WHSInventoryTransactionConfigurationProvider::shouldUseWorkInventoryTransactionQuery(_workTable.WorkId))
        {
            WHSWorkLine workLine;

            WHSWorkLine firstPutLine    = WHSWorkTable::getFirstPutWorkLine(_workTable.WorkId);
            Set         ignoreItemIdSet = new Set(Types::String);

            WHSWorkInventoryTransactionQuery workInventoryTransactionQuery = WHSWorkInventoryTransactionQuery::newFromWorkId(_workTable.WorkId);

            while select LineNum, ItemId from workLine
                where  workLine.WorkId == _workTable.WorkId
                    && workLine.WorkType == WHSWorkType::Pick
                    && workLine.LineNum < firstPutLine.LineNum
                    && workLine.InventQtyWork != workLine.InventQtyRemain
            {
                // this code is perf optimization - to avoid reading transactions when we know item cannot capture serials at pick or pack.
                if (workLine.ItemId)
                {
                    if (ignoreItemIdSet.in(workLine.ItemId))
                    {
                        continue;
                    }
                    else if (!canItemCaptureSerialsAtPickOrPack(workLine.ItemId))
                    {
                        ignoreItemIdSet.add(workLine.ItemId);
                        continue;
                    }
                }

                WHSWorkInventoryTransactionDescriptor inventoryTransactionDescriptor = workInventoryTransactionQuery.registeredReceiptByWorkLine(
                    workLine.LineNum,
                    WHSWorkInventoryTransactionQueryParameters::construct().setIncludeArchivedTransactions(true));

                WHSWorkInventoryTransactionDescriptorEnumerator enumerator = inventoryTransactionDescriptor.getEnumerator();

                while (enumerator.moveNext())
                {
                    WHSWorkInventoryTransactionDescriptorElement inventoryTransactionDescriptorElement = enumerator.current();

                    if (ignoreItemIdSet.in(inventoryTransactionDescriptorElement.parmItemId()))
                    {
                        continue;
                    }
                    else if (!canItemCaptureSerialsAtPickOrPack(inventoryTransactionDescriptorElement.parmItemId()))
                    {
                        ignoreItemIdSet.add(inventoryTransactionDescriptorElement.parmItemId());
                        continue;
                    }

                    if (inventoryTransactionDescriptorElement
                            .parmInventoryDimensionsDescriptor()
                            .parmProductTrackingDimensions()
                            .parmInventSerialId())
                    {
                        info(strFmt("@SYP4881557", workLine.ItemId));
                        return true;
                    }
                }
            }
        }
        else
        {
            InventTrans             inventTrans;
            InventTransOrigin       inventTransOrigin;
            InventDim               inventDim;

            while select itemId from inventTrans
                exists join inventDim
                    where inventTrans.inventDimId == inventDim.inventDimId
                       && inventDim.inventSerialId != ''
                exists join inventTransOrigin
                    where inventTransOrigin.RecId              == inventTrans.InventTransOrigin
                       && inventTransOrigin.ItemId             == inventTrans.itemId
                       && inventTransOrigin.ReferenceCategory  == InventTransType::WHSWork
                       && inventTransOrigin.ReferenceId        == _workTable.WorkId
            {
                switch (whsInventTable::captureSerial(inventTrans.ItemId))
                {
                    case WHSRFWhenToCapture::Picking:
                    case WHSRFWhenToCapture::Packing:
                        info(strFmt("@SYP4881557", inventTrans.ItemId));
                        return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExecuteWork</Name>
				<Source><![CDATA[
    protected boolean parmExecuteWork()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the work lines on a work.
    /// </summary>
    /// <param name="_workTable">
    /// The work table.
    /// </param>
    private void reverseWorkLines(WHSWorkTable  _workTable)
    {
        WHSWorkLineLoadLineDetailsEnumerator enumerator = _workTable.getEnumerator();
        while (enumerator.moveNext())
        {
            WHSLoadLine loadLine = enumerator.currentLoadLine();
            if (loadLine)
            {
                this.unpickSalesLine(loadLine, enumerator.currentInventQtyWork(), enumerator.currentCapturedWeight());

                loadLine.reread(); // Reread because we update the loadLine in above method
                loadLine.WorkCreatedQty -= enumerator.currentInventQtyWork();
                loadLine.update();

                WHSContainerLine::adjustQuantityBasedOnWorkLineNoContainer(loadLine.RecId, -enumerator.currentInventQtyWork());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpickSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reverse the pick of the sales line associated with the load line.
    /// </summary>
    private void unpickSalesLine(WHSLoadLine _loadLine, WHSInventQtyWork _inventQtyWork, WHSTransWeight _weight)
    {
        WHSLoadLine loadLine;
        WHSWorkLine workLine;
        SalesQty    pickedInTotalHandlingUnit;
        boolean     pickedInTotal = false;

        ttsbegin;

        // Get the sales line
        var salesLine = _loadLine.getOrderCommonFromLoadLine() as SalesLine;

        // When reversing a wave prevent reversal if work is ship confirmed.
        if (waveTable.WaveId && salesLine.deliveredInTotal() > 0)
        {
            // Do not undeliver qty.
            throw error("@WAX:ReverseWorkForDeliveredSalesLineError");
        }

        select count(RecId) from loadLine
            where loadLine.LoadId == _loadLine.LoadId
                && loadLine.InventTransId == _loadLine.InventTransId
                && loadLine.InventTransType == InventTransType::Sales;

        pickedInTotalHandlingUnit = PdsGlobal::pdsIsCWItem(salesLine.ItemId) ? salesLine.pdsCWPickedInTotal() : salesLine.pickedInTotalInventUnit();

        // Look at sales order details picked field and unpick
        if (pickedInTotalHandlingUnit > 0)
        {
            if (loadLine.RecId > 1)
            {
                select sum(InventQtyWork) from workLine
                    group by InventTransId
                        where workLine.InventTransId == _loadLine.InventTransId
                            && workLine.WorkStatus != WHSWorkStatus::Cancelled
                            && workLine.WorkType == WHSWorkType::Pick;

                this.unPick(salesLine, min(workLine.InventQtyWork, pickedInTotalHandlingUnit));
            }
            else
            {
                this.unPick(salesLine, _inventQtyWork);
            }

            pickedInTotal = true;
        }
            
        if (pickedInTotal || loadLine.RecId > 1)
        {
            _loadLine.PickedQty = max(0, _loadLine.PickedQty - _inventQtyWork);
            _loadLine.PickedWeight = max(0, _loadLine.PickedWeight - _weight);
            _loadLine.update();

            this.reReserve(_loadLine, salesLine, _inventQtyWork, _weight);
        }
		
        // Inform the user if the serial number is associated with load's sales line
        if (InventTable::find(salesLine.ItemId).isSalesProcessSerialActive()
			&& WHSInventTable::captureSerial(salesLine.ItemId) != WHSRFWhenToCapture::None)
        {
            warning("@WAX:SerialNumbersExistOnSalesLine");
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the operation can be performed.
    /// </summary>
    /// <param name="calledFrom">
    /// Unused, optional.
    /// </param>
    /// <returns>
    /// true if valid; otherwise, false.
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        boolean ret = super(calledFrom);

        this.validateTransType();

        this.validateNoCWTagItemsExist();

        WHSWorkTable workTable;
        select firstonly recId from workTable
            where ((loadTable.LoadId     && workTable.LoadId  == loadTable.LoadId)     ||
                   (waveTable.WaveId     && workTable.WaveId  == waveTable.WaveId))    &&
                  workTable.WorkStatus   != WHSWorkStatus::Cancelled &&
                  workTable.LockedUser   != '';

        if (workTable)
        {
            throw error("@WAX708");
        }

        if (loadTable.LoadId &&
            (loadTable.LoadStatus == WHSLoadStatus::Shipped ||
             loadTable.LoadStatus == WHSLoadStatus::Received ))
        {
            throw error("@WAX:ReverseWorkForDeliveredSalesLineError");
        }

        if (this.checkWorkTransTypeIsPackedContainerPicking())
        {
            throw error(strFmt("@WAX:CannotReverseWorkOrderType", WHSWorkTransType::PackedContainerPicking));
        }

        if (loadTable.isAnyRelatedTransportLoadShipped())
        {
            throw error("@WAX:Error_ShippedTransportLoadSalesCannotBeReversed");
        }

        if (loadTable.isAnyRelatedPackingSlipUpdated())
        {
            throw error(strFmt("@WAX:Error_PackingSlipPostedSalesOrderLoadLineCannotReverseWork", loadTable.LoadId));
        }

        this.validateNoWorkAssociatedToClusterLockedByUser();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoWorkAssociatedToClusterLockedByUser</Name>
				<Source><![CDATA[
    private void validateNoWorkAssociatedToClusterLockedByUser()
    {
        WHSWorkTable workTable;
        WHSWorkClusterLine workClusterLine;
        WHSWorkClusterTable workCLusterTable;

        // Filtering on loadId or waveId is the most selective for this query,
        // so forceselectorder keyword is used to filter first on WHSWorkTable.
        // The condition workClusterTable.WorkClusterStatus != WHSWorkClusterStatus::Closed helps performance.
        // The query from below should use the ClusterIdIdx index, ClustedId and WorkClusterStatus are part of the index
        // and LockedUser is an included column.

        select firstonly forceselectorder WorkId from workTable
            where ((loadTable.LoadId     && workTable.LoadId  == loadTable.LoadId)
                    ||(waveTable.WaveId     && workTable.WaveId  == waveTable.WaveId))
            join TableId from workClusterLine
                where workClusterLine.WorkId == workTable.WorkId
            join LockedUser from workClusterTable
                where workClusterTable.ClusterId            == workClusterLine.ClusterId
                   && workClusterTable.WorkClusterStatus    != WHSWorkClusterStatus::Closed
                   && workClusterTable.LockedUser           != '';

        if (workClusterTable.LockedUser)
        {
            throw error(strFmt("@WAX:WHSReverseWorkFoundWorkRelatedToClustedLockedByUser", workTable.WorkId, workClusterTable.LockedUser));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWorkTransTypeIsPackedContainerPicking</Name>
				<Source><![CDATA[
    private boolean checkWorkTransTypeIsPackedContainerPicking()
    {
        WHSWorkTable workTable;

        if (loadTable.LoadId)
        {
            select firstonly RecId from workTable
				where workTable.WorkTransType	== WHSWorkTransType::PackedContainerPicking
					&& workTable.LoadId			== loadTable.LoadId;
        }
        else if (waveTable.WaveId)
        {
			// The query needs to use the shipment table, because there are some works that don't have the wave ID set (e.g. Packed container picking).
            WHSShipmentTable shipmentTable;

            select firstonly RecId from workTable
				where workTable.WorkTransType == WHSWorkTransType::PackedContainerPicking
				exists join shipmentTable
					where shipmentTable.ShipmentId	== workTable.ShipmentId
                        && shipmentTable.WaveId		== waveTable.WaveId;
        }

        return (workTable.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reReserve</Name>
				<Source><![CDATA[
    private void reReserve(WHSLoadLine _loadLine, SalesLine _salesLine, Qty _handlingQty, WHSTransWeight _weight)
    {
        Qty qty;
        PdsCWQty cwQty;

        if (PdsGlobal::pdsIsCWItem(_salesLine.ItemId))
        {
            cwQty = _handlingQty;
            qty = _weight;

            // Reservation may attempt to update the movement buffer so this must be selected for update
            _salesLine.selectForUpdate(true);
        }
        else
        {
            cwQty = 0;
            qty = _handlingQty;
        }

        var movement = InventMovement::construct(_salesLine, InventMovSubType::None);

        var reservation = InventUpd_Reservation::newMovement(movement, -qty, false, false, false, -cwQty);
        reservation.parminventDimOnHandSelectionCriteria(InventDim::find(_loadLine.InventDimId));
        reservation.updateNow();

        this.reReserveFlexible(_loadLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reReserveFlexible</Name>
				<Source><![CDATA[
    private void reReserveFlexible(WHSLoadLine _loadLine)
    {
        WHSWorkLine		workLine;
        WHSWorkTable    workTable;

		while select InventTransId, OrderCommittedInventDimId, QtyWork from workLine
            where  workLine.LoadLineRefRecId == _loadLine.RecId
                && workLine.WorkType		 == WHSWorkType::Pick
				&& workLine.WorkStatus		 == WHSWorkStatus::Closed
                && workLine.OrderCommittedInventDimId
            notexists join workTable
                where workTable.WorkId == workLine.WorkId
                    && workTable.WorkStatus == WHSWorkStatus::Cancelled
        {
            WHSOrderCommittedReservationFacade::updateOrderCommittedReservation(workLine.InventTransId,
																				workLine.OrderCommittedInventDimId,
                                                                                workLine.QtyWork);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReverseWorkLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a work lines can be reversed.
    /// </summary>
    ///<param name="_workLineWithOnHand">
    ///The work line that contains details of where the goods are physically located.
    ///</param>
    /// <returns>
    /// True if the work lines can be reversed; otherwise, false.
    /// </returns>
    private boolean canReverseWorkLines(WHSWorkLine _workLineWithOnHand)
    {
        boolean ret = true;

        if (mode == WHSReverseWorkMode::MoveToLocation)
        {
            WHSContainerLine containerLine;
            WHSContainerTable containerTable;
            InventDim inventDim;
            WHSWorkLine workLine;

            select firstonly RecId from containerLine
                exists join containerTable
                    where containerTable.ShipmentId == containerLine.ShipmentId
                       && containerTable.ContainerId == containerLine.ContainerId
                       && containerTable.ContainerStatus == WHSContainerStatus::Closed
                exists join inventDim
                    where inventDim.inventDimId == containerLine.InventDimId
                        && inventDim.wMSLocationId == _workLineWithOnHand.WMSLocationId
                exists join workLine
                    where workLine.LoadLineRefRecId == containerLine.LoadLine
                       && workLine.WorkId == _workLineWithOnHand.WorkId;

            if (containerLine.RecId)
            {
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLicensePlateForReverseWork</Name>
				<Source><![CDATA[
    private WHSLicensePlateId getLicensePlateForReverseWork(WHSWorkTable _work)
    {
        if (WHSParameters::find().ToteReuse)
        {
            WHSToteReuseTable toteReuseTable = WHSToteReuseTable::find(_work.TargetLicensePlateId, _work.WorkId);

            return toteReuseTable ? toteReuseTable.TmpToteId : _work.TargetLicensePlateId;
        }
        else
        {
            return _work.TargetLicensePlateId;
        }        
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>