<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjWorkBreakdownStructureV2FormHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjWorkBreakdownStructureV2FormHelper
{
    #TimeConstants

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>initializeProjHierarchyTemp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert records to temp table from base hierarchy table.
    /// This assumes all records are missing (so does not check for existance first, unlike 'createMissingTempRecords', and only makes the root record visible.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the hierarchy to initialize temp table records from.</param>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table to initialize.</param>
    public static void initializeProjHierarchyTemp(
        HierarchyIdBase _hierarchyId,
        str _tempTablePhysicalName)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());
        str currentCompany = curExt();
  
        // Construct a query to insert all task (ProjPlanVersion) records into the temp table
        str insertTempSQL = strFmt(@"INSERT INTO %1 (
                                        Partition, DataAreaId, RefRecId, RefSortRecId, RefNodeId, Expand, Visible, SelectionGroup, DiffNumDeletedChildren, RefTableId
                                    ) SELECT
                                        %2, '%3', Task.RecId, Sort.RecId, Task.HierarchyTaskId, 0, IIF(Task.ParentHierarchyTaskId = 0, 1, 0), 0, 0, '%6'
                                    FROM ProjPlanVersion AS Task
                                    INNER JOIN ProjHierarchySorting AS Sort ON
                                        Sort.Partition = %2 AND Sort.DataAreaId = '%3'
                                        AND Sort.Type = %4 AND Sort.RefId = '%5' AND Sort.RefNodeId = Task.HierarchyTaskId
                                    WHERE
                                        Task.Partition = %2 AND Task.DataAreaId = '%3'
                                        AND Task.HierarchyId = '%5';",
                                    _tempTablePhysicalName,
                                    currentPartition,
                                    currentCompany,
                                    enum2int(ProjHierarchySortingType::ProjWBS),
                                    _hierarchyId,
                                    TableNum(ProjPlanVersion));

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(insertTempSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMissingTempRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new temp table records for ProjPlanVersion records that do not already have them.
    /// This initializes all new records to invisible and collapsed, you should use 'resolveVisibleAndExpand' afterwards, if desired.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the current hierarchy.</param>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table</param>
    public static void createMissingTempRecords(
        HierarchyIdBase _hierarchyId,
        str _tempTablePhysicalName)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());
        str currentCompany = curExt();

        // Create new temp table records for missing tasks
        str insertTempSQL = strFmt(@"INSERT INTO %1 (
                                        Partition, DataAreaId, RefRecId, RefSortRecId, RefNodeId, Visible, Expand, SelectionGroup, DiffNumDeletedChildren, RefTableId
                                    ) SELECT
                                        %2, '%3', Task.RecId, Sort.RecId, Task.HierarchyTaskId, 0, 0, 0, 0, '%6'
                                    FROM ProjPlanVersion AS Task
                                    INNER JOIN ProjHierarchySorting AS Sort ON
                                        Sort.Partition = %2 AND Sort.DataAreaId = '%3'
                                        AND Sort.Type = %4 AND Sort.RefId = '%5' AND Sort.RefNodeId = Task.HierarchyTaskId
                                    LEFT JOIN %1 AS TaskTemp ON
                                        TaskTemp.RefRecId = Task.RecId
                                    WHERE
                                        Task.Partition = %2 AND Task.DataAreaId = '%3'
                                        AND Task.HierarchyId = '%5'
                                        AND TaskTemp.RecId IS NULL;",
                                    _tempTablePhysicalName,
                                    currentPartition,
                                    currentCompany,
                                    enum2int(ProjHierarchySortingType::ProjWBS),
                                    _hierarchyId,
                                    TableNum(ProjPlanVersion));

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(insertTempSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTempRecordsForDeletedTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates temp table records for deleted tasks from a previous version.
    /// This has the limitation in that it only creates TempTable entries for the root of deleted sub-hierarchies, since it is not currently possible to correctly display
    /// deleted tasks within deleted sub-hierarchies.
    /// </summary>
    /// <param name = "_oldHierarchyId">Previous version Hierarchy Id.</param>
    /// <param name = "_newHierarchyId">New version Hierarchy Id.</param>
    /// <param name = "_tempTable">Temp table buffer.</param>
    public static void createTempRecordsForDeletedTasks(
        HierarchyIdBase _oldHierarchyId,
        HierarchyIdBase _newHierarchyId,
        ProjHierarchyTemp _tempTable)
    {
        ttsbegin;
        // Enumerate tasks in the OLD hierarchy that DO NOT exist in the NEW hierarchy
        ProjPlanVersion deletedTask, existingTask;
        while select deletedTask
        order by
            deletedTask.HierarchyLevel
        where
            deletedTask.HierarchyId == _oldHierarchyId
        notexists join existingTask where
            existingTask.HierarchyId == _newHierarchyId && existingTask.HierarchyTaskId == deletedTask.HierarchyTaskId
        {
            ProjPlanVersion parentTask = ProjPlanVersion::findByHierarchyAndTaskId(_newHierarchyId, deletedTask.ParentHierarchyTaskId);
            ProjHierarchyTemp parentTemp = _tempTable.findByNodeId(parentTask.HierarchyTaskId);

            // If the parent exists in the NEW hierarchy
            if (parentTask)
            {
                // Try to find the best 'fake' sorting record for this task
                // Ideally that is the same SiblingNumber - 1 (or parent in case of SiblingNumber == 1),
                // barring that it picks the sorting record of the last child,
                // barring that it picks the sorting record of the parent
                RefRecId sortRecId;
                if (parentTask.EndNode || deletedTask.TaskSiblingNumber == 1)
                {
                    sortRecId = parentTemp.RefSortRecId;
                }
                else
                {
                    LineNum bestFitSiblingNumber = min(deletedTask.TaskSiblingNumber - 1, ProjPlanVersion::getMaxSiblingNumber(_newHierarchyId, parentTask.HierarchyTaskId));
                    ProjPlanVersion bestFitSibling = ProjPlanVersion::findByParentTaskIdAndSiblingNumber(_newHierarchyId, parentTask.HierarchyTaskId, bestFitSiblingNumber);
                    sortRecId = ProjWorkBreakdownStructureV2FormHelper::findProjHierarchySortingRecord(_newHierarchyId, bestFitSibling.HierarchyTaskId).RecId;
                }

                // Create a temp record for this deleted task, point it at the sorting record for the parent
                ProjHierarchyTemp tempBuffer = _tempTable.getNewBuffer();
                tempBuffer.RefRecId = deletedTask.RecId;
                tempBuffer.RefSortRecId = sortRecId;
                tempBuffer.RefNodeId = deletedTask.HierarchyTaskId;
                tempBuffer.Visible = parentTemp.Expand;
                tempBuffer.Expand = FalseTrue::False;
                tempBuffer.DiffNumDeletedChildren = 0;
                tempBuffer.insert();
            }
            else
            {
                // Search for the first ancestor of this task in the OLD hierarchy that has a temp record (will be a task that passed the check above)
                ProjPlanVersion deletedAncestor = deletedTask;
                parentTemp.selectForUpdate(true);
                while (!parentTemp)
                {
                    deletedAncestor = ProjPlanVersion::findByHierarchyAndTaskId(_oldHierarchyId, deletedAncestor.ParentHierarchyTaskId);
                    select firstonly forupdate parentTemp where
                        parentTemp.RefNodeId == deletedAncestor.HierarchyTaskId;
                }

                // Increment the number of deleted subtasks, since we can't actually display them (without generating new sorting records)
                parentTemp.DiffNumDeletedChildren += 1;
                parentTemp.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTempRecordsForDeletedTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Destroys TempTable records for tasks not in the given hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy to check tasks against.</param>
    /// <param name = "_tempTable">TempTable buffer.</param>
    public static void deleteTempRecordsForDeletedTasks(
        HierarchyIdBase _hierarchyId,
        ProjHierarchyTemp _tempTable)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());

        str deleteTempSQL = strFmt(@"DELETE Temp FROM %1 AS Temp
                                    INNER JOIN ProjPlanVersion AS Task ON
                                        Task.Partition = %2 AND Task.RecId = Temp.RefRecId
                                    WHERE
                                        Task.HierarchyId != '%3';",
                                    _tempTable.getPhysicalTableName(),
                                    currentPartition,
                                    _hierarchyId);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(deleteTempSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>switchTempHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Points the temp table records to the tasks in the given hierarchy, preserving as much state as possible.
    /// </summary>
    /// <param name = "_newHierarchyId">The new hierarchy to point at.</param>
    /// <param name = "_tempTable">Temp table buffer.</param>
    public static void switchTempHierarchy(
        HierarchyIdBase _newHierarchyId,
        ProjHierarchyTemp _tempTable)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());
        str currentCompany = curExt();

        // Update temp table records for tasks that appear in both hierarchies
        str updateTempSQL = strFmt(@"UPDATE Temp SET
                                        RefRecId = NewTask.RecId,
                                        RefSortRecId = NewSort.RecId
                                    FROM %1 AS Temp
                                    INNER JOIN ProjPlanVersion AS OldTask ON
                                        OldTask.Partition = %2 AND OldTask.RecId = Temp.RefRecId
                                    INNER JOIN ProjPlanVersion AS NewTask ON
                                        NewTask.Partition = %2 AND NewTask.DataAreaId = '%3'
                                        AND NewTask.HierarchyId = '%4' AND NewTask.HierarchyTaskId = OldTask.HierarchyTaskId
                                    INNER JOIN ProjHierarchySorting AS NewSort ON
                                        NewSort.Partition = %2 AND NewSort.DataAreaId = '%3'
                                        AND NewSort.Type = %5 AND NewSort.RefId = '%4' AND NewSort.RefNodeId = NewTask.HierarchyTaskId;",
                                    _tempTable.getPhysicalTableName(),
                                    currentPartition,
                                    currentCompany,
                                    _newHierarchyId,
                                    enum2int(ProjHierarchySortingType::ProjWBS));

        // Delete temp table records for tasks that appear only in the old hierarchy
        str deleteTempSQL = strFmt(@"DELETE Temp FROM %1 AS Temp
                                    INNER JOIN ProjPlanVersion AS OldTask ON
                                        OldTask.Partition = %2 AND OldTask.RecId = Temp.RefRecId
                                    WHERE
                                        OldTask.HierarchyId != '%3';",
                                    _tempTable.getPhysicalTableName(),
                                    currentPartition,
                                    _newHierarchyId);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(updateTempSQL + deleteTempSQL);

        // Create temp table records for tasks that appear only in the new hierarchy
        ProjWorkBreakdownStructureV2FormHelper::createMissingTempRecords(_newHierarchyId, _tempTable.getPhysicalTableName());

        // Resolve the visible/expand state of temp table records
        ProjWorkBreakdownStructureV2FormHelper::resolveVisibleAndExpand(_tempTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveVisibleAndExpand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ensures that the visible/expand state of all temp table records is coherent.
    /// </summary>
    /// <param name = "_tempTable">Temp table buffer.</param>
    [SysObsoleteAttribute('This method is replaced by resolveVisibleFromParentTaskBySQLStatement', false, 20\03\2023)]
    public static void resolveVisibleAndExpand(
        ProjHierarchyTemp _tempTable)
    {
        boolean wbsFormLaunchEnhanceFlight = ProjWBSFormLaunchEnhancementFlight::instance().isEnabled();

        if (wbsFormLaunchEnhanceFlight)
        {
            // Currently this method is expected to be called by:
            // 1. ProjWorkBreakDownStructureV2 form datsource ProjHierarchyTemp.init()
            // 2. ProjWorkBreakdownStructureV2FormHelper::switchTempHierarchy() 
            // 
            // Before calling into this method, both cases should have expand being updated correctly.
            // However, due to CoC compatible issue, we still have both places calling into this method.
            //
            // When this public method resolveVisibleAndExpand() will be removed, then both callers
            // should be updated to replace -
            // from:
            // ProjWorkBreakdownStructureV2FormHelper::resolveVisibleAndExpand()
            // to:
            // ProjWorkBreakdownStructureV2FormHelper::resolveVisibleFromParentTaskBySQLStatement()
            //
            ProjWorkBreakdownStructureV2FormHelper::resolveVisibleFromParentTaskBySQLStatement(_tempTable);
        }
        else
        {
            ProjPlanVersion task;

            ttsbegin;
            while select task
            order by
                task.HierarchyLevel asc
            where
                task.ParentHierarchyTaskId != 0
            join forupdate _tempTable where
            _tempTable.RefRecId == task.RecId
            {
                ProjHierarchyTemp parentTemp = _tempTable.findByNodeId(task.ParentHierarchyTaskId);
                _tempTable.Visible = parentTemp.Expand; // A temp table record may only be visible if its parent has been expanded
                _tempTable.Expand = _tempTable.Expand && _tempTable.Visible; // A temp table record may only be expanded if it is visible
                _tempTable.update();
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResolveVisibleFromParentTaskSQLStatement</Name>
				<Source><![CDATA[
    private static str getResolveVisibleFromParentTaskSQLStatement(ProjHierarchyTemp _tempTable)
    {
        // Set SQL update statement for Visible field
        str updateTempVisibleSQL = strFmt(@"
            UPDATE TempTask SET
                Visible = %1
            FROM %2 AS TempTask
            INNER JOIN ProjPlanVersion as Task
                ON Task.RecId = TempTask.RefRecId
            INNER JOIN %2 AS TempParentTask
                ON TempParentTask.Partition = Task.Partition
                AND TempParentTask.DataAreaId = Task.DataAreaId
                AND TempParentTask.RefNodeId = Task.ParentHierarchyTaskId 
                AND TempParentTask.Expand = %1;",
            enum2int(FalseTrue::True),
            _tempTable.getPhysicalTableName());

        return updateTempVisibleSQL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveVisibleFromParentTaskBySQLStatement</Name>
				<Source><![CDATA[
    public final static void resolveVisibleFromParentTaskBySQLStatement(ProjHierarchyTemp _tempTable)
    {
        str updateTempVisibleSQL = ProjWorkBreakdownStructureV2FormHelper::getResolveVisibleFromParentTaskSQLStatement(_tempTable);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(updateTempVisibleSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRestoreExpandAndVisibleStateSQLStatement</Name>
				<Source><![CDATA[
    private static str getRestoreExpandAndVisibleStateSQLStatement(ProjHierarchyTemp _tempTable, RefRecId _wbsUserExpandRecId)
    {
        str restoreExpandAndVisibleStateSQL;

        if (_wbsUserExpandRecId)
        {
            restoreExpandAndVisibleStateSQL = strFmt(@"
                UPDATE TempTask SET
                    Expand = %1,
                    Visible = %1
                FROM %2 AS TempTask
                INNER JOIN ProjWBSUserExpandLine as ExpandLine
                    ON ExpandLine.Partition = TempTask.Partition
                    AND ExpandLine.DataAreaId = TempTask.DataAreaId
                    AND ExpandLine.ProjWBSUserExpandRefRecId = %3
                INNER JOIN ProjPlanVersion as Task
                    ON Task.RecId = TempTask.RefRecId
                    AND Task.HierarchyTaskId = ExpandLine.TaskId
                    AND Task.EndNode = %4;",
            enum2int(FalseTrue::True),
            _tempTable.getPhysicalTableName(),
            _wbsUserExpandRecId,
            enum2int(FalseTrue::False));
        }
        return restoreExpandAndVisibleStateSQL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreExpandAndVisibleState</Name>
				<Source><![CDATA[
    public final static void restoreExpandAndVisibleState(ProjHierarchyTemp _tempTable, RefRecId _wbsUserExpandRecId)
    {
        str restoreExpandAndVisibleStateSQL = ProjWorkBreakdownStructureV2FormHelper::getRestoreExpandAndVisibleStateSQLStatement(_tempTable, _wbsUserExpandRecId);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(restoreExpandAndVisibleStateSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collapseAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collapse all records except the root.
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table storing expand/collapse state.</param>
    public static void collapseAll(
        str _tempTablePhysicalName)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());

        // Construct a query to collapse and hide everything in the temp table
        str collapseSQL = strFmt(@"UPDATE Temp SET
                                        Expand = 0,
                                        Visible = 0
                                    FROM %1 AS Temp;",
                                    _tempTablePhysicalName);

        // Construct a query to show to root node
        str showRootSQL = strFmt(@"UPDATE Temp SET
                                        Visible = 1
                                    FROM %1 AS Temp
                                    INNER JOIN ProjPlanVersion AS Task ON
                                        Task.Partition = %2 AND Temp.RefRecId = Task.RecId
                                    WHERE
                                        Task.ParentHierarchyTaskId = 0;",
                                _tempTablePhysicalName,
                                currentPartition);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(collapseSQL + showRootSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandAll</Name>
				<Source><![CDATA[
    /// <summary>
    /// Expand all task records, and optionally make estimates visible.
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table storing expand/collapse state.</param>
    /// <param name = "_includeEstimates">Whether to make estimates visible when expanding tasks.</param>
    [SysObsoleteAttribute('This method is replaced by expandAllV2()', false, 10\04\2018)]
    public static void expandAll(
        str _tempTablePhysicalName,
        boolean _includeEstimates)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandAllV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Expand all task records (optionally including end nodes)
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table storing expand/collapse state.</param>
    /// <param name = "_includeEndNodes">Whether to expand end nodes.</param>
    public static void expandAllV2(
        str _tempTablePhysicalName,
        boolean _includeEndNodes = false)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());

        str expandSQL;
        if (_includeEndNodes)
        {
            expandSQL = strFmt(@"UPDATE Temp SET
                                    Expand = 1,
                                    Visible = 1
                                FROM %1 AS Temp;",
                                _tempTablePhysicalName);
        }
        else
        {
            expandSQL = strFmt(@"UPDATE Temp SET
                                    Expand = IIF(Task.EndNode = 0, 1, 0),
                                    Visible = 1
                                FROM %1 AS Temp
                                INNER JOIN ProjPlanVersion AS Task ON
                                    Task.Partition = %2 AND Temp.RefRecId = Task.RecId;",
                                _tempTablePhysicalName,
                                currentPartition);
        }

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(expandSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandToV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Expand records up to the specified hierarchy level, and collapses records greater than the specified hierarchy level.
    /// </summary>
    /// <param name = "_hierarhcyId">Id of the current hierarchy.</param>
    /// <param name = "_hierarchyLevel">Hierarchy level to be expanded to.</param>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table storing expand/collapse state.</param>
    /// <param name = "_includeEndNodes">Whether end nodes should be expanded as well (making estimates visible).</param>
    public static void expandToV2(
        HierarchyIdBase _hierarchyId,
        ProjHierarchyLevel _hierarchyLevel,
        str _tempTablePhysicalName,
        boolean _includeEndNodes = false)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());

        str expandSQL = strFmt(@"UPDATE Temp SET
                                    Expand = IIF(Task.HierarchyLevel < %2 %4 AND Task.HierarchyId = '%5', 1, 0),
                                    Visible = IIF(Task.HierarchyLevel <= %2, 1, 0)
                                FROM %1 AS Temp
                                INNER JOIN ProjPlanVersion AS Task ON
                                    Task.Partition = %3 AND Task.RecId = Temp.RefRecId;",
                                _tempTablePhysicalName,
                                _hierarchyLevel,
                                currentPartition,
                                _includeEndNodes ? "" : "AND Task.EndNode = 0",
                                _hierarchyId);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(expandSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandTaskV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Expands the given task, optionally showing estimates if this is a leaf task.
    /// </summary>
    /// <param name = "_taskToExpand">ProjPlanVersion record for the task to expand.</param>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table storing expand/collapse state.</param>
    /// <param name = "_allowEndNode">Whether to continue to expand this node if it is a leaf task.</param>
    public static void expandTaskV2(
        ProjPlanVersion _taskToExpand,
        str _tempTablePhysicalName,
        boolean _allowEndNode = false)
    {
        if (!_allowEndNode && _taskToExpand.EndNode)
        {
            return;
        }

        str currentPartition = int642Str(getCurrentPartitionRecId());

        // Construct a query to mark the given task as expanded
        str expandTaskSQL = strFmt(@"UPDATE Temp SET
                                        Expand = 1
                                    FROM %1 AS Temp
                                    WHERE
                                        Temp.RefRecId = %2;",
                                    _tempTablePhysicalName,
                                    _taskToExpand.RecId);

        str makeChildrenVisibleSQL = strFmt(@"UPDATE Temp Set
                                                Visible = 1
                                            FROM %1 AS Temp
                                            INNER JOIN ProjPlanVersion AS Task ON
                                                Task.Partition = %2 AND Task.RecId = Temp.RefRecId
                                            WHERE
                                                Task.ParentHierarchyTaskId = %3;",
                                            _tempTablePhysicalName,
                                            currentPartition,
                                            _taskToExpand.HierarchyTaskId);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(expandTaskSQL + makeChildrenVisibleSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collapseTaskV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collapses the given task.
    /// </summary>
    /// <param name = "_taskToCollapse">The ProjPlanVersion record for the task to collapse.</param>
    /// <param name = "_taskToCollapseSortingRecord">The ProjHierarchySorting record for the task to collapse.</param>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table storing expand/collapse state.</param>
    public static void collapseTaskV2(
        ProjPlanVersion _taskToCollapse,
        ProjHierarchySorting _taskToCollapseSortingRecord,
        str _tempTablePhysicalName)
    {
        // Need to collapse everything that's a child of this, easiest way is to use ProjHierarchySorting
        str currentPartition = int642Str(getCurrentPartitionRecId());

        // Construct a query to collapse and hide anything within the given task's hierarchy (except for the given task)
        str collapseSQL = strFmt(@"UPDATE Temp SET
                                    Expand = 0,
                                    Visible = IIF(Temp.RefRecId = %1, 1, 0)
                                FROM %2 AS Temp
                                INNER JOIN ProjHierarchySorting AS Sort ON
                                    Sort.Partition = %3 AND Sort.RecId = Temp.RefSortRecId",
                                _taskToCollapse.RecId,
                                _tempTablePhysicalName,
                                currentPartition);

        // Build up a predicate for filtering things to within the given hierarchy
        for (int i = 1; i <= _taskToCollapse.HierarchyLevel; ++i)
        {
            int hierarchyLevelValue = _taskToCollapseSortingRecord.getFieldValue(strFmt('HierarchyLevel%1', i));
            collapseSQL += strFmt(' AND Sort.HierarchyLevel%1 = %2', i, hierarchyLevelValue);
        }

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(collapseSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collapseEndNodes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Collapses all leaf tasks.
    /// </summary>
    /// <param name = "_tempTablePhysicalName">Physical name of the temp table.</param>
    public static void collapseEndNodes(
        str _tempTablePhysicalName)
    {
        str currentPartition = int642Str(getCurrentPartitionRecId());

        // Construct a SQL query to make all leaf tasks collapsed
        str collapseSQL = strFmt(@"UPDATE Temp SET
                                        EXPAND = 0
                                   FROM %1 AS Temp
                                   INNER JOIN ProjPlanVersion AS Task ON
                                        Task.Partition = %2 AND Task.RecId = Temp.RefRecId
                                   WHERE
                                        Task.EndNode = 1;",
                                   _tempTablePhysicalName,
                                   currentPartition);

        ProjWorkBreakdownStructureV2FormHelper::executeSQLStatement(collapseSQL);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addEstimateV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new estimate and adds it as a child of the given task.
    /// </summary>
    /// <param name = "_parentTask">ProjPlanVersion record for the task to use as the parent. This may not be a summary task.</param>
    /// <returns>The newly created record.</returns>
    public static PSAActivityEstimates addEstimateV2(
        ProjPlanVersion _parentTask)
    {
        // The given task must not be a summary task
        if (!_parentTask.EndNode)
        {
            throw error(strFmt("@ProjPlan:EstimateAddedToSummaryTaskException", _parentTask.PathId, _parentTask.TaskName));
        }

        ttsbegin;
        // Create an estimate record
        PSAActivityEstimates newEstimate;
        newEstimate.ProjPlanHierarchyId = _parentTask.HierarchyId;
        newEstimate.ProjPlanHierarchyTaskId = _parentTask.HierarchyTaskId;
        newEstimate.ActivityNumber = ProjPlanVersion::getActivityNumber(_parentTask.HierarchyId, _parentTask.HierarchyTaskId);
        newEstimate.insert();
        ttscommit;

        return newEstimate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteEstimatesV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the given estimates.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the current hierarchy.</param>
    /// <param name = "_estimatesToDelete">An enumerator for a sequence of RecIds for estimate records to delete.</param>
    public static void deleteEstimatesV2(
        HierarchyIdBase _hierarchyId,
        ListEnumerator _estimatesToDelete)
    {
        Set tasksToUpdate = new Set(Types::Int64);

        ttsbegin;
        while (_estimatesToDelete.moveNext())
        {
            PSAActivityEstimates estimateRecord = PSAActivityEstimates::find(_estimatesToDelete.current(), true);
            tasksToUpdate.add(estimateRecord.ProjPlanHierarchyTaskId);

            // If the current estimate is an Hour estimate, we have to update scheduling for the parent task
            if (estimateRecord.ProjTransType == QuotationProjTransType::Hour)
            {
                HierarchyIdBase deletingHierarchy = estimateRecord.ProjPlanHierarchyId;
                RefRecId deletingHierarchyTaskId = estimateRecord.ProjPlanHierarchyTaskId;

                estimateRecord.delete();
                ProjEstimate::updateTaskFromEstimatesV2(deletingHierarchy, deletingHierarchyTaskId);
            }
            else
            {
                estimateRecord.delete();
            }
        }

        // Update all of the tasks who's estimates were deleted
        SetEnumerator e = tasksToUpdate.getEnumerator();
        while (e.moveNext())
        {
            ProjEstimate::updateTaskFromEstimatesV2(_hierarchyId, e.current());
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaskV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new task record and adds it as the next sibling of the given task (or a child of the root, if the given task is null).
    /// </summary>
    /// <param name = "_newRecord"><c>ProjPlanVerion</c> buffer.</param>
    /// <param name = "_hierarchyId">HierarchyId of this hierarchy.</param>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_wbsType">Type of WBS.</param>
    /// <param name = "_upperSibling">The task to use as the upper sibling. This may be null, in which case the upper sibling will be the last child of the root.</param>
    /// <param name = "_upperSiblingSortingRecord">The sorting record for the upper sibling task. This may be null, in the case that the upper sibling record is null.</param>
    /// <param name = "_tempTable">Temp table buffer.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling should be enabled.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>The newly created task record.</returns>
    public static ProjPlanVersion addTaskV2(
        ProjPlanVersion _newRecord,
        HierarchyIdBase _hierarchyId,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        ProjPlanVersion _upperSibling,
        ProjHierarchySorting _upperSiblingSortingRecord,
        ProjHierarchyTemp _tempTable,
        boolean _autoScheduling,
        Hours _calendarStandardWorkDayHours)
    {
        ProjWorkBreakdownStructureContract wbsContract = new ProjWorkBreakdownStructureContract();
        wbsContract.parmTargetTask(_newRecord);
        wbsContract.parmHierarchyId(_hierarchyId);
        wbsContract.parmCalendarId(_calendarId);
        wbsContract.parmWbsType(_wbsType);
        wbsContract.parmUpperSiblingTask(_upperSibling);
        wbsContract.parmUpperSiblingHierarchySorting(_upperSiblingSortingRecord);
        wbsContract.parmHierarchyTemp(_tempTable);
        wbsContract.parmAutoScheduling(_autoScheduling);
        wbsContract.parmCalendarStandardWorkDayHours(_calendarStandardWorkDayHours);
        wbsContract.parmUpdateTempTable(true);

        ProjWorkBreakdownStructureHelper wbsHelper = new ProjWorkBreakdownStructureHelper();
        return wbsHelper.addTask(wbsContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaskValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if task can be deleted. Also cancel task resource assignment for the deleting task.
    /// </summary>
    /// <param name = "_task"><c>ProjPlanVersion</c> table buffer for the deleteing task.</param>
    /// <param name = "_wbsType">This WBS type.</param>
    /// <returns>true if task can be deleted; otherwise, false.</returns>
    public static boolean deleteTaskValidation(ProjPlanVersion _task, ProjWBSType _wbsType)
    {
        if (_wbsType != ProjWBSType::Template)
        {
            smmActivities activity = ProjPlanVersion::getActivityBuffer(_task.HierarchyId, _task.HierarchyTaskId);

            if (activity)
            {
                // If the activity is used as a dimension value, this task may not be deleted
                if (activity && !DimensionValidation::canDeleteEntityValue(activity))
                {
                    return checkFailed(strFmt("@SYS134392", _task.TaskName ? _task.TaskName : activity.ActivityNumber));
                }

                if (_task.EndNode == FalseTrue::True)
                {
                    if (_wbsType == ProjWBSType::Project)
                    {
                        // If this task has any resource assigned to it, update ProjPlanVersionAssignment so that the assigned resources assingment will be canceled unpon user publish this WBS.
                        str assignedResourceNames, assignedResourceRecIds;
                        [assignedResourceNames, assignedResourceRecIds] = ProjTask::getAssignedResourcePerActivity(activity.RecId);
                        if (assignedResourceRecIds)
                        {
                            //Add a cancelation record to ProjPlanVersionAssignment table.
                            ProjTask::removeResourcesFromDraftTask(_task.RecId, assignedResourceRecIds);
                        }
                    }
                    else
                    {
                        // Cancel assigned resource assignment from this task.
                        ProjTask::cancelActivityAssignment(activity.RecId);
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTasksV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the given tasks.
    /// </summary>
    /// <param name = "_hiearchyId">Id of the current hierarchy.</param>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_wbsType">The type of the current wbs.</param>
    /// <param name = "_tasksToDelete">An enumerator for a sequence of RecIds for ProjPlanVersion records to delete.</param>
    /// <param name = "_tempTable">The temp table buffer.</param>
    /// <param name = "_nextSelectionGroup">Next unique selection group to place temp table records into.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>The next unique selection group after this operation has completed.</returns>
    public static int deleteTasksV2(
        HierarchyIdBase _hierarchyId,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        ListEnumerator _tasksToDelete,
        ProjHierarchyTemp _tempTable,
        int _nextSelectionGroup,
        Hours _calendarStandardWorkDayHours)
    {
        ProjWorkBreakdownStructureContract wbsContract = new ProjWorkBreakdownStructureContract();
        wbsContract.parmHierarchyId(_hierarchyId);
        wbsContract.parmCalendarId(_calendarId);
        wbsContract.parmWbsType(_wbsType);
        wbsContract.parmTaskToDeleteListEnum(_tasksToDelete);
        wbsContract.parmHierarchyTemp(_tempTable);
        wbsContract.parmCalendarStandardWorkDayHours(_calendarStandardWorkDayHours);
        wbsContract.parmUpdateTempTable(true);

        ProjWorkBreakdownStructureHelper wbsHelper = new ProjWorkBreakdownStructureHelper();
        wbsHelper.deleteTasks(wbsContract);

        return _nextSelectionGroup + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>outdentTasksV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Outdents the given task records, and all of their sub-tasks and estimates.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the current hierarchy.</param>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_wbsType">The type of the current wbs.</param>
    /// <param name = "_tempTable">Temp table buffer.</param>
    /// <param name = "_selectedTaskRecIds">An enumerator for a sequence of RecIds for ProjPlanVersion records to outdent.</param>
    /// <param name = "_nextSelectionGroup">Next unique selection group to place temp table records into.</param>
    /// <param name = "_currentHierarchyMaxLevel">Current max depth of the hierarchy.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>The next unique selection group after this operation has completed.</returns>
    public static int outdentTasksV2(
        HierarchyIdBase _hierarchyId,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        ProjHierarchyTemp _tempTable,
        ListEnumerator _selectedTaskRecIds,
        int _nextSelectionGroup,
        int _currentHierarchyMaxLevel,
        Hours _calendarStandardWorkDayHours)
    {
        ProjWorkBreakdownStructureContract wbsContract = new ProjWorkBreakdownStructureContract();
        wbsContract.parmHierarchyId(_hierarchyId);
        wbsContract.parmCalendarId(_calendarId);
        wbsContract.parmWbsType(_wbsType);
        wbsContract.parmUpdateTempTable(true);
        wbsContract.parmHierarchyTemp(_tempTable);
        wbsContract.parmTaskToOutdentListEnum(_selectedTaskRecIds);
        wbsContract.parmNextSelectionGroup(_nextSelectionGroup);
        wbsContract.parmCurrentHierarchyMaxLevel(_currentHierarchyMaxLevel);
        wbsContract.parmCalendarStandardWorkDayHours(_calendarStandardWorkDayHours);
        
        ProjWorkBreakdownStructureHelper wbsHelper = new ProjWorkBreakdownStructureHelper();
        return wbsHelper.outdentTasks(wbsContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>indentTasksV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indents the given task records, and all of their sub-tasks and estimates.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the current hierarchy.</param>
    /// <param name = "_calendarId">Id of the calendar for the project.</param>
    /// <param name = "_wbsType">The type of the wbs.</param>
    /// <param name = "_tempTable">Temp table buffer.</param>
    /// <param name = "_selectedTaskRecIds">An enumerator for a sequence of RecIds for ProjPlanVersion records to indent.</param>
    /// <param name = "_nextSelectionGroup">Next unique selection group to place temp table records into.</param>
    /// <param name = "_currentHierarchyMaxLevel">Current max depth of the hierarchy.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>The next unique selection group after this operation has completed.</returns>
    public static int indentTasksV2(
        HierarchyIdBase _hierarchyId,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        ProjHierarchyTemp _tempTable,
        ListEnumerator _selectedTaskRecIds,
        int _nextSelectionGroup,
        int _currentHierarchyMaxLevel,
        Hours _calendarStandardWorkDayHours)
    {
        ProjWorkBreakdownStructureContract wbsContract = new ProjWorkBreakdownStructureContract();
        wbsContract.parmHierarchyId(_hierarchyId);
        wbsContract.parmCalendarId(_calendarId);
        wbsContract.parmWbsType(_wbsType);
        wbsContract.parmUpdateTempTable(true);
        wbsContract.parmHierarchyTemp(_tempTable);
        wbsContract.parmTaskToIndentListEnum(_selectedTaskRecIds);
        wbsContract.parmNextSelectionGroup(_nextSelectionGroup);
        wbsContract.parmCurrentHierarchyMaxLevel(_currentHierarchyMaxLevel);
        wbsContract.parmCalendarStandardWorkDayHours(_calendarStandardWorkDayHours);
        
        ProjWorkBreakdownStructureHelper wbsHelper = new ProjWorkBreakdownStructureHelper();
        return wbsHelper.indentTasks(wbsContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>swapTasksV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Swaps the position of a task (and all sub-tasks and estimates) with the sibling at the given offset.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the current hierarchy.</param>
    /// <param name = "_hierarchyTaskId">TaskId of the first task to swap.</param>
    /// <param name = "_delta">Relative position of the sibling to swap with.</param>
    /// <param name = "_tempTablePhysicalName">This parameter is no longer being used.</param>
    public static void swapTasksV2(
        HierarchyIdBase _hierarchyId,
        ProjHierarchyTaskId _hierarchyTaskId,
        int _delta,
        str _tempTablePhysicalName)
    {
        ProjPlanVersion taskToMove = ProjPlanVersion::findByHierarchyAndTaskId(_hierarchyId, _hierarchyTaskId, true);
        ProjWBSType wbsType = ProjPlanVersionDetail::findByHierarchyId(_hierarchyId).getWBSType();

        ProjWorkBreakdownStructureContract wbsContract = new ProjWorkBreakdownStructureContract();
        wbsContract.parmTargetTask(taskToMove);
        wbsContract.parmMoveTaskDeltaPosition(_delta);
        wbsContract.parmWbsType(wbsType);

        ProjWorkBreakdownStructureHelper wbsHelper = new ProjWorkBreakdownStructureHelper();
        wbsHelper.swapTasks(wbsContract);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPredecessorListStr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Formats the list of predecessors for the given sucessor as a string.
    /// </summary>
    /// <param name = "_hierarchyId">The ID of the hierarchy the predecessor belongs to.</param>
    /// <param name = "_successorId">The ID of the task for which to get predecessors.</param>
    /// <returns>A string containing the list of predecessors.</returns>
    public static str getPredecessorListStr(
        HierarchyIdBase _hierarchyId,
        ProjHierarchyTaskId _successorId)
    {
        str result = '';

        ProjDependency edge;
        ProjPlanVersion predecessor;
        while select predecessor
            where predecessor.HierarchyId == _hierarchyId
        exists join edge
            where edge.ProjPlanHierarchyId == _hierarchyId
            && edge.SuccessorHierarchyTaskId == _successorId
            && edge.PredecessorHierarchyTaskId == predecessor.HierarchyTaskId
        {
            result += predecessor.PathId + ', ';
        }

        return subStr(result, 0, max(strLen(result) - 2, 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalPrices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes total prices (TotalCostPrice/TotalSalesPrice) for tasks, based on either the sum of their estimates or the sum of their children's total prices.
    /// </summary>
    /// <param name = "_task">The task to compute/retreive the TotalCostPrice and TotalSalesPrice for.</param>
    /// <param name = "_cache">Cache to store result in, to reduce cost of subsequent lookups.</param>
    /// <returns>A container of [totalCostPrice: NonNegativeTotal, totalSalesPrice: NonNegativeTotal].</returns>
    public static container getTotalPrices(
        ProjPlanVersion _task,
        Map _cache)
    {
        // If the value already exists in the cache, return that
        if (_cache.exists(_task.RecId))
        {
            return _cache.lookup(_task.RecId);
        }

        if (_task.EndNode == FalseTrue::True)
        {
            // Compute sum of estimates
            PSAActivityEstimates estimates;
            select sum(TotalCostPrice), sum(TotalSalesPrice) from estimates
            where
                estimates.ProjPlanHierarchyId == _task.HierarchyId
                && estimates.ProjPlanHierarchyTaskId == _task.HierarchyTaskId;

            // Insert into cache
            container totals = [estimates.TotalCostPrice, estimates.TotalSalesPrice];
            _cache.insert(_task.RecId, totals);
            return totals;
        }
        else
        {
            NonNegativeTotal totalCostPrice = 0;
            NonNegativeTotal totalSalesPrice = 0;

            // Compute sum of children
            ProjPlanVersion child;
            while select RecId, HierarchyId, HierarchyTaskId, EndNode from child
            where
                child.HierarchyId == _task.HierarchyId
                && child.ParentHierarchyTaskId == _task.HierarchyTaskId
            {
                container childTotals = ProjWorkBreakdownStructureV2FormHelper::getTotalPrices(child, _cache);
                totalCostPrice += conPeek(childTotals, 1);
                totalSalesPrice += conPeek(childTotals, 2);
            }

            // Insert into cache
            container totals = [totalCostPrice, totalSalesPrice];
            _cache.insert(_task.RecId, totals);
            return totals;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taskHasResourcesAssigned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the given task has resources assigned to it.
    /// </summary>
    /// <param name = "_task">The task to check for assigned resources.</param>
    /// <returns>true if the task has assigned resources; otherwise, false.</returns>
    /// <remarks>This method should only be used for task in draft.</remarks>
    public static boolean taskHasResourcesAssigned(
        ProjPlanVersion _task)
    {
        boolean hasAssignment = false;

        if (_task)
        {
            Container resourceNamesCon;
            Container activityResourcesCon;
            const boolean isPublished = false;
            [resourceNamesCon, activityResourcesCon] = ProjWorkBreakdownStructureV2FormHelper::getAssignedResourcesListPerTask(_task, isPublished);
            
            hasAssignment = conLen(activityResourcesCon) != 0;
        }

        return hasAssignment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignedResourcesListPerTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get assigned resource names container and assigned activity resources container per the specified <c>ProjPlanVersion</c> record.
    /// </summary>
    /// <param name = "_planVersion"><c>ProjPlanVersion</c> table record of the specified task.</param>
    /// <param name = "_isPublished">Whether if this WBS is in published state.</param>
    /// <returns>
    /// A container which contains two containers.
    /// The first container contains the assigned resource names container.
    /// The second container contains the assigned activity resources record ID.
    /// </returns>
    public static container getAssignedResourcesListPerTask(
        ProjPlanVersion _planVersion,
        boolean _isPublished)
    {
        Container resourceNamesCon;
        Container activityResourcesCon;

        if (_planVersion.EndNode == FalseTrue::True)
        {
            PSAProjSchedRole teamMember;
            ResAssignment publishedAssignment;
            ActivityRecId activity = ProjPlanVersion::getActivityRecId(_planVersion.HierarchyId, _planVersion.HierarchyTaskId);
            
            if (!_isPublished && ProjPlanVersionAssignment::hasProjPlanVersion(_planVersion.RecId))
            {
                ProjPlanVersionAssignment draftAssignment;

                while select Name, RecId from teamMember
                    group by teamMember.Name, teamMember.RecId
                        exists join draftAssignment
                            where draftAssignment.ProjPlanVersion == _planVersion.RecId
                                && draftAssignment.ReservationType == ProjPlanVersionAssignmentType::Reserve
                                && draftAssignment.ActivityResource == teamMember.RecId

                {
                    resourceNamesCon += teamMember.Name;
                    activityResourcesCon += teamMember.RecId;
                }

                if (activity)
                {
                    // Only add the resource name from assignment table if has no generic or specific activity resource cancellation record in the ProjPlanVersionAssignment table for the referenced activity.
                    while select Name, RecId from teamMember
                        group by teamMember.Name, teamMember.RecId
                            exists join publishedAssignment
                                where publishedAssignment.Activity == activity
                                    && publishedAssignment.ActivityResource == teamMember.RecId
                            notexists join draftAssignment
                                where draftAssignment.ProjPlanVersion == _planVersion.RecId
                                    && draftAssignment.ReservationType == ProjPlanVersionAssignmentType::Cancel
                                    && (draftAssignment.ActivityResource == 0
                                        || draftAssignment.ActivityResource == publishedAssignment.ActivityResource)
                    {
                        resourceNamesCon += teamMember.Name;
                        activityResourcesCon += teamMember.RecId;
                    }
                }
            }
            else if (activity)
            {
                while select Name from teamMember
                    group by teamMember.Name, teamMember.RecId
                        exists join publishedAssignment
                            where publishedAssignment.Activity == activity
                                && publishedAssignment.ActivityResource == teamMember.RecId
                {
                    resourceNamesCon += teamMember.Name;
                    activityResourcesCon += teamMember.RecId;
                }
            }
        }

        return [resourceNamesCon, activityResourcesCon];
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeSQLStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the given string SQL statement.
    /// </summary>
    /// <param name = "_statement">SQL statement to execute.</param>
    private static void executeSQLStatement(
        str _statement,
        Map _paramMap = null)
    {
        ttsbegin;
        Connection userConnection = new Connection();
        Statement stmt = userConnection.createStatement();
        new SqlStatementExecutePermission(_statement).assert();
        stmt.executeUpdateWithParameters(_statement, _paramMap);
        CodeAccessPermission::revertAssert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateResourceAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update resource assignment to the task with user specified resources.
    /// </summary>
    /// <param name = "_planVersion">
    /// The specified <c>ProjPlanVersion</c> table task record.
    /// </param>
    /// <param name = "_assignedResourceRecIds">
    /// A container of Int64 values of the task assigned activity resource record IDs.
    /// </param>
    /// <param name = "_assignedResourceOriginalRecIds">
    /// A container of Int64 values of the task original assigned activity resource record IDs.
    /// </param>
    public static void updateResourceAssignment(
        ProjPlanVersion _planVersion,
        container _assignedResourceRecIdsCon,
        container _assignedResourceOriginalRecIdsCon)
    {
        // Takes action if the assigned activity resources list is different than the original assigned activity resources list.
        if (_assignedResourceRecIdsCon != _assignedResourceOriginalRecIdsCon)
        {
            str assignedResourceRecIds = con2Str(_assignedResourceRecIdsCon);
            str assignedResourceOriginalRecIds = con2Str(_assignedResourceOriginalRecIdsCon);
            ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findByHierarchyId(_planVersion.HierarchyId);
            boolean isProject = planVersionDetail.ProjId ? true : false;
            boolean activityIsDraft = isProject && (planVersionDetail.VersionType == ProjPlanVersionType::Draft);
            
            if (activityIsDraft)
            {
                //Add a cancelation record to ProjPlanVersionAssignment if the original assigned activity resource is assigned to ResAssignment table.
                ProjTask::removeResourcesFromDraftTask(_planVersion.RecId, assignedResourceOriginalRecIds);

                //Add reservation records to ProjPlanVersionAssignment for the selected activity resources.
                ProjTask::assignResourcesToDraftTask(_planVersion.RecId, assignedResourceRecIds);
            }
            else if (_planVersion.HierarchyTreeTableRefRecId)
            {
                // Activity will exists if this task has been published.
                ActivityRecId activity = ProjPlanVersion::getActivityRecId(_planVersion.HierarchyId, _planVersion.HierarchyTaskId);

                //Assign resources to the published activity.
                SchedFromDate startDate = _planVersion.TaskStartDate;
                SchedToDate endDate = _planVersion.TaskFinishDate;
                Hours effort = _planVersion.TaskEffort;

                Map assignResourceRecordMap = new Map(Types::Int64, Types::Record);
                ProjWorkBreakdownStructureV2FormHelper::setupAssignResourceRecordMapForQuotation(planVersionDetail.getWBSType(), assignResourceRecordMap, assignedResourceRecIds);

                if (assignedResourceOriginalRecIds != '')
                {
                    // Remove all resource reservation in this activity. For the case of quotation, it will remove the quotation team member
                    // from PSAProjSchedRole table if it has no reservation in other task of this quotation.
                    ProjTask::cancelActivityAssignment(activity);
                }

                if (assignedResourceRecIds != '')
                {
                    assignedResourceRecIds = ProjWorkBreakdownStructureV2FormHelper::updateAssignResourceRecIdsForQuotation(planVersionDetail.getWBSType(), assignResourceRecordMap, assignedResourceRecIds);
                    ProjTask::reserveResourceActivity(activity, assignedResourceRecIds, startDate, endDate, effort);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupAssignResourceRecordMapForQuotation</Name>
				<Source><![CDATA[
    /// <summary>
    /// For the case of quotation, canceling all reservation in this activity may remove the quotation team member if this team member does not
    /// have reservation in other task in this quotation. The removed quotation may need to be recreated for resource assignment. This method stores the
    /// quotation team member record ID and the record in a map in case the quotation team member data is needed to be recovered.
    /// </summary>
    /// <param name = "_wbsType">WBS Type.</param>
    /// <param name = "_assignResourceRecordMap">Assigned resource record map to store <c>PSAProjSchedRole</c> table record ID as the key and <c>PSAProjSchedRole</c> table buffer.</param>
    /// <param name = "_assignedResourceRecIds">Assigned resource <c>PSAProjSchedRole</c> record IDs as a string which splict by ','</param>
    public static void setupAssignResourceRecordMapForQuotation(ProjWBSType _wbsType, Map _assignResourceRecordMap, str _assignedResourceRecIds)
    {
        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            List assignedResourcesList = Global::strSplit(_assignedResourceRecIds, ',');
            ListEnumerator assignedResourcesListEnum = assignedResourcesList.getEnumerator();

            while (assignedResourcesListEnum.moveNext())
            {
                RefRecId teamRecordRecId = str2Int64(assignedResourcesListEnum.current());
                if (teamRecordRecId)
                {
                    PSAProjSchedRole teamRecord = PSAProjSchedRole::findByRecId(teamRecordRecId);
                    _assignResourceRecordMap.insert(teamRecordRecId, teamRecord);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssignResourceRecIdsForQuotation</Name>
				<Source><![CDATA[
    /// <summary>
    /// For the case of quotation, the assigned resource may no longer exists due to canceling all reservation for this quotation would have removed it
    /// from the quotation team. This method recreate the quotation team member record which was stored in the the map parameter. Then replace
    /// the assigned resource record IDs parameter.
    /// </summary>
    /// <param name = "_wbsType">WBS Type.</param>
    /// <param name = "_assignResourceRecordMap">Assigned resource record map to store <c>PSAProjSchedRole</c> table record ID as the key and <c>PSAProjSchedRole</c> table buffer.</param>
    /// <param name = "_assignedResourceRecIds">Assigned resource <c>PSAProjSchedRole</c> record IDs as a string which split by ','</param>
    /// <returns>The updated assigned resource record IDs which split by ','.</returns>
    public static str updateAssignResourceRecIdsForQuotation(ProjWBSType _wbsType, Map _assignResourceRecordMap, str _assignedResourceRecIds)
    {
        str assignedResourceRecIds = _assignedResourceRecIds;

        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            List assignedResourcesList = Global::strSplit(assignedResourceRecIds, ',');
            ListEnumerator assignedResourcesListEnum = assignedResourcesList.getEnumerator();

            while (assignedResourcesListEnum.moveNext())
            {
                RefRecId teamRecordRecId = str2Int64(assignedResourcesListEnum.current());
                if (teamRecordRecId && !PSAProjSchedRole::findByRecId(teamRecordRecId))
                {
                    ttsbegin;
                    PSAProjSchedRole teamMember;
                    teamMember.data(_assignResourceRecordMap.lookup(teamRecordRecId));
                    teamMember.insert();
                    ttscommit;

                    assignedResourceRecIds = strReplace(assignedResourceRecIds, assignedResourcesListEnum.current(), int642Str(teamMember.RecId));
                }
            }
        }

        return assignedResourceRecIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoAssignResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Auto assign resoruce to the task in attempt to fully assigned the specific task with best matching resources.
    /// </summary>
    /// <param name = "_projPlanVersionHierarchyId">
    /// ProjPlanVersion hierarchy Id.
    /// </param>
    /// <param name = "_taskId">
    /// ProjPlanVersion task id.
    /// </param>
    public static void autoAssignResource(
        HierarchyIdBase _projPlanVersionHierarchyId,
        ProjHierarchyTaskId _taskId)
    {
        boolean sucessfullyPropose = false;
        str     proposeMessage;

        // Get published hierarchy ID.
        HierarchyIdBase currentPublishedHierarchyId = ProjPlanVersionDetail::findLatestByHierarchyId(_projPlanVersionHierarchyId, false, false, ProjPlanVersionType::PublishedCurrent).HierarchyId;
        
        if (currentPublishedHierarchyId == _projPlanVersionHierarchyId)
        {
            //Auto assign resources to the activity
            boolean isProject = ProjPlanVersionDetail::isProjectHierarchy(_projPlanVersionHierarchyId);
            ActivityRecId activity = ProjPlanVersion::getActivityRecId(_projPlanVersionHierarchyId, _taskId);
            ResCommitType commitType = isProject ? ResCommitType::HardBook : ResCommitType::SoftBook;
            real remainingSeconds = ActivityFacade::getRemainingCapacityInSeconds(activity, commitType);
            
            // Only auto assign this task if remining seconds is larger than 59 seconds
            if (remainingSeconds > 59)
            {
                ResWBSAutoAssignResource autoAssign = ResWBSAutoAssignResource::construct(activity);
                
                [sucessfullyPropose, proposeMessage] = autoAssign.autoAssignResources();
            }
            else
            {
                sucessfullyPropose = false;
                proposeMessage = "@Res:TaskIsFullyAssigned";
            }
        }
        else
        {
            sucessfullyPropose = false;
            proposeMessage = "@Res:ActivityIsNotPublished";
        }

        if (!sucessfullyPropose)
        {
            error(proposeMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>launchWBSResourceAssignmentForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Launches the WBS resource assignment form for the specified task.
    /// </summary>
    /// <param name = "_planVersion">
    /// The specified <c>ProjPlanVersion</c> table task record.
    /// </param>
    public static void launchWBSResourceAssignmentForm(
        ProjPlanVersion _planVersion)
    {
        // Get published hierarchy ID.
        HierarchyIdBase currentPublishedHierarchyId = ProjPlanVersionDetail::findLatestByHierarchyId(_planVersion.HierarchyId, false, false, ProjPlanVersionType::PublishedCurrent).HierarchyId;
        
        // Only launches the form if this WBS has been published.
        if (currentPublishedHierarchyId == _planVersion.HierarchyId)
        {
            ActivityRecId activity = ProjPlanVersion::getActivityRecId(_planVersion.HierarchyId, _planVersion.HierarchyTaskId);
            TransDate startDate = _planVersion.TaskStartDate;
            TransDate endDate = _planVersion.TaskFinishDate;

            utcdatetime startDateTime = DateTimeUtil::newDateTime(startDate, 0);
            utcdatetime endDateTime = DatetimeUtil::newDateTime(endDate, #secondsPerDay - 1);

            if (ResUtil::validateRollupCalendarTimeFrameRange(startDateTime, endDateTime, false))
            {
                ResAvailabilityViewContext context = ResAvailabilityViewContext::construct();
                context.activity(activity);
                context.timescale(ResUtil::getRecommendedTimeframeType(startDateTime, endDateTime));
                context.startDateTime(startDateTime);
                context.endDateTime(endDateTime);

                PSARSEntityType entityType;
                ProjPlanVersionDetail planVersionDetail = ProjPlanVersionDetail::findByHierarchyId(_planVersion.HierarchyId);
                if (planVersionDetail.ProjId)
                {
                    entityType = PSARSEntityType::Project;
                    ProjTable project = ProjTable::find(planVersionDetail.ProjId);
                    context.description(strFmt("@Res:TitleWithIdAndName", project.ProjId, project.Name ));
                }
                else if (ProjPlanVersionDetail::isQuotationHierarchy(_planVersion.HierarchyId))
                {
                    entityType = PSARSEntityType::Quotation;
                    SalesQuotationTable quotationTable = ProjTask::getQuotationTableByHierarchyId(_planVersion.HierarchyId);
                    context.description(strFmt("@Res:TitleWithIdAndName", quotationTable.QuotationId, quotationTable.QuotationName ));
                }

                ResourceCategoryRecId resourceCategory = _planVersion.ResourceCategory;
                ResourceCategoryRecId defaultCategory = ResourceCategoryFacade::defaultResourceCategory();
                if (resourceCategory != defaultCategory)
                {
                    ResourceCategoryId resourceCategoryId = ResourceCategoryFacade::getId(resourceCategory);
                    ResResourceCategorySearchCriteria searchCriteriaItem = ResResourceCategorySearchCriteria::construct();
                    searchCriteriaItem.addValue(resourceCategoryId);

                    ResSearchCriteria searchCriteria = ResSearchCriteria::construct();
                    searchCriteria.setCriteriaItem(searchCriteriaItem);
                    context.searchString(searchCriteria.getCriteriaString());
                }

                context.activityType(entityType);

                Args args = new Args();
                args.parmObject(context);
                args.menuitemname(menuItemDisplayStr(ResWBSResourceAssignment));
                args.name(formStr(ResWBSResourceAssignment));
                FormRun formRun = ClassFactory.formRunClass(args);
                formRun.init();
                formRun.run();
                formRun.wait();
            }
        }
        else
        {
            error("@Res:ActivityIsNotPublished");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>proposePlannedResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Propose planned resources for the published hierarchy.
    /// </summary>
    /// <param name = "_projPlanVersionHierarchyId">
    /// ProjPlanVersion hierarchy Id.
    /// </param>
    /// <param name = "_suppressPopup">
    /// Suppress popup message to request if user will proceed the operation. If suppress, it will proceeed.
    /// </param>
    public static void proposePlannedResource(
        HierarchyIdBase _projPlanVersionHierarchyId,
        boolean _suppressPopup = false)
    {
        boolean sucessfullyPropose = true;
        str     proposeMessage;

        // Get published hierarchy ID
        HierarchyIdBase originalPublishedHierarchyId = ProjPlanVersionDetail::getOldDataModelPublishedHierarchyId(_projPlanVersionHierarchyId);
        HierarchyIdBase currentPublishedHierarchyId = ProjPlanVersionDetail::findLatestByHierarchyId(_projPlanVersionHierarchyId, false, false, ProjPlanVersionType::PublishedCurrent).HierarchyId;
        ResWBSActivityTeam activityTeam;
        
        if (currentPublishedHierarchyId == _projPlanVersionHierarchyId)
        {
            PSARSEntityType entityType = PSARSEntityType::None;
            if (ProjPlanVersionDetail::isProjectHierarchy(_projPlanVersionHierarchyId))
            {
                entityType = PSARSEntityType::Project;
            }
            else if (ProjPlanVersionDetail::isQuotationHierarchy(_projPlanVersionHierarchyId))
            {
                entityType = PSARSEntityType::Quotation;
            }

            if (entityType != PSARSEntityType::None)
            {
                // Get propose planned resources message.
                activityTeam = ResWBSActivityTeam::construct(originalPublishedHierarchyId, entityType);
                [sucessfullyPropose, proposeMessage] = activityTeam.proposePlannedResource();
            }
        }
        else
        {
            sucessfullyPropose = false;
            proposeMessage = "@Res:ActivityIsNotPublished";
        }

        if (!sucessfullyPropose)
        {
            error(proposeMessage);
        }
        else if (sucessfullyPropose && activityTeam)
        {
            // Ask if user will accept this proposal if pop up messete is not suppress.
            if (_suppressPopup || Box::yesNo(proposeMessage, DialogButton::No, "@ProjPlan:AutoGenerateTeam") == DialogButton::Yes)
            {
                boolean sucessfullyReserve = true;
                str     reserveErrorMessage;
                // reserve the planned resources.
                [sucessfullyReserve, reserveErrorMessage] = activityTeam.reservePlannedResource();

                if (!sucessfullyReserve)
                {
                    error(reserveErrorMessage);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendarStandardWorkDayHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get calendar standard work day hours by calendar ID. If the calendar standard work day hours is not set, then it will return 8 by default.
    /// </summary>
    /// <param name = "_calendarId">
    /// The ID of the calendar to use.
    /// </param>
    /// <returns>
    /// The calendar standard work day hours.
    /// </returns>
    public static Hours getCalendarStandardWorkDayHours(
        CalendarId _calendarId)
    {
        WorkCalendarTable workCalendarTable;
        Hours             defaultCalendarStandardWorkDayHours = 8;

        if (_calendarId)
        {
            select firstonly StandardWorkDayHours from workCalendarTable
                where workCalendarTable.CalendarId == _calendarId;
        }

        return workCalendarTable.StandardWorkDayHours ? workCalendarTable.StandardWorkDayHours : defaultCalendarStandardWorkDayHours;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyAndFixWorkBreakdownStructureSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify and fix the specified work breakdown structure effort hours if any task effort hours is not valid.
    /// </summary>
    /// <param name = "_task">The specified task to be verified and fixed.</param>
    /// <param name = "_projHierarchyTemp">The temp table buffer <c>_projHierarchyTemp</c> which is used as a datasource for the <c>WorkBreakdownStructureV2</c> form.</param>
    /// <param name = "_calendarId">The ID of the calendar for this work breakdown structure.</param>
    /// <param name = "_wbsType">Whether the WBS type is project or quotation.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling should be enabled.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>true if the specified work breakdown structure effort hours are fixed; otherwise, false.</returns>
    public static boolean verifyAndFixWorkBreakdownStructureSchedule(
        ProjPlanVersion _task,
         ProjHierarchyTemp _projHierarchyTemp,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        boolean _autoScheduling,
        Hours _calendarStandardWorkDayHours)
    {
        boolean fixed = false;
        ProjPlanVersion scheduledTasks;

        ttsbegin;
        while select forupdate scheduledTasks
            where scheduledTasks.HierarchyId == _task.HierarchyId
                && scheduledTasks.EndNode == falseTrue::True
        {
            fixed = true;
            if (!ProjPlanVersion::validateTaskDurationDays(scheduledTasks, _calendarStandardWorkDayHours))
            {
                scheduledTasks.TaskEffort = ProjPlanVersion::calcTaskEffortHours(scheduledTasks, _calendarId, _calendarStandardWorkDayHours);
                scheduledTasks.TaskEffortAtComplete = scheduledTasks.TaskEffort;
                scheduledTasks.TaskEffortToComplete = scheduledTasks.TaskEffort;
                scheduledTasks.update();

                if (ProjPlanVersion::postUserChangeEffortV2(_calendarId, scheduledTasks, _autoScheduling, _calendarStandardWorkDayHours))
                {
                    ProjEstimate::syncEstimateLinesFromTask(_task.HierarchyId, scheduledTasks.HierarchyTaskId, _wbsType);
                }
            }
        }
        ttscommit;

        return fixed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyAndFixTaskSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify and fix the specified task effort hours if it is not valid.
    /// </summary>
    /// <param name = "_task">The specified task to be verified and fixed.</param>
    /// <param name = "_projHierarchyTemp">The temp table buffer <c>_projHierarchyTemp</c> which is used as a datasource for the <c>WorkBreakdownStructureV2</c> form.</param>
    /// <param name = "_calendarId">The ID of the calendar for this work breakdown structure.</param>
    /// <param name = "_wbsType">Whether the WBS type is project or quotation.</param>
    /// <param name = "_autoScheduling">Whether auto scheduling should be enabled.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <returns>true if the specified task effort is fixed; false, otherwise.</returns>
    public static boolean verifyAndFixTaskSchedule(
        ProjPlanVersion _task,
        ProjHierarchyTemp _projHierarchyTemp,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        boolean _autoScheduling,
        Hours _calendarStandardWorkDayHours)
    {
        boolean fixed = false;
        ProjPlanVersion scheduledTasks;

        select firstonly forupdate scheduledTasks
                where scheduledTasks.HierarchyId == _task.HierarchyId
                    && scheduledTasks.HierarchyTaskId == _task.HierarchyTaskId
                    && scheduledTasks.EndNode == falseTrue::True;

        if (scheduledTasks && !ProjPlanVersion::validateTaskDurationDays(scheduledTasks, _calendarStandardWorkDayHours))
        {
            ttsbegin;
            fixed = true;
            scheduledTasks.TaskEffort = ProjPlanVersion::calcTaskEffortHours(scheduledTasks, _calendarId, _calendarStandardWorkDayHours);
            scheduledTasks.TaskEffortAtComplete = scheduledTasks.TaskEffort;
            scheduledTasks.TaskEffortToComplete = scheduledTasks.TaskEffort;
            scheduledTasks.update();

            if (ProjPlanVersion::postUserChangeEffortV2(_calendarId, scheduledTasks, _autoScheduling, _calendarStandardWorkDayHours))
            {
                ProjEstimate::syncEstimateLinesFromTask(_task.HierarchyId, scheduledTasks.HierarchyTaskId, _wbsType);
            }
            ttscommit;
        }

        return fixed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjHierarchySortingRecord</Name>
				<Source><![CDATA[
    public static ProjHierarchySorting findProjHierarchySortingRecord(
        HierarchyIdBase _hierarchyId,
        ProjHierarchyTaskId _taskId,
        boolean _forUpdate = false)
    {
        return ProjHierarchySorting::findByReferenceV2(ProjHierarchySortingType::ProjWBS, _hierarchyId, _taskId, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCorrespondingTaskElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the element number of a task in a project hierarchy (WBS).
    /// </summary>
    /// <param name = "_hierarchyId">A hierarchy ID.</param>
    /// <param name = "_taskId">A task ID.</param>
    /// <returns>The element number of the task in the hierarchy.</returns>
    public static ElementNumber getCorrespondingTaskElementNumber(
        HierarchyIdBase _hierarchyId,
        ProjHierarchyTaskId _taskId)
    {
        ProjPlanVersion projPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;

        select firstonly ElementNumber from hierarchyTreeTable
            exists join projPlanVersion
                where hierarchyTreeTable.RecId == projPlanVersion.HierarchyTreeTableRefRecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _taskId;

        return hierarchyTreeTable.ElementNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCorrespondingTaskRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update <c>PSAActivitySetup</c> table values and <c> smmActivities</c> table values
    /// from <c>ProjPlanvVersion</c> if WBS type is quotation.
    /// </summary>
    /// <param name = "_task"><c>ProjPlanVersion</c> task buffer.</param>
    /// <param name = "_wbsType">Project WBS type.</param>
    public static void updateCorrespondingTaskRecord(
        ProjPlanVersion _task,
        ProjWBSType _wbsType)
    {
        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            HierarchyTreeTable  hierarchyTreeTable;
            ProjPlanVersion     projPlanVersion;
            smmActivities       smmActivities;
            PSAActivitySetup    activitySetup;

            select forupdate activitySetup
                join smmActivities
                    where smmActivities.ActivityNumber == activitySetup.ActivityNumber
                join hierarchyTreeTable
                    where hierarchyTreeTable.RefRecId == smmActivities.RecId
                exists join projPlanVersion
                    where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                        && projPlanVersion.HierarchyId == _task.HierarchyId
                        && projPlanVersion.HierarchyTaskId == _task.HierarchyTaskId;

            if (activitySetup)
            {
                ttsbegin;
                activitySetup.initFromProjPlanVersion(_task);
                activitySetup.update();

                ProjWorkBreakdownStructureV2FormHelper::initsmmActivitiesField(smmActivities, _task);
                smmActivities.update();

                hierarchyTreeTable.reread();
                ProjWorkBreakdownStructureV2FormHelper::initHierarchyTreeTable(hierarchyTreeTable, _task);
                hierarchyTreeTable.update();
                ttscommit;
            }
            
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initsmmActivitiesField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes fields for the specified <c>smmActivities</c> record with values from the specified project WBS task version record.
    /// </summary>
    /// <param name="_smmActivities">
    /// The target <c>smmActivities</c> record to be initialized.
    /// </param>
    /// <param name="_projPlanVersion">
    /// The project WBS task record.
    /// </param>
    public static void initsmmActivitiesField(smmActivities _smmActivities, ProjPlanVersion _projPlanVersion)
    {
        _smmActivities.selectForUpdate(true);
        _smmActivities.Purpose              = _projPlanVersion.TaskName;
        _smmActivities.StartDateTime        = DateTimeUtil::newDateTime(_projPlanVersion.TaskStartDate, 0, DateTimeUtil::getUserPreferredTimeZone());
        _smmActivities.EndDateTime          = DateTimeUtil::newDateTime(_projPlanVersion.TaskFinishDate, timeMax(), DateTimeUtil::getUserPreferredTimeZone());
        _smmActivities.UserMemo             = _projPlanVersion.UserMemo;
        _smmActivities.TaskPriority         = _projPlanVersion.TaskPriority;
        _smmActivities.ActivityTaskTimeType = _projPlanVersion.ActivityTaskTimeType;
        _smmActivities.PSAMandatory         = _projPlanVersion.IsCategoryMandatory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initHierarchyTreeTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes fields for the specified <c>HierarchyTreeTable</c> record with values from the specified project WBS task version record.
    /// </summary>
    /// <param name = "_hierarchyTreeTable">
    /// The target <c>HierarchyTreeTable</c> record to be initialized.
    /// </param>
    /// <param name = "_projPlanVersion">
    /// The project WBS task record.
    /// </param>
    public static void initHierarchyTreeTable(HierarchyTreeTable _hierarchyTreeTable, ProjPlanVersion _projPlanVersion)
    {
        _hierarchyTreeTable.selectForUpdate(true);
        _hierarchyTreeTable.Name          = _projPlanVersion.TaskName;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>