<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPrepaymentHandling_W</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendPrepaymentHandling_W</c> class is responsible for handling prepyaments for customers and vendors.
/// </summary>
abstract class CustVendPrepaymentHandling_W
{
    #ISOCountryRegionCodes
    
    protected const str journalNum = 'Prepayment';

    CustVendTrans               custVendTrans;
    CustVendTrans               newCustVendTrans;
    CustVendTrans               custVendTransOriginal;
    AmountCur                   prepaymentAmount;
    AmountMST                   prepaymentAmountMST;
    TransDate                   transDate;
    ExchRate                    exchRate;
    ExchRate                    exchRateSecond;
    MapEnumerator               mapReversedAmountsEnumerator;
    LedgerJournalTrans          ledgerJournalTrans;
    LedgerJournalTable          ledgerJournalTable;
    LedgerJournalEngine         ledgerJournalEngine;
    LedgerVoucher               ledgerVoucher;
    LedgerVoucherGroup          ledgerVoucherGroup;
    LedgerVoucherObject         ledgerVoucherObject;
    PostingProfile              postingProfile;
    boolean                     createTaxDocument;
    boolean                     createTaxCreditMemo;
    boolean                     conversion;
    SysTmpRecIdMap              taxAmountDisplay;
    SysTmpRecIdMap              correctedTaxAmount;

    TaxCalculationJournal       tax;

    CustVendTransPostingLog_RU  postingLog;
    RecordSortedList            offsetGeneralJournalAccountEntries;

    real                        splitFactor;

    CustFactureAutoCreate_RU    custFactureAutoCreate;
    UseOriginalDocumentAsFacture_RU     useOriginalDocumentAsFacture_RU;

    TransDate                   taxDocumentDate;
    CzTaxDocumentNum            taxDocumentNum;
    private VendorVATDate_W     vendorVATDate;
    private boolean isTaxIntegrationEnabledForJournal;
    private LedgerJournalTransTaxExtension ledgerJournalTransTaxExtension;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEditTaxCreditMemo</Name>
				<Source><![CDATA[
    public boolean allowEditTaxCreditMemo()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditTaxDocument</Name>
				<Source><![CDATA[
    public boolean allowEditTaxDocument()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPrepaymentAmount</Name>
				<Source><![CDATA[
    private container calcPrepaymentAmount(TransDate _transDate)
    {
        AmountCur blockedAmountCur = 0, tmpCur;
        AmountCur remainAmountCur  = custVendTrans.remainAmountCur();
        AmountMST blockedAmountMST = 0, tmpMST;
        AmountMST remainAmountMST  = custVendTrans.remainAmountMST();

        if (LedgerParameters::find().AdvanceAdjustment_W)
        {
            // there is no need to take into account existing
            // unrealized exch adjustment due to cancellation of advance revaluation
            remainAmountMST -= custVendTrans.ExchAdjustmentUnrealized;
        }

        mapReversedAmountsEnumerator.reset();
        while (mapReversedAmountsEnumerator.moveNext())
        {
            if (mapReversedAmountsEnumerator.currentKey() > _transDate)
            {
                [ tmpCur, tmpMST ] = mapReversedAmountsEnumerator.currentValue();

                blockedAmountCur = abs(blockedAmountCur) < abs(tmpCur) ? tmpCur : blockedAmountCur;
                blockedAmountMST = abs(blockedAmountMST) < abs(tmpMST) ? tmpMST : blockedAmountMST;
            }
        }

        remainAmountCur = abs(remainAmountCur) > abs(blockedAmountCur) ? remainAmountCur + blockedAmountCur : 0;
        remainAmountMST = abs(remainAmountMST) > abs(blockedAmountMST) ? remainAmountMST + blockedAmountMST : 0;

        return [ remainAmountCur, remainAmountMST ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    public boolean check()
    {
        boolean ret = this.checkTransDate(transDate);

        if (this.remainAmountJournal())
        {
            ret = checkFailed("@GLS111489");
        }

        if (this.needCreateCustVendTrans())
        {
            ret = this.loadOffsetLedgerLists() && ret;
        }

        // <GEECZ>
        if (createTaxDocument && !taxDocumentDate)
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.TaxGroup &&
                      ledgerJournalTrans.TaxItemGroup &&
                     (ledgerJournalTrans.AmountCurCredit ||
                      ledgerJournalTrans.AmountCurDebit);

            if (ledgerJournalTrans.RecId)
            {
                ret = checkFailed("@GLS111684");
            }
        }

        if (!createTaxCreditMemo && CzTaxDocumentTable::exist(custVendTrans.Voucher, custVendTrans.TransDate))
        {
            ret = checkFailed("@GLS113360");
        }
        // </GEECZ>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransDate</Name>
				<Source><![CDATA[
    public boolean checkTransDate(TransDate _transDate)
    {
        boolean   ret = true;
        AmountCur newPrepaymentAmountCur;
        AmountMST newPrepaymentAmountMST;

        if (_transDate != transDate)
        {
            if (_transDate < custVendTrans.TransDate)
            {
                ret = checkFailed("@GLS107089");
            }

            if (ret)
            {
                [ newPrepaymentAmountCur, newPrepaymentAmountMST ] = this.calcPrepaymentAmount(_transDate);

                if (! newPrepaymentAmountCur)
                {
                    ret = checkFailed("@GLS107083");
                }
                else
                {
                    if (prepaymentAmount != newPrepaymentAmountCur)
                    {
                        if (CustVendTransData::construct(custVendTrans).remainAmountCur() != newPrepaymentAmountCur)
                        {
                            info(strFmt("@GLS111499", _transDate));
                        }
                        prepaymentAmount    = newPrepaymentAmountCur;
                        prepaymentAmountMST = newPrepaymentAmountMST;

                        this.tmpLedgerJournalTrans();
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCorrectedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the cache that holds the corrected tax amount.
    /// </summary>
    public void clearCorrectedTaxAmount()
    {
        if (ledgerJournalEngine)
        {
            ledgerJournalEngine.clearCorrectedTaxAmount(ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearLedgerJournalTransCache</Name>
				<Source><![CDATA[
    final public void clearLedgerJournalTransCache()
    {
        while select ledgerJournalTrans
        {
            delete_from ledgerJournalTransTaxExtension
                where ledgerJournalTransTaxExtension.LedgerJournalTrans == ledgerJournalTrans.RecId;

            ledgerJournalEngine.correctTaxAmount(ledgerJournalTrans,0);
            ledgerJournalEngine.clearTaxAmountCache(ledgerJournalTrans);
            ledgerJournalTrans.doDelete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes tax regulations
    /// </summary>
    public void clearRegulation()
    {
        while select ledgerJournalTrans
        {
            TaxWorkRegulation::clearRegulation(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cleares tax cache.
    /// </summary>
    protected void clearTaxCache()
    {
        tax = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns corrected tax amount for given <c>LedgerJournalTrans</c> record
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> to create tax for
    /// </param>
    /// <returns>
    /// Corrected tax amount for given <c>LedgerJournalTrans</c> record
    /// </returns>
    public TaxAmountJournal correctedTaxAmount(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxAmountCur        taxAmountCur;
        boolean             setDisplaySign = false;

        changecompany(custVendTrans.company())
        {
            this.ledgerJournalTrans(_ledgerJournalTrans);
            this.getTax();

            if ((ledgerJournalTrans.TaxGroup && ledgerJournalTrans.TaxItemGroup) || ledgerJournalTrans.TaxCode)
            {
                if (!correctedTaxAmount.exists(ledgerJournalTrans.RecId))
                {
                    setDisplaySign = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]);
                    taxAmountCur = tax.totalRegTaxAmountSingleLineIncludeUseTax(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId, setDisplaySign);
                    correctedTaxAmount.insert(ledgerJournalTrans.RecId, taxAmountCur);
                }
                else
                {
                    taxAmountCur = correctedTaxAmount.lookup(ledgerJournalTrans.RecId);
                }
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates facture.
    /// </summary>
    protected void createFacture()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax credit memo.
    /// </summary>
    protected void createTaxCreditMemo()
    {
        if (this.parmCreateTaxCreditMemo())
        {
            CzTaxCreditMemoCreate::createDiffMemo(custVendTrans, newCustVendTrans, taxDocumentNum, taxDocumentDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates tax document.
    /// </summary>
    protected void createTaxDocument()
    {
        CzTaxDocumentCreate doc;

        if (this.parmCreateTaxDocument() &&
            newCustVendTrans.Prepayment)
        {
            doc = CzTaxDocumentCreate::construct(newCustVendTrans);
            doc.parmDocumentNum(taxDocumentNum);
            doc.parmDocumentDate(taxDocumentDate);
            doc.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    private void endLedgerVoucher()
    {
        if (newCustVendTrans.RecId != custVendTrans.RecId)
        {
            newCustVendTrans.update();
        }

        ledgerVoucherGroup.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formDesignCaption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the caption for form design.
    /// </summary>
    /// <returns>Caption of the form.</returns>
    public Caption formDesignCaption()
    {
        return "@GLS111481";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes and(or) returns <c>Tax</c> object
    /// </summary>
    /// <returns>
    /// <c>Tax</c> object
    /// </returns>
    public Tax getTax()
    {
        LedgerJournalTaxDocument ledgerJournalTaxDocument;

        if (!tax)
        {
            this.packOverrideSalesTax(ledgerJournalTrans);

            ledgerJournalTaxDocument = LedgerJournalTaxDocumentTmp_RU::construct(ledgerJournalTable, ledgerJournalTrans);
            tax = TaxCalculation::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument);
            tax.sourceSingleLine(true, false);
            tax.calculateTax();
        }

        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes default payment value.
    /// </summary>
    public void init()
    {
        this.initTransDate();
        this.initTaxMaps();

        [ prepaymentAmount, prepaymentAmountMST ] = this.calcPrepaymentAmount(transDate);

        //Exchange rates should be taken from original transaction
        exchRate              = custVendTrans.ExchRate;
        exchRateSecond        = custVendTrans.ExchRateSecond;

        custVendTransOriginal = CustVendTransData::construct(custVendTrans).originalPaymTrans_RU();
        this.parmPostingProfile(custVendTrans.PostingProfile);

        if (! prepaymentAmount)
        {
            warning("@GLS107083");
            throw error("@GLS101992");
        }

        ledgerJournalTable.setTmp();
        ledgerJournalTable.LedgerJournalInclTax = true;
        ledgerJournalTable.doInsert();

        ledgerJournalTrans.setTmp();
        ledgerJournalTransTaxExtension.setTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultPaymentValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes default payment value.
    /// </summary>
    abstract protected void initDefaultPaymentValue()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultPrepaymentValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes default prepayment value.
    /// </summary>
    abstract protected void initDefaultPrepaymentValue()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>LedgerJournalEngine</c> object
    /// </summary>
    public void initLedgerJournalEngine()
    {
        ledgerJournalEngine = new LedgerJournalEngine(null);
        ledgerJournalEngine.newJournalActive(CustVendPrepaymentHandling_W::ledgerJournalTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTransValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>LedgerJournalTrans</c> object.
    /// </summary>
    /// <param name = "_prepaymentAmount">The prepayment amount.</param>
    /// <returns>Initialized <c>LedgerJournalTrans</c> object.</returns>
    final public LedgerJournalTrans initLedgerJournalTransValue(AmountCur _prepaymentAmount = prepaymentAmount)
    {
        ledgerJournalTrans.clear();
        ledgerJournalTrans.LineNum        = this.getNextLedgerJournalTransLineNum();
        ledgerJournalTrans.Voucher        = custVendTrans.Voucher;
        ledgerJournalTrans.TransDate      = custVendTrans.TransDate;

        this.setLedgerJournaValue(_prepaymentAmount);

        ledgerJournalTrans.Prepayment     = NoYes::Yes;
        ledgerJournalTrans.JournalNum     = journalNum;
        ledgerJournalTrans.DocumentDate   = custVendTrans.DocumentDate;
        ledgerJournalTrans.DocumentNum    = custVendTrans.DocumentNum;
        ledgerJournalTrans.Txt            = custVendTrans.Txt;
        ledgerJournalTrans.Company        = curext();

        ledgerJournalTrans.parmAccount(custVendTrans.AccountNum, custVendTrans.TableId == tableNum(CustTrans) ? LedgerJournalACType::Cust : LedgerJournalACType::Vend);

        ledgerJournalEngine.accountModified(ledgerJournalTrans);

        ledgerJournalTrans.DefaultDimension = custVendTrans.DefaultDimension;

        ledgerJournalTrans.CurrencyCode   = custVendTrans.CurrencyCode;
        ledgerJournalEngine.currencyModified(ledgerJournalTrans);
        ledgerJournalTrans.ExchRate       = exchRate;
        ledgerJournalTrans.ExchRateSecond = exchRateSecond;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLedgerJournalTransLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the next line number for Ledger journal line.
    /// </summary>
    /// <returns>
    ///     The next line number for Ledger journal line.
    /// </returns>
    protected LineNum getNextLedgerJournalTransLineNum()
    {
        LedgerJournalTrans  locLedgerJournalTrans;

        locLedgerJournalTrans.setTmp();
        locLedgerJournalTrans.setTmpData(ledgerJournalTrans);

        select maxof (LineNum) from locLedgerJournalTrans;

        return locLedgerJournalTrans.LineNum + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>LedgerVoucher</c> object.
    /// </summary>
    protected void initLedgerVoucher()
    {
        ledgerVoucherObject = LedgerVoucherObject::newVoucher(custVendTrans.Voucher,
                                                              transDate,
                                                              this.sysModule(),
                                                              custVendTrans.TransType);

        ledgerVoucherObject.parmVoucherCheck(false);
        ledgerVoucherObject.lastTransTxt(custVendTrans.Txt);

        ledgerVoucher.addVoucher(ledgerVoucherObject);
        ledgerVoucher.parmCompanyId(custVendTrans.company());

        ledgerVoucherGroup = LedgerVoucherGroup::construct();
        ledgerVoucherGroup.addLedgerVoucher(ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes transaction date.
    /// </summary>
    protected void initTransDate()
    {
        Map       mapReversedAmounts;
        int       i;
        TransDate tmpTransDate;

        transDate = max(transDate +1, custVendTrans.TransDate);
        mapReversedAmounts           = Map::create(CustVendTransData::construct(custVendTrans).mapReversedAmounts_RU());
        mapReversedAmountsEnumerator = mapReversedAmounts.getEnumerator();

        for (i = 1; i <= mapReversedAmounts.elements(); i++)
        {
            mapReversedAmountsEnumerator.moveNext();
            if (i == mapReversedAmounts.elements())
            {
                tmpTransDate = mapReversedAmountsEnumerator.currentKey();
            }
        }

        if (tmpTransDate > transDate)
        {
            transDate = tmpTransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns or sets <c>LedgerJournalTrans</c> temporary table
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Temporary <c>LedgerJournalTrans</c> table parameter
    /// </param>
    /// <returns>
    /// <c>LedgerJournalTrans</c> temporary table
    /// </returns>
    public LedgerJournalTrans ledgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = null)
    {
        if (_ledgerJournalTrans)
        {
            ledgerJournalTrans.setTmp();
            ledgerJournalTrans.data(_ledgerJournalTrans);

            if (isTaxIntegrationEnabledForJournal
                && _ledgerJournalTrans.isTmp()
                && TaxIntegrationPrepaymentHandlingFormVatNumFlight::instance().isEnabled())
            {
                ledgerJournalTransTaxExtension _taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
                select firstonly ledgerJournalTransTaxExtension
                    where ledgerJournalTransTaxExtension.LedgerJournalTrans == _ledgerJournalTrans.RecId;
                // Create tax extension for the new transaction line.
                if (!ledgerJournalTransTaxExtension)
                {
                    ledgerJournalTransTaxExtension.clear();
                    ledgerJournalTransTaxExtension.VATNumRecId = _taxExtension.VATNumRecId;
                    ledgerJournalTransTaxExtension.VATNumTableType = _taxExtension.VATNumTableType;
                    ledgerJournalTransTaxExtension.LedgerJournalTrans = _ledgerJournalTrans.RecId;
                    ledgerJournalTransTaxExtension.doInsert();
                }
            }

            this.clearTaxCache();
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseOriginalDocumentAsFacture_RU</Name>
				<Source><![CDATA[
    public UseOriginalDocumentAsFacture_RU parmUseOriginalDocumentAsFacture_RU(UseOriginalDocumentAsFacture_RU _useOriginalDocumentAsFacture_RU = useOriginalDocumentAsFacture_RU)
    {
        useOriginalDocumentAsFacture_RU = _useOriginalDocumentAsFacture_RU;

        return useOriginalDocumentAsFacture_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPostingTypeBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger posting type for balance.
    /// </summary>
    /// <returns>Ledger posting type for balance.</returns>
    abstract protected LedgerPostingType ledgerPostingTypeBalance()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerPostingTypePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger posting type for payment.
    /// </summary>
    /// <returns>Ledger posting type for balance.</returns>
    abstract protected LedgerPostingType ledgerPostingTypePayment()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger transaction text.
    /// </summary>
    /// <returns>Ledger transaction text.</returns>
    abstract protected LedgerTransTxt ledgerTransTxt()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransTxtReverse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets ledger transaction text for reverse.
    /// </summary>
    /// <returns>Ledger transaction text for reverse.</returns>
    abstract protected LedgerTransTxt ledgerTransTxtReverse()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadOffsetLedgerLists</Name>
				<Source><![CDATA[
    private boolean loadOffsetLedgerLists()
    {
        GeneralJournalAccountEntry          accountEntry;
        GeneralJournalEntry                 entry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        AmountCur   transAmountCur;
        RecId       currentRecID;

        custVendTransOriginal = CustVendTransData::construct(custVendTrans).originalPaymTrans_RU();

        offsetGeneralJournalAccountEntries = new RecordSortedList(tableNum(GeneralJournalAccountEntry));
        offsetGeneralJournalAccountEntries.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));

        while select sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount) from accountEntry
            group by LedgerDimension, TransactionCurrencyCode, AllocationLevel,
                     PostingType, PaymentReference, Text
            where accountEntry.TransactionCurrencyCode == custVendTransOriginal.CurrencyCode &&
                  accountEntry.PostingType      != this.ledgerPostingTypeBalance()    &&
                  accountEntry.PostingType      != this.ledgerPostingTypePayment()    &&
                  accountEntry.PostingType      != LedgerPostingType::Tax             &&
                  accountEntry.PostingType      != LedgerPostingType::Allocation      &&
                ((accountEntry.IsCorrection                                            &&
                ((custVendTrans.AmountCur < 0 && accountEntry.TransactionCurrencyAmount < 0)      ||
                 (custVendTrans.AmountCur > 0 && accountEntry.TransactionCurrencyAmount > 0)      ||
                 (CustVendPrepaymentOffTransExtFilterNegDebitFlight::instance().isEnabled() &&
                    custVendTrans.AmountCur < 0 && accountEntry.TransactionCurrencyAmount > 0)))  ||
                 (! accountEntry.IsCorrection                                           &&
                ((custVendTrans.AmountCur < 0 && accountEntry.TransactionCurrencyAmount > 0)      ||
                 (custVendTrans.AmountCur > 0 && accountEntry.TransactionCurrencyAmount < 0))))
            exists join entry
                where entry.RecId  == accountEntry.GeneralJournalEntry &&
                      entry.Ledger == Ledger::current()
                exists join subledgerVoucherLink
                    where subledgerVoucherLink.GeneralJournalEntry  == entry.RecId           &&
                          subledgerVoucherLink.Voucher              == custVendTransOriginal.Voucher   &&
                          subledgerVoucherLink.AccountingDate       == custVendTransOriginal.TransDate &&
                          subledgerVoucherLink.VoucherDataAreaId    == custVendTransOriginal.DataAreaId
        {
            transAmountCur += accountEntry.TransactionCurrencyAmount;
            currentRecID++;
            accountEntry.RecId   = currentRecID;
            entry.RecId         = currentRecID;
            offsetGeneralJournalAccountEntries.ins(accountEntry);
        }

        splitFactor = transAmountCur ? abs(prepaymentAmount / transAmountCur) : 0;
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needCreateCustVendTrans</Name>
				<Source><![CDATA[
    private boolean needCreateCustVendTrans()
    {
        return (custVendTrans.PostingProfile != postingProfile ||
                custVendTrans.TransDate      != transDate      ||
                conversion                                     ||
                !custVendTrans.Prepayment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmConversion</Name>
				<Source><![CDATA[
    final public boolean parmConversion(boolean _conversion = conversion)
    {
        conversion = _conversion;
        return conversion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateTaxCreditMemo</Name>
				<Source><![CDATA[
    final public boolean parmCreateTaxCreditMemo(boolean _createTaxCreditMemo = createTaxCreditMemo)
    {
        createTaxCreditMemo = _createTaxCreditMemo;
        return createTaxCreditMemo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateTaxDocument</Name>
				<Source><![CDATA[
    final public boolean parmCreateTaxDocument(boolean _createTaxDocument = createTaxDocument)
    {
        createTaxDocument = _createTaxDocument;
        return createTaxDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendTrans</Name>
				<Source><![CDATA[
    public CustVendTrans parmCustVendTrans(CustVendTrans _custVendTrans = custVendTrans)
    {
        custVendTrans = _custVendTrans;
        return custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFactureAutocreate</Name>
				<Source><![CDATA[
    final public CustFactureAutoCreate_RU parmFactureAutocreate(CustFactureAutoCreate_RU _custFactureAutoCreate = custFactureAutoCreate)
    {
        custFactureAutoCreate = _custFactureAutoCreate;
        return custFactureAutoCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalEngine</Name>
				<Source><![CDATA[
    final public LedgerJournalEngine parmLedgerJournalEngine(LedgerJournalEngine _ledgerJournalEngine = ledgerJournalEngine)
    {
        ledgerJournalEngine = _ledgerJournalEngine;
        return _ledgerJournalEngine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingProfile</Name>
				<Source><![CDATA[
    final public PostingProfile parmPostingProfile(PostingProfile _postingProfile = postingProfile)
    {
        postingProfile = _postingProfile;
        return postingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrepaymentAmount</Name>
				<Source><![CDATA[
    final public AmountCur parmPrepaymentAmount(AmountCur _prepaymentAmount = prepaymentAmount)
    {
        prepaymentAmount = _prepaymentAmount;
        return prepaymentAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDocumentDate</Name>
				<Source><![CDATA[
    final public CzTaxDocumentDate parmTaxDocumentDate(CzTaxDocumentDate _taxDocumentDate = taxDocumentDate)
    {
        taxDocumentDate = _taxDocumentDate;
        return taxDocumentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxDocumentNum</Name>
				<Source><![CDATA[
    final public CzTaxDocumentNum parmTaxDocumentNum(CzTaxDocumentNum _taxDocumentNum = taxDocumentNum)
    {
        taxDocumentNum = _taxDocumentNum;
        return taxDocumentNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    final public TransDate parmTransDate(TransDate _transDate = transDate)
    {
        transDate = _transDate;
        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVendorVATDate</Name>
				<Source><![CDATA[
    final internal VendorVATDate_W parmVendorVATDate(VendorVATDate_W _vendorVATDate = vendorVATDate)
    {
        vendorVATDate = _vendorVATDate;
        return vendorVATDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNewCustVendTrans</Name>
				<Source><![CDATA[
    private void postNewCustVendTrans()
    {
        LedgerBondClient_RU         ledgerBondClient;
        CustVendVoucher             custVendVoucher;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        GeneralJournalAccountEntry  accountEntry;
        AmountCur                   tmpAmountCur;

        ledgerVoucherObject.parmCorrection(custVendTrans.Correct);
        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        offsetGeneralJournalAccountEntries.first(accountEntry);

        do
        {
            accountEntry.RecId = 0;
            accountEntry.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimFromLedgerDim(accountEntry.LedgerDimension);
            ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(accountEntry);
            ledgerVoucherTransObject.parmTaxParentReferenceTableId(accountEntry.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(accountEntry.RecId);

            tmpAmountCur = CurrencyExchangeHelper::amount(splitFactor * accountEntry.TransactionCurrencyAmount, custVendTrans.CurrencyCode);
            ledgerVoucherTransObject.parmAmountCur(tmpAmountCur);
            if (tmpAmountCur == -prepaymentAmount)
            {
                ledgerVoucherTransObject.parmAmountMST(- prepaymentAmountMST);
            }
            else
            {
                ledgerVoucherTransObject.parmAmountMST(CurrencyExchangeHelper::amount(splitFactor * accountEntry.AccountingCurrencyAmount));
            }
            ledgerVoucherTransObject.parmAmountMSTSecondary(CurrencyExchangeHelper::amountCur2MSTSecond_RU(ledgerVoucherTransObject.parmAmountCur(), accountEntry.TransactionCurrencyCode, exchRate, transDate, exchRateSecond));

            ledgerVoucherTransObject.parmCorrect(custVendTrans.Correct);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        while (offsetGeneralJournalAccountEntries.next(accountEntry));

        custVendVoucher = CustVendVoucher::construct(this.sysModule(),
                                                     custVendTrans.AccountNum,
                                                     prepaymentAmount,
                                                     custVendTrans.CurrencyCode,
                                                     this.ledgerTransTxt(),
                                                     ledgerJournalTrans.DefaultDimension,
                                                     postingProfile,
                                                     this.ledgerPostingTypeBalance());

        custVendVoucher.parmAmountMST(prepaymentAmountMST);

        custVendVoucher.parmPaymMode(custVendTrans.PaymMode);
        custVendVoucher.parmPaymSpec(custVendTrans.PaymSpec);
        custVendVoucher.parmPaymReference(custVendTrans.PaymReference);
        custVendVoucher.parmTransTxt(custVendTrans.Txt);
        custVendVoucher.parmDocumentDate(custVendTrans.DocumentDate);
        custVendVoucher.parmDocumentNum(custVendTrans.DocumentNum);
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]))
        {
            custVendVoucher.parmPrePayment(custVendTrans.Prepayment ? !conversion : NoYes::Yes);
        }
        else
        {
            custVendVoucher.parmPrePayment(!custVendTrans.Prepayment);
        }
        custVendVoucher.parmExchRate(exchRate);
        custVendVoucher.parmExchRateSecondary(exchRateSecond);
        custVendVoucher.parmCustVendNegInstStatus(custVendTrans.NegInstStatus);
        this.setTransRefId(custVendVoucher, custVendTrans);
        custVendVoucher.post(ledgerVoucher, newCustVendTrans);

        if (ledgerBondClient)
        {
            ledgerBondClient.bondLastVRef2CurrentLog();
            ledgerBondClient.removeCurrentLogObject();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReverseCustVendTrans</Name>
				<Source><![CDATA[
    private void postReverseCustVendTrans()
    {
        LedgerBondClient_RU         ledgerBondClient;
        CustVendTrans               custVendTransStorno;
        CustVendVoucher             custVendVoucher;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        CustVendSettle              custVendSettle;
        OffsetVoucher               offsetVoucher;
        AmountCur                   tmpAmountCur;

        GeneralJournalAccountEntry  accountEntry;

        ledgerVoucher.findLedgerVoucherObject(ledgerVoucherObject.parmReferenceNumber(),
                                              ledgerVoucherObject.parmAccountingDate());

        ledgerVoucherObject.parmCorrection(! custVendTrans.Correct);
        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        while (offsetGeneralJournalAccountEntries.next(accountEntry))
        {
            accountEntry.RecId = 0;
            ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(accountEntry);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(accountEntry.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(accountEntry.RecId);
            ledgerVoucherTransObject.parmSkipDimensionValidation(true);

            tmpAmountCur = CurrencyExchangeHelper::amount(-splitFactor * accountEntry.TransactionCurrencyAmount, custVendTrans.CurrencyCode);
            ledgerVoucherTransObject.parmAmountCur(tmpAmountCur);
            if (tmpAmountCur == prepaymentAmount)
            {
                ledgerVoucherTransObject.parmAmountMST(prepaymentAmountMST);
            }
            else
            {
                ledgerVoucherTransObject.parmAmountMST(CurrencyExchangeHelper::amount(-splitFactor * accountEntry.AccountingCurrencyAmount));
            }
            ledgerVoucherTransObject.parmAmountMSTSecondary(CurrencyExchangeHelper::amountCur2MSTSecond_RU(ledgerVoucherTransObject.parmAmountCur(), accountEntry.TransactionCurrencyCode, exchRate, transDate, exchRateSecond));
            ledgerVoucherTransObject.parmCorrect(! custVendTrans.Correct);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        custVendTransStorno = custVendTrans.data();

        custVendVoucher = CustVendVoucher::construct(this.sysModule(),
                                                     custVendTrans.AccountNum,
                                                     - prepaymentAmount,
                                                     custVendTrans.CurrencyCode,
                                                     this.ledgerTransTxtReverse(),
                                                     custVendTrans.DefaultDimension,
                                                     custVendTrans.PostingProfile,
                                                     this.ledgerPostingTypeBalance());

        custVendVoucher.parmAmountMST(-prepaymentAmountMST);

        custVendVoucher.parmTransTxt(custVendTrans.Txt);
        custVendVoucher.parmExchRate(exchRate);
        custVendVoucher.parmExchRateSecondary(exchRateSecond);
        custVendVoucher.parmDocumentDate(custVendTrans.DocumentDate);
        custVendVoucher.parmDocumentNum(custVendTrans.DocumentNum);
        custVendVoucher.parmPrePayment(custVendTrans.Prepayment);
        custVendVoucher.parmCustVendNegInstStatus(custVendTrans.NegInstStatus);
        this.setTransRefId(custVendVoucher, custVendTrans);
        custVendVoucher.parmTransVoucher(ledgerVoucher.lastVoucher());
        custVendVoucher.post(ledgerVoucher, custVendTransStorno);

        custVendTransStorno.doUpdate();

        CustVendTransData::construct(custVendTransStorno).markForSettlement(custVendTrans);
        CustVendTransData::construct(custVendTrans).markForSettlement(custVendTrans);
        offsetVoucher = OffsetVoucher::construct(this.sysModule(), SettlementType::SelectedTransact, custVendTrans);
        offsetVoucher.parmUseDatePrinciple_RU(false);

        custVendSettle = CustVendSettle::newOffsetVoucher(this.sysModule(), offsetVoucher, ledgerVoucherGroup);
        custVendSettle.settleNow(custVendTrans.company(), custVendTrans.TableId, custVendTrans.RecId, true);
        this.restoreVoucher();

        postingLog = custVendSettle.createPostingTransLog_RU(CustVendTransPostingLogType_RU::Prepayment,
                                                             custVendTransStorno,
                                                             this.ledgerPostingTypeBalance(),
                                                             0,
                                                             0,
                                                             ledgerVoucherObject.lastAmountMST(),
                                                             ledgerVoucherObject.lastAmountMSTSecondary_RU(),
                                                             null,
                                                             custVendTrans.DefaultDimension,
                                                             ledgerVoucherObject.lastAmountCur(),
                                                             custVendTransStorno,
                                                             custVendTrans);

        if (ledgerBondClient)
        {
            ledgerBondClient.bondLastVRef2CurrentLog();
            ledgerBondClient.removeCurrentLogObject();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATAmount</Name>
				<Source><![CDATA[
    private void postVATAmount()
    {
        LedgerBondClient_RU      ledgerBondClient;
        TaxAmount                taxAmount;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        TaxWorkRegulation        taxWorkRegulation;
        TmpTaxWorkTrans          tmpTaxWorkTrans;
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        LedgerJournalTable       journalTable;

        CurrencyExchangeHelper   exchHelper;

        journalTable.setTmp();
        journalTable.JournalNum = '';
        journalTable.LedgerJournalInclTax = true;
        journalTable.doInsert();

        ledgerVoucherObject.parmCorrection(custVendTrans.Correct);
        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

        while select ledgerJournalTrans
            where ledgerJournalTrans.TaxGroup        &&
                  ledgerJournalTrans.TaxItemGroup    &&
                 (ledgerJournalTrans.AmountCurCredit ||
                  ledgerJournalTrans.AmountCurDebit)
        {
            update_recordset taxWorkRegulation
                setting HeadingTableId = newCustVendTrans.TableId,
                        HeadingRecId = newCustVendTrans.RecId
                where taxWorkRegulation.HeadingTableId == ledgerJournalTrans.TableId
                    && taxWorkRegulation.HeadingRecId == ledgerJournalTrans.RecId;

            ledgerJournalTrans.JournalNum = '';

            if (isTaxIntegrationEnabledForJournal
                && TaxIntegrationPrepaymentHandlingSkipEmptyLedgerJournalTransFlight::instance().isEnabled())
            {
                this.packOverrideSalesTax(ledgerJournalTrans);
            }
            else
            {
                RecId ledgerJournalTransRecId = ledgerJournalTrans.RecId;
                ledgerJournalTrans.RecId = 0;
                this.packOverrideSalesTax(ledgerJournalTrans, ledgerJournalTransRecId);
            }

            if (ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }

            ledgerJournalTaxDocument = LedgerJournalTaxDocumentTmp_RU::construct(journalTable, ledgerJournalTrans);
            tax = TaxCalculation::newForSourceType(TaxSourceType::Journals, ledgerJournalTaxDocument);
            tax.setHeading_RU(newCustVendTrans);
            tax.parmUseHeadingRecIdAsSourceRecId_RU(true);
            tax.setPrepaymentExchRates_RU(exchRate, exchRateSecond);
            taxAmount = tax.calculateTax();

            tmpTaxWorkTrans = tax.tmpTaxWorkTrans();
            boolean hasTaxWorkTrans = false;
            boolean shouldUpdateTableInfo = isTaxIntegrationEnabledForJournal && TaxIntegrationPrepaymentHandlingFormFlight::instance().isEnabled();
            while select tmpTaxWorkTrans
            {
                tmpTaxWorkTrans.TransDate = transDate;
                if (shouldUpdateTableInfo)
                {
                    // Use CustTrans/VendTrans as heading table just like that on tax specified by method setHeading_RU.
                    tmpTaxWorkTrans.HeadingTableId = newCustVendTrans.TableId;
                    tmpTaxWorkTrans.HeadingRecId = newCustVendTrans.RecId;
                    // Use CustTrans/VendTrans as source table just like that on tax specified by method parmUseHeadingRecIdAsSourceRecId_RU.
                    tmpTaxWorkTrans.SourceTableId = newCustVendTrans.TableId;
                    tmpTaxWorkTrans.SourceRecId = newCustVendTrans.RecId;
                }

                tmpTaxWorkTrans.update();
                hasTaxWorkTrans = true;
            }

            LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher);
            LedgerDimensionAccount ledgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(this.vatPrepaymentsLedgerDimension(newCustVendTrans), ledgerJournalTrans.DefaultDimension);

            if (hasTaxWorkTrans)
            {
                tax.saveAndPost(ledgerPostingController);
            }

            exchHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
            exchHelper.parmExchangeRate1(exchRate);
            exchHelper.parmExchangeRate2(exchRateSecond);
            exchHelper.parmExchangeDate(ledgerVoucherObject.parmTransDate());

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucherObject,
                                                                                             this.ledgerPostingTypePayment(),
                                                                                             ledgerDimensionAccount,
                                                                                             newCustVendTrans.CurrencyCode,
                                                                                             -taxAmount,
                                                                                             exchHelper);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(newCustVendTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(newCustVendTrans.RecId);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (TaxPrepaymentHandlingPostTaxInCostPriceFlight::instance().isEnabled())
            {
                TaxAmount taxInCostPrice = tax.totalTaxInCostPrice();
                if (taxInCostPrice)
                {
                    // Posts VAT non-deductible amounts, if the tax includes non-deductible.
                    TaxTrans taxTrans = TaxTrans::find(ledgerJournalTrans.Voucher, ledgerJournalTrans.TransDate);
                    tax.postCharge(ledgerPostingController, taxTrans, taxInCostPrice, exchHelper, ledgerDimensionAccount);
                }
            }

            if (ledgerBondClient)
            {
                if (!CustVendPrepaymentHandlingZeroTaxFlight::instance().isEnabled() || this.canDoTaxLedgerVoucherBonding(taxAmount))
                {
                    ledgerBondClient.bondLastVRef2CurrentLog();
                }
                ledgerBondClient.removeCurrentLogObject();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepaymentExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if specified <c>CustVendTrans</c> has prepayments or not.
    /// </summary>
    /// <param name = "_custVendTrans">The <c>CustVendTrans</c> which may contain prepayments.</param>
    /// <returns>True if prepayment exists, false otherwise.</returns>
    abstract protected boolean prepaymentExists(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainAmountJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the remaining amount from <c>LedgerJournalTrans</c>.
    /// </summary>
    /// <returns>The remaining amount.</returns>
    final public AmountCur remainAmountJournal()
    {
        LedgerJournalTrans ledgerJournalTransLocal;

        ledgerJournalTransLocal.setTmp();
        ledgerJournalTransLocal.setTmpData(ledgerJournalTrans);

        select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransLocal;
        return prepaymentAmount - ledgerJournalTransLocal.AmountCurDebit + ledgerJournalTransLocal.AmountCurCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreVoucher</Name>
				<Source><![CDATA[
    private void restoreVoucher()
    {
        ledgerVoucher.lastVoucher(ledgerVoucherObject.parmReferenceNumber());
        ledgerVoucher.lastTransDate(ledgerVoucherObject.parmAccountingDate());

        ledgerVoucher.findLedgerVoucherObject();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseVATAmount</Name>
				<Source><![CDATA[
    private void reverseVATAmount()
    {
        TaxReversePrepayment_RU  taxReversePrePayment;
        LedgerBondClient_RU      ledgerBondClient;
        TaxAmount                taxAmount,
                                 taxAmountMst;
        LedgerVoucherTransObject ledgerVoucherTransObject;

        CurrencyExchangeHelper   exchHelper;

        // Sales tax should always be reversed when converting a prepayment to a payment
        if (this.needCreateCustVendTrans() && !this.reverseVATonDate() && !conversion)
        {
            return;
        }

        ledgerVoucherObject.parmCorrection(!custVendTrans.Correct);
        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        taxReversePrePayment = new TaxReversePrepayment_RU();
        taxReversePrePayment.initFromSettlement(custVendTrans,
                                                prepaymentAmountMST,
                                                prepaymentAmount,
                                                0);

        [ taxAmount, taxAmountMst ] = taxReversePrePayment.calcPostAndInsertTaxes(
                                            LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher),
                                            TaxOrigin::Tax,
                                            exchRateSecond);

        if (taxAmount)
        {
            exchHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
            exchHelper.parmExchangeRate1(exchRate);
            exchHelper.parmExchangeRate2(exchRateSecond);
            exchHelper.parmExchangeDate(ledgerVoucher.lastTransDate());

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(ledgerVoucherObject,
                                                                                                        this.ledgerPostingTypePayment(),
                                                                                                        LedgerDimensionFacade::serviceCreateLedgerDimension(this.vatPrepaymentsLedgerDimension(custVendTrans), custVendTrans.DefaultDimension),
                                                                                                        custVendTrans.CurrencyCode,
                                                                                                        -taxAmount,
                                                                                                        -taxAmountMst,
                                                                                                        exchHelper);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(custVendTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(custVendTrans.RecId);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
                ledgerBondClient.removeCurrentLogObject();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseVATonDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if it is reverse value added tax on date.
    /// </summary>
    /// <returns>True if it is, false otherwise.</returns>
    abstract protected boolean reverseVATonDate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes prepayment handling logic for customers and vendors.
    /// </summary>
    final public void run()
    {
        #OCCRetryCount
        RecId recId = custVendTrans.RecId;
        CustVendTrans localCustVendTrans;

        try
        {
            ttsbegin;

            select pessimisticLock custVendTrans where custVendTrans.RecId == recId;
            this.initLedgerVoucher();

            if (custVendTrans.Prepayment)
            {
                this.reverseVATAmount();
            }

            newCustVendTrans = CustVendTransStatic::construct(custVendTrans).custVendTrans();
            newCustVendTrans.data(custVendTrans);

            if (this.needCreateCustVendTrans())
            {
                this.postReverseCustVendTrans();
                this.postNewCustVendTrans();
            }

            localCustVendTrans = CustVendTransStatic::construct(custVendTrans).custVendTrans();
            select forupdate localCustVendTrans  where localCustVendTrans.RecId == recId;
            if (newCustVendTrans.RecId == custVendTrans.RecId)
            {
                custVendTrans.Prepayment = custVendTrans.Prepayment ? ! conversion : NoYes::Yes;
                localCustVendTrans.Prepayment = custVendTrans.Prepayment;
            }

            if (vendorVATDate && FeatureStateProvider::isFeatureEnabled(VendorVATDateFeature::instance()))
            {
                localCustVendTrans.VendorVATDate = vendorVATDate;
            }

            this.postVATAmount();

            this.createFacture();

            this.endLedgerVoucher();

            localCustVendTrans.update();

            // <GEECZ>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ]))
            {
                this.createTaxDocument();
                this.createTaxCreditMemo();
            }
            // </GEECZ>

            this.unlinkAdvanceInvoices();

            info("@GLS101448");

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            if (this.parmCreateTaxDocument() ||
                this.parmCreateTaxCreditMemo())
            {
                // If tax document/credit memo creation fails
                // force tax to recalculate
                select ledgerJournalTrans;
                this.clearTaxCache();
            }

            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerJournaValue</Name>
				<Source><![CDATA[
    abstract protected void setLedgerJournaValue(AmountCur _amountCur)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransRefId</Name>
				<Source><![CDATA[
    // do nothing by default
    protected void setTransRefId(CustVendVoucher _custVendVoucher, CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>showAdvanceInvoiceProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show advance invoice proposal.
    /// </summary>
    /// <returns>False.</returns>
    public boolean showAdvanceInvoiceProposal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showButtons</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show all buttons.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showButtons()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showButtonSalesTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show buttons for sales tax.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showButtonSalesTax()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showConversion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show conversion or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showConversion()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showConversionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets conversion text based on text.
    /// </summary>
    /// <returns>Convert prepayment to payment if prepayment, empty string if not.</returns>
    public str showConversionText()
    {
        return custVendTrans.Prepayment ? "@GLS108373" : "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>showPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show posting profile or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showPostingProfile()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showPrepaymentAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show prepayment amount or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showPrepaymentAmount()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showRemainAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show remainning amount or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showRemainAmount()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTab</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show tab or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showTab()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show tax credit memo or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showTaxCreditMemo()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show tax document or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showTaxDocument()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTaxDocumentNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show tax document number or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showTaxDocumentNum()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if to show transaction date or not.
    /// </summary>
    /// <returns>True.</returns>
    public boolean showTransDate()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sysModule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets system module.
    /// </summary>
    /// <returns>The system module.</returns>
    abstract protected SysModule sysModule()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxAmountJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns tax amount for <c>LedgerJournalTrans</c> record
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// <c>LedgerJournalTrans</c> record
    /// </param>
    /// <returns>
    /// Tax amount for <c>LedgerJournalTrans</c> record
    /// </returns>
    public TaxAmountJournal taxAmountJournal(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxAmountCur        taxAmountCur;
        boolean             setDisplaySign = false;

        changecompany(custVendTrans.company())
        {
            this.ledgerJournalTrans(_ledgerJournalTrans);
            this.getTax();

            if ((ledgerJournalTrans.TaxGroup && ledgerJournalTrans.TaxItemGroup) || ledgerJournalTrans.TaxCode)
            {
                if (!taxAmountDisplay.exists(ledgerJournalTrans.RecId))
                {
                    setDisplaySign = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL]);
                    taxAmountCur = tax.totalTaxAmountSingleLine(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId, setDisplaySign, true);
                    taxAmountDisplay.insert(ledgerJournalTrans.RecId, taxAmountCur);
                }
                else
                {
                    taxAmountCur = taxAmountDisplay.lookup(ledgerJournalTrans.RecId);
                }
            }
        }

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets temporary table buffer of <c>LedgerJournalTrans</c>.
    /// </summary>
    /// <returns>The <c>LedgerJournalTrans</c>.</returns>
    public LedgerJournalTrans tmpLedgerJournalTrans()
    {
        boolean                       useSourceRecId;
        CustVendCalcSettledAmounts_RU custVendCalcSettledAmounts;
        Map                           taxAmountsCur;
        MapEnumerator                 enumerator;
        TaxCode                       taxCode;
        TaxGroup                      taxGroup;
        TaxItemGroup                  taxItemGroup;
        DimensionDefault              defaultDimension;
        LedgerDimensionAccount        ledgerDimension, offsetLedgerDimension;
        BookStructSmallVATAmounts_RU  bookStructSmallVATAmounts;
        TaxTrans                      taxTrans;
        InventTransId                 inventTransId;
        TaxModuleTypeId               source;
        TaxTrans_W                    taxTrans_W;

        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;

        this.clearLedgerJournalTransCache();
        this.clearTaxCache();

        if (custVendTrans.Prepayment)
        {
            if (conversion)
            {
                this.initLedgerJournalTransValue();
                ledgerJournalTrans.Prepayment = NoYes::No;
                ledgerJournalTrans.TaxGroup     = '';
                ledgerJournalTrans.TaxItemGroup = '';

                if (ledgerJournalTrans)
                {
                    ledgerJournalTrans.doUpdate();
                }
                else
                {
                    ledgerJournalTrans.doInsert();
                }

                this.initDefaultPaymentValue();
            }
            else
            {
                this.parmPostingProfile(custVendTrans.PostingProfile);

                useSourceRecId = CustVendTransData::construct(custVendTrans).isPrepaymentConverted_W();

                custVendCalcSettledAmounts = CustVendCalcSettledAmounts_RU::construct(custVendTrans, useSourceRecId, true, null, true);
                custVendCalcSettledAmounts.calcSettledAmounts();
                custVendCalcSettledAmounts.calcNewSettlement(0,prepaymentAmount);

                taxAmountsCur  = custVendCalcSettledAmounts.mapLastSettledAmountsCur();
                enumerator = taxAmountsCur.getEnumerator();

                while (enumerator.moveNext())
                {
                    bookStructSmallVATAmounts = BookStructSmallVATAmounts_RU::create(enumerator.currentValue());

                    if (bookStructSmallVATAmounts.amountInclVAT())
                    {
                        [ taxGroup,
                          taxItemGroup,
                          taxCode,
                          defaultDimension,
                          inventTransId,
                          ledgerDimension,
                          offsetLedgerDimension,
                          source ] = enumerator.currentKey();

                        select firstonly RecId, PartyTaxId from taxTrans order by RecId desc
                            where taxTrans.Voucher             == custVendTrans.Voucher   &&
                                  taxTrans.TransDate           == custVendTrans.TransDate &&
                                  taxTrans.ExemptTax           == NoYes::No               &&
                                  taxTrans.TaxOrigin           == TaxOrigin::Tax          &&
                                  taxTrans.TaxCode             == taxCode                 &&
                                  taxTrans.TaxGroup            == taxGroup                &&
                                  taxTrans.TaxItemGroup        == taxItemGroup            &&
                                  taxTrans.Source              == source                  &&
                               (! useSourceRecId || taxTrans.SourceRecId == custVendTrans.RecId)
                              outer join taxTrans_W
                                where taxTrans_W.TaxTrans == taxTrans.RecId
                              join RecId from taxTransGeneralJournalAccountEntry
                              where
                                  taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::Tax &&
                                  taxTransGeneralJournalAccountEntry.LedgerDimension      == ledgerDimension;

                        ledgerJournalTrans = this.initLedgerJournalTransValue();

                        ledgerJournalTrans.TaxGroup         = taxGroup;
                        ledgerJournalTrans.TaxItemGroup     = taxItemGroup;
                        ledgerJournalTrans.DefaultDimension = defaultDimension;

                        this.setLedgerJournaValue(bookStructSmallVATAmounts.amountInclVAT());

                        boolean shouldUpdateVatNumForTaxIntegration = isTaxIntegrationEnabledForJournal
                            && TaxIntegrationPrepaymentHandlingFormVatNumFlight::instance().isEnabled();
                        if (taxTrans_W)
                        {
                            ledgerJournalTrans.VatDueDate_W            = max(taxTrans_W.VatDueDate_W,transDate);
                            ledgerJournalTrans.CustVendName_PL         = taxTrans_W.CustVendName_PL;
                            if (!shouldUpdateVatNumForTaxIntegration)
                            {
                                ledgerJournalTrans.vatNumJournal           = taxTrans_W.vatNum_PL;
                                LedgerJournalTransTaxExtension taxExtension = ledgerJournalTrans.ledgerJournalTransTaxExtension();
                                taxExtension.VATNumRecId                   = taxTrans.PartyTaxId;
                                taxExtension.VATNumTableType               = TaxExemptNumberSourceType::TaxRegistration;
                                ledgerJournalTrans.packExtensionTable(taxExtension);
                            }
                            ledgerJournalTrans.Addressing_PL           = taxTrans_W.Addressing_PL;
                            ledgerJournalTrans.TaxPeriodPaymentCode_PL = taxTrans_W.TaxPeriodPaymentCode_PL;
                        }
                        // Handle tax exempt number
                        boolean shouldSavePartyTaxID = false;
                        if (shouldUpdateVatNumForTaxIntegration)
                        {
                            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                            {
                                if (taxTrans_W)
                                {
                                    ledgerJournalTrans.vatNumJournal = taxTrans_W.vatNum_PL;
                                    shouldSavePartyTaxID = taxTrans.PartyTaxId ? true : false;
                                }
                            }
                            else
                            {
                                if (taxTrans && taxTrans.PartyTaxId)
                                {
                                    ledgerJournalTrans.vatNumJournal = TaxRegistration::find(taxTrans.PartyTaxId).RegistrationNumber;
                                    shouldSavePartyTaxID = true;
                                }
                                // If party tax ID can't be found on taxTrans, ledgerJournalTrans.vatNumJournal will be the tax exempt number setup on Cust/Vend.
                            }
                        }

                        ledgerJournalTrans.insert();

                        if (shouldUpdateVatNumForTaxIntegration)
                        {
                            ledgerJournalTransTaxExtension.clear();
                            if (shouldSavePartyTaxID)
                            {
                                ledgerJournalTransTaxExtension.VATNumRecId = taxTrans.PartyTaxId;
                                ledgerJournalTransTaxExtension.VATNumTableType = TaxExemptNumberSourceType::TaxRegistration;
                            }
                            ledgerJournalTransTaxExtension.LedgerJournalTrans = ledgerJournalTrans.RecId;
                            ledgerJournalTransTaxExtension.doInsert();
                        }
                    }
                }
            }
        }
        else
        {
            this.initLedgerJournalTransValue();
            this.initDefaultPrepaymentValue();
            ledgerJournalTrans.modifyVatDueDate_W();
            ledgerJournalTrans.doInsert();
        }

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unlinkAdvanceInvoices</Name>
				<Source><![CDATA[
    private void unlinkAdvanceInvoices()
    {
        if (newCustVendTrans.RecId == custVendTrans.RecId &&
            custVendTrans.Prepayment)
            return;

        if (newCustVendTrans.Prepayment)
        {
            CzAdvanceInvoiceLink::moveLinksVoucherDate(custVendTrans, newCustVendTrans);
            return;
        }

        if (! this.prepaymentExists(newCustVendTrans))
        {
            CzAdvanceInvoiceLink::clearLinksVoucherDate(newCustVendTrans);
        }

        // if old prepayment is fully converted to payment,
        // i.e. if there is no settlement to invoice
        if (custVendTrans.RecId != newCustVendTrans.RecId &&
            ! this.prepaymentExists(custVendTrans))
        {
            CzAdvanceInvoiceLink::clearLinksVoucherDate(custVendTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatPrepaymentsLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Looks up default ledger dimension account for customer or vendor transaction.
    /// </summary>
    /// <param name="_custVendTrans">
    ///     Customer or vendor transaction <c>CustVendTrans</c>.
    /// </param>
    /// <returns>
    ///     Default ledger dimension account <c>LedgerDimensionAccount</c>.
    /// </returns>
    protected abstract LedgerDimensionDefaultAccount vatPrepaymentsLedgerDimension(CustVendTrans _custVendTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTable</Name>
				<Source><![CDATA[
    public static LedgerJournalTable ledgerJournalTable()
    {
        LedgerJournalTable ledgerJournalTable;

        ledgerJournalTable.JournalNum           = journalNum;
        ledgerJournalTable.JournalName          = journalNum;
        ledgerJournalTable.LedgerJournalInclTax = NoYes::Yes;
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalTableHistory</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static LedgerJournalTableHistory ledgerJournalTableHistory()
    {
        LedgerJournalTableHistory ledgerJournalTableHistory;

        ledgerJournalTableHistory.JournalNum           = journalNum;
        ledgerJournalTableHistory.JournalName          = journalNum;
        ledgerJournalTableHistory.LedgerJournalInclTax = NoYes::Yes;
        return ledgerJournalTableHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPrepaymentHandling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves proper <c>CustVendPrepaymentHandling_W</c> instance.
    /// </summary>
    /// <param name = "_prepaymentHandlingLayout_W">The prepayment handling type.</param>
    /// <returns>The <c>CustVendPrepaymentHandling_W</c> instance.</returns>
    protected static CustVendPrepaymentHandling_W custPrepaymentHandling(PrepaymentHandlingLayout_W _prepaymentHandlingLayout_W)
    {
        CustVendPrepaymentHandling_W custVendPrepaymentHandling;

        switch (_prepaymentHandlingLayout_W)
        {
            case PrepaymentHandlingLayout_W::Simple   :
                custVendPrepaymentHandling = new CustPrepaymentHandling_Simple_W();
                break;

            case PrepaymentHandlingLayout_W::Advanced :
                custVendPrepaymentHandling = new CustPrepaymentHandling_Advanced_W();
                break;
        }
        return custVendPrepaymentHandling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vendPrepaymentHandling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves proper <c>CustVendPrepaymentHandling_W</c> instance.
    /// </summary>
    /// <param name = "_prepaymentHandlingLayout_W">The prepayment handling type.</param>
    /// <returns>The <c>CustVendPrepaymentHandling_W</c> instance.</returns>
    protected static CustVendPrepaymentHandling_W vendPrepaymentHandling(PrepaymentHandlingLayout_W _prepaymentHandlingLayout_W)
    {
        CustVendPrepaymentHandling_W custVendPrepaymentHandling;

        switch (_prepaymentHandlingLayout_W)
        {
            case PrepaymentHandlingLayout_W::Simple   :
                custVendPrepaymentHandling = new VendPrepaymentHandling_Simple_W();
                break;

            case PrepaymentHandlingLayout_W::Advanced :
                custVendPrepaymentHandling = new VendPrepaymentHandling_Advanced_W();
                break;
        }
        return custVendPrepaymentHandling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromCustVendTrans</Name>
				<Source><![CDATA[
    public static CustVendPrepaymentHandling_W newFromCustVendTrans(CustVendTrans _custVendTrans)
    {
        CustVendPrepaymentHandling_W custVendPrepaymentHandling;

        switch (_custVendTrans.TableId)
        {
            case tableNum(CustTrans) :
                custVendPrepaymentHandling = CustVendPrepaymentHandling_W::custPrepaymentHandling(CustParameters::find().PrepaymentHandlingLayout_W);
                break;

            case tableNum(VendTrans) :
                custVendPrepaymentHandling = CustVendPrepaymentHandling_W::vendPrepaymentHandling(VendParameters::find().PrepaymentHandlingLayout_W);
                break;
        }

        if (!custVendPrepaymentHandling)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        custVendPrepaymentHandling.parmCustVendTrans(_custVendTrans);
        custVendPrepaymentHandling.parmConversion(_custVendTrans.Prepayment);
        custVendPrepaymentHandling.paramTaxIntegrationEnabledForJournal(TaxIntegrationUtils::isTaxIntegrationEnabledForJournalType(custVendPrepaymentHandling.getLedgerJournalType()));

        return custVendPrepaymentHandling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearTaxMaps</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Cleares tax Maps.
    /// </summary>
    public void clearTaxMaps()
    {
        taxAmountDisplay.remove(ledgerJournalTrans.RecId);
        correctedTaxAmount.remove(ledgerJournalTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxMaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes tax Maps.
    /// </summary>
    protected void initTaxMaps()
    {
        taxAmountDisplay          = SysTmpRecIdMap::construct(Types::Real);
        correctedTaxAmount        = SysTmpRecIdMap::construct(Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDoTaxLedgerVoucherBonding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if tax voucher transactions can be bonded.
    /// </summary>
    /// <param name = "_taxAmount">Tax amount.</param>
    /// <returns>true - if tax voucher transactions can be bonded; false, otherwise.</returns>
    internal boolean canDoTaxLedgerVoucherBonding(TaxAmount _taxAmount)
    {
        return _taxAmount != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the journal type of the journal transactions.
    /// </summary>
    /// <returns>The journal type.</returns>
    internal LedgerJournalType getLedgerJournalType()
    {
        LedgerJournalType ledgerJournalType = LedgerJournalType::None;
        if (Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Journal))
        {
            // Journal type should be taken from the original transaction
            LedgerJournalTrans ledgerJournalTransOrig = LedgerJournalTrans::findByCustVendTrans(custVendTrans);
            ledgerJournalType = ledgerJournalTransOrig.ledgerJournalTable().JournalType;
        }
        return ledgerJournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramTaxIntegrationEnabledForJournal</Name>
				<Source><![CDATA[
    final public boolean paramTaxIntegrationEnabledForJournal(boolean _isTaxIntegrationEnabledForJournal = isTaxIntegrationEnabledForJournal)
    {
        isTaxIntegrationEnabledForJournal = _isTaxIntegrationEnabledForJournal;
        return isTaxIntegrationEnabledForJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packOverrideSalesTax</Name>
				<Source><![CDATA[
    private void packOverrideSalesTax(LedgerJournalTrans _ledgerJournalTrans, RecId _ledgerJournalTransRecId = 0)
    {
        if (!isTaxIntegrationEnabledForJournal)
        {
            return;
        }

        ledgerJournalTransTaxExtension taxExtension;
        taxExtension.setTmp();
        boolean found = false;

        if (TaxIntegrationPrepaymentHandlingFormVatNumFlight::instance().isEnabled())
        {
            RecId transRecId = _ledgerJournalTransRecId ? _ledgerJournalTransRecId : _ledgerJournalTrans.RecId;
            select ledgerJournalTransTaxExtension
                where ledgerJournalTransTaxExtension.LedgerJournalTrans == transRecId;
            if (ledgerJournalTransTaxExtension)
            {
                if (_ledgerJournalTransRecId)
                {
                    ledgerJournalTransTaxExtension.LedgerJournalTrans = _ledgerJournalTrans.RecId;
                }
                found = true;
                taxExtension = ledgerJournalTransTaxExtension;
            }
        }
        if (!found)
        {
            taxExtension = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
        }
        // Always set Override sales tax = YES
        taxExtension.OverrideSalesTax = NoYes::Yes;
        _ledgerJournalTrans.packExtensionTable(taxExtension);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>