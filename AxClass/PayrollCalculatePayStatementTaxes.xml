<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PayrollCalculatePayStatementTaxes</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Performs the logic for calculating and creating the applicable <c>PayrollPayStatementTaxLine</c> records for a Pay Statement.
/// </summary>
/// <remarks>
/// This class is consumed by the <c>PayrollPayStatementGenerationTask</c> to calculate the taxes portion of the Pay Statement.
/// </remarks>
public class PayrollCalculatePayStatementTaxes
{
    #PayrollConstants
    #ISOCountryRegionCodes
    PayrollPayStatement                                 payStatement;
    PayrollParameters                                   payrollParameters;
    PayrollTaxTypeInitialization                        taxTypeInit;
    PayrollPaymentType                                  paymentType;
    PeriodEnd                                           payPeriodEndDate;
    PayrollPaymDate                                     paymentDate;
    HcmWorker                                           worker;
    LogisticsAddressCountryRegionId                     countryRegionId;
    PayrollWorkerTaxRegionRecId                         grossUpWorkerTaxRegionRecId;
    Amount                                              ytdPriorSutaSubjectWages,
                                                        futaHours,
                                                        futaWages,
                                                        sutaWages,
                                                        sutaHours,
                                                        deductedTaxTotal,
                                                        employeePayStatementPreTaxBenefitsTotal,
                                                        productiveHoursWA;
    utcdatetime                                         paymDateTime;
    str                                                 residentTaxLocation,
                                                        grossUpTaxLocation,
                                                        sutaState;
    InteropPermission                                   permission;
    System.Int16                                        payPeriodsPerYear,
                                                        zeroInt16;
    RecId                                               currLE;
    boolean                                             isExemptFromSuta,
                                                        isResidentApplyCourtesyWithholding,
                                                        isNonProductiveWageTypeSetOR,
                                                        isNonProductiveWageTypeSetWA;
    Map                                                 stateSingleLocationsMap,
                                                        customWageTypeMap;
    PayrollWorkerTaxRegionForSymmetry                   residentWorkerTaxRegionSym;
    PayrollUSState                                      priorSutaState;
    Map                                                 workerTaxRegionsMap;
    MapEnumerator                                       workerTaxRegionsMapEnumerator;
    PreferredLocale                                     locale = new Session().preferredLocale();

    //
    // Each instance of PrlCalculateTaxUS stores a single instance of the tax engine for tax calculation purposes (ste)
    // and another instance in order to determine the applicable taxes to attempt to calculate based on tax regions (steApplicable).
    //
    Amount                      grossWagesRegPositive,
                                grossWagesSupPositive,
                                grossWagesCustomPositive,
                                grossWagesCustomNegative,
                                nonProductiveAccumulatedWages,
                                nonProductiveAccumulatedHours,
                                userDefinedAccumulatedWages,
                                userDefinedAccumulatedHours,
                                wagesGtlReg,
                                wagesGtlSup,
                                grossHoursRegPositive,
                                grossHoursSupPositive,
                                grossHoursCustomPositive,
                                grossHoursCustomNegative,
                                grossWagesRegNegative,
                                grossWagesSupNegative,
                                grossHoursRegNegative,
                                grossHoursSupNegative;

    // Tax engine types that must be initialized and supplied to its methods
    System.Collections.ArrayList                        calculatedTaxesList;
  
    const str GtlIncomeType = 'GTLExcluded';
    const str TaxIDWashingtonEmployerSDI = '53-000-0000-ER_SDI-000';
    const str TaxIDWashingtonEmployeeSDI = '53-000-0000-SDI-000';
    const str TaxIDOregonEmployerWorkersComp = '41-000-0000-ER_WC-000';
    const str TaxIDOregonEmployeeWorkersComp = '41-000-0000-WC-000';
    const int CustomWageTypeOffset = 200;
    const int SteLoggingLevelOption = 6;
    const int SteLogNameOption = 8;
    const str SteLoggingLevelOptionDebug = 'DEBUG';
    const str SteLoggingLevelOptionOff = 'OFF';

  
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildSutaLocationCode</Name>
				<Source><![CDATA[
    private PayrollGNIS buildSutaLocationCode(PayrollUSState _sutaState)
    {
        PayrollGNIS locationCodeSuta;

        // locationCodeSuta should be of the format 'xx-00-000', where xx is the state. When the enum is a single digit integer value, it needs to padded with a leading "0"
        if (_sutaState < 10)
        {
            locationCodeSuta = '0' + int2str(_sutaState) + '-000-0000';
        }
        else
        {
            locationCodeSuta = int2str(_sutaState) + '-000-0000';
        }

        return locationCodeSuta;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Invokes the tax calculation process and retrieves the results.
    /// </summary>
    public void calculate()
    {
        calculatedTaxesList = PayrollTaxEngineUtil::getTaxCalcListFromTaxEngine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGrossUp</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the additional grossed-up earnings needed to have
    ///     a net pay statement amount equal to the amount specified on the gross-up
    ///     earning codes and writes the adjustment earnings lines.
    /// </summary>
    /// <param name="_grossEarnings">
    ///     The gross earnings created thus far for the pay statement.
    /// </param>
    /// <returns>
    ///     The amount of additional earnings added by the gross-up process.
    /// </returns>
    /// <remarks>
    ///     The current restrictions on gross-up pay statements are that they can
    ///     only process Supplemental earning codes that are marked for gross-up
    ///     and only process for a single worker tax region.
    /// </remarks>
    public PayrollStatementAccountingCurrencyAmount createGrossUp(PayrollStatementAccountingCurrencyAmount _grossEarnings)
    {
        this.setUnemployment();

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the <c>PayrollPayStatementTaxLine</c> records and the corresponding
    ///     <c>PRLUSTaxTransactionHistory</c> records for the payment based on the
    ///     calculated tax results returned by the tax engine.
    /// </summary>
    /// <param name="_accountingDistributionTemplatePositiveRecId">
    ///     The value of the record ID of the accounting distribution template based on positive earning lines.
    /// </param>
    /// <param name="_accountingDistributionTemplateNegativeRecId">
    ///     The value of the record ID of the accounting distribution template based on negative earning lines.
    /// </param>
    /// <param name="_templatePositiveRecIdMap">
    ///     A map containing each accounting distribution template line RecId and
    ///     it's corresponding project information based on positive earning lines.
    /// </param>
    /// <param name="_templateNegativeRecIdMap">
    ///     A map containing each accounting distribution template line RecId and
    ///     it's corresponding project information based on negative earning lines.
    /// </param>
    public void createLines(
        AccountingDistributionTemplateRecId _accountingDistributionTemplatePositiveRecId,
        AccountingDistributionTemplateRecId _accountingDistributionTemplateNegativeRecId,
        Map                                 _templatePositiveRecIdMap,
        Map                                 _templateNegativeRecIdMap
    )
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFullyQualifiedStateLocationCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a fully-qualified GNIS location code for the state of the specified
    /// location code.
    /// </summary>
    /// <param name="_stateLocationCode">
    /// A GNIS location code that only specifies the state portion, such as what is
    /// retrieved from the list of applicable taxes for a worker.
    /// </param>
    /// <returns>
    /// A fully-qualified GNIS location for the specified state.
    /// </returns>
    private str getFullyQualifiedStateLocationCode(str _stateLocationCode)
    {
        str stateGNISSubstring;
        str locationCode = _stateLocationCode;

        // Gross-up pay runs already have a fully-qualified location code
        if (payStatement.PaymentType == PayrollPaymentType::GrossUp)
        {
            return _stateLocationCode;
        }

        // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
        stateGNISSubstring = subStr(_stateLocationCode, 1, 2);
        if (stateSingleLocationsMap.exists(stateGNISSubstring))
        {
            // Get the fully-qualified GNIS location for the specified state
            locationCode = stateSingleLocationsMap.lookup(stateGNISSubstring);
        }

        return locationCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the <c>PRLUSTaxTransactionHistory</c> records for the specified
    ///     TaxCalculation returned by the tax engine.
    /// </summary>
    /// <param name="_taxCalculation">
    ///     An instance of the tax calculation engine.
    /// </param>
    public void createTaxHistory()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposeTaxEngine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Disposes the internal instances of the tax engine.
    /// </summary>
    /// <remarks>
    ///     Use this method once all processing has been done and the <c>PayrollCalculatePayStatementTaxes</c>
    ///     class is no longer needed.
    /// </remarks>
    public void disposeTaxEngine()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDeductedTaxTotal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the total of all non-employer taxes calculated for this payment.
    /// </summary>
    /// <returns>
    ///     The non-employer tax total.
    /// </returns>
    public Amount getDeductedTaxTotal()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNoStateIncomeTax</Name>
				<Source><![CDATA[
    private boolean hasNoStateIncomeTax(PayrollGNIS _location)
    {
        return PayrollTaxEngineUtil::hasNoStateIncomeTax(str2int(subStr(_location, 1, 2)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeAllNexus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the tax engine to be aware of which states the company has a
    ///     nexus relationship defined in order to handle reciprocity correctly.
    /// </summary>
    /// <remarks>
    ///     These relationships stay in force for the life of the tax engine instance so
    ///     they need not be set up more than once.
    /// </remarks>
    public void initializeAllNexus()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>PayrollCalculatePayStatementTaxes</c> instance to
    ///     calculate taxes for the specific pay statement header.
    /// </summary>
    /// <param name="_payStatement">
    ///     The pay statement header.
    /// </param>
    public void initializeForPayment(PayrollPayStatement _payStatement)
    {
        PayrollPayPeriod                    payPeriod;
        PayrollPayStatementEarningLine      grossUpEarningLines;
        PayrollWorkerTaxCode                workerTaxCodeSuta;
        PayrollTaxCode                      taxCode;

        permission.assert();

        payStatement = _payStatement;
        paymentType  = _payStatement.PaymentType;
        paymentDate  = _payStatement.PaymentDate;
        paymDateTime = DateTimeUtil::newDateTime(_payStatement.PaymentDate, timeMax(), DateTimeUtil::getCompanyTimeZone());

        payPeriod        = PayrollPayPeriod::find(payStatement.PayPeriod);
        payPeriodEndDate = payPeriod.PeriodEndDate;
        worker           = HcmWorker::find(payStatement.Worker);

        currLE           = CompanyInfo::current();

        deductedTaxTotal = 0;
        employeePayStatementPreTaxBenefitsTotal = 0;
        priorSutaState = 0;
        ytdPriorSutaSubjectWages = 0;
        isResidentApplyCourtesyWithholding = false;

        //
        // Initialize the accumulators that are used to back off custom wage type amounts from unemployment wages.
        // The tax engine will include these custom wages in unemployment wages by default.
        //
        nonProductiveAccumulatedWages = 0;
        nonProductiveAccumulatedHours = 0;
        userDefinedAccumulatedWages = 0;
        userDefinedAccumulatedHours = 0;

        // This instance is used to update the tax engine with tax specific settings.
        taxTypeInit = PayrollTaxTypeInitialization::construct(payStatement);

        // Retrieve the SUTA info up front since it is needed throughout the process
        select firstonly * from workerTaxCodeSuta
            where workerTaxCodeSuta.Worker == payStatement.Worker
            join RecId from taxCode
                where taxCode.RecId == workerTaxCodeSuta.PayrollTaxCode
                && taxCode.CountryRegionId == countryRegionId
                && taxCode.Type == PayrollTaxCodeType::ER_SUTA;

        isExemptFromSuta = workerTaxCodeSuta.isExempt(paymentDate);
        sutaState        = workerTaxCodeSuta.getValueForParameter(#SUTASTATE, paymentDate);

        if (_payStatement.PaymentType == PayrollPaymentType::GrossUp)
        {
            select firstonly WorkerTaxRegion from grossUpEarningLines where grossUpEarningLines.PayStatement == _payStatement.RecId;

            grossUpWorkerTaxRegionRecId = grossUpEarningLines.WorkerTaxRegion;
        }

        // Determine the number of pay periods for the worker
        payPeriodsPerYear = PayrollPayPeriod::getPayPeriodNumber(payPeriod.PayCycle);

        if (payrollParameters.EnableLogging)
        {
            // Attempts to delete the log file if one already exists
            PayrollTaxEngineUtil::deleteLogForDocumentNumber(payStatement.DocumentNumber);
        }

        CodeAccessPermission::revertAssert();

        // The key to this map is PayrollWorkerTaxRegion.RecId, and the value the PayrollTaxRegionForSymmetry.GNIS that it corresponds to
        workerTaxRegionsMap = new Map(Types::Int64, Types::String);
        this.insertWorkerResidentTaxRegionsToMap();
        this.insertEarningTaxRegionsToMap();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTaxEngine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the tax engine to be used for the tax calculation, as well as the tax engine
    ///     types and variables that will not change during the life of the tax engine instance.
    /// </summary>
    /// <exception cref="Exception::Error">
    ///     An error is thrown if payroll parameter records are missing.
    /// </exception>
    public void initializeTaxEngine()
    {
        str                                 applyRetirementannualWageLimit;

        const int ImputedIncomeType = 13;
        const int FicaSubjectWagesOptionType = 26;

        permission       = new InteropPermission(InteropKind::ClrInterop);
        permission.assert();

        countryRegionId = LogisticsAddressCountryRegion::findByISOCode(#isoUS).CountryRegionId;
        // The key to this map is the tax group ID, and the value the enum value of the Symmetry.TaxEngine.WageType that it corresponds to
        customWageTypeMap = new Map(Types::String, Types::Integer);

        payrollParameters = PayrollParameters::find();
        if (payrollParameters.ApplyGroupTermLife)
        {
            const int GtlFITOptionType = 36;
        }

        //
        // Update the tax engine with the ApplyRetirementAnnualWageLimit setting so that it will recognize the
        // retirement annual wage limit exemption when reporting subject wage info to tax history.
        //
        payrollParameters = PayrollParameters::find();
        if (payrollParameters.ApplyRetirementAnnualWageLimit)
        {
            applyRetirementannualWageLimit = #TRUE;
        }
        else
        {
            applyRetirementannualWageLimit = #FALSE;
        }

        this.initializeAllNexus();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEarningTaxRegionsToMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates a map of <c>PayrollWorkerTaxRegion</c> record identifiers from the <c>PayrollPayStatementEarningLine</c>
    ///     records for the year of the current pay statement.
    /// </summary>
    private void insertEarningTaxRegionsToMap()
    {
        PayrollPayStatementEarningLine  payStatementEarningLine;
        PayrollPayStatement             payrollPayStatement;
        PayrollWorkerTaxRegion          workerTaxRegion;
        PayrollTaxRegionForSymmetry     payrollTaxRegionForSymmetry;

        date yearStart = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), paymentDate);
        date yearEnd = DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), paymentDate);

        while select payStatementEarningLine
            join payrollPayStatement
                group by workerTaxRegion.RecId, payrollTaxRegionForSymmetry.GNIS
                where payStatementEarningLine.PayStatement == payrollPayStatement.RecId
                    && payrollPayStatement.Worker == payStatement.Worker
                    && payrollPayStatement.PaymentDate >= yearStart
                    && payrollPayStatement.PaymentDate <= yearEnd
            join RecId from workerTaxRegion
                where workerTaxRegion.RecId == payStatementEarningLine.WorkerTaxRegion
            join GNIS from payrollTaxRegionForSymmetry
                where payrollTaxRegionForSymmetry.TaxRegion == workerTaxRegion.TaxRegion
        {
            if (!workerTaxRegionsMap.exists(workerTaxRegion.RecId))
            {
                workerTaxRegionsMap.insert(workerTaxRegion.RecId, payrollTaxRegionForSymmetry.GNIS);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkerResidentTaxRegionsToMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Populates a map of <c>PayrollWorkerTaxRegion</c> record identifiers corresponding
    ///     to the worker's residency for year of the current pay statement.
    /// </summary>
    private void insertWorkerResidentTaxRegionsToMap()
    {
        PayrollWorkerTaxRegion          workerTaxRegion;
        PayrollWorkerResidentTaxRegion  workerResidentTaxRegion;
        PayrollTaxRegionForSymmetry     payrollTaxRegionForSymmetry;

        date yearStart = DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), paymentDate);
        date yearEnd = DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), paymentDate);

        // Loop through the worker's resident tax regions
        while select validTimeState(yearStart, yearEnd) WorkerTaxRegion from workerResidentTaxRegion
            where workerResidentTaxRegion.Worker == worker.RecId
            join RecId, TaxRegion from workerTaxRegion
                where workerTaxRegion.RecId == workerResidentTaxRegion.WorkerTaxRegion
            join GNIS from payrollTaxRegionForSymmetry
                where payrollTaxRegionForSymmetry.TaxRegion == workerTaxRegion.TaxRegion
        {
            if (!workerTaxRegionsMap.exists(workerTaxRegion.RecId))
            {
                workerTaxRegionsMap.insert(workerTaxRegion.RecId, payrollTaxRegionForSymmetry.GNIS);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isResident</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if it is a resident by comparing the worker's resident tax region with
    ///     the passed-in tax code's inherent location values.
    /// </summary>
    /// <param name="_taxCode">
    ///     The value of the tax code to extract from.
    /// </param>
    /// <param name="_segmentNumber">
    ///     The segment number indicating the level of residency desired: state, county, or city.
    /// </param>
    /// <param name="_residentLocation">
    ///     The worker's resident location to compare with.
    /// </param>
    /// <returns>
    ///     True, if resident; false, otherwise.
    /// </returns>
    public boolean isResident(
        str                     _taxCode,
        PayrollTaxCodeSegment   _segmentNumber,
        str                     _residentLocation)
    {
        str residentLocation;
        str locationFromTaxCode;

        if (Debug::debugMode())
        {
            Debug::assert(_segmentNumber != PayrollTaxCodeSegment::State || _segmentNumber != PayrollTaxCodeSegment::County || _segmentNumber!= PayrollTaxCodeSegment::City);
        }

        // The segments to evaluate to determine residency depends on the level of residency desired: state, county, or city.
        switch (_segmentNumber)
        {
            case PayrollTaxCodeSegment::State :
                // The state segment provides the uniqueness needed to determine if resident of the county
                locationFromTaxCode = PayrollTaxEngineUtil::getTaxCodeSegment(_taxCode, _segmentNumber);
                residentLocation = PayrollTaxEngineUtil::getTaxCodeSegment(_residentLocation, _segmentNumber);
                break;

            case PayrollTaxCodeSegment::County :
                // The state/county combination provides the uniqueness needed to determine if resident of the county
                locationFromTaxCode = PayrollTaxEngineUtil::getTaxCodeSegment(_taxCode, PayrollTaxCodeSegment::State) + PayrollTaxEngineUtil::getTaxCodeSegment(_taxCode, PayrollTaxCodeSegment::County);
                residentLocation = PayrollTaxEngineUtil::getTaxCodeSegment(_residentLocation, PayrollTaxCodeSegment::State) + PayrollTaxEngineUtil::getTaxCodeSegment(_residentLocation, PayrollTaxCodeSegment::County);
                break;

            case PayrollTaxCodeSegment::City :
                // The state/city combination provides the uniqueness needed to determine if resident of the city
                locationFromTaxCode = PayrollTaxEngineUtil::getTaxCodeSegment(_taxCode, PayrollTaxCodeSegment::State) + PayrollTaxEngineUtil::getTaxCodeSegment(_taxCode, PayrollTaxCodeSegment::City);
                residentLocation = PayrollTaxEngineUtil::getTaxCodeSegment(_residentLocation, PayrollTaxCodeSegment::State) + PayrollTaxEngineUtil::getTaxCodeSegment(_residentLocation, PayrollTaxCodeSegment::City);
                break;
        }

        // Return the result of whether or not the two values match
        return (locationFromTaxCode == residentLocation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isResidentByTaxCode</Name>
				<Source><![CDATA[
    private boolean isResidentByTaxCode(boolean isResidentState, boolean isResidentCounty, str taxCodeID)
    {
        return isResidentState && isResidentCounty
                        && ((PayrollTaxEngineUtil::getTaxCodeSegment(taxCodeID, PayrollTaxCodeSegment::City) == residentWorkerTaxRegionSym.MunicipalityId)
                        && (PayrollTaxEngineUtil::getTaxCodeSegment(taxCodeID, PayrollTaxCodeSegment::TaxCodeTypeModifier) == residentWorkerTaxRegionSym.SchoolDistrictId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBenefitsWageImpact</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Communicates the gross wage impacting benefits to the tax engine to
    ///     consider for its calculations
    /// </summary>
    public void setBenefitsWageImpact()
    {
        PayrollPayStatement                 payStatementBuffer;
        PayrollPayStatement                 payStatementTmp;
        PayrollPayStatementBenefitLine      benefitLine;
        PayrollBenefitTaxRule_US            benefitTaxRuleUS;
        HcmWorker                           hcmWorker;
        HcmBenefit                          hcmBenefit;
        HcmBenefitPlan                      hcmBenefitPlan;
        HcmBenefitOption                    hcmBenefitOption;
        HcmWorkerEnrolledBenefit            hcmWorkerEnrolledBenefit;
        PayrollWorkerEnrolledBenefitDetail  payrollWorkerEnrolledBenefitDetail;
        Amount                              employeeBenefitAmt,
                                            employeeBenefitAmtCurrentYear,
                                            employerBenefitAmt,
                                            employerBenefitAmtCurrentYear;

        permission.assert();

        //
        // Find all benefits for the current pay statement's calendar year and for the pay statement's
        // worker in order to send each benefit wage impact for taxes to the tax engine.
        //

        while select Benefit from benefitLine
            group by benefitLine.Benefit
            where benefitLine.IsMarkedForRemoval == NoYes::No
                join RecId from payStatementBuffer
                    where payStatementBuffer.RecId == benefitLine.PayStatement
                    && payStatementBuffer.Worker == payStatement.Worker
                    && payStatementBuffer.PaymentDate <= DateTimeUtil::getEndOfYearDate(locale, paymentDate)
                    && payStatementBuffer.PaymentDate >= DateTimeUtil::getStartOfYearDate(locale, paymentDate)
        {
            benefitTaxRuleUS = PayrollBenefitTaxRule_US::findByBenefitPlan(HcmBenefit::find(benefitLine.Benefit).BenefitPlan);

            // If the benefit does not impact taxes, don't bother sending it to the tax engine
            if (benefitTaxRuleUS.PreTaxBasis == PayrollPreTaxBasis::None)
            {
                continue;
            }

            hcmWorkerEnrolledBenefit = HcmWorkerEnrolledBenefit::findByWorkerBenefit(
                                        payStatement.Worker, benefitLine.Benefit, paymDateTime);
            payrollWorkerEnrolledBenefitDetail = PayrollWorkerEnrolledBenefitDetail::findByWorkerEnrolledBenefitLegalEntity(
                                                    hcmWorkerEnrolledBenefit.RecId, currLE, paymentDate);

            employeeBenefitAmt            = PayrollPayStatementTotals::calcBenefitTotalForCurrentPayment(
                                                payStatement.RecId, benefitLine.Benefit, false);
            employerBenefitAmt            = PayrollPayStatementTotals::calcBenefitTotalForCurrentPayment(
                                                payStatement.RecId, benefitLine.Benefit, true);
            employeeBenefitAmtCurrentYear = PayrollPayStatementTotals::calcBenefitTotalForCurrentYear(payStatement.RecId,
                                                benefitLine.Benefit, payStatement.Worker, paymentDate, false);
            employerBenefitAmtCurrentYear = PayrollPayStatementTotals::calcBenefitTotalForCurrentYear(payStatement.RecId,
                                                benefitLine.Benefit, payStatement.Worker, paymentDate, true);

            if (employeeBenefitAmtCurrentYear + employeeBenefitAmt < 0 || employerBenefitAmtCurrentYear + employerBenefitAmt < 0)
            {
                select firstonly Worker from payStatementTmp
                    where payStatementTmp.RecId == payStatement.RecId
                join personnelNumber from hcmWorker
                    where hcmWorker.RecId == payStatementTmp.Worker
                join BenefitPlan, BenefitOption from hcmBenefit
                    where hcmBenefit.RecId == benefitLine.Benefit
                join BenefitPlanId from hcmBenefitPlan
                    where hcmBenefitPlan.RecId == hcmBenefit.BenefitPlan
                join BenefitOptionId from hcmBenefitOption
                    where hcmBenefitOption.RecId == hcmBenefit.BenefitOption;

                // Fail the current pay statement generation because taxes might be calculated incorrectly if the YTD benefit amounts are negative.
                throw error(strFmt("@Payroll:ThePayStatementCannotBeCalculatedForWorker1BecauseBenefit23H", hcmWorker.personnelNumber, hcmBenefitPlan.BenefitPlanId, hcmBenefitOption.BenefitOptionId));
            }

            // Keep track of current pay statement pre-tax benefits total
            employeePayStatementPreTaxBenefitsTotal += employeeBenefitAmt;
        }

        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPreviousSutaStateWages</Name>
				<Source><![CDATA[
    private void setPreviousSutaStateWages(PayrollUSState _enumCurrentSutaStateValue, PayrollTaxCodeDetail _taxCodeDetail)
    {
        PayrollUSTaxTransactionHistory      taxTransactionHistorySuta;
        PayrollTaxCode                      taxCodePreviousSutaWages;

        //
        // Since MT, MN, and LA do not accept prior state wage credits, if the current SUTA
        // state is one of those states we should not calculate prior state wages, nor should we
        // if this SUTA tax is specified by the customer to exclude prior state wage credits.
        //
        if (_taxCodeDetail.ExcludePriorStateWages ||
            (      _enumCurrentSutaStateValue == PayrollUSState::LA
                || _enumCurrentSutaStateValue == PayrollUSState::MN
                || _enumCurrentSutaStateValue == PayrollUSState::MT))
        {
            priorSutaState = 0;
            ytdPriorSutaSubjectWages = 0.0;

            return;
        }

        // Identify the most recent prior SUTA state
        select firstOnly TaxationState from taxTransactionHistorySuta
            order by taxTransactionHistorySuta.TransDate desc
            join RecId, Type from taxCodePreviousSutaWages
                where taxCodePreviousSutaWages.RecId == taxTransactionHistorySuta.TaxCode
                && taxCodePreviousSutaWages.Type == PayrollTaxCodeType::ER_SUTA
                && taxTransactionHistorySuta.Worker == payStatement.Worker
                && taxTransactionHistorySuta.TransDate >= DateTimeUtil::getStartOfYearDate(locale, paymentDate)
                && taxTransactionHistorySuta.TransDate < paymentDate
                && taxTransactionHistorySuta.TaxationState != _enumCurrentSutaStateValue;

        // Save off the prior SUTA state to use for writing the tax history record
        priorSutaState = taxTransactionHistorySuta.TaxationState;

        // Calculate the YTD prior Suta wages relative to the current state
        ytdPriorSutaSubjectWages = PayrollPayStatementTotals::calcWageTotalPriorSutaForCurrentYear(payStatement.RecId, payStatement.Worker, paymentDate, enum2Symbol(enumNum(PayrollUSState), _enumCurrentSutaStateValue));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Communicates the tax-specific inputs that the tax engine requires to
    ///     properly calculate all taxes for the worker.
    /// </summary>
    public void setTaxes()
    {
        PayrollWorkerTaxRegionForSymmetry       workerTaxRegionSym;
        PayrollWorkerResidentTaxRegion          workerResidentTaxRegion;
        PayrollWorkerTaxRegionRecId             workerTaxRegionRecId;
        PayrollGNIS                             taxRegionSymGnis;

        workerTaxRegionsMapEnumerator = workerTaxRegionsMap.getEnumerator();

        // Loop through all worker tax regions in the workerTaxRegionsMap
        while (workerTaxRegionsMapEnumerator.moveNext())
        {
            taxRegionSymGnis = workerTaxRegionsMapEnumerator.currentValue();
            workerTaxRegionRecId = workerTaxRegionsMapEnumerator.currentKey();
            //
            // Due to a limitation in the tax engine not supporting reciprocity in gross up pay statements,
            // we can only set methods that apply to the gross-up earnings location, so skip all other locations.
            //
            if (payStatement.PaymentType == PayrollPaymentType::GrossUp && workerTaxRegionRecId != grossUpWorkerTaxRegionRecId)
            {
                continue;
            }

            // Get the records that hold the information needed to specify the locations for which taxes are applicable
            workerTaxRegionSym = PayrollWorkerTaxRegionForSymmetry::findByWorkerTaxRegion(workerTaxRegionRecId);

            // Save off the resident worker tax region
            select firstonly validTimeState(paymentDate) RecId from workerResidentTaxRegion
                where workerResidentTaxRegion.Worker == worker.RecId
                    && workerResidentTaxRegion.WorkerTaxRegion == workerTaxRegionRecId;

            if (workerResidentTaxRegion.RecId)
            {
                residentWorkerTaxRegionSym = workerTaxRegionSym;
                isResidentApplyCourtesyWithholding = workerResidentTaxRegion.IsApplyingCourtesyWithholding;
            }

            // The location code for the set tax calls during a gross-up pay run needs to be fully qualified, so caching this value here for later use
            if (payStatement.PaymentType == PayrollPaymentType::GrossUp)
            {
                grossUpTaxLocation = taxRegionSymGnis;
            }
        }

        this.setTaxMethods();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxMethods</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the applicable taxes and initializes the tax calculating
    ///     instance of the tax engine for each of those taxes.
    /// </summary>
    public void setTaxMethods()
    {
        PayrollTaxEngineTaxCodeForSymmetry      taxEngineTaxCodeSym;
        PayrollWorkerTaxCode                    workerTaxCode;
        PayrollTaxCode                          taxCode;
        PayrollTaxCodeDetail                    taxCodeDetail;
        System.Collections.ArrayList            taxList;
        System.Collections.IEnumerator          taxListIter;
        Amount                                  taxTotalYtd;
        PayrollGNIS                             locationCode;
        str                                     taxCodeID;
        boolean                                 isExempt,
                                                isResidentState = false,
                                                isResidentCounty = false,
                                                isResidentCity = false;

        taxList = PayrollTaxEngineUtil::getTaxCodeListFromTaxEngine();
        taxListIter = taxList.GetEnumerator(); 

        residentTaxLocation = taxTypeInit.getResidentTaxLocation();

        while (taxListIter.MoveNext())
        {
            // Retrieve the current tax code id from the given list of strings
            taxCodeId = taxListIter.get_Current().ToString();

            // If it is a tax that we don't support, skip to the next one
            taxEngineTaxCodeSym = PayrollTaxEngineTaxCodeForSymmetry::findByCodeCountryRegion(
                    taxCodeID,
                    countryRegionId);

            if (!taxEngineTaxCodeSym.RecId)

            {
                continue;
            }

            // Determine if the worker tax code exists, and if not then skip
            workerTaxCode = PayrollWorkerTaxCode::findByTaxCodeWorker(
                taxEngineTaxCodeSym.PayrollTaxCode,
                payStatement.Worker);
            
            if (!workerTaxCode.RecId)
            {
                continue;
            }

            if (payStatement.PaymentType == PayrollPaymentType::GrossUp)
            {
                // Use the grossup location code
                locationCode = grossUpTaxLocation;
            }
            else
            {
                // Get the GNIS location code from the tax code ID itself
                locationCode = PayrollTaxEngineUtil::taxCodeStr2GnisStr(taxCodeId);
            }

            isExempt            = workerTaxCode.isExempt(paymentDate);
            taxTotalYtd         = PayrollPayStatementTotals::calcTaxCodeTotalForCurrentYear(payStatement.RecId,
                                    workerTaxCode.PayrollTaxCode, payStatement.Worker, paymentDate);
            taxCodeDetail       = PayrollTaxCodeDetail::findByPayrollTaxCodeLegalEntity(
                                    workerTaxCode.PayrollTaxCode, currLE, paymentDate);
            taxCode             = PayrollTaxCode::find(taxEngineTaxCodeSym.PayrollTaxCode);

            if (!taxCode.RecId)
            {
                continue;
            }

            //
            // Since this process is driven by the applicable tax codes as returned by the tax engine, and since these codes
            // only have GNIS segments that are applicable to the current tax being processed, some of these residency flags
            // may be set to false even if "logically" they should be true.  For example, an SIT tax will only have the first
            // GNIS segment set since the tax only case about the state value, so there is no harm in the county and city residency
            // flags being false for this iteration, whereas a CITY tax will have the third segment set which allows the isResidentCity
            // flag to be set properly.
            //
            isResidentState     = this.isResident(taxEngineTaxCodeSym.Code, PayrollTaxCodeSegment::State, residentTaxLocation);
            isResidentCounty    = this.isResident(taxEngineTaxCodeSym.Code, PayrollTaxCodeSegment::County, residentTaxLocation);
            isResidentCity      = this.isResident(taxEngineTaxCodeSym.Code, PayrollTaxCodeSegment::City, residentTaxLocation);

            int taxCodeState = str2int(PayrollTaxEngineUtil::getTaxCodeSegment(taxEngineTaxCodeSym.Code, PayrollTaxCodeSegment::State));

            switch (taxCode.Type)
            {
                case PayrollTaxCodeType::CITY:
                    taxTypeInit.setCity(locationCode, isExempt, isResidentCity, workerTaxCode, taxEngineTaxCodeSym.MethodModifier);
                    break;

                case PayrollTaxCodeType::CNTY:
                    taxTypeInit.setCounty(locationCode, isExempt, isResidentCounty);
                    break;

                case PayrollTaxCodeType::EIT:
                    if (taxCodeState == PayrollUSState::PA)
                    {
                        //
                        // For Pennsylvania the tax code segments include municipality and school district values rather than the city portion
                        // of the GNIS code, so we must match against those values of the resident tax region to determine residency for this tax.
                        //
                        isResidentCity = this.isResidentByTaxCode(isResidentState, isResidentCounty, taxCodeID);
                    }

                    taxTypeInit.setEIT(taxCodeId, isExempt, isResidentCity);
                    break;

                case PayrollTaxCodeType::LST:
                    if (taxCodeState == PayrollUSState::PA)
                    {
                        //
                        // For Pennsylvania the tax code segments include municipality and school district values rather than the city portion
                        // of the GNIS code, so we must match against those values of the resident tax region to determine residency for this tax.
                        //
                        isResidentCity = this.isResidentByTaxCode(isResidentState, isResidentCounty, taxCodeID);
                    }

                    taxTypeInit.setEMST(taxCodeId, isExempt, isResidentCity, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::ER_ECET:

                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    taxTypeInit.setEmployerECET(locationCode, taxCodeDetail, taxTotalYtd, isExempt);
                    break;

                case PayrollTaxCodeType::ER_EMACS:
                    taxTypeInit.setEmployerEMACS(locationCode, isExempt, taxCodeDetail, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::ER_SDI:
                    taxTypeInit.setEmployerSDI(locationCode, isExempt, taxCodeDetail, taxEngineTaxCodeSym.MethodModifier, sutaState, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::ER_SDI_WA:
                    taxTypeInit.setEmployerSDIWashington(locationCode, isExempt, workerTaxCode, productiveHoursWA);
                    break;

                case PayrollTaxCodeType::ER_TRANS:
                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    taxTypeInit.setEmployerTransit(locationCode, isExempt, taxCodeId);
                    break;

                case PayrollTaxCodeType::ER_UHI:
                    taxTypeInit.setEmployerUHI(isExempt, taxCodeDetail, sutaState);
                    break;

                case PayrollTaxCodeType::ER_WC:
                    taxTypeInit.setEmployerWC(locationCode, isExempt, taxCodeDetail);

                    if (taxCodeState == PayrollUSState::WY)
                    {
                        taxTypeInit.setStateMiscellaneousParametersForWorkerTaxCode(locationCode, workerTaxCode);
                    }

                    break;

                case PayrollTaxCodeType::FICA:
                    taxTypeInit.setFICA(isExempt);
                    break;

                case PayrollTaxCodeType::FIT:
                    taxTypeInit.setFIT(isExempt, workerTaxCode);
                    break;

                case PayrollTaxCodeType::FLI:

                    // FLI taxes for Washington are handled through different tax engine APIs as of 2019-R1
                    if (taxCodeState != PayrollUSState::WA)
                    {
                        taxTypeInit.setFLI(locationCode, isExempt, taxCodeDetail, taxTotalYtd);
                    }

                    break;

                case PayrollTaxCodeType::ER_FLI:

                    if (taxCodeState == PayrollUSState::WA)
                    {
                        // For Washington FLI taxes as of the 2019-R1 tax update, both employee and employer taxes
                        // are calculated via the same tax engine method called below
                        taxTypeInit.setWashingtonPMFL(taxCodeDetail, taxTotalYtd, isExempt);
                    }
                    else if (taxCodeState == PayrollUSState::MA)
                    {
                        // For Massachussets FLI taxes as of the 2019-R6 tax update, both employee and employer taxes
                        // are calculated via the same tax engine method called below
                        taxTypeInit.setMassachusettsPFML(taxCodeDetail, workerTaxCode, taxTotalYtd, isExempt);
                    }
                    else if (taxCodeState == PayrollUSState::DC)
                    {
                        // Washington DC employer FLI taxes were added with the 2019-R5 update. Although
                        // an employer tax, these taxes are calculated via the employee FLI call to the
                        // tax engine
                        taxTypeInit.setFLI(locationCode, isExempt, taxCodeDetail, taxTotalYtd);
                    }

                    break;

                case PayrollTaxCodeType::HCSF:
                    taxTypeInit.setHCSF(locationCode, isExempt, taxCodeDetail, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::MEDI:
                    taxTypeInit.setMedicare(isExempt);
                    break;

                case PayrollTaxCodeType::MHT:
                    taxTypeInit.setMHT(locationCode, isExempt, isResidentCounty, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::MOT:
                    taxTypeInit.setMOT(locationCode, isExempt, isResidentCity, workerTaxCode);
                    break;

                case PayrollTaxCodeType::OLF:
                    taxTypeInit.setOLF(locationCode, isExempt, isResidentCity, workerTaxCode);
                    break;

                case PayrollTaxCodeType::OLF_County:
                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    taxTypeInit.setOLFCounty(locationCode, isExempt, isResidentCounty, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::OLTS:
                    taxTypeInit.setOLTS(locationCode, isExempt, isResidentCounty, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::SCHL:
                    taxTypeInit.setSCHL(taxCodeId, isExempt);
                    break;

                case PayrollTaxCodeType::SCT:
                    taxTypeInit.setSCT(locationCode, isExempt, isResidentCounty, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::SDI:
                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    // The tax engine will attempt to calculate California SDI taxes on current wages for any employee who has earned wages in CA
                    // throughout the year, regardless of where the current wages were earned or where the employee currently resides. This means
                    // an employee both working and living outside of CA will see the CA SDI tax taken out if they worked in CA earlier that year.
                    // To prevent this from happening, the below check ensures we only make the SDI call if an employee is either a resident of CA
                    // or has earned wages in CA this pay period.
                    if (taxCodeState == PayrollUSState::CA)
                    {
                        if (!isResidentState && !this.doesPayStatementContainEarningsForState(PayrollUSState::CA))
                        {
                            continue;
                        }
                    }

                    taxTypeInit.setSDI(locationCode, isExempt, taxCodeDetail, workerTaxCode, taxEngineTaxCodeSym.MethodModifier, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::SUI:
                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    taxTypeInit.setSUI(locationCode, isExempt, taxCodeDetail, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::TRANS:

                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    taxTypeInit.setStateTransit(locationCode, taxCodeDetail, isResidentState, isResidentApplyCourtesyWithholding, isExempt);
                    break;

                case PayrollTaxCodeType::TT:
                    taxTypeInit.setTT(locationCode, isExempt, isResidentCounty, taxTotalYtd);
                    break;

                case PayrollTaxCodeType::SIT:

                    // The tax code only specifies the state portion, but the tax engine expects a fully qualified location for state methods
                    locationCode = this.getFullyQualifiedStateLocationCode(locationCode);

                    // Due to Pennsylvania's unique tax system, calculation methods should be set for each worker tax region
                    // found in PA to ensure that municipal and other region specific taxes are calculated properly.
                    if (taxCodeState == PayrollUSState::PA)
                    {
                        this.setCalculationMethodsForAllWorkerTaxRegionsInState(workerTaxCode, PayrollUSState::PA);
                    }
                    else
                    {
                        taxTypeInit.setCalculationMethods(locationCode, workerTaxCode);
                    }

                    taxTypeInit.setSIT(locationCode, isExempt, isResidentState, workerTaxCode);
                    break;

                case PayrollTaxCodeType::WC:

                    if (taxCodeState == PayrollUSState::NM)
                    {
                        // New Mexico worker's compensation taxes are handled differently than other WC taxes
                        taxTypeInit.setWCForNewMexico(locationCode, isExempt, taxCodeDetail);
                    }
                    else
                    {
                        taxTypeInit.setWC(locationCode, isExempt, taxCodeDetail, taxEngineTaxCodeSym.MethodModifier);
                    }

                    break;
            }
        }

        if (HcmSharedParameters::find().EnableRailroadTaxes)
        {
            taxTypeInit.setRRTA();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesPayStatementContainEarningsForState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current pay statement contains earnings for a given state.
    /// </summary>
    /// <param name = "_state">The state in which earnings may have occurred.</param>
    /// <returns>true if the pay statement contains earnings for the given state; otherwise, false.</returns>
    private boolean doesPayStatementContainEarningsForState(PayrollUSState _state)
    {
        boolean wereWagesEarnedInGivenStateThisPeriod = false;

        MapEnumerator workerTaxRegionsEnumerator = workerTaxRegionsMap.getEnumerator();

        // Iterate over the worker tax regions for this pay statement
        while (workerTaxRegionsEnumerator.moveNext())
        {
            PayrollWorkerTaxRegionRecId currentWorkerTaxRegionRecId = workerTaxRegionsEnumerator.currentKey();
            str currentWorkerTaxRegionLocationCode = workerTaxRegionsEnumerator.currentValue();

            // Get the tax region state from the tax region location code
            int currentTaxRegionTaxCodeState = str2int(PayrollTaxEngineUtil::getTaxCodeSegment(currentWorkerTaxRegionLocationCode, PayrollTaxCodeSegment::State));
        
            // If the current worker tax region belongs to the given state, check if any earnings exist for the tax region
            if (currentTaxRegionTaxCodeState == _state)
            {
                if (PayrollPayStatementTotals::doesPayStatementContainEarningsForTaxRegion(payStatement.RecId, currentWorkerTaxRegionRecId))
                {
                    wereWagesEarnedInGivenStateThisPeriod = true;
                    break;
                }
            }
        }

        return wereWagesEarnedInGivenStateThisPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCalculationMethodsForAllWorkerTaxRegionsInState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets tax engine calculation methods for each worker tax region belonging to a given state.
    /// </summary>
    /// <param name = "_workerTaxCode">The worker tax code for which calculation methods should be set.</param>
    /// <param name = "_state">The state in which calculation methods should be set.</param>
    private void setCalculationMethodsForAllWorkerTaxRegionsInState(PayrollWorkerTaxCode _workerTaxCode, PayrollUSState _state)
    {
        MapEnumerator workerTaxRegionsEnumerator = workerTaxRegionsMap.getEnumerator();

        // Iterate over the worker tax regions for this pay statement
        while (workerTaxRegionsEnumerator.moveNext())
        {
            PayrollGNIS currentWorkerTaxRegionLocationCode = workerTaxRegionsEnumerator.currentValue();

            // Get the tax region state from the tax region location code
            int currentTaxRegionTaxCodeState = str2int(PayrollTaxEngineUtil::getTaxCodeSegment(currentWorkerTaxRegionLocationCode, PayrollTaxCodeSegment::State));
        
            // If the current worker tax region belongs to the given state, set calculation methods for that location code
            if (currentTaxRegionTaxCodeState == _state)
            {
                taxTypeInit.setCalculationMethods(currentWorkerTaxRegionLocationCode, _workerTaxCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUnemployment</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Specifies the wages to the tax engine that are applicable for
    ///     unemployment taxes.
    /// </summary>
    public void setUnemployment()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkerExemptFromRuia</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current worker tax code is exempt from RUIA or not.
    /// </summary>
    /// <param name = "_workerTaxCodeFederalRuia">
    /// The <c>PayrollWorkerTaxCode</c> table buffer.
    /// </param>
    /// <returns>
    /// True, if worker tax code is exempt from RUIA ; false, otherwise
    /// </returns>
    protected boolean isWorkerExemptFromRuia(PayrollWorkerTaxCode _workerTaxCodeFederalRuia)
    {
        boolean isExemptFromRuia = true;

        if (_workerTaxCodeFederalRuia)
        {
            HcmSharedParameters sharedParameters = HcmSharedParameters::find();
            isExemptFromRuia = (!sharedParameters.EnableRailroadTaxes || _workerTaxCodeFederalRuia.isExempt(paymentDate));
        }

        return isExemptFromRuia;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayrollWorkerTaxCodeRuia</Name>
				<Source><![CDATA[
    private PayrollWorkerTaxCode getPayrollWorkerTaxCodeRuia()
    {
        PayrollWorkerTaxCode workerTaxCode;
        PayrollTaxCode taxCode;

        select * from workerTaxCode
            where workerTaxCode.Worker == payStatement.Worker
            join RecId from taxCode
                where taxCode.RecId == workerTaxCode.PayrollTaxCode
                && taxCode.CountryRegionId == countryRegionId
                && taxCode.Type == PayrollTaxCodeType::ER_RUIA;

        return workerTaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWages</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Specifies the wages to the tax engine to calculate the current payment.
    /// </summary>
    public void setWages()
    {
        this.setWagesFederal();
        this.setWagesTaxRegion();
        this.setWagesCustom();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWagesFederal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Specifies the wages to the tax engine that are applicable for federal
    ///     taxes.
    /// </summary>
    public void setWagesFederal()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWagesTaxRegion</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Specifies the wages to the tax engine that are applicable for each of
    ///     the worker's tax regions.
    /// </summary>
    public void setWagesTaxRegion()
    {
        Amount                                  locWagesRegular,
                                                locWagesSupplemental,
                                                locWagesGtlRegular,
                                                locWagesGtlSupplemental,
                                                locHoursRegular,
                                                locHoursSupplemental,
                                                locNormalWagesRegular,
                                                locNormalWagesSupplemental,
                                                locNormalHoursRegular,
                                                locNormalHoursSupplemental,
                                                locCustomWagesRegular,
                                                locCustomWagesSupplemental,
                                                locCustomHoursRegular,
                                                locCustomHoursSupplemental,
                                                ytdLocWagesRegular,
                                                ytdLocWagesSupplemental,
                                                ytdLocWagesGtlRegular,
                                                ytdLocWagesGtlSupplemental,
                                                qtdLocWagesRegular,
                                                qtdLocWagesSupplemental,
                                                mtdLocWagesRegular,
                                                mtdLocWagesSupplemental;
        str                                     locationCode,
                                                stateGNISSubstring,
                                                residentStateGNISSubstring;
        int                                     state;
        boolean                                 isResidentState;
        PayrollWorkerTaxRegionRecId             workerTaxRegionRecId;

        permission.assert();

        // The key to this map is the two-character state portion of a GNIS code, and the value is a corresponding full GNIS code
        stateSingleLocationsMap = new Map(Types::String, Types::String);

        // We should not be setting wages if it is a GrossUp pay run
        if (paymentType == PayrollPaymentType::GrossUp)
        {
            return;
        }

        residentTaxLocation = taxTypeInit.getResidentTaxLocation();
        residentStateGNISSubstring = PayrollTaxEngineUtil::getTaxCodeSegment(residentTaxLocation, PayrollTaxCodeSegment::State);

        workerTaxRegionsMapEnumerator = workerTaxRegionsMap.getEnumerator();

        // Process each worker tax region in worker tax regions map
        while (workerTaxRegionsMapEnumerator.moveNext())
        {
            workerTaxRegionRecId = workerTaxRegionsMapEnumerator.currentKey();

            // Use a local variable for location code for readability
            locationCode = workerTaxRegionsMapEnumerator.currentValue();

            stateGNISSubstring = PayrollTaxEngineUtil::getTaxCodeSegment(locationCode, PayrollTaxCodeSegment::State);
            state = str2int(stateGNISSubstring);

            // For each state, make sure a single fully-qualified location code is saved off to be used for state-level method calls to ensure the tax engine functions properly
            if (!stateSingleLocationsMap.exists(stateGNISSubstring))
            {
                stateSingleLocationsMap.insert(stateGNISSubstring, locationCode);

                // Ensure that non-SIT states have their residency and other parameters set
                if (this.hasNoStateIncomeTax(locationCode))
                {
                    isResidentState = (stateGNISSubstring == residentStateGNISSubstring);
                }
            }

            //Switch statement to handle special earnings splits for state specific cases
            switch (state)
            {
                //
                // If an Oregon or WA location, then ProductiveBasis needs to be taken
                // into account for setting hours (and wages, for completeness)
                //
                case PayrollUSState::OR:
                case PayrollUSState::WA:

                    // Calculate current productive and non-productive-payment wages and hours for this location
                    [locNormalWagesRegular, locNormalHoursRegular, locCustomWagesRegular, locCustomHoursRegular] =
                        PayrollPayStatementTotals::calcProductiveWageTotalForPayment(payStatement.RecId, PayrollTaxMethod::Regular, workerTaxRegionRecId);

                    [locNormalWagesSupplemental, locNormalHoursSupplemental, locCustomWagesSupplemental, locCustomHoursSupplemental] =
                        PayrollPayStatementTotals::calcProductiveWageTotalForPayment(payStatement.RecId, PayrollTaxMethod::Supplemental, workerTaxRegionRecId);
      
                    // Keep a running total of custom wages for this employee to back off of the total unemployment amounts since
                    // the custome wage type setWages() call also adds them into SUTA wages.
                    
                    nonProductiveAccumulatedWages = nonProductiveAccumulatedWages + locCustomWagesRegular;
                    nonProductiveAccumulatedHours = nonProductiveAccumulatedHours + locCustomHoursRegular;

                    // Adjust the regular wages for the normal set wages call to only be non-custom wage type
                    locWagesRegular = locNormalWagesRegular;
                    locHoursRegular = locNormalHoursRegular;

                    // Since these custom wage types aren't taken into account for any taxes so far for Supplemental earnings, they are combined as usual
                    locWagesSupplemental = locNormalWagesSupplemental + locCustomWagesSupplemental;
                    locHoursSupplemental = locNormalHoursSupplemental + locCustomHoursSupplemental;

                    // Washington Employer SDI needs to know the productive hours specifically
                    if (state == PayrollUSState::WA)
                    {
                        productiveHoursWA += locNormalHoursSupplemental + locNormalHoursRegular;
                    }

                    break;

                 
                default:
                    // Calculate current payment wages and hours for this location
                    [locWagesRegular, locHoursRegular] =
                        PayrollPayStatementTotals::calcWageTotalForPayment(payStatement.RecId, PayrollTaxMethod::Regular, workerTaxRegionRecId);
                    [locWagesSupplemental, locHoursSupplemental] =
                        PayrollPayStatementTotals::calcWageTotalForPayment(payStatement.RecId, PayrollTaxMethod::Supplemental, workerTaxRegionRecId);
                    break;
            }

            [locWagesGtlRegular] = PayrollPayStatementTotals::calcGtlWageTotalForPayment(
                                        payStatement.RecId,
                                        PayrollTaxMethod::Regular,
                                        workerTaxRegionRecId);

            [locWagesGtlSupplemental] = PayrollPayStatementTotals::calcGtlWageTotalForPayment(
                                            payStatement.RecId,
                                            PayrollTaxMethod::Supplemental,
                                            workerTaxRegionRecId);
        }

        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setWagesCustom</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the specifying of wages to the tax engine that have user-defined
    ///     tax applicability.
    /// </summary>
    /// <remarks>
    ///     Wages based on earning codes that have an associated custom tax group
    ///     will not be applicable to any taxes defined by that tax group.
    /// </remarks>
    public void setWagesCustom()
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>