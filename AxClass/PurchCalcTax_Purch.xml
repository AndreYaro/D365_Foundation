<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchCalcTax_Purch</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class PurchCalcTax_Purch extends PurchCalcTax
{
    QueryRun                queryTransact;
    PurchTable              purchTable;
    PurchLine               prevPurchLine;
    VendInvoiceJour         lineVendInvoiceJour;
    InventRefTransId        lastInventRefTransId;
    TransDate               lineTaxCalculationDate;
    boolean                 lineTaxCalculationDateCached;
    SourceDocumentHeader    sourceDocumentHeader;
    boolean                 isPurchaseOrderInProcessAndWasPreviouslyConfirmed;
    boolean                 isPurchaseOrderInProcessAndWasPreviouslyConfirmedSet;
    int                     numberOfTaxLines;
    private boolean         headerChargeExists, headerChargeChecked;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>assessableValue_IN</Name>
				<Source><![CDATA[
    public AmountCur assessableValue_IN()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetICMSReceivableLongTerm_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>ICMS</c> asset is receivable long term.
    /// </summary>
    /// <returns>
    /// true if the <c>ICMS</c> asset is receivable long term; otherwise, false.
    /// </returns>
    public boolean assetICMSReceivableLongTerm_BR()
    {
        return purchLine.ICMSReceivableLongTerm_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetPISCOFINSReceivableLongTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>PISCONFINS</c> asset is receivable long term.
    /// </summary>
    /// <returns>
    /// true if the <c>PISCOFINS</c> asset is receivable long term; otherwise, false.
    /// </returns>
    public boolean assetPISCOFINSReceivableLongTerm()
    {
        return purchLine.PISCOFINSReceivableLongTerm_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfTaxLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of tax lines for purchase order lines included in tax calculation and related charges.
    /// </summary>
    /// <returns>The number of tax lines.</returns>
    internal int getNumberOfTaxLines()
    {
        return numberOfTaxLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the base amount.
    /// </summary>
    /// <param name="_rounded">
    /// If 'True', the amount is rounded.
    /// </param>
    /// <returns>
    /// The instance of the <c>AmountCur</c> class.
    /// </returns>
    public AmountCur baseAmount_IN(boolean _rounded = true)
    {
        AmountCur amountCur;

        if (TaxParameters::checkVatExciseParameters_IN())
        {
            amountCur = purchLine.calcLineAmountExclTax(this.destructiveQty_IN(), this.invoiceDate(), tax);

            if (this.endDisc() && purchLine.endDisc())
            {
                if (!_rounded)
                {
                    amountCur = CurrencyExchangeHelper::amount(amountCur, this.currencyCode()) * this.endDisc() / 100;
                }
                else
                {
                    amountCur = amountCur * this.endDisc() / 100;
                }
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>baseAmountInclTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets base amount in tax.
    /// </summary>
    /// <returns>
    /// The instance of the <c>AmountCur</c> class.
    /// </returns>
    public AmountCur baseAmountInclTax_IN()
    {
        AmountCur amountCur;

        if (TaxParameters::checkVatExciseParameters_IN())
        {
            amountCur = purchLine.calcLineAmount(this.destructiveQty_IN());

            if (this.endDisc() && purchLine.endDisc())
            {
                amountCur = amountCur * this.endDisc() / 100;
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseWorkflowTaxCalculationWithNonMaintainMode</Name>
				<Source><![CDATA[
    private boolean isPurchaseWorkflowTaxCalculationWithNonMaintainMode()
    {
        PurchaseWorkflowPurchTotalsCalcContext purchaseWorkflowPurchTotalsCalcContext = PurchaseWorkflowPurchTotalsCalcContext::current();

        return purchaseWorkflowPurchTotalsCalcContext != null
            && purchaseWorkflowPurchTotalsCalcContext.parmIsPurchTotalsCalculation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the tax amount.
    /// </summary>
    /// <param name="_purchTotals">
    ///    An instance of the <c>PurchTotals</c> class that is used to obtain totals.
    /// </param>
    /// <returns>
    ///    The tax amount.
    /// </returns>
    [Replaceable]
    TaxAmountCur calcTax(TradeTotalsBase    _purchTotals)
    {
        TaxCalculation  taxCalculation;
        boolean         loadTaxUncommitted;
        boolean         loadTaxTrans;

        AmountCur       amountCur;

        boolean         maintainTaxUncommitted;

        purchTotals         = _purchTotals as PurchTotals;

        if (this.useTaxUncommitted())
        {
            maintainTaxUncommitted = !this.isPurchaseWorkflowTaxCalculationWithNonMaintainMode() && this.maintainTaxUncommitted();

            if (this is PurchCalcTax_PackingSlip && this.headingRecID())
            {
                loadTaxUncommitted = false;
            }
            else
            {
                if (purchTable.DocumentState == VersioningDocumentState::Confirmed || !maintainTaxUncommitted)
                {
                    loadTaxUncommitted = TaxUncommitted::existByDocumentId(this.headingTableID(), this.headingRecID());
                }
                else if (purchTable.recalculateTaxForChangedLineOnly() || this.useOnlyEditedLinesForTaxCalc())
                {
                    if (this.canRecalculateTax())
                    {
                        // Calculate tax for the batch of new or modified lines.
                        taxCalculation  = TaxCalculation::newForSourceTypeWithTaxUncommitted(TaxSourceType::PurchaseOrder, this, false, false, true);
                        // Update TaxUncommitted for new or modified lines and header misc. charges.
                        taxCalculation.parmSkipLineMarkup(skipLineMarkup);
                        taxCalculation.calculateTax();

                        // Reset the order balances used in the above calculations in case the variable is reused below.
                        this.resetOrderBalances();
                    }

                    // Below the just created TaxUncommitted records will be loaded and the tax amount will be retrieved.
                    loadTaxUncommitted = true;
                }

                if (! loadTaxUncommitted)
                {
                    // check to see if the TaxUncommitted have already been posted to TaxTrans
                    loadTaxTrans = this.loadTaxTrans();
                }
            }

            loadFromTaxUncommitted = loadTaxUncommitted;
            loadFromTaxTrans = loadTaxTrans;

            if (salesTaxDetailIsNotNeeded)
            {
                if (!loadTaxUncommitted && !loadTaxTrans)
                {
                    taxCalculation  = TaxCalculation::newForSourceTypeWithTaxUncommitted(TaxSourceType::PurchaseOrder, this, loadTaxUncommitted, loadTaxTrans, maintainTaxUncommitted);
                    taxCalculation.parmSkipLineMarkup(skipLineMarkup);

                    if (this.canRecalculateTax())
                    {
                        amountCur = taxCalculation.calculateTax();
                    }

                    salesTaxDetailIsNotNeeded = false;
                }
                else if (loadTaxUncommitted)
                {
                    taxCalculation  = TaxCalculation::newForSourceType(TaxSourceType::PurchaseOrder, this);
                    
                    amountCur = TaxUncommitted::totalTaxAmountFromTaxUncommitted(this.headingTableID(), this.headingRecID(), taxCalculation.parmTaxModuleType());
                }
                else if (loadTaxTrans)
                {
                    taxCalculation  = TaxCalculation::newForSourceType(TaxSourceType::PurchaseOrder, this);

                    amountCur = TaxTrans::totalTaxAmountFromTaxTrans(this.headingTableSourceDocumentRecId());
                }
            }
            else
            {
                taxCalculation  = TaxCalculation::newForSourceTypeWithTaxUncommitted(TaxSourceType::PurchaseOrder, this, loadTaxUncommitted, loadTaxTrans, maintainTaxUncommitted);
                taxCalculation.parmSkipLineMarkup(skipLineMarkup);
                if (!loadTaxUncommitted && !loadTaxTrans)
                {
                    if (this.canRecalculateTax())
                    {
                        amountCur       = taxCalculation.calculateTax();
                        if (amountCur && this.source.tableId == tableNum(VendInvoiceInfoTable))
                        {
                            TaxUseTaxAssessmentUtil::adjustSalesTaxFromVendorChargedSalesTax(VendInvoiceInfoTable::findRecId(this.source.RecId), taxCalculation);
                        }
                    }
                }
                else
                {
                    amountCur       = taxCalculation.totalTaxAmount();
                }
            }
        }
        else
        {
            taxCalculation  = TaxCalculation::newForSourceType(TaxSourceType::PurchaseOrder, this);
            taxCalculation.parmSkipLineMarkup(skipLineMarkup);
            amountCur = taxCalculation.calculateTax();
        }

        this.tax(taxCalculation);

        numberOfTaxLines = taxCalculation.getNumberOfInsertedTaxLines();

        if (!TaxIntegrationNumberSequenceInDataPersistencePurchFlight::instance().isEnabled()
           && TaxIntegrationUtils::isMultipleTaxIdEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Purchase))
        {
            // When <c> TaxIntegrationNumberSequenceInDataPersistencePurchFlight </c> is enabled,
            // The logic for number sequence update will move from <c> PurchCalcTax_Purch </c> to <c> TaxIntegrationPurchTableDataPersistence </c> and <c> TaxIntegrationVendInvoiceInfoTableDataPersistence </c>.
            // We should remove method updatePONumberSequenceGroupId when remove flight <c> TaxIntegrationNumberSequenceInDataPersistencePurchFlight </c>.
            this.updatePONumberSequenceGroupId();
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePONumberSequenceGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Updates Purchase order or Pending invoice journal's number sequence group according to TaxId
    /// </summary>
    private void updatePONumberSequenceGroupId()
    {
        TaxRegistration taxRegistration;
        TmpTaxWorkTrans tmpTaxTrans;
        tmpTaxTrans.setTmpData(this.tax().tmpTaxWorkTrans());

        select firstonly TaxId from tmpTaxTrans
            where tmpTaxTrans.HeadingTableId == this.source.TableId
                && tmpTaxTrans.HeadingRecId == this.source.RecId
            join NumberSequenceGroupId from taxRegistration
                where taxRegistration.RecId == tmpTaxTrans.TaxId;

        if (taxRegistration.NumberSequenceGroupId != '')
        {
            VendInvoiceInfoTable vendInvoiceInfoTable;
            boolean isNonPO = false;

            if (this.source.tableId == tableNum(VendInvoiceInfoTable))
            {
                vendInvoiceInfoTable = VendInvoiceInfoTable::findRecId(this.source.RecId);
                isNonPO = vendInvoiceInfoTable.isNonPO();

                if (isNonPO)
                {
                    vendInvoiceInfoTable = VendInvoiceInfoTable::findRecId(this.source.RecId);
                    if (vendInvoiceInfoTable && taxRegistration.NumberSequenceGroupId != vendInvoiceInfoTable.NumberSequenceGroup)
                    {
                        ttsbegin;
                        vendInvoiceInfoTable.selectForUpdate(true);
                        vendInvoiceInfoTable.NumberSequenceGroup = taxRegistration.NumberSequenceGroupId;
                        vendInvoiceInfoTable.doUpdate();
                        ttscommit;
                    }
                }
            }

            if (!isNonPO)
            {
                PurchTable purchOrderTable;
                if (this.source.tableId == tableNum(PurchTable))
                {
                    purchOrderTable = PurchTable::findRecId(this.source.RecId);
                }
                else
                {
                    purchOrderTable = PurchTable::find(vendInvoiceInfoTable.PurchId);
                }

                if (purchOrderTable && taxRegistration.NumberSequenceGroupId != purchOrderTable.NumberSequenceGroup)
                {
                    ttsbegin;
                    purchOrderTable.selectForUpdate(true);
                    purchOrderTable.NumberSequenceGroup = taxRegistration.NumberSequenceGroupId;
                    purchOrderTable.doUpdate();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWithholdTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withhold taxes for Purchase order lines.
    /// </summary>
    /// <param name="_purchTotals">
    /// The PurchTotals class instance.
    /// </param>
    /// <returns>
    /// Returns withhold taxes for Purchase order lines.
    /// </returns>
    public TaxAmountCur calcWithholdTax_IN(TradeTotalsBase _purchTotals)
    {
        TaxWithholdCalcPurch_IN taxWithholdCalcPurch;
        boolean                 loadTaxWHTUncommitted;
        boolean                 loadTaxWHTTrans;
        AmountCur               taxWithholdAmountCur;

        purchTotals         = _purchTotals as PurchTotals;

        if (this.useTaxWithholdUncommitted_IN())
        {
            if (this is PurchCalcTax_PackingSlip && this.headingRecID())
            {
                loadTaxWHTUncommitted = false;
            }
            else
            {
                if (purchTable.DocumentState == VersioningDocumentState::Confirmed || !this.maintainTaxWithholdUncommitted_IN())
                {
                    loadTaxWHTUncommitted = TaxWithholdUncommitted_IN::existByDocumentId(this.headingTableID(), this.headingRecID());
                    if (loadTaxWHTUncommitted 
                        && !TaxWithholdParameters_IN::find().DisableThresholdCumulativeTracking)
                    {
                        loadTaxWHTUncommitted = !TaxWHTThresholdCumulativeChangeTracking_IN::determineCumulativeChanged(
                            this.headingTableID(),
                            this.headingRecID());
                    }
                }
                if (! loadTaxWHTUncommitted)
                {
                    // check to see if the TaxWithholdUncommitted_IN have already been posted to TaxWithholdTrans_IN
                    loadTaxWHTTrans = this.loadTaxWithholdTrans_IN();
                }
            }

            taxWithholdCalcPurch = TaxWithholdCalculation_IN::newForSourceTypeWithTaxUncommitted(
                TaxSourceType::PurchaseOrder,
                this,
                loadTaxWHTUncommitted,
                loadTaxWHTTrans,
                this.maintainTaxUncommitted());

            if (!loadTaxWHTUncommitted && !loadTaxWHTTrans)
            {
                taxWithholdAmountCur = taxWithholdCalcPurch.calculateTax();
            }
            else
            {
                taxWithholdAmountCur = taxWithholdCalcPurch.totalTaxWithholdAmount();
            }
        }
        else
        {
            taxWithholdCalcPurch = TaxWithholdCalculation_IN::newForSourceType(TaxSourceType::PurchaseOrder, this);
            taxWithholdAmountCur = taxWithholdCalcPurch.calculateTax();
        }

        this.taxWithholdCalculation_IN(taxWithholdCalcPurch);

        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcWithholdTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates withhold taxes for Purchase order.
    /// </summary>
    /// <param name = "_purchTotals">The PurchTotals class instance.</param>
    /// <returns>Returns withhold taxes for Purchase order.</returns>
    internal TaxAmountCur calcWithholdTax(TradeTotalsBase _purchTotals)
    {
        AmountCur taxWithholdAmountCur;
        TaxWithholdCalcPurch taxWithholdCalcPurch;

        PurchTotals purchTotalsLoc = _purchTotals as PurchTotals;

        taxWithholdCalcPurch = purchTotalsLoc.taxWithholdCalculation();
        taxWithholdCalcPurch.parmEndDiscPercent(this.endDisc());

        if (this.useTaxUncommitted())
        {
            RefTableId headingTableId = this.headingTableID();
            RefRecId headingRecId = this.headingRecID();

            if (TaxWithholdUncommitted::isTaxWithholdUncommittedExisted(headingTableId, headingRecId))
            {
                taxWithholdAmountCur = TaxWithholdUncommitted::taxWithholdTotal(headingTableId, headingRecId);
            }
            else
            {
                taxWithholdCalcPurch.parmDoGenerateWHTUncommitted(true);
                taxWithholdAmountCur = taxWithholdCalcPurch.calculateTax();
            }
        }
        else
        {
            taxWithholdAmountCur = taxWithholdCalcPurch.calculateTax();
        }

        this.parmTaxWithholdCalculation(taxWithholdCalcPurch);
        return taxWithholdAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cfopTable_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the <c>CFOPTable_BR</c> for the current record.
    /// </summary>
    /// <returns>
    ///     The <c>CFOPTable_BR</c> record.
    /// </returns>
    protected CFOPTable_BR cfopTable_BR()
    {
        PurchLine localPurchLine;

        select cfopTable_BR from localPurchLine
            where localPurchLine.PurchId == purchTable.PurchId;

        return CFOPTable_BR::find(localPurchLine.cfopTable_BR);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructInventMovement</Name>
				<Source><![CDATA[
    protected InventMovement constructInventMovement()
    {
        return InventMovement::construct(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    CurrencyCode currencyCode()
    {
        return purchTable.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDate</Name>
				<Source><![CDATA[
    DlvDate deliveryDate()
    {
        return purchLine.deliveryDate(this.invoiceDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDateMarkup</Name>
				<Source><![CDATA[
    DlvDate deliveryDateMarkup()
    {
        if (purchLine)
            return this.deliveryDate();
        else
            return purchTable.deliveryDateDisplay(this.invoiceDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>destructiveQty_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Destructive quantity.
    /// </summary>
    /// <returns>
    /// The instance of the <c>InventQualityOrderQty</c> class.
    /// </returns>
    public InventQualityOrderQty destructiveQty_IN()
    {
        InventQualityOrderQty qty;

        if (TaxParameters::checkVatExciseParameters_IN())
        {
            qty = InventQualityOrderTable::findSalesPurchRefTransId_IN(purchLine.InventTransId, InventTestReferenceType::Purch).Qty;
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentDate</Name>
				<Source><![CDATA[
    public DocumentDate documentDate()
    {
        return purchTotals.documentDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentHasTotalTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the document has a total tax code assigned.
    /// </summary>
    /// <param name="_purchId">
    /// The document to check.
    /// </param>
    /// <returns>
    /// True if the document contains a tax on total; otherwise false.
    /// </returns>
    private boolean documentHasTotalTaxCode(PurchId _purchId)
    {
        container           packedResult;
        boolean             result;
        TaxTable            taxTable;
        TaxGroupData        taxGroupData;
        TaxOnItem           taxOnItem;
        PurchLine           localPurchLine;

        packedResult = SysTransactionScopeCache::get(funcName(), _purchId, conNull());

        if (packedResult == conNull())
        {
            select firstOnly RecId from localPurchLine
                    where localPurchLine.PurchId == _purchId &&
                        localPurchLine.TaxGroup != '' &&
                        localPurchLine.TaxItemGroup != ''
                exists join taxGroupData
                    where taxGroupData.TaxGroup == localPurchLine.TaxGroup
                exists join taxOnItem
                    where taxOnItem.TaxItemGroup == localPurchLine.TaxItemGroup &&
                        taxOnItem.TaxCode == taxGroupData.TaxCode
                exists join taxTable
                    where taxTable.TaxCode == taxGroupData.taxCode &&
                        (taxTable.TaxLimitBase == TaxLimitBase::InvoiceInclVAT
                        || taxTable.TaxLimitBase == TaxLimitBase::InvoiceWithoutVAT);

            if (localPurchLine.RecId != 0)
            {
                result = true;
            }

            SysTransactionScopeCache::set(funcName(), _purchId, [result]);
        }
            else
        {
            [result] = packedResult;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTaxGroupExistsForDocument</Name>
				<Source><![CDATA[
    public boolean doTaxGroupExistsForDocument()
    {
        PurchLine purchLineLocal;
        MarkupTrans markupTransLine;
        boolean taxGroupsExist;

        select firstonly RecId from purchLineLocal
            where purchLineLocal.PurchId == purchTable.PurchId &&
                  purchLineLocal.IsDeleted == NoYes::No &&
                  purchLineLocal.TaxGroup != '' &&
                  purchLineLocal.TaxItemGroup != '';
        if (purchLineLocal != null)
        {
            taxGroupsExist = true;
        }

        if (!taxGroupsExist)
        {
            if (MarkupTrans::doTaxGroupExistsForMarkup(purchTable.TableId, purchTable.RecId))
            {
                taxGroupsExist = true;
            }
        }

        if (!taxGroupsExist)
        {
            select firstonly RecId from markupTransLine
                where markupTransLine.TaxGroup != '' &&
                      markupTransLine.TaxItemGroup != '' &&
                      !markupTransLine.IsDeleted
            exists join purchLineLocal
                where purchLineLocal.PurchId == purchTable.PurchId &&
                      purchLineLocal.TableId == markupTransLine.TransTableId &&
                      purchLineLocal.RecId == markupTransLine.TransRecId;
            if (markupTransLine != null)
            {
                taxGroupsExist = true;
            }
        }

        return taxGroupsExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endDisc</Name>
				<Source><![CDATA[
    DiscPct   endDisc()
    {
        return purchTable.DiscPercent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endDiscPercentWht_IN</Name>
				<Source><![CDATA[
    DiscPct endDiscPercentWht_IN()
    {
        return this.endDisc();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    VendExchRate exchRate(date _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return ExchangeRateHelper::exchRate(this.currencyCode(), _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondary</Name>
				<Source><![CDATA[
    ExchrateSecondary exchRateSecondary(date _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return ExchangeRateHelper::exchRateSecond(this.currencyCode(), _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyExchangeRate</Name>
				<Source><![CDATA[
    internal ReportingCurrencyExchRate reportingCurrencyExchangeRate(date _date = dateNull())
    {
        ReportingCurrencyExchRate reportingCurrencyExchRate = purchTable.ReportingCurrencyFixedExchRate;
        if (!reportingCurrencyExchRate
            && PurchParameters::find().DateOfExchRate_W != DateOfExchRate_W::PostingDate
            && _date
            && Ledger::isReportingCurrencyDefined())
        {
            ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), this.CurrencyCode());
            exchangeRateHelper.parmToCurrency(Ledger::reportingCurrency());
            exchangeRateHelper.parmExchangeRateTypeRecId(Ledger::reportingCurrencyExchangeRateType());
            exchangeRateHelper.parmExchangeDate(_date);
            reportingCurrencyExchRate = exchangeRateHelper.getExchangeRate1();
        }
        return reportingCurrencyExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCursor</Name>
				<Source><![CDATA[
    void  initCursor()
    {
        queryTransact = this.queryBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxIncluded</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether tax is included in the item price for the purchase order document.
    /// </summary>
    /// <returns>
    ///    true if tax is included in the item price; otherwise, false.
    /// </returns>
    public boolean isTaxIncluded()
    {
        return purchTable.InclTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTaxTrans</Name>
				<Source><![CDATA[
    protected boolean loadTaxTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadTaxWithholdTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the tax withhold transaction.
    /// </summary>
    /// <returns>
    /// Returns true if the load succeed.
    /// </returns>
    protected boolean loadTaxWithholdTrans_IN()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the existing <c>TaxUncommitted</c> records must be updated or if they can be
    /// recreated.
    /// </summary>
    /// <returns>
    /// true if the existing <c>TaxUncommitted</c> records must be updated; otherwise, false.
    /// </returns>
    protected boolean maintainTaxUncommitted()
    {
        return purchTable.maintainTaxUncommitted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainTaxWithholdUncommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if existing <c>TaxWithholdUncommitted_IN</c> records must be updated or if they can be recreated.
    /// </summary>
    /// <returns>
    /// true if the existing <c>TaxWithholdUncommitted_IN</c> records must be updated; otherwise, false.
    /// </returns>
    protected boolean maintainTaxWithholdUncommitted_IN()
    {
        return purchTable.maintainTaxUncommitted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAmount</Name>
				<Source><![CDATA[
    public MarkupAmount markupAmount()
    {
        MarkupAmount ret;

        ret = super();

        if (BrazilParameters::isEnabled())
        {
            if (markupTrans.CurrencyCode != this.currencyCode())
            {
                ret = CurrencyExchangeHelper::curAmount(ret, this.currencyCode(), this.invoiceDate(), 0, this.exchRate(), this.exchRateSecondary(), NoYes::Yes);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupDefaultDimension</Name>
				<Source><![CDATA[
    DimensionDefault markupDefaultDimension()
    {
        if (purchLine)
            return purchLine.DefaultDimension;
        else
            return purchTable.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRetailPrice_IN</Name>
				<Source><![CDATA[
    public MaximumRetailPrice_IN maximumRetailPrice_IN()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void  new(PurchTable    _purchTable)
    {
        super(_purchTable);

        purchTable  = _purchTable;

        this.setHeaderReasonTableRefRecId(purchTable.ReasonTableRef);
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextLine</Name>
				<Source><![CDATA[
    Common nextLine()
    {
        prevPurchLine = purchLine.data();
        purchLine = null;
        lineVendInvoiceJour = null;
        lineTaxCalculationDate = dateNull();
        lineTaxCalculationDateCached = false;

        while (queryTransact.next())
        {
            purchLine = this.queryGet(queryTransact);

            this.setLineReasonTableRefRecId(VendInvoiceInfoLine::findByPurchLineRefRecId(purchLine.RecId).ReasonTableRef);

            if (purchLine)
            {
                this.initCursorMarkupLine(purchLine.TableId, purchLine.RecId);
                break;
            }
        }

        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationAccount</Name>
				<Source><![CDATA[
    LedgerDimensionDefaultAccount operationAccount()
    {
        LedgerDimensionDefaultAccount   ledgerAccount;
        InventMovement                  inventMovement;

        //LedgerDimensionDefaultAccount can only change based on item, hence for category based lines just return.
        if (!purchLine || !purchLine.ItemId)
        {
            return ledgerAccount;
        }

        inventMovement = InventMovement::construct(purchLine);

        if (inventMovement.mustBeBookedFinancially())
        {
            if (inventMovement.mustBeBookedBalanceSheet())
            {
                ledgerAccount = inventMovement.accountBalanceSheet();
            }
            else
            {
                if (inventMovement.mustBeBookedOperations())
                {
                    ledgerAccount = inventMovement.accountOperations();
                }
            }
        }

        return ledgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationAccountMarkup</Name>
				<Source><![CDATA[
    LedgerDimensionDefaultAccount operationAccountMarkup()
    {
        LedgerDimensionDefaultAccount ledgerAccount;

        switch (markupTrans.markupTable().CustType)
        {
            case MarkupType::Item :
                if (purchLine)
                {
                    ledgerAccount = this.operationAccount();
                }
                break;

            case MarkupType::LedgerAccount :
                ledgerAccount = markupTrans.markupTable().parmCustomerLedgerDimension();
                break;

            case MarkupType::CustVend :
                ledgerAccount = markupTrans.markupTable().parmVendorLedgerDimension();
                break;
        }

        return ledgerAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationPosting</Name>
				<Source><![CDATA[
    LedgerPostingType operationPosting()
    {
        LedgerPostingType   ledgerPostingType;
        InventMovement      inventMovement;

        //LedgerPostingType can only change based on item, hence for category based lines just return.
        if (!purchLine || !purchLine.ItemId)
        {
            return ledgerPostingType;
        }

        inventMovement = InventMovement::construct(purchLine);

        if (inventMovement.mustBeBookedFinancially())
        {
            if (inventMovement.mustBeBookedBalanceSheet())
            {
                ledgerPostingType = inventMovement.postingBalanceSheet();
            }
            else
            {
                if (inventMovement.mustBeBookedOperations())
                {
                    ledgerPostingType = inventMovement.postingOperations();
                }
            }
        }

        return ledgerPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>operationPostingMarkup</Name>
				<Source><![CDATA[
    LedgerPostingType operationPostingMarkup()
    {
        LedgerPostingType   ledgerPostingType;
        switch (markupTrans.markupTable().CustType)
        {
            case MarkupType::Item           :   ledgerPostingType = this.operationPosting();
                                                break;

            case MarkupType::LedgerAccount  :   ledgerPostingType = markupTrans.markupTable().CustPosting;
                                                break;

            case MarkupType::CustVend       :   ledgerPostingType = LedgerPostingType::VendBalance;
                                                break;
        }

        return ledgerPostingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origHeadingRecID</Name>
				<Source><![CDATA[
    RecId  origHeadingRecID()
    {
        return purchTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origHeadingTableID</Name>
				<Source><![CDATA[
    TableId  origHeadingTableID()
    {
        return purchTable.TableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentStatus_IN</Name>
				<Source><![CDATA[
    public DocumentStatus parmDocumentStatus_IN()
    {
        return DocumentStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentStatus</Name>
				<Source><![CDATA[
    public DocumentStatus parmDocumentStatus()
    {
        return DocumentStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the tax amounts to the <c>TaxTrans</c> table and to the ledger.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> class required to post.
    /// </param>
    /// <param name="_post">
    ///    A <c>NoYes</c> enumeration value that indicates whether to post the tax amount.
    /// </param>
    public void post(LedgerVoucher _ledgerVoucher, NoYes _post = NoYes::Yes)
    {
        if (purchTable.DocumentStatus == DocumentStatus::PurchaseOrder)
        {
            taxPost = TaxPost::newForSourceType(TaxSourceType::PurchaseOrder, this, NoYes::No);

            taxPost.updateAndPost(LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher));
        }
        else
        {
            super(_ledgerVoucher, _post);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    abstract Object  queryBuild()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryGet</Name>
				<Source><![CDATA[
    abstract Common  queryGet(QueryRun  transact)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPurchTotals_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets purch totals.
    /// </summary>
    /// <param name="_purchTotals">
    /// The purch totals.
    /// </param>
    public void setPurchTotals_IN(PurchTotals _purchTotals)
    {
        purchTotals = _purchTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipTaxRecalculationsForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the tax should be recalculated for the current line.
    /// </summary>
    /// <returns>
    /// true if tax recalculation will be skipped; otherwise, false.
    /// </returns>
    public boolean skipTaxRecalculationsForLine()
    {
        boolean skip = false;

        if (purchTable.recalculateTaxForChangedLineOnly() || this.useOnlyEditedLinesForTaxCalc())
        {
            // For invoice matched lines allow tax recalculation in situations where specQty is different from All (e.g. when using UpdateSelection in PurchTotals form)
            // Notice: this piece of logic is referenced by the <c>TaxIntegrationPurchTableDataRetrieval.determineTaxabilityForLine</c> method, and should be consistent

            skip = ((purchLine.IsModified == NoYes::No && purchTable.IsModified == NoYes::No && !this.modifiedChargesExistOnPurchaseOrderLineOrHeader())
                    || (purchLine.isInvoiceMatched() 
                        || purchLine.sourceDocumentLine().AccountingStatus == SourceDocumentLineAccountingStatus::Finalized
                        || (purchLine.PurchStatus == PurchStatus::Canceled
                            && PurchCalcTaxSkipTaxRecalculationCanceledFlight::instance().isEnabled()))
                    && specQty == PurchUpdate::All);
        }

        return skip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedChargesExistOnPurchaseOrderLineOrHeader</Name>
				<Source><![CDATA[
    private boolean modifiedChargesExistOnPurchaseOrderLineOrHeader()
    {
        MarkupTrans modifiedMarkupTransLine, modifiedMarkupTransHeader;

        if (PurchCalcTaxConsiderMarkupChangesOnRecalcSkipFlight::instance().isEnabled())
        {
            if (headerChargeExists)
            {
                return true;
            }

            if (!headerChargeChecked)
            {
                select firstonly RecId from modifiedMarkupTransHeader
                  where modifiedMarkupTransHeader.TransTableId  == purchTable.TableId
                        && modifiedMarkupTransHeader.TransRecId == purchTable.RecId
                        && !modifiedMarkupTransHeader.IsDeleted
                        && modifiedMarkupTransHeader.IsModified;

                headerChargeChecked = true;

                if (modifiedMarkupTransHeader.RecId)
                {
                    headerChargeExists = true;
                    return headerChargeExists;
                }
            }
            
            select firstonly RecId from modifiedMarkupTransLine
                where modifiedMarkupTransLine.TransTableId  == purchLine.TableId 
                    && modifiedMarkupTransLine.TransRecId   == purchLine.RecId   
                    && !modifiedMarkupTransLine.IsDeleted
                    && modifiedMarkupTransLine.IsModified;
            if (modifiedMarkupTransLine.RecId)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentHeader</Name>
				<Source><![CDATA[
    private SourceDocumentHeader sourceDocumentHeader()
    {
        if (!sourceDocumentHeader)
        {
            sourceDocumentHeader = sourceDocumentHeader::find(purchTable.SourceDocumentHeader);
        }

        return sourceDocumentHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxCashDiscPercent</Name>
				<Source><![CDATA[
    DiscPct taxCashDiscPercent()
    {
        return purchTotals.taxCashDiscPercent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDefaultDimension</Name>
				<Source><![CDATA[
    public DimensionDefault transDefaultDimension()
    {
        return purchLine.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transItemId</Name>
				<Source><![CDATA[
    public ItemId transItemId()
    {
        return purchLine.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transLineAmount</Name>
				<Source><![CDATA[
    AmountCur  transLineAmount()
    {
        AmountCur   transLineAmount;
        if (markupTrans.MarkupCategory == MarkupCategory::InterCompanyPercent)
            transLineAmount = purchLine.interCompanyLineAmount(this.transQty(), this.invoiceDate(), tax);
        else
            transLineAmount = this.transLineAmountInclTax();

        return transLineAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transLineAmountInclTax</Name>
				<Source><![CDATA[
    AmountCur  transLineAmountInclTax()
    {
        return purchLine.calcLineAmount(this.transQty());
    }

]]></Source>
			</Method>
			<Method>
				<Name>transPcsPrice</Name>
				<Source><![CDATA[
    PriceCur transPcsPrice()
    {
        return purchLine.taxPcsPrice(this.invoiceDate(), tax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transProcurementCategory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>EcoResCategory</c> object for the current tax transaction.
    /// </summary>
    /// <returns>
    ///    The <c>PurchCategory</c> for the current tax transaction.
    /// </returns>
    public PurchCategory transProcurementCategory()
    {
        return purchLine.ProcurementCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transPurchUnit</Name>
				<Source><![CDATA[
    PurchUnit transPurchUnit()
    {
        return purchLine.PurchUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transQty</Name>
				<Source><![CDATA[
    PurchQty    transQty()
    {
        if (!purchLine.isInvoiced())
        {
            return PurchQuantity::construct(DocumentStatus::Invoice, true).calcPurchQty(purchLine, specQty);
        }
        else
            return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTaxCalculationDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resolves the calculation date which should be used for tax calculation.
    /// </summary>
    /// <returns>
    /// The calculation date which should be used for tax calculation.
    /// </returns>
    public TransDate transTaxCalculationDate()
    {
        TransDate               taxCalculationDate;
        TaxUncommitted          taxUncommitted;
        TaxTrans                taxTrans;

        // Try to fetch the Calculation date based on the invoice of the original order if return order/credit
        if (!FeatureStateProvider::isFeatureEnabled(TaxRateOnInvoiceDateInPurchaseOrderCreditNote::instance())
            && (purchLine.InventRefId && (purchLine.ItemRefType == InventRefType::None || purchLine.ItemRefType == InventRefType::Purch)))
        {
            // Cache the vendor invoice journal record to enable reuse for all calculation being done in context of the present purchase order line
            if (lineVendInvoiceJour == null || lastInventRefTransId != purchLine.InventRefTransId)
            {
                lineVendInvoiceJour = VendInvoiceTrans::findInventTransId(purchLine.InventRefTransId).vendInvoiceJour();
                lastInventRefTransId = purchLine.InventRefTransId;
            }

            // Only try to resolve id there's an historical invoice present
            if (lineVendInvoiceJour.RecId)
            {
                // if this is credit note of purchase order line, use the invoice date when posting invoice
                if (purchLine.CreditedVendInvoiceTrans && this.parmDocumentStatus() == DocumentStatus::Invoice)
                {
                    taxCalculationDate = lineVendInvoiceJour.InvoiceDate;
                }
                // Only try to resolve if this is for the purchase order line itself or a markup transaction of type Heading
                else if (!markupTrans.RecId || (markupTrans.RecId && markupTrans.ModuleCategory == HeadingLine::Heading))
                {
                    select firstOnly CalculationDate from taxUncommitted
                        join InventTransId, Voucher, TransDate from taxTrans
                            where  taxTrans.InventTransId       == taxUncommitted.InventTransId
                                && taxUncommitted.InventTransId == purchLine.InventRefTransId
                                && taxTrans.Voucher             == lineVendInvoiceJour.LedgerVoucher
                                && taxTrans.TransDate           == lineVendInvoiceJour.InvoiceDate;

                    taxCalculationDate = taxUncommitted.CalculationDate;
                    // Preserve the calculation date for the purchase order line so it can be reused
                    lineTaxCalculationDate = taxCalculationDate;
                }
                // In the context of markup transaction of type Line, reuse the preserved calculation date
                else if (markupTrans.RecId && markupTrans.ModuleCategory == HeadingLine::Line)
                {
                    taxCalculationDate = lineTaxCalculationDate;
                }
            }
        }

        // If calculation date was not resolved in the above logic, fetch it based on tax parameters setting (base implementation)
        if (taxCalculationDate == dateNull()
            // <GIN>
            || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            // </GIN>
            )
        {
            taxCalculationDate = super();
        }

        return taxCalculationDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTaxGroup</Name>
				<Source><![CDATA[
    TaxGroup    transTaxGroup()
    {
        return purchLine.TaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTaxItemGroup</Name>
				<Source><![CDATA[
    TaxItemGroup    transTaxItemGroup()
    {
        return purchLine.TaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTaxWithholdGroup</Name>
				<Source><![CDATA[
    internal TaxWithholdGroup transTaxWithholdGroup()
    {
        return purchLine.TaxWithholdGroup_TH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTaxWithholdItemGroup</Name>
				<Source><![CDATA[
    internal TaxWithholdItemGroupId_TH transTaxWithholdItemGroup()
    {
        return purchLine.TaxWithholdItemGroupHeading_TH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transTransId</Name>
				<Source><![CDATA[
    public TradeInventTransId transTransId()
    {
        return purchLine.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulation</Name>
				<Source><![CDATA[
    EUROTriangulation  triangulation(date _date = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        return Currency::triangulation(purchTable.CurrencyCode, _date);
    }

]]></Source>
			</Method>
			<Method>
				<Name>useAndConsumption_BR</Name>
				<Source><![CDATA[
    public boolean useAndConsumption_BR()
    {
        return purchTable.purchTable_BR().VendFinalUser_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useOnlyEditedLinesForTaxCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Taxes are recalculated only for the modified lines and not for the whole order if three conditions are met:
    /// 1.  The action performed is not confirmation of the purchase order (we want to recalculate everything in this case).
    /// 2.  An accounting event exists for the sourceDocumentHeader and the accounting status is "InProcess" or the order has change
    ///     management active (meaning that the taxes for all the lines have already been calculated at least once).
    /// 3.  When the type of tax doesn't require a redistribution of the tax quantity among all the lines when a single one is modified.
    /// This method checks if it is possible to recalculate the tax only for the modified and not all the lines in the document.
    /// </summary>
    /// <returns>
    /// A boolean specifying if it is possible to recalculate tax for only the modified lines in the order.
    /// </returns>
    private boolean useOnlyEditedLinesForTaxCalc()
    {
            return !purchTotals.isConfirmation()
                    && (this.isPurchaseOrderInProcessAndWasPreviouslyConfirmed() || purchTable.ChangeRequestRequired)
                    && !this.documentHasTotalTaxCode(purchTable.PurchId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseOrderInProcessAndWasPreviouslyConfirmed</Name>
				<Source><![CDATA[
    private boolean isPurchaseOrderInProcessAndWasPreviouslyConfirmed()
    {
        if (!isPurchaseOrderInProcessAndWasPreviouslyConfirmedSet)
        {
            isPurchaseOrderInProcessAndWasPreviouslyConfirmed = SourceDocumentProvider::isDocumentInProcessAndWasPreviouslyCompleted(this.sourceDocumentHeader());
            isPurchaseOrderInProcessAndWasPreviouslyConfirmedSet = true;
        }

        return isPurchaseOrderInProcessAndWasPreviouslyConfirmed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useSubLedgerJournalLines</Name>
				<Source><![CDATA[
    boolean useSubLedgerJournalLines()
    {
        if ((purchTable.DocumentStatus == DocumentStatus::None
            || purchTable.DocumentStatus == DocumentStatus::PurchaseOrder
            || purchTable.DocumentStatus == DocumentStatus::PackingSlip
            || purchTable.DocumentStatus == DocumentStatus::ReceiptsList
            || purchTable.DocumentStatus == DocumentStatus::Invoice
            || purchTable.DocumentStatus == DocumentStatus::ApproveJournal
            || purchTable.DocumentStatus == DocumentStatus::ConfirmationRequest)
            && (this.headingTableID() != tableNum(PurchParmTable)) && (specQty == PurchUpdate::All))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>Tax</c> class will use the <c>TaxUncommitted</c> table.
    /// </summary>
    /// <returns>
    /// true if the <c>Tax</c> class should use the <c>TaxUncommitted</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxUncommitted()
    {
        if (this.headingTableID() != tableNum(PurchParmTable) && specQty == PurchUpdate::All)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useTaxWithholdUncommitted_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the <c>TaxWithholdCalculation_IN</c> class should use the <c>TaxWithholdUncommitted_IN</c> table.
    /// </summary>
    /// <returns>
    ///    true if the <c>TaxWithholdCalculation_IN</c> class should use the <c>TaxWithholdUncommitted_IN</c> table; otherwise, false.
    /// </returns>
    public boolean useTaxWithholdUncommitted_IN()
    {
        if (this.headingTableID() != tableNum(PurchParmTable))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRegData_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used by various financial transactions to pass information from the financial transaction down to the tax calculation engine.
    /// </summary>
    /// <returns>
    /// A container loaded with various fields needed by the tax calculation engine.
    /// </returns>
    public container vatRegData_W()
    {
        VatDueDate_W           vatDate;
        DocumentDate            documentDate;
        PlCustVendName         custVendName;
        VATNum                 vatNum;
        Addressing             addressing;
        VendTable              vendTable;
        PlTaxPeriodPaymentCode taxPeriodPaymentCode;
        IntraComVATDueDate_W    useIntrComVatDate;
        VendInvoiceJour         vendInvoiceJour;
        #EECountryRegionCodes

        vendInvoiceJour     = VendInvoiceJour::findSourceDocumentHeader(this.vendInvoiceInfoTable().SourceDocumentHeader);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
        {
            useIntrComVatDate   = !vendInvoiceJour.creditNote();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            taxPeriodPaymentCode = purchTable.TaxPeriodPaymentCode_PL;
            vendTable            = VendTable::find(purchTable.InvoiceAccount);
            custVendName         = vendTable.name();
            addressing           = vendTable.invoiceAddress().Address;
            if (purchTable.VATNum)
            {
                vatNum = purchTable.VATNum;
            }
            else
            {
                vatNum = vendTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, vendInvoiceJour.InvoiceDate);
            }
        }

        return [ vatDate,
                 documentDate,
                 custVendName,
                 vatNum,
                 addressing,
                 taxPeriodPaymentCode,
                 useIntrComVatDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineEndDiscAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the end discount amount for a line.
    /// </summary>
    /// <param name="_baseAmount">
    /// The base amount for the discount calculation.
    /// </param>
    /// <returns>
    /// The end discount amount.
    /// </returns>
    public DiscAmount lineEndDiscAmount(TaxBaseCur _baseAmount)
    {
        DiscAmount lineEndDisc;

        if (purchTotals)
        {
            lineEndDisc = purchTotals.lineEndDiscBalance(purchLine.RecId);
        }

        if (!lineEndDisc && this.endDisc() && purchLine.endDisc())
        {
            lineEndDisc = _baseAmount * this.endDisc() / 100;
        }

        return lineEndDisc;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>