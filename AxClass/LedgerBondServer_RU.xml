<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerBondServer_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///  Stores bonding plan and provides basic plan manipulations
/// </summary>
class LedgerBondServer_RU
{
    LedgerBondTransList_RU          bondTransList;
    LedgerBondLogList_RU            bondLogList;

    TmpLedgerBondWorkTable_RU       tmpBond;

    boolean                         fatalError;
    boolean                         checkedBeforeBond;

    // last bond vref id before first split -
    // used as flag, wherther split was performed or not
    LedgerBondTransObject_RU      bondTransMSTDiff;
    LedgerBondTransObject_RU      bondTransMSTSecondDiff;

    CurrencyCode                    mstCode;
    CurrencyCode                    mstSecondCode;
    // set of recIDs, that should be skipped when evaluating lastVRefID
    Set                             skipped;
    Set                             currentSkipped;
    boolean                         inSkipped;

    container iDs;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addBondFinal</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adds primitive bonding to plan
    /// </summary>
    /// <param name="_tmpBond">
    ///    Temporary table with binding plan
    /// </param>
    /// <param name="_bondTransDebit">
    ///   debit
    /// </param>
    /// <param name="_bondTransCredit">
    ///  credit
    /// </param>
    protected void addBondFinal(TmpLedgerBondWorkTable_RU _tmpBond,
                              LedgerBondTransObject_RU  _bondTransDebit,
                              LedgerBondTransObject_RU  _bondTransCredit)
    {
        if (! this.checkTransObjects(_bondTransDebit, _bondTransCredit))
            return;

        _tmpBond.AmountMST           = abs(_tmpBond.AmountMST);
        _tmpBond.AmountMSTSecondary  = abs(_tmpBond.AmountMSTSecondary);
        _tmpBond.AmountCurDebit      = abs(_tmpBond.AmountCurDebit);
        _tmpBond.AmountCurCredit     = abs(_tmpBond.AmountCurCredit);

        Debug::assert(
            (
                abs(_tmpBond.AmountMST) <= _bondTransDebit.remainAmountMST()
                &&
                abs(_tmpBond.AmountMSTSecondary) <= _bondTransDebit.remainAmountMSTSecond()
            )
            ||
            (
                abs(_tmpBond.AmountMST) <= _bondTransCredit.remainAmountMST()
                &&
                abs(_tmpBond.AmountMSTSecondary) <= _bondTransCredit.remainAmountMSTSecond()
            )
        );

        _bondTransDebit.addBondAmounts(true,
                                  _tmpBond.AmountMST,
                                  _tmpBond.AmountMSTSecondary,
                                  _tmpBond.AmountCurDebit);

        _bondTransCredit.addBondAmounts(false,
                                   _tmpBond.AmountMST,
                                   _tmpBond.AmountMSTSecondary,
                                   _tmpBond.AmountCurCredit);

        _tmpBond.insert();

        #if.never
            setprefix("Added bond VRef " + int2str(_bondTransDebit.vrefId()) + " <-> " + int2str(_bondTransCredit.vrefid()) + " : " +
                "<CRD " + _bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() + " " + num2str(_tmpBond.AmountCurDebit, 0, 2, 2, 1) + "> " +
                "<CRC " + _bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode() + " " + num2str(_tmpBond.AmountCurCredit, 0, 2, 2, 1) + "> " +
                "<MST " + num2str(_tmpBond.AmountMST, 0, 2, 2, 1) + "> " +
                "<SEC " + num2str(_tmpBond.AmountMSTSecondary, 0, 2, 2, 1) + ">");
            warning("VRef " + int2str(_bondTransDebit.vrefId()) + " remainders: " +
                (_bondTransDebit.remainCrediting() ? "Credit" : "Debit") + " " +
                "<CUR " + _bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() + " " + num2str(_bondTransDebit.remainAmountCur(), 0, 2, 2, 1) + "> " +
                "<MST " + num2str(_bondTransDebit.remainAmountMST(), 0, 2, 2, 1) + "> " +
                "<SEC " + num2str(_bondTransDebit.remainAmountMSTSecond(), 0, 2, 2, 1) + ">");
            warning("VRef " + int2str(_bondTransCredit.vrefId()) + " remainders: " +
                (_bondTransCredit.remainCrediting() ? "Credit" : "Debit") + " " +
                "<CUR " + _bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode() + " " + num2str(_bondTransCredit.remainAmountCur(), 0, 2, 2, 1) + "> " +
                "<MST " + num2str(_bondTransCredit.remainAmountMST(), 0, 2, 2, 1) + "> " +
                "<SEC " + num2str(_bondTransCredit.remainAmountMSTSecond(), 0, 2, 2, 1) + ">");
        #endif
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBondMSTDiff</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Adds bonding of rounding difference in MST
    /// </summary>
    /// <param name="_bondIdDebit">
    ///  ID of debit transaction
    /// </param>
    /// <param name="_bondIdCredit">
    ///  ID of credit transaction
    /// </param>
    /// <param name="_amountMST">
    ///   Amount to bond
    /// </param>
    public void addBondMSTDiff(LedgerBondId_RU   _bondIdDebit,
                               LedgerBondId_RU   _bondIdCredit,
                               AmountMST         _amountMST)
    {
        LedgerBondTransObject_RU bondTransDebit  = this.findBondTransObject(_bondIdDebit),
                                 bondTransCredit = this.findBondTransObject(_bondIdCredit);

        if (fatalError)
            return;

        if (! _amountMST)
        {
            fatalError = ! checkFailed(strFmt("@SYS19378", funcName()));
        }

        tmpBond.clear();

        tmpBond.DebitBondId        = _bondIdDebit;
        tmpBond.CreditBondId       = _bondIdCredit;

        tmpBond.AmountCurCredit    = bondTransCredit.remainAmountCur() ? bondTransCredit.remainAmountCur() : 0;
        tmpBond.AmountCurDebit     = bondTransDebit.remainAmountCur() ? bondTransDebit.remainAmountCur() : 0;
        tmpBond.AmountMST          = _amountMST;
        tmpBond.AmountMSTSecondary = 0;

        this.addBondFinal(tmpBond, bondTransDebit, bondTransCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBondMSTSecondDiff</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Adds bonding of rounding difference in secondary currency
    /// </summary>
    /// <param name="_bondIdDebit">
    ///  ID of debit transaction
    /// </param>
    /// <param name="_bondIdCredit">
    ///  ID of credit transaction
    /// </param>
    /// <param name="_amountMSTSecond">
    ///   Amount to bond
    /// </param>
    public void addBondMSTSecondDiff(LedgerBondId_RU    _bondIdDebit,
                                     LedgerBondId_RU    _bondIdCredit,
                                     AmountMSTSecondary _amountMSTSecond)
    {
        LedgerBondTransObject_RU bondTransDebit  = this.findBondTransObject(_bondIdDebit),
                                 bondTransCredit = this.findBondTransObject(_bondIdCredit);

        if (fatalError)
            return;

        if (! _amountMSTSecond)
        {
            fatalError = ! checkFailed(strFmt("@SYS19378", funcName()));
        }

        tmpBond.clear();

        tmpBond.DebitBondId        = _bondIdDebit;
        tmpBond.CreditBondId       = _bondIdCredit;

        tmpBond.AmountCurCredit    = bondTransCredit.remainAmountCur() ? bondTransCredit.remainAmountCur() : 0;
        tmpBond.AmountCurDebit     = bondTransDebit.remainAmountCur() ? bondTransDebit.remainAmountCur() : 0;
        tmpBond.AmountMST          = 0;
        tmpBond.AmountMSTSecondary = _amountMSTSecond;

        this.addBondFinal(tmpBond, bondTransDebit, bondTransCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBondProrateAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds bonding in transaction currency
    /// </summary>
    /// <param name="_bondIdDebit">
    /// ID of debit transaction
    /// </param>
    /// <param name="_bondIdCredit">
    /// ID of credit transaction
    /// </param>
    /// <param name="_amountCur">
    ///   Amount to bond
    /// </param>
    /// <param name="_roundToCredit">
    /// If true, credit transaction is used to calculate MST and MSTSecondary values, otherwize debit transaction is used
    /// </param>
    /// <param name="_bondIDNegativeRemainder">
    /// bond ID of tansaction that can have negative remainder.
    /// </param>
    public void addBondProrateAmountCur(LedgerBondId_RU _bondIdDebit,
                                        LedgerBondId_RU _bondIdCredit,
                                        AmountCur       _amountCur,
                                        boolean         _roundToCredit = false,
                                        LedgerBondId_RU _bondIDNegativeRemainder = 0)
    {
        LedgerBondTransObject_RU    bondTransDebit  = this.findBondTransObject(_bondIdDebit),
                                    bondTransCredit = this.findBondTransObject(_bondIdCredit);
        Factor                      factor;
        boolean                     negativeRemainderDebit  = _bondIdDebit == _bondIDNegativeRemainder;
        boolean                     negativeRemainderCredit = _bondIdCredit == _bondIDNegativeRemainder;

        AmountMST maxBondAmountMst()
        {
            if (!_bondIDNegativeRemainder)
            {
                return min(bondTransDebit.remainAmountMST(), bondTransCredit.remainAmountMST());
            }
            return negativeRemainderDebit ? bondTransCredit.remainAmountMST() :  bondTransDebit.remainAmountMST();
        }

        AmountMSTSecondary maxBondAmountMstSecondary()
        {
            if (!_bondIDNegativeRemainder)
            {
                return min(bondTransDebit.remainAmountMSTSecond(), bondTransCredit.remainAmountMSTSecond());
            }
            return negativeRemainderDebit ? bondTransCredit.remainAmountMSTSecond() :  bondTransDebit.remainAmountMSTSecond();
        }
        if (fatalError)
            return;

        if (! _amountCur                                            ||
            ! bondTransDebit.ledgerTransObject().parmTransactionCurrencyAmount()    ||
            ! bondTransCredit.ledgerTransObject().parmTransactionCurrencyAmount()   ||
            bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() != bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
        {
            fatalError = ! checkFailed(strFmt("@SYS19378", funcName()));
            return;
        }

        Debug::assert(negativeRemainderDebit    || _amountCur <= bondTransDebit.remainAmountCur() &&
                      negativeRemainderCredit   ||  _amountCur <= bondTransCredit.remainAmountCur());

        tmpBond.clear();

        tmpBond.DebitBondId       = _bondIdDebit;
        tmpBond.CreditBondId      = _bondIdCredit;

        tmpBond.AmountCurDebit    = _amountCur;
        tmpBond.AmountCurCredit   = _amountCur;

        if (! _roundToCredit)
        {
            factor = _amountCur / bondTransDebit.ledgerTransObject().parmTransactionCurrencyAmount();
            tmpBond.AmountMSTSecondary = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmReportingCurrencyAmount() * factor, mstSecondCode);
            tmpBond.AmountMST          = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmAccountingCurrencyAmount() * factor, mstCode);
        }
        else
        {
            factor = _amountCur / bondTransCredit.ledgerTransObject().parmTransactionCurrencyAmount();
            tmpBond.AmountMSTSecondary = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmReportingCurrencyAmount() * factor, mstSecondCode);
            tmpBond.AmountMST          = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmAccountingCurrencyAmount() * factor, mstCode);
        }

        tmpBond.AmountMST = min(tmpBond.AmountMST, maxBondAmountMst());
        tmpBond.AmountMSTSecondary = min(tmpBond.AmountMSTSecondary, maxBondAmountMstSecondary());

        this.addBondFinal(tmpBond, bondTransDebit, bondTransCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBondProrateAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds bonding in Monetary STandard currency
    /// </summary>
    /// <param name="_bondIdDebit">
    /// ID of debit transaction
    /// </param>
    /// <param name="_bondIdCredit">
    /// ID of credit transaction
    /// </param>
    /// <param name="_amountMST">
    ///   Amount to bond
    /// </param>
    /// <param name="_roundToCredit">
    /// If true, credit transaction is used to calculate MST and transaction currency values, otherwize debit transaction is used
    /// </param>
    /// <param name="_bondIDNegativeRemainder">
    /// bond ID of tansaction that can have negative remainder.
    /// </param>
    public void addBondProrateAmountMST(LedgerBondId_RU _bondIdDebit,
                                        LedgerBondId_RU _bondIdCredit,
                                        AmountMST       _amountMST,
                                        boolean         _roundToCredit = false,
                                        LedgerBondId_RU _bondIDNegativeRemainder = 0)
    {
        LedgerBondTransObject_RU bondTransDebit  = this.findBondTransObject(_bondIdDebit),
                                 bondTransCredit = this.findBondTransObject(_bondIdCredit);
        Factor                   factor;
        boolean                     negativeRemainderDebit  = _bondIdDebit == _bondIDNegativeRemainder;
        boolean                     negativeRemainderCredit = _bondIdCredit == _bondIDNegativeRemainder;
        AmountMST maxBondAmountCur()
        {
            if (!_bondIDNegativeRemainder)
            {
                return min(bondTransDebit.remainAmountCur(), bondTransCredit.remainAmountCur());
            }
            return negativeRemainderDebit ? bondTransCredit.remainAmountCur() :  bondTransDebit.remainAmountCur();
        }

        AmountMSTSecondary maxBondAmountMstSecondary()
        {
            if (!_bondIDNegativeRemainder)
            {
                return min(bondTransDebit.remainAmountMSTSecond(), bondTransCredit.remainAmountMSTSecond());
            }
            return negativeRemainderDebit ? bondTransCredit.remainAmountMSTSecond() :  bondTransDebit.remainAmountMSTSecond();
        }

        if (fatalError)
            return;

        if (! _amountMST                                            ||
            ! bondTransDebit.ledgerTransObject().parmAccountingCurrencyAmount()    ||
            ! bondTransCredit.ledgerTransObject().parmAccountingCurrencyAmount())
        {
            fatalError = ! checkFailed(strFmt("@SYS19378", funcName()));
            return;
        }

        Debug::assert(negativeRemainderDebit    || _amountMST <= bondTransDebit.remainAmountMST() &&
                      negativeRemainderCredit   || _amountMST <= bondTransCredit.remainAmountMST());

        tmpBond.clear();

        tmpBond.DebitBondId        = _bondIdDebit;
        tmpBond.CreditBondId       = _bondIdCredit;

        tmpBond.AmountMST          = _amountMST;

        if (! _roundToCredit)
        {
            factor = _amountMST /  bondTransDebit.ledgerTransObject().parmAccountingCurrencyAmount();
            tmpBond.AmountMSTSecondary = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmReportingCurrencyAmount() * factor, mstSecondCode);
            tmpBond.AmountCurDebit     = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode());
            if (bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() == bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
            {
                tmpBond.AmountCurCredit = tmpBond.AmountCurDebit;
            }
            else
            {
                factor = _amountMST / bondTransCredit.ledgerTransObject().parmAccountingCurrencyAmount();
                tmpBond.AmountCurCredit = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode());
            }
        }
        else
        {
            factor = _amountMST / bondTransCredit.ledgerTransObject().parmAccountingCurrencyAmount();
            tmpBond.AmountMSTSecondary = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmReportingCurrencyAmount() * factor, mstSecondCode);
            tmpBond.AmountCurCredit    = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode());
            if (bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() == bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
            {
                tmpBond.AmountCurDebit = tmpBond.AmountCurCredit;
            }
            else
            {
                factor = _amountMST / bondTransDebit.ledgerTransObject().parmAccountingCurrencyAmount();
                tmpBond.AmountCurDebit = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode());
            }
        }

        tmpBond.AmountMSTSecondary = min(tmpBond.AmountMSTSecondary, maxBondAmountMSTSecondary());

        if (bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() == bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
        {
            tmpBond.AmountCurDebit = min(tmpBond.AmountCurDebit, maxBondAmountCur());

            tmpBond.AmountCurCredit = tmpBond.AmountCurDebit;
        }
        else
        {
            if (!negativeRemainderDebit)
            {
                tmpBond.AmountCurDebit = min(
                    tmpBond.AmountCurDebit,
                    bondTransDebit.remainAmountCur());
            }
            if (!negativeRemainderCredit)
            {
                tmpBond.AmountCurCredit = min(
                    tmpBond.AmountCurCredit,
                    bondTransCredit.remainAmountCur());
            }
        }

        this.addBondFinal(tmpBond, bondTransDebit, bondTransCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBondProrateAmountMSTSecond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds bonding in secondary currency
    /// </summary>
    /// <param name="_bondIdDebit">
    /// ID of debit transaction
    /// </param>
    /// <param name="_bondIdCredit">
    /// ID of credit transaction
    /// </param>
    /// <param name="_amountMSTSecond">
    ///   Amount to bond
    /// </param>
    /// <param name="_roundToCredit">
    /// If true, credit transaction is used to calculate MST and transaction currency values, otherwize debit transaction is used
    /// </param>
    /// <param name="_bondIDNegativeRemainder">
    /// bond ID of tansaction that can have negative remainder.
    /// </param>
    public void addBondProrateAmountMSTSecond(LedgerBondId_RU    _bondIdDebit,
                                              LedgerBondId_RU    _bondIdCredit,
                                              AmountMSTSecondary _amountMSTSecond,
                                              boolean            _roundToCredit = false,
                                              LedgerBondId_RU    _bondIDNegativeRemainder = 0)
    {
        LedgerBondTransObject_RU bondTransDebit  = this.findBondTransObject(_bondIdDebit),
                                 bondTransCredit = this.findBondTransObject(_bondIdCredit);
        Factor                   factor;
        boolean                  negativeRemainderDebit  = _bondIdDebit == _bondIDNegativeRemainder;
        boolean                  negativeRemainderCredit = _bondIdCredit == _bondIDNegativeRemainder;

        AmountMST maxBondAmountCur()
        {
            if (!_bondIDNegativeRemainder)
            {
                return min(bondTransDebit.remainAmountCur(), bondTransCredit.remainAmountCur());
            }
            return negativeRemainderDebit ? bondTransCredit.remainAmountCur() :  bondTransDebit.remainAmountCur();
        }

        AmountMST maxBondAmountMst()
        {
            if (!_bondIDNegativeRemainder)
            {
                return min(bondTransDebit.remainAmountMST(), bondTransCredit.remainAmountMST());
            }
            return negativeRemainderDebit ? bondTransCredit.remainAmountMST() :  bondTransDebit.remainAmountMST();
        }

        if (fatalError)
            return;

        if (! _amountMSTSecond                                                  ||
            ! bondTransDebit.ledgerTransObject().parmReportingCurrencyAmount()  ||
            ! bondTransCredit.ledgerTransObject().parmReportingCurrencyAmount())
        {
            fatalError = ! checkFailed(strFmt("@SYS19378", funcName()));
            return;
        }

        Debug::assert(negativeRemainderDebit  || _amountMSTSecond <= bondTransDebit.remainAmountMSTSecond() &&
                      negativeRemainderCredit || _amountMSTSecond <= bondTransCredit.remainAmountMSTSecond());

        tmpBond.clear();

        tmpBond.DebitBondId        = _bondIdDebit;
        tmpBond.CreditBondId       = _bondIdCredit;

        tmpBond.AmountMSTSecondary = _amountMSTSecond;

        if (! _roundToCredit)
        {
            factor = _amountMSTSecond /  bondTransDebit.ledgerTransObject().parmReportingCurrencyAmount();
            tmpBond.AmountMST       = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmAccountingCurrencyAmount() * factor, mstCode);
            tmpBond.AmountCurDebit  = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode());
            if (bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() == bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
            {
                tmpBond.AmountCurCredit = tmpBond.AmountCurDebit;
            }
            else
            {
                factor = _amountMSTSecond / bondTransCredit.ledgerTransObject().parmReportingCurrencyAmount();
                tmpBond.AmountCurCredit = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode());
            }
        }
        else
        {
            factor = _amountMSTSecond / bondTransCredit.ledgerTransObject().parmReportingCurrencyAmount();
            tmpBond.AmountMST       = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmAccountingCurrencyAmount() * factor, mstCode);
            tmpBond.AmountCurCredit = CurrencyExchangeHelper::amount(bondTransCredit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode());
            if (bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() == bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
            {
                tmpBond.AmountCurDebit = tmpBond.AmountCurCredit;
            }
            else
            {
                factor = _amountMSTSecond / bondTransDebit.ledgerTransObject().parmReportingCurrencyAmount();
                tmpBond.AmountCurDebit = CurrencyExchangeHelper::amount(bondTransDebit.ledgerTransObject().parmTransactionCurrencyAmount() * factor, bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode());
            }
        }
        tmpBond.AmountMST = min(tmpBond.AmountMST, maxBondAmountMst());

        if (bondTransDebit.ledgerTransObject().parmTransactionCurrencyCode() == bondTransCredit.ledgerTransObject().parmTransactionCurrencyCode())
        {
            tmpBond.AmountCurDebit = min(
                tmpBond.AmountCurDebit,
                maxBondAmountCur()
                );

            tmpBond.AmountCurCredit = tmpBond.AmountCurDebit;
        }
        else
        {
            if (!negativeRemainderDebit)
            {
                tmpBond.AmountCurDebit = min(tmpBond.AmountCurDebit, bondTransDebit.remainAmountCur());
            }

            if (!negativeRemainderCredit)
            {
                tmpBond.AmountCurCredit = min(tmpBond.AmountCurCredit, bondTransCredit.remainAmountCur());
            }
        }

        this.addBondFinal(tmpBond, bondTransDebit, bondTransCredit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds information about new transaction to bonding structures
    /// </summary>
    /// <param name="_transaction">
    ///   transaction
    /// </param>
    /// <param name="_vrefId">
    ///   internal id
    /// </param>
    /// <remarks>
    ///  This method shpuld be called when a new trasaction is created
    /// </remarks>
    public void addTrans(LedgerBondableTrans_RU _transaction,
                         LedgerBondId_RU        _vrefId = _transaction.parmID())
    {
        LedgerBondTransObject_RU bondTransObject = new LedgerBondTransObject_RU(
                                                        _vrefId,
                                                        _transaction);
        this.insertBondTransObject(bondTransObject);
        iDs += _vrefId;
        if (inSkipped)
        {
            if (! currentSkipped)
            {
                currentSkipped = new Set(Types::Integer);
            }
            currentSkipped.add(_vrefId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bondTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns list of remainders of bondable transactions
    /// </summary>
    /// <returns>
    /// LedgerBondTransList_RU
    /// </returns>
    LedgerBondTransList_RU bondTransactions()
    {
        return bondTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransObjects</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks properties of given transaction objects
    /// </summary>
    /// <param name="_transObject1">
    /// first object
    /// </param>
    /// <param name="_transObject2">
    /// secondObject
    /// </param>
    /// <returns>
    ///  true if OK otherwise - false
    /// </returns>
    public boolean checkTransObjects(LedgerBondTransObject_RU _transObject1,
                                     LedgerBondTransObject_RU _transObject2)
    {
        if (fatalError)
            return false;

        if (_transObject1.transDate() != _transObject2.transDate())
        {
            fatalError = true;
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endSkipping</Name>
				<Source><![CDATA[
    /// <summary>
    ///  ends range of transactions to be skipped in lastVrefID
    /// </summary>
    /// <remarks>
    /// see also startSkipping()
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///  call of method without prior call of startSkipping()
    /// </exception>
    void endSkipping()
    {
        if (! inSkipped)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        inSkipped = false;
        if (currentSkipped)
        {
            skipped = skipped ? Set::union(skipped, currentSkipped) : currentSkipped;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fatalErrorState</Name>
				<Source><![CDATA[
    /// <summary>
    ///  returns wherther fatal error was detected on previous actions
    /// </summary>
    /// <returns>
    ///  true if fatal error
    /// </returns>
    public boolean fatalErrorState()
    {
        return fatalError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBondTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns bond transaction object by VrefID
    /// </summary>
    /// <param name="_vRefId">
    /// LedgerBondVrefId_RU
    /// </param>
    /// <returns>
    /// LedgerBondTransObject_RU
    /// </returns>
    public LedgerBondTransObject_RU findBondTransObject(LedgerBondId_RU _vRefId)
    {
        fatalError = ! bondTransList.find(_vRefId) || fatalError;
        return bondTransList.item();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBondedVRefIDs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get container of vrefIDs that are bonded to given vref ID
    /// </summary>
    /// <param name="_id">
    /// ID of transaction
    /// </param>
    /// <returns>
    ///  container of bonded vrefIDs
    /// </returns>
    container getBondedVRefIDs(LedgerBondId_RU _id)
    {
        container ret;
        while select DebitBondId, CreditBondId from tmpBond
            where tmpBond.DebitBondId  == _id ||
                  tmpBond.CreditBondId == _id
        {
            ret += (tmpBond.DebitBondId  == _id) ? tmpBond.CreditBondId : tmpBond.DebitBondId;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBondTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Inserts _bondTransObject into the internal list
    /// </summary>
    /// <param name="_bondTransObject">
    /// LedgerBondTransObject_RU
    /// </param>
    void insertBondTransObject(LedgerBondTransObject_RU _bondTransObject)
    {
        if (! fatalError)
        {
            fatalError = ! bondTransList.add(_bondTransObject);
            bondLogList.lastLogObject().addBondTransObject(_bondTransObject);
            bondTransList.parmTransDate(_bondTransObject.transDate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastVrefId</Name>
				<Source><![CDATA[
    /// <summary>
    ///  VrefID of the last added transaction object
    /// </summary>
    /// <param name="_offset">
    ///    a number which is added to VRefID. Should be non positive
    /// </param>
    /// <param name="_useSkipping">
    ///  ignore transactions recorded between startSkipping() and endSkipping()
    /// </param>
    /// <returns>
    ///   LedgerBondVrefId_RU of the last added transaction
    /// </returns>
    /// <remarks>
    ///   see also startSkipping(), endSkipping()
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///   _offset most not be negative
    /// </exception>
    public LedgerBondId_RU lastVrefId(int _offset = 0, boolean _useSkipping = false)
    {
        return _useSkipping && skipped ? this.lastVrefId_withSkipped(_offset) : this.lastVrefId_withoutSkipped(_offset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastVrefId_withoutSkipped</Name>
				<Source><![CDATA[
    /// <summary>
    ///  VrefID of the last added transaction object
    /// </summary>
    /// <param name="_offset">
    ///    a number which is added to VRefID. Should be non positive
    /// </param>
    /// <returns>
    ///   LedgerBondVrefId_RU of the last added transaction
    /// </returns>
    /// <exception cref="Exception::Error">
    ///   ofset must not be negative
    /// </exception>
    protected LedgerBondId_RU lastVrefId_withoutSkipped(int _offset = 0)
    {
        LedgerBondId_RU ret = bondTransList.lastVrefId();

        if (! _offset)
            return ret;

        // Supposed to be called with an offset before splitting
        if (_offset > 0)
            throw error(Error::wrongUseOfFunction(funcName()));

        ret = conPeek(ids, conLen(ids) + _offset);
        return ret > 0 ? ret : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastVrefId_withSkipped</Name>
				<Source><![CDATA[
    /// <summary>
    ///  VrefID of the last added transaction object
    /// </summary>
    /// <param name="_offset">
    ///    a number which is added to VRefID. Should be non positive
    /// </param>
    /// <returns>
    ///   LedgerBondVrefId_RU of the last added transaction
    /// </returns>
    /// <exception cref="Exception::Error">
    /// VRefID list is empty
    /// </exception>
    protected LedgerBondId_RU lastVrefId_withSkipped(int _offset = 0)
    {
        int                 rest = _offset - 1;
        LedgerBondId_RU     ret;
        int                 i = conLen(ids);
        do
        {
            if (i < 0)
            {
                throw error(Error::wrongUseOfFunction(funcName()));
            }
            ret = conPeek(ids, i);
            if (! skipped.in(ret))
            {
                rest++;
            }
            i--;
        }
        while (rest != 0);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logList</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns list of logs
    /// </summary>
    /// <returns>
    /// LedgerBondLogList_RU
    /// </returns>
    public LedgerBondLogList_RU logList()
    {
        return bondLogList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        mstCode       = CompanyInfoHelper::standardCurrency();
        mstSecondCode = CompanyInfoHelper::secondaryCurrency_RU();

        bondTransList = new LedgerBondTransList_RU();
        bondLogList   = new LedgerBondLogList_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDiff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes rounding differences
    /// </summary>
    /// <param name="_transDate">
    /// Transaction date
    /// </param>
    public void processDiff(TransDate _transDate)
    {
        if (fatalError)
            return;

        bondTransList.parmTransDate(_transDate);
        this.processMSTDiff();
        this.processMSTDiffSecond();

        bondTransMSTDiff = null;
        bondTransMSTSecondDiff = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processMSTDiff</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Processes rounding difference in secondary currency
    /// </summary>
    private void processMSTDiff()
    {
        LedgerBondTransObject_RU      bondTransObject,
                                        bondTransObjectDebet,
                                        bondTransObjectCredit;
        Map                         mapTransDebet,mapTransCredit;
        MapEnumerator               enumeratorDebet,enumeratorCredit;
        Set                         equalsBondTransObject;
        Amount                      tmpAmount;
        boolean                     more;
        int                         i,j;
        LedgerBondableTrans_RU    ledgerTrans;

        void bondMstDiff(boolean _equals)
        {
            enumeratorDebet.reset();
            while (enumeratorDebet.moveNext())
            {
                bondTransObjectDebet = this.findBondTransObject(enumeratorDebet.currentValue());
                enumeratorCredit.reset();
                while (enumeratorCredit.moveNext())
                {
                    if (bondTransObjectDebet.remainAmountMST() == 0)
                    {
                        break;
                    }

                    bondTransObjectCredit = this.findBondTransObject(enumeratorCredit.currentValue());
                    if (bondTransObjectCredit.remainAmountMST() == 0)
                    {
                        continue;
                    }

                    if ((_equals ? bondTransObjectDebet.equals(bondTransObjectCredit) : true))
                    {
                        this.addBondMSTDiff(bondTransObjectDebet.vrefId(),
                                            bondTransObjectCredit.vrefId(),
                                            min(bondTransObjectDebet.remainAmountMST(),bondTransObjectCredit.remainAmountMST()));
                    }
                }
            }
        }

        mapTransDebet  = new Map(Types::Container,Types::Integer);
        mapTransCredit = new Map(Types::Container,Types::Integer);
        equalsBondTransObject = new Set(Types::Container);
        tmpAmount = 0;
        for (more = bondTransList.first();
             more;
             more = bondTransList.next())
        {
            bondTransObject = bondTransList.item();

            if (bondTransObject.remainAmountMST())
            {
                ledgerTrans = bondTransObject.ledgerTransObject();
                if (bondTransObject.remainCrediting())
                {
                    i++;
                    mapTransCredit.insert([ledgerTrans.parmTransactionCurrencyCode(),
                                           bondTransObject.remainAmountMST(),
                                           ledgerTrans.parmLedgerDimensionId(),
                                           i],
                                           bondTransObject.vrefId());
                    tmpAmount -= bondTransObject.remainAmountMST();
                }
                else
                {
                    j++;
                    mapTransDebet.insert([ledgerTrans.parmTransactionCurrencyCode(),
                                          bondTransObject.remainAmountMST(),
                                          ledgerTrans.parmLedgerDimensionId(),
                                          j],
                                          bondTransObject.vrefId());
                    tmpAmount += bondTransObject.remainAmountMST();
                }
            }
        }

        if (! tmpAmount)
        {
            enumeratorDebet  = mapTransDebet.getEnumerator();
            enumeratorCredit = mapTransCredit.getEnumerator();
            bondMstDiff(true);
            bondMstDiff(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processMSTDiffSecond</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Processes rounding difference in secondary currency
    /// </summary>
    private void processMSTDiffSecond()
    {
        LedgerBondTransObject_RU    bondTransObject;
        LedgerBondTransObject_RU    bondTransObjectDebet;
        LedgerBondTransObject_RU    bondTransObjectCredit;

        Map                         mapTransDebet;
        Map                         mapTransCredit;
        MapEnumerator               enumeratorDebet;
        MapEnumerator               enumeratorCredit;
        Set                         equalsBondTransObject;
        Amount                      tmpAmount;
        boolean                     more;
        int                         i,j;
        LedgerBondableTrans_RU    ledgerTrans;

        void bondMstDiff(boolean _equals)
        {
            enumeratorDebet.reset();
            while (enumeratorDebet.moveNext())
            {
                bondTransObjectDebet = this.findBondTransObject(enumeratorDebet.currentValue());
                enumeratorCredit.reset();
                while (enumeratorCredit.moveNext())
                {
                    if (bondTransObjectDebet.remainAmountMSTSecond() == 0)
                    {
                        break;
                    }

                    bondTransObjectCredit = this.findBondTransObject(enumeratorCredit.currentValue());
                    if (bondTransObjectCredit.remainAmountMSTSecond() == 0)
                    {
                        continue;
                    }

                    if ((_equals ? bondTransObjectDebet.equals(bondTransObjectCredit) : true))
                    {
                        this.addBondMSTSecondDiff(bondTransObjectDebet.vrefId(),
                                                  bondTransObjectCredit.vrefId(),
                                                  min(bondTransObjectDebet.remainAmountMSTSecond(),bondTransObjectCredit.remainAmountMSTSecond()));
                    }
                }
            }
        }

        mapTransDebet  = new Map(Types::Container,Types::Integer);
        mapTransCredit = new Map(Types::Container,Types::Integer);
        equalsBondTransObject = new Set(Types::Container);
        tmpAmount = 0;
        for (more = bondTransList.first();
             more;
             more = bondTransList.next())
        {
            bondTransObject = bondTransList.item();

            if (bondTransObject.remainAmountMSTSecond())
            {
                ledgerTrans = bondTransObject.ledgerTransObject();
                if (bondTransObject.remainCrediting())
                {
                    i++;
                    mapTransCredit.insert([ledgerTrans.parmTransactionCurrencyCode(),
                                           bondTransObject.remainAmountMSTSecond(),
                                           ledgerTrans.parmLedgerDimensionId(),
                                           i],
                                           bondTransObject.vrefId());
                    tmpAmount -= bondTransObject.remainAmountMSTSecond();
                }
                else
                {
                    j++;
                    mapTransDebet.insert([ledgerTrans.parmTransactionCurrencyCode(),
                                          bondTransObject.remainAmountMSTSecond(),
                                          ledgerTrans.parmLedgerDimensionId(),
                                          j],
                                          bondTransObject.vrefId());
                    tmpAmount += bondTransObject.remainAmountMSTSecond();
                }
            }
        }

        if (! tmpAmount)
        {
            enumeratorDebet  = mapTransDebet.getEnumerator();
            enumeratorCredit = mapTransCredit.getEnumerator();
            bondMstDiff(true);
            bondMstDiff(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeBonding</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all bonding related to transaction with _id
    /// </summary>
    /// <param name="_id">
    ///   BondId of transaction
    /// </param>
    public void removeBonding(LedgerBondId_RU _id)
    {
        LedgerBondTransObject_RU bondObjectBonded;
        LedgerBondTransObject_RU bondObject = this.findBondTransObject(_id);
        LedgerBondId_RU          bondedID;
        while select tmpBond
            where tmpBond.DebitBondId  == _id ||
                  tmpBond.CreditBondId == _id
        {
            bondedID = (tmpBond.DebitBondId  == _id) ? tmpBond.CreditBondId : tmpBond.DebitBondId;
            bondObjectBonded = this.findBondTransObject(bondedID);

            bondObjectBonded.addBondAmounts(
                tmpBond.DebitBondId  == _id,
                tmpBond.AmountMST,
                tmpBond.AmountMSTSecondary,
                (tmpBond.DebitBondId  == _id) ?
                    tmpBond.AmountCurCredit : tmpBond.AmountCurDebit
            );

            bondObject.addBondAmounts(
                tmpBond.DebitBondId  != _id,
                tmpBond.AmountMST,
                tmpBond.AmountMSTSecondary,
                (tmpBond.DebitBondId  == _id) ?
                    tmpBond.AmountCurDebit : tmpBond.AmountCurCredit
            );
            tmpBond.delete();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeBondTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes given _bondTransObject from logs
    /// </summary>
    /// <param name="_bondTransObject">
    /// <c>LedgerBondTransObject_RU</c>
    /// </param>
    void removeBondTransObject(LedgerBondTransObject_RU _bondTransObject)
    {
        boolean                 more;

        for (more = bondLogList.first();
             more;
             more = bondLogList.next())
        {
            bondLogList.item().remove(_bondTransObject.vrefId());
        }

        if (fatalError)
            return;

        bondTransList.remove(_bondTransObject.vrefId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Process removal of transaction
    /// </summary>
    /// <param name="_id">
    ///   Transaction ID
    /// </param>
    public void removeTrans(LedgerBondId_RU _id)
    {
        LedgerBondTransObject_RU bondObject = this.findBondTransObject(_id);
        Debug::assert(bondObject != null);
        this.removeBonding(_id);
        this.removeBondTransObject(bondObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBondTransMSTDiff</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Sets property - _bondTransObject which represents rounding difference in MST
    /// </summary>
    /// <param name="_bondTransObject">
    /// LedgerBondTransObject_RU
    /// </param>
    public void setBondTransMSTDiff(LedgerBondTransObject_RU _bondTransObject)
    {
        bondTransMSTDiff = _bondTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBondTransMSTSecondDiff</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Sets property - _bondTransObject which represents rounding difference in secondary currency
    /// </summary>
    /// <param name="_bondTransObject">
    /// LedgerBondTransObject_RU
    /// </param>
    public void setBondTransMSTSecondDiff(LedgerBondTransObject_RU _bondTransObject)
    {
        bondTransMSTSecondDiff = _bondTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startSkipping</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Starts recording of transactions to be skipped in lastVRefId
    /// </summary>
    /// <remarks>
    ///  The skipping is need to ensure correct work of lastVRefID in case when adding transaction
    ///  to voucher generate more stransaction (now at allocation). Additional transactions are
    ///  bethween startSkipping() and endSkipping() and will be ignored while evaluating
    ///  vrefID by offset in lastVrefID
    ///   see also endSkipping()
    /// </remarks>
    /// <exception cref="Exception::Error">
    ///    Skipping ranges can not be nested
    /// </exception>
    void startSkipping()
    {
        if (inSkipped)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        inSkipped = true;
        currentSkipped = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpBond</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns temporary table with bonding plan
    /// </summary>
    /// <returns>
    /// TmpLedgerBondWorkTable_RU
    /// </returns>
    TmpLedgerBondWorkTable_RU tmpBond()
    {
        return tmpBond;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transList</Name>
				<Source><![CDATA[
    /// <summary>
    /// List of all objects representing bonding remainders
    /// </summary>
    /// <returns>
    /// LedgerBondTransList_RU
    /// </returns>
    public LedgerBondTransList_RU transList()
    {
        return bondTransList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates ledger dimension in transaction.
    /// </summary>
    /// <param name="_transaction">
    /// Transaction.
    /// </param>
    /// <remarks>
    /// Added for case when exist fixed dimensions in MainAccount and
    /// these dimensions were applied after insert transactions in bonding structures.
    ///</remarks>
    public void updateLedgerDimension(LedgerBondableTrans_RU _transaction)
    {
        if (_transaction.parmLedgerDimensionId())
        {
            LedgerBondTransObject_RU bondTransObject = this.findBondTransObject(_transaction.parmID());
            
            if (bondTransObject)
            {
                bondTransObject.ledgerTransObject().parmLedgerDimensionId(_transaction.parmLedgerDimensionId());
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>