<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjWBSUpdateController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ProjWBSUpdateController</c> class is responsible for reading and updating a WBS tree.
/// </summary>
class ProjWBSUpdateController
{
    ProjWBSTree                 tree;
    ProjExpandCollapseManager   expandCollapseManager;
    TmpTreeTable                tmpTreeTable;

    str tab;

    HierarchyTreeTable                      selectedHierarchyTreeTable;
    ProjTable                               projTable;
    SalesQuotationTable                     salesQuotationTable;
    Common                                  wbsOwner;
    CalendarId                              calendarId;
    StandardWorkDayHours                    standardWorkingHours;
    UnitOfMeasureDecimalPrecision           timeUnitPrecision;
    boolean                                 isDebugOn;
    ProjWBSSchedulingErrorsFixingOptions    fixingOptions;
    CategoryId                              categoryId;
    ProjViewType                            viewType;
    Set                                     activityNumbers;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activityNumberToElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Wrapper for tree utility method to convert an Activity Number to Element number.
    /// </summary>
    /// <param name="_smmActivityNumber">
    /// ActivityNumber that needs to be converted.
    /// </param>
    /// <returns>
    /// Element number for corresponding activity number.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public ElementNumber activityNumberToElementNumber(smmActivityNumber _smmActivityNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualCostFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets actual cost of given task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task.
    /// </param>
    /// <returns>
    ///     Actual cost.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Total actualCostFor(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualEffortFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Actual effort for given task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task.
    /// </param>
    /// <returns>
    ///     Actual effort.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Hours actualEffortFor(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAncestorsToNodesSorting</Name>
				<Source><![CDATA[
    private void addAncestorsToNodesSorting(ProjWBSTreeNode _node, Map _nodesSorting)
    {
        ProjWBSTreeNode currentNode = _node;
        while (currentNode.parmParentElementNumber())
        {
            currentNode = tree.getParentNodeOf(currentNode.elementNumber());
            if (!_nodesSorting.insert(currentNode.parmChildrensPath(), currentNode))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addDependenciesToDB</Name>
				<Source><![CDATA[
    private void addDependenciesToDB(Set _predecessors, smmActivityNumber _successor)
    {
        Enumerator          predecessorsEnum = _predecessors.getEnumerator();
        RecordInsertList    dependenciesList = new RecordInsertList(tableNum(ProjDependency), true, true, true, false, true);

        ProjDependency      dependency;

        while (predecessorsEnum.moveNext())
        {
            dependency.Predecessor  = predecessorsEnum.current();
            dependency.Successor    = _successor;
            dependenciesList.add(dependency);
        }

        dependenciesList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Add a task to the WBS.
    /// </summary>
    /// <param name="_hierarchyTreeTable">
    ///     Hierarchy node record of the task.
    /// </param>
    /// <param name="_smmActivities">
    ///     Activity record of the task.
    /// </param>
    /// <param name="_psaActivitySetup">
    ///     Task specific information of the task.
    /// </param>
    /// <param name="_projActivity">
    ///     Project activity record of the task.
    /// </param>
    /// <param name="_predecessorsList">
    ///     List of predecessors of a task that is being added.
    /// </param>
    /// <returns>
    ///     Whether the Add operation was actually performed.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean addTask(HierarchyTreeTable           _hierarchyTreeTable,
                           smmActivities                _smmActivities,
                           PSAActivitySetup             _psaActivitySetup,
                           ProjActivity                 _projActivity,
                           List                         _predecessorsList = null)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaskToDatabase</Name>
				<Source><![CDATA[
    private boolean addTaskToDatabase(HierarchyTreeTable _hierarchyTreeTable, smmActivities _smmActivities, PSAActivitySetup _psaActivitySetup)
    {
        this.incrementSiblingNumbersInDatabase(_hierarchyTreeTable.SiblingNumber, _hierarchyTreeTable.ParentElementNumber, _hierarchyTreeTable.ElementNumber);
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaskToTree</Name>
				<Source><![CDATA[
    private boolean addTaskToTree(HierarchyTreeTable _hierarchyTreeTable, smmActivities _smmActivities, PSAActivitySetup _psaActivitySetup, ProjActivity _projActivity)
    {
        ProjWBSTreeNode newNode;

        if (tree.isQuotation())
        {
            categoryId = _psaActivitySetup.CategoryDefault;
        }
        else
        {
            categoryId = _projActivity.CategoryDefault;
        }

        newNode =   new ProjWBSTreeNode(_hierarchyTreeTable.ElementNumber,
                                        _hierarchyTreeTable.ParentElementNumber,
                                        _hierarchyTreeTable.SiblingNumber,
                                        _psaActivitySetup.ActivityNumber,
                                        _hierarchyTreeTable.Path,
                                        true,
                                        _smmActivities.Purpose,
                                        categoryId,
                                        _psaActivitySetup.Effort,
                                        _psaActivitySetup.psaSchedStart,
                                        _psaActivitySetup.psaSchedEnd,
                                        _psaActivitySetup.ActivityDuration,
                                        _psaActivitySetup.NumberOfResources,
                                        new Set(Types::String),
                                        0.0,
                                        0.0,
                                        _psaActivitySetup.CostAtComplete,
                                        0.0,
                                        _psaActivitySetup.EffortAtComplete);
        this.incrementSiblingNumbersInTree(newNode);
        tree.insertNewNode(newNode);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cacheCalendarParameters</Name>
				<Source><![CDATA[
    private void cacheCalendarParameters()
    {
        WorkCalendarTable workCalendarTable;
        select firstonly StandardWorkDayHours from workCalendarTable
              where workCalendarTable.CalendarId == calendarId;

        standardWorkingHours = workCalendarTable.StandardWorkDayHours;
        timeUnitPrecision = max(UnitOfMeasure::findByInternalCode(UnitOfMeasureCodeSymbol::Hours).DecimalPrecision, this.getDefaultHourPrecision());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoLoops</Name>
				<Source><![CDATA[
    private boolean checkNoLoops(ProjWBSTreeNode _node, Map _operatorsMap = null, Map _labelsMap = null)
    {
        ProjWBSTreeNodeOperator     nodeOperator;
        ProjWBSTreeNode             currentNode;
        Map                         labelsMap           = _labelsMap ? _labelsMap : new Map(Types::String, Types::Integer);
        Stack                       vertexStack         = new Stack();
        container                   cont;

        ElementNumber               currentDependencyElementNumber, currentNodeElementNumber;

        boolean skip = false;
        vertexStack.push([_node.elementNumber()]);
        while (vertexStack.qty() != 0)
        {
            skip = false;
            cont = vertexStack.pop();
            vertexStack.push(cont);

            currentNodeElementNumber = conPeek(cont, 1);
            currentNode = this.getNodeByElementNumber(currentNodeElementNumber);

            if (_operatorsMap && _operatorsMap.exists(currentNode.parmChildrensPath()))
            {
                nodeOperator = _operatorsMap.lookup(currentNode.parmChildrensPath());
            }
            else
            {
                nodeOperator = ProjWBSTreeNodeOperator::construct(tree, currentNode);
            }

            while (nodeOperator.moveNext())
            {
                currentDependencyElementNumber = nodeOperator.current();
                if (!labelsMap.exists(currentDependencyElementNumber))
                {
                    vertexStack.push([currentDependencyElementNumber]);
                    labelsMap.insert(currentDependencyElementNumber, 1);
                    skip = true;
                    break;
                }
                else if (labelsMap.lookup(currentDependencyElementNumber) != 2)
                {
                    return false;
                }
            }

            if (skip)
            {
                continue;
            }

            labelsMap.insert(currentNodeElementNumber, 2);
            cont = vertexStack.pop();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoLoopsBeforeMultipleOperation</Name>
				<Source><![CDATA[
    private boolean checkNoLoopsBeforeMultipleOperation(Map _nodeOperatorsSortedByChildrensPath)
    {
        Map labelsMap = new Map(Types::String, Types::Integer);

        MapEnumerator operatorsEnumerator = _nodeOperatorsSortedByChildrensPath.getEnumerator();
        ProjWBSTreeNode currentNode;
        HierarchyPath currentPath;

        while (operatorsEnumerator.moveNext())
        {
            if (!currentPath || !ProjWBSTreeNode::isSubPath(operatorsEnumerator.currentKey(), currentPath))
            {
                currentNode = operatorsEnumerator.currentValue().parmNode();
                if (!labelsMap.exists(currentNode.elementNumber()) && !this.checkNoLoops(currentNode, _nodeOperatorsSortedByChildrensPath, labelsMap))
                {
                    return false;
                }
                currentPath = operatorsEnumerator.currentKey();
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPredecessorsBeforeIndenting</Name>
				<Source><![CDATA[
    private boolean checkPredecessorsBeforeIndenting(ProjWBSTreeNode _parentNode, ProjWBSTreeNode _childNode)
    {
        Map predecessorEnumerators = new Map(Types::String, Types::Class);
        ProjWBSTreeNode previousParentNode = tree.getNodeByElementNumber(_parentNode.parmParentElementNumber());

        predecessorEnumerators.insert(_parentNode.elementNumber(),
                                      ProjDependecyEnumerator::constructForParentNodeWithNewChild(tree, _parentNode, _childNode.elementNumber()));
        predecessorEnumerators.insert(_childNode.elementNumber(),
                                      ProjDependecyEnumerator::construct(tree, _childNode, _parentNode.activityNumber()));
        predecessorEnumerators.insert(previousParentNode.elementNumber(),
                                      ProjDependecyEnumerator::construct(tree, previousParentNode, "", new List(Types::String)));

        return this.checkNoLoops(previousParentNode, predecessorEnumerators);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPredecessorsBeforeOutdenting</Name>
				<Source><![CDATA[
    private boolean checkPredecessorsBeforeOutdenting(ProjWBSTreeNode _outdentedNode)
    {
        Map             predecessorEnumerators  = new Map(Types::String, Types::Class);
        ProjWBSTreeNode parentNode              = this.getNodeByElementNumber(_outdentedNode.parmParentElementNumber());
        ProjWBSTreeNode grandParentNode         = tree.getParentNodeOf(parentNode.elementNumber());
        ProjWBSTreeNode childNode;
        List            children                = tree.getChildrenOf(parentNode.elementNumber());
        ListEnumerator  childrenEnumerator      = children.getEnumerator();
        List            childrenToAdd           = new List(Types::String);

        predecessorEnumerators.insert(parentNode.elementNumber(),
                                      ProjDependecyEnumerator::construct(tree, parentNode, "", new List(Types::String), _outdentedNode.elementNumber()));

        while (childrenEnumerator.moveNext())
        {
            childNode = tree.getNodeByElementNumber(childrenEnumerator.current());
            if (childNode.parmSiblingNumber() > _outdentedNode.parmSiblingNumber())
            {
                childrenToAdd.addEnd(childNode.elementNumber());
                predecessorEnumerators.insert(childNode.elementNumber(),
                                              ProjDependecyEnumerator::construct(tree, childNode, _outdentedNode.activityNumber()));
            }
            else
            {
                break;
            }
        }

        predecessorEnumerators.insert(_outdentedNode.elementNumber(),
                                      ProjDependecyEnumerator::construct(tree, _outdentedNode, "", childrenToAdd));

        predecessorEnumerators.insert(grandParentNode.elementNumber(),
                                    ProjDependecyEnumerator::constructForParentNodeWithNewChild(tree, grandParentNode, _outdentedNode.elementNumber()));

        return this.checkNoLoops(grandParentNode, predecessorEnumerators);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanDependenciesForNewParent</Name>
				<Source><![CDATA[
    private void cleanDependenciesForNewParent(ProjWBSTreeNode _node)
    {
        ProjWBSTreeNode parentNode          = tree.getParentNodeOf(_node.elementNumber());
        ProjWBSTreeNode currentNode;
        List            children            = tree.getChildrenOf(parentNode.elementNumber());
        Enumerator      childrenEnumerator  = children.getEnumerator();

        while (childrenEnumerator.moveNext())
        {
            currentNode = tree.getNodeByElementNumber(childrenEnumerator.current());
            if (currentNode.parmSiblingNumber() > _node.parmSiblingNumber())
            {
                if (currentNode.parmPredecessors().remove(_node.activityNumber()))
                {
                    this.removeDependencyFromDB(_node.activityNumber(), currentNode.activityNumber());
                }
            }
            else
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearDependenciesFromDB</Name>
				<Source><![CDATA[
    private void clearDependenciesFromDB(smmActivityNumber _successor)
    {
        ProjDependency dependency;
        if (tree.getNodeByActivityNumber(_successor))
        {
            delete_from dependency
                where dependency.Successor == _successor;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertLeafToSummaryTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Converts given leaf task to a summary task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the leaf task.
    /// </param>
    /// <param name="_recomputeSummariesUpToTheRoot">
    ///     Indicates if recomputation of summaries up to the root is needed.
    /// </param>
    public void convertLeafToSummaryTask(ElementNumber _elementNumber, boolean _recomputeSummariesUpToTheRoot = true)
    {
        ProjWBSTreeNode node;
        PSAActivitySetup psaActivitySetup;
        ProjActivity projActivity;
        PSAActivityEstimates psaActivityEstimates;

        node = tree.getNodeByElementNumber(_elementNumber);
        ttsbegin;
        if (_recomputeSummariesUpToTheRoot)
        {
            this.recomputeSummariesFromTaskUpToTheRoot(node.elementNumber());
        }

        projActivity = ProjActivity::find(node.activityNumber(), true);
        psaActivitySetup = PSAActivitySetup::findActivityNumber(node.activityNumber(), true);

        if (projActivity)
        {
            projActivity.CategoryDefault = "";  // Wipe its category.
            projActivity.update();
        }
        if (psaActivitySetup)
        {
            if (salesQuotationTable)
            {
                psaActivitySetup.CategoryDefault = "";
            }
            psaActivitySetup.selectForUpdate(true);
            psaActivitySetup.NumberOfResources = 0;  // Wipe number of resources.
            psaActivitySetup.update();
        }

        //delete all estimate Lines
        delete_from psaActivityEstimates
            where psaActivityEstimates.ActivityNumber == node.activityNumber();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costAtCompleteFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Task cost at complete.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task.
    /// </param>
    /// <returns>
    ///     Cost at complete.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Total costAtCompleteFor(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIndentOperators</Name>
				<Source><![CDATA[
    private Map createIndentOperators(Map _tasksSorting)
    {
        MapEnumerator               pathsEnumerator         = _tasksSorting.getEnumerator();
        Map                         nodesOperators          = new Map(Types::String, Types::Class);
        str                         currentPath             = "";
        Map                         indentedSiblingsSorting = new Map(Types::Real, Types::Class);
        ProjWBSTreeNode             indentedNode;

        //creating list of nodes
        while (pathsEnumerator.moveNext())
        {
            if (!currentPath || subStr(pathsEnumerator.currentKey(), 0, strlen(currentPath)) != currentPath)
            {
                indentedNode   = pathsEnumerator.currentValue();
                if (currentPath && subStr(currentPath, 0, strLen(currentPath) - strLen(indentedNode.ElementNumber()) - 1) != indentedNode.parmPath())
                {
                    this.createOperatorsForIndentedSiblings(indentedSiblingsSorting, nodesOperators);
                    indentedSiblingsSorting = new Map(Types::Real, Types::Class);
                }

                indentedSiblingsSorting.insert(indentedNode.parmSiblingNumber(), indentedNode);
                currentPath = pathsEnumerator.currentKey();
            }
        }

        this.createOperatorsForIndentedSiblings(indentedSiblingsSorting, nodesOperators);

        return nodesOperators;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOperatorsForIndentedSiblings</Name>
				<Source><![CDATA[
    private void createOperatorsForIndentedSiblings(Map _indentedSiblingsSorting, Map _nodesOperators)
    {
        ProjWBSTreeNode         currentSiblingNode, previousSiblingNode, newParentNode, grandParentNode;
        ProjWBSTreeNodeOperator newParentOperator, currentSiblingOperator;
        MapEnumerator           indentedSiblingsEnumerator = _indentedSiblingsSorting.getEnumerator();

        MapEnumerator           childrenToinsertEnumerator;
        List                    currentChildrenToInsert;

        void initParentContext()
        {
            str childrensPathsOfNewParentNode = newParentNode.parmChildrensPath();
            if (_nodesOperators.exists(childrensPathsOfNewParentNode))
            {
                newParentOperator = _nodesOperators.lookup(newParentNode.parmChildrensPath());
            }
            else
            {
                newParentOperator = ProjWBSTreeNodeOperator::construct(tree, newParentNode);
                _nodesOperators.insert(childrensPathsOfNewParentNode, newParentOperator);
            }

            childrenToinsertEnumerator = newParentOperator.parmChildrenToInsert().getEnumerator();
            if (childrenToinsertEnumerator.moveNext())
            {
                currentChildrenToInsert = childrenToinsertEnumerator.currentValue();
            }
            else
            {
                currentChildrenToInsert = new List(Types::Class);
                newParentOperator.parmChildrenToInsert().insert(tree.getChildrenOf(newParentNode.elementNumber()).elements(), currentChildrenToInsert);
            }
        }

        if (!indentedSiblingsEnumerator.moveNext())
        {
            return;
        }

        currentSiblingNode = indentedSiblingsEnumerator.currentValue();
        if (currentSiblingNode.parmSiblingNumber() == 1)
        {
            if (!indentedSiblingsEnumerator.moveNext())
            {
                return;
            }
        }

        do
        {
            currentSiblingNode = indentedSiblingsEnumerator.currentValue();
            if (!previousSiblingNode || currentSiblingNode.parmSiblingNumber() - previousSiblingNode.parmSiblingNumber() > 1)
            {
                newParentNode = tree.getPreviousSibling(currentSiblingNode);
                initParentContext();
            }

            currentChildrenToInsert.addStart(currentSiblingNode);
            currentSiblingOperator = ProjWBSTreeNodeOperator::construct(tree, currentSiblingNode, newParentNode.activityNumber());
            _nodesOperators.insert(currentSiblingNode.parmChildrensPath(), currentSiblingOperator);
            previousSiblingNode = currentSiblingNode;
        }while (indentedSiblingsEnumerator.moveNext());

        grandParentNode = tree.getParentNodeOf(newParentNode.elementNumber());
        _nodesOperators.insert(grandParentNode.parmChildrensPath(), ProjWBSTreeNodeOperator::construct(tree, grandParentNode));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOperatorsForOutdentedSiblings</Name>
				<Source><![CDATA[
    private void createOperatorsForOutdentedSiblings(Map _outdentedSiblingsSorting, Map _nodesOperators)
    {
        List                    allSiblings, currentOutdentedNodeChildren;
        ListEnumerator          allSiblingsEnumerator;
        LineNum                 insertAfter;
        Map                     childrenToInsert;
        List                    currentOutdentedNodeNewChildren = new List(Types::Class);
        List                    outdentedNodesList = new List(Types::Class);
        ProjWbsTreeNode         currentOutdentedNode, currentSiblingNode, parentNode, grandParentNode;
        ProjWBSTreeNodeOperator currentOperator;

        MapEnumerator           outdentedSiblingEnumerator  = _outdentedSiblingsSorting.getEnumerator();

        if (!outdentedSiblingEnumerator.moveNext())
        {
            return;
        }

        currentOutdentedNode = outdentedSiblingEnumerator.currentValue();
        parentNode = tree.getNodeByElementNumber(currentOutdentedNode.parmParentElementNumber());
        grandParentNode = tree.getNodeByElementNumber(parentNode.parmParentElementNumber());

        allSiblings           = tree.getChildrenOf(parentNode.elementNumber());
        allSiblingsEnumerator = allSiblings.getEnumerator();

        while (allSiblingsEnumerator.moveNext())
        {
            currentSiblingNode = tree.getNodeByElementNumber(allSiblingsEnumerator.current());
            if (currentSiblingNode.parmSiblingNumber() > currentOutdentedNode.parmSiblingNumber())
            {
                currentOutdentedNodeNewChildren.addStart(currentSiblingNode);
                currentOperator = ProjWBSTreeNodeOperator::construct(tree, currentSiblingNode, currentOutdentedNode.activityNumber(), null, "", true);
                _nodesOperators.insert(currentSiblingNode.parmChildrensPath(), currentOperator);
            }
            else
            {
                currentOutdentedNodeChildren = tree.getChildrenOf(currentOutdentedNode.elementNumber());
                insertAfter = currentOutdentedNodeChildren.elements();

                childrenToInsert = new Map(Types::Real, Types::Class);
                childrenToInsert.insert(insertAfter, currentOutdentedNodeNewChildren);

                currentOperator = ProjWBSTreeNodeOperator::construct(tree, currentOutdentedNode, grandParentNode.activityNumber(), childrenToInsert);
                currentOperator.parmChildrenToInsertContiguous(true);

                _nodesOperators.insert(currentOutdentedNode.parmChildrensPath(), currentOperator);
                outdentedNodesList.addEnd(currentOutdentedNode);

                if (outdentedSiblingEnumerator.moveNext())
                {
                    currentOutdentedNodeNewChildren = new List(Types::Class);
                    currentOutdentedNode = outdentedSiblingEnumerator.currentValue();
                }
                else
                {
                    break;
                }
            }
        }

        if (!_nodesOperators.exists(grandParentNode.parmChildrensPath()))
        {
            currentOperator = ProjWBSTreeNodeOperator::construct(tree, grandParentNode);
            _nodesOperators.insert(grandParentNode.parmChildrensPath(), currentOperator);
        }
        else
        {
            currentOperator = _nodesOperators.lookup(grandParentNode.parmChildrensPath());
        }
        childrenToInsert = currentOperator.parmChildrenToInsert();
        childrenToInsert.insert(parentNode.parmSiblingNumber(), outdentedNodesList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOutdentOperators</Name>
				<Source><![CDATA[
    private Map createOutdentOperators(Map _tasksSorting)
    {
        MapEnumerator               pathsEnumerator         = _tasksSorting.getEnumerator();
        Map                         nodesOperators          = new Map(Types::String, Types::Class);
        str                         currentPath             = "";

        Map                         outdentedSiblingsSorting = new Map(Types::Real, Types::Class);

        ProjWBSTreeNodeOperator     currentOperator;
        ProjWBSTreeNode             outdentedNode, parentNode;

        //creating list of nodes
        while (pathsEnumerator.moveNext())
        {
            if (!currentPath || subStr(pathsEnumerator.currentKey(), 0, strlen(currentPath)) != currentPath)
            {
                //filling context
                outdentedNode   = pathsEnumerator.currentValue();
                parentNode      = tree.getParentNodeOf(outdentedNode.elementNumber());

                if (!parentNode || !tree.getParentNodeOf(parentNode.elementNumber()))
                {
                    continue;
                }

                //creating operators for outdented node parent
                if (nodesOperators.exists(parentNode.parmChildrensPath()))
                {
                    currentOperator = nodesOperators.lookup(parentNode.parmChildrensPath());
                    if (currentOperator.parmChildToExcludeFrom() && currentOperator.parmChildToExcludeFrom().parmSiblingNumber() > outdentedNode.parmSiblingNumber())
                    {
                        nodesOperators.insert(parentNode.parmChildrensPath(),
                                          ProjWBSTreeNodeOperator::construct(tree, parentNode, "", null, outdentedNode.elementNumber()));
                    }
                }
                else
                {
                    nodesOperators.insert(parentNode.parmChildrensPath(),
                                          ProjWBSTreeNodeOperator::construct(tree, parentNode, "", null, outdentedNode.elementNumber()));
                }

                //creating operators for outdented nodes themselves and for their grandparent
                if (currentPath && subStr(currentPath, 0, strLen(currentPath) - strLen(outdentedNode.ElementNumber()) - 1) != outdentedNode.parmPath())
                {
                    this.createOperatorsForOutdentedSiblings(outdentedSiblingsSorting, nodesOperators);
                    outdentedSiblingsSorting = new Map(Types::Real, Types::Class);
                }

                outdentedSiblingsSorting.insert(-1 * outdentedNode.parmSiblingNumber(), outdentedNode);
                currentPath = pathsEnumerator.currentKey();
            }
        }

        this.createOperatorsForOutdentedSiblings(outdentedSiblingsSorting, nodesOperators);

        return nodesOperators;
    }

]]></Source>
			</Method>
			<Method>
				<Name>decrementSiblingNumbersInDatabase</Name>
				<Source><![CDATA[
    private void decrementSiblingNumbersInDatabase(LineNum _startSiblingNumber, ElementNumber _parentElementNumber)
    {
        HierarchyTreeTable hierarchyTreeTable;

        hierarchyTreeTable.skipDataMethods(true);
        hierarchyTreeTable.skipEvents(true);

        update_recordset hierarchyTreeTable
        setting
            SiblingNumber = hierarchyTreeTable.SiblingNumber - 0.9
        where
            hierarchyTreeTable.HierarchyId == tree.hierarchyId()
            && hierarchyTreeTable.ParentElementNumber == _parentElementNumber
            && hierarchyTreeTable.SiblingNumber >= _startSiblingNumber;

        update_recordset hierarchyTreeTable
        setting
            SiblingNumber = hierarchyTreeTable.SiblingNumber - 0.1
        where
            hierarchyTreeTable.HierarchyId == tree.hierarchyId()
            && hierarchyTreeTable.ParentElementNumber == _parentElementNumber
            && hierarchyTreeTable.SiblingNumber >= _startSiblingNumber + 0.1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteSubTreeNodes</Name>
				<Source><![CDATA[
    private boolean deleteSubTreeNodes(ElementNumber _subTreeRootElementNumber)
    {
        ProjWBSTreeNode     selectedNode = tree.getNodeByElementNumber(_subTreeRootElementNumber);
        ProjWBSTreeNode     firstAncestorNode;

        HierarchyTreeTable  hierarchyTreeTable;

        Set     impactedNodes;
        List    deletedNodes;

        ttsbegin;
        // Delete task from inmem tree and indb tree.
        impactedNodes = hierarchyTreeTable.deleteActivityHierarchy(tree.hierarchyId(), _subTreeRootElementNumber);

        if (impactedNodes == null)
        {
            ttsCommit;
            return false;
        }

        firstAncestorNode = tree.getParentNodeOf(_subTreeRootElementNumber);
        tree.removeChild(selectedNode);
        deletedNodes = tree.cleanupChildrenAfterDelete(selectedNode);
        if (impactedNodes)
        {
            tree.cleanupPredecessorsAfterDelete(impactedNodes, deletedNodes);
        }

        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates task.
    /// </summary>
    /// <param name="_hierarchyTreeTable">
    ///     <c>hierarchyTreeTable</c> record of the task to move down.
    /// </param>
    /// <param name="_smmActivities">
    ///     <c>smmActivities</c> record of the task to move down.
    /// </param>
    /// <param name="_psaActivitySetup">
    ///     <c>PSAActivitySetup</c> record of the task to move down.
    /// </param>
    /// <param name="_projActivity">
    ///     <c>ProjActivity</c> record of the task to move down.
    /// </param>
    /// <returns>
    ///     true if it was successful; false otherwise.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean editTask(HierarchyTreeTable _hierarchyTreeTable, smmActivities _smmActivities, PSAActivitySetup _psaActivitySetup, ProjActivity _projActivity)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>editTaskInTree</Name>
				<Source><![CDATA[
    private boolean editTaskInTree(HierarchyTreeTable _hierarchyTreeTable, smmActivities _smmActivities, PSAActivitySetup _psaActivitySetup, ProjActivity _projActivity)
    {
        ProjWBSTreeNode node = tree.getNodeByElementNumber(_hierarchyTreeTable.ElementNumber);

        if (tree.isQuotation())
        {
            node.parmCategory(_psaActivitySetup.CategoryDefault);
        }
        else
        {
            node.parmCategory(_projActivity.CategoryDefault);
        }

        node.parmName(_smmActivities.Purpose);
        node.parmEffort(_psaActivitySetup.Effort);
        node.parmCostAtComplete(_psaActivitySetup.CostAtComplete);
        node.parmEffortAtComplete(_psaActivitySetup.EffortAtComplete);
        node.parmStartDate(_psaActivitySetup.psaSchedStart);
        node.parmEndDate(_psaActivitySetup.psaSchedEnd);
        node.parmActivityDuration(_psaActivitySetup.ActivityDuration);
        node.parmNumberOfResources(_psaActivitySetup.NumberOfResources);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>effortAtCompleteFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets effort at complete of the given task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task.
    /// </param>
    /// <returns>
    ///     Effort at complete.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Hours effortAtCompleteFor(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandUpTo</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Expands WBS tree up to given level.
    /// </summary>
    /// <param name="_level">
    ///     Level.
    /// </param>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void expandUpTo(Integer _level)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProjCostPrice</Name>
				<Source><![CDATA[
    private CostPrice findProjCostPrice(smmActivityNumber _activityNumber)
    {
        ProjCategoryId taskDefaultCategory;

        if (salesQuotationTable)
        {
            taskDefaultCategory = PSAActivitySetup::findActivityNumber(_activityNumber).CategoryDefault;
        }
        else
        {
            taskDefaultCategory = ProjActivity::find(_activityNumber).CategoryDefault;
        }

        return ProjHourCostPrice::findProjCostPrice(projTable.ProjId, 0, taskDefaultCategory, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), salesQuotationTable.CustAccount, '').CostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixSchedulingDiscrepancies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fixes WBS summaries, start dates, end dates and duration according to intra-task
    /// and inter-task dependencies.
    /// </summary>
    /// <param name="_rootNodeActivityNumber">
    /// Optional parameter that specifies root node of subtree to fix. If blank,
    /// the entire hierarchy is fixed.
    /// </param>
    /// <param name="_eacOnly">
    /// If true, only resummarizes EAC (Estimate at complete) fields (e.g. Cost at complete, Effort at complete).
    /// </param>
    public void fixSchedulingDiscrepancies(smmActivityNumber _rootNodeActivityNumber = "", boolean _eacOnly = false)
    {
        List                topologicallySortedActivityNumbers;
        ListEnumerator      activityNumbersEnumerator;
        ProjWBSTreeNode     currNode;
        PSAActivitySetup    psaActivitySetup;
        TransDate           predecessorsLastDate;
        TransDate           nextWorkingDayAfterPredecessors;
        ProjAutoScheduler   projAutoScheduler;
        boolean             predecessorsError, effortError;

        if (calendarId)
        {
            projAutoScheduler = new ProjAutoScheduler(calendarId);
        }

        if (_rootNodeActivityNumber)
        {
            topologicallySortedActivityNumbers = this.produceDependenciesSortingForSubtree(_rootNodeActivityNumber);
        }
        else
        {
            topologicallySortedActivityNumbers = this.produceDependenciesSorting();
        }

        activityNumbersEnumerator = topologicallySortedActivityNumbers.getEnumerator();

        while (activityNumbersEnumerator.moveNext())
        {
            currNode = this.getNodeByActivityNumber(activityNumbersEnumerator.current());
            select forupdate psaActivitySetup
                where psaActivitySetup.ActivityNumber == currNode.activityNumber();

            if (currNode.elementNumber() != this.getRootElementNumber()
                && !this.hasChildrenByElementNumber(currNode.elementNumber()))
            {
                if (!_eacOnly)
                {
                    predecessorsLastDate = this.getPredecessorsLastDate(currNode.activityNumber());
                    nextWorkingDayAfterPredecessors = WorkCalendarCalculator::findNextWorkDayAfterDate(psaActivitySetup.CalendarId, predecessorsLastDate);

                    predecessorsError = predecessorsLastDate && (currNode.parmStartDate() != nextWorkingDayAfterPredecessors);
                    effortError = this.hasEffortError(psaActivitySetup);

                    if (predecessorsError)
                    {
                        psaActivitySetup.psaSchedStart = WorkCalendarCalculator::findNextWorkDayAfterDate(calendarId, predecessorsLastDate);
                    }

                    if (predecessorsError || effortError)
                    {
                        projAutoScheduler.calcFieldsRelatedToEffort(psaActivitySetup);
                        ttsbegin;
                        psaActivitySetup.update();
                        ttscommit;
                        this.updateSmmActivities(psaActivitySetUp);

                        currNode.parmStartDate(psaActivitySetup.psaSchedStart);
                        currNode.parmEndDate(psaActivitySetup.psaSchedEnd);
                        currNode.parmEffort(psaActivitySetup.Effort);
                    }
                }
            }
            else
            {
                this.recomputeSingleTaskSummaries(currNode, psaActivitySetup, _eacOnly);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultHourPrecision</Name>
				<Source><![CDATA[
    private UnitOfMeasureDecimalPrecision getDefaultHourPrecision()
    {
        //Default precision for Hours comparsion
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIndentationByActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets indentation by activity number.
    /// </summary>
    /// <param name="_smmActivityNumber">
    ///     Activity number.
    /// </param>
    /// <returns>
    ///     Indentation.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public str getIndentationByActivityNumber(smmActivityNumber _smmActivityNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodeByActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets in-memory task node by activity number.
    /// </summary>
    /// <param name="_smmActivityNumber">
    ///     Activity number.
    /// </param>
    /// <returns>
    ///     In-memory task node.
    /// </returns>
    public ProjWBSTreeNode getNodeByActivityNumber(smmActivityNumber _smmActivityNumber)
    {
        return tree.getNodeByElementNumber(tree.activityNumberToElementNumber(_smmActivityNumber));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodeByChildrensPath</Name>
				<Source><![CDATA[
    private ProjWBSTreeNode getNodeByChildrensPath(HierarchyPath _fullPath)
    {
        int             length;
        int             dividerPosition;
        ElementNumber   elementNumber;
        #Characters;

        length          = strLen(_fullPath);
        dividerPosition = strFind(_fullPath, #sharp,  length - 2, -1 * length + 1);
        elementNumber   = subStr(_fullPath, dividerPosition ? dividerPosition + 1 : 0, length - dividerPosition + 1);

        return tree.getNodeByElementNumber(elementNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodeByElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets in-memory task node given its element number.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number.
    /// </param>
    /// <returns>
    ///     In-memory task node.
    /// </returns>
    public ProjWBSTreeNode getNodeByElementNumber(ElementNumber _elementNumber)
    {
        return tree.getNodeByElementNumber(_elementNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodesMapSortedByPath</Name>
				<Source><![CDATA[
    protected Map getNodesMapSortedByPath (List _tasks)
    {
        ListEnumerator      tasksEnumerator;
        ProjWBSTreeNode     currentNode;
        Map                 sorting = new Map(Types::String, Types::Class);

        tasksEnumerator = _tasks.getEnumerator();
        while (tasksEnumerator.moveNext())
        {
            currentNode = this.getNodeByElementNumber(tasksEnumerator.current());
            if (currentNode)
            {
                sorting.insert(currentNode.parmChildrensPath(), currentNode);
            }
        }

        return sorting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOperatorsSortingForMultipleOperation</Name>
				<Source><![CDATA[
    private List getOperatorsSortingForMultipleOperation(Map _operatorsMap)
    {
        MapEnumerator   operatorsEnumerator                 = _operatorsMap.getEnumerator();
        List            operatorsSorting                    = new List(Types::Class);
        List            currentSiblingsSorting;
        List            nonSortedNodes = new List(Types::Class);
        Map             currentSiblingsOperatorsSorting     = new Map(Types::Real, Types::Class);
        MapEnumerator   currentSiblingOperatorEnumerator;

        ProjWBSTreeNode         currentNode, previousNode;
        ProjWBSTreeNodeOperator currentOperator;

        void addCurrentSiblingsOperatorsToSorting()
        {
            currentSiblingsSorting = new List(Types::Class);
            currentSiblingOperatorEnumerator = currentSiblingsOperatorsSorting.getEnumerator();
            while (currentSiblingOperatorEnumerator.moveNext())
            {
                currentSiblingsSorting.addStart(currentSiblingOperatorEnumerator.currentValue());
            }
            operatorsSorting.appendList(currentSiblingsSorting);
            currentSiblingsOperatorsSorting = new Map(Types::Real, Types::Class);
        }

        while (operatorsEnumerator.moveNext())
        {
            currentOperator = operatorsEnumerator.currentValue();
            currentNode = currentOperator.parmNode();

            if (previousNode && previousNode.parmPath() != currentNode.parmPath())
            {
                addCurrentSiblingsOperatorsToSorting();
            }

            if (!currentOperator.parmCanBeSkipped())
            {
                currentSiblingsOperatorsSorting.insert(currentNode.parmSiblingNumber(), currentOperator);
                previousNode = currentNode;
            }
            else
            {
                nonSortedNodes.addEnd(currentOperator);
            }
        }

        addCurrentSiblingsOperatorsToSorting();
        operatorsSorting.appendList(nonSortedNodes);
        return operatorsSorting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOutlineNumberToActivityNumberMap</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an outline number to activity number map for the entire WBS tree.
    /// </summary>
    /// <returns>
    ///     Outline number to activity number map.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Map getOutlineNumberToActivityNumberMap()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPredecessorsLastDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets latest date among predecessor tasks of the given task.
    /// </summary>
    /// <param name="_smmActivityNumber">
    ///     Activity number of the task.
    /// </param>
    /// <returns>
    ///     Latest date among predecessor tasks.
    /// </returns>
    public SchedToDate getPredecessorsLastDate(smmActivityNumber _smmActivityNumber)
    {
        ProjWBSTreeNode     node            = tree.getNodeByElementNumber(tree.activityNumberToElementNumber(_smmActivityNumber));
        Set                 predecessors    = node.parmPredecessors();
        SetEnumerator       setEnum         = predecessors.getEnumerator();

        SchedToDate         result;
        while (setEnum.moveNext())
        {
            node = tree.getNodeByElementNumber(tree.activityNumberToElementNumber(setEnum.current()));
            if (node.parmEndDate() > result)
            {
                result = node.parmEndDate();
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRootElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Get element number of root task.
    /// </summary>
    /// <returns>
    ///     Element number of root task.
    /// </returns>
    public ElementNumber getRootElementNumber()
    {
        return tree.rootElementNumber();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdateList</Name>
				<Source><![CDATA[
    private List getUpdateList(Map _tasksSorting)
    {
        List updateList = new List(Types::Class);
        Map updateSorting = new Map(Types::String, Types::Class);
        MapEnumerator tasksEnumerator = _tasksSorting.getEnumerator();
        ProjWBSTreeNode currentNode;

        while (tasksEnumerator.moveNext())
        {
            currentNode = tasksEnumerator.currentValue();
            this.addAncestorsToNodesSorting(currentNode, updateSorting);
        }

        tasksEnumerator = updateSorting.getEnumerator();
        while (tasksEnumerator.moveNext())
        {
            updateList.addStart(tasksEnumerator.currentValue());
        }

        return updateList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildren</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets whether the given task has children.
    /// </summary>
    /// <param name="_hierarchyTreeTable">
    ///     <c>HierarchyTreeTable</c> record of the task.
    /// </param>
    /// <returns>
    ///     true if task has children; false otherwise.
    /// </returns>
    public boolean hasChildren(HierarchyTreeTable _hierarchyTreeTable)
    {
        return tree.hasChildren(_hierarchyTreeTable.ElementNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildrenByActivityNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the given activity has child activities.
    /// </summary>
    /// <param name="_activityNumber">
    ///     Activity number that identifies the activity.
    /// </param>
    /// <returns>
    ///     whether the given activity has child activities
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean hasChildrenByActivityNumber(smmActivityNumber _activityNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildrenByElementNumber</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets whether the given task has children.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task.
    /// </param>
    /// <returns>
    ///     true if task has children; false otherwise.
    /// </returns>
    public boolean hasChildrenByElementNumber(ElementNumber _elementNumber)
    {
        return tree.hasChildren(_elementNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasEffortError</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether task has effort error.
    /// </summary>
    /// <param name="_psaActivitySetup">
    ///     <c>PSAActivitySetup</c> record of the task.
    /// </param>
    /// <returns>
    ///     true if has effort error; false otherwise.
    /// </returns>
    public boolean hasEffortError(PSAActivitySetup _psaActivitySetup)
    {
        Hours duration, effort, calculatedEffort;
        NumberOfResources resources;

        duration = _psaActivitySetup.ActivityDuration;
        resources = _psaActivitySetup.NumberOfResources;
        effort = _psaActivitySetup.Effort;
        calculatedEffort = duration * resources * standardWorkingHours;

        if (resources && standardWorkingHours)
        {
            return round(effort, timeUnitPrecision) != round(calculatedEffort, timeUnitPrecision);
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLagError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there is a lag error which is the gap between the last end date among all predecessors and start date of the given task.
    /// </summary>
    /// <param name="_psaActivitySetup">
    /// _psaActivitySetup identifies the task under consideration.
    /// </param>
    /// <returns>
    /// true if there is a lag error, otherwise false.
    /// </returns>
    public boolean hasLagError(PSAActivitySetup _psaActivitySetup)
    {
        SchedToDate  latestPredecessorEndDate;
        if (_psaActivitySetup)
        {
            latestPredecessorEndDate = this.getPredecessorsLastDate(_psaActivitySetup.ActivityNumber);
            return (latestPredecessorEndDate && (_psaActivitySetup.PSASchedStart > WorkCalendarCalculator::findNextWorkDayAfterDate(_psaActivitySetup.CalendarId, latestPredecessorEndDate)));
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPredecessors</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the node has predecessors.
    /// </summary>
    /// <param name = "_nodeElementNumber">
    ///     Node element number.
    /// </param>
    /// <returns>
    ///     True if node has predecessors.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean hasPredecessors(ElementNumber _nodeElementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPredecessorsError</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether task has predecessors error.
    /// </summary>
    /// <param name="_psaActivitySetup">
    ///     <c>PSAActivitySetup</c> record of the task.
    /// </param>
    /// <returns>
    ///     true if has predecessors error; false otherwise.
    /// </returns>
    public boolean hasPredecessorsError(PSAActivitySetup _psaActivitySetup)
    {
        SchedToDate lastDate;
        if (_psaActivitySetup && _psaActivitySetup.psaSchedStart)
        {
            lastDate = this.getPredecessorsLastDate(_psaActivitySetup.ActivityNumber);
            return  (lastDate && _psaActivitySetup.psaSchedStart <= lastDate);
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementSiblingNumbersInDatabase</Name>
				<Source><![CDATA[
    private void incrementSiblingNumbersInDatabase(LineNum _startSiblingNumber, ElementNumber _parentElementNumber, ElementNumber _notIncrementedNodeElementNumber = "")
    {
        HierarchyTreeTable hierarchyTreeTable;

        hierarchyTreeTable.skipDataMethods(true);
        hierarchyTreeTable.skipEvents(true);

        update_recordset hierarchyTreeTable
        setting
            SiblingNumber = hierarchyTreeTable.SiblingNumber + 1.1
        where
            hierarchyTreeTable.HierarchyId == tree.hierarchyId()
            && hierarchyTreeTable.ParentElementNumber == _parentElementNumber
            && hierarchyTreeTable.SiblingNumber >= _startSiblingNumber
            && hierarchyTreeTable.ElementNumber != _notIncrementedNodeElementNumber;

        update_recordset hierarchyTreeTable
        setting
            SiblingNumber = hierarchyTreeTable.SiblingNumber - 0.1
        where
            hierarchyTreeTable.HierarchyId == tree.hierarchyId()
            && hierarchyTreeTable.ParentElementNumber == _parentElementNumber
            && hierarchyTreeTable.SiblingNumber >= _startSiblingNumber + 0.1
            && hierarchyTreeTable.ElementNumber != _notIncrementedNodeElementNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementSiblingNumbersInTree</Name>
				<Source><![CDATA[
    // Pre-condition: call before inserting _startNode in the tree.
    private void incrementSiblingNumbersInTree(ProjWBSTreeNode _startNode)
    {
        List siblings = tree.getChildrenOf(_startNode.parmParentElementNumber());
        LineNum startSiblingNumber = _startNode.parmSiblingNumber();
        ListEnumerator listEnumerator;
        ElementNumber siblingElementNumber;
        ProjWBSTreeNode siblingNode;

        listEnumerator = siblings.getEnumerator();
        while (listEnumerator.moveNext())
        {
            siblingElementNumber = listEnumerator.current();
            siblingNode = tree.getNodeByElementNumber(siblingElementNumber);
            if (siblingNode.parmSiblingNumber() >= startSiblingNumber)
            {
                siblingNode.parmSiblingNumber(siblingNode.parmSiblingNumber() + 1);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEACFromPlannedInMemory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Resets, in-memory (i.e. no writes to the database), all task Estimate at complete
    ///     values (e.g. Cost at complete) to match its planned counterpart in the
    ///     task (e.g. Total planned cost).
    /// </summary>
    /// <param name="_activityNumber">
    ///     Optional activity number of the parent activity of the activities that will be
    ///     initialized. If blank, the whole WBS is initialized.
    /// </param>
    /// <returns>
    ///     The list of in-memory nodes that had their EACs initialized to planned values.
    /// </returns>
    /// <remarks>
    ///     Estimate at complete amounts are usually shown in project tasks tracking
    ///     views (e.g. Cost tracking view).
    ///
    ///     The activity identified by _activityNumber itself won't be initiliazed.
    /// </remarks>
    public List initEACFromPlannedInMemory(smmActivityNumber _activityNumber = "")
    {
        ListEnumerator      childrenEnumerator;
        ProjWBSTreeNode     childNode;
        ElementNumber       currElementNumber;
        List                initializedNodes;
        Stack               stack;

        if (_activityNumber)
        {
            initializedNodes = new List(Types::Class);
        }
        else
        {
            return this.initEACFromPlannedInMemoryForFullTree();
        }

        stack = new stack();
        stack.push([tree.activityNumberToElementNumber(_activityNumber)]);

        while (stack.qty() > 0)
        {
            [currElementNumber] = stack.pop();

            childrenEnumerator = tree.getChildrenOf(currElementNumber).getEnumerator();
            while (childrenEnumerator.moveNext())
            {
                childNode = tree.getNodeByElementNumber(childrenEnumerator.current());
                childNode.parmCostAtComplete(childNode.parmPlannedCost());
                childNode.parmEffortAtComplete(childNode.parmEffort());

                initializedNodes.addEnd(childNode);
            }
        }
        return initializedNodes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEACFromPlannedInMemoryForFullTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Re-initializes EAC (Estimate at complete) values from planned values.
    /// </summary>
    /// <returns>
    ///     List of in-memory task nodes that have been initialized.
    /// </returns>
    public List initEACFromPlannedInMemoryForFullTree()
    {
        MapEnumerator   nodeEnumerator;
        ProjWBSTreeNode node;
        List            initializedNodes = new List(Types::Class);

        nodeEnumerator = tree.getNodes().getEnumerator();

        while (nodeEnumerator.moveNext())
        {
            node = nodeEnumerator.currentValue();
            node.parmCostAtComplete(node.parmPlannedCost());
            node.parmEffortAtComplete(node.parmEffort());
            initializedNodes.addEnd(node);
        }

        return initializedNodes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLeavesPlannedCostInMemory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Re-initializes planned cost in-memory.
    /// </summary>
    /// <returns>
    ///     Set of activity numbers of tasks that have non-zero planned cost value.
    /// </returns>
    public Set initLeavesPlannedCostInMemory()
    {
        PSAActivityEstimates    psaActivityEstimates;
        smmActivities           smmActivities;
        HierarchyTreeTable      hierarchyTreeTable;
        Set                     hasPlannedCost;
        ProjWBSTreeNode         node;
        Map                     nodes;
        MapEnumerator           nodesEnumerator;

        hasPlannedCost = new Set(Types::String);
        nodes          = tree.getNodes();

        if (!nodes)
        {
            return hasPlannedCost;
        }

        nodesEnumerator = nodes.getEnumerator();
        while (nodesEnumerator.moveNext())
        {
            node = nodesEnumerator.currentValue();
            if (node)
            {
                node.parmPlannedCost(0);
            }
        }

        while select ActivityNumber, sum(TotalCostPrice) from psaActivityEstimates
        group by psaActivityEstimates.ActivityNumber
        join RecId from smmActivities
            where psaActivityEstimates.ActivityNumber == smmActivities.ActivityNumber
            join RecId from hierarchyTreeTable
                where smmActivities.RecId == hierarchyTreeTable.RefRecId && hierarchyTreeTable.HierarchyId == tree.hierarchyId()
        {
            hasPlannedCost.add(psaActivityEstimates.ActivityNumber);
            node = tree.getNodeByActivityNumber(psaActivityEstimates.ActivityNumber);
            if (node)
            {
                node.parmPlannedCost(psaActivityEstimates.TotalCostPrice);
            }
        }
        return hasPlannedCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewTaskFromParentTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes new task with information of its parent task.
    /// </summary>
    /// <param name="_newPSAActivitySetup">
    ///     <c>PSAActivitySetup</c> record of new task.
    /// </param>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void initNewTaskFromParentTask(PSAActivitySetup _newPSAActivitySetup)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFilterMatch</Name>
				<Source><![CDATA[
    private boolean isFilterMatch(ProjWBSTreeNode node, str _filterValue, str _filterField)
    {
        boolean     ret = false;
        date        validDate;
        str         processedFilterValue;
        int         lenStringToFind;
        int         lenStringToSearch;
        int         retries;

        processedFilterValue = this.processStringForSearch(_filterValue);

        if (processedFilterValue == "")
        {
            return true;
        }

        lenStringToFind = strLen(processedFilterValue);

        switch (_filterField)
        {
            case enum2str(ProjWBSFilters::Effort),  enum2str(ProjWBSFilters::NumberOfResources), enum2str(ProjWBSFilters::Duration) :
                //Need to test if garbage input; str2num returns 0 if invalid number
                if (processedFilterValue != '0' && str2num(processedFilterValue) == 0)
                {
                    return ret;
                }
                break;
            case enum2str(ProjWBSFilters::StartDate), enum2str(ProjWBSFilters::FinishDate) :
                validDate = str2Date(processedFilterValue,-1);
                if (processedFilterValue != '0' && validDate ==mkDate(1,1,1900))
                {
                    return ret;
                }
                break;
        }

        switch (_filterField)
        {
            case enum2str(ProjWBSFilters::WBS) :
                lenStringToSearch = strLen(node.parmOutlineNumber());
                if (lenStringToFind > lenStringToSearch)
                {
                    break;
                }
                retries = lenStringToSearch - lenStringToFind + 1;
                if (strScan(node.parmOutlineNumber(), processedFilterValue,1,retries))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::TaskName) :
                lenStringToSearch = strLen(this.processStringForSearch(node.parmName()));
                if (lenStringToFind > lenStringToSearch)
                {
                    break;
                }
                retries = lenStringToSearch - lenStringToFind + 1;
                if (strScan(this.processStringForSearch(node.parmName()), processedFilterValue,1,retries))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::Category) :
                lenStringToSearch = strLen(this.processStringForSearch(node.parmCategory()));
                if (lenStringToFind > lenStringToSearch)
                {
                    break;
                }
                retries = lenStringToSearch - lenStringToFind + 1;
                if (strScan(this.processStringForSearch(node.parmCategory()), processedFilterValue,1,retries))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::Effort) :
                if (node.parmEffort() == str2num(processedFilterValue))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::NumberOfResources) :
                if (node.parmNumberOfResources() == str2num(processedFilterValue))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::StartDate) :
                if (node.parmStartDate() == str2Date(processedFilterValue,-1))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::FinishDate) :
                if (node.parmEndDate() == str2Date(processedFilterValue,-1))
                {
                    ret = true;
                }
                break;
            case enum2str(ProjWBSFilters::Duration) :
                if (node.parmActivityDuration() == str2num(processedFilterValue))
                {
                    ret = true;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRoot</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether task is the root task or not.
    /// </summary>
    /// <param name="_hierarchTreeTable">
    ///     <c>HierarchyTreeTable</c> record of task to verify.
    /// </param>
    /// <returns>
    ///     true if task is the root task; false otherwise.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean isRoot(HierarchyTreeTable _hierarchTreeTable)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRootActivity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the given activity is the root activity.
    /// </summary>
    /// <param name="_activityNumber">
    ///     Activity number of the activity.
    /// </param>
    /// <returns>
    ///     true if activity is the root, false otherwise.
    /// </returns>
    /// <remarks>
    ///     Returns false if activity doesn't exist.
    /// </remarks>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean isRootActivity(smmActivityNumber _activityNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaskExpanded</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the given task is expanded.
    /// </summary>
    /// <param name="_elementNumber">
    ///     The element number that identifies the task.
    /// </param>
    /// <returns>
    ///     Whether the given task is expanded.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public boolean isTaskExpanded(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveChildrenFromTaskToTask</Name>
				<Source><![CDATA[
    private void moveChildrenFromTaskToTask(ProjWBSTreeNode _fromTaskNode,
                                            ProjWBSTreeNode _toTaskNode,
                                            HierarchyTreeTable _toTaskHierarchyTreeTable,
                                            LineNum _fromSiblingNumber)
    {
        LineNum maxSibNumAtDestination;
        maxSibNumAtDestination = tree.moveChildrenFromNodeToNode(_fromTaskNode, _toTaskNode, _fromSiblingNumber);

        if (maxSibNumAtDestination != -1)
        {
            this.moveChildrenFromTaskToTaskInDatabase(_fromTaskNode,
                                                      _toTaskNode,
                                                      _toTaskHierarchyTreeTable,
                                                      _fromSiblingNumber,
                                                      maxSibNumAtDestination);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveChildrenFromTaskToTaskInDatabase</Name>
				<Source><![CDATA[
    // Note: it doesn't fix levels nor paths
    private void moveChildrenFromTaskToTaskInDatabase(ProjWBSTreeNode _fromTaskNode,
                                                      ProjWBSTreeNode _toTaskNode,
                                                      HierarchyTreeTable _toTaskHierarchyTreeTable,
                                                      LineNum _startSiblingNumberAtOrigin,
                                                      LineNum _maxSibNumAtDestination)
    {
        HierarchyTreeTable hierarchyTreeTable;

        hierarchyTreeTable.skipDataMethods(true);
        hierarchyTreeTable.skipEvents(true);

        update_recordset hierarchyTreeTable
        setting
            SiblingNumber = hierarchyTreeTable.SiblingNumber - _startSiblingNumberAtOrigin + 0.1 + _maxSibNumAtDestination,
            ParentElementNumber =  _toTaskNode.elementNumber()
        where
            hierarchyTreeTable.HierarchyId == tree.hierarchyId()
            && hierarchyTreeTable.ParentElementNumber == _fromTaskNode.elementNumber()
            && hierarchyTreeTable.SiblingNumber >= _startSiblingNumberAtOrigin;

        update_recordset hierarchyTreeTable
        setting
            SiblingNumber = hierarchyTreeTable.SiblingNumber - 0.1,
            Path          = _toTaskNode.parmChildrensPath()
        where
            hierarchyTreeTable.HierarchyId == tree.hierarchyId()
            && hierarchyTreeTable.ParentElementNumber == _toTaskNode.elementNumber()
            && hierarchyTreeTable.SiblingNumber > _maxSibNumAtDestination;

        _toTaskHierarchyTreeTable.selectForUpdate(true);
        _toTaskHierarchyTreeTable.IsNodeExpanded = true;
        ttsbegin;
        _toTaskHierarchyTreeTable.update();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaskToNewParentInDatabase</Name>
				<Source><![CDATA[
    private boolean moveTaskToNewParentInDatabase(ProjWBSTreeNode _node, ProjWBSTreeNode _newParentNode, LineNum _maxSiblingNumber)
    {
        HierarchyTreeTable hierarchyTreeTable, parentHierarchyTreeTable;
        PSAActivitySetup parentPSAActivitySetup;
        LineNum oldSiblingNumber;
        LineNum newSiblingNumber = _maxSiblingNumber + 1;
        ElementNumber oldParentElementNumber;
        #Characters;

        // Update parent's IsNodeExpanded to expanded if necessary
        select firstonly IsNodeExpanded from parentHierarchyTreeTable
            where parentHierarchyTreeTable.HierarchyId == tree.hierarchyId()
                  && parentHierarchyTreeTable.ElementNumber == _newParentNode.elementNumber();

        if (!parentHierarchyTreeTable.IsNodeExpanded)
        {
            parentHierarchyTreeTable.selectForUpdate(true);
            parentHierarchyTreeTable.IsNodeExpanded = true;
            ttsbegin;
            parentHierarchyTreeTable.update();
            ttscommit;
        }

        // Update parent's number of resource if necessary
        select firstonly NumberOfResources from parentPSAActivitySetup
            where parentPSAActivitySetup.ActivityNumber == _newParentNode.activityNumber();

        if (parentPSAActivitySetup.NumberOfResources != 0.0)
        {
            parentPSAActivitySetup.NumberOfResources = 0.0;
        }

        // Update target task record.
        select firstonly ParentElementNumber, SiblingNumber from hierarchyTreeTable
        where hierarchyTreeTable.HierarchyId        == tree.hierarchyId()
                && hierarchyTreeTable.ElementNumber == _node.elementNumber();

        oldSiblingNumber = hierarchyTreeTable.SiblingNumber;
        oldParentElementNumber = hierarchyTreeTable.ParentElementNumber;

        ttsbegin;
        this.incrementSiblingNumbersInDatabase(newSiblingNumber, _newParentNode.elementNumber());  // Increment at destination.
        update_recordSet hierarchyTreeTable
        setting
            ParentElementNumber = _newParentNode.elementNumber(),
            SiblingNumber       = newSiblingNumber,
            Level               = _newParentNode.parmLevel() + 1,
            Path                = _newParentNode.parmPath() + _newParentNode.elementNumber() + #sharp
        where hierarchyTreeTable.HierarchyId      == tree.hierarchyId()
              && hierarchyTreeTable.ElementNumber == _node.elementNumber();
        this.decrementSiblingNumbersInDatabase(oldSiblingNumber, oldParentElementNumber);  // Decrement at origin.
        this.updateSubtreePathsAndLevels(_node.elementNumber());
        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaskToNewParentInTree</Name>
				<Source><![CDATA[
    private boolean moveTaskToNewParentInTree(ProjWBSTreeNode _node, ProjWBSTreeNode _newParentNode, LineNum _afterSiblingNumber)
    {
        tree.removeChild(_node);
        tree.reInsertNode(_newParentNode.elementNumber(), _node, _afterSiblingNumber);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveTaskUpOrDownInDatabase_Internal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Private method to use for all internal references to deprecated method moveTaskUpOrDownInDatabase. 
    ///     This method to be removed when all internal references have been deprecated.
    /// </summary>
    /// <param name="_node">
    ///     In-memory task node to be moved.
    /// </param>
    /// <param name="_siblingNode">
    ///     Above sibling node (if it's move up) and below sibling node (if it's move down).
    /// </param>
    /// <returns>
    ///     true if it was successful; false otherwise.
    /// </returns>
    private boolean moveTaskUpOrDownInDatabase_Internal(ProjWBSTreeNode _node, ProjWBSTreeNode _siblingNode)
    {
        HierarchyTreeTable hierarchyTreeTable;
        HierarchyTreeTable hierarchyTreeTableSibling;
        LineNum tmpSiblingNumber;

        select firstonly forupdate hierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == tree.hierarchyId()
                  && hierarchyTreeTable.ElementNumber == _node.elementNumber();

        if (_node.parmSiblingNumber() < _siblingNode.parmSiblingNumber())
        {
            hierarchyTreeTableSibling = HierarchyTreeTable::findPreviousSibling(hierarchyTreeTable);
        }
        else
        {
            hierarchyTreeTableSibling = HierarchyTreeTable::findNextSibling(hierarchyTreeTable);
        }

        tmpSiblingNumber = hierarchyTreeTable.SiblingNumber;
        hierarchyTreeTable.SiblingNumber = hierarchyTreeTableSibling.SiblingNumber;
        hierarchyTreeTableSibling.SiblingNumber = tmpSiblingNumber;

        hierarchyTreeTableSibling.selectForUpdate(true);
        ttsbegin;
        hierarchyTreeTable.SiblingNumber += 0.1;
        hierarchyTreeTable.update();
        hierarchyTreeTableSibling.update();
        hierarchyTreeTable.SiblingNumber -= 0.1;
        hierarchyTreeTable.update();
        ttscommit;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Instantiates a new <c>ProjWBSUpdateController</c>.
    /// </summary>
    /// <param name="_hierarchyId">
    ///     Hierarchy id of the WBS hierarchy.
    /// </param>
    /// <param name="_calendarId">
    ///     Calendar id associated to WBS (e.g. project/project quotation calendar).
    /// </param>
    /// <param name="_tmpHierarchyTreeTable">
    ///     A not-null <c>tmpHierarchyTreeTable</c> table buffer.
    /// </param>
    /// <param name="_tmpSMMActivities">
    ///     A not-null <c>tmpSMMActivities</c> table buffer.
    /// </param>
    /// <param name="_tmpPSAActivitySetup">
    ///     A not-null <c>tmpPSAActivitySetup</c> table buffer.
    /// </param>
    /// <param name="_tmpTreeTable">
    ///     A not-null <c>tmpTreeTable</c> table buffer.
    /// </param>
    /// <param name="_isDebugOn">
    ///     if true enables debugging mode (i.e. provides debugging information).
    /// </param>
    /// <param name="_viewType">
    ///     View type.
    /// </param>
    /// <param name="_projTable">
    ///     <c>ProjTable</c> record associated with WBS. Pass null if there is none.
    /// </param>
    /// <param name="_salesQuotationTable">
    ///     <c>SalesQuotationTable</c> record associated with WBS. Pass null if there is none.
    /// </param>
    /// <param name="_forceFullTreeLoad">
    ///     if true foces full WBS tree to be loaded into memory; otherwise only loads visible tasks.
    /// </param>
    /// <remarks>
    ///     Note 1: debug mode can slow down key operations substantially.
    ///     Note 2: do not use pass false to _forceFullTreeLoad if predecessors will be used.
    /// </remarks>

    public void new(HierarchyIdBase     _hierarchyId,
                    CalendarId          _calendarId,
                    HierarchyTreeTable  _tmpHierarchyTreeTable = null,
                    smmActivities       _tmpSMMActivities = null,
                    PSAActivitySetup    _tmpPSAActivitySetup = null,
                    TmpTreeTable        _tmpTreeTable = null,
                    boolean             _isDebugOn = false,
                    ProjViewType        _viewType = ProjViewType::PlanningView,
                    ProjTable           _projTable = null,
                    SalesQuotationTable _salesQuotationTable = null,
                    boolean             _forceFullTreeLoad = true)
    {
        calendarId              = _calendarId;
        tab                     = '     ';
        tree                    = new ProjWBSTree(_hierarchyId, _isDebugOn, _forceFullTreeLoad);
        expandCollapseManager   = new ProjExpandCollapseManager(tree);
        tmpTreeTable            = _tmpTreeTable;
        projTable               = _projTable;
        salesQuotationTable     = _salesQuotationTable;
        isDebugOn               = _isDebugOn;
        viewType                = _viewType;
        fixingOptions           = null;

        this.cacheCalendarParameters();

        if (projTable)
        {
            wbsOwner = projTable;
        }
        else if (salesQuotationTable)
        {
            wbsOwner = salesQuotationTable;
        }
        else
        {
            wbsOwner = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>nodeToTableBuffer</Name>
				<Source><![CDATA[
    private ProjTmpWBSTransferTable nodeToTableBuffer(ProjWBSTreeNode _node)
    {
        ProjTmpWBSTransferTable tmpWBSTransferTable;

        tmpWBSTransferTable.HierarchyId = tree.hierarchyId();
        tmpWBSTransferTable.ElementNumber = _node.elementNumber();
        tmpWBSTransferTable.Path = _node.parmPath();
        tmpWBSTransferTable.Level = _node.parmLevel();
        tmpWBSTransferTable.SiblingNumber = _node.parmSiblingNumber();
        tmpWBSTransferTable.ActivityNumber = _node.activityNumber();
        tmpWBSTransferTable.Effort = _node.parmEffort();
        tmpWBSTransferTable.psaSchedStart = _node.parmStartDate();
        tmpWBSTransferTable.psaSchedEnd = _node.parmEndDate();
        tmpWBSTransferTable.ActivityDuration = _node.parmActivityDuration();
        tmpWBSTransferTable.EffortAtComplete = _node.parmEffortAtComplete();
        tmpWBSTransferTable.CostAtComplete = _node.parmCostAtComplete();

        return tmpWBSTransferTable.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>outlineNumberFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets outline number of task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of task.
    /// </param>
    /// <returns>
    ///     Outline number
    /// </returns>
    public str outlineNumberFor(ElementNumber _elementNumber)
    {
        ProjWBSTreeNode projWBSTreeNode = tree.getNodeByElementNumber(_elementNumber);

        if (projWBSTreeNode)
        {
            return projWBSTreeNode.parmOutlineNumber();
        }
        return "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCalendarId</Name>
				<Source><![CDATA[
    public CalendarId parmCalendarId(CalendarId _calendarId = calendarId)
    {
        if (calendarId != _calendarId)
        {
            calendarId = _calendarId;
            this.cacheCalendarParameters();
        }

        return calendarId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSchedulingErrorsFixingOptions</Name>
				<Source><![CDATA[
    public ProjWBSSchedulingErrorsFixingOptions parmSchedulingErrorsFixingOptions(ProjWBSSchedulingErrorsFixingOptions _fixingOptions = fixingOptions)
    {
        fixingOptions = _fixingOptions;
        return fixingOptions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSelectedHierarchyTreeTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets and gets a <c>HierarchyTreeTable</c> record that will be used by
    ///     the next controller method calls.
    /// </summary>
    /// <param name="_selectedHierarchyTreeTable">
    ///     <c>HierarchyTreeTable</c> record table buffer.
    /// </param>
    /// <param name="_forceSame">
    ///     If true, forces setting the given <c>HierarchyTreeTable</c> record
    ///     even if it has the same Element Number as the currently active one.
    /// </param>
    /// <returns>
    ///     Currently active <c>HierarchyTreeTable</c> record table buffer
    /// </returns>
    public HierarchyTreeTable parmSelectedHierarchyTreeTable(HierarchyTreeTable _selectedHierarchyTreeTable = selectedHierarchyTreeTable, boolean _forceSame = false)
    {
        if (_forceSame || !selectedHierarchyTreeTable.RecId || selectedHierarchyTreeTable.ElementNumber != _selectedHierarchyTreeTable.ElementNumber)
        {
            selectedHierarchyTreeTable = _selectedHierarchyTreeTable.data();
        }
        return selectedHierarchyTreeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performTreeNodeOperator</Name>
				<Source><![CDATA[
    private void performTreeNodeOperator(ProjWBSTReeNodeOperator _operator)
    {
        MapEnumerator   childrenToInsertEnumerator;
        List            currentChildrenToInsert;
        ListEnumerator  nodesEnumerator;
        ProjWBSTreeNode firstNodeToMove, currentNodeToMove, currentNode = _operator.parmNode();
        int             counter = 0;

        if (_operator.parmNewParent() && currentNode.parmPredecessors().remove(_operator.parmNewParent()))
        {
            this.removeDependencyFromDB(_operator.parmNewParent(), currentNode.activityNumber());
        }

        if (_operator.parmChildrenToInsertContiguous())
        {
            childrenToInsertEnumerator = _operator.parmChildrenToInsert().getEnumerator();
            childrenToInsertEnumerator.moveNext();
            currentChildrenToInsert = childrenToInsertEnumerator.currentValue();
            if (!currentChildrenToInsert.empty())
            {
                nodesEnumerator = currentChildrenToInsert.getEnumerator();
                nodesEnumerator.moveNext();
                firstNodeToMove = nodesEnumerator.current();

                this.moveChildrenFromTaskToTask(tree.getParentNodeOf(firstNodeToMove.elementNumber()),
                                                currentNode,
                                                HierarchyTreeTable::findElementNumber(tree.hierarchyId(), currentNode.elementNumber()),
                                                firstNodeToMove.parmSiblingNumber());
            }
        }
        else if (!_operator.parmChildrenToInsert().empty())
        {
            childrenToInsertEnumerator = _operator.parmChildrenToInsert().getEnumerator();
            while (childrenToInsertEnumerator.moveNext())
            {
                currentChildrenToInsert = childrenToInsertEnumerator.currentValue();
                nodesEnumerator = currentChildrenToInsert.getEnumerator();
                while (nodesEnumerator.moveNext())
                {
                    currentNodeToMove = nodesEnumerator.current();
                    this.moveTaskToNewParentInTree(currentNodeToMove, currentNode, childrenToInsertEnumerator.currentKey());
                    this.moveTaskToNewParentInDatabase(currentNodeToMove, currentNode, counter + childrenToInsertEnumerator.currentKey());
                }

                counter += currentChildrenToInsert.elements();
            }
            counter = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>plannedCostFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets planned cost of given task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of task.
    /// </param>
    /// <returns>
    ///     Planned cost.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Total plannedCostFor(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>plannedEffortFor</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets planned effort of given task.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of task.
    /// </param>
    /// <returns>
    ///     Planned effort.
    /// </returns>
    [SysObsolete('Function is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public Hours plannedEffortFor(ElementNumber _elementNumber)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processStringForSearch</Name>
				<Source><![CDATA[
    private str processStringForSearch(str string)
    {
        return strLwr(strLRTrim(string));
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTreeNodeOperators</Name>
				<Source><![CDATA[
    private void processTreeNodeOperators(Map operators)
    {
        List            operatorsSorting    = this.getOperatorsSortingForMultipleOperation(operators);
        ListEnumerator  operatorsEnumerator = operatorsSorting.getEnumerator();
        while (operatorsEnumerator.moveNext())
        {
            this.performTreeNodeOperator(operatorsEnumerator.current());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>produceDependenciesSorting</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Produces dependency sorting for dependencies graph for the entire project hierarchy
    /// </summary>
    /// <returns>
    ///     List of activities in the topological order
    /// </returns>

    public List produceDependenciesSorting()
    {
        List                    result = new List(Types::String);
        Map                     labelsMap = new Map(Types::String, Types::Integer);
        MapEnumerator           nodesEnumerator = tree.getNodes().getEnumerator();

        while (nodesEnumerator.moveNext() && !labelsMap.exists(nodesEnumerator.currentKey()))
        {
            this.produceDependenciesSortingForHierarchy(nodesEnumerator.currentKey(), labelsMap, result);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>produceDependenciesSortingForHierarchy</Name>
				<Source><![CDATA[
    private void produceDependenciesSortingForHierarchy(ElementNumber _startingNodeElementNumber, Map _labelsMap, List _result)
    {
        Stack                   vertexStack = new Stack();
        container               cont;
        ProjWBSTreeNode         currentNode;
        ElementNumber           currentDependencyElementNumber;
        ProjDependecyEnumerator dependenciesEnumerator;
        boolean                 skip        = false;

        vertexStack.push([_startingNodeElementNumber]);
        while (vertexStack.qty() != 0)
        {
            //read top of the stack
            skip = false;
            cont = vertexStack.pop();
            vertexStack.push(cont);

            //select node
            currentNode = tree.getNodeByElementNumber(conPeek(cont, 1));
            dependenciesEnumerator = ProjDependecyEnumerator::construct(tree, currentNode);

            //iterating dependencies
            while (dependenciesEnumerator.moveNext())
            {
                currentDependencyElementNumber = dependenciesEnumerator.current();
                if (!_labelsMap.exists(currentDependencyElementNumber))
                {
                    vertexStack.push([currentDependencyElementNumber]);
                    _labelsMap.insert(currentDependencyElementNumber, 1);
                    skip = true;
                    break;
                }
                else if (_labelsMap.lookup(currentDependencyElementNumber) != 2)
                {
                    skip = true;
                    break;
                }
            }

            if (skip)
            {
                continue;
            }

            //adding to result|tracking maps
            _labelsMap.insert(currentNode.elementNumber(), 2);
            cont = vertexStack.pop();
            _result.addEnd(currentNode.activityNumber());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>produceDependenciesSortingForSubtree</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Produces dependency sorting for dependencies graph for specified subtree
    /// </summary>
    /// <param name="_rootActivityNumber">
    ///     Subtree root node activity number.
    /// </param>
    /// <returns>
    ///     List of activities in the topological order
    /// </returns>
    public List produceDependenciesSortingForSubtree(smmActivityNumber _rootActivityNumber)
    {
        List                    result      = new List(Types::String);
        Map                     labelsMap   = new Map(Types::String, Types::Integer);
        ProjWBSTreeNode         rootNode    = tree.getNodeByActivityNumber(_rootActivityNumber);

        if (rootNode)
        {
            this.produceDependenciesSortingForHierarchy(rootNode.elementNumber(), labelsMap, result);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recomputeSingleTaskSummaries</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Recompute summaries for a given task node.
    /// </summary>
    /// <param name="_node">
    ///     Task node.
    /// </param>
    /// <param name="_psaActivitySetup">
    ///     PSAActivitySetup record table buffer that corresponds to the task.
    /// </param>
    /// <param name="_eacOnly">
    ///     If true, only resummarizes EAC (Estimate at complete) fields (e.g. Cost at complete, Effort at complete).
    /// </param>
    public void recomputeSingleTaskSummaries(ProjWBSTreeNode _node, PSAActivitySetup _psaActivitySetup, boolean _eacOnly = false)
    {
        Hours               totalEffort             = 0;
        Total               totalCostAtComplete     = 0;
        Hours               totalEffortAtComplete   = 0;
        Hours               maxChildrenDuration     = 0;
        List                children                = tree.getChildrenOf(_node.elementNumber());
        ListEnumerator      childEnumerator         = children.getEnumerator();
        ProjWBSTreeNode     childNode;
        SchedFromDate       minStartDate            = dateNull();
        SchedFromDate       maxEndDate              = dateNull();
        PSAActivitySetup    psaActivitySetup;

        if (children.empty())
        {
            return;
        }

        // Compute summaries.
        while (childEnumerator.moveNext())
        {
            childNode               = tree.getNodeByElementNumber(childEnumerator.current());
            totalEffort             += childNode.parmEffort();
            totalCostAtComplete     += childNode.parmCostAtComplete();
            totalEffortAtComplete   += childNode.parmEffortAtComplete();
            maxChildrenDuration     =  maxChildrenDuration < childNode.parmActivityDuration() ? childNode.parmActivityDuration() : maxChildrenDuration;

            if (minStartDate == dateNull() || childNode.parmStartDate() < minStartDate)
            {
                minStartDate = childNode.parmStartDate();
            }

            if (maxEndDate == dateNull() || childNode.parmEndDate() > maxEndDate)
            {
                maxEndDate = childNode.parmEndDate();
            }
        }

        // Update inmem tree.
        _node.parmEffort(totalEffort);
        _node.parmStartDate(minStartDate);
        _node.parmEndDate(maxEndDate);
        _node.parmCostAtComplete(totalCostAtComplete);
        _node.parmEffortAtComplete(totalEffortAtComplete);

        if (maxChildrenDuration == 0 && _node.parmStartDate() == _node.parmEndDate())
        {
            _node.parmActivityDuration(0);
        }
        else
        {
            _node.parmActivityDuration(WorkCalendarCalculator::calcDuration(_node.parmStartDate(), _node.parmEndDate(), this.parmCalendarId()));
        }

        // Update database.
        update_recordSet psaActivitySetup
        setting
            Effort              = totalEffort,
            PSASchedStart       = minStartDate,
            PSASchedEnd         = maxEndDate,
            ActivityDuration    = _node.parmActivityDuration(),
            CostAtComplete      = totalCostAtComplete,
            EffortAtComplete    = totalEffortAtComplete,
            CalendarId          = this.parmCalendarId()
        where psaActivitySetup.ActivityNumber == _node.activityNumber();

        if (_node.parmParentElementNumber() == "")
        {
            this.updateWBSOwner();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recomputeSummariesFromTaskUpToTheRoot</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Recomputes summaries from given task up to root.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Task element number.
    /// </param>
    public void recomputeSummariesFromTaskUpToTheRoot(ElementNumber _elementNumber)
    {
        PSAActivitySetup psaActivitySetup;
        ProjWBSTreeNode currNode;

        currNode = tree.getNodeByElementNumber(_elementNumber);
        while (true)
        {
            psaActivitySetup = PSAActivitySetup::findActivityNumber(currNode.activityNumber(), true);
            this.recomputeSingleTaskSummaries(currNode, psaActivitySetup);

            if (currNode.parmParentElementNumber())
            {
                currNode = tree.getParentNodeOf(currNode.elementNumber());
            }
            else
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reloadSubTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reloads project WBS sub-tree.
    /// </summary>
    /// <param name="_subTreeRoot">
    ///     Parent hierarchy element of the project tasks that will be reloaded.
    /// </param>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void reloadSubTree(HierarchyTreeTable _subTreeRoot)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>reloadTree</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Reloads WBS hierarchy.
    /// </summary>
    /// <remarks>
    ///     Reloading the WBS will pick up any changes done to the WBS hierarchy in the database.
    /// </remarks>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void reloadTree()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDependencyFromDB</Name>
				<Source><![CDATA[
    private void removeDependencyFromDB(smmActivityNumber _predecessor, smmActivityNumber _successor)
    {
        ProjDependency projDependency;
        delete_from projDependency
            where projDependency.Predecessor == _predecessor && projDependency.Successor == _successor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resummarizeInMemory</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Re-summarizes WBS in-memory values.
    /// </summary>
    /// <remarks>
    ///     This method does not commit to the database.
    /// </remarks>
    public void resummarizeInMemory()
    {
        ElementNumber currElementNumber;
        ProjWBSTreeNode childNode, parentNode, node;
        ProjStack stack = new ProjStack(Types::String);
        Set isVisited = new Set(Types::String);
        ListEnumerator childEnumerator;

        Set hasPlannedCost;

        // Make sure the whole tree is loaded into memory.
        tree.loadTreeFromDatabase("", true);

        hasPlannedCost = this.initLeavesPlannedCostInMemory();

        // Compute summaries.
        stack.push(tree.rootElementNumber());
        while (!stack.isEmpty())
        {
            currElementNumber = stack.peek();

            if (!isVisited.in(currElementNumber))
            {
                node = tree.getNodeByElementNumber(currElementNumber);

                node.parmChildrenCostAtComplete(0);
                node.parmChildrenEffortAtComplete(0);

                if (!hasPlannedCost.in(node.activityNumber()))
                {
                    node.parmPlannedCost(0.0);
                }

                if (tree.hasChildren(node.elementNumber()))
                {// If it's not a leaf node.
                    node.parmEffort(0);
                    node.parmStartDate(dateNull());
                    node.parmEndDate(dateNull());
                    node.parmActivityDuration(0);
                    node.parmCostAtComplete(0);
                    node.parmEffortAtComplete(0);
                    node.parmLevel();
                    node.parmPath();
                    node.parmPlannedCost();
                    node.parmSiblingNumber();
                }

                isVisited.add(node.elementNumber());

                childEnumerator = tree.getChildrenOf(currElementNumber).getEnumerator();
                while (childEnumerator.moveNext())
                {
                    childNode = tree.getNodeByElementNumber(childEnumerator.current());

                    node.parmChildrenCostAtComplete(node.parmChildrenCostAtComplete() + childNode.parmCostAtComplete());
                    node.parmChildrenEffortAtComplete(node.parmChildrenEffortAtComplete() + childNode.parmEffortAtComplete());

                    if (tree.hasChildren(childEnumerator.current()))
                    {// If it's not a leaf node.
                        stack.push(childEnumerator.current());
                    }
                    else
                    {
                        parentNode = tree.getNodeByElementNumber(childNode.parmParentElementNumber());
                        ProjWBSUpdateController::resummarizeParent(parentNode, childNode, calendarId);
                    }
                }
            }
            else
            {
                node = tree.getNodeByElementNumber(currElementNumber);
                stack.pop();

                if (node.parmParentElementNumber())
                {
                    parentNode = tree.getNodeByElementNumber(node.parmParentElementNumber());
                    ProjWBSUpdateController::resummarizeParent(parentNode, node, calendarId);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaskCompletionStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks the given task (summary or leaf level) as closed.
    /// </summary>
    /// <param name="_smmActivities">
    /// Identifies the task to be closed.
    /// </param>
    /// <param name="_isComplete">
    /// The task is marked as complete if true and as in-progress otherwise.
    /// </param>
    /// <remarks>
    /// Caller must enclose this method within ttsbegin/ttscommit statements since this method is also reused in the logic to close a task.
    /// </remarks>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void setTaskCompletionStatus(smmActivities _smmActivities, boolean _isComplete)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaskCompletionStatusForDescendents</Name>
				<Source><![CDATA[
    private void setTaskCompletionStatusForDescendents(boolean _isComplete)
    {
        ProjWBSTreeNode     childNode,node;
        ProjStack           stack = new ProjStack(Types::String);
        ListEnumerator      childEnumerator;
        smmActivities       smmActivities;
        PSAActivitySetup    psaActivitySetup;

        stack.push(this.parmSelectedHierarchyTreeTable().ElementNumber);
        while (!stack.isEmpty())
        {
            node = tree.getNodeByElementNumber(stack.pop());
            select forupdate smmActivities
                where smmActivities.ActivityNumber == node.activityNumber();
            if (smmActivities.Closed == NoYes::No)
            {
                node.parmCostAtComplete(node.parmActualCost());
                node.parmEffortAtComplete(node.parmActualEffort());
                smmActivities.ActivityTaskTimeType = _isComplete ? (smmActivityTaskTimeType::Completed) : (smmActivityTaskTimeType::InProgress);
                smmActivities.update();
                smmActivities.clear();
                activityNumbers.add(node.activityNumber());

                if (_isComplete)
                {
                    update_recordSet psaActivitySetup
                    setting EffortAtComplete = node.parmEffortAtComplete(),
                            CostAtComplete = node.parmCostAtComplete()
                    where psaActivitySetup.ActivityNumber == node.activityNumber();
                }
            }
            if (this.hasChildrenByElementNumber(node.elementNumber()))
            {
                childEnumerator = tree.getChildrenOf(node.elementNumber()).getEnumerator();
                while (childEnumerator.moveNext())
                {
                    childNode = tree.getNodeByElementNumber(childEnumerator.current());
                    stack.push(childNode.elementNumber());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setViewType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets WBS view type (a.k.a. view mode).
    /// </summary>
    /// <param name="_viewType">
    ///     View type. (e.g. Planning, Cost tracking)
    /// </param>
    public void setViewType(ProjViewType _viewType)
    {
        viewType = _viewType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toggleExpandCollapseTask</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Toggles the expanded/collapsed state of a task node.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task node.
    /// </param>
    /// <param name="_force">
    ///     if true forces the given task node to a particular state.
    /// </param>
    /// <param name="_forcedValue">
    ///     State to force the task node to. This parameter is ignored if _force is equal to false.
    /// </param>
    public void toggleExpandCollapseTask(ElementNumber _elementNumber, boolean _force = false, boolean _forcedValue = true)
    {
        ProjWBSTreeNode node = tree.getNodeByElementNumber(_elementNumber);
        boolean oldIsExpanded = node.parmIsExpanded();
        boolean newIsExpanded;
        HierarchyTreeTable hierarchyTreeTable;

        if (_force)
        {
            newIsExpanded = _forcedValue;
        }
        else
        {
            newIsExpanded = !node.parmIsExpanded();
        }

        if (newIsExpanded == oldIsExpanded)
        {
            return;
        }

        // Update tree.
        node.parmIsExpanded(newIsExpanded);

        // Update database.
        update_recordSet hierarchyTreeTable
        setting IsNodeExpanded = newIsExpanded
        where hierarchyTreeTable.HierarchyId == tree.hierarchyId()
              && hierarchyTreeTable.ElementNumber == _elementNumber;

        if (newIsExpanded == false)
        {
            tree.pruneSubTree(node.elementNumber());
        }
        else
        {
            tree.loadSubTree(hierarchyTreeTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostAtComplete_Internal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method contains the logic for the deprecated updateCostAtComplete() method and is used to resolve internal references
    ///     This method should be removed once all internal references are deprecated/removed
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task for which to update cost at complete.
    /// </param>
    /// <param name="_newCostToComplete">
    ///     New cost to complete.
    /// </param>
    /// <param name="_psaActivitySetup">
    ///     <c>PSAAcitivitySetup</c> record of the given task.
    /// </param>
    private void updateCostAtComplete_Internal(ElementNumber _elementNumber, Total _newCostToComplete, PSAActivitySetup _psaActivitySetup)
    {
        ProjWBSTreeNode node;
        Total oldCostAtComplete;

        ttsBegin;
        node = tree.getNodeByElementNumber(_elementNumber);
        oldCostAtComplete = node.parmCostAtComplete();

        node.parmCostAtComplete(node.parmActualCost() + _newCostToComplete);
        _psaActivitySetup.CostAtComplete = node.parmCostAtComplete();
        _psaActivitySetup.update();

        if (tree.hasChildren(node.elementNumber()))
        {
            this.updateCostAtCompleteForDescendants(node.elementNumber());
        }

        node.parmCostAtComplete(oldCostAtComplete);  // Workaround to have this updated later on summarization.
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostAtCompleteForDescendants</Name>
				<Source><![CDATA[
    private void updateCostAtCompleteForDescendants(ElementNumber _elementNumber)
    {
        ProjWBSTreeNode childNode, node;
        ProjStack stack = new ProjStack(Types::String);
        ListEnumerator childEnumerator;
        PSAActivitySetup psaActivitySetup;

        ttsbegin;

        stack.push(_elementNumber);
        while (!stack.isEmpty())
        {
            node = tree.getNodeByElementNumber(stack.pop());

            if (node.parmChildrenCostAtComplete() == 0)
            {
                continue;
            }

            childEnumerator = tree.getChildrenOf(node.elementNumber()).getEnumerator();
            while (childEnumerator.moveNext())
            {
                childNode = tree.getNodeByElementNumber(childEnumerator.current());
                childNode.parmCostAtComplete(childNode.parmCostAtComplete() / node.parmChildrenCostAtComplete() * node.parmCostAtComplete());

                update_recordSet psaActivitySetup
                setting CostAtComplete = childNode.parmCostAtComplete()
                where psaActivitySetup.ActivityNumber == childNode.activityNumber();

                stack.push(childNode.elementNumber());
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostAtCompleteSummariesInTree</Name>
				<Source><![CDATA[
    private List updateCostAtCompleteSummariesInTree(ProjWBSTreeNode _firstAncestorNode, Total _oldCostAtComplete, Total _newCostAtComplete)
    {
        Total delta = _newCostAtComplete - _oldCostAtComplete;
        Total currCostAtComplete;
        ProjWBSTreeNode node;
        List ancestorCostAtCompletes = new List(Types::Real);

        node = _firstAncestorNode;
        while (node)
        {
            currCostAtComplete = node.parmCostAtComplete();
            node.parmCostAtComplete(currCostAtComplete + delta);
            ancestorCostAtCompletes.addEnd(currCostAtComplete + delta);
            node = tree.getParentNodeOf(node.elementNumber());
        }

        return ancestorCostAtCompletes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDependencies</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the list of predecessors of the given successor task.
    /// </summary>
    /// <param name="_predecessors">
    ///     List of predecessor.
    /// </param>
    /// <param name="_successor">
    ///     Activity number of successor task.
    /// </param>
    /// <returns>
    ///     true if successful; false otherwise.
    /// </returns>
    /// <remarks>
    ///     A failure to set predecessors would happen if, for instance, these predecessors
    ///     would cause a depency loop when combined with existing dependencies.
    /// </remarks>
    public boolean updateDependencies(List _predecessors, smmActivityNumber _successor)
    {
        ProjWBSTreeNode     selectedNode;
        Set                 newPredecessors, oldPredecessors;

        ListEnumerator      listEnum    = _predecessors.getEnumerator();

        newPredecessors = new Set(Types::String);
        while (listEnum.moveNext())
        {
            newPredecessors.add(listEnum.current());
        }

        selectedNode = tree.getNodeByActivityNumber(_successor);
        oldPredecessors = selectedNode.parmPredecessors();
        selectedNode.parmPredecessors(newPredecessors);

        if (this.checkNoLoops(selectedNode))
        {
            this.clearDependenciesFromDB(_successor);
            this.addDependenciesToDB(newPredecessors, selectedNode.activityNumber());
            return true;
        }

        selectedNode.parmPredecessors(oldPredecessors);
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEffortAtComplete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates effort at complete given new effort to complete.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number of the task for which to update effort at complete.
    /// </param>
    /// <param name="_newEffortToComplete">
    ///     New effort to complete.
    /// </param>
    /// <param name="_psaActivitySetup">
    ///     <c>PSAAcitivitySetup</c> record of the given task.
    /// </param>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void updateEffortAtComplete(ElementNumber _elementNumber, Hours _newEffortToComplete, PSAActivitySetup _psaActivitySetup)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEffortAtCompleteForDescendants</Name>
				<Source><![CDATA[
    private void updateEffortAtCompleteForDescendants(ElementNumber _elementNumber)
    {
        ProjWBSTreeNode childNode, node;
        ProjStack stack = new ProjStack(Types::String);
        ListEnumerator childEnumerator;
        PSAActivitySetup psaActivitySetup;

        ttsbegin;

        stack.push(_elementNumber);
        while (!stack.isEmpty())
        {
            node = tree.getNodeByElementNumber(stack.pop());

            if (node.parmChildrenEffortAtComplete() == 0)
            {
                continue;
            }

            childEnumerator = tree.getChildrenOf(node.elementNumber()).getEnumerator();
            while (childEnumerator.moveNext())
            {
                childNode = tree.getNodeByElementNumber(childEnumerator.current());
                childNode.parmEffortAtComplete(childNode.parmEffortAtComplete() / node.parmChildrenEffortAtComplete() * node.parmEffortAtComplete());

                update_recordSet psaActivitySetup
                setting EffortAtComplete = childNode.parmEffortAtComplete()
                where psaActivitySetup.ActivityNumber == childNode.activityNumber();

                stack.push(childNode.elementNumber());
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEffortAtCompleteSummariesInTree</Name>
				<Source><![CDATA[
    private List updateEffortAtCompleteSummariesInTree(ProjWBSTreeNode _firstAncestorNode, Hours _oldEffortAtComplete, Hours _newEffortAtComplete)
    {
        Hours delta = _newEffortAtComplete - _oldEffortAtComplete;
        Hours currEffortAtComplete;
        ProjWBSTreeNode node;
        List ancestorEffortsAtComplete = new List(Types::Real);

        node = _firstAncestorNode;
        while (node)
        {
            currEffortAtComplete = node.parmEffortAtComplete();
            node.parmEffortAtComplete(currEffortAtComplete + delta);
            ancestorEffortsAtComplete.addEnd(currEffortAtComplete + delta);
            node = tree.getParentNodeOf(node.elementNumber());
        }

        return ancestorEffortsAtComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEffortSummariesInTree</Name>
				<Source><![CDATA[
    private List updateEffortSummariesInTree(ProjWBSTreeNode _firstAncestorNode, Hours _oldEffort, Hours _newEffort)
    {
        Hours delta = _newEffort - _oldEffort;
        Hours currEffort;
        ProjWBSTreeNode node;
        List ancestorEfforts = new List(Types::Real);

        node = _firstAncestorNode;
        while (node)
        {
            currEffort = node.parmEffort();
            node.parmEffort(currEffort + delta);
            ancestorEfforts.addEnd(currEffort + delta);
            node = tree.getParentNodeOf(node.elementNumber());
        }

        return ancestorEfforts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEndDateSummariesInTree</Name>
				<Source><![CDATA[
    private List updateEndDateSummariesInTree(ProjWBSTreeNode _firstAncestorNode)
    {
        SchedToDate maxEndDate;
        ProjWBSTreeNode node = _firstAncestorNode;
        PSAActivitySetup psaActivitySetup;
        List ancestorEndDates = new List(Types::Date);

        while (node)
        {
            maxEndDate = tree.maxChildEndDate(node);
            node.parmEndDate(maxEndDate);
            ancestorEndDates.addEnd(maxEndDate);

            psaActivitySetup.psaSchedStart = node.parmStartDate();
            psaActivitySetup.psaSchedEnd = node.parmEndDate();
            psaActivitySetup.CalendarId = calendarId;
            psaActivitySetup.modifiedField(fieldNum(PSAActivitySetup, psaSchedEnd));
            node.parmActivityDuration(psaActivitySetup.ActivityDuration);

            node = tree.getParentNodeOf(node.elementNumber());
        }

        return ancestorEndDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOutlineNumbersAndPublishInPreOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates task outline numbers and publishes in-memory tasks data to temporary table.
    /// </summary>
    /// <param name="_filterValue">
    ///     Value to filter records on.
    /// </param>
    /// <param name="_filterField">
    ///     Field to filter records on.
    /// </param>
    /// <param name="_isFilteringOn">
    ///     If true tasks are filtered, otherwise it's not.
    /// </param>
    /// <param name="_shouldIgnoreExpandAndCollapse">
    ///     If true ignores expand and collase and publishes all tasks.
    /// </param>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void updateOutlineNumbersAndPublishInPreOrder(str _filterValue = "", str _filterField = "", boolean _isFilteringOn = false, boolean _shouldIgnoreExpandAndCollapse = false)
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectEffortAndDates</Name>
				<Source><![CDATA[
    private void updateProjectEffortAndDates(ProjWBSTreeNode ancestor)
    {
        if (projTable)
        {
            projTable.PSASchedEffort = ancestor.parmEffort();
            projTable.PSASchedStartDate = ancestor.parmStartDate();
            projTable.PSASchedEndDate = ancestor.parmEndDate();
            projTable.modifiedField(fieldNum(ProjTable, PSASchedEndDate));
            projTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateStartDateSummariesInTree</Name>
				<Source><![CDATA[
    private List updateStartDateSummariesInTree(ProjWBSTreeNode _firstAncestorNode)
    {
        SchedFromDate minStartDate;
        ProjWBSTreeNode node = _firstAncestorNode;
        PSAActivitySetup psaActivitySetup;
        List ancestorStartDates = new List(Types::Date);

        while (node)
        {
            minStartDate = tree.minChildStartDate(node);
            node.parmStartDate(minStartDate);
            ancestorStartDates.addEnd(minStartDate);

            psaActivitySetup.psaSchedStart = node.parmStartDate();
            psaActivitySetup.psaSchedEnd = node.parmEndDate();
            psaActivitySetup.CalendarId = calendarId;
            psaActivitySetup.modifiedField(fieldNum(PSAActivitySetup, psaSchedStart));
            node.parmActivityDuration(psaActivitySetup.ActivityDuration);

            node = tree.getParentNodeOf(node.elementNumber());
        }

        return ancestorStartDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSubtreePathsAndLevels</Name>
				<Source><![CDATA[
    private void updateSubtreePathsAndLevels(str _subTreeRootElementNumber)
    {
        ProjStack stack = new ProjStack(Types::String);
        ElementNumber currElementNumber;
        ProjWBSTreeNode currNode;
        ProjWBSTreeNode childNode;
        ListEnumerator currChild;
        List children;
        int i;

        RecordInsertList nodeRecordsToUpdate;
        ProjTmpHierarchyTreeTable currProjTmpHierarchyTreeTable;
        ProjTmpHierarchyTreeTable projTmpHierarchyTreeTable;
        HierarchyTreeTable hierarchyTreeTable;

        #Characters
        ;

        ttsbegin;

        nodeRecordsToUpdate = new RecordInsertList(tableNum(ProjTmpHierarchyTreeTable),
                                                    true,
                                                    true,
                                                    true,
                                                    false,
                                                    true);

        // Clear temp table.
        delete_from projTmpHierarchyTreeTable
        where projTmpHierarchyTreeTable.HierarchyId == tree.hierarchyId();

        stack.push(_subTreeRootElementNumber);
        while (!stack.isEmpty())
        {
            currElementNumber = stack.pop();
            currNode = tree.getNodeByElementNumber(currElementNumber);
            // Update outline numbers and indentation
            children = tree.getChildrenOf(currElementNumber);
            currChild = children.getEnumerator();
            i = children.elements();
            while (currChild.moveNext())
            {
                childNode = tree.getNodeByElementNumber(currChild.current());
                childNode.parmPath(currNode.parmPath() + currNode.elementNumber() + #sharp);
                childNode.parmLevel(currNode.parmLevel() + 1);
                childNode.parmSiblingNumber(i);
                stack.push(currChild.current());
                i -= 1;

                currProjTmpHierarchyTreeTable.HierarchyId = tree.hierarchyId();
                currProjTmpHierarchyTreeTable.ElementNumber = childNode.elementNumber();
                currProjTmpHierarchyTreeTable.Path = childNode.parmPath();
                currProjTmpHierarchyTreeTable.Level = childNode.parmLevel();
                currProjTmpHierarchyTreeTable = currProjTmpHierarchyTreeTable.data();
                nodeRecordsToUpdate.add(currProjTmpHierarchyTreeTable);
            }
        }

        // Fill the tmp table.
        nodeRecordsToUpdate.insertDatabase();

        hierarchyTreeTable.skipDataMethods(true);
        hierarchyTreeTable.skipEvents(true);

        update_recordset hierarchyTreeTable
        setting
            Path = projTmpHierarchyTreeTable.Path,
            Level = projTmpHierarchyTreeTable.Level
        join projTmpHierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == projTmpHierarchyTreeTable.HierarchyId
                  && hierarchyTreeTable.ElementNumber == projTmpHierarchyTreeTable.ElementNumber;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSummariesFromTask</Name>
				<Source><![CDATA[
    private boolean updateSummariesFromTask(ProjWBSTreeNode _firstAncestorNode,
                                            Hours _oldEffort,
                                            Hours _newEffort,
                                            Total _oldCostAtComplete,
                                            Total _newCostAtComplete,
                                            Hours _oldEffortAtComplete,
                                            Hours _newEffortAtComplete,
                                            SchedFromDate _oldStartDate,
                                            SchedFromDate _newStartDate,
                                            SchedToDate _oldEndDate,
                                            SchedToDate _newEndDate)
    {
        boolean shouldUpdateEffort = (_newEffort - _oldEffort != 0);
        boolean shouldUpdateCostAtComplete = (_oldCostAtComplete != _newCostAtComplete);
        boolean shouldUpdateEffortAtComplete = (_oldEffortAtComplete != _newEffortAtComplete);
        boolean shouldUpdateStartDate = (_oldStartDate != _newStartDate);
        boolean shouldUpdateEndDate = (_oldEndDate != _newEndDate);
        List ancestorEfforts;
        List ancestorCostsAtComplete;
        List ancestorEffortsAtComplete;
        List ancestorStartDates;
        List ancestorEndDates;

        if (shouldUpdateEffort || shouldUpdateCostAtComplete || shouldUpdateEffortAtComplete || shouldUpdateStartDate || shouldUpdateEndDate)
        {
            if (shouldUpdateEffort)
            {
                ancestorEfforts = this.updateEffortSummariesInTree(_firstAncestorNode, _oldEffort, _newEffort);
            }

            if (shouldUpdateCostAtComplete)
            {
                ancestorCostsAtComplete = this.updateCostAtCompleteSummariesInTree(_firstAncestorNode, _oldCostAtComplete, _newCostAtComplete);
            }

            if (shouldUpdateEffortAtComplete)
            {
                ancestorEffortsAtComplete = this.updateEffortAtCompleteSummariesInTree(_firstAncestorNode, _oldEffortAtComplete, _newEffortAtComplete);
            }

            if (shouldUpdateStartDate)
            {
                ancestorStartDates = this.updateStartDateSummariesInTree(_firstAncestorNode);
            }

            if (shouldUpdateEndDate)
            {
                ancestorEndDates = this.updateEndDateSummariesInTree(_firstAncestorNode);
            }

            this.updateSummariesInDatabase(_firstAncestorNode,
                                           ancestorStartDates,
                                           ancestorEndDates,
                                           ancestorEfforts,
                                           ancestorCostsAtComplete,
                                           ancestorEffortsAtComplete,
                                           shouldUpdateEffort,
                                           shouldUpdateCostAtComplete,
                                           shouldUpdateEffortAtComplete,
                                           shouldUpdateStartDate,
                                           shouldUpdateEndDate);
        }

        if (shouldUpdateEffort || shouldUpdateStartDate || shouldUpdateEndDate)
        {
            this.updateWBSOwner();
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSummariesInDatabase</Name>
				<Source><![CDATA[
    private void updateSummariesInDatabase(ProjWBSTreeNode _firstAncestorNode,
                                           List _ancestorStartDates,
                                           List _ancestorEndDates,
                                           List _ancestorEfforts,
                                           List _ancestorCostsAtComplete,
                                           List _ancestorEffortsAtComplete,
                                           boolean _shouldUpdateEffort,
                                           boolean _shouldUpdateCostAtComplete,
                                           boolean _shouldUpdateEffortAtComplete,
                                           boolean _shouldUpdateStartDate,
                                           boolean _shouldUpdateEndDate)
    {
        ProjWBSTreeNode node = _firstAncestorNode;

        ListEnumerator ancestorEffort;
        ListEnumerator ancestorCostAtComplete;
        ListEnumerator ancestorEffortAtComplete;
        ListEnumerator ancestorStartDate;
        ListEnumerator ancestorEndDate;

        HierarchyTreeTable currTreeTable;
        HierarchyTreeTable parentTreeTable;
        PSAActivitySetup psaActivitySetup;
        smmActivities smmActivities;

        if (_shouldUpdateEffort)
        {
            ancestorEffort = _ancestorEfforts.getEnumerator();
        }

        if (_shouldUpdateCostAtComplete)
        {
            ancestorCostAtComplete = _ancestorCostsAtComplete.getEnumerator();
        }

        if (_shouldUpdateEffortAtComplete)
        {
            ancestorEffortAtComplete = _ancestorEffortsAtComplete.getEnumerator();
        }

        if (_ancestorStartDates)
        {
            ancestorStartDate = _ancestorStartDates.getEnumerator();
        }

        if (_ancestorEndDates)
        {
            ancestorEndDate = _ancestorEndDates.getEnumerator();
        }

        currTreeTable.ParentElementNumber = node.elementNumber();
        currTreeTable.HierarchyId = tree.hierarchyId();
        while (true)
        {
            select firstonly forupdate psaActivitySetup
                join RecId from smmActivities
                where smmActivities.ActivityNumber == psaActivitySetup.ActivityNumber
                    join ParentElementNumber from parentTreeTable
                        where parentTreeTable.RefRecId == smmActivities.RecId
                                && parentTreeTable.ElementNumber == currTreeTable.ParentElementNumber
                                && parentTreeTable.HierarchyId == currTreeTable.HierarchyId;

            if (_shouldUpdateEffort && ancestorEffort.moveNext())
            {
                psaActivitySetup.Effort = ancestorEffort.current();
            }

            if (_shouldUpdateCostAtComplete && ancestorCostAtComplete.moveNext())
            {
                psaActivitySetup.CostAtComplete = ancestorCostAtComplete.current();
            }

            if (_shouldUpdateEffortAtComplete && ancestorEffortAtComplete.moveNext())
            {
                psaActivitySetup.EffortAtComplete = ancestorEffortAtComplete.current();
            }

            // Update start date and end date (and duration by calling modifiedField).
            if (_shouldUpdateStartDate && ancestorStartDate.moveNext())
            {
                psaActivitySetup.psaSchedStart = ancestorStartDate.current();
            }

            if (_shouldUpdateEndDate && ancestorEndDate.moveNext())
            {
                psaActivitySetup.psaSchedEnd = ancestorEndDate.current();
            }
            psaActivitySetup.CalendarId = psaActivitySetup.CalendarId ? psaActivitySetup.CalendarId : calendarId;
            psaActivitySetup.modifiedField(fieldNum(PSAActivitySetup, psaSchedStart));

            ttsbegin;
            psaActivitySetup.update();
            ttscommit;

            if (parentTreeTable.ParentElementNumber == "")  // if root...
            {
                break;
            }

            currTreeTable.ParentElementNumber = parentTreeTable.ParentElementNumber;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrackingSummaries</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates tracking summaries (values shown in summary tasks) and stores then
    ///     in the in-memory data structure.
    /// </summary>
    [SysObsolete('Method is deprecated due to the WBS architecture is changed. WBS APIs are managed by ProjWorkBreakdownStructureHelper class and publishing is managed by ProjPlanVersionsManager class.', true, 11\01\2021)]
    public void updateTrackingSummaries()
    {
        throw error(Error::wrongUseOfFunction(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWBSOwner</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates WBS owner (e.g. Project, Project quotation) to match WBS.
    /// </summary>
    /// <remarks>
    ///     Pre-condition: in-memory root node must already be up-to-date.
    /// </remarks>
    public void updateWBSOwner()
    {
        ProjWBSTreeNode rootNode = tree.getNodeByElementNumber(tree.rootElementNumber());

        if (rootNode)
        {
            if (projTable)
            {
                projTable.reread();
                projTable.psaSchedEffort = rootNode.parmEffort();
                projTable.psaSchedStartDate = rootNode.parmStartDate();
                projTable.psaSchedEndDate = rootNode.parmEndDate();
                projTable.psaSchedDuration = rootNode.parmActivityDuration();

                projTable.selectForUpdate(true);
                ttsbegin;
                projTable.update();
                ttscommit;
            }
            else if (salesQuotationTable)
            {
                salesQuotationTable.reread();
                salesQuotationTable.psaEstProjStartDate = rootNode.parmStartDate();
                salesQuotationTable.psaEstProjEndDate = rootNode.parmEndDate();

                salesQuotationTable.selectForUpdate(true);
                ttsbegin;
                salesQuotationTable.update();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeEACsToTable</Name>
				<Source><![CDATA[
    private void writeEACsToTable(List nodesToWrite)
    {
        PSAActivitySetup    psaActivitySetup;
        ListEnumerator      nodeEnumerator;
        ProjWBSTreeNode     node;

        nodeEnumerator = nodesToWrite.getEnumerator();

        while (nodeEnumerator.moveNext())
        {
            node = nodeEnumerator.current();

            update_recordSet psaActivitySetup
            setting
                CostAtComplete = node.parmCostAtComplete(),
                EffortAtComplete = node.parmEffortAtComplete()
            where
                psaActivitySetup.ActivityNumber == node.activityNumber();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeToTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Writes in-memory tree contents to database tables.
    /// </summary>
    /// <param name="_skipDataMethodsAndValidation">
    /// Skips data methods and related validation to speed up the operation.
    /// </param>
    public void writeToTable(boolean _skipDataMethodsAndValidation = false)
    {
        ProjStack stack = new ProjStack(Types::String);
        ElementNumber currElementNumber;
        ProjWBSTreeNode currNode;
        ProjWBSTreeNode childNode;
        ListEnumerator currChild;
        List children;
        int i;

        RecordInsertList nodeRecordsToUpdate;
        ProjTmpWBSTransferTable currProjTmpWBSTransferTable;
        ProjTmpWBSTransferTable projTmpWBSTransferTable;
        HierarchyTreeTable hierarchyTreeTable;
        PSAActivitySetup psaActivitySetup;

        #Characters
        ;

        ttsbegin;

        nodeRecordsToUpdate = new RecordInsertList(tableNum(ProjTmpWBSTransferTable),
                                                    true,
                                                    true,
                                                    true,
                                                    false,
                                                    true);

        delete_from projTmpWBSTransferTable
        where projTmpWBSTransferTable.HierarchyId == tree.hierarchyId();

        currNode = tree.getNodeByElementNumber(tree.rootElementNumber());
        currProjTmpWBSTransferTable = this.nodeToTableBuffer(currNode);
        nodeRecordsToUpdate.add(currProjTmpWBSTransferTable);

        stack.push(tree.rootElementNumber());
        while (!stack.isEmpty())
        {
            currElementNumber = stack.pop();
            currNode = tree.getNodeByElementNumber(currElementNumber);
            children = tree.getChildrenOf(currElementNumber);
            currChild = children.getEnumerator();
            i = children.elements();
            while (currChild.moveNext())
            {
                childNode = tree.getNodeByElementNumber(currChild.current());
                childNode.parmPath(currNode.parmPath() + currNode.elementNumber() + #sharp);
                childNode.parmLevel(currNode.parmLevel() + 1);
                childNode.parmSiblingNumber(i);
                stack.push(currChild.current());
                i -= 1;

                currProjTmpWBSTransferTable = this.nodeToTableBuffer(childNode);
                nodeRecordsToUpdate.add(currProjTmpWBSTransferTable);
            }
        }

        // Fill the tmp table.
        nodeRecordsToUpdate.insertDatabase();

        if (_skipDataMethodsAndValidation)
        {
            new SkipAOSValidationPermission().assert();

            hierarchyTreeTable.skipAosValidation(true);
            hierarchyTreeTable.skipDatabaseLog(true);
            hierarchyTreeTable.skipDataMethods(true);
            hierarchyTreeTable.skipEvents(true);
            hierarchyTreeTable.skipTTSCheck(true);

            psaActivitySetup.skipAosValidation(true);
            psaActivitySetup.skipDatabaseLog(true);
            psaActivitySetup.skipDataMethods(true);
            psaActivitySetup.skipEvents(true);
            psaActivitySetup.skipTTSCheck(true);
        }

        update_recordset hierarchyTreeTable
        setting
            Path = projTmpWBSTransferTable.Path,
            Level = projTmpWBSTransferTable.Level,
            SiblingNumber = projTmpWBSTransferTable.SiblingNumber
        join projTmpWBSTransferTable
            where hierarchyTreeTable.HierarchyId      == projTmpWBSTransferTable.HierarchyId
                  && hierarchyTreeTable.ElementNumber == projTmpWBSTransferTable.ElementNumber;

        update_recordset psaActivitySetup
        setting
            Effort = projTmpWBSTransferTable.Effort,
            psaSchedStart = projTmpWBSTransferTable.psaSchedStart,
            psaSchedEnd = projTmpWBSTransferTable.psaSchedEnd,
            ActivityDuration = projTmpWBSTransferTable.ActivityDuration,
            EffortAtComplete = projTmpWBSTransferTable.EffortAtComplete,
            CostAtComplete = projTmpWBSTransferTable.CostAtComplete
        join projTmpWBSTransferTable
            where psaActivitySetup.ActivityNumber == projTmpWBSTransferTable.ActivityNumber;

        ttscommit;

        // Cleaning up temp table outside the tts block above, because in case an exception happens here
        // it won't rollback the functionally critical operations done above.
        delete_from projTmpWBSTransferTable
        where projTmpWBSTransferTable.HierarchyId == tree.hierarchyId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>ProjWBSUpdateController</c> instance.
    /// </summary>
    /// <param name="_hierarchyId">
    /// Hierarchy id of the WBS hierarchy.
    /// </param>
    /// <param name="_calendarId">
    /// Calendar id of associated to the WBS (e.g. project/project quotation calendar).
    /// </param>
    /// <param name="_viewType">
    /// Calendar id of associated to the WBS (e.g. project/project quotation calendar).
    /// </param>
    /// <param name="_wbsOwner">
    /// Table buffer of the WBS owner (i.e. ProjTable, SalesQuotation or null for templates)
    /// </param>
    /// <param name="_tmpTreeTable">
    ///     A not-null <c>tmpTreeTable</c> table buffer.
    /// </param>
    /// <returns>
    /// A <c>ProjWBSUpdateController</c> instance.
    /// </returns>
    public static ProjWBSUpdateController construct(HierarchyIdBase _hierarchyId,
                                                    CalendarId      _calendarId,
                                                    ProjViewType    _viewType = ProjViewType::PlanningView,
                                                    Common          _wbsOwner = null,
                                                    TmpTreeTable    _tmpTreeTable = null)
    {
        ProjTable           projTable           = null;
        SalesQuotationTable salesQuotationTable = null;

        if (_wbsOwner)
        {
            if (_wbsOwner.TableId == tableNum(ProjTable))
            {
                projTable = _wbsOwner;
            }
            else if (_wbsOwner.TableId == tableNum(ProjTable))
            {
                salesQuotationTable = _wbsOwner;
            }
        }

        return new ProjWBSUpdateController(_hierarchyId,
                                           _calendarId,
                                           null,
                                           null,
                                           null,
                                           _tmpTreeTable,
                                           false,
                                           _viewType,
                                           projTable,
                                           salesQuotationTable,
                                           true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resummarizeParent</Name>
				<Source><![CDATA[
    private static void resummarizeParent(ProjWBSTreeNode _parentNode, ProjWBSTreeNode _childNode, CalendarId _calendarId)
    {
        Hours activityDuration;

        _parentNode.parmPlannedCost(_parentNode.parmPlannedCost() + _childNode.parmPlannedCost());
        _parentNode.parmEffort(_parentNode.parmEffort() + _childNode.parmEffort());
        _parentNode.parmCostAtComplete(_parentNode.parmCostAtComplete() + _childNode.parmCostAtComplete());
        _parentNode.parmEffortAtComplete(_parentNode.parmEffortAtComplete() + _childNode.parmEffortAtComplete());

        if (_parentNode.parmStartDate() == dateNull() || _parentNode.parmStartDate() > _childNode.parmStartDate())
        {
            _parentNode.parmStartDate(_childNode.parmStartDate());
        }

        if (_parentNode.parmEndDate() == dateNull() || _parentNode.parmEndDate() < _childNode.parmEndDate())
        {
            _parentNode.parmEndDate(_childNode.parmEndDate());
        }

        if (_parentNode.parmStartDate() && _parentNode.parmEndDate())
        {
            activityDuration = WorkCalendarCalculator::calcDuration(_parentNode.parmStartDate(), _parentNode.parmEndDate(), _calendarId);
            _parentNode.parmActivityDuration(activityDuration);
        }
        else
        {
            _parentNode.parmActivityDuration(0);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resummarizeTaskFromChildrenInDatabase</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Resummarizes a summary task from its children tasks.
    /// </summary>
    /// <param name="_elementNumber">
    ///     Element number that identifies the task in the WBS hierarchy.
    /// </param>
    /// <param name="_hierarchyId">
    ///     Hierarchy Id that identifies the WBS hierarchy.
    /// </param>
    /// <remarks>
    ///     Pre-conditions: the element number must correspond to summary (i.e. non-leaf) task.
    /// </remarks>
    public static void resummarizeTaskFromChildrenInDatabase(ElementNumber _elementNumber, HierarchyIdBase _hierarchyId)
    {
        HierarchyTreeTable  parentNode, childNode;
        PSAActivitySetup    parentTaskInfo, childTaskInfo;
        smmActivities       parentActivity, childActivity;

        select firstOnly parentNode
        where parentNode.HierarchyId == _hierarchyId
            && parentNode.ElementNumber == _elementNumber;

        select forupdate parentTaskInfo
        join RecId from parentActivity
        where parentActivity.ActivityNumber == parentTaskInfo.ActivityNumber
            join RecId from parentNode
            where parentNode.RefRecId           == parentActivity.RecId
                  && parentNode.ElementNumber   == _elementNumber
                  && parentNode.HierarchyId     == _hierarchyId;

        if (parentTaskInfo)
        {
            select
                sum(Effort),
                minof(psaSchedStart),
                maxof(psaSchedEnd),
                sum(EffortAtComplete),
                sum(CostAtComplete) from childTaskInfo
                where childTaskInfo.psaSchedStart != dateNull()
                      && childTaskInfo.psaSchedEnd != dateNull()
                    join RecId from childActivity
                    where childActivity.ActivityNumber == childTaskInfo.ActivityNumber
                        join RecId from childNode
                        where childNode.RefRecId                == childActivity.RecId
                              && childNode.ParentElementNumber  == _elementNumber
                              && childNode.HierarchyId          == _hierarchyId;

            parentTaskInfo.Effort = childTaskInfo.Effort;
            parentTaskInfo.psaSchedStart = childTaskInfo.psaSchedStart;
            parentTaskInfo.psaSchedEnd = childTaskInfo.psaSchedEnd;
            parentTaskInfo.EffortAtComplete = childTaskInfo.EffortAtComplete;
            parentTaskInfo.CostAtComplete = childTaskInfo.CostAtComplete;

            if (parentTaskInfo.CalendarId)
            {
                parentTaskInfo.modifiedField(fieldNum(PSAActivitySetup, psaSchedEnd));
            }

            ttsbegin;
            parentTaskInfo.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resummarizeWBS</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Re-summarizes the entire WBS.
    /// </summary>
    /// <param name="_hierarchyId">
    ///     Hierarchy id of the WBS hierarchy.
    /// </param>
    /// <param name="_calendarId">
    ///     Calendar id of associated to the WBS (e.g. project/project quotation calendar).
    /// </param>
    /// <param name="_shouldReInitializeEACFromPlanned">
    ///     if true also re-initializes all EAC (e.g. Effort at complete and Cost at complete).
    /// </param>
    /// <remarks>
    ///     Utilizes in-memory tree to perform re-summarization.
    /// </remarks>
    public static void resummarizeWBS(HierarchyIdBase _hierarchyId, CalendarId _calendarId, boolean _shouldReInitializeEACFromPlanned = false)
    {
        ProjWBSUpdateController controller = ProjWBSUpdateController::construct(_hierarchyId, _calendarId);

        controller.resummarizeInMemory();

        if (_shouldReInitializeEACFromPlanned)
        {
            controller.initEACFromPlannedInMemory();
        }

        controller.writeToTable(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSmmActivities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the StartDateTime and EndDateTime in smmActivities table
    /// </summary>
    /// <param name="_psaActivitySetup">
    /// buffer of <c>PSAActivitySetup</c> table
    /// </param>
    public void updateSmmActivities(PSAActivitySetup _psaActivitySetup)
    {
        smmActivities  localsmmActivities;
        ttsBegin;
        select forUpdate localsmmActivities
            where localsmmActivities.ActivityNumber == _psaActivitySetup.ActivityNumber;
        if (localsmmActivities.RecId)
        {
            localsmmActivities.StartDateTime = DateTimeUtil::newDateTime(_psaActivitySetup.PSASchedStart, 0, DateTimeUtil::getCompanyTimeZone());
            localsmmActivities.EndDateTime   = DateTimeUtil::newDateTime(_psaActivitySetup.PSASchedEnd, 0, DateTimeUtil::getCompanyTimeZone());
            localsmmActivities.update();
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfRelatedBillingMilestoneExists</Name>
				<Source><![CDATA[
    private static boolean checkIfRelatedBillingMilestoneExists(ProjTable projTable, Set activityNumbers, boolean _isComplete)
    {
        ProjOnAccTrans projOnAccTrans;
        Enumerator activityNumberEnumerator;
        NoYes milestoneStatus;

        boolean projMultipleContractLinesForProjectFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        if (!projTable || (!projMultipleContractLinesForProjectFeatureEnabled && projTable.Type != ProjType::FixedPrice) ||
            (projMultipleContractLinesForProjectFeatureEnabled &&
            !ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            return false;
        }

        milestoneStatus = _isComplete ? NoYes::No : NoYes::Yes;

        activityNumberEnumerator = activityNumbers.getEnumerator();
        activityNumberEnumerator.reset();

        while (activityNumberEnumerator.moveNext())
        {
            while select  RecId from projonAccTrans
                    where projOnAccTrans.ActivityNumber == activityNumberEnumerator.current()
                    && projOnAccTrans.ProjId == projTable.ProjId
                    && projOnAccTrans.IsMilestoneComplete == milestoneStatus
            {
                if (projOnAccTrans.RecId)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRelatedBillingMilestone</Name>
				<Source><![CDATA[
    private static void updateRelatedBillingMilestone(ProjTable projTable, Set activityNumbers)
    {
        ProjOnAccTrans projOnAccTrans;
        Enumerator activityNumberEnumerator;

        boolean projMultipleContractLinesForProjectFeatureEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        if (!projTable || (!projMultipleContractLinesForProjectFeatureEnabled && projTable.Type != ProjType::FixedPrice) ||
            (projMultipleContractLinesForProjectFeatureEnabled &&
            !ProjMultipleContractLinesForProjectFeatureHelper::existContractLineForBillingMethod(projTable.ProjId, projTable.ProjInvoiceProjId, ProjContractBillingMethod::FixedPrice)))
        {
            return;
        }

        activityNumberEnumerator = activityNumbers.getEnumerator();
        activityNumberEnumerator.reset();

        while (activityNumberEnumerator.moveNext())
        {
            while select forUpdate projOnAccTrans
                    where projOnAccTrans.ActivityNumber == activityNumberEnumerator.current()
                    && projOnAccTrans.ProjId == projTable.ProjId
                    && projOnAccTrans.IsMilestoneComplete == NoYes::No
            {
                if (projOnAccTrans.RecId)
                {
                    projOnAccTrans.IsMileStoneComplete = NoYes::Yes;
                    projOnAccTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostedActualCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets actual costs for a hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">The hierarchy ID of the hierarchy.</param>
    /// <returns>A map containing the activity number and total posted actual cost for every activity in the hierarchy.</returns>
    public static Map getPostedActualCost(HierarchyIdBase _hierarchyId)
    {
        Map                                 postedActualCost;
        Total                               rootActualCost;
        ProjTable                           projTable;
        ProjTaskCostView                    taskCostView;
        str                                 rootActivityNumber;

        postedActualCost    = new Map(Types::String, Types::Real);
        rootActivityNumber  = HierarchyTreeTable::findRootActivityNumber(_hierarchyId);
        projTable           = HierarchyLinkTable::findAssociation(_hierarchyId, tableNum(ProjTable));

        while select ActivityNumber, TotalCost from taskCostView
            where taskCostView.ProjId == projTable.ProjId
        {
            if (taskCostView.ActivityNumber && taskCostView.ActivityNumber != rootActivityNumber)
            {
                postedActualCost.insert(taskCostView.ActivityNumber, taskCostView.TotalCost);
            }
            else
            {
                rootActualCost += taskCostView.TotalCost;
            }
        }

        postedActualCost.insert(rootActivityNumber, rootActualCost);

        return postedActualCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostedActualEffort</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the actual effort for a hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">The hierarchy ID of the hierarchy.</param>
    /// <returns>A map containing the activity number and total posted actual effort for every activity in the hierarchy.</returns>
    public static Map getPostedActualEffort(HierarchyIdBase _hierarchyId)
    {
        Map                         postedActualEffort;
        Total                       rootActualEffort;
        ProjTable                   projTable;
        ProjTaskActualEffortView    taskActualEffortView;
        str                         rootActivityNumber;

        postedActualEffort = new Map(Types::String, Types::Real);
        rootActivityNumber  = HierarchyTreeTable::findRootActivityNumber(_hierarchyId);
        projTable           = HierarchyLinkTable::findAssociation(_hierarchyId, tableNum(ProjTable));

        while select ActivityNumber, TotalEffort from taskActualEffortView
                    where taskActualEffortView.ProjId == projTable.projId
        {
            if (taskActualEffortView.ActivityNumber && taskActualEffortView.ActivityNumber != rootActivityNumber)
            {
                postedActualEffort.insert(taskActualEffortView.ActivityNumber, taskActualEffortView.TotalEffort);
            }
            else
            {
                rootActualEffort += taskActualEffortView.TotalEffort;
            }
        }
        postedActualEffort.insert(rootActivityNumber, rootActualEffort);

        return postedActualEffort;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>