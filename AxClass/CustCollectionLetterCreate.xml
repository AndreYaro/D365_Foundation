<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustCollectionLetterCreate</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustCollectionLetterCreate extends RunBaseBatch implements BatchRetryable
{
    QueryRun queryRun;

    DialogField dialogInvoice;
    DialogField dialogCreditNote;
    DialogField dialogPayment;
    DialogField dialogInterest;

    DialogField dialogCustCollectionLetterCode;
    DialogField dialogCollectionLetterDate;
    DialogField dialogAccountChoice;
    DialogField dialogPostingProfile;

    TransDate collectionLetterDate;
    CustCollectionLetterCode collectionLetterCode;
    NoYes feeOnCollectionLetter;
    CustPostingProfile custPostingProfile;
    AccountChoice accountChoice;

    Counter qty;
    Counter numMaxCollectionPerCust;
    RecId collectionLetter[ ,100];
    CustCollectionLetterCode custCollectionLetterCode[ ,100];

    RecordSortedList custTransOpenList;
    RecordInsertList custTransOpenRefRecIdList;
    CustCollectionTransOpenRefRecIdTmp custCollectionTransOpenRefRecIdTmp;
    CustCollectionLetterCodeTmp custCollectionLetterCodeTmpStatic;
    CustCollectionLetterLine custCollectionLetterLine;
    AmountCur totalAmount[5];
    Counter progressCounter;

    boolean includeInvoices;
    boolean includeCreditNotes;
    boolean includePayments;
    boolean includeInterestNotes;
    boolean collectionLetterCreated;
    boolean useCurrentDate;

    container custAccountsRestriction;
    boolean hasRestrictionBeenAppliedToQuery;

    int dialogBillingClassificationNamesId;

    DialogField dialogInclTransWithNoBillingClassifications;
    str billingClassificationIds;
    NoYes inclTransWithNoBillingClassifications;
    SysLookupMultiSelectCtrl custBillingClassificationLookup;
    boolean isBillingClassificationEnabled;

    PositiveDays graceDaysAfterTransDate;
    NoYes referToCollectionAgency[ ,100];
    boolean enableReferToCollectionAgency;

    CustCollectionLetterCodeOrderedList custCollectionLetterCodeOrderedList;
    
    private CustParameters custParameters;
    private boolean isMainBatchTask = true;
    private boolean isFinalBatchTask;
    private guid jobSessionId;
    private const int BaseExponentialWait = 2; // exponential backoff base value

    #DEFINE.CurrentVersion(10)
    #LOCALMACRO.CurrentList_v10
        collectionLetterDate,
        collectionLetterCode,
        custPostingProfile,
        accountChoice,
        includeInvoices,
        includeCreditNotes,
        includePayments,
        includeInterestNotes,
        custAccountsRestriction,
        billingClassificationIds,
        inclTransWithNoBillingClassifications,
        isBillingClassificationEnabled
    #ENDMACRO

    #DEFINE.CurrentVersion(11)
    #LOCALMACRO.CurrentList_v11
        collectionLetterDate,
        collectionLetterCode,
        custPostingProfile,
        accountChoice,
        includeInvoices,
        includeCreditNotes,
        includePayments,
        includeInterestNotes,
        custAccountsRestriction,
        billingClassificationIds,
        inclTransWithNoBillingClassifications,
        isBillingClassificationEnabled,
        useCurrentDate
    #ENDMACRO
    
    #DEFINE.CurrentVersion(12)
    #LOCALMACRO.CurrentList
        collectionLetterDate,
        collectionLetterCode,
        custPostingProfile,
        accountChoice,
        includeInvoices,
        includeCreditNotes,
        includePayments,
        includeInterestNotes,
        custAccountsRestriction,
        billingClassificationIds,
        inclTransWithNoBillingClassifications,
        isBillingClassificationEnabled,
        useCurrentDate,
        isMainBatchTask,
        isFinalBatchTask,
        jobSessionId
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class where the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Running a class two times with the
    ///    same parameters is not always possible. If the <see cref="M:RunBaseBatch.canGoBatch" /> method
    ///    returns false, this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLastCollectionLetterDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the last collection letter date to use when checking the <c>CustTransOpen</c> record during creation of a new
    /// collection letter.
    /// </summary>
    /// <param name = "_previousCustCollectionLetterJour">The last updated customer collection letter.</param>
    /// <returns>The last collection letter date to use when creating a new collection letter.</returns>
    [SysObsolete('This method is no longer used. Please use method determineLastCollectionLetterDateFromCustTransOpen.', false, 30\6\2020)]
    protected TransDate determineLastCollectionLetterDate(CustCollectionLetterJour _previousCustCollectionLetterJour)
    {
        return custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Posting ?
            _previousCustCollectionLetterJour.CollectionLetterDate : _previousCustCollectionLetterJour.PrintDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineLastCollectionLetterDateFromCustTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the last collection letter date to use when checking the <c>CustTransOpen</c> record during creation of a new
    /// collection letter.
    /// </summary>
    /// <param name = "_previousCustCollectionLetterJour">The last updated customer collection letter.</param>
    /// <param name = "_custTransOpen">The <c>CustTransOpen</c> record currently being checked.</param>
    /// <returns>The last collection letter date to use when creating a new collection letter.</returns>
    protected TransDate determineLastCollectionLetterDateFromCustTransOpen(CustCollectionLetterJour _previousCustCollectionLetterJour, CustTransOpen _custTransOpen)
    {
        return _custTransOpen.CollectionLetterCode == CustCollectionLetterCode::None ?
            _custTransOpen.DueDate : _previousCustCollectionLetterJour.CollectionLetterDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustCollectionLetterLineValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>CustCollectionLetterLine</c> record is valid for processing collection letter creation.
    /// </summary>
    /// <param name = "_lastCollectionLetterDate">The last collection letter date to use when creating a new collection letter.</param>
    /// <returns>true if the <c>CustCollectionLetterLine</c> record is valid for processing collection letter creation; otherwise, false.</returns>
    protected boolean isCustCollectionLetterLineValid(TransDate _lastCollectionLetterDate)
    {
        boolean ret = false;

        if (custCollectionLetterLine
            && (custCollectionLetterLine.CollectionLetterCode == this.parmCollectionLetterCode()
                || custCollectionLetterCodeOrderedList.indexOf(this.parmCollectionLetterCode()) >= custCollectionLetterCodeOrderedList.indexOf(CustCollectionLetterCode::All))
                && _lastCollectionLetterDate + custCollectionLetterLine.NumOfDays <= this.parmCollectionLetterDate())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustTransOpen</Name>
				<Source><![CDATA[
    protected boolean checkCustTransOpen(CustTransOpenRefRecId _refRecId, CustTable _custTable)
    {
        CustTransOpen custTransOpen = CustTransOpen::find(_refRecId);
        CustTrans custTrans = custTransOpen.custTrans();
        boolean isValid;

        if (this.custTransOk(custTrans) && custTransOpen.CollectionLetter == NoYes::Yes)
        {
            CustCollectionLetterJour previousCustCollectionLetterJour = custTransOpen.lastUpdatedCollectionLetter(false, true);

            // If there are no records with CustTransOpenRefRecIds found either it is the first time a collection letter
            // is being generated for the custTransOpen record or the CustCollectionLetterJour records were generated
            // before fix for TFSID 3684120. We need to check to see if that is the case and fall back to using
            // CollectionLetterJour records associated with the custTrans record.
            if (!previousCustCollectionLetterJour)
            {
                previousCustCollectionLetterJour = custTrans.lastUpdatedCollectionLetterOld();
            }

            CustCollectionLetterCode transCollectionLetterCode = custTransOpen.CollectionLetterCode;
            TransDate lastCollectionLetterDate = this.determineLastCollectionLetterDateFromCustTransOpen(previousCustCollectionLetterJour, custTransOpen);

            if (isBillingClassificationEnabled || enableReferToCollectionAgency)
            {
                custCollectionLetterLine = this.nextCustCollectionLetterLine(_custTable.AccountNum, _custTable.Currency, transCollectionLetterCode, custTrans);
            }
            else
            {
                custCollectionLetterLine = this.nextCustCollectionLetterLine(_custTable.AccountNum, _custTable.Currency, transCollectionLetterCode);
            }

            if (this.isCustCollectionLetterLineValid(lastCollectionLetterDate))
            {
                isValid = true;
                feeOnCollectionLetter = NoYes::Yes;
            }
            else if (previousCustCollectionLetterJour
                && custCollectionLetterCodeOrderedList.indexOf(transCollectionLetterCode) != custCollectionLetterCodeOrderedList.indexOf(CustCollectionLetterCode::None)
                && custParameters.isCustomerLevelCollectionLetterEnabled())
            {
                // When generating customer-level collection letters, include all previously-included transactions, without incrementing the code
                CustCollectionLetterCode previousCode = CustCollectionLetterCodeOrderedList::determinePreviousCustCollectionLetterCode(transCollectionLetterCode);
                custCollectionLetterLine = this.nextCustCollectionLetterLine(_custTable.AccountNum, _custTable.Currency, previousCode);
                isValid = true;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectionLetterCode</Name>
				<Source><![CDATA[
    public CustCollectionLetterCode parmCollectionLetterCode(CustCollectionLetterCode _collectionLetterCode = collectionLetterCode)
    {
        collectionLetterCode = _collectionLetterCode;
        return collectionLetterCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBillingClassificationIds</Name>
				<Source><![CDATA[
    public str parmBillingClassificationIds(str _billingClassificationIds = billingClassificationIds)
    {
        billingClassificationIds = _billingClassificationIds;
        return billingClassificationIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectionLetterDate</Name>
				<Source><![CDATA[
    public TransDate parmCollectionLetterDate(TransDate _collectionLetterDate = collectionLetterDate)
    {
        collectionLetterDate = _collectionLetterDate;
        return collectionLetterDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canIncludeCustCollectionLetterLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the condition to include the <c>CustCollectionLetterLine</c> record.
    /// </summary>
    /// <param name = "_custCollectionLetterLine">
    ///     A <c>CustCollectionLetterLine</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the <c>CustCollectionLetterLine</c> can be included; otherwise, false.
    /// </returns>
    protected boolean canIncludeCustCollectionLetterLine(CustCollectionLetterLine _custCollectionLetterLine)
    {
        return (this.totalAmount(_custCollectionLetterLine)
            && CurrencyExchangeHelper::curAmount(this.totalAmount(_custCollectionLetterLine), _custCollectionLetterLine.CurrencyCode, this.getActualCollectionLetterDate()) >= _custCollectionLetterLine.MinAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustColletionLetterJourForPerCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the <c>CustCollectionLetterJour</c> record for CollectionPerCust collection letter code.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    ///     A <c>CustCollectionLetterJour</c> buffer.
    /// </param>
    /// <param name = "_custTable">
    ///     A <c>CustTable</c> buffer.
    /// </param>
    protected void updateCustColletionLetterJourForPerCustomer(CustCollectionLetterJour _custCollectionLetterJour, CustTable _custTable)
    {
        if (custCollectionLetterCodeOrderedList.indexOf(_custCollectionLetterJour.CollectionLetterCode) < custCollectionLetterCodeOrderedList.indexOf(custCollectionLetterLine.CollectionLetterCode))
        {
            _custCollectionLetterJour.CollectionLetterCode = custCollectionLetterLine.CollectionLetterCode;
            _custCollectionLetterJour.initFromCustCollectionLetterLine(custCollectionLetterLine);

            if (_custTable.CustExcludeCollectionFee ||
                (feeOnCollectionLetter == NoYes::No && custParameters.isCustomerLevelCollectionLetterEnabled()))
            {
                _custCollectionLetterJour.Fee = 0;
            }
            _custCollectionLetterJour.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustCollectionLetterJourForCollectionLetterCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the <c>CustCollectionLetterJour</c> record.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    ///     A <c>CustCollectionLetterJour</c> buffer.
    /// </param>
    /// <param name = "_custTable">
    ///     A <c>CustTable</c> buffer.
    /// </param>
    /// <param name = "_custTrans">
    ///     A <c>CustTrans</c> buffer.
    /// </param>
    /// <param name = "_prefix">
    ///     A string used for prefix.
    /// </param>
    /// <param name = "_counter">
    ///     Counter for <c>CustCollectionLetterCode</c> enum.
    /// </param>
    protected void createCustCollectionLetterJourForCollectionLetterCode(
        CustCollectionLetterJour _custCollectionLetterJour,
        CustTable _custTable,
        CustTrans _custTrans,
        str _prefix,
        Counter _counter)
    {
        #ISOCountryRegionCodes

        _custCollectionLetterJour.clear();

        this.initializeCustCollectionLetterJourForCollectionLetterCode(_custCollectionLetterJour, _custTable, _custTrans);

        if (this.parmCollectionLetterCode() == CustCollectionLetterCode::CollectionPerCust)
        {
            if (isBillingClassificationEnabled)
            {
                this.updateAllExisting(_custTable.AccountNum, _prefix, _custTrans.CustBillingClassification);
            }
            else
            {
                this.updateAllExisting(_custTable.AccountNum, _prefix);
            }
        }
        else
        {
            if (isBillingClassificationEnabled)
            {
                this.updateExisting(_custTable.AccountNum,
                                                    custCollectionLetterCode[_counter],
                                                    _prefix,
                                                    _custTrans.CustBillingClassification,
                                                    referToCollectionAgency[_counter]);
            }
            else
            {
                this.updateExisting(_custTable.AccountNum,
                                                    custCollectionLetterCode[_counter],
                                                    _prefix,
                                                    0,
                                                    referToCollectionAgency[_counter]);
            }
        }

        if (CustConfigurablePaymentIdFeature_CH::isEnabled()
            || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]) && _custCollectionLetterJour.NumberSequenceTable))
        {
            _custCollectionLetterJour.setPaymId(_custCollectionLetterJour.NumberSequenceTable);
        }

        PaymTermId paymTermId = CustCollectionLetterTable::find(custCollectionLetterLine.CollectionLetterCourse).PaymTermId;
        _custCollectionLetterJour.PaymTermId = paymTermId ? paymTermId : _custTable.PaymTermId;

        if (PaymTerm::isCashAccount(_custCollectionLetterJour.PaymTermId))
        {
            throw error(strfmt("@AccountsReceivable:CollectionLetterCanNotBeCreatedWithTermsOfPaymentUsingCashAccount", _custTable.AccountNum));
        }

        if (_custCollectionLetterJour.PaymTermId)
        {
            _custCollectionLetterJour.DueDate = CustCollectionLetter::getAdjustedDate(_custCollectionLetterJour);
        }

        if (_custCollectionLetterJour.validateWrite())
        {
            _custCollectionLetterJour.insert();

            collectionLetterCreated = true;
            this.logInfo(_prefix, strFmt("@SYS66285", _custCollectionLetterJour.CollectionLetterNum, _custCollectionLetterJour.CollectionLetterCode, _custCollectionLetterJour.AccountNum));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustCollectionLetterJourForCollectionLetterCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes fields on the <c>CustCollectionLetterJour</c> table buffer.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal table buffer.</param>
    /// <param name = "_custTable">The customer record.</param>
    /// <param name = "_custTrans">The customer transaction record.</param>
    protected void initializeCustCollectionLetterJourForCollectionLetterCode(
        CustCollectionLetterJour _custCollectionLetterJour,
        CustTable _custTable,
        CustTrans _custTrans)
    {
        _custCollectionLetterJour.collectionLetterNum();

        if (_custCollectionLetterJour.CollectionLetterNum == '')
        {
            throw error(strFmt("@SYS28626","@SYS13960"));
        }
        _custCollectionLetterJour.initFromCustTable(_custTable);

        _custCollectionLetterJour.CollectionLetterDate = this.getActualCollectionLetterDate();

        if (custParameters.CollectionLetterIgnoreCreditTransactionCodes
            && (_custTrans.isCreditNote() || _custTrans.isPayment())
            && custCollectionLetterCodeOrderedList.indexOf(this.parmCollectionLetterCode()) > custCollectionLetterCodeOrderedList.indexOf(CustCollectionLetterCode::All))
        {
            // Do not use the code from a credit transaction if the parameter is set to ignore, and the selected code is per customer;
            // default the first code instead
            _custCollectionLetterJour.CollectionLetterCode = CustCollectionLetterCodeOrderedList::determineNextCustCollectionLetterCode(CustCollectionLetterCode::None);
        }
        else
        {
            _custCollectionLetterJour.CollectionLetterCode = custCollectionLetterLine.CollectionLetterCode;
        }

        _custCollectionLetterJour.ReferToCollectionAgency_W = custCollectionLetterLine.ReferToCollectionAgency_W;

        if (isBillingClassificationEnabled)
        {
            _custCollectionLetterJour.CustBillingClassification = _custTrans.CustBillingClassification;
        }
        _custCollectionLetterJour.PostingProfile = this.parmCustPostingProfile();

        _custCollectionLetterJour.initFromCustCollectionLetterLine(custCollectionLetterLine);

        if (_custTable.CustExcludeCollectionFee == NoYes::Yes ||
                (feeOnCollectionLetter == NoYes::No && custParameters.isCustomerLevelCollectionLetterEnabled()))
        {
            _custCollectionLetterJour.Fee = 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Creates journal.
    /// </summary>
    /// <param name = "_custTable">
    ///     A <c>CustTable</c> buffer.
    /// </param>
    /// <param name = "_prefix">
    ///     A string used for prefix.
    /// </param>
    /// <param name = "_custTrans">
    ///     A <c>CustTrans</c> buffer.
    /// </param>
    protected void createJournal(CustTable _custTable,
                                 str _prefix = getPrefix(),
                                 CustTrans _custTrans = null)
    {
        Counter counter;
        Counter transCounter;
        CustCollectionLetterJour custCollectionLetterJour;
        boolean moreRecords;
        boolean custOk = true;

        for (counter = 1; counter <= qty; counter++)
        {
            if (collectionLetter[counter] != 0)
            {
                moreRecords = false;
                for (transCounter = 1; transCounter <= qty; transCounter++)
                {
                    if (collectionLetter[transCounter] != 0)
                    {
                        moreRecords = true;
                        break;
                    }
                }
                if (!moreRecords)
                {
                    break;
                }

                if (isBillingClassificationEnabled)
                {
                    custCollectionLetterLine = this.custCollectionLetterLine(_custTable.AccountNum, _custTable.Currency, custCollectionLetterCode[counter], _custTrans);
                }
                else
                {
                    custCollectionLetterLine = this.custCollectionLetterLine(_custTable.AccountNum, _custTable.Currency, custCollectionLetterCode[counter]);
                }

                if (!custCollectionLetterLine)
                {
                    custOk = false;
                }
                if (custOk)
                {
                    if (this.canIncludeCustCollectionLetterLine(custCollectionLetterLine))
                    {
                        CustTrans custTransLocal = _custTrans;
                        boolean ignoreCreditTransactionCodes = custParameters.CollectionLetterIgnoreCreditTransactionCodes;

                        if (ignoreCreditTransactionCodes)
                        {
                            CustTransOpen custTransOpen;
                            custTransOpen.RecId = collectionletter[counter];
                            custTransOpenList.find(custTransOpen);
                            custTransLocal = custTransOpen.custTrans();
                        }
                        
                        if (this.parmCollectionLetterCode() == CustCollectionLetterCode::CollectionPerCust
                            && custCollectionLetterJour.RecId != 0
                            && custCollectionLetterLine.ReferToCollectionAgency_W == NoYes::No)
                        {
                            // Do not use the code from a credit transaction if the parameter is set to ignore
                            boolean skipUpdate = (ignoreCreditTransactionCodes && (custTransLocal.isCreditNote() || custTransLocal.isPayment()));

                            if (!skipUpdate)
                            {
                                this.updateCustColletionLetterJourForPerCustomer(custCollectionLetterJour, _custTable);
                            }
                        }
                        else
                        {
                            this.createCustCollectionLetterJourForCollectionLetterCode(custCollectionLetterJour, _custTable, custTransLocal, _prefix, counter);
                        }
                        
                        this.createCustCollectionLetterTransForJournal(custCollectionLetterJour);
                    }
                }
                else
                {
                    this.logInfo(_prefix, strFmt("@SYS22908", _custTable.AccountNum, custCollectionLetterCode[counter], _custTable.Currency, this.parmCustPostingProfile()));
                }
            }
        }
        totalAmount[0] = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustCollectionLetterTransForJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the <c>CustCollectionLetterTrans</c> records for the <c>CustCollectionLetterJour</c> record.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">
    ///     A <c>CustCollectionLetterJour</c> buffer.
    /// </param>
    protected void createCustCollectionLetterTransForJournal(CustCollectionLetterJour _custCollectionLetterJour)
    {
        this.createCustCollectionLetterTransForJournalSetbased(_custCollectionLetterJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateCustCollectionLetterTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not a new <c>CustCollectionLetterTrans</c> record can be created.
    /// </summary>
    /// <param name = "_custCollectionLetterLine">The current <c>CustCollectionLetterLine</c> record.</param>
    /// <param name = "_transCounter">The position in the array of collection letter codes.</param>
    /// <returns>True if a new <c>CustCollectionLetterTrans</c> record can be created; otherwise, false.</returns>
    protected boolean canCreateCustCollectionLetterTrans(CustCollectionLetterLine _custCollectionLetterLine, Counter _transCounter)
    {
        return custCollectionLetterCode[_transCounter] == _custCollectionLetterLine.CollectionLetterCode
            && referToCollectionAgency[_transCounter] == _custCollectionLetterLine.ReferToCollectionAgency_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustCollectionLetterTransForJournalSetbased</Name>
				<Source><![CDATA[
    private void createCustCollectionLetterTransForJournalSetbased(CustCollectionLetterJour _custCollectionLetterJour)
    {
        CustCollectionLetterTrans collectionLetterTrans;
        CustTransOpen transOpen;
        CustTrans trans;

        NoYes letterIssued = NoYes::Yes;
        CustCollectionLetterCode letterCode = custCollectionLetterLine.CollectionLetterCode;
        NoYes referToAgency = custCollectionLetterLine.ReferToCollectionAgency_W;
        CustAccount accountNum = _custCollectionLetterJour.AccountNum;
        CollectionLetterNum letterNum = _custCollectionLetterJour.CollectionLetterNum;

        custTransOpenRefRecIdList.insertDatabase();
        this.updateCollectionLetterArray();
        
        insert_recordset collectionLetterTrans (
            CollectionLetterNum, 
            AccountNum, 
            CollectionLetterIssued, 
            CollectionLetterCode, 
            CustTransOpenRecId, 
            DueDate, 
            RemainAmount, 
            TransDate, 
            CustTransId, 
            Voucher, 
            Invoice, 
            CurrencyCode, 
            Txt, 
            CalculationAmount)
        select
            letterNum,
            accountNum,
            letterIssued,
            letterCode,
            RecId,
            DueDate,
            AmountCur,
            TransDate
        from transOpen
        join custCollectionTransOpenRefRecIdTmp
            where transOpen.RecId == custCollectionTransOpenRefRecIdTmp.CustTransOpenRefRecId
                && custCollectionTransOpenRefRecIdTmp.CustCollectionLetterCode == letterCode
                && custCollectionTransOpenRefRecIdTmp.ReferToCollectionAgency == referToAgency
        join 
            RecId,
            Voucher,
            Invoice,
            CurrencyCode,
            Txt,
            AmountCur
        from trans
            where transOpen.RefRecId == trans.RecId
                && transOpen.AccountNum == accountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionLetterArray</Name>
				<Source><![CDATA[
    private void updateCollectionLetterArray()
    {
        for (int transCounter = 1; transCounter <= qty; transCounter++)
        {
            if (this.canCreateCustCollectionLetterTrans(custCollectionLetterLine, transCounter))
            {
                collectionLetter[transCounter] = 0;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustCollectionLetterTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>CustCollectionLetterTrans</c> table buffer.
    /// </summary>
    /// <param name = "_custCollectionLetterTrans">The current <c>CustCollectionLetterTrans</c> record.</param>
    /// <param name = "_custCollectionLetterJour">The current <c>CustCollectionLetterJour</c> record.</param>
    /// <param name = "_custTransOpen">The current <c>CustTransOpen</c> record.</param>
    /// <param name = "_custCollectionLetterLine">The current <c>CustCollectionLetterLine</c> record.</param>
    protected void initializeCustCollectionLetterTrans(
        CustCollectionLetterTrans _custCollectionLetterTrans,
        CustCollectionLetterJour _custCollectionLetterJour,
        CustTransOpen _custTransOpen,
        CustCollectionLetterLine _custCollectionLetterLine)
    {
        _custCollectionLetterTrans.clear();

        _custCollectionLetterTrans.initFromCustCollectionLetterJour(_custCollectionLetterJour);

        _custCollectionLetterTrans.initFromCustTransOpen(_custTransOpen);
        _custCollectionLetterTrans.CollectionLetterIssued = NoYes::Yes;
        _custCollectionLetterTrans.CollectionLetterCode = _custCollectionLetterLine.CollectionLetterCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountChoice</Name>
				<Source><![CDATA[
    public void parmAccountChoice(AccountChoice _accountChoice = accountChoice)
    {
        accountChoice = _accountChoice;
        accountChoice = accountChoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeCreditNotes</Name>
				<Source><![CDATA[
    public boolean parmIncludeCreditNotes(boolean _includeCreditNotes = includeCreditNotes)
    {
        includeCreditNotes = _includeCreditNotes;
        return includeCreditNotes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custCollectionLetterLine</Name>
				<Source><![CDATA[
    protected CustCollectionLetterLine custCollectionLetterLine(CustAccount _custAccount,
                                                                CurrencyCode _currencyCode,
                                                                CustCollectionLetterCode _collectionLetterCode,
                                                                CustTrans _custTrans = null)
    {
        CollectionLetterCourseId collectionLetterCourse;

        CustBillingClassification custBillingClassification;

        // Pulling the Collection letter code based on Billing classification
        if (isBillingClassificationEnabled)
        {
            custBillingClassification = CustBillingClassification::find(_custTrans.CustBillingClassification);

            if (custBillingClassification.UseBillingClassCollectionLetter != true && custBillingClassification.RecId != 0)
            {
                collectionLetterCourse = custBillingClassification.CollectionLetterCourse;
            }
            else
            {
                collectionLetterCourse = CustLedgerAccounts::collectionLetterCourse(_custAccount, this.parmCustPostingProfile());
            }
        }
        else
        {
            collectionLetterCourse = CustLedgerAccounts::collectionLetterCourse(_custAccount, this.parmCustPostingProfile());
        }

        select firstonly custCollectionLetterLine
            where custCollectionLetterLine.CollectionLetterCourse == collectionLetterCourse
                && custCollectionLetterLine.CurrencyCode == _currencyCode
                && custCollectionLetterLine.CollectionLetterCode == _collectionLetterCode;

        return custCollectionLetterLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustPostingProfile</Name>
				<Source><![CDATA[
    public CustPostingProfile parmCustPostingProfile(CustPostingProfile _custPostingProfile = custPostingProfile)
    {
        custPostingProfile = _custPostingProfile;
        return custPostingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTransOk</Name>
				<Source><![CDATA[
    protected boolean custTransOk(CustTrans _custTrans)
    {
        if (! _custTrans)
        {
            return false;
        }

        if (_custTrans.CollectionLetter == NoYes::No)
        {
            return false;
        }

        if (_custTrans.isInvoice() && !this.parmIncludeInvoices())
        {
            return false;
        }
        if (_custTrans.isCreditNote() && ! this.parmIncludeCreditNotes())
        {
            return false;
        }

        if (_custTrans.isPayment() && ! this.parmIncludePayments())
        {
            return false;
        }

        if (_custTrans.isInterest() && ! this.parmIncludeInterestNotes())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultPostingProfile</Name>
				<Source><![CDATA[
    private CustPostingProfile getDefaultPostingProfile()
    {
        CustPostingProfile defaultPostingProfile = custPostingProfile;

        if (!custPostingProfile)
        {
            defaultPostingProfile = custParameters.PostingProfile;
        }

        return defaultPostingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the AOT.
    /// </remarks>
    public Object dialog()
    {
        FormBuildGroupControl currGroup;
        FormBuildStringControl dialogBillingClassificationNames;

        //restrict based on records passed in from calling lists.
        this.setRanges();

        DialogRunbase dialogRunbase = super();

        if (isBillingClassificationEnabled)
        {
            dialogRunbase.addGroup().frameType(FormFrameType::None);
            currGroup = dialogRunbase.form().design().control(dialogRunbase.curFormBuildGroup().name());
            dialogBillingClassificationNames = currGroup.addControl(FormControlType::String, 'CustBillingClassificationLookup');
            dialogBillingClassificationNames.helpText("@SPS680");
            dialogBillingClassificationNamesId = dialogBillingClassificationNames.id();

            inclTransWithNoBillingClassifications = NoYes::Yes;
            dialogInclTransWithNoBillingClassifications = dialogRunbase.addFieldValue(enumStr(NoYes), inclTransWithNoBillingClassifications, "@SPS691", "@SPS1009");
        }

        includeInvoices = NoYes::Yes;
        dialogInvoice = dialogRunbase.addFieldValue(enumStr(NoYes), includeInvoices, "@SYS12128", "@SYS67826");
        dialogCreditNote = dialogRunbase.addFieldValue(enumStr(NoYes), includeCreditNotes, "@SYS8125", "@SYS67827");
        dialogPayment = dialogRunbase.addFieldValue(enumStr(NoYes), includePayments, "@SYS828", "@SYS67828");
        dialogInterest = dialogRunbase.addFieldValue(enumStr(NoYes), includeInterestNotes, "@SYS10770", "@SYS67829");
        dialogCustCollectionLetterCode = dialogRunbase.addFieldValue(enumStr(CustCollectionLetterCode), collectionLetterCode, "@SYS13960");
        dialogCollectionLetterDate = dialogRunbase.addFieldValue(extendedTypeStr(TransDate), collectionLetterDate , "@SYS6847", "@AccountsReceivable:CustCollectionsLetterGenerationDate");
        dialogAccountChoice = dialogRunbase.addFieldValue(enumStr(AccountChoice), accountChoice, "@SYS26617", "@SYS24177");
        dialogPostingProfile = dialogRunbase.addFieldValue(extendedTypeStr(CustPostingProfile), this.getDefaultPostingProfile(), "@SYS21530", "@SYS17924");

        if (custParameters.isCustomerLevelCollectionLetterEnabled())
        {
            dialogCustCollectionLetterCode.allowEdit(false);
        }

        return dialogRunbase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the <c>CustCollectionLetterCreate.dialog</c> method is called to add controls after
    /// the <c>CustCollectionLetterCreate.dialog</c> method call.
    /// </summary>
    /// <param name="dialog">
    /// An instance of the <c>Dialog</c> class.
    /// </param>
    /// <remarks>
    /// This method adds a Multi-Select lookup for Billing classification.
    /// </remarks>
    public void dialogPostRun(DialogRunbase dialog)
    {
        FormStringControl dialogBillingClassificationNames;

        super(dialog);

        if (isBillingClassificationEnabled)
        {
            dialogBillingClassificationNames = dialog.formRun().design().control(dialogBillingClassificationNamesId);
            dialogBillingClassificationNames.label("@SPS371");

            custBillingClassificationLookup = SysLookupMultiSelectCtrl::construct(dialog.formRun(), dialogBillingClassificationNames, queryStr
                (CustBillingClassificationLookup));

            custBillingClassificationLookup.set(CustBillingClassification::custBillingClassificationForMultiSelectControl(billingClassificationIds));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountNumberFiltersFromSourceForm</Name>
				<Source><![CDATA[
    private static Set getAccountNumberFiltersFromSourceForm(FormDataSource _formDataSource)
    {
        CustVendAC accountNum;
        Set customerAccountFilters;

        customerAccountFilters = new Set(Types::String);

        if (_formDataSource)
        {
            //Loop through all records selected on the calling forms datasource.
            for (Common record = getFirstSelection(_formDataSource);
            record;
            record = _formDataSource.getNext())
            {
                accountNum = "";
                switch (_formDataSource.table())
                {
                    case tableNum(CustTransOpen):
                        CustTransOpen custTransOpenLocal = record;
                        accountNum = custTransOpenLocal.AccountNum;
                        break;
                    case tableNum(CustTable):
                        CustTable custTableLocal = record;
                        accountNum = custTableLocal.AccountNum;
                        break;
                    default:
                        throw error(error::wrongUseOfFunction(funcName()));
                }

                if (!customerAccountFilters.in(accountNum))
                {
                    customerAccountFilters.add(accountNum);
                }
            }
        }

        return customerAccountFilters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        useCurrentDate = dialogCollectionLetterDate.value() ? false : true;
        collectionLetterDate = useCurrentDate ? DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) : dialogCollectionLetterDate.value();
        collectionLetterCode = dialogCustCollectionLetterCode.value();
        accountChoice = dialogAccountChoice.value();
        custPostingProfile = dialogPostingProfile.value();
        includeInvoices = dialogInvoice.value();
        includeCreditNotes = dialogCreditNote.value();
        includePayments = dialogPayment.value();
        includeInterestNotes = dialogInterest.value();

        if (isBillingClassificationEnabled)
        {
            inclTransWithNoBillingClassifications = dialogInclTransWithNoBillingClassifications.value();
            billingClassificationIds = con2Str(custBillingClassificationLookup.get());
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last choice stored in the last value table.
    /// </summary>
    /// <remarks>
    ///    If no record can be found or the <c>unpack</c> method returns false, the <c>initParmDefault</c>
    ///    method will be called. This method should not typically be overridden.
    /// </remarks>
    public void getLast()
    {
        container previousAccountsRestriction;

        if (conLen(custAccountsRestriction))
        {
            // We want any restrictions passed in from the list pages to override
            // any restrictions coming from what was stored.
            previousAccountsRestriction = custAccountsRestriction;
        }

        super();

        if (conLen(previousAccountsRestriction))
        {
            // overwrite restrictions with what was passed in from the list pages.
            // Do not use any ranges which were previously saved. The ranges must match
            // what was passed in from the list page
            queryRun.query().clearQueryFilters();
            queryRun.query().dataSourceTable(tableNum(CustTable)).clearRanges();
            custAccountsRestriction = previousAccountsRestriction;
        }
        else
        {
            // In this scenario, we don't want to allow a previously packed
            // restriction to be used. This is because custAccountsRestriction
            // holds passed in restrictions. If previousAccountsRestriction is
            // empty, then none were passed in so we don't want to unpack any either.
            // custAccountsRestriction needs to be packed and unpacked for when the code
            // moves from the server to the client we don't want to loose these in that scenario.
            custAccountsRestriction = conNull();
        }

        this.initCollectionLetterCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeBasedOnDisputeStatus</Name>
				<Source><![CDATA[
    protected boolean includeBasedOnDisputeStatus(RecId _custTransOpenRecId, boolean _excludeDisputedTransactions)
    {
        CustVendDisputeHelper disputeHelper = CustVendDisputeHelper::construct(curext(), tableNum(CustTransOpen), _custTransOpenRecId);

        return !(_excludeDisputedTransactions && disputeHelper.parmStatus() == CustVendDisputeStatus::Disputed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCollectionLetterCode</Name>
				<Source><![CDATA[
    private void initCollectionLetterCode()
    {
        if (custParameters.isCustomerLevelCollectionLetterEnabled())
        {
            // If collection letters are being generated at the customer level, then force the code to be per customer
            collectionLetterCode = CustCollectionLetterCode::CollectionPerCust;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        this.queryBuild();

        this.initCollectionLetterCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeInterestNotes</Name>
				<Source><![CDATA[
    public boolean parmIncludeInterestNotes(boolean _includeInterestNotes = includeInterestNotes)
    {
        includeInterestNotes = _includeInterestNotes;
        return includeInterestNotes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeInvoices</Name>
				<Source><![CDATA[
    public boolean parmIncludeInvoices(boolean _includeInvoices = includeInvoices)
    {
        includeInvoices = _includeInvoices;
        return includeInvoices;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJobSessionId</Name>
				<Source><![CDATA[
    internal guid parmJobSessionId(guid _jobSessionId = jobSessionId)
    {
        jobSessionId = _jobSessionId;
        return jobSessionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCollectionLetterCreated</Name>
				<Source><![CDATA[
    internal boolean parmCollectionLetterCreated(boolean _collectionLetterCreated = collectionLetterCreated)
    {
        collectionLetterCreated = _collectionLetterCreated;
        return collectionLetterCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextCustCollectionLetterLine</Name>
				<Source><![CDATA[
    protected CustCollectionLetterLine nextCustCollectionLetterLine(
        CustAccount _custAccount, CurrencyCode _currencyCode, CustCollectionLetterCode _collectionLetterCode, CustTrans _custTrans = null)
    {
        CollectionLetterCourseId collectionLetterCourseId = CustLedgerAccounts::collectionLetterCourse(_custAccount, this.parmCustPostingProfile());
        CustCollectionLetterCode maxCustCollectionLetterCode = this.getMaxCustCollectionLetterCode(collectionLetterCourseId);

        CustBillingClassification custBillingClassification;
        CustCollectionLetterJour custCollectionLetterJour;
        CustCollectionLetterTrans custCollectionLetterTrans;

        if (isBillingClassificationEnabled)
        {
            custBillingClassification = CustBillingClassification::find(_custTrans.CustBillingClassification);

            if (custBillingClassification.UseBillingClassCollectionLetter != true && custBillingClassification.RecId != 0)
            {
                collectionLetterCourseId = custBillingClassification.CollectionLetterCourse;
            }
        }

        if (enableReferToCollectionAgency && graceDaysAfterTransDate)
        {
            select firstOnly RecId from custCollectionLetterTrans
                where custCollectionLetterTrans.CustTransId == _custTrans.RecId
                exists join custCollectionLetterJour
                    where custCollectionLetterJour.AccountNum == custCollectionLetterTrans.AccountNum
                        && custCollectionLetterJour.CollectionLetterNum == custCollectionLetterTrans.CollectionLetterNum
                        && custCollectionLetterJour.ReferToCollectionAgency_W == NoYes::Yes
                        && ((custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Posting
                            && custCollectionLetterJour.Status == PrintPostCancel::Posted)
                            || (custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Printed
                            && custCollectionLetterJour.JournalPrinted));

            if (custCollectionLetterTrans.RecId)
            {
                // it means that this transaction has already been included in the posted journal of referring to the collection agency
                // so no need to include this transaction to any new journal
                custCollectionLetterLine.clear();
                return custCollectionLetterLine;
            }

            select firstonly custCollectionLetterLine
            where custCollectionLetterLine.CollectionLetterCourse == collectionLetterCourseId
                && custCollectionLetterLine.CurrencyCode == _currencyCode
                && custCollectionLetterLine.ReferToCollectionAgency_W == NoYes::Yes
                && _custTrans.TransDate <= (this.parmCollectionLetterDate() - graceDaysAfterTransDate);

            if (custCollectionLetterLine.RecId)
            {
                custCollectionLetterLine.NumOfDays = 0;
                return custCollectionLetterLine;
            }
        }

        custCollectionLetterLine = this.getCustCollectionLetterLineWithGreaterCollectionLetterCode(
            collectionLetterCourseId, _currencyCode, _collectionLetterCode, maxCustCollectionLetterCode, custCollectionLetterJour);

        if (this.parmCollectionLetterCode() == CustCollectionLetterCode::CollectionPerCust
            && _collectionLetterCode == maxCustCollectionLetterCode
            && custCollectionLetterLine)
        {
            numMaxCollectionPerCust++;
        }

        return custCollectionLetterLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxCustCollectionLetterCodeWithStaticMap</Name>
				<Source><![CDATA[
    private CustCollectionLetterCode getMaxCustCollectionLetterCodeWithStaticMap(CollectionLetterCourseId _collectionLetterCourseId)
    {
        CustCollectionLetterLine custCollectionLetterLineLocal;

        select firstonly custCollectionLetterLineLocal
            where custCollectionLetterLineLocal.CollectionLetterCourse == _collectionLetterCourseId
            join custCollectionLetterCodeTmpStatic
                order by custCollectionLetterCodeTmpStatic.CustCollectionLetterCodeValue desc
                where custCollectionLetterLineLocal.CollectionLetterCode == custCollectionLetterCodeTmpStatic.CustCollectionLetterCode;

        return custCollectionLetterLineLocal.CollectionLetterCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxCustCollectionLetterCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum <c>CustCollectionLetterCode</c> enumeration value based on the current <c>CollectionLetterCourseId</c> value provided.
    /// </summary>
    /// <param name = "_collectionLetterCourseId">The current collection letter course id.</param>
    /// <returns>The maximum <c>CustCollectionLetterCode</c> enumeration value.</returns>
    protected CustCollectionLetterCode getMaxCustCollectionLetterCode(CollectionLetterCourseId _collectionLetterCourseId)
    {
        return this.getMaxCustCollectionLetterCodeWithStaticMap(_collectionLetterCourseId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustCollectionLetterLineWithGreaterCollectionLetterCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the next <c>CollectionLetterLine</c> record that contains a higher <c>CustCollectionLetterCode</c> enumeration value based on the
    /// given criteria.
    /// </summary>
    /// <param name = "_collectionLetterCourseId">The collection letter course id.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_collectionLetterCode">The collection letter code.</param>
    /// <param name = "_maxCustCollectionLetterCode">The maximum <c>CustCollectionLetterCode</c> enumeration value.</param>
    /// <param name = "_custCollectionLetterJour">The current <c>CustCollectionLetterJour</c> record.</param>
    /// <returns>The next <c>CollectionLetterLine</c> record that contains a higher <c>CustCollectionLetterCode</c> enumeration value.</returns>
    protected CustCollectionLetterLine getCustCollectionLetterLineWithGreaterCollectionLetterCode(
        CollectionLetterCourseId _collectionLetterCourseId,
        CurrencyCode _currencyCode,
        CustCollectionLetterCode _collectionLetterCode,
        CustCollectionLetterCode _maxCustCollectionLetterCode,
        CustCollectionLetterJour _custCollectionLetterJour)
    {
        CustCollectionLetterLine custCollectionLetterLineLocal;

        while select custCollectionLetterLineLocal
            where custCollectionLetterLineLocal.CollectionLetterCourse == _collectionLetterCourseId
                && custCollectionLetterLineLocal.CurrencyCode == _currencyCode
                && _custCollectionLetterJour.ReferToCollectionAgency_W == NoYes::No
        {
            if (!custCollectionLetterLineLocal
                || (custCollectionLetterCodeOrderedList.indexOf(custCollectionLetterLineLocal.CollectionLetterCode) > custCollectionLetterCodeOrderedList.indexOf(_collectionLetterCode)
                    || (collectionLetterCode == CustCollectionLetterCode::CollectionPerCust
                    && _collectionLetterCode == _maxCustCollectionLetterCode
                    && custCollectionLetterLineLocal.CollectionLetterCode == _collectionLetterCode)))
            {
                break;
            }
        }

        return custCollectionLetterLineLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludePayments</Name>
				<Source><![CDATA[
    public boolean parmIncludePayments(boolean _includePayments = includePayments)
    {
        includePayments = _includePayments;
        return includePayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressTotal</Name>
				<Source><![CDATA[
    protected int progressTotal(QueryRun _queryRun)
    {
        Query queryProgress = new Query();

        SysQuery::mergeRanges(queryProgress, _queryRun.query(), 1);

        return QueryRun::getQueryRowCount(queryProgress, intMax());
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    protected void progressUpdate(str _text)
    {
        progressCounter++;
        progress.setCount(progressCounter);
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    protected void queryBuild()
    {
        queryRun = new QueryRun(queryStr(CustCollectionLetterCreate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildUpdate</Name>
				<Source><![CDATA[
    protected void queryBuildUpdate()
    {
        QueryBuildRange queryBuildRange;
        CustCollectionAgencyGracePeriodSetup_W gracePeriodSetup;

        #define.BillingCalssificationselected(',0')
        #define.NoBillingclassificationselected('0')

        if (enableReferToCollectionAgency)
        {
            select maxOf(GraceDaysAfterTransDate) from gracePeriodSetup;

            queryBuildRange = queryRun.query().dataSourceTable(tableNum(CustTransOpen)).addRange(fieldNum(CustTransOpen, DataAreaId));
            queryBuildRange.value(strFmt('((%1.%2 <= %3) || (%1.%4 <= %5))',
            queryRun.query().dataSourceTable(tableNum(CustTransOpen)).name(),
            fieldStr(CustTransOpen, DueDate),
            date2StrXpp(this.getActualCollectionLetterDate()),
            fieldStr(CustTransOpen, TransDate),
            date2StrXpp(this.getActualCollectionLetterDate() - gracePeriodSetup.GraceDaysAfterTransDate)));
        }
        else
        {
            queryRun.query().dataSourceTable(tableNum(CustTransOpen)).findRange(fieldNum(CustTransOpen, DueDate)).value(strFmt('..%1', this.getActualCollectionLetterDate()));
        }

        if (isBillingClassificationEnabled)
        {
            if (inclTransWithNoBillingClassifications == NoYes::Yes)
            {
                if (billingClassificationIds != '')
                {
                    billingClassificationIds = billingClassificationIds + #BillingCalssificationselected;
                }
                else
                {
                    billingClassificationIds = billingClassificationIds + #NoBillingclassificationselected;
                }
            }

            SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(CustTrans)), fieldNum(CustTrans, CustBillingClassification));
            queryRun.query().dataSourceTable(tableNum(CustTrans)).findRange(fieldNum(CustTrans, CustBillingClassification)).value(billingClassificationIds);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfDaysOverDue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the number of overdue days since the collection letter.
    /// </summary>
    /// <returns>
    ///     The number of overdue days since the collection letter.
    /// </returns>
    protected PositiveDays getNumberOfDaysOverDue()
    {
        return custCollectionLetterLine.NumOfDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCollectionLetterCreationForRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Skips creation of record for <c>CustCollectionLetterJour</c> table.
    /// </summary>
    /// <param name = "_queryRun">
    ///     A instance of <c>QueryRun</c> class.
    /// </param>
    /// <returns>
    ///     Always returns false.
    /// </returns>
    protected boolean skipCollectionLetterCreationForRecord(QueryRun _queryRun)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code to cordinate the collection letters creation
    /// </summary>
    public void run()
    {
        #OCCRetryCount
        #macrolib.AviFiles

        try
        {
            Counter progressTotal = this.progressTotal(queryRun);
            this.getRunBase().progressInit("@SYS18620", progressTotal, #AviFindFile);
            progress = this.getRunBase().parmProgress();

            if (CustCollectionLetterCreateOptimizationFlight::instance().isEnabled())
            {
                if (FeatureStateProvider::isFeatureEnabled(CustCollectionLetterCreateMultithreadedBatchFeature::instance()) && this.isInBatch())
                {
                    if (this.parmIsMainBatchTask())
                    {
                        this.PreProcessTask();

                        this.jobSessionId = newGuid();

                        this.createBatchTasks();
                    }
                    else
                    {
                        // This check ensures that CustCollectionLetterCodeTmp temporary table gets populated for all the tasks
                        // including Child and Final Tasks.
                        // (CustCollectionLetterCodeTmp table is already being populated for Main task in preProcessTask() method call)
                        if (CustCollLetterCreateMTBatchCCLCodeTmpTableFlight::instance().isEnabled())
                        {
                            custCollectionLetterCodeOrderedList.buildSortedTempTableMap(custCollectionLetterCodeTmpStatic);
                        }

                        this.processTaskOptimized(!this.parmIsFinalBatchTask());

                        if (this.parmIsFinalBatchTask())
                        {
                            this.postRun();
                        }
                    }
                }
                else
                {
                    // Run CustCollectionLetterCreate Synchronously
                    this.PreProcessTask();

                    this.doProcessWorkItem();

                    this.postRun();
                }
            }
            else
            {
                if (this.parmIsMainBatchTask())
                {
                    this.PreProcessTask();
                }

                if (this.isInBatch() && this.parmIsMainBatchTask() &&
                FeatureStateProvider::isFeatureEnabled(CustCollectionLetterCreateMultithreadedBatchFeature::instance()))
                {
                    this.jobSessionId = newGuid();

                    this.createBatchTasks();
                }

                // This check ensures that CustCollectionLetterCodeTmp temporary table gets populated for all the tasks
                // including Child and Final Tasks.
                // (CustCollectionLetterCodeTmp table is already being populated for Main task in preProcessTask() method call)
                if (CustCollLetterCreateMTBatchCCLCodeTmpTableFlight::instance().isEnabled()
                && this.isInBatch()
                && !this.parmIsMainBatchTask())
                {
                    custCollectionLetterCodeOrderedList.buildSortedTempTableMap(custCollectionLetterCodeTmpStatic);
                }
           
                if (this.isInBatch() && this.parmIsFinalBatchTask())
                {
                    //Does a final processing without readPast enbaled to handle uprocessed records
                    this.processTask(false);
                }
                else
                {
                    this.processTask();
                }

                if (!this.isInBatch() || this.parmIsFinalBatchTask())
                {
                    this.postRun();
                }
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                sleep(100 * power(BaseExponentialWait, xSession::currentRetryCount()));
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            ttsabort;
            error("@SYS18447");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>PreProcessTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes initial logic before task processing. This is one processed on the main task
    /// </summary>
    public void PreProcessTask()
    {
        if (!hasRestrictionBeenAppliedToQuery)
        {
            this.setRanges();
        }
        
        custCollectionLetterCodeOrderedList.buildSortedTempTableMap(custCollectionLetterCodeTmpStatic);

        this.queryBuildUpdate();

        //
        //  This method is required to for cancelling collection letters
        //  for customers that were not handled during the create collection
        //  letter process. This will make sure that collection letters that
        //  no longer valid are cancelled.
        //
        this.updateCreatedCollectionLetter();

        enableReferToCollectionAgency = custParameters.EnableReferToCollectionAgency_W == NoYes::Yes;

        if (isBillingClassificationEnabled)
        {
            QueryBuildDataSource qbdsCustTrans = queryRun.query().dataSourceTable(tableNum(CustTrans));
            qbdsCustTrans.addSortField(fieldNum(CustTrans, CustBillingClassification));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTask</Name>
				<Source><![CDATA[
    private void processTask(boolean _readPast = true)
    {
        if (!this.isInBatch() || !FeatureStateProvider::isFeatureEnabled(CustCollectionLetterCreateMultithreadedBatchFeature::instance()))
        {
            this.doProcessWorkItem();
            return;
        }

        this.doProcessTasks(_readPast);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaskOptimized</Name>
				<Source><![CDATA[
    private void processTaskOptimized(boolean _readPast = true)
    {
        UserConnection  stagingConnection;

        try
        {
            stagingConnection = new UserConnection();

            this.doProcessTasksOptimized(stagingConnection, _readPast);
        }
        finally
        {
            stagingConnection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doProcessTasks</Name>
				<Source><![CDATA[
    private void doProcessTasks(boolean _readPast)
    {
        UserConnection stagingConnection;
        
        try
        {
            stagingConnection = new UserConnection();
            CustCollectionLetterCreateStaging staging;

            staging.setConnection(stagingConnection);
            staging.readPast(_readPast);

            do
            {
                stagingConnection.ttsbegin();
                
                select firstonly pessimisticlock AccountNum from staging
                    where staging.jobSessionId == this.jobSessionId;
                
                if (staging)
                {
                    if (CustCollLetterMTBatchUpdCustTransAccNumRangeFlight::instance().isEnabled())
                    {
                        this.setRange(tableNum(CustTrans), fieldNum(CustTrans, AccountNum), staging.AccountNum);
                    }
                    else
                    {
                        this.setRange(tableNum(CustTable), fieldNum(CustTable, AccountNum), staging.AccountNum);
                    }
                    this.doProcessWorkItem();
                
                    if (CustCollLetterMTBatchUpdCustTransAccNumRangeFlight::instance().isEnabled())
                    {
                        this.removeRange(tableNum(CustTrans), fieldNum(CustTrans, AccountNum));
                    }
                    else
                    {
                        this.removeRange(tableNum(CustTable), fieldNum(CustTable, AccountNum));
                    }
                    staging.delete();
                }

                stagingConnection.ttscommit();
            }
            while (staging);
        }
        finally
        {
            stagingConnection.finalize();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>doProcessTasksOptimized</Name>
				<Source><![CDATA[
    private void doProcessTasksOptimized(UserConnection _stagingConnection, boolean _readPast)
    {
        CustCollectionLetterCreateStaging staging;

        staging.setConnection(_stagingConnection);
        staging.readPast(_readPast);

        do
        {
            _stagingConnection.ttsbegin();
                
            select firstonly pessimisticlock AccountNum from staging
                where staging.jobSessionId == this.jobSessionId;
                
            if (staging)
            {
                if (CustCollLetterMTBatchUpdCustTransAccNumRangeFlight::instance().isEnabled())
                {
                    this.setRange(tableNum(CustTrans), fieldNum(CustTrans, AccountNum), staging.AccountNum);
                }
                else
                {
                    this.setRange(tableNum(CustTable), fieldNum(CustTable, AccountNum), staging.AccountNum);
                }
                this.doProcessWorkItem();
                
                if (CustCollLetterMTBatchUpdCustTransAccNumRangeFlight::instance().isEnabled())
                {
                    this.removeRange(tableNum(CustTrans), fieldNum(CustTrans, AccountNum));
                }
                else
                {
                    this.removeRange(tableNum(CustTable), fieldNum(CustTable, AccountNum));
                }
                staging.delete();
            }

            _stagingConnection.ttscommit();
        }
        while (staging);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doProcessWorkItem</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains logic to perform actual collection letters generation work on customer accounts
    /// </summary>
    private void doProcessWorkItem()
    {
        CustTable custTable;
        CustTable custTable_Orig;
        
        str prefix;
        CustTrans custTrans;
        CustTrans custTrans_Orig;
        RefRecId currentCustBillingClassification = 0;

        boolean firstJournal = true;
        boolean skipCustomer;

        boolean excludeDisputedTransactions = custParameters.CollectionsExcludeDisputedTransactions == NoYes::Yes;

        while (queryRun.next())
        {
            if (this.skipCollectionLetterCreationForRecord(queryRun))
            {
                continue;
            }

            // Need to handle case where CustTrans record changes separately since shouldCreateJournal is only dependent upon
            // whether the CustBillingClassification has changed and muliple customers could have the same billing classification.
            if (isBillingClassificationEnabled && queryRun.changed(tableNum(CustTrans)))
            {
                custTrans = queryRun.get(tableNum(CustTrans));
            }

            if (this.shouldCreateJournal(queryRun, currentCustBillingClassification))
            {
                custTable = queryRun.get(tableNum(CustTable));

                if (isBillingClassificationEnabled)
                {
                    currentCustBillingClassification = custTrans.CustBillingClassification;
                }

                this.progressUpdate(strFmt("@SYS70279",custTable.AccountNum));

                if (!firstJournal)
                {
                    ttsbegin;

                    this.validateAndCreateJournal(custTable_Orig, custTrans_Orig, prefix);

                    ttscommit;
                }

                skipCustomer = this.skipCustomer(custTable);

                custTable_Orig = custTable.data();
                if (isBillingClassificationEnabled)
                {
                    custTrans_Orig = custTrans.data();
                }

                firstJournal = false;
                prefix = #PreFixField(Custtable,AccountNum);

                this.resetCustCollectionLetterVarsForNewJournal();
            }
          
            if (!skipCustomer && queryRun.changed(tableNum(CustTransOpen)))
            {
                if (queryRun.changed(tableNum(CustTransOpen)))
                {
                    CustTransOpen custTransOpen = queryRun.get(tableNum(CustTransOpen));

                    if (enableReferToCollectionAgency)
                    {
                        graceDaysAfterTransDate = CustCollectionAgencyGracePeriodSetup_W::findGraceDaysAfterTransDate(custTransOpen.AccountNum, custTransOpen.TransDate);
                    }

                    if (this.includeBasedOnDisputeStatus(custTransOpen.RecId, excludeDisputedTransactions)
                        && this.checkCustTransOpen(custTransOpen.RecId, custTable))
                    {
                        if (custTransOpen.DueDate + this.getNumberOfDaysOverDue() <= this.parmCollectionLetterDate())
                        {
                            qty++;

                            CustCollectionTransOpenRefRecIdTmp transOpenRef;
                            transOpenRef.CustTransOpenRefRecId = custTransOpen.RecId;
                            transOpenRef.CustCollectionLetterCode = custCollectionLetterLine.CollectionLetterCode;
                            transOpenRef.ReferToCollectionAgency = custCollectionLetterLine.ReferToCollectionAgency_W;
                            custTransOpenRefRecIdList.add(transOpenRef);
                            custTransOpenList.ins(custTransOpen);
                            this.setTotalAmount(custTransOpen.AmountMST, custCollectionLetterLine);
                            collectionLetter[qty] = custTransOpen.RecId;
                            custCollectionLetterCode[qty] = custCollectionLetterLine.CollectionLetterCode;
                            referToCollectionAgency[qty] = custCollectionLetterLine.ReferToCollectionAgency_W;
                        }
                    }
                }
            }
        }

        ttsbegin;

        this.validateAndCreateJournal(custTable_Orig, custTrans_Orig, prefix);

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfBatchTasks</Name>
				<Source><![CDATA[
    internal BatchSessions getNumberOfBatchTasks()
    {
        CustCollectionLetterBatchTaskParameters parameters = CustCollectionLetterBatchTaskParameters::find();
        BatchSessions tasksCount = parameters.getDefaultNumberOfBatchTasks();

        return tasksCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchTasks</Name>
				<Source><![CDATA[
    private void createBatchTasks()
    {
        this.initializeBatchStaging(queryRun.query());

        int counter;
        int totalNumberOfTasksNeeded = this.getNumberOfBatchTasks();

        BatchHeader batchHeader = BatchHeader::getCurrentBatchHeader();

        CustCollectionLetterCreate finalTask = this.createFinalBatchTask(batchHeader);

        if (CustCollectionLetterCreateOptimizationFlight::instance().isEnabled())
        {
            // When flight is enabled, main task will be just creating batch tasks and won't perform main processing, so one more child task is required to compensate for main task which was doing main processing without flight.
            for (counter = 1; counter <= totalNumberOfTasksNeeded; counter++)
            {
                this.createBatchTask(batchHeader, finalTask, counter);
            }
        }
        else
        {
            for (counter = 1; counter < totalNumberOfTasksNeeded; counter++)
            {
                this.createBatchTask(batchHeader, finalTask, counter);
            }
        }
        
        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFinalBatchTask</Name>
				<Source><![CDATA[
    private CustCollectionLetterCreate createFinalBatchTask(BatchHeader _batchHeader)
    {
        CustCollectionLetterCreate finalBatchTask = CustCollectionLetterCreate::construct();

        finalBatchTask.unpack(this.pack());
        finalBatchTask.parmIsMainBatchTask(false);
        finalBatchTask.parmIsFinalBatchTask(true);

        finalBatchTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
        finalBatchTask.batchInfo().parmCaption(strFmt("%1 - Final Task", CustCollectionLetterCreate::description()));

        _batchHeader.addRuntimeTask(finalBatchTask, this.parmCurrentBatch().RecId);

        return finalBatchTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatchTask</Name>
				<Source><![CDATA[
    private void createBatchTask(BatchHeader _batchHeader, CustCollectionLetterCreate _finalBatchTask, int _index)
    {
        CustCollectionLetterCreate batchTask = CustCollectionLetterCreate::construct();

        batchTask.unpack(this.pack());
        batchTask.parmIsMainBatchTask(false);

        batchTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
        batchTask.batchInfo().parmCaption(strFmt("%1 - Child Task %2", CustCollectionLetterCreate::description(), _index));

        _batchHeader.addRuntimeTask(batchTask, this.parmCurrentBatch().RecId);
        _batchHeader.addDependency(_finalBatchTask, batchTask, BatchDependencyStatus::FinishedOrError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsMainBatchTask</Name>
				<Source><![CDATA[
    public boolean parmIsMainBatchTask(boolean _isMainBatchTask = isMainBatchTask)
    {
        isMainBatchTask = _isMainBatchTask;
        return isMainBatchTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFinalBatchTask</Name>
				<Source><![CDATA[
    private boolean parmIsFinalBatchTask(boolean _isFinalBatchTask = isFinalBatchTask)
    {
        isFinalBatchTask = _isFinalBatchTask;
        return isFinalBatchTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBatchStaging</Name>
				<Source><![CDATA[
    protected void initializeBatchStaging(Query _query)
    {
        ttsbegin;
        CustCollectionLetterBatchJobSessionTmp jobSessionTmp;
        jobSessionTmp.SessionId = this.jobSessionId;
        jobSessionTmp.insert();
        ttscommit;

        Query query = new Query(_query);
        query.clearAllFields();
        query.clearOrderBy();
        query.clearGroupBy();

        QueryBuildDataSource custTableQbds = query.dataSourceTable(tableNum(CustTable));
        custTableQbds.fields().dynamic(NoYes::No);
        custTableQbds.fields().clearFieldList();

        QueryBuildDataSource custTransOpenQbds = query.dataSourceTable(tableNum(CustTransOpen));
        custTransOpenQbds.fields().dynamic(NoYes::No);
        custTransOpenQbds.fields().clearFieldList();

        QueryBuildDataSource custTransQbds = query.dataSourceTable(tableNum(CustTrans));
        custTransQbds.fields().dynamic(NoYes::No);
        custTransQbds.fields().clearFieldList();
        custTransQbds.addGroupByAndSelectionField(fieldNum(CustTrans, AccountNum));


        QueryBuildDataSource qbdsTmp = custTransQbds.addDataSource(tableNum(CustCollectionLetterBatchJobSessionTmp));
        qbdsTmp.addLink(fieldNum(CustTrans, DataAreaId), fieldNum(CustCollectionLetterBatchJobSessionTmp, DataAreaId));
        qbdsTmp.cursor(jobSessionTmp);
        qbdsTmp.joinMode(JoinMode::InnerJoin);

        if (CustCollectionLetterCreateMultithreadQueryFlight::instance().isEnabled())
        {
            qbdsTmp.fetchMode(QueryFetchMode::One2One);

            custTransQbds.fetchMode(QueryFetchMode::One2One);
        }
        else
        {
            qbdsTmp.fetchMode(QueryFetchMode::One2Many);
        }

        qbdsTmp.addRange(fieldNum(CustCollectionLetterBatchJobSessionTmp, SessionId)).value(SysQuery::value(this.jobSessionId));
        qbdsTmp.fields().dynamic(NoYes::No);
        qbdsTmp.fields().clearFieldList();

        qbdsTmp.addGroupByAndSelectionField(fieldNum(CustCollectionLetterBatchJobSessionTmp, SessionId));

        Map fieldMap = new Map(Types::String, Types::Container);
        fieldMap.insert(fieldStr(CustCollectionLetterCreateStaging, AccountNum), [custTransQbds.uniqueId(), fieldStr(CustTrans, AccountNum)]);
        fieldMap.insert(fieldStr(CustCollectionLetterCreateStaging, JobSessionId), [qbdsTmp.uniqueId(), fieldStr(CustCollectionLetterBatchJobSessionTmp, SessionId)]);

        CustCollectionLetterCreateStaging staging;

        Query::insert_recordset(staging, fieldMap, query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAndCreateJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates and then conditionally creates a customer collection letter.
    /// </summary>
    /// <param name = "_custTable">The customer record.</param>
    /// <param name = "_custTrans">The customer transaction record.</param>
    /// <param name = "prefix">The prefix string.</param>
    protected void validateAndCreateJournal(
        CustTable _custTable,
        CustTrans _custTrans,
        str prefix)
    {
        if (_custTable
            && qty != 0
            && qty != numMaxCollectionPerCust)
        {
            if (isBillingClassificationEnabled)
            {
                this.createJournal(_custTable, prefix, _custTrans);
            }
            else
            {
                this.createJournal(_custTable, prefix);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes additional logic post <c>run</c>.
    /// </summary>
    public void postRun()
    {
        if (!collectionLetterCreated)
        {
            info("@AccountsReceivable:CollectionLettersNotCreated");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipCustomer</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Skips the customer based on the collection dates difference.
    /// </summary>
    /// <param name = "_custTable">
    ///     An instance of <c>CustTable</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the customer can be skipped; otherwise, false.
    /// </returns>
    protected boolean skipCustomer(CustTable _custTable)
    {
        boolean skipCustomer;

        if (custParameters.isCustomerLevelCollectionLetterEnabled())
        {
            CustCollectionLetterCode transCollectionLetterCode = _custTable.editCollectionLetterCode(false, CustCollectionLetterCode::None);

            CustCollectionLetterLine custCollectionLetterLineLocal = this.nextCustCollectionLetterLine(_custTable.AccountNum, _custTable.Currency, transCollectionLetterCode);
            
            skipCustomer = _custTable.collectionLetterDate() + custCollectionLetterLineLocal.NumOfDays > this.parmCollectionLetterDate();
        }

        return skipCustomer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a new journal should be created based on data from the <c>QueryRun</c> object.
    /// </summary>
    /// <param name = "_queryRun">The <c>QueryRun</c> object.</param>
    /// <returns>true if the journal should be created; otherwise, false.</returns>
    protected boolean shouldCreateJournal(QueryRun _queryRun, RefRecId _previousCustBillingClassification)
    {
        return _queryRun.changed(tableNum(CustTable))
            || (isBillingClassificationEnabled && _previousCustBillingClassification != _queryRun.get(tableNum(CustTrans)).getFieldValue(fieldStr(CustTrans, CustBillingClassification)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetCustCollectionLetterVarsForNewJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the class-level variables for a new customer collection letter journal.
    /// </summary>
    protected void resetCustCollectionLetterVarsForNewJournal()
    {
        numMaxCollectionPerCust = 0;
        qty = 0;
        feeOnCollectionLetter = NoYes::No;

        this.clearArrays();

        custTransOpenList = new RecordSortedList(tableNum(CustTransOpen));
        custTransOpenList.sortOrder(fieldNum(CustTransOpen, RecId));
        
        delete_from custCollectionTransOpenRefRecIdTmp;
        custTransOpenRefRecIdList = new RecordInsertList(tableNum(CustCollectionTransOpenRefRecIdTmp), true, true, true, true, true, custCollectionTransOpenRefRecIdTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearArrays</Name>
				<Source><![CDATA[
    private void clearArrays()
    {
        collectionLetter[0] = 0;
        custCollectionLetterCode[0] = CustCollectionLetterCode::None;
        referToCollectionAgency[0] = 0;
        totalAmount[0] = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend the <c>RunBaseBatch</c> class must override the <c>runsImpersonated</c>
    ///    method and return false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the last choice by using the <see cref="M:RunBase.pack" /> method.
    /// </summary>
    /// <remarks>
    ///    This method should not ordinarily be overridden.
    /// </remarks>
    public void saveLast()
    {
        // If restrictions were passed in, then we don't want to persist them
        // as they don't necessarily represent the users favorite settings.
        // (e.g. this is done from list pages.)
        if (!conLen(custAccountsRestriction))
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeRange</Name>
				<Source><![CDATA[
    void removeRange(TableId _tableId, FieldId _fieldId)
    {
        if (this.queryRun().query().dataSourceTable(_tableId))
        {
            //clear all ranges on CustTable to remove the top pick AccountNum (parallel batch task) from the query
            queryRun.query().dataSourceTable(_tableId).clearRanges();
            
            //Resetting instance of QueryRun to accomaodate dynamically changing custTable ranges in multi-threaded batch tasks
            queryRun = new QueryRun(queryRun.query());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRange</Name>
				<Source><![CDATA[
    QueryBuildRange setRange(TableId _tableId, FieldId _fieldId, str _value, RangeStatus _rangeStatus = RangeStatus::Open)
    {
        QueryBuildRange range;

        if (this.queryRun().query().dataSourceTable(_tableId))
        {
            range = queryRun.query().dataSourceTable(_tableId).addRange(_fieldId);

            range.value(_value);
            range.status(_rangeStatus);
        }

        return range;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRanges</Name>
				<Source><![CDATA[
    void setRanges()
    {
        int loc;
        str account;

        hasRestrictionBeenAppliedToQuery = true;

        for (loc = 1; loc <= conLen(custAccountsRestriction); loc++)
        {
            // set a range for every account number in the restrictions container
            account = conPeek(custAccountsRestriction, loc);
            this.setRange(tableNum(CustTable), fieldNum(CustTable, AccountNum), account);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTotalAmount</Name>
				<Source><![CDATA[
    void setTotalAmount(AmountCur _totalAmount, CustCollectionLetterLine _custCollectionLetterLine)
    {
        switch (_custCollectionLetterLine.CollectionLetterCode)
        {
            case CustCollectionLetterCode::CollectionLetter1:
                totalAmount[1] += _totalAmount;
                break;
            case CustCollectionLetterCode::CollectionLetter2:
                totalAmount[2] += _totalAmount;
                break;
            case CustCollectionLetterCode::CollectionLetter3:
                totalAmount[3] += _totalAmount;
                break;
            case CustCollectionLetterCode::CollectionLetter4:
                totalAmount[4] += _totalAmount;
                break;
            case CustCollectionLetterCode::Collection:
                totalAmount[5] += _totalAmount;
                break;
            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showIndexFields</Name>
				<Source><![CDATA[
    public boolean showIndexFields(TableId _id)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQuerySelectButton</Name>
				<Source><![CDATA[
    boolean showQuerySelectButton()
    {
        if (conLen(custAccountsRestriction))
        {
            // List Pages: if restrictions were passed in then we don't want to allow the end user
            // to change what ranges are in place. This is done from the list page - not in this
            // dialog.
            return false;
        }

        super();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether to add a select button to the dialog.
    /// </summary>
    /// <returns>
    ///    Always returns true.
    /// </returns>
    /// <remarks>
    ///    If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    ///    return a valid <c>queryRun</c> object.If you change the return value to false the button will no
    ///    longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmount</Name>
				<Source><![CDATA[
    public AmountCur totalAmount(CustCollectionLetterLine _custCollectionLetterLine)
    {
        if (collectionLetterCode == CustCollectionLetterCode::CollectionPerCust)
        {
            return totalAmount[1] + totalAmount[2] + totalAmount[3] + totalAmount[4] + totalAmount[5];
        }
        switch (_custCollectionLetterLine.CollectionLetterCode)
        {
            case CustCollectionLetterCode::CollectionLetter1:
                return totalAmount[1];
            case CustCollectionLetterCode::CollectionLetter2:
                return totalAmount[2];
            case CustCollectionLetterCode::CollectionLetter3:
                return totalAmount[3];
            case CustCollectionLetterCode::CollectionLetter4:
                return totalAmount[4];
            case CustCollectionLetterCode::Collection:
                return totalAmount[5];
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedQuery;

        #LOCALMACRO.CurrentList_v6
        collectionLetterDate,
        collectionLetterCode,
        custPostingProfile,
        accountChoice,
        includeInvoices,
        includeCreditNotes,
        includePayments,
        includeInterestNotes
    #ENDMACRO

        #LOCALMACRO.CurrentList_v7
        collectionLetterDate,
        collectionLetterCode,
        custPostingProfile,
        accountChoice,
        includeInvoices,
        includeCreditNotes,
        includePayments,
        includeInterestNotes,
        custAccountsRestriction
    #ENDMACRO

        // version 8 and 9 were technically identical in current list. it
        // seems there was some incrementing confusion with relation to
        // overlayering, especially when it came to the GLS collapse into
        // SYS.
        #LOCALMACRO.CurrentList_v8v9
        collectionLetterDate,
        collectionLetterCode,
        custPostingProfile,
        accountChoice,
        includeInvoices,
        includeCreditNotes,
        includePayments,
        includeInterestNotes,
        custAccountsRestriction,
        billingClassificationIds,
        inclTransWithNoBillingClassifications
    #ENDMACRO

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;
            case 6:
                [version, #CurrentList_v6, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;
            case 7:
                [version, #CurrentList_v7, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;

            case 8:
            case 9:
                [version, #CurrentList_v8v9, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;
            case 10:
                [version, #CurrentList_v10, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;
            case 11:
                [version, #CurrentList_v11, packedQuery] = _packedClass;
                queryRun = new QueryRun(packedQuery);
                break;

            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateCustCollectionLetterJourForAllExisting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the existing <c>CustCollectionLetterJour</c> record should be updated during the processing of
    /// all existing collection letters.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal record.</param>
    /// <returns>true if the existing <c>CustCollectionLetterJour</c> record should be updated; otherwise, false.</returns>
    protected boolean shouldUpdateCustCollectionLetterJourForAllExisting(CustCollectionLetterJour _custCollectionLetterJour)
    {
        return (custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Posting
            || (custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Printed && ! _custCollectionLetterJour.JournalPrinted));
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateCreatedCustCollectionLetter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the existing <c>CustCollectionLetterJour</c> record should be updated.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal record.</param>
    /// <param name = "_custCollectionLetterTrans">The customer collection letter transaction.</param>
    /// <returns>true if the existing <c>CustCollectionLetterJour</c> record should be updated; otherwise, false.</returns>
    protected boolean shouldUpdateCreatedCustCollectionLetter(CustCollectionLetterJour _custCollectionLetterJour, CustCollectionLetterTrans _custCollectionLetterTrans)
    {
        return ((custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Posting && _custCollectionLetterTrans)
            || (custParameters.CollectionLetterCodeUpdate == CustPostedPrinted::Printed && ! _custCollectionLetterJour.JournalPrinted));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllExisting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates all of the existing <c>CustCollectionLetterJour</c> records.
    /// </summary>
    /// <param name = "_accountNum">The customer account number.</param>
    /// <param name = "_prefix">The prefix string.</param>
    /// <param name = "_custBillingClassification">The customer billing classification.</param>
    protected void updateAllExisting(CustAccount _accountNum, str _prefix = getPrefix(), RefRecId _custBillingClassification = 0)
    {
        CustCollectionLetterJour oldCustCollectionLetterJour;

        if (isBillingClassificationEnabled)
        {
            while select forupdate oldCustCollectionLetterJour
                where oldCustCollectionLetterJour.AccountNum == _accountNum
                    && oldCustCollectionLetterJour.CustBillingClassification == _custBillingClassification
                    && oldCustCollectionLetterJour.Status == PrintPostCancel::Created
            {
                if (this.shouldUpdateCustCollectionLetterJourForAllExisting(oldCustCollectionLetterJour))
                {
                    oldCustCollectionLetterJour.setCancelling();
                    oldCustCollectionLetterJour.update();
                }
            }
        }
        else
        {
            while select forupdate oldCustCollectionLetterJour
                where oldCustCollectionLetterJour.AccountNum == _accountNum
                    && oldCustCollectionLetterJour.Status == PrintPostCancel::Created
            {
                if (this.shouldUpdateCustCollectionLetterJourForAllExisting(oldCustCollectionLetterJour))
                {
                    oldCustCollectionLetterJour.setCancelling();
                    oldCustCollectionLetterJour.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCollectionLetterQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>Query</c> object for updating collection letters.
    /// </summary>
    /// <returns>A newly initialized <c>Query</c> object for updating collection letters.</returns>
    protected Query initializeCollectionLetterQuery()
    {
        Query q = new Query(queryRun.query());
        q.dataSourceTable(tableNum(CustTransOpen)).findRange(fieldNum(CustTransOpen, DueDate)).value(strFmt('%1..', this.getActualCollectionLetterDate()));

        QueryBuildDataSource qbds = q.dataSourceTable(tableNum(CustTransOpen));
        qbds = q.dataSourceTable(tableNum(CustTrans));
        qbds.relations(true);
        qbds.addDataSource(tableNum(CustCollectionLetterTrans));

        qbds = q.dataSourceTable(tableNum(CustCollectionLetterTrans));
        qbds.addSortIndex(indexNum(CustCollectionLetterTrans, CollectIdx));
        qbds.addLink(fieldNum(CustTrans, RecId), fieldNum(CustCollectionLetterTrans, CustTransId));
        qbds.addDataSource(tableNum(CustCollectionLetterJour));

        qbds = q.dataSourceTable(tableNum(CustCollectionLetterJour));
        qbds.relations(true);
        qbds.update(true);

        qbds.addRange(fieldNum(CustCollectionLetterJour,Status)).value(queryValue(PrintPostCancel::Created));

        return q;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreatedCollectionLetter</Name>
				<Source><![CDATA[
    //
    //  This method will make sure that collection letter created previously are properly
    //  canceled if the criteria that created them is no longer valid.
    //
    //  ex. The transaction's due date has been adjusted forward, therefore based on the
    //      collection date that was used as the reference for creating it the collection
    //      letter may no longer be valid.
    //
    //
    void updateCreatedCollectionLetter()
    {
        CustCollectionLetterJour custCollectionLetterJour;
        DataAreaId prevDataAreaId;
        RecId prevRecId;

        Query q = this.initializeCollectionLetterQuery();
        QueryRun qR = new QueryRun(q);

        ttsbegin;
        while (qR.next())
        {
            custCollectionLetterJour = qR.get(tableNum(CustCollectionLetterJour));

            if (prevDataAreaId != custCollectionLetterJour.DataAreaId || prevRecId != custCollectionLetterJour.RecId)
            {
                prevDataAreaId = custCollectionLetterJour.DataAreaId;
                prevRecId = custCollectionLetterJour.RecId;

                CustCollectionLetterTrans custCollectionLetterTrans;

                select firstonly custCollectionLetterTrans
                    where custCollectionLetterTrans.AccountNum == custCollectionLetterJour.AccountNum
                        && custCollectionLetterTrans.CollectionLetterNum == custCollectionLetterJour.CollectionLetterNum
                        && custCollectionLetterTrans.CollectionLetterCode == collectionLetterCode;

                if (this.shouldUpdateCreatedCustCollectionLetter(custCollectionLetterJour, custCollectionLetterTrans))
                {
                    custCollectionLetterJour.setCancelling();
                    custCollectionLetterJour.update();
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateExistingCustCollectionLetterJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the existing <c>CustCollectionLetterJour</c> record should be updated.
    /// </summary>
    /// <param name = "_custCollectionLetterJour">The customer collection letter journal record.</param>
    /// <returns>true if the existing <c>CustCollectionLetterJour</c> record should be updated; otherwise, false.</returns>
    protected boolean shouldUpdateExistingCustCollectionLetterJour(CustCollectionLetterJour _custCollectionLetterJour)
    {
        return _custCollectionLetterJour.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExisting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates existing <c>CustCollectionLetterJour</c>.
    /// </summary>
    /// <param name = "_accountNum">The customer account number.</param>
    /// <param name = "_collectionLetterCode">The collection letter code.</param>
    /// <param name = "_prefix">The prefix string.</param>
    /// <param name = "_custBillingClassification">The customer billing classification.</param>
    /// <param name = "_referToCollectionAgency">A boolean whether to refer the collection letter to a collection agency.</param>
    protected void updateExisting(CustAccount _accountNum,
                                CustCollectionLetterCode _collectionLetterCode,
                                str _prefix = getPrefix(),
                                RefRecId _custBillingClassification = 0,
                                ReferToCollectionAgency_W _referToCollectionAgency = NoYes::No
                                )
    {
        CustCollectionLetterJour oldCustCollectionLetterJour;

        if (isBillingClassificationEnabled)
        {
            while select forupdate oldCustCollectionLetterJour
                where oldCustCollectionLetterJour.AccountNum == _accountNum
                    && oldCustCollectionLetterJour.CollectionLetterCode == _collectionLetterCode
                    && oldCustCollectionLetterJour.CustBillingClassification == _custBillingClassification
                    && oldCustCollectionLetterJour.Status == PrintPostCancel::Created
                    && oldCustCollectionLetterJour.ReferToCollectionAgency_W == _referToCollectionAgency
            {
                this.updateCollectionLetter(oldCustCollectionLetterJour);
            }
        }
        else
        {
            while select forupdate oldCustCollectionLetterJour
                where oldCustCollectionLetterJour.AccountNum == _accountNum
                    && oldCustCollectionLetterJour.CollectionLetterCode == _collectionLetterCode
                    && oldCustCollectionLetterJour.Status == PrintPostCancel::Created
                    && oldCustCollectionLetterJour.ReferToCollectionAgency_W == _referToCollectionAgency
            {
                this.updateCollectionLetter(oldCustCollectionLetterJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the fields.
    /// </summary>
    /// <param name="_calledFrom">
    /// An instance of the <c>Object</c> class.
    /// </param>
    /// <returns>
    /// false if validation failed; otherwise, true.
    /// </returns>
    public boolean validate(Object _calledFrom = null)
    {
        boolean ok = super();

        if (isBillingClassificationEnabled && inclTransWithNoBillingClassifications == NoYes::No && billingClassificationIds == '')
        {
            ok = checkFailed("@SPS686");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCollectionLetter</Name>
				<Source><![CDATA[
    private void updateCollectionLetter(CustCollectionLetterJour custCollectionLetterJour)
    {
        if (this.shouldUpdateExistingCustCollectionLetterJour(custCollectionLetterJour)
            && this.shouldUpdateCustCollectionLetterJourForAllExisting(custCollectionLetterJour))
        {
            custCollectionLetterJour.setCancelling();
            custCollectionLetterJour.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logInfo</Name>
				<Source><![CDATA[
    private void logInfo(str _prefix, str _message)
    {
        info("@AccountsReceivable:CollectionLetterCreationProcessComplete" + '\t'
            +_prefix + '\t'
            + _message);
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS15514";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        Set customerAccountFilters;

        if (args && args.record())
        {
            // If records are selected on the calling form then capture the account numbers and automatically apply the restrictions.
            customerAccountFilters = CustCollectionLetterCreate::getAccountNumberFiltersFromSourceForm(FormDataUtil::getFormDataSource(args.record()));
        }

        CustCollectionLetterCreate custCollectionLetterCreate;

        if (customerAccountFilters)
        {
            custCollectionLetterCreate = CustCollectionLetterCreate::constructWithCustomerAccountFilter(customerAccountFilters);
        }
        else
        {
            custCollectionLetterCreate = new CustCollectionLetterCreate();
        }

        if (custCollectionLetterCreate.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {          
                custCollectionLetterCreate.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>CustCollectionLetterCreate</c> class.
    /// </summary>
    /// <returns>An instance of the <c>CustCollectionLetterCreate</c> class.</returns>
    public static CustCollectionLetterCreate construct()
    {
        return new CustCollectionLetterCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructWithCustomerAccountFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>CustCollectionLetterCreate</c> class with customer account restrictions.
    /// </summary>
    /// <param name = "_customerSet">A set of account numbers used as a filter.</param>
    /// <returns>An instance of the <c>CustCollectionLetterCreate</c> class.</returns>
    public static CustCollectionLetterCreate constructWithCustomerAccountFilter(Set _customerSet)
    {
        CustCollectionLetterCreate collectionLetterCreate = CustCollectionLetterCreate::construct();
        collectionLetterCreate.applyCustomerFilter(_customerSet);
        return collectionLetterCreate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyCustomerFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the provided customer account filters.
    /// </summary>
    /// <param name = "_customerSet">A set of account numbers.</param>
    /// <remarks>
    /// These restrictions are eventually applied to the query that drives the collection letter creation process.
    /// </remarks>
    protected void applyCustomerFilter(Set _customerSet)
    {
        Debug::assert(_customerSet.typeId() == Types::String);

        SetEnumerator setEnumerator = _customerSet.getEnumerator();
        while (setEnumerator.moveNext())
        {
            custAccountsRestriction += [setEnumerator.current()];
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        custParameters = CustParameters::find();
        
        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        custCollectionLetterCodeOrderedList = CustCollectionLetterCodeOrderedList::newFromOrder();

        this.queryBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActualCollectionLetterDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the collection letter generation date.
    /// </summary>
    /// <returns>The date to be used on the collection letter.</returns>
    protected TransDate getActualCollectionLetterDate()
    {
        if (useCurrentDate)
        {
            collectionLetterDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        return collectionLetterDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>