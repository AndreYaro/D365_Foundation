<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustFreeInvoiceCorrection</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustFreeInvoiceCorrection</c> class is used to create a corrected or adjusting invoice.
/// </summary>
public class CustFreeInvoiceCorrection
{
    CustInvoiceJour parentCustInvoiceJour;

    CustInvoiceTableRefRecId custParentInvoiceRecId;
    RefRecId childCustInvoiceTableRecId;
    RecId custChildSourceDocumentRecId;
    RecId childReasonCodeRecId;
    TransDate parentAdjustingInvoiceDate;
    boolean isCorrectedInvoiceWithTemplate;

    TransDate invoiceDate;
    InvoiceAssociationType invoiceType;

    // <GIN>
    boolean isRegionIndia;
    #ISOCountryRegionCodes
    // </GIN>

    #EECountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>populateChildInvoiceFromParent</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the <c>CustInvoiceTable</c> table buffer of child invoice from <c>CustInvoiceTable</c> table buffer of the parent invoice.
    /// </summary>
    /// <param name = "_custInvoiceTableParent">
    ///    The parent <c>CustInvoiceTable</c> table buffer.
    /// </param>
    /// <returns>
    ///    The populated <c>CustInvoiceTable</c> table buffer of child invoice.
    /// </returns>
    [Wrappable(true)]
    protected final CustInvoiceTable populateChildInvoiceFromParent(CustInvoiceTable _custInvoiceTableParent)
    {
        CustInvoiceTable custInvoiceTableChild;

        buf2Buf(_custInvoiceTableParent, custInvoiceTableChild);

        // setting invoice date for adjusting invoice
        if (invoiceType == InvoiceAssociationType::AdjustingInvoice)
        {
            custInvoiceTableChild.InvoiceDate = _custInvoiceTableParent.AdjustingInvoiceDate;

            if (!custInvoiceTableChild.InvoiceDate && SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                custInvoiceTableChild.InvoiceDate = parentAdjustingInvoiceDate;
            }

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                custInvoiceTableChild.ExchRate_W = _custInvoiceTableParent.displayExchRate();
            }
            // </GEERU>
            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV]))
            {
                custInvoiceTableChild.ManualNumbering_W = NoYes::No;
                custInvoiceTableChild.DocNumberingCode_LT = '';
                custInvoiceTableChild.ManualInvoiceID_W = '';
            }
            if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
            {
                custInvoiceTableChild.VatDueDate_W = _custInvoiceTableParent.VatDueDate_W;
            }
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                custInvoiceTableChild.SalesDate_W = _custInvoiceTableParent.SalesDate_W;
            }
            // </GEEU>
        }
        else
        {
            // Should save the input of canceling invoice date as the invoice date to the corrected invoice always.
            custInvoiceTableChild.InvoiceDate = parentAdjustingInvoiceDate;
            custInvoiceTableChild.DueDate = CustInvoiceTable::paymentDueDateServer(custInvoiceTableChild);
        }

        custInvoiceTableChild.SourceDocumentHeader = 0;
        custInvoiceTableChild.SourceDocumentLine = 0;
        custInvoiceTableChild.Log = '';
        custInvoiceTableChild.Posted = false;
        custInvoiceTableChild.InvoiceId = '';
        custInvoiceTableChild.CorrectionReasonCode = childReasonCodeRecId;
        custInvoiceTableChild.AdjustingInvoiceDate = dateNull();

        // setting workflow status for corrected and adjusting invoice
        if (WorkflowTable::findActiveTemplate(workFlowTypeStr(CustFreeTextInvoiceTemplate)).RecId != 0)
        {
            custInvoiceTableChild.WorkflowApprovalState = CustFreeInvoiceWFApprovalState::NotSubmitted;
            custInvoiceTableChild.WorkflowApprovalStatus = CustFreeInvoiceWFApprovalStatus::Draft;
        }
        else
        {
            custInvoiceTableChild.WorkflowApprovalState = CustFreeInvoiceWFApprovalState::NotSubmitted;
            custInvoiceTableChild.WorkflowApprovalStatus = 0;
        }

        return custInvoiceTableChild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustingCorrectedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the header level record for an adjusting or corrected invoice.
    /// </summary>
    protected void createAdjustingCorrectedInvoice()
    {
        CustInvoiceTable custInvoiceTableParent;

        // Select CustInvoiceTable record of parent invoice and copy it for the corrected or adjusting invoice
        select firstonly forupdate custInvoiceTableParent
            where custInvoiceTableParent.RecId == custParentInvoiceRecId;

        CustInvoiceTable custInvoiceTableChild = this.populateChildInvoiceFromParent(custInvoiceTableParent);

        custInvoiceTableChild.insert();

        // copying parent postal address to child postal address
        this.updateDelieveryLocation(custInvoiceTableParent.DeliveryLocation, custInvoiceTableChild.DeliveryLocation);

        custChildSourceDocumentRecId = custInvoiceTableChild.SourceDocumentHeader;
        childCustInvoiceTableRecId = custInvoiceTableChild.RecId;

        // Insert original invoice record in CustRelatedInvoice table if invoice is going to be corrected for the first time
        CustRelatedInvoice::insertOriginal(custParentInvoiceRecId);

        // Insert corrected on adjusting invoice record in CustRelatedInvoiceTable
        if (this.shouldRelateAdjustingAndParentInvoice())
        {
            CustRelatedInvoice::insertAdjusting(custInvoiceTableChild.RecId, custParentInvoiceRecId);
        }
        else
        {
            this.relateCorrectedAndParentInvoice(custInvoiceTableParent, custInvoiceTableChild);
        }

        // Set CustInvoiceJour buffer based on the CustInvoiceTable
        parentCustInvoiceJour = custInvoiceTableParent.custInvoiceJour();
    }

]]></Source>
			</Method>
			<Method>
				<Name>relateCorrectedAndParentInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a relationship between the corrected invoice and the parent invoice.
    /// </summary>
    /// <param name = "_custInvoiceTableParent">
    ///    The <c>CustInvoiceTable</c> child buffer.
    /// </param>
    /// <param name = "_custInvoiceTableChild">
    ///    The <c>CustInvoiceTable</c> parent buffer.
    /// </param>
    [Wrappable(true)]
    protected final void relateCorrectedAndParentInvoice(CustInvoiceTable _custInvoiceTableParent, CustInvoiceTable _custInvoiceTableChild)
    {
        CustRelatedInvoice::insertCorrecting(_custInvoiceTableChild.RecId, custParentInvoiceRecId);

        if (CustRelatedInvoice::doesInvoiceExistForType(_custInvoiceTableParent.RecId, InvoiceAssociationType::OriginalInvoice))
        {
            _custInvoiceTableParent.CorrectionReasonCode = 0;
        }

        _custInvoiceTableParent.AdjustingInvoiceDate = parentAdjustingInvoiceDate;
        _custInvoiceTableParent.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRelateAdjustingAndParentInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the adjusting invoice should be related to the parent invoice.
    /// </summary>
    /// <returns>
    ///    true if the adjusting invoice should be related to the parent invoice; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldRelateAdjustingAndParentInvoice()
    {
        return (invoiceType == InvoiceAssociationType::AdjustingInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAdjustingInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an adjusting free text invoice.
    /// </summary>
    /// <returns>
    ///    The record ID of the adjusting free text invoice that is created.
    /// </returns>
    public CustInvoiceTableRefRecId createAdjustingInvoice()
    {
        invoiceType = InvoiceAssociationType::AdjustingInvoice;

        return this.createInvoice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCorrectedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a corrected free text invoice.
    /// </summary>
    /// <param name="_reasonCodeRecId">
    ///    The record ID of the reason code.
    /// </param>
    /// <param name="_adjustingInvoiceDate">
    ///    The date of the adjusting invoice.
    /// </param>
    /// <param name="_invoiceDate">
    ///    The date of the invoice.
    /// </param>
    /// <returns>
    ///    The record ID of the corrected free text invoice that is created.
    /// </returns>
    public CustInvoiceTableRefRecId createCorrectedInvoice(RefRecId _reasonCodeRecId, TransDate _adjustingInvoiceDate, TransDate _invoiceDate)
    {
        // <GEEU>
        CustInvoiceJour_W custInvoiceJour_W;
        // </GEEU>
        if (this.validate(_reasonCodeRecId, _adjustingInvoiceDate, _invoiceDate))
        {
            invoiceType = InvoiceAssociationType::CorrectedInvoice;
            childReasonCodeRecId = _reasonCodeRecId;
            parentAdjustingInvoiceDate = _adjustingInvoiceDate;

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                invoiceDate = _invoiceDate;
            }
            childCustInvoiceTableRecId = this.createInvoice();
        }

        return childCustInvoiceTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDocumentReferences</Name>
				<Source><![CDATA[
    protected void createDocumentReferences()
    {
        CustInvoiceTable parentInvoice;
        CustInvoiceTable childInvoice;

        // It is not necessary to retrieve the tables since the only fields used for the
        // document reference copy are DataAreaId, TableId and RecId
        parentInvoice.RecId = custParentInvoiceRecId;
        childInvoice.RecId = childCustInvoiceTableRecId;

        Docu::copy(parentInvoice, childInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createIntercompanyProjInvoiceLines</Name>
				<Source><![CDATA[
    private void createIntercompanyProjInvoiceLines()
    {
        CustInvoiceLine parentInvoiceLine;
        CustInvoiceLine childInvoiceLine;
        CustInvoiceLineInterProj parentProjInvoiceLine;
        CustInvoiceLineInterProj childProjInvoiceLine;

        while select recid from childInvoiceLine
            where childInvoiceLine.ParentRecId == childCustInvoiceTableRecId
            join RecId from parentInvoiceLine
            where parentInvoiceLine.RecId == childInvoiceLine.CorrectedCustInvoiceLine
            join parentProjInvoiceLine
            where parentProjInvoiceLine.CustInvoiceLine == parentInvoiceLine.RecId
        {
            buf2Buf(parentProjInvoiceLine, childProjInvoiceLine);
            childProjInvoiceLine.CustInvoiceLine = childInvoiceLine.RecId;
            childProjInvoiceLine.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an adjusting or corrected free text invoice.
    /// </summary>
    /// <returns>
    ///    The record ID of the free text invoice that is created.
    /// </returns>
    protected CustInvoiceTableRefRecId createInvoice()
    {
        #OCCRetryCount

        try
        {
            // Taxes should only created automatically for cancelling invoice.
            boolean shouldCreateTaxesForHeaderCharges = !TaxFTICorrectionOnlyCopyHeaderChargeTaxToCancellingFlight::instance().isEnabled() || invoiceType == InvoiceAssociationType::AdjustingInvoice;

            ttsbegin;
            this.createAdjustingCorrectedInvoice();
            this.createInvoiceLines();
            this.createMiscellaneousCharges(
                parentCustInvoiceJour.TableId,
                parentCustInvoiceJour.RecId,
                tableNum(CustInvoiceTable),
                childCustInvoiceTableRecId,
                shouldCreateTaxesForHeaderCharges);
            this.createPrintMgmt();
            this.createDocumentReferences();

            // Create source document distributions as soon as the corrected invoice is created, if the invoice lines are associated with the FTI template.
            // This is needed as there is no way to say if the dimensions were updated on the Free text invoice after the free text invoice(FTI) has been created
            // from a template. This causes ambiguity whether to default distributions from the template or create distributions using FTI dimensions. Creating the
            // distributions right after the source document is created defaults the distributions from the original invoice line. Then, if the dimensions are updated on the
            // FTI, the new distributions are created using the FTI main account and dimensions.
            if (isCorrectedInvoiceWithTemplate)
            {
                SourceDocumentProcessor::submitSourceDocumentLinesForHeader(
                    CustInvoiceTable::findRecId(childCustInvoiceTableRecId).SourceDocumentHeader,
                    SourceDocumentLineAccountingStatus::FullyDistributed);
            }

            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                this.createIntercompanyProjInvoiceLines();
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }

        return childCustInvoiceTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the invoice lines for the corrected or adjusting invoice.
    /// </summary>
    protected void createInvoiceLines()
    {
        CustInvoiceLine custInvoiceLineParent;
        CustInvoiceLine custInvoiceLineChild;
        CustInvoiceTrans custInvoiceTrans;
        // <GIN>
        CustInvoiceLineTaxExtensionIN custInvoiceLineTaxExtensionINChild;
        // </GIN>
        // <GEERU>
        CustInvoiceTrans_W custInvoiceTrans_W;
        // </GEERU>

        boolean hasIntercompanyProject = false;
        // Tax of cancelling FTI should copy from origin with opposite sign.
        boolean createTaxOnlyForCancellingFTI = !TaxCalcFTICorrectionOnlyCopyTaxToCancellingFlight::instance().isEnabled()
                || invoiceType == InvoiceAssociationType::AdjustingInvoice;

        while select custInvoiceLineParent
            where custInvoiceLineParent.ParentRecId == custParentInvoiceRecId
        {
            if (this.isIntercompanyVendInvoicePostedForFTI(custInvoiceLineParent))
            {
                hasIntercompanyProject = true;
                continue;
            }

            custInvoiceLineChild.clear();
            custInvoiceLineChild = this.populateCustInvoiceLineFromParent(custInvoiceLineParent);

            if (!custInvoiceLineChild.ReasonRefRecId)
            {
                custInvoiceLineChild.ReasonRefRecId = CustInvoiceTable::findCorrectionReasonCode(custInvoiceLineParent.ParentRecId);
            }

            custInvoiceLineChild.insert();

            if (!isCorrectedInvoiceWithTemplate && custInvoiceLineChild.CustInvoiceLineTemplate)
            {
                isCorrectedInvoiceWithTemplate = true;
            }

            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                custInvoiceLineTaxExtensionINChild.clear();
                custInvoiceLineTaxExtensionINChild.TaxModelDocLineExtensionIN::initFromBaseTable(custInvoiceLineChild);
                CustFreeInvoiceCorrection::initFromParentInvoiceLine_IN(custInvoiceLineParent, custInvoiceLineTaxExtensionINChild);

                custInvoiceLineTaxExtensionINChild.MaxRetailPricePerUnit =
                    this.getAdjustedAmount(custInvoiceLineTaxExtensionINChild.MaxRetailPricePerUnit);
                custInvoiceLineTaxExtensionINChild.MaximumRetailPrice =
                    this.getAdjustedAmount(custInvoiceLineTaxExtensionINChild.MaximumRetailPrice);
                custInvoiceLineTaxExtensionINChild.AssessableValueTransactionCurrency =
                    this.getAdjustedAmount(custInvoiceLineTaxExtensionINChild.AssessableValueTransactionCurrency);
                custInvoiceLineTaxExtensionINChild.doInsert();

            }
            // </GIN>

            // <GTE>
            if (TaxIntegrationUtils::isTaxInformationEnabled())
            {
                TransTaxInformationHelper::copyTransTaxInformation(custInvoiceLineParent, custInvoiceLineChild);
            }

            // For corrected invoice maintain lines mapping
            if (invoiceType == InvoiceAssociationType::CorrectedInvoice)
            {
                CustInvoiceLineMapping::createCustInvoiceLineMapping(
                    custInvoiceLineParent.RecId,
                    custInvoiceLineParent.ParentRecId,
                    custInvoiceLineParent.LineNum,
                    custInvoiceLineChild.RecId,
                    custInvoiceLineChild.ParentRecId,
                    custInvoiceLineChild.LineNum);

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    this.copyCustomFieldValues_PSN(custInvoiceLineChild, custInvoiceLineParent);
                }
            }

            while select RecId, SourceDocumentLine from custInvoiceTrans
                where custInvoiceTrans.SalesId == parentCustInvoiceJour.SalesId &&
                custInvoiceTrans.InvoiceId == parentCustInvoiceJour.InvoiceId &&
                custInvoiceTrans.InvoiceDate == parentCustInvoiceJour.InvoiceDate &&
                custInvoiceTrans.NumberSequenceGroup == parentCustInvoiceJour.NumberSequenceGroup &&
                custInvoiceTrans.SourceDocumentLine == custInvoiceLineParent.SourceDocumentLine
            // <GEERU>
            notExists join custInvoiceTrans_W
                where custInvoiceTrans_W.CustInvoiceTrans == custInvoiceTrans.RecId
                   && custInvoiceTrans_W.RefReturnInvoiceTrans_W
            // </GEERU>
            {
                if (createTaxOnlyForCancellingFTI)
                {
                    // Select Tax records of parent invoice lines and copy it for the corrected or adjusting invoice
                    this.createTaxes(
                        custInvoiceTrans.RecId,
                        tableNum(CustInvoiceTrans),
                        childCustInvoiceTableRecId,
                        custInvoiceLineChild.RecId,
                        tableNum(CustInvoiceLine));

                    // <GIN>
                    if (TaxWithholdParameters_IN::checkTaxParameters())
                    {
                        this.createWithholdTaxes_IN(
                            custInvoiceTrans.RecId,
                            tableNum(CustInvoiceTrans),
                            childCustInvoiceTableRecId,
                            custInvoiceLineChild.RecId,
                            tableNum(CustInvoiceLine));
                    }
                    // </GIN>
                }

                if (SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
                {
                    this.createMiscellaneousCharges(custInvoiceTrans.TableId,
                        custInvoiceTrans.RecId,
                        custInvoiceLineChild.TableId,
                        custInvoiceLineChild.RecId,
                        createTaxOnlyForCancellingFTI);
                }
            }
        }

        if (hasIntercompanyProject == true)
        {
            warning("@Proj:ProjIntercompNoFTICorrectionForPostedVendInvoice");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustInvoiceLineFromParent</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>CustInvoiceLine</c> table buffer from the specified parent invoice line record.
    /// </summary>
    /// <param name = "_custInvoiceLineParent">
    ///     The <c>CustInvoiceLine</c> table buffer.
    /// </param>
    /// <returns>
    ///     A populated <c>CustInvoiceLine</c> table buffer based on the specified parent invoice line record.
    /// </returns>
    protected CustInvoiceLine populateCustInvoiceLineFromParent(CustInvoiceLine _custInvoiceLineParent)
    {
        CustInvoiceLine   custInvoiceLineChild;

        buf2Buf(_custInvoiceLineParent, custInvoiceLineChild);

        custInvoiceLineChild.AmountCur   = this.getAdjustedAmount(custInvoiceLineChild.AmountCur);
        custInvoiceLineChild.Quantity    = this.getAdjustedAmount(custInvoiceLineChild.Quantity);
        custInvoiceLineChild.TaxAmount   = this.getAdjustedAmount(custInvoiceLineChild.TaxAmount);
        custInvoiceLineChild.ParentRecId = childCustInvoiceTableRecId;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            this.setBillingCodeVersionDetails(custInvoiceLineChild);
        }

        custInvoiceLineChild.CorrectedCustInvoiceLine = _custInvoiceLineParent.RecId;
        custInvoiceLineChild.SourceDocumentLine = 0;

        return custInvoiceLineChild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMiscellaneousCharges</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the miscellaneous charges for the corrected or adjusting invoice.
    /// </summary>
    /// <param name="_parentTransTableId">
    ///    The table ID of the parent invoice line.
    /// </param>
    /// <param name="_parentTransRecId">
    ///    The record ID of the parent invoice line.
    /// </param>
    /// <param name="_childTransTableId">
    ///    The table ID of the corrected or adjusting invoice line.
    /// </param>
    /// <param name="_childTransRecId">
    ///    The record ID of the corrected or adjusting invoice line.
    /// </param>
    /// <param name="_createTax">
    ///    True if tax should be created.
    /// </param>
    protected void createMiscellaneousCharges(
        RefTableId _parentTransTableId = parentCustInvoiceJour.TableId,
        RefRecId _parentTransRecId = parentCustInvoiceJour.RecId,
        RefTableId _childTransTableId = tableNum(CustInvoiceTable),
        RefRecId _childTransRecId = childCustInvoiceTableRecId
        , boolean _createTax = true
        )
    {
        MarkupTrans markupTransParent;
        MarkupTrans markupTransChild;

        while select markupTransParent
            where markupTransParent.TransRecId == _parentTransRecId &&
                markupTransParent.TransTableId == _parentTransTableId
        {
            markupTransChild.clear();

            buf2Buf(markupTransParent, markupTransChild);

            markupTransChild.Voucher = '';
            markupTransChild.CorrectedMarkupTrans = markupTransParent.RecId;
            markupTransChild.TransDate = dateNull();
            if (SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
            {
                markupTransChild.TransRecId = _childTransRecId;
                markupTransChild.TransTableId = _childTransTableId;
            }
            else
            {
                markupTransChild.TransRecId = childCustInvoiceTableRecId;
                markupTransChild.TransTableId = tableNum(CustInvoiceTable);
            }
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                markupTransChild.ItemPosted_RU = 0;
                markupTransChild.CustVendPosted_RU = 0;
                markupTransChild.FacturedAmount_RU = 0;
                markupTransChild.LineNum = MarkupTrans::lastLineNum(markupTransChild.TransTableId, markupTransChild.TransRecId) + 1;
            }
            // </GEERU>
            markupTransChild.CalculatedAmount = 0;
            markupTransChild.OrigTableId = 0;
            markupTransChild.OrigRecId = 0;
            markupTransChild.TaxAmount = 0;
            markupTransChild.Posted = 0;
            markupTransChild.SourceDocumentLine = 0;

            if (this.canAdjustAmountForMiscellaneousChargeCategoryType(markupTransChild.MarkupCategory))
            {
                markupTransChild.Value = this.getAdjustedAmount(markupTransChild.Value);
            }

            markupTransChild.insert();
            // <GEEU>
            if (_createTax)
            {
                // </GEEU>
                this.createTaxes(
                    markupTransParent.RecId,
                    tableNum(MarkupTrans),
                    childCustInvoiceTableRecId,
                    markupTransChild.RecId,
                    tableNum(MarkupTrans));
                // <GEEU>
            }
            // </GEEU>

            // For corrected invoice maintain misc. charge mapping
            if (invoiceType == InvoiceAssociationType::CorrectedInvoice)
            {
                MarkupTransMapping::createMiscellaneousChargeMapping(
                    markupTransChild.LineNum,
                    markupTransChild.TransRecId,
                    markupTransChild.TransTableId,
                    markupTransParent.LineNum,
                    markupTransParent.TransRecId,
                    markupTransParent.TransTableId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAdjustAmountForMiscellaneousChargeCategoryType</Name>
				<Source><![CDATA[
    private boolean canAdjustAmountForMiscellaneousChargeCategoryType(MarkupCategoryType _markupCategoryType)
    {
        boolean canAdjustAmountForMiscellaneousCharge = true;

        if (invoiceType == InvoiceAssociationType::AdjustingInvoice
            &&  (_markupCategoryType == MarkupCategory::InterCompanyPercent
                || _markupCategoryType == MarkupCategory::Percent))
        {
            //
            // The sign on the invoice transaction amount should determine the
            // markup transaction amount calculated for percentage based markup transactions
            // created for the Adjusting Invoice in order to prevent the net effect on the
            // invoice transaction amount from being the opposite of what is expected.
            //
            canAdjustAmountForMiscellaneousCharge = false;
        }

        return canAdjustAmountForMiscellaneousCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPrintMgmt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the print management records for the corrected and adjusting invoice.
    /// </summary>
    protected void createPrintMgmt()
    {
        PrintMgmtDocInstance printMgmtDocInstanceParent;
        PrintMgmtDocInstance printMgmtDocInstanceChild;

        PrintMgmtSettings printMgmtSettingsParent;
        PrintMgmtSettings printMgmtSettingsChild;

        PrintMgmtIdentificationText printMgmtIdentificationTextParent;
        PrintMgmtIdentificationText printMgmtIdentificationTextChild;

        while select printMgmtDocInstanceParent
            where printMgmtDocInstanceParent.ReferencedRecId == custParentInvoiceRecId &&
            printMgmtDocInstanceParent.ReferencedTableId == tableNum(CustInvoiceTable)
        {
            printMgmtDocInstanceChild.clear();

            buf2Buf(printMgmtDocInstanceParent, printMgmtDocInstanceChild);

            printMgmtDocInstanceChild.ReferencedRecId = childCustInvoiceTableRecId;
            printMgmtDocInstanceChild.insert();

            // Select print management setting records of parent invoice and copy it for the corrected invoice.
            while select printMgmtSettingsParent
                where printMgmtSettingsParent.ParentId == printMgmtDocInstanceParent.RecId
            {
                printMgmtSettingsChild.clear();

                buf2Buf(printMgmtSettingsParent, printMgmtSettingsChild);

                printMgmtSettingsChild.ParentId = printMgmtDocInstanceChild.RecId;
                printMgmtSettingsChild.insert();

                while select printMgmtIdentificationTextParent
                    where printMgmtIdentificationTextParent.ParentId == printMgmtSettingsParent.RecId
                {
                    printMgmtIdentificationTextChild.clear();

                    buf2Buf(printMgmtIdentificationTextParent, printMgmtIdentificationTextChild);

                    printMgmtIdentificationTextChild.ParentId = printMgmtSettingsChild.RecId;
                    printMgmtIdentificationTextChild.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTaxUncommittedChild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>TaxUncommitted</c> table buffer.
    /// </summary>
    /// <param name = "_parameter">
    /// An <c>CustFreeInvoiceCorrectionInitChildTaxUncommContractParameters</c> instance with parameters to initialize the <c>TaxUncommitted</c> table buffer.
    /// </param>
    /// <returns>
    /// The initialized <c>TaxUncommitted</c> table buffer.
    /// </returns>
    [Wrappable(true)]
    final protected TaxUncommitted initTaxUncommittedChild(CustFreeInvoiceCorrectionInitChildTaxUncommContractParameters _parameter)
    {
        TaxUncommitted taxUncommittedChild;
        TaxTrans taxTrans = _parameter.parmTaxTrans();

        taxUncommittedChild.HeadingTableId = tableNum(CustInvoiceTable);
        taxUncommittedChild.HeadingRecId = _parameter.parmChildHeadingRecId();
        taxUncommittedChild.SourceTableId = _parameter.parmChildSourceTableId();
        taxUncommittedChild.SourceRecId = _parameter.parmChildSourceRecId();
        taxUncommittedChild.Source = taxTrans.Source;
        taxUncommittedChild.TransDate = _parameter.parmChildCustInvoiceTable().InvoiceDate;
        taxUncommittedChild.InventTransId = taxTrans.InventTransId;
        taxUncommittedChild.TaxCode = taxTrans.TaxCode;
        taxUncommittedChild.TaxGroup = taxTrans.TaxGroup;
        taxUncommittedChild.TaxItemGroup = taxTrans.TaxItemGroup;
        taxUncommittedChild.TaxBaseAmount = this.getAdjustedAmount(taxTrans.TaxBaseAmount);
        taxUncommittedChild.TaxBaseAmountCur = this.getAdjustedAmount(taxTrans.TaxBaseAmountCur);
        taxUncommittedChild.TaxBaseAmountRep = this.getAdjustedAmount(taxTrans.TaxBaseAmountRep);
        taxUncommittedChild.SourceBaseAmountCur = this.getAdjustedAmount(taxTrans.SourceBaseAmountCur);
        taxUncommittedChild.TaxBaseQty = this.getAdjustedAmount(taxTrans.TaxBaseQty);
        taxUncommittedChild.SourceTaxAmountCur = this.getAdjustedAmount(taxTrans.SourceTaxAmountCur);
        taxUncommittedChild.SourceRegulateAmountCur = this.getAdjustedAmount(taxTrans.SourceRegulateAmountCur);
        taxUncommittedChild.ReverseCharge_W = taxTrans.ReverseCharge_W;
        taxUncommittedChild.TaxValue = taxTrans.TaxValue;

        if (taxTrans.TaxAutogenerated == NoYes::Yes)
        {
            taxUncommittedChild.TaxAmount = this.getAdjustedAmount(taxTrans.TaxAmount);
            taxUncommittedChild.TaxAmountCur = this.getAdjustedAmount(taxTrans.TaxAmountCur);
            taxUncommittedChild.TaxAmountRep = this.getAdjustedAmount(taxTrans.TaxAmountRep);
            taxUncommittedChild.TaxAutogenerated = taxTrans.TaxAutogenerated;
        }
        else
        {
            taxUncommittedChild.TaxAmount = this.getAdjustedAmount(taxTrans.SourceTaxAmountCur);
            taxUncommittedChild.TaxAmountCur = this.getAdjustedAmount(taxTrans.SourceTaxAmountCur);
            taxUncommittedChild.TaxAmountRep = this.getAdjustedAmount(taxTrans.SourceTaxAmountCur);
            taxUncommittedChild.TaxAutogenerated = false;
        }

        taxUncommittedChild.TaxInCostPrice = this.getAdjustedAmount(taxTrans.TaxInCostPrice);
        taxUncommittedChild.TaxInCostPriceMST = this.getAdjustedAmount(taxTrans.TaxInCostPriceMST);
        taxUncommittedChild.TaxInCostPriceCur = this.getAdjustedAmount(taxTrans.TaxInCostPriceCur);
        taxUncommittedChild.TaxInCostPriceRep = this.getAdjustedAmount(taxTrans.TaxInCostPriceRep);
        taxUncommittedChild.CurrencyCode = taxTrans.CurrencyCode;
        taxUncommittedChild.SourceCurrencyCode = taxTrans.SourceCurrencyCode;
        taxUncommittedChild.TaxDirection = taxTrans.TaxDirection;
        taxUncommittedChild.ExemptTax = taxTrans.ExemptTax;
        taxUncommittedChild.TaxInCostPriceRegulated = this.getAdjustedAmount(taxTrans.TaxInCostPriceRegulated);
        taxUncommittedChild.euroTriangulation = taxTrans.euroTriangulation;
        taxUncommittedChild.TaxOrigin = taxTrans.TaxOrigin;
        taxUncommittedChild.SourceBaseAmountCurRegulated = this.getAdjustedAmount(taxTrans.SourceBaseAmountCurRegulated);
        taxUncommittedChild.SourceBaseAmountCurCalculated = this.getAdjustedAmount(taxTrans.SourceBaseAmountCur);
        taxUncommittedChild.Company = taxTrans.company();
        // <GMX>
        taxUncommittedChild.TaxType_MX = taxTrans.TaxType_MX;
        // </GMX>

        return taxUncommittedChild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the tax record for the corrected or adjusting invoice lines and miscellaneous charges.
    /// </summary>
    /// <param name="_parentSourceRecId">
    ///    The record ID of the parent invoice line.
    /// </param>
    /// <param name="_parentSourceTableId">
    ///    The table ID of the parent invoice line.
    /// </param>
    /// <param name="_childHeadingRecId">
    ///    The record ID of the corrected or adjusting invoice.
    /// </param>
    /// <param name="_childSourceRecId">
    ///    The record ID of the corrected or adjusting invoice line.
    /// </param>
    /// <param name="_childSourceTableId">
    ///    The table ID of the corrected or adjusting invoice line.
    /// </param>
    protected void createTaxes(
        RecId _parentSourceRecId,
        TableId _parentSourceTableId,
        RecId _childHeadingRecId,
        RecId _childSourceRecId,
        TableId _childSourceTableId)
    {
        TaxUncommitted taxUncommittedChild;
        TaxWorkRegulation taxWorkRegulation;
        TaxTrans taxTrans;
        TaxTable taxTable;

        // <GIN>
        TaxUncommitted_IN taxUncommittedIN;
        TaxTrans_W taxTrans_W;
        // </GIN>

        // <GEERU>
        TaxTrans_RU taxTrans_RU;
        // <GEERU>

        // <GTH>
        LedgerDimensionDefaultAccount defaultAccount_TH;
        // </GTH>

        CustInvoiceTable childCustInvoiceTable;
        CustInvoiceLine childCustInvoiceLine;
       
        select firstOnly InvoiceDate from childCustInvoiceTable
            where childCustInvoiceTable.RecId == _childHeadingRecId;

        select firstOnly LedgerDimension from childCustInvoiceLine
            where childCustInvoiceLine.RecId == _childSourceRecId;

        // <GEEU>
        while select * from taxTrans
        // </GEEU>
        where taxTrans.SourceRecId == _parentSourceRecId &&
            taxTrans.SourceTableId == _parentSourceTableId &&
            taxTrans.Voucher == parentCustInvoiceJour.LedgerVoucher &&
            taxTrans.TransDate == parentCustInvoiceJour.InvoiceDate
        {
            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                break;
            }
            // </GTE>

            taxTable = TaxTable::find(taxTrans.TaxCode);

            CustFreeInvoiceCorrectionInitChildTaxUncommContractParameters parameters = CustFreeInvoiceCorrectionInitChildTaxUncommContractParameters::construct();

            parameters.parmChildHeadingRecId(_childHeadingRecId);
            parameters.parmChildSourceRecId(_childSourceRecId);
            parameters.parmChildSourceTableId(_childSourceTableId);
            parameters.parmTaxTrans(taxTrans);
            parameters.parmChildCustInvoiceTable(childCustInvoiceTable);

            taxUncommittedChild = this.initTaxUncommittedChild(parameters);
            taxUncommittedChild.OperationLedgerDimension = this.setOperationLedgerDimension(childCustInvoiceLine);
            

            taxUncommittedChild.submitSourceDocumentLine();
            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                taxUncommittedChild.LedgerDimension = TaxTransGeneralJournalAccountEntry::getTaxLedgerDimensionForTaxTrans(taxTrans.RecId);
            }
            // </GIN>
            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                taxTrans_RU = taxTrans.taxTrans_RU();
                taxUncommittedChild.vatTaxAgentVendAccount_RU = taxTrans_RU.vatTaxAgentVendAccount_RU;
                taxUncommittedChild.vatOperationCode_RU = taxTrans_RU.vatOperationCode_RU;
                taxUncommittedChild.OffsetLedgerDimension_RU = taxTrans_RU.OffsetLedgerDimension_RU;

                if (!taxUncommittedChild.ExchRate)
                {
                    taxUncommittedChild.ExchRate = childCustInvoiceTable.getExchRate();
                }
                if (!taxUncommittedChild.ReportingCurrencyExchRate)
                {
                    taxUncommittedChild.ReportingCurrencyExchRate = childCustInvoiceTable.getReportingCurrencyExchRate();
                }
            }
            // <GEERU>

            // <GEEU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                taxTrans_W = taxTrans.taxTrans_W();
                taxUncommittedChild.VatDueDate_W = taxTrans_W.VatDueDate_W;

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    taxUncommittedChild.Addressing_PL = taxTrans_W.Addressing_PL;
                    taxUncommittedChild.CustVendName_PL = taxTrans_W.CustVendName_PL;
                    taxUncommittedChild.VATNum_PL = taxTrans_W.VATNum_PL;
                    taxUncommittedChild.DocumentDate_PL = taxTrans_W.DocumentDate_PL;
                    taxUncommittedChild.TaxPeriodPaymentCode_PL = taxTrans_W.TaxPeriodPaymentCode_PL;
                }
            }
            // </GEEU>

            // <GTH>
            if (TaxThaiGovCertificationFeatureChecker::isTaxBranchEnabled() && taxUncommittedChild.LedgerDimension == 0)
            {
                defaultAccount_TH = TaxLedgerAccountGroup::find(taxTable.TaxAccountGroup).taxLedgerDimension(taxUncommittedChild.TaxDirection);

                if (defaultAccount_TH)
                {
                    taxUncommittedChild.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount_TH, CustInvoiceLine::findByParentRecId(custParentInvoiceRecId).DefaultDimension);
                }
            }
            // </GTH>

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBR]))
            {
                taxUncommittedChild.IncludedInPrice_BR = taxTable.IncludedTax_BR || taxTable.RetainedTax_BR;
            }

            taxUncommittedChild.insert();

            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                taxTrans_W = taxTrans.taxTrans_W();
                taxUncommittedIN.TaxUncommitted = taxUncommittedChild.RecId;
                taxUncommittedIN.AbatementAmount = this.getAdjustedAmount(taxTrans_W.AbatementAmount_IN);
                taxUncommittedIN.ClaimPercentage = taxTrans_W.ClaimPercentage_IN;
                taxUncommittedIN.CustomsDuty = this.getAdjustedAmount(taxTrans_W.CustomsDuty_IN);
                taxUncommittedIN.TaxRegistrationNumberTable_IN = taxTrans_W.TaxRegistrationNumberTable_IN;
                taxUncommittedIN.insert();
            }
            // </GIN>

            if (taxTrans.TaxAutogenerated == NoYes::No)
            {
                taxWorkRegulation.HeadingRecId = _childHeadingRecId;
                taxWorkRegulation.HeadingTableId = tableNum(CustInvoiceTable);
                taxWorkRegulation.ManualInsertedTax = 0;
                taxWorkRegulation.SourceBaseAmountCurRegulated = this.getAdjustedAmount(taxUncommittedChild.SourceBaseAmountCurRegulated);
                taxWorkRegulation.TaxCode = taxUncommittedChild.TaxCode;
                taxWorkRegulation.TaxDirection = taxUncommittedChild.TaxDirection;
                taxWorkRegulation.TaxRegulationAmountCur = this.getAdjustedAmount(taxTrans.SourceRegulateAmountCur);
                taxWorkRegulation.insert();
            }
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TaxableDocumentObject taxableDocumentObject = TaxableDocumentObject::construct(
            TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(CustInvoiceTable::findRecId(_childHeadingRecId)));

            if (InvoiceType == InvoiceAssociationType::AdjustingInvoice)
            {
                CustInvoiceTrans parentInvoiceTrans = CustInvoiceTrans::findRecId(_parentSourceRecId);
                CustInvoiceLine childInvoiceLine = custInvoiceLine::find(_childSourceRecId);
                TaxBusinessService::copyTaxDocumentLine(parentInvoiceTrans, childInvoiceLine, null, classStr(TaxMeasureTaxAmount), NoYes::Yes, childInvoiceLine.custInvoiceTable());
                TaxBusinessService::markTaxDocumentTaxStatus(taxableDocumentObject, TaxDocumentCalculationLevel::Dirty);
            }

            if (!FeatureStateProvider::isFeatureEnabled(TaxInterCompInvGSTDelayTaxCalcFlighting::instance()))
            {
                TaxBusinessService::calculateTax(taxableDocumentObject);
            }
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWithholdTaxes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the withhold tax record for the corrected or adjusting invoice lines.
    /// </summary>
    /// <param name="_parentSourceRecId">
    ///    The record ID of the parent invoice line.
    /// </param>
    /// <param name="_parentSourceTableId">
    ///    The table ID of the parent invoice line.
    /// </param>
    /// <param name="_childHeadingRecId">
    ///    The record ID of the corrected or adjusting invoice.
    /// </param>
    /// <param name="_childSourceRecId">
    ///    The record ID of the corrected or adjusting invoice line.
    /// </param>
    /// <param name="_childSourceTableId">
    ///    The table ID of the corrected or adjusting invoice line.
    /// </param>
    protected void createWithholdTaxes_IN(
        RecId _parentSourceRecId,
        TableId _parentSourceTableId,
        RecId _childHeadingRecId,
        RecId _childSourceRecId,
        TableId _childSourceTableId)
    {
        TaxWithholdUncommitted_IN taxWithholdUncommittedChild;
        TaxWithholdTrans_IN taxWithholdTransParent;
        RefRecId parentHeadingRecId;
        RefTableId parentHeadingTableId;
        CustTrans custTrans;

        if (!TaxwithholdTransReverse_IN::isSettlementProcessRun(parentCustInvoiceJour.LedgerVoucher, parentCustInvoiceJour.InvoiceDate))
        {
            parentHeadingRecId = parentCustInvoiceJour.RecId;
            parentHeadingTableId = tableNum(CustInvoiceJour);

            while select * from taxWithholdTransParent
                where taxWithholdTransParent.HeadingRecId == parentHeadingRecId &&
                taxWithholdTransParent.HeadingTableId == parentHeadingTableId &&
                taxWithholdTransParent.SourceRecId == _parentSourceRecId &&
                taxWithholdTransParent.SourceTableId == _parentSourceTableId &&
                taxWithholdTransParent.Voucher == parentCustInvoiceJour.LedgerVoucher &&
                taxWithholdTransParent.TransDate == parentCustInvoiceJour.InvoiceDate
            {
                taxWithholdUncommittedChild.clear();
                taxWithholdUncommittedChild.initFromTaxWithholdTrans(taxWithholdTransParent, -1);
                taxWithholdUncommittedChild.HeadingTableId = tableNum(CustInvoiceTable);
                taxWithholdUncommittedChild.HeadingRecId = _childHeadingRecId;
                taxWithholdUncommittedChild.SourceTableId = _childSourceTableId;
                taxWithholdUncommittedChild.SourceRecId = _childSourceRecId;

                // Fields related to original cust/vend trans fields selected for adjustment.
                custTrans = CustTrans::findByVoucher(taxWithholdTransParent.Voucher);
                taxWithholdUncommittedChild.TransactionStatus = TaxWithholdTransactionstatus_IN::Adjusted;
                taxWithholdUncommittedChild.SourceTransTableId = custTrans.TableId;
                taxWithholdUncommittedChild.SourceTransDate = custTrans.TransDate;
                taxWithholdUncommittedChild.SourceTransRecId = custTrans.RecId;
                taxWithholdUncommittedChild.SourceTransVoucher = custTrans.Voucher;

                taxWithholdUncommittedChild.submitSourceDocumentLine();

                taxWithholdUncommittedChild.insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAdjustedAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the amount for the adjusting or the corrected invoice.
    /// </summary>
    /// <param name="_amount">
    ///    The amount of the invoice.
    /// </param>
    /// <returns>
    ///    The amount of the adjusting or the corrected invoice.
    /// </returns>
    protected real getAdjustedAmount(real _amount)
    {
        return _amount * ((invoiceType == InvoiceAssociationType::AdjustingInvoice) ? -1 : 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the class level variables.
    /// </summary>
    /// <param name="_custParentInvoiceRecId">
    ///    The record ID of the parent invoice.
    /// </param>
    protected void init(CustInvoiceTableRefRecId _custParentInvoiceRecId)
    {
        custParentInvoiceRecId = _custParentInvoiceRecId;
        // <GIN>
        isRegionIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBillingCodeVersionDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the value of the new version in the <c>CustInvoiceLine</c> field.
    /// </summary>
    /// <param name="_custInvoiceLineChild">
    /// The buffer of the <c>CustInvoiceLine</c> table.
    /// </param>
    private void setBillingCodeVersionDetails(CustInvoiceLine _custInvoiceLineChild)
    {
        CustBillingCodeVersion custBillingCodeVersionNew = CustBillingCodeVersion::findByDate(_custInvoiceLineChild.CustBillingCode, parentAdjustingInvoiceDate);

        if (invoiceType == InvoiceAssociationType::CorrectedInvoice && _custInvoiceLineChild.CustBillingCode != 0)
        {
            if (custBillingCodeVersionNew.AllowChangeLedgerAccount == NoYes::No)
            {
                // Update ledger dimension to the corrected invoice line from the billing code.
                CustBillingCodeLedgerAccount custBillingCodeLedgerAccount = CustBillingCodeLedgerAccount::findByCustBillingCodeVersion(custBillingCodeVersionNew.RecId);
                _custInvoiceLineChild.LedgerDimension = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(custBillingCodeLedgerAccount.LedgerDimension);
            }

            if (custBillingCodeVersionNew.AllowChangeAmount == NoYes::No)
            {
                // Update invoice line amount based on invoice currency from the billing code.
                _custInvoiceLineChild.convertCurrencyCode(_custInvoiceLineChild.custInvoiceTable().CurrencyCode,
                                                          parentAdjustingInvoiceDate,
                                                          CustInvoiceChangeCurrencyOption::ResetToBillingCodeRate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDelieveryLocation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the postal address of the child invoice with the postal address of the parent invoice.
    /// </summary>
    /// <param name="parentCustInvoiceTableDeliveryLocation">
    ///    The record ID of the <c>LogisticsLocation</c> table of the parent invoice.
    /// </param>
    /// <param name="childCustInvoiceTableDeliveryLocation">
    ///    The record ID of the <c>LogisticsLocation</c> table of the child invoice.
    /// </param>
    protected void updateDelieveryLocation(recId parentCustInvoiceTableDeliveryLocation, recId childCustInvoiceTableDeliveryLocation)
    {
        LogisticsLocation parentlocation;
        LogisticsPostalAddress parentPostalAddress;

        LogisticsLocation childlocation;
        LogisticsPostalAddress childPostalAddress;

        ttsbegin;

        // copying from parent postal address to child postal address
        select firstonly CountryRegionId, County, State from parentPostalAddress
            exists join parentlocation
                where parentPostalAddress.Location == parentlocation.RecId &&
                      parentlocation.RecId == parentCustInvoiceTableDeliveryLocation;

        select firstonly forupdate childPostalAddress
            exists join childlocation
                where childPostalAddress.Location == childlocation.RecId &&
                      childlocation.RecId == childCustInvoiceTableDeliveryLocation;

        childPostalAddress.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
        childPostalAddress.CountryRegionId = parentPostalAddress.CountryRegionId;
        childPostalAddress.County = parentPostalAddress.County;
        childPostalAddress.State = parentPostalAddress.State;
        childPostalAddress.write();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the adjusting invoice date and reason code.
    /// </summary>
    /// <param name="_reasonCodeRecId">
    ///    The record ID of the reason code.
    /// </param>
    /// <param name="_adjustingInvoiceDate">
    ///    The date for the adjusting invoice.
    /// </param>
    /// <param name="_invoiceDate">
    ///    The date of the invoice.
    /// </param>
    /// <returns>
    ///    true if the reason code record ID and adjusting invoice date is valid; otherwise, false.
    /// </returns>
    protected boolean validate(RefRecId _reasonCodeRecId, TransDate _adjustingInvoiceDate, TransDate _invoiceDate)
    {
        boolean isValid = true;

        if (!_reasonCodeRecId)
        {
            error("@SYS300515");
            isValid = false;
        }

        if (_adjustingInvoiceDate)
        {
            if (_adjustingInvoiceDate < _invoiceDate)
            {
                error("@SYS300083");
                isValid = false;
            }

            if (!LedgerFiscalCalendar::isDateInOpenPeriod(CompanyInfoHelper::fiscalCalendarRecId(), _adjustingInvoiceDate))
            {
                error("@SYS300084");
                isValid = false;
            }
        }
        else
        {
            isValid = false;
        }

        // <GIN>
        if (isRegionIndia
            && isValid)
        {
            CustFreeInvoiceCorrection::validate_IN(custParentInvoiceRecId);
        }
        // </GIN>

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCorrectedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates an instance of the <c>CustInvoiceCorrection</c> class.
    /// </summary>
    /// <param name="_custParentInvoiceRecId">
    ///    The record ID of the parent invoice.
    /// </param>
    /// <returns>
    ///    An instance of the <c>CustInvoiceCorrection</c> class.
    /// </returns>
    public static CustFreeInvoiceCorrection newCorrectedInvoice (CustInvoiceTableRefRecId _custParentInvoiceRecId)
    {
        CustFreeInvoiceCorrection custFreeInvoice;

        custFreeInvoice = new CustFreeInvoiceCorrection();
        custFreeInvoice.init(_custParentInvoiceRecId);
        return custFreeInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the payment record from TaxWithholdTrans_IN table for the corrected invoice.
    /// </summary>
    /// <remarks>
    ///     The<c>isOriginFTISettledWithWHTPayment</c> method is used to check for FTI Correction only.
    /// </remarks>
    /// <param name="_custParentInvoiceRecId">
    /// RecId of original FTI Header..
    /// </param>
    public static void validate_IN(CustInvoiceTableRefRecId _custParentInvoiceRecId)
    {
        CustInvoiceJour parentCustInvoiceJourLoc;
        CustTrans custTrans;
        CustTrans custTransPayment;
        TaxWithholdTrans_IN taxWithholdTrans;
        CustSettlement custSettlement;
        CustInvoiceTable custInvoiceTable;
        LedgerTransVoucherLink ledgerTransVoucherLink;
        LedgerTransVoucherLink ledgerTransVoucherLinkRel;
        TaxItemGroupHeading taxItemGroup;
        TaxTrans paymentTaxTrans;
        TaxTrans_W paymentTaxTrans_W;

        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            custInvoiceTable = CustInvoiceTable::findRecId(_custParentInvoiceRecId);
            parentCustInvoiceJourLoc = custInvoiceTable.custInvoiceJour();
            custTrans = CustTrans::findVoucherDate(parentCustInvoiceJourLoc.LedgerVoucher, parentCustInvoiceJourLoc.InvoiceDate);

            if (TaxParameters::isServiceTaxEnable_IN())
            {
                select firstOnly Voucher, TransDate, VoucherGroupId from ledgerTransVoucherLink
                    exists join custTransPayment
                    where ledgerTransVoucherLink.Voucher == custTransPayment.Voucher
                        && ledgerTransVoucherLink.TransDate == custTransPayment.TransDate
                        && ledgerTransVoucherLink.VoucherGroupId == ledgerTransVoucherLink.RecId // To identify the payments
                    join VoucherGroupId from ledgerTransVoucherLinkRel
                        where ledgerTransVoucherLinkRel.VoucherGroupId == ledgerTransVoucherLink.RecId
                            && ledgerTransVoucherLinkRel.VoucherGroupId != ledgerTransVoucherLinkRel.RecId
                        join custSettlement
                        where custSettlement.OffsetRecid == custTransPayment.RecId
                        && custSettlement.TransRecId == custTrans.RecId
                        && custSettlement.CanBeReversed == NoYes::Yes
                    join RecId, TransDate, Voucher from paymentTaxTrans
                        where paymentTaxTrans.TransDate == ledgerTransVoucherLinkRel.TransDate
                            && paymentTaxTrans.Voucher == ledgerTransVoucherLinkRel.Voucher
                    join TaxType_IN from paymentTaxTrans_W
                        where paymentTaxTrans_W.TaxTrans == paymentTaxTrans.RecId
                        && paymentTaxTrans_W.TaxType_IN == TaxType_IN::ServiceTax
                    exists join RecId from taxItemGroup
                        where taxItemGroup.TaxItemGroup == paymentTaxTrans.TaxItemGroup
                            && taxItemGroup.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;

                if (ledgerTransVoucherLink.RecId !=0)
                {
                    throw error("@SYS4080124");
                }
            }

            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                // check whether the original FTI is posted with a payment with WHT
                select firstOnly RecId from taxWithholdTrans
                    exists join custTransPayment
                    where custTransPayment.voucher == taxWithholdTrans.Voucher
                        && custTransPayment.TransDate == taxWithholdTrans.TransDate
                        && custTransPayment.AccountNum == taxWithholdTrans.CustAccount
                        exists join custSettlement
                            where custSettlement.OffsetRecid == custTransPayment.RecId
                                && custSettlement.TransRecId == custTrans.RecId
                                && custSettlement.CanBeReversed == NoYes::Yes;

                if (taxWithholdTrans.RecId != 0)
                {
                    throw error("@SYS4080125");
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyCustomFieldValues_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copy the record of the Custom Fields from its original invoice lines' custom fields.
    /// </summary>
    /// <param name="_custInvoiceLineChild">
    ///    The invoice line for the corrected invoice.
    /// </param>
    /// <param name="_custInvoiceLineParent">
    ///    The invoice line from the original invoice.
    /// </param>
    [SysObsoleteAttribute('This method is no longer used. Use CustInvLineBillCodeCustomFieldBase::copy() instead.', false, 30\6\2020)]
    protected void copyCustomFieldValues_PSN(CustInvoiceLine _custInvoiceLineChild, CustInvoiceLine _custInvoiceLineParent)
    {
        CustInvLineBillCodeCustomFieldBase::copy(_custInvoiceLineParent, _custInvoiceLineChild, systemDateGet());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOperationLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the value of the field operationLedgerDimension in the <c>CustInvoiceLine</c> field.
    /// </summary>
    /// <param name = "_custInvoiceLine">
    ///    The buffer of the <c>CustInvoiceLine</c> table.
    /// </param>
    /// <returns>
    /// return operationLedgerDimension.
    /// </returns>
    private LedgerDimensionAccount setOperationLedgerDimension(CustInvoiceLine _custInvoiceLine)
    {
        LedgerDimensionAccount operationLedgerDimension;
        if (!_custInvoiceLine)
        {
            return 0;
        }

        if (DimensionAttributeValueCombination::find(_custInvoiceLine.LedgerDimension).LedgerDimensionType == LedgerDimensionType::DefaultAccount)
        {
            operationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_custInvoiceLine.LedgerDimension);
        }
        else
        {
            operationLedgerDimension = _custInvoiceLine.LedgerDimension;
        }

        return operationLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromParentInvoiceLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the child extension instance from the parent extensionIN table.
    /// </summary>
    /// <param name = "_custInvoiceLineParent">The parent <c>CustInvoiceLine</c> table buffer.</param>
    /// <param name = "_custInvoiceLineTaxExtensionINChild">The child <c>CustInvoiceLineTaxExtensionIN</c> table buffer.</param>
    private static void initFromParentInvoiceLine_IN(CustInvoiceLine _custInvoiceLineParent, CustInvoiceLineTaxExtensionIN _custInvoiceLineTaxExtensionINChild)
    {
        CustInvoiceLineTaxExtensionIN custInvoiceLineTaxExtensionINParent = _custInvoiceLineParent.custInvoiceLineTaxExtensionIN();

        _custInvoiceLineTaxExtensionINChild.AssessableValueTransactionCurrency = custInvoiceLineTaxExtensionINParent.AssessableValueTransactionCurrency;
        _custInvoiceLineTaxExtensionINChild.MaximumRetailPrice = custInvoiceLineTaxExtensionINParent.MaximumRetailPrice;
        _custInvoiceLineTaxExtensionINChild.MaxRetailPricePerUnit = custInvoiceLineTaxExtensionINParent.MaxRetailPricePerUnit;
        _custInvoiceLineTaxExtensionINChild.TDSGroup = custInvoiceLineTaxExtensionINParent.TDSGroup;
        _custInvoiceLineTaxExtensionINChild.TCSGroup = custInvoiceLineTaxExtensionINParent.TCSGroup;
        _custInvoiceLineTaxExtensionINChild.TaxWithholdAcknowledgementNumber = custInvoiceLineTaxExtensionINParent.TaxWithholdAcknowledgementNumber;
        _custInvoiceLineTaxExtensionINChild.TaxWithholdCountryRegionToRemittance = custInvoiceLineTaxExtensionINParent.TaxWithholdCountryRegionToRemittance;
        _custInvoiceLineTaxExtensionINChild.TaxWithholdNatureOfRemittance = custInvoiceLineTaxExtensionINParent.TaxWithholdNatureOfRemittance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompanyVendInvoicePostedForFTI</Name>
				<Source><![CDATA[
    private boolean isIntercompanyVendInvoicePostedForFTI(CustInvoiceLine custInvoiceLine)
    {
        boolean isIntercompPendingVendInvoicePosted = false;

        CustInvoiceLineInterProj custInvoiceLineInterProj;
        CustInvoiceTrans custInvoiceTrans;

        select firstonly RecId, ProjDataArea from custInvoiceLineInterProj
            where custInvoiceLineInterProj.CustInvoiceLine == custInvoiceLine.RecId
                join InvoiceId, invoiceDate from custInvoiceTrans
                   where custInvoiceTrans.SourceDocumentLine == custInvoiceLine.SourceDocumentLine;

        if (custInvoiceLineInterProj.RecId)
        {
            // Checking for the pending vendor invoice posted in the borrowing legal entity.
            changecompany(custInvoiceLineInterProj.ProjDataArea)
            {
                if (VendInvoiceJour::existByInvoiceIdTransDate(custInvoiceTrans.InvoiceId, custInvoiceTrans.InvoiceDate))
                {
                    isIntercompPendingVendInvoicePosted = true;
                }
            }
        }

        return isIntercompPendingVendInvoicePosted;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>