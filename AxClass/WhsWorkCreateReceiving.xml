<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSWorkCreateReceiving</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsWorkCreateReceiving</c> class creates warehouse work for receiving inventory items.
/// </summary>
abstract class WhsWorkCreateReceiving extends WHSWorkCreate
{
    const str UOMStructureCleanupNeededKey         = 'UOMStructureCleanupNeededKey';
    const str UOMStructureHandledInventTransIdsKey = 'UOMStructurehandledInventTransIdsKey';

    InventQty   unitizeQty;

    private WhsLoadLineInventoryReceiptId loadLineInventoryReceiptId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmUnitizeQty</Name>
				<Source><![CDATA[
    public InventQty parmUnitizeQty(InventQty _unitizeQty)
    {
        unitizeQty = _unitizeQty;

        return unitizeQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadLineInventoryReceiptId</Name>
				<Source><![CDATA[
    internal WhsLoadLineInventoryReceiptId parmLoadLineInventoryReceiptId(WhsLoadLineInventoryReceiptId _loadLineInventoryReceiptId = loadLineInventoryReceiptId)
    {
        loadLineInventoryReceiptId = _loadLineInventoryReceiptId;

        return loadLineInventoryReceiptId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBatchFromReceiptDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a batch record from the receipt details.
    /// </summary>
    /// <param name = "_inventBatch">The batch record to initialize.</param>
    /// <param name = "_whsInventBatchReceiptDetails">The receipt details.</param>
    protected void initializeBatchFromReceiptDetails(InventBatch _inventBatch, WHSInventBatchReceiptDetails _whsInventBatchReceiptDetails)
    {
        _inventBatch.pdsInitFromVendBatchDetails(_whsInventBatchReceiptDetails.bufferPdsVendBatchInfo());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates or updates an inventory batch ID for a given item.
    /// </summary>
    /// <param name="_batchId">
    /// The inventory batch ID.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    public void createBatch(InventBatchId _batchId, ItemId _itemId)
    {
        ttsbegin;

        WHSInventBatchReceiptDetails whsInventBatchReceiptDetails = WHSInventBatchReceiptDetails::find(receiptId, _itemId, _batchId);

        InventTable inventTable = InventTable::find(_itemId);
        InventBatch inventBatch = InventBatch::find(_batchId, _itemId, true);

        this.initializeBatchFromReceiptDetails(inventBatch, whsInventBatchReceiptDetails);

        if (inventBatch.RecId == 0)
        {
            inventBatch.InventBatchId   = _batchId;
            inventBatch.ItemId          = _itemId;
        }

        this.initializeBatchDates(inventBatch, whsInventBatchReceiptDetails, inventTable);

        if (!inventBatch.RecId)
        {
            inventBatch.pdsSetShelfLifeBestBeforeFields(inventTable);
        }

        inventBatch.write();

        if (!WHSWorkCreateReceivingPotencyUpdateFlight::instance().isEnabled() || inventTable.PDSPotencyAttribRecording == PDSPotencyAttribRecordingEnum::PurchProdReceipt)
        {
            // Set the potency attribute value
            inventBatch.updateBaseBatchAttribValue(whsInventBatchReceiptDetails.PdsPotencyBaseValue);
        }

        // Capture the batch disposition code
        if (inventTable.pdsIsShelfLifeCapable() && whsInventBatchReceiptDetails.PdsBatchDispositionCode)
        {
            PdsResetDispositionStatus::setBatchDispositionCode(_itemId, _batchId, whsInventBatchReceiptDetails.PdsBatchDispositionCode);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBatchDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the dates for the specified <c>InventBatch</c> buffer.
    /// </summary>
    /// <param name = "_inventBatch">The <c>InventBatch</c> to initialize.</param>
    /// <param name = "_whsInventBatchReceiptDetails">The batch receipt details.</param>
    /// <param name = "_inventTable">The batch item ID.</param>
    protected void initializeBatchDates(InventBatch _inventBatch, WHSInventBatchReceiptDetails _whsInventBatchReceiptDetails, InventTable _inventTable)
    {
        if (_inventBatch.RecId == 0)
        {
            _inventBatch.initializeProductionDate();
            _inventBatch.ExpDate    = _inventTable.isShelfLifeItem() ? _inventBatch.ProdDate : _whsInventBatchReceiptDetails.ExpDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSerial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates an inventory serial ID for a given item.
    /// </summary>
    /// <param name="_serialId">
    /// The serial ID.
    /// </param>
    /// <param name="_itemId">
    /// The item ID.
    /// </param>
    public void createSerial(InventSerialId _serialId, ItemId _itemId)
    {
        if (!InventSerial::exist(_serialId, _itemId))
        {
            InventSerial inventSerial;

            ttsbegin;
            inventSerial.InventSerialId = _serialId;
            inventSerial.ItemId         = _itemId;
            inventSerial.insert();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiveTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles receive of a transfer line.
    /// </summary>
    /// <param name="_inventTransferLine">Transfer line that is received.</param>
    public void receiveTransferLine(InventTransferLine _inventTransferLine)
    {
        var transferLineReceiptPoster = WHSTransferLineReceiptPoster::newFromTransferLine(_inventTransferLine);
        transferLineReceiptPoster.postTransferLineReceipt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerInventTransferLineHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers part or the whole Transfer Order Line based on the <c>InventDim</c> record
    /// and the license plate id parameters.
    /// </summary>
    /// <param name = "_inventTransferLine">
    /// The <c>InventTransferLine</c> record that will be used for the registration.
    /// </param>
    /// <param name = "_licensePlateId">
    /// The license plate id that will be used for the registration.
    /// </param>
    /// <param name = "_qty">
    /// The quantity that will be registered.
    /// </param>
    /// <param name = "_inventDimShipped">
    /// The <c>InventDim</c> record that was already shipped.
    /// </param>
    /// <param name = "_cwQty">
    /// The catch weight quantity that will be registered.
    /// </param>
    [Hookable(false)]
    final public void registerInventTransferLineHandlingQty(
        InventTransferLine  _inventTransferLine,
        WHSLicensePlateId   _licensePlateId,
        InventQty			_qty,
        InventDim           _inventDimShipped,
        PdsCWInventQty		_cwQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _inventTransferLine.ItemId, _cwQty))
        {
            this.registerInventTransferLineQuantities(_inventTransferLine, _licensePlateId, _qty, _inventDimShipped, _cwQty);
        }
        else
        {
            this.registerInventTransferLine(_inventTransferLine, _licensePlateId, _qty, _inventDimShipped);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerInventTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers part or the whole Transfer Order Line based on the <c>InventDim</c> record
    /// and the license plate id parameters.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The <c>InventTransferLine</c> record that will be used for the registration.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate id that will be used for the registration.
    /// </param>
    /// <param name="_qty">
    /// The quantity that will be registered.
    /// </param>
    /// <param name="_inventDimShipped">
    /// The <c>InventDim</c> record that was already shipped.
    /// </param>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the registerInventTransferLineHandlingQty method. Extenders should move their logic to wrap or override the registerInventTransferLineQuantities method.', false, 30\9\2019)]
    public void registerInventTransferLine(
        InventTransferLine  _inventTransferLine,
        WHSLicensePlateId   _licensePlateId,
        InventQty           _qty,
        InventDim           _inventDimShipped)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _inventTransferLine.ItemId);

        this.registerInventTransferLineQuantities(_inventTransferLine, _licensePlateId, _qty, _inventDimShipped, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerInventTransferLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers part or the whole Transfer Order Line based on the <c>InventDim</c> record
    /// and the license plate id parameters.
    /// </summary>
    /// <param name = "_inventTransferLine">
    /// The <c>InventTransferLine</c> record that will be used for the registration.
    /// </param>
    /// <param name = "_licensePlateId">
    /// The license plate id that will be used for the registration.
    /// </param>
    /// <param name = "_qty">
    /// The quantity that will be registered.
    /// </param>
    /// <param name = "_inventDimShipped">
    /// The <c>InventDim</c> record that was already shipped.
    /// </param>
    /// <param name = "_cwQty">
    /// The catch weight quantity that will be registered.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the registerInventTransferLineHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected void registerInventTransferLineQuantities(
        InventTransferLine  _inventTransferLine,
        WHSLicensePlateId   _licensePlateId,
        InventQty           _qty,
        InventDim           _inventDimShipped,
        PdsCWInventQty      _cwQty)
    {
        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _inventTransferLine.ItemId, _cwQty, _qty);

        InventDim           inventDim;
        InventTrans         inventTrans;
        InventTransOrigin	inventTransOrigin;
        InventDimParm       inventDimParm;
        InventDimParm       inventDimParmTransferDim;

        InventMovement movement = InventMovement::construct(_inventTransferLine, InventMovSubType::TransferOrderTo);
        movement.inventTable();
        movement.transIdSum();

        inventDimParmTransferDim.initDimTransferReceipt(_inventDimShipped);
        inventDimParmTransferDim.LicensePlateFlag   = NoYes::No;

        InventQty		remainRegisterQty	= _qty;
        PdsCWInventQty	remainRegisterCWQty = _cwQty;

        while select sum(PdsCWQty), sum(Qty) from inventTrans
            group by InventDimId
            where inventTrans.StatusReceipt        >  StatusReceipt::Registered
                && inventTrans.StatusIssue         == StatusIssue::None
            exists join inventTransOrigin
            where inventTransOrigin.RecId          == inventTrans.InventTransOrigin
                && inventTransOrigin.InventTransId == _inventTransferLine.InventTransIdReceive
                #InventDimExistsJoinNoField(inventTrans.inventDimId, inventDim, _inventDimShipped, inventDimParmTransferDim)
        && inventDim.LicensePlateId        == _licensePlateId
        {
            InventDim inventDimAllFields = this.initializeTransferLPReceivingDims(inventTrans.inventDimId, _inventTransferLine.ItemId);

            InventQty		registerQty	  = min(remainRegisterQty, inventTrans.Qty);
            PdsCWInventQty	registerCWQty = min(remainRegisterCWQty, inventTrans.PdsCWQty);

            // Register the item
            inventDimParm.initFromInventDim(inventDimAllFields);

            InventDim arrInventDim = InventDim::find(InventTrans.InventDimId);

            InventDimParm arrInventDimParm;
            arrInventDimParm.initFromInventDim(arrInventDim);

            InventUpd_Registered inventTransRegister = InventUpd_Registered::newParameters(
                                                                        movement,
                                                                        inventDimAllFields,
                                                                        inventDimParm,
                                                                        arrInventDim,
                                                                        arrInventDimParm,
                                                                        registerQty,
                                                                        registerCWQty);

            inventTransRegister.updateNow();

            remainRegisterQty -= registerQty;
            remainRegisterCWQty -= registerCWQty;

            if (remainRegisterQty <= 0
                || (PdsGlobal::pdsIsCWItem(_inventTransferLine.ItemId)
                    && remainRegisterCWQty <= 0))
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeTransferLPReceivingDims</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimension used for registering transfer order items.
    /// </summary>
    /// <param name = "_inventDimIdInit">Initial inventory dimension id.</param>
    /// <param name="_itemId">The item Id.</param>
    /// <returns>An <c>InventDim</c> record.</returns>
    [Hookable(false)]
    internal InventDim initializeTransferLPReceivingDims(InventDimId _inventDimIdInit, ItemId _itemId)
    {
        return InventDim::find(_inventDimIdInit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPurchLineHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers a purchase order line that is received by warehouse.
    /// </summary>
    /// <param name="_inventTransId">
    /// Inventory transaction id.
    /// </param>
    /// <param name="_qty">
    /// Quantity received.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the purchase line.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions of the purchase line.
    /// </param>
    /// <param name = "_cwQty">
    ///	Catch weight received if applicable.
    /// </param>
    [Hookable(false)]
    final public void registerPurchLineHandlingQty(
        InventTransId        _inventTransId,
        InventQty			 _qty,
        WHSLicensePlateId    _licensePlateId,
        InventDimId          _inventDimId,
        PdsCWInventQty       _cwQty)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), this.findOrderLineByInventTransId(_inventTransId).ItemId, _cwQty))
        {
            this.registerPurchLineQuantities(_inventTransId, _qty, _licensePlateId, _inventDimId, _cwQty);
        }
        else
        {
            this.registerPurchLine(_inventTransId, _qty, _licensePlateId, _inventDimId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers a purchase order line that is received by warehouse.
    /// </summary>
    /// <param name="_inventTransId">
    /// Inventory transaction id.
    /// </param>
    /// <param name="_qty">
    /// Quantity received.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the purchase line.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions of the purchase line.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws exception when update is cancelled.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Throws exception when the work is done in different warehouse.
    /// </exception>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the registerPurchLineHandlingQty method. Extenders should move their logic to wrap or override the registerPurchLineQuantities method.', false, 30\9\2019)]
    public void registerPurchLine(
        InventTransId        _inventTransId,
        InventQty            _qty,
        WHSLicensePlateId    _licensePlateId = '',
        InventDimId          _inventDimId = '')
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), this.findOrderLineByInventTransId(_inventTransId).ItemId);

        this.registerPurchLineQuantities(_inventTransId, _qty, _licensePlateId, _inventDimId, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstInventTransForRegister</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the first <c>InventTrans</c> record that is applicable for registration.
    /// </summary>
    /// <param name = "_inventTransId">The inventory transaction ID.</param>
    /// <returns>The found <c>InventTrans</c> record.</returns>
    [Hookable(false)]
    internal protected InventTrans findFirstInventTransForRegister(InventTransId _inventTransId)
    {
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        InventDim           inventDim;

        // Only consider inventory transactions of status Arrived and Ordered as these are the only
        // transactions against which we can receive. In cases where we want to over receive
        // we need to select the inventory transaction that has status Registered, as we get the
        // inventDimId from the inventory transactions.
        select firstonly inventTrans
            order by inventTrans.StatusReceipt desc
            where inventTrans.StatusReceipt  == StatusReceipt::Arrived
                || inventTrans.StatusReceipt == StatusReceipt::Ordered
                || inventTrans.StatusReceipt == StatusReceipt::Registered
            join TableId from inventTransOrigin
                where inventTransOrigin.RecId          == inventTrans.InventTransOrigin
                    && inventTransOrigin.InventTransId == _inventTransId;
        
        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderLineByInventTransId</Name>
				<Source><![CDATA[
    protected WHSReceiptOrderLine findOrderLineByInventTransId(InventTransId _inventTransId)
    {
        var inboundTransactionType = WhsWorkTransactionType::singletonFromType(this.parmWorkTransType()) as WHSInboundShipmentWorkTransactionType;
        if (inboundTransactionType)
        {
            return inboundTransactionType.receivingOrderProvider().findInventTransId(_inventTransId, true);      
        }

        return PurchLine::findInventTransId(_inventTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventMovementArgumentFromOrderLine</Name>
				<Source><![CDATA[
    internal static Common inventMovementArgumentFromOrderLine(WHSReceiptOrderLine _orderLine)
    {
        var purchLine = _orderLine as PurchLine;
        if (purchLine)
        {
            PurchParmLine purchParmLine;
            purchParmLine.initFromPurchLine(purchLine);
            return purchParmLine;
        }
        
        return _orderLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerPurchLineQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Registers a purchase order line that is received by warehouse.
    /// </summary>
    /// <param name="_inventTransId">
    /// Inventory transaction id.
    /// </param>
    /// <param name="_qty">
    /// Quantity received.
    /// </param>
    /// <param name="_licensePlateId">
    /// License plate id of the purchase line.
    /// </param>
    /// <param name="_inventDimId">
    /// Dimensions of the purchase line.
    /// </param>
    /// <param name = "_cwQty">
    ///	Catch weight received if applicable.
    /// </param>
    /// <remarks>
    /// The method is an extension point and is not meant to be called directly. Callers should call the registerPurchLineHandlingQty method.
    /// </remarks>
    [Wrappable(true)]
    protected void registerPurchLineQuantities(
        InventTransId        _inventTransId,
        InventQty            _qty,
        WHSLicensePlateId    _licensePlateId,
        InventDimId          _inventDimId,
        PdsCWInventQty       _cwQty)
    {
        WHSReceiptOrderLine orderLine = this.findOrderLineByInventTransId(_inventTransId);

        InventMovement movement = InventMovement::construct(WhsWorkCreateReceiving::inventMovementArgumentFromOrderLine(orderLine));

        this.registerReceiptLine(orderLine, movement, _qty, _licensePlateId, _inventDimId, _cwQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerReceiptLine</Name>
				<Source><![CDATA[
    internal void registerReceiptLine(
        WHSReceiptOrderLine  _orderLine,
        InventMovement       _movement,
        InventQty            _qty,
        WHSLicensePlateId    _licensePlateId,
        InventDimId          _inventDimId,
        PdsCWInventQty       _cwQty,
        WHSLoadId            _loadId = null)
    {
        InventDimParm                   inventDimParm;
        InventTrans                     inventTransSave;

        WHSCatchWeightTelemetryLogger::logCatchWeightConflictingQuantities(funcName(), _orderLine.ItemId, _cwQty, _qty);
        
        InventDim inventDimOrderLine = _orderLine.inventDim();

        // If not received in with disposition then use order line status.
        inventStatusId = dispositionCode && inventStatusId ? inventStatusId : inventDimOrderLine.InventStatusId;

        InventTrans inventTrans = this.findFirstInventTransForRegister(_orderLine.InventTransId);

        if (inventTrans && inventTrans.StatusReceipt != StatusReceipt::Registered)
        {
            InventTrans inventTransUpd;
            
            select forupdate inventTransUpd
            where inventTransUpd.RecId == inventTrans.RecId;

            // Inventory update handles the splits on CW items as opposed to manually splitting them within the warehousing logic.
            if (!PdsGlobal::pdsIsCWItem(_orderLine.ItemId))
            {
                if (!inventTransUpd.checkIsChanged(inventTrans))
                {
                    throw error("@SYS18447");
                }

                if (this.mustSplitInventoryTransaction(inventTransUpd, _qty))
                {
                    inventTransSave = inventTransUpd.updateSplit(_qty);
                }
            }
        }

        InventDimId inventDimId = _inventDimId ? _inventDimId : inventTrans.inventDimId;

        InventDim inventDim = InventDim::find(inventDimId);

        this.initWarehouse(inventDim, inventDimOrderLine);
        inventDim.setInventoryOwnerByMovement(_movement);
        inventDim.wmsLocationId     = this.retrieveWMSLocationFromReceiptLocation(inventDim);
        inventDim.LicensePlateId    = _licensePlateId;
        inventDim.InventStatusId    = inventStatusId;
        inventDim = InventDim::findOrCreate(inventDim);

        workInventDim = inventDim;

        // Register the item
        inventDimParm.initFromInventDim(inventDim);

        InventUpd_Registered registered = this.createInventUpd_Registered(
                                                _movement,
                                                inventDim,
                                                inventDimParm,
                                                _qty,
                                                _cwQty);

        if (!prmIsDefault(_loadId))
        {
            registered.parmLoadId(_loadId);
        }
        registered.parmDispositionCode(dispositionCode);
        
        this.updateInventUpd_Registered(registered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventUpd_Registered</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    protected void updateInventUpd_Registered(InventUpd_Registered _registered)
    {
        _registered.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventUpd_Registered</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    protected InventUpd_Registered createInventUpd_Registered(
        InventMovement _movement,
        InventDim      _inventDim,
        InventDimParm  _inventDimParm,
        InventQty      _qty,
        PdsCWInventQty _cwQty)
    {
        InventDimParm arrInventDimParm = _inventDimParm.data();

        if (WhsWorkCreateReceivingRegisterReceiptLineClearTDimensionFlight::instance().isEnabled()
            && _inventDim.anyTrackingDimensionSpecified())
        {
            // The receipt transaction list includes transactions that do not match specified criteria, but for sorting this list the same transactions 
            // are used but that should match. Exactly this issue is fixed by the next lines.
            // For more information, look at the initializeInventTransToReceiveList method of the InventTransReceiveList class. Note that the buildReceiptTransListSpecifiedDimensionAllowBlank 
            // method is used for creating the receipt transaction list because tracking dimensions are specified in the criteria and also the addRecordsNotMatchingCriteria 
            // variable equals the true value. Next, look at the sortMarkedListByStatusDateTransOrigin method. Note that the _allDimensions variable
            // equals the false value therefore transactions are used only if they match specified criteria.

            arrInventDimParm.clearTrackingDimensions();
            arrInventDimParm.WMSLocationIdFlag = false;
            arrInventDimParm.LicensePlateFlag = false;
        }

        InventUpd_Registered registered = InventUpd_Registered::newParameters(
                                                _movement,
                                                _inventDim,
                                                _inventDimParm,
                                                _inventDim,
                                                arrInventDimParm,
                                                _qty,
                                                _cwQty);
        
        registered.parmReceiptId(this.parmLoadLineInventoryReceiptId());
        registered.parmLoadId(WHSWorkCreateReceivingLoadContext::currentReceivingLoadId());
        registered.parmWhsSuppressPhysicalRereservationOnNonWorkEnabledIssues(this.mustSuppressPhysicalRereservationOnNonWorkEnabledIssues());

        return registered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSuppressPhysicalRereservationOnNonWorkEnabledIssues</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected boolean mustSuppressPhysicalRereservationOnNonWorkEnabledIssues()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSplitInventoryTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if inventory transaction must be split based on the quantities.
    /// </summary>
    /// <param name = "_inventTrans">The inventory transaction record.</param>
    /// <param name="_receivedQuantity">The quantity received.</param>
    /// <returns>true if split must be done; otherwise, false.</returns>
    protected boolean mustSplitInventoryTransaction(InventTrans _inventTrans, InventQty _receivedQuantity)
    {
        return (_inventTrans.Qty != abs(_receivedQuantity)) && _inventTrans.Qty > _receivedQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveWMSLocationFromReceiptLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the location from receipt location.
    /// </summary>
    /// <param name = "_inventDim">
    /// The inventory dimension record.
    /// </param>
    /// <returns>
    /// The location id if found; otherwise empty.
    /// </returns>
    protected WMSLocationId retrieveWMSLocationFromReceiptLocation(InventDim _inventDim)
    {
        return InventLocation::find(_inventDim.InventLocationId).wmsLocationIdDefaultReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unitizes quantity of an item.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity to be unitized.
    /// </param>
    /// <param name="_unitization">
    /// Determines whether unitization logic should be used or not.
    /// </param>
    /// <returns>
    /// Container containing the number of license plates, final quantity and UOM.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Invalid UOM sequence group.
    /// </exception>
    public static container unitizeQuantity(
                                ItemId                  _itemId,
                                InventQty               _inventQty,
                                WHSLicensePlateGrouping _unitization,
                                InventDimId             _inventDimId = '')
    {
        #WHSBuildQty
        WHSUOMSeqGroupLine  seqGroupLine;
        WHSUOMSeqGroupId    seqGroupId;
        UnitOfMeasureSymbol finalUnitId;
        UnitOfMeasureSymbol unitId;
        Qty                 inventTotalQty;
        Qty                 qty;
        Qty                 finalQty;
        Qty                 inventQty;
        container           buildQty;
        int                 length;
        int                 numLP;
        int                 i;
        int                 j;
        UnitOfMeasureDecimalPrecision precision;
        boolean                       alreadyAddNumLP;

        EcoResReleasedProductUnitConverter  releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

        if (!_itemId || !_inventQty)
        {
            return [0, 0, ''];
        }

        InventHandlingUnitId inventHandlingUnitId = WHSCatchWeightHelper::inventHandlingUnitId(_itemId);
        precision = UnitOfMeasure::findBySymbol(inventHandlingUnitId).DecimalPrecision;
        inventTotalQty = _inventQty;

        if (_unitization == WHSLicensePlateGroupingPolicy::LicensePlateGrouping)
        {
            seqGroupId  = WHSInventTable::find(_itemId).uomSeqGroupId;

            if (!seqGroupId)
            {
                throw error("@WAX1252");
            }

            buildQty    = WHSInventTable::buildQty(_itemId, _inventQty, inventHandlingUnitId, _inventDimId);
            length      = conLen(buildQty);

            for (i = length; i >= 1; --i)
            {
                qty = conPeek(conPeek(buildQty, i), #BuildQtyQty);

                if (qty >= 1)
                {
                    unitId          = conPeek(conPeek(buildQty, i), #BuildQtyUOM);
                    seqGroupLine    = WHSUOMSeqGroupLine::findByUnitId(seqGroupId, unitId);

                    if (frac(qty) > 0)
                    {
                        if (!seqGroupLine.UnitizationGrouping)
                        {
                            qty = Global::roundDown(qty, 1);
                        }
                        else
                        {
                            continue;
                        }
                    }

                    if (seqGroupLine.UnitizationGrouping)
                    {
                        inventQty = releasedProductUnitConverter.convert(qty,
                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(unitId),
                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(inventHandlingUnitId),
                                                                    NoYes::No,
                                                                    _itemId,
                                                                    _inventDimId,
                                                                    NoYes::No);
                        if (!finalUnitId)
                        {
                            finalUnitId = unitId;
                            finalQty    = qty;
                        }

                        ++numLP;
                    }
                    else
                    {
                        inventQty = releasedProductUnitConverter.convert(1,
                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(unitId),
                                                                    UnitOfMeasure::unitOfMeasureIdBySymbol(inventHandlingUnitId),
                                                                    NoYes::No,
                                                                    _itemId,
                                                                    _inventDimId,
                                                                    NoYes::No);

                        for (j = 1; j <= qty; ++j)
                        {
                            if (!finalUnitId)
                            {
                                finalUnitId = unitId;
                                finalQty    = 1;
                            }

                            ++numLP;
                        }

                        inventQty = inventQty * qty;
                    }
                    alreadyAddNumLP = true;

                    // Subtract the quantity we just created work for.
                    inventTotalQty -= inventQty;

                    // Get a new buildQty container and reset our counter for the for () loop.
                    buildQty = WHSInventTable::buildQty(_itemId, inventTotalQty, inventHandlingUnitId, _inventDimId);
                    i = length + 1;
                    if (decRound(inventTotalQty, precision) > 0)
                    {
                        alreadyAddNumLP = false;
                    }
                }
            }
        }

        if (numLP && !alreadyAddNumLP && decRound(inventTotalQty, precision) > 0)
        {
            ++numLP;
        }

        if (_unitization == WHSLicensePlateGroupingPolicy::None || !numLP)
        {
            numLP       = 1;
            finalQty    = _inventQty;
            finalUnitId = inventHandlingUnitId;
        }

        return [numLP, finalQty, finalUnitId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWarehouse</Name>
				<Source><![CDATA[
    protected void initWarehouse(InventDim _inventDim, InventDim _inventDimOrder)
    {
        _inventDim.InventLocationId  = _inventDimOrder.InventLocationId;
        _inventDim.InventSiteId      = _inventDimOrder.InventSiteId;

        if (this.parmInventLocationId())
        {
            _inventDim.InventLocationId = this.parmInventLocationId();

            // Should have already failed in Mobile Device, this is to cover direct API calls.
            if (_inventDim.InventLocationId != _inventDimOrder.InventLocationId
                && !InventSite::allowReceiptAtOtherWarehouse(_inventDimOrder.InventLocationId, _inventDim.InventLocationId))
            {
                throw error("@WAX1239");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMustCleanupUOMStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set a boolean flag into the transaction scope cache in order to flag whether to clean up the UOMStructure or not.
    /// </summary>
    /// <param name = "_mustCleanupUOMStructure">
    /// The boolean flag to set in the cache.
    /// </param>
    protected void setMustCleanupUOMStructure(boolean _mustCleanupUOMStructure)
    {
        SysTransactionScopeCache::set(tableStr(WHSUOMStructure), UOMStructureCleanupNeededKey, _mustCleanupUOMStructure);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCleanupUOMStructure</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve a boolean flag from the transaction scope cache in order to flag whether to clean up the UOMStructure or not.
    /// </summary>
    /// <returns>
    /// True if the flag exists and set to true; false otherwise.
    /// </returns>
    public static boolean mustCleanupUOMStructure()
    {
        return SysTransactionScopeCache::get(tableStr(WHSUOMStructure), UOMStructureCleanupNeededKey, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>InventUpd_Registered_registrationCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Subscribes to <c>InventUpd_Registered::registrationCompleted</c> in order to be notified of a inventory update completion.
    /// For each inventory registration, we remove the relative line from the UOMStructure, because the items have been received at the
    /// destination warehouse
    /// </summary>
    /// <param name="_inventUpd_Registered">
    /// The object <c>InventUpd_Registered</c> signaling the completion of an inventory update.
    /// </param>
    /// <remarks>
    /// This event handler is invoked upon inventory registration is completed. For each registration we need to clear the UOMStructure
    /// as the items have been received. As a perf optimization, by caching the inventTransId in the transaction scope of the <c>UOMStructure</c> table,
    /// we avoid to fire off the deletion of UOMStrucuture lines that might have been deleted already
    /// </remarks>
    [SubscribesTo(classStr(InventUpd_Registered), delegateStr(InventUpd_Registered, registrationCompleted))]
    public static void InventUpd_Registered_registrationCompleted(InventUpd_Registered _inventUpd_Registered)
    {
        InventMov_TransferTo movement = _inventUpd_Registered.movement() as InventMov_TransferTo;

        if (movement && WhsWorkCreateReceiving::mustCleanupUOMStructure()
            && movement.isItemWHSEnabled())
        {
            InventTransferLine transferLine = movement.buffer() as InventTransferLine;
            if (WhsWorkCreateReceiving::mustCleanupTOUOMStructureForTransferLine(transferLine))
            {
                Set handledInventTransIds = WhsWorkCreateReceiving::getHandledInventTransIdsFromUOMStructureTSCache();

                if (!handledInventTransIds.in(movement.inventTransOriginId()))
                {
                    WHSUOMStructure::cleanupTOUOMStructureFromQuery(transferLine.shippedLicensePlatesWithUOMStructure());

                    handledInventTransIds.add(movement.inventTransOriginId());
                    WhsWorkCreateReceiving::setHandledInventTransIdsToUOMStrucureTSCache(handledInventTransIds);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCleanupTOUOMStructureForTransferLine</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal static boolean mustCleanupTOUOMStructureForTransferLine(InventTransferLine _transferLine)
    {
        return _transferLine && _transferLine.inventTransferTable().fromInventLocation().WHSEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHandledInventTransIdsFromUOMStructureTSCache</Name>
				<Source><![CDATA[
    private static Set getHandledInventTransIdsFromUOMStructureTSCache()
    {
        return SysTransactionScopeCache::get(tableStr(WHSUOMStructure), UOMStructureHandledInventTransIdsKey, new Set(Types::Int64));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHandledInventTransIdsToUOMStrucureTSCache</Name>
				<Source><![CDATA[
    private static void setHandledInventTransIdsToUOMStrucureTSCache(Set inventTransIds)
    {
        SysTransactionScopeCache::set(tableStr(WHSUOMStructure), UOMStructureHandledInventTransIdsKey, inventTransIds);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReceiveTransferLineNonLP</Name>
				<Source><![CDATA[
    protected boolean canReceiveTransferLineNonLP(InventTransferLine _inventTransferLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>receiveTransferLineNonLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles receipt of non LP transfer line.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The inventory transfer line.
    /// </param>
    /// <exception cref="Exception::UpdateConflict">
    /// Update conflict exception occurred.
    /// </exception>
    protected void receiveTransferLineNonLP(InventTransferLine _inventTransferLine)
    {
        if (this.canReceiveTransferLineNonLP(_inventTransferLine))
        {
            ttsbegin;

            InventTransferParmTable inventTransferParmTable;
            inventTransferParmTable.clear();
            inventTransferParmTable.initParmDefault();
            inventTransferParmTable.TransferId       = _inventTransferLine.TransferId;
            inventTransferParmTable.UpdateType       = InventTransferUpdateType::Receive;
            inventTransferParmTable.ShipUpdateQty    = InventTransferShipUpdateQty::ShipNow;
            inventTransferParmTable.ReceiveUpdateQty = InventTransferReceiveUpdateQty::Registered;
            inventTransferParmTable.EditLines        = true;
            inventTransferParmTable.LineNum          = 1;
            inventTransferParmTable.JobStatus        = ParmJobStatus::Executed;
            inventTransferParmTable.ExecutedDateTime = DateTimeUtil::utcNow();
            inventTransferParmTable.PickUpdateQty    = InventTransferPickUpdateQty::ShipNow;
            inventTransferParmTable.ExplodeLines     = true;

            InventTransferMultiReceive inventTransferMultiReceive = InventTransferMultiReceive::construct();
            inventTransferMultiReceive.init();
            inventTransferMultiReceive.parmCalledFromWMS(false);
            RunBaseMultiParm::initParm(inventTransferMultiReceive);

            inventTransferParmTable.ParmId = inventTransferMultiReceive.parmId();
        
            inventTransferParmTable.insert(false);
        
            InventTransferParmLineCreate inventTransferParmLineCreate = InventTransferParmLineCreate::newFromParameters(inventTransferParmTable);
            inventTransferParmLineCreate.parmInventTransferLineToProcess(_inventTransferLine);
            inventTransferParmLineCreate.createReceiveLines();

            select inventTransferParmTable
                where inventTransferParmTable.ParmId == inventTransferMultiReceive.parmId();

            InventTransferParmLine inventTransferParmLine;
            while select forupdate inventTransferParmLine
                where inventTransferParmLine.ParmId == inventTransferParmTable.ParmId
            {
                InventDim inventDim = InventDim::find(inventTransferParmLine.InventDimId);
                inventDim.LicensePlateId = '';
                inventDim = InventDim::findOrCreate(inventDim);
                inventTransferParmLine.InventDimId = inventDim.InventDimId;
                inventTransferParmLine.update();
            }

            while (inventTransferParmTable)
            {
                inventTransferMultiReceive.runUpdate(inventTransferParmTable);
                inventTransferMultiReceive.addUpdateRec(InventTransferTable::find(inventTransferParmTable.TransferId));
            
                next inventTransferParmTable;
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerInventTransferLineNonLicensePlate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles registering of the non LP transfer line.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The inventory transfer line.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate id.
    /// </param>
    /// <param name="_qty">
    /// The quantity of the transfer line.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions.
    /// </param>
    /// <param name = "_captureWeight">
    ///	The capture weight quantity that will be registered.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Inventory transaction is changed.
    /// </exception>
    protected void registerInventTransferLineNonLicensePlate(
        InventTransferLine  _inventTransferLine,
        WHSLicensePlateId   _licensePlateId,
        InventQty           _qty,
        InventDim           _inventDim,
        WHSTransWeight	    _captureWeight)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), _inventTransferLine.ItemId, _captureWeight))
        {
            this.registerInventTransferLineQuantitiesNonLP(_inventTransferLine, _licensePlateId, _qty, _inventDim, _captureWeight);
        }
        else
        {
            this.registerInventTransferLineNonLP(_inventTransferLine, _licensePlateId, _qty, _inventDim);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerInventTransferLineNonLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles registering of the non LP transfer line.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The inventory transfer line.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate id.
    /// </param>
    /// <param name="_qty">
    /// The quantity of the transfer line.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Inventory transaction is changed.
    /// </exception>
    [SysObsolete('Method is obsoleted to support catch weight items. Callers should redirect their calls to the registerInventTransferLineNonLicensePlate method. Please file an extensibility request if other access is required.', false, 30\9\2019)]
    protected void registerInventTransferLineNonLP(
        InventTransferLine  _inventTransferLine,
        WHSLicensePlateId   _licensePlateId = '',
        InventQty           _qty = 0,
        InventDim           _inventDim = null)
    {
        WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), _inventTransferLine.ItemId);

        this.registerInventTransferLineQuantitiesNonLP(_inventTransferLine, _licensePlateId, _qty, _inventDim, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerInventTransferLineQuantitiesNonLP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles registering of the non LP transfer line.
    /// </summary>
    /// <param name="_inventTransferLine">
    /// The inventory transfer line.
    /// </param>
    /// <param name="_licensePlateId">
    /// The license plate id.
    /// </param>
    /// <param name="_qty">
    /// The quantity of the transfer line.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions.
    /// </param>
    /// <param name="_captureWeight">
    /// The capture weight quantity that will be registered.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Inventory transaction is changed.
    /// </exception>
    private void registerInventTransferLineQuantitiesNonLP(
        InventTransferLine  _inventTransferLine,
        WHSLicensePlateId   _licensePlateId,
        InventQty           _qty,
        InventDim           _inventDim,
        WHSTransWeight	    _captureWeight)
    {
        boolean isCWItem = PdsGlobal::pdsIsCWItem(_inventTransferLine.ItemId);
        if (isCWItem)
        {
            _inventTransferLine.selectForUpdate(true);
        }

        InventMovement movement = InventMovement::construct(_inventTransferLine, InventMovSubType::TransferOrderTo);
        movement.inventTable();
        movement.transIdSum();

        InventDimParm inventDimParm;
        InventDim     inventDimCriteria = InventDim::find(_inventDim.InventDimId);

        inventDimCriteria.LicensePlateId = '';
        inventDimCriteria = InventDim::findOrCreate(inventDimCriteria);
        inventDimParm.initFromInventDim(inventDimCriteria);

        InventDim         inventDim;
        InventTrans       inventTrans;
        InventTransOrigin inventTransOrigin;

        // Selecting only the first record as the call to InventUpd_Registered will handle updating the proper InventTrans records.
        select firstonly inventTrans
            where inventTrans.StatusReceipt == StatusReceipt::Ordered
            &&    inventTrans.StatusIssue == StatusIssue::None
            join  InventTransId, RecId from inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
                &&    inventTransOrigin.InventTransId == _inventTransferLine.InventTransIdReceive
            #InventDimExistsJoin(inventTrans.InventDimId, inventDim, inventDimCriteria, inventDimParm);
        
        InventTrans inventTransUpd = InventTrans::findRecId(inventTrans.RecId, true);

        if (!inventTransUpd.RecId || !inventTransUpd.checkIsChanged(inventTrans))
        {
            throw error("@SYS18447");
        }

        InventHandlingQty   registerQty     = _qty;
        WHSTransWeight      registerWeight  = isCWItem ? _captureWeight : 0;

        // If a catch weight item with no capture weight, set to nominal to prevent splitting errors
        if (isCWItem && _qty > 0 && !registerWeight)
        {
            registerWeight = WHSCatchWeightHelper::calculateAverageWeight(
                                                    registerQty,
                                                    inventTrans.PdsCWQty,
                                                    inventTrans.Qty,
                                                    InventTable::inventDecimals(_inventTransferLine.ItemId));
        }
            

        if (inventTransUpd.Qty != abs(registerQty) && !isCWItem)
        {
            if (inventTransUpd.Qty > registerQty)
            {
                inventTransUpd.updateSplit(registerQty);
            }
        }
        else if (isCWItem && (inventTransUpd.Qty != abs(registerWeight) || inventTransUpd.PdsCWQty != abs(registerQty)))
        {
            if (inventTransUpd.Qty > registerWeight || inventTransUpd.PdsCWQty > registerQty)
            {
                inventTransUpd.updateSplit(registerWeight, registerQty);
            }
        }

        InventDim tmpInventDim = InventDim::find(inventTrans.InventDimId);
        tmpInventDim.wmsLocationId = this.retrieveWMSLocationFromReceiptLocation(tmpInventDim);

        /*
        If the license plate is different from the one on the transactions then we should not add that as a search criteria
        since we won't find any matches and the registration will default back to a more loose search preventing us from finding specific tracking dimensions
        */
        if (tmpInventDim.LicensePlateId != _licensePlateId)
        {
            inventDimParm.LicensePlateFlag = NoYes::No;
        }

        tmpInventDim.LicensePlateId    = _licensePlateId;
        tmpInventDim = InventDim::findOrCreate(tmpInventDim);

        workInventDim = tmpInventDim;


        // Register the item
        inventDimParm.clear();
        inventDimParm.initFromInventDim(tmpInventDim);
        inventDimParm inventDimParm_NoLP = inventDimParm.data();
        inventDimParm_NoLP.LicensePlateFlag = NoYes::No;

        InventUpd_Registered inventTransRegister = InventUpd_Registered::newParameters(
                                                                            movement,
                                                                            tmpInventDim,
                                                                            inventDimParm,
                                                                            tmpInventDim,
                                                                            inventDimParm_NoLP,
                                                                            isCWItem ? registerWeight : registerQty,
                                                                            isCWItem ? registerQty : 0);
        inventTransRegister.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQtyUserDefined</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unitizes quantity of an item for the user defined license plate grouping policy.
    /// </summary>
    /// <param name="_inventQty">
    /// The inventory quantity that is being used for unitization.
    /// </param>
    /// <param name="_unit">
    /// Unit of measure that is being used for unitization.
    /// </param>
    /// <returns>
    /// Container containing the number of license plates, final quantity and unit of measure.
    /// </returns>
    public static container unitizeQtyUserDefined(
                                InventQty           _inventQty,
                                UnitOfMeasureSymbol _unit)
    {
        UnitOfMeasureSymbol finalUnitId = _unit;
        Qty                 finalQty    = 1;
        int                 numLP       = real2int(_inventQty);

        return [numLP, finalQty, finalUnitId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unitizeQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unitizes quantity of an item.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventQty">
    /// The quantity to be unitized.
    /// </param>
    /// <param name="_unitization">
    /// Determines whether unitization logic should be used or not.
    /// </param>
    /// <returns>
    /// Container containing the number of license plates, final quantity and UOM.
    /// </returns>
    [SysObsolete('Deprecated method. Use unitizeQuantity instead', false, 30\11\2017)]
    public static container unitizeQty(
        ItemId          _itemId,
        InventQty       _inventQty,
        WHSUnitization  _unitization,
        InventDimId     _inventDimId = '')
    {
        return WHSWorkCreateReceiving::unitizeQuantity(
            _itemId,
            _inventQty,
            WHSWorkCreateReceiving::convertWHSUnitization(_unitization),
            _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertWHSUnitization</Name>
				<Source><![CDATA[
    private static WHSLicensePlateGrouping convertWHSUnitization(WHSUnitization _unitization)
    {
        return (_unitization == NoYes::No ? WHSLicensePlateGroupingPolicy::None : WHSLicensePlateGroupingPolicy::LicensePlateGrouping);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>