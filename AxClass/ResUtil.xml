<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ResUtil</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;

/// <summary>
/// Resource management utility class.
/// </summary>
public static class ResUtil
{
    #TimeConstants

    const int secondsPerMinute = #secondsPerMinute;
    const int secondsPerHour = #secondsPerHour;
    const int secondsPerWorkDay = secondsPerHour * 8; // 8 hour work day
    const int secondsPerWorkWeek = secondsPerWorkDay * 5; // 5 day work week

    public static const str activityResourceIdFormat = "%1 + '-' + %2 + '-' + %3";
    public static const str activityResourceIdStrFormat = "%1-%2-%3";
    public static const str wbsHardLockedCapacityFormula = "%1-(%2-%3)";
    public static const str chartDelimiter = ' - ';
    public static const str collectionItemDataDelimiter = "-";

    // Limit the number of async process allow for ResRollUp records generation
    public static const int numberOfAsyncProcessAllow = 2;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>projectHasWBS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the project has work break down structure.
    /// </summary>
    /// <param name = "_projectId">Project Id.</param>
    /// <returns>Whether the project has WBS.</returns>
    public static boolean projectHasWBS(ProjId _projectId)
    {
        PSASummaryActivity  psaSummaryActivity = new PSASummaryActivity();
        HierarchyTreeTable  hierarchyTreeTable = psaSummaryActivity.isSummaryProject(ProjTable::find(_projectId));
        return HierarchyTreeTable_Extension::psaFindChildElement(
            hierarchyTreeTable.HierarchyId, hierarchyTreeTable.ElementNumber) ?  true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTeamInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update PSAProjSchedRole records for a project according to ResDayCapacityUsageView records.
    /// </summary>
    /// <param name="_activity">
    /// <c>smmActivities</c> table rec Id.
    /// </param>
    /// <remarks>
    /// Update the resource start and end date on ResDayCapacityUsageView according to ResDayCapacityUsageView table for the project.
    /// </remarks>
    public static void updateTeamInfo(ActivityRecId _activity)
    {
        PSAProjSchedRole        psaProjSchedRole;
        ResDayCapacityUsageView resDayCapacityUsageView;
        ProjId                  projectId;
        QuotationId             quotationId;

        PSARSEntityType resEntityType = ActivityFacade::getActivityType(_activity);

        if (resEntityType == PSARSEntityType::Project)
        {
            projectId = ActivityFacade::getProjId(ActivityFacade::getRootProjectActivity(_activity));
        }
        else
        {
            quotationId = ActivityFacade::getQuotationId(ActivityFacade::getRootActivity(_activity));
        }

        ttsbegin;
        //---Update the rest of team memeber start and end date
        while select forUpdate RecId, ProjId, QuotationId from psaProjSchedRole
            where ((resEntityType == PSARSEntityType::Project && psaProjSchedRole.ProjId == projectId)
                    || (resEntityType == PSARSEntityType::Quotation && psaProjSchedRole.QuotationId == quotationId))
        {
            psaProjSchedRole.psaRoleStartDate = ActivityResourceFacade::getEarliestReservationDate(psaProjSchedRole.RecId);
            psaProjSchedRole.psaRoleEndDate   = ActivityResourceFacade::getLatestReservationDate(psaProjSchedRole.RecId);
            psaProjSchedRole.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCapacityAggregationFactor</Name>
				<Source><![CDATA[
    public static real getCapacityAggregationFactor(ResCapacityAggregation _aggregation)
    {
        switch (_aggregation)
        {
            case ResCapacityAggregation::Minute:
                return secondsPerMinute;
            case ResCapacityAggregation::Hour:
                return secondsPerHour;
            case ResCapacityAggregation::Day:
                return secondsPerWorkDay;
            case ResCapacityAggregation::Week:
                return secondsPerWorkWeek;
            default:
                return 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToProjectResourceValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a resource to a project resource validation group.
    /// </summary>
    /// <param name = "_resource">
    /// The <c>ResourceRecId</c> of the resource to add to the validation group.
    /// </param>   
    /// <param name = "_projId">
    /// The project ID for which the resource is added to its validation group.
    /// </param>
    public static void addToProjectResourceValidation(ResourceRecId _resource, ProjId _projId)
    {
        if (_resource && _projId)
        {
            ttsBegin;

            ProjValEmplProjSetup projValEmplProjSetup;
            select firstonly Resource, Projid from projValEmplProjSetup
                where projValEmplProjSetup.Resource == _resource &&
                    projValEmplProjSetup.Projid == _projId;

            if (!projValEmplProjSetup)
            {
                projValEmplProjSetup.Projid = _projId;
                projValEmplProjSetup.Resource = _resource;
                projValEmplProjSetup.insert();
            }

            ttsCommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteFromProjectResourceValidation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes a resource from a project resource validation group.
    /// </summary>
    /// <param name = "_resource">
    /// The <c>ResourceRecId</c> of the resource to be deleted from the validation group.
    /// </param>   
    /// <param name = "_projId">
    /// The project ID for which the resource is a member of.
    /// </param>
    public static void deleteFromProjectResourceValidation(ResourceRecId _resource, ProjId _projId)
    {
        ttsBegin;
        ProjValEmplProjSetup projValEmplProjSetup;
        delete_from projValEmplProjSetup 
            where projValEmplProjSetup.Resource == _resource
                && projValEmplProjSetup.Projid == _projId;
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRecommendedTimeframeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the recommendated timescale using the specified date/time range
    /// </summary>
    /// <param name = "_start">Start date/time</param>
    /// <param name = "_end">End date/time</param>
    /// <returns><c>AVTimeframeType</c> enum value</returns>
    public static AVTimeframeType getRecommendedTimeframeType(utcdatetime _start, utcdatetime _end)
    {
        #TimeConstants
        int64 diffSeconds = DateTimeUtil::getDifference(_end, _start);
        real days = diffSeconds / #secondsPerDay;

        AVTimeframeType timescale;

        if (days < 1)
        {
            if (PSAParameters::find().EnableHourScheduling)
            {
                timescale = AVTimeframeType::Hour;
            }
            else
            {
                timescale = AVTimeframeType::Day;
            }
        }
        else if (days < #daysPerWeek * 2)
        {
            timescale = AVTimeframeType::Day;
        }
        else if (days < #daysPerWeek * 10)
        {
            timescale = AVTimeframeType::Week;
        }
        else if (days < #daysPerMonth * 5)
        {
            timescale = AVTimeframeType::Month;
        }
        else if (days < #daysPerMonth * 12)
        {
            timescale = AVTimeframeType::Quarter;
        }
        else
        {
            timescale = AVTimeframeType::HalfYear;
        }

        return timescale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectSchedulingDuration</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of duration days from the project scheduling start and end dates for the specific calendar.
    /// </summary>
    /// <param name="_schedulingStartDate">
    ///  The start date.
    /// </param>
    /// <param name="_schedulingEndDate">
    /// The end date.
    /// </param>
    /// <param name="_calendarId">
    /// The ID of the calendar to use.
    /// </param>
    /// <returns>
    /// The number of project scheduling duration days.
    /// </returns>
    public static Days getProjectSchedulingDuration(    TransDate _schedulingStartDate,
                                                        TransDate _schedulingEndDate,
                                                        CalendarId _calendarId)
    {
        Days schedulingDuration;

        if (_calendarId)
        {
            schedulingDuration = WorkCalendarCalculator::calcDuration(_schedulingStartDate,
                _schedulingEndDate, _calendarId);
        }
        else
        {
            schedulingDuration = _schedulingEndDate - _schedulingStartDate + 1;
        }
        return schedulingDuration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCompanyResourceFromActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the specified activity resource identifier is a company resource.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource identifier.</param>
    /// <returns>true when the specified activity resource identifier is a company resource; otherwise, false.</returns>
    public static boolean isCompanyResourceFromActivityResourceId(ActivityResourceId _activityResourceId)
    {
        int resourcesLength = strLen(_activityResourceId);
        boolean isPlannedResource = ResUtil::isPlannedResourceFromActivityResourceId(_activityResourceId);
        return !isPlannedResource && strScan(_activityResourceId, '-0', 1, resourcesLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPlannedResourceFromActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the specified activity resource identifier is a planned resource.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource identifier.</param>
    /// <returns>true when the specified activity resource identifier is a planned resource; otherwise, false.</returns>
    public static boolean isPlannedResourceFromActivityResourceId(ActivityResourceId _activityResourceId)
    {
        int resourcesLength = strLen(_activityResourceId);
        return strScan(_activityResourceId, '-0-', 1, resourcesLength);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNamedResourceFromActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the specified activity resource identifier is a named resource.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource identifier.</param>
    /// <returns>true when the specified activity resource identifier is neither a planned or company resource; otherwise, false.</returns>
    public static boolean isNamedResourceFromActivityResourceId(ActivityResourceId _activityResourceId)
    {
        return (ResUtil::isCompanyResourceFromActivityResourceId(_activityResourceId) ||
            ResUtil::isPlannedResourceFromActivityResourceId(_activityResourceId)) ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the activity rec id from the specified activity resource identifier.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource identifier.</param>
    /// <returns>Resource record rec Id.</returns>
    public static ActivityRecId getActivityRecId(ActivityResourceId _activityResourceId)
    {
        container keys = str2con(_activityResourceId, ResUtil::collectionItemDataDelimiter);
        return str2Int64(conPeek(keys, 1));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the resource record identifier from the specified activity resource identifier.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource identifier.</param>
    /// <returns>Resource record rec Id.</returns>
    public static ResourceRecId getResourceRecId(ActivityResourceId _activityResourceId)
    {
        container keys = str2con(_activityResourceId, ResUtil::collectionItemDataDelimiter);
        return str2Int64(conPeek(keys, 2));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityResourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the activity resource record rec id from the specified activity resource identifier.
    /// </summary>
    /// <param name = "_activityResourceId">Activity resource identifier.</param>
    /// <returns>Activity Resource record rec Id.</returns>
    public static ActivityResourceRecId getActivityResourceRecId(ActivityResourceId _activityResourceId)
    {
        container keys = str2con(_activityResourceId, ResUtil::collectionItemDataDelimiter);
        return str2Int64(conPeek(keys, 3));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the company activity resource id from resource record ID.
    /// </summary>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <returns>Company activity resource ID.</returns>
    public static ActivityResourceId getCompanyActivityResourceId(ResourceRecId _resourceRecId)
    {
        return strFmt(ResUtil::activityResourceIdStrFormat, 0, int642Str(_resourceRecId), 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRollUpByResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update roll-up table records by resourc record ID.
    /// </summary>
    /// <param name = "_resource">The specified resource record ID.</param>
    /// <param name = "_start">The specified start date time.</param>
    /// <param name = "_end">The specified end time.</param>
    /// <param name = "_updateRollUpAsync">Update <c>ResRollUp</c> table in async.</param>
    public static void updateRollUpByResource(ResourceRecId _resource, utcdatetime _start, 
        utcdatetime _end, boolean _updateRollUpAsync = true)
    {
        if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
        {
            utcdatetime start = AVTimeframe::getTimeframe(_start, AVTimeframeType::Month).start();
            utcdatetime end = AVTimeframe::getTimeframe(_end, AVTimeframeType::Month).end();

            if (_updateRollUpAsync)
            {
                container arguments = [_resource, start, end];
                Global::runAsync(classNum(ResRollUpWriter),
                    staticMethodStr(ResRollUpWriter, setupRollUpForNewResourceAsync), arguments);
            }
            else
            {
                ResRollUpWriter::setupRollUpForNewResource(_resource, start, end);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEnableHourSchedulingSetting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get enable hour scheduling setting.
    /// </summary>
    /// <returns>Whether enable hour scheduling setting is set to true or false.</returns>
    public static boolean getEnableHourSchedulingSetting()
    {
        NoYes enableHourScheduling = PSAParameters::find().EnableHourScheduling;
        return enableHourScheduling == NoYes::Yes ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSchedulesCollectionDateRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get each schedule earliest and latest dates by the specified <c>ResReservationSchedule</c> list
    /// and output the dates to <c>ResTmpRollUpResource</c> temp table.
    /// </summary>
    /// <param name = "_schedules">List of <c>ResReservationSchedule</c> class.</param>
    /// <param name = "_tmpRollUp"><c>ResTmpRollUpResource</c> temp table for storing scheduling results.</param>
    /// <param name = "_processRollUpByAssignmentRequest">
    /// The temp table values generation constraint by <c>ResReservationSchedule</c> class
    /// boolean parameter processRollUpByAssignmentRequest() value.
    /// </param>
    /// <returns>true if <c>ResTmpRollUpResource</c> temp table contains data; otherwise, false</returns>
    public static boolean getSchedulesCollectionDateRanges(List _schedules, ResTmpRollUpResource _tmpRollUp, boolean _processRollUpByAssignmentRequest = false)
    {
        // Consolidate activity resource ID with the smallest and largest dates.
        List updateRollUpResource = new List(Types::Class);

        if (_schedules)
        {
            Enumerator enumerator = _schedules.getEnumerator();
            ttsbegin;
            while (enumerator.moveNext())
            {
                ResReservationSchedule schedule = enumerator.current();

                if (schedule.parmProcessRollUpByAssignmentRequest() == _processRollUpByAssignmentRequest)
                {
                    utcdatetime startTime = schedule.start();
                    utcdatetime endTime = schedule.end();
                    ActivityRecId activity = schedule.activity();
                    boolean isResourceATeamMember = schedule.parmIsExistingTeamMember();

                    // If the dates are not specified in the schedule, get it from the roll up table.
                    if (startTime == DateTimeUtil::minValue())
                    {
                        startTime = ResUtil::getRollupStartTimeFromRollupTable(schedule);
                    }

                    if (endTime == DateTimeUtil::maxValue())
                    {
                        endTime = ResUtil::getRollupEndTimeFromRollupTable(schedule);

                        // If no date is found, set it back to max value.
                        endTime = (endTime == DateTimeUtil::minValue()) ? DateTimeUtil::maxValue() : endTime;
                    }

                    if (startTime != DateTimeUtil::minValue() && endTime != DateTimeUtil::maxValue())
                    {
                        // In the case of cancellation operation, the activity and activity reosurce will not be specified.
                        if (!ResUtil::isPerformanceEnhancementFeatureEnabled() && !schedule.activity() && !schedule.activityResource())
                        {
                            if (schedule.resource())
                            {
                                ResRollUp resourceRollUp;

                                while select CollectionKey from resourceRollUp
                                group by CollectionKey
                                    where resourceRollUp.Resource == schedule.resource()
                                        && resourceRollUp.Timeframe >= startTime
                                        && resourceRollUp.Timeframe <= endTime
                                {
                                    ResourceRecId resource = ResUtil::getResourceRecId(resourceRollUp.CollectionKey);

                                    ResUtil::insertOrUpdateTempRollupTableByActivityResourceId(_tmpRollUp,
                                        activity, resource, resourceRollUp.CollectionKey, startTime, endTime, isResourceATeamMember,
                                        schedule.commitment(), schedule.reservationType());
                                }
                            }
                        }
                        else
                        {
                            ResActivityResourceId activityResourceId = schedule.getActivityResourceId();
                            ResourceRecId resource = ResUtil::getResourceRecId(schedule.getActivityResourceId());

                            ResUtil::insertOrUpdateTempRollupTableByActivityResourceId(_tmpRollUp,
                                activity, resource , activityResourceId, startTime, endTime, isResourceATeamMember,
                                schedule.commitment(), schedule.reservationType());
                        }
                    }
                }
            }
            ttscommit;
        }

        return _tmpRollUp ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRollupStartTimeFromRollupTable</Name>
				<Source><![CDATA[
    private static utcdatetime getRollupStartTimeFromRollupTable(ResReservationSchedule _schedule)
    {
        ResRollUp   rollUp;
        utcdatetime startTime;

        // Cancellation and confirmation operations allow user
        // to not sepcified start time. Hence look up the roll up start
        // time can from tje existing roll up records.
        if (_schedule.activityResource())
        {
            select minof(Timeframe) from rollUp
                group by ActivityResource
                where rollUp.ActivityResource == _schedule.activityResource()
                    && rollUp.Coverage == ResRollupCoverage::Activity
                    && (rollUp.HardLocked != 0 || rollUp.SoftLocked != 0);
        }       
        else if (_schedule.resource())
        {
            select minof(Timeframe) from rollUp
                group by Resource
                where rollUp.Resource == _schedule.resource()
                    && rollUp.Coverage == ResRollupCoverage::Activity
                    && (rollUp.HardLocked != 0 || rollUp.SoftLocked != 0);
        }

        if (rollUp)
        {
            startTime = rollUp.Timeframe;
        }

        return startTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRollupEndTimeFromRollupTable</Name>
				<Source><![CDATA[
    private static utcdatetime getRollupEndTimeFromRollupTable(ResReservationSchedule _schedule)
    {
        ResRollUp   rollUp;
        utcdatetime endTime;

        // Cancellation and confirmation operations allow user
        // to not sepcified end time. Hence look up the roll up start
        // time can from tje existing roll up records.
        if (_schedule.activityResource())
        {
            select maxof(Timeframe) from rollUp
                group by ActivityResource
                where rollUp.ActivityResource == _schedule.activityResource()
                    && rollUp.Coverage == ResRollupCoverage::Activity
                    && (rollUp.HardLocked != 0 || rollUp.SoftLocked != 0);
        }        
        else if (_schedule.resource())
        {
            select maxof(Timeframe) from rollUp
                group by Resource
                where rollUp.Resource == _schedule.resource()
                    && rollUp.Coverage == ResRollupCoverage::Activity
                    && (rollUp.HardLocked != 0 || rollUp.SoftLocked != 0);
        }

        if (rollUp)
        {
            endTime = rollUp.Timeframe;
        }

        return endTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOrUpdateTempRollupTableByActivityResourceId</Name>
				<Source><![CDATA[
    private static void insertOrUpdateTempRollupTableByActivityResourceId(ResTmpRollUpResource _tmpRollUp,
        ActivityRecId _activity, ResourceRecId _resource, ResActivityResourceId _activityResourceId,
        utcDateTime _startTime, utcDateTime _endTime, boolean _isResourceATeamMember,
        ResCommitType _commitType, ResReservationType _reservationType)
    {
        select firstonly forupdate Start, End from _tmpRollUp
            where _tmpRollUp.ActivityResourceId == _activityResourceId;

        if (_tmpRollUp)
        {
            if (_tmpRollUp.Start > _startTime)
            {
                _tmpRollUp.Start = _startTime;
            }
            if (_tmpRollUp.End < _endTime)
            {
                _tmpRollUp.End = _endTime;
            }
            _tmpRollUp.update();
        }
        else
        {
            _tmpRollUp.Activity = _activity;
            _tmpRollUp.Resource = _resource;
            _tmpRollUp.ActivityResourceId = _activityResourceId;
            _tmpRollUp.Start = _startTime;
            _tmpRollUp.End = _endTime;
            _tmpRollUp.CommitType = _commitType;
            _tmpRollUp.ReservationType = _reservationType;
            _tmpRollUp.IsResourceATeamMember = _isResourceATeamMember ? NoYes::Yes : NoYes::No;
            _tmpRollUp.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBookingHoursFromAssignmentHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add Booking hours to back up the existing assignment hours.
    /// </summary>
    /// <param name = "_activity"><c>smmActivities</c> record ID for the WBS task.</param>
    /// <param name = "_activityResource"><c>PSAProjSchedRole</c> record ID.</param>
    /// <param name = "_start">Assignment start date time.</param>
    /// <param name = "_end">Assignment end date time.</param>
    /// <param name = "_commitType">Assignment commit type.</param>
    public static void addBookingHoursFromAssignmentHours(ActivityRecId _activity,
        activityresourcerecid _activityResource, utcdatetime _start, utcdatetime _end, ResCommitType _commitType = ResCommitType::HardBook)
    {
        ActivityRecId targetRootActivity = ActivityFacade::getRootActivity(_activity);
        ResBooking resBooking;        
        ResUtil::skipDatabaseLogAndEvent(resBooking);

        // Add assignment records should be back up by booking records. Insert booking records if they are missing.

        ResAssignment resAssignment;
        ResBooking existsBooking;

        ttsbegin;
        insert_recordset resBooking(ActivityResource, Activity, CommitType,
                Start, End, Hour, Day, Week, Month, Quarter, HalfYear)
            select ActivityResource, targetRootActivity, CommitType,
                Start, End, Hour, Day, Week, Month, Quarter, HalfYear
            from resAssignment
            where resAssignment.ActivityResource == _activityResource
                && resAssignment.CommitType == _commitType
                && resAssignment.Hour >= _start
                && resAssignment.Hour <= _end
            notexists join existsBooking
            where existsBooking.ActivityResource == resAssignment.ActivityResource
                && existsBooking.CommitType == resAssignment.CommitType
                && existsBooking.Hour == resAssignment.Hour;

        // Even the booking record exists, it may not have the right capacity. Hence verify if the booking record for the assignment hour exists and 
        // has at leat equal or more than the assignment record. If not, insert booking record for the differenc of the total assignment capacity 
        // minus total booking capacity for that hour. This value can be found in ResAssignmentBookingCapacityDifferenceView.CapacityDifference.
        // Note: It seems X++ does not support insert_recordset select values from a view only. Hence, the select from an actual table
        // then join to a view is necessary.
        
        Qty startSeconds = 0;
        ResAssignmentBookingCapacityDifferenceView capacityDifferenceView;

        insert_recordset resBooking(ActivityResource, Activity, CommitType,
                Hour, Day, Week, Month, Quarter, HalfYear, Start, End)
            select ActivityResource, targetRootActivity, CommitType,
                Hour, Day, Week, Month, Quarter, HalfYear, startSeconds
            from resAssignment
            group by resAssignment.ActivityResource, ResAssignment.CommitType, resAssignment.Hour, resAssignment.Day, resAssignment.Week, 
                resAssignment.Month, resAssignment.Quarter, resAssignment.HalfYear, capacityDifferenceView.CapacityDifference
            where resAssignment.ActivityResource == _activityResource
                && resAssignment.CommitType == _commitType
                && resAssignment.Hour >= _start
                && resAssignment.Hour <= _end
            join CapacityDifference from capacityDifferenceView
            where capacityDifferenceView.ActivityResource == _activityResource
                && capacityDifferenceView.CommitType == _commitType
                && capacityDifferenceView.Hour == resAssignment.Hour
                && capacityDifferenceView.CapacityDifference > 0;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRollupCalendarTimeFrameRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if <c>ResRollupCalendar</c> table TimeFrame field has sufficient range to support the specified date time range.
    /// If it does not, a No/Yes message box will be pop up to asks user if they allow the system to generate the resource roll up data on the fly.
    /// If user choose no, the specified form will be closed and data will not be generated.
    /// </summary>
    /// <param name = "_startDateTime">Start date time range.</param>
    /// <param name = "_endDateTime">End date time range.</param>
    /// <param name = "_form">Caller <c>FormRun</c> object.</param>
    /// <param name = "_extendRollUpDateRange">Whether to extend the start and end dates if roll up data is needed to be generated.</param>
    /// <param name = "_noConfirmation">No pop up confirmation will be launched and resource roll up data will be generated on the fly if insufficient is detected.</param>
    /// <returns>true if <c>ResRollupCalendar</c> table TimeFrame has sufficient range to support the specified date time range; else false.</returns>
    public static boolean validateRollupCalendarTimeFrameRange(utcdatetime _startDateTime, utcdatetime _endDateTime, 
        boolean _extendRollUpDateRange = true, FormRun _form = null, boolean _noConfirmation = false)
    {
        boolean valid = true;

        if (!ResUtil::isPerformanceEnhancementFeatureEnabled(ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()))
        {
            ResRollupCalendarShared resRollupCalendar;

            select maxof(TimeFrame) from resRollupCalendar
            where resRollupCalendar.Timescale == AVTimeframeType::Day;
            utcdatetime maxCalendar = resRollupCalendar.TimeFrame;

            select minof(TimeFrame) from resRollupCalendar
            where resRollupCalendar.Timescale == AVTimeframeType::Day;
            utcdatetime minCalendar = resRollupCalendar.TimeFrame;

            date startDate = DateTimeUtil::date(_startDateTime);
            date endDate = DateTimeUtil::date(_endDateTime);

            boolean hasSufficientCalendarRecords = (
                minCalendar <= DateTimeUtil::newDateTime(startDate, 0)
                && maxCalendar >= DateTimeUtil::newDateTime(endDate, 0)) ? true : false;

            if (!hasSufficientCalendarRecords)
            {
                utcdatetime startDateTime = _startDateTime;
                utcdatetime endDateTime = _endDateTime;

                str startDateStr, endDateStr;

                if (_noConfirmation || Box::yesNo(strFmt("@Res:InsufficientCalendarRollUpRecordsRange",
                date2StrUsr(startDate, DateFlags::FormatAll),
                date2StrUsr(endDate, DateFlags::FormatAll))
                , DialogButton::No) == DialogButton::Yes)
                {
                    if (_extendRollUpDateRange)
                    {
                        const int daysInAMonth = 30;
                        const int numMonthsEarlier = 2;
                        const int numMonthsLater = 6;

                        // Extend 2 months earlier and 6 months later from the original requested date range
                        startDate = dateStartMth(startDate - (numMonthsEarlier * daysInAMonth));
                        endDate = dateEndMth(endDate + (numMonthsEarlier * daysInAMonth));

                        startDateTime = DateTimeUtil::newDateTime(startDate, 0);
                        endDateTime = DateTimeUtil::newDateTime(endDate, #LastSecondOfTheDay);
                    }

                    startDateStr = date2StrUsr(startDate, DateFlags::FormatAll);
                    endDateStr = date2StrUsr(endDate, DateFlags::FormatAll);

                    ApplicationEventSource::EventWriteResGenerateRollupStart(startDateStr, endDateStr);

                    ResRollUpWriter::updateRollUpForAllResources(startDateTime, endDateTime);

                    ApplicationEventSource::EventWriteResGenerateRollupStop(startDateStr, endDateStr);
                }
                else
                {
                    valid = false;

                    startDateStr = date2StrUsr(startDate, DateFlags::FormatAll);
                    endDateStr = date2StrUsr(endDate, DateFlags::FormatAll);

                    if (_form)
                    {
                        _form.close();
                    }
                }

                ApplicationEventSource::EventWriteResMissingRollupData(valid, startDateStr, endDateStr);
            }
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousDateTimeByTimeScale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the previous date time by time scale.
    /// </summary>
    /// <param name = "_timeframe">Specific time frame.</param>
    /// <param name = "_timeScale">Specific time scale.</param>
    /// <returns>The previous time frame by time scale.</returns>
    public static utcdatetime getPreviousDateTimeByTimeScale(utcdatetime _timeframe, AVTimeframeType _timeScale)
    {
        utcdatetime timeframe;

        switch (_timeScale)
        {
            case AVTimeframeType::Hour:
                timeframe = DateTimeUtil::addHours(_timeframe,  (0 - 1));
                break;
            case AVTimeframeType::Day:
                timeframe = DateTimeUtil::addDays(_timeframe, -1);
                break;
            case AVTimeframeType::Week:
                timeframe = DateTimeUtil::addDays(_timeframe, (0 - #daysPerWeek));
                break;
            case AVTimeframeType::Month:
                timeframe = DateTimeUtil::addMonths(_timeframe, -1);
                break;
            case AVTimeframeType::Quarter:
                timeframe = DateTimeUtil::addMonths(_timeframe, (0 - #monthsPerQuarter));
                break;
            case AVTimeframeType::HalfYear:
                timeframe = DateTimeUtil::addMonths(_timeframe, -6);
                break;
        }

        return timeframe;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextDateTimeByTimeScale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the next date time by time scale.
    /// </summary>
    /// <param name = "_timeframe">Specific time frame.</param>
    /// <param name = "_timeScale">Specific time scale.</param>
    /// <returns>The next time frame by time scale.</returns>
    public static utcdatetime getNextDateTimeByTimeScale(utcdatetime _timeframe, AVTimeframeType _timeScale)
    {
        utcdatetime timeframe;

        switch (_timeScale)
        {
            case AVTimeframeType::Hour:
                timeframe = DateTimeUtil::addHours(_timeframe,  1);
                break;
            case AVTimeframeType::Day:
                timeframe = DateTimeUtil::addDays(_timeframe, 1);
                break;
            case AVTimeframeType::Week:
                timeframe = DateTimeUtil::addDays(_timeframe, #daysPerWeek);
                break;
            case AVTimeframeType::Month:
                timeframe = DateTimeUtil::addMonths(_timeframe, 1);
                break;
            case AVTimeframeType::Quarter:
                timeframe = DateTimeUtil::addMonths(_timeframe, #monthsPerQuarter);
                break;
            case AVTimeframeType::HalfYear:
                timeframe = DateTimeUtil::addMonths(_timeframe, 6);
                break;
        }

        return timeframe;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPerformanceEnhancementFeatureEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the resource performance enhancement feature <c>ResPerformanceEnhancementFeature</c> is enabled.
    /// </summary>
    /// <param name = "_validateDataMigration">If the feature is enabled, it detmines whether the validation of data migration logic should be executed.</param>
    /// <returns>
    /// true if the <c>ResPerformanceEnhancementFeature</c> is enabled.
    /// </returns>
    /// <remarks>
    /// In the future, when <c>ResPerformanceEnhancementFeature</c> will be removed, this method should be obsolete altogether.
    /// </remarks>
    [Hookable(false), Wrappable(false)]
    public static boolean isPerformanceEnhancementFeatureEnabled(boolean _validateDataMigration = false)
    {
        boolean isEnabled = FeatureStateProvider::isFeatureEnabled(ResPerformanceEnhancementFeature::instance());

        if (isEnabled && _validateDataMigration)
        {
            ProjParameters projParameters = ProjParameters::find();

            if (projParameters)
            {
                if (ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled()) 
                {
                    if (projParameters.ResPerfDataUpgradeStatus == ProjDataUpgradeStatus::InProgress)
                    {
                        throw Error("@Res:PopulateProjectResourcesInProgressWarning");
                    }
                    else if (projParameters.ResPerfDataUpgradeStatus == ProjDataUpgradeStatus::NotUpgraded)
                    {
                        isEnabled = false;
                    }
                }
                else if (projParameters.ResPerfDataUpgradeStatus == ProjDataUpgradeStatus::NotUpgraded)
                {
                    throw Error("@Res:MissingProjectResourceData");
                }
            }
        }

        return isEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateResPerfDataUpgradeStatus</Name>
				<Source><![CDATA[
    [Hookable(false), Wrappable(false)]
    public static void validateResPerfDataUpgradeStatus()
    {
        if (ResEnableByDefaultPerfEnhancementFeatureFlight::instance().isEnabled())
        {
            ProjParameters projParameters = ProjParameters::find();
            
            if (projParameters && projParameters.ResPerfDataUpgradeStatus == ProjDataUpgradeStatus::InProgress)
            {
                warning("@Res:PopulateProjectResourcesInProgressWarning");
            }
            else if (projParameters.ResPerfDataUpgradeStatus == ProjDataUpgradeStatus::NotUpgraded)
            {
                warning("@Res:PopulateProjectResourcesNotUpgradedWarning");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCalendarCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get calendar capacity in seconds.
    /// </summary>
    /// <param name = "_calendarRecId">Calendar record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <returns>Calendar capacity in seconds.</returns>
    [Hookable(false), Wrappable(false)]
    public static real getCalendarCapacity(CalendarRecId _calendarRecId, utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResCalendarCapacityView calendarCapacityView;

        select sum(Capacity) from calendarCapacityView
            where calendarCapacityView.Hour >= _startDateTime &&
                calendarCapacityView.Hour <= _endDateTime &&
                calendarCapacityView.Calendar == _calendarRecId;
                
        return calendarCapacityView.Capacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfWorkingDaysByCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get number of working days for the specified resource.
    /// </summary>
    /// <param name = "_calendarRecId">Calendar record ID.</param>
    /// <param name = "_startDateTime">Start date time.</param>
    /// <param name = "_endDateTime">End date time.</param>
    /// <returns>Number of working days.</returns>
    [Hookable(false), Wrappable(false)]
    public static int getNumberOfWorkingDaysByCalendar(CalendarRecId _calendarRecId, utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResCalendarCapacityDayView calendarCapacityDayView;
            
        select count(RecId) from calendarCapacityDayView
            where calendarCapacityDayView.Day >= _startDateTime &&
                calendarCapacityDayView.Day <= _endDateTime &&
                calendarCapacityDayView.Calendar == _calendarRecId &&
                calendarCapacityDayView.Capacity > 0;

        return int642int(calendarCapacityDayView.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWorkingDayMapByActivityResourceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update working day map by activity resource ID. This map should contains date as key and values as enum NoYes to represent whether that day has capacity day.
    /// </summary>
    /// <param name = "_workingDayMap">User specify working day map with a definition of (Types::Date, Types::Enum) with NoYes as enum.</param>
    /// <param name = "_activityResourceId">Activity resource ID value which equivalent to table field CollectionKey value.</param>
    /// <param name = "_startDateTime">Start date time value which equivalent to table field Timeframe value.</param>
    /// <param name = "_endDateTime">End date time value which equivalent to table field Timeframe value.</param>
    /// <remarks>It will update the map with NoYes::Yes to represent working day and NoYes::No to represent not a working day.</remarks>
    internal static void updateWorkingDayMapByActivityResourceId(Map _workingDayMap, ActivityResourceId _activityResourceId, utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResRollup resRollup;

        if (_activityResourceId)
        {
            ResourceRecId resource = ResUtil::getResourceRecId(_activityResourceId);
            ActivityResourcerecId activityResource = ResUtil::getActivityResourceRecId(_activityResourceId);

            boolean missingDate = false;
            date startWorkingDate = DateTimeUtil::date(_startDateTime);
            date endWorkingDate = DateTimeUtil::date(_endDateTime);
            date tempWorkingDate = startWorkingDate;

            // Only access table if the map is missing date.
            while (endWorkingDate >= tempWorkingDate)
            {
                if (!_workingDayMap.exists(tempWorkingDate))
                {
                    missingDate = true;
                    break;
                }
                tempWorkingDate++;
            }

            if (missingDate)
            {
                if (resource)
                {
                    ResUtil::insertWorkingDayMapIfMissingByResource(_workingDayMap, resource, _startDateTime, _endDateTime);
                }
                else if (activityResource)
                {
                    CalendarRecId calendar = ActivityResourceFacade::getCalendar(activityResource);
                    ResUtil::insertWorkingDayMapIfMissingByCalendar(_workingDayMap, calendar, _startDateTime, _endDateTime);
                }

                // Set the rest of date as not a working date.
                tempWorkingDate = startWorkingDate;
                while (endWorkingDate >= tempWorkingDate)
                {
                    if (!_workingDayMap.exists(tempWorkingDate))
                    {
                        _workingDayMap.insert(tempWorkingDate, NoYes::No);
                    }
                    tempWorkingDate++;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkingDayMapIfMissingByResource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert working day to working day map by resource record ID.
    /// </summary>
    /// <param name = "_workingDayMap">User specify working day map with a definition of (Types::Date, Types::Enum) with NoYes as enum.</param>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <param name = "_startDateTime">Start date time value which equivalent to table field Timeframe value.</param>
    /// <param name = "_endDateTime">End date time value which equivalent to table field Timeframe value.</param>
    /// <remarks>It will update the map with NoYes::Yes to represent working day.</remarks>
    private static void insertWorkingDayMapIfMissingByResource(Map _workingDayMap, ResourceRecId _resourceRecId, utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        if (ResUtil::isPerformanceEnhancementFeatureEnabled(true))
        {
            ResCalendarCapacityDayView calendarCapacityDayView;
            ResCalendarDateTimeRange calendarDateTimeRange;
            ResProjectResource projectResource;
            
            while select Day from calendarCapacityDayView
                where calendarCapacityDayView.Day >= _startDateTime &&
                    calendarCapacityDayView.Day <= _endDateTime &&
                    calendarCapacityDayView.Capacity != 0
            exists join calendarDateTimeRange
                where calendarDateTimeRange.Calendar == calendarCapacityDayView.Calendar &&
                    calendarDateTimeRange.ValidFromDateTime < calendarCapacityDayView.Day &&
                    calendarDateTimeRange.ValidToDateTime > calendarCapacityDayView.Day
            exists join projectResource
                where projectResource.Resource == calendarDateTimeRange.Resource &&
                    projectResource.RecipientCompany == projectResource.SourceCompany &&
                    projectResource.Resource == _resourceRecId
            {
                _workingDayMap.insert(DateTimeUtil::date(calendarCapacityDayView.Day), NoYes::Yes);
            }
        }
        else
        {
            ResCalendarCapacityDayView calendarCapacityDayView;
            ResourceLegalEntityView resourceLegalEntityView;
            
            while select Day from calendarCapacityDayView
                where calendarCapacityDayView.Day >= _startDateTime &&
                    calendarCapacityDayView.Day <= _endDateTime &&
                    calendarCapacityDayView.Capacity != 0
            exists join resourceLegalEntityView
                where resourceLegalEntityView.Calendar == calendarCapacityDayView.Calendar &&
                    resourceLegalEntityView.CalendarValidFrom < calendarCapacityDayView.Day &&
                    resourceLegalEntityView.CalendarValidTo > calendarCapacityDayView.Day &&
                    resourceLegalEntityView.Resource == _resourceRecId
            {
                _workingDayMap.insert(DateTimeUtil::date(calendarCapacityDayView.Day), NoYes::Yes);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWorkingDayMapIfMissingByCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert working day to working day map by calendar record ID.
    /// </summary>
    /// <param name = "_workingDayMap">User specify working day map with a definition of (Types::Date, Types::Enum) with NoYes as enum.</param>
    /// <param name = "_calendarRecId">Calendar record ID.</param>
    /// <param name = "_startDateTime">Start date time value which equivalent to table field Timeframe value.</param>
    /// <param name = "_endDateTime">End date time value which equivalent to table field Timeframe value.</param>
    /// <remarks>It will update the map with NoYes::Yes to represent working day.</remarks>
    private static void insertWorkingDayMapIfMissingByCalendar(Map _workingDayMap, CalendarRecId _calendarRecId, utcdatetime _startDateTime, utcdatetime _endDateTime)
    {
        ResCalendarCapacityDayView calendarCapacityDayView;
            
        while select Day from calendarCapacityDayView
            where calendarCapacityDayView.Day >= _startDateTime &&
                calendarCapacityDayView.Day <= _endDateTime &&
                calendarCapacityDayView.Calendar == _calendarRecId &&
                calendarCapacityDayView.Capacity != 0
        {
            _workingDayMap.insert(DateTimeUtil::date(calendarCapacityDayView.Day), NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailabilityScheduledCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get resource scheduled capacity in seconds for the <c>ResRollUpCoverage</c> of type Availability.
    /// </summary>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <param name = "_timeframe">Target date.</param>
    /// <param name = "_timeScale">Time scale type.</param>
    /// <returns>Scheduled capacity in seconds.</returns>
    public static real getAvailabilityScheduledCapacity(ResourceRecId _resourceRecId, utcdatetime _timeframe, AVTimeframeType _timeScale)
    {
        ResBookingView bookingView;
        PSAProjSchedRole teamTable;

        switch (_timeScale)
        {
            case (AVTimeframeType::Hour):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Hour
                    where bookingView.Hour == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook
                exists join teamTable
                    where teamTable.Resource == _resourceRecId &&
                        teamTable.RecId == bookingView.ActivityResource;
                break;
            case (AVTimeframeType::Day):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Day
                    where bookingView.Day == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook
                exists join teamTable
                    where teamTable.Resource == _resourceRecId &&
                        teamTable.RecId == bookingView.ActivityResource;
                break;
            case (AVTimeframeType::Week):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Week
                    where bookingView.Week == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook
                exists join teamTable
                    where teamTable.Resource == _resourceRecId &&
                        teamTable.RecId == bookingView.ActivityResource;
                break;
            case (AVTimeframeType::Month):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Month
                    where bookingView.Month == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook
                exists join teamTable
                    where teamTable.Resource == _resourceRecId &&
                        teamTable.RecId == bookingView.ActivityResource;
                break;
            case (AVTimeframeType::Quarter):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Quarter
                    where bookingView.Quarter == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook
                exists join teamTable
                    where teamTable.Resource == _resourceRecId &&
                        teamTable.RecId == bookingView.ActivityResource;
                break;
            case (AVTimeframeType::HalfYear):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.HalfYear
                    where bookingView.HalfYear == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook
                exists join teamTable
                    where teamTable.Resource == _resourceRecId &&
                        teamTable.RecId == bookingView.ActivityResource;
                break;
        }
        return bookingView.Capacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityScheduledCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get activity resource scheduled capacity in seconds for the <c>ResRollUpCoverage</c> of type Activity.
    /// </summary>
    /// <param name = "_activityResourceRecId">Activity record ID.</param>
    /// <param name = "_timeframe">Target date.</param>
    /// <param name = "_timeScale">Time scale type.</param>
    /// <returns>Scheduled capacity in seconds.</returns>
    public static real getActivityScheduledCapacity(ActivityResourceRecId _activityResourceRecId, utcdatetime _timeframe, AVTimeframeType _timeScale)
    {
        ResBookingView bookingView;
        
        switch (_timeScale)
        {
            case (AVTimeframeType::Hour):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Hour
                    where bookingView.Hour == _timeframe && 
                        bookingView.CommitType == ResCommitType::HardBook &&
                        bookingView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Day):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Day
                    where bookingView.Day == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook &&
                        bookingView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Week):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Week
                    where bookingView.Week == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook &&
                        bookingView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Month):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Month
                    where bookingView.Month == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook &&
                        bookingView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Quarter):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.Quarter
                    where bookingView.Quarter == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook &&
                        bookingView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::HalfYear):
                select crosscompany sum(Capacity) from bookingView
                    group by bookingView.HalfYear
                    where bookingView.HalfYear == _timeframe &&
                        bookingView.CommitType == ResCommitType::HardBook &&
                        bookingView.ActivityResource == _activityResourceRecId;
                break;
        }

        return bookingView.Capacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssignmentScheduledCapacity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get activity resource scheduled capacity in seconds for the <c>ResRollUpCoverage</c> of type Assignment.
    /// </summary>
    /// <param name = "_resourceRecId">Resource record ID.</param>
    /// <param name = "_activityResourceRecId">Activity record ID.</param>
    /// <param name = "_timeframe">Target date.</param>
    /// <param name = "_timeScale">Time scale type.</param>
    /// <returns>Scheduled capacity in seconds.</returns>
    public static real getAssignmentScheduledCapacity(ResourceRecId _resourceRecId, ActivityResourceRecId _activityResourceRecId, utcdatetime _timeframe, AVTimeframeType _timeScale)
    {
        real usedCapacity = ResUtil::getAvailabilityScheduledCapacity(_resourceRecId, _timeframe, _timeScale) - ResUtil::getActivityScheduledCapacity(_activityResourceRecId, _timeframe, _timeScale);
        ResAssignmentView assignmentView;
        
        switch (_timeScale)
        {
            case (AVTimeframeType::Hour):
                select sum(Capacity) from assignmentView
                    group by assignmentView.Hour
                    where assignmentView.Hour == _timeframe && 
                        assignmentView.CommitType == ResCommitType::HardBook &&
                        assignmentView.ActivityResource == _activityResourceRecId;
                break;

            case (AVTimeframeType::Day):
                select sum(Capacity) from assignmentView
                    group by assignmentView.Day
                    where assignmentView.Day == _timeframe &&
                        assignmentView.CommitType == ResCommitType::HardBook &&
                        assignmentView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Week):
                select sum(Capacity) from assignmentView
                    group by assignmentView.Week
                    where assignmentView.Week == _timeframe &&
                        assignmentView.CommitType == ResCommitType::HardBook &&
                        assignmentView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Month):
                select sum(Capacity) from assignmentView
                    group by assignmentView.Month
                    where assignmentView.Month == _timeframe &&
                        assignmentView.CommitType == ResCommitType::HardBook &&
                        assignmentView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::Quarter):
                select sum(Capacity) from assignmentView
                    group by assignmentView.Quarter
                    where assignmentView.Quarter == _timeframe &&
                        assignmentView.CommitType == ResCommitType::HardBook &&
                        assignmentView.ActivityResource == _activityResourceRecId;
                break;
            case (AVTimeframeType::HalfYear):
                select sum(Capacity) from assignmentView
                    group by assignmentView.HalfYear
                    where assignmentView.HalfYear == _timeframe &&
                        assignmentView.CommitType == ResCommitType::HardBook &&
                        assignmentView.ActivityResource == _activityResourceRecId;
                break;
        }

        usedCapacity = usedCapacity + assignmentView.Capacity;
        return usedCapacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateWrkCtrId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a resource ID that has the basis of another name.
    /// </summary>
    /// <param name="_name">
    /// The base name that the new ID should be generated from.
    /// </param>
    /// <returns>
    /// A new resource ID.
    /// </returns>
    /// <remarks>
    /// The resource ID will at first be set to the same value as the base name. If that name already
    /// exists then it will be post fixed with a number. If the base name is longer than the length of 
    /// WrkCtrId EDT, then prefix of the base name will be truncated to keep the postfix values.
    /// </remarks>
    [Replaceable]
    public static WrkCtrId generateWrkCtrId(str _name)
    {
        WrkCtrId result;
        
        SysDictType sysDictType = new SysDictType(extendedTypeNum(WrkCtrId));
        int wrkCtrIdEDTLen = sysDictType.stringLen();

        int inputStringLen = strLen(_name);
        if (inputStringLen == 0)
        {
            return '';
        }
        
        // If input string length is shorter or equal to WrkCtrId EDT size,
        // then seed string will be the input string.
        // Else if the input string length is larger than WrkCtrId EDT size,
        // then seed string will be the substring of WrkCtrId EDT size counting from the last character.
        WrkCtrId seed;
        if (inputStringLen <= wrkCtrIdEDTLen)
        {
            seed = _name;
        }
        else
        {
            seed = subStr(_name, inputStringLen - wrkCtrIdEDTLen + 1, wrkCtrIdEDTLen);
        }

        // Algorithm to come up with a unique WrkCtrId by look up if exists and increatment the substring.
        int i, j;
        for (i = 0; i < wrkCtrIdEDTLen && result == ''; i++)
        {
            WrkCtrId base = subStr(seed, 1, wrkCtrIdEDTLen - i);

            WrkCtrId candidate = base;
            if (!WrkCtrTable::exist(candidate))
            {
                result = candidate;
                break;
            }
            else
            {
                for (j=1; j < power(10, i); j++)
                {
                    candidate = base + int2str(j);
                    if (!WrkCtrTable::exist(candidate))
                    {
                        result = candidate;
                        break;
                    }
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipDatabaseLogAndEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Skip database log and event to improve performance.
    /// </summary>
    /// <param name = "_table">The specified table buffer.</param>
    public static void skipDatabaseLogAndEvent(Common _table)
    {
        _table.skipDatabaseLog(true);
        _table.skipEvents(true);
        _table.skipDataMethods(true);
        _table.skipDeleteMethod(true);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>