<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>McrCreateContinuityChildrenOrders</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The class <c>MCRCreateContinuityChildrenOrders</c> creates
/// continuity children orders.
/// </summary>
class McrCreateContinuityChildrenOrders extends RunBaseBatch implements BatchRetryable
{
    // Dialog variables.
    TransDate           startDate;
    ItemId              continuityItem;
    MCRContinuityScheduleID mcrSchedule;
    SalesId salesId;

    // Dialog fields
    DialogField     dlgContinuityItem;
    DialogField     dlgStartDate;
    DialogField     dlgSalesID;
    DialogField     dlgSchedule;

    real continuityParentPriceInclTax;
    real continuityParentPriceExclTax;
    real continuityParentTax;
    real salesLinePriceTotal;

    FormStringControl   tempItemIDQueryCtrl;

    // Macro for the pack / unpack
    #define.CurrentVersion(3)
    #localmacro.CurrentList
        startDate,
        continuityItem,
        mcrSchedule,
        salesId
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Dialog for create continuity children orders.
    /// </summary>
    /// <returns>The dialog object.</returns>
    public Object dialog()
    {
        DialogGroup                 dialogGrp;
        DialogGroup                 dialogGrpCriteria;
        DialogRunbase               dialog;
        str                         fieldName;

        //Setup the dialog
        dialog = new DialogRunbase("@MCR12795", this);
        dialogGrp = dialog.addGroup('');
        dialogGrp.frameType(FormFrameType::None);
        dialogGrp.columns(1);
        //Add the group for the Criteria
        dialogGrpCriteria = dialog.addGroup("@SYS13128", dialogGrp);
        dialogGrpCriteria.frameType(FormFrameType::Auto);
        //Prompt for "Start date"
        dlgStartDate = dialog.addField(extendedTypeStr(TransDate), "@SYS6255");
        //Prompt for "Continuity item"
        dlgContinuityItem = dialog.addField(extendedTypeStr(ItemId), "@MCR12800" );
        dlgContinuityItem.value('');
        dlgContinuityItem.lookupButton(FormLookupButton::Always);

        //check for item id lookup
        fieldName = dlgContinuityItem.fieldname();
        fieldName = fieldName + '_lookup';
        if (!MCRCreateContinuityChildrenOrders::classHasMethod(this.name(), fieldName))
        {
            throw error(strFmt("@MCR32922", fieldName, this.name()));
        }

        dlgSalesID = dialog.addField(extendedTypeStr(SalesId), "@SYS9694");
        dlgSalesID.value('');
        dlgSchedule = dialog.addField(extendedTypeStr(MCRContinuityScheduleID), "@MCR12095");
        dlgSchedule.value('');

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the dialog posting logic.
    /// </summary>
    /// <param name="_dialog">
    /// The <c>DialogRunbase</c> object to be run.
    /// </param>
    public void dialogPostRun(DialogRunbase _dialog)
    {
        FormRun formRun = _dialog.formRun();

        super(_dialog);

        formRun.controlMethodOverload(true);
        formRun.controlMethodOverloadObject(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTmpFrmVirtual</Name>
				<Source><![CDATA[
    private void findTmpFrmVirtual(TmpFrmVirtual _tmpFrmVirtual, TableId _tableId, RecId _recId)
    {
        select _tmpFrmVirtual
            where _tmpFrmVirtual.TableNum   == _tableId &&
                  _tmpFrmVirtual.RecordNo   == _recId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fld2_1_lookup</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an item lookup used for the dialog.
    /// </summary>
    private void fld2_1_lookup()
    {
        SysTableLookup          sysTableLookup;
        Query                   query = new Query();
        QueryBuildDataSource    queryBuildDataSource = query.addDataSource(tableNum(InventTable));
        QueryBuildDataSource    mcrInventTableQueryBuildDataSource;

        tempItemIDQueryCtrl = dlgContinuityItem.control();
        sysTableLookup = SysTableLookup::newParameters(tableNum(InventTable), tempItemIDQueryCtrl);

        sysTableLookup.addLookupfield(fieldNum(InventTable, ItemId));
        sysTableLookup.addLookupMethod(tableMethodStr(InventTable, itemName));
        sysTableLookup.addLookupMethod(tableMethodStr(InventTable, itemGroupId));
        mcrInventTableQueryBuildDataSource = queryBuildDataSource.addDataSource(tableNum(MCRInventTable));
        mcrInventTableQueryBuildDataSource.joinMode(JoinMode::InnerJoin);
        mcrInventTableQueryBuildDataSource.relations(true);
        mcrInventTableQueryBuildDataSource.addRange(fieldNum(MCRInventTable, ContinuityScheduleId)).value(SysQuery::valueNotEmptyString());

        sysTableLookup.parmQuery(query);
        sysTableLookup.performFormLookup();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAlreadyAllocatedSalesPriceExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the portion of the continuity line that has already been allocated.
    /// </summary>
    /// <param name="_inventTransIdCustHdr">
    ///     The inventory transaction record relating to the continuity line.
    /// </param>
    /// <returns>
    ///     The currently allocated amount excluding tax.
    /// </returns>
    private SalesPrice getAlreadyAllocatedSalesPriceExclTax(InventTransId _inventTransIdCustHdr)
    {
        MCRContinuityCustLine continuityCustLine;
        SalesPrice totalAllocatedSalesPrice;

        if (_inventTransIdCustHdr)
        {
            while select Price, SalesQty from continuityCustLine
                where continuityCustLine.InventTransId == _inventTransIdCustHdr
                    && continuityCustLine.SalesId != ""
                    && continuityCustLine.ActionCode != MCRContinuityActionCode::Skip
            {
                totalAllocatedSalesPrice = totalAllocatedSalesPrice +
                                           (continuityCustLine.Price * continuityCustLine.SalesQty);
            }
        }
        return totalAllocatedSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAlreadyAllocatedSalesPriceInclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///      Calculates the portion of the continuity line that has already been allocated.
    /// </summary>
    /// <param name="_inventTransIdCustHdr">
    ///     The invent trans record relating to the continuity line.
    /// </param>
    /// <returns>
    ///     The currently allocated amount excluding tax.
    /// </returns>
    private SalesPrice getAlreadyAllocatedSalesPriceInclTax(InventTransId _inventTransIdCustHdr)
    {
        MCRContinuityCustLine continuityCustLine;
        SalesPrice totalAllocatedSalesPrice;

        if (_inventTransIdCustHdr)
        {
            while select PriceInclTax, SalesQty from continuityCustLine
                            where continuityCustLine.InventTransId == _inventTransIdCustHdr
                            && continuityCustLine.SalesId != ""
                            && continuityCustLine.ActionCode != MCRContinuityActionCode::Skip
            {
                totalAllocatedSalesPrice = totalAllocatedSalesPrice +
                                           (continuityCustLine.PriceInclTax * continuityCustLine.SalesQty);
            }
        }
        return totalAllocatedSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContChildLineSalesPriceExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the sales price for the continuity child line exculding tax.
    /// </summary>
    /// <param name="_itemId">
    ///     The itemID for the item contained in the sales line.
    /// </param>
    /// <param name="_salesQty">
    ///     The quantity of the item on the sales line.
    /// </param>
    /// <param name="_inventTransId">
    ///     The inventTransID relating to the sales line.
    /// </param>
    /// <param name="_currencyCode">
    ///     The currency in which the price is to be calculated.
    /// </param>
    /// <returns>
    ///     The calculated price of the continuity child line excluding tax.
    /// </returns>
    private SalesPrice getContChildLineSalesPriceExclTax(ItemId _itemId, SalesQty _salesQty, InventTransId _inventTransId,
                    CurrencyCode _currencyCode)
    {
        SalesPrice salesLinePrice;
        CostPrice  totalCostOfContLines;
        CostPrice  itemCost;
        CostPrice  remainingPrice;
        SalesPrice allocatedPrice;
        totalCostOfContLines = this.getTotalCostOfContinuityLines(_inventTransId);
        itemCost = this.getItemCostPrice(_itemId, InventTransOrigin::findByInventTransId(_inventTransId).ItemInventDimId);

        allocatedPrice = this.getAlreadyAllocatedSalesPriceExclTax(_inventTransId);
        //Calculate the price that remains to be allocated.
        remainingPrice = continuityParentPriceExclTax - allocatedPrice;
        //if the item costs are not zero then calculate the line price
        //use this formula: itemcost / totalCost * (continuityParentPrice - alreadyallocatedPrice)
        if (totalCostOfContLines > 0)
        {
            salesLinePrice = CurrencyExchangeHelper::price(itemCost / totalCostOfContLines * remainingPrice, _currencyCode);
        }
        return salesLinePrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContChildLineSalesPriceInclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the sales price for the continuity child line including tax.
    /// </summary>
    /// <param name="_itemId">
    ///     The itemID for the item contained in the sales line.
    /// </param>
    /// <param name="_salesQty">
    ///     The quantity of the item on the sales line.
    /// </param>
    /// <param name="_inventTransId">
    ///     The inventTransID relating to the sales line.
    /// </param>
    /// <param name="_currencyCode">
    ///     The currency in which the price is to be calculated.
    /// </param>
    /// <returns>
    ///     The calculated price of the continuity child line including tax.
    /// </returns>
    private SalesPrice getContChildLineSalesPriceInclTax(ItemId _itemId, SalesQty _salesQty,
                InventTransId _inventTransId, CurrencyCode _currencyCode)
    {
        SalesPrice salesLinePrice;
        CostPrice  totalCostOfContLines;
        CostPrice  itemCost;
        CostPrice  remainingPrice;
        SalesPrice allocatedPrice;
        totalCostOfContLines = this.getTotalCostOfContinuityLines(_inventTransId);
        itemCost = this.getItemCostPrice(_itemId, InventTransOrigin::findByInventTransId(_inventTransId).ItemInventDimId);
        allocatedPrice = this.getAlreadyAllocatedSalesPriceInclTax(_inventTransId);
        //Calculate the price that remains to be allocated.
        remainingPrice = continuityParentPriceInclTax - allocatedPrice;
        //if the item costs are not zero then calculate the line price
        // itemcost/totalCost * (continuityParentPrice-alreadyallocatedPrice)
        if (totalCostOfContLines > 0)
        {
            salesLinePrice = CurrencyExchangeHelper::price(itemCost / totalCostOfContLines * remainingPrice, _currencyCode);
        }
        return salesLinePrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityChildLineTax</Name>
				<Source><![CDATA[
    private SalesPrice getContinuityChildLineTax(ItemId _itemId, SalesQty _salesQty, InventTransId _inventTransId)
    {
        SalesPrice salesLinePrice;
        CostPrice  totalCostOfContLines;
        CostPrice  itemCost;
        CostPrice  remainingPrice;
        SalesPrice allocatedTax;
        totalCostOfContLines = this.getTotalCostOfContinuityLines(_inventTransId);
        itemCost = this.getItemCostPrice(_itemId, InventTransOrigin::findByInventTransId(_inventTransId).ItemInventDimId);
        allocatedTax = this.getAlreadyAllocatedSalesPriceInclTax(_inventTransId);
        //Calculate the price that remains to be allocated.
        remainingPrice = continuityParentTax - allocatedTax;
        //if the item costs are not zero then calculate the line price
        //use this formula: itemcost / totalCost * (continuityParentPrice - alreadyallocatedPrice)
        if (totalCostOfContLines > 0)
        {
            salesLinePrice = (itemCost / totalCostOfContLines) * (remainingPrice);
        }
        return salesLinePrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContinuityParentTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retreives the tax amount on the continuity parent that needs to be allocated down among the children.
    /// </summary>
    /// <param name="_inventTransId">
    ///     The inventTransID belonging to the continuity parent transaction.
    /// </param>
    /// <returns>
    ///     The tax amount belonging to the continuity parent order.
    /// </returns>
    private real getContinuityParentTax(InventTransId _inventTransId)
    {
        SalesLine salesLine;
        salesLine = SalesLine::findInventTransId(_inventTransId, false);
        return SalesLine::mcrCalcContinuityLineTax(salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContParentSalesPriceExclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the sales price from the continuity parent, excluding taxes.
    /// </summary>
    /// <param name="_inventTransId">
    ///     The inventTransID belonging to the continuity parent transaction.
    /// </param>
    /// <returns>
    ///     The sales price of the continuity parent, excluding taxes.
    /// </returns>
    private real getContParentSalesPriceExclTax(InventTransId _inventTransId)
    {
        SalesLine salesLine;

        salesLine = SalesLine::findInventTransId(_inventTransId);
        return (salesLine.LineAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContParentSalesPriceInclTax</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the sales price from the continuity parent, including taxes.
    /// </summary>
    /// <param name="_inventTransId">
    ///     The inventTransID belonging to the continuity parent transaction.
    /// </param>
    /// <returns>
    ///     The sales price of the continuity parent, including taxes.
    /// </returns>
    private real getContParentSalesPriceInclTax(InventTransId _inventTransId)
    {
        SalesLine salesLine;
        salesLine = SalesLine::findInventTransId(_inventTransId);
        return (salesLine.LineAmount+
                SalesLine::mcrCalcContinuityLineTax(salesLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves user input from the selection criteria.
    /// </summary>
    /// <returns>
    ///     true if the dialog is closed using the 'Ok' button; otherwise, false.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     An ErrorException when the item passed from the dialog is not found, or is not a continuity item.
    /// </exception>
    public boolean getFromDialog()
    {
        startDate         = dlgStartDate.value();
        continuityItem    = dlgContinuityItem.value();
        mcrSchedule       = dlgSchedule.value();
        salesId           = dlgSalesID.value();

        if (continuityItem && !MCRInventTable::findByItemId(continuityItem).ContinuityScheduleId)
        {
            throw error("@MCR28798");
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Return item cost which is itemcost/unit from the InventTableModule
    ///     for a given item id. Also convert the costprice to the selling
    ///     unit of measure.
    /// </summary>
    /// <param name="_itemId">
    ///     The itemId belonging to the item for which the cost is to be found.
    /// </param>
    /// <param name="_inventDimId">
    /// The dimension ID for conversions.
    /// </param>
    /// <returns>
    ///     The cost price of the item.
    /// </returns>
    protected CostPrice getItemCostPrice(
        ItemId      _itemId,
        InventDimId _inventDimId)
    {
        InventTableModule inventTableModule = InventTableModule::find(_itemId, ModuleInventPurchSales::Invent, false);

        // If price unit is 0, set it to 1 to avoid divide by zero error.
        if (!inventTableModule.PriceUnit)
        {
            inventTableModule.PriceUnit = 1;
        }

        CostPrice           costPrice               = (inventTableModule.Price / inventTableModule.PriceUnit);
        InventTableModule   inventTableModulePrice  = InventTableModule::find(_itemId, ModuleInventPurchSales::Sales, false);

        //  Convert the cost to the selling unit of measure.
        //  (Note: the unit of measures seem to be swapped, but that is correct because
        //  it is converting and amount / uom. )
        CostPrice convertedCostPrice = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_itemId,
                                                                                                             _inventDimId,
                                                                                                             costPrice,
                                                                                                             inventTableModulePrice.UnitId,
                                                                                                             inventTableModule.UnitId,
                                                                                                             NoYes::Yes,
                                                                                                             NoYes::No);

        return convertedCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalCostOfContinuityLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Cycles through the continuitycustlines and total the cost of the items
    ///     on those lines, that do not have a sales order created for it yet.
    /// </summary>
    /// <param name="_inventTransIdCustHdr">
    ///     The inventory transaction's ID relating to the continuity header record.
    /// </param>
    /// <returns>
    ///     The total cost price of all continuity lines relating the header record.
    /// </returns>
    private CostPrice getTotalCostOfContinuityLines(InventTransId _inventTransIdCustHdr)
    {
        MCRContinuityCustLine continuityCustLine;
        CostPrice totalCostPrice;

        //Initialize the totalCostPrice to zero to obtain the cost of snap shot in time
        totalCostPrice = 0;
        while select SalesQty, ItemId from continuityCustLine
            where continuityCustLine.InventTransId == _inventTransIdCustHdr &&
                continuityCustLine.SalesId == ""
                && continuityCustLine.ActionCode != MCRContinuityActionCode::Skip
        {
            totalCostPrice = totalCostPrice + (continuityCustLine.SalesQty *
                                              this.getItemCostPrice(continuityCustLine.ItemId, InventTransOrigin::findByInventTransId(_inventTransIdCustHdr).ItemInventDimId));
        }
        return totalCostPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes and creates an inventory dimension for the line
    ///     based on parameters from the continuity schedule.
    /// </summary>
    /// <param name="_continuityCustLine">
    ///     The continuity line for which the inventory dimension is to be created.
    /// </param>
    /// <param name="_inventDimWrite">
    ///     The inventory dimension to be written.
    /// </param>
    /// <param name="_axSalesTable">
    ///     The sales table record used to set default inventory dimension prior to overriding with the continuity schedule.
    /// </param>
    /// <param name="_axSalesLine">
    ///     The sales line record used to set default inventory dimension prior to overriding with the continuity schedule.
    /// </param>
    /// <param name="_salesLineParent">
    ///     The parent sales line record used to set default inventory dimension if no other default exists for the continuity schedule.
    /// </param>
    /// <returns>
    ///     The inventory dimension to be set on the continuity line.
    /// </returns>
    private AxInventDim inventDimWrite(MCRContinuityCustLine _continuityCustLine, AxInventDim  _inventDimWrite, AxSalesTable _axSalesTable, AxSalesLine _axSalesLine, SalesLine _salesLineParent = null)
    {
        InventDim               inventDim;
        MCRInventTable          mcrInventTable;
        InventDim               inventDimItemLocal;

        // Use the AxSalesLine to set the default inventory dimensions prior to
        // overriding them with what is on the continuity schedule.
        _axSalesLine.axInventDim().setInventDimId();
        inventDim = _axSalesLine.axInventDim().inventDim();

        mcrInventTable = MCRInventTable::findByItemId(_continuityCustLine.ItemId);

        ttsbegin;

        // Conditionally format the fields if they are on the continuity.
        inventDim = InventDim::find(_continuityCustLine.InventDimId);

        // First check drop ship, if not, then check continuity setup
        if (mcrInventTable.DropShipment == NoYes::Yes
            && mcrInventTable.DefaultDropShipmentWarehouse)
        {
            inventDim.InventLocationId = mcrInventTable.DefaultDropShipmentWarehouse;
            inventDim.InventSiteId = InventLocation::find(mcrInventTable.DefaultDropShipmentWarehouse).InventSiteId;
        }
        // Use warehouse set on continuity line, if not set, use item default
        else if (!inventDim.InventLocationId)
        {
            // If the continuity line does not have site/warehouse specified, take defaults from the item
            inventDimItemLocal = InventItemSalesSetup::mcrGetDfltCombination(_continuityCustLine.ItemId);
            if (inventDimItemLocal)
            {
                inventDim.InventSiteId      = inventDimItemLocal.InventSiteId;
                inventDim.InventLocationId  = inventDimItemLocal.InventLocationId;
            }
            // If no defaults are set, take site/warehouse from the parent line
            else
            {
                inventDimItemLocal = _salesLineParent.inventDim();
                if (inventDimItemLocal.InventLocationId)
                {
                    inventDim.InventLocationId  = inventDimItemLocal.InventLocationId;
                    inventDim.InventSiteId      = inventDimItemLocal.InventSiteId;
                }
            }
        }

        // Change to the constructor so needed to set the inventDim.
        _inventDimWrite = AxInventDim::construct();
        _inventDimWrite.inventDim(inventDim);
        _inventDimWrite.setInventDimId();

        ttscommit;

        return _inventDimWrite;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This class creates sales orders in a batch format for subscription and continuity orders.
    /// </summary>
    public void run()
    {
        MCRContinuityCustHeader     continuityCustHeader;
        MCRContinuityCustHeader     continuityCustHeader_upd;
        MCRContinuityCustLine       continuityCustLine, continuityCustLine_Loop;
        MCRContinuityEventId        currentEventID = 0;
        boolean                     orderComplete = true;
        int                         counter;
        int                         numOrders;
        int                         invalidCCDate;
        MCRCustPaymTable            custPaymTable;
        boolean                     paymentValid;
        SalesLine                   salesLine;
        SalesTable                  salesTable;

        MCRContinuityEventId        endEventID;

        super();

        #OCCRetryCount

        numOrders = MCROrderParameters::find().ContChildToCreate;

        // Find all continuity orders in the system that are still processing.
        setPrefix("@MCR20669");

        while select continuityCustHeader
            where continuityCustHeader.Complete    != true
                &&   (continuityCustHeader.SalesId     == salesId || !salesId)
                &&   (continuityCustHeader.ScheduleId  == mcrSchedule || !mcrSchedule)
                exists join salesLine
                where salesLine.InventTransId          == continuityCustHeader.InventTransId
                    &&  ((salesLine.ItemId             == continuityItem) || !continuityItem)
                    &&  (salesLine.SalesStatus  == SalesStatus::None
                        || salesLine.SalesStatus == SalesStatus::Backorder
                        || salesLine.SalesStatus == SalesStatus::Delivered
                        || salesLine.SalesStatus == SalesStatus::Invoiced)
        {
            try
            {
                // Don't create child order if parent is on hold or open
                salesTable = SalesTable::find(continuityCustHeader.SalesId);
                if (salesTable.SalesStatus == SalesStatus::Backorder
                &&  salesTable.mcrOrderStopped == NoYes::Yes)
                {
                    continue;
                }

                paymentValid = true;

                // Do not want to create child orders for continuity orders that have invalid CC dates
                custPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(continuityCustHeader.RecId,
                                                                           continuityCustHeader.TableId);
                // Continuity orders can not have more than 1 payment, no need to loop
                // However, may not have a payment at all
                if (custPaymTable)
                {
                    if (custPaymTable.CustPaymType == MCRCustPaymType::CreditCard)
                    {
                        if (CreditCardCust::find(custPaymTable.PaymInfoRecId))
                        {
                            paymentValid = true;
                        }
                        else
                        {
                            error(strFmt("@MCR31102", continuityCustHeader.SalesId));
                            invalidCCDate++;
                        }
                    }
                }

                if (paymentValid)
                {
                    // Do not allow create of continuity children that have an event ID greater
                    //              than the line marked end
                    select firstonly EventId from continuityCustLine
                        where continuityCustLine.InventTransId == continuityCustHeader.InventTransId
                           && continuityCustLine.ActionCode == MCRContinuityActionCode::End;

                    endEventID = continuityCustLine.EventId;
                    continuityCustLine.clear();

                    currentEventID = 0;

                    if (startDate == dateNull())
                    {
                        startDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    }

                    while select InventTransId, SalesId, StartDate, ActionCode, RecId
                        from  continuityCustLine_Loop
                        order by EventId asc
                        where continuityCustLine_Loop.InventTransId == continuityCustHeader.InventTransId
                        &&    continuityCustLine_Loop.SalesId       == ""
                        &&    continuityCustLine_Loop.StartDate     <= startDate
                        &&    continuityCustLine_Loop.ActionCode    != MCRContinuityActionCode::Skip
                        &&    continuityCustLine_Loop.EventId       <= endEventID
                    {
                        //  The loop will buffer all the records we want to process, since part of the
                        //              WriteSO logic will update one of the records that has not been processed yet
                        //              need to reselect it to make sure a sales order has not been created for it.
                        continuityCustLine = MCRContinuityCustLine::findRecId(continuityCustLine_Loop.RecId);
                        if (!continuityCustLine.SalesId)
                        {
                            currentEventID = continuityCustLine.EventId;

                            //Create SO for the event.
                            this.writeSO(continuityCustHeader, currentEventID);
                            counter++;

                            continuityCustHeader_upd = MCRContinuityCustHeader::find(continuityCustLine.InventTransId, true);
                            // If the last record to be processed was just process, change the continuity's status to complete so that
                            // if will not get run through any of the batch jobs again.
                            if (!continuityCustHeader_upd.hasOpenLines())
                            {
                                //have to re-select record forupdate due to a bug where you can not have a try catch inside a ttsBegin/ttsCommit.
                                ttsbegin;

                                continuityCustHeader_upd.Complete = true;
                                continuityCustHeader_upd.update();
                                ttscommit;
                            }
                        }
                    }
                    if (numOrders != 0
                        && counter >= numOrders)
                    {
                        break;
                    }
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            catch (Exception::Error)
            {
                continue;
            }
        }

        info(strFmt("@MCR31106", int2str(counter)));
        info(strFmt("@MCR31107", int2str(invalidCCDate)));
        info("@MCR12761");
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesLineWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Writes the continuity child order sales lines.
    /// </summary>
    /// <param name="_continuityCustHeader">
    ///     The continuity parent order whose child orders are to be written.
    /// </param>
    /// <param name="_salesLine">
    ///     The sales line record used to set default inventory dimension prior to overriding with the continuity schedule.
    /// </param>
    /// <param name="_salesTable">
    ///     The sales table record used to set default inventory dimension prior to overriding with the continuity schedule.
    /// </param>
    /// <param name="_salesLineNum">
    ///     The number used to track what child order is being created.
    /// </param>
    /// <param name="_continuityEventId">
    ///     The ID for this continuity line creation.
    /// </param>
    /// <param name="_axSalesTable">
    ///     The ax sales table record the child is to be created in.
    /// </param>
    private void salesLineWrite(MCRContinuityCustHeader _continuityCustHeader,
                            SalesLine _salesLine, SalesTable _salesTable,
                            real _salesLineNum, MCRContinuityEventId _continuityEventId, AxSalesTable _axSalesTable)
    {
        InventTable                 inventTable;
        AxInventDim                 inventDimWrite;
        AxSalesLine                 axSalesLine;
        MCRContinuityCustLine       continuityCustLine;
        MCRContinuityScheduleHeader continuitySchedHdr;
        int                         counter;
        SalesLine                   salesLine_new;
        MCRSalesLinePriceOverride   mcrSalesLinePriceOverride;
        MCRSalesLine                mcrSalesLineParent = _salesLine.mcrSalesLine();
        MCRSalesLine                mcrSalesLine;
        AmountCur                   salesPrice = 0;

        salesLinePriceTotal = 0;

        //Retrieve the schedule header to see if the bill up front has a schedule or not
        continuitySchedHdr = MCRContinuityScheduleHeader::find(_continuityCustHeader.ScheduleId, false);

        ttsbegin;

        // Select all lines on the continuity order that have start dates of today or earlier where a sales
        // order has not yet been created.
        // Grab this record forUpdate
        while select forupdate continuityCustLine order by EventId asc
              where continuityCustLine.InventTransId == _continuityCustHeader.InventTransId
                    && continuityCustLine.SalesId == ""
                    && continuityCustLine.StartDate <= startDate
                    && (continuityCustLine.EventId == _continuityEventId
                    || continuitySchedHdr.ConsolidatePastOrders)
                    && continuityCustLine.ActionCode != MCRContinuityActionCode::Skip
        {
            //increment counter so that rounding can be taken care of on the last line
            counter += 1;
            //Run validation on SalesLine.
            axSalesLine = AxSalesLine::construct();
            axSalesLine.validateInput(true);

            //Get the item description.
            inventTable = InventTable::find(continuityCustLine.ItemId);
            //Assign Sales Line values.
        
            //ADDRESS
            axSalesLine.parmItemId(continuityCustLine.ItemId);
            axSalesLine.parmName(inventTable.itemName());
            axSalesLine.parmLineNum (_salesLineNum + 1);
            _salesLineNum = axSalesLine.parmLineNum();
            axSalesLine.parmSalesUnit(continuityCustLine.SalesQtyUOM);
            axSalesLine.parmSalesQty (continuityCustLine.SalesQty);
            axSalesLine.parmSalesId (_salesTable.SalesId);
            axSalesLine.parmCustAccount(_salesLine.CustAccount);
            axSalesLine.parmCustGroup(_salesLine.CustGroup);
            axSalesLine.parmCurrencyCode(_salesTable.CurrencyCode);
            axSalesLine.parmLedgerDimension(_salesLine.LedgerDimension);
            axSalesLine.parmDeliveryPostalAddress(_salesLine.DeliveryPostalAddress);
            axSalesLine.parmDeliveryName(_salesLine.DeliveryName);
            axSalesLine.parmDefaultDimension(_salesLine.DefaultDimension);
            axSalesLine.parmTaxGroup(_salesLine.TaxGroup);
            axSalesLine.parmTaxItemGroup(_salesLine.TaxItemGroup);

            axSalesLine.parmDeliveryDateControlType(SalesDeliveryDateControlType::None);

            axSalesLine.parmConfirmedDlv(continuityCustLine.ShipDate);

            axSalesLine.parmPriceUnit(1);

            // The following migrates the delivery mode into the sales line
            // if valid, default in from parent line, or last ,
            // default in a valid one as a part of the Ax class
            // processing.
            if (continuityCustLine.DeliveryMode)
            {
                axSalesLine.parmDlvMode(continuityCustLine.DeliveryMode);
            }
            // Only default expedite flag if no delivery mode specified.
            else
            {
                if (_salesLine.DlvMode)
                {
                    axSalesLine.parmDlvMode(_salesLine.DlvMode);
                }
            }

            if (_continuityCustHeader.BillUpFront)
            {
                // Need to call the price allocation method to get the correct price for this line
                // The price field on the MCRContinuityCustLine will be allocated the amount excluding taxes
                // The PriceInclTax field will store the same amount with taxes.
                continuityCustLine.Price =  this.getContChildLineSalesPriceExclTax
                                                (continuityCustLine.ItemId, continuityCustLine.SalesQty,
                                                 _continuityCustHeader.InventTransId,
                                                 _salesLine.CurrencyCode);

                continuityCustLine.PriceInclTax = this.getContChildLineSalesPriceInclTax
                                                   (continuityCustLine.ItemId, continuityCustLine.SalesQty,
                                                    _continuityCustHeader.InventTransId,
                                                    _salesLine.CurrencyCode);

                // Price is on the parent line
                axSalesLine.parmSalesPrice(0);
            }
            else
            {
                // If continuity price is not set then it will pick the item sales price.
                if (continuityCustLine.Price)
                {
                    axSalesLine.parmSalesPrice(continuityCustLine.Price);
                    salesPrice = continuityCustLine.Price;
                }
                else
                {
                   axSalesLine.parmSalesPrice(inventTable.salesPcsPrice());
                   salesPrice = inventTable.salesPcsPrice();
                }
            }
            //update the just created sales line with inventDimId;
            // Then use the inventDimId for the sales order.
            inventDimWrite = this.inventDimWrite(continuityCustLine, inventDimWrite, _axSalesTable, axSalesLine, _salesLine);
            axSalesLine.parmInventDimId(inventDimWrite.parmInventDimId());

            //There is a tts in this function
            axSalesLine.save();

            ttsbegin;
            select forupdate firstonly mcrSalesLine
                where mcrSalesLine.SalesLine == axSalesLine.currentRecord().RecId;

            if (mcrSalesLine)
            {
                mcrSalesLine.SourceId = mcrSalesLineParent.SourceId;
                if (!continuityCustLine.DeliveryMode)
                {
                    mcrSalesLine.Expedite = mcrSalesLineParent.Expedite;
                }
                mcrSalesLine.update();
            }
            else if (mcrSalesLineParent.SourceId ||
                (!continuityCustLine.DeliveryMode && mcrSalesLineParent.Expedite))
            {
                mcrSalesLine.SourceId = mcrSalesLineParent.SourceId;
                mcrSalesLine.SalesLine = axSalesLine.currentRecord().RecId;
                if (!continuityCustLine.DeliveryMode && mcrSalesLineParent.Expedite)
                {
                    mcrSalesLine.Expedite = mcrSalesLineParent.Expedite;
                }
                mcrSalesLine.insert();
            }
            ttscommit;

            // If the conintuity order line had it's price changed, copy the reason code
            //  down to the new sales line.
            salesLine_new = axSalesLine.salesLine();

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                this.updateSalesLine_BR(salesLine_new);
            }
            // </GBR>

            if (!_continuityCustHeader.BillUpFront
                && continuityCustLine.PriceOverride)
            {
                mcrSalesLinePriceOverride = salesLine_new.mcrSalesLinePriceOverride();
                mcrSalesLinePriceOverride.PriceOverride = continuityCustLine.PriceOverride;
                mcrSalesLinePriceOverride.ReasonCode = continuityCustLine.PriceOverrideReason;
                salesLine_new.mcrPackMCRSalesLinePriceOverride(mcrSalesLinePriceOverride);
                salesLine_new.update();
            }
            
            continuityCustLine.InventTransIDChild = salesLine_new.InventTransId;
            continuityCustLine.SalesId = salesLine_new.SalesId;
            continuityCustLine.Price = salesPrice;
            continuityCustLine.update();
        }

        ttscommit;

        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTableWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates the sales table for the child continuity orders, defaulting data from the continuity parent order.
    /// </summary>
    /// <param name="_axSalesTable">
    ///     The ax sales table record to be used in the sales table creation for the child order.
    /// </param>
    /// <param name="_salesTable">
    ///     The parent sales table record used to set default values in the child sales table record.
    /// </param>
    /// <param name="_continuityCustHeader">
    ///     The parent continuity record used to set default values in the child record.
    /// </param>
    /// <param name="_salesLine">
    ///     The parent sales line record used to set default values in the child sales table record.
    /// </param>
    /// <param name="_currentEventId">
    ///     The ID for this continuity sales table creation.
    /// </param>
    /// <returns>
    ///     The sales ID for the newly created child continuity sales table.
    /// </returns>
    private SalesId salesTableWrite (AxSalesTable           _axSalesTable,
                                    SalesTable              _salesTable,
                                    MCRContinuityCustHeader _continuityCustHeader,
                                    SalesLine               _salesLine,
                                    MCRContinuityEventId    _currentEventId)
    {
        MCRContinuityCustLine   continuityCustLine;
        AxMCRSalesTableShipping axMCRSalesTableShipping = AxMCRSalesTableShipping::construct();
        MCRSalesTableShipping   mcrSalesTableShipping;
        MCRSalesTable           mcrSalesTable;
        MCRSalesTableShipping   mcrSalesTableShippingParent = _salesTable.mcrSalesTableShipping();
        MCRSalesTable           mcrSalesTableParent = _salesTable.mcrSalesTable();
        //Assign SalesTable Values.
        //Copy the salesTable from the subscription to the salesTable for the SubscriptionOrder.
        ttsbegin;
        continuityCustLine = MCRContinuityCustLine::findInventTransEventId(_continuityCustHeader.InventTransId, _currentEventId);

        _axSalesTable = this.initAxSalesTable(_continuityCustHeader, continuityCustLine, _salesTable, _salesLine);
        _axSalesTable.save();

        select forupdate firstonly mcrSalesTable
            where mcrSalesTable.SalesTable == _axSalesTable.currentRecord().RecId;

        mcrSalesTable.ContinuityChild = true;
        mcrSalesTable.SourceId = _salesLine.mcrSalesLine().SourceId;
        mcrSalesTable.ftcExempt = mcrSalesTableParent.ftcExempt;
        mcrSalesTable.SalesTable = _axSalesTable.currentRecord().RecId;
        mcrSalesTable.write();

        select forupdate firstonly mcrSalesTableShipping
            where mcrSalesTableShipping.SalesTable == _axSalesTable.currentRecord().RecId;
        if (mcrSalesTableShipping)
        {
            // Format the expedite flag on the order based on the line.
            mcrSalesTableShipping.Expedite = _salesLine.mcrSalesLine().Expedite;
            mcrSalesTableShipping.update();
        }
        else
        {
            mcrSalesTableShipping.Expedite = _salesLine.mcrSalesLine().Expedite;
            if (mcrSalesTableShipping.Expedite)
            {
                mcrSalesTableShipping.SalesTable = _axSalesTable.currentRecord().RecId;
                mcrSalesTableShipping.insert();
            }
        }

        salesId = _axSalesTable.parmSalesId();

        ttscommit;
        return salesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAxSalesTable</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    private AxSalesTable initAxSalesTable(MCRContinuityCustHeader _continuityCustHeader,
        MCRContinuityCustLine continuityCustLine,
        SalesTable _salesTable,
        SalesLine _salesLine)
    {
        AxSalesTable _axSalesTable = AxSalesTable::construct();
        _axSalesTable.validateInput(true);
        _axSalesTable.parmCustAccount(_salesTable.CustAccount);
        _axSalesTable.parmInvoiceAccount(_salesTable.InvoiceAccount);
        _axSalesTable.parmSalesType(SalesType::Sales);
        _axSalesTable.parmSalesStatus(SalesStatus::Backorder);
        _axSalesTable.parmPaymentSched(continuityCustLine.PaymentSchedLine);

        //If bill upfront, the children orders will not receive Postage charges.
        if (_continuityCustHeader.BillUpFront)
        {
            // Misc charges are on parent order
            _axSalesTable.parmMarkupGroup("");
        }

        _axSalesTable.parmDeliveryDate(continuityCustLine.ShipDate);
        //Only assign Delivery mode and end disc if they have not already defaulted in from the source code.
        if (!_axSalesTable.parmDlvMode())
        {
            _axSalesTable.parmDlvMode(_salesLine.DlvMode);
        }
        if (!_axSalesTable.parmEndDisc())
        {
            _axSalesTable.parmEndDisc(_salesTable.EndDisc);
        }
        _axSalesTable.parmCurrencyCode(_salesTable.CurrencyCode);
        _axSalesTable.parmCustGroup(_salesTable.CustGroup);
        _axSalesTable.parmLanguageId(_salesTable.LanguageId);
        _axSalesTable.parmPaymMode(_salesTable.PaymMode);
        _axSalesTable.parmCommissionGroup(_salesTable.CommissionGroup);
        _axSalesTable.parmContactPersonId(_salesTable.ContactPersonId);
        _axSalesTable.parmCustomerRef(_salesTable.CustomerRef);
        _axSalesTable.parmDeadline(_salesTable.Deadline);
        _axSalesTable.parmDeliveryPostalAddress(_salesLine.DeliveryPostalAddress);
        _axSalesTable.parmDeliveryPostalAddress(_salesLine.DeliveryPostalAddress);
        _axSalesTable.parmDeliveryName(_salesLine.DeliveryName);
        _axSalesTable.parmDiscPercent(_salesTable.DiscPercent);
        _axSalesTable.parmDlvTerm(_salesTable.DlvTerm);
        _axSalesTable.parmDocumentStatus(_salesTable.DocumentStatus);
        _axSalesTable.parmEmail(_salesTable.Email);
        _axSalesTable.parmExportReason(_salesTable.ExportReason);
        _axSalesTable.parmFixedDueDate(_salesTable.FixedDueDate);
        _axSalesTable.parmFixedExchRate(_salesTable.FixedExchRate);
        _axSalesTable.parmReportingCurrencyFixedExchRate(_salesTable.ReportingCurrencyFixedExchRate);
        _axSalesTable.parmFreightSlipType(_salesTable.FreightSlipType);
        _axSalesTable.parmFreightZone(_salesTable.FreightZone);
        _axSalesTable.parmGiroType(_salesTable.GiroType);
        _axSalesTable.parmInclTax(_salesTable.InclTax);
        _axSalesTable.parmInterCompanyCompanyId(_salesTable.InterCompanyCompanyId);
        _axSalesTable.parmInterCompanyOrder(_salesTable.InterCompanyOrder);
        _axSalesTable.parmInterCompanyPurchId(_salesTable.InterCompanyPurchId);
        _axSalesTable.parmInventLocationId(_salesTable.InventLocationId);
        _axSalesTable.parmLanguageId(_salesTable.LanguageId);
        _axSalesTable.parmListcode(_salesTable.Listcode);
        _axSalesTable.parmOneTimeCustomer(_salesTable.OneTimeCustomer);
        _axSalesTable.parmPaymSpec(_salesTable.PaymSpec);
        _axSalesTable.parmPort(_salesTable.Port);
        _axSalesTable.parmPostingProfile(_salesTable.PostingProfile);
        _axSalesTable.parmPriceGroupId(_salesTable.PriceGroupId);
        _axSalesTable.parmProjId(_salesTable.ProjId);
        _axSalesTable.parmPurchOrderFormNum(_salesTable.PurchOrderFormNum);
        _axSalesTable.parmReservation(_salesTable.Reservation);
        _axSalesTable.parmReturnItemNum(_salesTable.ReturnItemNum);
        _axSalesTable.parmSalesGroup(_salesTable.SalesGroup);
        _axSalesTable.parmSalesOriginId(_salesTable.SalesOriginId);
        _axSalesTable.parmSalesPoolId(_salesTable.SalesPoolId);
        _axSalesTable.parmWorkerSalesTaker(_salesTable.WorkerSalesTaker);
        _axSalesTable.parmSettleVoucher(_salesTable.SettleVoucher);
        _axSalesTable.parmStatProcId(_salesTable.StatProcId);
        _axSalesTable.parmTaxGroup(_salesTable.TaxGroup);
        _axSalesTable.parmTransactionCode(_salesTable.TransactionCode);
        _axSalesTable.parmTransport(_salesTable.Transport);
        _axSalesTable.parmURL(_salesTable.url);
        _axSalesTable.parmVATNum(_salesTable.vatNum);
        _axSalesTable.parmVATNumRecId(_salesTable.vatNumRecId);
        _axSalesTable.parmVATNumTableType(_salesTable.vatNumTableType);
        _axSalesTable.parmDefaultDimension(_salesTable.DefaultDimension);

        // Set the Sales Table dates to run off the Continuity Line Ship Date
        _axSalesTable.parmReceiptDateRequested(continuityCustLine.ShipDate);
        _axSalesTable.parmShippingDateRequested(continuityCustLine.ShipDate);
        _axSalesTable.parmDeliveryDateControlType(SalesDeliveryDateControlType::None);
        return _axSalesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setContinuityLineEval</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the <c>ContinuityLineEval</c> field of the child sales order.
    /// </summary>
    /// <param name="_continuityCustHeader">
    ///     The continuity header used to set the child sales order <c>ContinuityLineEval</c> field.
    /// </param>
    /// <param name="_newSalesTable">
    ///     The child continuity sales table record.
    /// </param>
    /// <remarks>
    ///     Conditions:
    ///     If Bill Up front with no payment schedule, then all amounts were paid
    ///      by the parent sales order so the children to be marked as "Paid"
    ///     If Bill up front with a payment schedule, then the children to be marked as
    ///      Pay Now.
    ///     If not bill up front, then check if a schedule exists at the header. If it does
    ///      then it will be pay all later
    ///     If not bill up front and if no schedule exists at the header, check if schedules
    ///      exist at the line level, if they do then this will also be a pay all later situation
    ///     If not bill up front and no schedules exist either at the header or at the line
    ///      level then this will be a Pay All now situation.
    /// </remarks>
    private void setContinuityLineEval(MCRContinuityCustHeader _continuityCustHeader, SalesTable _newSalesTable)
    {
        MCRSalesTable mcrSalesTable = _newSalesTable.mcrSalesTable();
        if (_continuityCustHeader.BillUpFront && _continuityCustHeader.PaymentScheduleId)
            mcrSalesTable.ContinuityLineEval = MCRContinuityLineEval::PayAllLater;

        //If Bill up front and no payment schedule, then this order was already paid for
        //on the parent sales order so mark order as paid
        if (_continuityCustHeader.BillUpFront && !_continuityCustHeader.PaymentScheduleId)
            mcrSalesTable.ContinuityLineEval = MCRContinuityLineEval::Paid;

        if (!_continuityCustHeader.BillUpFront)
        {
            //If there are no payment schedules at the line level, then it will be a pay all now
            //situation, else it will be a pay all later.
            if (!_newSalesTable.PaymentSched)
                mcrSalesTable.ContinuityLineEval = MCRContinuityLineEval::PayAllNow;
            else
                mcrSalesTable.ContinuityLineEval = MCRContinuityLineEval::PayAllLater;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);
        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeSO</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Writes the sales order for a subscription.
    /// </summary>
    /// <param name="_mcrContinuityCustHeader">
    ///     The continuity header record to which the sales order is related.
    /// </param>
    /// <param name="_mcrContinuityEventId">
    ///     The ID for this continuity order creation.
    /// </param>
    private void writeSO(MCRContinuityCustHeader  _mcrContinuityCustHeader, MCRContinuityEventId _mcrContinuityEventId)
    {
        MCRContinuityScheduleHeader mcrContinuityScheduleHeader;
        SalesTableLinks             salesTableLinks;
        SalesLine                   salesLine;
        SalesTable                  salesTable;
        SalesTable                  newSalesTable;
        AxSalesTable                axSalesTable;
        Integer                     salesLineNum;

        MCRSalesOrderTotals         mcrSalesOrderTotals;
        McrContinuityCustLine       mcrContinuityCustLine;

        ttsbegin;
        mcrContinuityScheduleHeader = MCRContinuityScheduleHeader::find(MCRContinuityCustHeader::find(_mcrContinuityCustHeader.InventTransId).ScheduleId);
        salesLineNum = 0;
        // Get the sales line for the parent order.
        salesLine = SalesLine::findInventTransId(_mcrContinuityCustHeader.InventTransId);
        // Get the header record for the parent order.
        salesTable = SalesTable::find(salesLine.SalesId);
        // Start to create the new order.
        axSalesTable = AxSalesTable::newValidateInput();

        // Write sales header.
        salesId = this.salesTableWrite(axSalesTable, salesTable, _mcrContinuityCustHeader, salesLine, _mcrContinuityEventId);

        // Obtain the continuity parent sales order price
        continuityParentPriceInclTax = 0;
        continuityParentPriceExclTax = 0;
        // Retrieve the continuity parent line amount both amount including tax and amount excluding tax
        continuityParentPriceInclTax=this.getContParentSalesPriceInclTax(_mcrContinuityCustHeader.InventTransId);
        continuityParentPriceExclTax=this.getContParentSalesPriceExclTax(_mcrContinuityCustHeader.InventTransId);

        // Write all sales lines for an event number on one sales order.
        this.salesLineWrite(_mcrContinuityCustHeader, salesLine, SalesTable::find(salesId), salesLineNum, _mcrContinuityEventId, axSalesTable);

        // Read the created sales order so that remaining updates can be performed.
        newSalesTable = SalesTable::find(salesId, true);
        // Set the continuityLineEval for the children orders and then update the
        // sales order with this field value
        this.setContinuityLineEval(_mcrContinuityCustHeader, newSalesTable);
        // Set the dimensions (not working in AxSalesTable)
        newSalesTable.DefaultDimension = salesTable.DefaultDimension;
        newSalesTable.doUpdate();

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.updateSalesTable_BR(salesTable, newSalesTable);
        }
        // </GBR>
       
        // We need the total for the sales order before writing the CustPaymrecord
        mcrSalesOrderTotals = new MCRSalesOrderTotals(newSalesTable);

        if (!_mcrContinuityCustHeader.BillUpFront)
        {
            newSalesTable.Estimate = mcrSalesOrderTotals.getTotalOrder();
            newSalesTable.doUpdate();
              
        }

        if (newSalesTable.PaymentSched)
        {
            newSalesTable.createPaymentSched();
        }
        if (_mcrContinuityCustHeader.BillUpFront)
        {
            MCRCustPaymTable::copyCustPayment(_mcrContinuityCustHeader.TableId, _mcrContinuityCustHeader.RecId,
                                            newSalesTable.TableId, newSalesTable.RecId,
                                            newSalesTable.SalesId,
                                            0);
        }
        else
        {
            MCRCustPaymTable::copyCustPayment(_mcrContinuityCustHeader.TableId, _mcrContinuityCustHeader.RecId,
                                         newSalesTable.TableId, newSalesTable.RecId,
                                         newSalesTable.SalesId,
                                         mcrSalesOrderTotals.getTotalOrder());
        }
        ttscommit;

        if (MCROrderParameters::find().mcrAuthContinuityChild)
        {
            MCREndOrder::endOrder(newSalesTable.SalesId);
        }

        // Insert the links from the parent order to the child orders.
        salesTableLinks.MainSalesId = salesTable.SalesId;
        salesTableLinks.mcrMainInventTransId = salesLine.InventTransId;
        salesTableLinks.SubSalesId = salesId;
        salesTableLinks.insert();

        // Recalculate price for sales order since new policy may be added during the initial creation of the continuity order.
        select firstonly mcrContinuityCustLine where mcrContinuityCustLine.SalesId == newSalesTable.SalesId;
        if (mcrContinuityCustLine.Price)
        {
            ttsbegin;
            MCRSalesTableController::recalculateRetailPricesDiscounts(newSalesTable);
            ttscommit;
        }

        // Write the info log with order created.
        info(strFmt("@MCR12841", _mcrContinuityCustHeader.SalesId,
                    salesLine.ItemId,
                    _mcrContinuityCustHeader.InventTransId,
                    salesId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>classHasMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the passed class has
    /// the passed method.
    /// </summary>
    /// <param name="_className">
    /// The name of the class to find.
    /// </param>
    /// <param name="_methodName">
    /// The name of the method to find on the class.
    /// </param>
    /// <returns>
    /// true if the class has the specified method; otherwise, false.
    /// </returns>
    public static boolean classHasMethod(str _className, str _methodName)
    {
        ClassNode classNode;
        #aot
        TreeNode treeNode;
        MemberFunction method;
        boolean ret;
        treeNode = TreeNode::findNode(#ClassesPath);
        classNode = treeNode.AOTfindChild(_className);
        if (classNode)
        {
            method = classNode.AOTfindChild(_methodName);
            if (method)
            {
                ret = true;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static MCRCreateContinuityChildrenOrders construct()
    {
        return new MCRCreateContinuityChildrenOrders();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@MCR12795";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        MCRCreateContinuityChildrenOrders  createContinuityChildrenOrders;
        createContinuityChildrenOrders = MCRCreateContinuityChildrenOrders::construct();

        if (createContinuityChildrenOrders.prompt())
        {
            createContinuityChildrenOrders.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update information on SalesLine_BR.
    /// </summary>
    /// <param name="salesLine">
    /// SalesLine created for continuity order.
    /// </param>
    private void updateSalesLine_BR(SalesLine salesLine)
    {
        SalesLine_BR salesLine_BR;

        salesLine_BR = salesLine.salesLine_BR();
        salesLine_BR.selectForUpdate(true);

        salesLine_BR.initFiscalDocumentType(salesLine.inventDim(), salesLine.inventTable());

        salesLine_BR.update();
        salesLine.reread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update information on SalesTable_BR of the new continuity order based on original SalesTable_BR information.
    /// </summary>
    /// <param name="originalSalesTable">
    /// SalesTable used to create child SalesTable line.
    /// </param>
    /// <param name="newSalesTable">
    /// Created SalesTable line.
    /// </param>
    private void updateSalesTable_BR(SalesTable originalSalesTable, SalesTable newSalesTable)
    {
        SalesTable_BR salesTable_BR, newSalesTable_BR;

        salesTable_BR = originalSalesTable.SalesTable_BR();

        newSalesTable_BR = newSalesTable.salesTable_BR();
        newSalesTable_BR.selectForUpdate(true);

        newSalesTable_BR.CustFinalUser_BR               = salesTable_BR.CustFinalUser_BR;
        newSalesTable_BR.FineCode_BR                    = salesTable_BR.FineCode_BR;
        newSalesTable_BR.FiscalDocumentType_BR          = salesTable_BR.FiscalDocumentType_BR;
        newSalesTable_BR.InterestCode_BR                = salesTable_BR.InterestCode_BR;

        newSalesTable_BR.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>batchInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// This batch job is not retryable because run() is not wrapped with a transaction.
    /// </summary>
    /// <returns>An instance of BatchInfo with the configuration for retryable and retries.</returns>
    public BatchInfo batchInfo()
    {
        BatchInfo info = super();

        info.parmRetryable(false);
        info.parmRetriesOnFailure(0);

        return info;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>