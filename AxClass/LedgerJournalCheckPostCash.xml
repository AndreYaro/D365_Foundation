<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalCheckPostCash</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Provides helper methods related to settlement for journal validation.
/// </summary>
public class LedgerJournalCheckPostCash extends LedgerJournalCheckPost implements BatchRetryable
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAddCashDiscTrans_ES</Name>
				<Source><![CDATA[
    private static void cashDiscAddCashDiscTrans_ES(
        LedgerVoucher _ledgerVoucher,
        DiscAmount _cashDiscountAmount,
        LedgerJournalTrans _custVendLedgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerPostingType ledgerPostingType = _custVendLedgerJournalTrans.AccountType == LedgerJournalACType::Cust ?
            LedgerPostingType::CustCashDisc :
            LedgerPostingType::VendCashDisc;

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _custVendLedgerJournalTrans.TransDate);
        exchangeRateHelper.parmExchangeRate1(_custVendLedgerJournalTrans.ExchRate);
        exchangeRateHelper.parmExchangeRate2(_custVendLedgerJournalTrans.ExchRateSecond);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _ledgerVoucher.findLedgerVoucherObject(),
            ledgerPostingType,
            LedgerJournalCheckPostCash::cashDiscGetCashDiscAccount_ES(_custVendLedgerJournalTrans, _ledgerPostingMessageCollection),
            _custVendLedgerJournalTrans.CurrencyCode,
            _cashDiscountAmount,
            exchangeRateHelper);

        ledgerVoucherTransObject.parmSourceTableId(_custVendLedgerJournalTrans.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_custVendLedgerJournalTrans.RecId);
        ledgerVoucherTransObject.parmQuantity(_custVendLedgerJournalTrans.Qty);
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAddFixedAssetTrans_ES</Name>
				<Source><![CDATA[
    // This method will post an invoice cash discount for a fixed asset.
    private static void cashDiscAddFixedAssetTrans_ES(LedgerVoucher _ledgerVoucher, LedgerJournalTrans _ledgerJournalTrans)
    {
        AssetPost assetPost;

        // Is there a cash discount to deduct?
        if (_ledgerJournalTrans.CashDiscAmount)
        {
            assetPost = AssetPost::newInvoiceCashDiscTrans(_ledgerVoucher, _ledgerJournalTrans);

            // Set the _checkNetBookValue parameter to "false"
            // because the discount asset transaction should not
            // check for "negative net book value" or
            // "netbook value higher than acquisition cost"
            // because the entire asset transaction will
            // be validated for this based on the transaction's
            // net value.
            if (assetPost.check(false, false))
            {
                // If the assetPost passes it's validation.
                // Post the asset's cash discount to the assetTrans
                // for the value models and for any derived value models.
                assetPost.post(true, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscAddTrans_ES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add cash discount trans.
    /// </summary>
    /// <param name = "_ledgerVoucher">The Ledger voucher.</param>
    /// <param name = "_ledgerJournalTrans">The journal line.</param>
    /// <param name = "_ledgerPostingMessageCollection">The message collection.</param>
    public static void cashDiscAddTrans_ES(
        LedgerVoucher _ledgerVoucher,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection)
    {
        LedgerJournalTrans custVendLedgerJournalTrans;

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust || _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            // We don't need to post cash discount transactions to Cust/Vend journal.
            // Cash discount amount is subtracted from the base amount of cust/vend transactions.
            // See the VendVoucher::newVendVoucherJournal()/CustVoucher::newCustVoucherJournal() method.
            return;
        }

        // Fetch Cust/Vend transaction from the same voucher
        select firstonly custVendLedgerJournalTrans
            where custVendLedgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher
                && custVendLedgerJournalTrans.TransDate == _ledgerJournalTrans.TransDate
                && custVendLedgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum
                && (custVendLedgerJournalTrans.AccountType == LedgerJournalACType::Cust
                    || custVendLedgerJournalTrans.AccountType == LedgerJournalACType::Vend
                    || custVendLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
                    || custVendLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend);

        if (!custVendLedgerJournalTrans.RecId)
        {
            // In the general journal (and derived daily journals) cash discounts can only apply to Cust and Vend invoices
            return;
        }

        if (custVendLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust
            || custVendLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            custVendLedgerJournalTrans.swapAccountOffsetAccount();
        }

        if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets && AssetParameters::find().DeductCashDisc)
        {
            LedgerJournalCheckPostCash::cashDiscAddFixedAssetTrans_ES(_ledgerVoucher, _ledgerJournalTrans);
        }
        else
        {
            LedgerJournalCheckPostCash::cashDiscAddCashDiscTrans_ES(
                _ledgerVoucher,
                -_ledgerJournalTrans.CashDiscAmount,
                custVendLedgerJournalTrans,
                _ledgerPostingMessageCollection);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscGetCashDiscAccount_ES</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the ledger dimension for the specifed cash discount.
    /// </summary>
    /// <param name = "_custVendLedgerJournalTrans">The ledger journal line with a cash discount.</param>
    /// <param name = "_ledgerPostingMessageCollection">The message collection.</param>
    /// <returns></returns>
    private static LedgerDimensionAccount cashDiscGetCashDiscAccount_ES(
        LedgerJournalTrans _custVendLedgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        CashDisc cashDisc;
        LedgerDimensionDefaultAccount cashDiscLedgerDimensionDefaultAccount;
        LedgerDimensionAccount cashDiscLedgerDimensionAccount;

        cashDisc = CashDisc::find(_custVendLedgerJournalTrans.CashDiscCode);

        if (_custVendLedgerJournalTrans.AccountType == LedgerJournalACType::Vend)
        {
            cashDiscLedgerDimensionDefaultAccount = cashDisc.ReceivedLedgerDimension ?
                cashDisc.ReceivedLedgerDimension :
                LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::VendCashDisc);
        }
        else
        {
            cashDiscLedgerDimensionDefaultAccount = cashDisc.PaidLedgerDimension ?
                cashDisc.PaidLedgerDimension :
                LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::CustCashDisc);
        }

        cashDiscLedgerDimensionAccount = LedgerDimensionFacade::serviceCreateLedgerDimension(cashDiscLedgerDimensionDefaultAccount, _custVendLedgerJournalTrans.DefaultDimension);

        if (!cashDiscLedgerDimensionAccount)
        {
            if (_ledgerPostingMessageCollection)
            {
                _ledgerPostingMessageCollection.logAndThrowError("@SYS99085");
            }
            else
            {
                throw error("@SYS99085");
            }
        }

        return cashDiscLedgerDimensionAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInVoucherErrorList</Name>
				<Source><![CDATA[
     /// <summary>
    /// Inserts an vouchers error into the error list.
    /// </summary>
    /// <param name = "_voucher">The voucher.</param>
    public void insertInVoucherErrorList(Voucher _voucher)
    {
        Voucher voucher;

        if (tmpVoucherMap)
        {
            voucher = tmpVoucherMap.lookup(_voucher);
            errorTmpVoucherMap.insert(_voucher, voucher);
        }
        else
        {
            voucher = _voucher;
        }

        if (transferErrors)
        {
            if (!voucherErrorList.in(voucher))
            {
                voucherErrorList.add(voucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyAutoPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a corresponding customer payment journal in the company that represents the vendor.
    /// </summary>
    /// <param name = "_caller">The <c>LedgerJournalCheckPost</c> caller.</param>
    public static void interCompanyAutoPost(LedgerJournalCheckPost _caller)
    {
        VendTable vendTable;
        CustTable custTable;
        VendAccount vendAccount;
        UserGroupId approveGroupId;

        LedgerJournalTable ledgerJournalTableAutoPost;
        MenuFunction postMenuFunction;
        Args args;
        int i;
        container newCompanyCon = _caller.parmNewCompanyCon();
        container newVendIdCon = _caller.parmNewVendIdCon();
        container newJournalNumCon = _caller.parmNewJournalNumCon();

        InterCompanyTradingValueMap fromInterCompanyTradingValueMap = _caller.parmFromInterCompanyTradingValueMap();
        InterCompanyTradingValueMap toInterCompanyTradingValueMap = _caller.parmToInterCompanyTradingValueMap();
        InterCompanyEndpointActionPolicy toInterCompanyEndpointActionPolicy = _caller.parmToInterCompanyEndpointActionPolicy();

        // Find the intercompany customer payment journals created and, if specified, post them.
        for (i = 1; i <= conLen(newCompanyCon); i++)
        {
            setPrefix("@SYS79376");

            vendAccount = conPeek(newVendIdCon, i);
            vendTable = VendTable::find(vendAccount);

            if (vendTable.interCompanyTradingPartnerCompanyID())
            {
                fromInterCompanyTradingValueMap = vendTable.interCompanyTradingPartner().interCompanyTradingValueMap();

                changecompany (vendTable.interCompanyTradingPartnerCompanyID())
                {
                    custTable = CustTable::find(vendTable.interCompanyTradingPartnerAccount());
                    toInterCompanyTradingValueMap = custTable.interCompanyTradingPartner().interCompanyTradingValueMap();
                    toInterCompanyEndpointActionPolicy = custTable.interCompanyTradingPartner().interCompanyEndpointActionPolicy();

                    setPrefix(strFmt("@SYS93821", TradeInterCompany::curCompanyName()));

                    // Auto-post the payment journal if the parameter is set on the customer reference.
                    if (toInterCompanyEndpointActionPolicy.AutoPostCustPaym)
                    {
                        ledgerJournalTableAutoPost = LedgerJournalTable::find(conPeek(newJournalNumCon, i));

                        if (ledgerJournalTableAutoPost.ledgerJournalName().ApproveActive)
                        {
                            approveGroupId = ledgerJournalTableAutoPost.ledgerJournalName().ApproveGroupId;

                            if (UserInfoHelp::userInUserGroup(curUserId(), approveGroupId))
                            {
                                postMenuFunction = new MenuFunction(menuitemActionStr(LedgerJourPostIntercompanyPayment), MenuItemType::Action);
                                args = new Args();
                                args.record(ledgerJournalTableAutoPost);
                                postMenuFunction.run(args);
                            }
                            else
                            {
                                ttsbegin;

                                ledgerJournalTableAutoPost = LedgerJournalTable::find(ledgerJournalTableAutoPost.JournalNum, true);
                                ledgerJournalTableAutoPost.markReportAsReady();
                                ledgerJournalTableAutoPost.update();

                                ttscommit;
                            }
                        }
                        else
                        {
                            postMenuFunction = new MenuFunction(menuitemActionStr(LedgerJourPostIntercompanyPayment), MenuItemType::Action);
                            args = new Args();
                            args.record(ledgerJournalTableAutoPost);
                            postMenuFunction.run(args);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCheckPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks payments for valid relation to intercompany invoice.
    /// </summary>
    /// <param name = "_caller">The <c>LedgerJournalCheckPost</c> caller.</param>
    public static void interCompanyCheckPayment(LedgerJournalCheckPost _caller)
    {
        LedgerJournalTrans ledgerJournalTrans;

        LedgerJournalTable LedgerJournalTable = _caller.parmLedgerJournalTable();

        if (ledgerJournalTable.JournalType == LedgerJournalType::Daily
            || ledgerJournalTable.JournalType == LedgerJournalType::Payment)
        {
            // Check payments for valid relation to intercompany invoice
            while select ledgerJournalTrans
                index hint NumVoucherIdx
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                    && ((ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                            && ledgerJournalTrans.LedgerDimension != 0)
                        || (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                            && ledgerJournalTrans.OffsetLedgerDimension != 0))
            {
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    LedgerJournalCheckPostCash::checkPaymentJournal(_caller, ledgerJournalTrans, ledgerJournalTrans.parmAccount());
                }

                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    LedgerJournalCheckPostCash::checkPaymentJournal(_caller, ledgerJournalTrans, ledgerJournalTrans.parmOffsetAccount());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentJournal</Name>
				<Source><![CDATA[
    private static void checkPaymentJournal(
        LedgerJournalCheckPost _caller,
        LedgerJournalTrans _ledgerJournalTrans,
        VendAccount _vendAccount)
    {
        VendTrans vendTrans;
        VendSettlement vendSettlement;

        select firstonly forceplaceholders crossCompany vendSettlement
            where vendSettlement.OffsetTransVoucher == _ledgerJournalTrans.Voucher
                && vendSettlement.OffsetCompany == _ledgerJournalTrans.Company
            join Invoice from vendTrans
                where vendTrans.RecId == vendSettlement.TransRecId
                    && vendTrans.AccountNum == vendSettlement.AccountNum;

        if (!vendTrans.Invoice && !_caller.parmBeQuiet())
        {
            warning(strFmt("@SYS98473", _ledgerJournalTrans.Voucher, _ledgerJournalTrans.amount()));
        }
        else if (!VendTable::find(_vendAccount).interCompanyTradingRelationActive())
        {
            warning(strFmt("@SYS98474", _ledgerJournalTrans.Voucher, vendTrans.Invoice));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPaymentExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a corresponding customer payment journal header in the company that represents
    /// the vendor is needed and creates it if necessary.
    /// </summary>
    /// <param name = "_caller">The <c>LedgerJournalCheckPost</c> caller.</param>
    /// <returns>true if a customer payment journal header was created; otherwise, false.</returns>
    public static boolean interCompanyPaymentExist(LedgerJournalCheckPost _caller)
    {
        LedgerJournalTrans ledgerJournalTrans;
        boolean ret = false;

        LedgerJournalTable LedgerJournalTable = _caller.parmLedgerJournalTable();

        if (ledgerJournalTable.JournalType == LedgerJournalType::Daily
            || ledgerJournalTable.JournalType == LedgerJournalType::Payment)
        {
            // Creation of CustPaymentJournal's for all intercompany vendor accounts
            while select ledgerJournalTrans
                index hint NumVoucherIdx
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                    && ((ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                            && ledgerJournalTrans.LedgerDimension != 0)
                        || (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                            && ledgerJournalTrans.OffsetLedgerDimension != 0))
            {
                if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                {
                    ret = LedgerJournalCheckPostCash::createCustPaymentJournal(_caller, ledgerJournalTrans, ledgerJournalTrans.parmAccount()) || ret;
                }

                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    ret = LedgerJournalCheckPostCash::createCustPaymentJournal(_caller, ledgerJournalTrans, ledgerJournalTrans.parmOffsetAccount()) || ret;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustPaymentJournal</Name>
				<Source><![CDATA[
    private static boolean createCustPaymentJournal(
        LedgerJournalCheckPost _caller,
        LedgerJournalTrans _ledgerJournalTrans,
        VendAccount _vendAccount)
    {
        boolean ret = false;

        VendTrans vendTrans;
        VendSettlement vendSettlement;
        LedgerJournalTable newLedgerJournalTable;
        JournalId newJournalId;

        VendTable vendTable;
        CustTable custTable;

        container newCompanyCon = _caller.parmNewCompanyCon();
        container newVendIdCon = _caller.parmNewVendIdCon();
        container newJournalNumCon = _caller.parmNewJournalNumCon();

        InterCompanyTradingValueMap fromInterCompanyTradingValueMap = _caller.parmFromInterCompanyTradingValueMap();
        InterCompanyEndpointActionPolicy toInterCompanyEndpointActionPolicy = _caller.parmToInterCompanyEndpointActionPolicy();

        select firstonly forceplaceholders crossCompany vendSettlement
            where vendSettlement.OffsetTransVoucher == _ledgerJournalTrans.Voucher
                && vendSettlement.OffsetCompany == _ledgerJournalTrans.Company
            join vendTrans
                where vendTrans.RecId == vendSettlement.TransRecId
                    && vendTrans.AccountNum == vendSettlement.AccountNum
                    && vendTrans.Invoice;

        if (vendTrans.Invoice)
        {
            ttsbegin;

            vendTable = VendTable::find(_vendAccount);

            if (vendTable.interCompanyTradingRelationActive())
            {
                fromInterCompanyTradingValueMap = vendTable.interCompanyTradingPartner().interCompanyTradingValueMap();

                changecompany (vendTable.interCompanyTradingPartnerCompanyID())
                {
                    newLedgerJournalTable = LedgerJournalTable::find(conPeek(newJournalNumCon, conFind(newCompanyCon, vendTable.interCompanyTradingPartnerCompanyID())));

                    if (!newLedgerJournalTable)
                    {
                        custTable = CustTable::find(vendTable.interCompanyTradingPartnerAccount());
                        toInterCompanyEndpointActionPolicy = custTable.interCompanyTradingPartner().interCompanyEndpointActionPolicy();

                        setPrefix(strFmt("@SYS93821", TradeInterCompany::curCompanyName()));

                        if (toInterCompanyEndpointActionPolicy.LedgerJournalNameIdCustPaym)
                        {
                            newLedgerJournalTable = null;
                            newJournalId = JournalTableData::newTable(newLedgerJournalTable).nextJournalId();
                            newJournalNumCon += newJournalId;
                            newCompanyCon += vendTable.interCompanyTradingPartnerCompanyID();
                            newVendIdCon += _vendAccount;

                            newLedgerJournalTable.JournalName = toInterCompanyEndpointActionPolicy.LedgerJournalNameIdCustPaym;
                            newLedgerJournalTable.JournalNum = newJournalId;
                            newLedgerJournalTable.initFromLedgerJournalName();
                            if (CustPaymInterCompanyTradeBankTransSummarizationFlight::instance().isEnabled())
                            {
                                newLedgerJournalTable.inheritBankTransSummarizationConfigurationFromJournalName();
                            }
                            newLedgerJournalTable.Name = "@SYS74106";
                            newLedgerJournalTable.insert();

                            _caller.parmNewCompanyCon(newCompanyCon);
                            _caller.parmNewJournalNumCon(newJournalNumCon);
                            _caller.parmNewVendIdCon(newVendIdCon);

                            if (!_caller.parmBeQuiet())
                            {
                                info(strFmt("@SYS94073", newLedgerJournalTable.JournalNum));
                            }

                            ret = true;
                        }
                    }
                }
            }

            ttscommit;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyTransferToCustPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a corresponding customer payment journal lines in the company that represents the vendor.
    /// </summary>
    /// <param name = "_caller">The <c>LedgerJournalCheckPost</c> caller.</param>
    public static void interCompanyTransferToCustPayment(LedgerJournalCheckPost _caller)
    {
        #OCCRetryCount

        LedgerJournalTrans ledgerJournalTrans;

        try
        {
            setPrefix("@SYS94074");

            if (LedgerJournalCheckPostCash::interCompanyPaymentExist(_caller))
            {
                LedgerJournalCheckPostCash::interCompanyCheckPayment(_caller);

                ttsbegin;

                LedgerJournalTable ledgerJournalTable = _caller.parmLedgerJournalTable();

                // Creation of payment journal lines for each intercompany account
                while select forupdate ledgerJournalTrans
                    index hint NumVoucherIdx
                    where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                        && ((ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
                                && ledgerJournalTrans.LedgerDimension != 0)
                            || (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend
                                && ledgerJournalTrans.OffsetLedgerDimension != 0))
                {
                    if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
                    {
                        LedgerJournalCheckPostCash::createCustPaymentTrans(_caller, ledgerJournalTrans, ledgerJournalTrans.parmAccount());
                    }

                    if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                    {
                        LedgerJournalCheckPostCash::createCustPaymentTrans(_caller, ledgerJournalTrans, ledgerJournalTrans.parmOffsetAccount());
                    }
                }

                ttscommit;

                LedgerJournalCheckPostCash::interCompanyAutoPost(_caller);
            }
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustPaymentTrans</Name>
				<Source><![CDATA[
    private static void createCustPaymentTrans(
        LedgerJournalCheckPost _caller,
        LedgerJournalTrans _ledgerJournalTrans,
        VendAccount _vendAccount)
    {
        LedgerJournalTrans newLedgerJournalTrans;
        VendTrans vendTrans;
        VendSettlement vendSettlement;

        #isoCountryRegionCodes
        LedgerJournalTransTaxExtensionIN newLedgerJournalTransExtension;

        container newCompanyCon = _caller.parmNewCompanyCon();
        container newJournalNumCon = _caller.parmNewJournalNumCon();

        InterCompanyTradingValueMap fromInterCompanyTradingValueMap = _caller.parmFromInterCompanyTradingValueMap();
        InterCompanyTradingValueMap toInterCompanyTradingValueMap = _caller.parmToInterCompanyTradingValueMap();
        InterCompanyEndpointActionPolicy toInterCompanyEndpointActionPolicy = _caller.parmToInterCompanyEndpointActionPolicy();

        InterCompanyJournalSettle_CustPayment settle_CustPayment = new InterCompanyJournalSettle_CustPayment();

        select firstonly forceplaceholders crossCompany vendSettlement
            where vendSettlement.OffsetTransVoucher == _ledgerJournalTrans.Voucher
                && vendSettlement.OffsetCompany == _ledgerJournalTrans.Company
            join vendTrans
                where vendTrans.RecId == vendSettlement.TransRecId
                    && vendTrans.AccountNum == vendSettlement.AccountNum
                    && vendTrans.Invoice;

        if (vendTrans.Invoice)
        {
            VendTable vendTable = VendTable::find(_vendAccount);
            if (vendTable.interCompanyTradingRelationActive())
            {
                fromInterCompanyTradingValueMap = vendTable.interCompanyTradingPartner().interCompanyTradingValueMap();

                changecompany (vendTable.interCompanyTradingPartnerCompanyID())
                {
                    CustTable custTable = CustTable::find(vendTable.interCompanyTradingPartnerAccount());
                    toInterCompanyTradingValueMap = custTable.interCompanyTradingPartner().interCompanyTradingValueMap();
                    toInterCompanyEndpointActionPolicy = custTable.interCompanyTradingPartner().interCompanyEndpointActionPolicy();

                    setPrefix(strFmt("@SYS93821", TradeInterCompany::curCompanyName()));

                    if (toInterCompanyEndpointActionPolicy.LedgerJournalNameIdCustPaym)
                    {
                        LedgerJournalTable newLedgerJournalTable = LedgerJournalTable::find(conPeek(newJournalNumCon, conFind(newCompanyCon, vendTable.interCompanyTradingPartnerCompanyID())));
                        NumberSeq numberSeq = NumberSeq::newGetNumFromId(newLedgerJournalTable.NumberSequenceTable);

                        newLedgerJournalTrans = LedgerJournalCheckPostCash::populateCustPaymentTrans(_ledgerJournalTrans, newLedgerJournalTable, custTable, vendTrans, numberSeq);
                        Voucher numAllocated = newLedgerJournalTrans.Voucher;
                        newLedgerJournalTrans.insert();

                        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                        {
                            newLedgerJournalTransExtension.clear();
                            newLedgerJournalTransExtension = newLedgerJournalTrans.ledgerJournalTransTaxExtensionIN();
                            newLedgerJournalTransExtension.LedgerJournalTrans = newLedgerJournalTrans.RecId;
                            newLedgerJournalTrans.SysExtensionSerializerMap::packExtensionTable(newLedgerJournalTransExtension);
                        }

                        if (numberSeq && newLedgerJournalTrans.Voucher == numAllocated)
                        {
                            numberSeq.used();
                        }
                        else if (numberSeq)
                        {
                            numberSeq.abort();
                        }
                    }

                    setPrefix("@SYS94075");

                    settle_CustPayment.settlePaym(_ledgerJournalTrans, newLedgerJournalTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustPaymentTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates customer payment journal lines.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// The journal line.
    /// </param>
    /// <param name = "_newLedgerJournalTable">
    /// The <c>LedgerJournalTable></c> record.
    /// </param>
    /// <param name = "_custTable">
    /// A <c>CustTable></c> record to set account type.
    /// </param>
    /// <param name = "_vendTrans">
    /// A <c>VendTrans</c> record used to set the journal text.
    /// </param>
    /// <param name = "_numberSeq">
    /// A <c>NumberSeq</c> class instance.
    /// </param>
    /// <returns>
    /// The populated <c>LedgerJournalTrans</c> buffer.
    /// </returns>
    protected static LedgerJournalTrans populateCustPaymentTrans(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTable _newLedgerJournalTable,
        CustTable _custTable,
        VendTrans _vendTrans,
        NumberSeq _numberSeq)
    {
        LedgerJournalTrans newLedgerJournalTrans;
        newLedgerJournalTrans.initValue();

        if (_numberSeq)
        {
            newLedgerJournalTrans.Voucher = _numberSeq.num();
        }

        newLedgerJournalTrans.JournalNum = _newLedgerJournalTable.JournalNum;
        newLedgerJournalTrans.TransDate = _ledgerJournalTrans.TransDate;

        if (_custTable.InvoiceAccount)
        {
            newLedgerJournalTrans.parmAccount(_custTable.InvoiceAccount, LedgerJournalACType::Cust);
        }
        else
        {
            newLedgerJournalTrans.parmAccount(_custTable.AccountNum, LedgerJournalACType::Cust);
        }

        LedgerJournalEngine_CustPayment ledgerJournalEngine_CustPayment = LedgerJournalEngine::construct(_newLedgerJournalTable.JournalType);
        ledgerJournalEngine_CustPayment.newJournalActive(_newLedgerJournalTable);
        ledgerJournalEngine_CustPayment.accountModified(newLedgerJournalTrans);
        newLedgerJournalTrans.Txt = strFmt("@SYS77381", _vendTrans.Invoice);
        newLedgerJournalTrans.AmountCurCredit = _ledgerJournalTrans.AmountCurDebit;
        newLedgerJournalTrans.AmountCurDebit = _ledgerJournalTrans.AmountCurCredit;

        if (_newLedgerJournalTable.OffsetAccountType == LedgerJournalACType::Ledger)
        {
            // if type is ledger need to create ledger account structure by merging the main
            // account and the dimensions for the main account with the currently entered values
            newLedgerJournalTrans.setOffsetLedgerDimension(
                _newLedgerJournalTable,
                _newLedgerJournalTable.OffsetAccountType,
                newLedgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                _newLedgerJournalTable.OffsetLedgerDimension,
                newLedgerJournalTrans.getOffsetCompany()));
        }
        else
        {
            newLedgerJournalTrans.OffsetLedgerDimension = _newLedgerJournalTable.parmOffsetLedgerDimension();
        }

        newLedgerJournalTrans.CurrencyCode = _ledgerJournalTrans.CurrencyCode;
        newLedgerJournalTrans.CashDiscAmount = -_ledgerJournalTrans.CashDiscAmount;
        newLedgerJournalTrans.TransactionType = _ledgerJournalTrans.TransactionType;
        ledgerJournalEngine_CustPayment.currencyModified(newLedgerJournalTrans);

        return newLedgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidateCreditCardPayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>boolean</c> value indicating that the amounts on the specified <c>MCRCustPaymTable</c>
    /// record buffer are correct when compared against the specified <c>LedgerJournalTrans</c> record buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record buffer to validate amounts against.
    /// </param>
    /// <param name="_mcrCustPaymTable">
    /// The <c>MCRCustPaymTable</c> record buffer who's amounts will be validated.
    /// </param>
    /// <returns>
    /// true if the amounts are valid; otherwise, false.
    /// </returns>
    public static boolean mcrValidateCreditCardPayments(
        LedgerJournalTrans _ledgerJournalTrans,
        MCRCustPaymTable _mcrCustPaymTable)
    {
        boolean ccPaymentsValidated = false;
        MCRCustPaymTotals mcrCustPaymTotals;
        MCRCustPaymTable mcrCustPaymTable;

        mcrCustPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(_ledgerJournalTrans.RecId, _ledgerJournalTrans.TableId, true);

        if (mcrCustPaymTable)
        {
            mcrCustPaymTotals = MCRCustPaymTotals::construct(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);

            // Call process payments to authorize the card.
            mcrCustPaymTotals.parmLedgerJournalTrans(_ledgerJournalTrans);
            ccPaymentsValidated = mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostAll);
        }

        return ccPaymentsValidated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrValidatePayments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that all the <c>LedgerJournalTrans</c> records, that have a <c>CustPaymentType</c>
    /// of credit card, have accurate payments.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record buffer to validate payments against.
    /// </param>
    /// <returns>
    /// A <c>boolean</c> value indicating that all payments are valid; otherwise, false.
    /// </returns>
    public static boolean mcrValidatePayments(LedgerJournalTable _ledgerJournalTable)
    {
        boolean paymentsValidated = true;
        LedgerJournalTrans ledgerJournalTrans;
        MCRCustPaymTable mcrCustPaymTable;
        int numInvalidPayments = 0;

        while select ledgerJournalTrans
            where ledgerJournalTrans.AccountType == LedgerJournalACType::Cust
                && ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
            join forupdate mcrCustPaymTable
                where mcrCustPaymTable.RefTableId == ledgerJournalTrans.TableId
                    && mcrCustPaymTable.RefRecId == ledgerJournalTrans.RecId
                    && mcrCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard
        {
            paymentsValidated = LedgerJournalCheckPostCash::mcrValidateCreditCardPayments(
                ledgerJournalTrans,
                mcrCustPaymTable);

            if (paymentsValidated == false)
            {
                numInvalidPayments += 1;
            }
        }
        if (numInvalidPayments > 0)
        {
            paymentsValidated = false;
        }
        else
        {
            paymentsValidated = true;
        }

        return paymentsValidated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePDC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the postdated check posting that is associated with the payment is valid.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>ledgerJournalTrans</c> record for which the postdated check has to validate.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    /// The posting messages collection; optional.
    /// </param>
    /// <returns>
    /// true if the postdated check posting is valid for the current <c>ledgerJournalTrans</c> record;
    /// otherwise, false.
    /// </returns>
    public static boolean validatePDC(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        CustVendPDCRegister custVendPDCRegister;
        CustVendAC custVendAC;
        boolean ok = true;

        custVendPDCRegister = CustVendPDCRegister::findByReference(_ledgerJournalTrans.RecId);

        if (custVendPDCRegister && CustVendPDCManager::allowPostDatedChecks(_ledgerJournalTrans))
        {
            custVendAC = _ledgerJournalTrans.parmAccount();

            if (custVendPDCRegister.MaturityDate > DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())
                && !BankParameters::find().PostTransPDC)
            {
                ok = LedgerJournalCheckPostCash::logWarningMesage("@SYS338905", _ledgerPostingMessageCollection);
            }

            if (custVendPDCRegister.pdcStatus == PostDatedCheckStatus::OnHold)
            {
                ok = LedgerJournalCheckPostCash::logWarningMesage("@SYS330990", _ledgerPostingMessageCollection);
            }

            if (!custVendPDCRegister.CheckNumber)
            {
                ok = LedgerJournalCheckPostCash::logWarningMesage("@SYS330991", _ledgerPostingMessageCollection);
            }

            if (!custVendPDCRegister.MaturityDate)
            {
                ok = LedgerJournalCheckPostCash::logWarningMesage("@SYS330992", _ledgerPostingMessageCollection);
            }
            
            var systemDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
            if (FeatureStateProvider::isFeatureEnabled(CustVendPDCMaturityDateValidationFeature::instance()))
            {
                if (custVendPDCRegister.MaturityDate <= systemDate && _ledgerJournalTrans.OffsetAccountType != LedgerJournalACType::Bank)
                {
                    ok = LedgerJournalCheckPostCash::logWarningMesage("@ApplicationSuite_Localization:PDCMaturityDateShouldBeGreater", _ledgerPostingMessageCollection);
                }
                else if (custVendPDCRegister.MaturityDate > systemDate && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
                {
                    ok = LedgerJournalCheckPostCash::logWarningMesage("@ApplicationSuite_Localization:PDCMaturityDateShouldBeLess", _ledgerPostingMessageCollection);
                }
            }
            else if (custVendPDCRegister.MaturityDate <= systemDate)
            {
                ok = LedgerJournalCheckPostCash::logWarningMesage("@SYS330443", _ledgerPostingMessageCollection);
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logWarningMesage</Name>
				<Source><![CDATA[
    private static boolean logWarningMesage(str _message, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ret;
        if (_ledgerPostingMessageCollection)
        {
            ret = _ledgerPostingMessageCollection.logCheckFailed(_message);
        }
        else
        {
            ret = checkFailed(_message);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedInvoiceRecIdLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>MarkedInvoiceRecId</c> field to zero on customer payment journals.
    /// </summary>
    public static void updateMarkedInvoiceRecIdLines(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        // The marked invoice rec id is only set on customer payment journals and once
        // the journal is posted it is not used. So posting will update this field to zero.
        // The MarkedInvoice string field is left at its original value though as this
        // is a string value and does not cause referential integrity problems.
        if (_ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
        {
            ledgerJournalTrans.skipDataMethods(true);
            ledgerJournalTrans.skipDatabaseLog(true);
            ledgerJournalTrans.skipEvents(true);

            update_recordset ledgerJournalTrans
                setting MarkedInvoiceRecId = 0
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settlePayrollDisbursementJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to settle a posted journal against a supplied vendor invoice.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// The journal header.
    /// </param>
    /// <param name="_vendTransOriginal">
    /// A <c>VendTrans</c> record which is used to settle the journal.
    /// </param>
    public static void settlePayrollDisbursementJournal(LedgerJournalTable _ledgerJournalTable, VendTrans _vendTransOriginal, boolean _beQuiet)
    {
        VendTable vendTable = VendTable::find(_vendTransOriginal.AccountNum);
        VendTransOpen vendTransOpenFieldList;
        SpecTransManager specTransManager;
        LedgerJournalTrans ledgerJournalTrans;
        NoYes foundVendTransOpen = NoYes::No;

        specTransManager = SpecTransManager::newFromSpec(vendTable);

        if (specTransManager.getSpecTransCount() > 0)
        {
            specTransManager.deleteAll();
        }

        while select DataAreaId, TableId, RecId, AmountCur from vendTransOpenFieldList
            where vendTransOpenFieldList.RefRecId == _vendTransOriginal.RecId
        {
            specTransManager.insert(vendTransOpenFieldList.DataAreaId, vendTransOpenFieldList.TableId, vendTransOpenFieldList.RecId, vendTransOpenFieldList.AmountCur, _vendTransOriginal.CurrencyCode);
            foundVendTransOpen = NoYes::Yes;
        }

        if (!foundVendTransOpen)
        {
            if (!_beQuiet)
            {
                warning(strFmt("@GLS94663", _vendTransOriginal.Invoice));
            }
        }
        else
        {
            while select VendTransId from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
            {
                while select DataAreaId, TableId, RecId, AmountCur from vendTransOpenFieldList
                    where vendTransOpenFieldList.RefRecId == ledgerJournalTrans.VendTransId
                {
                    specTransManager.insert(vendTransOpenFieldList.DataAreaId, vendTransOpenFieldList.TableId, vendTransOpenFieldList.RecId, vendTransOpenFieldList.AmountCur, _vendTransOriginal.CurrencyCode);
                }
            }

            try
            {
                VendTrans::settleTransact(vendTable);
            }
            catch
            {
                if (!_beQuiet)
                {
                    warning(strFmt("@GLS94664", _vendTransOriginal.Invoice));
                }
            }
        }

        specTransManager.deleteAll();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>