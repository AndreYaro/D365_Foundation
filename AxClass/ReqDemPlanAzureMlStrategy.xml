<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqDemPlanAzureMlStrategy</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.AX.DemandPlanning.Azure;
using Microsoft.Dynamics.AX.DemandPlanning.Azure.Data;

/// <summary>
///     The <c>ReqDemPlanAzureMlStrategy</c> class is responsible for creating the forecast using Azure Machine Learning.
/// </summary>
[ReqDemPlanForecastStrategyAttribute]
class ReqDemPlanAzureMlStrategy extends ReqDemPlanForecastStrategy
{
    private const ReqDemPlanForecastingStrategy ForecastingStrategyAzureML = ReqDemPlanForecastingStrategy::AzureMachineLearning;

    ReqDemPlanTaskLoggerInterface                               logger;
    List                                                        globalAlgorithmParameters;
    UnitOfMeasureDecimalPrecision                               importPrecision;
    date                                                        forecastStartDate;
    date                                                        forecastEndDate;
    ReqDemPlanDataProcessingHelper                              processingHelper;
    ReqDemPlanForecastParameters                                globalForecastParameters;
    ReqDemPlanDataProcessingHelper                              dataProcessingHelper;
    ReqDemplanForecastIAKParameters                             globalAllocationKeyParameters;
    RefRecId                                                    forecastVersion;
    IForecastClient                                             azureClient;
    boolean                                                     readersColumnsChecked;
    boolean                                                     useRequestResponseMode;
    int                                                         granularityColumn;
    int                                                         qtyColumn;
    int                                                         dateKeyColumn;
    int                                                         sigmaColumn;
    boolean                                                     reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled;

    #ReqDemPlan
    #ReqDemPlanTask
    #BIFramework
    #ReqDemPlanForecastAlgorithmParameters

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>dbFieldName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the field name in the database.
    /// </summary>
    /// <param name="_tableId">
    ///     The table ID.
    /// </param>
    /// <param name="_fieldId">
    ///     The field ID.
    /// </param>
    /// <returns>
    ///     The field name in the database.
    /// </returns>
    [Wrappable(false)]
    protected str dbFieldName(TableId _tableId, FieldId _fieldId)
    {
        return ReqDemPlanDataProcessingHelper::dbFieldName(_tableId, _fieldId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dbTableName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the table name in the database.
    /// </summary>
    /// <param name="_tableId">
    ///     The table ID.
    /// </param>
    /// <returns>
    ///     The table name in the database.
    /// </returns>
    [Wrappable(false)]
    protected str dbTableName(TableId _tableId)
    {
        return ReqDemPlanDataProcessingHelper::dbTableName(_tableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getForecastingStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns binded forecasting strategy enum value.
    /// </summary>
    /// <returns>
    ///     The strategy enum value.
    /// </returns>
    [Wrappable(false)]
    protected ReqDemPlanForecastingStrategy getForecastingStrategy()
    {
        return ReqDemPlanAzureMlStrategy::ForecastingStrategyAzureML;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showDeprecationMessage</Name>
				<Source><![CDATA[
    private void showDeprecationMessage()
    {
        if (ReqDemPlanAzureMachineLearningServiceFeature::isEnabled() && this.getForecastingStrategy() == ForecastingStrategyAzureML)
        {
            warning(strFmt("@DMP:MLSDeprecationNoticeForAzureMl", enum2Str(ReqDemPlanForecastingStrategy::AzureMachineLearning), enum2Str(ReqDemPlanForecastingStrategy::MachineLearningService)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanForecastingStrategyRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if current forecasting strategy is enabled and can be run.
    /// </summary>
    /// <returns>
    ///     true if it is enabled, otherwise, false.
    /// </returns>
    [Wrappable(false)]
    protected boolean checkCanForecastingStrategyRun()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>execute</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes the statistical forecast creation.
    /// </summary>
    /// <param name="_allocationKeyFilterTable">
    ///     Temporary table instance holding the allocation keys to be processed.
    /// </param>
    /// <param name="_dataContract">
    ///     Data contract holding the forecast generation related information.
    /// </param>
    /// <param name="_forecastVersion">
    ///     Version to be used for the forecast generation.
    /// </param>
    /// <param name="_logger">
    ///     The logger instance to be used for logging.
    /// </param>
    public void execute(
        ReqDemPlanAllocationKeyFilterTmp        _allocationKeyFilterTable,
        ReqDemPlanCreateForecastDataContract    _dataContract,
        RefRecId                                _forecastVersion,
        ReqDemPlanTaskLoggerInterface           _logger)
    {
        using (var instrumentation = ReqInstrumentationSegmentFactory::create(ReqInstrumentationActivities::DemandForecastGenerationAzureML))
        {
            if (this.isStatisticalForecastNeeded(_allocationKeyFilterTable))
            {
                if (!this.checkCanForecastingStrategyRun())
                {
                    return;
                }

                this.showDeprecationMessage();

                reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled = ReqDemPlanCreateForecastService::isTransientSqlConnectionErrorRetryEnabled();

                forecastVersion = _forecastVersion;

                this.init();

                this.parmLogger(_logger);

                processingHelper  = ReqDemPlanDataProcessingHelper::construct();

                this.prepareMiningModelStagingTable(_dataContract, _allocationKeyFilterTable);
                this.generateAndImportPredictions(_dataContract, _allocationKeyFilterTable);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateAndImportPredictions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sends the data to AzureML and retrieves the result.
    /// </summary>
    /// <param name="_dataContract">
    ///     The data contract.
    /// </param>
    /// <param name="_allocationKeyFilterTable">
    ///     Temporary table hodling the values for the allocation keys to be used.
    /// </param>
    private void generateAndImportPredictions(
        ReqDemPlanCreateForecastDataContract    _dataContract,
        ReqDemPlanAllocationKeyFilterTmp        _allocationKeyFilterTable)
    {
        System.Exception                    ex;
        str                                 exceptionText;
        int infologLineTry = infologLine();

        try
        {
            logger.startMonitoredTask(ReqDemPlanTaskCodes::GenerateAndImportForecastInML, "@DMP1119");
            logger.setTaskRank(#DefaultTaskRank + 1);

            forecastStartDate = _dataContract.offsetForecastStartDate();
            forecastEndDate = _dataContract.actualDemandEndDate();

            this.ensureAzureClientCreated();
            this.setParameters(_allocationKeyFilterTable);
            this.feedHistoricalData(_allocationKeyFilterTable);
            this.importPredictions(_dataContract, _allocationKeyFilterTable);

            logger.finishTask();
        }
        catch (Exception::CLRError)
        {
            ex = CLRInterop::getLastException();
            ApplicationUnhandledExceptionLogger::logCLRException(ex);

            exceptionText = ex.ToString();
            logger.taskFailed(exceptionText);

            this.checkAndDisplayTimeoutWarning(exceptionText);

            //detailed exception has been logged, override to show simple exception message in the infolog
            exceptionText = strFmt("@DMP1248", ReqDemPlanExceptionHelper::getBasicExceptionMessage(ex));
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (ReqDemPlanCreateForecastService::canRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled))
            {
                ReqDemPlanCreateForecastService::prepareRetryDataContract(_dataContract, _allocationKeyFilterTable);
                ReqDemPlanCreateForecastService::logTransientErrorRetry(logger, true);//logger, failLoggerTask
                azureClient = null;

                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::Error)
        {
            if (ReqDemPlanCreateForecastService::isTransientSqlConnectionError(infologLineTry)
                && ReqDemPlanCreateForecastService::canRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled))
            {
                ReqDemPlanCreateForecastService::prepareRetryDataContract(_dataContract, _allocationKeyFilterTable);
                ReqDemPlanCreateForecastService::logTransientErrorRetry(logger, true);//logger, failLoggerTask
                azureClient = null;

                retry;
            }
            else
            {
                throw;
            }
        }
        catch
        {
            exceptionText = "@DMP1027";
            logger.taskFailed(exceptionText);
        }

        if (exceptionText)
        {
            throw error(exceptionText);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAndDisplayTimeoutWarning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if timeout exception has been thrown by Azure Machine learning service
    /// and shows information how to solve this issue.
    /// </summary>
    /// <param name = "exceptionText">Text of the service exception.</param>
    private void checkAndDisplayTimeoutWarning(str exceptionText)
    {
        if (useRequestResponseMode)
        {
            System.Globalization.CultureInfo cultureInfo = System.Globalization.CultureInfo::InvariantCulture;
            if (cultureInfo.CompareInfo.IndexOf(exceptionText, 'timeout', System.Globalization.CompareOptions::IgnoreCase) > 0)
            {
                warning(strfmt("@DMP:AzureMlRequestResponseTimeoutDetected", "@DMP1036"));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets up forecasting parameters.
    /// </summary>
    /// <param name = "_allocationKeyFilterTable">The allocation key filter table buffer.</param>
    private void setParameters(ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        ReqDemPlanForecastAzureMlParameters     globalParameters;
        ReqDemPlanForecastAzureMlParameters     allocationKeyParameters;
        ReqDemPlanDefaultAlgorithmParameters    defaultParameters;
        ReqDemPlanForecastIAKMap                allocationKeyMapping;
        DataArea                                dataArea;
        ReqDemPlanForecastAzureMlAlgorithmParametersChecker algorithmParametersChecker;

        if (ReqDemPlanForecastAzureMlAlgorithmParametersCheckToggle::instance().isEnabled())
        {
            algorithmParametersChecker = new ReqDemPlanForecastAzureMlAlgorithmParametersChecker();
        }

        while select defaultParameters
        {
            azureClient.AddGlobalParameter(defaultParameters.RealName, defaultParameters.Value);

            if (algorithmParametersChecker)
            {
                algorithmParametersChecker.addGlobalParameter(defaultParameters.RealName, defaultParameters.Value);
            }
        }

        while select globalParameters
            join defaultParameters
                where globalParameters.ForecastIAKParameters == globalForecastParameters.ReqDemplanForecastIAKParameters
                && globalParameters.DefaultAlgorithmParameter == defaultParameters.RecId
        {
            azureClient.AddGlobalParameter(defaultParameters.RealName, globalParameters.Value);

            if (algorithmParametersChecker)
            {
                algorithmParametersChecker.addGlobalParameter(defaultParameters.RealName, globalParameters.Value);
            }
        }

        while select crossCompany _allocationKeyFilterTable
            join dataArea
                where _allocationKeyFilterTable.DataAreaId == dataArea.id
            join allocationKeyMapping
                where dataArea.id                           == allocationKeyMapping.ForecastItemAllocationDataAreaID
                    && _allocationKeyFilterTable.AllocateId == allocationKeyMapping.ForecastItemAllocation
            join allocationKeyParameters
                where allocationKeyParameters.ForecastIAKParameters == allocationKeyMapping.ReqDemplanForecastIAKParameters
                    && _allocationKeyFilterTable.ForecastingStrategy == this.getForecastingStrategy()
            join defaultParameters
                where allocationKeyParameters.DefaultAlgorithmParameter == defaultParameters.RecId
        {
            azureClient.AddParameterForAllocationKey(int642Str(_allocationKeyFilterTable.AllocationKeyRecId), defaultParameters.RealName, allocationKeyParameters.Value);

            if (algorithmParametersChecker)
            {
                algorithmParametersChecker.addParameterForAllocationKey(allocationKeyMapping.RecId, defaultParameters.RealName, allocationKeyParameters.Value);
            }
        }

        if (algorithmParametersChecker)
        {
            algorithmParametersChecker.check(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>feedHistoricalData</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Provides historical data to the AzureML client library.
    /// </summary>
    /// <param name = "_allocationKeyFilterTable">The allocation key filter table buffer.</param>
    [Wrappable(false)]
    protected void feedHistoricalData(ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        while select crossCompany _allocationKeyFilterTable
            where _allocationKeyFilterTable.ForecastingStrategy == this.getForecastingStrategy()
        {
            changecompany (_allocationKeyFilterTable.company())
            {
                ReqDemPlanMiningModelStagingTable   miningModelStagingTable;
                select miningModelStagingTable
                    order by miningModelStagingTable.GranularityAttribute, miningModelStagingTable.DateKey
                    where miningModelStagingTable.AllocationKey == _allocationKeyFilterTable.AllocateId;

                azureClient.AddHistoricalTransactions(int642Str(_allocationKeyFilterTable.AllocationKeyRecId), new ReqDemPlanTableDataReader(miningModelStagingTable));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importPredictions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Imports predictions made by AzureML.
    /// </summary>
    /// <param name = "_dataContract">The data contract.</param>
    /// <param name = "_allocationKeyFilterTable">The allocation key filter table buffer.</param>
    private void importPredictions(ReqDemPlanCreateForecastDataContract _dataContract, ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        ReqDemPlanForecast                  forecast;
        ReqDemPlanDateConverter             dateConverter           = ReqDemPlanDateConverter::construct();
        List                                enabledAttributeFields;
        ReqDemPlanForecastAttributeManager  attributeManager        = _dataContract.attributeManager();
        RecordInsertList                    forecastRecordList;

        enabledAttributeFields = attributeManager.getAttributeFields(
            tableNum(ReqDemPlanForecast),
            attributeManager.getAllEnabledAttributes());

        new SkipAOSValidationPermission().assert();
        forecastRecordList = new RecordInsertList(tableNum(ReqDemPlanForecast), true, true, true, true, true);

        var forecastStartDateKey = dateConverter.dateToDateKey(forecastStartDate, _dataContract.parmDateGranularity());
        var forecaseHistoryDateRangeFromKey = dateConverter.dateToDateKey(_dataContract.parmHistoricalStart(), _dataContract.parmDateGranularity());
        var forecaseHistoryDateRangeToKey   = dateConverter.dateToDateKey(_dataContract.parmHistoricalEnd(), _dataContract.parmDateGranularity());

        azureClient.AddGlobalParameter(#Horizon, int2Str(_dataContract.parmForecastHorizon()));
        azureClient.AddGlobalParameter(#ForecastStartDateKey, int2Str(forecastStartDateKey));
        azureClient.AddGlobalParameter(#ForecastHistoryDateRangeFrom, int2Str(forecaseHistoryDateRangeFromKey));
        azureClient.AddGlobalParameter(#ForecastHistoryDateRangeTo, int2Str(forecaseHistoryDateRangeToKey));

        var forecastReaders = azureClient.GenerateForecast();

        try
        {
            var enumerator = forecastReaders.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ISimpleDataReader forecastReader = enumerator.get_Current();

                if (!readersColumnsChecked)
                {
                    dateKeyColumn = forecastReader.GetOrdinal(DataReaderColumns::DateKey);
                    granularityColumn = forecastReader.GetOrdinal(DataReaderColumns::GranularityAttribute);
                    qtyColumn = forecastReader.GetOrdinal(DataReaderColumns::Quantity);
                    sigmaColumn = forecastReader.GetOrdinal(DataReaderColumns::Sigma);
                    readersColumnsChecked = true;
                }

                List pendingRecordsList = new List(Types::Record);

                while (forecastReader.Read())
                {
                    if (this.prepareForecastLine(forecast, _dataContract, forecastReader, dateConverter, enabledAttributeFields, _allocationKeyFilterTable))
                    {
                        if (reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled)
                        {
                            pendingRecordsList.addEnd(forecast);
                        }
                        else
                        {
                            changecompany(forecast.DataAreaId)
                            {
                                forecastRecordList.add(forecast);
                            }
                        }
                    }

                    if (pendingRecordsList.elements() == this.flushRecordsCount())
                    {
                        this.flushPendingForecastRecordsToDatabase(pendingRecordsList, _dataContract, _allocationKeyFilterTable);

                        pendingRecordsList = new List(Types::Record);
                    }
                }

                this.flushPendingForecastRecordsToDatabase(pendingRecordsList, _dataContract, _allocationKeyFilterTable);
            }

            if (reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled)
            {
                this.saveModelVariables(attributeManager, _dataContract, _allocationKeyFilterTable);
            }
            else
            {
                ttsbegin;

                this.saveModelVariables(attributeManager, _dataContract, _allocationKeyFilterTable);

                forecastRecordList.insertDatabase();

                ttscommit;
            }
        }
        finally
        {
            if (forecastReaders)
            {
                var enumerator = forecastReaders.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ISimpleDataReader forecastReader = enumerator.get_Current();
                    if (forecastReader)
                    {
                        forecastReader.Dispose();
                    }
                }
            }
            
            ReqDemPlanCreateForecastGuid::cleanUp();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushRecordsCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of records in a list to be saved.
    /// </summary>
    /// <returns>The number of records in a list to be saved.</returns>
    protected int flushRecordsCount()
    {
        return 1000;
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushPendingForecastRecordsToDatabase</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saved data to database.
    /// </summary>
    /// <param name = "_pendingRecordsList">The records imported to memory.</param>
    /// <param name = "_dataContract">The data contract to refresh tmp tables.</param>
    /// <param name = "_allocationKeyFilterTable">The tmp table to be refreshed.</param>
    private void flushPendingForecastRecordsToDatabase(List _pendingRecordsList,
        ReqDemPlanCreateForecastDataContract _dataContract,
        ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        guid importId = newGuid();
        int infologLineTry = infologLine();
        
        try
        {
            if (_pendingRecordsList.elements())
            {
                ttsbegin;

                //Checkd the case when transaction is committed but error is thrown
                ReqDemPlanCreateForecastGuid reqDemPlanCreateForecastGuid = ReqDemPlanCreateForecastGuid::find(importId, true);

                if (reqDemPlanCreateForecastGuid)
                {
                    reqDemPlanCreateForecastGuid.delete();
                    return;
                }
                else
                {
                    reqDemPlanCreateForecastGuid.ImportId = importId;
                    reqDemPlanCreateForecastGuid.insert();
                }

                this.flushingPendingForecastRecordsToDatabase();

                RecordInsertList forecastRecordList = new RecordInsertList(tableNum(ReqDemPlanForecast), true, true, true, true, true);
                ListEnumerator listEnumerator = _pendingRecordsList.getEnumerator();

                while (listEnumerator.moveNext())
                {
                    ReqDemPlanForecast forecast = listEnumerator.current();

                    changecompany(forecast.DataAreaId)
                    {
                        forecastRecordList.add(forecast);
                    }
                }

                forecastRecordList.insertDatabase();

                ttscommit;
            }
        }
        #ReqDemPlanCatchRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, _dataContract, _allocationKeyFilterTable, logger, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushingPendingForecastRecordsToDatabase</Name>
				<Source><![CDATA[
    delegate void flushingPendingForecastRecordsToDatabase()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the instance of the class to be executed.
    /// </summary>
    public void init()
    {
        ReqDemPlanForecastAzureMlParameters algorithmParameters;

        globalAlgorithmParameters = algorithmParameters.getGlobalAlgorithmParameters();

        globalForecastParameters = ReqDemPlanForecastParameters::find();
        importPrecision = globalForecastParameters.forecastingUnitOfMeasure().DecimalPrecision;
        globalAllocationKeyParameters = globalForecastParameters.allocationKeyParameters();
        useRequestResponseMode = globalForecastParameters.AzureMlUseRequestResponseMode;

        dataProcessingHelper = ReqDemPlanDataProcessingHelper::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Resolves the compound granularity key.
    /// </summary>
    /// <param name="_buffer">
    ///     The record buffer.
    /// </param>
    /// <param name="_key">
    ///     The compound key.
    /// </param>
    /// <param name="_enabledAttributes">
    ///     The list of enabled forecast attributes.
    /// </param>
    private void initializeAttributes(
        Common              _buffer,
        str                 _key,
        List                _enabledAttributes)
    {
        List                keyAttributes;
        ListEnumerator      keyAttributesEnumerator;
        ListEnumerator      enabledAttributeEnumerator;
        FieldId             attributeFieldId;
        str                 value;
        int                 i;
        int                 enabledAttributesCount = _enabledAttributes.elements();

        keyAttributes = strSplit(_key, num2char(#GranularityDelimiterAsciiCode));

        //If a mining model key ends with NewLine+EmptyString, the end of the string is trimmed altogether.
        //This can happen only when there are empty attribute values in the end of the key.
        for (i = keyAttributes.elements(); i < enabledAttributesCount; i++)
        {
            keyAttributes.addEnd('');
        }

        if (keyAttributes.elements() != enabledAttributesCount)
        {
            throw error(strFmt("@DMP1441",
                _key, keyAttributes.elements(), enabledAttributesCount));
        }

        keyAttributesEnumerator = keyAttributes.getEnumerator();
        enabledAttributeEnumerator = _enabledAttributes.getEnumerator();

        while (keyAttributesEnumerator.moveNext() && enabledAttributeEnumerator.moveNext())
        {
            value = keyAttributesEnumerator.current();
            attributeFieldId = enabledAttributeEnumerator.current();

            if (attributeFieldId == fieldNum(Common, DataAreaId))
            {
                _buffer.company(value);
            }
            else
            {
                _buffer.(attributeFieldId) = value;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatisticalForecastNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks if there will be any need for statistical forecast generation, so that the initialization can proceed.
    /// </summary>
    /// <param name="_allocationKeyFilterTable">
    ///     Temporary table hodling the values for the allocation keys to be used.
    /// </param>
    /// <returns>
    ///     <c>True</c> if there are IAK with statistical forecast, <c>False</c> otherwise
    /// </returns>
    private boolean isStatisticalForecastNeeded(ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        select firstOnly RecId from _allocationKeyFilterTable where _allocationKeyFilterTable.ForecastingStrategy == this.getForecastingStrategy();

        return _allocationKeyFilterTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [SuppressBpWarning('BPErrorClassNewNotProtected', 'The constructor is preserved public due to API compatibility.')]
    public void new()
    {
        // initialize logger instance
        this.parmLogger(null);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLogger</Name>
				<Source><![CDATA[
    public ReqDemPlanTaskLoggerInterface parmLogger(ReqDemPlanTaskLoggerInterface _logger = logger)
    {
        if (!prmisDefault(_logger))
        {
            logger = _logger;

            if (logger == null)
            {
                // ensure logger instance is never null
                logger = ReqDemPlanDummyTaskLogger::construct();
            }
        }

        return logger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareForecastLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a forecast line.
    /// </summary>
    /// <param name="_forecast">
    ///     The forecast line to be prepared.
    /// </param>
    /// <param name="_dataContract">
    ///     The data contract.
    /// </param>
    /// <param name="_reader">
    ///     The adomd data _reader instance.
    /// </param>
    /// <param name="_dateConverter">
    ///     The date converter instance
    /// </param>
    /// <param name="_enabledAttributes">
    ///     The list of enabled forecast attributes.
    /// </param>
    /// <param name="_allocationKeyFilterTable">
    ///     Temporary table hodling the values for the allocation keys to be used.
    /// </param>
    /// <returns>
    ///     true if the record should be inserted in the database; otherwise false.
    /// </returns>
    private boolean prepareForecastLine(
        ReqDemPlanForecast                              _forecast,
        ReqDemPlanCreateForecastDataContract            _dataContract,
        ISimpleDataReader                               _reader,
        ReqDemPlanDateConverter                         _dateConverter,
        List                                            _enabledAttributes,
        ReqDemPlanAllocationKeyFilterTmp                _allocationKeyFilterTable)
    {
        boolean                             result = false;
        str                                 currValue;
        real                                qty;
        date                                nonFrozenForecastStartDate;

        int infologLineTry = infologLine();

        try
        {
            _forecast.clear();

            _forecast.ForecastDate = _dateConverter.dateKeyToDate(_reader.GetInt32(dateKeyColumn), _dataContract.parmDateGranularity());

            if (_forecast.ForecastDate >= forecastStartDate && _forecast.ForecastDate <= forecastEndDate)
            {
                result = true;

                currValue = _reader.GetString(granularityColumn);
                this.initializeAttributes(_forecast, currValue, _enabledAttributes);

                if (_allocationKeyFilterTable.DataAreaId != _forecast.company() || _allocationKeyFilterTable.AllocateId != _forecast.AllocationKey)
                {
                    select crosscompany _allocationKeyFilterTable
                        where _allocationKeyFilterTable.DataAreaId == _forecast.company()
                            && _allocationKeyFilterTable.AllocateId == _forecast.AllocationKey
                        && _allocationKeyFilterTable.ForecastingStrategy == this.getForecastingStrategy();
                }

                qty = processingHelper.normalizeQty(_reader.GetDecimal(qtyColumn), currValue, true, _allocationKeyFilterTable);
                if (qty == _allocationKeyFilterTable.MinValue || qty == _allocationKeyFilterTable.MaxValue)
                {
                    _forecast.Qty = qty;
                }
                else
                {
                    _forecast.Qty = decRound(qty, importPrecision);
                }

                _forecast.OriginalQty = _forecast.Qty;
                _forecast.Sigma = min(_reader.GetDecimal(sigmaColumn), ReqDemPlanDataProcessingHelper::getMinMaxDBValueReal());

                nonFrozenForecastStartDate = _dateConverter.addPeriods(
                                                                         forecastStartDate,
                                                                         _dataContract.parmDateGranularity(),
                                                                         _dataContract.parmFreezingHorizon());

                _forecast.InsideFreezingHorizon = _forecast.ForecastDate < nonFrozenForecastStartDate;
                _forecast.Version = forecastVersion;
            }

            logger.incrementTaskRecordsProcessed();
        }
        #ReqDemPlanCatchRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, _dataContract, _allocationKeyFilterTable, logger, infologLineTry)

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareMiningModelStagingTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs the query against the historical data in the staging table.
    /// </summary>
    /// <param name="_dataContract">
    ///     The data contract.
    /// </param>
    /// <param name="_allocationKeyFilterTable">
    ///     Temporary table hodling the values for the allocation keys to be used.
    /// </param>
    public void prepareMiningModelStagingTable(ReqDemPlanCreateForecastDataContract _dataContract, ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        str                                 dateField;
        str                                 sqlQuery;
        str                                 sqlDateFrom;
        str                                 sqlDateTo;
        str                                 sqlDatesExpression;
        str                                 sqlDateDimensionName;
        str                                 sqlDateDimensionDotNetCulture;
        str                                 sqlGranularityDelimiter         = 'CHAR(' + int2str(#GranularityDelimiterAsciiCode) + ')';
        str                                 granularityAttributeExpression  = '';
        SqlSystem                           sqlSystem = new SqlSystem();
        ReqDemPlanMiningModelStagingTable   stagingTable;
        Statement                           statement;
        ListEnumerator                      listEnumerator;
        ReqDemPlanForecastAttributeManager  attributeManager;
        List                                enabledAttributes;

        #BIFramework

        void addToGranularityAttributeExpr(FieldId _fieldId)
        {
            boolean addField = true;

            if (granularityAttributeExpression != '')
            {
                granularityAttributeExpression += '+' + sqlGranularityDelimiter;
            }

            if (addField)
            {
                if (granularityAttributeExpression != '')
                {
                    granularityAttributeExpression += '+';
                }

                granularityAttributeExpression += 'CAST(ST.' + this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), _fieldId) + ' AS NVARCHAR(MAX))';
            }
        }

        attributeManager = _dataContract.attributeManager();
        enabledAttributes = attributeManager.getAllEnabledAttributes();
        listEnumerator = attributeManager.getAttributeFields(tableNum(ReqDemPlanCubeStagingTable), enabledAttributes).getEnumerator();
        while (listEnumerator.moveNext())
        {
            addToGranularityAttributeExpr(listEnumerator.current());
        }

        switch (_dataContract.parmDateGranularity())
        {
            case ReqDemPlanDateGranularity::Day:
                dateField = this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, DateKey));
                break;
            case ReqDemPlanDateGranularity::Week:
                dateField = this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, WeekKey));
                break;
            case ReqDemPlanDateGranularity::Month:
                dateField = this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, MonthKey));
                break;
            default:
                throw error("@DMP1061");
        }

        int infologLineTry = infologLine();

        try
        {
            logger.startMonitoredTask(ReqDemPlanTaskCodes::PrepareMiningModelStagingTable, "@DMP1120");
            logger.setTaskRank(#DefaultTaskRank + 2);
            
            str allocationKeyFilterTableName = _allocationKeyFilterTable.getPhysicalTableName();

            sqlDateFrom = sqlSystem.sqlLiteral(_dataContract.parmHistoricalStart());
            sqlDateTo = sqlSystem.sqlLiteral(_dataContract.parmHistoricalEnd());
            sqlDateDimensionName = sqlSystem.sqlLiteral(#Date);
            sqlDateDimensionDotNetCulture = sqlSystem.sqlLiteral(#DefaultDotNetCulture);

            sqlDatesExpression = strFmt(@'
        DATES AS (
            SELECT
                ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, Date))  + @' AS [DATE],
                ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, DateKey))  + @' AS [DATEKEY],
                ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, WeekKey))  + @' AS [WEEKKEY],
                ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, MonthKey)) + @' AS [MONTHKEY]
            FROM ' + this.dbTableName(tableNum(BIDateDimensionsView)) + @'
            WHERE
                    ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, Name)) + @' = %1
                AND ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, DotNetCulture)) + @' = %2
                AND ' + this.dbFieldName(tableNum(BIDateDimensionsView), fieldNum(BIDateDimensionsView, Date)) +  @' BETWEEN %3 AND %4)',
            sqlDateDimensionName,
            sqlDateDimensionDotNetCulture,
            sqlDateFrom,
            sqlDateTo);

            sqlQuery = strFmt(@'
        WITH
        RECORDSCOUNT AS ( SELECT CASE WHEN MAX(%5) IS NULL THEN 0 ELSE MAX(%5) END AS [Count]
                            FROM ' + this.dbTableName(tableNum(ReqDemPlanMiningModelStagingTable)) +
                            @' WITH (HOLDLOCK, TABLOCK)  ),
        %1,
        DATEKEYS AS (
            SELECT [%2] AS [DATEKEY] FROM DATES GROUP BY [%2]),
        STAGINGTABLEEXTENDED AS (
            SELECT
                ST.' + this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, DataAreaId)) + @' AS [DATAAREAID],
                ' + this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, AllocationKey)) + @' AS [ALLOCATIONKEY],
                ' + this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, TransactionDate)) + @' AS [TRANSACTIONDATE],
                ' + this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, TransactionQty)) + @' AS [TRANSACTIONQTY],
                (%3) AS GRANULARITYATTRIBUTE
            FROM ' + this.dbTableName(tableNum(ReqDemPlanCubeStagingTable)) + @' ST ' + @'
            JOIN ' + allocationKeyFilterTableName + @' F ' + @'
            ON   '  + @'ST.'+ this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, AllocationKey)) + @' = '
                         + @'F.'+ this.dbFieldName(tableNum(ReqDemPlanAllocationKeyFilterTmp), fieldNum(ReqDemPlanAllocationKeyFilterTmp, AllocateId)) + @'
                   AND ' + @'ST.'+ this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, DataAreaId)) + @' = '
                         + @'F.'+ this.dbFieldName(tableNum(ReqDemPlanAllocationKeyFilterTmp), fieldNum(ReqDemPlanAllocationKeyFilterTmp, DataAreaId)) + @'
                   AND ' + @'ST.'+ this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, Partition)) + @' = '
                         + @'F.'+ this.dbFieldName(tableNum(ReqDemPlanAllocationKeyFilterTmp), fieldNum(ReqDemPlanAllocationKeyFilterTmp, Partition)) + @'
            WHERE ' + @'ST.'+ this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, Partition)) + @' = %4
                    AND ' + @'ST.'+ this.dbFieldName(tableNum(ReqDemPlanCubeStagingTable), fieldNum(ReqDemPlanCubeStagingTable, Version)) + @' = %6
                    AND ' + @'F.'+ this.dbFieldName(tableNum(ReqDemPlanAllocationKeyFilterTmp), fieldNum(ReqDemPlanAllocationKeyFilterTmp, ForecastingStrategy)) + @' = %7),
        QUANTITIES AS (
            SELECT D.[%2] AS [DATEKEY],
                [GRANULARITYATTRIBUTE],
                SUM([TRANSACTIONQTY]) AS [TRANSACTIONQTY]
            FROM STAGINGTABLEEXTENDED S
                JOIN DATES D ON S.[TRANSACTIONDATE] = D.[DATE]
            GROUP BY D.[%2], S.[GRANULARITYATTRIBUTE]),
        GRANULARITIES AS (
            SELECT DISTINCT [DATAAREAID], [ALLOCATIONKEY], [GRANULARITYATTRIBUTE]
            FROM STAGINGTABLEEXTENDED),
        GRANULARITIESBYDATE AS (
            SELECT *,
                (SELECT [COUNT] FROM [RECORDSCOUNT]) +
                (ROW_NUMBER() OVER(ORDER BY [DATEKEY])) AS FAKERECID
            FROM DATEKEYS
                CROSS JOIN GRANULARITIES)
        INSERT INTO ' + this.dbTableName(tableNum(ReqDemPlanMiningModelStagingTable)) + @' (
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, Partition)) + @',
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, DataAreaId)) + @',
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, AllocationKey)) + @',
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, RecId)) + @',
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, DateKey)) + @',
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, GranularityAttribute)) + @',
            ' + this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, TransactionQty)) + @')
        SELECT
            %4,
            G.[DATAAREAID],
            G.[ALLOCATIONKEY],
            G.[FAKERECID],
            G.[DATEKEY],
            G.[GRANULARITYATTRIBUTE],
            Q.[TRANSACTIONQTY]
        FROM GRANULARITIESBYDATE G JOIN
            QUANTITIES Q ON G.[DATEKEY] = Q.[DATEKEY] AND G.[GRANULARITYATTRIBUTE] = Q.[GRANULARITYATTRIBUTE]
        ORDER BY G.[DATEKEY], G.[GRANULARITYATTRIBUTE]
            ',  sqlDatesExpression,
                dateField,
                granularityAttributeExpression,
                getcurrentpartitionrecid(),
                this.dbFieldName(tableNum(ReqDemPlanMiningModelStagingTable), fieldNum(ReqDemPlanMiningModelStagingTable, RecId)),
                forecastVersion,
            enum2int(this.getForecastingStrategy()));

            ReqDemPlanMiningModelStagingTable::cleanUp();

            new SqlStatementExecutePermission(sqlQuery).assert();

            statement = new Connection().createStatement();
            statement.executeUpdate(sqlQuery);

            select crossCompany count(RecId) from stagingTable;
            logger.incrementTaskRecordsProcessed(stagingTable.RecId);
            logger.finishTask();
        }
        #ReqDemPlanCatchRetryTransientSqlConnectionErrorFailLogTask(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, _dataContract, _allocationKeyFilterTable, logger, infologLineTry)
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ReqDemPlanAzureMlStrategy construct()
    {
        return new ReqDemPlanAzureMlStrategy();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAzureClient</Name>
				<Source><![CDATA[
    public IForecastClient parmAzureClient(IForecastClient _azureClient = azureClient)
    {
        azureClient = _azureClient;
        return azureClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseRequestResponseMode</Name>
				<Source><![CDATA[
    public boolean parmUseRequestResponseMode(boolean _useRequestResponseMode = useRequestResponseMode)
    {
        useRequestResponseMode = _useRequestResponseMode;
        return useRequestResponseMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensureAzureClientCreated</Name>
				<Source><![CDATA[
    [Wrappable(false)]
    protected void ensureAzureClientCreated()
    {
        if (!azureClient)
        {
            var context = new AzureConnectionContext();

            context.ApiKey = globalForecastParameters.AzureMlApiKey;
            context.ServiceEndpointUri = globalForecastParameters.AzureMlServiceEndpointUri;
  
            if (!useRequestResponseMode)
            {
                context.AzureStorageConnectionString = this.getAzureStorageConnectionString(globalForecastParameters);
            }

            azureClient = new ForecastClient(context, useRequestResponseMode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showAzureMlWebServiceDeploymentInstruction</Name>
				<Source><![CDATA[
	/// <summary>
    ///     Shows Azure Machine Learning deployment instructions.
    /// </summary>
    public static void showAzureMlWebServiceDeploymentInstruction()
    {
		if(ReqDemPlanAzureMlStrategy::isAzureMachineLearningUsed() && !ReqDemPlanAzureMlStrategy::isAzureMachineLearningSetUp())
		{	
			setPrefix("@DMP:AzureMlDeployMainMessage");
			warning("@DMP:AzureMlDeploySubMessage");
			info(strfmt("@DMP:AzureMlDeployStep1", #AzureMlGalleryExperimentUrl));
			info("@DMP:AzureMlDeployStep2");
            info(strfmt("@DMP:AzureMlDeployStep3", "@DMP1532", "@DMP1036"));
            info(strfmt("@DMP:AzureMlDeployStep4", "@DMP1533", "@DMP1036", "@DMP:AzureMlEndpointURIPattern"));
			info("@DMP:AzureMlDeployStep5");
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>isForecastingStrategyUsed</Name>
				<Source><![CDATA[
    protected static boolean isForecastingStrategyUsed(ReqDemPlanForecastingStrategy _forecastingStrategy)
    {
        ReqDemPlanForecastParameters globalForecastParameters = ReqDemPlanForecastParameters::find();
        ReqDemplanForecastIAKParameters globalAllocationKeyParameters = globalForecastParameters.allocationKeyParameters();

        if (globalAllocationKeyParameters &&
            globalAllocationKeyParameters.ForecastingStrategy == _forecastingStrategy)
        {
            return true;
        }

        ReqDemplanForecastIAKParameters iakParameters;
        ReqDemPlanForecastIAKMap allocationKeyMapping;

        select firstonly RecId from iakParameters
            where iakParameters.ForecastingStrategy == _forecastingStrategy
            exists join allocationKeyMapping
                where allocationKeyMapping.ReqDemplanForecastIAKParameters == iakParameters.RecId;

        return iakParameters.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAzureMachineLearningUsed</Name>
				<Source><![CDATA[
	/// <summary>
    ///     Checks if Azure Machine Learning service is used by forecast generation.
    /// </summary>
    /// <returns>
    ///     true if Azure Machine Learning is used by forecast generation; otherwise false.
    /// </returns>
    public static boolean isAzureMachineLearningUsed()
    {
        return ReqDemPlanAzureMlStrategy::isForecastingStrategyUsed(ReqDemPlanAzureMlStrategy::ForecastingStrategyAzureML);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAzureMachineLearningSetUp</Name>
				<Source><![CDATA[
	/// <summary>
    ///     Checks if Azure Machine Learning service parameters are set up.
    /// </summary>
    /// <returns>
    ///     true if Azure Machine Learning parameters are set up; otherwise false.
    /// </returns>
    public static boolean isAzureMachineLearningSetUp()
    {
		var globalForecastParameters = ReqDemPlanForecastParameters::find();
		
		return globalForecastParameters.AzureMlApiKey != '' && globalForecastParameters.AzureMlServiceEndpointUri != '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAzureStorageConnectionString</Name>
				<Source><![CDATA[
    private str getAzureStorageConnectionString(ReqDemPlanForecastParameters parameters)
    {
        if (parameters.UseCustomAzureStorage)
        {
            if (parameters.AzureStorageAccountName == '' || parameters.AzureStorageAccountKey == '')
            {
                throw error("@DMP:AzureStorageNameKeyRequired");
            }

            var credentials = new Microsoft.WindowsAzure.Storage.Auth.StorageCredentials(parameters.AzureStorageAccountName, parameters.AzureStorageAccountKey);
            var account = new Microsoft.WindowsAzure.Storage.CloudStorageAccount(credentials, true);

            return account.ToString(true);
        }
        else if (ReqDemPlanAzureMlStrategy::isDeploymentTypeOnPremise())
        {
            throw error("@DMP:CustomAzureStorageAccountRequiredForOnPremise");
        }

        var connectionString = Microsoft.Dynamics.Clx.ServicesWrapper.CloudInfrastructure::GetCsuStorageConnectionString();
        var localAccount = Microsoft.WindowsAzure.Storage.CloudStorageAccount::DevelopmentStorageAccount;

        //Azure Machine Learning does not have access to local emulator's storage.
        if (connectionString == localAccount.toString(true))
        {
            throw error("@DMP:AzureStorageCustomRequired");
        }

        return connectionString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeploymentTypeOnPremise</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether deployment type is on premise.
    /// </summary>
    /// <returns>true, if deployment type is on premise; otherwise, false.</returns>
    private static boolean isDeploymentTypeOnPremise()
    {
        var applicationEnvironment = Microsoft.Dynamics.ApplicationPlatform.Environment.EnvironmentFactory::GetApplicationEnvironment();
        if (applicationEnvironment && applicationEnvironment.Common)
        {
            return applicationEnvironment.Common.DeploymentType == Microsoft.Dynamics.ApplicationPlatform.Environment.Settings.DeploymentType::OnPrem;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveModelVariables</Name>
				<Source><![CDATA[
    private void saveModelVariables(
        ReqDemPlanForecastAttributeManager _attributeManager,
        ReqDemPlanCreateForecastDataContract _dataContract,
        ReqDemPlanAllocationKeyFilterTmp _allocationKeyFilterTable)
    {
        ISimpleDataReader[] modelVariablesReaders = null;
        ReqDemPlanModelVariables modelVariables;

        int infologLineTry = infologLine();

        try
        {
            modelVariablesReaders = azureClient.GetModelVariables();

            ttsbegin;

            while select crosscompany DataAreaId from modelVariables group by DataAreaId
            {
                changecompany(modelVariables.DataAreaId)
                {
                    ReqDemPlanModelVariables modelVariablesPerCompany;
                    dataProcessingHelper.skipAll(modelVariablesPerCompany);
                    delete_from modelVariablesPerCompany;
                }
            }

            var attributeFields = _attributeManager.getAttributeFields(
                modelVariables.TableId,
                _attributeManager.getAllEnabledAttributes());

            var enumerator = modelVariablesReaders.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ISimpleDataReader reader = enumerator.get_Current();

                var granularityAttribute = reader.GetOrdinal(DataReaderColumns::GranularityAttribute);
                var errorPercentage = reader.GetOrdinal(DataReaderColumns::ErrorPercentage);
                var forecastModelName = reader.GetOrdinal(DataReaderColumns::ForecastModelName);

                while (reader.Read())
                {
                    modelVariables.clear();
                    this.initializeAttributes(modelVariables, reader.GetString(granularityAttribute), attributeFields);
                    modelVariables.ErrorPercentage = reader.GetDecimal(errorPercentage);
                    modelVariables.ForecastModelName = reader.GetString(forecastModelName);

                    if (modelVariables.isForecastGenerationFailed())
                    {
                        this.showForecastGenerationFailedWarning(modelVariables, attributeFields);
                    }

                    changecompany (modelVariables.DataAreaId)
                    {
                        modelVariables.insert();
                    }
                }
            }
            ttscommit;
        }
        #ReqDemPlanCatchRetryTransientSqlConnectionError(reqDemPlanHandleTransientSqlConnectionErrorFlightIsEnabled, _dataContract, _allocationKeyFilterTable, logger, infologLineTry)
        finally
        {
            if (modelVariablesReaders)
            {
                var enumerator = modelVariablesReaders.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    ISimpleDataReader reader = enumerator.get_Current();
                    if (reader)
                    {
                        reader.Dispose();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showForecastGenerationFailedWarning</Name>
				<Source><![CDATA[
    protected void showForecastGenerationFailedWarning(ReqDemPlanModelVariables _modelVariables, List _enabledAttributes)
    {
        container   granularityKeyCont;
        var         fieldEnumerator     = _enabledAttributes.getEnumerator();

        while (fieldEnumerator.moveNext())
        {
            var fieldContent = _modelVariables.(fieldEnumerator.current());
            granularityKeyCont += fieldContent ? fieldContent : '--';
        }

        setPrefix("@DMP:ForecastFailedForSomeDimensions");
        warning(con2Str(granularityKeyCont, #AttributeKeyDelimiter));
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>