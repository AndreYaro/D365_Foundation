<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerAllocationProcessReqByBudgetPlan</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerAllocationProcessReqByBudgetPlan</c> class is used to create the list of <c>BudgetPlanLine</c> table buffers as per the specified ledger allocation rule.
/// </summary>
/// <remarks>
/// The <c>LedgerAllocationProcessReqByBudgetPlan</c> class is similar to <c>LedgerAllocationProcessRequest</c> class.
/// </remarks>
public class LedgerAllocationProcessReqByBudgetPlan
{
    int                                     numberOfDestinations;
    real                                    totalWeight,
                                            totalPercentage;
    boolean                                 needToThrowGenError;
    Percent                                 percentAllocated;
    EffectiveDate                           startDate,
                                            endDate;
    LedgerPeriodCode                        ledgerPeriodCode;
    AmountCur                               basisTotal;
    LineNum                                 lastBasisLine;
    //newLineNumFactor,
    //currentLineNum;
    BudgetPlanCurrencyAmount                allocationTotal,
                                            amountRemaining,
                                            totalAmountAllocated;
    BudgetPlanQuantity                      basisTotalQuantity,
                                            quantityAllocationTotal,
                                            quantityRemaining,
                                            totalQuantityAllocated;
    BudgetPlanCurrencyCode                  planCurrencyCode;
    BudgetPlanUnitOfMeasureRecId            unitOfMeasure;
    BudgetPlanUnitPrice                     unitPrice;

    Set                                     setLedgerDimension;
    Set                                     setAccount;
    Set                                     setDimension;
    Set                                     setSourceRecId;
    List                                    budgetPlanLineDistributions;

    LedgerAllocationRule                    ledgerAllocationRule;
    LedgerAllocationRuleID                  ruleId;
    LedgerAllocationRuleDestination         ruleDestination;
    BudgetPlanHeaderRecId                   budgetPlanHeaderRecId;
    BudgetPlanScenarioRecId                 budgetPlanSourceScenarioRecId,
                                            budgetPlanBasisScenarioRecId,
                                            budgetPlanTargetScenarioRecId;
    BudgetPlanScenario                      budgetPlanSourceScenario,
                                            budgetPlanTargetScenario;
    LedgerAllocationBasisRulesByBudgetPlan  basisRule;

    boolean                                 useSourceEffectiveDateForAllocation;
    Map                                     effectiveDatesAllocationMap;
    MapEnumerator                           effectiveDatesAllocationMapEnumerator;
    BudgetPlanLineEffectiveDate             budgetPlanLineDefaultEffectiveDate;
    int                                     numberOfOriginalDestinations;
    real                                    totalOriginalWeight;
    real                                    totalOriginalPercentage;
    boolean                                 appendLines;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allocate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Controls the processing of allocation request for specified ledger allocation rule and adds <c>BudgetPlanLine</c> table buffers in the list.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Occurs when any preprocessing validation fails.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Occurs when amount and quantity to be distributed as per the ledger allocation rule are both zero.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Occurs when <c>initDestinationAllocationSettings</c> method fails to initialize internal variables for performing calculations or <c>createBudgetPlanLineDestinations</c> method
    /// fails to create the destination <c>BudgetPlanLine</c> table buffers.
    /// </exception>
    public void allocate()
    {
        boolean beginProcessing = true;
        needToThrowGenError = true;
        budgetPlanLineDistributions = new List(Types::Record);

        // Perform pre-processing error checking prior to kicking off the allocation generation
        if (this.validateRequest())
        {
            try
            {
                // Pre-processing validation has detected no errors. Get the amounts and quantities to allocate
                if (!this.initSourceValues())
                {
                    beginProcessing = checkFailed(strFmt("@SYS106597", ruleId));
                    error("@SYS106317");
                }
            }
            catch
            {
                exceptionTextFallThrough();
            }
        }
        else
        {
            error("@SYS106317");
            beginProcessing = false;
        }

        try
        {
            if (beginProcessing)
            {
                // Initializes configuration for allocation process.
                this.initDestinationAllocationSettings();

                // If use source effective date field is not checked, add the current budget cycle start date to the map with total amount and quantity to be allocated.
                if (!useSourceEffectiveDateForAllocation)
                {
                    this.addAmountAndQuantityByEffectiveDate(budgetPlanLineDefaultEffectiveDate, allocationTotal, quantityAllocationTotal);
                }

                // Loop through all the budget plan lines effective dates and create destination record for each.
                effectiveDatesAllocationMapEnumerator = effectiveDatesAllocationMap.getEnumerator();

                while (effectiveDatesAllocationMapEnumerator.moveNext())
                {
                    [allocationTotal, quantityAllocationTotal] = effectiveDatesAllocationMapEnumerator.currentValue();

                    if (ledgerAllocationRule.CalculationType == LedgerAllocationMathType::Divide)
                    {
                        allocationTotal         = allocationTotal / ledgerAllocationRule.CalculationAmount;
                        quantityAllocationTotal = quantityAllocationTotal / ledgerAllocationRule.CalculationAmount;
                    }
                    else if (ledgerAllocationRule.CalculationType == LedgerAllocationMathType::Multiply)
                    {
                        allocationTotal         = allocationTotal * ledgerAllocationRule.CalculationAmount;
                        quantityAllocationTotal = quantityAllocationTotal * ledgerAllocationRule.CalculationAmount;
                    }

                    amountRemaining     = allocationTotal;
                    quantityRemaining   = quantityAllocationTotal;

                    // Doing the recalculation for unit price in case any of the lines has a unit price defined.
                    unitPrice = (quantityAllocationTotal == 0 ? 0 : allocationTotal / quantityAllocationTotal);

                    // Getting basis total amount and quantity based on an effective date.
                    [basisTotal, basisTotalQuantity] = basisRule.getEffectiveDateBasisAllocationMap(effectiveDatesAllocationMapEnumerator.currentKey());

                    // Since basis quantity total is used for non-monetary basis scenario, therefore both basisTotal and basisTotalQuantity are checked.
                    if ((ledgerAllocationRule.AllocationMethod == LedgerAllocationMethod::Basis) && basisTotal == 0 && basisTotalQuantity == 0)
                    {
                        error("@SYS106596");
                    }
                    else
                    {
                        // Create budget plan line records in the target budget plan scenario.
                        this.createBudgetPlanLineDestinations();
                    }
                }
            }
        }
        catch
        {
            exceptionTextFallThrough();

            if (needToThrowGenError == true)
            {
                error("@SYS106317");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDestinationValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the distribution value for a destination line, and adjusts totals and remaining amounts and quantities.
    /// </summary>
    /// <param name="_method">
    /// <c>LedgerAllocationMethod</c> enumeration value.
    /// </param>
    /// <param name="_destinationPercent">
    /// Percentage to calculate allocated amount and quantity when <c>LedgerAllocationMethod</c> enumeration value is fixed percentage.
    /// </param>
    /// <param name="_fixedWeight">
    /// Fixed weight to calculate the amount and quantity when <c>LedgerAllocationMethod</c> enumeration value is fixed weight.
    /// </param>
    /// <param name="_basis">
    /// Basis to calculate the amount and quantity when the <c>LedgerAllocationMethod</c> enumeration value is basis.
    /// </param>
    /// <returns>
    /// Container containing the amount and quantity value based on the <c>LedgerAllocationMethod</c> enumeration value for <c>BudgetPlanLine</c> table buffer.
    /// </returns>
    protected container calcDestinationValues(
        LedgerAllocationMethod      _method,
        LedgerAllocatePct           _destinationPercent = 0,
        LedgerAllocationFixedWeight _fixedWeight = 0,
        container                   _basis = conNull())
    {
        container                   calculatedValues;
        BudgetPlanQuantity          allocatedQuantity;
        BudgetPlanQuantity          basisQuantity;
        BudgetPlanCurrencyAmount    allocatedAmount;
        BudgetPlanCurrencyAmount    basisAmount;

        switch (_method)
        {
            case LedgerAllocationMethod::Basis:
                if (_basis == conNull())
                {
                    allocatedAmount   = 0.0;
                    allocatedQuantity = 0;
                }
                else
                {
                    if (ruleDestination.LineNum == lastBasisLine)
                    {
                        // adding the quantity calculation for the budgetplan lines
                        allocatedAmount   = allocationTotal - totalAmountAllocated;
                        allocatedQuantity = quantityAllocationTotal - totalQuantityAllocated;
                    }
                    else
                    {
                        if (basisRule.isMonetary())
                        {
                            basisAmount = conPeek(_basis, 1);

                            if (basisAmount == 0)
                            {
                                allocatedAmount   = 0;
                                allocatedQuantity = 0;
                            }
                            else
                            {
                                allocatedAmount   = allocationTotal * (basisAmount / basisTotal);
                                allocatedQuantity = quantityAllocationTotal * (basisAmount / basisTotal);
                            }
                        }
                        else
                        {
                            basisQuantity = conPeek(_basis, 2);

                            if (basisQuantity == 0)
                            {
                                allocatedAmount   = 0;
                                allocatedQuantity = 0;
                            }
                            else
                            {
                                allocatedAmount   = allocationTotal * (basisQuantity / basisTotalQuantity);
                                allocatedQuantity = quantityAllocationTotal * (basisQuantity / basisTotalQuantity);
                            }
                        }
                    }
                }

                // total the amount allocated to all destinations
                totalAmountAllocated   = totalAmountAllocated + allocatedAmount;
                totalQuantityAllocated = totalQuantityAllocated + allocatedQuantity;
                break;

            case LedgerAllocationMethod::FixedPercentage:

                // calculate the amount to allocate to this destination
                allocatedAmount   = allocationTotal * _destinationPercent / 100;

                // adding the quantity calculation for the budgetplan lines
                allocatedQuantity = quantityAllocationTotal * _destinationPercent / 100;

                // total the amount allocated to all destinations
                totalAmountAllocated   = totalAmountAllocated + allocatedAmount;
                totalQuantityAllocated = totalQuantityAllocated + allocatedQuantity;

                numberOfDestinations--;
                percentAllocated = percentAllocated + _destinationPercent;

                // the last amount is the total remaining if we are allocating 100%
                if ((numberOfDestinations == 0 && percentAllocated == 100)
                    || (percentAllocated == 100 && _destinationPercent != 0.0))
                {
                    allocatedAmount   = allocatedAmount + (allocationTotal - totalAmountAllocated);
                    allocatedQuantity = allocatedQuantity + (quantityAllocationTotal - totalQuantityAllocated);

                    totalAmountAllocated = allocationTotal;
                    totalQuantityAllocated = quantityAllocationTotal;
                }
                break;

            case LedgerAllocationMethod::FixedWeight:
                if (numberOfDestinations > 1)
                {
                    allocatedAmount   = amountRemaining * (_fixedWeight / totalWeight);
                    allocatedQuantity = quantityRemaining * (_fixedWeight / totalWeight);

                    amountRemaining   = amountRemaining - allocatedAmount;
                    quantityRemaining = quantityRemaining - allocatedQuantity;

                    totalWeight = totalWeight - _fixedWeight;
                }
                else
                {
                    allocatedAmount   = amountRemaining;
                    allocatedQuantity = quantityRemaining;
                }
                numberOfDestinations--;
                break;

            case LedgerAllocationMethod::SpreadEven:
                if (numberOfDestinations > 1)
                {
                    allocatedAmount   = amountRemaining * (1 / numberOfDestinations);
                    allocatedQuantity = quantityRemaining * (1 / numberOfDestinations);

                    amountRemaining   = amountRemaining - allocatedAmount;
                    quantityRemaining = quantityRemaining - allocatedQuantity;
                }
                else
                {
                    allocatedAmount   = amountRemaining;
                    allocatedQuantity = quantityRemaining;
                }
                numberOfDestinations--;
                break;
        }

        // Add both the calculated amount and quantity in the container and return it
        calculatedValues = [allocatedAmount, allocatedQuantity];

        return calculatedValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBudgetPlanLineDestinations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates destination <c>BudgetPlanLine</c> table buffers as per the specified <c>LedgerAllocationRule</c> table's <c>LedgerAllocationRuleID</c> field.
    /// </summary>
    /// <remarks>
    /// This method is similar to <c>LedgerAllocationProcessRequest</c> class <c>createVoucherDestinations</c> method. The difference between the two is that
    /// <c>createVoucherDestinations</c> method populates distribution values into the <c>LedgerJournalTrans</c> table fields and inserts the row whereas this method
    /// adds the <c>BudgetPlanLine</c> table records into a list data structure.
    /// </remarks>
    protected void createBudgetPlanLineDestinations()
    {
        boolean                     performSave = true;
        container                   allocatedValues;
        BudgetPlanQuantity          allocatedQuantity;
        BudgetPlanCurrencyAmount    allocatedAmount;
        BudgetPlanLine              budgetPlanLine;
        SetEnumerator               setEnumerator;

        //
        // delete the source budget plan lines if the source budget plan line scenario and target budget plan line scenario are same.
        // In case of fixed value, there are no source budget plan lines.
        //
        if ((ledgerAllocationRule.DataSource != LedgerAllocationSource::FixedValue) &&
           (budgetPlanSourceScenarioRecId == budgetPlanTargetScenarioRecId))
        {
            setEnumerator = setSourceRecId.getEnumerator();

            if (!this.parmAppendLines())
            {
                while (setEnumerator.moveNext())
                {
                    delete_from budgetPlanLine
                        where budgetPlanLine.RecId == setEnumerator.current()
                            && (!useSourceEffectiveDateForAllocation || budgetPlanLine.EffectiveDate == effectiveDatesAllocationMapEnumerator.currentKey());
                }
            }
        }

        // deleting budgetplanline having matching ledger allocation source or destination ledger dimension values
        if (!this.parmAppendLines()
            && !this.deleteBudgetPlanLinesByLedgerDimension(
                    ledgerAllocationRule.DestinationAccountFrom == LedgerAllocationFromTo::Source,
                    ledgerAllocationRule.DestinationDimensionFrom == LedgerAllocationFromTo::Source))
        {
            throw error("@SYS106317");
        }

        if (ledgerAllocationRule.DestinationAccountFrom == LedgerAllocationFromTo::Source
            && ledgerAllocationRule.DestinationDimensionFrom == LedgerAllocationFromTo::Source)
        {
            // when using source in spread even, this code path creates the distributions
            this.createSpreadEvenDestinations(0, 0,
                    (ledgerAllocationRule.DestinationAccountFrom == LedgerAllocationFromTo::Source),
                    (ledgerAllocationRule.DestinationDimensionFrom == LedgerAllocationFromTo::Source));
        }
        else
        {
            this.resetVariables();

            while select ruleDestination where ruleDestination.RuleID == ruleId
            {
                // loop through the destination records for the ruleId, creating a distribution for each
                [allocatedValues, performSave] = this.calculateDestinationValuesForAllocationMethod();

                if (performSave)
                {
                    allocatedAmount   = conPeek(allocatedValues, 1);
                    allocatedQuantity = conPeek(allocatedValues, 2);

                    budgetPlanLine = this.setDistributionValues(
                                            ruleDestination.ToLedgerDimension,
                                            ruleDestination.ToDefaultDimension,
                                            allocatedAmount,
                                            allocatedQuantity,
                                            ruleDestination.ToCompany);

                    budgetPlanLineDistributions.addEnd(budgetPlanLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateDestinationValuesForAllocationMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Computes the distribution value for a destination line, and adjusts totals and remaining amounts and quantities.
    /// </summary>
    /// <returns>
    /// Container containing the values of distribution for a destination line and a boolean value to check for save operation, based on the <c>LedgerAllocationMethod</c> enumeration value for <c>LedgerAllocationRule</c> table buffer.
    /// </returns>
    protected container calculateDestinationValuesForAllocationMethod()
    {
        container          calculatedValues;
        container          allocatedValues;
        AmountCur          basisAmount;
        BudgetPlanQuantity basisQuantity;
        boolean            performSave = true;

        switch (ledgerAllocationRule.AllocationMethod)
        {
            case LedgerAllocationMethod::Basis:
                [basisAmount, basisQuantity] = basisRule.getEffectiveDateBasisAllocLedgerDestMap(effectiveDatesAllocationMapEnumerator.currentKey(), ruleDestination.LineNum);
                allocatedValues = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod, 0, 0, [basisAmount, basisQuantity]);
                break;

            case LedgerAllocationMethod::FixedPercentage:
                allocatedValues = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod, ruleDestination.FixedPercent);
                break;

            case LedgerAllocationMethod::FixedWeight:
                allocatedValues = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod, 0, ruleDestination.FixedWeight);
                break;

            case LedgerAllocationMethod::SpreadEven:

                // need the ability to loop when using source for accounts and/or dimensions
                if (ledgerAllocationRule.DestinationAccountFrom == LedgerAllocationFromTo::Source
                            || ledgerAllocationRule.DestinationDimensionFrom == LedgerAllocationFromTo::Source)
                {
                    performSave = false;

                    this.createSpreadEvenDestinations(
                                ruleDestination.ToLedgerDimension,
                                ruleDestination.ToDefaultDimension,
                                (ledgerAllocationRule.DestinationAccountFrom == LedgerAllocationFromTo::Source),
                                (ledgerAllocationRule.DestinationDimensionFrom == LedgerAllocationFromTo::Source));
                }
                else
                {
                    // both Accounts and Dimensions are user defined
                    allocatedValues = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod);
                }
                break;
        }
        calculatedValues = [allocatedValues, performSave];

        return calculatedValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSpreadEvenDestinations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the destination <c>BudgetPlanLine</c> table buffers in the case where the allocation method is Spread Even and Source <c>BudgetPlanLine</c> table record's main account,
    /// dimensions or both are to be used to create the <c>LedgerDimenison</c> field of destination <c>BudgetPlanLine</c> table buffers.
    /// </summary>
    /// <param name="_ledgerDimensionId">
    /// The record ID of the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The record ID of the <c>DimensionAttributeValueSet</c> table.
    /// </param>
    /// <param name="_usingSourceAccounts">
    /// true when source <c>BudgetPlanLine</c> table record's main account needs to be used; otherwise false.
    /// </param>
    /// <param name="_usingSourceDimensions">
    /// true when source <c>BudgetPlanLine</c> table record's dimension(s) needs to be used; otherwise false.
    /// </param>
    /// <remarks>
    /// This method is similar to <c>LedgerAllocationProcessRequest</c> class <c>createSpreadEvenDestinations</c> method.
    /// <c>LedgerAllocationProcessRequest</c> class uses <c>LedgerAllocationTmpSource</c> table to store the <c>GeneralJournalAccountEntry</c> table
    /// source records. It also breaks the <c>GeneralJournalAccountEntry</c> table <c>LedgerDimension</c> field storing Main Account in the <c>LedgerAllocationTmpSource</c> table
    /// <c>LedgerDimension</c> field and rest of the dimemsion in the <c>GeneralJournalAccountEntry</c> table <c>DefaultDimension</c> field.
    /// In <c>LedgerAllocationProcessReqByBudgetPlan</c> class this information is stored in <c>setLedgerDimension</c> set, <c>setAccount</c>
    /// set and <c>setDimension</c> set and retrieved accordingly.
    /// </remarks>
    protected void createSpreadEvenDestinations(
        RecId               _ledgerDimensionId,
        DimensionDefault    _dimensionDefault,
        boolean             _usingSourceAccounts,
        boolean             _usingSourceDimensions)
    {
        container                   allocatedValues;
        RecId                       ledgerDimensionId;
        DimensionDefault            dimensionDefault;
        BudgetPlanQuantity          allocatedQuantity;
        BudgetPlanCurrencyAmount    allocatedAmount;
        BudgetPlanLine              spreadBudgetPlanLine;
        SetEnumerator               setEnumerator;

        if (_usingSourceAccounts && _usingSourceDimensions)
        {
            //
            // When both account and dimensions are from the source:
            // iterate through the LedgerDimension set to create the destination distributions
            //
            setEnumerator = setLedgerDimension.getEnumerator();

            while (setEnumerator.moveNext())
            {
                ledgerDimensionId   = setEnumerator.current();
                dimensionDefault    = _dimensionDefault;

                allocatedValues     = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod);
                allocatedAmount     = conPeek(allocatedValues, 1);
                allocatedQuantity   = conPeek(allocatedValues, 2);

                spreadBudgetPlanLine = this.setDistributionValues(
                                        ledgerDimensionId,
                                        0,
                                        allocatedAmount,
                                        allocatedQuantity,
                                        curext(),
                                        true);

                budgetPlanLineDistributions.addEnd(spreadBudgetPlanLine);
            }
        }
        else if (_usingSourceAccounts)
        {
            //
            // When account is from the source:
            //iterate through the account set to create the destination distributions
            //

            setEnumerator = setAccount.getEnumerator();

            while (setEnumerator.moveNext())
            {
                ledgerDimensionId   = setEnumerator.current();
                dimensionDefault    = _dimensionDefault;

                allocatedValues     = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod);
                allocatedAmount     = conPeek(allocatedValues, 1);
                allocatedQuantity   = conPeek(allocatedValues, 2);

                spreadBudgetPlanLine = this.setDistributionValues(
                                        ledgerDimensionId,
                                        dimensionDefault,
                                        allocatedAmount,
                                        allocatedQuantity);

                budgetPlanLineDistributions.addEnd(spreadBudgetPlanLine);
            }
        }
        else if (_usingSourceDimensions)
        {
            //
            // When dimension is from the source:
            //iterate through the dimension set to create the destination distributions
            //

            setEnumerator = setDimension.getEnumerator();

            while (setEnumerator.moveNext())
            {
                ledgerDimensionId   = _ledgerDimensionId;
                dimensionDefault    = setEnumerator.current();

                allocatedValues     = this.calcDestinationValues(ledgerAllocationRule.AllocationMethod);
                allocatedAmount     = conPeek(allocatedValues, 1);
                allocatedQuantity   = conPeek(allocatedValues, 2);

                spreadBudgetPlanLine = this.setDistributionValues(
                                        ledgerDimensionId,
                                        dimensionDefault,
                                        allocatedAmount,
                                        allocatedQuantity);

                budgetPlanLineDistributions.addEnd(spreadBudgetPlanLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBudgetPlanLinesByLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the matching <c>BudgetPlanLine</c> table records in the target scenario, after confirmation from the user.
    /// </summary>
    /// <param name="_usingSourceAccounts">
    /// true when <c>LedgerAllocationRule</c> table <c>DestinationAccountFrom</c> enum is set to Source; otherwise false.
    /// </param>
    /// <param name="_usingSourceDimensions">
    /// true when <c>LedgerAllocationRule</c> table <c>DestinationDimensionFrom</c> enum is set to Source; otherwise false.
    /// </param>
    /// <returns>
    /// true if the matching <c>BudgetPlanLine</c> table records are deleted; otherwise false.
    /// </returns>
    /// <remarks>
    /// As per the functional requirement, the Budget Plan Lines the target scenario that have the same dimension values as the budget plan lines
    /// created through allocation needs to be deleted. This method is used to achieve this objective.
    /// </remarks>
    public boolean deleteBudgetPlanLinesByLedgerDimension(
        boolean          _usingSourceAccounts   = false,
        boolean          _usingSourceDimensions = false)
    {
        QueryBuildDataSource                qbdsBudgetPlanLine;
        QueryRun                            queryRun;
        Query                               query;
        LedgerDimensionBudgetPlanning       ledgerDimensionBudgetPlanning;
        boolean                             isComplete = true;
        SetEnumerator                       setEnumerator;

        query = new Query();
        qbdsBudgetPlanLine = query.addDataSource(tableNum(BudgetPlanLine));

        qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, BudgetPlanHeader)).value(queryValue(budgetPlanHeaderRecId));
        qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, budgetPlanScenario)).value(queryValue(budgetPlanTargetScenarioRecId));

        // Add effective date range only when use effective date parameter is checked.
        if (useSourceEffectiveDateForAllocation)
        {
            qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, EffectiveDate)).value(queryValue(effectiveDatesAllocationMapEnumerator.currentKey()));
        }

        if (_usingSourceAccounts && _usingSourceDimensions)
        {
            if (budgetPlanSourceScenarioRecId == budgetPlanTargetScenarioRecId)
            {
                // returning from method since in this case source lines are already deleted.
                return isComplete;
            }

            setEnumerator = setLedgerDimension.getEnumerator();

            while (setEnumerator.moveNext())
            {
                qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, LedgerDimension)).value(queryValue(setEnumerator.current()));
            }
        }
        else
        {
            // iterating ledger rule destination table for matching ledger dimension.
            while select ruleDestination where ruleDestination.RuleID == ruleId
            {
                if (_usingSourceAccounts)
                {
                    // matching ledger dimension when main account are taken from ledger allocation source instead of ledger rule destination table.
                    setEnumerator = setAccount.getEnumerator();

                    while (setEnumerator.moveNext())
                    {
                        changecompany(ruleDestination.ToCompany)
                        {
                            ledgerDimensionBudgetPlanning = LedgerDimensionFacade::serviceCreateLedgerDimensionForType(
                                LedgerDimensionType::BudgetPlanning,
                                setEnumerator.current(),
                                ruleDestination.ToDefaultDimension);
                        }
                        qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, LedgerDimension)).value(queryValue(ledgerDimensionBudgetPlanning));
                    }
                }
                else if (_usingSourceDimensions)
                {
                    // matching ledger dimension when financial dimension are taken from ledger allocation source instead of ledger rule destination table.
                    setEnumerator = setDimension.getEnumerator();

                    while (setEnumerator.moveNext())
                    {
                        changecompany(ruleDestination.ToCompany)
                        {
                            ledgerDimensionBudgetPlanning = LedgerDimensionFacade::serviceCreateLedgerDimensionForType(
                                LedgerDimensionType::BudgetPlanning,
                                ruleDestination.ToLedgerDimension,
                                setEnumerator.current());
                        }
                        qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, LedgerDimension)).value(queryValue(ledgerDimensionBudgetPlanning));
                    }
                }
                else
                {
                    // matching leder dimension when ledger dimension are taken from ledger rule destination table.
                    changecompany(ruleDestination.ToCompany)
                    {
                        ledgerDimensionBudgetPlanning = LedgerDimensionFacade::serviceCreateLedgerDimensionForType(
                            LedgerDimensionType::BudgetPlanning,
                            ruleDestination.ToLedgerDimension,
                            ruleDestination.ToDefaultDimension);
                    }
                    qbdsBudgetPlanLine.addRange(fieldNum(BudgetPlanLine, LedgerDimension)).value(queryValue(ledgerDimensionBudgetPlanning));
                }
            }
        }

        queryRun = new QueryRun(query);

        if (SysQuery::countTotal(queryRun) > 0)
        {
            if (xSession::isCLRSession())
            {
                LedgerAllocationProcessReqByBudgetPlan::deleteBudgetPlanLines(queryRun);
            }
            else
            {
                if ((ledgerAllocationRule.DataSource != LedgerAllocationSource::FixedValue
                    && budgetPlanSourceScenarioRecId == budgetPlanTargetScenarioRecId) ||
                    Box::okCancel("@GLS150063", DialogButton::Cancel) == DialogButton::Ok)
                {
                    //
                    // if the source and destination scenario are same, the user will have already seen this message, the first condition will be suppressed the box message from showing up again.
                    // This does not happen in case of fixed value. So this message needs to be displayed again.
                    //
                    LedgerAllocationProcessReqByBudgetPlan::deleteBudgetPlanLines(queryRun);
                }
                else
                {
                    isComplete = false;
                }
            }
        }
        return isComplete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetPlanLineDefaultEffectiveDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the budget cycle start date for the <c>BudgetCycle</c> field on the <c>BudgetPlanningProcess</c> table.
    /// </summary>
    /// <returns>
    /// The start date of the budget planning process budget cycle, if found; otherwise, a null date.
    /// </returns>
    private BudgetPlanLineEffectiveDate getBudgetPlanLineDefaultEffectiveDate()
    {
        BudgetPlanHeader        budgetPlanHeader;
        BudgetPlanningProcess   budgetPlanningProcess;
        BudgetCycle             budgetCycle;
        FiscalCalendarPeriod    fiscalCalendarPeriod;

        if (budgetPlanHeaderRecId)
        {
            select StartDate from fiscalCalendarPeriod
                exists join budgetCycle
                    where fiscalCalendarPeriod.RecId == budgetCycle.StartFiscalCalendarPeriod
                exists join budgetPlanningProcess
                    where budgetCycle.RecId == budgetPlanningProcess.BudgetCycle
                exists join budgetPlanHeader
                    where budgetPlanHeader.RecId == budgetPlanHeaderRecId
                        && budgetPlanningProcess.RecId == budgetPlanHeader.BudgetPlanningProcess;
        }

        return fiscalCalendarPeriod.StartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBudgetPlanningQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query to retrieve the <c>BudgetPlanLine</c> table records based on the ledger allocation rules source criteria.
    /// </summary>
    /// <returns>
    /// Instance of <c>Query</c> object.
    /// </returns>
    /// <remarks>
    /// This method is similar to the <c>LedgerAllocationProcessRequest</c> class <c>getLedgerAmounts</c> method. Both these methods retrieve records based on the the ledger allocation
    /// rules source criteria. The basic difference is that <c>getLedgerAmounts</c> method populates the <c>LedgerAllocationTmpSource</c> table with these records whereas
    /// <c>getBudgetPlanningQuery()</c> method returns the query to retrieve these records.
    /// </remarks>
    protected Query getBudgetPlanningQuery()
    {
        str                                 emptyStr;
        LedgerAllocationRuleSource          ruleSource;
        RecId                               keyValue,
                                            mainAccountDimAttrId;

        Set                                 dimensionRangeIncludeEmpty;
        Map                                 dimensionRange;

        Query                               query;
        QueryBuildDataSource                qbds;
        QueryBuildRange                     qbr;

        dimensionRange              = new Map(Types::Int64, Types::String);
        dimensionRangeIncludeEmpty  = new Set(Types::Int64);
        emptyStr                    = SysQuery::valueEmptyString();
        mainAccountDimAttrId        = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

        query = new Query();
        qbds = query.addDataSource(tableNum(BudgetPlanLine));

        // Budget plan selection fields
        qbds.addSelectionField(fieldNum(BudgetPlanLine, RecId));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, LedgerDimension));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, EffectiveDate));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, Quantity));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, TransactionUnitPrice));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, TransactionCurrencyAmount));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, TransactionCurrencyCode));
        qbds.addSelectionField(fieldNum(BudgetPlanLine, UnitOfMeasure));

        // Budget plan specific range
        qbds.addRange(fieldNum(BudgetPlanLine, BudgetPlanHeader)).value(queryValue(budgetPlanHeaderRecId));
        qbds.addRange(fieldNum(BudgetPlanLine, BudgetPlanScenario)).value(queryValue(budgetPlanSourceScenarioRecId));

        //
        //Ledger class code from here till the end. Only BudgetPlanLine table replaces the GeneralJournalEntry table.
        // Add the range for the start/end date
        //
        qbr = qbds.addRange(fieldNum(BudgetPlanLine, EffectiveDate));
        qbr.value(SysQuery::range(startDate, endDate));

        // Build the account and dimension range string from LedgerAllocationRuleSource for this rule
        while select SourceCriteria, FieldSetting, SourceDimensionAttribute from ruleSource
                where ruleSource.RuleID == ruleId
        {
            if (ruleSource.SourceCriteria == '')
            {
                // empty SourceCriteria for dimensions needs to map to blank dimension
                ruleSource.SourceCriteria = emptyStr;
            }

            // Get the key for the map
            keyValue = this.setRuleSourceFieldSetting(ruleSource, mainAccountDimAttrId);

            this.processRuleSourceCriteria(query, ruleSource);

            this.createRuleSourceCriteria(ruleSource, keyValue, emptyStr, dimensionRange, dimensionRangeIncludeEmpty);
        }

        QueryBuildDataSource qbdsDavc = qbds.addDataSource(tableNum(DimensionAttributeValueCombination));
        qbdsDavc.joinMode(JoinMode::ExistsJoin);
        qbdsDavc.addLink(fieldNum(BudgetPlanLine, LedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));
        qbdsDavc.fetchMode(QueryFetchMode::One2One);

        LedgerAllocationProcessRequest::createDimensionRanges(qbdsDavc, dimensionRange.getEnumerator(), dimensionRangeIncludeEmpty);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getListOfBudgetPlanLineDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the list of <c>BudgetPlanLine</c> table buffers.
    /// </summary>
    /// <returns>
    /// list of <c>BudgetPlanLine</c> table buffers.
    /// </returns>
    /// <remarks>
    /// The <c>LedgerAllocationProcessRequest</c> class populates distribution values into the <c>LedgerJournalTrans</c> table fields and inserts the row.
    /// The <c>LedgerAllocationProcessReqByBudgetPlan</c> adds the <c>BudgetPlanLine</c> table buffers into <c>budgetPlanLineDistributions</c> list.
    /// The list is returned by this method.
    /// </remarks>
    public List getListOfBudgetPlanLineDistributions()
    {
        return budgetPlanLineDistributions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBasisValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the basis amount for each destination <c>BudgetPlanline</c> table record against each <c>LedgerAllocationBasisRule</c> table record id.
    /// </summary>
    /// <remarks>
    /// This method also sums the basis amount and quantities across all destination records. This method is similar to the <c>LedgerAllocationProcessRequest</c>
    /// class <c>initBasisAmounts</c> method. The difference is that <c>initBasisAmounts</c> method returns the basis amount where as this method returns
    /// both basis amount and quantity in <c>container</c> data structure.
    /// </remarks>
    protected void initBasisValues()
    {
        container           basisValue;
        AmountCur           basisAmount;
        BudgetPlanQuantity  basisQuantity;

        // Iterate through the destination rules for the current ruleID and get the basis total for each
        while select ruleDestination where ruleDestination.RuleID == ruleId
        {
            if (ruleDestination.BasisId == '')
            {
                basisAmount = 0.0;
                basisQuantity = 0;
            }
            else
            {
                basisValue = basisRule.getBasisTotal(ruleDestination.BasisId, ruleDestination.LineNum);
                basisAmount = conPeek(basisValue, 1);
                basisQuantity = conPeek(basisValue, 2);
            }

            basisTotal = basisTotal + basisAmount;
            basisTotalQuantity += basisQuantity;

            if (basisRule.isMonetary() && basisAmount != 0.0)
            {
                lastBasisLine = ruleDestination.LineNum;
            }
            else if (basisQuantity != 0)
            {
                lastBasisLine = ruleDestination.LineNum;
            }
        }

        numberOfDestinations = LedgerAllocationRuleDestinations::destinationRecordCount(ruleId);

        numberOfOriginalDestinations = numberOfDestinations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDestinationAllocationSettings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the total number of destination <c>BudgetPlanLine</c> buffers to be created.
    /// </summary>
    /// <remarks>
    /// Amount and quantities (total Percentage, total Weight, total basis amount or quantity) needed to calculate
    /// the individual <c>BudgetPlanLine</c> table buffers' amount and quantity are also calculated in this method.
    /// </remarks>
    protected void initDestinationAllocationSettings()
    {
        switch (ledgerAllocationRule.AllocationMethod)
        {
            case LedgerAllocationMethod::Basis:

                //
                // determine basisTotal across all destination lines; basis amount for each
                // destination line & total number of destinations
                //
                this.initBasisValues();
                break;

            case LedgerAllocationMethod::FixedPercentage:

                // get total percentage to distribute & total number of destinations
                this.initFixedPercentage();
                break;

            case LedgerAllocationMethod::FixedWeight:

                // get total weighted amount to distribute & total number of destinations
                this.initFixedWeight();
                break;

            case LedgerAllocationMethod::SpreadEven:
                this.initSpreadEven(ledgerAllocationRule.DestinationAccountFrom, ledgerAllocationRule.DestinationDimensionFrom);
                break;

            default :
                
                if(!this.tryInitBasedOnAllocationMethod())
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryInitBasedOnAllocationMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the <c>LedgerAllocationMethod</c> enumeration is correctly initialized.
    /// </summary>
    /// <returns>
    /// Returns true if the <c>LedgerAllocationMethod</c> enumeration is correctly initialized; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean tryInitBasedOnAllocationMethod()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFixedPercentage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fixed Percentage allocation method requires all destinations to be user-specified.
    /// </summary>
    /// <remarks>
    /// The <c>LedgerAllocationRuleDestination</c> table will contain all the destination <c>BudgetPlanLine</c> table records' main accounts and dimensions.
    /// The total percentage to distribute can be less than 100%.
    /// </remarks>
    protected void initFixedPercentage()
    {
        // determine the total percentage for all destinations and the total number of destinations
        select sum(FixedPercent), count(RecId) from ruleDestination
               where ruleDestination.RuleID == ruleId;

        totalPercentage              = ruleDestination.FixedPercent;
        numberOfDestinations         = any2int(ruleDestination.RecId);
        numberOfOriginalDestinations = numberOfDestinations;
        totalOriginalPercentage      = totalPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFixedWeight</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fixed Weight allocation method requires all destinations to be user-specified.
    /// </summary>
    /// <remarks>
    /// The <c>LedgerAllocationRuleDestination</c> table will contain all of the <c>BudgetPlanLine</c> table records' main accounts and dimensions.
    /// </remarks>
    protected void initFixedWeight()
    {
        // determine the total weight for all destinations and the total number of destinations
        select sum(FixedWeight), count(RecId) from ruleDestination
               where ruleDestination.RuleID == ruleId;

        totalWeight                  = ruleDestination.FixedWeight;
        numberOfDestinations         = any2int(ruleDestination.RecId);
        numberOfOriginalDestinations = numberOfDestinations;
        totalOriginalWeight          = totalWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>LedgerAllocationProcessReqByBudgetPlan</c> class.
    /// </summary>
    /// <param name="_budgetPlanHeaderRecId">
    /// <c>BudgetPlanHeaderRecId</c> field of <c>BudgetPlanLine</c> table.
    /// </param>
    /// <param name="_budgetPlanSourceScenarioRecId">
    /// <c>BudgetPlanScenarioRecId</c> field of <c>BudgetPlanLine</c> table for source scenario.
    /// </param>
    /// <param name="_budgetPlanBasisScenarioRecId">
    /// <c>BudgetPlanScenarioRecId</c> field of <c>BudgetPlanLine</c> table for basis scenario.
    /// </param>
    /// <param name="_budgetPlanTargetScenarioRecId">
    /// <c>BudgetPlanScenarioRecId</c> field of <c>BudgetPlanLine</c> table for target scenario.
    /// </param>
    /// <param name="_ruleId">
    /// Record Id of <c>LedgerAllocationRule</c> table.
    /// </param>
    /// <param name="_useSourceEffectiveDateForAllocation">
    /// A boolean value that indicates if source effective date is to be used; optional.
    /// </param>
    /// <param name="_appendLines">
    /// A boolean value determining whether line data should be appended; optional.
    /// </param>
    public void initRequest(
        BudgetPlanHeaderRecId   _budgetPlanHeaderRecId,
        BudgetPlanScenarioRecId _budgetPlanSourceScenarioRecId,
        BudgetPlanScenarioRecId _budgetPlanBasisScenarioRecId,
        BudgetPlanScenarioRecId _budgetPlanTargetScenarioRecId,
        LedgerAllocationRuleID  _ruleId,
        boolean                 _useSourceEffectiveDateForAllocation = false,
        boolean                 _appendLines = false)
    {
        ruleId                              = _ruleId;
        budgetPlanHeaderRecId               = _budgetPlanHeaderRecId;
        budgetPlanSourceScenarioRecId       = _budgetPlanSourceScenarioRecId;
        budgetPlanBasisScenarioRecId        = _budgetPlanBasisScenarioRecId;
        budgetPlanTargetScenarioRecId       = _budgetPlanTargetScenarioRecId;
        useSourceEffectiveDateForAllocation = _useSourceEffectiveDateForAllocation;
        appendLines                         = _appendLines;

        if (!useSourceEffectiveDateForAllocation)
        {
            budgetPlanLineDefaultEffectiveDate  = BudgetPlanningProcessHelper::getProcessCycleStartDate(BudgetPlanHeader::find(budgetPlanHeaderRecId).BudgetPlanningProcess);
        }

        ledgerAllocationRule     = LedgerAllocationRule::find(ruleId);

        basisRule                = LedgerAllocationBasisRulesByBudgetPlan::construct();
        basisRule.initRequest(budgetPlanHeaderRecId, budgetPlanBasisScenarioRecId, useSourceEffectiveDateForAllocation, budgetPlanLineDefaultEffectiveDate);

        budgetPlanSourceScenario = BudgetPlanScenario::find(budgetPlanSourceScenarioRecId);
        budgetPlanTargetScenario = BudgetPlanScenario::find(budgetPlanTargetScenarioRecId);

        // set the date range to be used (need if retrieving source amounts from ledger data)
        if (ledgerAllocationRule.DateInterval)
        {
            //
            // As per the ledgerAllocationProcess request class, we are doing period balance; get the date range for the date interval chosen based on the 'as of date'
            // Since in case of BudgetPlanLine allocation we are not setting the asOfDate. We are setting the period codes using session date.
            //
            ledgerPeriodCode = LedgerPeriodCode::find(ledgerAllocationRule.DateInterval);
            startDate = ledgerPeriodCode.fromDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
            endDate = ledgerPeriodCode.toDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }
        else
        {
            // we are doing net change; date range is from start of time up to the max date.
            startDate = dateNull();
            endDate = dateMax();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Intializes the source amounts and quantities to allocate.
    /// </summary>
    /// <returns>
    /// true if the source amount or quantity exists; otherwise false.
    /// </returns>
    /// <remarks>
    /// This method is similar to <c>initSourceAmounts</c> method of <c>LedgerAllocationProcessRequest</c> class. In both these methods are initializing
    /// the <c>allocationTotal</c> property and <c>amountRemaing</c> property. In this version of the method is also initializing the <c>BudgetPlanLine</c>.
    /// Since <c>LedgerAllocationTmpSource</c> table is not used, the <c>LedgerDimension</c> field of <c>BudgetPlanLine</c> table source record is also retrieved
    /// when <c>LedgerAllocationRule</c> table <c>DestinationAccountFrom</c> field is set to true or <c>DestinationDimensionFrom</c> set to true. The basic difference
    /// between these two methods is that the <c>initSourceAmounts</c> method retrieves the values to populate the amounts from the <c>LedgerAllocationTmpSource</c> table
    /// whereas this method uses the query object to retrieve the values directly from the <c>BudgetPlanLine</c> table source records.
    /// </remarks>
    public boolean initSourceValues()
    {
        boolean                             sourceAmountsExist,
                                            recordExist;
        CurrencyCode                        callersMSTCurrency;
        Query                               query;
        QueryRun                            queryRun;

        BudgetPlanQuantity                  quantityAllocationSubTotal;
        BudgetPlanUnitOfMeasureRecId        sourceUnitOfMeasure,
                                            targetUnitOfMeasure,
                                            subTotalUnitOfMeasure;
        BudgetPlanCurrencyAmount            allocationSubTotal;
        BudgetPlanCurrencyCode              subTotalCurrencyCode;
        UnitOfMeasureConverter              unitOfMeasureConverter;

        BudgetPlanLine                      budgetPlanLine;

        sourceAmountsExist          = false;
        recordExist                 = false;
        callersMSTCurrency          = CompanyInfoHelper::standardCurrency();
        sourceUnitOfMeasure         = budgetPlanSourceScenario.UnitOfMeasure;
        targetUnitOfMeasure         = budgetPlanTargetScenario.UnitOfMeasure;

        effectiveDatesAllocationMap = new Map(Types::Date, Types::Container);

        if (ledgerAllocationRule.DataSource == LedgerAllocationSource::FixedValue)
        {
            if (budgetPlanTargetScenario.UnitOfMeasureClass == UnitOfMeasureClass::Monetary)
            {
                allocationTotal         = ledgerAllocationRule.FixedValue;
                quantityAllocationTotal = 0;
                unitPrice               = 0;
                planCurrencyCode        = callersMSTCurrency;
                sourceAmountsExist      = true;
            }
            else
            {
                quantityAllocationTotal = ledgerAllocationRule.FixedValue;
                unitOfMeasure           = targetUnitOfMeasure;
                sourceAmountsExist      = true;
            }
        }
        else
        {
            if (budgetPlanSourceScenarioRecId == budgetPlanTargetScenarioRecId)
            {
                // Initialize the set containing the recIds of budget plan lines to be deleted
                setSourceRecId = new Set(Types::Int64);
            }

            query = this.getBudgetPlanningQuery();

            if (budgetPlanSourceScenario.UnitOfMeasureClass == UnitOfMeasureClass::Monetary)
            {
                // Run the query and populate the total amount and total quantity, also populate the ledger dimension, account or dimension sets where necessary.
                queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    budgetPlanLine = queryRun.get(tableNum(BudgetPlanLine));

                    if (ledgerAllocationRule.DestinationAccountFrom && ledgerAllocationRule.DestinationDimensionFrom)
                    {
                        // If both main account and dimension is from the source
                        this.setLedgerDimensionValues(budgetPlanLine);
                    }
                    else if (ledgerAllocationRule.DestinationAccountFrom)
                    {
                        // If only main account is from the source
                        this.setAccountValues(budgetPlanLine);
                    }
                    else if (ledgerAllocationRule.DestinationDimensionFrom)
                    {
                        // only dimension is from the source
                        this.setDimensionValues(budgetPlanLine);
                    }

                    if (recordExist)
                    {
                        allocationSubTotal          = budgetPlanLine.TransactionCurrencyAmount;
                        subTotalCurrencyCode        = budgetPlanLine.TransactionCurrencyCode;
                        quantityAllocationSubTotal  = budgetPlanLine.Quantity;

                        if (subTotalCurrencyCode != planCurrencyCode)
                        {
                            if (subTotalCurrencyCode != callersMSTCurrency)
                            {
                                // Convert the amount into the caller's standard currency using the budgeting exchange rate type and budget plan line effective date.
                                allocationSubTotal = BudgetTransactionManager::calculateTransAmountToAccountingAmount(allocationSubTotal, subTotalCurrencyCode,
                                                                                                                        budgetPlanLine.EffectiveDate);
                            }

                            if (planCurrencyCode != callersMSTCurrency)
                            {
                                // Convert the amount into the caller's standard currency using the budgeting exchange rate type and budget plan line effective date.
                                allocationTotal  = BudgetTransactionManager::calculateTransAmountToAccountingAmount(allocationTotal, planCurrencyCode,
                                                                                                                        budgetPlanLine.EffectiveDate);
                                planCurrencyCode    = callersMSTCurrency;
                            }
                        }

                        allocationTotal         += allocationSubTotal;
                        quantityAllocationTotal = quantityAllocationTotal + budgetPlanLine.Quantity;
                    }
                    else
                    {
                        allocationSubTotal          = budgetPlanLine.TransactionCurrencyAmount;
                        allocationTotal             = allocationSubTotal;
                        quantityAllocationSubTotal  = budgetPlanLine.Quantity;
                        quantityAllocationTotal     = quantityAllocationSubTotal;
                        unitOfMeasure               = targetUnitOfMeasure;
                        unitPrice                   = budgetPlanLine.TransactionUnitPrice;
                        planCurrencyCode            = budgetPlanLine.TransactionCurrencyCode;
                        recordExist                 = true;
                    }

                    if (budgetPlanSourceScenarioRecId == budgetPlanTargetScenarioRecId)
                    {
                        setSourceRecId.add(budgetPlanLine.RecId);
                    }

                    //
                    // If use source effective date field is checked, add the current budget plan line effective date to the map along with the
                    // current budget plan line amount and quantity.
                    //

                    if (useSourceEffectiveDateForAllocation)
                    {
                        this.addAmountAndQuantityByEffectiveDate(budgetPlanLine.EffectiveDate, allocationSubTotal, quantityAllocationSubTotal);
                    }

                    sourceAmountsExist = true;
                }
            }
            else
            {
                queryRun = new QueryRun(query);

                while (queryRun.next())
                {
                    budgetPlanLine = queryRun.get(tableNum(BudgetPlanLine));

                    if (ledgerAllocationRule.DestinationAccountFrom && ledgerAllocationRule.DestinationDimensionFrom)
                    {
                        // If both main account and dimension is from the source
                        this.setLedgerDimensionValues(budgetPlanLine);
                    }
                    else if (ledgerAllocationRule.DestinationAccountFrom)
                    {
                        // If only main account is from the source
                        this.setAccountValues(budgetPlanLine);
                    }
                    else if (ledgerAllocationRule.DestinationDimensionFrom)
                    {
                        // If only dimension is from the source
                        this.setDimensionValues(budgetPlanLine);
                    }

                    if (recordExist)
                    {
                        quantityAllocationSubTotal  = budgetPlanLine.Quantity;
                        subTotalUnitOfMeasure       = budgetPlanLine.UnitOfMeasure;

                        // In case of multiple unit of measures for non-monetary scenario, all the units are converted to the source scenario default unit of measure
                        if (subTotalUnitOfMeasure != unitOfMeasure)
                        {
                            if (subTotalUnitOfMeasure != sourceUnitOfMeasure)
                            {
                                unitOfMeasureConverter = UnitOfMeasureConverter::newFromConversionParameters(
                                                                    subTotalUnitOfMeasure,
                                                                    sourceUnitOfMeasure,
                                                                    NoYes::No);

                                quantityAllocationSubTotal = unitOfMeasureConverter.convertValue(quantityAllocationSubTotal);
                            }

                            if (unitOfMeasure != sourceUnitOfMeasure)
                            {
                                unitOfMeasureConverter = UnitOfMeasureConverter::newFromConversionParameters(
                                                                unitOfMeasure,
                                                                sourceUnitOfMeasure,
                                                                NoYes::No);

                                quantityAllocationTotal = unitOfMeasureConverter.convertValue(quantityAllocationTotal);
                                unitOfMeasure           = sourceUnitOfMeasure;
                            }
                        }

                        quantityAllocationTotal += quantityAllocationSubTotal;
                    }
                    else
                    {
                        quantityAllocationTotal = budgetPlanLine.Quantity;
                        unitOfMeasure           = budgetPlanLine.UnitOfMeasure;
                        planCurrencyCode        = callersMSTCurrency;
                        recordExist             = true;
                    }

                    if (budgetPlanSourceScenarioRecId == budgetPlanTargetScenarioRecId)
                    {
                        setSourceRecId.add(budgetPlanLine.RecId);
                    }

                    if (useSourceEffectiveDateForAllocation)
                    {
                        this.addAmountAndQuantityByEffectiveDate(budgetPlanLine.EffectiveDate, allocationSubTotal, quantityAllocationSubTotal);
                    }

                    sourceAmountsExist = true;
                }
            }
        }

        return sourceAmountsExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSpreadEven</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the number of destination allocations to be created for spread even method.
    /// </summary>
    /// <param name="_keepAccountFrom">
    /// Keep account(s) from source <c>BudgetPlanLine</c> table records.
    /// </param>
    /// <param name="_keepDimensionFrom">
    /// Keep dimension(s) from source <c>BudgetPlanLine</c> table records.
    /// </param>
    protected void initSpreadEven(
        LedgerAllocationFromTo _keepAccountFrom,
        LedgerAllocationFromTo _keepDimensionFrom)
    {
        boolean     usingSourceAccounts, usingSourceDimensions;

        usingSourceAccounts   = _keepAccountFrom == LedgerAllocationFromTo::Source;
        usingSourceDimensions = _keepDimensionFrom == LedgerAllocationFromTo::Source;

        if (usingSourceAccounts && usingSourceDimensions)
        {
            // Both Accounts and Dimensions are from Source: get count from set containing ledger dimension.
            numberOfDestinations = setLedgerDimension.elements();
        }
        else
        {
            // Get the number of destinations defined from the rule.
            numberOfDestinations = LedgerAllocationRuleDestinations::destinationRecordCount(ruleId);

            // Accounts are from Source: get count from set containing accounts and multiple it by rule destination.
            if (usingSourceAccounts)
            {
                numberOfDestinations =  numberOfDestinations * setAccount.elements();
            }
            else if (usingSourceDimensions)
            {
                // Dimensions are from Source: get count from set containing Dimensions and multiple it by rule destination.
                numberOfDestinations =  numberOfDestinations * setDimension.elements();
            }
        }

        numberOfOriginalDestinations = numberOfDestinations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetVariables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the variables to their original state.
    /// </summary>
    private void resetVariables()
    {
        totalAmountAllocated    = 0;
        totalQuantityAllocated  = 0;
        numberOfDestinations    = numberOfOriginalDestinations;
        totalPercentage         = totalOriginalPercentage;
        totalWeight             = totalOriginalWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>LedgerDimension</c> field of <c>BudgetPlanLine</c> table record and creates a new  a default account and retrieves the record ID of the persisted
    /// <c>DimensionAttributeValueCombination</c> table record.
    /// based on the Main Account in the <c>BudgetPlanLine</c> table's <c>LedgerDimension</c> field.
    /// </summary>
    /// <param name="_budgetPlanLine">
    /// <c>BudgetPlanLine</c> table buffer.
    /// </param>
    private void setAccountValues(BudgetPlanLine _budgetPlanLine)
    {
        RecId                               defaultAccount;
        DimensionHierarchyLevel             dimHierarchyLevel;
        DimensionAttributeValueGroup        valueGroup;
        DimensionAttributeLevelValueAllView levelValueView;
        DimensionStorage                    dimStorage;

        if (setAccount == null)
        {
            setAccount = new Set(Types::Int64);
        }

        // Figure out how many segments are in the account structure.
        select reverse firstOnly Level, DimensionHierarchy from dimHierarchyLevel order by Level
            join RecId, DimensionHierarchy from valueGroup where
                valueGroup.DimensionHierarchy == dimHierarchyLevel.DimensionHierarchy
            join * from levelValueView where
                valueGroup.RecId == levelValueView.DimensionAttributeValueGroup
                 && levelValueView.ValueCombinationRecId == _budgetPlanLine.LedgerDimension
                 && levelValueView.DimensionAttribute == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

        dimStorage = DimensionStorage::construct(0);
        dimStorage.addAccountStructure(valueGroup.DimensionHierarchy, dimHierarchyLevel.Level);

        // Find the main account segment
        select firstOnly Level from dimHierarchyLevel order by Level where
            dimHierarchyLevel.DimensionHierarchy == valueGroup.DimensionHierarchy &&
            dimHierarchyLevel.DimensionAttribute == DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

        dimStorage.setSegment(
            dimHierarchyLevel.Level,
            DimensionStorageSegment::construct(
                levelValueView.DisplayValue,
                levelValueView.AttributeValueRecId,
                levelValueView.AttributeValueHashKey,
                levelValueView.DimensionAttribute,
                levelValueView.EntityInstance));

        defaultAccount = dimStorage.saveAsDefaultAccount();

        setAccount.add(defaultAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves <c>ledgerDimension</c> field from <c>BudgetPlanLine</c> table record and converts it to <c>DimensionDefault</c> extended data type.
    /// </summary>
    /// <param name="_budgetPlanLine">
    /// Record buffer of <c>BudgetPlanLine</c> table.
    /// </param>
    private void setDimensionValues(BudgetPlanLine _budgetPlanLine)
    {
        DimensionDefault defaultDimension;

        if (setDimension == null)
        {
            setDimension = new Set(Types::Int64);
        }

        // Break ledger dimension into default dimension information
        defaultDimension = LedgerDimensionDefaultingEngine::getDefaultDimension(LedgerDimensionDefaultingEngine::getDimensionSourcesForLedgerDimension(_budgetPlanLine.LedgerDimension));

        setDimension.add(defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDistributionValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assigns the value in the <c>BudgetPlanLine</c> table record buffer for allocation.
    /// </summary>
    /// <param name="_ledgerDimensionId">
    /// The record ID of the <c>DimensionAttributeValueCombination</c> table.
    /// </param>
    /// <param name="_dimensionDefault">
    /// The record ID of the <c>DimensionAttributeValueSet</c> table.
    /// </param>
    /// <param name="_amountCur">
    ///  The amount to be assigned to the <c>BudgetPlanLine</c> table record buffer.
    /// </param>
    /// <param name="_quantity">
    /// The quantity to be assigned to the <c>BudgetPlanLine</c> table record buffer.
    /// </param>
    /// <param name="_currentCompany">
    /// The <c>DataArea</c> string that identifies a company.
    /// </param>
    /// <param name="_fromSource">
    /// true when both account and dimensions are from the source <c>BudgetPlanLine</c> table record; otherwise false.
    /// </param>
    /// <returns>
    /// The record buffer of <c>BudgetPlanLine</c> table.
    /// </returns>
    /// <remarks>
    /// This method is similar to the <c>setDistributionValues</c> method of <c>LedgerAllocationProcessRequest</c> class.
    /// In <c>LedgerAllocationProcessRequest</c> class, the <c>ledgerDimension</c> field of the <c>LedgerJournalTrans</c> is
    /// recreated even in the case when both main account and dimension fields are from the source. This method in the following condition
    /// uses the source <c>BudgetPlanLine</c> table's <c>LedgerDimension</c> field directly _fromSource flag is used to indicate this condition.
    /// </remarks>
    /// <exception cref="Exception::Error">
    /// Occurs when the main account or any of the dimension segment is invalid for the required company.
    /// </exception>
    /// <exception cref="Exception::Error">
    /// Occurs when the main account or any of the dimension segment is invalid for the current company.
    /// </exception>
    protected BudgetPlanLine setDistributionValues(
        RecId                       _ledgerDimensionId,
        DimensionDefault            _dimensionDefault,
        BudgetPlanCurrencyAmount    _amountCur,
        BudgetPlanQuantity          _quantity,
        CompanyId                   _currentCompany = curext(),
        boolean                     _fromSource = false)
    {
        BudgetPlanLine localBudgetPlanLine;
        localBudgetPlanLine.BudgetPlanHeader = budgetPlanHeaderRecId;
        localBudgetPlanLine.initValue();

        if (_fromSource)
        {
            //
            // In <c>LedgerAllocationProcessRequest</c> class, the <c>ledgerDimension</c> field of the <c>LedgerJournalTrans</c> is
            // recreated even in the case when both main account and dimension fields are from the source. This method in the following condition
            // uses the source <c>BudgetPlanLine</c> table's <c>LedgerDimension</c> field directly.
            //
            localBudgetPlanLine.LedgerDimension = _ledgerDimensionId;
        }
        else if (!prmisDefault(_currentCompany))
        {
            changecompany(_currentCompany)
            {
                if (!LedgerAllocationRules::validateLedgerAccount(_ledgerDimensionId, true) ||
                    !LedgerAllocationRules::validateDimension(_dimensionDefault, true))
                {
                    needToThrowGenError = false;
                    throw error("@SYS106317");
                }
            }
        }
        else if (prmisDefault(_currentCompany))
        {
            if (!LedgerAllocationRules::validateLedgerAccount(_ledgerDimensionId) ||
                !LedgerAllocationRules::validateDimension(_dimensionDefault))
            {
                needToThrowGenError = false;
                throw error("@SYS106317");
            }
        }

        changecompany(_currentCompany)
        {
            localBudgetPlanLine.LedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimensionForType(
                LedgerDimensionType::BudgetPlanning,
                _ledgerDimensionId,
                _dimensionDefault);
        }

        localBudgetPlanLine.BudgetPlanHeader           = budgetPlanHeaderRecId;
        localBudgetPlanLine.BudgetPlanScenario         = budgetPlanTargetScenarioRecId;
        localBudgetPlanLine.Quantity                   = _quantity;
        localBudgetPlanLine.TransactionCurrencyAmount  = _amountCur;
        localBudgetPlanLine.TransactionCurrencyCode    = planCurrencyCode;
        localBudgetPlanLine.TransactionUnitPrice       = unitPrice;
        localBudgetPlanLine.UnitOfMeasure              = unitOfMeasure;
        localBudgetPlanLine.EffectiveDate              = effectiveDatesAllocationMapEnumerator.currentKey();

        return localBudgetPlanLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>LedgerDimension</c> field of <c>BudgetPlanLine</c> table record and add it to the instance of <c>Set</c> class named setLedgerDimension.
    /// </summary>
    /// <param name="_budgetPlanLine">
    /// <c>BudgetPlanLine</c> table buffer.
    /// </param>
    private void setLedgerDimensionValues(BudgetPlanLine _budgetPlanLine)
    {
        if (setLedgerDimension == null)
        {
            setLedgerDimension = new Set(Types::Int64);
        }

        setLedgerDimension.add(_budgetPlanLine.LedgerDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBasisRules</Name>
				<Source><![CDATA[
    /// <summary>
    /// The allocation rule is of allocation type  = Basis. Iterate through each destination line
    /// for the rule and validate the Basis Id assigned to that destination line.
    /// </summary>
    /// <returns>
    /// true if the <c>LedgerAllocationBasisRule</c> table record is valid; otherwise false.
    /// </returns>
    /// <remarks>
    /// Called only when the allocation rule is of allocation type = Basis.
    /// </remarks>
    protected  boolean validateBasisRules()
    {
        boolean ret = true;
        LedgerAllocationBasisNum        basisId;

        while select ruleDestination
            where ruleDestination.RuleID == ruleId && ruleDestination.BasisId != ''
        {
            basisId = ruleDestination.BasisId;

            if (!LedgerAllocationBasisRule::find(basisId))
            {
                ret = checkFailed(strFmt("@SYS104124", basisId));
            }
            else
            {
                if (!LedgerAllocationBasisRules::isRuleActive(basisId))
                {
                    ret = checkFailed(strFmt("@SYS106172", basisId));
                }

                if (!LedgerAllocationBasisRules::isAsOfDateValid(basisId, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())))
                {
                    // Since asOfDate is not set in budget planning, session date is used instead
                    ret = checkFailed(strFmt("@SYS106171", DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), basisId));
                }

                // budget plan specific change: at least one source record must be specified for the basis rule
                if (!((select firstonly BasisId
                    from
                        ledgerAllocationBasisRuleSource
                    where
                        ledgerAllocationBasisRuleSource.BasisId == basisId).BasisId == basisId))
                {
                    ret = checkFailed(strFmt("@SYS106595", basisId));
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the ledger allocation rule and basis rules.
    /// </summary>
    /// <returns>
    /// true if all conditions are fulfilled; otherwise, false.
    /// </returns>
    private boolean validateRequest()
    {
        boolean ret = true;

        if (!ledgerAllocationRule)
        {
            ret = checkFailed(strFmt("@SYS97692", ruleId, fieldPName(LedgerAllocationRule, RuleId), tablePName(LedgerAllocationRule)));
        }
        else
        {
            if (!LedgerAllocationRules::isRuleActive(ruleId))
            {
                ret = checkFailed("@SYS106011");
            }

            if (!LedgerAllocationRules::isAsOfDateValid(ruleId, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())))
            {
                // Since in case of BudgetPlanLine allocation we are not setting the asOfDate. We are performing the validations using session date.
                ret = checkFailed(strFmt("@SYS106012", DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())));
            }

            if (ledgerAllocationRule.DataSource != LedgerAllocationSource::FixedValue &&
               (budgetPlanSourceScenario.UnitOfMeasureClass != UnitOfMeasureClass::Monetary
                && budgetPlanTargetScenario.UnitOfMeasureClass != UnitOfMeasureClass::Monetary))
            {
                //
                // Budget Plan specific code.
                // Compare the source scenario and target scenario unit of measure when both are non-monetary.
                // Ignore this condition when ledger allocation rule datasource is fixed value.
                //
                if (budgetPlanSourceScenario.UnitOfMeasureClass != budgetPlanTargetScenario.UnitOfMeasureClass)
                {
                    ret = checkFailed("@GLS150220");
                }
            }

            // No offset account in Budget Planning.

            if (ledgerAllocationRule.DestinationAccountFrom == LedgerAllocationFromTo::UserSpecified)
            {
                // budget plan specific change: at least one destination record must be specified for the rule
                if (!((select firstOnly RuleID
                    from
                        ledgerAllocationRuleDestination
                    where
                        ledgerAllocationRuleDestination.RuleID == ruleId &&
                        ledgerAllocationRuleDestination.ToLedgerDimension != 0).RuleID == ruleId))
                {
                    ret = checkFailed("@SYS106071");
                }
            }

            if (ledgerAllocationRule.DataSource == LedgerAllocationSource::Ledger)
            {
                // at least one source account must be specified for the rule
                if (!((select firstOnly RuleID
                    from
                        ledgerAllocationRuleSource
                    where
                        ledgerAllocationRuleSource.RuleID == ruleId &&
                        ledgerAllocationRuleSource.SourceCriteria != '').RuleID == ruleId))
                {
                    ret = checkFailed("@SYS103516");
                }
            }

            if (ledgerAllocationRule.AllocationMethod == LedgerAllocationMethod::Basis)
            {
                ret = this.validateBasisRules() && ret;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static LedgerAllocationProcessReqByBudgetPlan construct()
    {
        return new LedgerAllocationProcessReqByBudgetPlan();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBudgetPlanLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the <c>BudgetPlanLine</c> table records that are returned by specified <c>QueryRun</c> class instance.
    /// </summary>
    /// <param name="_queryRun">
    /// The <c>QueryRun</c> class instance.
    /// </param>
    public static void deleteBudgetPlanLines(QueryRun _queryRun)
    {
        BudgetPlanLine  localBudgetPlanLine,
                        deleteBudgetPlanLine;

        // delete the budget plan lines having matching ledger dimension
        while (_queryRun.next())
        {
            localBudgetPlanLine = _queryRun.get(tableNum(BudgetPlanLine));

            delete_from deleteBudgetPlanLine
                where deleteBudgetPlanLine.RecId == localBudgetPlanLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addAmountAndQuantityByEffectiveDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts amount and quantity to be allocated for an effective date in a map.
    /// </summary>
    /// <param name="_budgetPlanLineEffectiveDate">
    /// The effective date of the <c>BudgetPlanLine</c> record.
    /// </param>
    /// <param name="_budgetPlanCurrencyAmount">
    /// The allocated amount for an effective date.
    /// </param>
    /// <param name="_budgetPlanQuantity">
    /// The allocated quantity for an effective date.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Wrong use of function error is thrown if no value is passed for date parameter.
    /// </exception>
    private void addAmountAndQuantityByEffectiveDate(
        BudgetPlanLineEffectiveDate _budgetPlanLineEffectiveDate,
        BudgetPlanCurrencyAmount    _budgetPlanCurrencyAmount   = 0,
        BudgetPlanQuantity          _budgetPlanQuantity         = 0)
    {
        BudgetPlanCurrencyAmount    budgetPlanCurrencyAmount;
        BudgetPlanQuantity          budgetPlanQuantity;

        if (_budgetPlanLineEffectiveDate == dateNull())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (effectiveDatesAllocationMap.exists(_budgetPlanLineEffectiveDate))
        {
            [budgetPlanCurrencyAmount, budgetPlanQuantity] = effectiveDatesAllocationMap.lookup(_budgetPlanLineEffectiveDate);

            budgetPlanCurrencyAmount    += _budgetPlanCurrencyAmount;
            budgetPlanQuantity          += _budgetPlanQuantity;
        }
        else
        {
            budgetPlanCurrencyAmount    = _budgetPlanCurrencyAmount;
            budgetPlanQuantity          = _budgetPlanQuantity;
        }

        effectiveDatesAllocationMap.insert(
            _budgetPlanLineEffectiveDate,
            [budgetPlanCurrencyAmount,
            budgetPlanQuantity]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAppendLines</Name>
				<Source><![CDATA[
    public boolean parmAppendLines(boolean _appendLines = appendLines)
    {
        appendLines = _appendLines;
        return appendLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRuleSourceCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates query ranges based on the allocation rule source criteria.
    /// </summary>
    /// <param name="_query">
    /// The query to determine the amounts to be allocated from ledger.
    /// </param>
    /// <param name="_ruleSource">
    /// The <c>LedgerAllocationRuleSource</c> record.
    /// </param>
    protected void processRuleSourceCriteria(Query _query, LedgerAllocationRuleSource _ruleSource)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRuleSourceFieldSetting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the dimension attribute value based on the field setting.
    /// </summary>
    /// <param name="_ledgerAllocRuleSource">
    /// The <c>LedgerAllocationRuleSource</c> record.
    /// </param>
    /// <param name="_mainAccountDimAttrId">
    /// The identifier of the primary dimension attribute.
    /// </param>
    /// <returns>
    /// The unique identifier of the <c>DimensionAttribute</c>.
    /// </returns>
    protected RecId setRuleSourceFieldSetting(LedgerAllocationRuleSource _ledgerAllocRuleSource, RecId _mainAccountDimAttrId)
    {
        RecId keyValue;
        if (_ledgerAllocRuleSource.FieldSetting == LedgerAllocationAccountDimension::Account)
        {
            keyValue = _mainAccountDimAttrId;
        }
        else
        {
            keyValue = _ledgerAllocRuleSource.SourceDimensionAttribute;
        }
        return keyValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRuleSourceCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the ledger allocation rule source criteria.
    /// </summary>
    /// <param name="_ledgerAllocRuleSource">
    /// The <c>LedgerAllocationRuleSource</c> record.
    /// </param>
    /// <param name="_keyValue">
    /// The identifier of the primary dimension attribute.
    /// </param>
    /// <param name="_emptyStr">
    /// Empty string.
    /// </param>
    /// <param name="_dimensionRange">
    /// The map to build dimension attribute criteria.
    /// </param>
    /// <param name="_dimensionRangeIncludeEmpty">
    /// The set to track empty values included in the dimension attribute.
    /// </param>
    protected void createRuleSourceCriteria(LedgerAllocationRuleSource _ledgerAllocRuleSource, RecId _keyValue, str _emptyStr, Map _dimensionRange, Set _dimensionRangeIncludeEmpty)
    {
        if (_ledgerAllocRuleSource.FieldSetting == LedgerAllocationAccountDimension::Account || _ledgerAllocRuleSource.FieldSetting == LedgerAllocationAccountDimension::Dimension)
        {
            if (_ledgerAllocRuleSource.SourceCriteria == _emptyStr)
            {
                // Track whether empty is included by dimension attribute
                _dimensionRangeIncludeEmpty.add(_keyValue);

                // Then mark that this dimension attribute exists as criteria
                if (!_dimensionRange.exists(_keyValue))
                {
                    _dimensionRange.insert(_keyValue, _emptyStr);
                }
            }
            else
            {
                // Build up criteria
                if (_dimensionRange.exists(_keyValue) && _dimensionRange.lookup(_keyValue) != _emptyStr)
                {
                    _dimensionRange.insert(_keyValue, _dimensionRange.lookup(_keyValue) + ',' + _ledgerAllocRuleSource.SourceCriteria);
                }
                else
                {
                    _dimensionRange.insert(_keyValue, _ledgerAllocRuleSource.SourceCriteria);
                }
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>