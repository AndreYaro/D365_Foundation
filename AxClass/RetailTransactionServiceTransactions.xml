<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceTransactions</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Reflection;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using Microsoft.Dynamics.Commerce.Runtime.TransactionService.Serialization;
using Microsoft.Dynamics.Application.Instrumentation;
using CrtTransactionService = Microsoft.Dynamics.Commerce.Runtime.TransactionService;
using CrtOrderOriginator = Microsoft.Dynamics.Commerce.Runtime.DataModel.OrderOriginator;
using CrtDataModel = Microsoft.Dynamics.Commerce.Runtime.DataModel;

/// <summary>
/// The <c>RetailTransactionServiceTransactions</c> implements the transactions related methods of the service interface exposed by the <c>RetailTransactionService</c> class to the retail channels.
/// </summary>
public class RetailTransactionServiceTransactions
{
    #define.resultsCountOfTransaction(20)
    #define.resultsDefaultSkip(1)
    #define.OfferName('OfferName')
    #define.ColumnDealPrice('DealPrice')
    #define.ColumnAmount('Amount')
    #define.ColumnPercentage('Percentage')
    #define.ColumnLineManualDiscountAmount('LineManualDiscountAmount')
    #define.ColumnLineManualDiscountPercentage('LineManualDiscountPercentage')
    #define.ColumnPeriodicPercentageDiscount('PeriodicPercentageDiscount')
    #define.ColumnPeriodicDiscount('PeriodicDiscount')
    #define.ColumnTotalDiscount('TotalDiscount')
    #define.ColumnTotalPercentageDiscount('TotalPercentageDiscount')
    #define.ColumnLineDiscount('LineDiscount')
    #define.ElementSalesOrder('SalesOrder')
    #define.ElementSalesTransaction('SalesTransaction')
    #define.OriginalPrice('OriginalPrice')
    #define.IsPriceOverridden('IsPriceOverridden')

    #define.TrueStr('true')
    #define.FalseStr('false')

    #ISOCountryRegionCodes

    #EECountryRegionCodes

    public const str dateTimeOffsetXmlNsKey = 'xmlns:a';
    public const str dateTimeOffsetXmlNsValue = 'http://schemas.datacontract.org/2004/07/System';

    public const str schemaInstanceNSKey = 'xmlns:xsi';
    public const str schemaInstanceNSUrl = 'http://www.w3.org/2001/XMLSchema-instance';

    private const str fulfillmentStoreIdColumn = 'FulfillmentStoreId';
    private const str quantityOrderedColumn = 'QuantityOrdered';
    private const str discAmountColumn = 'DiscountAmount';
    private const str discAmountWithoutTaxColumn = 'DiscountAmountWithoutTax';
    private const str netPriceColumn = 'NetPrice';
    private const str ColumnLinePercentageDiscount = 'LinePercentageDiscount';

    private const str ColumnTenderDiscountPercentage = 'TenderDiscountPercentage';
    private const str ColumnTenderDiscount = 'TenderDiscountAmount';

    private const str IsTaxExemptedForPriceInclusive = 'IsTaxExemptedForPriceInclusive';
    private const str TaxExemptPriceInclusiveOriginalPrice = 'TaxExemptPriceInclusiveOriginalPrice';
    private const str TaxExemptPriceInclusiveReductionAmount = 'TaxExemptPriceInclusiveReductionAmount';

    private const str IsLegacyPriceIncludesTaxNetAmountWithoutTaxCalculationEnabled = 'IsLegacyPriceIncludesTaxNetAmountWithoutTaxCalculationEnabled';

    private const str TransactionServiceAssemblyName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService';
    private const str TransactionServiceSalesOrderParametersSearchCriteriaTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceSalesOrderParameters';
    private const str TransactionServiceOrderOriginatorParametersTypeName = 'Microsoft.Dynamics.Commerce.Runtime.TransactionService.TransactionServiceOrderOriginatorParameters';

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
    private const str SubtotalAmountNode = 'SubtotalAmount';
    private const str TaxAmountNode = 'TaxAmount';
    private const str SubtotalAmountWithoutTax = 'SubtotalAmountWithoutTax';
    private const str SubtotalSalesAmount = 'SubtotalSalesAmount';
    private const Int MaskedCardLength = 12;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getNewXmlDoc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get a new XmlDocument instance.
    /// </summary>
    /// <returns><c>XmlDocument</c> compatible with transaction service API.</c></returns>
    private static XmlDocument getNewXmlDoc()
    {
        return XmlDocument::newBlank('utf-16LE');
    }

]]></Source>
			</Method>
			<Method>
				<Name>getArrayOfSalesOrderXmlRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an ArrayOfSalesOrder root element for use in result collections from transaction service APIs.
    /// </summary>
    /// <param name = "_doc"><c>XmlDocument</c> that the root element is to be created for.</param>
    /// <returns><c>XmlElement</c> for an ArrayOfSalesOrder collection.</returns>
    private static XmlElement getArrayOfSalesOrderXmlRoot(XmlDocument _doc)
    {
        XmlElement xmlRoot = _doc.createElement('ArrayOfSalesOrder');
        xmlRoot.setAttribute('xmlns', 'http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Commerce.Runtime.DataModel');
        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillImageUrlForPurchaseHistory</Name>
				<Source><![CDATA[
    private static Set fillImageUrlForPurchaseHistory(Set purchaseHistories, LanguageId _languageId)
    {
        XmlDocument _xmlDocument = new XmlDocument();
        RetailChannelRecId channelId = 0;
        CatalogRefRecId _catalogRecId = 0;
        RefRecId internalOrgRecId = 0;
        str _attributeRecIdRangeValue = 'Image';
        RetailTmpCatalogProduct tmpCatalogProduct;
        Set productRecIds = new Set(Types::Int64);

        SetEnumerator enumerator = purchaseHistories.getEnumerator();

        while (enumerator.moveNext())
        {
            PurchaseHistory purchaseHistory = enumerator.current();
            if (!productRecIds.in(purchaseHistory.productId))
            {
                productRecIds.add(purchaseHistory.productId);
            }
        }

        Map imageByProductRecId = RetailMediaHelper::getProductPrimaryImageUrl(productRecIds, _catalogRecId, internalOrgRecId, _languageId);

        try
        {
            enumerator.reset();
            while (enumerator.moveNext())
            {
                PurchaseHistory purchaseHistory = enumerator.current();
                if (imageByProductRecId.exists(purchaseHistory.productId))
                {
                    Url imageUrl = imageByProductRecId.lookup(purchaseHistory.productId);
                    purchaseHistory.ImageUrl = imageUrl;
                }
            }
        }
        catch
        {
            eventSource.EventWriteOrdersFillImageUrlForPurchaseHistoryError(funcName());
        }

        return purchaseHistories;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImageUrlFromAttributeValueXml</Name>
				<Source><![CDATA[
    private static Url getImageUrlFromAttributeValueXml(RecId productRecId, Map attributeValueXmlByProduct)
    {
        XmlElement element = attributeValueXmlByProduct.lookup(productRecId);
        if (element == null)
        {
            return null;
        }

        XmlElement attributeValueNode = element.firstChild();
        str textValue = attributeValueNode.getAttribute('TextValue');
        XmlDocument doc = new XmlDocument();
        doc.loadXml(textValue);

        XmlNode richMediaLocations = doc.getElementsByTagName('RichMediaLocations').nextNode();
        if (richMediaLocations == null)
        {
            return null;
        }

        XmlNode richMediaLocation = richMediaLocations.childNodes().nextNode();
        if (richMediaLocation == null)
        {
            return null;
        }

        XmlNodeList childNodes = richMediaLocation.childNodes();
        XmlNode childNode = childNodes.nextNode();
        while (childNode != null)
        {
            if (childNode.name() == "Url")
            {
                return childNode.innerXml();
            }
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>backfillDiscountTrans</Name>
				<Source><![CDATA[
    private static RetailTransactionDiscountTrans backfillDiscountTrans(RetailTransactionSalesTrans _salesTrans, boolean _isPeriodic, boolean _isLine, boolean _isTotal)
    {
        RetailTransactionDiscountTrans discountTrans;
        discountTrans.TransactionId = _salesTrans.transactionId;
        discountTrans.Channel = _salesTrans.Channel;
        discountTrans.StoreId = _salesTrans.store;
        discountTrans.TerminalId= _salesTrans.terminalId;
        discountTrans.LineNum = _salesTrans.lineNum;

        if (_isPeriodic)
        {
            discountTrans.DiscountOriginType = RetailDiscountOriginType::Manual;
            discountTrans.ManualDiscountType = RetailManualDiscountType::LineDiscountAmount;
            discountTrans.Amount = _salesTrans.periodicDiscAmount;
        }
        else if (_isLine)
        {
            discountTrans.DiscountOriginType = RetailDiscountOriginType::Customer;
            discountTrans.CustomerDiscountType = RetailCustomerDiscountType::Line;
            discountTrans.Amount = _salesTrans.lineDscAmount;
        }
        else if (_isTotal)
        {
            discountTrans.DiscountOriginType = RetailDiscountOriginType::Customer;
            discountTrans.CustomerDiscountType = RetailCustomerDiscountType::TotalDiscount;
            discountTrans.Amount = _salesTrans.totalDiscAmount;
        }

        if (_salesTrans.qty)
        {
            discountTrans.DiscountAmount = discountTrans.Amount / _salesTrans.qty;
        }

        return discountTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertDocumentStatusToRetailSalesStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the document status to the RetailSalesStatus
    /// </summary>
    /// <param name="_documentStatus">
    /// The document status to be converted.
    /// </param>
    /// <returns>
    /// The converted retail sales status.
    /// </returns>
    private static RetailSalesStatus ConvertDocumentStatusToRetailSalesStatus(DocumentStatus _documentStatus)
    {
        RetailSalesStatus retailSalesStatus;

        switch (_documentStatus)
        {
            case DocumentStatus::None:
                retailSalesStatus = RetailSalesStatus::Created;
                break;

            case DocumentStatus::PickingList:
                retailSalesStatus = RetailSalesStatus::Processing;
                break;

            case DocumentStatus::PackingSlip:
                retailSalesStatus = RetailSalesStatus::Delivered;
                break;

            case DocumentStatus::Invoice:
                retailSalesStatus = RetailSalesStatus::Invoiced;
                break;

            case DocumentStatus::Cancelled:
                retailSalesStatus = RetailSalesStatus::Canceled;
                break;

            case DocumentStatus::Lost:
                retailSalesStatus = RetailSalesStatus::Lost;
                break;

            default:
                retailSalesStatus = RetailSalesStatus::Unknown;
                break;
        }

        return retailSalesStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertSalesStatusToRetailSalesStatusDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for converting the <c>SalesStatus</c> to the <c>RetailSalesStatus</c> enum value.
    /// </summary>
    /// <param name = "_salesStatus">The sales status to be converted.</param>
    /// <param name = "_result">An instance of <c>EnventHandlerResult</c> to use for providing the result of the conversion.</param>
    static delegate void convertSalesStatusToRetailSalesStatusDelegate(SalesStatus _salesStatus, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerSearchJournalCustomFilterRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension field ranges for custom filters of journal search criteria.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters.</param>
    /// <param name = "extensionRanges">List of the containers (extensionFieldName, extensionFieldValue) used to build query ranges for custom filters from extensions.</param>
    static delegate void registerSearchJournalCustomFilterRanges(XmlElement customFiltersXmlElement, List extensionRanges)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerSearchJournalCustomDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to add custom data sources and filters to the search journal query.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters and datasources.</param>
    /// <param name = "qbds">The search journal query QueryBuildDataSource object that can be used for adding custom datasources and filters</param>
    static delegate void registerSearchJournalCustomDataSources(XmlElement customFiltersXmlElement, QueryBuildDataSource qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetListOrderSearchCustomFilterRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension field ranges for custom filters of sales order search criteria.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters.</param>
    /// <param name = "extensionRanges">List of the containers (extensionFieldName, extensionFieldValue) used to build query ranges for custom filters from extensions.</param>
    static delegate void registerGetListOrderSearchCustomFilterRanges(XmlElement customFiltersXmlElement, List extensionRanges)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetListQuotationOrderSearchCustomFilterRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to get the extension field ranges for custom filters of quotations order search criteria.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters.</param>
    /// <param name = "extensionRanges">List of the containers (extensionFieldName, extensionFieldValue) used to build query ranges for custom filters from extensions.</param>
    static delegate void registerGetListQuotationOrderSearchCustomFilterRanges(XmlElement customFiltersXmlElement, List extensionRanges)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetListOrderSearchCustomDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to add custom data sources and filters to the search sales orders query.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters and datasources.</param>
    /// <param name = "qbds">The order search query QueryBuildDataSource object that can be used for adding custom datasources and filters</param>
    static delegate void registerGetListOrderSearchCustomDataSources(XmlElement customFiltersXmlElement, QueryBuildDataSource qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerGetListQuotationOrderSearchCustomDataSources</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to add custom data sources and filters to the search quotation orders query.
    /// </summary>
    /// <param name = "customFiltersXmlElement">The XML element of custom filters and datasources.</param>
    /// <param name = "qbds">The quotation order search query QueryBuildDataSource object that can be used for adding custom datasources and filters</param>
    static delegate void registerGetListQuotationOrderSearchCustomDataSources(XmlElement customFiltersXmlElement, QueryBuildDataSource qbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>ConvertSalesStatusToRetailSalesStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the sales status to the RetailSalesStatus
    /// </summary>
    /// <param name="_salesStatus">
    /// The sales status to be converted.
    /// </param>
    /// <returns>
    /// The converted retail sales status.
    /// </returns>
    public static RetailSalesStatus ConvertSalesStatusToRetailSalesStatus(SalesStatus _salesStatus)
    {
        switch (_salesStatus)
        {
            case SalesStatus::Backorder:
                return RetailSalesStatus::Created;

            case SalesStatus::Delivered:
                return RetailSalesStatus::Delivered;

            case SalesStatus::Invoiced:
                return RetailSalesStatus::Invoiced;

            case SalesStatus::Canceled:
                return RetailSalesStatus::Canceled;

            default:
                EventHandlerResult conversionResult = new EventHandlerResult();
                RetailTransactionServiceTransactions::convertSalesStatusToRetailSalesStatusDelegate(_salesStatus, conversionResult);
                if (conversionResult.hasResult())
                {
                    return conversionResult.result();
                }
                return RetailSalesStatus::Unknown;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDiscountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>discountTrans</c> having the data of the <c>RetailTransactionDiscountTrans</c> table.
    /// </summary>
    /// <param name="transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionDiscountTrans</c> table.
    /// Example:
    /// <ArrayOfTransactionDiscount>
    ///   <TransactionDiscount>
    ///    <TransactionId />
    ///    <StoreId />
    ///    <TerminalId />
    ///    <Amount />
    ///    <Channel />
    ///    <CustomerDiscountType />
    ///    <DiscountCode />
    ///    <DiscountCost />
    ///    <DiscountOriginType />
    ///    <LineNum />
    ///    <ManualDiscountType />
    ///    <Origin />
    ///    <PeriodicDiscountOfferId />
    ///    <ReplicationCounterFromOrigin />
    ///    <SaleLineNum />
    ///  </TransactionDiscount>
    ///</ArrayOfTransactionDiscount>
    /// </returns>
    private static str fillDiscountTrans(RetailTransactionTable transactionTable)
    {
        RetailTransactionSalesTrans salesTrans;
        RetailTransactionDiscountTrans discountTrans;
        XmlDocument         xmlDoc;
        XmlElement          xmlRoot;

        boolean hasLineDiscountLines = false;
        boolean hasTotalDiscountLines = false;
        boolean hasPeriodicDiscountLines = false;
        boolean hasTenderDiscountLines = false;

        RetailPeriodicDiscount retailDiscount;
        DiscAmount discountAmount;

        void addDiscountTransToXml()
        {
            XmlElement xmlRecord, xmlEntry;
            xmlRecord = xmlDoc.createElement('TransactionItemDiscount');

            xmlEntry = xmlDoc.createElement('TransactionId');
            xmlEntry.innerText(discountTrans.TransactionId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('StoreId');
            xmlEntry.innerText(discountTrans.StoreId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TerminalId');
            xmlEntry.innerText(discountTrans.TerminalId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(#ColumnDealPrice);
            xmlEntry.innerText(num2str(discountTrans.DealPrice,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('DiscountAmount');
            xmlEntry.innerText(num2str(discountAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Percentage');
            xmlEntry.innerText(num2str(discountTrans.Percentage,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Amount');
            xmlEntry.innerText(num2str(discountTrans.Amount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Channel');
            xmlEntry.innerText(int642str(discountTrans.Channel));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('CustomerDiscountType');
            xmlEntry.innerText(int2str(enum2int(discountTrans.CustomerDiscountType)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('DiscountCode');
            xmlEntry.innerText(discountTrans.DiscountCode);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('DiscountCost');
            xmlEntry.innerText(num2str(discountTrans.DiscountCost,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('DiscountOriginType');
            xmlEntry.innerText(int2str(enum2int(discountTrans.DiscountOriginType)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('LineNum');
            xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(discountTrans.LineNum));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ManualDiscountType');
            xmlEntry.innerText(int2str(enum2int(discountTrans.ManualDiscountType)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Origin');
            xmlEntry.innerText(discountTrans.Origin);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('PeriodicDiscountOfferId');
            xmlEntry.innerText(discountTrans.PeriodicDiscountOfferId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(#OfferName);
            xmlEntry.innerText(retailDiscount.Name);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ReplicationCounterFromOrigin');
            xmlEntry.innerText(int2str(discountTrans.ReplicationCounterFromOrigin));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('SaleLineNum');
            xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(discountTrans.SaleLineNum));
            xmlRecord.appendChild(xmlEntry);

            xmlRoot.appendChild(xmlRecord);
        }

        xmlDoc = XmlDocument::newBlank('Unicode');
        xmlRoot = xmlDoc.createElement('ArrayOfTransactionItemDiscount');

        while select TransactionId, Store, TerminalId, ReceiptId, LineNum, Qty,
                     TotalDiscAmount, TotalDiscPct, LineDscAmount,
                     PeriodicDiscAmount, DiscAmount, PeriodicPercentageDiscount,
                     LineManualDiscountAmount, LineManualDiscountPercentage, TenderDiscountAmount
            from salesTrans
                where salesTrans.TransactionId   == transactionTable.TransactionId
                    && salesTrans.store        == transactionTable.Store
                    && salesTrans.TerminalId     == transactionTable.Terminal
        {
            hasPeriodicDiscountLines = false;
            hasLineDiscountLines = false;
            hasTotalDiscountLines = false;
            hasTenderDiscountLines = false;

            while select discountTrans
                where discountTrans.TransactionId   == transactionTable.TransactionId
                    && discountTrans.StoreId        == transactionTable.Store
                    && discountTrans.TerminalId     == transactionTable.Terminal
                    && discountTrans.SaleLineNum    == salesTrans.LineNum
                outer join Name from retailDiscount
                    where discountTrans.PeriodicDiscountOfferId
                        && retailDiscount.OfferId == discountTrans.PeriodicDiscountOfferId
            {
                // Backfill discount amount for R2 customer orders.
                discountAmount = discountTrans.DiscountAmount;
                if (!discountAmount && !discountTrans.Percentage)
                {
                    discountAmount = salesTrans.qty ? discountTrans.Amount / salesTrans.qty : 0;
                }

                if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Periodic)
                {
                    hasPeriodicDiscountLines = true;
                }
                else if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Customer)
                {
                    if (discountTrans.CustomerDiscountType != RetailCustomerDiscountType::TotalDiscount)
                    {
                        hasLineDiscountLines = true;
                    }
                    else
                    {
                        hasTotalDiscountLines = true;
                    }
                }
                else if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Manual)
                {
                    if (discountTrans.ManualDiscountType == RetailManualDiscountType::LineDiscountAmount ||
                        discountTrans.ManualDiscountType == RetailManualDiscountType::LineDiscountPercent)
                    {
                        hasLineDiscountLines = true;
                    }
                    else
                    {
                        hasTotalDiscountLines = true;
                    }
                }
                else if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Tender)
                {
                    hasTenderDiscountLines = true;
                }

                addDiscountTransToXml();
            }

            // Backfill periodic discount transaction.
            discountAmount = 0;
            retailDiscount.clear();

            if (salesTrans.periodicDiscAmount && !hasPeriodicDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(salesTrans, true, false, false);
                addDiscountTransToXml();
            }

            // Backfill customer line discount transaction.
            if (salesTrans.lineDscAmount && !hasLineDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(salesTrans, false, true, false);
                addDiscountTransToXml();
            }

            // Backfill customer total discount transaction.
            if (salesTrans.totalDiscAmount && !hasTotalDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(salesTrans, false, false, true);
                addDiscountTransToXml();
            }

            // Backfill tender discount transaction.
            if (salesTrans.TenderDiscountAmount && !hasTenderDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(salesTrans, false, false, false);
                discountTrans.Amount = salesTrans.TenderDiscountAmount;
                if (salesTrans.qty)
                {
                    discountTrans.DiscountAmount = discountTrans.Amount / salesTrans.qty;
                }
                addDiscountTransToXml();
            }
        }

        xmlDoc.appendChild(xmlRoot);
        return xmlDoc.toString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillLoyaltyTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the loyalty card of the transaction.
    /// </summary>
    /// <param name="transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// The loyalty card of the transaction.
    /// </returns>
    private static str fillLoyaltyTrans(RetailTransactionTable transactionTable)
    {
        RetailTransactionLoyaltyRewardPointTrans transactionLoyaltyTrans;
        if (transactionTable.loyaltyCardId)
        {
            return transactionTable.loyaltyCardId;
        }
        else
        {
            select firstonly CardNumber from transactionLoyaltyTrans
                where transactionLoyaltyTrans.TransactionId == transactionTable.TransactionId
                   && transactionLoyaltyTrans.StoreId       == transactionTable.Store
                   && transactionLoyaltyTrans.TerminalId    == transactionTable.Terminal
                   && transactionLoyaltyTrans.EntryType != RetailLoyaltyRewardPointEntryType::Redeem
                   && transactionLoyaltyTrans.EntryType != RetailLoyaltyRewardPointEntryType::Refund;

            return transactionLoyaltyTrans.CardNumber;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRetailChargeTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>ChargeLine</c> having the data of the <c>RetailTransactionMarkupTrans</c> table.
    /// </summary>
    /// <param name="_chargeTrans">
    /// Table buffer of <c>RetailTransactionMarkupTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionMarkupTrans</c> table.
    /// * Members must be in order of the ChargeLine DataContract
    /// Example:
    ///    <ChargeLine>
    ///      <ItemTaxGroupId />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <TaxLines />
    ///      <CalculatedAmount />
    ///      <ChargeCode />
    ///      <CurrencyCode />
    ///      <Description />
    ///      <IsShipping />
    ///      <ModuleTypeValue />
    ///      <Value />
    ///    </ChargeLine>
    /// </returns>
    private static XmlElement fillRetailChargeTrans(RetailTransactionMarkupTrans _chargeTrans, XmlDocument xmlDoc)
    {
        XmlElement xmlRecord, xmlEntry, xmlTaxLine, xmlTax;
        xmlRecord = xmlDoc.createElement('ChargeLine');

        xmlEntry = xmlDoc.createElement('ItemTaxGroupId');
        xmlEntry.innerText(_chargeTrans.TaxItemGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SalesTaxGroupId');
        xmlEntry.innerText(_chargeTrans.TaxGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxAmountNode);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_chargeTrans.TaxAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlTax = xmlDoc.createElement('TaxLines');
        RetailTransactionChargeTaxTrans retailChargeTaxTrans;
        while select retailChargeTaxTrans
        where retailChargeTaxTrans.TransactionId == _chargeTrans.TransactionId
            && retailChargeTaxTrans.SaleLineNum == _chargeTrans.SaleLineNum
            && retailChargeTaxTrans.MarkupLineNum == _chargeTrans.MarkupLineNum
        {
            xmlEntry = RetailTransactionServiceTransactions::fillRetailChargeLineTaxTrans(retailChargeTaxTrans, xmlDoc);
            xmlTax.appendChild(xmlEntry);
        }
        xmlRecord.appendChild(xmlTax);

        xmlEntry = xmlDoc.createElement('CalculatedAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_chargeTrans.CalculatedAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ChargeCode');
        xmlEntry.innerText(_chargeTrans.MarkupCode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('CurrencyCode');
        xmlEntry.innerText(_chargeTrans.CurrencyCode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Description');
        xmlEntry.innerText(_chargeTrans.Description);
        xmlRecord.appendChild(xmlEntry);

        MarkupTable markup = MarkupTable::find(_chargeTrans.ModuleType, _chargeTrans.MarkupCode);

        if (markup)
        {
            RetailParameters retailparameters = RetailParameters::find();
            xmlEntry = xmlDoc.createElement('IsShipping');
            if(retailparameters.UseAdvancedAutoCharges)
            {
                xmlEntry.innerText(int2str(enum2int(markup.IsShipping)));
            }
            else
            {
                xmlEntry.innerText(int2str(retailparameters.ShippingChargeCode == markup.MarkupCode));
            }
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = xmlDoc.createElement('ModuleTypeValue');
        xmlEntry.innerText(int2Str(enum2int(_chargeTrans.ModuleType)));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Value');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_chargeTrans.Value));
        xmlRecord.appendChild(xmlEntry);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRetailTransactionMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>ChargeLine</c> having the data of the <c>RetailTransactionMarkupTrans</c> table.
    /// </summary>
    /// <param name="_retailTransactionMarkupTrans">
    /// Table buffer of <c>RetailTransactionMarkupTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionMarkupTrans</c> table.
    /// * Members must be in order of the ChargeLine DataContract
    /// Example:
    ///    <ChargeLine>
    ///      <ItemTaxGroupId />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <TaxLines />
    ///      <CalculatedAmount />
    ///      <ChargeCode />
    ///      <ChargeMethodValue />
    ///      <ChargeTypeValue />
    ///      <CurrencyCode />
    ///      <Description />
    ///      <IsShipping />
    ///      <ModuleTypeValue />
    ///      <Value />
    ///    </ChargeLine>
    /// </returns>
    private static XmlElement fillRetailTransactionMarkupTrans(RetailTransactionMarkupTrans _retailTransactionMarkupTrans, XmlDocument xmlDoc)
    {
        // TaxableItem fields sorted alphabetically
        XmlElement xmlRecord, xmlEntry, xmlTaxLine, xmlTax;
        xmlRecord = xmlDoc.createElement('ChargeLine');

        xmlEntry = xmlDoc.createElement('ItemTaxGroupId');
        xmlEntry.innerText(_retailTransactionMarkupTrans.TaxItemGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SalesTaxGroupId');
        xmlEntry.innerText(_retailTransactionMarkupTrans.TaxGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxAmountNode);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailTransactionMarkupTrans.TaxAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxExemptPriceInclusiveOriginalPrice);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailTransactionMarkupTrans.TaxExemptPriceInclusiveOriginalPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxExemptPriceInclusiveReductionAmount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailTransactionMarkupTrans.TaxExemptPriceInclusiveReductionAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlTax = xmlDoc.createElement('TaxLines');
        xmlTaxLine = xmlDoc.createElement('TaxLine');
        xmlEntry = xmlDoc.createElement('Amount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailTransactionMarkupTrans.TaxAmount));
        xmlTaxLine.appendChild(xmlEntry);
        xmlTax.appendChild(xmlTaxLine);
        xmlRecord.appendChild(xmlTax);

        // ChargeLine properties sorted by alphabetical order.
        xmlEntry = xmlDoc.createElement('CalculatedAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailTransactionMarkupTrans.CalculatedAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ChargeCode');
        xmlEntry.innerText(_retailTransactionMarkupTrans.MarkupCode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ChargeMethodValue');
        xmlEntry.innerText(int2Str(enum2int(_retailTransactionMarkupTrans.Method)));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ChargeTypeValue');
        xmlEntry.innerText('0'); // ChargeType.ManualCharge in CRT.
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('CurrencyCode');
        xmlEntry.innerText(_retailTransactionMarkupTrans.CurrencyCode);
        xmlRecord.appendChild(xmlEntry);

        MarkupTable markup = MarkupTable::find(_retailTransactionMarkupTrans.ModuleType, _retailTransactionMarkupTrans.MarkupCode);

        if (markup)
        {
            xmlEntry = xmlDoc.createElement('Description');
            xmlEntry.innerText(markup.Txt);
            xmlRecord.appendChild(xmlEntry);

            RetailParameters retailparameters = RetailParameters::find();
            xmlEntry = xmlDoc.createElement('IsShipping');
            if(retailparameters.UseAdvancedAutoCharges)
            {
                xmlEntry.innerText(int2str(enum2int(markup.IsShipping)));
            }
            else
            {
                xmlEntry.innerText(int2str(retailparameters.ShippingChargeCode == markup.MarkupCode));
            }
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = xmlDoc.createElement('ModuleTypeValue');
        xmlEntry.innerText(int2Str(enum2int(_retailTransactionMarkupTrans.ModuleType)));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Value');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailTransactionMarkupTrans.Value));
        xmlRecord.appendChild(xmlEntry);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPaymentTransDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// </summary>
    /// <param name="_paymentTrans">
    /// Table buffer of <c>RetailTransactionPaymentTrans</c> table.
    /// </param>
    /// <param name="_channel">
    /// Table buffer of <c>RetailChannelTable</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionSalesTrans</c> table.
    /// * Members must be in order of the SalesLine DataContract
    /// Example:
    ///    <TenderLine>
    ///     <Amount/>
    ///     <AmountInCompanyCurrency/>
    ///     <AmountInTenderedCurrency/>
    ///     <AuthorizedAmount/>
    ///     <CardTypeId/>
    ///     <CompanyCurrencyExchangeRate/>
    ///     <CreditMemoId/>
    ///     <Currency/>
    ///     <CustomerId/>
    ///     <ExchangeRate/>
    ///     <GiftCardId/>
    ///     <IsChangeLine/>
    ///     <IsHistorical/>
    ///     <IsVoidable/>
    ///     <LineNumber/>
    ///     <LoyaltyCardId/>
    ///     <TenderTypeId/>
    ///     <Authorization/>
    ///     <IsLinkedRefund/>
    ///     <LinkedPaymentCurrency/>
    ///     <LinkedPaymentLineNumber/>
    ///     <LinkedPaymentStore/>
    ///     <LinkedPaymentTerminalId/>
    ///     <LinkedPaymentTransactionId/>
    ///     <MaskedCardNumber/>
    ///     <PaymentCaptureToken/>
    ///     <RefundableAmount/>
    ///     <TenderDate/>
    ///     <TransactionStatusValue/>
    ///    </TenderLine>
    /// </returns>
    [Wrappable(true)]
    protected final static XmlElement fillPaymentTransDetails(
        RetailTransactionPaymentTrans _paymentTrans,
        RetailChannelTable _channel,
        XmlDocument xmlDoc)
    {
        XmlElement xmlEntry,xmlRecord;

        void addElement( str name, str text)

        {
            xmlEntry = xmlDoc.createElement(name);
            xmlEntry.innerText(text);
            xmlRecord.appendChild(xmlEntry);
        }

        xmlRecord = xmlDoc.createElement('TenderLine');

        // DataContractSerializer requires fields to be ordered (base types first, alphabetic)
        // See https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/data-member-order

        // XML tags for TenderLineBase (base class)
        
        addElement('Amount', RetailTransactionServiceUtilities::realToString(_paymentTrans.amountTendered));   //decimal Amount
        addElement('AmountInCompanyCurrency', RetailTransactionServiceUtilities::realToString(_paymentTrans.amountMST));   //decimal AmountInCompanyCurrency
        addElement('AmountInTenderedCurrency', RetailTransactionServiceUtilities::realToString(_paymentTrans.amountTendered));   //decimal AmountInTenderedCurrency
        addElement('AuthorizedAmount', RetailTransactionServiceUtilities::realToString(_paymentTrans.AuthorizedAmount));    // decimal AuthorizedAmount
        addElement('CardTypeId', _paymentTrans.cardTypeId);   //string CardTypeId
        //addElement('CashBackAmount', '');   //decimal CashBackAmount
        addElement('CompanyCurrencyExchangeRate', RetailTransactionServiceUtilities::realToString(_paymentTrans.exchRateMST));   //decimal CompanyCurrencyExchangeRate
        addElement('CreditMemoId', _paymentTrans.creditVoucherId);   //string CreditMemoId
        addElement('Currency', _paymentTrans.currency);   //string Currency
        addElement('CustomerId', _paymentTrans.cardOrAccount);   //string CustomerId
        addElement('ExchangeRate', RetailTransactionServiceUtilities::realToString(_paymentTrans.exchRate));   //decimal ExchangeRate
        addElement('GiftCardId', _paymentTrans.giftCardId);   //string GiftCardId
        addElement('IsChangeLine', (_paymentTrans.changeLine ? #TrueStr : #FalseStr));   //bool IsChangeLine
        addElement('IsHistorical', #TrueStr);   //bool IsHistorical
        addElement('IsVoidable', #FalseStr);   //bool IsVoidable
        addElement('LineNumber', RetailTransactionServiceUtilities::lineNumToString(_paymentTrans.lineNum));   //decimal LineNumber
        addElement('LoyaltyCardId', _paymentTrans.loyaltyCardId);   //string LoyaltyCardId
        addElement('StatusValue', int2str(_paymentTrans.getRetailTenderLineStatus()));   //int StatusValue (int value from enum TenderLineStatus)
        addElement('TenderTypeId', _paymentTrans.tenderType);   //string TenderTypeId

        // XML tags for TenderLine (extends TenderLineBase class)

        addElement('Authorization', _paymentTrans.paymentAuthorization);   //string Authorization (not sure if we need this)
        //addElement('IncomeExpenseAccountTypeValue', '');   //int IncomeExpenseAccountTypeValue (int value from enum IncomeExpenseAccountType)
        //addElement('IsPreProcessed', '');   //bool IsPreProcessed
        addElement('CaptureToken', _paymentTrans.PaymentCaptureToken);

        addElement('IsLinkedRefund', (_paymentTrans.IsLinkedRefund ? #TrueStr : #FalseStr));
        addElement('LinkedPaymentCurrency', _paymentTrans.LinkedPaymentCurrency);
        addElement('LinkedPaymentLineNumber',RetailTransactionServiceUtilities::lineNumToString(_paymentTrans.LinkedPaymentLineNumber));
        addElement('LinkedPaymentStore', _paymentTrans.LinkedPaymentStore);
        addElement('LinkedPaymentTerminalId', _paymentTrans.LinkedPaymentTerminalId);
        addElement('LinkedPaymentTransactionId', _paymentTrans.LinkedPaymentTransactionId);
        addElement('MaskedCardNumber', strRep('*', MaskedCardLength) + _paymentTrans.cardOrAccount);   //string MaskedCardNumber
        addElement('RefundableAmount', RetailTransactionServiceUtilities::realToString(RetailTransactionServiceTransactions::calculateRefundableAmount(_paymentTrans)));
        addElement('StoreId', _paymentTrans.store);
        addElement('TerminalId', _paymentTrans.terminal);
        addElement('TransactionId', _paymentTrans.transactionId);

        xmlEntry = xmlDoc.createElement('TenderDate');
        xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
        xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(
                    DateTimeUtil::newDateTime(_paymentTrans.transDate, _paymentTrans.transTime, _channel.ChannelTimeZone)));   //DateTimeOffset? TenderDate
        xmlRecord.appendChild(xmlEntry);

        addElement('TransactionStatusValue', int2str(_paymentTrans.transactionStatus));   //int TransactionStatusValue (int value from enum TransactionStatus)

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateRefundableAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates Refundable Amount for a transaction based on paymentTrans and paymentRefundableAmounts whichever is minimum.
    /// </summary>
    /// <param name = "paymentTrans">Retail transaction payments record.</param>
    /// <returns></returns>
    internal static AmountCur calculateRefundableAmount(RetailTransactionPaymentTrans paymentTrans)
    {
        if (paymentTrans.RecId == 0)
        {
            return 0.00;
        }

        RetailTransactionPaymentRefundableAmounts retailTransactionPaymentRefundableAmounts;
        AmountCur minRefundableAmount = paymentTrans.refundableAmount;

        retailTransactionPaymentRefundableAmounts = RetailTransactionPaymentRefundableAmounts::find(paymentTrans.transactionId,
                                                                                                    paymentTrans.store,
                                                                                                    paymentTrans.terminal,
                                                                                                    paymentTrans.lineNum);

        if(retailTransactionPaymentRefundableAmounts.RecId != 0 && minRefundableAmount > retailTransactionPaymentRefundableAmounts.RefundableAmount)
        {
            minRefundableAmount = retailTransactionPaymentRefundableAmounts.RefundableAmount;
        }

        return minRefundableAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPaymentHistoryDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of Sales Order payment activity/history in the form of the <c>RetailTransactionPaymentTrans</c> table schema.
    /// </summary>
    /// <param name = "_salesId">The ID of the sales order.</param>
    /// <param name = "_root">The <c>XmlElement</c> that is the root for individual payment history records.</param>
    /// <param name = "_xmlDoc">The parent <c>XmlDocument</c>. </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionPaymentTrans</c> table as populated by <c>LedgerJournalTrans</c> and <c>CustTrans</c> records for the given Sales Order.
    /// * Members must be in order of the TenderLine DataContract
    /// Example:
    /// <![CDATA[
    ///   <_root>
    ///    <TenderLine>
    ///     <Amount/>
    ///     <AmountInCompanyCurrency/>
    ///     <AmountInTenderedCurrency/>
    ///     <CardTypeId/>
    ///     <CompanyCurrencyExchangeRate/>
    ///     <CreditMemoId/>
    ///     <Currency/>
    ///     <CustomerId/>
    ///     <ExchangeRate/>
    ///     <GiftCardId/>
    ///     <IsChangeLine/>
    ///     <IsHistorical/>
    ///     <IsVoidable/>
    ///     <LineNumber/>
    ///     <LoyaltyCardId/>
    ///     <TenderTypeId/>
    ///     <Authorization/>
    ///     <IsPreProcessed/>
    ///     <MaskedCardNumber/>
    ///     <TenderDate/>
    ///     <TransactionStatusValue/>
    ///    </TenderLine>
    ///  </_root>
    ///  ]]]]><![CDATA[>
    /// </returns>
    private static XmlElement fillPaymentHistoryDetails(
        SalesId _salesId,
        XmlElement _root,
        XmlDocument _xmlDoc)
    {
        RetailTransactionPaymentTrans tmpPaymentTrans;
        RetailChannelTable channelTable;
        RetailTransactionTable transactionTable;
        MCRCustPaymTable mcrCustPaymTable;

        // refactor from CustomerOrder code
        LedgerJournalTrans  ledgerJournalTrans;
        AmountCur amount;

        // <GEERU>
        boolean countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        // </GEERU>

        //
        // This method is patterned after RetailTransactionServiceOrders::AddPaymentHistoryXml(...), which aggregates similar payment details for a given Sales Order.
        //

        //
        // 1. Get ONLY Payments created from POS.
        //
        boolean paymentDetailsProvided;
        if (RetailTransactionServiceTransactions::isAllPaymentsMadeFromPOS(_salesId))
        {
            while select tmpPaymentTrans
                exists join transactionTable
                where transactionTable.salesOrderId == _salesId
                    && tmpPaymentTrans.Channel == transactionTable.Channel
                    && tmpPaymentTrans.store == transactionTable.store
                    && tmpPaymentTrans.terminal == transactionTable.terminal
                    && tmpPaymentTrans.transactionId == transactionTable.transactionId
            {
                paymentDetailsProvided = true;
                _root.appendChild(RetailTransactionServiceTransactions::fillPaymentTransDetails(tmpPaymentTrans, channelTable, _xmlDoc));
            }
        }

        // For Cash & Carry orders, the payment transactions exists only in RetailTarnsactionPaymentTrans table, and 1st query will be used for such orders.
        // For customer orders, the payment transactions exists in both RetailTransactionPaymentTrans table and McrCustPaymTable. 
        // Specifically, for customer orders,
        // - The deposit paid at POS exists in both tables.
        // - But the remaining balance paid in HQ only exists in McrCustPaymTable.
        if(!paymentDetailsProvided)
        {
            while select
                PaymReference,
                PaymMode,
                AmountCurCredit,
                AmountCurDebit,
                Prepayment,
                CreatedDateTime,
                CurrencyCode,
                TransDate,
                MCRRefPaymID
                // <GEERU>
                ,Accounttype
                // </GEERU>
                from ledgerJournalTrans
            where LedgerJournalTrans.MCRPaymOrderID == _salesId
                && LedgerJournalTrans.TransactionType == LedgerTransType::Payment
            {
                // <GEERU>
                if (countryRegion_W && ledgerJournalTrans.AccountType != LedgerJournalAcType::Cust)
                {
                    amount = (ledgerJournalTrans.AmountCurDebit - ledgerJournalTrans.AmountCurCredit);
                }
                else
                {
                    // </GEERU>
                    amount = (ledgerJournalTrans.AmountCurCredit - ledgerJournalTrans.AmountCurDebit);
                    // <GEERU>
                }
                // </GEERU>

            MCRCustPaymTable mcrCustPaymDetails = MCRCustPaymTable::findByRecID(ledgerJournalTrans.MCRRefPaymID);

                tmpPaymentTrans = RetailTransactionServiceTransactions::AddHistoryEntry(
                    ledgerJournalTrans.PaymMode,
                    amount,
                    ledgerJournalTrans.CurrencyCode,
                    ledgerJournalTrans.TransDate,
                    mcrCustPaymDetails.TenderTypeId,
                    mcrCustPaymDetails.CardTypeId,
                    mcrCustPaymDetails.PaymInfoRecId);

                _root.appendChild(RetailTransactionServiceTransactions::fillPaymentTransDetails(tmpPaymentTrans, channelTable, _xmlDoc));
            }
        }
        // returning <_root> <TenderLine/> <TenderLine/> ... </_root>
        return _root;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillPurchaseHistory</Name>
				<Source><![CDATA[
    private static XmlElement fillPurchaseHistory(XmlDocument xmlDoc, Set purchaseHistoryResults)
    {
        XmlElement xmlRoot, xmlPurchaseHistory, xmlField;

        // Prepare the result xml document

        xmlRoot = xmlDoc.createElement('ArrayOfPurchaseHistory');
        xmlRoot.setAttribute('xmlns', 'http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Commerce.Runtime.DataModel');

        SetEnumerator enumerator = purchaseHistoryResults.getEnumerator();
        while (enumerator.moveNext())
        {
            PurchaseHistory purchaseHistory = enumerator.current();
            xmlPurchaseHistory = xmlDoc.createElement("PurchaseHistory");

            xmlField = xmlDoc.createElement('DatePurchased');
            xmlField.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlField.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(purchaseHistory.datePurchased));   //DateTimeOffset? TenderDate
            xmlPurchaseHistory.appendChild(xmlField);

            xmlField = xmlDoc.createElement('ImageUrl');
            xmlField.innerText(purchaseHistory.ImageUrl);
            xmlPurchaseHistory.appendChild(xmlField);

            xmlField = xmlDoc.createElement('ItemId');
            xmlField.innerText(purchaseHistory.itemId);
            xmlPurchaseHistory.appendChild(xmlField);

            xmlField = xmlDoc.createElement('ProductId');
            xmlField.innerText(int642str(purchaseHistory.productId));
            xmlPurchaseHistory.appendChild(xmlField);

            xmlField = xmlDoc.createElement('ProductName');
            xmlField.innerText(purchaseHistory.productName);
            xmlPurchaseHistory.appendChild(xmlField);

            xmlField = xmlDoc.createElement('ReceiptId');
            xmlField.innerText(purchaseHistory.receiptId);
            xmlPurchaseHistory.appendChild(xmlField);

            xmlField = xmlDoc.createElement('SalesId');
            xmlField.innerText(purchaseHistory.salesId);
            xmlPurchaseHistory.appendChild(xmlField);

            xmlRoot.appendChild(xmlPurchaseHistory);
        }

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillQuoteDetails</Name>
				<Source><![CDATA[
    public static XmlElement fillQuoteDetails(
        SalesQuotationTable _salesQuotationTable,
        RetailSalesQuotationTable _rsqTable,
        CustTable _custTable,
        boolean _includeDetails,
        XmlDocument xmlDoc,
        str _elementName = #ElementSalesOrder)
    {
        XmlElement              xmlRoot, xmlRecord, xmlContainer;
        SalesQuotationTotals    salesTotals;
        AmountCur               totalAmount, totalTaxAmount, totalDiscountAmount, totalChargeAmount;
        LogisticsPostalAddress  deliveryAddress;
        SalesQuotationLine      salesQuotationLine;
        RetailSalesQuotationLine rsqLine;

        InventDim               inventDim;

        salesTotals     = SalesQuotationTotals::construct(_salesQuotationTable,SalesUpdate::All);
        salesTotals.calc();
        // totalAmount is the sales order balance due amount + previously invoiced amounts
        totalAmount     = salesTotals.totalAmount();
        totalTaxAmount  = salesTotals.totalTaxAmount();
        totalDiscountAmount = salesTotals.totalLineDisc();
        totalChargeAmount = salesTotals.totalMarkup();

        xmlRoot = xmlDoc.createElement(_elementName);

        RetailFillQuoteDetailsParameters headerParameters = RetailFillQuoteDetailsParameters::construct();
        headerParameters.xmlDoc = xmlDoc;
        headerParameters.xmlRoot = xmlRoot;
        headerParameters.quoteTable = _salesQuotationTable;
        headerParameters.retailSalesQuoteTable = _rsqTable;
        headerParameters.custTable = _custTable;
        headerParameters.includeDetails = _includeDetails;

        RetailCustomerOrderExtensions::fillQuoteDetailsPrePopulate(headerParameters);

        xmlRecord = xmlDoc.createElement('ChannelReferenceId');
        xmlRecord.innerText(_rsqTable.ChannelReferenceId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ChargeAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalChargeAmount));
        xmlRoot.appendChild(xmlRecord);

        if (_salesQuotationTable.createdDateTime)
        {
            xmlRecord = xmlDoc.createElement('CreatedDateTime');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(_salesQuotationTable.CreatedDateTime));
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('CustomerId');
        xmlRecord.innerText(_salesQuotationTable.CustAccount);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerOrderTypeValue');
        xmlRecord.innerText(int2str(RetailCustomerOrderType::Quotation));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerRequisition');
        xmlRecord.innerText(_salesQuotationTable.CustPurchaseOrder);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('DeliveryMode');
        xmlRecord.innerText(_salesQuotationTable.DlvMode);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Id');
        xmlRecord.innerText(_salesQuotationTable.QuotationId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('InventoryLocationId');
        xmlRecord.innerText(_salesQuotationTable.InventLocationId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Name');
        if (_custTable.name() != '')
        {
            xmlRecord.innerText(_custTable.name());
        }
        else
        {
            xmlRecord.innerText(_salesQuotationTable.QuotationName);
        }
        xmlRoot.appendChild(xmlRecord);

        if (_includeDetails)
        {
            xmlRoot.appendChild(RetailTransactionServiceTransactions::addNotes(xmlDoc, _salesQuotationTable.RecId, _salesQuotationTable.TableId, _salesQuotationTable.DataAreaId));
        }

        if (RetailTransactionQuotationExpiryDateFlight::instance().isEnabled() && _salesQuotationTable.QuotationExpiryDate)
        {
            xmlRecord = xmlDoc.createElement('QuotationExpiryDate');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_salesQuotationTable.QuotationExpiryDate, _rsqTable.RetailChannel));
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('ReceiptEmail');
        xmlRecord.innerText(_salesQuotationTable.Email);
        xmlRoot.appendChild(xmlRecord);

        if (_salesQuotationTable.ReceiptDateRequested)
        {
            xmlRecord = xmlDoc.createElement('RequestedDeliveryDate');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_salesQuotationTable.ReceiptDateRequested, _rsqTable.RetailChannel));
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('SalesId');
        xmlRecord.innerText(_salesQuotationTable.QuotationId);
        xmlRoot.appendChild(xmlRecord);

        xmlContainer = xmlDoc.createElement('SalesLines');

        if (_includeDetails)
        {
            while select * from salesQuotationLine
                join inventDim where salesQuotationLine.QuotationId == _salesQuotationTable.QuotationId
                    && inventDim.InventDimId == salesQuotationLine.InventDimId
                outer join rsqLine where rsqLine.RecId == salesQuotationLine.RecId
            {
                xmlRecord = RetailTransactionServiceTransactions::fillQuoteLineDetails(salesQuotationLine, rsqLine, inventDim, _custTable, xmlDoc);
                xmlContainer.appendChild(xmlRecord);
            }
        }

        xmlRoot.appendChild(xmlContainer);

        if (_includeDetails)
        {
            deliveryAddress = LogisticsPostalAddress::findRecId(_salesQuotationTable.DeliveryPostalAddress);
            if (deliveryAddress)
            {
                xmlRecord = RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, _salesQuotationTable.DeliveryName, _custTable.Party, xmlDoc);
                xmlRoot.appendChild(xmlRecord);
            }
        }

        xmlRecord = xmlDoc.createElement(TaxAmountNode);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalTaxAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TotalAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TotalDiscount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalDiscountAmount));
        xmlRoot.appendChild(xmlRecord);

        // Assume it is a customer order
        xmlRecord = xmlDoc.createElement('TransactionType');
        xmlRecord.innerText(enum2str(RetailTransactionType::CustomerOrder));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TransactionTypeValue');
        xmlRecord.innerText(int2str(enum2int(RetailTransactionType::CustomerOrder)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CommissionSalesGroup');
        xmlRecord.innerText(_salesQuotationTable.SalesGroup);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('RecordId');
        xmlRecord.innerText(int642str(_salesQuotationTable.RecId));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Status');
        xmlRecord.innerText('Created');
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('StatusValue');
        xmlRecord.innerText('1');
        xmlRoot.appendChild(xmlRecord);

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillQuoteLineDetails</Name>
				<Source><![CDATA[
    private static XmlElement fillQuoteLineDetails(salesQuotationLine _qLine, RetailSalesQuotationLine _rsqLine, InventDim _inventDim, CustTable _custTable, XmlDocument xmlDoc)
    {
        LogisticsPostalAddress  deliveryAddress;

        InventTable                 inventTable;
        InventDimCombination        inventDimCombination;
        RecId                       productId;
        InventDimParm               inventDimParm;
        InventDimId                 inventDimId;
        EcoResProduct               ecoResProduct;
        str                         listingId;

        XmlElement xmlRecord, xmlEntry, xmlAddress, xmlTax, xmlTaxLine;

        xmlRecord = xmlDoc.createElement('SalesLine');

        RetailFillQuoteLineDetailsParameters lineParameters = RetailFillQuoteLineDetailsParameters::construct();
        lineParameters.xmlDoc = xmlDoc;
        lineParameters.xmlRecord = xmlRecord;
        lineParameters.salesQuotationLine = _qLine;
        lineParameters.retailSalesQuotationLine = _rsqLine;
        lineParameters.inventDim = _inventDim;

        RetailCustomerOrderExtensions::fillQuoteLineDetailsPrePopulate(lineParameters);

        xmlEntry = xmlDoc.createElement('ItemId');
        xmlEntry.innerText(_qLine.ItemId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ItemTaxGroupId');
        xmlEntry.innerText(_qLine.TaxItemGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('NetAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_qLine.LineAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Price');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_qLine.SalesPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Quantity');
        xmlEntry.innerText(num2str(_qLine.SalesQty, 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SalesTaxGroupId');
        xmlEntry.innerText(_qLine.TaxGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlTax = xmlDoc.createElement('TaxLines');
        xmlTaxLine = xmlDoc.createElement('TaxLine');
        xmlEntry = xmlDoc.createElement('Amount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_qLine.LineAmount - _qLine.lineAmountExclTax()));
        xmlTaxLine.appendChild(xmlEntry);
        xmlTax.appendChild(xmlTaxLine);
        xmlRecord.appendChild(xmlTax);

        RetailTransactionServiceTransactions::addChargeLines(_qLine.TableId, _qLine.RecId, xmlDoc, xmlRecord);

        xmlEntry = xmlDoc.createElement('DeliveryMode');
        xmlEntry.innerText(_qLine.DlvMode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('InventoryDimensionId');
        xmlEntry.innerText(_qLine.InventDimId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('InventoryLocationId');
        xmlEntry.innerText(_inventDim.InventLocationId);
        xmlRecord.appendChild(xmlEntry);

        // Add IsWarrantyLine to QuotationLine when needed.
        RetailTransactionServiceWarranty::appendIsWarrantyLineFlagToSalesLine(xmlDoc, xmlRecord, _qLine);

        xmlEntry = xmlDoc.createElement('LineDiscount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_qLine.LineDisc));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('LineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_qLine.LineNum));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('CommissionSalesGroup');
        xmlEntry.innerText(_qLine.SalesGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ListingId');
        if (_rsqLine && _rsqLine.ListingId)
        {
            xmlEntry.innerText(_rsqLine.ListingId);
        }
        else
        {
            productId = (select firstOnly Product
                    from inventTable
                        where inventTable.ItemId == _qLine.ItemId).Product;

            ecoResProduct = EcoResProduct::find(productId);

            if (ecoResProduct != null &&
                    !ecoResProduct.isDistinctProduct())
            {
                inventDimParm.setAllProductDimensions();
                _inventDim.clearNotSelectedDim(inventDimParm);
                inventDimId = InventDim::findOrCreate(_inventDim).inventDimId;

                productId = (select firstOnly DistinctProductVariant
                        from inventDimCombination
                                where inventDimCombination.ItemId == _qLine.ItemId
                                    && inventDimCombination.InventDimId == inventDimId).DistinctProductVariant;
            }

            xmlEntry.innerText(int642str(productId));
        }
        listingId = xmlEntry.innerText();
        xmlRecord.appendChild(xmlEntry);

        //ProductId is a copy of ListingId
        xmlEntry = xmlDoc.createElement('ProductId');
        xmlEntry.innerText(listingId);
        xmlRecord.appendChild(xmlEntry);

        deliveryAddress = LogisticsPostalAddress::findRecId(_qLine.DeliveryPostalAddress);
        if (deliveryAddress)
        {
            xmlAddress = RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, _qLine.DeliveryName, _custTable.Party, xmlDoc);
            xmlRecord.appendChild(xmlAddress);
        }

        xmlEntry = xmlDoc.createElement('UnitOfMeasureSymbol');
        xmlEntry.innerText(_qLine.SalesUnit);
        xmlRecord.appendChild(xmlEntry);

        // Add WarrantyInfo to QuotationLine.
        RetailTransactionServiceWarranty::appendWarrantiedRelationToSalesLine(xmlDoc, xmlRecord, _qLine);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addChargeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends <c>ChargeLine</c> information to the <paramref name="xmlContainer"/>< with data from <c>MarkupTrans</c> table.
    /// </summary>
    /// <param name="_tableId">
    /// Table id to filter by TransTableId or MCRSavedTableID columns.
    /// </param>
    /// <param name="_recId">
    /// Record id to filter by TransRecId or MCRSavedRecID columns.
    /// </param>
    /// <param name="xmlDoc">
    /// The XML document.
    /// </param>
    /// <param name="xmlRecord">
    /// The XML record to append to.
    /// </param>
    private static void addChargeLines(int _tableId, int64 _recId, XmlDocument xmlDoc, XmlElement xmlContainer)
    {
        MarkupTrans markupTrans = RetailTransactionServiceTransactions::getChargesFromMarkupTrans(_tableId, _recId);
        RetailTransactionServiceTransactions::fillChargeLines(markupTrans, xmlDoc, xmlContainer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getChargesFromMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves <c>ChargeLine</c> data from the <c>MarkupTrans</c> table.
    /// </summary>
    /// <param name = "_tableId">
    /// Table id to filter by TransTableId or MCRSavedTableID columns.
    /// </param>
    /// <param name = "_recId">
    /// Record id to filter by TransRecId or MCRSavedRecID columns.
    /// </param>
    /// <returns></returns>
    private static MarkupTrans getChargesFromMarkupTrans(int _tableId, int64 _recId)
    {
        MarkupTrans markupTrans;

        select CalculatedAmount, CurrencyCode, IsAutoCharge, MarkupCategory, MarkupCode, ModuleType, TaxAmount, TaxGroup, TaxItemGroup, Txt, Value
            from markupTrans
            where (markupTrans.TransTableId == _tableId && markupTrans.TransRecId == _recId)
            || (markupTrans.MCRSavedTableID == _tableId && markupTrans.MCRSavedRecID == _recId);

        return markupTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillChargeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method appends serialized xml strings of <c>ChargeLine</c> with data from <c>MarkupTrans</c> table to a parent container.
    /// Example:
    ///    <ChargeLine>
    ///      <ItemTaxGroupId />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <TaxLines />
    ///      <CalculatedAmount />
    ///      <ChargeCode />
    ///      <ChargeMethodValue />
    ///      <ChargeTypeValue />
    ///      <CurrencyCode />
    ///      <Description />
    ///      <IsShipping />
    ///      <ModuleTypeValue />
    ///      <Value />
    ///    </ChargeLine>
    /// </summary>
    /// <param name="_markupTrans">
    /// Table buffer of <c>MarkupTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    private static void fillChargeLines(MarkupTrans _markupTrans, XmlDocument xmlDoc, XmlElement xmlContainer)
    {
        while(_markupTrans)
        {
            XmlElement xmlRecord, xmlEntry, xmlTaxLine, xmlTax;
            xmlRecord = xmlDoc.createElement('ChargeLine');

            xmlEntry = xmlDoc.createElement('ItemTaxGroupId');
            xmlEntry.innerText(_markupTrans.TaxItemGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('SalesTaxGroupId');
            xmlEntry.innerText(_markupTrans.TaxGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(TaxAmountNode);
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_markupTrans.TaxAmount));
            xmlRecord.appendChild(xmlEntry);

            xmlTax = xmlDoc.createElement('TaxLines');
            xmlTaxLine = xmlDoc.createElement('TaxLine');
            xmlEntry = xmlDoc.createElement('Amount');
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_markupTrans.TaxAmount));
            xmlTaxLine.appendChild(xmlEntry);
            xmlTax.appendChild(xmlTaxLine);
            xmlRecord.appendChild(xmlTax);

            // Keep aligned with the meaning of RetailTransactionMarkupTrans.CalculatedAmount
            xmlEntry = xmlDoc.createElement('CalculatedAmount');
            real calculatedAmount = RetailChargeSetCalculatedAmountAsValueFlight::instance().isEnabled() ? _markupTrans.Value : _markupTrans.CalculatedAmount;
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(calculatedAmount));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ChargeCode');
            xmlEntry.innerText(_markupTrans.MarkupCode);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ChargeMethodValue');
            xmlEntry.innerText(int2Str(enum2int(_markupTrans.MarkupCategory)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ChargeTypeValue');
            if (_markupTrans.IsAutoCharge == NoYes::Yes)
            {
                xmlEntry.innerText('2'); // ChargeType.AutoCharge in CRT.
            }
            else
            {
                xmlEntry.innerText('0'); // ChargeType.ManualCharge in CRT.
            }

            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('CurrencyCode');
            xmlEntry.innerText(_markupTrans.CurrencyCode);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Description');
            xmlEntry.innerText(_markupTrans.Txt);
            xmlRecord.appendChild(xmlEntry);

            MarkupTable markup = MarkupTable::find(_markupTrans.ModuleType, _markupTrans.MarkupCode);

            if (markup)
            {
                RetailParameters retailparameters = RetailParameters::find();
                xmlEntry = xmlDoc.createElement('IsShipping');
                if(retailparameters.UseAdvancedAutoCharges)
                {
                    xmlEntry.innerText(int2str(enum2int(markup.IsShipping)));
                }
                else
                {
                    xmlEntry.innerText(int2str(retailparameters.ShippingChargeCode == markup.MarkupCode));
                }
                xmlRecord.appendChild(xmlEntry);
            }

            xmlEntry = xmlDoc.createElement('ModuleTypeValue');
            xmlEntry.innerText(int2Str(enum2int(_markupTrans.ModuleType)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Value');
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_markupTrans.Value));
            xmlRecord.appendChild(xmlEntry);

            xmlContainer.appendChild(xmlRecord);

            next _markupTrans;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRetailTransactionDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>RetailTransaction</c> having the data of the <c>RetailTransactionTable</c> table.
    /// </summary>
    /// <param name="transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="taxTable">
    /// Table buffer of <c>RetailTransactionTaxTrans</c> table.
    /// </param>
    /// <param name="chargeTable">
    /// Table buffer of <c>RetailTransactionMarkupTrans</c> table.
    /// </param>
    /// <param name="partyTable">
    /// Table buffer of <c>DirPartyTable</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_includePaymentDetails">
    /// Whether or not to include payment line details.
    /// </param>
    /// <param name="_includeAttributes">
    /// Whether or not to include attributes.
    /// </param>
    /// <param name="_elementName">
    /// Name of the element to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionTable</c> table.
    /// * Members must be in order of the SalesOrder DataContract
    /// Example:
    ///    <SalesOrder>
    ///      <AmountPaid />
    ///      <ChannelId />
    ///      <ChannelReferenceId />
    ///      <ChargeAmount />
    ///      <ChargeLines />
    ///      <CommissionSalesGroup />
    ///      <CreatedDateTime />
    ///      <CurrencyCode />
    ///      <CustomerAccountDepositLines />
    ///      <CustomerId />
    ///      <DiscountAmount />
    ///      <EntryStatusValue />
    ///      <FiscalTransactions />
    ///      <GrossAmount />
    ///      <HasLoyaltyPayment />
    ///      <Id />
    ///      <InvoiceComment />
    ///      <LoyaltyCardId />
    ///      <Name />
    ///      <NetAmountWithNoTax />
    ///      <PrepaymentAmountPaid />
    ///      <ReceiptEmail />
    ///      <ReceiptId />
    ///      <SalesId />
    ///      <SalesLines />
    ///      <ShiftId />
    ///      <StaffId />
    ///      <StoreId />
    ///      <SubtotalAmount />
    ///      <TaxAmount />
    ///      <TerminalId />
    ///      <TotalAmount />
    ///      <TotalDiscount />
    ///      <TransactionDate />
    ///      <TransactionTime />
    ///      <TransactionTypeValue />
    ///    </SalesOrder>
    /// </returns>
    [Wrappable(true)]
    protected final static XmlElement fillRetailTransactionDetails(
        RetailTransactionTable transactionTable,
        RetailTransactionTaxTrans taxTable,
        RetailTransactionMarkupTrans chargeTable,
        DirPartyTable partyTable,
        XmlDocument xmlDoc,
        boolean _includePaymentDetails,
        boolean _includeAttributes,
        str _elementName = #ElementSalesTransaction)
    {
        RetailTransactionPaymentTrans paymentTable;
        RetailChannelTable channelTable;
        RetailTransactionMarkupTrans headerChargeTable;
        RetailTransactionTenderDeclarationTrans tenderDeclare;
        RetailTransactionBankedTenderTrans tenderBank;
        RetailTransactionSafeTenderTrans tenderSafe;

        XmlElement                  xmlRoot, xmlRecord, xmlChargeLinesContainer, xmlFiscalTransContainer;
        AmountCur                   prepaymentAmountPaid, subtotalAmount, amountPaid, totalAmount, netAmountWithNoTax;
        boolean                     hasLoyaltyPayment;
        str                         utcTimeString;

        xmlRoot = xmlDoc.createElement(_elementName);

        // DataContractSerializer requires fields to be ordered (base types first, alphabetic)
        // See https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/data-member-order

        // Need to calculate amountPaid, totalAmount, netAmountWithNoTax and subtotalAmount differently for Payment TransactionType.

        if (transactionTable.Type == RetailTransactionType::Payment)
        {
            subtotalAmount = RetailTransactionServiceTransactions::getCustAccountDepositTransactionSubtotalAmount(
            transactionTable.DataAreaId,
            transactionTable.Channel,
            transactionTable.Store,
            transactionTable.Terminal,
            transactionTable.TransactionId);

            amountPaid = subtotalAmount;
            netAmountWithNoTax = subtotalAmount;

            select sum(amountTendered) from paymentTable
                where paymentTable.DataAreaId == transactionTable.DataAreaId
                    && paymentTable.Channel == transactionTable.Channel
                    && paymentTable.Store == transactionTable.Store
                    && paymentTable.Terminal == transactionTable.Terminal
                    && paymentTable.TransactionId == transactionTable.TransactionId
                    && ( paymentTable.TransactionStatus == RetailEntryStatus::None 
                        || paymentTable.TransactionStatus == RetailEntryStatus::Posted);

            totalAmount = paymentTable.amountTendered;
        }
        else if (transactionTable.Type == RetailTransactionType::TenderDeclaration)
        {
            subtotalAmount = 0;
            amountPaid = 0;
            netAmountWithNoTax = 0;

            select sum(amountTendered) from tenderDeclare
                where tenderDeclare.DataAreaId == transactionTable.DataAreaId
                && tenderDeclare.Channel == transactionTable.Channel
                && tenderDeclare.Store == transactionTable.Store
                && tenderDeclare.Terminal == transactionTable.Terminal
                && tenderDeclare.TransactionId == transactionTable.TransactionId
                && ( tenderDeclare.TransactionStatus == RetailEntryStatus::None
                    || tenderDeclare.TransactionStatus == RetailEntryStatus::Posted);

            totalAmount = tenderDeclare.amountTendered;
        }
        else if (transactionTable.Type == RetailTransactionType::BankDrop)
        {
            subtotalAmount = 0;
            amountPaid = 0;
            netAmountWithNoTax = 0;

            select sum(amountTendered) from tenderBank
                where tenderBank.DataAreaId == transactionTable.DataAreaId
                && tenderBank.Channel == transactionTable.Channel
                && tenderBank.Store == transactionTable.Store
                && tenderBank.Terminal == transactionTable.Terminal
                && tenderBank.TransactionId == transactionTable.TransactionId
                && ( tenderBank.TransactionStatus == RetailEntryStatus::None
                    || tenderBank.TransactionStatus == RetailEntryStatus::Posted);

            totalAmount = tenderBank.amountTendered;

        }
        else if (transactionTable.Type == RetailTransactionType::SafeDrop)
        {
            subtotalAmount = 0;
            amountPaid = 0;
            netAmountWithNoTax = 0;

            select sum(amountTendered) from tenderSafe
                where tenderSafe.DataAreaId == transactionTable.DataAreaId
                && tenderSafe.Channel == transactionTable.Channel
                && tenderSafe.Store == transactionTable.Store
                && tenderSafe.Terminal == transactionTable.Terminal
                && tenderSafe.TransactionId == transactionTable.TransactionId
                && ( tenderSafe.TransactionStatus == RetailEntryStatus::None
                    || tenderSafe.TransactionStatus == RetailEntryStatus::Posted);

            totalAmount = tenderSafe.amountTendered;
        }
        else
        {
            subtotalAmount = RetailTransactionServiceTransactions::getTransactionSubtotalAmount(
            transactionTable.TransactionId,
            transactionTable.DataAreaId,
            transactionTable.Channel,
            transactionTable.Terminal);

            subtotalAmount = subtotalAmount * -1;
            amountPaid = transactionTable.PaymentAmount;
            netAmountWithNoTax = transactionTable.netAmount * -1;
            totalAmount = transactionTable.GrossAmount * -1;
        }

        // XML tags for SalesTransaction (base class)

        xmlRecord = xmlDoc.createElement('AmountPaid');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(amountPaid));
        xmlRoot.appendChild(xmlRecord);

        if (_includeAttributes)
        {
            int headerLevel = 0;
            xmlRecord = RetailTransactionServiceTransactions::populateTransactionAttributes(
                xmlDoc, transactionTable.transactionId, transactionTable.terminal, transactionTable.store, transactionTable.Channel, headerLevel, transactionTable.DataAreaId);
            
            if (xmlRecord)
            {
                xmlRoot.appendChild(xmlRecord);
            }
        }

        xmlRecord = xmlDoc.createElement('ChannelId');
        xmlRecord.innerText(int642str(transactionTable.Channel));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ChannelReferenceId');
        xmlRecord.innerText(transactionTable.ChannelReferenceId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ChargeAmount');

        // Check if "Price includes tax" is on for the store. If yes, then we need to subtract a tax amount from the total charge amount.
        int isTaxIncludedInPrice = RetailTransactionTaxTrans::readPriceInclTaxConfiguration(transactionTable);

        if (isTaxIncludedInPrice)
        {
            RetailTransactionChargeTaxTrans chargeTaxTransTable;

            select sum(Amount) from chargeTaxTransTable
                where chargeTaxTransTable.TransactionId == transactionTable.TransactionId
                && chargeTaxTransTable.Channel == transactionTable.Channel
                && chargeTaxTransTable.StoreId == transactionTable.store
                && chargeTaxTransTable.TerminalId == transactionTable.terminal
                && chargeTaxTransTable.IsExempt == 0;

            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(chargeTable.CalculatedAmount - chargeTaxTransTable.Amount));
        }

        else
        {
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(chargeTable.CalculatedAmount));
        }

        xmlRoot.appendChild(xmlRecord);

        if (RetailParameters::isRetailAutoChargesEnabledAndInUse())
        {
            xmlChargeLinesContainer = xmlDoc.createElement('ChargeLines');

            // Select all charges matching the header of this transaction and aggregate them by business key.
            while select sum(Value), sum(CalculatedAmount), sum(TaxAmount), sum(TaxExemptPriceInclusiveOriginalPrice), sum(TaxExemptPriceInclusiveReductionAmount), MarkupCode, ModuleType, TaxGroup, TaxItemGroup, CurrencyCode, Description from headerChargeTable
            group by headerChargeTable.MarkupCode, headerChargeTable.ModuleType, headerChargeTable.TaxGroup, headerChargeTable.TaxItemGroup, headerChargeTable.CurrencyCode, headerChargeTable.Description
                where headerChargeTable.Channel == transactionTable.Channel
                && headerChargeTable.store == transactionTable.store
                && headerChargeTable.terminalId == transactionTable.terminal
                && headerChargeTable.transactionId == transactionTable.transactionId
                && headerChargeTable.saleLineNum == 0
            {
                headerChargeTable = RetailTransactionServiceTransactions::subtractPreviouslyReturnedChargeAmountFromHeaderCharge(headerChargeTable, transactionTable);

                if (headerChargeTable.CalculatedAmount > 0)
                {
                    xmlRecord = RetailTransactionServiceTransactions::fillRetailTransactionMarkupTrans(headerChargeTable, xmlDoc);
                    xmlChargeLinesContainer.appendChild(xmlRecord);
                }
                
            }

            xmlRoot.appendChild(xmlChargeLinesContainer);
        }

        xmlRecord = xmlDoc.createElement('Comment');
        xmlRecord.innerText(transactionTable.comment);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CommissionSalesGroup');
        xmlRecord.innerText(transactionTable.SalesGroup);
        xmlRoot.appendChild(xmlRecord);

        // NOTE: The code in this case indicates it returns CreateDateTime (for constency with XML schema for different scenarios) but
        // it actually returns the Transaction Date converted from UTC to local time for the channel.  Thus while TS.getOrderHistoryList() is
        // invoked, it sorts by TransDate, the results it returns may be sligtly skewed by the fact that it retuns the data adjusted to the
        // channel time.
        xmlRecord = xmlDoc.createElement('CreatedDateTime');
        xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
        utcTimeString = RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(DateTimeUtil::newDateTime(transactionTable.transDate,transactionTable.transTime, RetailChannelTable::findByRecId(transactionTable.Channel).ChannelTimeZone));
        xmlRecord.innerXml(utcTimeString);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CurrencyCode');
        xmlRecord.innerText(transactionTable.currency);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerAccountDepositLines');
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerId');
        xmlRecord.innerText(transactionTable.CustAccount);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerOrderTypeValue');
        xmlRecord.innerText(int2str(transactionTable.TransactionOrderType));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerRequisition');
        xmlRecord.innerText(transactionTable.CustPurchaseOrder);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('DeliveryMode');
        xmlRecord.innerText(transactionTable.DlvMode);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('DiscountAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(transactionTable.DiscAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('DiscountAmountWithoutTax');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(transactionTable.DiscAmountWithoutTax));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('EntryStatusValue');
        xmlRecord.innerText(int2str(transactionTable.EntryStatus));
        xmlRoot.appendChild(xmlRecord);

        xmlFiscalTransContainer = RetailTransactionServiceTransactions::fillFiscalTransactions(xmlDoc, transactionTable.Channel, transactionTable.store, transactionTable.terminal, transactionTable.transactionId);
        xmlRoot.appendChild(xmlFiscalTransContainer);

        xmlRecord = xmlDoc.createElement('GrossAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(transactionTable.GrossAmount * -1));
        xmlRoot.appendChild(xmlRecord);

        hasLoyaltyPayment = RetailLoyaltyCardRewardPointTrans::IsTransactionPaidByLoyalty(
            transactionTable.transactionId,
            transactionTable.store,
            transactionTable.terminal,
            transactionTable.Channel,
            transactionTable.dataAreaId);
        xmlRecord = xmlDoc.createElement('HasLoyaltyPayment');
        xmlRecord.innerText(hasLoyaltyPayment ? #TrueStr : #FalseStr);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Id');
        xmlRecord.innerText(transactionTable.TransactionId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('InvoiceComment');
        xmlRecord.innerText(transactionTable.InvoiceComment);
        xmlRoot.appendChild(xmlRecord);
        
        if (transactionTable.TaxCalculationType == TaxCalculationType::GTE)
        {
            RetailTransactionTaxTransGTE    transTaxTransGTE;

            select IsIncludedInPrice from transTaxTransGTE
                where  transactionTable.Channel         == transTaxTransGTE.Channel
                    && transactionTable.Terminal        == transTaxTransGTE.TerminalId
                    && transactionTable.Store           == transTaxTransGTE.StoreId
                    && transactionTable.TransactionId   == transTaxTransGTE.TransactionId
                    && transactionTable.DataAreaId      == transTaxTransGTE.DataAreaId;

            isTaxIncludedInPrice = transTaxTransGTE ? transTaxTransGTE.IsIncludedInPrice : isTaxIncludedInPrice;
        }
        else
        {
            RetailTransactionTaxTrans       transTaxTrans;

            select IsIncludedInPrice from transTaxTrans
                where  transactionTable.Channel         == transTaxTrans.Channel
                    && transactionTable.Terminal        == transTaxTrans.TerminalId
                    && transactionTable.Store           == transTaxTrans.StoreId
                    && transactionTable.TransactionId   == transTaxTrans.TransactionId
                    && transactionTable.DataAreaId      == transTaxTrans.DataAreaId;

            isTaxIncludedInPrice = transTaxTrans ? transTaxTrans.IsIncludedInPrice : isTaxIncludedInPrice;
        }

        xmlRecord = xmlDoc.createElement(IsTaxExemptedForPriceInclusive);
        xmlRecord.innerText(int2str(enum2int(transactionTable.IsTaxExemptedForPriceInclusive)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('IsTaxIncludedInPrice');
        xmlRecord.innerText(int2str(enum2int(isTaxIncludedInPrice)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('LoyaltyCardId');
        xmlRecord.innerText(transactionTable.loyaltyCardId);
        xmlRoot.appendChild(xmlRecord);

        // Add LoyaltyRewardPointLines
        xmlRoot.appendChild(RetailLoyaltyManager::FillLoyaltyRewardPointLinesForXmlWithRetailTransactionSalesTrans(transactionTable, xmlDoc));

        xmlRecord = xmlDoc.createElement('Name');
        xmlRecord.innerText(partyTable.Name);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('NetAmountWithNoTax');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(netAmountWithNoTax));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('NetAmountWithTax');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(transactionTable.GrossAmount * -1));
        xmlRoot.appendChild(xmlRecord);

        xmlRoot.appendChild(RetailTransactionServiceTransactions::fillNoteTransactions(xmlDoc, transactionTable.Channel, transactionTable.store, transactionTable.terminal, transactionTable.transactionId));

        // total invoice amounts paid
        prepaymentAmountPaid = RetailPrePaymentTrans::paymentsMade(transactionTable.salesOrderId);

        xmlRecord = xmlDoc.createElement('PrepaymentAmountPaid');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(prepaymentAmountPaid));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ReceiptEmail');
        xmlRecord.innerText(transactionTable.receiptEmail);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ReceiptId');
        xmlRecord.innerText(transactionTable.ReceiptId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('SalesId');
        xmlRecord.innerText(transactionTable.salesOrderId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('SalesLines');
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ShiftId');
        xmlRecord.innerText(transactionTable.Shift ? transactionTable.Shift : '0');
        xmlRoot.appendChild(xmlRecord);

        LogisticsPostalAddress deliveryAddress = LogisticsPostalAddress::findRecId(transactionTable.LogisticsPostalAddress);
        if (deliveryAddress)
        {
            str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, partyTable.Name);
            xmlRecord = RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, deliveryName, partyTable.RecId, xmlDoc);
            xmlRoot.appendChild(xmlRecord);
        }
        else
        {
            RetailTransactionAddressTrans addressTrans = RetailTransactionTransformer::getAddressLineFromTransaction(transactionTable);
            if (addressTrans)
            {
                xmlRecord = RetailTransactionServiceTransactions::fillRetailTransactionLineAddress(addressTrans, addressTrans.DeliveryName, xmlDoc);
                xmlRoot.appendChild(xmlRecord);
            }
        }

        xmlRecord = xmlDoc.createElement('StaffId');
        xmlRecord.innerText(transactionTable.Staff);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('StoreId');
        xmlRecord.innerText(transactionTable.Store);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(SubtotalAmountNode);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(subtotalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement(TaxAmountNode);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(taxTable.Amount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TenderLines');
        xmlRoot.appendChild(xmlRecord);

        if (_includePaymentDetails)
        {
            channelTable = RetailChannelTable::findByRecId(transactionTable.Channel);

            // Select the tender lines for the current transaction
            while select * from paymentTable
            where
                transactionTable.TransactionId == paymentTable.TransactionId
                && transactionTable.Channel == paymentTable.Channel
                && transactionTable.Store == paymentTable.Store
                && transactionTable.Terminal == paymentTable.Terminal
                && transactionTable.DataAreaId == paymentTable.DataAreaId
            {
                xmlRecord = xmlRoot.getElementsByTagName('TenderLines').item(0);
                xmlRecord.appendChild(RetailTransactionServiceTransactions::fillPaymentTransDetails(paymentTable, channelTable, xmlDoc));
            }
        }

        xmlRecord = xmlDoc.createElement('TerminalId');
        xmlRecord.innerText(transactionTable.Terminal);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TotalAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TotalDiscount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(transactionTable.TotalDiscAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TransactionDate');
        xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
        utcTimeString = RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(DateTimeUtil::newDateTime(transactionTable.transDate, 0, RetailChannelTable::findByRecId(transactionTable.Channel).ChannelTimeZone));
        xmlRecord.innerXml(utcTimeString);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TransactionTime');
        xmlRecord.innerText(num2Str(transactionTable.transTime, 5, 0, 0, 0));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TransactionTypeValue');
        xmlRecord.innerText(int2str(enum2int(transactionTable.type)));
        xmlRoot.appendChild(xmlRecord);

        // XML tags for SalesOrder (derived class)

        SalesTable salesTableLocal;
        salesTableLocal = SalesTable::find(transactionTable.salesOrderId);

        if (salesTableLocal)
        {
            xmlRecord = xmlDoc.createElement('DocumentStatusValue');
            xmlRecord.innerText(int2str(enum2int(salesTableLocal.DocumentStatus)));
            xmlRoot.appendChild(xmlRecord);
        }

        SalesStatus salesStatus = RetailTransactionServiceTransactions::GetSalesStatus(transactionTable, salesTableLocal);

        xmlRecord = xmlDoc.createElement('Status');
        xmlRecord.innerText(enum2str(salesStatus));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('StatusValue');
        xmlRecord.innerText(int2str(RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(salesStatus)));
        xmlRoot.appendChild(xmlRecord);

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesStatus</Name>
				<Source><![CDATA[
    internal static SalesStatus GetSalesStatus(RetailTransactionTable transactionTable, SalesTable salesTable = null)
    {
        SalesStatus salesStatus = SalesStatus::None;

        if (salesTable)
        {
            salesStatus = salesTable.SalesStatus;
        }
        else
        {
            if (transactionTable.Type == RetailTransactionType::Sales)
            {
                salesStatus = SalesStatus::Invoiced;
            }
        }

        return salesStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the serialized xml string of a <c>SalesLine</c> having the data of the <c>SalesLine</c> table.
    /// </summary>
    /// <param name="_salesTable">
    /// Table buffer of <c>SalesTable</c> table.
    /// </param>
    /// <param name="_rsoTable">
    /// Table buffer of <c>RetailSalesTable</c> table.
    /// </param>
    /// <param name="_soLine">
    /// Table buffer of <c>SalesLine</c> table.
    /// </param>
    /// <param name="_rsoLine">
    /// Table buffer of <c>RetailSalesLine</c> table.
    /// </param>
    /// <param name="_inventDim">
    /// Table buffer of <c>InventDim</c> table.
    /// </param>
    /// <param name="_xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_includeDiscount">
    /// Whether to include the discount details, by default is false.
    /// </param>
    /// <param name="_salesOrderRecId">
    /// The sales order rec id.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>SalesLine</c> table.
    /// * Members must be in order of the SalesLine DataContract
    /// Example:
    ///    <SalesLine>
    ///      <ItemId />
    ///      <ItemTaxGroupId />
    ///      <NetAmount />
    ///      <Price />
    ///      <Quantity />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <TaxLines />
    ///      <ChargeLines />
    ///      <DeliveryMode />
    ///      <InventoryDimensionId />
    ///      <InventoryLocationId />
    ///      <LineDiscount />
    ///      <LineNumber />
    ///      <ListingId />
    ///      <ShippingAddress />
    ///    </SalesLine>
    /// </returns>
    /// <remarks>
    ///  C# SalesLine fields must be sorted alphabetically
    /// </remarks>
    internal static XmlElement fillSalesLineDetails(SalesTable _salesTable, RetailSalesTable _rsoTable, SalesLine _soLine, RetailSalesLine _rsoLine, InventDim _inventDim, XmlDocument _xmlDoc, boolean _includeDiscount = false, RecId _salesOrderRecId = 0)
    {
        LogisticsPostalAddress      deliveryAddress;
        MarkupTrans                 markupTrans;
        RetailSalesDiscountLine     salesLineDiscount;
        RetailPeriodicDiscount      retailDiscount;
        RetailTenderDiscount        tenderDiscount;
        MCRSalesLine                mcrSalesLine;
        RetailStoreTable            retailStoreTable;

        XmlElement xmlRecord, xmlEntry, xmlAddress, xmlTax, xmlTaxLine, xmlContainer;

        DiscAmount lineDiscount = 0, periodicDiscount = 0, totalDiscount = 0, tenderDiscountAmount = 0;
        boolean hasDiscountLines = false;
        boolean needBackfill = _soLine.LineDisc
            && !_rsoLine.LineDscAmount
            && !_rsoLine.PeriodicDiscount
            && !_rsoLine.TotalDiscount
            && _rsoLine.TenderDiscount;

        InventTable                 inventTable;
        InventDimCombination        inventDimCombination;
        RecId                       productId;
        InventDimParm               inventDimParm;
        InventDimId                 inventDimId;
        EcoResProduct               ecoResProduct;
        str                         listingId;

        eventSource.EventWriteFillSalesLineDetailsStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
        System.Diagnostics.Stopwatch salesOrderLineDetailsSW = new System.Diagnostics.Stopwatch();
        salesOrderLineDetailsSW.Start();

        xmlRecord = _xmlDoc.createElement('SalesLine');

        RetailFillSalesLineDetailsParameters lineParameters = RetailFillSalesLineDetailsParameters::construct();
        lineParameters.xmlDoc = _xmlDoc;
        lineParameters.xmlRecord = xmlRecord;
        lineParameters.salesLine = _soLine;
        lineParameters.retailSalesLine = _rsoLine;
        lineParameters.inventDim = _inventDim;
        lineParameters.includeDiscount = _includeDiscount;

        RetailCustomerOrderExtensions::fillSalesLineDetailsPrePopulate(lineParameters);

        // C# TaxableItem fields sorted alphabetically
        xmlEntry = _xmlDoc.createElement('ItemId');
        xmlEntry.innerText(_soLine.ItemId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('ItemTaxGroupId');
        xmlEntry.innerText(_soLine.TaxItemGroup);
        xmlRecord.appendChild(xmlEntry);

        real netAmountWithAllInclusiveTax = _soLine.LineAmount;
        xmlEntry = _xmlDoc.createElement('NetAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(netAmountWithAllInclusiveTax));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('NetAmountWithAllInclusiveTax');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(netAmountWithAllInclusiveTax));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('Price');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_soLine.SalesPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('Quantity');
        xmlEntry.innerText(num2str(_soLine.SalesQty, 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('SalesTaxGroupId');
        xmlEntry.innerText(_soLine.TaxGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlTax = _xmlDoc.createElement('TaxLines');
        RetailTransactionTable transactionTable;

        select firstonly transactionTable
            where transactionTable.SalesOrderId == _soLine.SalesId && transactionTable.DataAreaId == _soLine.DataAreaId;
        if (transactionTable)
        {
            RetailTransactionSalesTrans transactionSalesTrans = RetailTransactionSalesTrans::find(transactionTable.TransactionId,
                                                                                                  transactionTable.Store,
                                                                                                  transactionTable.Terminal,
                                                                                                  _soLine.LineNum,
                                                                                                  false,
                                                                                                  transactionTable.Channel);
            RetailTransactionTaxTrans taxTransTable;

            while select taxTransTable
                where taxTransTable.TransactionId == transactionSalesTrans.TransactionId
                    && taxTransTable.SaleLineNum == transactionSalesTrans.lineNum
                    && taxTransTable.Channel == transactionSalesTrans.Channel
                    && taxTransTable.StoreId == transactionSalesTrans.Store
                    && taxTransTable.TerminalId == transactionSalesTrans.terminalId
                    && taxTransTable.DataAreaId == transactionSalesTrans.DataAreaId
            {
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineTaxTrans(taxTransTable, transactionSalesTrans, _xmlDoc);
                xmlTax.appendChild(xmlEntry );
            }
        }
        else
        {
            xmlTaxLine = _xmlDoc.createElement('TaxLine');
            xmlEntry = _xmlDoc.createElement('Amount');
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_soLine.LineAmount - _soLine.lineAmountExclTax()));
            xmlTaxLine.appendChild(xmlEntry);
            xmlTax.appendChild(xmlTaxLine);
        }
        xmlRecord.appendChild(xmlTax);

        // C# SalesLine fields sorted alphabetically
        RetailTransactionSerializationContext context = RetailTransactionSerializationContext::current();
        boolean includeAttributeValues = false;

        if (context != null && context.parmIncludeAttributeValues())
        {
            includeAttributeValues = context.parmIncludeAttributeValues();
        }

        if (includeAttributeValues && !RetailUseLegacySalesOrderAttributesToggle::instance().isEnabled())
        {
            xmlContainer = _xmlDoc.createElement('AttributeValues');
            RetailSalesTableInstanceValue retailSalesTableInstanceValue = RetailSalesTableInstanceValue::findBySalesTable(_soLine.SalesId,
                                                                                                                          _soLine.DataAreaId,
                                                                                                                          false,
                                                                                                                          _soLine.LineNum);

            if (retailSalesTableInstanceValue)
            {
                xmlContainer = RetailTransactionServiceTransactions::fillAttributeValues(retailSalesTableInstanceValue.RecId, xmlContainer, _xmlDoc);
                xmlRecord.appendChild(xmlContainer);
            }
        }

        //This catalogid is being used in SalesLine as column name Catalog.
        xmlEntry = _xmlDoc.createElement('CatalogId');
        xmlEntry.innerText(int642str(_rsoLine.Catalog));
        xmlRecord.appendChild(xmlEntry);

        System.Diagnostics.Stopwatch chargesSW = new System.Diagnostics.Stopwatch();
        chargesSW.Start();
        eventSource.EventWriteFillSaleslLineChargesStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
        
        //Add line level charges
        xmlContainer = _xmlDoc.createElement('ChargeLines');

        if (transactionTable && RetailTaxFillSalesOrderWithRetailTransactionTableFlight::instance().isEnabled())
        {
            RetailTransactionMarkupTrans retailChargeTrans;
            while select retailChargeTrans
                where retailChargeTrans.TransactionId == transactionTable.TransactionId
                && retailChargeTrans.SaleLineNum == _soLine.LineNum
            {
                xmlEntry = RetailTransactionServiceTransactions::fillRetailChargeTrans(retailChargeTrans, _xmlDoc);
                xmlContainer.appendChild(xmlEntry);
            }
        }
        else
        {
            RetailTransactionServiceTransactions::addChargeLines(_soLine.TableId, _soLine.RecId, _xmlDoc, xmlContainer);
        }
        xmlRecord.appendChild(xmlContainer);

        chargesSW.Stop();
        eventSource.EventWriteFillSaleslLineChargesFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), chargesSW.ElapsedMilliseconds);

        xmlEntry = _xmlDoc.createElement('Comment');
        xmlEntry.innerText(_soLine.CustomerRef);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('CommissionSalesGroup');
        xmlEntry.innerText(_soLine.SalesGroup);
        xmlRecord.appendChild(xmlEntry);

        if (_soLine.ShippingDateConfirmed)
        {
            xmlEntry = _xmlDoc.createElement('ConfirmedShipDate');
            xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlEntry.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_soLine.ShippingDateConfirmed, _rsoTable.RetailChannel));
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = _xmlDoc.createElement('DeliveryMode');
        xmlEntry.innerText(_soLine.DlvMode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('Description');
        xmlEntry.innerText(_soLine.itemName());
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('DetailedLineStatusValue');
        xmlEntry.innerText(int2Str(enum2int(RetailDetailedOrderInfoHelper::getDetailedLineStatus(_soLine))));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(discAmountColumn);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_soLine.lineDisc * _soLine.QtyOrdered));
        xmlRecord.appendChild(xmlEntry);

        if (_includeDiscount)
        {
            System.Diagnostics.Stopwatch discountSW = new System.Diagnostics.Stopwatch();
            discountSW.Start();
            eventSource.EventWriteFillSalesLineDiscountStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));

            xmlContainer = _xmlDoc.createElement('DiscountLines');
            // add discount data
            while select salesLineDiscount
                where salesLineDiscount.InventTransId == _soLine.InventTransId
            outer join Name from retailDiscount
                where salesLineDiscount.PeriodicDiscountOfferId
                    && retailDiscount.OfferId == salesLineDiscount.PeriodicDiscountOfferId
                    && salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Periodic
            outer join Name from tenderDiscount
                where salesLineDiscount.PeriodicDiscountOfferId
                    && retailDiscount.OfferId == tenderDiscount.OfferId
                    && salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Tender
            {
                hasDiscountLines = true;
                if (needBackfill)
                {
                    if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Periodic)
                    {
                        periodicDiscount += salesLineDiscount.Amount;
                    }
                    else if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Customer)
                    {
                        if (salesLineDiscount.CustomerDiscountType != RetailCustomerDiscountType::TotalDiscount)
                        {
                            lineDiscount += salesLineDiscount.Amount;
                        }
                        else
                        {
                            totalDiscount += salesLineDiscount.Amount;
                        }
                    }
                    else if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Manual)
                    {
                        if (salesLineDiscount.ManualDiscountType == RetailManualDiscountType::LineDiscountAmount ||
                            salesLineDiscount.ManualDiscountType == RetailManualDiscountType::LineDiscountPercent)
                        {
                            lineDiscount += salesLineDiscount.Amount;
                        }
                        else
                        {
                            totalDiscount += salesLineDiscount.Amount;
                        }
                    }
                    else if (salesLineDiscount.DiscountOriginType == RetailDiscountOriginType::Tender)
                    {
                        tenderDiscountAmount += salesLineDiscount.Amount;
                    }
                }
                // fill in discount data
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountDetails(salesLineDiscount, retailDiscount, tenderDiscount, _soLine.LineNum, _soLine.SalesQty, _xmlDoc);
                xmlContainer.appendChild(xmlEntry);

                discountSW.Stop();
                eventSource.EventWriteFillSalesLineDiscountFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), discountSW.ElapsedMilliseconds);
            }

            if (needBackfill)
            {
                // make up a discount line if non exists.
                if (!hasDiscountLines)
                {
                    discountSW.Reset();
                    eventSource.EventWriteFillSalesLineDiscountStarted(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));

                    lineDiscount = _soLine.LineDisc * _soLine.SalesQty;

                    salesLineDiscount.initValue();
                    salesLineDiscount.InventTransId = _soLine.InventTransId;
                    salesLineDiscount.DiscountOriginType = RetailDiscountOriginType::Customer;
                    salesLineDiscount.CustomerDiscountType = RetailCustomerDiscountType::Line;
                    salesLineDiscount.Amount = _soLine.LineDisc;
                    if (_soLine.SalesQty)
                    {
                        salesLineDiscount.DiscountAmount = _soLine.LineDisc / _soLine.SalesQty;
                    }

                    retailDiscount.clear();

                    xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountDetails(salesLineDiscount, retailDiscount, tenderDiscount, _soLine.LineNum, _soLine.SalesQty, _xmlDoc);
                    xmlContainer.appendChild(xmlEntry);

                    discountSW.Stop();
                    eventSource.EventWriteFillSalesLineDiscountFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), discountSW.ElapsedMilliseconds);
                }

            }
            else
            {
                lineDiscount = _rsoLine.LineDscAmount;
                periodicDiscount = _rsoLine.PeriodicDiscount;
                totalDiscount = _rsoLine.TotalDiscount;
                tenderDiscountAmount = _rsoLine.TenderDiscount;
            }

            xmlRecord.appendChild(xmlContainer);
        }
        else
        {
            if (needBackfill)
            {
                lineDiscount = _soLine.LineDisc * _soLine.SalesQty;
            }
            else
            {
                lineDiscount = _rsoLine.LineDscAmount;
                periodicDiscount = _rsoLine.PeriodicDiscount;
                totalDiscount = _rsoLine.TotalDiscount;
                tenderDiscountAmount = _rsoLine.TenderDiscount;
            }
        }

        xmlEntry = _xmlDoc.createElement('ElectronicDeliveryEmailAddress');
        mcrSalesLine = _soLine.mcrSalesLine();
        xmlEntry.innerText(mcrSalesLine.GiftCardRecipientEmail);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('FulfillmentStatusValue');
        xmlEntry.innerText(int2Str(any2Int(_rsoLine.FulfillmentStatus)));
        xmlRecord.appendChild(xmlEntry);

        if (_rsoLine && _rsoLine.FulfillmentStoreId != '')
        {
            xmlEntry = _xmlDoc.createElement(FulfillmentStoreIdColumn);
            xmlEntry.innerText(_rsoLine.FulfillmentStoreId);
            xmlRecord.appendChild(xmlEntry);
        }
        else
        {
            // Regular SO (Non call center SO) created in HQ for Pickup in store doesn't have assigned
            // Fullfilment Store Id, so we have to assign during pickup
            if (RetailDlvMode::isPickupDeliveryMode(_soLine.DlvMode))
            {
                xmlEntry = _xmlDoc.createElement(FulfillmentStoreIdColumn);
                xmlEntry.innerText(RetailStoreTable::getFirstStoreIdByInventLocation(_inventDim.InventLocationId));
                xmlRecord.appendChild(xmlEntry);
            }
        }

        xmlEntry = _xmlDoc.createElement('InventoryDimensionId');
        xmlEntry.innerText(_soLine.InventDimId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('InventoryLocationId');
        xmlEntry.innerText(_inventDim.InventLocationId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('InventorySiteId');
        xmlEntry.innerText(_inventDim.InventSiteId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('InventoryTransactionId');
        xmlEntry.innerText(_soLine.InventTransId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#IsPriceOverridden);
        if (_rsoLine.IsPriceOverridden == NoYes::Yes)
        {
            xmlEntry.innerText('1');
        }
        else
        {
            xmlEntry.innerText('0');
        }
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('IsSalesAgreementSkipped');
        xmlEntry.innerText(int642Str(_soLine.AgreementSkipAutoLink));
        xmlRecord.appendChild(xmlEntry);

        // Add IsWarrantyLine to SalesLine when needed.
        RetailTransactionServiceWarranty::appendIsWarrantyLineFlagToSalesLine(_xmlDoc, xmlRecord, _soLine);

        xmlEntry = _xmlDoc.createElement(#ColumnLineDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(lineDiscount));
        xmlRecord.appendChild(xmlEntry);
        
        xmlEntry = _xmlDoc.createElement(#ColumnLineManualDiscountAmount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.LineManualDiscountAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#ColumnLineManualDiscountPercentage);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.LineManualDiscountPercentage));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('LineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_soLine.LineNum));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(ColumnLinePercentageDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.LinePercentageDiscount));
        xmlRecord.appendChild(xmlEntry);

        // Need a version number to tell if Hybrid X++ code is present
        // Version 1 was for above properties QuantityRemained and QuantityShipped so MPOS can tell if X++ change present
        xmlEntry = _xmlDoc.createElement('LineVersion');
        xmlEntry.innerText('1');
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('ListingId');
        if (_rsoLine && _rsoLine.ListingId)
        {
            xmlEntry.innerText(_rsoLine.ListingId);
        }
        else
        {
            productId = (select firstOnly Product
                        from inventTable
                        where inventTable.ItemId == _soLine.ItemId).Product;

            ecoResProduct = EcoResProduct::find(productId);

            if (ecoResProduct != null &&
                        !ecoResProduct.isDistinctProduct())
            {
                inventDimParm.setAllProductDimensions();
                _inventDim.clearNotSelectedDim(inventDimParm);
                inventDimId = InventDim::findOrCreate(_inventDim).inventDimId;

                productId = (select firstOnly DistinctProductVariant
                            from inventDimCombination
                            where inventDimCombination.ItemId == _soLine.ItemId
                                && inventDimCombination.InventDimId == inventDimId).DistinctProductVariant;
            }

            xmlEntry.innerText(int642str(productId));
        }

        listingId = xmlEntry.innerText();
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#OriginalPrice);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.OriginalPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#ColumnPeriodicDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(periodicDiscount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#ColumnPeriodicPercentageDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.PeriodicPercentageDiscount));
        xmlRecord.appendChild(xmlEntry);

        if (_rsoLine.PickupEndTime > 0)
        {
            // Formatted as yyyy-MM-ddTHH:mm:ss
            xmlEntry = _xmlDoc.createElement('PickupTimeslotEndDateTime');
            xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(DateTimeUtil::newDateTime(_soLine.ShippingDateRequested, _rsoLine.PickupEndTime)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = _xmlDoc.createElement('PickupTimeslotStartDateTime');
            xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(DateTimeUtil::newDateTime(_soLine.ShippingDateRequested, _rsoLine.PickupStartTime)));
            xmlRecord.appendChild(xmlEntry);
        }

        if (!RetailTransactionXmlSkipPriceLineFlight::instance().isEnabled() && RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            RetailTransactionServiceTransactions::fillSalesLinePriceDetails(_xmlDoc, xmlRecord, _soLine);
        }

        //ProductId is a copy of ListingId
        xmlEntry = _xmlDoc.createElement('ProductId');
        xmlEntry.innerText(listingId);
        xmlRecord.appendChild(xmlEntry);

        RetailSalesLineQuantitiesCalculator qtyCalculator = RetailSalesLineQuantitiesCalculator::construct(_soLine);

        var pickupOrderProcessingImprovementFeatureEnabled = RetailImprovedPickupOrderProcessingInPosFeatureExposure::isEnabledInFeatureManagement();
        boolean isRetailFulfillmentQuantitiesInSalesUomFlightEnabled = RetailFulfillmentQuantitiesInSalesUomFlight::instance().isEnabled();

        if (_rsoLine && pickupOrderProcessingImprovementFeatureEnabled && _rsoLine.stockedInventoryQuantitiesNeverUpdated(_soLine))
        {
            RetailTransactionServiceTransactionsJson::updateLineQuantities(_rsoLine);
        }

        xmlEntry = _xmlDoc.createElement('QuantityCanceled');
        xmlEntry.innerText(num2str(qtyCalculator.quantityCanceled() , 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('QuantityInvoiced');
        xmlEntry.innerText(num2str(_soLine.invoicedInTotal(), 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        if (_rsoLine && pickupOrderProcessingImprovementFeatureEnabled)
        {
            xmlEntry = _xmlDoc.createElement('QuantityNotProcessed');
            if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
            {
                xmlEntry.innerText(num2str(_rsoLine.getQuantityNotProcessedInSalesUnit(_soLine), 0, 2, 1, 0));
            }
            else
            {
                xmlEntry.innerText(num2str(_rsoLine.QuantityNotProcessed, 0, 2, 1, 0));
            }
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = _xmlDoc.createElement(quantityOrderedColumn);
        xmlEntry.innerText(num2str(_soLine.SalesQty, 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        if (_rsoLine && pickupOrderProcessingImprovementFeatureEnabled)
        {
            xmlEntry = _xmlDoc.createElement('QuantityPacked');
            if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
            {
                xmlEntry.innerText(num2str(_rsoLine.getQuantityPackedInSalesUnit(_soLine), 0, 2, 1, 0));
            }
            else
            {
                xmlEntry.innerText(num2str(_rsoLine.QuantityPacked, 0, 2, 1, 0));
            }
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = _xmlDoc.createElement('QuantityPicked');
            if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
            {
                xmlEntry.innerText(num2str(_rsoLine.getQuantityPickedInSalesUnit(_soLine), 0, 2, 1, 0));
            }
            else
            {
                xmlEntry.innerText(num2str(_rsoLine.QuantityPicked, 0, 2, 1, 0));
            }
            xmlRecord.appendChild(xmlEntry);
        }

        // Quantity that is still available for pickup in the stores
        xmlEntry = _xmlDoc.createElement('QuantityRemained');
        xmlEntry.innerText(num2str(qtyCalculator.quantityRemaining(), 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        if (_rsoLine && pickupOrderProcessingImprovementFeatureEnabled)
        {
            xmlEntry = _xmlDoc.createElement('QuantityReserved');
            if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
            {
                xmlEntry.innerText(num2str(_rsoLine.getQuantityPhysicallyReservedInSalesUnit(_soLine), 0, 2, 1, 0));
            }
            else
            {
                xmlEntry.innerText(num2str(_rsoLine.QuantityPhysicallyReserved, 0, 2, 1, 0));
            }
            xmlRecord.appendChild(xmlEntry);
        }

        // Quantities that were already picked in the HQ, are showed as "shipped" in MPOS,
        // as they won't be available for pick-up anymore.
        xmlEntry = _xmlDoc.createElement('QuantityShipped');
        xmlEntry.innerText(num2str(_soLine.deliveredInTotal(), 0, 2, 1, 0));
        xmlRecord.appendChild(xmlEntry);

        if (WarrantyFeatureExposure::isWarrantySalesViaCustomerOrderFeatureEnabled())
        {
            SalesQty qty;
            PdsCWInventQty cwQty;
            [qty, cwQty] = SalesLine::pdsRemainReturnLotQtyAllCreditNote(_soLine.InventTransId);

            xmlEntry = _xmlDoc.createElement('ReturnQuantity');
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(qty));
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = _xmlDoc.createElement('SalesAgreementLineRecordId');
        xmlEntry.innerText(int642Str(_soLine.MatchingAgreementLine));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('SalesStatus');
        xmlEntry.innerText(int2str(RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(_soLine.SalesStatus)));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('SalesStatusValue');
        xmlEntry.innerText(int2str(RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(_soLine.SalesStatus)));
        xmlRecord.appendChild(xmlEntry);

        deliveryAddress = LogisticsPostalAddress::findRecId(_soLine.DeliveryPostalAddress);
        if (deliveryAddress)
        {
            DirPartyRecId customerParty = CustTable::find(_salesTable.custAccount).Party;
            str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, _soLine.DeliveryName);
            xmlAddress = RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, deliveryName, customerParty, _xmlDoc);
            xmlRecord.appendChild(xmlAddress);
        }

        xmlEntry = _xmlDoc.createElement(ColumnTenderDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(tenderDiscountAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(ColumnTenderDiscountPercentage);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.TenderDiscountPercentage));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#ColumnTotalDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(totalDiscount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(#ColumnTotalPercentageDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_rsoLine.TotalPctDiscount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement('UnitOfMeasureSymbol');
        xmlEntry.innerText(_soLine.SalesUnit);
        xmlRecord.appendChild(xmlEntry);

        // Add WarrantyInfo to SalesLine.
        RetailTransactionServiceWarranty::appendWarrantiedRelationToSalesLine(_xmlDoc, xmlRecord, _soLine);

        salesOrderLineDetailsSW.Stop();
        eventSource.EventWriteFillSalesLineDetailsFinished(_salesOrderRecId, _soLine.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), salesOrderLineDetailsSW.ElapsedMilliseconds);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineDiscountDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>DiscountLine</c> having the data of the <c>RetailSalesDiscountLine</c> table.
    /// </summary>
    /// <param name="discountLine">
    /// Table buffer of <c>RetailSalesDiscountLine</c> table.
    /// </param>
    /// <param name="retailDiscount">
    /// Table buffer of <c>RetailPeriodicDiscount</c> table.
    /// </param>
    /// <param name="tenderDiscount">
    /// Table buffer of <c>RetailTenderDiscount</c> table.
    /// </param>
    /// <param name="lineNum">
    /// The line number
    /// </param>
    /// <param name="salesQty">
    /// The sales quantity
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionDiscountTrans</c> table.
    /// * Members must be in order of the DiscountLine DataContract
    /// Example:
    ///    <DiscountLine>
    ///      <SaleLineNumber />
    ///      <OfferId />
    ///      <OfferName />
    ///      <DealPrice />
    ///      <Amount />
    ///      <Percentage />
    ///      <EffectiveAmount />
    ///      <Percentage />
    ///      <DiscountLineTypeValue />
    ///      <ManualDiscountTypeValue />
    ///      <CustomerDiscountTypeValue />
    ///      <PeriodicDiscountTypeValue />
    ///      <DiscountApplicationGroup />
    ///      <ConcurrencyModeValue />
    ///      <IsCompoundable />
    ///      <DiscountCode />
    ///      <DiscountCost />
    ///      <IsDiscountCodeRequired />
    ///      <ThresholdAmountRequired />
    ///    </DiscountLine>
    /// </returns>
    private static XmlElement fillSalesLineDiscountDetails(RetailSalesDiscountLine  discountLine,
                                                           RetailPeriodicDiscount   retailDiscount,
                                                           RetailTenderDiscount     tenderDiscount,
                                                           LineNum                  lineNum,
                                                           SalesOrderedQty          salesQty,
                                                           XmlDocument              xmlDoc)
    {
        DiscAmount discountAmount;

        XmlElement xmlRecord, xmlEntry;
        xmlRecord = xmlDoc.createElement('DiscountLine');

        // Backfill discount amount for R2 customer orders.
        discountAmount = discountLine.DiscountAmount;
        if (!discountAmount && !discountLine.Percentage)
        {
            discountAmount = salesQty ? discountLine.Amount / salesQty : 0;
        }

        xmlEntry = xmlDoc.createElement(#ColumnAmount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(discountAmount));
        xmlRecord.appendChild(xmlEntry);
        
        xmlEntry = xmlDoc.createElement('CustomerDiscountTypeValue');
        xmlEntry.innerText(int2str(discountLine.CustomerDiscountType));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('BundleId');
        xmlEntry.innerText(int2str(discountLine.BundleId));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnDealPrice);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(discountLine.DealPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DiscountCode');
        xmlEntry.innerText(discountLine.DiscountCode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DiscountCost');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(discountAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DiscountLineTypeValue');
        xmlEntry.innerText(int2str(discountLine.DiscountOriginType));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('EffectiveAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(discountLine.Amount));
        xmlRecord.appendChild(xmlEntry);

        if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            xmlRecord = RetailTransactionServiceTransactions::addLineNumberForDiscountLineXml(xmlDoc, xmlRecord, discountLine);
        }

        xmlEntry = xmlDoc.createElement('ManualDiscountTypeValue');
        xmlEntry.innerText(int2str(discountLine.ManualDiscountType));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('OfferId');
        xmlEntry.innerText(discountLine.PeriodicDiscountOfferId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('OfferName');
        xmlEntry.innerText(discountLine.DiscountOriginType == RetailDiscountOriginType::Periodic ? retailDiscount.Name : tenderDiscount.Name);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnPercentage);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(discountLine.Percentage));
        xmlRecord.appendChild(xmlEntry);

        if (RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            xmlRecord = RetailTransactionServiceTransactions::addRecordIdForDiscountLineXml(xmlDoc, xmlRecord, discountLine);
        }

        xmlEntry = xmlDoc.createElement('SaleLineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(lineNum));
        xmlRecord.appendChild(xmlEntry);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillAttributeValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fill attribute values.
    /// </summary>
    /// <param name = "instanceValueRecId"> RecId of retailSalesTableInstanceValue table. </param>
    /// <param name = "xmlContainer">Xml element</param>
    /// <param name = "xmlDoc"> Xml Document.</param>
    /// <returns></returns>
    private static XmlElement fillAttributeValues(RefRecId instanceValueRecId, XmlElement xmlContainer, XmlDocument xmlDoc)
    {
        EcoResAttribute                 ecoResAttribute;
        EcoResAttributeValue            ecoResAttributeValue;
        EcoResTextValue                 ecoResTextValue;
        XmlElement xmlrecord, xmlEntry;

        while select * from ecoResAttributeValue where ecoResAttributeValue.InstanceValue == instanceValueRecId
                join Name from ecoResAttribute where ecoResAttribute.RecId == ecoResAttributeValue.Attribute
                    join TextValue from ecoResTextValue where ecoResTextValue.RecId == ecoResAttributeValue.Value
        {
            xmlrecord = xmlDoc.createElement('AttributeValueBase');
            xmlrecord.setAttribute2('type', schemaInstanceNSUrl, 'AttributeTextValue');

            xmlEntry = xmlDoc.createElement('Name');
            xmlEntry.innerText(ecoResAttribute.Name);
            xmlrecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TextValue');
            xmlEntry.innerText(ecoResTextValue.TextValue);
            xmlrecord.appendChild(xmlEntry);

            xmlContainer.appendChild(xmlRecord);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>TaxLine</c> having the data of the <c>RetailTransactionTaxTrans</c> table.
    /// </summary>
    /// <param name = "_taxTable">Table buffer of <c>RetailTransactionTaxTrans</c> table.</param>
    /// <param name = "_salesLineTable">Table buffer of <c>RetailTransactionSalesTrans</c> table.</param>
    /// <param name = "xmlDoc">XmlDocument</param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionTaxTrans</c> table.
    /// Example:
    /// <TaxLine>
    ///     <TaxGroup />
    ///     <TaxBasis />
    ///     <IsExempt />
    ///     <IsIncludedInPrice />
    ///     <DataAreaId />
    ///     <SaleLineNumber />
    ///     <StoreId />
    ///     <TerminalId />
    ///     <TransactionId />
    ///     <TaxCode />
    ///     <Amount />
    /// </TaxLine>
    ///</returns>
    [HookableAttribute(true)]
    private static XmlElement fillSalesLineTaxTrans(RetailTransactionTaxTrans _taxTable, RetailTransactionSalesTrans _salesLineTable, XmlDocument xmlDoc)
    {
        XmlElement result = xmlDoc.createElement('TaxLine');
        XmlElement xmlEntry;

        xmlEntry = xmlDoc.createElement('Amount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_taxTable.Amount));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DataAreaId');
        xmlEntry.innerText(_taxTable.DataAreaId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('IsExempt');
        xmlEntry.innerText(int2Str(_taxTable.IsExempt));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('IsIncludedInPrice');
        xmlEntry.innerText(int2Str(_taxTable.IsIncludedInPrice));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Percentage');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_taxTable.TaxPercentage));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SaleLineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_taxTable.SaleLineNum));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('StoreId');
        xmlEntry.innerText(_taxTable.StoreId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxBasis');
        TaxTable taxTable;
        select firstonly TaxBase from taxTable where taxTable.TaxCode == _taxTable.TaxCode;
        if (taxTable.TaxBase == TaxBaseType::AmountByUnit)
        {
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_salesLineTable.qty));
        }
        else
        {
            real taxBasisAmount = _taxTable.TaxBaseAmount;
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(taxBasisAmount));
        }
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxCode');
        xmlEntry.innerText(_taxTable.TaxCode);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxGroup');
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TerminalId');
        xmlEntry.innerText(_taxTable.TerminalId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TransactionId');
        xmlEntry.innerText(_taxTable.TransactionId);
        result.appendChild(xmlEntry);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRetailChargeLineTaxTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>TaxLine</c> having the data of the <c>RetailTransactionChargeTaxTrans</c> table.
    /// </summary>
    /// <param name = "_chargeTaxTrans">Table buffer of <c>RetailTransactionChargeTaxTrans</c> table.</param>
    /// <param name = "xmlDoc">XmlDocument</param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionChargeTaxTrans</c> table.
    /// Example:
    /// <TaxLine>
    ///     <TaxGroup />
    ///     <IsExempt />
    ///     <IsIncludedInPrice />
    ///     <DataAreaId />
    ///     <SaleLineNumber />
    ///     <StoreId />
    ///     <TerminalId />
    ///     <TransactionId />
    ///     <TaxCode />
    ///     <Amount />
    /// </TaxLine>
    ///</returns>
    [HookableAttribute(true)]
    private static XmlElement fillRetailChargeLineTaxTrans(RetailTransactionChargeTaxTrans _chargeTaxTrans, XmlDocument xmlDoc)
    {
        XmlElement result = xmlDoc.createElement('TaxLine');
        XmlElement xmlEntry;

        xmlEntry = xmlDoc.createElement('Amount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_chargeTaxTrans.Amount));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DataAreaId');
        xmlEntry.innerText(_chargeTaxTrans.DataAreaId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('IsExempt');
        xmlEntry.innerText(int2Str(_chargeTaxTrans.IsExempt));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('IsIncludedInPrice');
        xmlEntry.innerText(int2Str(_chargeTaxTrans.IsIncludedInPrice));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SaleLineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_chargeTaxTrans.SaleLineNum));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('StoreId');
        xmlEntry.innerText(_chargeTaxTrans.StoreId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxCode');
        xmlEntry.innerText(_chargeTaxTrans.TaxCode);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxGroup');
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TerminalId');
        xmlEntry.innerText(_chargeTaxTrans.TerminalId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TransactionId');
        xmlEntry.innerText(_chargeTaxTrans.TransactionId);
        result.appendChild(xmlEntry);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineTaxTransGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>TaxLineGTE</c> having the data of the <c>RetailTransactionTaxTransGTE</c> table.
    /// </summary>
    /// <param name = "_taxTableGTE">Table buffer of <c>RetailTransactionTaxTransGTE</c> table.</param>
    /// <param name = "_salesLineTable">Table buffer of <c>RetailTransactionSalesTrans</c> table.</param>
    /// <param name = "xmlDoc">XmlDocument</param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionTaxTransGTE</c> table.
    /// Example:
    /// <TaxLineGTE>
    ///     <TaxGroup />
    ///     <TaxBasis />
    ///     <IsIncludedInPrice />
    ///     <DataAreaId />
    ///     <SaleLineNumber />
    ///     <StoreId />
    ///     <TerminalId />
    ///     <TransactionId />
    ///     <TaxComponent />
    ///     <Amount />
    /// </TaxLineGTE>
    ///</returns>
    [HookableAttribute(true)]
    private static XmlElement fillSalesLineTaxTransGTE(RetailTransactionTaxTransGTE _taxTableGTE, RetailTransactionSalesTrans _salesLineTable, XmlDocument xmlDoc)
    {
        XmlElement result;

        if (UseTaxLineWithTypeTaxLineGteFlight::instance().isEnabled())
        {
            result = xmlDoc.createElement('TaxLine');
            result.setAttribute2('type', schemaInstanceNSUrl, 'TaxLineGTE');
        }
        else
        {
            result = xmlDoc.createElement('TaxLineGTE');
        }

        XmlElement xmlEntry;

        xmlEntry = xmlDoc.createElement('Amount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_taxTableGTE.TaxAmount));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DataAreaId');
        xmlEntry.innerText(_taxTableGTE.DataAreaId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('IsIncludedInPrice');
        xmlEntry.innerText(int2Str(_taxTableGTE.IsIncludedInPrice));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SaleLineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_taxTableGTE.SaleLineNum));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('StoreId');
        xmlEntry.innerText(_taxTableGTE.StoreId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxBasis');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_taxTableGTE.TaxBasis));
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxComponent');
        xmlEntry.innerText(_taxTableGTE.TaxComponent);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TaxGroup');
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TerminalId');
        xmlEntry.innerText(_taxTableGTE.TerminalId);
        result.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TransactionId');
        xmlEntry.innerText(_taxTableGTE.TransactionId);
        result.appendChild(xmlEntry);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineDiscountTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>DiscountLine</c> having the data of the <c>RetailTransactionDiscountTrans</c> table.
    /// </summary>
    /// <param name="_discountTrans">
    /// Table buffer of <c>RetailTransactionDiscountTrans</c> table.
    /// </param>
    /// <param name="_retailDiscount">
    /// Table buffer of <c>RetailPeriodicDiscount</c> table.
    /// </param>
    /// <param name="_salesQty">
    /// The sales quantity
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionDiscountTrans</c> table.
    /// * Members must be in order of the DiscountLine DataContract
    /// Example:
    ///    <DiscountLine>
    ///      <SaleLineNumber />
    ///      <OfferId />
    ///      <OfferName />
    ///      <DealPrice />
    ///      <Amount />
    ///      <Percentage />
    ///      <EffectiveAmount />
    ///      <Percentage />
    ///      <DiscountLineTypeValue />
    ///      <ManualDiscountTypeValue />
    ///      <CustomerDiscountTypeValue />
    ///      <PeriodicDiscountTypeValue />
    ///      <DiscountApplicationGroup />
    ///      <ConcurrencyModeValue />
    ///      <IsCompoundable />
    ///      <DiscountCode />
    ///      <DiscountCost />
    ///      <IsDiscountCodeRequired />
    ///      <ThresholdAmountRequired />
    ///    </DiscountLine>
    /// </returns>
    private static XmlElement fillSalesLineDiscountTrans(RetailTransactionDiscountTrans _discountTrans, RetailPeriodicDiscount _retailDiscount, SalesOrderedQty _salesQty, XmlDocument xmlDoc)
    {
        DiscAmount discountAmount;

        XmlElement xmlRecord, xmlEntry;
        xmlRecord = xmlDoc.createElement('DiscountLine');

        // Backfill discount amount for R2 customer orders.
        discountAmount = _discountTrans.DiscountAmount;
        if (!discountAmount && !_discountTrans.Percentage)
        {
            discountAmount = _salesQty ? _discountTrans.Amount / _salesQty : 0;
        }

        // Alphabetical order!!!

        xmlEntry = xmlDoc.createElement('BundleId');
        xmlEntry.innerText(int2str(_discountTrans.BundleId));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnAmount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(discountAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('CustomerDiscountTypeValue');
        xmlEntry.innerText(int2Str(_discountTrans.CustomerDiscountType));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnDealPrice);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_discountTrans.DealPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DiscountCode');
        xmlEntry.innerText(_discountTrans.DiscountCode);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DiscountCost');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_discountTrans.DiscountCost));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DiscountLineTypeValue');
        xmlEntry.innerText(int2Str(_discountTrans.DiscountOriginType));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('EffectiveAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_discountTrans.Amount));
        xmlRecord.appendChild(xmlEntry);

        if (RetailTransactionTransformerHelper::shouldAddMorePriceDetailsInfo() && RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            xmlEntry = xmlDoc.createElement(RetailTransactionTransformerHelper::getLineNumberStr());
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_discountTrans.AppliedDiscountLineNum));
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = xmlDoc.createElement('ManualDiscountTypeValue');
        xmlEntry.innerText(int2Str(_discountTrans.ManualDiscountType));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('OfferId');
        xmlEntry.innerText(_discountTrans.PeriodicDiscountOfferId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#OfferName);
        xmlEntry.innerText(_retailDiscount.Name);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnPercentage);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_discountTrans.Percentage));
        xmlRecord.appendChild(xmlEntry);

        if (RetailTransactionTransformerHelper::shouldAddMorePriceDetailsInfo() && RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            xmlEntry = xmlDoc.createElement(RetailTransactionTransformerHelper::getRecordIdStr());
            xmlEntry.innerText(int642Str(_discountTrans.DiscountLineRecId));
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = xmlDoc.createElement('SaleLineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_discountTrans.LineNum));
        xmlRecord.appendChild(xmlEntry);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLineNumberForDiscountLineXml</Name>
				<Source><![CDATA[
    internal protected static XmlElement addLineNumberForDiscountLineXml(XmlDocument _xmlDoc, XmlElement _xmlRecord, RetailSalesDiscountLine _discountLine)
    {
        return _xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRecordIdForDiscountLineXml</Name>
				<Source><![CDATA[
    internal protected static XmlElement addRecordIdForDiscountLineXml(XmlDocument _xmlDoc, XmlElement _xmlRecord, RetailSalesDiscountLine _discountLine)
    {
        return _xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesOrderAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>CustomerAddress</c> having the data of the <c>LogisticsPostalAddress</c> table.
    /// </summary>
    /// <param name="_deliveryAddress">
    /// Table buffer of <c>LogisticsPostalAddress</c> table.
    /// </param>
    /// <param name="_deliveryName">
    /// Delivery Name
    /// </param>
    /// <param name="_customerParty">
    /// Party associated with the customer.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_elementName">
    /// Element name of the xml node to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>LogisticsPostalAddress</c> table.
    /// * Members must be in order of the CustomerAddress DataContract
    /// Example:
    ///    <ShippingAddress>
    ///      <City />
    ///      <County />
    ///      <Name />
    ///      <DistrictName />
    ///      <State />
    ///      <Street />
    ///      <StreetNumber />
    ///      <ThreeLetterISORegionName />
    ///      <ZipCode />
    ///      <BuildingCompliment />
    ///      <FullAddress />
    ///      <Postbox />
    ///      <RecordId />
    ///    </ShippingAddress>
    /// </returns>
    internal static XmlElement fillSalesOrderAddress(LogisticsPostalAddress _deliveryAddress, str _deliveryName, DirPartyRecId _customerParty, XmlDocument xmlDoc, str _elementName = 'ShippingAddress')
    {
        XmlElement xmlAddress, xmlRecord;

        xmlAddress = xmlDoc.createElement(_elementName);

        xmlRecord = xmlDoc.createElement('BuildingCompliment');
        xmlRecord.innerText(_deliveryAddress.BuildingCompliment);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('City');
        xmlRecord.innerText(_deliveryAddress.City);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('County');
        xmlRecord.innerText(_deliveryAddress.County);
        xmlAddress.appendChild(xmlRecord);

        DirPartyLocation dirPartyLocation = RetailTransactionServiceTransactions::GetDirPartyLocationForCustomerPostalAddress(_deliveryAddress, _customerParty);

        if (RetailDirPartyLocationChangesFlight::instance().isEnabled())
        {
            xmlRecord = xmlDoc.createElement('DirectoryPartyLocationRecordId');
            xmlRecord.innerText(int642Str(dirPartyLocation.RecId));
            xmlAddress.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('DistrictName');
        xmlRecord.innerText(_deliveryAddress.DistrictName);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('FullAddress');
        xmlRecord.innerText(_deliveryAddress.Address);
        xmlAddress.appendChild(xmlRecord);

        LogisticsLocationRole logisticsLocationRole = RetailTransactionServiceTransactions::GetLogisticsLocationRoleForPostalAddress(_deliveryAddress);

        xmlRecord = xmlDoc.createElement('IsPrimary');
        xmlRecord.innerText(dirPartyLocation.isPrimary ? #TrueStr : #FalseStr);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('LogisticsLocationRoleRecordId');
        xmlRecord.innerText(int642Str(logisticsLocationRole.RecId));
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Name');
        xmlRecord.innerText(_deliveryName);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Postbox');
        xmlRecord.innerText(_deliveryAddress.PostBox);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('RecordId');
        xmlRecord.innerText(int642str(_deliveryAddress.RecId));
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('State');
        xmlRecord.innerText(_deliveryAddress.State);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Street');
        xmlRecord.innerText(_deliveryAddress.Street);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('StreetNumber');
        xmlRecord.innerText(_deliveryAddress.StreetNumber);
        xmlAddress.appendChild(xmlRecord);

        if (!RetailTaxKillSwitch::IsIgnoreTaxGroupOnShippingAddressInRecall())
        {
            LogisticsLocationExt locationExt;
            locationExt = LogisticsLocationExt::findByLogisticsPostalAddressRecId(_deliveryAddress.RecId);
            if (locationExt)
            {
                xmlRecord = xmlDoc.createElement('TaxGroup');
                xmlRecord.innerText(locationExt.TaxGroup);
                xmlAddress.appendChild(xmlRecord);
            }
        }

        xmlRecord = xmlDoc.createElement('ThreeLetterISORegionName');
        xmlRecord.innerText(_deliveryAddress.CountryRegionId);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ZipCode');
        xmlRecord.innerText(_deliveryAddress.ZipCode);
        xmlAddress.appendChild(xmlRecord);

        return xmlAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillRetailTransactionLineAddress</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>CustomerAddress</c> having the data of the <c>RetailTransactionAddressTrans</c> table.
    /// </summary>
    /// <param name="_addressTrans">
    /// Results from <c>RetailTransactionAddressTrans</c> table.
    /// </param>
    /// <param name="_deliveryName">
    /// Delivery Name
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_elementName">
    /// Element name of the xml node to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>LogisticsPostalAddress</c> table.
    /// * Members must be in order of the CustomerAddress DataContract
    /// Example:
    ///    <ShippingAddress>
    ///      <City />
    ///      <County />
    ///      <Name />
    ///      <DistrictName />
    ///      <State />
    ///      <Street />
    ///      <StreetNumber />
    ///      <ThreeLetterISORegionName />
    ///      <ZipCode />
    ///      <FullAddress />
    ///      <RecordId />
    ///    </ShippingAddress>
    /// </returns>
    internal static XmlElement fillRetailTransactionLineAddress(RetailTransactionAddressTrans _addressTrans, str _deliveryName, XmlDocument xmlDoc, str _elementName = 'ShippingAddress')
    {
        XmlElement xmlAddress, xmlRecord;
        LogisticsAddressing logisticsAddressing = LogisticsPostalAddressStringBuilder::buildAddressStringFromParameters(_addressTrans.postalAddressStringBuilderParameters());

        xmlAddress = xmlDoc.createElement(_elementName);

        xmlRecord = xmlDoc.createElement('BuildingCompliment');
        xmlRecord.innerText(_addressTrans.BuildingCompliment);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('City');
        xmlRecord.innerText(_addressTrans.City);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('County');
        xmlRecord.innerText(_addressTrans.County);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('DistrictName');
        xmlRecord.innerText(_addressTrans.DistrictName);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('FullAddress');
        xmlRecord.innerText(logisticsAddressing);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Name');
        xmlRecord.innerText(_deliveryName);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('RecordId');
        xmlRecord.innerText(int642str(_addressTrans.RecId));
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('State');
        xmlRecord.innerText(_addressTrans.State);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Street');
        xmlRecord.innerText(_addressTrans.Street);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('StreetNumber');
        xmlRecord.innerText(_addressTrans.StreetNumber);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ThreeLetterISORegionName');
        xmlRecord.innerText(_addressTrans.CountryRegionId);
        xmlAddress.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ZipCode');
        xmlRecord.innerText(_addressTrans.ZipCode);
        xmlAddress.appendChild(xmlRecord);

        return xmlAddress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesOrderDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a <c>SalesOrder</c> having the data of the <c>SalesTable</c> table.
    /// </summary>
    /// <param name="_salesTable">
    /// Table buffer of <c>SalesTable</c> table.
    /// </param>
    /// <param name="_rsoTable">
    /// Table buffer of <c>RetailSalesTable</c> table.
    /// </param>
    /// <param name="_custTable">
    /// Table buffer of <c>CustTable</c> table.
    /// </param>
    /// <param name="_transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether to include line details and order attributes.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="includeDiscount">
    /// Whether to include the discount details, by default is false
    /// </param>
    /// <param name="_elementName">
    /// Name of the element to be created.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>SalesTable</c> table.
    /// * Members must be in order of the SalesOrder DataContract
    /// Example:
    ///    <SalesOrder>
    ///      <AttributeValues />
    ///      <ChannelId />
    ///      <ChannelReferenceId />
    ///      <ChargeAmount />
    ///      <ChargeLines />
    ///      <CommissionSalesGroup />
    ///      <CreatedDateTime />
    ///      <CurrencyCode />
    ///      <CustomerId />
    ///      <CustomerOrderTypeValue />
    ///      <DeliveryMode />
    ///      <FiscalTransactions />
    ///      <GrossAmount />
    ///      <Id />
    ///      <InventoryLocationId />
    ///      <Name />
    ///      <NetAmountWithNoTax />
    ///      <PrepaymentAmountPaid />
    ///      <ReceiptEmail />
    ///      <ReceiptId />
    ///      <RequestedDeliveryDate />
    ///      <SalesId />
    ///      <SalesLines />
    ///      <ShippingAddress />
    ///      <StaffId />
    ///      <StoreId />
    ///      <SubtotalAmount />
    ///      <TaxAmount />
    ///      <TerminalId />
    ///      <TotalAmount />
    ///      <TotalDiscount />
    ///      <TransactionType />
    ///      <TransactionTypeValue />
    ///      <DocumentStatusValue />
    ///      <RecordId />
    ///      <Status />
    ///      <StatusValue />
    ///    </SalesOrder>
    /// </returns>
    public static XmlElement fillSalesOrderDetails(SalesTable _salesTable,
                                                    RetailSalesTable _rsoTable,
                                                    CustTable _custTable,
                                                    RetailTransactionTable _transactionTable,
                                                    boolean _includeDetails,
                                                    XmlDocument xmlDoc,
                                                    boolean includeDiscount = false,
                                                    str _elementName = #ElementSalesOrder)
    {
        XmlElement          xmlRoot, xmlRecord, xmlContainer;
        SalesTotals         salesTotals;
        AmountCur           totalAmount, totalTaxAmount, totalDiscountAmount, totalChargeAmount, subtotalAmount;
        AmountCur           prepaymentAmountPaid;
        LogisticsPostalAddress  deliveryAddress;
        SalesLine soLine;
        RetailSalesLine rsoLine;
        InventDim inventDim;
        MarkupTrans markupTrans;
        RetailSalesTableInstanceValue   retailSalesTableInstanceValue;
        EcoResAttribute                 ecoResAttribute;
        EcoResAttributeValue            ecoResAttributeValue;
        EcoResTextValue                 ecoResTextValue;
        RetailLoyaltyCard             retailLoyaltyCard;
        RetailTransactionFiscalTrans fiscalTrans;

        // Retrieve the sum of all invoiced sales lines amounts for the given Sales Id.
        AmountCur salesBalanceAmountInvoiced(SalesId _salesId)
        {
            return (select sum(SalesBalance) from CustInvoiceJour where CustInvoiceJour.RefNum == RefNum::SalesOrder && CustInvoiceJour.SalesId == _salesId).SalesBalance;
        }

        eventSource.EventWriteFillSalesOrderDetailsStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
        System.Diagnostics.Stopwatch salesOrderSW = new System.Diagnostics.Stopwatch();
        salesOrderSW.Start();

        eventSource.EventWriteSalesTotalsStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
        System.Diagnostics.Stopwatch totalsSW = new System.Diagnostics.Stopwatch();
        totalsSW.Start();

        SalesOrderTotals orderTotals;
        if (FeatureStateProvider::isFeatureEnabled(RetailEnableSalesOrderTotalsFeature::instance()))
        {
            orderTotals = SalesOrderTotals::find(_salesTable.SalesId);
        }
        
        if (orderTotals)
        {
            totalAmount         = orderTotals.OrderTotalAmount;
            totalTaxAmount      = orderTotals.OrderTotalTaxAmount;
            totalDiscountAmount = orderTotals.OrderTotalDiscountAmount;
            totalChargeAmount   = orderTotals.OrderTotalChargesAmount;
            subtotalAmount      = orderTotals.LineTotalAmount;
        }
        else
        {
            salesTotals     = SalesTotals::construct(_salesTable,SalesUpdate::All);
            salesTotals.calc();

            // totalAmount is the sales order balance due amount + previously invoiced amounts
            totalAmount     = salesTotals.totalAmount() + _salesTable.amountInvoiced();

            // totalTaxAmount is the sales order tax amount + any previously invoiced tax amounts. Same applies to charges and discounts.
            totalTaxAmount  = salesTotals.totalTaxAmount() + _salesTable.taxAmountInvoiced();
            totalDiscountAmount = salesTotals.totalLineDisc() + _salesTable.lineDiscInvoiced();
            totalChargeAmount = salesTotals.totalMarkup() + _salesTable.markupInvoiced();
            subtotalAmount      = salesTotals.totalBalance() + salesBalanceAmountInvoiced(_salesTable.SalesId);
        }
        totalsSW.Stop();
        eventSource.EventWriteSalesTotalsSalesTotalsFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), totalsSW.ElapsedMilliseconds);

        xmlRoot = xmlDoc.createElement(_elementName);

        RetailFillSalesOrderDetailsParameters headerParameters = RetailFillSalesOrderDetailsParameters::construct();
        headerParameters.xmlDoc = xmlDoc;
        headerParameters.xmlRoot = xmlRoot;
        headerParameters.salesTable = _salesTable;
        headerParameters.retailSalesTable = _rsoTable;
        headerParameters.custTable = _custTable;
        headerParameters.retailTransactionTable = _transactionTable;
        headerParameters.includeDetails = _includeDetails;
        headerParameters.includeDiscount = includeDiscount;

        RetailCustomerOrderExtensions::fillSalesOrderDetailsPrePopulate(headerParameters);

        // Begin properties on SalesTransaction entity
        // (Make sure you do not include SalesOrder properties here, or deserialization will break -- put them under the comment for SalesOrder)

        if (_includeDetails)
        {
            eventSource.EventWriteFillHeaderAttributesStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
            System.Diagnostics.Stopwatch attributesSW = new System.Diagnostics.Stopwatch();
            attributesSW.Start();

            xmlContainer = xmlDoc.createElement('AttributeValues');

            //Add attributes
            retailSalesTableInstanceValue = RetailSalesTableInstanceValue::findBySalesTable(_salesTable.SalesId, _salesTable.DataAreaId);
            // if this sales order has any attributes
            if ( retailSalesTableInstanceValue)
            {
                if (RetailUseLegacySalesOrderAttributesToggle::instance().isEnabled())
                {
                    //Get all attributes (Name and Text value) for this sales order
                    while select * from ecoResAttributeValue where ecoResAttributeValue.InstanceValue == retailSalesTableInstanceValue.RecId
                        join Name from ecoResAttribute where ecoResAttribute.RecId == ecoResAttributeValue.Attribute
                            join TextValue from ecoResTextValue where ecoResTextValue.RecId == ecoResAttributeValue.Value
                    {
                        xmlRecord = xmlDoc.createElement('AttributeTextValue');
                        xmlRecord.setAttribute('Name', ecoResAttribute.Name);
                        xmlRecord.setAttribute('TextValue', ecoResTextValue.TextValue);
                        xmlRoot.appendChild(xmlRecord);
                    }

                }
                else
                {
                    RetailTransactionSerializationContext context = RetailTransactionSerializationContext::current();
                    boolean includeAttributeValues = false;

                    if (context != null && context.parmIncludeAttributeValues())
                    {
                        includeAttributeValues = context.parmIncludeAttributeValues();
                    }

                    if (includeAttributeValues)
                    {
                        xmlContainer = RetailTransactionServiceTransactions::fillAttributeValues(retailSalesTableInstanceValue.RecId, xmlContainer, xmlDoc);
                    }
                }
            }

            xmlRoot.appendChild(xmlContainer);

            attributesSW.Stop();
            eventSource.EventWriteFillHeaderAttributesFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), attributesSW.ElapsedMilliseconds);
        }

        xmlRecord = xmlDoc.createElement('ChannelId');
        xmlRecord.innerText(int642str(_rsoTable.RetailChannel));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ChannelReferenceId');
        xmlRecord.innerText(_rsoTable.ChannelReferenceId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ChargeAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalChargeAmount));
        xmlRoot.appendChild(xmlRecord);

        if (_includeDetails)
        {
            eventSource.EventWriteFillHeaderChargesStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
            System.Diagnostics.Stopwatch chargesSW = new System.Diagnostics.Stopwatch();
            chargesSW.Start();

            //Add header level charges
            xmlContainer = xmlDoc.createElement('ChargeLines');
            if (_transactionTable && RetailTaxFillSalesOrderWithRetailTransactionTableFlight::instance().isEnabled())
            {
                RetailTransactionMarkupTrans retailChargeTrans;
                while select retailChargeTrans
                    where retailChargeTrans.TransactionId == _transactionTable.TransactionId
                    && retailChargeTrans.SaleLineNum == 0
                {
                    xmlRecord = RetailTransactionServiceTransactions::fillRetailChargeTrans(retailChargeTrans, xmlDoc);
                    xmlContainer.appendChild(xmlRecord);
                }
            }
            else
            {
                RetailTransactionServiceTransactions::addChargeLines(_salesTable.TableId, _salesTable.RecId, xmlDoc, xmlContainer);
            }

            xmlRoot.appendChild(xmlContainer);

            chargesSW.Stop();
            eventSource.EventWriteFillHeaderChargesFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), chargesSW.ElapsedMilliseconds);
        }

        xmlRecord = xmldoc.createElement('Comment');
        xmlRecord.innerText(_salesTable.CustomerRef);
        xmlRoot.appendChild(xmlRecord);

        if (_transactionTable)
        {
            xmlRecord = xmlDoc.createElement('CommissionSalesGroup');
            xmlRecord.innerText(_transactionTable.SalesGroup);
            xmlRoot.appendChild(xmlRecord);
        }

        if (_salesTable.ShippingDateConfirmed)
        {
            xmlRecord = xmlDoc.createElement('ConfirmedShipDate');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_salesTable.ShippingDateConfirmed, _rsoTable.RetailChannel));
            xmlRoot.appendChild(xmlRecord);
        }

        xmlContainer = xmlDoc.createElement('ContactInformationCollection');
        if (_salesTable.Email)
        {
            xmlRecord = RetailTransactionServiceTransactions::fillContactInformation(LogisticsElectronicAddressMethodType::Email, _salesTable.Email, xmlDoc);
            xmlContainer.appendChild(xmlRecord);
        }

        if (_salesTable.Phone)
        {
            xmlRecord = RetailTransactionServiceTransactions::fillContactInformation(LogisticsElectronicAddressMethodType::Phone, _salesTable.Phone, xmlDoc);
            xmlContainer.appendChild(xmlRecord);
        }

        xmlRoot.appendChild(xmlContainer);

        if (_salesTable.createdDateTime)
        {
            xmlRecord = xmlDoc.createElement('CreatedDateTime');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(_salesTable.CreatedDateTime));
            xmlRoot.appendChild(xmlRecord);
        }

        if (_salesTable)
        {
            xmlRecord = xmlDoc.createElement('CurrencyCode');
            xmlRecord.innerText(_salesTable.CurrencyCode);
            xmlRoot.appendChild(xmlRecord);
        }
        else
        {
            xmlRecord = xmlDoc.createElement('CurrencyCode');
            xmlRecord.innerText(_transactionTable.currency);
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('CustomerId');
        xmlRecord.innerText(_salesTable.CustAccount);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerOrderTypeValue');
        xmlRecord.innerText(int2str(RetailCustomerOrderType::Salesorder));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmldoc.createElement('CustomerRequisition');
        xmlRecord.innerText(_salesTable.PurchOrderFormNum);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('DeliveryMode');
        xmlRecord.innerText(_salesTable.DlvMode);
        xmlRoot.appendChild(xmlRecord);

        if (_transactionTable && _includeDetails)
        {
            eventSource.EventWriteFillFiscalTransactionsStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
            System.Diagnostics.Stopwatch fiscalSW = new System.Diagnostics.Stopwatch();
            fiscalSW.Start();

            xmlContainer = RetailTransactionServiceTransactions::fillFiscalTransactions(xmlDoc, _transactionTable.Channel,
                _transactionTable.store, _transactionTable.terminal, _transactionTable.transactionId);
            xmlRoot.appendChild(xmlContainer);

            fiscalSW.Stop();
            eventSource.EventWriteFillFiscalTransactionsFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), fiscalSW.ElapsedMilliseconds);
        }

        xmlRecord = xmlDoc.createElement('GrossAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Id');
        if (_transactionTable)
        {
            xmlRecord.innerText(_transactionTable.TransactionId);
        }
        else
        {
            xmlRecord.innerText(' ');
        }
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('InitialReceiptId');
        xmlRecord.innerText(_rsoTable.InitialReceiptId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('InventoryLocationId');
        xmlRecord.innerText(_salesTable.InventLocationId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('IsTaxIncludedInPrice');
        xmlRecord.innerText(int2str(enum2int(_salesTable.InclTax)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('LoyaltyCardId');
        retailLoyaltyCard = RetailLoyaltyCard::find(_rsoTable.RetailLoyaltyCard);
        xmlRecord.innerText(retailLoyaltyCard.CardNumber);
        xmlRoot.appendChild(xmlRecord);

        // Add LoyaltyRewardPoints
        xmlRoot.appendChild(RetailLoyaltyManager::FillLoyaltyRewardPointLinesForXmlWithSalesTable(_salesTable, xmlDoc));

        xmlRecord = xmlDoc.createElement('Name');
        if (_custTable.name() != '')
        {
            xmlRecord.innerText(_custTable.name());
        }
        else
        {
            xmlRecord.innerText(_salesTable.SalesName);
        }
        xmlRoot.appendChild(xmlRecord);

        if (_transactionTable)
        {
            xmlRecord = xmlDoc.createElement('NetAmountWithNoTax');
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(_transactionTable.netAmount * -1));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = xmlDoc.createElement('NetAmountWithTax');
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
            xmlRoot.appendChild(xmlRecord);
        }

        if (_includeDetails)
        {
            xmlRoot.appendChild(RetailTransactionServiceTransactions::addNotes(xmlDoc, _salesTable.RecId, _salesTable.TableId, _salesTable.DataAreaId));
        }

        // total invoice amounts paid
        prepaymentAmountPaid = RetailPrePaymentTrans::paymentsMade(_salesTable.SalesId);

        xmlRecord = xmlDoc.createElement('PrepaymentAmountPaid');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(prepaymentAmountPaid));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ReceiptEmail');
        xmlRecord.innerText(_salesTable.Email);
        xmlRoot.appendChild(xmlRecord);

        if (_transactionTable)
        {
            xmlRecord = xmlDoc.createElement('ReceiptId');
            xmlRecord.innerText(_transactionTable.ReceiptId);
            xmlRoot.appendChild(xmlRecord);
        }

        if (_salesTable.ReceiptDateRequested)
        {
            xmlRecord = xmlDoc.createElement('RequestedDeliveryDate');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::dateToDateTimeStringWithOffset(_salesTable.ReceiptDateRequested, _rsoTable.RetailChannel));
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('SalesAgreementRecordId');
        xmlRecord.innerText(int642Str(_salesTable.MatchingAgreement));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('SalesId');
        xmlRecord.innerText(_salesTable.SalesId);
        xmlRoot.appendChild(xmlRecord);

        xmlContainer = xmlDoc.createElement('SalesLines');

        if (_includeDetails)
        {
            eventSource.EventWriteFillSalesLinesStarted(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml));
            System.Diagnostics.Stopwatch slSW = new System.Diagnostics.Stopwatch();
            slSW.Start();

            while select * from soLine
                join inventDim where soLine.SalesId == _salesTable.SalesId
                    && inventDim.InventDimId == soLine.InventDimId
                outer join rsoLine where rsoLine.SalesLine == soLine.RecId
            {
                xmlRecord = RetailTransactionServiceTransactions::fillSalesLineDetails(_salesTable, _rsoTable, soLine, rsoLine, inventDim, xmlDoc, includeDiscount, _salesTable.RecId);
                xmlContainer.appendChild(xmlRecord);
            }

            slSW.Stop();
            eventSource.EventWriteFillSalesLinesFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), slSW.ElapsedMilliseconds);
        }

        xmlRoot.appendChild(xmlContainer);

        if (_includeDetails)
        {
            DirPartyRecId customerParty = CustTable::find(_salesTable.custAccount).Party;
            deliveryAddress = LogisticsPostalAddress::findRecId(_salesTable.DeliveryPostalAddress);
            if (deliveryAddress)
            {
                str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, _salesTable.DeliveryName);
                // Element name "ShippingAddress"
                xmlRecord = RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, deliveryName, customerParty, xmlDoc);
                xmlRoot.appendChild(xmlRecord);
            }
        }

        if (_transactionTable)
        {
            xmlRecord = xmlDoc.createElement('StaffId');
            xmlRecord.innerText(_transactionTable.Staff);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = xmlDoc.createElement('StoreId');
            xmlRecord.innerText(_transactionTable.Store);
            xmlRoot.appendChild(xmlRecord);

            if (!RetailTransactionSetSubtotalAmountFromSalesOrInvoiceLineFlight::instance().isEnabled())
            {
                if (salesTotals && RetailTransactionAcquireSubtotalFromSalesTotalsFlight::instance().isEnabled())  // this flight is enabled by default
                {
                    subtotalAmount = -1 * salesTotals.totalBalance();
                }
                else
                {
                    subtotalAmount = RetailTransactionServiceTransactions::getTransactionSubtotalAmount(
                    _transactionTable.TransactionId,
                    _transactionTable.DataAreaId,
                    _transactionTable.Channel,
                    _transactionTable.Terminal);
                }

                xmlRecord = xmlDoc.createElement('SubtotalAmount');
                xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(subtotalAmount * -1));
                xmlRoot.appendChild(xmlRecord);
            }
        }
        else if (!RetailTransactionSetSubtotalAmountFromSalesOrInvoiceLineFlight::instance().isEnabled())
        {
            // legacy, broken implementation, soon to be removed, left to prevent this fix regression
            // Subtotal Amount
            xmlRecord = xmldoc.createElement(SubtotalAmountNode);
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(salesTotals.totalBalance()));
            xmlRoot.appendChild(xmlRecord);

            // Subtotal Amount WithoutTax
            xmlRecord = xmldoc.createElement(SubtotalAmountWithoutTax);
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(salesTotals.totalAmount() - salesTotals.totalTaxAmount()));
            xmlRoot.appendChild(xmlRecord);

            // Subtotal Amount WithoutTax
            xmlRecord = xmldoc.createElement(SubtotalSalesAmount);
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(salesTotals.totalAmount()));
            xmlRoot.appendChild(xmlRecord);
        }

        if (RetailTransactionSetSubtotalAmountFromSalesOrInvoiceLineFlight::instance().isEnabled()) // this flight is enabled by default
        {
            // SubtotalAmount is the only property required.
            // Please note SubtotalAmountWithoutTax and SubtotalSalesAmount values are not required
            // as not consumed and easily constructed from other core properties, such as TotalAmount, TaxAmount, SubtotalAmount, etc.
            xmlRecord = xmldoc.createElement(SubtotalAmountNode);
            xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(subtotalAmount));
            xmlRoot.appendChild(xmlRecord);
        }


        xmlRecord = xmlDoc.createElement(TaxAmountNode);
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalTaxAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TenderLines');
        xmlRecord = RetailTransactionServiceTransactions::fillPaymentHistoryDetails(_salesTable.SalesId, xmlRecord, xmlDoc);
        xmlRoot.appendChild(xmlRecord);

        if (_transactionTable)
        {
            xmlRecord = xmlDoc.createElement('TerminalId');
            xmlRecord.innerText(_transactionTable.Terminal);
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('TotalAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TotalDiscount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(totalDiscountAmount));
        xmlRoot.appendChild(xmlRecord);

        if (_salesTable.SalesId != '')
        {
            // Assume it is a customer order
            xmlRecord = xmlDoc.createElement('TransactionType');
            xmlRecord.innerText(enum2str(RetailTransactionType::CustomerOrder));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = xmlDoc.createElement('TransactionTypeValue');
            xmlRecord.innerText(int2str(enum2int(RetailTransactionType::CustomerOrder)));
            xmlRoot.appendChild(xmlRecord);
        }
        else
        {
            xmlRecord = xmlDoc.createElement('TransactionType');
            xmlRecord.innerText(enum2str(RetailTransactionType::PendingSalesOrder));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = xmlDoc.createElement('TransactionTypeValue');
            xmlRecord.innerText(int2str(enum2int(RetailTransactionType::PendingSalesOrder)));
            xmlRoot.appendChild(xmlRecord);
        }

        // Begin properties on SalesOrder entity (subclass of SalesTransaction entity)

        if (_includeDetails && RetailImprovedPickupOrderProcessingInPosFeatureExposure::isEnabledInFeatureManagement())
        {
            xmlContainer = RetailTransactionServiceTransactions::fillInventoryQuantities(xmlDoc, _salesTable.SalesId);
            xmlRoot.appendChild(xmlContainer);
        }

        if (RetailAllowPartialOrderEditingFeatureExposure::isEnabledInFeatureManagement()
            || RetailImprovedRecallOrderOperationInPosFeatureExposure::isEnabledInFeatureManagement())
        {
            xmlRecord = xmlDoc.createElement('DetailedOrderStatusValue');
            int detailedOrderStatusValue = enum2int(RetailDetailedOrderInfoHelper::getDetailedOrderStatus(_salesTable));
            xmlRecord.innerText(int2Str(detailedOrderStatusValue));
            xmlRoot.appendChild(xmlRecord);
        }

        xmlRecord = xmlDoc.createElement('DocumentStatusValue');
        xmlRecord.innerText(int2str(enum2int(_salesTable.DocumentStatus)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('RecordId');
        xmlRecord.innerText(int642str(_salesTable.RecId));
        xmlRoot.appendChild(xmlRecord);

        if (_salesTable.SalesId != '')
        {
            // fill shipments.
            xmlContainer = RetailTransactionServiceOrders::fillOrderShipments(xmlDoc, _salesTable.SalesId);
            xmlRoot.appendChild(xmlContainer);
        }

        xmlRecord = xmlDoc.createElement('Status');
        xmlRecord.innerText(enum2str(_salesTable.SalesStatus));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('StatusValue');
        xmlRecord.innerText(int2str(RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(_salesTable.SalesStatus)));
        xmlRoot.appendChild(xmlRecord);

        salesOrderSW.Stop();
        eventSource.EventWriteFillSalesOrderDetailsFinished(_salesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), RetailTransactionServiceResultFormat::Xml), salesOrderSW.ElapsedMilliseconds);

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// </summary>
    /// <param name="transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionSalesTrans</c> table.
    /// Example:
    /// <ArrayOfTransactionItem>
    ///   <TransactionItem>
    ///    <TransactionId />
    ///    <Store></Store>
    ///    <TerminalId></TerminalId>
    ///    <ReceiptId></ReceiptId>
    ///    <LineNumber></LineNumber>
    ///    <ListingId></ListingId>
    ///    <Barcode></Barcode>
    ///    <ItemId></ItemId>
    ///    <VariantId />
    ///    <Status />
    ///    <Comment></Comment>
    ///    <InventBatchId></InventBatchId>
    ///    <ReturnQuantity />
    ///    <Price></Price>
    ///    <NetPrice></NetPrice>
    ///    <Quantity></Quantity>
    ///    <TaxGroup />
    ///    <TaxAmount />
    ///    <TotalDiscountAmount />
    ///    <TotalDiscountPercentage />
    ///    <LineDiscountAmount></LineDiscountAmount>
    ///    <Unit />
    ///    <UnitQuantity />
    ///    <InventSerialId></InventSerialId>
    ///    <RFIDTagId />
    ///    <OriginalTaxGroup></OriginalTaxGroup>
    ///    <TaxItemGroup />
    ///    <OriginalTaxItemGroup></OriginalTaxItemGroup>
    ///    <PeriodicDiscountType></PeriodicDiscountType>
    ///    <PeriodicDiscountAmount />
    ///    <DiscountAmount />
    ///  </TransactionItem>
    ///</ArrayOfTransactionItem>
    /// </returns>
    /// <remarks>
    ///  C# SalesLine fields must be sorted alphabetically
    /// </remarks>
    private static str fillSalesTrans(RetailTransactionTable transactionTable)
    {
        RetailTransactionSalesTrans     transactionSalesTrans;
        RetailTransactionTaxTransGTE    transTaxTransGTE;
        NoYes                           isTaxIncludedInPrice;
        XmlDocument         xmlDoc;
        XmlElement          xmlRoot,xmlRecord,xmlEntry;

        xmlDoc = XmlDocument::newBlank('Unicode');
        xmlRoot = xmlDoc.createElement('ArrayOfTransactionItem');

        while select    TransactionId, Store, TerminalId, ReceiptId, LineNum, ListingId,
                        Barcode, ItemId, VariantId, TransactionStatus, Comment, SalesGroup,
                        InventBatchId, ReturnQty, Price, NetPrice, NetAmount, NetAmountInclTax, Qty,
                        TaxGroup, TaxAmount, TotalDiscAmount, TotalDiscPct, LineDscAmount,
                        PeriodicDiscAmount, DiscAmount, DiscAmountWithoutTax, Unit, UnitQty, InventSerialId,
                        PeriodicPercentageDiscount, LineManualDiscountAmount, LineManualDiscountPercentage,
                        rfidTagId, OriginalTaxGroup, TaxItemGroup, OriginalTaxItemGroup, PeriodicDiscType,
                        originalPrice, priceChange, Channel
                        // <GEERU>
                        , LoyaltyDiscPct_RU
                        // </GEERU>
                        from transactionSalesTrans
            where transactionSalesTrans.TransactionId   == transactionTable.TransactionId
                && transactionSalesTrans.Store           == transactionTable.Store
                && transactionSalesTrans.TerminalId      == transactionTable.Terminal
                && transactionSalesTrans.ReceiptId       == transactionTable.ReceiptId
        {
            xmlRecord = xmlDoc.createElement('TransactionItem');

            xmlEntry = xmlDoc.createElement('TransactionId');
            xmlEntry.innerText(transactionSalesTrans.TransactionId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Store');
            xmlEntry.innerText(transactionSalesTrans.Store);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TerminalId');
            xmlEntry.innerText(transactionSalesTrans.TerminalId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ReceiptId');
            xmlEntry.innerText(transactionSalesTrans.ReceiptId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('LineNumber');
            xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(transactionSalesTrans.LineNum));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ListingId');
            xmlEntry.innerText(transactionSalesTrans.ListingId ? transactionSalesTrans.ListingId : '0');
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Barcode');
            xmlEntry.innerText(transactionSalesTrans.Barcode);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ItemId');
            xmlEntry.innerText(transactionSalesTrans.ItemId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('VariantId');
            xmlEntry.innerText(transactionSalesTrans.VariantId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Status');
            xmlEntry.innerText(int2str(enum2int(transactionSalesTrans.TransactionStatus)));
            xmlRecord.appendChild(xmlEntry);

            ///  C# SalesLine fields must be sorted alphabetically
            xmlEntry = xmlDoc.createElement('Comment');
            xmlEntry.innerText(transactionSalesTrans.Comment);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('CommissionSalesGroup');
            xmlEntry.innerText(transactionSalesTrans.SalesGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('InventBatchId');
            xmlEntry.innerText(transactionSalesTrans.InventBatchId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('ReturnQuantity');
            real returnedQuantity = 0;
            if (RetailUnifiedReturnsFeatureExposure::isEnabled())
            {
                returnedQuantity = RetailReturnedQuantities::find(
                    transactionSalesTrans.transactionId,
                    transactionSalesTrans.lineNum, 
                    transactionSalesTrans.store, 
                    transactionSalesTrans.terminalId, 
                    transactionSalesTrans.Channel).ReturnedQty * -1;
                returnedQuantity += transactionSalesTrans.returnQty; // add sales trans quantity for backwards compatibility
            }
            else
            {
                returnedQuantity = transactionSalesTrans.returnQty;
            }
            xmlEntry.innerText(num2str(returnedQuantity,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Price');
            xmlEntry.innerText(num2str(transactionSalesTrans.Price,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('NetPrice');
            xmlEntry.innerText(num2str(transactionSalesTrans.NetPrice,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('NetAmount');
            xmlEntry.innerText(num2str(transactionSalesTrans.NetAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('NetAmountInclusiveTax');
            xmlEntry.innerText(num2str(transactionSalesTrans.NetAmountInclTax,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Quantity');
            xmlEntry.innerText(num2str(transactionSalesTrans.Qty,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(TaxAmountNode);
            xmlEntry.innerText(num2str(transactionSalesTrans.TaxAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TaxGroup');
            xmlEntry.innerText(transactionSalesTrans.TaxGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TaxRatePercent');
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TaxRatePercent));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TotalDiscountAmount');
            xmlEntry.innerText(num2str(transactionSalesTrans.TotalDiscAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TotalDiscountPercentage');
            xmlEntry.innerText(num2str(transactionSalesTrans.TotalDiscPct,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('LineDiscountAmount');
            xmlEntry.innerText(num2str(transactionSalesTrans.LineDscAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('PeriodicDiscountAmount');
            xmlEntry.innerText(num2str(transactionSalesTrans.PeriodicDiscAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(#ColumnPeriodicPercentageDiscount);
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.PeriodicPercentageDiscount));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(#ColumnLineManualDiscountAmount);
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.LineManualDiscountAmount));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(#ColumnLineManualDiscountPercentage);
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.LineManualDiscountPercentage));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(discAmountColumn);
            xmlEntry.innerText(num2str(transactionSalesTrans.DiscAmount,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement(discAmountWithoutTaxColumn);
            xmlEntry.innerText(num2str(transactionSalesTrans.discAmountWithoutTax,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('Unit');
            xmlEntry.innerText(transactionSalesTrans.Unit);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('UnitQuantity');
            xmlEntry.innerText(num2str(transactionSalesTrans.UnitQty,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('InventSerialId');
            xmlEntry.innerText(transactionSalesTrans.InventSerialId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('RFIDTagId');
            xmlEntry.innerText(transactionSalesTrans.rfidTagId);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('OriginalTaxGroup');
            xmlEntry.innerText(transactionSalesTrans.OriginalTaxGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('TaxItemGroup');
            xmlEntry.innerText(transactionSalesTrans.TaxItemGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('OriginalTaxItemGroup');
            xmlEntry.innerText(transactionSalesTrans.OriginalTaxItemGroup);
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('PeriodicDiscountType');
            xmlEntry.innerText(int2str(enum2int(transactionSalesTrans.PeriodicDiscType)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('OriginalPrice');
            xmlEntry.innerText(num2str(transactionSalesTrans.originalPrice,5,3,1,0));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('PriceChange');
            xmlEntry.innerText(int2str(enum2int(transactionSalesTrans.priceChange)));
            xmlRecord.appendChild(xmlEntry);

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                xmlEntry = xmlDoc.createElement('LoyaltyDiscountPercentage');
                xmlEntry.innerText(num2str(transactionSalesTrans.LoyaltyDiscPct_RU,5,3,1,0));
                xmlRecord.appendChild(xmlEntry);
            }
            // </GEERU>

            xmlRoot.appendChild(xmlRecord);
        }

        xmlDoc.appendChild(xmlRoot);
        return xmlDoc.toString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillCustAccountTransDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>customer account deposit lines</c> having the data of the <c>RetailTransactionCustomerAccountDepositTrans</c> table.
    /// </summary>
    /// <param name="transactionCustomerAccountDepositTrans">
    /// Table buffer of <c>RetailTransactionCustomerAccountDepositTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionCustomerAccountDepositTrans</c> table.
    /// * Members must be in order of the CustomerAccountDepositLine DataContract
    /// Example:
    ///    <CustomerAccountDepositLine>
    ///      <Amount />
    ///      <Comment />
    ///      <CustomerAccount />
    ///      <Shift />
    ///      <StoreNumber />
    ///      <Terminal />
    ///      <TransactionStatusValue />
    ///    </CustomerAccountDepositLine>
    /// </returns>
    private static XmlElement fillCustAccountTransDetails(
        RetailTransactionCustomerAccountDepositTrans transactionCustomerAccountDepositTrans,
        XmlDocument xmlDoc)
    {
        XmlElement xmlEntry, xmlRecord;

        xmlRecord = xmlDoc.createElement('CustomerAccountDepositLine');

        xmlEntry = xmlDoc.createElement('Amount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionCustomerAccountDepositTrans.amount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Comment');
        xmlEntry.innerText(transactionCustomerAccountDepositTrans.comment);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('CustomerAccount');
        xmlEntry.innerText(transactionCustomerAccountDepositTrans.custAccount);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Shift');
        xmlEntry.innerText(transactionCustomerAccountDepositTrans.shift);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('StoreNumber');
        xmlEntry.innerText(transactionCustomerAccountDepositTrans.store);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Terminal');
        xmlEntry.innerText(transactionCustomerAccountDepositTrans.terminal);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TransactionStatusValue');
        xmlEntry.innerText(int2Str(transactionCustomerAccountDepositTrans.transactionStatus));
        xmlRecord.appendChild(xmlEntry);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesTransDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// </summary>
    /// <param name="transactionSalesTrans">
    /// Table buffer of <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="includeAttributes">
    /// Whether to include the line attributes, by default is false.
    /// </param>
    /// <param name="includeDiscount">
    /// Whether to include the discount details, by default is false
    /// </param>
    /// <param name="includeTaxLines">
    /// Whether to include the tax details, by default is false.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionSalesTrans</c> table.
    /// * Members must be in order of the SalesLine DataContract
    /// Example:
    ///    <SalesLine>
    ///      <ItemId />
    ///      <ItemTaxGroupId />
    ///      <NetAmount />
    ///      <Price />
    ///      <Quantity />
    ///      <SalesOrderUnitOfMeasure />
    ///      <SalesTaxGroupId />
    ///      <TaxAmount />
    ///      <DiscountAmount />
    ///      <LineDiscount />
    ///      <LineNumber />
    ///      <ListingId />
    ///      <PeridicDiscount />
    ///      <ReturnQuantity />
    ///      <SalesDate />
    ///      <Store />
    ///      <TerminalId />
    ///      <StatusValue />
    ///      <TotalDiscount />
    ///      <TotalPercentageDiscount />
    ///      <VariantInventoryDimensionId />
    ///    </SalesLine>
    /// </returns>
    [Wrappable(true)]
    protected final static XmlElement fillSalesTransDetails(
        RetailTransactionSalesTrans transactionSalesTrans,
        XmlDocument xmlDoc,
        boolean _includeAttributes,
        boolean includeDiscount = false,
        boolean includeTaxLines = false)
    {
        XmlElement xmlEntry, xmlRecord, xmlContainer, xmlChargeLinesContainer, predecessorForIsWarrantyLine;
        RetailTransactionDiscountTrans discountTrans;
        RetailTransactionTaxTrans taxTransTable;
        InventDimCombination inventDimComb;
        InventTable inventTable;
        str listingId;

        RetailPeriodicDiscount retailDiscount;

        boolean hasLineDiscountLines = false;
        boolean hasTotalDiscountLines = false;
        boolean hasPeriodicDiscountLines = false;
        boolean hasTenderDiscountLines = false;

        RetailTransactionMarkupTrans chargeTable;

        xmlRecord = xmlDoc.createElement('SalesLine');

        // DataContractSerializer requires fields to be ordered (base types first, alphabetic)
        // See https://docs.microsoft.com/en-us/dotnet/framework/wcf/feature-details/data-member-order

        RetailFillSalesTransDetailsParameters lineParameters = RetailFillSalesTransDetailsParameters::construct();
        lineParameters.xmlDoc = xmlDoc;
        lineParameters.xmlRecord = xmlRecord;
        lineParameters.retailTransactionSalesTrans = transactionSalesTrans;
        lineParameters.includeAttributes = _includeAttributes;
        lineParameters.includeDiscount = includeDiscount;
        lineParameters.includeTaxLines = includeTaxLines;

        RetailCustomerOrderExtensions::fillSalesTransDetailsPrePopulate(lineParameters);

        // XML tags for TaxableItem (base class)

        xmlEntry = xmlDoc.createElement('ItemId');
        xmlEntry.innerText(transactionSalesTrans.itemId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ItemTaxGroupId');
        xmlEntry.innerText(transactionSalesTrans.TaxItemGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('NetAmount');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.NetAmount * -1));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('NetAmountWithAllInclusiveTax');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.NetAmountInclTax * -1));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Price');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.Price));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Quantity');
        xmlEntry.innerText(RetailTransactionServiceUtilities::qtyToString(transactionSalesTrans.Qty * -1));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SalesOrderUnitOfMeasure');
        xmlEntry.innerText(transactionSalesTrans.Unit);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SalesTaxGroupId');
        xmlEntry.innerText(transactionSalesTrans.TaxGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxAmountNode);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TaxAmount * -1));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxExemptPriceInclusiveOriginalPrice);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TaxExemptPriceInclusiveOriginalPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(TaxExemptPriceInclusiveReductionAmount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TaxExemptPriceInclusiveReductionAmount));
        xmlRecord.appendChild(xmlEntry);

        if (includeTaxLines)
        {
            xmlContainer = xmlDoc.createElement('TaxLines');

            // Add tax Lines
            if (transactionSalesTrans.transactionTable().TaxCalculationType == TaxCalculationType::GTE)
            {
                RetailTransactionTaxTransGTE taxTransGTE;

                while select taxTransGTE
                where taxTransGTE.TransactionId == transactionSalesTrans.TransactionId
                    && taxTransGTE.SaleLineNum == transactionSalesTrans.lineNum
                    && taxTransGTE.Channel == transactionSalesTrans.Channel
                    && taxTransGTE.StoreId == transactionSalesTrans.Store
                    && taxTransGTE.TerminalId == transactionSalesTrans.terminalId
                    && taxTransGTE.DataAreaId == transactionSalesTrans.DataAreaId
                {
                    // Fill in tax data
                    xmlEntry = RetailTransactionServiceTransactions::fillSalesLineTaxTransGTE(taxTransGTE, transactionSalesTrans, xmlDoc);
                    xmlContainer.appendChild(xmlEntry);
                }
            }
            else
            {
                while select taxTransTable
                where taxTransTable.TransactionId == transactionSalesTrans.TransactionId
                    && taxTransTable.SaleLineNum == transactionSalesTrans.lineNum
                    && taxTransTable.Channel == transactionSalesTrans.Channel
                    && taxTransTable.StoreId == transactionSalesTrans.Store
                    && taxTransTable.TerminalId == transactionSalesTrans.terminalId
                    && taxTransTable.DataAreaId == transactionSalesTrans.DataAreaId
                {
                    // Fill in tax data
                    xmlEntry = RetailTransactionServiceTransactions::fillSalesLineTaxTrans(taxTransTable, transactionSalesTrans, xmlDoc);
                    xmlContainer.appendChild(xmlEntry);
                }
            }

            xmlRecord.appendChild(xmlContainer);
        }

        xmlEntry = xmlDoc.createElement('TaxRatePercent');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TaxRatePercent));
        xmlRecord.appendChild(xmlEntry);

        // XML tags for SalesLine (extends TaxableItem class)
        if (_includeAttributes)
        {
            xmlEntry = RetailTransactionServiceTransactions::populateTransactionAttributes(
                xmlDoc, transactionSalesTrans.transactionId, transactionSalesTrans.terminalId, transactionSalesTrans.store, transactionSalesTrans.Channel, transactionSalesTrans.lineNum, transactionSalesTrans.DataAreaId);
            
            if (xmlEntry)
            {
                xmlRecord.appendChild(xmlEntry);
            }
        }

        if (transactionSalesTrans.barcode)
        {
            xmlEntry = xmlDoc.createElement('Barcode');
            xmlEntry.innerText(transactionSalesTrans.barcode);
            xmlRecord.appendChild(xmlEntry);
        }

        //This catalogid is being used in SalesLine as column name Catalog.
        xmlEntry = xmlDoc.createElement('CatalogId');
        xmlEntry.innerText(int642str(transactionSalesTrans.Catalog));
        xmlRecord.appendChild(xmlEntry);

        if (RetailParameters::isRetailAutoChargesEnabledAndInUse())
        {
            xmlChargeLinesContainer = xmlDoc.createElement('ChargeLines');

            // Select all charges matching the sales line and aggregate by business key.
            while select sum(Value), sum(CalculatedAmount), sum(TaxAmount), sum(TaxExemptPriceInclusiveOriginalPrice), sum(TaxExemptPriceInclusiveReductionAmount), MarkupCode, ModuleType, TaxGroup, TaxItemGroup, CurrencyCode from chargeTable
            group by chargeTable.MarkupCode, chargeTable.ModuleType, chargeTable.TaxGroup, chargeTable.TaxItemGroup, chargeTable.CurrencyCode
                where chargeTable.Channel == transactionSalesTrans.Channel
                && chargeTable.store == transactionSalesTrans.store
                && chargeTable.terminalId == transactionSalesTrans.terminalId
                && chargeTable.transactionId == transactionSalesTrans.transactionId
                && chargeTable.saleLineNum == transactionSalesTrans.lineNum
            {
                chargeTable = RetailTransactionServiceTransactions::subtractPreviouslyReturnedChargeAmountFromLineCharge(chargeTable, transactionSalesTrans);

                if (chargeTable.CalculatedAmount > 0)
                {
                    xmlEntry = RetailTransactionServiceTransactions::fillRetailTransactionMarkupTrans(chargeTable, xmlDoc);
                    xmlChargeLinesContainer.appendChild(xmlEntry);
                }
            }

            xmlRecord.appendChild(xmlChargeLinesContainer);
        }

        xmlEntry = xmlDoc.createElement('Comment');
        xmlEntry.innerText(transactionSalesTrans.comment);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('CommissionSalesGroup');
        xmlEntry.innerText(transactionSalesTrans.SalesGroup);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('DeliveryMode');
        xmlEntry.innerText(transactionSalesTrans.DlvMode);
        xmlRecord.appendChild(xmlEntry);

        if (RetailRealTimeServiceForSalesTransDiscountAmountFlight::instance().isEnabled())
        {
            xmlEntry = xmlDoc.createElement('DiscountAmount');
            xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.discAmount));
            xmlRecord.appendChild(xmlEntry);
        }

        xmlEntry = xmlDoc.createElement(discAmountWithoutTaxColumn);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.discAmountWithoutTax));
        xmlRecord.appendChild(xmlEntry);

        if (includeDiscount)
        {
            xmlContainer = xmlDoc.createElement('DiscountLines');
            // Add discount data
            while select discountTrans
                where discountTrans.SaleLineNum == transactionSalesTrans.lineNum
                && discountTrans.TransactionId == transactionSalesTrans.transactionId
                && discountTrans.TerminalId == transactionSalesTrans.terminalId
                && discountTrans.StoreId == transactionSalesTrans.store
            outer join Name from retailDiscount
                where discountTrans.PeriodicDiscountOfferId
                    && retailDiscount.OfferId == discountTrans.PeriodicDiscountOfferId
            {
                // Fill in discount data
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountTrans(discountTrans, retailDiscount, transactionSalesTrans.qty, xmlDoc);
                xmlContainer.appendChild(xmlEntry);

                if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Periodic)
                {
                    hasPeriodicDiscountLines = true;
                }
                else if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Customer)
                {
                    if (discountTrans.CustomerDiscountType != RetailCustomerDiscountType::TotalDiscount)
                    {
                        hasLineDiscountLines = true;
                    }
                    else
                    {
                        hasTotalDiscountLines = true;
                    }
                }
                else if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Manual)
                {
                    if (discountTrans.ManualDiscountType == RetailManualDiscountType::LineDiscountAmount ||
                        discountTrans.ManualDiscountType == RetailManualDiscountType::LineDiscountPercent)
                    {
                        hasLineDiscountLines = true;
                    }
                    else
                    {
                        hasTotalDiscountLines = true;
                    }
                }
                else if (discountTrans.DiscountOriginType == RetailDiscountOriginType::Tender)
                {
                    hasTenderDiscountLines = true;
                }
            }

            // Backfill periodic discount transaction.
            retailDiscount.clear();
            if (transactionSalesTrans.periodicDiscAmount && !hasPeriodicDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(transactionSalesTrans, true, false, false);
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountTrans(discountTrans, retailDiscount, transactionSalesTrans.qty, xmlDoc);
                xmlContainer.appendChild(xmlEntry);
            }

            // Backfill tender discount transaction.
            retailDiscount.clear();
            if (transactionSalesTrans.TenderDiscountAmount && !hasTenderDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(transactionSalesTrans, false, false, false);
                discountTrans.Amount = transactionSalesTrans.TenderDiscountAmount;
                if (transactionSalesTrans.qty != 0)
                {
                    discountTrans.DiscountAmount = discountTrans.Amount / transactionSalesTrans.qty;
                }
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountTrans(discountTrans, retailDiscount, transactionSalesTrans.qty, xmlDoc);
                xmlContainer.appendChild(xmlEntry);
            }

            // Backfill customer line discount transaction.
            if (transactionSalesTrans.lineDscAmount && !hasLineDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(transactionSalesTrans, false, true, false);
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountTrans(discountTrans, retailDiscount, transactionSalesTrans.qty, xmlDoc);
                xmlContainer.appendChild(xmlEntry);
            }

            // Backfill customer total discount transaction.
            if (transactionSalesTrans.totalDiscAmount && !hasTotalDiscountLines)
            {
                discountTrans = RetailTransactionServiceTransactions::backfillDiscountTrans(transactionSalesTrans, false, false, true);
                xmlEntry = RetailTransactionServiceTransactions::fillSalesLineDiscountTrans(discountTrans, retailDiscount, transactionSalesTrans.qty, xmlDoc);
                xmlContainer.appendChild(xmlEntry);
            }

            xmlRecord.appendChild(xmlContainer);
        }

        if (transactionSalesTrans.VariantId)
        {
            select firstonly DistinctProductVariant, InventDimId from inventDimComb
                where inventDimComb.ItemId == transactionSalesTrans.ItemId
                && inventDimComb.RetailVariantId == transactionSalesTrans.VariantId
                && inventDimComb.DataAreaId == transactionSalesTrans.DataAreaId;

            xmlEntry = xmlDoc.createElement('InventoryDimensionId');
            xmlEntry.innerText(inventDimComb.InventDimId);
            xmlRecord.appendChild(xmlEntry);
        }
        xmlEntry = xmlDoc.createElement('IsGiftCardLine');
        xmlEntry.innerText(int2Str(transactionSalesTrans.giftcard));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('IsPriceOverridden');
        xmlEntry.innerText(int2str(enum2int(transactionSalesTrans.priceChange)));
        predecessorForIsWarrantyLine = xmlRecord.appendChild(xmlEntry);

        RetailReturnedQuantities returnedQuantities;
        if (RetailUnifiedReturnsFeatureExposure::isEnabled())
        {
            returnedQuantities = RetailReturnedQuantities::find(transactionSalesTrans.transactionId,
                    transactionSalesTrans.lineNum, transactionSalesTrans.store, transactionSalesTrans.terminalId, transactionSalesTrans.Channel);

            if (returnedQuantities.RecId && returnedQuantities.LastReturnProcessedTime > DateTimeUtil::minValue())
            {
                xmlEntry = xmlDoc.createElement('LastReturnProcessedTime');
                xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
                xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(returnedQuantities.LastReturnProcessedTime));
                xmlRecord.appendChild(xmlEntry);
            }
        }

        xmlEntry = xmlDoc.createElement(#ColumnLineDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.LineDscAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnLineManualDiscountAmount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.LineManualDiscountAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnLineManualDiscountPercentage);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.LineManualDiscountPercentage));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('LineNumber');
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(transactionSalesTrans.LineNum));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(ColumnLinePercentageDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.LinePercentageDiscount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ListingId');
        if (transactionSalesTrans.ListingId != '')
        {
            xmlEntry.innerText(transactionSalesTrans.ListingId);
        }
        else if (transactionSalesTrans.VariantId)
        {
            xmlEntry.innerText(inventDimComb.DistinctProductVariant ? int642str(inventDimComb.DistinctProductVariant) : '0');
        }
        else
        {
            select firstonly Product from inventTable
                where inventTable.ItemId == transactionSalesTrans.ItemId
                && inventTable.DataAreaId == transactionSalesTrans.DataAreaId;
            xmlEntry.innerText(inventTable.Product ? int642str(inventTable.Product) : '0');
        }
        listingId = xmlEntry.innerText();
        xmlRecord.appendChild(xmlEntry);

        // Add LoyaltyRewardPointLines
        xmlRecord.appendChild(RetailLoyaltyManager::FillLoyaltyRewardPointLinesForXmlWithRetailTransactionSalesLine(transactionSalesTrans, xmlDoc));

        xmlEntry = xmlDoc.createElement(netPriceColumn);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.netPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('OriginalPrice');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.OriginalPrice));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnPeriodicDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.PeriodicDiscAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnPeriodicPercentageDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.PeriodicPercentageDiscount));
        xmlRecord.appendChild(xmlEntry);

        if (transactionSalesTrans.PickupEndTime > 0)
        {
            // Formatted as yyyy-MM-ddTHH:mm:ss
            xmlEntry = xmlDoc.createElement('PickupTimeslotEndDateTime');
            xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(DateTimeUtil::newDateTime(transactionSalesTrans.ShippingDateRequested, transactionSalesTrans.PickupEndTime)));
            xmlRecord.appendChild(xmlEntry);

            xmlEntry = xmlDoc.createElement('PickupTimeslotStartDateTime');
            xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(DateTimeUtil::newDateTime(transactionSalesTrans.ShippingDateRequested, transactionSalesTrans.PickupStartTime)));
            xmlRecord.appendChild(xmlEntry);
        }

        if (!RetailTransactionXmlSkipPriceLineFlight::instance().isEnabled() && RetailTransactionServiceOrderSyncPriceDetailsFlight::instance().isEnabled())
        {
            RetailTransactionServiceTransactions::fillSalesTransWithPriceDetails(transactionSalesTrans, xmlDoc, xmlRecord);
        }

        //ProductId is a copy of ListingId
        xmlEntry = xmlDoc.createElement('ProductId');
        xmlEntry.innerText(listingId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('ReturnQuantity');
        real returnedQuantity = 0;
        if (RetailUnifiedReturnsFeatureExposure::isEnabled() && returnedQuantities.RecId)
        {
            returnedQuantity = returnedQuantities.ReturnedQty + (transactionSalesTrans.returnQty * -1); // add sales trans quantity for backwards compatibility
        }
        else
        {
            returnedQuantity = transactionSalesTrans.returnQty * -1;
        }
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(returnedQuantity));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('SalesDate');
        xmlEntry.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
        xmlEntry.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(
            DateTimeUtil::newDateTime(transactionSalesTrans.transDate,
            transactionSalesTrans.transTime,
            RetailChannelTable::findByRecId(transactionSalesTrans.Channel).ChannelTimeZone))); // DateTimeOffset? SalesDate
        xmlRecord.appendChild(xmlEntry);
        
        xmlEntry = xmlDoc.createElement('SerialNumber');
        xmlEntry.innerText(transactionSalesTrans.InventSerialId);
        xmlRecord.appendChild(xmlEntry);
        
        DirPartyTable partyTable = DirPartyTable::findRec(CustTable::find(transactionSalesTrans.custAccount).Party);
        LogisticsPostalAddress deliveryAddress = LogisticsPostalAddress::findRecId(transactionSalesTrans.LogisticsPostalAddress);
        if (deliveryAddress)
        {
            str deliveryName = RetailTransactionServiceTransactions::GetDeliveryAddressName(deliveryAddress, partyTable.Name);
            xmlEntry = RetailTransactionServiceTransactions::fillSalesOrderAddress(deliveryAddress, deliveryName, partyTable.RecId, xmlDoc);
            xmlRecord.appendChild(xmlEntry);
        }
        else
        {
            RetailTransactionTable transactionTable = RetailTransactionTable::findByUniqueKey(transactionSalesTrans.transactionId, transactionSalesTrans.channel, transactionSalesTrans.store, transactionSalesTrans.terminalId);
            RetailTransactionAddressTrans addressTrans = RetailTransactionTransformer::getAddressLineFromTransaction(transactionTable, transactionSalesTrans.lineNum);
            if (addressTrans)
            {
                xmlEntry = RetailTransactionServiceTransactions::fillRetailTransactionLineAddress(addressTrans, addressTrans.DeliveryName, xmlDoc);
                xmlRecord.appendChild(xmlEntry);
            }
        }

        xmlEntry = xmlDoc.createElement('StaffId');
        xmlEntry.innerText(transactionSalesTrans.staffId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('StatusValue');
        xmlEntry.innerText(int2str(transactionSalesTrans.TransactionStatus));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Store');
        xmlEntry.innerText(transactionSalesTrans.store);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(ColumnTenderDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TenderDiscountAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(ColumnTenderDiscountPercentage);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TenderDiscountPercentage));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('TerminalId');
        xmlEntry.innerText(transactionSalesTrans.terminalId);
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnTotalDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TotalDiscAmount));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement(#ColumnTotalPercentageDiscount);
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.TotalDiscPct));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('UnitQuantity');
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(transactionSalesTrans.UnitQty * -1));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('VariantInventoryDimensionId');
        xmlEntry.innerText(transactionSalesTrans.VariantId);
        xmlRecord.appendChild(xmlEntry);

        // Appends WarantyRelations to SalesLine.
        // This will be used by both RTS GetSalesOrderDetailsByTransaction (Add Warranty to Existing Cash & Carry Transaction) and Post Invoice.
        RetailTransactionServiceWarranty::fillSalesTransWithWarrantyDetails(
            transactionSalesTrans, xmlDoc, xmlRecord, predecessorForIsWarrantyLine);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesTransWithPriceDetails</Name>
				<Source><![CDATA[
    internal protected static void fillSalesTransWithPriceDetails(RetailTransactionSalesTrans _transactionSalesTrans, XmlDocument _xmlDoc, XmlElement _xmlRecord)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLinePriceDetails</Name>
				<Source><![CDATA[
    private static void fillSalesLinePriceDetails(XmlDocument _xmlDoc, XmlElement _xmlRecord, SalesLine _soLine)
    {
        XmlElement xmlEntry, xmlContainer;
        xmlContainer = _xmlDoc.createElement(RetailTransactionTransformerHelper:: getPriceLinesStr());

        RetailSalesPriceAdjustmentLine retailSalesPriceAdjustmentLine;

        while select RetailPeriodicDiscountLineRefRecId, Amount from retailSalesPriceAdjustmentLine
            where retailSalesPriceAdjustmentLine.InventTransId == _soLine.InventTransId
        {
            xmlEntry = RetailTransactionServiceTransactions::fillSalesLineAdjustmentPriceDetails(_xmlDoc, retailSalesPriceAdjustmentLine, _soLine.LineNum);
            xmlContainer.appendChild(xmlEntry);
        }

        xmlContainer = RetailTransactionServiceTransactions::fillGUPSalesLinePriceDetails(_xmlDoc, _soLine, xmlContainer);
        _xmlRecord.appendChild(xmlContainer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillGUPSalesLinePriceDetails</Name>
				<Source><![CDATA[
    internal protected static XmlElement fillGUPSalesLinePriceDetails(XmlDocument _xmlDoc, SalesLine _soLine, XmlElement _xmlContainer)
    {
        return _xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFiscalTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of the <c>FiscalTransaction</c> having the data of the <c>RetailTransactionFiscalTrans</c> table.
    /// </summary>
    /// <param name="_xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_channel">
    /// The channel identifier.
    /// </param>
    /// <param name="_store">
    /// The store number.
    /// </param>
    /// <param name="_terminal">
    /// The terminal number.
    /// </param>
    /// <param name="_transactionId">
    /// Transaction number of the related <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionFiscalTrans</c> table.
    /// * Members must be in order of the FiscalTransaction DataContract
    /// Example:
    ///    <FiscalTransactions>
    ///      <FiscalTransaction>
    ///        <ExtensionProperties />
    ///        <ConnectorFunctionalityProfileId />
    ///        <ConnectorGroup />
    ///        <ConnectorName />
    ///        <CountryRegionIsoCode />
    ///        <CreatedDateTime />
    ///        <DocumentNumber />
    ///        <LineNumber />
    ///        <ReasonCodeLines />
    ///        <ReceiptCopy />
    ///        <RecordGUID />
    ///        <RegisterInfo />
    ///        <RegisterResponse />
    ///        <RegisterStoreId />
    ///        <RegisterTerminalId />
    ///        <RegistrationProcessId />
    ///        <RegistrationStatusValue />
    ///        <RegistrationTypeValue />
    ///        <SalesLineAdjustments />
    ///        <ServiceName />
    ///        <StaffId />
    ///        <StoreId />
    ///        <TenderLineAdjustments />
    ///        <TerminalId />
    ///        <TransDateTime />
    ///        <TransactionId />
    ///      </FiscalTransaction>
    ///    <FiscalTransactions>
    /// </returns>
    private static XmlElement fillFiscalTransactions(XmlDocument _xmlDoc, RefRecId _channel, RetailStoreId _store, RetailTerminalId _terminal, RetailTransactionId _transactionId)
    {
        XmlElement xmlRecord, xmlCollection, xmlRoot, xmlContainer;
        RetailTransactionFiscalTrans fiscalTrans;

        xmlContainer = _xmlDoc.createElement('FiscalTransactions');

        while select fiscalTrans
            where fiscalTrans.Channel == _channel
            && fiscalTrans.Store == _store
            && fiscalTrans.Terminal == _terminal
            && fiscalTrans.TransactionId == _transactionId
        {
            xmlRoot = _xmlDoc.createElement('FiscalTransaction');

            xmlCollection = RetailTransactionServiceTransactions::fillFiscalTransactionExtendedData(
                _xmlDoc, _channel, _store, _terminal, _transactionId, fiscalTrans.LineNum, fiscalTrans.RecordGuid);
            xmlRoot.appendChild(xmlCollection);

            xmlRecord = _xmlDoc.createElement('ConnectorFunctionalityProfileId');
            xmlRecord.innerText(fiscalTrans.ConnectorFunctionalityProfileId);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('ConnectorGroup');
            xmlRecord.innerText(fiscalTrans.ConnectorGroup);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('ConnectorName');
            xmlRecord.innerText(fiscalTrans.ConnectorName);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('CountryRegionIsoCode');
            xmlRecord.innerText(fiscalTrans.CountryRegionId);
            xmlRoot.appendChild(xmlRecord);

            if (fiscalTrans.CreatedDateTime)
            {
                xmlRecord = _xmlDoc.createElement('CreatedDateTime');
                xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
                xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(fiscalTrans.CreatedDateTime));
                xmlRoot.appendChild(xmlRecord);
            }

            xmlRecord = _xmlDoc.createElement('DocumentNumber');
            xmlRecord.innerText(fiscalTrans.DocumentNumber);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('LineNumber');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(fiscalTrans.LineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlCollection = RetailTransactionServiceTransactions::fillFiscalTransactionReasonCodeLines(
                _xmlDoc, _channel, _store, _terminal, _transactionId, fiscalTrans.LineNum, fiscalTrans.RecordGuid);
            xmlRoot.appendChild(xmlCollection);

            xmlRecord = _xmlDoc.createElement('ReceiptCopy');
            xmlRecord.innerText(int2str(enum2int(fiscalTrans.ReceiptCopy)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RecordGUID');
            xmlRecord.innerText(guid2StrWithoutBraces(fiscalTrans.RecordGuid));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegisterInfo');
            xmlRecord.innerText(fiscalTrans.RegisterInfo);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegisterResponse');
            xmlRecord.innerText(fiscalTrans.RegisterResponse);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegisterStoreId');
            xmlRecord.innerText(fiscalTrans.RegisterStore);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegisterTerminalId');
            xmlRecord.innerText(fiscalTrans.RegisterTerminal);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegistrationProcessId');
            xmlRecord.innerText(fiscalTrans.RegistrationProcessId);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegistrationStatusValue');
            xmlRecord.innerText(int2str(enum2int(fiscalTrans.RegistrationStatus)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RegistrationTypeValue');
            xmlRecord.innerText(int2str(enum2int(fiscalTrans.RegistrationType)));
            xmlRoot.appendChild(xmlRecord);

            xmlCollection = RetailTransactionServiceTransactions::fillFiscalTransactionSalesLineAdjustments(
                _xmlDoc, _channel, _store, _terminal, _transactionId, fiscalTrans.LineNum, fiscalTrans.RecordGuid);
            xmlRoot.appendChild(xmlCollection);

            xmlRecord = _xmlDoc.createElement('ServiceName');
            xmlRecord.innerText(fiscalTrans.ServiceName);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('StaffId');
            xmlRecord.innerText(fiscalTrans.StaffId);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('StoreId');
            xmlRecord.innerText(fiscalTrans.Store);
            xmlRoot.appendChild(xmlRecord);

            xmlCollection = RetailTransactionServiceTransactions::fillFiscalTransactionTenderLineAdjustments(
                _xmlDoc, _channel, _store, _terminal, _transactionId, fiscalTrans.LineNum, fiscalTrans.RecordGuid);
            xmlRoot.appendChild(xmlCollection);

            xmlRecord = _xmlDoc.createElement('TerminalId');
            xmlRecord.innerText(fiscalTrans.Terminal);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('TransDateTime');
            xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
            xmlRecord.innerXml(RetailTransactionServiceUtilities::utcdateTimeToDateTimeStringWithOffsetAndTimeZone(
                DateTimeUtil::newDateTime(fiscalTrans.transDate, fiscalTrans.transTime), fiscalTrans.Channel));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('TransactionId');
            xmlRecord.innerText(fiscalTrans.TransactionId);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFiscalTransactionReasonCodeLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills an XML element with the serialized collection of <c>RetailTransactionInfocodeTrans</c> related to a retail fiscal transaction.
    /// </summary>
    /// <param name="_xmlDoc">
    /// An <c>XmlDocument</c>.
    /// </param>
    /// <param name="_channel">
    /// The channel identifier.
    /// </param>
    /// <param name="_store">
    /// The store number.
    /// </param>
    /// <param name="_terminal">
    /// The terminal number.
    /// </param>
    /// <param name="_transactionId">
    /// Transaction number of the related <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="_fiscalTransLineNum">
    /// The retail fiscal transaction line number.
    /// </param>
    /// <param name="_fiscalTransParentGuid">
    /// The retail fiscal transaction identifier.
    /// </param>
    /// <returns>
    /// The XML element with the serialized collection of <c>RetailTransactionInfocodeTrans</c> related to a retail fiscal transaction.
    /// * Members must be in order of the ReasonCodeLine DataContract
    /// Example:
    ///    <ReasonCodeLines>
    ///      <ReasonCodeLine>
    ///        <Amount />
    ///        <CreatedDateTime />
    ///        <FiscalTransactionParentGuid />
    ///        <Information />
    ///        <InformationAmount />
    ///        <InputTypeValue />
    ///        <ItemTender />
    ///        <LineId />
    ///        <LineNumber />
    ///        <LineTypeValue />
    ///        <ParentLineId />
    ///        <ParentLineNumber />
    ///        <ReasonCodeId />
    ///        <SourceCode />
    ///        <SourceCode2 />
    ///        <SourceCode3 />
    ///        <StatementCode />
    ///        <SubReasonCodeId />
    ///        <TransactionId />
    ///      </ReasonCodeLine>
    ///    <ReasonCodeLines>
    /// </returns>
    private static XmlElement fillFiscalTransactionReasonCodeLines(XmlDocument _xmlDoc, RefRecId _channel, RetailStoreId _store, RetailTerminalId _terminal, RetailTransactionId _transactionId, LineNum _fiscalTransLineNum, Guid _fiscalTransParentGuid)
    {
        XmlElement xmlRecord, xmlRoot, xmlContainer;
        RetailTransactionInfocodeTrans infocodeTrans;

        xmlContainer = _xmlDoc.createElement('ReasonCodeLines');
        
        while select infocodeTrans
            where infocodeTrans.Channel == _channel
            && infocodeTrans.store == _store
            && infocodeTrans.terminal == _terminal
            && infocodeTrans.transactionId == _transactionId
            && infocodeTrans.parentLineNum == _fiscalTransLineNum
            && infocodeTrans.fiscalTransParentGuid == _fiscalTransParentGuid
            && infocodeTrans.type == RetailInfocodeTransType::Fiscal
        {
            xmlRoot = _xmlDoc.createElement('ReasonCodeLine');

            xmlRecord = _xmlDoc.createElement('Amount');
            xmlRecord.innerText(num2Str(infocodeTrans.amount, 5, 3, 1, 0));
            xmlRoot.appendChild(xmlRecord);

            if (infocodeTrans.transDate)
            {
                xmlRecord = _xmlDoc.createElement('CreatedDateTime');
                xmlRecord.setAttribute(dateTimeOffsetXmlNsKey, dateTimeOffsetXmlNsValue);
                xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(
                    DateTimeUtil::newDateTime(infocodeTrans.transDate, infocodeTrans.transTime, RetailChannelTable::findByRecId(infocodeTrans.Channel).ChannelTimeZone)));
                xmlRoot.appendChild(xmlRecord);
            }

            xmlRecord = _xmlDoc.createElement('FiscalTransactionParentGuid');
            xmlRecord.innerText(guid2StrWithoutBraces(infocodeTrans.fiscalTransParentGuid));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('Information');
            xmlRecord.innerText(infocodeTrans.information);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('InformationAmount');
            xmlRecord.innerText(num2Str(infocodeTrans.infoAmount, 5, 3, 1, 0));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('InputTypeValue');
            xmlRecord.innerText(int2Str(enum2int(infocodeTrans.inputType)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('ItemTender');
            xmlRecord.innerText(infocodeTrans.itemTender);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('LineId');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(infocodeTrans.lineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('LineNumber');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(infocodeTrans.lineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('LineTypeValue');
            xmlRecord.innerText(int2Str(enum2int(infocodeTrans.type)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('ParentLineId');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(infocodeTrans.parentLineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('ParentLineNumber');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(infocodeTrans.parentLineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('ReasonCodeId');
            xmlRecord.innerText(infocodeTrans.infocodeId);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('SourceCode');
            xmlRecord.innerText(infocodeTrans.sourceCode);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('SourceCode2');
            xmlRecord.innerText(infocodeTrans.sourceCode2);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('SourceCode3');
            xmlRecord.innerText(infocodeTrans.sourceCode3);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('StatementCode');
            xmlRecord.innerText(infocodeTrans.statementCode);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('SubReasonCodeId');
            xmlRecord.innerText(infocodeTrans.subInfocodeId);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('TransactionId');
            xmlRecord.innerText(infocodeTrans.transactionId);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFiscalTransactionSalesLineAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills an XML element with the serialized collection of <c>RetailFiscalTransSalesTransAdjustment</c> related to a retail transaction.
    /// </summary>
    /// <param name="_xmlDoc">
    /// An <c>XmlDocument</c>.
    /// </param>
    /// </param>
    /// <param name="_channel">
    /// The channel identifier.
    /// </param>
    /// <param name="_store">
    /// The store number.
    /// </param>
    /// <param name="_terminal">
    /// The terminal number.
    /// </param>
    /// <param name="_transactionId">
    /// Transaction number of the related <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="_fiscalTransLineNum">
    /// The retail fiscal transaction line number.
    /// </param>
    /// <param name="_fiscalTransRecordGuid">
    /// The retail fiscal transaction record GUID.
    /// </param>
    /// <returns>
    /// The XML element with the serialized collection of <c>RetailFiscalTransSalesTransAdjustment</c> related to a retail transaction.
    /// * Members must be in order of the FiscalTransactionSalesLineAdjustment DataContract
    /// Example:
    ///    <SalesLineAdjustments>
    ///      <FiscalTransactionSalesLineAdjustment>
    ///        <Exclude />
    ///        <RecordGuid />
    ///        <SalesLineNumber />
    ///        <TransactionId />
    ///      </FiscalTransactionSalesLineAdjustment>
    ///    <SalesLineAdjustments>
    /// </returns>
    private static XmlElement fillFiscalTransactionSalesLineAdjustments(XmlDocument _xmlDoc, RefRecId _channel, RetailStoreId _store, RetailTerminalId _terminal, RetailTransactionId _transactionId, LineNum _fiscalTransLineNum, Guid _fiscalTransRecordGuid)
    {
        XmlElement xmlRecord, xmlRoot, xmlContainer;
        RetailFiscalTransSalesTransAdjustment salesTransAdjustment;

        xmlContainer = _xmlDoc.createElement('SalesLineAdjustments');
        
        while select salesTransAdjustment
            where salesTransAdjustment.Channel == _channel
            && salesTransAdjustment.Store == _store
            && salesTransAdjustment.Terminal == _terminal
            && salesTransAdjustment.TransactionId == _transactionId
            && salesTransAdjustment.FiscalTransLineNum == _fiscalTransLineNum
            && salesTransAdjustment.FiscalTransRecordGuid == _fiscalTransRecordGuid
        {
            xmlRoot = _xmlDoc.createElement('FiscalTransactionSalesLineAdjustment');

            xmlRecord = _xmlDoc.createElement('Exclude');
            xmlRecord.innerText(int2Str(enum2int(salesTransAdjustment.Exclude)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RecordGuid');
            xmlRecord.innerText(guid2StrWithoutBraces(salesTransAdjustment.FiscalTransRecordGuid));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('SalesLineNumber');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(salesTransAdjustment.SalesTransLineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('TransactionId');
            xmlRecord.innerText(salesTransAdjustment.TransactionId);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFiscalTransactionTenderLineAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills an XML element with the serialized collection of <c>RetailFiscalTransPaymentTransAdjustment</c> related to a retail transaction.
    /// </summary>
    /// <param name="_xmlDoc">
    /// An <c>XmlDocument</c>.
    /// </param>
    /// </param>
    /// <param name="_channel">
    /// The channel identifier.
    /// </param>
    /// <param name="_store">
    /// The store number.
    /// </param>
    /// <param name="_terminal">
    /// The terminal number.
    /// </param>
    /// <param name="_transactionId">
    /// Transaction number of the related <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="_fiscalTransLineNum">
    /// The retail fiscal transaction line number.
    /// </param>
    /// <param name="_fiscalTransRecordGuid">
    /// The retail fiscal transaction record GUID.
    /// </param>
    /// <returns>
    /// The XML element with the serialized collection of <c>RetailFiscalTransPaymentTransAdjustment</c> related to a retail transaction.
    /// * Members must be in order of the FiscalTransactionTenderLineAdjustment DataContract
    /// Example:
    ///    <TenderLineAdjustments>
    ///      <FiscalTransactionTenderLineAdjustment>
    ///        <AdjustmentAmount />
    ///        <RecordGuid />
    ///        <TenderLineNumber />
    ///        <TransactionId />
    ///      </FiscalTransactionTenderLineAdjustment>
    ///    <TenderLineAdjustments>
    /// </returns>
    private static XmlElement fillFiscalTransactionTenderLineAdjustments(XmlDocument _xmlDoc, RefRecId _channel, RetailStoreId _store, RetailTerminalId _terminal, RetailTransactionId _transactionId, LineNum _fiscalTransLineNum, Guid _fiscalTransRecordGuid)
    {
        XmlElement xmlRecord, xmlRoot, xmlContainer;
        RetailFiscalTransPaymentTransAdjustment paymentTransAdjustment;

        xmlContainer = _xmlDoc.createElement('TenderLineAdjustments');
        
        while select paymentTransAdjustment
            where paymentTransAdjustment.Channel == _channel
            && paymentTransAdjustment.Store == _store
            && paymentTransAdjustment.Terminal == _terminal
            && paymentTransAdjustment.TransactionId == _transactionId
            && paymentTransAdjustment.FiscalTransLineNum == _fiscalTransLineNum
            && paymentTransAdjustment.FiscalTransRecordGuid == _fiscalTransRecordGuid
        {
            xmlRoot = _xmlDoc.createElement('FiscalTransactionTenderLineAdjustment');

            xmlRecord = _xmlDoc.createElement('AdjustmentAmount');
            xmlRecord.innerText(num2Str(paymentTransAdjustment.AdjustmentAmount, 5, 3, 1, 0));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RecordGuid');
            xmlRecord.innerText(guid2StrWithoutBraces(paymentTransAdjustment.FiscalTransRecordGuid));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('TenderLineNumber');
            xmlRecord.innerText(RetailTransactionServiceUtilities::lineNumToString(paymentTransAdjustment.PaymentTransLineNum));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('TransactionId');
            xmlRecord.innerText(paymentTransAdjustment.TransactionId);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillFiscalTransactionExtendedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fills an XML element with the serialized collection of <c>CommerceProperty</c> related to a retail fiscal transaction.
    /// </summary>
    /// <param name="_xmlDoc">
    /// An <c>XmlDocument</c>.
    /// </param>
    /// </param>
    /// <param name="_channel">
    /// The channel identifier.
    /// </param>
    /// <param name="_store">
    /// The store number.
    /// </param>
    /// <param name="_terminal">
    /// The terminal number.
    /// </param>
    /// <param name="_transactionId">
    /// Transaction number of the related <c>RetailTransactionTable</c> table.
    /// </param>
    /// <param name="_fiscalTransLineNum">
    /// The retail fiscal transaction line number.
    /// </param>
    /// <param name="_fiscalTransRecordGuid">
    /// The retail fiscal transaction record GUID.
    /// </param>
    /// <returns>
    /// The XML element with the serialized collection of <c>RetailFiscalTransPaymentTransAdjustment</c> related to a retail transaction.
    /// * Members must be in order of the FiscalTransactionTenderLineAdjustment DataContract
    /// Example:
    ///    <ExtensionProperties>
    ///      <CommerceProperty>
    ///        <Key />
    ///        <Value>
    ///          <StringValue />
    ///        </Value>
    ///      </CommerceProperty>
    ///    <ExtensionProperties>
    /// </returns>
    private static XmlElement fillFiscalTransactionExtendedData(XmlDocument _xmlDoc, RefRecId _channel, RetailStoreId _store, RetailTerminalId _terminal, RetailTransactionId _transactionId, LineNum _fiscalTransLineNum, Guid _fiscalTransRecordGuid)
    {
        XmlElement xmlRecord, xmlSubRecord, xmlRoot, xmlContainer;
        RetailTransactionFiscalTransExtendedData fiscalTransExtendedData;

        xmlContainer = _xmlDoc.createElement('ExtensionProperties');
        
        while select fiscalTransExtendedData
            where fiscalTransExtendedData.Channel == _channel
            && fiscalTransExtendedData.Store == _store
            && fiscalTransExtendedData.Terminal == _terminal
            && fiscalTransExtendedData.TransactionId == _transactionId
            && fiscalTransExtendedData.FiscalTransLineNum == _fiscalTransLineNum
            && fiscalTransExtendedData.FiscalTransRecordGuid == _fiscalTransRecordGuid
        {
            xmlRoot = _xmlDoc.createElement('CommerceProperty');

            xmlRecord = _xmlDoc.createElement('Key');
            xmlRecord.innerText(enum2Symbol(enumNum(RetailFiscalRegistrationExtendedDataType), enum2int(fiscalTransExtendedData.DataKey)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('Value');
            xmlSubRecord = _xmlDoc.createElement('StringValue');
            xmlSubRecord.innerText(fiscalTransExtendedData.DataValue);
            xmlRecord.appendChild(xmlSubRecord);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillNoteTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of the <c>Notes</c> having the data of the <c>RetailTransactionNoteTrans</c> table.
    /// </summary>
    /// <param name="_xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name="_channel">
    /// The channel identifier.
    /// </param>
    /// <param name="_store">
    /// The store number.
    /// </param>
    /// <param name="_terminal">
    /// The terminal number.
    /// </param>
    /// <param name="_transactionId">
    /// Transaction number of the related <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionNoteTrans</c> table.
    /// * Members must be in alphabetical order of the Notes DataContract
    /// Example:
    ///    <Notes>
    ///      <Note>
    ///        <Description />
    ///        <DocuRefRecId />
    ///        <Restriction />
    ///        <StaffId />
    ///        <Title />
    ///      </Note>
    ///    <Notes>
    /// </returns>
    private static XmlElement fillNoteTransactions(XmlDocument _xmlDoc, RefRecId _channel, RetailStoreId _store, RetailTerminalId _terminal, RetailTransactionId _transactionId)
    {
        XmlElement xmlRecord, xmlCollection, xmlRoot, xmlContainer;
        RetailTransactionNoteTrans noteTrans;

        xmlContainer = _xmlDoc.createElement('Notes');

        // Ideally this query should leverage RETAILTRANSACTIONNOTETRANS TRANSACTIONLINEIDX
        // PARTITION, DATAAREAID, CHANNEL, STORE, TERMINAL, TRANSACTIONID, LINENUM
        while select noteTrans
            where noteTrans.Channel == _channel
            && noteTrans.Store == _store
            && noteTrans.Terminal == _terminal
            && noteTrans.TransactionId == _transactionId
        {
            // 'Note' XML maps to 'Note' CRT Entity.
            xmlRoot = _xmlDoc.createElement('Note');

            xmlRecord = _xmlDoc.createElement('Description');
            xmlRecord.innerText(noteTrans.Notes);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('DocuRefRecId');
            xmlRecord.innerText(int642Str(noteTrans.DocuRefRecId));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RestrictionValue');
            xmlRecord.innerText(int2Str(enum2int(noteTrans.Restriction)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('StaffId');
            xmlRecord.innerText(noteTrans.StaffId);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('Title');
            xmlRecord.innerText(noteTrans.Description);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillTransactionTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the container <c>transTable</c> having the data of the <c>RetailTransactionTable</c>.
    /// </summary>
    /// <param name="transactionTable">
    /// Table buffer of <c>RetailTransactionTable</c>.
    /// </param>
    /// <returns>
    /// The xml serialized string of the <c>RetailTransactionTable</c>.
    /// Example:
    /// <TransactionHeader>
    ///   <TransactionId>TransactionId</TransactionId>
    ///   <ReceiptId>ReceiptId</ReceiptId>
    ///   <Store>Store</Store>
    ///   <Terminal>Terminal</Terminal>
    ///   <Staff>Staff</Staff>
    ///   <TransactionDate>TransactionDate</TransactionDate>
    ///   <Shift>Shift</Shift>
    ///   <ShiftDate>ShiftDate</ShiftDate>
    ///   <CustomerAccount>CustomerAccount</CustomerAccount>
    ///   <EntryStatus>EntryStatus</EntryStatus>
    ///   <Currency>Currency</Currency>
    ///   <PaymentAmount>PaymentAmount</PaymentAmount>
    ///   <BatchId>BatchId</BatchId>
    ///   <LoyaltyCardId>LoyaltyCardId</LoyaltyCardId>
    ///   <HasLoyaltyPayment>true</HasLoyaltyPayment>
    /// </TransactionHeader>
    /// </returns>

    private static str fillTransactionTable(RetailTransactionTable transactionTable)
    {
        XmlDocument         xmlDoc;
        XmlElement          xmlRoot,xmlRecord;
        boolean             hasLoyaltyPayment;

        xmlDoc = XmlDocument::newBlank('Unicode');
        xmlRoot = xmlDoc.createElement('TransactionHeader');

        xmlRecord = xmlDoc.createElement('TransactionId');
        xmlRecord.innerText(transactionTable.TransactionId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ReceiptId');
        xmlRecord.innerText(transactionTable.ReceiptId);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Store');
        xmlRecord.innerText(transactionTable.Store);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Terminal');
        xmlRecord.innerText(transactionTable.Terminal);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Staff');
        xmlRecord.innerText(transactionTable.Staff);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CommissionSalesGroup');
        xmlRecord.innerText(transactionTable.SalesGroup);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('TransactionDate');
        xmlRecord.innerText(date2str(transactionTable.TransDate,
                                    321,
                                    DateDay::Digits2,
                                    DateSeparator::Hyphen, // separator1
                                    DateMonth::Digits2,
                                    DateSeparator::Hyphen, // separator2
                                    DateYear::Digits4,
                                    DateFlags::None));

        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Shift');
        xmlRecord.innerText(transactionTable.Shift);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('ShiftDate');
        xmlRecord.innerText(date2str(transactionTable.ShiftDate,
                                    321,
                                    DateDay::Digits2,
                                    DateSeparator::Hyphen, // separator1
                                    DateMonth::Digits2,
                                    DateSeparator::Hyphen, // separator2
                                    DateYear::Digits4,
                                    DateFlags::None));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('CustomerAccount');
        xmlRecord.innerText(transactionTable.CustAccount);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('EntryStatus');
        xmlRecord.innerText(int2str(enum2int(transactionTable.EntryStatus)));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('Currency');
        xmlRecord.innerText(transactionTable.Currency);
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('PaymentAmount');
        xmlRecord.innerText(RetailTransactionServiceUtilities::realToString(transactionTable.PaymentAmount));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('BatchId');
        xmlRecord.innerText(int642str(transactionTable.BatchID));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('LoyaltyCardId');
        xmlRecord.innerText(transactionTable.loyaltyCardId);
        xmlRoot.appendChild(xmlRecord);

        hasLoyaltyPayment = RetailLoyaltyCardRewardPointTrans::IsTransactionPaidByLoyalty(
            transactionTable.transactionId,
            transactionTable.store,
            transactionTable.terminal,
            transactionTable.Channel,
            transactionTable.dataAreaId);
        xmlRecord = xmlDoc.createElement('HasLoyaltyPayment');
        xmlRecord.innerText(hasLoyaltyPayment ? #TrueStr : #FalseStr);
        xmlRoot.appendChild(xmlRecord);

        xmlDoc.appendChild(xmlRoot);

        return xmlDoc.toString();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get credit memo balance and currency code.
    /// </summary>
    /// <param name="dataEntryId">
    /// Credit memo identifier (RetailCreditVoucherTable.entryId field).
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    public static container getCreditMemo(RetailEntryId dataEntryId)
    {
        #OCCRetryCount

        RetailCreditVoucherTable    tCreditVoucherTable;
        CurrencyCode        currencyCode = '';
        AmountMST           pAmountMST = 0;
        container           creditMemoStatus = [false,'',pAmountMST,0];

        // Process all credit memo transactions that occurred in offline mode before processing the current request.
        RetailCreditVoucherTable::processChannelTransactions();

        tCreditVoucherTable = RetailCreditVoucherTable::find(dataEntryId);

        if (tCreditVoucherTable) // credit memo exists
        {
            if (!tCreditVoucherTable.Voided) // credit memo is not voided
            {
                if (!tCreditVoucherTable.Applied) // credit memo is not used
                {
                    if (!tCreditVoucherTable.Reserved) // credit memo is not reserved
                    {
                        currencyCode = tCreditVoucherTable.CurrencyCode;
                        pAmountMST = tCreditVoucherTable.Amount;
                        creditMemoStatus = [true,'',currencyCode,pAmountMST];
                        eventSource.EventWritePaymentsValidCreditMemo(tCreditVoucherTable.RecId);
                    }
                    else // credit memo is reserved
                    {
                        creditMemoStatus = [false,strFmt("@RET2422",dataEntryId,tCreditVoucherTable.ReservedByStoreId,tCreditVoucherTable.ReservedByTerminalId),currencyCode,pAmountMST];
                        eventSource.EventWritePaymentsCreditMemoInUseException(tCreditVoucherTable.RecId, tCreditVoucherTable.ReservedByStoreId, tCreditVoucherTable.ReservedByTerminalId);
                    }
                }
                else // credit memo has already been used
                {
                    creditMemoStatus = [false,"@RET2424",currencyCode,pAmountMST];
                    eventSource.EventWritePaymentsCreditMemoUsed(tCreditVoucherTable.RecId);
                }
            }
            else // credit memo has been voided
            {
                creditMemoStatus = [false,"@RET2426",currencyCode,pAmountMST];
                eventSource.EventWritePaymentsCreditMemoVoided(tCreditVoucherTable.RecId);
            }
        }
        else // credit memo does not exist
        {
            creditMemoStatus = [false,"@RET2425",currencyCode,pAmountMST];
            eventSource.EventWritePaymentsCreditMemoIsNotFound(dataEntryId);
        }

        return creditMemoStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the status of the gift card.
    /// </summary>
    /// <param name="cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container including [success, message, currencyCode, blanace]
    /// </returns>
    public static container getGiftCardBalance(RetailGiftCardId cardNumber)
    {
        return RetailTransactionServiceTransactions::getGiftCardData(cardNumber, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardInquiry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method performs gift card inquiry.
    /// </summary>
    /// <param name="cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name = "historyCount">Specifies how much history, if any, should be returned.  Maximum value of ten (10).</param>
    /// <returns>
    /// The status as a container including [success, message, currencyCode, blanace, issueAmount, ActiveFrom, ExpiryDate, xmlResultsDetails]
    /// </returns>
    public static container giftCardInquiry(RetailGiftCardId cardNumber, int historyCount)
    {
        return RetailTransactionServiceTransactions::getGiftCardData(cardNumber, true, historyCount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the gift card data.
    /// </summary>
    /// <param name = "cardNumber">ID of the RetailGiftCardTable.entryId field.</param>
    /// <param name = "includeDetails">true if inquiry details should be included; otherwise, false.</param>
    /// <param name = "historyCount">when details are included, specifies how much history, if any, should be returned.  Clamped at ten (10).  This parameter is optional.</param>
    /// <returns></returns>
    private static container getGiftCardData(RetailGiftCardId cardNumber, boolean includeDetails, int historyCount = 0)
    {
        const int                  maxHistoryCount = 10;
        RetailGiftCardTable        tGiftCardTable;
        container                  giftCardStatus = [false, '']; // Status, ErrorMsg

        str                        giftCardCompany;
        container                  conCompanies;
        str                        giftCardBalCo;
        str                        channelName;
        XmlDocument                xmldoc;
        XmlElement                 xmlRoot, xmlLineRecord, xmlRecord;
        RetailGiftCardTransactions giftCardTransactions;
        RetailStoreTable           retailStoreTable;
        int                        insertedHistoryCount;

        try
        {
            // Locate the gift card across all companies.
            container companiesToAttemptToLocateTheRecordIn = [curExt(), RetailParameters::find().GiftCardCompany];
            tGiftCardTable = RetailGiftCardTable::findCrossCompany(cardNumber, companiesToAttemptToLocateTheRecordIn);

            // Return an error if we are unable to locate the gift card record.
            if (tGiftCardTable.RecId == 0)
            {
                giftCardStatus = [false, "@RET2431"];
                eventSource.EventWritePaymentsGiftCardIsNotFound(cardNumber);
            }
            else
            {
                // Change the company to the gift card company.
                changecompany(tGiftCardTable.DataAreaId)
                {
                    // If the card is locked, check if we can unlock it.
                    if (tGiftCardTable.reserved)
                    {
                        ttsbegin;
                        //Reselect for update purpose with selectForUpdate = true
                        tGiftCardTable = RetailGiftCardTable::findCrossCompany(cardNumber, companiesToAttemptToLocateTheRecordIn, true);
                        
                        //Double check that gift card still reserved, if not we can skip release step.
                        if (tGiftCardTable.RecId == 0)
                        {
                            giftCardStatus = [false, "@RET2431"];
                            eventSource.EventWritePaymentsGiftCardIsNotFound(cardNumber);
                        }
                        else if (tGiftCardTable.RecId != 0 && tGiftCardTable.reserved)
                        {
                            tGiftCardTable.tryReleaseCardLock();
                        }
                        ttscommit;
                    }

                    if (tGiftCardTable.RecId != 0)
                    {
                        // If the card is still locked, return an error.
                        if (tGiftCardTable.reserved)
                        {
                            if (tGiftCardTable.reservedByChannel)
                            {
                                // If the card is reserved (unavailable and/or locked), report that it's "in use".
                                channelName = OMOperatingUnit::find(RetailChannelTable::findByRecId(tGiftCardTable.reservedByChannel).OMOperatingUnitID, OMOperatingUnitType::RetailChannel).Name;
                                giftCardStatus = [false, strFmt("@RET2428", channelName, tGiftCardTable.ReservedByTerminalId)];
                                eventSource.EventWritePaymentsGiftCardIsInUse(cardNumber, channelName, tGiftCardTable.ReservedByTerminalId);
                            }
                            else
                            {
                                giftCardStatus = [false, "@Retail:RetailBlockedGiftCard"];
                                eventSource.EventWritePaymentsGiftCardIsBlocked(cardNumber);
                            }
                        }
                        else
                        {
                            if (includeDetails)
                            {
                                // Return full gift card inquiry details.

                                xmldoc =  XmlDocument::newBlank();

                                if (historyCount > 0)
                                {
                                    xmlRoot = xmldoc.createElement('GiftCardTransactions');
                                    insertedHistoryCount = 0;
                            
                                    while select firstonly10 * from giftCardTransactions
                                    order by giftCardTransactions.RecId desc
                                    where giftCardTransactions.cardNumber == cardNumber
                                    outer join RetailChannelId, StoreNumber from retailStoreTable
                                        where giftCardTransactions.Channel == retailStoreTable.RecId
                                    {
                                        if (insertedHistoryCount < historyCount)
                                        {
                                            xmlLineRecord = xmldoc.createElement('GiftCardTransaction');

                                            xmlRecord = xmldoc.createElement('ReceiptNumber');
                                            xmlRecord.innerText(giftCardTransactions.receiptId);
                                            xmlLineRecord.appendChild(xmlRecord);

                                            xmlRecord = xmldoc.createElement('Date');
                                            xmlRecord.innerText(date2Str(giftCardTransactions.transDate, 321, DateDay::Digits2, DateSeparator::Hyphen, DateMonth::Digits2, DateSeparator::Hyphen, DateYear::Digits4));
                                            xmlLineRecord.appendChild(xmlRecord);

                                            xmlRecord = xmldoc.createElement('Amount');
                                            xmlRecord.innerText(num2str(giftCardTransactions.amount,5,3,1,0));
                                            xmlLineRecord.appendChild(xmlRecord);

                                            xmlRecord = xmldoc.createElement('Operation');
                                            xmlRecord.innerText(any2Str(giftCardTransactions.operation));
                                            xmlLineRecord.appendChild(xmlRecord);

                                            xmlRecord = xmldoc.createElement('StoreNumber');
                                            xmlRecord.innerText(retailStoreTable.StoreNumber);
                                            xmlLineRecord.appendChild(xmlRecord);

                                            xmlRecord = xmldoc.createElement('ChannelId');
                                            xmlRecord.innerText(retailStoreTable.RetailChannelId);
                                            xmlLineRecord.appendChild(xmlRecord);

                                            xmlRoot.appendChild(xmlLineRecord);
                                            insertedHistoryCount += 1;
                                        }
                                    }

                                    xmldoc.appendChild(xmlRoot);
                                }

                                giftCardStatus = [true, '',
                                tGiftCardTable.CurrencyCode,
                                tGiftCardTable.balance(),
                                tGiftCardTable.issueAmount(),
                                tGiftCardTable.ActiveFrom,
                                tGiftCardTable.ExpiryDate,
                                xmldoc.toString() // full details history as XML
                                ];
                            }
                            else
                            {
                                // Just return the simple currency code and balance (old API)
                                giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];
                            }
                        }

                        eventSource.EventWritePaymentsGiftCardStatusIsReturned(cardNumber, conPeek(giftCardStatus, 1));
                    }
                }
            }
        }
        catch
        {
            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardDataError(cardNumber);
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetRetailSalesStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the sales status and document status to the RetailSalesStatus
    /// </summary>
    /// <param name="_salesStatus">
    /// The sales status to be converted.
    /// </param>
    /// <param name="_documentStatus">
    /// The document status to be converted.
    /// </param>
    /// <returns>
    /// The converted retail sales status.
    /// </returns>
    private static RetailSalesStatus GetRetailSalesStatus(SalesStatus _salesStatus, DocumentStatus _documentStatus)
    {
        RetailSalesStatus retailSalesStatus;
        RetailSalesStatus retailDocumentStatus;

        retailSalesStatus = RetailTransactionServiceTransactions::ConvertSalesStatusToRetailSalesStatus(_salesStatus);

        switch (retailSalesStatus)
        {
            case RetailSalesStatus::Unknown:
            case RetailSalesStatus::Created:
                retailDocumentStatus = RetailTransactionServiceTransactions::ConvertDocumentStatusToRetailSalesStatus(_documentStatus);
                if (retailDocumentStatus == RetailSalesStatus::Unknown)
                {
                    return RetailSalesStatus;
                }

                return retailDocumentStatus;

            default:
                return RetailSalesStatus;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validations:
    /// 1.No transactions for the receipt ID.
    /// 2.Too many transactions were found for receipt ID.
    /// </summary>
    /// <param name="transactionTable">
    /// RetailTransactionTable.
    /// </param>
    /// <param name="output">
    /// The output container.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <remarks>
    /// RetailTransactionService.fillTransactionTable method returns the container <c>transTable</c> having the data of the <c>RetailTransactionTable</c>.
    /// RetailTransactionService.fillSalesTrans method returns the container <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// RetailTransactionService.fillLoyaltyTrans method returns <c>container</c> with the loyalty card number.
    /// RetailTransactionService.fillDiscountTrans method returns the container <c>discountTrans</c> having the data of the <c>RetailTransactionDiscountTrans</c> table.
    /// </remarks>
    private static container getTransaction(RetailTransactionTable transactionTable, container output)
    {
        RetailTransactionService             transactionService = new RetailTransactionService();

        output = conIns(output,conLen(output)+1, RetailTransactionServiceTransactions::fillTransactionTable(transactionTable));

        // Add item details as container of containers.
        output = conIns(output,conLen(output)+1, RetailTransactionServiceTransactions::fillSalesTrans(transactionTable));

        // Add loyalty as container.
        output = conIns(output,conLen(output)+1, RetailTransactionServiceTransactions::fillLoyaltyTrans(transactionTable));

        // Add discount transactions
        output = conIns(output,conLen(output)+1, RetailTransactionServiceTransactions::fillDiscountTrans(transactionTable));

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionByReceiptId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validations:
    /// 1.No transactions for the receipt ID.
    /// 2.Too many transactions were found for receipt ID.
    /// </summary>
    /// <param name="receiptId">
    /// ID of the RetailTransactionTable.receiptId field.
    /// </param>
    /// <param name="storeId">
    /// ID of the RetailTransactionTable.store field.
    /// </param>
    /// <param name="terminalId">
    /// ID of the RetailTransactionTable.terminal field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <remarks>
    /// RetailTransactionService.fillTransactionTable method returns the container <c>transTable</c> having the data of the <c>RetailTransactionTable</c>.
    /// RetailTransactionService.fillSalesTrans method returns the container <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// RetailTransactionService.fillLoyaltyTrans method returns <c>container</c> with the loyalty card number.
    /// RetailTransactionService.fillDiscountTrans method returns the container <c>discountTrans</c> having the data of the <c>RetailTransactionDiscountTrans</c> table.
    /// </remarks>
    public static container getTransactionByReceiptId(RetailReceiptId   receiptId,
                                                     RetailStoreId     storeId    = '',
                                                     RetailTerminalId  terminalId = '')
    {
        RetailTransactionService            transactionService = new RetailTransactionService();
        RetailTransactionTable              transactionTable;
        container                           output = [true,''];
        ;

        if (storeId && terminalId)
        {
            select count(RecId) from transactionTable
            where transactionTable.ReceiptId   == receiptId
               && transactionTable.Store       == storeId
               && transactionTable.Terminal    == terminalId
               && transactionTable.EntryStatus != RetailEntryStatus::Voided;
        }
        else
        {
            select count(RecId) from transactionTable
            where transactionTable.ReceiptId   == receiptId
               && transactionTable.EntryStatus != RetailEntryStatus::Voided;
        }

        if (transactionTable.RecId == 0)
        {
            // No transactions for receipt ID.
            output = [false,strFmt("@RET4544",receiptId),transactionTable.RecId];
        }
        else if (transactionTable.RecId > 1)
        {
            // Too many transactions were found for receipt ID.
            output = [false,strFmt("@RET4545",receiptId),transactionTable.RecId];
        }
        else if (transactionTable.RecId == 1)
        {
            // Add count of transactions to container, which is always 1.
            output = conIns(output,conLen(output)+1,transactionTable.RecId);

            if (storeId && terminalId)
            {
                // Add transaction detail as a container.
                select firstonly transactionTable
                where transactionTable.Store       == storeId
                   && transactionTable.Terminal    == terminalId
                   && transactionTable.ReceiptId   == receiptId
                   && transactionTable.EntryStatus != RetailEntryStatus::Voided;
            }
            else
            {
                select firstonly transactionTable
                where transactionTable.ReceiptId   == receiptId
                   && transactionTable.EntryStatus != RetailEntryStatus::Voided;
            }

            output = RetailTransactionServiceTransactions::getTransaction(transactionTable, output);
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionByTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for retrieving the sales transactions. Performs the following:
    /// 1.Adds transaction details.
    /// 2.Adds item details.
    /// 3.Adds loyalty.
    /// Performs the following validation:
    /// 1.No transaction for the transaction ID.
    /// </summary>
    /// <param name="transactionId">
    /// The <c>transactionId</c> field of the <c>RetailTransactionTable</c> table.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container getTransactionByTransactionId(RetailTransactionId transactionId)
    {
        RetailTransactionService            transactionService = new RetailTransactionService();
        RetailTransactionTable              transactionTable;
        container                           output = [true,''];
        ;

        select count(RecId) from transactionTable
        where transactionTable.TransactionId == transactionId
            && transactionTable.EntryStatus != RetailEntryStatus::Voided;

        if (transactionTable.RecId == 0)
        {
            // No transactions for transaction ID.
            // Label: "No transaction for transaction ID %1."
            output = [false,strFmt("@REX4040005",transactionId),transactionTable.RecId];
        }
        else if (transactionTable.RecId == 1)
        {
            // Add count of transactions to container, which is always 1.
            output = conIns(output,conLen(output)+1,transactionTable.RecId);

            select firstonly transactionTable
            where transactionTable.TransactionId == transactionId
                && transactionTable.EntryStatus != RetailEntryStatus::Voided;

            output = RetailTransactionServiceTransactions::getTransaction(transactionTable, output);
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container giftCardPayment(RetailGiftCardId   _cardNumber,
                                           RetailChannelRecId  _channelId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321)
    {
        #OCCRetryCount

        container giftCardStatus = [false, '', '', 0]; // Status, ErrorMsg, currenyCode, Balance
        str giftCardCompany;
        container conCompanies;
        str giftCardPayCo;
        RetailGiftCardTable tGiftCardTable;
        RetailGiftCardOperation giftCardOperation = RetailGiftCardOperation::Redeem;
        Counter   pCounter = 0;

        try
        {
            ttsbegin;
            tGiftCardTable = RetailGiftCardTable::find(_cardNumber, true);

            if (tGiftCardTable)
            {
                if (_amountMST < 0)
                {
                    giftCardOperation = RetailGiftCardOperation::Refund;
                }

                RecId lastTransactionId = RetailGiftCardTransactions::lastTransaction(giftCardOperation, _cardNumber, _transactionId, -_amountMST);

                if (!lastTransactionId)
                {
                    RetailGiftCardTransactions::add(giftCardOperation, _cardNumber, _channelId,
                         _terminalId, _staffId, _transactionId, _receiptId, -1 * _amountMST,
                        str2Date(_transDate,_dateSequence), str2time(_transTime));

                    tGiftCardTable.unlockCard(tGiftCardTable.OneTimeRedemption && giftCardOperation == RetailGiftCardOperation::Redeem);
                    giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];

                    eventSource.EventWritePaymentsGiftCardRecordIsCreated(tGiftCardTable.RecId);
                }
                else
                {
                    giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];
                    eventSource.EventWritePaymentsGiftCardRecordAlreadyExists(tGiftCardTable.RecId, lastTransactionId);

                    if (tGiftCardTable.reserved == NoYes::Yes)
                    {
                        tGiftCardTable.unlockCard(tGiftCardTable.OneTimeRedemption && giftCardOperation == RetailGiftCardOperation::Redeem);
                    }
                }
            }
            else
            {
                giftCardCompany = RetailParameters::find().GiftCardCompany;
                conCompanies = [giftCardCompany];
                tGiftCardTable = RetailGiftCardTable::findCrossCompany(_cardNumber, conCompanies, true);
                giftCardPayCo = conPeek(conCompanies,1);
                if (tGiftCardTable)
                {
                    changeCompany(giftCardPayCo)
                    {
                        if (_amountMST < 0)
                        {
                            giftCardOperation = RetailGiftCardOperation::Refund;
                        }

                        RecId lastTransactionId = RetailGiftCardTransactions::lastTransaction(giftCardOperation, _cardNumber, _transactionId, -_amountMST);

                        if (!lastTransactionId)
                        {
                            RetailGiftCardTransactions::add(giftCardOperation, _cardNumber, _channelId,
                                _terminalId, _staffId, _transactionId, _receiptId, -1 * _amountMST,
                                str2Date(_transDate,_dateSequence), str2time(_transTime));

                            tGiftCardTable.unlockCard(tGiftCardTable.OneTimeRedemption && giftCardOperation == RetailGiftCardOperation::Redeem);
                            giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];
                            eventSource.EventWritePaymentsGiftCardRecordIsCreated(tGiftCardTable.RecId);
                        }
                        else
                        {
                            giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];
                            eventSource.EventWritePaymentsGiftCardRecordAlreadyExists(tGiftCardTable.RecId, lastTransactionId);

                            if (tGiftCardTable.reserved == NoYes::Yes)
                            {
                                tGiftCardTable.unlockCard(tGiftCardTable.OneTimeRedemption && giftCardOperation == RetailGiftCardOperation::Redeem);
                            }
                        }
                    }
                    
                }
                else
                {
                    giftCardStatus = [false, "@RET2431"];
                    eventSource.EventWritePaymentsGiftCardRecordNotFound(_cardNumber);
                }
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardPaymentError(_cardNumber);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsGiftCardPayConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardPayRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsGiftCardPayConflictException();
            }

            giftCardStatus = [false, "@RET2429"];
        }
        catch
        {
            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardPaymentError(_cardNumber);
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>giftCardRelease</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to release a gift card, after it has been issued.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container giftCardRelease(RetailGiftCardId   _cardNumber)
    {
        #OCCRetryCount

        container giftCardStatus = [false, '', '']; // Status, ErrorMsg, CardNumber
        RetailGiftCardTable tGiftCardTable;
        str giftCardCompany;
        AmountMST amountMST = 0;
        Counter   pCounter = 0;

        try
        {
            giftCardCompany = RetailParameters::find().GiftCardCompany;
            changeCompany(giftCardCompany)
            {
                ttsbegin;

                if (_cardNumber != '')
                {
                    tGiftCardTable = RetailGiftCardTable::find(_cardNumber, true);
                }

                if (tGiftCardTable)
                {
                    tGiftCardTable.unlockCard();

                    giftCardStatus = [true, '', _cardNumber];
                }
                else
                {
                    giftCardStatus = [false,"@RET2431"];
                    eventSource.EventWritePaymentsGiftCardNotExistAtGiftCardRelease(_cardNumber);
                }

                ttscommit;
            }
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            giftCardStatus = [false, "@RET2429", ''];
            eventSource.EventWritePaymentsGiftCardReleaseError(_cardNumber);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsGiftCardReleaseConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardReleaseRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsGiftCardReleaseConflictException();
            }

            giftCardStatus = [false, "@RET2429", ''];
        }
        catch
        {
            giftCardStatus = [false, "@RET2429", ''];
            eventSource.EventWritePaymentsGiftCardReleaseError(_cardNumber);
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultTradeDates_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes trade dates with default values.
    /// </summary>
    /// <param name="_salesParmUpdate">
    /// the <c>SalesParmUpdate</c> record.
    /// </param>
    private static void initDefaultTradeDates_W(SalesParmUpdate _salesParmUpdate)
    {
        SalesParmTable salesParmTable;

        boolean salesDateEnabled = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) ||
                        (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll) &&
                         isConfigurationkeyEnabled(configurationKeyNum(TradeDates_W)));

        if (!salesDateEnabled)
            return;

        ttsBegin;

        update_recordset salesParmTable
        setting SalesDate_W = salesParmTable.TransDate
        where
            salesParmTable.ParmId      == _salesParmUpdate.parmId &&
            salesParmTable.SalesDate_W == dateNull();

        update_recordset salesParmTable
        setting VatDueDate_W = salesParmTable.TransDate
        where
            salesParmTable.ParmId      == _salesParmUpdate.parmId &&
            salesParmTable.VatDueDate_W == dateNull();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailCreditVoucherTable</c>.
    /// </summary>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.createdInStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.createdByTerminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailCreditVoucherTable.createdByStaffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailCreditVoucherTable.createdByTransactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailCreditVoucherTable.createdByReceipId field.
    /// </param>
    /// <param name="_lineNum">
    /// ID of the RetailCreditVoucherTable.createdByLineNum field.
    /// </param>
    /// <param name="_currencyCode">
    /// ID of the RetailCreditVoucherTable.currencyCode field.
    /// </param>
    /// <param name="_amountMST">
    /// Value for the RetailCreditVoucherTable.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value for the RetailCreditVoucherTable.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value for the RetailCreditVoucherTable.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueCreditMemo(RetailStoreId       _storeId,
                                            RetailTerminalId    _terminalId,
                                            RetailStaffId       _staffId,
                                            RetailTransactionId _transactionId,
                                            RetailReceiptId     _receiptId,
                                            RetailLineNum       _lineNum,
                                            CurrencyCode     _currencyCode,
                                            AmountMST        _amountMST,
                                            str              _transDate,//RBOTransDate     _transDate,
                                            str              _transTime,//RetailTransTime     _transTime)
                                            int              _dateSequence = 321)
    {
        #OCCRetryCount

        container           creditVoucherStatus = [false,0];
        AmountMST           amountMST = 0;
        Counter             pCounter = 0;
        NumberSeq           numberSeq;
        RetailEntryId       entryId;

        try
        {
            ttsbegin;

            numberSeq = NumberSeq::newGetNum(RetailParameters::numRefCreditVoucherId());
            entryId = numberSeq.num();

            numberSeq.used();

            creditVoucherStatus = RetailCreditVoucherTable::createRBOCreditVoucherTable(   entryId,
                                                                                        _storeId,
                                                                                        _terminalId,
                                                                                        _staffId,
                                                                                        _transactionId,
                                                                                        _receiptId,
                                                                                        _lineNum,
                                                                                        _currencyCode,
                                                                                        _amountMST,
                                                                                        str2Date(_transDate,_dateSequence),//_transDate,
                                                                                        str2time(_transTime)); // _transTime

            ttscommit;
            eventSource.EventWritePaymentsCreditMemoIssued(entryId);
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
            {
                retry;
            }

            creditVoucherStatus = [false,"@RET2382",''];
            eventSource.EventWritePaymentsCreditMemoIssueError(entryId);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsCreditMemoIssueConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsCreditMemoIssueRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsCreditMemoIssueUpdateConflictException();
            }

            creditVoucherStatus = [false,"@RET2382",''];
        }
        catch
        {
            creditVoucherStatus = [false,"@RET2382",''];
            eventSource.EventWritePaymentsCreditMemoIssueError(entryId);
        }

        return creditVoucherStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>issueGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for creating the record in <c>RetailGiftCardTransactions</c> table.
    /// Initially the gift card is marked as reserved.  Call giftCardRelease to clear the reservation.
    /// </summary>
    /// <param name="_cardNumber">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTransactions.channel field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTransactions.terminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailGiftCardTransactions.staffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTransactions.transactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailGiftCardTransactions.receiptId field.
    /// </param>
    /// <param name="_currencyCode">
    /// <c>CurrencyCode</c>
    /// </param>
    /// <param name="_amountMST">
    /// Value of the RetailGiftCardTransactions.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value of the RetailGiftCardTransactions.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value of the RetailGiftCardTransactions.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <param name="_reserved">
    /// Issues a reserved gift card if set to true.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container issueGiftCard(RetailGiftCardId   _cardNumber,
                                           RetailChannelRecId  _channelId,
                                           RetailTerminalId    _terminalId,
                                           RetailStaffId       _staffId,
                                           RetailTransactionId _transactionId,
                                           RetailReceiptId     _receiptId,
                                           CurrencyCode     _currencyCode,
                                           AmountMST        _amountMST,
                                           str              _transDate,
                                           str              _transTime,
                                           int              _dateSequence = 321,
                                           boolean          _reserved = true)
    {
        #OCCRetryCount

        container giftCardStatus = [false, '', '']; // Status, ErrorMsg, CardNumber
        RetailGiftCardTable tGiftCardTable;
        str giftCardCompany;
        AmountMST amountMST = 0;
        Counter   pCounter = 0;

        NumberSeq                   numberSeq ;

        try
        {
            giftCardCompany = RetailParameters::find().GiftCardCompany;

            if (giftCardCompany == '')
            {
                giftCardStatus = [false, "@REX4520246", ''];
                eventSource.EventWritePaymentsGiftCardCompanyNotSetup();
            }
            else
            {
                changeCompany(giftCardCompany)
                {
                    boolean _transactionExists = RetailGiftCardTransactions::findTransaction(RetailGiftCardOperation::Issue, _cardNumber, _transactionId, _amountMST);

                    ttsbegin;

                    // If RetailEx3 has not specified any Card number then create one.
                    if (_cardNumber == '')
                    {
                        numberSeq = NumberSeq::newGetNum(RetailParameters::numRefGiftCardId());
                        _cardNumber = numberSeq.num();
                        numberSeq.used();
                    }

                    if (!_transactionExists)
                    {
                        tGiftCardTable = RetailGiftCardTable::createCard(
                            _cardNumber,
                            _currencyCode,
                            MCRGiftCardType::Physical,
                            DateTimeUtil::newDateTime(str2Date(_transDate,_dateSequence), str2time(_transTime)),
                            RetailChannelTable::findByRecId(_channelId).ChannelTimeZone);

                        if (tGiftCardTable)
                        {
                            if (_reserved)
                            {
                                tGiftCardTable.reserveCard(_terminalId, _channelId, _transactionId); // Lock new cards until paid for...
                            }

                            RetailGiftCardTransactions::add(RetailGiftCardOperation::Issue, _cardNumber, _channelId, _terminalId,
                            _staffId, _transactionId, _receiptId, _amountMST,
                            str2Date(_transDate,_dateSequence), str2time(_transTime));

                            giftCardStatus = [true, '', _cardNumber];
                        }
                        else
                        {
                            giftCardStatus = [false, "@RET2430", ''];
                            eventSource.EventWritePaymentsGiftCardAlreadyExists(_cardNumber);
                        }
                    }
                    else
                    {
                        giftCardStatus = [true, '', _cardNumber];
                        eventSource.EventWritePaymentsGiftCardAlreadyExists(_cardNumber);
                    }

                    ttscommit;
                }
            }
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            giftCardStatus = [false, "@RET2429", ''];
            eventSource.EventWritePaymentsGiftCardIssueError(_cardNumber);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsGiftCardIssueConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardIssueRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsGiftCardIssueUpdateConflictException();
            }

            giftCardStatus = [false, "@RET2429", ''];
        }
        catch
        {
            giftCardStatus = [false, "@RET2429", ''];
            eventSource.EventWritePaymentsGiftCardIssueError(_cardNumber);
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>MarkItemsReturned</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method updates the RetailTransactionSalesTrans.returnQty with the value in <c>returnQty</c> if the RetailTransactionSalesTrans.returnQty + returnQty > RetailTransactionSalesTrans.qty field.
    /// </summary>
    /// <param name="itemReturnXmlStr">
    /// Return items serialized to xml string.
    /// Example:
    /// <ArrayOfItemReturn>
    ///   <ItemReturn>
    ///     <TransactionId>100001</TransactionId>
    ///     <StoreId>1001</StoreId>
    ///     <TerminalId>1001</TerminalId>
    ///     <LineNumber>1</LineNumber>
    ///     <Quantity>1.00</Quantity>
    ///   </ItemReturn>
    ///   <ItemReturn>
    ///     <TransactionId>100002</TransactionId>
    ///     <StoreId>1001</StoreId>
    ///     <TerminalId>1001</TerminalId>
    ///     <LineNumber>2</LineNumber>
    ///     <Quantity>2.00</Quantity>
    ///   </ItemReturn>
    /// </ArrayOfItemReturn>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container MarkItemsReturned(str itemReturnXmlStr)
    {
        RetailTransactionSalesTrans    transactionSalesTrans;
        RetailTransactionId            transactionId;
        RetailStoreId                  storeId;
        RetailChannelRecId             channelId;
        RetailTerminalId               terminalId;
        LineNum                     lineNum;
        Qty                         returnQty;
        container                   ret = [true,''];
        int                         transaction;
        XmlDocument         itemReturnXml;
        XmlNodeList         itemReturnList;
        XmlElement          itemReturn;
        XmlElement          element;
        int                 i;

        try
        {
            itemReturnXml = new XmlDocument();
            itemReturnXml.loadXml(itemReturnXmlStr);
            itemReturnList = itemReturnXml.getNamedElement('ArrayOfItemReturn').childNodes();
        }
        catch (Exception::Error)
        {
            return [false, 'Error parsing input xml string'];
        }

        if (itemReturnList == null || itemReturnList.length() == 0)
        {
            return [false, 'No item return found in input xml string'];
        }

        int fromLine = infologLine();

        try
        {
            ttsbegin;
            for (i = 0; i < itemReturnList.length(); i++)
            {
                itemReturn = itemReturnList.item(i);

                transactionId = itemReturn.getNamedElement('TransactionId').text();
                storeId = itemReturn.getNamedElement('StoreId').text();

                element = itemReturn.getNamedElement('ChannelId');
                if (element != null)
                {
                    channelId = str2recId(element.text());
                }
                else
                {
                    channelId = 0;
                }

                terminalId = itemReturn.getNamedElement('TerminalId').text();
                lineNum =  str2num(itemReturn.getNamedElement('LineNumber').text());
                returnQty = str2num(itemReturn.getNamedElement('Quantity').text());

                transactionSalesTrans = RetailTransactionSalesTrans::find(transactionId,
                                                                    storeId,
                                                                    terminalId,
                                                                    lineNum,
                                                                    true,
                                                                    channelId);

                if (transactionSalesTrans)
                {
                    if (transactionSalesTrans.returnQty + returnQty < transactionSalesTrans.qty)
                    {
                        ret = conpoke(ret, 1, false);
                        str errorMsg = strfmt("@RET4546",transactionSalesTrans.itemId + num2char(10),
                                                        num2str(abs(transactionSalesTrans.qty),4,0,0,0) + num2char(10),
                                                        num2str(abs(transactionSalestrans.returnQty),4,0,0,0) + num2char(10));

                        ret = conpoke(ret, 2, errorMsg);
                        eventSource.EventWriteOrdersMarkItemsReturnedReturnExceedsOriginalWarning(funcName(), transactionSalesTrans.RecId);

                        if (RetailOrdersFeatureControl::allowThirdElementInReturnForMarkItemsReturned())
                        {
                            ret = conpoke(ret, 3, int2Str(Microsoft.Dynamics.Commerce.Runtime.DataModel.ReturnedItemValidationErrorType::ExceedsQuantityAvailableForReturn));
                            // We cannot throw error if the feature flag is disabled to allow other items to be marked if one fails.
                            // Throwing inside this if block keeps it backward compatible.
                            throw error(errorMsg);
                        }
                    }
                    else
                    {
                        try
                        {
                            transactionSalesTrans.returnQty += returnQty;
                            transactionSalesTrans.update();
                            eventSource.EventWriteOrdersMarkItemsReturnedTransactionUpdated(funcName(), transactionSalesTrans.RecId);
                        }
                        catch (Exception::UpdateConflict)
                        {
                            ret = conpoke(ret, 1, false);
                            ret = conpoke(ret, 2, strfmt("@RET4547",transactionId,storeId,terminalId,lineNum));
                            eventSource.EventWriteOrdersMarkItemsReturnedCouldNotUpdateTableWarning(funcName(), transactionSalesTrans.RecId);
                            throw Exception::UpdateConflictNotRecovered;
                        }
                    }
                }
                else
                {
                    ret = conpoke(ret, 1, false);

                    str errorMsg = strfmt("@RET4548",transactionId,storeId,terminalId,lineNum);
                    ret = conpoke(ret, 2, errorMsg);

                    eventSource.EventWriteOrdersMarkItemsReturnedCouldNotFindTransactionWarning(funcName());
                    
                    if (RetailOrdersFeatureControl::allowThirdElementInReturnForMarkItemsReturned())
                    {
                        ret = conpoke(ret, 3, int2Str(Microsoft.Dynamics.Commerce.Runtime.DataModel.ReturnedItemValidationErrorType::TransactionNotFound));
                        // We cannot throw error if the feature flag is disabled to allow other items to be marked if one fails.
                        // Throwing inside this if block keeps it backward compatible.
                        throw error(errorMsg);
                    }
                }

                transaction += 1;
            }
            ttscommit;
        }
        catch (Exception::Error)
        {
            if (conPeek(ret, 1) == false)
            {
                eventSource.EventWriteOrdersMarkItemsReturnedEncounteredException(funcName());
                return ret;
            }
            else
            {
                str error = RetailUtilities::getInfologMessages(fromLine);
                eventSource.EventWriteOrdersMarkItemsReturnedEncounteredException(funcName());
                return [false, error];
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the record in <c>RetailTerminalTable</c>. If the <c>dimension</c> exist for field RetailTerminalTable.Dimensions then <c>paymentDimension</c>
    /// is initialized with RetailTerminalTable.Dimensions; else method checks for the record in <c>RetailStoreTable</c> and if the record exist and the value in
    /// RetailStoreTable.dimension then <c>paymentDimension</c> is initialized with RetailStoreTable.dimension.
    /// </summary>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <returns>
    /// <c>paymentDimension</c>
    /// </returns>

    public static DimensionDefault paymentDimension(RetailTerminalId _terminalId)
    {
        RetailTerminalTable        terminalTable = RetailTerminalTable::find(_terminalId);
        RetailStoreTable           storeTable;
        DimensionDefault           paymentDimension;
        ;

        if (terminalTable)
        {
            if (terminalTable.DefaultDimension)
                paymentDimension = terminalTable.DefaultDimension;
            else
            {
                storeTable = RetailStoreTable::findRecId(terminalTable.StoreRecId);

                if (storeTable && storeTable.DefaultDimension)
                    paymentDimension = storeTable.DefaultDimension;
            }
        }

        return paymentDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentsMade</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method finds the Prepayment and payments for the invoice.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustInvoiceJour.InvoiceId field.
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <returns>
    /// Prepayment and payments for the invoice.
    /// </returns>
    /// <remarks>
    /// RetailPrepaymentTable.totalPaymentsMade method returns the unsettled amount which has been paid to the sales order.
    /// </remarks>
    private static AmountCur paymentsMade(InvoiceId _invoiceId)
    {
        CustTrans           custTrans;
        AmountCur           totalPaymentsMade;

        //Find payments for the invoice
        while select Invoice, TransType, AmountCur from custTrans
        where custTrans.Invoice     == _invoiceId
          && custTrans.TransType   == LedgerTransType::None
        {
            totalPaymentsMade += -custTrans.AmountCur;
        }

        return totalPaymentsMade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>payInvoices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pay multiple invoices given the input parameter.
    /// </summary>
    /// <param name = "_xmlInvoiceParameter">
    /// The XML contains invoice parameters to be paid. Those are:
    /// TransactionId: The transaction identifier.
    /// StoreId: The store number identifier.
    /// TerminalId: The terminal identifier.
    /// PaymentInvoices: The list of invoices to be paid, contains sub element of:
    /// InvoiceId: The invoice identifier.
    /// AmountBalance: The invoice amount to be paid.
    /// InvoiceTypeValue: The invoice type represented in int.
    /// </param>
    /// <returns>The container result of pay invoices.</returns>
    public static container payInvoices(str _xmlInvoiceParameter)
    {
        str getStringElement(XmlElement _rootElement, str _elementName, boolean _isMandatory)
        {
            XmlElement currentElement = _rootElement.getNamedElement(_elementName);

            if (currentElement == null)
            {
                throw error(strFmt('Could not find element name %1 on xml input', _elementName));
            }

            str textValue = currentElement.text();

            if (textValue == '' && _isMandatory)
            {
                throw error(strFmt('Text value is empty on element name %1', _elementName));
            }

            return textValue;
        }

        XmlDocument invoiceParameterXmlDoc = new XmlDocument();
        invoiceParameterXmlDoc.loadXml(_xmlInvoiceParameter);
        XmlElement rootElement = invoiceParameterXmlDoc.documentElement();

        RetailTransactionId transactionId = getStringElement(rootElement, 'TransactionId', true);
        RetailStoreId storeId = getStringElement(rootElement, 'StoreId', false);
        RetailTerminalId terminalId = getStringElement(rootElement, 'TerminalId', false);

        XmlElement invoicesRootElement = rootElement.getNamedElement('PaymentInvoices');
        boolean success = true;
        str errorMessage = '';
        int fromLine = infologLine();

        try
        {
            if (invoicesRootElement != null)
            {
                XmlNodeList invoices = invoicesRootElement.childNodes();

                ttsbegin;

                for (int i = 0; i < invoices.length(); i++)
                {
                    XmlNode invoiceNode = invoices.item(i);
                    InvoiceId invoiceId = invoiceNode.getNamedElement('Id').text();
                    AmountCur balance = str2Num(invoiceNode.getNamedElement('AmountBalance').text());
                    RetailInvoiceType invoiceType = str2Int(invoiceNode.getNamedElement('InvoiceTypeValue').text());

                    container resultPayInvoicesInternal = RetailTransactionServiceTransactions::payOpenInvoiceInternal(invoiceId, balance, terminalId, storeId, transactionId, invoiceType);
                    boolean settlementSuccessful = conPeek(resultPayInvoicesInternal, 1);

                    if (!settlementSuccessful)
                    {
                        success = false;
                        errorMessage = conPeek(resultPayInvoicesInternal, 2);
                        break;
                    }
                }

                if (success)
                {
                    ttscommit;
                }
                else
                {
                    ttsabort;
                }
            }
        }
        catch(Exception::Error)
        {
            success = false;
            errorMessage = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
        }

        return [success, errorMessage];
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySalesInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for calculating the payment for the sales invoice, create and post the payment journal.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container paySalesInvoice(InvoiceId           _invoiceId,
                                            AmountCur           _paymentAmount,
                                            RetailTerminalId       _terminalId,
                                            RetailStoreId          _storeId,
                                            RetailTransactionId    _transactionId)
    {
        return RetailTransactionServiceTransactions::payOpenInvoiceInternal(_invoiceId, _paymentAmount, _terminalId,
             _storeId, _transactionId, RetailInvoiceType::SalesOrder);
    }

]]></Source>
			</Method>
			<Method>
				<Name>payOpenInvoiceInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for calculating the payment for the open invoice, create and post the payment journal.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <param name="_invoiceType">
    /// The retail invoice type.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    private static container payOpenInvoiceInternal(InvoiceId _invoiceId, AmountCur _paymentAmount, RetailTerminalId _terminalId,
        RetailStoreId _storeId, RetailTransactionId _transactionId, RetailInvoiceType _invoiceType)
    {
        CustTrans               custTrans;

        CustInvoiceJour         custInvoiceJour;
        ProjInvoiceJour         projInvoiceJour;
        AmountCur               totalPaymentsMade = _paymentAmount;
        container               paymentSuccess = [true, ''];
        LedgerTransType         ledgerTransType = RetailTransactionServiceInvoices::invoiceTypeToLedgerTransType(_invoiceType);
        boolean                 isSalesOrderInvoice = RetailTransactionServiceInvoices::isSalesOrderInvoice(_invoiceType);
        int                     fromLine = infologLine();

        try
        {
            ttsbegin;

            select firstonly custTrans
            where custTrans.Invoice == _invoiceId
                && custTrans.TransType == ledgerTransType;

            if (custTrans)
            {
                if (_invoiceType == RetailInvoiceType::Project || _invoiceType == RetailInvoiceType::ProjectCreditNote)
                {
                    select firstonly projInvoiceJour
                        where projInvoiceJour.ProjInvoiceId == _invoiceId
                        && projInvoiceJour.InvoiceAccount == custTrans.AccountNum;
                }
                else
                {
                    select firstonly custInvoiceJour
                        where custInvoiceJour.InvoiceId == _invoiceId
                        && (custInvoiceJour.SalesType == SalesType::Sales || custInvoiceJour.SalesType == SalesType::Journal
                            || (_paymentAmount < 0 && custInvoiceJour.SalesType == SalesType::ReturnItem));
                }

                if ((custInvoiceJour || projInvoiceJour) && ((isSalesOrderInvoice && custInvoiceJour.SalesId) || (!isSalesOrderInvoice)))
                {
                    totalPaymentsMade += RetailTransactionServiceTransactions::paymentsMade(_invoiceId);

                    paymentSuccess = RetailTransactionServiceTransactions::postInvoicePayment(_paymentAmount,    //Creates and posts payment journal
                    custTrans.AccountNum,
                                                                           _invoiceId,
                                                                           _terminalId,
                                                                           _storeId,
                                                                           _transactionId);

                    if (conPeek(paymentSuccess, 1))
                    {
                        paymentSuccess = RetailTransactionServiceTransactions::settleInvoice(_invoiceId, _invoiceType);
                    }
                }
                else
                {
                    paymentSuccess = [false,"@RET2434"]; //Could not find the sales order.
                    eventSource.EventWriteOrdersPayOpenInvoiceInternalOrderNotFoundWarning(funcName());
                }
            }
            else
            {
                paymentSuccess = [false,strFmt("@RET2433",_invoiceId)]; //Could not find the invoice %1.
                eventSource.EventWriteOrdersPayOpenInvoiceInternalInvoiceNotFoundWarning(funcName());
            }

            if (conPeek(paymentSuccess,1))
                ttscommit;
            else
                ttsabort;
        
        }
        catch (Exception::Error)
        {
            paymentSuccess = [false, RetailTransactionServiceUtilities::getInfologMessages(fromLine)];
        }

        return paymentSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paySalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for payment of sales order. Method performs the following:
    /// 1.Creates and posts payment journal.
    /// 2.Return error if the total prepayment exceed the sales order total.
    /// </summary>
    /// <param name="_salesId">
    /// ID of the SalesTable.SalesId firld.
    /// </param>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    public static container paySalesOrder(SalesId           _salesId,
                                          AmountCur         _paymentAmount,
                                          RetailTerminalId     _terminalId,
                                          RetailStoreId        _storeId,
                                          RetailTransactionId  _transactionId)
    {
        RetailTransactionService transactionService = new RetailTransactionService();

        SalesTable              salesTable;
        CustInvoiceJour         custInvoiceJour;
        Set                     invoices = new Set(Types::String);
        AmountCur               salesOrderTotal;
        SalesTotals             salesTotals;
        AmountCur               totalPaymentsMade = _paymentAmount;
        container               paymentSuccess = [true,''];

        ttsbegin;

        salesTable = SalesTable::find(_salesId);

        if (salesTable)
        {
            // Remember all in invoices for this sale order so far.
            while select SalesId, InvoiceId from custInvoiceJour
                where custInvoiceJour.SalesId == _salesId
            {
                invoices.add(custInvoiceJour.InvoiceId);
            }

            salesTotals = SalesTotals::construct(salesTable,SalesUpdate::All);
            salesTotals.calc();
            salesOrderTotal = salesTotals.totalAmount();

            if (totalPaymentsMade <= salesOrderTotal)
            {
                paymentSuccess = RetailtransactionServiceTransactions::postOrderPayment(_paymentAmount,    //Creates and posts payment journal
                                                                     salesTable,
                                                                     _terminalId,
                                                                     _storeId,
                                                                     _transactionId);
            }
            else
            {
                paymentSuccess = [false,"@RET2435"];  //Return error if the total prepayment exceed the sales order total
                eventSource.EventWriteOrdersPaySalesOrderPaymentExceedsTotalWarning(funcName(), salesTable.RecId);
            }

            //If the payment posted, the order is fully paid and the parameter is true, create an invoice and settle
            if (conPeek(paymentSuccess,1) && totalPaymentsMade == salesOrderTotal && RetailParameters::find().PostSalesOrderWhenPaid)
            {
                paymentSuccess = RetailtransactionServiceTransactions::postSalesOrder(salesTable);
            }
        }
        else
        {
            paymentSuccess = [false,strFmt("@RET4513",_salesId)];
            eventSource.EventWriteOrdersPaySalesOrderCouldNotFindOrderWarning(funcName());
        }

        if (conPeek(paymentSuccess,1))
        {
            ttscommit;
            eventSource.EventWriteOrdersPaySalesOrderPaymentSuccess(funcName(), salesTable.RecId);
        }
        else
        {
            ttsabort;
            eventSource.EventWriteOrdersPaySalesOrderPaymentFailedWarning(funcName(), salesTable.RecId);
        }

        return paymentSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInvoicePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method creates the journal entries in <c>LedgerJournalTable</c> and <c>LedgerJournalTrans</c> for the invoice payment.
    /// </summary>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_custAccount">
    /// ID of the customer account.
    /// </param>
    /// <param name="_invoiceId">
    /// ID of the LedgerJournalTrans.MarkedInvoice field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful; else false and appropriate string message.
    /// </returns>
    private static container postInvoicePayment(AmountCur          _paymentAmount,
                                         CustAccount        _custAccount,
                                         InvoiceId          _invoiceId,
                                         RetailTerminalId      _terminalId,
                                         RetailStoreId         _storeId,
                                         RetailTransactionId   _transactionId)
    {
        RetailParameters           rboParameters = RetailParameters::find();

        LedgerJournalTable      ledgerJournalTable;
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalCheckPost  ledgerJournalCheckPost;
        JournalId               journalId;
        NumberSeq               numberSeq;
        Voucher                 voucher;
        container               postingSuccess = [true, ''];
        LedgerJournalName       ledgerJournalName;        

        boolean             isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        if (LedgerJournalName::exist(rboParameters.PrePaymentLedgerJournalName))
        {
            try
            {
                journalId = JournalTableData::newTable(ledgerJournalTable).nextJournalId();

                ledgerJournalTable.clear();
                ledgerJournalTable.JournalNum   = journalId;
                ledgerJournalTable.initFromLedgerJournalName(rboParameters.PrePaymentLedgerJournalName);
                ledgerJournalTable.Name = strFmt("@RET4501",_invoiceId);
                ledgerJournalTable.insert();

                if (!RetailDisplayCustomerFinancialDimensionInVouchersForSalesInvoiceOperationsFlight::instance().isEnabled())
                {
                    ledgerJournalTable.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(any2int64(RetailTransactionServiceTransactions::paymentDimension(_terminalId)), ledgerJournalTable.DefaultDimension);
                }
                else
                {
                    ledgerJournalTable.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(custTable::find(_custAccount).DefaultDimension, any2int64(RetailTransactionServiceTransactions::paymentDimension(_terminalId)), ledgerJournalTable.DefaultDimension);
                }
 
                ledgerJournalTable.update();

                numberSeq   = NumberSeq::newGetVoucherFromCode(
                    NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).NumberSequence,
                    NumberSeqScopeFactory::createDefaultScope(), true, true);
                voucher     = numberSeq.voucher();

                select firstonly OffsetLedgerDimension, OffsetAccountType from ledgerJournalName where ledgerJournalName.JournalName == rboParameters.PrePaymentLedgerJournalName;

                ledgerJournalTrans.clear();
                ledgerJournalTrans.initValue();
                ledgerJournalTrans.JournalNum           = ledgerJournalTable.JournalNum;
                ledgerJournalTrans.LineNum              = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
                ledgerJournalTrans.AccountType          = LedgerJournalACType::Cust;
                ledgerJournalTrans.parmAccount(_custAccount);
                ledgerJournalTrans.DefaultDimension     = ledgerJournalTable.DefaultDimension;
                ledgerJournalTrans.OffsetAccountType    = ledgerJournalName.OffsetAccountType;

                if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    if (rboParameters.PrepaymentLedgerDimension)
                    {
                        ledgerJournalTrans.parmOffsetLedgerDimension(ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(rboParameters.PrepaymentLedgerDimension, ledgerJournalTrans.getOffsetCompany()));
                    }
                    else
                    {
                        postingSuccess = [false, strFmt("@Retail:InvoicePaymentOffsetAccountBlankInRetailParameters", ledgerJournalTable.JournalNum)];
                        throw Error(strFmt("@Retail:InvoicePaymentOffsetAccountBlankInRetailParameters", ledgerJournalTable.JournalNum));
                    }
                }
                else
                {
                    LedgerJournalAC offsetAccount = LedgerJournalName::find(ledgerJournalTable.JournalName).parmOffsetAccount();
                    
                    if (offsetAccount)
                    {
                        ledgerJournalTrans.parmOffsetAccount(offsetAccount);
                    }
                    else
                    {
                        postingSuccess = [false, strFmt("@Retail:InvoicePaymentOffsetAccountBlankInJournalConfiguration", ledgerJournalTable.JournalNum)];
                        throw Error(strFmt("@Retail:InvoicePaymentOffsetAccountBlankInJournalConfiguration", ledgerJournalTable.JournalNum));
                    }
                }

                RetailStoreTable retailStoreTable = RetailStoreTable::find(_storeId);
                ledgerJournalTrans.CurrencyCode         = CompanyInfoHelper::standardCurrency();
                ledgerJournalTrans.ExchRate             = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode);
                ledgerJournalTrans.JournalNum           = ledgerJournalTable.JournalNum;
                ledgerJournalTrans.TransDate            = RetailTransactionServiceTransactions::getStoreOrUserSystemDate(retailStoreTable);
                ledgerJournalTrans.MarkedInvoice        = _invoiceId;
                ledgerJournalTrans.Voucher              = voucher;

                if (_paymentAmount < 0)
                    ledgerJournalTrans.AmountCurDebit   = abs(_paymentAmount);
                else
                    ledgerJournalTrans.AmountCurCredit  = abs(_paymentAmount);

                ledgerJournalTrans.TransactionType      = LedgerTransType::Payment;
                ledgerJournalTrans.Txt                  = strFmt("@RET4502",_invoiceId);
                ledgerJournalTrans.insert();

                if (isIndia)
                {
                    RetailTransactionService::setTaxInformationForJournalLine_IN(ledgerJournalTrans, retailStoreTable.inventLocation);
                }
                numberSeq.used();

                ledgerJournalCheckPost = LedgerJournalCheckPostRetail::newRBOLedgerJournalTable(ledgerJournalTable,NoYes::Yes,NoYes::No,_transactionId,_storeId,_terminalId);
                LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);               
            }
            catch (Exception::Error)
            {
                postingSuccess = [false,strFmt("@RET4503",ledgerJournalTable.JournalNum)];
                eventSource.EventWriteOrdersPostInvoicePaymentError(funcName(), ledgerJournalTable.RecId);
            }
        }
        else
        {
            postingSuccess = [false,"@RET4504"];
            eventSource.EventWriteOrdersPostInvoicePaymentCannotCreateJournalWarning(funcName());
        }

        return postingSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getStoreOrUserSystemDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the current system date using the store's or users preferred timezone.
    /// </summary>
    /// <param name = "_retailStoreTable">The retail store row if available.</param>
    /// <returns>The system date using the required timezone.</returns>
    internal static TransDate getStoreOrUserSystemDate(RetailStoreTable _retailStoreTable)
    {
        TransDate requiredDate;
        if (_retailStoreTable.RecId)
        {
            requiredDate = DateTimeUtil::getSystemDate(_retailStoreTable.ChannelTimeZone);
        }
        else
        {
            requiredDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        return requiredDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOrderPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method creates the journal entries in <c>LedgerJournalTable</c> and <c>LedgerJournalTrans</c> for the order payment.
    /// </summary>
    /// <param name="_paymentAmount">
    /// Amount stored in LedgerJournalTrans.AmountCurDebit if <c>_paymentAmount</c> is less than 0; else LedgerJournalTrans.AmountCurCredit.
    /// </param>
    /// <param name="_salesTable">
    /// Table buffer of <c>SalesTable</c>.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailTerminalTable.TerminalId field.
    /// </param>
    /// <param name="_storeId">
    /// <c>RetailStoreId</c>
    /// </param>
    /// <param name="_transactionId">
    /// <c>RetailTransactionId</c>
    /// </param>
    /// <returns>
    /// <c>Container</c> with the status as true if the creation of record is successful; else false and appropriate string message.
    /// </returns>
    private static container postOrderPayment(AmountCur        _paymentAmount,
                                       SalesTable       _salesTable,
                                       RetailTerminalId    _terminalId,
                                       RetailStoreId       _storeId,
                                       RetailTransactionId _transactionId)
    {
        RetailParameters           rboParameters = RetailParameters::find();
        RetailPrePaymentTrans      prePaymentTrans;
        CustTrans               custTrans;
        LedgerJournalTable      ledgerJournalTable;
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalCheckPost  ledgerJournalCheckPost;
        JournalId               journalId;
        NumberSeq               numberSeq;
        Voucher                 voucher;
        container               postingSuccess = [true,''];
        LedgerJournalName       ledgerJournalName;

        boolean             isIndia = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        if (LedgerJournalName::exist(rboParameters.PrePaymentLedgerJournalName))
        {
            try
            {
                journalId = JournalTableData::newTable(ledgerJournalTable).nextJournalId();

                ledgerJournalTable.clear();
                ledgerJournalTable.JournalNum   = journalId;
                ledgerJournalTable.initFromLedgerJournalName(rboParameters.PrePaymentLedgerJournalName);
                ledgerJournalTable.Name = strFmt("@RET4505",_salesTable.SalesId);
                ledgerJournalTable.insert();
                ledgerJournalTable.DefaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(any2int64(RetailTransactionServiceTransactions::paymentDimension(_terminalId)), ledgerJournalTable.DefaultDimension);
                ledgerJournalTable.update();

                numberSeq   = NumberSeq::newGetVoucherFromCode(
                    NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).NumberSequence,
                    NumberSeqScopeFactory::createDefaultScope(), true, true);
                voucher     = numberSeq.voucher();

                select firstonly OffsetLedgerDimension, OffsetAccountType from ledgerJournalName where ledgerJournalName.JournalName == rboParameters.PrePaymentLedgerJournalName;

                ledgerJournalTrans.clear();
                ledgerJournalTrans.initValue();
                ledgerJournalTrans.JournalNum           = ledgerJournalTable.JournalNum;
                ledgerJournalTrans.LineNum              = LedgerJournalTrans::lastLineNum(ledgerJournalTrans.JournalNum) + 1;
                ledgerJournalTrans.AccountType          = LedgerJournalACType::Cust;
                ledgerJournalTrans.parmAccount(_salesTable.CustAccount);
                ledgerJournalTrans.DefaultDimension     = ledgerJournalTable.DefaultDimension;
                ledgerJournalTrans.OffsetLedgerDimension= ledgerJournalName.OffsetLedgerDimension;
                ledgerJournalTrans.OffsetAccountType    = ledgerJournalName.OffsetAccountType;
                ledgerJournalTrans.CurrencyCode         = CompanyInfoHelper::standardCurrency();
                ledgerJournalTrans.ExchRate             = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode);
                ledgerJournalTrans.JournalNum           = ledgerJournalTable.JournalNum;
                ledgerJournalTrans.TransDate            = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                ledgerJournalTrans.PaymReference        = _salesTable.SalesId;
                ledgerJournalTrans.Voucher              = voucher;

                if (_paymentAmount < 0)
                    ledgerJournalTrans.AmountCurDebit   = abs(_paymentAmount);
                else
                    ledgerJournalTrans.AmountCurCredit  = abs(_paymentAmount);

                ledgerJournalTrans.TransactionType      = LedgerTransType::Payment;
                ledgerJournalTrans.Txt                  = strFmt("@RET4506",_salesTable.SalesId);
                ledgerJournalTrans.insert();

                if (isIndia)
                {
                    RetailTransactionService::setTaxInformationForJournalLine_IN(ledgerJournalTrans, RetailStoreTable::find(_storeId).inventLocation);
                }
                numberSeq.used();

                ledgerJournalCheckPost = LedgerJournalCheckPostRetail::newRBOLedgerJournalTable(ledgerJournalTable,NoYes::Yes,NoYes::No,_transactionId,_storeId,_terminalId);
                LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);

                custTrans = CustTrans::findVoucherDate(voucher,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

                if (custTrans && custTrans.PaymReference == _salesTable.SalesId)
                {
                    prePaymentTrans.clear();
                    prePaymentTrans.SalesId         = _salesTable.SalesId;
                    prePaymentTrans.CustTransRecId  = custTrans.RecId;
                    prePaymentTrans.insert();
                }
                else
                {
                    postingSuccess = [false,strFmt("@RET4507",_salesTable.SalesId)];
                    eventSource.EventWriteOrdersPostOrderPaymentNotPostForOrderWarning(funcName(), _salesTable.RecId);
                }
            }
            catch (Exception::Error)
            {
                postingSuccess = [false, strFmt("@RET4503",ledgerJournalTable.JournalNum)];
                eventSource.EventWriteOrdersPostOrderPaymentCannotCreateJournalWarning(funcName(), ledgerJournalTable.RecId);
            }
        }
        else
        {
            postingSuccess = [false,"@RET4504"];
            eventSource.EventWriteOrdersPostOrderPaymentError(funcName());
        }

        return postingSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesInvoice_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts sales order.
    /// </summary>
    /// <param name="_salesTable">
    /// The <c>SalesTable</c> record.
    /// </param>
    /// <param name="_specQty">
    /// Quantity to update.
    /// </param>
    private static void postSalesInvoice_RU(SalesTable _salesTable, SalesUpdate _specQty)
    {
        SalesFormLetter    salesFormLetter;
        LtDocNumberingCode docNumberingCode;

        DocumentStatus documentStatus;
        if (RetailParameters::find().PostFacture_RU == NoYes::Yes)
        {
            documentStatus = DocumentStatus::Facture_RU;
        }
        else
        {
            documentStatus = DocumentStatus::Invoice;
        }

        salesFormLetter = SalesFormLetter::construct(documentStatus);

        salesFormLetter.salesTable(_salesTable);
        salesFormLetter.initParmSalesTable(_salesTable);

        salesFormLetter.transDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        salesFormLetter.specQty(_specQty);
        salesFormLetter.proforma(false);
        salesFormLetter.printFormLetter(false);
        salesFormLetter.printCODLabel(false);
        salesFormLetter.printShippingLabel(false);
        salesFormLetter.usePrintManagement(false);

        salesFormLetter.createParmUpdateFromParmUpdateRecord(
            SalesFormletterParmData::initSalesParmUpdateFormletter(salesFormLetter.documentStatus(),
                                                                   salesFormLetter.pack(),
                                                                   true,
                                                                   CustParameters::find().CreditError,
                                                                   InventParameters::find().StornoPhysicalPosting_RU));

        salesFormLetter.initParameters(salesFormLetter.salesParmUpdate(), Printout::Current);

        if (_salesTable.InvoiceAutoNumbering_LT)
        {
            docNumberingCode = LtInvoiceAutoNumberingTable::findDocNumberingCodeForRetail();
            if (!docNumberingCode)
            {
                throw error(strFmt("@SYS4002053", curuserid()));
            }

            salesFormLetter.getSalesFormLetterContract().parmLtDocNumberingCode(docNumberingCode);
        }

        salesFormLetter.initLinesQuery();

        if (RetailParameters::find().UseDefaultTradeDates_W)
        {
            RetailTransactionServiceTransactions::initDefaultTradeDates_W(salesFormLetter.salesParmUpdate());
        }

        salesFormLetter.reArrangeNow(false);
        salesFormLetter.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSalesOrder</Name>
				<Source><![CDATA[
    /// </GEERU>

    /// <summary>
    /// Method is used for posting the sales order transaction.
    /// </summary>
    /// <param name="_salesTable">
    /// Table buffer of <c>Salestable</c>.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the posting is success; else false wih the appropriate string message.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Throws error if the sales order is not posted.
    /// </exception>
    private static container postSalesOrder(SalesTable _salesTable)
    {
        SalesFormLetter salesFormLetter;
        CustInvoiceJour custInvoiceJour;
        container       postingSuccess = [true,''];

        boolean         countryRegion_W = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);

        try
        {
            if (countryRegion_W)
            {
                RetailTransactionServiceTransactions::postSalesInvoice_RU(_salesTable, SalesUpdate::All);
            }
            else
            {
                salesFormLetter = SalesFormLetter::construct(DocumentStatus::Invoice);
                salesFormLetter.update(_salesTable,DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),SalesUpdate::All, AccountOrder::None,false,false);
            }

            select firstonly custInvoiceJour
            where custInvoiceJour.SalesId == _salesTable.SalesId
               && custInvoiceJour.InvoiceId
               && custInvoiceJour.SalesType == SalesType::Sales;

            if (!custInvoiceJour)
            {
                eventSource.EventWriteOrdersPostOrderPaymentCannotCreateJournal(funcName(), _salesTable.RecId);
                throw error(strFmt("@RET4508",_salesTable.SalesId));
            }
        }
        catch (Exception::Error)
        {
            eventSource.EventWriteOrdersPostSalesOrderCouldNotPostError(funcName(), _salesTable.RecId);
            postingSuccess = [false,strFmt("@RET4509",_salesTable.SalesId)];
        }

        return postingSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderListQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the order query.
    /// </summary>
    /// <param name="_sortingInfo">
    /// The sorting info.
    /// </param>
    /// <param name="_startDateTime">
    /// Start date-time for the range of journals.
    /// </param>
    /// <param name="_endDateTime">
    /// End date-time for the range of journals.
    /// </param>
    /// <returns>
    /// Query with default filters based date ranges.
    /// </returns>
    private static Query getOrderListQuery(
        XmlElement _sortingInfo,
        utcDateTime _startDateTime = DateTimeUtil::minValue(),
        utcDateTime _endDateTime = DateTimeUtil::maxValue())
    {
        Query   query;
        QueryBuildDataSource qbds;

        // Get the query
        query = new Query(queryStr(RetailOrderListQuery));

        // Add filters/ranges to the data source
        qbds = query.dataSourceTable(tableNum(SalesTable));

        // Change the endDateTime to the last scecond of that day, default it is the beginning second of that day.
        if (_endDateTime !=  DateTimeUtil::maxValue())
        {
            _endDateTime = DateTimeUtil::addSeconds(DateTimeUtil::addDays(_endDateTime, 1), -1);
        }

        // SalesTable ranges
        // Orders within the date range: "SalesTable.createdDateTime >= startDate && SalesTable.createdDateTime <= endDate"
        qbds.addRange(fieldNum(SalesTable, createdDateTime)).value(SysQuery::range(_startDateTime, _endDateTime));

        if (_sortingInfo != null)
        {
            // RetailOrderListQuery contains default orderBy field SalesTable.CreatedDateTime.
            // We should honor the client sorting info when provided.
            qbds.removeOrderByField(fieldNum(SalesTable, CreatedDateTime));

            XmlNodeList sortColumns = _sortingInfo.childNodes();
            for (int i = 0; i < sortColumns.length(); i++)
            {
                XmlNode sortColumnsNode = sortColumns.item(i);

                str columnName;
                SortOrder sortOrder;
                [columnName, sortOrder] = RetailTransactionServiceUtilities::parseSortColumn(sortColumnsNode);

                // Currently only the following sort columns are supported.
                // X++ string == operator is insensitive to string cases.
                switch (columnName)
                {
                    case 'CreatedDateTime':
                        qbds.addOrderByField(fieldNum(SalesTable, CreatedDateTime), sortOrder);
                        break;
                    case 'ConfirmedShipDate':
                        qbds.addOrderByField(fieldNum(SalesTable, ShippingDateConfirmed), sortOrder);
                        break;
                    default:
                        // Ignore other unsupported sort columns.
                        eventSource.EventWriteGetOrderListSearchSortColumnIgnored(columnName);
                        break;
                }
            }

            if (qbds.sortFieldCount() == 0)
            {
                // If the client does not provide any valid sort column, sort the results by SalesTable.CreatedDateTime descending.
                qbds.addOrderByField(fieldNum(SalesTable, CreatedDateTime), SortOrder::Descending);
            }
        }

        // return the query with default ranges applied.
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuoteListQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the quote query.
    /// </summary>
    /// <param name="_sortingInfo">
    /// The sorting info.
    /// </param>
    /// <param name="_startDateTime">
    /// Start date-time for the range of journals.
    /// </param>
    /// <param name="_endDateTime">
    /// End date-time for the range of journals.
    /// </param>
    /// <returns>
    /// Query with default filters based date ranges.
    /// </returns>
    private static Query getQuoteListQuery(
        XmlElement _sortingInfo,
        utcDateTime _startDateTime = DateTimeUtil::minValue(),
        utcDateTime _endDateTime = DateTimeUtil::maxValue())
    {
        Query   query;
        QueryBuildDataSource qbds;
        // Get the query
        query = new Query(queryStr(RetailQuoteListQuery));

        // Add filters/ranges to the data source
        qbds = query.dataSourceTable(tableNum(SalesQuotationTable));

        // Change the endDateTime to the last scecond of that day, default it is the beginning second of that day.
        if (_endDateTime !=  DateTimeUtil::maxValue())
        {
            _endDateTime = DateTimeUtil::addSeconds(DateTimeUtil::addDays(_endDateTime, 1), -1);
        }

        // SalesQuotationTable ranges
        // Orders within the date range: "SalesQuotationTable.createdDateTime >= startDate && SalesQuotationTable.createdDateTime <= endDate"
        qbds.addRange(fieldNum(SalesQuotationTable, createdDateTime)).value(SysQuery::range(_startDateTime, _endDateTime));

        // NOTE consider adding additional constrains here based upon the requirements.  For example:
        // * SalesIdRef is empty
        // * QuotationType == QuotationType::Sales
        // * QuotationStatus = SalesQuotationStatus::Created || SalesQuotationStatus::Approved || SalesQuotationStatus::Submitted

        if (_sortingInfo != null)
        {
            // RetailQuoteListQuery contains default orderBy field SalesQuotationTable.CreatedDateTime.
            // We should honor the client sorting info when provided.
            qbds.removeOrderByField(fieldNum(SalesQuotationTable, CreatedDateTime));

            XmlNodeList sortColumns = _sortingInfo.childNodes();
            for (int i = 0; i < sortColumns.length(); i++)
            {
                XmlNode sortColumnsNode = sortColumns.item(i);

                str columnName;
                SortOrder sortOrder;
                [columnName, sortOrder] = RetailTransactionServiceUtilities::parseSortColumn(sortColumnsNode);

                // X++ string == operator is insensitive to differences in string casing.
                switch (columnName)
                {
                    case 'CreatedDateTime':
                        qbds.addOrderByField(fieldNum(SalesQuotationTable, CreatedDateTime), sortOrder);
                        break;
                    default:
                        // Ignore other unsupported sort columns.
                        eventSource.EventWriteGetOrderListSearchSortColumnIgnored(columnName);
                        break;
                }
            }

            if (qbds.sortFieldCount() == 0)
            {
                // If the client does not provide any valid sort column, sort the results by SalesTable.CreatedDateTime descending.
                qbds.addOrderByField(fieldNum(SalesQuotationTable, CreatedDateTime), SortOrder::Descending);
            }
        }

        // return the query with default ranges applied.
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderListSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML arguments.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    /// <remarks>
    /// Xml argument example:
    /// <Arguments>
    ///  <CustomerAccountNumber/>
    ///  <CustomerName/>
    ///  <EmailAddress/>
    ///  <LoyaltyCardNumber/>
    ///  <CustomerPhoneNumber/>
    ///  <ReceiptEmailAddress/>
    ///  <SalesId />  Unclude wild charter, e.g, 10* to 20*
    ///  <ReceiptId/>
    ///  <OrderStatus />
    ///  <DocumentStatus />
    ///  <StartDateTime/>
    ///  <EndDateTime/>
    ///  <StoreId/>
    ///  <OrderType />
    ///  <ChannelReferenceId/>
    ///  <ChannelIds/>
    ///  <BusinessPartnerId/>
    ///  <CustomerRequisition/>
    ///
    ///  <LimitTransactionType/>
    ///  <TransactionId/>
    ///  <IncludeDetails/>
    ///
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///</Arguments>
    /// </remarks>
    public static container getOrderListSearch(str _xmlArgumentString)
    {
        XmlDocument         argsXml;
        XmlElement          argsRoot;

        RecId argCurrentChannelId;
        RetailTransactionId argTransactionId;
        RetailReceiptId argReceiptId;
        RetailOrderChannelReferenceId argChannelRefId;
        CustAccount argCustAccount;
        str argCustName;
        str custNameSearchText;
        RetailStoreId argStoreId;
        RetailItemId argItemId;
        RetailBarcode argBarcode;
        str argStartDate;
        str argEndDate;
        RetailReceiptEmail argReceiptEmailAddress = ''; // Receipt Email on the RetailTransacationTable
        str argEmailAddress = ''; // Email on the SalesTable
        str argLoyaltyCardNumber = '';
        str argCustomerPhoneNumber = '';
        InventSerialId argSerialNumber = '';
        boolean argIncludeDetails = false;
        boolean argLimitTransactionType = true;
        boolean argSearchOnlyRetailOrders = false;
        str argSalesId = '';
        str limitOrderTransactionTypes ;
        str notLimitOrderTransactionTypes ;
        str argCustomerRequisition = '';

        container           output = [true,''];
        utcDateTime         startDateTime = DateTimeUtil::minValue();
        utcDateTime         endDateTime = DateTimeUtil::maxValue();

        int resultsStartingPosition = 1;  // Absolute starting position
        int adjustedStartingPosition;
        int salesOrderRowCount = 0;
        int resultsMaxCount = #resultsCountOfTransaction;
        int             resultsCount;

        Query   retailOrderListQuery; // Query for SalesTable et. al.
        Query   retailQuoteListQuery; // Query for SalesQuotationTable
        QueryRun qr;
        QueryBuildDataSource qbds;
        QueryBuildDataSource qbdsRoot;  // Root (e.g., SalesTable or SalesQuotationTable)
        QueryBuildRange         qbr;

        SalesTable qSalesTable;
        SalesQuotationTable qSalesQuotationTable;
        boolean includeRetailSalesTable = false;
        boolean includeCustTable = false;
        boolean includeRetailTransactionTable = false;
        RetailSalesTable qRetailSalesTable;
        RetailSalesQuotationTable qRetailSalesQuotationTable;
        CustTable qCustTable;
        RetailTransactionTable qRetailTransactionTable;
        boolean canAddMore = true;
        boolean includeOrders, includeQuotes;

        RetailDlvModeTmp pickupDlvModes = RetailDlvMode::getPickupDeliveryModes();
        RetailDlvModeInventLocationTmp dlvModeInventLocationTmp;
        boolean hasPickupFulfillmentType = false;
        boolean hasShipFulfillmentType = false;

        str                 argOrderStatus = '';
        str                 argDocumentStatus = '';
        str                 argOrderType = '';
        str                 argDeliveryMode;
        str                 argPickUpStartDate;
        str                 argPickUpEndDate;
        str                 argPickupTimeslotStartTime;
        str                 argPickupTimeslotEndTime;
        str                 argBusinessPartnerId;

        // Get the string value of an XML element argument.
        str getArg(str argName)
        {
            str result = '';

            XmlElement xmlRoot = argsRoot.getNamedElement(argName);
            if (xmlRoot != null)
            {
                result = xmlRoot.text();
            }

            return result;
        }

        // Set record to QueryRun before iterate it
        void setTemporaryTableRecordsInQueryRun(QueryRun _queryRun, SalesIdTempTable _salesIdsByReceiptId)
        {
            if (argReceiptId && FeatureStateProvider::isFeatureEnabled(RetailOmniChannelGenerateOrderConfirmationIdFeature::instance()))
            {
                _queryRun.setRecord(_salesIdsByReceiptId);
            }

            if (RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled() && (hasPickupFulfillmentType || hasShipFulfillmentType))
            {
                _queryRun.setRecord(dlvModeInventLocationTmp);
            }

            if (argPickUpStartDate || argPickUpEndDate)
            {
                _queryRun.setRecord(pickupDlvModes);
            }
        }

        // Gets row count from orderListQuery
        int getOptimizedRowCountFromQuery(Query _orderListQuery, SalesIdTempTable _salesIdsByReceiptId)
        {
            // Below code taken from SysQuery::countTotal(queryRun)
            // Almost all of the logic was taken from it. With minor edits for query optimizations.
            // To make this query run using SELECT COUNT.
            QueryRun countQueryRun = new QueryRun(_orderListQuery);
            Query countQuery = countQueryRun.query();
            QueryBuildDataSource countDataSource = countQuery.dataSourceNo(1);
            countDataSource.update(false);
            countDataSource.sortClear();
            QueryBuildFieldList countBuildFilesList = countDataSource.fields();
            countBuildFilesList.dynamic(false);
            countBuildFilesList.clearFieldList();
            // Change "SELECT * FROM SalesTable" to "SELECT COUNT (RECID) FROM SalesTable"
            // In the SysQuery::countTotal code, this was done only if there was only one datasource.
            // But in our case, this should always be done.
            // The code in SysQuery::countTotal executes several queries and added up the number of rows in these dataSources,
            // this led to unrealistically large results, sometimes they were even negative.
            countDataSource.addSelectionField(fieldNum(Common, RecId), SelectionField::Count);
            countQueryRun = new QueryRun(countQuery);
            setTemporaryTableRecordsInQueryRun(countQueryRun, _salesIdsByReceiptId);
            if (countQueryRun.next())
            {
                return countQueryRun.get(tableNum(SalesTable)).RecId;
            }
            else
            {
                return 0;
            }
        }

        //
        // Main method body
        //

        eventSource.EventWriteOrderListSearchStarted();
        System.Diagnostics.Stopwatch sw = new System.Diagnostics.Stopwatch();
        sw.Start();

        // Parse the arguments
        argsXml   = new XmlDocument();
        argsXml.loadXml(_xmlArgumentString);
        argsRoot = argsXml.documentElement();

        argCustAccount = getArg('CustomerAccountNumber');
        argCustName = getArg('CustomerName');
        if (argCustName)
        {
            // Set wildcards for full name search.  For example <name>* or *<name>*  or *<name>
            // For full-name we will expect match to start with wild-cards beyond name provided
            custNameSearchText = strFmt('%1*', argCustName);
        }

        argEmailAddress = getArg('EmailAddress');
        argLoyaltyCardNumber = getArg('LoyaltyCardNumber');
        argCustomerPhoneNumber = getArg('CustomerPhoneNumber');
        argReceiptEmailAddress = getArg('ReceiptEmailAddress');
        argSalesId = getArg('SalesId');
        argReceiptId = getArg('ReceiptId');
        argOrderStatus = getArg('OrderStatus'); // comma separated list maps to SalesTable.SalesStatus
        argDocumentStatus = getArg('DocumentStatus'); // comma separated list maps to SalesTable.DocumentStatus
        argStartDate = getArg('StartDateTime');
        argEndDate = getArg('EndDateTime');
        argStoreId = getArg('StoreId');
        argOrderType = getArg('OrderType'); // comma separated list to include Customer Order (0), Quote (1).
        argChannelRefId = getArg('ChannelReferenceId');
        argTransactionId = getArg('TransactionId');
        argLimitTransactionType = ('false' != getArg('LimitTransactionType')); // Default to true - private const str mposOrderTransactionTypes = '19,27,33,31'
          
        if (argLimitTransactionType)
        {
            // '19,27,33,31,36'
            limitOrderTransactionTypes = strFmt('%1,%2,%3,%4,%5',
                enum2int(RetailTransactionType::CustomerOrder),
                enum2int(RetailTransactionType::PendingSalesOrder),
                enum2int(RetailTransactionType::AsyncCustomerOrder),
                enum2int(RetailTransactionType::AsyncCustomerQuote),
                enum2int(RetailTransactionType::SuspendedTransaction));

            // '!19,!27,!33,!31,!36'
            notLimitOrderTransactionTypes = strFmt('!%1,!%2,!%3,!%4,!%5',
                enum2int(RetailTransactionType::CustomerOrder),
                enum2int(RetailTransactionType::PendingSalesOrder),
                enum2int(RetailTransactionType::AsyncCustomerOrder),
                enum2int(RetailTransactionType::AsyncCustomerQuote),
                enum2int(RetailTransactionType::SuspendedTransaction));
        }

        // This is not required for advanced search but still useful for tests
        argIncludeDetails = ('true' == getArg('IncludeDetails'));

        if (argOrderType != '')
        {
            // We need to filter Orders (0), quotes (1)
            includeOrders = (strFind(argOrderType, '0', 1, strLen(argOrderType)) != 0);
            includeQuotes = (strFind(argOrderType, '1', 1, strLen(argOrderType)) != 0);
        }
        else
        {
            includeOrders = true; // Default to include orders in search result
            includeQuotes = true; // Default to include quotes in search result
        }

        // Get paging details
        [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

        // Get sorting info
        XmlElement sortingInfo = argsXml.documentElement().getNamedElement('SortingInfo');

        // Process the arguments

        if (argStartDate)
        {
            startDateTime =  DateTimeUtil::parse(argStartDate);
        }

        if (argEndDate)
        {
            endDateTime = DateTimeUtil::parse(argEndDate);
        }

        // prepare list helper
        str argFormat = getArg('SerializationFormat');
        RetailTransactionResultListHelper listHelper = new RetailTransactionResultListHelper(
            (argFormat == int2Str(enum2int(RetailTransactionServiceResultFormat::Json))) // RetailTransactionServiceResultFormat::Json = '1'
            ? RetailTransactionServiceResultFormat::Json
            : RetailTransactionServiceResultFormat::Xml);

        argDeliveryMode = getArg('DeliveryMode');
        argPickUpStartDate = getArg('PickupStartDate');
        argPickUpEndDate = getArg('PickupEndDate');
        argPickupTimeslotStartTime = getArg('PickupTimeslotStartTime');
        argPickupTimeslotEndTime = getArg('PickupTimeslotEndTime');

        List argFulfillmentTypeValues = new List(Types::Integer);
        XmlElement fulfillmentTypeXmlElement = argsRoot.getNamedElement('FulfillmentTypeValues');

        if (fulfillmentTypeXmlElement)
        {
            var childNodes = fulfillmentTypeXmlElement.childNodes();
            for (int i = 0; i < childNodes.length(); i++)
            {
                argFulfillmentTypeValues.addEnd(str2Int(childNodes.item(i).text()));
            }
        }

        // We don't need quotations when searching by fulfillment type.
        if (!argFulfillmentTypeValues.empty())
        {
            includeQuotes = false;
        }

        List argChannelIds = new List(Types::String);
        XmlElement channelIdsXmlElement = argsRoot.getNamedElement('ChannelIds');
        if (channelIdsXmlElement)
        {
            var childNodes = channelIdsXmlElement.childNodes();
            for (int i = 0; i < childNodes.length(); i++)
            {
                argChannelIds.addEnd(childNodes.item(i).text());
            }
        }

        argCustomerRequisition = getArg('CustomerRequisition');
        argBusinessPartnerId = getArg('BusinessPartnerId');
        argSearchOnlyRetailOrders = ('true' == getArg('SearchOnlyRetailOrders'));

        XmlElement customFiltersXmlElement = argsRoot.getNamedElement('CustomFilters');
        
        if (includeOrders)
        {
            // Get the basic query
            retailOrderListQuery = RetailTransactionServiceTransactions::getOrderListQuery(sortingInfo, startDateTime, endDateTime);

            // Initialize list of tables to include
            includeRetailSalesTable = false;  // RetailSalesTable for Order or RetailSalesQuotationTable for Quote
            includeCustTable = false;
            includeRetailTransactionTable = false;

            //Add filters/ranges
            qbds = retailOrderListQuery.dataSourceTable(tableNum(SalesTable));
            qbdsRoot = qbds;

            // optional id filters...
            if (argCustAccount)        qbds.addRange(fieldNum(SalesTable, CustAccount)).value(argCustAccount);
            if (argSalesId)            qbds.addRange(fieldNum(SalesTable, SalesId)).value(argSalesId);
            if (argEmailAddress)       qbds.addRange(fieldNum(SalesTable, Email)).value(argEmailAddress);
            if (argChannelIds && !argChannelIds.empty())         qbds.addRange(fieldNum(SalesTable, RetailChannelTable)).value(strList2str(argChannelIds));
            if (argCustomerRequisition)         qbds.addRange(fieldNum(SalesTable, PurchOrderFormNum)).value(argCustomerRequisition);

            // Filter out Call center Sales Orders in Stopped state (orders not completed in Ax and orders On-hold)
            qbds.addRange(fieldNum(SalesTable, MCROrderStopped)).value(queryValue(NoYes::No));

            // Multi-select filters
            // NOTE: PM has indicated QuotationStatus does not need to be mapped/returned based upon search for Sales Status or Document Status
            if (argOrderStatus)        qbds.addRange(fieldNum(SalesTable, SalesStatus)).value(argOrderStatus); // comma separated list for multiple
            if (argDocumentStatus)     qbds.addRange(fieldNum(SalesTable, DocumentStatus)).value(argDocumentStatus); // comma separated list for multiple

            // Custom filters from extensions
            if (customFiltersXmlElement)
            {
                List extensionRanges = new List(Types::Container);
                
                // Gather custom filters from extensions
                RetailTransactionServiceTransactions::registerGetListOrderSearchCustomFilterRanges(customFiltersXmlElement, extensionRanges);

                // Apply custom filters as query ranges
                RetailTransactionServiceTransactions::addExtensionFieldRangeValue(qbds, extensionRanges);

                // Call extension point to add custom data sources and filters
                RetailTransactionServiceTransactions::registerGetListOrderSearchCustomDataSources(customFiltersXmlElement, qbds);
            }

            // We always include the RetailSalesTable so that the ChannelRefereceId can be used to filter out Async orders/quotes on the client side
            //select SalesTable.SalesId, RetailSalesTable.CHANNELREFERENCEID, * from SalesTable
            //    join RetailSalesTable on SalesTable.RecId = RetailSalesTable.SALESTABLE
            qbds = qbdsRoot.addDataSource(tableNum(RetailSalesTable), 'RetailSalesTable_Outer');
            qbds.fetchMode(QueryFetchMode::One2One);
            qbds.joinMode(JoinMode::OuterJoin);
            qbds.relations(false);
            qbds.addLink(fieldNum(salesTable, RecId), fieldNum(RetailSalesTable, SalesTable));
            includeRetailSalesTable = true;

            // optional id filters...
            if (argChannelRefId)
            {
                retailOrderListQuery.addQueryFilter(qbds, fieldStr(RetailSalesTable, ChannelReferenceId)).value(argChannelRefId);
            }

            SalesIdTempTable salesIdsByReceiptId;
            if (argReceiptId)
            {
                if (FeatureStateProvider::isFeatureEnabled(RetailOmniChannelGenerateOrderConfirmationIdFeature::instance()))
                {
                    // Filter against RetailSalesTable.ChannelReferenceId or RetailSalesTable.ReceiptId.
                    // In the past for retail orders created from POS, there is no InitialReceiptId column in the RetailSalesTable.
                    // Instead ChannelReferenceId column contains the value of ReceiptId.

                    // Search sales ids first, then use the origin query to filter by those sales ids.
                    SalesTable st;
                    RetailSalesTable rst;
                    insert_recordset salesIdsByReceiptId (SalesId)
                    select SalesId from st
                        exists join rst
                        where st.RecId == rst.SalesTable
                        && rst.InitialReceiptId == argReceiptId;

                    insert_recordset salesIdsByReceiptId (SalesId)
                    select SalesId from st
                        exists join rst
                        where st.RecId == rst.SalesTable
                        && rst.ChannelReferenceId == argReceiptId
                        notexists join salesIdsByReceiptId
                        where st.SalesId == salesIdsByReceiptId.SalesId;

                    QueryBuildDataSource salesIdByReceiptQbds = qbdsRoot.addDataSource(tableNum(SalesIdTempTable));
                    salesIdByReceiptQbds.joinMode(JoinMode::ExistsJoin);
                    salesIdByReceiptQbds.addLink(fieldNum(SalesTable, SalesId), fieldNum(SalesIdTempTable, SalesId));
                }
                else
                {
                    // Before the feature is enabled, POS ReceiptId is actually stored in ChannelReferenceId field.
                    // Logic above is compatible to the current code block. We left previous logic here to prevent performance regression.
                    retailOrderListQuery.addQueryFilter(qbds, fieldStr(RetailSalesTable, ChannelReferenceId)).value(argReceiptId);
                }
            }

            if (argStoreId && argFulfillmentTypeValues.empty())
            {
                retailOrderListQuery.addQueryFilter(qbds, fieldStr(RetailSalesTable, RetailStoreId)).value(argStoreId);
            }
            
            if (argTransactionId || argReceiptEmailAddress)
            {
                // Add RetailTransactionTable
                //join salesTable
                //        where transactionTable.Channel == RetailSalesTable.RetailChannel
                //            and transactionTable.salesOrderId == salesTable.SalesId
                qbds = qbdsRoot.addDataSource(tableNum(RetailTransactionTable), 'RetailTransactionTable_Inner');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::InnerJoin); // Use inner join (instead of ExistJoin) to ensure RetailTransactionTable is available
                qbds.relations(false);
                qbds.addLink(fieldNum(RetailSalesTable, RetailChannel), fieldNum(RetailTransactionTable, Channel), 'RetailSalesTable_Outer');
                qbds.addLink(fieldNum(salesTable, SalesId), fieldNum(RetailTransactionTable, salesOrderId));
                includeRetailTransactionTable = true;

                // optional id filters...
                if (argTransactionId)       qbds.addRange(fieldNum(RetailTransactionTable, transactionId)).value(argTransactionId);
                if (argReceiptEmailAddress) qbds.addRange(fieldNum(RetailTransactionTable, receiptEmail)).value(argReceiptEmailAddress);

                if (argLimitTransactionType)
                {
                    qbds.addRange(fieldNum(RetailTransactionTable, SalesOrderId)).value(SysQuery::valueNot(''));
                    qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(limitOrderTransactionTypes);  // Include those OF the allowed type
                }
            }
            else if (argLimitTransactionType)
            {
                // Filter to the equivlent SQL:
                //select SalesId, * from SalesTable as st
                //left join RetailSalesTable as rst
                // ...
                //    where
                //        st.DATAAREAID = 'usrt' and
                //        not exists
                //            (select null from RetailTransactionTable rtt where
                //                rst.SALESORDERID <> '' and
                //                rtt.Channel == rst.RetailChannel
                //                rtt.SALESORDERID = st.SALESID and
                //                rtt.[type] not in ('19', '27', '33', '31'))


                qbds = qbdsRoot.addDataSource(tableNum(RetailTransactionTable), 'RetailTransactionTable_NotExists');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::NoExistsJoin);
                qbds.relations(false);
                qbds.addLink(fieldNum(RetailSalesTable, RetailChannel), fieldNum(RetailTransactionTable, Channel), 'RetailSalesTable_Outer');
                qbds.addLink(fieldNum(salesTable, SalesId), fieldNum(RetailTransactionTable, salesOrderId));

                qbds.addRange(fieldNum(RetailTransactionTable, SalesOrderId)).value(SysQuery::valueNot(''));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(notLimitOrderTransactionTypes);  // excluded those NOT of the allowed type
                qbds.addRange(fieldNum(RetailTransactionTable, entryStatus)).value(SysQuery::valueNot(RetailEntryStatus::Voided));

                // Filter out Sales Orders created in new EOD, needed especially for statements where the sales orders are
                // created but not yet posted. Also note the above condition is always used to catch old EOD created orders.
                RetailTransactionServiceTransactions::createFilterForNewEODSalesOrders(qbdsRoot, qbds);
            }

            if (argCustName || argLoyaltyCardNumber || argCustomerPhoneNumber)
            {
                // Add CustTable
                //join AccountNum from customerTable
                //    where SalesTable.CustAccount == customerTable.AccountNum
                qbds = qbdsRoot.addDataSource(tableNum(CustTable), 'CustTable_Inner');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::InnerJoin);
                qbds.relations(false);
                qbds.addLink(fieldNum(SalesTable, CustAccount), fieldNum(CustTable, AccountNum));
                includeCustTable = true;

                // Add PartyTable
                //join Name from partyTable
                //    where partyTable.RecId == customerTable.Party
                //        && partyTable.Name like argCustName
                // NOTE: To make something as the "LIKE" operator in a query,  you should just assign a value to the queryRange including a wildcard.
                qbds = qbds.addDataSource(tableNum(DirPartyTable), 'DirPartyTable_Exists');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::ExistsJoin);  // Use ExistJoin for perf since we don't need the result - just the query
                qbds.relations(false);
                qbds.addLink(fieldNum(CustTable, Party), fieldNum(DirPartyTable, RecId));

                if (argCustName)
                {
                    qbds.addRange(fieldNum(DirPartyTable, Name)).value(custNameSearchText);
                }

                if (argLoyaltyCardNumber)
                {
                    RetailTransactionServiceTransactions::addLoyaltyCardNumberToQuery(qbds, argLoyaltyCardNumber);
                }
                if (argCustomerPhoneNumber)
                {
                    RetailTransactionServiceTransactions::addCustomerPhoneNumberToQuery(qbds, argCustomerPhoneNumber);
                }
            }

            if (!argFulfillmentTypeValues.empty() || argDeliveryMode || argPickUpStartDate || argPickUpEndDate || argPickupTimeslotStartTime || argPickupTimeslotEndTime)
            {
                qbds = qbdsRoot.addDataSource(tableNum(SalesLine));
                qbds.fetchMode(QueryFetchMode::One2Many);
                qbds.joinMode(JoinMode::ExistsJoin);
                qbds.relations(true);

                RetailParameters retailParameters = RetailParameters::find();

                if (!argFulfillmentTypeValues.empty())
                {
                    qbds.addRange(fieldNum(SalesLine, SalesStatus)).value(strfmt('%1,%2', enum2int(SalesStatus::Backorder), enum2int(SalesStatus::Delivered)));
                    var enumerator = argFulfillmentTypeValues.getEnumerator();

                    RetailStoreTable retailStoreTable = RetailStoreTable::find(argStoreId);
                    QueryBuildDataSource qbdsInventDim = qbds.addDataSource(tableNum(InventDim));
                    qbdsInventDim.fetchMode(QueryFetchMode::One2One);
                    qbdsInventDim.joinMode(JoinMode::InnerJoin);
                    qbdsInventDim.relations(true);

                    // There will be multiple fulfillment types provided by client and we need to combine them with **OR** condition.
                    // For example, client provides both pickup and ship. We need to have SQL like:
                    // (DLVMODE = '' AND INVENTLOCATIONID = '')
                    // OR (DLVMODE <> '' AND DLVMODE <> '' AND DLVMODE <> '' AND INVENTLOCATIONID = '')
                    // So we have to provide same FieldId to addRange.
                    while (enumerator.moveNext())
                    {
                        int argFulfillmentType = enumerator.current();
                        if (argFulfillmentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.FulfillmentOperationType::Pickup)
                        {
                            hasPickupFulfillmentType = true;

                            if (!RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled())
                            {
                                qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(
                                    strFmt('((%1.%2 == "%3") && (%4.%5 == "%6"))',
                                        qbds.name(),
                                        fieldStr(SalesLine, DlvMode),
                                        retailParameters.PickUpDeliveryModeCode,
                                        qbdsInventDim.name(),
                                        fieldStr(InventDim, InventLocationId),
                                        retailStoreTable.InventLocation));
                            }
                        }
                        else if (argFulfillmentType == Microsoft.Dynamics.Commerce.Runtime.DataModel.FulfillmentOperationType::Ship)
                        {
                            hasShipFulfillmentType = true;

                            if (!RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled())
                            {
                                qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(
                                strFmt('((%1.%2 != "%3") && (%1.%2 != "%4") && (%1.%2 != "%5") && (%6.%7 == "%8"))',
                                    qbds.name(),
                                    fieldStr(SalesLine, DlvMode),
                                    retailParameters.PickUpDeliveryModeCode,
                                    retailParameters.CarryOutDeliveryModeCode,
                                    retailParameters.ElectronicDeliveryModeCode,
                                    qbdsInventDim.name(),
                                    fieldStr(InventDim, InventLocationId),
                                    retailStoreTable.InventLocationIdForCustomerOrder));
                            }
                        }
                    }

                    if (RetailMultiplePickupDeliveryModeFeatureExposure::isEnabled() &&
                        (hasPickupFulfillmentType || hasShipFulfillmentType))
                    {
                        DlvMode dlvMode;
                        InventLocationId inventLocation = retailStoreTable.inventLocation;
                        DlvModeId carryOutDlvMode = retailParameters.CarryOutDeliveryModeCode;
                        DlvModeId electronicDlvMode = retailParameters.ElectronicDeliveryModeCode;

                        if (hasPickupFulfillmentType)
                        {
                            insert_recordset dlvModeInventLocationTmp(DlvMode, InventLocationId)
                                select Code, inventLocation from pickupDlvModes;
                        }

                        if (hasShipFulfillmentType)
                        {
                            insert_recordset dlvModeInventLocationTmp(DlvMode, InventLocationId)
                                select Code, inventLocation from dlvMode
                                    where dlvMode.Code != carryOutDlvMode
                                        && dlvMode.Code != electronicDlvMode
                                    notexists join pickupDlvModes
                                    where dlvMode.Code == pickupDlvModes.Code;
                       }

                        QueryBuildDataSource pickupQbdsSales = qbds.addDataSource(tableNum(RetailDlvModeInventLocationTmp));
                        pickupQbdsSales.joinMode(JoinMode::ExistsJoin);
                        pickupQbdsSales.addLink(fieldNum(SalesLine, DlvMode), fieldNum(RetailDlvModeInventLocationTmp, DlvMode));

                        qbdsInventDim.addRange(fieldNum(InventDim, InventLocationId)).value(inventLocation);
                    }
                }

                if (argDeliveryMode)
                {
                    qbds.addRange(fieldNum(SalesLine, DlvMode)).value(SysQuery::value(argDeliveryMode));
                }

                if (argPickUpStartDate || argPickUpEndDate)
                {
                    utcDateTime startPickUpDateTime = DateTimeUtil::minValue();
                    utcdatetime endPickUpDateTime = DateTimeUtil::maxValue();

                    if (argPickUpStartDate)
                    {
                        startPickUpDateTime = DateTimeUtil::parse(argPickUpStartDate);
                    }

                    if (argPickUpEndDate)
                    {
                        endPickUpDateTime = DateTimeUtil::parse(argPickUpEndDate);
                    }

                    qbds.addRange(fieldNum(SalesLine, ShippingDateRequested)).value(SysQuery::range(startPickUpDateTime, endPickUpDateTime));

                    var pickupQbdsDate = qbds.addDataSource(tableNum(RetailDlvModeTmp));
                    pickupQbdsDate.joinMode(JoinMode::ExistsJoin);
                    pickupQbdsDate.addLink(fieldNum(SalesLine, DlvMode), fieldNum(RetailDlvModeTmp, Code));
                }

                if (argPickupTimeslotStartTime || argPickupTimeslotEndTime)
                {
                    var qbdsRetailSalesLine = qbds.addDataSource(tableNum(RetailSalesLine));
                    qbdsRetailSalesLine.fetchMode(QueryFetchMode::One2One);
                    qbdsRetailSalesLine.joinMode(JoinMode::InnerJoin);
                    qbdsRetailSalesLine.relations(true);

                    RetailPickupTimeslotStartTime pickUpStartTime = 0;
                    RetailPickupTimeslotEndTime pickUpEndTime = 86400;

                    if (argPickupTimeslotStartTime)
                    {
                        pickUpStartTime = str2Int(argPickupTimeslotStartTime);
                    }

                    if (argPickupTimeslotEndTime)
                    {
                        pickUpEndTime = str2Int(argPickupTimeslotEndTime);
                    }

                    // We have to have logics like, e.g. search criteria = [04:00; 08:00]. The SQL will look like:
                    // RetailSalesLine.PickupStartTime < '08:00' && RetailSalesLine.PickupEndTime > '04:00'
                    // In order to find all intersactions.
                    qbdsRetailSalesLine.addRange(fieldNum(RetailSalesLine, PickupStartTime)).value(strFmt('((%1 <= %2) && (%3 >= %4))',
                        fieldStr(RetailSalesLine, PickupStartTime),
                        pickUpEndTime,
                        fieldStr(RetailSalesLine, PickupEndTime),
                        pickUpStartTime));

                    // All pickup timeslot enabled order should have a PickupEndTime > 0.
                    qbdsRetailSalesLine.addRange(fieldNum(RetailSalesLine, PickupEndTime)).value(">0");
                }
            }

            if (argBusinessPartnerId)
            {
                // Add RetailCustTable
                // join salesTable
                //        where RetailCustTable.AccountNum == SalesTable.CustAccount
                qbds = qbdsRoot.addDataSource(tableNum(RetailCustTable));
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::InnerJoin);
                qbds.relations(false);
                qbds.addLink(fieldNum(SalesTable, CustAccount), fieldNum(RetailCustTable, AccountNum));

                // Add CustHierarchyNode
                // join CustHierarchyId from CustHierarchyNode
                //    where CustHierarchyNode.RecId == RetailCustTable.B2BCustomerHierarchyNode
                qbds = qbds.addDataSource(tableNum(CustHierarchyNode));
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::InnerJoin);
                qbds.relations(false);
                qbds.addLink(fieldNum(RetailCustTable, B2BCustomerHierarchyNode), fieldNum(CustHierarchyNode, RecId));

                // Filter out sales orders based on BusinessPartnerId
                qbds.addRange(fieldNum(CustHierarchyNode, CustHierarchyId)).value(argBusinessPartnerId);
            }

            qr = new QueryRun(retailOrderListQuery);
            setTemporaryTableRecordsInQueryRun(qr, salesIdsByReceiptId);
            qr.enablePositionPaging(true);
            qr.addPageRange(resultsStartingPosition, resultsMaxCount);

            // Get the max total returned for all pages in order to support paging into the next query for Quotes
            if (RetailOptimizeCountQueryForOrderListSearchFlightV2::instance().isEnabled())
            {
                salesOrderRowCount = getOptimizedRowCountFromQuery(retailOrderListQuery, salesIdsByReceiptId);
            }
            else
            {
                // AX supports countTotal as well as CountLoops API.  Given all results has SalesTable countTotal should
                // be adequate and provide the optimal SQL performance
                salesOrderRowCount = SysQuery::countTotal(qr);
            }

            resultsCount = 0;
            canAddMore = true;

            while (qr.next())
            {
                // Skip if we have already reached max count
                if (resultsCount < resultsMaxCount)
                {
                    // Add xml to results map
                    qSalesTable = qr.get(tableNum(SalesTable));
                    if (includeRetailTransactionTable)
                    {
                        qRetailTransactionTable = qr.get(tableNum(RetailTransactionTable));
                    }

                    if (includeRetailSalesTable)
                    {
                        qRetailSalesTable = qr.get(tableNum(RetailSalesTable));
                    }

                    if (includeCustTable)
                    {
                        qCustTable = qr.get(tableNum(CustTable));
                    }

                    if (!argSearchOnlyRetailOrders || qRetailSalesTable.RetailOrder)
                    {
                        listHelper.AddSalesOrder(
                            qSalesTable, // SalesTable
                            qRetailSalesTable,
                            qCustTable,
                            qRetailTransactionTable,
                            argIncludeDetails,
                            false); //includeDiscountLines

                        resultsCount++;
                    }
                }
                else
                {
                    canAddMore = false; // We have reached the end of the page size boundry for results
                    break;
                }
            }
        }

        if (includeQuotes)
        {
            // Sales Quotations are in their own table.  They need to be added to the result set within the allowed page
            // boundry.  Ideally we would sort all  results from Sales Table and Sales Quotation based upon the CreatedDateTime.
            // But this is not done in the legacy API and PM is ok with continuing to append to the end of the list for now.
            // In the future we may consdier creating a view on top of the two queries sorted by the data and from which
            // the specific are filtered/retreived and added to the result.
            canAddMore = canAddMore && (resultsCount < resultsMaxCount);
            if (canAddMore && !argOrderStatus && !argDocumentStatus)
            {
                // NOTE: We exclude all Quotes if OrderStatus or DocumentStatus is specified in the query.  Also excluded if ChannelRefId specified.

                // Initialize list of tables to include
                includeRetailSalesTable = false;  // RetailSalesTable for Order or RetailSalesQuotationTable for Quote
                includeCustTable = false;
                includeRetailTransactionTable = false;

                // Get the basic query
                retailQuoteListQuery = RetailTransactionServiceTransactions::getQuoteListQuery(sortingInfo, startDateTime, endDateTime);

                //Add filters/ranges
                qbds = retailQuoteListQuery.dataSourceTable(tableNum(SalesQuotationTable));
                qbdsRoot = qbds;

                // optional id filters...
                if (argCustAccount)        qbds.addRange(fieldNum(SalesQuotationTable, CustAccount)).value(argCustAccount);
                if (argSalesId)            qbds.addRange(fieldNum(SalesQuotationTable, QuotationId)).value(argSalesId);
                if (argEmailAddress)       qbds.addRange(fieldNum(SalesQuotationTable, Email)).value(argEmailAddress);
                if (argCustomerRequisition)         qbds.addRange(fieldNum(SalesQuotationTable, CustPurchaseOrder)).value(argCustomerRequisition);

                // Custom filters from extensions
                if (customFiltersXmlElement)
                {
                    List extensionRanges = new List(Types::Container);
                
                    // Gather custom filters from extensions
                    RetailTransactionServiceTransactions::registerGetListQuotationOrderSearchCustomFilterRanges(customFiltersXmlElement, extensionRanges);

                    // Apply custom filters as query ranges
                    RetailTransactionServiceTransactions::addExtensionFieldRangeValue(qbds, extensionRanges);

                    // Call extension point to add custom data sources and filters
                    RetailTransactionServiceTransactions::registerGetListQuotationOrderSearchCustomDataSources(customFiltersXmlElement, qbds);
                }

                if (argTransactionId || argReceiptEmailAddress)
                {
                    // Add RetailTransactionTable
                    //join salesQuotationTable
                    //        where transactionTable.salesOrderId == salesTable.SalesId
                    // NOTE: This is included to ensure additional filtering applied based upon search criteria.
                    
                    qbds = qbdsRoot.addDataSource(tableNum(SalesQuotationTable), 'RetailTransactionTable_Inner');
                    qbds.fetchMode(QueryFetchMode::One2One);
                    qbds.joinMode(JoinMode::InnerJoin); // Use inner join (instead of ExistJoin) to ensure RetailTransactionTable is available
                    qbds.relations(false);
                    qbds.addLink(fieldNum(SalesQuotationTable, QuotationId), fieldNum(RetailTransactionTable, salesOrderId));
                    includeRetailTransactionTable = true;

                    // optional id filters...
                    if (argTransactionId)       qbds.addRange(fieldNum(RetailTransactionTable, transactionId)).value(argTransactionId);
                    if (argReceiptEmailAddress) qbds.addRange(fieldNum(RetailTransactionTable, receiptEmail)).value(argReceiptEmailAddress);
                }

                if (argCustName || argLoyaltyCardNumber || argCustomerPhoneNumber)
                {
                    // Add CustTable
                    //join AccountNum from customerTable
                    //    where SalesTable.CustAccount == customerTable.AccountNum
                    qbds = qbdsRoot.addDataSource(tableNum(CustTable), 'CustTable_Inner');
                    qbds.fetchMode(QueryFetchMode::One2One);
                    qbds.joinMode(JoinMode::InnerJoin);
                    qbds.relations(false);
                    qbds.addLink(fieldNum(SalesQuotationTable, CustAccount), fieldNum(CustTable, AccountNum));
                    includeCustTable = true;

                    // Add PartyTable
                    //join Name from partyTable
                    //    where partyTable.RecId == customerTable.Party
                    //        && partyTable.Name like argCustName
                    // NOTE: To make something as the "LIKE" operator in a query,  you should just assign a value to the queryRange including a wildcard.
                    qbds = qbds.addDataSource(tableNum(DirPartyTable), 'DirPartyTable_Exists');
                    qbds.fetchMode(QueryFetchMode::One2One);
                    qbds.joinMode(JoinMode::ExistsJoin);  // Use ExistJoin for perf since we don't need the result - just the query
                    qbds.relations(false);
                    qbds.addLink(fieldNum(CustTable, Party), fieldNum(DirPartyTable, RecId));

                    if (argCustName)
                    {
                        qbds.addRange(fieldNum(DirPartyTable, Name)).value(custNameSearchText);
                    }

                    if (argLoyaltyCardNumber)
                    {
                        RetailTransactionServiceTransactions::addLoyaltyCardNumberToQuery(qbds, argLoyaltyCardNumber);
                    }

                    if (argCustomerPhoneNumber)
                    {
                        RetailTransactionServiceTransactions::addCustomerPhoneNumberToQuery(qbds, argCustomerPhoneNumber);
                    }
                }

                // We always include the RetailSalesQuotationTable so that the ChannelRefereceId can be used to filter out Async orders/quotes on the client side
                qbds = qbdsRoot.addDataSource(tableNum(RetailSalesQuotationTable), 'RetailSalesQuotationTable_Outer');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::OuterJoin); // Use outter join to recover both Call center and Non call center quotations
                qbds.relations(false);
                qbds.addLink(fieldNum(SalesQuotationTable, RecId), fieldNum(RetailSalesQuotationTable, SalesQuotationTable));
                includeRetailSalesTable = true;

                // optional id filters...
                if (argChannelRefId)
                {
                    retailQuoteListQuery.addQueryFilter(qbds, fieldStr(RetailSalesQuotationTable, ChannelReferenceId)).value(argChannelRefId);
                }

                SalesIdTempTable quotationIdsByReceiptId;
                if (argReceiptId)
                {
                    if (FeatureStateProvider::isFeatureEnabled(RetailOmniChannelGenerateOrderConfirmationIdFeature::instance()))
                    {
                        // Filter against RetailSalesQuotationTable.ChannelReferenceId or RetailSalesQuotationTable.ReceiptId.
                        // In the past for retail quotes created from POS, there is no ReceiptId column in the RetailSalesQuotationTable.
                        // Instead ChannelReferenceId column contains the value of ReceiptId.

                        // Search quotation ids first, then use the origin query to filter by those quotation ids.
                        SalesQuotationTable sqt;
                        RetailSalesQuotationTable rsqt;
                        insert_recordset quotationIdsByReceiptId (SalesId)
                        select QuotationId from sqt
                            exists join rsqt
                            where sqt.RecId == rsqt.SalesQuotationTable
                            && rsqt.InitialReceiptId == argReceiptId;

                        insert_recordset quotationIdsByReceiptId (SalesId)
                        select QuotationId from sqt
                            exists join rsqt
                            where sqt.RecId == rsqt.SalesQuotationTable
                            && rsqt.ChannelReferenceId == argReceiptId
                        notexists join quotationIdsByReceiptId
                        where sqt.QuotationId == quotationIdsByReceiptId.SalesId;

                        QueryBuildDataSource quotationIdByReceiptQbds = qbdsRoot.addDataSource(tableNum(SalesIdTempTable));
                        quotationIdByReceiptQbds.joinMode(JoinMode::ExistsJoin);
                        quotationIdByReceiptQbds.addLink(fieldNum(SalesQuotationTable, QuotationId), fieldNum(SalesIdTempTable, SalesId));
                    }
                    else
                    {
                        // Before the feature is enabled, POS ReceiptId is actually stored in ChannelReferenceId field.
                        // Logic above is compatible to the current code block. We left previous logic here to prevent performance regression.
                        retailQuoteListQuery.addQueryFilter(qbds, fieldStr(RetailSalesQuotationTable, ChannelReferenceId)).value(argReceiptId);
                    }
                }

                if (argStoreId)
                {
                    retailQuoteListQuery.addQueryFilter(qbds, fieldStr(RetailSalesQuotationTable, RetailStoreId)).value(argStoreId);
                }

                if (argDeliveryMode || argPickUpStartDate || argPickUpEndDate)
                {
                    qbds = qbdsRoot.addDataSource(tableNum(SalesQuotationLine));
                    qbds.fetchMode(QueryFetchMode::One2Many);
                    qbds.joinMode(JoinMode::ExistsJoin);
                    qbds.relations(true);

                    RetailParameters retailParameters = RetailParameters::find();

                    if (argDeliveryMode)
                    {
                        qbds.addRange(fieldNum(SalesQuotationLine, DlvMode)).value(SysQuery::value(argDeliveryMode));
                    }

                    if (argPickUpStartDate || argPickUpEndDate)
                    {
                        utcDateTime startPickUpDateTime = DateTimeUtil::minValue();
                        utcdatetime endPickUpDateTime = DateTimeUtil::maxValue();

                        if (argPickUpStartDate)
                        {
                            startPickUpDateTime = DateTimeUtil::parse(argPickUpStartDate);
                        }

                        if (endPickUpDateTime)
                        {
                            endPickUpDateTime = DateTimeUtil::parse(argPickUpEndDate);
                        }

                        qbds.addRange(fieldNum(SalesQuotationLine, ShippingDateRequested)).value(SysQuery::range(startPickUpDateTime, endPickUpDateTime));
                        var pickupQuoteQbdsDate = qbds.addDataSource(tableNum(RetailDlvModeTmp));
                        pickupQuoteQbdsDate.joinMode(JoinMode::ExistsJoin);
                        pickupQuoteQbdsDate.addLink(fieldNum(SalesQuotationLine, DlvMode), fieldNum(RetailDlvModeTmp, Code));
                    }
                }

                // Determine the start page position for retailQuoteListQuery
                if ((resultsStartingPosition <= salesOrderRowCount) || (salesOrderRowCount <= 0))
                {
                    // Start from the beginning if we had some entries in the Sales Table...
                    adjustedStartingPosition = 1;
                }
                else
                {
                    adjustedStartingPosition = resultsStartingPosition - salesOrderRowCount + 1; // 1 based position
                }

                // Run the query
                qr = new QueryRun(retailQuoteListQuery);
                if (argReceiptId && FeatureStateProvider::isFeatureEnabled(RetailOmniChannelGenerateOrderConfirmationIdFeature::instance()))
                {
                    qr.setRecord(quotationIdsByReceiptId);
                }

                if (argPickUpStartDate || argPickUpEndDate)
                {
                    qr.setRecord(pickupDlvModes);
                }
                qr.enablePositionPaging(true);
                qr.addPageRange(adjustedStartingPosition, resultsMaxCount);

                qCustTable = null;

                while (qr.next())
                {
                    // Skip if we have already reached max count
                    if (resultsCount < resultsMaxCount)
                    {
                        // Add xml to results map
                        qSalesQuotationTable = qr.get(tableNum(SalesQuotationTable));

                        if (includeCustTable)
                        {
                            qCustTable = qr.get(tableNum(CustTable));
                        }

                        if (includeRetailSalesTable)
                        {
                            qRetailSalesQuotationTable = qr.get(tableNum(RetailSalesQuotationTable));
                        }

                        listHelper.AddSalesQuotation(
                            qSalesQuotationTable, // SalesTable
                            qRetailSalesQuotationTable, // RetailSalesQuotationTable
                            qCustTable, // CustTable
                            argIncludeDetails);

                        resultsCount++;
                    }
                    else
                    {
                        canAddMore = false; // We have reached the end of the page size boundry for results
                        break;
                    }
                }
            }
        }

        str results = listHelper.Serialize();
        output = [true, '', results];

        var format = (argFormat == int2Str(enum2int(RetailTransactionServiceResultFormat::Json)))
            ? RetailTransactionServiceResultFormat::Json
            : RetailTransactionServiceResultFormat::Xml;

        sw.Stop();
        eventSource.EventWriteOrderListSearchFinished(qSalesTable.RecId, enum2Symbol(enumNum(RetailTransactionServiceResultFormat), format), sw.ElapsedMilliseconds, resultsCount);

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFilterForNewEODSalesOrders</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a filter for new EOD sales orders, needed especially for statements where the
    /// sales orders are created but not yet posted.
    /// </summary>
    /// <param name="_qbdsRoot">
    /// QueryBuildDataSource for the parent query.
    /// </param>
    /// <param name="_qbds">
    /// QueryBuildDataSource to build on.
    /// </param>
    /// <param name="_notLimitOrderTransactionTypes">
    /// String list of transactions that are of the correct type.
    /// </param>
    protected static void createFilterForNewEODSalesOrders(QueryBuildDataSource _qbdsRoot, QueryBuildDataSource _qbds)
    {
        // Do nothing, implemented in RetailTransactionServiceTransactions_Extension
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchSalesTransactionsByReceiptId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in receipt identifier.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML arguments.
    /// </param>
    /// <returns>
    /// A list of orders that match the given receipt identifier.
    /// </returns>
    /// <remarks>
    /// Xml argument example:
    /// <Arguments>
    ///  <ReceiptId/>
    ///  <DataAreaId />
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///</Arguments>
    /// </remarks>
    public static container searchSalesTransactionsByReceiptId(str _xmlArgumentString)
    {
        str receiptId;
        str dataAreaId;
        int resultsStartingPosition = 1;
        int resultsMaxCount = #resultsCountOfTransaction;
        int resultsCount;
        boolean includeDetails = false;
        boolean includeDiscountLines = false;

        DirPartyTable qDirPartyTable;
        XmlDocument         xmlDoc;
        XmlElement          xmlRoot, xmlTrans;
        List                salesOrderXmlList = new List(Types::Class);
        ListEnumerator      enumerator;
        XmlDocument         argsXml;
        XmlElement          argsRoot;
        Query   query;
        QueryRun queryRun;
        QueryBuildDataSource qbds;
        container           output = [true,''];

        // Get the string value of an XML element argument.
        str getArg(str argName)
        {
            str result = '';

            xmlRoot = argsRoot.getNamedElement(argName);
            if (xmlRoot != null)
            {
                result = xmlRoot.text();
            }

            return result;
        }

        // Parse the arguments
        argsXml = new XmlDocument();
        argsXml.loadXml(_xmlArgumentString);
        argsRoot = argsXml.documentElement();

        receiptId = getArg('ReceiptId');
        dataAreaId = getArg('DataAreaId');

        // Get paging details
        [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

        // Prepare output xml
        xmlDoc = RetailTransactionServiceUtilities::getXmlDocumentForSerializedEntities();
        xmlRoot = xmlDoc.createElement('ArrayOfSalesOrder');
        xmlRoot.setAttribute('xmlns', RetailTransactionServiceUtilities::getCrtDataModelXmlNamespace());

        // Get the query
        query = new Query(queryStr(RetailJournalListQuery));

        // Add the data source
        qbds = query.dataSourceTable(tableNum(RetailTransactionTable));

        // Add filters
        if (receiptId)
        {
            qbds.addRange(fieldNum(RetailTransactionTable, ReceiptId)).value(receiptId);
        }

        if (dataAreaId)
        {
            qbds.addRange(fieldNum(RetailTransactionTable, DataAreaId)).value(dataAreaId);
        }

        qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(queryValue(enum2int(RetailTransactionType::Sales)));
        qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(queryValue(enum2int(RetailTransactionType::CustomerOrder)));
        qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(queryValue(enum2int(RetailTransactionType::AsyncCustomerOrder)));
        qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(queryValue(enum2int(RetailTransactionType::AsyncCustomerQuote)));
        qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(queryValue(enum2int(RetailTransactionType::PendingSalesOrder)));
        qbds.addSortField(fieldNum(RetailTransactionTable, CreatedDateTime), SortOrder::Descending);

        // Run the query
        queryRun = new QueryRun(query);
        queryRun.enablePositionPaging(true);
        queryRun.addPageRange(resultsStartingPosition, resultsMaxCount);

        while (queryRun.next())
        {
            // Skip if we have already reached max count
            if (queryRun.isPositionPagingEnabled() || (resultsCount < resultsMaxCount))
            {
                // Add xml to results map
                RetailTransactionServiceTransactions::addTransactionToResultMap(
                            salesOrderXmlList, xmlDoc,
                            queryRun.get(tableNum(RetailTransactionTable)),
                            qDirPartyTable,
                            includeDetails,
                            includeDiscountLines,
                            true,     // IncludeTaxLines
                            #ElementSalesOrder,
                true); // includeAttributes
                resultsCount++;
            }
            else
            {
                break;
            }
        }

        enumerator = salesOrderXmlList.getEnumerator();
        while (enumerator.MoveNext())
        {
            xmlTrans = enumerator.current();
            xmlRoot.appendChild(xmlTrans);
        }

        xmlDoc.appendChild(xmlRoot);
        output = [true, '', xmlDoc.toString()];

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchOrderList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_transactionId">
    /// TransactionID to match against the RetailTransactionTable.TransactionId field.
    /// </param>
    /// <param name="_salesId">
    /// SalesID to match against the SalesTable.SalesId field.
    /// </param>
    /// <param name="_receiptId">
    /// ReceiptID to match against the RetailTransactionTable.ReceiptId field.
    /// </param>
    /// <param name="_channelRefId">
    /// Channel Reference ID to match against the SalesOrder.ChannelReferenceId field.
    /// </param>
    /// <param name="_custAccount">
    /// Customer Account Number to match against the RetailTransactionTable.CustAccount field.
    /// </param>
    /// <param name="_custFirstName">
    /// First name of customer who is linked to the RetailTransactionTable.
    /// </param>
    /// <param name="_custLastName">
    /// Last name of customer who is linked to the RetailTransactionTable.
    /// </param>
    /// <param name="_storeId">
    /// StoreId to match against the RetailTransactionTable.Store field.
    /// </param>
    /// <param name="_terminalId">
    /// TerminalId to match against the RetailTransactionTable.Terminal field.
    /// </param>
    /// <param name="_itemId">
    /// ItemId to match against the RetailTransactionSalesTrans.ItemId field.
    /// </param>
    /// <param name="_barcode">
    /// Barcode to match against the RetailTransactionSalesTrans.Barcode field.
    /// </param>
    /// <param name="_staffId">
    /// StaffId to match against the RetailTransactionTable.Staff field.
    /// </param>
    /// <param name="_startDate">
    /// RetailTransactionTable.TransDate field greater than or equal to startDate.
    /// </param>
    /// <param name="_endDate">
    /// RetailTransactionTable.TransDate field less than or equal to endDate.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether to include all order information including order lines and attributes.
    /// </param>
    /// <param name="_receiptEmailAddress">
    /// ReceiptEmailAddress to match against the RetailTransactionTable.ReceiptEmail field.
    /// </param>
    /// <param name="_seachIdentifiers">
    /// SeachIdentifiers to math against the RetailTransactionTable with the following fields
    /// TransactionId
    /// ReceiptId
    /// SalesId
    /// CustomerAccount
    /// ChannelRefId
    /// </param>
    /// <param name="_resultsMaxCount">
    /// The maximum amount of rows to return (default is 20).
    /// </param>
    /// <param name="_retailTransactionTypes">
    /// Transaction types to be returned.
    /// </param>
    /// <param name="_serialNumber">
    /// SerialNumber to match against the RetailTransactionSalesTrans.InventSerialId field.
    /// </param>
    /// <param name="_transactionStatusTypes">
    /// Transaction's entry status to match against the RetailTransactionTable.EntryStatus field.
    /// </param>
    /// <param name="_includeNonTransactions">
    /// Whether or not to include non-transaction records (ie, records from SalesTable).  TRUE by default.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    public static container searchOrderList(RetailTransactionId _transactionId,
                                            SalesId _salesId,
                                            RetailReceiptId _receiptId,
                                            RetailOrderChannelReferenceId _channelRefId,
                                            CustAccount _custAccount,
                                            str _custFirstName,
                                            str _custLastName,
                                            RetailStoreId _storeId,
                                            RetailTerminalId _terminalId,
                                            RetailItemId _itemId,
                                            RetailBarcode _barcode,
                                            RetailStaffId _staffId,
                                            str _startDate,
                                            str _endDate,
                                            boolean _includeDetails,
                                            RetailReceiptEmail _receiptEmailAddress = '',
                                            String50 _seachIdentifiers = '',
                                            int _resultsMaxCount = #resultsCountOfTransaction,
                                            str _retailTransactionTypes = '',
                                            InventSerialId _serialNumber = '',
                                            str _transactionStatusTypes = '',
                                            boolean _includeNonTransactions = true)
    {
        RetailTransactionTable                 transactionTable;
        RetailTransactionTaxTrans              taxTable;
        RetailTransactionMarkupTrans           chargeTable;
        RetailTransactionSalesTrans            transactionSalesTable;
        RetailTransactionSalesTrans            salesLineExistsTable;
        CustTable                              customerTable;
        DirPartyTable                          partyTable;
        SalesTable              salesTable;
        SalesLine               salesLineTable;
        RetailSalesTable        rsoTable;
        RetailSalesQuotationTable rsqTable;
        int resultsCount;
        boolean foundByChannelReferenceId;

        container           output = [true,''];
        utcDateTime         startDateTime = DateTimeUtil::minValue();
        TransDate           startDate = DateTimeUtil::date(startDateTime);
        utcDateTime         endDateTime = DateTimeUtil::maxValue();
        TransDate           endDate = DateTimeUtil::date(endDateTime);
        CustName            custName = '';
        XmlDocument         xmlDoc;
        XmlElement          xmlRoot, xmlTrans, xmlItems;
        Map                 transactionXmlMap = new Map(Types::String, Types::Class);
        Map                 salesOrderXmlMap = new Map(Types::String, Types::Class);
        MapEnumerator       enumerator;
        boolean             results = false;
        Set                 foundSalesOrders = new Set(Types::String);
        CustInvoiceJour     custInvoiceJour;
        TmpRecIdFilter      tmpRecIdFilter;
        TmpRecIdFilter      tmpRecIdFilterDuplicateCheck;
        SalesQuotationTable salesQuotationTable;
        Map                 quoteXmlMap = new Map(Types::String, Types::Class);
        Set                 transactionTypesSet = new Set(Types::Integer);
        ListEnumerator      transactionTypesListEnumerator;
        boolean             filterByTransactionType = true;
        boolean             includeDiscountLines = (_receiptId || _channelRefId || _salesId || _transactionId);
        container           transactionStatusTypes = str2con(_transactionStatusTypes, ',');
        boolean             filterByTransactionStatusType = (_transactionStatusTypes != '') && (conLen(transactionStatusTypes) > 0) ? true : false;
        boolean             includeCustomerOrder = false;

        //
        // Main method body
        //

        if (_custFirstName != '' || _custLastName != '')
        {
            custName = _custFirstName + '*' + _custLastName;
        }

        if (_startDate)
        {
            startDateTime =  DateTimeUtil::parse(_startDate);
            startDate = DateTimeUtil::date(startDateTime);
        }

        if (_endDate)
        {
            endDateTime = DateTimeUtil::parse(_endDate);
            endDate = DateTimeUtil::date(endDateTime);
        }

        transactionTypesListEnumerator = strSplit(_retailTransactionTypes, ',').getEnumerator();
        while (transactionTypesListEnumerator.moveNext())
        {
            transactionTypesSet.add(str2int(transactionTypesListEnumerator.current()));
        }

        if (_retailTransactionTypes == '' || transactionTypesSet.empty() || transactionTypesSet.in(-1)) // -1 means None filter is included
        {
            filterByTransactionType = false;
            includeCustomerOrder = true;
        }
        else if (transactionTypesSet.in(RetailTransactionType::CustomerOrder)
                || transactionTypesSet.in(RetailTransactionType::AsyncCustomerOrder)
                || transactionTypesSet.in(RetailTransactionType::AsyncCustomerQuote))
        {
            includeCustomerOrder = true;
        }

        xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        xmlRoot = RetailTransactionServiceTransactions::getArrayOfSalesOrderXmlRoot(xmlDoc);

        //
        // Search without cusotmer
        //
        if (custName == '')
        {
            // Query for sales orders (if required)
            if (_includeNonTransactions)
            {
                while select Channel, TransactionId, ReceiptId, Store, Terminal, Staff, TransDate, TransTime, CustAccount, NetAmount, Shift, PaymentAmount, SalesOrderId, ChannelReferenceId,
                         GrossAmount, DiscAmount, TotalDiscAmount, EntryStatus, LoyaltyCardId, ReceiptEmail, Type, CreatedDateTime from transactionTable
                order by CreatedDateTime desc
                where (_receiptId == '' || transactionTable.ReceiptId == _receiptId)
                    && (_transactionId == '' || transactionTable.transactionId == _transactionId)
                    && (_channelRefId == '' || transactionTable.ChannelReferenceId == _channelRefId)
                    && (_salesId == '' || transactionTable.SalesOrderId == _salesId)
                    && (_receiptEmailAddress == '' || transactionTable.receiptEmail == _receiptEmailAddress)
                    && (_seachIdentifiers == '' ||
                        transactionTable.transactionId == _seachIdentifiers ||
                        transactionTable.ReceiptId == _seachIdentifiers ||
                        transactionTable.SalesOrderId == _seachIdentifiers ||
                        transactionTable.custAccount == _seachIdentifiers ||
                        transactionTable.ChannelReferenceId == _seachIdentifiers)
                    && (_storeId == '' || transactionTable.Store == _storeId)
                    && (_terminalId == '' || transactionTable.Terminal == _terminalId)
                    && (_staffId == '' || transactionTable.Staff == _staffId)
                    && transactionTable.TransDate >= startDate
                    && transactionTable.TransDate <= endDate
                    && (_custAccount == '' || transactionTable.custAccount == _custAccount)
                join salesTable
                    where transactionTable.salesOrderId == salesTable.SalesId
                       && (_salesId == '' || salesTable.SalesId == _salesId)
                       && (_custAccount == '' || transactionTable.CustAccount == salesTable.CustAccount)
                       && salesTable.SalesType == SalesType::Sales
                outer join customerTable
                    where transactionTable.CustAccount == customerTable.AccountNum
                outer join rsoTable
                    where salesTable.RecId == rsoTable.SalesTable
                       && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                exists join salesLineExistsTable
                    where transactionTable.TransactionId == salesLineExistsTable.TransactionId
                        && transactionTable.Channel == salesLineExistsTable.Channel
                        && transactionTable.Store == salesLineExistsTable.Store
                        && transactionTable.Terminal == salesLineExistsTable.Terminalid
                        && transactionTable.DataAreaId == salesLineExistsTable.DataAreaId
                        && (_itemId == '' || salesLineExistsTable.ItemId == _itemId)
                        && (_barcode == '' || salesLineExistsTable.Barcode == _barcode)
                        && (_serialNumber == '' || salesLineExistsTable.InventSerialId == _serialNumber)
                {
                    if (resultsCount < _resultsMaxCount)
                    {
                        if (foundSalesOrders.in(salesTable.SalesId) == false
                        && (!filterByTransactionType || transactionTypesSet.in(transactionTable.Type))
                        && (!filterByTransactionStatusType || confind(TransactionStatusTypes, transactionTable.entryStatus) != 0))
                        {
                            salesOrderXmlMap.insert(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel), RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, transactionTable, _includeDetails, xmlDoc, includeDiscountLines));
                            foundSalesOrders.add(salesTable.SalesId);
                            resultsCount++;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
            //end if (_includeNonTransactions)

            // Query for transactions
            while select Channel, TransactionId, ReceiptId, Store, Terminal, Staff, TransDate, TransTime, CustAccount, NetAmount, Shift, PaymentAmount, SalesOrderId, ChannelReferenceId,
                         GrossAmount, DiscAmount, TotalDiscAmount, EntryStatus, LoyaltyCardId, ReceiptEmail, Type, CreatedDateTime, InvoiceComment
                from transactionTable
                group by Channel, TransactionId, ReceiptId, Store, Terminal, Staff, TransDate, TransTime, CustAccount, NetAmount, Shift, PaymentAmount, SalesOrderId, ChannelReferenceId,
                         GrossAmount, DiscAmount, TotalDiscAmount, EntryStatus, LoyaltyCardId, ReceiptEmail, Type, CreatedDateTime, InvoiceComment
                order by CreatedDateTime desc
                where (_receiptId == '' || transactionTable.ReceiptId == _receiptId)
                    && (_transactionId == '' || transactionTable.transactionId == _transactionId)
                    && (_channelRefId == '' || transactionTable.ChannelReferenceId == _channelRefId)
                    && (_salesId == '' || transactionTable.SalesOrderId == _salesId)
                    && (_receiptEmailAddress == '' || transactionTable.receiptEmail == _receiptEmailAddress)
                    && (_seachIdentifiers == '' ||
                        transactionTable.transactionId == _seachIdentifiers ||
                        transactionTable.ReceiptId == _seachIdentifiers ||
                        transactionTable.SalesOrderId == _seachIdentifiers ||
                        transactionTable.custAccount == _seachIdentifiers ||
                        transactionTable.ChannelReferenceId == _seachIdentifiers)
                    && (_storeId == '' || transactionTable.Store == _storeId)
                    && (_terminalId == '' || transactionTable.Terminal == _terminalId)
                    && (_staffId == '' || transactionTable.Staff == _staffId)
                    && transactionTable.TransDate >= startDate
                    && transactionTable.TransDate <= endDate
                    && (_custAccount == '' || transactionTable.custAccount == _custAccount)
                    && (transactionTable.Type == RetailTransactionType::Sales
                        || (includeCustomerOrder && (transactionTable.Type == RetailTransactionType::CustomerOrder
                                                    || transactionTable.type == RetailTransactionType::AsyncCustomerOrder
                                                    || transactionTable.type == RetailTransactionType::AsyncCustomerQuote))
                        || transactionTable.Type == RetailTransactionType::SalesOrder
                        || transactionTable.Type == RetailTransactionType::PendingSalesOrder)
                outer join sum(Amount) from taxTable
                    where transactionTable.TransactionId == taxTable.TransactionId
                        && transactionTable.Channel == taxTable.Channel
                        && transactionTable.Store == taxTable.StoreId
                        && transactionTable.Terminal == taxTable.TerminalId
                        && transactionTable.DataAreaId == taxTable.DataAreaId
                outer join sum(CalculatedAmount) from chargeTable
                    where transactionTable.TransactionId == chargeTable.TransactionId
                        && transactionTable.Channel == chargeTable.Channel
                        && transactionTable.Store == chargeTable.Store
                        && transactionTable.Terminal == chargeTable.TerminalId
                        && transactionTable.DataAreaId == chargeTable.DataAreaId
                exists join salesLineExistsTable
                    where transactionTable.TransactionId == salesLineExistsTable.TransactionId
                        && transactionTable.Channel == salesLineExistsTable.Channel
                        && transactionTable.Store == salesLineExistsTable.Store
                        && transactionTable.Terminal == salesLineExistsTable.TerminalId
                        && transactionTable.DataAreaId == salesLineExistsTable.DataAreaId
                        && (_itemId == '' || salesLineExistsTable.ItemId == _itemId)
                        && (_barcode == '' || salesLineExistsTable.Barcode == _barcode)
                        && (_serialNumber == '' || salesLineExistsTable.InventSerialId == _serialNumber)
            {
                // Skip if we have already found the corresponding Sales Order or reached max count or doesn't match transaction types
                if (resultsCount < _resultsMaxCount)
                {
                    if (!salesOrderXmlMap.exists(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel))
                        && (!filterByTransactionType || transactionTypesSet.in(transactionTable.Type))
                        && (!filterByTransactionStatusType || confind(TransactionStatusTypes, transactionTable.entryStatus) != 0))
                    {
                        results = true;
                        transactionXmlMap.insert(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel),
                            RetailTransactionServiceTransactions::fillRetailTransactionDetails(transactionTable, taxTable, chargeTable, partyTable, xmlDoc, _includeDetails, false, #ElementSalesOrder));
                        if (foundSalesOrders.in(transactionTable.SalesOrderId) == false)
                        {
                            foundSalesOrders.add(transactionTable.SalesOrderId);
                        }
                        resultsCount++;
                    }
                }
                else
                {
                    break;
                }
            }

            // Catch new sales orders that haven't been processed by the p-job
            if (_includeNonTransactions && (_salesId != '' || _custAccount != '' || _channelRefId != '' || _storeId != '' || _terminalId != '' || _transactionId != '' || _seachIdentifiers != '' || _startDate!= ''))
            {
                if (_seachIdentifiers != '')
                {
                    insert_recordset tmpRecIdFilter ( RefRecId )
                    select RecId
                    from salesTable where salesTable.SalesId == _seachIdentifiers
                    notExists join tmpRecIdFilterDuplicateCheck
                    where tmpRecIdFilterDuplicateCheck.RefRecId == salesTable.RecId;

                    insert_recordset tmpRecIdFilter ( RefRecId )
                    select RecId
                    from salesTable where salesTable.custAccount == _seachIdentifiers
                    notExists join tmpRecIdFilterDuplicateCheck
                    where tmpRecIdFilterDuplicateCheck.RefRecId == salesTable.RecId;

                    insert_recordset tmpRecIdFilter ( RefRecId )
                    select SalesTable
                    from rsoTable where rsoTable.ChannelReferenceId == _seachIdentifiers
                    notExists join tmpRecIdFilterDuplicateCheck
                    where tmpRecIdFilterDuplicateCheck.RefRecId == rsoTable.SalesTable;
                }
                else
                {
                    tmpRecIdFilter.RefRecId = -1;
                    tmpRecIdFilter.insert();
                }

                // Return orders will set the transactionId = invoiceId
                if (_transactionId != '')
                {
                    if (_channelRefId != '' || _storeId != '' || _terminalId != '')
                    {
                        // Query for sales orders joining with custInvoiceJour to match the transactionId
                        // (INCLUDE ChannelRef, StoreId, TerminalId in the search criteria)
                        while select * from salesTable
                        order by salesTable.createdDateTime desc
                        where (_salesId == '' || salesTable.SalesId == _salesId)
                            && salesTable.createdDateTime >= startDateTime
                            && salesTable.createdDateTime <= endDateTime
                            && (_custAccount == '' || salesTable.custAccount == _custAccount)
                            && (_seachIdentifiers == '' ||
                                salesTable.SalesId == _seachIdentifiers ||
                                salesTable.custAccount == _seachIdentifiers)
                            && salesTable.SalesType == SalesType::Sales
                        join rsoTable
                            where salesTable.RecId == rsoTable.SalesTable
                            && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                            && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                            && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                        join InvoiceId from custInvoiceJour
                            where custInvoiceJour.SalesId == salesTable.SalesId
                            && (_transactionId == '' || custInvoiceJour.InvoiceId == _transactionId)
                        outer join customerTable
                            where salesTable.CustAccount == customerTable.AccountNum
                        outer join type from transactionTable
                            where salesTable.SalesId == transactionTable.salesOrderId
                        exists join tmpRecIdFilter
                            where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                        exists join salesLineTable
                            where salesTable.SalesId == salesLineTable.SalesId
                                && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                && (_barcode == '' || salesLineTable.Barcode == _barcode)
                        {
                            if (resultsCount < _resultsMaxCount)
                            {
                                if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                {
                                    salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                    foundSalesOrders.add(salesTable.SalesId);
                                    resultsCount++;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        // Query for sales orders joining with custInvoiceJour to match the transactionId
                        // (EXCLUDE ChannelRef, StoreId, TerminalId from the search criteria)
                        while select * from salesTable
                        order by salesTable.createdDateTime desc
                        where (_salesId == '' || salesTable.SalesId == _salesId)
                            && salesTable.createdDateTime >= startDateTime
                            && salesTable.createdDateTime <= endDateTime
                            && (_custAccount == '' || salesTable.custAccount == _custAccount)
                            && (_seachIdentifiers == '' ||
                                salesTable.SalesId == _seachIdentifiers ||
                                salesTable.custAccount == _seachIdentifiers)
                            && salesTable.SalesType == SalesType::Sales
                        outer join rsoTable
                            where salesTable.RecId == rsoTable.SalesTable
                            && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                            && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                            && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                        join InvoiceId from custInvoiceJour
                            where custInvoiceJour.SalesId == salesTable.SalesId
                            && (_transactionId == '' || custInvoiceJour.InvoiceId == _transactionId)
                        outer join customerTable
                            where salesTable.CustAccount == customerTable.AccountNum
                        outer join type from transactionTable
                            where salesTable.SalesId == transactionTable.salesOrderId
                        exists join tmpRecIdFilter
                            where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                        exists join salesLineTable
                            where salesTable.SalesId == salesLineTable.SalesId
                                && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                && (_barcode == '' || salesLineTable.Barcode == _barcode)
                        {
                            if (resultsCount < _resultsMaxCount)
                            {
                                if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                {
                                    salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                    foundSalesOrders.add(salesTable.SalesId);
                                    resultsCount++;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }
                else
                {
                    if (includeCustomerOrder)
                    {
                        if (_channelRefId != '' || _receiptId != '' || _storeId != '' || _terminalId != '')
                        {
                            // Query for sales orders
                            while select * from salesTable
                            order by salesTable.createdDateTime desc
                            where (_salesId == '' || salesTable.SalesId == _salesId)
                                && salesTable.createdDateTime >= startDateTime
                                && salesTable.createdDateTime <= endDateTime
                                && (_custAccount == '' || salesTable.custAccount == _custAccount)
                                && (_seachIdentifiers == '' ||
                                    salesTable.SalesId == _seachIdentifiers ||
                                    salesTable.custAccount == _seachIdentifiers)
                            && salesTable.SalesType == SalesType::Sales
                            join rsoTable
                                where salesTable.RecId == rsoTable.SalesTable
                                && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                                && (_receiptId == '' || rsoTable.ChannelReferenceId == _receiptId)
                                && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                                && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                            outer join customerTable
                                where salesTable.CustAccount == customerTable.AccountNum
                            outer join type from transactionTable
                                where salesTable.SalesId == transactionTable.salesOrderId
                                && (transactionTable.CustAccount == '' || salesTable.CustAccount == transactionTable.CustAccount)
                            exists join tmpRecIdFilter
                                where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                            exists join salesLineTable
                                where salesTable.SalesId == salesLineTable.SalesId
                                && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                && (_barcode == '' || salesLineTable.Barcode == _barcode)
                            {
                                if (resultsCount < _resultsMaxCount)
                                {
                                    if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                    {
                                        salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                        foundSalesOrders.add(salesTable.SalesId);
                                        resultsCount++;
                                    }
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            select count(RecId) from rsoTable where rsoTable.ChannelReferenceId == _seachIdentifiers;
                            foundByChannelReferenceId = 0 < int642int(rsoTable.RecId);

                            // Query for sales orders
                            while select * from salesTable
                            order by salesTable.createdDateTime desc
                            where (_salesId == '' || salesTable.SalesId == _salesId)
                                && salesTable.createdDateTime >= startDateTime
                                && salesTable.createdDateTime <= endDateTime
                                && (_custAccount == '' || salesTable.custAccount == _custAccount)
                                && (_seachIdentifiers == '' ||
                                    salesTable.SalesId == _seachIdentifiers ||
                                    salesTable.custAccount == _seachIdentifiers ||
                                    foundByChannelReferenceId)
                            && salesTable.SalesType == SalesType::Sales
                            outer join rsoTable
                                where salesTable.RecId == rsoTable.SalesTable
                                && (_seachIdentifiers == '' || rsoTable.ChannelReferenceId == _seachIdentifiers)
                                && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                                && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                            outer join customerTable
                                where salesTable.CustAccount == customerTable.AccountNum
                            outer join type from transactionTable
                                where salesTable.SalesId == transactionTable.salesOrderId
                                && (transactionTable.CustAccount == '' || salesTable.CustAccount == transactionTable.CustAccount)
                            exists join tmpRecIdFilter
                                where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                            exists join salesLineTable
                                where salesTable.SalesId == salesLineTable.SalesId
                                && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                && (_barcode == '' || salesLineTable.Barcode == _barcode)
                            {
                                if (resultsCount < _resultsMaxCount)
                                {
                                    if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                    {
                                        salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                        foundSalesOrders.add(salesTable.SalesId);
                                        resultsCount++;
                                    }
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                }

                tmpRecIdFilter = null;
            }
            //end Catch new sales orders that haven't been processed by the p-job

            if (results && _includeDetails)
            {
                // Fill in sales lines
                while select TransactionId, Store, Terminal, Channel, TransDate from transactionTable
                    order by transactionTable.CreatedDateTime desc
                    where (_receiptId == '' || transactionTable.ReceiptId == _receiptId)
                        && (_transactionId == '' || transactionTable.transactionId == _transactionId)
                        && (_channelRefId == '' || transactionTable.ChannelReferenceId == _channelRefId)
                        && (_salesId == '' || transactionTable.SalesOrderId == _salesId)
                        && (_receiptEmailAddress == '' || transactionTable.receiptEmail == _receiptEmailAddress)
                        && (_storeId == '' || transactionTable.Store == _storeId)
                        && (_terminalId == '' || transactionTable.Terminal == _terminalId)
                        && (_staffId == '' || transactionTable.Staff == _staffId)
                        && transactionTable.TransDate >= startDate
                        && transactionTable.TransDate <= endDate
                        && (_custAccount == '' || transactionTable.custAccount == _custAccount)
                        && (transactionTable.Type == RetailTransactionType::Sales
                            || (includeCustomerOrder && (transactionTable.Type == RetailTransactionType::CustomerOrder
                                                        || transactionTable.type == RetailTransactionType::AsyncCustomerOrder
                                                        || transactionTable.type == RetailTransactionType::AsyncCustomerQuote))
                            || transactionTable.Type == RetailTransactionType::SalesOrder
                            || transactionTable.Type == RetailTransactionType::PendingSalesOrder)
                    join TransactionId, Store, TerminalId, ReceiptId, LineNum, transDate,
                        Barcode, ItemId, VariantId, ListingId, TransactionStatus, Comment, giftcard,
                        InventBatchId, ReturnQty, Price, NetAmount, NetPrice, NetAmountInclTax, Qty,
                        TaxGroup, TaxAmount, TotalDiscAmount, TotalDiscPct, LineDscAmount,
                        PeriodicDiscAmount, DiscAmount, DiscAmountWithoutTax, Unit, UnitQty, InventSerialId,
                        PeriodicPercentageDiscount, LineManualDiscountAmount, LineManualDiscountPercentage,
                        rfidTagId, OriginalTaxGroup, TaxItemGroup, OriginalTaxItemGroup, PeriodicDiscType, staffId from transactionSalesTable
                        where transactionTable.TransactionId == transactionSalesTable.TransactionId
                        && transactionTable.Channel == transactionSalesTable.Channel
                        && transactionTable.Store == transactionSalesTable.Store
                        && transactionTable.Terminal == transactionSalesTable.Terminalid
                        && transactionTable.DataAreaId == transactionSalesTable.DataAreaId
                    exists join salesLineExistsTable
                        where transactionTable.TransactionId == salesLineExistsTable.TransactionId
                        && transactionTable.Channel == salesLineExistsTable.Channel
                        && transactionTable.Store == salesLineExistsTable.Store
                        && transactionTable.Terminal == salesLineExistsTable.Terminalid
                        && transactionTable.DataAreaId == salesLineExistsTable.DataAreaId
                        && (_itemId == '' || salesLineExistsTable.ItemId == _itemId)
                        && (_barcode == '' || salesLineExistsTable.Barcode == _barcode)
                        && (_serialNumber == '' || salesLineExistsTable.InventSerialId == _serialNumber)
                {
                    // If the transaction exists in the results map, then fill the lines - Ideally, we should restrict the query to ONLY those transactionIds that were already added to the results map.
                    if (transactionXmlMap.exists(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel)))
                    {
                        xmlTrans = transactionXmlMap.lookup(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel));
                        xmlItems = xmlTrans.getElementsByTagName('SalesLines').item(0);
                        xmlItems.appendChild(RetailTransactionServiceTransactions::fillSalesTransDetails(transactionSalesTable, xmlDoc, false, includeDiscountLines));
                    }
                    else
                    {
                        // TransactionId wasn't in the header result map.
                        eventSource.EventWriteOrdersSearchOrderListNotExistsWithoutCustNameWarning(funcName(), transactionTable.RecId);
                    }
                }
            }
        }
        else
        {
            //
            // Search LIKE CustomerName
            //

            if (_includeNonTransactions)
            {
                // Query for sales orders
                while select Channel, TransactionId, ReceiptId, Store, Terminal, Staff, TransDate, TransTime, CustAccount, NetAmount, Shift, PaymentAmount, SalesOrderId, ChannelReferenceId,
                         GrossAmount, DiscAmount, TotalDiscAmount, EntryStatus, LoyaltyCardId, ReceiptEmail, Type, CreatedDateTime from transactionTable
                order by transactionTable.CreatedDateTime desc
                where (_receiptId == '' || transactionTable.ReceiptId == _receiptId)
                    && (_transactionId == '' || transactionTable.transactionId == _transactionId)
                    && (_channelRefId == '' || transactionTable.ChannelReferenceId == _channelRefId)
                    && (_salesId == '' || transactionTable.SalesOrderId == _salesId)
                    && (_receiptEmailAddress == '' || transactionTable.receiptEmail == _receiptEmailAddress)
                    && (_seachIdentifiers == '' ||
                        transactionTable.transactionId == _seachIdentifiers ||
                        transactionTable.ReceiptId == _seachIdentifiers ||
                        transactionTable.SalesOrderId == _seachIdentifiers ||
                        transactionTable.custAccount == _seachIdentifiers ||
                        transactionTable.ChannelReferenceId == _seachIdentifiers)
                    && (_storeId == '' || transactionTable.Store == _storeId)
                    && (_terminalId == '' || transactionTable.Terminal == _terminalId)
                    && (_staffId == '' || transactionTable.Staff == _staffId)
                    && transactionTable.TransDate >= startDate
                    && transactionTable.TransDate <= endDate
                    && (_custAccount == '' || transactionTable.custAccount == _custAccount)
                    && (transactionTable.Type == RetailTransactionType::PendingSalesOrder
                        || (includeCustomerOrder && (transactionTable.Type == RetailTransactionType::CustomerOrder
                                                    || transactionTable.type == RetailTransactionType::AsyncCustomerOrder
                                                    || transactionTable.type == RetailTransactionType::AsyncCustomerQuote)))
                join salesTable
                    where transactionTable.SalesOrderId == salesTable.SalesId
                       && (_salesId == '' || salesTable.SalesId == _salesId)
                       && (transactionTable.CustAccount == '' || transactionTable.CustAccount == salesTable.CustAccount)
                       && salesTable.SalesType == SalesType::Sales
                join AccountNum from customerTable
                    where transactionTable.CustAccount == customerTable.AccountNum
                join Name from partyTable
                    where partyTable.RecId == customerTable.Party
                        && partyTable.Name like custName
                outer join rsoTable
                    where salesTable.RecId == rsoTable.SalesTable
                       && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                exists join salesLineExistsTable
                    where transactionTable.TransactionId == salesLineExistsTable.TransactionId
                        && transactionTable.Channel == salesLineExistsTable.Channel
                        && transactionTable.Store == salesLineExistsTable.Store
                        && transactionTable.Terminal == salesLineExistsTable.Terminalid
                        && transactionTable.DataAreaId == salesLineExistsTable.DataAreaId
                        && (_itemId == '' || salesLineExistsTable.ItemId == _itemId)
                        && (_barcode == '' || salesLineExistsTable.Barcode == _barcode)
                        && (_serialNumber == '' || salesLineExistsTable.InventSerialId == _serialNumber)
                {
                    if (resultsCount < _resultsMaxCount)
                    {
                        if (foundSalesOrders.in(salesTable.SalesId) == false
                        && (!filterByTransactionType || transactionTypesSet.in(transactionTable.Type))
                        && (!filterByTransactionStatusType || confind(TransactionStatusTypes, transactionTable.entryStatus) != 0))
                        {
                            salesOrderXmlMap.insert(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel), RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, transactionTable, _includeDetails, xmlDoc, includeDiscountLines));
                            foundSalesOrders.add(salesTable.SalesId);
                            resultsCount++;
                        }
                    }
                    else
                    {
                        break;
                    }
                }
            }
            //end if (_includeNonTransactions)

            // Query for transactions
            while select Channel, TransactionId, ReceiptId, Store, Terminal, Staff, TransDate, TransTime, CustAccount, NetAmount, ChannelReferenceId,
                         GrossAmount, DiscAmount, TotalDiscAmount, EntryStatus, LoyaltyCardId, ReceiptEmail, Type, CreatedDateTime, SalesOrderId, InvoiceComment
                from transactionTable
                group by Channel, TransactionId, ReceiptId, Store, Terminal, Staff, TransDate, TransTime, CustAccount, NetAmount, ChannelReferenceId,
                         GrossAmount, DiscAmount, TotalDiscAmount, EntryStatus, LoyaltyCardId, ReceiptEmail, Type, CreatedDateTime, SalesOrderId, InvoiceComment
                where (_receiptId == '' || transactionTable.ReceiptId == _receiptId)
                    && (_transactionId == '' || transactionTable.transactionId == _transactionId)
                    && (_channelRefId == '' || transactionTable.ChannelReferenceId == _channelRefId)
                    && (_salesId == '' || transactionTable.SalesOrderId == _salesId)
                    && (_receiptEmailAddress == '' || transactionTable.receiptEmail == _receiptEmailAddress)
                    && (_seachIdentifiers == '' ||
                        transactionTable.transactionId == _seachIdentifiers ||
                        transactionTable.ReceiptId == _seachIdentifiers ||
                        transactionTable.SalesOrderId == _seachIdentifiers ||
                        transactionTable.custAccount == _seachIdentifiers ||
                        transactionTable.ChannelReferenceId == _seachIdentifiers)
                    && (_storeId == '' || transactionTable.Store == _storeId)
                    && (_terminalId == '' || transactionTable.Terminal == _terminalId)
                    && (_staffId == '' || transactionTable.Staff == _staffId)
                    && transactionTable.TransDate >= startDate
                    && transactionTable.TransDate <= endDate
                    && (_custAccount == '' || transactionTable.custAccount == _custAccount)
                    && (transactionTable.Type == RetailTransactionType::Sales
                        || (includeCustomerOrder && (transactionTable.Type == RetailTransactionType::CustomerOrder
                                                    || transactionTable.type == RetailTransactionType::AsyncCustomerOrder
                                                    || transactionTable.type == RetailTransactionType::AsyncCustomerQuote))
                        || transactionTable.Type == RetailTransactionType::SalesOrder
                        || transactionTable.Type == RetailTransactionType::PendingSalesOrder)
                outer join sum(Amount) from taxTable
                    where taxTable.TransactionId   == transactionTable.TransactionId
                        && transactionTable.Channel == taxTable.Channel
                        && transactionTable.Store == taxTable.StoreId
                        && transactionTable.Terminal == taxTable.TerminalId
                        && transactionTable.DataAreaId == taxTable.DataAreaId
                outer join sum(CalculatedAmount) from chargeTable
                    where transactionTable.TransactionId == chargeTable.TransactionId
                        && transactionTable.Channel == chargeTable.Channel
                        && transactionTable.Store == chargeTable.Store
                        && transactionTable.Terminal == chargeTable.TerminalId
                        && transactionTable.DataAreaId == chargeTable.DataAreaId
                exists join AccountNum from customerTable
                    where transactionTable.CustAccount == customerTable.AccountNum
                exists join Name from partyTable
                    where customerTable.Party == partyTable.RecId
                        && partyTable.Name like custName
                exists join salesLineExistsTable
                    where transactionTable.TransactionId == salesLineExistsTable.TransactionId
                        && transactionTable.Channel == salesLineExistsTable.Channel
                        && transactionTable.Store == salesLineExistsTable.Store
                        && transactionTable.Terminal == salesLineExistsTable.Terminalid
                        && transactionTable.DataAreaId == salesLineExistsTable.DataAreaId
                        && (_itemId == '' || salesLineExistsTable.ItemId == _itemId)
                        && (_barcode == '' || salesLineExistsTable.Barcode == _barcode)
                        && (_serialNumber == '' || salesLineExistsTable.InventSerialId == _serialNumber)
            {
                customerTable = CustTable::find(transactionTable.CustAccount);
                partyTable = DirPartyTable::findRec(customerTable.Party);
                if (resultsCount < _resultsMaxCount)
                {
                    // Skip if we have already found the corresponding Sales Order or transaction types do not match
                    if (!salesOrderXmlMap.exists(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel))
                        && (!filterByTransactionType || transactionTypesSet.in(transactionTable.Type))
                        && (!filterByTransactionStatusType || confind(TransactionStatusTypes, transactionTable.entryStatus) != 0))
                    {
                        results = true;
                        transactionXmlMap.insert(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel),
                            RetailTransactionServiceTransactions::fillRetailTransactionDetails(transactionTable, taxTable, chargeTable, partyTable, xmlDoc, _includeDetails, false, #ElementSalesOrder));
                        if (foundSalesOrders.in(transactionTable.SalesOrderId) == false)
                        {
                            foundSalesOrders.add(transactionTable.SalesOrderId);
                        }
                        resultsCount++;
                    }
                }
                else
                {
                    break;
                }
            }

            // Catch new sales orders that haven't been processed by the p-job
            if (_includeNonTransactions && (_salesId != '' || _custAccount != '' || _channelRefId != '' || _storeId != '' || _terminalId != '' || custName != '' || _transactionId != '' || _seachIdentifiers != '' || _startDate!= ''))
            {
                if (_seachIdentifiers != '')
                {
                    insert_recordset tmpRecIdFilter ( RefRecId )
                    select RecId
                    from salesTable where salesTable.SalesId == _seachIdentifiers
                    notExists join tmpRecIdFilterDuplicateCheck
                    where tmpRecIdFilterDuplicateCheck.RefRecId == salesTable.RecId;

                    insert_recordset tmpRecIdFilter ( RefRecId )
                    select RecId
                    from salesTable where salesTable.custAccount == _seachIdentifiers
                    notExists join tmpRecIdFilterDuplicateCheck
                    where tmpRecIdFilterDuplicateCheck.RefRecId == salesTable.RecId;

                    insert_recordset tmpRecIdFilter ( RefRecId )
                    select SalesTable
                    from rsoTable where rsoTable.ChannelReferenceId == _seachIdentifiers
                    notExists join tmpRecIdFilterDuplicateCheck
                    where tmpRecIdFilterDuplicateCheck.RefRecId == rsoTable.SalesTable;
                }
                else
                {
                    tmpRecIdFilter.RefRecId = -1;
                    tmpRecIdFilter.insert();
                }

                // Return orders will set the transactionId = invoiceId
                if (_transactionId != '')
                {
                    if (_channelRefId != '' || _storeId != '' || _terminalId != '')
                    {
                        // Query for sales orders joining with custInvoiceJour to match the transactionId
                        while select * from salesTable
                        order by salesTable.createdDateTime desc
                        where (_salesId == '' || salesTable.SalesId == _salesId)
                            && salesTable.createdDateTime >= startDateTime
                            && salesTable.createdDateTime <= endDateTime
                            && (_custAccount == '' || salesTable.custAccount == _custAccount)
                            && (_seachIdentifiers == '' ||
                                salesTable.SalesId == _seachIdentifiers ||
                                salesTable.custAccount == _seachIdentifiers)
                            && salesTable.SalesType == SalesType::Sales
                        join rsoTable
                            where salesTable.RecId == rsoTable.SalesTable
                            && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                            && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                            && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                        join InvoiceId from custInvoiceJour
                            where custInvoiceJour.SalesId == salesTable.SalesId
                            && (_transactionId == '' || custInvoiceJour.InvoiceId == _transactionId)
                        outer join customerTable
                            where salesTable.CustAccount == customerTable.AccountNum
                        join Name from partyTable
                            where partyTable.RecId == customerTable.Party
                                && partyTable.Name like custName
                        outer join type from transactionTable
                            where salesTable.SalesId == transactionTable.salesOrderId
                                && (transactionTable.CustAccount == '' || transactionTable.CustAccount == salesTable.CustAccount)
                        exists join tmpRecIdFilter
                            where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                        exists join salesLineTable
                            where salesTable.SalesId == salesLineTable.SalesId
                                && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                && (_barcode == '' || salesLineTable.Barcode == _barcode)
                        {
                            if (resultsCount < _resultsMaxCount)
                            {
                                if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                {
                                    salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                    foundSalesOrders.add(salesTable.SalesId);
                                    resultsCount++;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                    else
                    {
                        if (_channelRefId != '' || _storeId != '' || _terminalId != '')
                        {
                            // Query for sales orders joining with custInvoiceJour to match the transactionId
                            while select * from salesTable
                            order by salesTable.createdDateTime desc
                            where (_salesId == '' || salesTable.SalesId == _salesId)
                                && salesTable.createdDateTime >= startDateTime
                                && salesTable.createdDateTime <= endDateTime
                                && (_custAccount == '' || salesTable.custAccount == _custAccount)
                                && (_seachIdentifiers == '' ||
                                    salesTable.SalesId == _seachIdentifiers ||
                                    salesTable.custAccount == _seachIdentifiers)
                                && salesTable.SalesType == SalesType::Sales
                            join rsoTable
                                where salesTable.RecId == rsoTable.SalesTable
                                && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                                && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                                && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                            join InvoiceId from custInvoiceJour
                                where custInvoiceJour.SalesId == salesTable.SalesId
                                && (_transactionId == '' || custInvoiceJour.InvoiceId == _transactionId)
                            outer join customerTable
                                where salesTable.CustAccount == customerTable.AccountNum
                            join Name from partyTable
                                where partyTable.RecId == customerTable.Party
                                    && partyTable.Name like custName
                            outer join type from transactionTable
                                where salesTable.SalesId == transactionTable.salesOrderId
                                    && (transactionTable.CustAccount == '' || salesTable.CustAccount == transactionTable.CustAccount)
                            exists join tmpRecIdFilter
                                where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                            exists join salesLineTable
                                where salesTable.SalesId == salesLineTable.SalesId
                                    && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                    && (_barcode == '' || salesLineTable.Barcode == _barcode)
                            {
                                if (resultsCount < _resultsMaxCount)
                                {
                                    if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                    {
                                        salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                        foundSalesOrders.add(salesTable.SalesId);
                                        resultsCount++;
                                    }
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                        else
                        {
                            // Query for sales orders joining with custInvoiceJour to match the transactionId
                            while select * from salesTable
                            order by salesTable.createdDateTime desc
                            where (_salesId == '' || salesTable.SalesId == _salesId)
                                && salesTable.createdDateTime >= startDateTime
                                && salesTable.createdDateTime <= endDateTime
                                && (_custAccount == '' || salesTable.custAccount == _custAccount)
                                && (_seachIdentifiers == '' ||
                                    salesTable.SalesId == _seachIdentifiers ||
                                    salesTable.custAccount == _seachIdentifiers)
                                && salesTable.SalesType == SalesType::Sales
                            outer join rsoTable
                                where salesTable.RecId == rsoTable.SalesTable
                                && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                                && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                                && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                            join InvoiceId from custInvoiceJour
                                where custInvoiceJour.SalesId == salesTable.SalesId
                                && (_transactionId == '' || custInvoiceJour.InvoiceId == _transactionId)
                            outer join customerTable
                                where salesTable.CustAccount == customerTable.AccountNum
                            join Name from partyTable
                                where partyTable.RecId == customerTable.Party
                                    && partyTable.Name like custName
                            outer join type from transactionTable
                                where salesTable.SalesId == transactionTable.salesOrderId
                                    && (transactionTable.CustAccount == '' || salesTable.CustAccount == transactionTable.CustAccount)
                            exists join tmpRecIdFilter
                                where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                            exists join salesLineTable
                                where salesTable.SalesId == salesLineTable.SalesId
                                    && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                    && (_barcode == '' || salesLineTable.Barcode == _barcode)
                            {
                                if (resultsCount < _resultsMaxCount)
                                {
                                    if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                    {
                                        salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                        foundSalesOrders.add(salesTable.SalesId);
                                        resultsCount++;
                                    }
                                }
                                else
                                {
                                    break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    if (includeCustomerOrder)
                    {
                        // Query for sales orders
                        while select * from salesTable
                        order by salesTable.createdDateTime desc
                        where (_salesId == '' || salesTable.SalesId == _salesId)
                            && salesTable.createdDateTime >= startDateTime
                            && salesTable.createdDateTime <= endDateTime
                            && (_custAccount == '' || salesTable.custAccount == _custAccount)
                            && (_seachIdentifiers == '' ||
                                salesTable.SalesId == _seachIdentifiers ||
                                salesTable.custAccount == _seachIdentifiers)
                        && salesTable.SalesType == SalesType::Sales
                        outer join rsoTable
                            where salesTable.RecId == rsoTable.SalesTable
                            && (_channelRefId == '' || rsoTable.ChannelReferenceId == _channelRefId)
                            && (_storeId == '' || rsoTable.RetailStoreId == _storeId)
                            && (_terminalId == '' || rsoTable.RetailTerminalId == _terminalId)
                        outer join customerTable
                            where salesTable.CustAccount == customerTable.AccountNum
                        join Name from partyTable
                            where partyTable.RecId == customerTable.Party
                                && partyTable.Name like custName
                        outer join type from transactionTable
                            where salesTable.SalesId == transactionTable.salesOrderId
                                && (transactionTable.CustAccount == '' || salesTable.CustAccount == transactionTable.CustAccount)
                        exists join tmpRecIdFilter
                            where tmpRecIdFilter.RefRecId == -1 || tmpRecIdFilter.RefRecId == salesTable.RecId
                        exists join salesLineTable
                            where salesTable.SalesId == salesLineTable.SalesId
                                && (_itemId == '' || salesLineTable.ItemId == _itemId)
                                && (_barcode == '' || salesLineTable.Barcode == _barcode)
                        {
                            if (resultsCount < _resultsMaxCount)
                            {
                                if (foundSalesOrders.in(salesTable.SalesId) == false
                                        && (!filterByTransactionType || !transactionTable || transactionTypesSet.in(transactionTable.Type)))
                                {
                                    salesOrderXmlMap.insert(salesTable.SalesId, RetailTransactionServiceTransactions::fillSalesOrderDetails(salesTable, rsoTable, customerTable, null, _includeDetails, xmlDoc, includeDiscountLines));
                                    foundSalesOrders.add(salesTable.SalesId);
                                    resultsCount++;
                                }
                            }
                            else
                            {
                                break;
                            }
                        }
                    }
                }

                tmpRecIdFilter = null;
            }

            if (results && _includeDetails)
            {
                // Fill in sales lines
                while select TransactionId, Store, Terminal, Channel from transactionTable
                    order by transactionTable.CreatedDateTime desc
                    where (_receiptId == '' || transactionTable.ReceiptId == _receiptId)
                        && (_transactionId == '' || transactionTable.transactionId == _transactionId)
                        && (_channelRefId == '' || transactionTable.ChannelReferenceId == _channelRefId)
                        && (_receiptEmailAddress == '' || transactionTable.receiptEmail == _receiptEmailAddress)
                        && (_storeId == '' || transactionTable.Store == _storeId)
                        && (_terminalId == '' || transactionTable.Terminal == _terminalId)
                        && (_staffId == '' || transactionTable.Staff == _staffId)
                        && transactionTable.TransDate >= startDate
                        && transactionTable.TransDate <= endDate
                        && (_custAccount == '' || transactionTable.custAccount == _custAccount)
                        && (transactionTable.Type == RetailTransactionType::Sales
                            || (includeCustomerOrder && (transactionTable.Type == RetailTransactionType::CustomerOrder
                                                        || transactionTable.type == RetailTransactionType::AsyncCustomerOrder
                                                        || transactionTable.type == RetailTransactionType::AsyncCustomerQuote))
                            || transactionTable.Type == RetailTransactionType::SalesOrder
                            || transactionTable.Type == RetailTransactionType::PendingSalesOrder)
                    join TransactionId, Store, TerminalId, ReceiptId, LineNum, transDate,
                            Barcode, ItemId, VariantId, ListingId, TransactionStatus, Comment,
                            InventBatchId, ReturnQty, Price, NetAmount, NetPrice, NetAmountInclTax, Qty,
                            TaxGroup, TaxAmount, TotalDiscAmount, TotalDiscPct, LineDscAmount,
                            PeriodicDiscAmount, DiscAmount, DiscAmountWithoutTax, Unit, UnitQty, InventSerialId,
                            PeriodicPercentageDiscount, LineManualDiscountAmount, LineManualDiscountPercentage,
                            rfidTagId, OriginalTaxGroup, TaxItemGroup, OriginalTaxItemGroup, PeriodicDiscType, staffId from transactionSalesTable
                        where transactionTable.TransactionId == transactionSalesTable.TransactionId
                        && transactionTable.Channel == transactionSalesTable.Channel
                        && transactionTable.Store == transactionSalesTable.Store
                        && transactionTable.Terminal == transactionSalesTable.Terminalid
                        && transactionTable.DataAreaId == transactionSalesTable.DataAreaId
                    join AccountNum from customerTable
                        where transactionTable.CustAccount == customerTable.AccountNum
                    join Name from partyTable
                        where partyTable.RecId == customerTable.Party
                            && partyTable.Name like custName
                    exists join salesLineExistsTable
                        where transactionTable.TransactionId == salesLineExistsTable.TransactionId
                            && transactionTable.Channel == salesLineExistsTable.Channel
                            && transactionTable.Store == salesLineExistsTable.Store
                            && transactionTable.Terminal == salesLineExistsTable.Terminalid
                            && transactionTable.DataAreaId == salesLineExistsTable.DataAreaId
                            && (_itemId == '' || salesLineExistsTable.ItemId == _itemId)
                            && (_barcode == '' || salesLineExistsTable.Barcode == _barcode)
                            && (_serialNumber == '' || salesLineExistsTable.InventSerialId == _serialNumber)
                {
                    // If the transaction exists in the results map, then fill the lines - Ideally, we should restrict the query to ONLY those transactionIds that were already added to the results map.
                    if (transactionXmlMap.exists(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel)))
                    {
                        xmlTrans = transactionXmlMap.lookup(transactionTable.transactionId + transactionTable.store + transactionTable.terminal + int642str(transactionTable.Channel));
                        xmlItems = xmlTrans.getElementsByTagName('SalesLines').item(0);
                        xmlItems.appendChild(RetailTransactionServiceTransactions::fillSalesTransDetails(transactionSalesTable, xmlDoc, false, includeDiscountLines));
                    }
                    else
                    {
                        // TransactionId wasn't in the header result map.
                        eventSource.EventWriteOrdersSearchOrderListNotExistsWithCustNameWarning(funcName(), transactionTable.RecId);
                    }
                }
            }
        }

        // Catch new quotes that haven't been processed by the p-job (if not include only transactions)
        if (_includeNonTransactions && (_salesId != '' || _custAccount != '' || custName != '' || _seachIdentifiers != '' || _receiptEmailAddress != ''))
        {
            while select * from salesQuotationTable
                order by salesQuotationTable.CreatedDateTime desc
                where (_salesId == '' || salesQuotationTable.QuotationId == _salesId)
                    && salesQuotationTable.QuotationType == QuotationType::Sales
                    && salesQuotationTable.createdDateTime >= startDateTime
                    && salesQuotationTable.createdDateTime <= endDateTime
                    && (_custAccount == '' || salesQuotationTable.CustAccount == _custAccount)
                    && (_receiptEmailAddress == '' || salesQuotationTable.Email == _receiptEmailAddress)
                    && (_seachIdentifiers == '' || salesQuotationTable.QuotationId == _seachIdentifiers || salesQuotationTable.CustAccount == _seachIdentifiers)
                    && (salesQuotationTable.QuotationStatus == SalesQuotationStatus::Created
                    || salesQuotationTable.QuotationStatus == SalesQuotationStatus::Approved
                    || salesQuotationTable.QuotationStatus == SalesQuotationStatus::Submitted)
                join customerTable
                    where salesQuotationTable.CustAccount == customerTable.AccountNum
                join Name from partyTable
                    where partyTable.RecId == customerTable.Party
                    && (custName == '' || partyTable.Name like custName)
            {
                if (resultsCount < _resultsMaxCount)
                {
                    quoteXmlMap.insert(salesQuotationTable.QuotationId, RetailTransactionServiceTransactions::fillQuoteDetails(salesQuotationTable, rsqTable, customerTable, _includeDetails, xmlDoc));
                    resultsCount++;
                }
            }
        }

        enumerator = new MapEnumerator(salesOrderXmlMap);
        while (enumerator.MoveNext())
        {
            xmlTrans = enumerator.currentValue();
            xmlRoot.appendChild(xmlTrans);
        }

        enumerator = new MapEnumerator(transactionXmlMap);
        while (enumerator.MoveNext())
        {
            xmlTrans = enumerator.currentValue();
            xmlRoot.appendChild(xmlTrans);
        }

        enumerator = new MapEnumerator(quoteXmlMap);
        while (enumerator.MoveNext())
        {
            xmlTrans = enumerator.currentValue();
            xmlRoot.appendChild(xmlTrans);
        }

        xmlDoc.appendChild(xmlRoot);
        output = conIns(output,conLen(output)+1, xmlDoc.toString());

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for settling the invoice and the customer transactions.
    /// </summary>
    /// <param name="_invoiceId">
    /// ID of the CustTrans.Invoice field.
    /// </param>
    /// <param name=_invoiceType>
    /// The retail invoice type.
    /// </param>
    /// <returns>
    /// <c>Container</c> with the value true and empty string if the settlement is success; else false wih the appropriate string message.
    /// </returns>
    private static container settleInvoice(InvoiceId _invoiceId, RetailInvoiceType _invoiceType)
    {
        CustTable           custTable;
        CustTrans           custTrans;
        LedgerJournalTrans  ledgerJournalTrans;
        CustTransOpen       custTransOpen;
        SpecTransManager    specTransManager;
        CustInvoiceJour     custInvoiceJour;
        ProjInvoiceJour     projInvoiceJour;
        RetailPrePaymentTrans  prepaymentTrans;
        container           settleSuccess = [true, ''];
        LedgerTransType ledgerTransType = RetailTransactionServiceInvoices::invoiceTypeToLedgerTransType(_invoiceType);
        SpecTransExecutionContext specTransExecutionContext;

        //Find invoice
        select firstonly custTrans
        where custTrans.Invoice     == _invoiceId &&
              custTrans.TransType   == ledgerTransType;

        if (custTrans)
        {
            custTable = custTable::find(custTrans.AccountNum);
            specTransExecutionContext = SpecTransExecutionContext::newFromSource(custTable);
            specTransManager = SpecTransManager::newFromSpec(specTransExecutionContext.parmSpecContext());

            custTransOpen = CustTransOpen::findRefId(custTrans.RecId);
        }
        else
        {
            eventSource.EventWriteOrdersSettleInvoiceInvoiceNotFound(funcName());
            settleSuccess = [false,"@RET4510"]; //Could not find invoice to settle.
        }

        if (custTransOpen && custTransOpen.AmountCur)
        {
            specTransManager.insert(custTransOpen.company(),custTransOpen.TableId,custTransOpen.RecId,custTransOpen.AmountCur,custTrans.CurrencyCode);
        }
        else
        {
            eventSource.EventWriteOrdersSettleInvoiceCustTransNotFound(funcName(), custTrans.RecId);
            settleSuccess = [false,"@RET4511"]; //Could not find open customer transaction to settle.
        }

        if (conPeek(settleSuccess,1))
        {
            if (_invoiceType == RetailInvoiceType::Project || _invoiceType == RetailInvoiceType::ProjectCreditNote)
            {
                select firstonly projInvoiceJour
                    where projInvoiceJour.ProjInvoiceId == _invoiceId
                    && projInvoiceJour.InvoiceAccount == custTrans.AccountNum;
            }
            else
            {
                // Find prepayments for the invoice
                select firstonly custInvoiceJour
                    where custInvoiceJour.InvoiceId == _invoiceId;
            }

            if (custInvoiceJour || projInvoiceJour)
            {
                boolean salesOrderInvoice = RetailTransactionServiceInvoices::isSalesOrderInvoice(_invoiceType);

                while select SalesId, CustTransRecId from prepaymentTrans
                where salesOrderInvoice
                    && prepaymentTrans.SalesId == custInvoiceJour.SalesId
                {
                    custTrans = CustTrans::find(prepaymentTrans.CustTransRecId);

                    if (custTrans)
                    {
                        custTransOpen = CustTransOpen::findRefId(custTrans.RecId);
                    }

                    if (custTransOpen && custTransOpen.AmountCur)
                    {
                        specTransManager.insert(custTransOpen.company(),custTransOpen.TableId,custTransOpen.RecId,custTransOpen.AmountCur,custTrans.CurrencyCode);
                    }
                }
            }
            else
            {
                eventSource.EventWriteOrdersSettleInvoiceSalesTableNotFound(funcName());
                settleSuccess = [false,strFmt("@RET4512",_invoiceId)]; //Could not find sales order related to invoice %1.
            }

            if (conPeek(settleSuccess,1))
            {
                //Find payments for the invoice
                while select custTrans
                    where (custTrans.TransType == LedgerTransType::Payment)
                join Voucher from ledgerJournalTrans
                    where (custTrans.Voucher == ledgerJournalTrans.Voucher
                    && ledgerJournalTrans.MarkedInvoice == _invoiceId)
                {
                    custTransOpen = CustTransOpen::findRefId(custTrans.RecId);

                    if (custTransOpen && custTransOpen.AmountCur)
                    {
                        specTransManager.insert(custTransOpen.company(),custTransOpen.TableId,custTransOpen.RecId,custTransOpen.AmountCur,custTrans.CurrencyCode);
                    }
                }

                if (CustTrans::settleTransaction(specTransExecutionContext, CustTransSettleTransactionParameters::construct()))
                {
                    specTransManager.deleteAll();
                }
            }
        }

        return settleSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLinkedPaymentsRefundableAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates refundable amounts for the specified payment lines used in a linked refund.
    /// </summary>
    /// <param name="linkedRefundPaymentLinesXml">
    /// The list of payment lines whose refundable amounts is going to be updated.
    /// Example
    /// <LinkedRefundPayments>
    ///   <LinkedRefundPayment>
    ///     <StoreNumber>ST100001</StoreNumber>
    ///     <TerminalId>T001</TerminalId>
    ///     <TransactionId>Trans1001</TransactionId>
    ///     <LineNumber>1</LineNumber>
    ///     <PreviousRefundableAmount>10.00</PreviousRefundableAmount>
    ///     <UpdatedRefundableAmount>5.00</UpdatedRefundableAmount>
    ///   </LinkedRefundPayment>
    ///   <LinkedRefundPayment>
    ///     <StoreNumber>ST100001</StoreNumber>
    ///     <TerminalId>T001</TerminalId>
    ///     <TransactionId>Trans1001</TransactionId>
    ///     <LineNumber>2</LineNumber>
    ///     <PreviousRefundableAmount>20.00</PreviousRefundableAmount>
    ///     <UpdatedRefundableAmount>0.00</UpdatedRefundableAmount>
    ///   </LinkedRefundPayment>
    /// </LinkedRefundPayments>
    /// </param>
    /// <returns>A container having the status of the operation and error messages if any.</returns>
    public static container updateLinkedPaymentsRefundableAmount(str linkedRefundPaymentLinesXml)
    {
        container result = [true, ''];

        int fromLine = infologLine();

        try
        {
            LinkedRefundPaymentInfoCollection linkedRefundPaymentInfoCollection = LinkedRefundPaymentInfoCollection::Deserialize(linkedRefundPaymentLinesXml);

            for (int i = 0; i < linkedRefundPaymentInfoCollection.LinkedRefundPaymentInfoList.get_Count(); i++)
            {
                Microsoft.Dynamics.Commerce.Runtime.DataModel.LinkedRefundPayment linkedRefundPayment =  linkedRefundPaymentInfoCollection.LinkedRefundPaymentInfoList.get_Item(i);

                RetailTransactionPaymentTrans retailTransactionPaymentTrans;

                select firstonly forupdate retailTransactionPaymentTrans
                    where retailTransactionPaymentTrans.transactionId == linkedRefundPayment.TransactionId &&
                    retailTransactionPaymentTrans.store == linkedRefundPayment.StoreNumber &&
                    retailTransactionPaymentTrans.terminal == linkedRefundPayment.TerminalId &&
                    retailTransactionPaymentTrans.lineNum == linkedRefundPayment.LineNumber;

                RetailTransactionPaymentRefundableAmounts retailTransactionPaymentRefundableAmounts = RetailTransactionPaymentRefundableAmounts::find(linkedRefundPayment.TransactionId,
                                                                                                                                                      linkedRefundPayment.StoreNumber,
                                                                                                                                                      linkedRefundPayment.TerminalId,
                                                                                                                                                      linkedRefundPayment.LineNumber,
                                                                                                                                                      true);

                if (retailTransactionPaymentTrans.RecId != 0)
                {
                    AmountCur minRefundableAmount = retailTransactionPaymentTrans. refundableAmount;

                    // Minimum refundable amount is being calculated to ensure we don't allow overrefund.
                    if(retailTransactionPaymentRefundableAmounts.RecId != 0 && minRefundableAmount > retailTransactionPaymentRefundableAmounts.RefundableAmount)
                    {
                        minRefundableAmount = retailTransactionPaymentRefundableAmounts.RefundableAmount;
                    }

                    if (minRefundableAmount >= linkedRefundPayment.UpdatedRefundableAmount)
                    {
                        ttsbegin;
                        retailTransactionPaymentTrans.RefundableAmount = linkedRefundPayment.UpdatedRefundableAmount;
                        retailTransactionPaymentTrans.update();
                        ttscommit;
                    }
                    else
                    {
                        eventSource.EventWritePaymentsUpdateRefundableAmountForLinkedRefundSkipped(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }

                    if(linkedRefundPayment.PreviousRefundableAmount > retailTransactionPaymentTrans.RefundableAmount)
                    {
                        eventSource.EventWritePaymentsPreviousRefundableAmountGreaterThanCurrentValue(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }
                    else if(linkedRefundPayment.PreviousRefundableAmount < retailTransactionPaymentTrans.RefundableAmount)
                    {
                        eventSource.EventWritePaymentsPreviousRefundableAmountLowerThanCurrentValue(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }

                    // find RetailTransactionPaymentRefundableAmounts records for deleting if exists.
                    if(retailTransactionPaymentRefundableAmounts.RecId != 0)
                    {
                        ttsbegin;
                        retailTransactionPaymentRefundableAmounts.delete();
                        ttscommit;
                    }
                }
                else
                {
                    eventSource.EventWritePaymentsPaymentTransactionRecordNotFound(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);

                    if (retailTransactionPaymentRefundableAmounts.RecId == 0)
                    {
                        // create a record in RetailTransactionPaymentTransTmp table.
                        ttsbegin;
                        retailTransactionPaymentRefundableAmounts.store = linkedRefundPayment.StoreNumber;
                        retailTransactionPaymentRefundableAmounts.terminal = linkedRefundPayment.TerminalId;
                        retailTransactionPaymentRefundableAmounts.RefundableAmount =  linkedRefundPayment.UpdatedRefundableAmount;
                        retailTransactionPaymentRefundableAmounts.transactionId = linkedRefundPayment.TransactionId;
                        retailTransactionPaymentRefundableAmounts.lineNum = linkedRefundPayment.LineNumber;
                        retailTransactionPaymentRefundableAmounts.insert();
                        ttscommit;

                        eventSource.EventWritePaymentsCreatedRetailTransactionPaymentRefundableAmounts(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }
                    else if (retailTransactionPaymentRefundableAmounts.RefundableAmount >= linkedRefundPayment.UpdatedRefundableAmount)
                    {
                        // update the refundable amount in RetailTransactionPaymentTransTmp table.
                        ttsbegin;
                        retailTransactionPaymentRefundableAmounts.RefundableAmount = linkedRefundPayment.UpdatedRefundableAmount;
                        retailTransactionPaymentRefundableAmounts.update();
                        ttscommit;

                        eventSource.EventWritePaymentsUpdatedRetailTransactionPaymentRefundableAmounts(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }

                    if(linkedRefundPayment.PreviousRefundableAmount > retailTransactionPaymentRefundableAmounts.RefundableAmount)
                    {
                        eventSource.EventWritePaymentsPreviousRefundableAmountGreaterThanCurrentValue(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }
                    else if(linkedRefundPayment.PreviousRefundableAmount < retailTransactionPaymentRefundableAmounts.RefundableAmount)
                    {
                        eventSource.EventWritePaymentsPreviousRefundableAmountLowerThanCurrentValue(linkedRefundPayment.TransactionId, linkedRefundPayment.StoreNumber, linkedRefundPayment.TerminalId);
                    }
                }
            }
        }
        catch (Exception::Error)
        {
            str error = RetailTransactionServiceUtilities::getInfologMessages(fromLine);
            result = [false, error];
        }
        catch (Exception::CLRError)
        {
            str error = CLRInterop::getLastException().toString();
            result = [false, error];
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for updating the record in <c>RetailCreditVoucherTable</c>.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.createdInStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.createdByTerminalId field.
    /// </param>
    /// <param name="_staffId">
    /// ID of the RetailCreditVoucherTable.createdByStaffId field.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailCreditVoucherTable.createdByTransactionId field.
    /// </param>
    /// <param name="_receiptId">
    /// ID of the RetailCreditVoucherTable.createdByReceipId field.
    /// </param>
    /// <param name="_lineNum">
    /// ID of the RetailCreditVoucherTable.createdByLineNum field.
    /// </param>
    /// <param name="_amountMST">
    /// Value for the RetailCreditVoucherTable.amount field.
    /// </param>
    /// <param name="_transDate">
    /// Value for the RetailCreditVoucherTable.transDate field.
    /// </param>
    /// <param name="_transTime">
    /// Value for the RetailCreditVoucherTable.transTime field.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container updateCreditMemo(RetailCreditVoucherId   _dataEntryId,
                                             RetailStoreId          _storeId,
                                             RetailTerminalId       _terminalId,
                                             RetailStaffId          _staffId,
                                             RetailTransactionId    _transactionId,
                                             RetailReceiptId        _receiptId,
                                             RetailLineNum          _lineNum,
                                             AmountMST              _amountMST,
                                             str                    _transDate,//RBOTransDate     _transDate,
                                             str                    _transTime,//RetailTransTime     _transTime)
                                             int                    _dateSequence = 321)
    {
        #OCCRetryCount
        container   creditVoucherStatus = [false,0];
        AmountMST   amountMST = 0;
        Counter     pCounter = 0;

        try
        {
            ttsbegin;

            if (RetailCreditVoucherTable::updateRBOCreditVoucherTable(   _dataEntryId,
                                                            _storeId,
                                                            _terminalId,
                                                            _staffId,
                                                            _transactionId,
                                                            _receiptId,
                                                            _lineNum,
                                                            _amountMST,
                                                            str2Date(_transDate,_dateSequence),//_transDate,
                                                            str2time(_transTime))) // _transTime
            {
                creditVoucherStatus = [true,''];
                eventSource.EventWritePaymentsCreditMemoUpdated(RetailCreditVoucherTable::find(_dataEntryId).RecId);
            }
            else
            {
                creditVoucherStatus = [false,"@RET2382"];//infolog.text()];
                eventSource.EventWritePaymentsCreditMemoUpdateError(RetailCreditVoucherTable::find(_dataEntryId).RecId);
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
            {
                retry;
            }

            creditVoucherStatus = [false,"@RET2382"];
            eventSource.EventWritePaymentsCreditMemoUpdateError(RetailCreditVoucherTable::find(_dataEntryId).RecId);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsCreditMemoUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsCreditMemoUpdateRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsCreditMemoUpdateUpdateConflictException();
            }

            creditVoucherStatus = [false,"@RET2382"];
        }
        catch
        {
            creditVoucherStatus = [false,"@RET2382"];
            eventSource.EventWritePaymentsCreditMemoUpdateError(RetailCreditVoucherTable::find(_dataEntryId).RecId);
        }

        infolog.clear(0);
        return creditVoucherStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the credit vouchers.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container validateCreditMemo(RetailCreditVoucherId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId)
    {
        #OCCRetryCount
        RetailCreditVoucherTable    tCreditVoucherTable;
        CurrencyCode        currencyCode = '';
        AmountMST           pAmountMST = 0;
        container           creditVoucherStatus = [false,'',pAmountMST,0];
        Counter             pCounter;
        str                 text01 = "@RET2421";
        str                 text02 = "@RET2422";
        str                 text03 = "@RET2423";    // Future addition
        str                 text04 = "@RET2424";
        str                 text05 = "@RET2425";

        try
        {
            // Process all credit memo transactions that occurred in offline mode before processing the current request.
            RetailCreditVoucherTable::processChannelTransactions();

            ttsbegin;
            tCreditVoucherTable = RetailCreditVoucherTable::find(_dataEntryId);

            if (tCreditVoucherTable)
            {
                if (!tCreditVoucherTable.Voided)
                {
                    if (!tCreditVoucherTable.Applied)
                    {
                        if (tCreditVoucherTable.Reserved)
                        {
                            if (tCreditVoucherTable.ReservedByStoreId == _storeId && tCreditVoucherTable.ReservedByTerminalId == _terminalId)
                            {
                                currencyCode = tCreditVoucherTable.CurrencyCode;
                                pAmountMST = tCreditVoucherTable.Amount;

                                creditVoucherStatus = [true,'',currencyCode,pAmountMST];
                                eventSource.EventWritePaymentsCreditMemoIsValidated(_dataEntryId);
                            }
                            else
                            {
                                creditVoucherStatus = [false,strFmt("@RET2422",_dataEntryId,tCreditVoucherTable.ReservedByStoreId,tCreditVoucherTable.ReservedByTerminalId),currencyCode,pAmountMST];
                                eventSource.EventWritePaymentsCreditMemoIsInUse(_dataEntryId);
                            }
                        }
                        else
                        {
                            if (RetailCreditVoucherTable::reserveRBOCreditVoucherTable(_dataEntryId,_storeId,_terminalId))
                            {
                                currencyCode = tCreditVoucherTable.CurrencyCode;
                                pAmountMST = tCreditVoucherTable.Amount;

                                creditVoucherStatus = [true,'',currencyCode,pAmountMST];
                                eventSource.EventWritePaymentsCreditMemoIsValidated(_dataEntryId);
                            }
                            else
                            {
                                creditVoucherStatus = [false,"@RET2382",currencyCode,pAmountMST];
                                eventSource.EventWritePaymentsCreditMemoValidationFailure(_dataEntryId);
                            }
                        }
                    }
                    else
                    {
                        creditVoucherStatus = [false,"@RET2424",currencyCode,pAmountMST];
                        eventSource.EventWritePaymentsCreditMemoIsUsed(_dataEntryId);
                    }
                }
                else
                {
                    creditVoucherStatus = [false,"@RET2426",currencyCode,pAmountMST];
                    eventSource.EventWritePaymentsCreditMemoIsVoided(_dataEntryId);
                }
            }
            else
            {
                creditVoucherStatus = [false,"@RET2425",currencyCode,pAmountMST];
                eventSource.EventWritePaymentsCreditMemoDoesNotExist(_dataEntryId);
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
            {
                retry;
            }

            creditVoucherStatus = [false,"@RET2382",'', 0];
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsCreditMemoValidateUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsCreditMemoValidateRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsCreditMemoValidateUpdateConflictException();
            }

            creditVoucherStatus = [false,"@RET2382",'', 0];
        }
        catch
        {
            creditVoucherStatus = [false,"@RET2382",'', 0];
        }

        return creditVoucherStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used for validating the gift cards.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <param name="_skipReserveValidation">
    /// Skip gift card reserve validation sign.
    /// </param>
    /// <param name="_transactionId">
    /// ID of the RetailGiftCardTable.reservedByTransactionId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container validateGiftCard(RetailGiftCardId _dataEntryId, RetailChannelRecId  _channelId, RetailTerminalId _terminalId
                                             , boolean _skipReserveValidation = false
                                             , RetailTransactionId _transactionId = ''
                                             )
    {
        #OCCRetryCount

        RetailGiftCardTable tGiftCardTable;
        container           giftCardStatus = [false, '', '', 0]; // Status, ErrorMsg, CurrencyCode, Balance
        str                 giftCardCompany;
        str                 giftcardHoldCo;
        str                 channelName;
        container           conCompanies;
        Counter             pCounter;

        try
        {
            ttsbegin;

            // Locate the gift card across all companies.
            container companiesToAttemptToLocateTheRecordIn = [curExt(), RetailParameters::find().GiftCardCompany];
            tGiftCardTable = RetailGiftCardTable::findCrossCompany(_dataEntryId, companiesToAttemptToLocateTheRecordIn, true);

            if (!tGiftCardTable)
            {
                giftCardStatus = [false, "@RET2431"];
                eventSource.EventWritePaymentsCreditMemoValidateGiftCardDoesNotExist(_dataEntryId);
            }
            else
            {
                // Change the company to the gift card company.
                changecompany(tGiftCardTable.DataAreaId)
                {
                    // If the gift card is locked check if we can unlock it.
                    if (tGiftCardTable.reserved && !_skipReserveValidation)
                    {
                        tGiftCardTable.tryReleaseCardLock();
                    }

                    // If teh card is still locked, return an error.
                    if (tGiftCardTable.Reserved
                                // <GEERU>
                                && !_skipReserveValidation
                                // </GEERU>
                                )
                    {
                        if (tGiftCardTable.reservedByChannel)
                        {
                            channelName = OMOperatingUnit::find(RetailChannelTable::findByRecId(tGiftCardTable.reservedByChannel).OMOperatingUnitID, OMOperatingUnitType::RetailChannel).Name;
                            giftCardStatus = [false, strFmt("@RET2428", channelName, tGiftCardTable.ReservedByTerminalId)];
                            eventSource.EventWritePaymentsGiftCardIsInUse(_dataEntryId, channelName, tGiftCardTable.ReservedByTerminalId);
                        }
                        else
                        {
                            giftCardStatus = [false, "@Retail:RetailBlockedGiftCard"];
                            eventSource.EventWritePaymentsGiftCardIsBlocked(_dataEntryId);
                        }
                    }
                    else
                    {
                        tGiftCardTable.reserveCard(_terminalId, _channelId, _transactionId);
                        giftCardStatus = [true, '', tGiftCardTable.CurrencyCode, tGiftCardTable.balance()];
                        eventSource.EventWritePaymentsGiftCardIsValidated(_dataEntryId);
                    }
                }
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardValidationError(_dataEntryId);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsGiftCardValidateUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardValidateRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsGiftCardValidateUpdateConflictException();
            }

            giftCardStatus = [false, "@RET2429"];
        }
        catch
        {
            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardValidationError(_dataEntryId);
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCreditMemo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to check the status of the credit voucher i.e., voucher exists or voided or not voided.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidCreditMemo(RetailCreditVoucherId _dataEntryId)
    {
        #OCCRetryCount
        RetailCreditVoucherTable    tCreditVoucherTable;
        container                   creditVoucherStatus = [false,0];
        Counter                     pCounter;

        try
        {
            ttsbegin;
            tCreditVoucherTable = RetailCreditVoucherTable::find(_dataEntryId);

            if (tCreditVoucherTable)
            {
                if (!tCreditVoucherTable.Voided)
                {
                    if (RetailCreditVoucherTable::voidCreditVoucher(_dataEntryId))
                    {
                        creditVoucherStatus = [true,''];
                        eventSource.EventWritePaymentsCreditMemoStatusChanged();
                    }
                    else
                    {
                        creditVoucherStatus = [false,"@RET2427"];
                        eventSource.EventWritePaymentsCreditMemoStatusChangedError();
                    }
                }
                else
                {
                    creditVoucherStatus = [true,"@RET2426"];
                    eventSource.EventWritePaymentsCreditMemoStatusChanged();
                }
            }
            else
            {
                creditVoucherStatus = [false,"@RET2425"];
                eventSource.EventWritePaymentsCreditMemoStatusDoesNotExist();
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
            {
                retry;
            }

            creditVoucherStatus = [false,"@RET2382"];
            eventSource.EventWritePaymentsCreditMemoStatusChangedError();
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsCreditMemoVoidUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsCreditMemoVoidRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsCreditMemoVoidUpdateConflictException();
            }

            creditVoucherStatus = [false,"@RET2382"];
        }
        catch
        {
            creditVoucherStatus = [false,"@RET2382"];
            eventSource.EventWritePaymentsCreditMemoStatusChangedError();
        }

        return creditVoucherStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidCreditMemoPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the status of the credit voucher i.e., voucher is in use or the voucher has any errors or the voucher does not exists.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailCreditVoucherTable.entryId field.
    /// </param>
    /// <param name="_storeId">
    /// ID of the RetailCreditVoucherTable.reservedByStoreId field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailCreditVoucherTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// <c>Container</c>
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidCreditMemoPayment(RetailCreditVoucherId _dataEntryId, RetailStoreId _storeId, RetailTerminalId _terminalId)
    {
        #OCCRetryCount
        /*
        reservedByStoreId,
        entryTypeId,
        entryId,
        reservedByTerminalId

        str                 text01 = "Insufficient amount";
        str                 text02 = "CreditVoucher %1 is in use at Store : %2, Terminal : %3";
        str                 text03 = "The CreditVoucher has expired";    // Future addition
        str                 text04 = "CreditVoucher has been used";
        str                 text05 = "CreditVoucher does not exist";
    */
        RetailCreditVoucherTable   tCreditVoucherTable;
        AmountMST               pAmountMST = 0;
        container               creditVoucherStatus = [false,''];
        Counter                 pCounter;

        try
        {
            ttsbegin;
            tCreditVoucherTable = RetailCreditVoucherTable::find(_dataEntryId, true);

            if (tCreditVoucherTable)
            {
                if (!tCreditVoucherTable.Applied)
                {
                    if (tCreditVoucherTable.Reserved && tCreditVoucherTable.ReservedByStoreId == _storeId && tCreditVoucherTable.ReservedByTerminalId == _terminalId)
                    {
                        if (RetailCreditVoucherTable::voidPayementRBOCreditVoucherTable(_dataEntryId))
                        {
                            creditVoucherStatus = [true,''];
                            eventSource.EventWritePaymentsCreditMemoStatusChangedDuringVoidPayment();
                        }
                        else
                        {
                            creditVoucherStatus = [false,"@RET2382"];
                            eventSource.EventWritePaymentsCreditMemoStatusChangedErrorDuringVoidPayment();
                        }
                    }
                    else
                    {
                        creditVoucherStatus = [true,''];
                        eventSource.EventWritePaymentsCreditMemoStatusChangedDuringVoidPayment();
                    }
                }
                else
                {
                    creditVoucherStatus = [false,"@RET2424"];
                    eventSource.EventWritePaymentsCreditMemoIsInUseDuringVoidPayment();
                }
            }
            else
            {
                creditVoucherStatus = [false,"@RET2425"];
                eventSource.EventWritePaymentsCreditMemoDoesNotExistVoidPayment();
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
            {
                retry;
            }

            creditVoucherStatus = [false,"@RET2382"];
            eventSource.EventWritePaymentsCreditMemoVoidPaymentError();
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsCreditMemoVoidPaymentUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsCreditMemoVoidPaymentRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsCreditMemoVoidPaymentUpdateConflictException();
            }

            creditVoucherStatus = [false,"@RET2382"];
        }
        catch
        {
            creditVoucherStatus = [false,"@RET2382"];
            eventSource.EventWritePaymentsCreditMemoVoidPaymentError();
        }

        return creditVoucherStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method is used to check the status of the gift card i.e., card exists or voided or not voided.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidGiftCard(RetailGiftCardId _dataEntryId)
    {
        #OCCRetryCount
        RetailGiftCardTable    tGiftCardTable;
        container           giftCardStatus = [false, '']; // Status, ErrorMsg
        Counter             pCounter;
        str giftCardCompany;
        container conCompanies;
        str giftCardBalCo;

        try
        {
            ttsbegin;
            tGiftCardTable = RetailGiftCardTable::find(_dataEntryId, true);

            if (tGiftCardTable)
            {
                if (tGiftCardTable.voidCard())
                {
                    giftCardStatus = [true, ''];
                    eventSource.EventWritePaymentsGiftCardIsVoided(_dataEntryId);
                }
                else
                {
                    giftCardStatus = [false,"@RET2432"];
                    eventSource.EventWritePaymentsGiftCardCannotBeVoided(_dataEntryId);
                }
            }
            else
            {
                giftCardCompany = RetailParameters::find().GiftCardCompany;
                if (giftCardCompany != curext())
                {
                    conCompanies = [giftCardCompany];
                    tGiftCardTable = RetailGiftCardTable::findCrossCompany(_dataEntryId, conCompanies, true);
                    giftCardBalCo = conPeek(conCompanies, 1);
                    if (tGiftCardTable)
                    {
                        changeCompany(giftCardBalCo)
                        {
                            if (tGiftCardTable.voidCard())
                            {
                                giftCardStatus = [true, ''];
                                eventSource.EventWritePaymentsGiftCardIsVoided(_dataEntryId);
                            }
                            else
                            {
                                giftCardStatus = [false,"@RET2432"];
                                eventSource.EventWritePaymentsGiftCardCannotBeVoided(_dataEntryId);
                            }
                        }
                    }
                    else
                    {
                        giftCardStatus = [false,"@RET2431"];
                        eventSource.EventWritePaymentsGiftCardDoesNotExistDuringVoid(_dataEntryId);
                    }
                }
                else
                {
                    giftCardStatus = [false,"@RET2431"];
                    eventSource.EventWritePaymentsGiftCardDoesNotExistDuringVoid(_dataEntryId);
                }
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            pCounter++;
            if (pCounter <= 10)
                retry;

            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardVoidError(_dataEntryId);
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    eventSource.EventWritePaymentsGiftCardVoidUpdateConflictNotRecoveredError();
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardVoidRetry(#RetryNum);
                    retry;
                }
            }
            else
            {
                eventSource.EventWritePaymentsGiftCardVoidUpdateConflictException();
            }

            giftCardStatus = [false, "@RET2429"];
        }
        catch
        {
            giftCardStatus = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardVoidError(_dataEntryId);
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method checks for the status of the gift card i.e., card exists or the gift card has any errors.
    /// </summary>
    /// <param name="_dataEntryId">
    /// ID of the RetailGiftCardTable.entryId field.
    /// </param>
    /// <param name="_channelId">
    /// ID of the RetailGiftCardTable.channel field.
    /// </param>
    /// <param name="_terminalId">
    /// ID of the RetailGiftCardTable.reservedByTerminalId field.
    /// </param>
    /// <returns>
    /// The status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidGiftCardPayment(RetailGiftCardId _dataEntryId, RetailChannelRecId _channelId, RetailTerminalId _terminalId)
    {
        #OCCRetryCount

        container           giftCardStatus = [false, '']; // Status, ErrorMsg
        Counter             counter;
        const int deadlockMaxRetry = 10;

        // Work around broken chain of command.
        // We need to ensure obsolete method still being called from all previouse locations
        // to mimic original behavior.
        if (RetailTransactionServiceTransactionsParameters::isChainOfCommandCallback)
        {
            RetailTransactionServiceTransactionsParameters::isChainOfCommandCallback = false;
            giftCardStatus = [true, ''];
        }
        else
        {
            try
            {
                RetailGiftCardTable giftCardTable;

                ttsbegin;
                giftCardTable = RetailGiftCardTable::find(_dataEntryId, true);

                if (giftCardTable)
                {
                    if (giftCardTable.Reserved && giftCardTable.reservedByChannel == _channelId && giftCardTable.ReservedByTerminalId == _terminalId)
                    {
                        giftCardTable.unlockCard();
                        giftCardStatus = [true, ''];
                    }
                    else
                    {
                        giftCardStatus = [true, ''];
                    }

                    eventSource.EventWritePaymentsGiftCardPaymentVoidSuccessful(_dataEntryId);
                }
                else
                {
                    giftCardStatus = [false,"@RET2431"];
                    eventSource.EventWritePaymentsGiftCardPaymentVoidCardDoesNotExist(_dataEntryId);
                }

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                counter++;
                if (counter <= deadlockMaxRetry)
                {
                    retry;
                }

                giftCardStatus = [false,"@RET2429"];
                eventSource.EventWritePaymentsGiftCardPaymentVoidError(_dataEntryId);
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        eventSource.EventWritePaymentsGiftCardVoidPaymentUpdateConflictNotRecoveredError();
                    }
                    else
                    {
                        eventSource.EventWritePaymentsGiftCardVoidPaymentRetry(#RetryNum);
                        retry;
                    }
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardVoidPaymentUpdateConflictException();
                }

                giftCardStatus = [false,"@RET2429"];
            }
            catch
            {
                giftCardStatus = [false,"@RET2429"];
                eventSource.EventWritePaymentsGiftCardPaymentVoidError(_dataEntryId);
            }
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>voidOrRefundGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refunds the amount passed-in to the giftcard associated with the passed-in _cardNumber.
    /// </summary>
    /// <param name="_cardNumber">
    /// The gift card number associated with this particular transaction.
    /// </param>
    /// <param name="_channelId">
    /// The channel identifier associated with this transaction (e.g., 5637144592).
    /// </param>
    /// <param name="_terminalId">
    /// The terminal identifier associated with this transaction (e.g., HOUSTON-1).
    /// </param>
    /// <param name="_transactionId">
    /// The transaction identifier associated with this transaction (e.g., HOUSTON-HOUSTON-1-22).
    /// </param>
    /// <param name="_amountMST">
    /// The amount that will be refunded to the card number.
    /// </param>
    /// <param name="_staffId">
    /// The user or staff identifier associated with this transaction (e.g., 000160).
    /// </param>
    /// <param name="_receiptId">
    /// The receipt identifier associated with this transaction (e.g., STONON-1300004).
    /// </param>
    /// <param name="_transDate">
    /// The transaction date when this current transaction is taking place.
    /// </param>
    /// <param name="_transTime">
    /// The transaction time when this current transaction is taking place.
    /// </param>
    /// <param name="_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// The gift card status as a container.
    /// </returns>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// A conflict occurred that could not be recovered from when updating.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    /// An update conflict occurred.
    /// </exception>
    public static container voidOrRefundGiftCardPayment(RetailGiftCardId _cardNumber,
                                                        RetailChannelRecId _channelId,
                                                        RetailTerminalId _terminalId,
                                                        RetailTransactionId _transactionId,
                                                        AmountMST _amountMST,
                                                        RetailStaffId _staffId,
                                                        RetailReceiptId _receiptId,
                                                        str _transDate,
                                                        str _transTime,
                                                        int _dateSequence)
    {
        #OCCRetryCount

        container giftCardStatus = [false, '']; // Status, ErrorMsg
        Counter counter = 0;
        const int deadlockMaxRetry = 3;

        // Keep chain of command callback intact.
        // If the old method returns a false value, simply return that skipping over the new method's logic.
        RetailTransactionServiceTransactionsParameters::isChainOfCommandCallback = true;
        giftCardStatus = RetailTransactionServiceTransactions::voidGiftCardPayment(_cardNumber, _channelId, _terminalId);
        
        // Look at the first index, which represents whether the operation was successful.
        // This is to handle CoC extensibility where the return value can change after the old method was called.
        boolean isSuccess = conpeek(giftCardStatus, 1);
        if (isSuccess)
        {
            try
            {
                ttsbegin;
                RetailGiftCardTable giftCardTable;

                // Locate the gift card across all companies.
                container companiesToAttemptToLocateTheRecordIn = [curExt(), RetailParameters::find().GiftCardCompany];
                giftCardTable = RetailGiftCardTable::findCrossCompany(_cardNumber, companiesToAttemptToLocateTheRecordIn, true);

                // Return an error if we are unable to locate the gift card record.
                if (!giftCardTable)
                {
                    giftCardStatus = [false, "@RET2431"];
                    eventSource.EventWritePaymentsGiftCardPaymentVoidRefundCardDoesNotExist(_cardNumber);
                }
                else
                {
                    // Change the company to the gift card company.
                    changecompany(giftCardTable.DataAreaId)
                    {
                        // Check if the gift card is reserved.
                        if (giftCardTable.reserved)
                        {
                            // Check if the gift card has been reserved by this transaction.
                            if (giftCardTable.reservedByChannel == _channelId && giftCardTable.reservedByTerminalId == _terminalId && giftCardTable.ReservedByTransactionId == _transactionId)
                            {
                                // The gift card is locked by the current transaction. Proceed to unlock the gift card.
                                giftCardTable.unlockCard();
                                giftCardStatus = [true, ''];

                                eventSource.EventWritePaymentsGiftCardPaymentVoidRefundSuccessful(giftCardTable.RecId);
                            }
                            else
                            {
                                // Return a failure message stating the gift card is locked by some other transaction.
                                str channelName = OMOperatingUnit::find(RetailChannelTable::findByRecId(giftCardTable.reservedByChannel).OMOperatingUnitID, OMOperatingUnitType::RetailChannel).Name;
                                giftCardStatus = [false, strFmt("@RET2428", channelName, giftCardTable.ReservedByTerminalId)];

                                eventSource.EventWritePaymentsGiftCardPaymentVoidRefundCardIsInUse(giftCardTable.RecId);
                            }
                        }
                        else
                        {
                            // The gift card is not reserved. Check if we should be refunding the payment for this transaction.
                            giftCardStatus = RetailTransactionServiceTransactions::refundGiftCardPayment(_cardNumber,
                                    _channelId,
                                    _terminalId,
                                    _staffId,
                                    _transactionId,
                                    _receiptId,
                                    _amountMST,
                                    _transDate,
                                    _transTime,
                                    _dateSequence);
                        }
                    }
                }

                ttscommit;
            }
            catch (Exception::Deadlock)
            {
                counter++;
                if (counter <= deadlockMaxRetry)
                {
                    retry;
                }

                giftCardStatus = [false,"@RET2429"];
                eventSource.EventWritePaymentsGiftCardPaymentVoidRefundError(_cardNumber);
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        eventSource.EventWritePaymentsGiftCardVoidRefundPaymentUpdateConflictNotRecoveredError();
                    }
                    else
                    {
                        eventSource.EventWritePaymentsGiftCardVoidRefundPaymentRetry(#RetryNum);
                        retry;
                    }
                }
                else
                {
                    eventSource.EventWritePaymentsGiftCardVoidRefundPaymentUpdateConflictException();
                }

                giftCardStatus = [false,"@RET2429"];
            }
            catch
            {
                giftCardStatus = [false,"@RET2429"];
                eventSource.EventWritePaymentsGiftCardPaymentVoidRefundError(_cardNumber);
            }
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refundGiftCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refund a gift card payment.
    /// </summary>
    /// <param name = "_cardNumber">
    /// The gift card number associated with this particular transaction.
    /// </param>
    /// <param name = "_channelId">
    /// The channel identifier associated with this transaction (e.g., 5637144592).
    /// </param>
    /// <param name = "_terminalId">
    /// The terminal identifier associated with this transaction (e.g., HOUSTON-1).
    /// </param>
    /// <param name = "_staffId">
    /// The user or staff identifier associated with this transaction (e.g., 000160).
    /// </param>
    /// <param name = "_transactionId">
    /// The transaction identifier associated with this transaction (e.g., HOUSTON-HOUSTON-1-22).
    /// </param>
    /// <param name = "_receiptId">
    /// The receipt identifier associated with this transaction (e.g., STONON-1300004).
    /// </param>
    /// <param name = "_amountMST">
    /// The amount that will be refunded to the card number.
    /// </param>
    /// <param name = "_transDate">
    /// The transaction date when this current transaction is taking place.
    /// </param>
    /// <param name = "_transTime">
    /// The transaction time when this current transaction is taking place.
    /// </param>
    /// <param name = "_dateSequence">
    /// Format of the date.
    /// </param>
    /// <returns>
    /// The gift card status as a container.
    /// </returns>
    private static container refundGiftCardPayment(RetailGiftCardId _cardNumber,
                                                    RetailChannelRecId _channelId,
                                                    RetailTerminalId _terminalId,
                                                    RetailStaffId _staffId,
                                                    RetailTransactionId _transactionId,
                                                    RetailReceiptId _receiptId,
                                                    AmountMST _amountMST,
                                                    str _transDate,
                                                    str _transTime,
                                                    int _dateSequence)
    {
        container giftCardStatus = [false, '']; // Status, ErrorMsg

        RetailGiftCardOperation operationTypeToLookup = _amountMST < 0 ? RetailGiftCardOperation::Refund: RetailGiftCardOperation::Redeem;
        boolean _doesGiftCardPaymentTxnExist = RetailGiftCardTransactions::findTransaction(operationTypeToLookup, _cardNumber, _transactionId, -1 * _amountMST);

        if (_doesGiftCardPaymentTxnExist)
        {
            // We need to add a transaction to revert the captured payment transaction log.
            // This API needs to be idempotent to ensure we don't add extra amounts to the card.
            // To this end, check if the transaction to be added.
            RetailGiftCardOperation operationTypeToAdd = operationTypeToLookup == RetailGiftCardOperation::Redeem ? RetailGiftCardOperation::Refund: RetailGiftCardOperation::Redeem;
            boolean _doesGiftCardPaymentReversalTxnExist = RetailGiftCardTransactions::findTransaction(operationTypeToAdd, _cardNumber, _transactionId, _amountMST);

            if (!_doesGiftCardPaymentReversalTxnExist)
            {
                RetailGiftCardTransactions::add(operationTypeToAdd,
                                    _cardNumber,
                                    _channelId,
                                    _terminalId,
                                    _staffId,
                                    _transactionId,
                                    _receiptId,
                                    _amountMST,
                                    str2Date(_transDate,_dateSequence),
                                    str2time(_transTime));

                giftCardStatus = [true, ''];
                eventSource.EventWritePaymentsGiftCardRefundSuccessful(_cardNumber);
            }
            else
            {
                // This API has been called more than once. Nothing to do.
                giftCardStatus = [true, ''];
                eventSource.EventWritePaymentsGiftCardRefundRecordExists(_cardNumber);
            }
        }
        else
        {
            // No transaction record exists that need to be reverted. Nothing to do.
            giftCardStatus = [true, ''];
        }

        return giftCardStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustAccountDepositTransactionSubtotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the subtotal amount for a customer account deposit transaction.
    /// </summary>
    /// <param name="_transactionId">
    /// The identifier of the transaction.
    /// </param>
    /// <param name="_dataAreaId">
    /// The identifier of the data area.
    /// </param>
    /// <param name="_channelId">
    /// The identifier of the channel.
    /// </param>
    /// <param name="_terminalId">
    /// The identifier of the terminal.
    /// </param>
    /// <param name="_storeId">
    /// The identifier of the store.
    /// </param>
    /// <returns>
    /// The subtotal amount for a customer account deposit transaction.
    /// </returns>
    private static AmountCur getCustAccountDepositTransactionSubtotalAmount(DataAreaId          _dataAreaId,
                                                                            RetailChannelRecId   _channelId,
                                                                            RetailStoreId         _storeId,
                                                                            RetailTerminalId    _terminalId,
                                                                            RetailTransactionId _transactionId)
    {
        RetailTransactionCustomerAccountDepositTrans custAccountDepositTrans;
        AmountCur                   subtotalAmount = 0.0;

        if (_transactionId && _dataAreaId && _channelId)
        {
            select sum(amount)
                from custAccountDepositTrans
                where custAccountDepositTrans.DataAreaId == _dataAreaId
                    && custAccountDepositTrans.Channel == _channelId
                    && custAccountDepositTrans.Store == _storeId
                    && custAccountDepositTrans.Terminal == _terminalId
                    && custAccountDepositTrans.TransactionId == _transactionId;

            subtotalAmount = custAccountDepositTrans.amount;
        }

        return subtotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionSubtotalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the subtotal amount for a sales transaction.
    /// </summary>
    /// <param name="_transactionId">
    /// The identifier of the transaction.
    /// </param>
    /// <param name="_dataAreaId">
    /// The identifier of the data area.
    /// </param>
    /// <param name="_channelId">
    /// The identifier of the channel.
    /// </param>
    /// <param name="_terminalId">
    /// The identifier of the terminal.
    /// </param>
    /// <returns>
    /// The subtotal amount for a sales transaction.
    /// </returns>
    public static AmountCur getTransactionSubtotalAmount(RetailTransactionId _transactionId,
                                                     DataAreaId          _dataAreaId,
                                                     RetailChannelRecId  _channelId,
                                                     RetailTerminalId    _terminalId)
    {
        RetailTransactionSalesTrans salesTrans;
        AmountCur                   subtotalAmount = 0.0;

        if (_transactionId && _dataAreaId && _channelId)
        {
            select sum(netAmount), sum(netAmountInclTax)
                from salesTrans
                where salesTrans.TransactionId == _transactionId
                    && salesTrans.DataAreaId == _dataAreaId
                    && salesTrans.Channel == _channelId
                    && (salesTrans.Terminalid == _terminalId || _terminalId == '')
                    && salesTrans.TransactionStatus != RetailEntryStatus::Voided;    // Exclude the voided line

            if (RetailFeatureControl::isFeatureFlightKeySet(IsLegacyPriceIncludesTaxNetAmountWithoutTaxCalculationEnabled, funcName(), false))
            {
                subtotalAmount = salesTrans.netAmountInclTax;
            }
            else
            {
                subtotalAmount = salesTrans.netAmount;
            }
        }

        return subtotalAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardPolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the gift card policies.
    /// </summary>
    /// <param name="_cardNumber">
    /// The gift card number.
    /// </param>
    /// <returns>
    /// The gift card policies.
    /// </returns>
    public static container getGiftCardPolicies(RetailGiftCardId _cardNumber)
    {
        RetailGiftCardTable giftCard;
        DataAreaId          giftCardCompany;
        container           res = [false, ''];

        try
        {
            giftcardCompany = RetailGiftCardPostingParameters::getGiftCardCompany();

            if (!giftcardCompany)
            {
                giftcardCompany = curext();
            }

            if (!xDataArea::exist(giftcardCompany))
            {
                throw error(strFmt("@SYS10666", giftCardCompany));
            }

            changeCompany(giftcardCompany)
            {
                giftCard = RetailGiftCardTable::find(_cardNumber);

                if (giftCard)
                {
                    res = [
                        true,
                        '',
                        giftCard.Status,
                        giftCard.ActiveFrom,
                        giftCard.ExpiryDate,
                        giftCard.OneTimeRedemption,
                        giftCard.NonReloadable,
                        giftCard.MinReloadMST,
                        giftCard.MaxBalanceMST,
                        Ledger::accountingCurrency()];

                    ApplicationEventSource::EventWriteRetailTransactionServiceInfoLog(funcName(), 'Returning the gift card policies');
                    eventSource.EventWritePaymentsGiftCardPoliciesReturnSuccessful(giftCard.RecId);
                }
                else
                {
                    res = [false, "@RET2431"];
                    eventSource.EventWritePaymentsGiftCardPoliciesNotFound(_cardNumber);
                }
            }
        }
        catch
        {
            res = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardPoliciesReturnError(_cardNumber);
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGiftCardPolicySet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the gift card policy set and face value.
    /// </summary>
    /// <param name="_cardNumber">
    /// The gift card number.
    /// </param>
    /// <returns>
    /// The gift card policy set and face value from gift card number range.
    /// </returns>
    public static container getGiftCardPolicySet(RetailGiftCardId _cardNumber)
    {
        RetailGiftCardPolicySet policySet;
        DataAreaId              giftCardCompany;
        container               res = [false, ''];

        try
        {
            giftcardCompany = RetailGiftCardPostingParameters::getGiftCardCompany();

            if (!giftcardCompany)
            {
                giftcardCompany = curext();
            }

            if (!xDataArea::exist(giftcardCompany))
            {
                throw error(strFmt("@SYS10666", giftCardCompany));
            }

            changeCompany(giftcardCompany)
            {
                policySet = RetailGiftCardPolicySet::findOrCreateDefaultByGiftCardNumber(_cardNumber);

                res = [
                    true,
                    '',
                    policySet.FaceValue,
                    policySet.ActivationPeriod,
                    policySet.ValidityPeriod,
                    policySet.FixedExpiryDate,
                    policySet.OneTimeRedemption,
                    policySet.NonReloadable,
                    policySet.MinReloadMST,
                    policySet.MaxBalanceMST,
                    Ledger::accountingCurrency()];

                ApplicationEventSource::EventWriteRetailTransactionServiceInfoLog(funcName(), 'Returning the gift card policy set');
                eventSource.EventWritePaymentsGiftCardPoliciesSetReturnSuccessful(_cardNumber);
            }
        }
        catch
        {
            res = [false, "@RET2429"];
            eventSource.EventWritePaymentsGiftCardPoliciesSetReturnError(_cardNumber);
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalListQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the journal query for a given/local channel
    /// </summary>
    /// <param name="_localChannelId">
    /// The ID of the 'local' channel.
    /// </param>
    /// <param name="_startDateTime">
    /// Start date-time for the range of journals.
    /// </param>
    /// <param name="_endDateTime">
    /// End date-time for the range of journals.
    /// </param>
    /// <returns>
    /// Query with default filters based on the local channel and date ranges.
    /// </returns>
    /// <remarks>
    /// Non-sale transactions are excluded from channels other than the specified 'local' channel.
    /// </remarks>
    [Wrappable(true)]
    protected final static Query getJournalListQuery(
        RecId _localChannelId,
        utcDateTime _startDateTime = DateTimeUtil::minValue(),
        utcDateTime _endDateTime = DateTimeUtil::maxValue())
    {
        Query query = new Query();

        if (RetailSplitGetJournalQueryFlight::instance().isEnabled())
        {
            query.queryType(QueryType::Union);

            RetailTransactionServiceTransactions::getJournalListQuery_ForCurrentChannel(query, _localChannelId, _startDateTime, _endDateTime);
            RetailTransactionServiceTransactions::getJournalListQuery_ForOtherChannels(query, _localChannelId, _startDateTime, _endDateTime);
        }
        else
        {
            QueryBuildDataSource qbds;
            str rangeString;
            TransDate startDate = DateTimeUtil::date(_startDateTime);
            RetailTransTime startTime = DateTimeUtil::time(_startDateTime);
            TransDate endDate = DateTimeUtil::date(_endDateTime);
            RetailTransTime endTime = DateTimeUtil::time(_endDateTime);
            str rangeDate, rangeTime;

            qbds = query.addDataSource(tableNum(RetailTransactionTable));
        
            // For performance reasons, we only want RecId
            qbds.fields().clearFieldList();
            qbds.fields().addField(fieldNum(RetailTransactionTable, RecId));

            // RetailTransactionTable ranges
            // Transactions within the date range: "transactionTable.TransDate >= startDate && transactionTable.TransDate <= endDate"
            qbds.addRange(fieldNum(RetailTransactionTable, TransDate)).value(SysQuery::range(startDate, endDate));

            if (startDate)
            {
                // or on StartDate and TransTime >= StartTime
                rangeString = strFmt('((%1 == %3) && (%2 >= %4))',
                fieldStr(RetailTransactionTable, transDate),
                fieldStr(RetailTransactionTable, transTime),
                date2Str(startDate, 321, DateDay::Digits2, DateSeparator::Hyphen, DateMonth::Digits2, DateSeparator::Hyphen, DateYear::Digits4),
                SysQuery::value(startTime));
                qbds.addRange(fieldNum(RetailTransactionTable, TransDate)).value(rangeString);
            }

            if (_endDateTime != DateTimeUtil::maxValue())
            {
                // or on EndDate and TransTime <= EndTime
                rangeString = strFmt('((%1 == %3) && (%2 <= %4))',
                fieldStr(RetailTransactionTable, transDate),
                fieldStr(RetailTransactionTable, transTime),
                date2Str(endDate, 321, DateDay::Digits2, DateSeparator::Hyphen, DateMonth::Digits2, DateSeparator::Hyphen, DateYear::Digits4),
                SysQuery::value(endTime));
                qbds.addRange(fieldNum(RetailTransactionTable, TransDate)).value(rangeString);
            }

            // All transaction types that can print a receipt for the current channel, but only "sale" types for other channels:
            // "((transaction.Channel <> _currentChannel) && (type == Sale || type == CustomerOrder || type == SalesOrder)) ||
            // ((transaction.Channel == _currentChannel) && (type == Sale || type == CustomerOrder || type == SalesOrder || type == Payment || type == TenderDeclaration || type == SalesInvoice || type == BankDrop || type == SafeDrop || type == IncomeExpense))"
            rangeString = strFmt('(((%1 != %2) && (((%3 == %4) || (%3 == %5)) || (%3 == %6))) || ((%1 == %2) && ((((((((((%3 == %4) || (%3 == %5))|| (%3 == %6))|| (%3 == %7))|| (%3 == %8))|| (%3 == %9))|| (%3 == %10))||(%3 == %11)) || (%3 == %12))||(%3 == %13))))',
                fieldStr(RetailTransactionTable, Channel),
                int642str(_localChannelId),
                fieldStr(RetailTransactionTable, Type),
                any2int(RetailTransactionType::Sales),
                any2int(RetailTransactionType::CustomerOrder),
                any2int(RetailTransactionType::AsyncCustomerOrder),
                any2int(RetailTransactionType::SalesOrder),
                any2Int(RetailTransactionType::Payment),
                any2Int(RetailTransactionType::TenderDeclaration),
                any2Int(RetailTransactionType::SalesInvoice),
                any2Int(RetailTransactionType::BankDrop),
                any2Int(RetailTransactionType::SafeDrop),
                any2Int(RetailTransactionType::IncomeExpense));
            qbds.addRange(fieldNum(RetailTransactionTable, DataAreaId)).value(rangeString);
        
            // Order results by descending createddatetime for pagination.
            qbds.addSortField(fieldNum(RetailTransactionTable, CreatedDateTime), SortOrder::Descending);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalListQuery_ForCurrentChannel</Name>
				<Source><![CDATA[
    private static void getJournalListQuery_ForCurrentChannel(
        Query _query,
        RecId _localChannelId,
        utcDateTime _startDateTime = DateTimeUtil::minValue(),
        utcDateTime _endDateTime = DateTimeUtil::maxValue())
    {
        str rangeString;
        QueryBuildDataSource qbds = RetailTransactionServiceTransactions::getJournalListQuery_CommonLogic(_query, _localChannelId, _startDateTime, _endDateTime);

        // All transaction types that can print a receipt for the current channel, but only "sale" types for other channels:
        // ((transaction.Channel == _currentChannel) && (type == Sale || type == CustomerOrder || type == SalesOrder || type == Payment || type == TenderDeclaration || type == SalesInvoice || type == BankDrop || type == SafeDrop || type == IncomeExpense))"
        rangeString = strFmt('((%1 == %2) && ((((((((((%3 == %4) || (%3 == %5))|| (%3 == %6))|| (%3 == %7))|| (%3 == %8))|| (%3 == %9))|| (%3 == %10))||(%3 == %11)) || (%3 == %12))||(%3 == %13)))',
                fieldStr(RetailTransactionTable, Channel),
                int642str(_localChannelId),
                fieldStr(RetailTransactionTable, Type),
                any2int(RetailTransactionType::Sales),
                any2int(RetailTransactionType::CustomerOrder),
                any2int(RetailTransactionType::AsyncCustomerOrder),
                any2int(RetailTransactionType::SalesOrder),
                any2Int(RetailTransactionType::Payment),
                any2Int(RetailTransactionType::TenderDeclaration),
                any2Int(RetailTransactionType::SalesInvoice),
                any2Int(RetailTransactionType::BankDrop),
                any2Int(RetailTransactionType::SafeDrop),
                any2Int(RetailTransactionType::IncomeExpense));
        qbds.addRange(fieldNum(RetailTransactionTable, DataAreaId)).value(rangeString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalListQuery_ForOtherChannels</Name>
				<Source><![CDATA[
    private static void getJournalListQuery_ForOtherChannels(
        Query _query,
        RecId _localChannelId,
        utcDateTime _startDateTime = DateTimeUtil::minValue(),
        utcDateTime _endDateTime = DateTimeUtil::maxValue())
    {
        str rangeString;
        QueryBuildDataSource qbds = RetailTransactionServiceTransactions::getJournalListQuery_CommonLogic(_query, _localChannelId, _startDateTime, _endDateTime);

        // All transaction types that can print a receipt for the current channel, but only "sale" types for other channels:
        // "((transaction.Channel <> _currentChannel) && (type == Sale || type == CustomerOrder || type == SalesOrder))
        rangeString = strFmt('((%1 != %2) && (((%3 == %4) || (%3 == %5)) || (%3 == %6)))',
                fieldStr(RetailTransactionTable, Channel),
                int642str(_localChannelId),
                fieldStr(RetailTransactionTable, Type),
                any2int(RetailTransactionType::Sales),
                any2int(RetailTransactionType::CustomerOrder),
                any2int(RetailTransactionType::AsyncCustomerOrder));
        qbds.addRange(fieldNum(RetailTransactionTable, DataAreaId)).value(rangeString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalListQuery_CommonLogic</Name>
				<Source><![CDATA[
    private static QueryBuildDataSource getJournalListQuery_CommonLogic(
        Query _query,
        RecId _localChannelId,
        utcDateTime _startDateTime = DateTimeUtil::minValue(),
        utcDateTime _endDateTime = DateTimeUtil::maxValue())
    {
        QueryBuildDataSource qbds;
        str rangeString;
        TransDate startDate = DateTimeUtil::date(_startDateTime);
        RetailTransTime startTime = DateTimeUtil::time(_startDateTime);
        TransDate endDate = DateTimeUtil::date(_endDateTime);
        RetailTransTime endTime = DateTimeUtil::time(_endDateTime);
        str rangeDate, rangeTime;

        // Get the query
        qbds = _query.addDataSource(tableNum(RetailTransactionTable));
        qbds.unionType(UnionType::Union);
        
        // For performance reasons, we only want RecId and CreatedDateTime for sorting
        qbds.fields().clearFieldList();
        qbds.fields().addField(fieldNum(RetailTransactionTable, RecId));

        // RetailTransactionTable ranges
        // Transactions within the date range: "transactionTable.TransDate >= startDate && transactionTable.TransDate <= endDate"
        qbds.addRange(fieldNum(RetailTransactionTable, TransDate)).value(SysQuery::range(startDate, endDate));

        // make sure to have this logic only if start time specified
        if (_startDateTime != DateTimeUtil::minValue() && startTime)
        {
            // or on StartDate and TransTime >= StartTime
            rangeString = strFmt('((%1 == %3) && (%2 >= %4))',
                fieldStr(RetailTransactionTable, transDate),
                fieldStr(RetailTransactionTable, transTime),
                date2Str(startDate, 321, DateDay::Digits2, DateSeparator::Hyphen, DateMonth::Digits2, DateSeparator::Hyphen, DateYear::Digits4),
                SysQuery::value(startTime));
            qbds.addRange(fieldNum(RetailTransactionTable, TransDate)).value(rangeString);
        }

        // make sure to have this logic only if end time specified
        if (_endDateTime != DateTimeUtil::maxValue() && endTime)
        {
            // or on EndDate and TransTime <= EndTime
            rangeString = strFmt('((%1 == %3) && (%2 <= %4))',
                fieldStr(RetailTransactionTable, transDate),
                fieldStr(RetailTransactionTable, transTime),
                date2Str(endDate, 321, DateDay::Digits2, DateSeparator::Hyphen, DateMonth::Digits2, DateSeparator::Hyphen, DateYear::Digits4),
                SysQuery::value(endTime));
            qbds.addRange(fieldNum(RetailTransactionTable, TransDate)).value(rangeString);
        }

        return qbds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalListSearch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns a list of retail transactions that match the passed in criteria.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML arguments.
    /// </param>
    /// <returns>
    /// A list of orders that match all of the criteria parameters.
    /// </returns>
    /// <remarks>
    /// Xml argument example:
    /// <Arguments>
    ///  <CurrentChannelId/>
    ///  <TransactionIds/>
    ///  <ReceiptId/>
    ///  <ChannelReferenceId/>
    ///  <CustomerAccountNumber/>
    ///  <CustomerFirstName/>
    ///  <CustomerLastName/>
    ///  <StoreId/>
    ///  <TerminalId/>
    ///  <ItemId/>
    ///  <Barcode/>
    ///  <StaffId/>
    ///  <StartDateTime/>
    ///  <EndDateTime/>
    ///  <ReceiptEmailAddress/>
    ///  <SerialNumber/>
    ///  <IncludeDetails/>
    ///  <PagingInfo>
    ///    <Skip/>
    ///    <Top/>
    ///  </PagingInfo>
    ///</Arguments>
    /// </remarks>
    public static container getJournalListSearch(str _xmlArgumentString)
    {
        XmlDocument         argsXml;
        XmlElement          argsRoot;

        // Get the string value of an XML element argument.
        str getArg(str argName)
        {
            XmlElement xmlRoot = argsRoot.getNamedElement(argName);
            if (xmlRoot != null)
            {
                return xmlRoot.text();
            }
            return '';
        }

        if (RetailSplitGetJournalQueryFlight::instance().isEnabled())
        {
            RecId argCurrentChannelId;
            str argStartDate;
            str argEndDate;
            boolean argIncludeDetails = false;

            int resultsStartingPosition = 1;
            int resultsMaxCount = #resultsCountOfTransaction;
            DirPartyTable   partyTable;
            int             resultsCount;

            container           output = [true,''];
            utcDateTime         startDateTime = DateTimeUtil::minValue();
            utcDateTime         endDateTime = DateTimeUtil::maxValue();
            CustName            custName = '';

            Query   retailJournalListQuery;
            QueryRun qr;

            //
            // Main method body
            //

            // Parse the arguments
            argsXml   = new XmlDocument();
            argsXml.loadXml(_xmlArgumentString);
            argsRoot = argsXml.documentElement();

            argcurrentChannelId = str2int64(getArg('CurrentChannelId'));
            argstartDate = getArg('StartDateTime');
            argendDate = getArg('EndDateTime');
            argIncludeDetails = false; // Never include details for list APIs ('true' == getArg('IncludeDetails'));

            // Get paging details
            [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

            // Process the arguments
            if (argStartDate)
            {
                startDateTime =  DateTimeUtil::parse(argStartDate);
            }

            if (argendDate)
            {
                endDateTime = DateTimeUtil::parse(argEndDate);
            }

            // prepare list helper
            str argFormat = getArg('SerializationFormat');
            RetailTransactionResultListHelper listHelper = new RetailTransactionResultListHelper(
            (argFormat == int2Str(enum2int(RetailTransactionServiceResultFormat::Json))) // RetailTransactionServiceResultFormat::Json = '1'
            ? RetailTransactionServiceResultFormat::Json
            : RetailTransactionServiceResultFormat::Xml);

            // Get the basic query
            retailJournalListQuery = RetailTransactionServiceTransactions::getJournalListQuery(argCurrentChannelId, startDateTime, endDateTime);

            retailJournalListQuery = RetailTransactionServiceTransactions::finalizeJournalQuery(retailJournalListQuery, argsRoot, 1);
            retailJournalListQuery = RetailTransactionServiceTransactions::finalizeJournalQuery(retailJournalListQuery, argsRoot, 2);
        
            Query paginatedQuery = RetailTransactionServiceTransactions::convertUnionJournalQueryToPaginatedQuery(retailJournalListQuery);

            // Run the query to get the recids of the records in result set.
            qr = new QueryRun(paginatedQuery);
            qr.enablePositionPaging(true);
            qr.addPageRange(resultsStartingPosition, resultsMaxCount);

            RetailTransactionTableRecIdTemp recIdTemp;
            RecordInsertList recIds = new RecordInsertList(tableNum(RetailTransactionTableRecIdTemp),
                                                       false,
                                                       false,
                                                       false,
                                                       false,
                                                       false,
                                                       recIdTemp);

            while (qr.next())
            {
                // Skip if we have already reached max count
                if (qr.isPositionPagingEnabled() || resultsCount < resultsMaxCount)
                {
                    RetailTransactionTable rttRecIdOnly = qr.get(tableNum(RetailTransactionTable));
                    recIdTemp.RetailTransactionTableRecId = rttRecIdOnly.recId;
                    recIds.add(recIdTemp);

                    resultsCount++;
                }
                else
                {
                    break;
                }
            }

            recIds.insertDatabase();

            RetailTransactionTable rtt;
            while select rtt join recIdTemp where rtt.RecId == recIdTemp.RetailTransactionTableRecId
            {
                listHelper.AddSalesTransaction(
                        rtt,
                        partyTable,
                        argincludeDetails);
            }

            str results = listHelper.Serialize();
            output = [true, '', results];

            return output;
        }
        else
        {
            RecId argCurrentChannelId;
            RetailTransactionId argTransactionId;
            RetailReceiptId argReceiptId;
            RetailOrderChannelReferenceId argChannelRefId;
            CustAccount argCustAccount;
            str argCustFirstName;
            str argCustLastName;
            RetailStoreId argStoreId;
            RetailTerminalId argTerminalId;
            RetailItemId argItemId;
            RetailBarcode argBarcode;
            RetailStaffId argStaffId;
            str argStartDate;
            str argEndDate;
            RetailReceiptEmail argReceiptEmailAddress = '';
            InventSerialId argSerialNumber = '';
            boolean argIncludeDetails = false;
            str argsalesId = '';

            int resultsStartingPosition = 1;
            int resultsMaxCount = #resultsCountOfTransaction;
            DirPartyTable   partyTable;
            int             resultsCount;

            container           output = [true,''];
            utcDateTime         startDateTime = DateTimeUtil::minValue();
            utcDateTime         endDateTime = DateTimeUtil::maxValue();
            CustName            custName = '';
            boolean             includeDiscountLines = (argReceiptId || argChannelRefId || argTransactionId);

            Query   retailJournalListQuery;
            QueryRun qr;
            QueryBuildDataSource qbds;

            //
            // Main method body
            //

            // Parse the arguments
            argsXml   = new XmlDocument();
            argsXml.loadXml(_xmlArgumentString);
            argsRoot = argsXml.documentElement();

            argcurrentChannelId = str2int64(getArg('CurrentChannelId'));
            argtransactionId = getArg('TransactionIds');
            argreceiptId = getArg('ReceiptId');
            argchannelRefId = getArg('ChannelReferenceId');
            argcustAccount = getArg('CustomerAccountNumber');
            argcustFirstName = getArg('CustomerFirstName');
            argcustLastName = getArg('CustomerLastName');
            argstoreId = getArg('StoreId');
            argterminalId = getArg('TerminalId');
            argitemId = getArg('ItemId');
            argbarcode = getArg('BarCode');
            argstaffId = getArg('StaffId');
            argstartDate = getArg('StartDateTime');
            argendDate = getArg('EndDateTime');
            argreceiptEmailAddress = getArg('ReceiptEmailAddress');
            argserialNumber = getArg('SerialNumber');
            argIncludeDetails = false; // Never include details for list APIs ('true' == getArg('IncludeDetails'));
            argsalesId = getArg('SalesId');

            // Get paging details
            [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

            // Process the arguments
            if (argStartDate)
            {
                startDateTime =  DateTimeUtil::parse(argStartDate);
            }

            if (argendDate)
            {
                endDateTime = DateTimeUtil::parse(argEndDate);
            }

            // prepare list helper
            str argFormat = getArg('SerializationFormat');
            RetailTransactionResultListHelper listHelper = new RetailTransactionResultListHelper(
            (argFormat == int2Str(enum2int(RetailTransactionServiceResultFormat::Json))) // RetailTransactionServiceResultFormat::Json = '1'
            ? RetailTransactionServiceResultFormat::Json
            : RetailTransactionServiceResultFormat::Xml);

            // Get the basic query
            retailJournalListQuery = RetailTransactionServiceTransactions::getJournalListQuery(argCurrentChannelId, startDateTime, endDateTime);

            //Add filters/ranges
            qbds = retailJournalListQuery.dataSourceTable(tableNum(RetailTransactionTable));

            // optional id filters...
            if (argReceiptId)          qbds.addRange(fieldNum(RetailTransactionTable, ReceiptId)).value(argReceiptId);               //(argreceiptId == '' || transactionTable.ReceiptId == argreceiptId)
            if (argTransactionId)      qbds.addRange(fieldNum(RetailTransactionTable, transactionId)).value(argTransactionId);       //&& (argtransactionId == '' || transactionTable.transactionId == argtransactionId)
            if (argChannelRefId)       qbds.addRange(fieldNum(RetailTransactionTable, ChannelReferenceId)).value(argChannelRefId);   //&& (argchannelRefId == '' || transactionTable.ChannelReferenceId == argchannelRefId)
            if (argReceiptEmailAddress)qbds.addRange(fieldNum(RetailTransactionTable, receiptEmail)).value(argReceiptEmailAddress);  //&& (argreceiptEmailAddress == '' || transactionTable.receiptEmail == argreceiptEmailAddress)
            if (argStoreId)            qbds.addRange(fieldNum(RetailTransactionTable, Store)).value(argStoreId);                     //  && (argstoreId == '' || transactionTable.Store == argstoreId)
            if (argTerminalId)         qbds.addRange(fieldNum(RetailTransactionTable, Terminal)).value(argTerminalId);               //  && (argterminalId == '' || transactionTable.Terminal == argterminalId)
            if (argStaffId)            qbds.addRange(fieldNum(RetailTransactionTable, Staff)).value(argStaffId);                     //  && (argstaffId == '' || transactionTable.Staff == argstaffId)
            if (argCustAccount)        qbds.addRange(fieldNum(RetailTransactionTable, custAccount)).value(argCustAccount);           //  && (argcustAccount == '' || transactionTable.custAccount == argcustAccount)
            if (argSalesId)            qbds.addRange(fieldNum(RetailTransactionTable, SalesOrderId)).value(argSalesId);              //  && (argsalesId == '' || transactionTable.SalesOrderId == argsalesId)

            // Custom filters from extensions
            List extensionRanges = new List(Types::Container);
            XmlElement customFiltersXmlElement = argsRoot.getNamedElement('CustomFilters');
            if (customFiltersXmlElement)
            {
                // Gather custom filters from extensions
                RetailTransactionServiceTransactions::registerSearchJournalCustomFilterRanges(customFiltersXmlElement, extensionRanges);
          
                // Apply custom filters as query ranges
                RetailTransactionServiceTransactions::addExtensionFieldRangeValue(qbds, extensionRanges);

                // Call extension point to add custom data sources and filters
                RetailTransactionServiceTransactions::registerSearchJournalCustomDataSources(customFiltersXmlElement, qbds);
            }
        
            // Filter for CustName if necessary
            if (argCustFirstName != '' || argCustLastName != '')
            {
                // Add RetailTransactionTable exists join CustTable
                qbds = qbds.addDataSource(tableNum(CustTable), 'CustTable_Exists');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::ExistsJoin);
                qbds.relations(false);
                qbds.addLink(fieldNum(RetailTransactionTable, custAccount), fieldNum(CustTable, AccountNum));

                // Add CustTable exists join DirPersonName
                qbds = qbds.addDataSource(tableNum(DirPersonName), 'DirPersonName_Exists');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::ExistsJoin);
                qbds.relations(false);
                qbds.addLink(fieldNum(CustTable, Party), fieldNum(DirPersonName, Person));
                if(argCustFirstName != '')
                {
                    qbds.addRange(fieldNum(DirPersonName, FirstName)).value(argCustFirstName);
                }
                if(argCustLastName != '')
                {
                    qbds.addRange(fieldNum(DirPersonName, LastName)).value(argCustLastName);
                }
            }

            //SalesLineExists table
            if ( argItemId || argBarcode || argSerialNumber)
            {
                qbds = qbds.addDataSource(tableNum(RetailTransactionSalesTrans), 'RetailTransactionSalesTrans_Exists');
                qbds.fetchMode(QueryFetchMode::One2One);
                qbds.joinMode(JoinMode::ExistsJoin);
                qbds.relations(true);
                if (argItemId) qbds.addRange(fieldNum(RetailTransactionSalesTrans, ItemId)).value(argItemId);
                if (argBarcode) qbds.addRange(fieldNum(RetailTransactionSalesTrans, Barcode)).value(argBarcode);
                if (argSerialNumber) qbds.addRange(fieldNum(RetailTransactionSalesTrans, InventSerialId)).value(argSerialNumber);
            }
        
            // Run the query to get the recids of the records in result set.
            qr = new QueryRun(retailJournalListQuery);
            qr.enablePositionPaging(true);
            qr.addPageRange(resultsStartingPosition, resultsMaxCount);

            RetailTransactionTableRecIdTemp recIdTemp;
            RecordInsertList recIds = new RecordInsertList(tableNum(RetailTransactionTableRecIdTemp),
                                                       false,
                                                       false,
                                                       false,
                                                       false,
                                                       false,
                                                       recIdTemp);

        
            while (qr.next())
            {
                // Skip if we have already reached max count
                if (qr.isPositionPagingEnabled() || (resultsCount < resultsMaxCount) )
                {
                    RetailTransactionTable rttRecIdOnly = qr.get(tableNum(RetailTransactionTable));
                    recIdTemp.RetailTransactionTableRecId = rttRecIdOnly.recId;
                    recIds.add(recIdTemp);

                    resultsCount++;
                }
                else
                {
                    break;
                }
            }

            recIds.insertDatabase();

            RetailTransactionTable rtt;
            while select rtt join recIdTemp where rtt.RecId == recIdTemp.RetailTransactionTableRecId
            {
                listHelper.AddSalesTransaction(
                        rtt,
                        partyTable,
                        argincludeDetails);
            }

            str results = listHelper.Serialize();
            output = [true, '', results];

            return output;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeJournalQuery</Name>
				<Source><![CDATA[
    private static Query finalizeJournalQuery(
        Query _query,
        XmlElement argsRoot,
        int occurrence)
    {
        QueryBuildDataSource qbds;

        RetailTransactionId argTransactionId;
        RetailReceiptId argReceiptId;
        RetailOrderChannelReferenceId argChannelRefId;
        CustAccount argCustAccount;
        str argCustFirstName;
        str argCustLastName;
        RetailStoreId argStoreId;
        RetailTerminalId argTerminalId;
        RetailItemId argItemId;
        RetailBarcode argBarcode;
        RetailStaffId argStaffId;
        RetailReceiptEmail argReceiptEmailAddress = '';
        InventSerialId argSerialNumber = '';
        str argSalesId = '';

        str getArg(str argName)
        {
            XmlElement xmlRoot = argsRoot.getNamedElement(argName);
            if (xmlRoot != null)
            {
                return xmlRoot.text();
            }
            return '';
        }

        argtransactionId = getArg('TransactionIds');
        argreceiptId = getArg('ReceiptId');
        argchannelRefId = getArg('ChannelReferenceId');
        argcustAccount = getArg('CustomerAccountNumber');
        argcustFirstName = getArg('CustomerFirstName');
        argcustLastName = getArg('CustomerLastName');
        argstoreId = getArg('StoreId');
        argterminalId = getArg('TerminalId');
        argitemId = getArg('ItemId');
        argbarcode = getArg('BarCode');
        argstaffId = getArg('StaffId');
        argreceiptEmailAddress = getArg('ReceiptEmailAddress');
        argserialNumber = getArg('SerialNumber');
        argsalesId = getArg('SalesId');

        //Add filters/ranges
        qbds = _query.dataSourceTable(tableNum(RetailTransactionTable), occurrence);

        // optional id filters...
        if (argReceiptId)          qbds.addRange(fieldNum(RetailTransactionTable, ReceiptId)).value(argReceiptId);               //(argreceiptId == '' || transactionTable.ReceiptId == argreceiptId)
        if (argTransactionId)      qbds.addRange(fieldNum(RetailTransactionTable, transactionId)).value(argTransactionId);       //&& (argtransactionId == '' || transactionTable.transactionId == argtransactionId)
        if (argChannelRefId)       qbds.addRange(fieldNum(RetailTransactionTable, ChannelReferenceId)).value(argChannelRefId);   //&& (argchannelRefId == '' || transactionTable.ChannelReferenceId == argchannelRefId)
        if (argReceiptEmailAddress)qbds.addRange(fieldNum(RetailTransactionTable, receiptEmail)).value(argReceiptEmailAddress);  //&& (argreceiptEmailAddress == '' || transactionTable.receiptEmail == argreceiptEmailAddress)
        if (argStoreId)            qbds.addRange(fieldNum(RetailTransactionTable, Store)).value(argStoreId);                     //  && (argstoreId == '' || transactionTable.Store == argstoreId)
        if (argTerminalId)         qbds.addRange(fieldNum(RetailTransactionTable, Terminal)).value(argTerminalId);               //  && (argterminalId == '' || transactionTable.Terminal == argterminalId)
        if (argStaffId)            qbds.addRange(fieldNum(RetailTransactionTable, Staff)).value(argStaffId);                     //  && (argstaffId == '' || transactionTable.Staff == argstaffId)
        if (argCustAccount)        qbds.addRange(fieldNum(RetailTransactionTable, custAccount)).value(argCustAccount);           //  && (argcustAccount == '' || transactionTable.custAccount == argcustAccount)
        if (argSalesId)            qbds.addRange(fieldNum(RetailTransactionTable, SalesOrderId)).value(argSalesId);              //  && (argsalesId == '' || transactionTable.SalesOrderId == argsalesId)

        // Custom filters from extensions
        List extensionRanges = new List(Types::Container);
        XmlElement customFiltersXmlElement = argsRoot.getNamedElement('CustomFilters');
        if (customFiltersXmlElement)
        {
            // Gather custom filters from extensions
            RetailTransactionServiceTransactions::registerSearchJournalCustomFilterRanges(customFiltersXmlElement, extensionRanges);
          
            // Apply custom filters as query ranges
            RetailTransactionServiceTransactions::addExtensionFieldRangeValue(qbds, extensionRanges);

            // Call extension point to add custom data sources and filters
            RetailTransactionServiceTransactions::registerSearchJournalCustomDataSources(customFiltersXmlElement, qbds);
        }
        
        // Filter for CustName if necessary
        if (argCustFirstName != '' || argCustLastName != '')
        {
            // Add RetailTransactionTable exists join CustTable
            qbds = qbds.addDataSource(tableNum(CustTable), 'CustTable_Exists');
            qbds.fetchMode(QueryFetchMode::One2One);
            qbds.joinMode(JoinMode::ExistsJoin);
            qbds.relations(false);
            qbds.addLink(fieldNum(RetailTransactionTable, custAccount), fieldNum(CustTable, AccountNum));

            // Add CustTable exists join DirPersonName
            qbds = qbds.addDataSource(tableNum(DirPersonName), 'DirPersonName_Exists');
            qbds.fetchMode(QueryFetchMode::One2One);
            qbds.joinMode(JoinMode::ExistsJoin);
            qbds.relations(false);
            qbds.addLink(fieldNum(CustTable, Party), fieldNum(DirPersonName, Person));
            if(argCustFirstName != '')
            {
                qbds.addRange(fieldNum(DirPersonName, FirstName)).value(argCustFirstName);
            }
            if(argCustLastName != '')
            {
                qbds.addRange(fieldNum(DirPersonName, LastName)).value(argCustLastName);
            }
        }

        //SalesLineExists table
        if ( argItemId || argBarcode || argSerialNumber)
        {
            qbds = qbds.addDataSource(tableNum(RetailTransactionSalesTrans), 'RetailTransactionSalesTrans_Exists');
            qbds.fetchMode(QueryFetchMode::One2One);
            qbds.joinMode(JoinMode::ExistsJoin);
            qbds.relations(true);
            if (argItemId) qbds.addRange(fieldNum(RetailTransactionSalesTrans, ItemId)).value(argItemId);
            if (argBarcode) qbds.addRange(fieldNum(RetailTransactionSalesTrans, Barcode)).value(argBarcode);
            if (argSerialNumber) qbds.addRange(fieldNum(RetailTransactionSalesTrans, InventSerialId)).value(argSerialNumber);
        }

        return _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertUnionJournalQueryToPaginatedQuery</Name>
				<Source><![CDATA[
    private static Query convertUnionJournalQueryToPaginatedQuery(Query _unionQuery)
    {
        Query paginatedQuery = new Query();
        QueryBuildDataSource qbds = paginatedQuery.addDataSource(tableNum(RetailTransactionTable));
        
        // For performance reasons, we only want RecId.
        qbds.fields().clearFieldList();
        qbds.fields().addField(fieldNum(RetailTransactionTable, RecId));

        QueryRun qr = new QueryRun(_unionQuery);
        str queryRange;

        while (qr.next())
        {
            RetailTransactionTable rttRecIdOnly = qr.get(tableNum(RetailTransactionTable));
            queryRange = queryRangeConcat(queryRange, rttRecIdOnly.recId);
        }
        QueryBuildRange range = xSysQuery::findOrCreateRange(qbds, fieldNum(RetailTransactionTable, RecId));
        range.value(queryRange == '' ? '0' : queryRange);

        // Order results by descending createddatetime for pagination.
        qbds.addSortField(fieldNum(RetailTransactionTable, CreatedDateTime), SortOrder::Descending);

        return paginatedQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the purchase histories for a customer.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of purchase histories.
    ///     <ArrayOfPurchaseHistory>
    ///         <PurchaseHistory />
    ///     </ArrayOfPurchaseHistory>
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <LanguageId>"en-us"</LanguageId>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///         <StartDateTime>11/10/2015 3:47:22 AM</StartDateTime>
    ///     </Arguments>
    /// </remarks>
    public static container getPurchaseHistory(str _xmlArgumentString = '')
    {
        // arguments
        XmlDocument argsXml;
        XmlElement argsRoot;
        CustAccount custAccount;
        LanguageId languageId;
        str includeDetails;
        int skip = 0;
        int top = 0;

        // output
        container output = [true,''];
        XmlDocument xmlDoc = XmlDocument::newBlank('utf-16LE');
        XmlElement xmlRoot;

        //
        // Helper methods
        //

        // Get the string value of an XML element argument.
        str getArg(str argName)
        {
            xmlRoot = argsRoot.getNamedElement(argName);
            if (xmlRoot != null)

            {
                return xmlRoot.text();
            }
            return '';
        }

        // Parse the arguments
        argsXml   = new XmlDocument();
        argsXml.loadXml(_xmlArgumentString);
        argsRoot = argsXml.documentElement();

        custAccount = getArg('CustomerAccountNumber');
        languageId = getArg('LanguageId');
        CreatedDateTime startDateTime = str2Datetime(getArg('StartDateTime'), 213);
        CreatedDateTime endDateTime = DateTimeUtil::utcNow();
        str itemId = getArg('ItemId');
        str productNameFilter = getArg('ProductNameFilter');
        str receiptId = getArg('ReceiptId');
        str strEndDate = getArg('EndDateTime');
        if (strEndDate != '')
        {
            endDateTime = str2Datetime(strEndDate, 213);
        }

        // Customer is required. If customer does not exist, return error
        CustTable custTable = CustTable::find(custAccount);
        if (RetailSearchOrderReturnInvalidCustomerFlight::instance().isEnabled() && !custTable)
        {
            return [false, strFmt("@SYS119849", custAccount)];
        }

        // Get paging details
        [skip, top] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);
        top = top + skip - 1;

        Query q = new Query(queryStr(RetailPurchaseHistoryQuery));

        // Add filters/ranges
        QueryBuildDataSource qbds = q.dataSourceTable(tableNum(RetailPurchaseHistoryView));
        qbds.addRange(fieldNum(RetailPurchaseHistoryView, CustAccount)).value(custAccount); //View.CustAccount == custAccount
        qbds.addRange(fieldNum(RetailPurchaseHistoryView, MaxCreatedDateTime)).value(queryRange(startDateTime, endDateTime));
        qbds.addSortField(fieldNum(RetailPurchaseHistoryView, MaxCreatedDateTime), SortOrder::Descending); // Newest order first
        qbds.addRange(fieldNum(RetailPurchaseHistoryView, LanguageId)).value(languageId);
        if (itemId != '')
        {
            qbds.addRange(fieldNum(RetailPurchaseHistoryView, ItemId)).value(itemId);
        }
        if (productNameFilter != '')
        {
            qbds.addRange(fieldNum(RetailPurchaseHistoryView, Name)).value(SysQuery::valueLike(productNameFilter));
        }
        if (receiptId != '')
        {
            qbds.addRange(fieldNum(RetailPurchaseHistoryView, ReceiptId)).value(receiptId);
        }


        QueryRun qr = new QueryRun(q);

        // the number of fetched records
        int fetchedCount = 0;
        int64 productId = 0;

        RetailPurchaseHistoryView historyView = null;
        Set purchaseHistories = new Set(Types::Class);
        while (qr.next())
        {
            if (fetchedCount < top)
            {
                historyView = qr.get(tableNum(RetailPurchaseHistoryView));

                if (historyView.SalesId == '')
                {
                    productId = str2Int64(historyView.ListingId);
                }
                else
                {
                    productId = historyView.DistinctProductVariant == 0 ? historyView.Product : historyView.DistinctProductVariant;
                }

                purchaseHistories.add(
                    new PurchaseHistory(
                        historyView.receiptId,
                        historyView.SalesId,
                        historyView.ItemId,
                        historyView.MaxCreatedDateTime,
                        historyView.Name,
                        productId)
                    );
                ++fetchedCount;
            }
            else
            {
                break;
            }
        }

        // get images url for all items
        // Product image URL will be filled by client.
        RetailTransactionServiceTransactions::fillImageUrlForPurchaseHistory(purchaseHistories, languageId);
        xmlRoot = RetailTransactionServiceTransactions::fillPurchaseHistory(xmlDoc, purchaseHistories);
        xmlDoc.appendChild(xmlRoot);
        output = [true, '', xmlDoc.toString()];
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderHistoryList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the history of all transactions and orders for a given customer.
    /// </summary>
    /// <param name="_xmlArgumentString">
    /// XML document containing the arguments for the method call.  See remarks for example.
    /// </param>
    /// <returns>
    /// Collection of orders.
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    /// </returns>
    /// <remarks>
    /// Argument xml example:
    ///     <Arguments>
    ///         <CustomerAccountNumber>"1234"</CustomerAccountNumber>
    ///         <IncludeDetails>"true"</IncludeDetails>
    ///         <PagingInfo>
    ///             <Skip>1</Skip>
    ///             <Top>100</Top>
    ///         </PagingInfo>
    ///     </Arguments>
    /// </remarks>
    public static container getOrderHistoryList(str _xmlArgumentString = '')
    {
        // arguments
        XmlDocument         argsXml;
        XmlElement          argsRoot;
        CustAccount         custAccount;
        boolean             includeDetails;
        int                 resultsStartingPosition = 1;
        int                 resultsMaxCount = 100;

        // query filtering
        RetailTransactionTable      transactionTable;
        SalesTable                  salesTable;
        SalesQuotationTable         quoteTable;
        DirPartyTable               partyTable;

        // temp result variables
        int historySource;
        int64 orderRecId;

        // output
        container           output = [true,''];

        //
        // Helper methods
        //

        // Get the string value of an XML element argument.
        str getArg(str argName)
        {
            XmlElement xmlRoot = argsRoot.getNamedElement(argName);
            if (xmlRoot != null)

            {
                return xmlRoot.text();
            }
            return '';
        }

        //
        // Main body
        //

        // Parse the arguments
        argsXml   = new XmlDocument();
        argsXml.loadXml(_xmlArgumentString);
        argsRoot = argsXml.documentElement();

        custAccount = getArg('CustomerAccountNumber');
        includeDetails = ('true' == getArg('IncludeDetails'));
        CreatedDateTime startDateTime = str2Datetime(getArg('StartDateTime'), 213);
        CreatedDateTime endDateTime = DateTimeUtil::utcNow();

        // Customer is required. If customer does not exist, return error
        CustTable custTable = CustTable::find(custAccount);
        if (RetailSearchOrderReturnInvalidCustomerFlight::instance().isEnabled() && !custTable)
        {
            return [false, strFmt("@SYS119849", custAccount)];
        }

        // Get paging details
        [resultsStartingPosition, resultsMaxCount] = RetailTransactionServiceTransactions::parsePagingInfo(argsXml);

        // Prepare the results
        str argFormat = getArg('SerializationFormat');
        RetailTransactionResultListHelper resultHelper = new RetailTransactionResultListHelper(
            (argFormat == int2Str(enum2int(RetailTransactionServiceResultFormat::Json))) // RetailTransactionServiceResultFormat::Json = '1'
            ? RetailTransactionServiceResultFormat::Json
            : RetailTransactionServiceResultFormat::Xml);

        // Basic union query structure...
        //RetailTransactionTable where
        // rtt.custAccount == custAccount && rtt.type != CustomerOrder
        //
        //SalesTable
        // inner join RetailSalesTable on st.SalesId == rst.SalesTable
        //
        //SalesQuotationTable
        // inner join RetailSalesQuotationTable on sqt.QuotationId == rsqt.SalesQuotationTable

        RetailOrderHistoryQuery q = new RetailOrderHistoryQuery(custAccount, startDateTime, endDateTime);
        q.addPageRange(resultsStartingPosition, resultsMaxCount);

        while (q.moveNext())
        {
            // get result
            [historySource, orderRecId] = q.get();

            switch (historySource)
            {
                case tableNum(RetailTransactionTable):
                    //if Transaction
                    select firstonly * from transactionTable where transactionTable.recid == orderRecId; // 1:1 mapping so only need first record.
                    resultHelper.AddSalesTransaction(
                        transactionTable,
                        partyTable,
                        includeDetails,
                        true);
                    break;

                case tableNum(SalesTable):
                    //if Sales Order
                    salesTable = salesTable::findRecId(orderRecId);
                    resultHelper.AddSalesOrderBasic(
                        salesTable,
                        partyTable,
                        includeDetails);
                    break;

                case tableNum(SalesQuotationTable):
                    //if Sales Quote
                    quoteTable = SalesQuotationTable::findRec(orderRecId);
                    resultHelper.AddSalesQuotationBasic(
                        quoteTable,
                        partyTable,
                        includeDetails);
                    break;
            }
        }

        str results = resultHelper.Serialize();
        output = [true, '', results];

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parsePagingInfo</Name>
				<Source><![CDATA[
    public static container parsePagingInfo(XmlDocument _pagingElement)
    {
        XmlElement node, root;
        int64 recordSkip = #resultsDefaultSkip;
        int64 recordCount = #resultsCountOfTransaction;

        root = _pagingElement.documentElement().getNamedElement('PagingInfo');
        if (root != null)
        {
            // We have PagingInfo so override defaults...

            node = root.getNamedElement('Skip');
            if (node != null)
            {
                recordSkip = str2int(node.text());
                if (recordSkip <= 0)
                {
                    recordSkip = #resultsDefaultSkip;
                }
                else
                {
                    //Translate "skip" to AX 1-based starting position.
                    recordSkip = recordSkip + 1;
                }
            }

            node = root.getNamedElement('Top');
            if (node != null)
            {
                recordCount = str2int(node.text());
            }
        }

        return [recordSkip, recordCount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransactionToResultMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given Transaction entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_transactionXmlList">
    /// The List the new transaction entry will be added to.
    /// </param>
    /// <param name="_xmlDoc">
    /// The parent XML document to be used as a template for the new xml.
    /// </param>
    /// <param name="_transactionTable">
    /// The transaction table entry.
    /// </param>
    /// <param name="_partyTable">
    /// The optional associated DirPartyTable entry.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeTaxLines">
    /// Whether or not tax line details are to be included in the transaction xml.
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    /// <param name="_includeAttributes">
    /// Whether or not attributes are to be included in the transaction xml.
    /// </param>
    public static void addTransactionToResultMap(
        List _transactionXmlList,
        XmlDocument _xmlDoc,
        RetailTransactionTable _transactionTable,
        DirPartyTable _partyTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true,
        boolean _includeTaxLines = true,
        str _overrideElementName = #ElementSalesTransaction,
        boolean _includeAttributes = false)
    {
        RetailTransactionTaxTrans retailTransactionTaxTrans;
        RetailTransactionMarkupTrans chargeTable;
        XmlElement  xmlTrans, xmlItems;

        // Get Transaction Key
        str getTransactionKey(RetailTransactionTable t)
        {
            return t.transactionId + t.store + t.terminal + int642str(t.Channel);
        }

        retailTransactionTaxTrans.Amount = _transactionTable.isGTETransaction() ?
            RetailTransactionTaxTransGTE::calculateTotalTaxAmountForRetailTransaction(_transactionTable) :
            RetailTransactionServiceTransactions::calculateRegularTotalTaxAmountForRetailTransaction(_transactionTable);

        select sum(CalculatedAmount) from chargeTable
            where _transactionTable.TransactionId == chargeTable.TransactionId
                && _transactionTable.Channel == chargeTable.Channel
                && _transactionTable.Store == chargeTable.Store
                && _transactionTable.Terminal == chargeTable.TerminalId
                && _transactionTable.DataAreaId == chargeTable.DataAreaId;

        // Generate xml for transaction header
        xmlTrans = RetailTransactionServiceTransactions::fillRetailTransactionDetails(
            _transactionTable, retailTransactionTaxTrans, chargeTable, _partyTable, _xmlDoc, _includeDetails, _includeAttributes, _overrideElementName);

        // Fill in sales lines or customer account deposit lines.
        if (_includeDetails)
        {
            if (_transactionTable.Type == RetailTransactionType::Payment)
            {
                RetailTransactionCustomerAccountDepositTrans transactionCustAccountDepositTrans;

                // Select the customer account deposit lines for the current transaction.
                while select transactionCustAccountDepositTrans order by TransDate desc
                    where transactionCustAccountDepositTrans.DataAreaId == _transactionTable.DataAreaId
                        && transactionCustAccountDepositTrans.Channel == _transactionTable.Channel
                        && transactionCustAccountDepositTrans.Store == _transactionTable.Store
                        && transactionCustAccountDepositTrans.Terminal == _transactionTable.Terminal
                        && transactionCustAccountDepositTrans.TransactionId == _transactionTable.TransactionId
                {
                    // Add the lines from the RetailTransactionCustomerAccountDepositTrans in order by TransDate (ideally they should have the same TransDate but sort to be safe).
                    xmlItems = xmlTrans.getElementsByTagName('CustomerAccountDepositLines').item(0);
                    xmlItems.appendChild(RetailTransactionServiceTransactions::fillCustAccountTransDetails(transactionCustAccountDepositTrans, _xmlDoc));
                }
            }
            else
            {
                RetailTransactionSalesTrans transactionSalesTable;

                // Select the sales lines for the current transaction.
                while select * from transactionSalesTable order by TransDate desc
                where
                    _transactionTable.TransactionId == transactionSalesTable.TransactionId
                && _transactionTable.Channel == transactionSalesTable.Channel
                && _transactionTable.Store == transactionSalesTable.Store
                && _transactionTable.Terminal == transactionSalesTable.Terminalid
                && _transactionTable.DataAreaId == transactionSalesTable.DataAreaId
                {
                    // Add the sales lines from the transactionSalesTable in order by TransDate (ideally they should have the same TransDate but sort to be safe).
                    xmlItems = xmlTrans.getElementsByTagName('SalesLines').item(0);
                    xmlItems.appendChild(RetailTransactionServiceTransactions::fillSalesTransDetails(transactionSalesTable, _xmlDoc, _includeAttributes, _includeDiscountLines, _includeTaxLines));
                }
            }
        }

        // Add xml to results map
        _transactionXmlList.AddEnd(xmlTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesOrderToResultMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given SalesOrder entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_transactionXmlList">
    /// The List the new Sales Order entry will be added to.
    /// </param>
    /// <param name="_xmlDoc">
    /// The parent XML document to be used as a template for the new xml.
    /// </param>
    /// <param name="_salesTable">
    /// The SalesTable entry.
    /// </param>
    /// <param name="_partyTable">
    /// The optional associated DirPartyTable.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name = "_skipResultsWithoutTransactions">
    /// Whether or not to skip orders that do not have transactions (ie, due to pending P-Job).
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addSalesOrderToResultMap(
        List _transactionXmlList,
        XmlDocument _xmlDoc,
        SalesTable _salesTable,
        DirPartyTable _partyTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true,
        str _overrideElementName = #ElementSalesOrder,
        boolean _skipResultsWithoutTransactions = false)
    {
        RetailSalesTable rsTable;
        RetailTransactionTable rtTable;
        CustTable custTable;

        XmlElement  xmlTrans;
        boolean isCallCenter;

        // Get additional summary values
        rsTable = RetailSalesTable::findSalesTable(_salesTable);
        custTable = custTable::findByPartyRecId(_partyTable.RecId);

        // Get the most recent Transaction associated with this order (if one exists)
        select firstOnly1 * from rtTable
        order by rtTable.transDate desc, rtTable.transTime desc
            where rtTable.salesOrderId == _salesTable.SalesId
            && rtTable.entryStatus != RetailEntryStatus::Voided; // Exclude the voided transaction

        // If we would skip, confirm whether or not the order is from Call Center.
        if (_skipResultsWithoutTransactions & !rtTable)
        {
            isCallCenter = RetailChannelTable::findByRecId(rsTable.RetailChannel).ChannelType == RetailChannelType::MCRCallCenter;
        }

        //If we aren't supposed to skip orders that don't have any Transactions (yet), or we found a matching transaction, add it to the list
        if ( (!_skipResultsWithoutTransactions) || rtTable || isCallCenter)
        {
            // Generate xml for transaction header
            xmlTrans = RetailTransactionServiceTransactions::fillSalesOrderDetails(
            _salesTable,
            rsTable,
            custTable,
            rtTable,
            _includeDetails,
            _xmlDoc,
            _includeDiscountLines,
            _overrideElementName);

            // Add xml to results map
            _transactionXmlList.AddEnd(xmlTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSalesQuoteToResultMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate the XML document for a given SalesQuotation entry, and add it to the result map collection.
    /// </summary>
    /// <param name="_transactionXmlList">
    /// The List the new Quote entry will be added to.
    /// </param>
    /// <param name="_xmlDoc">
    /// The parent XML document to be used as a template for the new xml.
    /// </param>
    /// <param name="_quoteTable">
    /// The SalesQuotationTable entry.
    /// </param>
    /// <param name="_partyTable">
    /// The optional associated DirPartyTable.
    /// </param>
    /// <param name="_includeDetails">
    /// Whether or not line-level details are to be included in the transaction xml.
    /// </param>
    /// <param name="_includeDiscountLines">
    /// Whether or not discount line details are to be included in the transaction xml.
    /// </param>
    /// <param name = "_skipResultsWithoutTransactions">
    /// Whether or not to skip orders that do not have transactions (ie, due to pending P-Job).
    /// </param>
    /// <param name="_overrideElementName">
    /// Override the element name for elements in the result map.
    /// </param>
    public static void addSalesQuoteToResultMap(
        List _transactionXmlList,
        XmlDocument _xmlDoc,
        SalesQuotationTable _quoteTable,
        DirPartyTable _partyTable,
        boolean _includeDetails,
        boolean _includeDiscountLines = true,
        str _overrideElementName = '',
        boolean _skipResultsWithoutTransactions = false)
    {
        RetailSalesQuotationTable rsqTable;
        CustTable custTable;

        XmlElement  xmlTrans;

        // Get Transaction Key
        str getTransactionKey(SalesQuotationTable t)
        {
            return t.QuotationId;
        }

        // Get additional summary values
        rsqTable = RetailSalesQuotationTable::find(_quoteTable.QuotationId);
        custTable = custTable::findByPartyRecId(_partyTable.RecId);

        //If we aren't supposed to skip orders that don't have any Transactions (yet), or we found a matching transaction, add it to the list
        if ( (!_skipResultsWithoutTransactions) || rsqTable)
        {
            // Generate xml for transaction header
            xmlTrans = RetailTransactionServiceTransactions::fillQuoteDetails(
            _quoteTable,
            rsqTable,
            custTable,
            _includeDetails,
            _xmlDoc,
            _overrideElementName);

            // Add xml to results map
            _transactionXmlList.AddEnd(xmlTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetOrderDetails</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given order.
    /// </summary>
    /// <param name = "_transactionId">The Transaction Id of the order.</param>
    /// <param name = "_salesId">The Sales Id of the order (or quote).</param>
    /// <returns>
    /// A collection of orders in the form...
    /// <ArrayOfSalesOrder>
    ///     <SalesOrder />
    /// </ArrayOfSalesOrder>
    /// </returns>
    public static container GetOrderDetails(
        RetailTransactionId _transactionId,
        SalesId _salesId)
    {
        RetailOrderHistoryView historyView;
        XmlDocument xmlDoc;
        XmlElement xmlRoot;
        str xmlArgument;

        //find the unique Sale/Order record (ignoring posted orders for sales and un-posted transactions or customer orders)
        select firstonly1 RecId, HistorySource from historyView
            where historyView.OrderId == _transactionId || historyView.OrderId == _salesId;

        //get the details for the proper record using existing SearchOrderList api
        if (historyView && historyView.HistorySource == tableNum(RetailTransactionTable))
        {
            //return searchOrdersList(
            //    transasctionId = _transactionId,
            //    includeNonTransactions = false);

            return RetailTransactionServiceTransactions::searchOrderList(
                _transactionId, //RetailTransactionId _transactionId,
                '', //SalesId _salesId,
                '', //RetailReceiptId _receiptId,
                '', //RetailOrderChannelReferenceId _channelRefId,
                '', //CustAccount _custAccount,
                '', //str _custFirstName,
                '', //str _custLastName,
                '', //RetailStoreId _storeId,
                '', //RetailTerminalId _terminalId,
                '', //RetailItemId _itemId,
                '', //RetailBarcode _barcode,
                '', //RetailStaffId _staffId,
                '', //str _startDate,
                '', //str _endDate,
                true, //boolean _includeDetails,
                '', //RetailReceiptEmail _receiptEmailAddress = '',
                '', //String50 _seachIdentifiers = '',
                1, //int _resultsMaxCount = #resultsCountOfTransaction,
                '', //str _retailTransactionTypes = '',
                '', //InventSerialId _serialNumber = '',
                '', //str _transactionStatusTypes = '',
                false //boolean _includeNonTransactions
                );
        }
        else // in all other cases, attempt to find it across all tables (sales, quote, etc.)
        {
            //return searchOrdersList(
            //    salesId = _salesId,
            //    includeNonTransactions = true);

            return RetailTransactionServiceTransactions::searchOrderList(
                '', //RetailTransactionId _transactionId,
                _salesId, //SalesId _salesId,
                '', //RetailReceiptId _receiptId,
                '', //RetailOrderChannelReferenceId _channelRefId,
                '', //CustAccount _custAccount,
                '', //str _custFirstName,
                '', //str _custLastName,
                '', //RetailStoreId _storeId,
                '', //RetailTerminalId _terminalId,
                '', //RetailItemId _itemId,
                '', //RetailBarcode _barcode,
                '', //RetailStaffId _staffId,
                '', //str _startDate,
                '', //str _endDate,
                true, //boolean _includeDetails,
                '', //RetailReceiptEmail _receiptEmailAddress = '',
                '', //String50 _seachIdentifiers = '',
                1, //int _resultsMaxCount = #resultsCountOfTransaction,
                '', //str _retailTransactionTypes = '',
                '', //InventSerialId _serialNumber = '',
                '', //str _transactionStatusTypes = '',
                true //boolean _includeNonTransactions = true
                );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getXmlArg</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the value of an xml node with the given name from the given root element.
    /// </summary>
    /// <param name = "_root">The parent xml element which contains the named element.</param>
    /// <param name = "_argName">The name of the element to get.</param>
    /// <returns>The string value of the named element if it exists, empty string otherwise.</returns>
    private static str getXmlArg(XmlElement _root, str _argName)
    {
        XmlElement node = _root.getNamedElement(_argName);
        if (node != null)
        {
            return node.text();
        }
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>AppendSalesOrdersToXmlDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pack a list of individual SalesOrder xml entries into a single xml document.
    /// </summary>
    /// <param name = "_XmlDocument">The parent xml docuemnt that the list should be appended to.</param>
    /// <param name = "_listOfSalesOrderXmlElements">The list of Sales order xml elemnts to append..</param>
    /// <returns>
    /// An xml document orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]><![CDATA[>
    /// </returns>
    public static XmlDocument AppendSalesOrdersToXmlDocument(
        XmlDocument _XmlDocument,
        List _listOfSalesOrderXmlElements)
    {
        XmlElement  xmlRoot = RetailTransactionServiceTransactions::getArrayOfSalesOrderXmlRoot(_XmlDocument);
        XmlElement  xmlTrans;
        ListEnumerator enumerator = _listOfSalesOrderXmlElements.getEnumerator();

        while (enumerator.MoveNext())
        {
            xmlTrans = enumerator.current();
            xmlRoot.appendChild(xmlTrans);
        }

        _XmlDocument.appendChild(xmlRoot);
        return _XmlDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesOrderDetailsByTransactionId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given sale transaction.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// <![CDATA[
    ///   <_root>
    ///     <Arguments>
    ///         <TransactionId></TransactionId>
    ///         <ChannelId></ChannelId>
    ///         <CustomerId></CustomerId>
    ///     </Arguments>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </param>
    /// <returns>
    /// A collection of orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </returns>
    public static container GetSalesOrderDetailsByTransactionId(
        str _xmlArgumentString = '')
    {
        XmlDocument xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        XmlDocument argsXml;
        XmlElement argsRoot;
        List        xmlList = new List(Types::Class);
        container   output = [false, ''];

        try
        {
            // Parse the arguments
            argsXml   = new XmlDocument();
            argsXml.loadXml(_xmlArgumentString);
            argsRoot = argsXml.documentElement();

            RetailTransactionId transactionID = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'TransactionId');
            RetailChannelId channelId = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'ChannelId');
            AccountNumber customerId = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'CustomerId');

            //Priority is Receipt > Transaction > Sales order > Quote
            if (transactionId)
            {
                // Start with the basic Journal query
                Query query = new Query(queryStr(RetailJournalListQuery));

                // Add filters/ranges to the data source
                QueryBuildDataSource qbds = query.dataSourceTable(tableNum(RetailTransactionTable));

                // Include Transactions of status CreatingOrder. Base query already includes: None, Posted.
                qbds.addRange(fieldNum(RetailTransactionTable, EntryStatus)).value(QueryValue(RetailEntryStatus::CreatingOrder));

                // Include types: Sales, Customer order, Customer quote, Online order, Async Customer order, Async Customer quote
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::AsyncCustomerOrder));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::AsyncCustomerQuote));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::CustomerOrder));  // Customer Order & Quote
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::Sales));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::PendingSalesOrder));  // Online orders
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::Payment));

                if (transactionId)
                {
                    qbds.addRange(fieldNum(RetailTransactionTable, TransactionId)).value(transactionId);
                }
                if (channelId)
                {
                    qbds.addRange(fieldNum(RetailTransactionTable, Channel)).value(channelId);
                }
                if (customerId)
                {
                    qbds.addRange(fieldNum(RetailTransactionTable, CustAccount)).value(customerId);
                }

                QueryRun qr = new QueryRun(query);
                while (qr.next())
                {
                    RetailTransactionTable transactionTable = qr.get(tableNum(RetailTransactionTable));
                    DirPartyTable   partyTable = DirPartyTable::findRec(CustTable::find(transactionTable.CustAccount).Party);

                    RetailTransactionServiceTransactions::addTransactionToResultMap(
                        xmlList,
                        xmlDoc,
                        transactionTable,
                        partyTable,
                        true,   //includeDetails,
                        true,   //includeDiscountLines
                        true,   //includeTaxLines
                        #ElementSalesOrder,
                    true);  //includeAttributes
                }
            }

            xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
            output = [true, '', xmlDoc.toString()];
        }
        catch (Exception::Error)
        {
            str error = infolog.text(Global::infologLine());
            eventSource.EventWriteOrdersGetSalesOrderDetailsByTransactionIdError(funcName());
            output = [false, error];
        }
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesOrderDetailsBySalesId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given order.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// If multiple ids are given, priority is as follows: Receipt Id > Transction Id > Sales Id > Quote Id.
    /// <![CDATA[
    ///   <_root>
    ///     <Arguments>
    ///         <SalesId></SalesId>
    ///         <CustomerId></CustomerId>
    ///     </Arguments>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </param>
    /// <returns>
    /// A collection of orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </returns>
    public static container GetSalesOrderDetailsBySalesId(
        str _xmlArgumentString = '')
    {
        XmlDocument xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        XmlDocument argsXml;
        XmlElement argsRoot;
        List        xmlList = new List(Types::Class);
        container   output = [false, ''];

        try
        {
            // Parse the arguments
            argsXml   = new XmlDocument();
            argsXml.loadXml(_xmlArgumentString);
            argsRoot = argsXml.documentElement();

            DataAreaId    dataAreaId = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'DataAreaId');
            SalesId       salesId    = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'SalesId');
            CustAccount   customerId = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'CustomerId');

            if (salesId)
            {
                SalesTable      salesTable = SalesTable::find(salesId);

                if (salesTable)
                {
                    // When the salesOrder has a different customerId associated with it than the passed in customerId, return nothing
                    // We do this because we do not want customers to be able to look up order details for sales orders they did not create.
                    if (customerId && salesTable.CustAccount != customerId)
                    {
                        xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
                        output = [true, '', xmlDoc.toString()];

                        return output;
                    }

                    DirPartyTable   partyTable = DirPartyTable::findRec(CustTable::find(SalesTable.CustAccount).Party);

                    using (RetailTransactionSerializationContext context = RetailTransactionSerializationContext::construct())
                    {
                        context.parmIncludeAttributeValues(true);
                        RetailTransactionServiceTransactions::addSalesOrderToResultMap(
                            xmlList,
                            xmlDoc,
                            salesTable,
                            partyTable,
                            true,   //includeDetails,
                            true,   //includeDiscountLines
                            #ElementSalesOrder);
                    }
                }
                else
                {
                    output = [false, "@RET2434"];//Could not find the sales order.
                    eventSource.EventWriteOrdersGetSalesOrderDetailsBySalesIdError(funcName());

                    return output;
                }
            }

            xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
            output = [true, '', xmlDoc.toString()];
        }
        catch (Exception::Error)
        {
            str error = infolog.text(Global::infologLine());
            eventSource.EventWriteOrdersGetSalesOrderDetailsBySalesIdError(funcName());
            output = [false, error];
        }
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetSalesOrderDetailsByQuotationId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get full details for a single given quote.
    /// </summary>
    /// <param name = "_xmlArgumentString">
    /// The XML document containing the identifier(s) for the entity whose details are to be retrieved.
    /// If multiple ids are given, priority is as follows: Receipt Id > Transction Id > Sales Id > Quote Id.
    /// <![CDATA[
    ///   <_root>
    ///     <Arguments>
    ///         <QuotationId></QuotationId>
    ///     </Arguments>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </param>
    /// <returns>
    /// A collection of orders in the form...
    /// <![CDATA[
    ///   <_root>
    ///     <ArrayOfSalesOrder>
    ///         <SalesOrder />
    ///     </ArrayOfSalesOrder>
    ///  </_root>
    ///  ]]]]]]><![CDATA[><![CDATA[>
    /// </returns>
    public static container GetSalesOrderDetailsByQuotationId(
        str _xmlArgumentString = '')
    {
        XmlDocument xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        XmlDocument argsXml;
        XmlElement argsRoot;
        List        xmlList = new List(Types::Class);
        container   output = [false, ''];

        try
        {
            // Parse the arguments
            argsXml   = new XmlDocument();
            argsXml.loadXml(_xmlArgumentString);
            argsRoot = argsXml.documentElement();

            DataAreaId          dataAreaId = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'DataAreaId');
            SalesQuotationId    quoteId = RetailTransactionServiceTransactions::getXmlArg(argsRoot, 'QuotationId');

            if (quoteId)
            {
                SalesQuotationTable quoteTable = SalesQuotationTable::find(quoteId);
                DirPartyTable   partyTable = DirPartyTable::findRec(CustTable::find(quoteTable.CustAccount).Party);

                RetailTransactionServiceTransactions::addSalesQuoteToResultMap(
                    xmlList,
                    xmlDoc,
                    quoteTable,
                    partyTable,
                    true,   //includeDetails,
                    true,   //includeDiscountLines
                    #ElementSalesOrder);
            }

            xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
            output = [true, '', xmlDoc.toString()];
        }
        catch (Exception::Error)
        {
            str error = infolog.text(Global::infologLine());
            eventSource.EventWriteOrdersGetSalesOrderDetailsByQuotationIdError(funcName());
            output = [false, error];
        }
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExtensionFieldRangeValue</Name>
				<Source><![CDATA[
    private static void addExtensionFieldRangeValue(QueryBuildDataSource _qbds, List _extensionRanges)
    {
        ListEnumerator extensionRangeEnumerator = _extensionRanges.getEnumerator();
        while (extensionRangeEnumerator.moveNext())
        {
            str extensionFieldName;
            str extensionFieldValue;

            [extensionFieldName, extensionFieldValue] = extensionRangeEnumerator.current();
            int extensionFieldId = fieldName2Id(_qbds.table(), extensionFieldName);
            if (extensionFieldId)
            {
                _qbds.addRange(extensionFieldId).value(extensionFieldValue);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTransactionAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate attributes on transaction header or line level.
    /// </summary>
    /// <param name = "_xmlDoc">The xml document to create new xml elements.</param>
    /// <param name = "_transactionId">The transaction identifier.</param>
    /// <param name = "_terminalId">The terminal identifier.</param>
    /// <param name = "_storeId">The store identifier.</param>
    /// <param name = "_channelId">The channel identifier.</param>
    /// <param name = "_lineNum">The line number. Zero if level is header.</param>
    /// <param name = "_dataAreaId">The data area identifier.</param>
    /// <returns>The xml element for attributes result.</returns>
    private static XmlElement populateTransactionAttributes(
        XmlDocument _xmlDoc,
        RetailTransactionId _transactionId,
        RetailTerminalId _terminalId,
        RetailStoreId _storeId,
        RefRecId _channelId,
        HeaderOrLineNum _lineNum,
        DataAreaId _dataAreaId)
    {
        XmlElement xmlRecord;
        XmlElement attributeRecord, propertyRecord;
        RetailTransactionAttributeTrans attributeTable;

        if (_transactionId && _channelId && _lineNum >= 0 && _dataAreaId)
        {
            while select Name, TextValue from attributeTable
            where attributeTable.Channel == _channelId
                && attributeTable.transactionId == _transactionId
                && attributeTable.terminal == _terminalId
                && attributeTable.store == _storeId
                && attributeTable.HeaderOrLineNum == _lineNum
            {
                if (!xmlRecord)
                {
                    xmlRecord = _xmlDoc.createElement('AttributeValues');
                    xmlRecord.setAttribute('xmlns:i', schemaInstanceNSUrl);
                }

                attributeRecord = _xmlDoc.createElement('AttributeValueBase');
                attributeRecord.setAttribute2('type', schemaInstanceNSUrl, 'AttributeTextValue');

                // Elements should be sorted alphabetically.
                propertyRecord = _xmlDoc.createElement('Name');
                propertyRecord.innerText(attributeTable.Name);
                attributeRecord.appendChild(propertyRecord);

                propertyRecord = _xmlDoc.createElement('TextValue');
                propertyRecord.innerText(attributeTable.TextValue);
                attributeRecord.appendChild(propertyRecord);

                xmlRecord.appendChild(attributeRecord);
            }
        }

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesTransDetailsWithoutAttributesDiscountTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the serialized xml string of a list of <c>salesTrans</c> having the data of the <c>RetailTransactionSalesTrans</c> table.
    /// </summary>
    /// <param name="transactionSalesTrans">
    /// Table buffer of <c>RetailTransactionSalesTrans</c> table.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of the <c>RetailTransactionSalesTrans</c> table.
    /// </returns>
    internal static XmlElement fillSalesTransDetailsWithoutAttributesDiscountTax(
        RetailTransactionSalesTrans transactionSalesTrans,
        XmlDocument xmlDoc)
    {
        return RetailTransactionServiceTransactions::fillSalesTransDetails(transactionSalesTrans, xmlDoc, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>subtractPreviouslyReturnedChargeAmountFromHeaderCharge</Name>
				<Source><![CDATA[
    private static RetailTransactionMarkupTrans subtractPreviouslyReturnedChargeAmountFromHeaderCharge(RetailTransactionMarkupTrans refundCharge, RetailTransactionTable originalTransaction)
    {
        RetailTransactionMarkupTrans previouslyRefundedCharges;
        RetailTransactionSalesTrans previousReturnLine;
        RetailTransactionTable previousReturnHeader;

        while select transactionId, terminal, store, Channel from previousReturnHeader
            exists join previousReturnLine
            where previousReturnLine.transactionId == previousReturnHeader.transactionId
            && previousReturnLine.terminalId == previousReturnHeader.terminal
            && previousReturnLine.store == previousReturnHeader.store
            && previousReturnLine.Channel == previousReturnHeader.Channel
            && previousReturnLine.returnTransactionId == originalTransaction.transactionId
            && previousReturnLine.returnTerminalId == originalTransaction.terminal
            && previousReturnLine.returnStore == originalTransaction.Store
            && previousReturnLine.TransactionStatus != RetailEntryStatus::Voided
        {
            previouslyRefundedCharges = RetailTransactionServiceTransactions::getPreviouslyRefundedCharges(
                refundCharge,
                previousReturnHeader.transactionId,
                previousReturnHeader.terminal,
                previousReturnHeader.store,
                previousReturnHeader.Channel);
    
            refundCharge.Value -= abs(previouslyRefundedCharges.Value);
            refundCharge.CalculatedAmount -= abs(previouslyRefundedCharges.CalculatedAmount);
            refundCharge.TaxAmount -= abs(previouslyRefundedCharges.TaxAmount);
        }

        return refundCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>subtractPreviouslyReturnedChargeAmountFromLineCharge</Name>
				<Source><![CDATA[
    private static RetailTransactionMarkupTrans subtractPreviouslyReturnedChargeAmountFromLineCharge(RetailTransactionMarkupTrans refundCharge, RetailTransactionSalesTrans originalLine)
    {
        RetailTransactionMarkupTrans previouslyRefundedCharges;
        RetailTransactionSalesTrans  previousReturnLine;

        while select transactionId, terminalId, store, Channel, LineNum from previousReturnLine
            where previousReturnLine.returnTransactionId == originalLine.transactionId
            && previousReturnLine.returnTerminalId == originalLine.terminalId
            && previousReturnLine.returnStore == originalLine.Store
            && previousReturnLine.returnLineNum == originalLine.lineNum
            && previousReturnLine.TransactionStatus != RetailEntryStatus::Voided
        {
            
            previouslyRefundedCharges = RetailTransactionServiceTransactions::getPreviouslyRefundedCharges(
                refundCharge,
                previousReturnLine.transactionId,
                previousReturnLine.terminalId,
                previousReturnLine.store,
                previousReturnLine.Channel,
                previousReturnLine.lineNum);
    
            refundCharge.Value -= abs(previouslyRefundedCharges.Value);
            refundCharge.CalculatedAmount -= abs(previouslyRefundedCharges.CalculatedAmount);
            refundCharge.TaxAmount -= abs(previouslyRefundedCharges.TaxAmount);
        }

        return refundCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviouslyRefundedCharges</Name>
				<Source><![CDATA[
    // The line num parameter should either be the line num of the sales line if you are getting line charges, or 0 if you are getting header charges
    private static RetailTransactionMarkupTrans getPreviouslyRefundedCharges(
        RetailTransactionMarkupTrans refundCharge,
        RetailTransactionId transactionId,
        RetailTerminalId terminalId,
        RetailStoreId store,
        RefRecId channel,
        Real lineNum = 0)
    {
        RetailTransactionMarkupTrans previouslyRefundedCharges;
        RetailTransactionTable transactionTable;

        select sum(Value), sum(CalculatedAmount), sum(TaxAmount) from previouslyRefundedCharges
                where previouslyRefundedCharges.transactionId == transactionId
                && previouslyRefundedCharges.terminalId == terminalId
                && previouslyRefundedCharges.store == store
                && previouslyRefundedCharges.Channel == channel
                && previouslyRefundedCharges.saleLineNum == lineNum
                && previouslyRefundedCharges.MarkupCode == refundCharge.MarkupCode
                && previouslyRefundedCharges.ModuleType == refundCharge.ModuleType
                && previouslyRefundedCharges.TaxGroup == refundCharge.TaxGroup
                && previouslyRefundedCharges.TaxItemGroup == refundCharge.TaxItemGroup
        exists join transactionTable
                where transactionTable.TransactionId == transactionId
                   && transactionTable.Channel == channel
                   && transactionTable.Terminal == terminalId
                   && transactionTable.Store == store
                   && transactionTable.EntryStatus != RetailEntryStatus::Voided;

        return previouslyRefundedCharges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLoyaltyCardNumberToQuery</Name>
				<Source><![CDATA[
    private static void addLoyaltyCardNumberToQuery(QueryBuildDataSource _qbds, str _loyaltyCardNumberParam)
    {
        // Add RetailLoyaltyCard
        // join * from RetailLoyaltyCard
        //     where RetailLoyaltyCard.Party == DirPartyTable.RecId
        //     && RetailLoyaltyCard.CardNumber == _loyaltyCardNumberParam
        QueryBuildDataSource retailLoyaltyCard_ds = _qbds.addDatasource(tableNum(RetailLoyaltyCard));
        retailLoyaltyCard_ds.joinMode(JoinMode::InnerJoin);
        retailLoyaltyCard_ds.relations(false);
        retailLoyaltyCard_ds.addLink(fieldNum(DirPartyTable, RecId), fieldNum(RetailLoyaltyCard, Party));
        retailLoyaltyCard_ds.addRange(fieldNum(RetailLoyaltyCard, CardNumber)).value(_loyaltyCardNumberParam);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustomerPhoneNumberToQuery</Name>
				<Source><![CDATA[
    private static void addCustomerPhoneNumberToQuery(QueryBuildDataSource _qbds, str _customerPhoneNumberParam)
    {
        // Add DirPartyLocation
        //join * from dirPartyLocation
        //    where dirPartyLocation.Party == dirPartyTable.RecId
        QueryBuildDataSource dirPartyLocation_ds = _qbds.addDataSource(tableNum(DirPartyLocation));
        dirPartyLocation_ds.joinMode(JoinMode::ExistsJoin);
        dirPartyLocation_ds.relations(false);
        dirPartyLocation_ds.addLink(fieldNum(DirPartyTable, RecId), fieldNum(DirPartyLocation, Party));

        // Add LogisticsElectronicAddress
        // join * from LogisticsElectronicAddress
        //      where LogisticsElectronicAddress.Location = dirPartyLocation.Location
        //      && LogisticsElectronicAddress.Type == LogisticsElectronicAddressMethodType::Phone
        //      && logisticsElectronicAddress.Locator == _customerPhoneNumberParam
        QueryBuildDataSource logisticsElectronicAddress_ds = dirPartyLocation_ds.addDataSource(tableNum(LogisticsElectronicAddress));
        logisticsElectronicAddress_ds.joinMode(JoinMode::InnerJoin);
        logisticsElectronicAddress_ds.relations(false);
        logisticsElectronicAddress_ds.addLink(fieldNum(DirPartyLocation, Location), fieldNum(LogisticsElectronicAddress, Location));
        logisticsElectronicAddress_ds.addRange(fieldNum(LogisticsElectronicAddress, Locator)).value(_customerPhoneNumberParam);
        logisticsElectronicAddress_ds.addRange(fieldNum(LogisticsElectronicAddress, Type)).value(enum2Str(LogisticsElectronicAddressMethodType::Phone));
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDeliveryAddressName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns delivery address name for a given transaction or order.
    /// </summary>
    /// <param name="_deliveryAddress">
    /// The delivery address associated with a transaction.
    /// </param>
    /// <param name="_deliveryName">
    /// The passed in delivery name associated with the transaction or order.
    /// </param>
    /// <returns>
    /// Delivery address name for a given transaction or order.
    /// </returns>
    [Hookable(false), Wrappable(false)]
    internal static str GetDeliveryAddressName(LogisticsPostalAddress _deliveryAddress, str _deliveryName)
    {
        str deliveryName = _deliveryName;
        Description displayLocationDecription = _deliveryAddress.displayLocationDescription();

        if (displayLocationDecription != '')
        {
            deliveryName = displayLocationDecription;
        }

        return deliveryName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateRegularTotalTaxAmountForRetailTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates total tax amount for retail transaction by <t>RetailTransactionTaxTrans</t> table.
    /// </summary>
    /// <param name = "_transactionTable">The transaction table entry.</param>
    /// <returns>Tax amount.</returns>
    private static Amount calculateRegularTotalTaxAmountForRetailTransaction(RetailTransactionTable _transactionTable)
    {
        RetailTransactionSalesTrans retailTransactionSalesTrans;
        RetailTransactionTaxTrans retailTransactionTaxTrans;
        
        // Get additional summary values
        select sum(Amount) from retailTransactionTaxTrans
            where _transactionTable.TransactionId == retailTransactionTaxTrans.TransactionId
                && _transactionTable.Channel == retailTransactionTaxTrans.Channel
                && _transactionTable.Store == retailTransactionTaxTrans.StoreId
                && _transactionTable.Terminal == retailTransactionTaxTrans.TerminalId
                && _transactionTable.DataAreaId == retailTransactionTaxTrans.DataAreaId
            join retailTransactionSalesTrans
            where retailTransactionTaxTrans.TransactionId == retailTransactionSalesTrans.transactionId
            && retailTransactionTaxTrans.Channel == retailTransactionSalesTrans.Channel
            && retailTransactionTaxTrans.StoreId == retailTransactionSalesTrans.store
            && retailTransactionTaxTrans.TerminalId == retailTransactionSalesTrans.terminalId
            && retailTransactionTaxTrans.DataAreaId == retailTransactionSalesTrans.DataAreaId
            && retailTransactionTaxTrans.SaleLineNum == retailTransactionSalesTrans.LineNum
            && retailTransactionSalesTrans.transactionStatus != RetailEntryStatus::Voided;

        return retailTransactionTaxTrans.Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetLogisticsLocationRoleForPostalAddress</Name>
				<Source><![CDATA[
    private static LogisticsLocationRole GetLogisticsLocationRoleForPostalAddress(LogisticsPostalAddress logisticsPostalAddress)
    {
        DirPartyLocation dirPartyLocation;
        DirPartyLocationRole dirPartyLocationRole;
        LogisticsLocationRole logisticsLocationRole;

        select firstonly logisticsLocationRole
            join dirPartyLocationRole
                where logisticsLocationRole.RecId == dirPartyLocationRole.LocationRole
            join dirPartyLocation
                where dirPartyLocationRole.PartyLocation == dirPartyLocation.RecId
                    && dirPartyLocation.IsPostalAddress
                    && dirPartyLocation.Location == logisticsPostalAddress.Location;

        return logisticsLocationRole;
    }

]]></Source>
			</Method>
			<Method>
				<Name>GetDirPartyLocationForCustomerPostalAddress</Name>
				<Source><![CDATA[
    private static DirPartyLocation GetDirPartyLocationForCustomerPostalAddress(LogisticsPostalAddress logisticsPostalAddress, DirPartyRecId customerParty = 0)
    {
        DirPartyLocation dirPartyLocation;

        if (RetailDirPartyLocationChangesFlight::instance().isEnabled() && customerParty)
        {
            select firstonly dirPartyLocation
                where dirPartyLocation.IsPostalAddress
                    && dirPartyLocation.Location == logisticsPostalAddress.Location
                    && dirPartyLocation.Party == customerParty;
        }
        else
        {
            select firstonly dirPartyLocation
                where dirPartyLocation.IsPostalAddress
                    && dirPartyLocation.Location == logisticsPostalAddress.Location;
        }

        return dirPartyLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>AddHistoryEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add payment history entry to collection.
    /// </summary>
    /// <param name = "_paymentType">The transaction payment type.</param>
    /// <param name = "_amount">The transaction amount.</param>
    /// <param name = "_currency">The transaction currency.</param>
    /// <param name = "_date">The transaction date.</param>
    /// <param name = "_tenderTypeId">The transaction tender type.</param>
    /// <returns>Returns <t>RetailTransactionPaymentTrans</t> table data.</returns>
    private static RetailTransactionPaymentTrans AddHistoryEntry(str _paymentType, AmountCur _amount, CurrencyCode _currency, TransDate _date, MCRRetailStoreTenderTypeId _tenderTypeId, RetailStoreCardTypeId _cardTypeId, RefRecId _PaymentRecID)
    {
        RetailTransactionPaymentTrans tmpPaymentTrans;

        // Fill a temporary RetailTransactionPaymentTrans record to feed the filPaymentTransDetails(...) method.
        tmpPaymentTrans.clear();
        tmpPaymentTrans.amountTendered = _amount;
        tmpPaymentTrans.amountMST = _amount;
        tmpPaymentTrans.currency = _currency;
        tmpPaymentTrans.transDate = _date;
        tmpPaymentTrans.tenderType = _tenderTypeId;
        tmpPaymentTrans.cardTypeId = _cardTypeId;
        tmpPaymentTrans.cardOrAccount = CreditCard::creditCardNumber(_PaymentRecID);

        return tmpPaymentTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillInventoryQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the xml string of aggregated inventory quantities of a sales order.
    /// </summary>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <param name = "_salesId">
    /// The sales id.
    /// </param>
    /// <returns>
    /// XML serialized string of AggregateInventoryQuantities.
    /// * Members must be in order of the InventoryQuantities
    /// Example, inside the <AggregateInventoryQuantities> node:
    ///      <QuantityInvoiced />
    ///      <QuantityNotProcessed />
    ///      <QuantityOrdered />
    ///      <QuantityPacked />
    ///      <QuantityPicked />
    ///      <QuantityReserved />
    ///      <QuantityOrdered />
    /// </returns>
    public static XmlElement fillInventoryQuantities(
        XmlDocument xmlDoc,
        SalesId _salesId)
    {
        boolean isRetailFulfillmentQuantitiesInSalesUomFlightEnabled = RetailFulfillmentQuantitiesInSalesUomFlight::instance().isEnabled();
        XmlElement xmlRoot = xmlDoc.createElement('AggregateInventoryQuantities');

        SalesLine soLine;
        RetailSalesLine rsoLine;
        Qty quantityOrdered = 0;
        Qty quantityNotProcessed = 0;
        Qty quantityPhysicallyReserved = 0;
        Qty quantityPicked = 0;
        Qty quantityPacked = 0;
        Qty quantityInvoiced = 0;

        if (isRetailFulfillmentQuantitiesInSalesUomFlightEnabled)
        {
            while select soLine 
                where soLine.SalesId == _salesId
                join rsoLine where rsoLine.SalesLine == soLine.RecId
            {
                quantityOrdered += rsoLine.getQuantityOrderedInSalesUnit(soLine);
                quantityNotProcessed += rsoLine.getQuantityNotProcessedInSalesUnit(soLine);
                quantityPhysicallyReserved += rsoLine.getQuantityPhysicallyReservedInSalesUnit(soLine);
                quantityPicked += rsoLine.getQuantityPickedInSalesUnit(soLine);
                quantityPacked += rsoLine.getQuantityPackedInSalesUnit(soLine);
                quantityInvoiced += rsoLine.getQuantityInvoicedInSalesUnit(soLine);
            }
        }
        else
        {
            select
                sum(QtyOrdered)
            from soLine where soLine.SalesId == _salesId
            join
                sum(QuantityNotProcessed),
                sum(QuantityPhysicallyReserved),
                sum(QuantityPicked),
                sum(QuantityPacked),
                sum(QuantityInvoiced)
            from rsoLine where rsoLine.SalesLine == soLine.RecId;

            quantityInvoiced = rsoLine.QuantityInvoiced;
            quantityNotProcessed = rsoLine.QuantityNotProcessed;
            quantityOrdered = soLine.QtyOrdered;
            quantityPacked = rsoLine.QuantityPacked;
            quantityPicked = rsoLine.QuantityPicked;
            quantityPhysicallyReserved = rsoLine.QuantityPhysicallyReserved;
        }
        
        XmlElement xmlRecord = xmlDoc.createElement('QuantityInvoiced');
        xmlRecord.innerText(num2str(quantityInvoiced, 0, 2, 1, 0));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('QuantityNotProcessed');
        xmlRecord.innerText(num2str(quantityNotProcessed, 0, 2, 1, 0));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('QuantityOrdered');
        xmlRecord.innerText(num2str(quantityOrdered, 0, 2, 1, 0));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('QuantityPacked');
        xmlRecord.innerText(num2str(quantityPacked, 0, 2, 1, 0));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('QuantityPicked');
        xmlRecord.innerText(num2str(quantityPicked, 0, 2, 1, 0));
        xmlRoot.appendChild(xmlRecord);

        xmlRecord = xmlDoc.createElement('QuantityReserved');
        xmlRecord.innerText(num2str(quantityPhysicallyReserved, 0, 2, 1, 0));
        xmlRoot.appendChild(xmlRecord);

        return xmlRoot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillContactInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method returns the xml string of one contact information.
    /// </summary>
    /// <param name = "_contactInformationType">
    /// The type.
    /// </param>
    /// <param name = "_value">
    /// The value.
    /// </param>
    /// <param name="xmlDoc">
    /// XmlDocument
    /// </param>
    /// <returns>
    /// XML serialized string of ContactInformation in CRT.
    /// * Members must be in order of the CRT ContactInformation DataContract.
    /// Example:
    ///    <ContactInformation>
    ///      <ContactInformationTypeValue />
    ///      <Value />
    ///    </ContactInformation>
    /// </returns>
    public static XmlElement fillContactInformation(LogisticsElectronicAddressMethodType _contactInformationType, str _value, XmlDocument xmlDoc)
    {
        XmlElement xmlRecord, xmlEntry;
        xmlRecord = xmlDoc.createElement('ContactInformation');

        xmlEntry = xmlDoc.createElement('ContactInformationTypeValue');
        xmlEntry.innerText(int2Str(enum2int(_contactInformationType)));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = xmlDoc.createElement('Value');
        xmlEntry.innerText(_value);
        xmlRecord.appendChild(xmlEntry);

        return xmlRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderIdByChannelReferenceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get Sales Order details by channel reference id(order confirmation id).
    /// </summary>
    /// <param name = "_orderSearchJson"> The JSON document containing the identifier(s) for the entity whose details are to be retrieved.</param>
    /// <returns>A collection of orders in the form.</returns>
    public static container getSalesOrderIdByChannelReferenceId(str _orderSearchJson)
    {
        XmlDocument xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        List        xmlList = new List(Types::Class);
        container   output = [false, ''];
        RetailTransactionTable retailTransactionTable;

        CrtTransactionService.TransactionServiceSalesOrderParameters orderDetailsByChannelReferenceId = RetailTransactionServiceTransactions::getSalesOrderLookupParameterFromJson(_orderSearchJson);
        if (!orderDetailsByChannelReferenceId)
        {
            return [false, "@Retail:RetailInvalidOrderDetalsByConfirmationIdSearchOrders", ''];
        }

        try
        {
            RetailOrderChannelReferenceId confirmationId = orderDetailsByChannelReferenceId.ConfirmationId;
            RefRecId channelId = orderDetailsByChannelReferenceId.ChannelId;

            if (System.String::IsNullOrEmpty(confirmationId))
            {
                return [false,"@Retail:ChannelReferenceIdIsNull",''];
            }

            if (channelId)
            {
                select firstonly ChannelReferenceId,Channel,salesOrderId from retailTransactionTable
                    order by RecId desc
                    where retailTransactionTable.ChannelReferenceId == confirmationId
                    && retailTransactionTable.Channel == channelId;
            }
            else
            {
                select firstonly ChannelReferenceId,Channel,salesOrderId from retailTransactionTable
                    order by RecId desc
                    where retailTransactionTable.ChannelReferenceId == confirmationId;
            }

            if (retailTransactionTable)
            {
                if (retailTransactionTable.salesOrderId)
                {
                    eventSource.EventWriteGetSalesOrderIdFoundBylookupOrderDetailsBySalesIdInfoEventId(retailTransactionTable.RecId);
                    return RetailTransactionServiceTransactions::lookupOrderDetailsBySalesId(retailTransactionTable.salesOrderId);
                }
                else
                {
                    eventSource.EventWriteGetSalesOrderIdNotFoundlookupOrderDetailsByChannelReferenceIdInfoEventId(retailTransactionTable.RecId);
                    return RetailTransactionServiceTransactions::lookupOrderDetailsByChannelReferenceId(retailTransactionTable.ChannelReferenceId, retailTransactionTable.Channel);
                }
            }
            // If no transaction is found, we will return empty XML data.
            xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
            output = [true, '', xmlDoc.toString()];

        }
        catch
        {
            str error = infolog.text(Global::infologLine());
            eventSource.EventWriteGetSalesOrderDetailsByChannelReferenceIdError(funcName());
            output = [false, error];
        }

        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderOriginators</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the order originator information of each order by transaction id or sales id.
    /// The order originator is an entity that keeps the information of who placed an order (employee) and for whom (customer).
    /// It contains the employee information (id and name), the customer information (id and name) and the identifier (transaction id or the sales id).
    /// If the information does not exist or we could not find, we will not populate the data.
    /// If the transaction id is used in parameters, then the channel information is required.
    /// </summary>
    /// <param name = "_orderOriginatorsParametersJsonString">
    /// A JSON formatted string the parameters to get the order originators.
    /// </param>
    /// <returns>
    /// A JSON formatted string with a list of order originators.
    /// </returns>
    /// <remarks>
    /// Input JSON example:
    ///     {
    ///         "ChannelId": 54321,
    ///         "TransactionIds": [
    ///             "A",
    ///             "B",
    ///             "C",
    ///             "D"
    ///         ],
    ///         "SalesIds": [
    ///             "S01",
    ///             "S02",
    ///         ]
    ///     }
    /// 
    /// In this example:
    ///     * Transaction "A" has an employee and a customer associated and we found their names in database.
    ///     * Transaction "B" has only a customer associated and we did not found the name in database.
    ///     * Transaction "C" has an employee and a customer associated and we found the customer's name only in database.
    ///     * Transaction "D" does not exist in the given channel.
    ///     * Order "S01" has an employee and a customer associated and we found their names in database.
    ///     * Order "S02" does not exist.
    /// 
    /// Output JSON example:
    ///     "[
    ///         {
    ///             \"__type\":\"OrderOriginator:#Microsoft.Dynamics.Commerce.Runtime.DataModel\",
    ///             \"ExtensionProperties\":[],
    ///             \"CustomerId\":\"123\",
    ///             \"CustomerName\":\"Customer's name\",
    ///             \"StaffId\":\"123\",
    ///             \"StaffName\":\"Employee's name\",
    ///             \"TransactionId\":\"A\"
    ///         },
    ///         {
    ///             \"__type\":\"OrderOriginator:#Microsoft.Dynamics.Commerce.Runtime.DataModel\",
    ///             \"ExtensionProperties\":[],
    ///             \"CustomerId\":\"124\",
    ///             \"CustomerName\":null,
    ///             \"StaffId\":null,
    ///             \"StaffName\":null,
    ///             \"TransactionId\":\"B\"
    ///         },
    ///         {
    ///             \"__type\":\"OrderOriginator:#Microsoft.Dynamics.Commerce.Runtime.DataModel\",
    ///             \"ExtensionProperties\":[],
    ///             \"CustomerId\":\"123\",
    ///             \"CustomerName\":\"Customer's name\",
    ///             \"StaffId\":\"124\",
    ///             \"StaffName\":null,
    ///             \"TransactionId\":\"C\"
    ///         },
    ///         {
    ///             \"__type\":\"OrderOriginator:#Microsoft.Dynamics.Commerce.Runtime.DataModel\",
    ///             \"ExtensionProperties\":[],
    ///             \"CustomerId\":\"123\",
    ///             \"CustomerName\":\"Customer's name\",
    ///             \"StaffId\":\"123\",
    ///             \"StaffName\":\"Employee's name\",
    ///             \"SalesId\":\"S01\"
    ///         },
    ///     ]"
    /// </remarks>
    public static container getOrderOriginators(str _orderOriginatorsParametersJsonString = '')
    {
        System.Collections.ArrayList orderOriginators;
        System.Exception ex;

        var parameters = RetailTransactionServiceTransactions::getOrderOriginatorParametersFromJson(_orderOriginatorsParametersJsonString);

        try
        {
            RetailTransactionServiceTransactions::validateOrderOriginatorParameters(parameters);
            orderOriginators = RetailTransactionServiceTransactions::getOrderOriginatorEntities(parameters);
        }
        catch (ex)
        {
            eventSource.EventWriteGetOrderOriginatorsParametersValidationError(funcName(), ex.GetType().ToString(), ex.ToString());
            return [false, ex.Message, ''];
        }

        return RetailTransactionServiceTransactions::serializeOrderOriginators(orderOriginators);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderOriginatorParametersFromJson</Name>
				<Source><![CDATA[
    /// <summary>
    /// Parses the JSON and retrieves the parameters.
    /// </summary>
    /// <param name = "_orderOriginatorParameters">
    /// A JSON formatted string the parameters to get the order originators.
    /// </param>
    /// <returns>
    /// The parameters if JSON is successfuly parsed; null otherwise.
    /// </returns>
    private static CrtTransactionService.TransactionServiceOrderOriginatorParameters getOrderOriginatorParametersFromJson(str _orderOriginatorsParametersJsonString)
    {
        System.Exception ex;
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type parametersType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceOrderOriginatorParametersTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of client version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CrtTransactionService.TransactionServiceOrderOriginatorParameters parameters = Newtonsoft.Json.JsonConvert::DeserializeObject(_orderOriginatorsParametersJsonString, parametersType, settings);

            return parameters;
        }
        catch (ex)
        {
            eventSource.EventWriteGetOrderOriginatorsParserError(funcName(), ex.GetType().ToString(), ex.ToString());
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateOrderOriginatorParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the parameters and return error if not valid.
    /// </summary>
    /// <param name = "_parameters">
    /// The parameters to fetch the order originators information.
    /// </param>
    private static void validateOrderOriginatorParameters(CrtTransactionService.TransactionServiceOrderOriginatorParameters _parameters)
    {
        if (!_parameters)
        {
            throw error("@Retail:OrderOriginatorInvalidParameters");
        }

        RefRecId channelId = _parameters.ChannelId;
        var transactionIds = _parameters.get_TransactionIds();
        var salesIds = _parameters.get_SalesIds();

        if (!channelId && transactionIds && transactionIds.get_Count() > 0)
        {
            throw error("@Retail:OrderOriginatorChannelParameterIsRequired");
        }

        System.Collections.IEnumerator transactionIdsEnumerator = transactionIds.GetEnumerator();
        while (transactionIdsEnumerator.MoveNext())
        {
            if (!transactionIdsEnumerator.get_Current())
            {
                throw error("@Retail:OrderOriginatorTransactionIdsHasNullOrEmptyValue");
            }
        }

        System.Collections.IEnumerator salesIdsEnumerator = salesIds.GetEnumerator();
        while (salesIdsEnumerator.MoveNext())
        {
            if (!salesIdsEnumerator.get_Current())
            {
                throw error("@Retail:OrderOriginatorSalesIdsHasNullOrEmptyValue");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderOriginatorEntities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a list of order originators.
    /// </summary>
    /// <param name = "_parameters">
    /// The parameters to fetch the order originators information.
    /// </param>
    /// <returns>
    /// The list of order originator entities.
    /// </returns>
    private static System.Collections.ArrayList getOrderOriginatorEntities(CrtTransactionService.TransactionServiceOrderOriginatorParameters _parameters)
    {
        var orderOriginators = RetailTransactionServiceTransactions::getOrderOriginatorEntitiesByTransactionIds(_parameters);
        var orderOriginatorsBySalesId = RetailTransactionServiceTransactions::getOrderOriginatorEntitiesBySalesIds(_parameters);
        orderOriginators.AddRange(orderOriginatorsBySalesId);
        return orderOriginators;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderOriginatorEntitiesByTransactionIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of order originators using transaction ids.
    /// </summary>
    /// <param name = "_parameters">
    /// The parameters to be used to fetch the order originators information.
    /// </param>
    /// <returns>
    /// The list of order originator entities.
    /// </returns>
    private static System.Collections.ArrayList getOrderOriginatorEntitiesByTransactionIds(CrtTransactionService.TransactionServiceOrderOriginatorParameters _parameters)
    {
        DirPartyTable dirPartyTable;
        HCMWorker hcmWorker;
        Set uniqueTransactionIds = new Set(Types::String);

        System.Collections.ArrayList orderOriginators = new System.Collections.ArrayList();

        var transactionIds = _parameters.get_TransactionIds();
        if (transactionIds.get_Count() > 0)
        {
            // Using the same logic used to retrieve the order details by transaction id
            // Start with the basic Journal query
            Query query = new Query(queryStr(RetailJournalListQuery));

            // Add filters/ranges to the data source
            QueryBuildDataSource qbds = query.dataSourceTable(tableNum(RetailTransactionTable));

            // Include Transactions of status CreatingOrder. Base query already includes: None, Posted.
            qbds.addRange(fieldNum(RetailTransactionTable, EntryStatus)).value(QueryValue(RetailEntryStatus::CreatingOrder));

            // Include types: Sales, Customer order, Customer quote, Online order, Async Customer order, Async Customer quote
            qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::AsyncCustomerOrder));
            qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::AsyncCustomerQuote));
            qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::CustomerOrder));     // Customer Order & Quote
            qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::Sales));
            qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::PendingSalesOrder));  // Online orders

            qbds.addRange(fieldNum(RetailTransactionTable, Channel)).value(int642Str(_parameters.ChannelId));

            System.Collections.IEnumerator transactionIdsEnumerator = transactionIds.GetEnumerator();
            while (transactionIdsEnumerator.MoveNext())
            {
                str currentValue = transactionIdsEnumerator.get_Current();
                qbds.addRange(fieldNum(RetailTransactionTable, TransactionID)).value(queryValue(currentValue));
            }

            QueryRun qr = new QueryRun(query);
            while (qr.next())
            {
                RetailTransactionTable retailTransactionTable = qr.get(tableNum(RetailTransactionTable));

                if (uniqueTransactionIds.in(retailTransactionTable.transactionId))
                {
                    throw error("@Retail:OrderOriginatorMultipleTransactionsFoundWithSameTransactionId");
                }
                uniqueTransactionIds.add(retailTransactionTable.transactionId);

                var orderOriginator = new CrtOrderOriginator();
                orderOriginator.TransactionId = retailTransactionTable.transactionId;

                if (retailTransactionTable.custAccount)
                {
                    orderOriginator.CustomerId = retailTransactionTable.custAccount;

                    DirPartyTable partyTable = DirPartyTable::findRec(CustTable::find(retailTransactionTable.custAccount).Party);
                    if (partyTable)
                    {
                        orderOriginator.CustomerName = partyTable.Name;
                    }
                }

                if (retailTransactionTable.staff)
                {
                    orderOriginator.StaffId = retailTransactionTable.staff;

                    select firstonly RecId, Name from dirPartyTable
                        join PersonnelNumber, Person from hcmWorker where
                            hcmWorker.PersonnelNumber == retailTransactionTable.staff && hcmWorker.Person == dirPartyTable.RecId;

                    if (dirPartyTable)
                    {
                        orderOriginator.StaffName = dirPartyTable.Name;
                    }
                }

                orderOriginators.Add(orderOriginator);
            }
        }

        return orderOriginators;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderOriginatorEntitiesBySalesIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of order originators using sales ids.
    /// </summary>
    /// <param name = "_parameters">
    /// The parameters to be used to fetch the order originators information.
    /// </param>
    /// <returns>
    /// The list of order originator entities.
    /// </returns>
    private static System.Collections.ArrayList getOrderOriginatorEntitiesBySalesIds(CrtTransactionService.TransactionServiceOrderOriginatorParameters _parameters)
    {
        SalesIdTempTable tmpTable;
        SalesTable salesTable;
        CustTable custTable;
        HcmWorker hcmWorker;
        RetailStaffTable retailStaffTable;
        DirPartyTable custDirPartyTable, workerDirPartyTable;

        System.Collections.ArrayList orderOriginators = new System.Collections.ArrayList();

        var salesIds = _parameters.get_SalesIds();
        if (salesIds.get_Count() > 0)
        {
            System.Collections.IEnumerator salesIdsEnumerator = salesIds.GetEnumerator();
            while (salesIdsEnumerator.MoveNext())
            {
                tmpTable.SalesId = salesIdsEnumerator.get_Current();
                tmpTable.insert();
            }

            while select SalesId, CustAccount, WorkerSalesResponsible from salesTable
                join tmpTable
                    where tmpTable.SalesId == salesTable.SalesId
                outer join AccountNum, Party from custTable
                    where custTable.AccountNum == salesTable.CustAccount
                outer join RecId, Name from custDirPartyTable
                    where custDirPartyTable.RecId == custTable.Party
                outer join RecId, Person, PersonnelNumber from hcmWorker
                    where hcmWorker.RecId == salesTable.WorkerSalesResponsible
                outer join StaffId from retailStaffTable
                    where retailStaffTable.StaffId == hcmWorker.PersonnelNumber
                outer join RecId, Name from workerDirPartyTable
                    where workerDirPartyTable.RecId == hcmWorker.Person
            {
                var orderOriginator = new CrtOrderOriginator();
                orderOriginator.SalesId = salesTable.SalesId;
                orderOriginator.CustomerId = salesTable.CustAccount;
                orderOriginator.CustomerName = custDirPartyTable.Name;
                orderOriginator.StaffId = retailStaffTable.StaffId;
                orderOriginator.StaffName = workerDirPartyTable.Name;
                orderOriginators.Add(orderOriginator);
            }
        }

        return orderOriginators;
    }

]]></Source>
			</Method>
			<Method>
				<Name>serializeOrderOriginators</Name>
				<Source><![CDATA[
    /// <summary>
    /// Serialize the a list of order originators to JSON.
    /// </summary>
    /// <param name = "_orderOriginators">
    /// A list of order originator entities.
    /// </param>
    private static container serializeOrderOriginators(System.Collections.ArrayList _orderOriginators)
    {
        str results;
        System.Exception ex;

        try
        {
            // Serialize the list of OrderOriginator to JSON
            System.Type[] typeArray = new System.Type[1](); // create the type array with only one element.
            System.Type sourceDocumentType = new CrtOrderOriginator().GetType();
            typeArray.SetValue(sourceDocumentType, 0); // define the CrtOrderOriginator as the array type.
            results = RetailTransactionServiceJsonHelper::SerializeToJson(_orderOriginators, typeArray);
        }
        catch (ex)
        {
            eventSource.EventWriteGetOrderOriginatorsSerializationError(funcName(), ex.GetType().ToString(), ex.ToString());
            return [false, "@Retail:OrderOriginatorSerializationError", ''];
        }

        return [true, '', results];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrdersByLookupCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get sales order order by transaction id or sales id with some details.
    /// </summary>
    /// <param name = "_lookupCriteriaJsonString">
    /// A JSON formatted string with the parameters to get the orders.
    /// </param>
    /// <returns>
    /// A JSON formatted string with a list of orders with some details.
    /// </returns>
    /// <remarks>
    /// Given current usage of this method, we are returning only line and shipments information.
    /// 
    /// Input JSON example:
    ///        {
    ///            "SalesOrderLookups":
    ///            [
    ///                {
    ///                    "__type":"SalesOrderLookupBySalesId:#Microsoft.Dynamics.Commerce.Runtime.DataModel",
    ///                    "ExtensionProperties":[],
    ///                    "SalesId":"SO-10291"
    ///                },
    ///                {
    ///                    "__type":"SalesOrderLookupByTransactionId:#Microsoft.Dynamics.Commerce.Runtime.DataModel",
    ///                    "ExtensionProperties":[],
    ///                    "TransactionId":"HOUSTON-HOUSTON-2-133",
    ///                    "StoreId":"HOUSTON",
    ///                    "TerminalId":"HOUSTON-2",
    ///                    "ChannelId":"5637144592"
    ///                }
    ///            ]
    ///        }
    /// </remarks>
    public static container getSalesOrdersByLookupCriteria(str _lookupCriteriaJsonString = '')
    {
        System.Exception ex;

        RetailTransactionResultListHelper resultHelper = new RetailTransactionResultListHelper(RetailTransactionServiceResultFormat::Json);

        try
        {
            var salesOrdersLookupCriteria = RetailTransactionServiceTransactions::getSalesOrdersLookupCriteria(_lookupCriteriaJsonString);

            CrtDataModel.SalesOrderLookupBySalesId SalesOrderLookupBySalesId = null;
            CrtDataModel.SalesOrderLookupByTransactionId SalesOrderLookupByTransactionId = null;
            System.Collections.IList lookupByTransactionId = new System.Collections.ArrayList();
            System.Collections.IList lookupBySalesId = new System.Collections.ArrayList();

            var salesOrderLookups = salesOrdersLookupCriteria.get_SalesOrderLookups();
            System.Collections.IEnumerator enumerator = salesOrderLookups.GetEnumerator();
            while (enumerator.MoveNext())
            {
                SalesOrderLookupBySalesId = enumerator.get_Current() as CrtDataModel.SalesOrderLookupBySalesId;
                if (SalesOrderLookupBySalesId)
                {
                    lookupBySalesId.Add(SalesOrderLookupBySalesId);
                    continue;
                }

                SalesOrderLookupByTransactionId = enumerator.get_Current() as CrtDataModel.SalesOrderLookupByTransactionId;
                if (SalesOrderLookupByTransactionId)
                {
                    lookupByTransactionId.Add(SalesOrderLookupByTransactionId);
                    continue;
                }
            }

            resultHelper = RetailTransactionServiceTransactions::getSalesOrderEntitiesByLookupCriteriaByTransactionIds(resultHelper, lookupByTransactionId);
            resultHelper = RetailTransactionServiceTransactions::getSalesOrderEntitiesByLookupCriteriaBySalesIds(resultHelper, lookupBySalesId);
        }
        catch (ex)
        {
            eventSource.EventWriteSalesOrdersLookupCriteriaValidationError(funcName(), ex.GetType().ToString(), ex.ToString());
            return [false, ex.Message, ''];
        }

        return [true, '', resultHelper.Serialize()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrdersLookupCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the lookup criteria and return error if not valid.
    /// </summary>
    /// <param name = "_salesOrdersLookupCriteria">
    /// The lookup criteria to fetch the orders.
    /// </param>
    /// <returns>
    /// The sales orders lookup criteria.
    /// </returns>
    private static CrtDataModel.SalesOrdersLookupCriteria getSalesOrdersLookupCriteria(str _lookupCriteriaJsonString)
    {
        if (!_lookupCriteriaJsonString)
        {
            throw error("@Retail:GetSalesOrdersByLookupCriteriaInvalidParameters");
        }

        CrtDataModel.SalesOrdersLookupCriteria salesOrdersLookupCriteria = RetailTransactionServiceJsonHelper::DeserializeSalesOrdersLookupCriteriaFromJSON(_lookupCriteriaJsonString);

        var salesOrderLookups = salesOrdersLookupCriteria.get_SalesOrderLookups();

        if (!salesOrderLookups)
        {
            throw error("@Retail:GetSalesOrdersByLookupCriteriaInvalidParameters");
        }

        System.Collections.IEnumerator enumerator = salesOrderLookups.GetEnumerator();
        while (enumerator.MoveNext())
        {
            if (!enumerator.get_Current())
            {
                throw error("@Retail:GetSalesOrdersByLookupCriteriaSalesOrderLookupsHasNullOrEmptyValue");
            }
        }

        return salesOrdersLookupCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderEntitiesByLookupCriteriaByTransactionIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of orders using transaction id lookup criteria.
    /// </summary>
    /// <param name = "_resultHelper">
    /// The helper that keeps orders and serialize them.
    /// </param>
    /// <param name = "_lookupByTransactionId">
    /// The list containing lookup criteria to fetch the orders by transaction id.
    /// </param>
    /// <returns>
    /// The helper that keeps orders and serializes them.
    /// </returns>
    private static RetailTransactionResultListHelper getSalesOrderEntitiesByLookupCriteriaByTransactionIds(RetailTransactionResultListHelper _resultHelper, System.Collections.IList _lookupByTransactionId)
    {
        RetailTransactionTable retailTransactionTable;
        RetailTransactionIdTempTable tmpTable;
        DirPartyTable partyTable;

        Set uniqueKeys = new Set(Types::String);

        if (_lookupByTransactionId.get_Count() > 0)
        {
            RecordInsertList tmpTableInsertList = new RecordInsertList(
                tableNum(RetailTransactionIdTempTable),
                true, // skip insert
                true, // skip database log
                true, // skip events
                true, // skip aos validation
                true, // skip RLS validation
                tmpTable); // buffer where records will be inserted

            System.Collections.IEnumerator enumerator = _lookupByTransactionId.GetEnumerator();
            while (enumerator.MoveNext())
            {
                CrtDataModel.SalesOrderLookupByTransactionId currentValue = enumerator.get_Current();
                tmpTable.clear();
                tmpTable.transactionId = currentValue.TransactionId;
                tmpTable.Channel = currentValue.ChannelId;
                tmpTable.store = currentValue.StoreId;
                tmpTable.terminal = currentValue.TerminalId;

                str key = strFmt('%1;%2;%3;%4', tmpTable.transactionId, tmpTable.Channel, tmpTable.store, tmpTable.terminal);
                if (!uniqueKeys.in(key))
                {
                    tmpTableInsertList.add(tmpTable);
                    uniqueKeys.add(key);
                }
            }
            tmpTableInsertList.insertDatabase();

            if (IncludeCashAndCarryTransactionsFromGetSalesOrdersByLookupCriteriaFlight::instance().isEnabled())
            {
                while select tmpTable
                join retailTransactionTable
                    where tmpTable.transactionId == retailTransactionTable.transactionId &&
                        tmpTable.channel == retailTransactionTable.channel &&
                        tmpTable.store == retailTransactionTable.store &&
                        tmpTable.terminal == retailTransactionTable.terminal &&
                        (
                            retailTransactionTable.entryStatus == RetailEntryStatus::None ||
                            retailTransactionTable.entryStatus == RetailEntryStatus::CreatingOrder ||
                            retailTransactionTable.entryStatus == RetailEntryStatus::Posted
                        )
                        && (
                            retailTransactionTable.type == RetailTransactionType::AsyncCustomerOrder ||
                            retailTransactionTable.type == RetailTransactionType::AsyncCustomerQuote ||
                            retailTransactionTable.type == RetailTransactionType::PendingSalesOrder  ||
                            retailTransactionTable.type == RetailTransactionType::Sales
                        )
                {
                    _resultHelper.AddSalesTransaction(retailTransactionTable, partyTable, true, false);
                }
            }
            else
            {
                while select tmpTable
                join retailTransactionTable
                    where tmpTable.transactionId == retailTransactionTable.transactionId &&
                        tmpTable.channel == retailTransactionTable.channel &&
                        tmpTable.store == retailTransactionTable.store &&
                        tmpTable.terminal == retailTransactionTable.terminal &&
                        (
                            retailTransactionTable.entryStatus == RetailEntryStatus::None ||
                            retailTransactionTable.entryStatus == RetailEntryStatus::CreatingOrder ||
                            retailTransactionTable.entryStatus == RetailEntryStatus::Posted
                        )
                        && (
                            retailTransactionTable.type == RetailTransactionType::AsyncCustomerOrder ||
                            retailTransactionTable.type == RetailTransactionType::AsyncCustomerQuote ||
                            retailTransactionTable.type == RetailTransactionType::PendingSalesOrder
                        )
                {
                    _resultHelper.AddSalesTransaction(retailTransactionTable, partyTable, true, false);
                }
            }
        }

        return _resultHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderEntitiesByLookupCriteriaBySalesIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the list of orders using sales id lookup criteria.
    /// </summary>
    /// <param name = "_resultHelper">
    /// The helper that keeps orders and serializes them.
    /// </param>
    /// <param name = "_lookupBySalesId">
    /// The list containing lookup criteria to fetch the orders by sales id.
    /// </param>
    /// <returns>
    /// The helper that keeps orders and serializes them.
    /// </returns>
    private static RetailTransactionResultListHelper getSalesOrderEntitiesByLookupCriteriaBySalesIds(RetailTransactionResultListHelper _resultHelper, System.Collections.IList _lookupBySalesId)
    {
        SalesIdTempTable tmpTable;
        SalesTable salesTable;
        RetailSalesTable retailSalesTable;
        CustTable custTable;
        RetailTransactionTable retailTransactionTable;

        Set uniqueKeys = new Set(Types::String);

        if (_lookupBySalesId.get_Count() > 0)
        {
            RecordInsertList tmpTableInsertList = new RecordInsertList(
                tableNum(SalesIdTempTable),
                true, // skip insert
                true, // skip database log
                true, // skip events
                true, // skip aos validation
                true, // skip RLS validation
                tmpTable); // buffer where records will be inserted

            System.Collections.IEnumerator enumerator = _lookupBySalesId.GetEnumerator();
            while (enumerator.MoveNext())
            {
                CrtDataModel.SalesOrderLookupBySalesId currentValue = enumerator.get_Current();
                tmpTable.clear();
                tmpTable.SalesId = currentValue.SalesId;

                if (!uniqueKeys.in(currentValue.SalesId))
                {
                    tmpTableInsertList.add(tmpTable);
                    uniqueKeys.add(currentValue.SalesId);
                }
            }
            tmpTableInsertList.insertDatabase();

            while select tmpTable
                join salesTable
                    where tmpTable.SalesId == salesTable.SalesId
                outer join retailSalesTable
                    where salesTable.RecId == retailSalesTable.SalesTable
            {
                _resultHelper.AddSalesOrder(salesTable, retailSalesTable, custTable, retailTransactionTable, true, false);
            }
        }

        return _resultHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesOrderLookupParameterFromJson</Name>
				<Source><![CDATA[
    private static CrtTransactionService.TransactionServiceSalesOrderParameters getSalesOrderLookupParameterFromJson(str _orderLookupParameters)
    {
        try
        {
            Assembly transactionServiceAssembly = Assembly::Load(TransactionServiceAssemblyName);
            System.Type searchCriteriaType = transactionServiceAssembly == null? null: transactionServiceAssembly.GetType(TransactionServiceSalesOrderParametersSearchCriteriaTypeName);

            Newtonsoft.Json.JsonSerializerSettings settings = new Newtonsoft.Json.JsonSerializerSettings();
            // Below two properties are needed for the scenario where HQ version of Retail binaries is ahead of client's version.
            settings.TypeNameHandling = Newtonsoft.Json.TypeNameHandling::Auto;
            settings.NullValueHandling = Newtonsoft.Json.NullValueHandling::Ignore;

            // Use parameterless private constructor
            settings.ConstructorHandling = Newtonsoft.Json.ConstructorHandling::AllowNonPublicDefaultConstructor;

            CrtTransactionService.TransactionServiceSalesOrderParameters salesOrderLookupParameter = Newtonsoft.Json.JsonConvert::DeserializeObject(_orderLookupParameters, searchCriteriaType, settings);

            return salesOrderLookupParameter;
        }
        catch
        {
            eventSource.EventWriteGetSalesOrderDetailsByChannelReferenceIdInputDeserializationFailed();
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupOrderDetailsBySalesId</Name>
				<Source><![CDATA[
    private static container lookupOrderDetailsBySalesId(SalesId _salesId)
    {
        XmlDocument xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        List        xmlList = new List(Types::Class);
        container   output = [false, ''];

        try
        {
            if (_salesId)
            {
                SalesTable salesTable = SalesTable::find(_salesId);
                DirPartyTable   partyTable = DirPartyTable::findRec(CustTable::find(salestable.CustAccount).Party);

                using (RetailTransactionSerializationContext context = RetailTransactionSerializationContext::construct())
                {
                    context.parmIncludeAttributeValues(true);
                    RetailTransactionServiceTransactions::addSalesOrderToResultMap(
                    xmlList,
                    xmlDoc,
                    salesTable,
                    partyTable,
                    true,   //includeDetails,
                    true,   //includeDiscountLines
                    #ElementSalesOrder);
                }
            }

            xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
            output = [true, '', xmlDoc.toString()];
        }
        catch (Exception::Error)
        {
            str error = infolog.text(Global::infologLine());
            eventSource.EventWriteOrdersGetSalesOrderDetailsBySalesIdError(funcName());
            output = [false, error];
        }
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupOrderDetailsByChannelReferenceId</Name>
				<Source><![CDATA[
    private static container lookupOrderDetailsByChannelReferenceId(RetailOrderChannelReferenceId _channelReferenceId, RefRecId _channelId)
    {
        XmlDocument xmlDoc = RetailTransactionServiceTransactions::getNewXmlDoc();
        List        xmlList = new List(Types::Class);
        container   output = [false, ''];

        try
        {

            if (_channelReferenceId && _channelId)
            {

                // Start with the basic Journal query
                Query query = new Query(queryStr(RetailJournalListQuery));

                // Add filters/ranges to the data source
                QueryBuildDataSource qbds = query.dataSourceTable(tableNum(RetailTransactionTable));

                // Include types: Sales, Customer order, Customer quote, Online order, Async Customer order, Async Customer quote
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::AsyncCustomerOrder));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::AsyncCustomerQuote));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::CustomerOrder));  // Customer Order & Quote
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::Sales));
                qbds.addRange(fieldNum(RetailTransactionTable, Type)).value(QueryValue(RetailTransactionType::PendingSalesOrder));  // Online orders

                qbds.addRange(fieldNum(RetailTransactionTable, ChannelReferenceId)).value(_channelReferenceId); //ConfirmationId
                qbds.addRange(fieldNum(RetailTransactionTable, Channel)).value(Int642Str(_channelId));            //ChannelId

                QueryRun qr = new QueryRun(query);
                while (qr.next())
                {
                    RetailTransactionTable transactionTable = qr.get(tableNum(RetailTransactionTable));
                    DirPartyTable   partyTable = DirPartyTable::findRec(CustTable::find(transactionTable.CustAccount).Party);

                    RetailTransactionServiceTransactions::addTransactionToResultMap(
                    xmlList,
                    xmlDoc,
                    transactionTable,
                    partyTable,
                    true,   //includeDetails,
                    true,   //includeDiscountLines
                    true,   //includeTaxLines
                    #ElementSalesOrder,
                    true);  //includeAttributes
                }
            }

            xmlDoc = RetailTransactionServiceTransactions::AppendSalesOrdersToXmlDocument(xmlDoc, xmlList);
            output = [true, '', xmlDoc.toString()];
        }
        catch (Exception::Error)
        {
            str error = infolog.text(Global::infologLine());
            eventSource.EventWriteGetSalesOrderDetailsByChannelReferenceIdError(funcName());
            output = [false, error];
        }
        return output;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllPaymentsMadeFromPOS</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method checks wheather all payments were made from POS or not.
    /// </summary>
    /// <param name = "_salesId">
    /// Sales order ID for which we are checking transaction count.
    /// </param>
    /// <returns>
    /// True, if number of payments made from POS greater than or equal to payments made on HQ. Else, false.
    /// </returns>
    private static boolean isAllPaymentsMadeFromPOS(SalesId _salesId)
    {
        RetailTransactionPaymentTrans tmpPaymentTrans;
        RetailTransactionTable transactionTable;
        MCRCustPaymTable mcrCustPaynTableLoc;
        LedgerJournalTrans  ledgerJournalTrans;
        boolean isAllPOSPayments = true;

        if (RetailGetPaymentHistoryFromPOSFlight::instance().isEnabled())
        {
            // Get POS transaction count.
            select count(RecId) from tmpPaymentTrans
                exists join transactionTable
                where transactionTable.salesOrderId == _salesId
                   && tmpPaymentTrans.Channel == transactionTable.Channel
                   && tmpPaymentTrans.store == transactionTable.store
                   && tmpPaymentTrans.terminal == transactionTable.terminal
                   && tmpPaymentTrans.transactionId == transactionTable.transactionId;

            // Get total transaction count for a given sales order.
            select count(RecId) from mcrCustPaynTableLoc
                exists join ledgerJournalTrans
                where ledgerJournalTrans.MCRRefPaymID == mcrCustPaynTableLoc.RecId
                   && ledgerJournalTrans.MCRPaymOrderID == _salesId
                   && ledgerJournalTrans.TransactionType == LedgerTransType::Payment;

            if (tmpPaymentTrans.RecId < mcrCustPaynTableLoc.RecId)
            {
                isAllPOSPayments = false;
            }
        }

        return isAllPOSPayments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addNotes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Appends <c>Note</c> information to the <paramref name="_xmlDoc"/>< with data from <c>DocuRef</c> table.
    /// </summary>
    /// <param name = "xmlDoc">The XML document.</param>
    /// <param name = "_recId">The retail order header record id.</param>
    /// <param name = "_tableId">The retail order header table id.</param>
    /// <param name = "_dataAreaId">The data area id.</param>
    private static XmlElement addNotes(XmlDocument _xmlDoc, RefRecId _recId, TableId _tableId, DataAreaId _dataAreaId)
    {
        XmlElement xmlRecord, xmlRoot, xmlContainer;
        DocuRef docuRef;

        xmlContainer = _xmlDoc.createElement('Notes');

        // Ideally this query should leverage DOCUREF table REFIDX.
        // PARTITION, REFCOMPANYID, REFTABLEID, REFRECID, CREATEDDATETIME, CREATEDBY
        while select RecId, Name, Notes, Restriction
            from docuRef
            order by DocuRef.CreatedDateTime desc
            where docuRef.TypeId == DocuType::typeNote()
                && docuRef.RefTableId == _tableId
                && docuRef.RefRecId == _recId
                && docuRef.RefCompanyId == _dataAreaId
        {
            // 'Note' XML maps to 'Note' CRT Entity.
            xmlRoot = _xmlDoc.createElement('Note');

            xmlRecord = _xmlDoc.createElement('Description');
            xmlRecord.innerText(docuRef.Notes);
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('DocuRefRecId');
            xmlRecord.innerText(int642Str(docuRef.RecId));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('RestrictionValue');
            xmlRecord.innerText(int2Str(enum2int(docuRef.Restriction)));
            xmlRoot.appendChild(xmlRecord);

            xmlRecord = _xmlDoc.createElement('Title');
            xmlRecord.innerText(docuRef.Name);
            xmlRoot.appendChild(xmlRecord);

            xmlContainer.appendChild(xmlRoot);
        }

        return xmlContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSalesLineAdjustmentPriceDetails</Name>
				<Source><![CDATA[
    internal static XmlElement fillSalesLineAdjustmentPriceDetails(
        XmlDocument _xmlDoc,
        RetailSalesPriceAdjustmentLineMap _retailSalesPriceAdjustmentLineMap,
        LineNum _lineNum)
    {
        XmlElement xmlRecord, xmlEntry;
        xmlRecord = _xmlDoc.createElement(RetailTransactionTransformerHelper::getPriceLineStr());

        xmlEntry = _xmlDoc.createElement(RetailTransactionTransformerHelper::getPriceTypeStr());
        xmlEntry.innerText(int2str(PriceLineType::PriceAdjustmentPriceLine));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(RetailTransactionTransformerHelper::getRecordIdStr());
        xmlEntry.innerText(int642str(_retailSalesPriceAdjustmentLineMap.RetailPeriodicDiscountLineRefRecId));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(RetailTransactionTransformerHelper::getSaleLineNumberStr());
        xmlEntry.innerText(RetailTransactionServiceUtilities::lineNumToString(_lineNum));
        xmlRecord.appendChild(xmlEntry);

        xmlEntry = _xmlDoc.createElement(RetailTransactionTransformerHelper::getValueStr());
        xmlEntry.innerText(RetailTransactionServiceUtilities::realToString(_retailSalesPriceAdjustmentLineMap.Amount));
        xmlRecord.appendChild(xmlEntry);
        return xmlRecord;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>