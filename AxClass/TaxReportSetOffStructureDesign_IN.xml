<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxReportSetOffStructureDesign_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Designs the structure for tax report set off structure.
/// </summary>
[TaxReportHrchyStructureAttribute_IN(TaxReportHrchyStructDesignType_IN::Setoff)]
public class TaxReportSetOffStructureDesign_IN extends TaxReportHrchyStructureDesign_IN
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateAllNodesSelfBalance</Name>
				<Source><![CDATA[
    public void calculateAllNodesSelfBalance(TaxSalesTaxPaymentHistory_IN _history,
                                             TaxSalesTaxPaymentProfile_IN _profile)
    {
        super(_history, _profile);

        if (_profile && _history)
        {
            //Calculate nodes which are used for specified period and registration number, TaxPeriod takes a key role to select transTrans
            this.calculateNodesSelfBalanceForTaxRegNumber(_history, _profile);

            //Calculate nodes for trans that are in the TaxRegGroup
            this.calculateNodesSelfBalanceForTaxRegGroup(_history, _profile);

            //Update tax registration number
            this.setHistoryNodeTaxRegNumber(_history);

            //Update node balance
            this.updateDetailsTransBalance(_history);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNodesSelfBalanceForTaxRegGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate ll <c>TaxReportHierarchyNode_IN</c> self balance for the specified TaxRegistrationGroup in the instance of <c>TaxSalesTaxPaymentProfile_IN</c>.
    /// </summary>
    /// <param name="_history">
    /// The instance of <c>TaxSalesTaxPaymentHistory_IN</c>.
    /// </param>
    /// <param name="_profile">
    /// The instance of <c>TaxSalesTaxPaymentHistory_IN</c>.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throw error if cannot find <c>TaxSalesTaxPaymentHistoryDetails_IN</c> record which should be created before this method is called.
    /// </exception>
    private void calculateNodesSelfBalanceForTaxRegGroup(TaxSalesTaxPaymentHistory_IN _history,
                                                         TaxSalesTaxPaymentProfile_IN _profile)
    {
        TaxTrans                                    taxTrans;
        TaxTrans_IN                                 taxTransIN;
        TaxRegistrationGroupSetup_IN                taxGroupSetup;
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetail;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;
        TaxReportPeriod_IN                          taxReportPeriodFromDate, taxReportPeriodToDate, taxReportPeriod;
        NoYes                                       mark = NoYes::Yes;
        TaxVersion                                  fromDateVersion, ToDateVersion;

        while select TaxRegistrationGroupName, TaxRegistrationNumberTable from taxGroupSetup
            where taxGroupSetup.TaxRegistrationGroupName == _profile.parmTaxRegistrationGroup().RecId
               && taxGroupSetup.TaxRegistrationNumberTable != _profile.parmTaxRegistrationNumber().RecId
        {
            fromDateVersion = -1;
            ToDateVersion = -1;

            select VersionNum, RecId from taxReportPeriod
                where taxReportPeriod.TaxRegistrationNumberTable   ==  taxGroupSetup.TaxRegistrationNumberTable
                   && taxReportPeriod.FromDate                     >=  _profile.taxPeriodFromDate()
                   && taxReportPeriod.ToDate                       <=  _profile.taxPeriodToDate();

            select VersionNum, RecId from taxReportPeriodFromDate
                where taxReportPeriodFromDate.TaxRegistrationNumberTable   ==  taxGroupSetup.TaxRegistrationNumberTable
                   && taxReportPeriodFromDate.FromDate                     <=  _profile.taxPeriodFromDate()
                   && taxReportPeriodFromDate.ToDate                       >=  _profile.taxPeriodFromDate();

            select VersionNum, RecId from taxReportPeriodToDate
                where taxReportPeriodToDate.TaxRegistrationNumberTable   ==  taxGroupSetup.TaxRegistrationNumberTable
                   && taxReportPeriodToDate.FromDate                     <=  _profile.taxPeriodToDate()
                   && taxReportPeriodToDate.ToDate                       >=  _profile.taxPeriodToDate();

            if (taxReportPeriod.RecId == 0 && taxReportPeriodFromDate.RecId == 0 && taxReportPeriodToDate.RecId == 0)
            {
                fromDateVersion = 0;
                ToDateVersion = 0;
            }
            else
            {
                if (taxReportPeriod.RecId)
                {
                    fromDateVersion = taxReportPeriod.VersionNum;
                    ToDateVersion = taxReportPeriod.VersionNum;
                }

                if (taxReportPeriodFromDate.RecId)
                {
                    fromDateVersion = taxReportPeriodFromDate.VersionNum;
                }

                if (taxReportPeriodToDate.RecId)
                {
                    ToDateVersion = taxReportPeriodToDate.VersionNum;
                }
            }

            //New trans in current period
            insert_recordset detailTrans
                (Mark, TaxCode, TaxType, Source, Voucher, TransDate, TaxRegistrationNumbers_IN, TaxTrans_IN, TaxSalesTaxPaymentHistoryDetails_IN)
            select mark, TaxCode, TaxType, Source, Voucher, TransDate, CompanyRegistrationNumber, RecId
                from taxTransIN
                    where taxTransIN.Source    != TaxModuleType::Tax
                     &&   taxTransIN.CompanyRegistrationNumber == taxGroupSetup.TaxRegistrationNumberTable
                     &&   taxTransIN.TaxReportHierarchyNode_IN != 0
                     &&   taxTransIN.PostedTaxAmout != 0
                     &&   taxTransIN.TransDate >= _profile.taxPeriodFromDate()
                     &&   taxTransIN.TransDate <= _profile.taxPeriodToDate()
                     &&   taxTransIN.TaxReportPeriod_IN == 0
                join taxTrans
                    where taxTrans.RecId == taxTransIN.RefRecId
                    &&    (taxTrans.TaxRepCounter  == fromDateVersion
                    ||    taxTrans.TaxRepCounter  == ToDateVersion)
                    &&   (taxTransIN.TaxType != TaxType_IN::GST
                            || (taxTrans.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                                || taxTrans.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable))
                join RecId from historyDetail
                    where taxTransIN.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN
                    &&  historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

            if (TaxParameters::find().ReportAdjustment)
            {
                //Previous unsettled/partially settled trans
                insert_recordset detailTrans
                    (Mark, TaxCode, TaxType, Source, Voucher, TransDate, TaxRegistrationNumbers_IN, TaxTrans_IN, TaxSalesTaxPaymentHistoryDetails_IN)
                select mark, TaxCode, TaxType, Source, Voucher, TransDate, CompanyRegistrationNumber, RecId
                    from taxTransIN
                        where taxTransIN.Source    != TaxModuleType::Tax
                            && taxTransIN.CompanyRegistrationNumber == taxGroupSetup.TaxRegistrationNumberTable
                            && taxTransIN.TaxReportHierarchyNode_IN != 0
                            && taxTransIN.PostedTaxAmout != 0
                            && taxTransIN.TransDate < _profile.taxPeriodFromDate()
                            && taxTransIN.TaxReportPeriod_IN == 0
                            && (!TaxFilterReportAdjustmentWithTaxAccountType_INFlight::instance().isEnabled()
                                || (taxTransIN.TaxType != TaxType_IN::GST
                                    || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                                        || taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable)))
                    join RecId from historyDetail
                        where taxTransIN.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN
                        &&  historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNodesSelfBalanceForTaxRegNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate ll <c>TaxReportHierarchyNode_IN</c> self balance for the specified TaxRegistrationNumber in the instance of <c>TaxSalesTaxPaymentProfile_IN</c>.
    /// </summary>
    /// <param name="_history">
    /// The instance of <c>TaxSalesTaxPaymentHistory_IN</c>.
    /// </param>
    /// <param name="_profile">
    /// The instance of <c>TaxSalesTaxPaymentHistory_IN</c>.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throw error if cannot find <c>TaxSalesTaxPaymentHistoryDetails_IN</c> record which should be created before this method is called.
    /// </exception>
    private void calculateNodesSelfBalanceForTaxRegNumber(TaxSalesTaxPaymentHistory_IN _history,
                                                          TaxSalesTaxPaymentProfile_IN _profile)
    {
        TaxTrans                                    taxTrans;
        TaxTrans_IN                                 taxTransIN;
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetail;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;
        Counter                                     counterMin, counterMax;
        NoYes                                       mark = NoYes::Yes;

        counterMin = TaxSalesTaxPaymentFacade_IN::counterMin(
                            _profile.parmTaxRepVersion(),
                            _profile.parmTaxPeriod(),
                            _profile.parmTaxRegistrationNumber().RecId,
                            _profile.taxPeriodFromDate());

        counterMax = TaxSalesTaxPaymentFacade_IN::counterMax(
                            _profile.parmTaxRepVersion(),
                            _profile.parmTaxPeriod(),
                            _profile.parmTaxRegistrationNumber().RecId,
                            _profile.taxPeriodFromDate());

        //New trans in current period
        insert_recordset detailTrans
            (Mark, TaxCode, TaxType, Source, Voucher, TransDate, TaxRegistrationNumbers_IN, TaxTrans_IN, TaxSalesTaxPaymentHistoryDetails_IN)
        select mark, TaxCode, TaxType, Source, Voucher, TransDate, CompanyRegistrationNumber, RecId
           from taxTransIN
               where taxTransIN.TaxPeriod == _profile.parmTaxPeriod()
                &&   taxTransIN.CompanyRegistrationNumber == _profile.parmTaxRegistrationNumber().RecId
                &&   taxTransIN.Source    != TaxModuleType::Tax
                &&   taxTransIN.TaxReportHierarchyNode_IN != 0
                &&   taxTransIN.PostedTaxAmout != 0
                &&   taxTransIN.TransDate >= _profile.taxPeriodFromDate()
                &&   taxTransIN.TransDate <= _profile.taxPeriodToDate()
               join taxTrans
                   where taxTrans.RecId == taxTransIN.RefRecId
                    &&   taxTrans.TaxRepCounter  >= counterMin
                    &&   taxTrans.TaxRepCounter  <= counterMax
                    &&   (taxTransIN.TaxType != TaxType_IN::GST
                            || (taxTrans.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                                || taxTrans.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable))
               join RecId from historyDetail
                   where taxTransIN.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN
                    &&   historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        if (TaxParameters::find().ReportAdjustment)
        {
            //Previous unsettled/partially settled trans
            insert_recordset detailTrans
                (Mark, TaxCode, TaxType, Source, Voucher, TransDate, TaxRegistrationNumbers_IN, TaxTrans_IN, TaxSalesTaxPaymentHistoryDetails_IN)
            select mark, TaxCode, TaxType, Source, Voucher, TransDate, CompanyRegistrationNumber, RecId
                from taxTransIN
                    where taxTransIN.Source    != TaxModuleType::Tax
                    && taxTransIN.CompanyRegistrationNumber == _profile.parmTaxRegistrationNumber().RecId
                    && taxTransIN.TaxReportHierarchyNode_IN != 0
                    && taxTransIN.PostedTaxAmout != 0
                    && taxTransIN.TransDate < _profile.taxPeriodFromDate()
                    && taxTransIN.TaxReportPeriod_IN == 0
                    && taxTransIN.TaxPeriod == _profile.parmTaxPeriod()
                    && (!TaxFilterReportAdjustmentWithTaxAccountType_INFlight::instance().isEnabled()
                        || (taxTransIN.TaxType != TaxType_IN::GST
                            || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                                || taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable)))
                    join RecId from historyDetail
                        where taxTransIN.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN
                        &&   historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTaxReportHrchyNodeForTrans</Name>
				<Source><![CDATA[
    public RefRecId findTaxReportHrchyNodeForTrans(Common _record, TaxReportHierarchyVersion_IN _hierarchyVersion = null)
    {
        TaxReportHrchyRootNode_IN               rootNode;
        TaxReportHierarchyNode_IN               tableNode;
        RecId                                   tableNodeRecId;
        TaxReportHrchyNodeComboDisplayValue_IN  message;
        container                               cachedResult;
        TaxReportHierarchy_IN                   setoffHierarchy;
        TaxReportHierarchyVersion_IN            hierarchyVersion;
        TaxTrans_IN                             taxTrans = _record as TaxTrans_IN;
        TaxReportHrchyNodeComboDisplayValue_IN  nodeDisplayValue;

        TaxReportHrchyStructDesignType_IN taxReportHrchyStructDesignType = taxTrans.TaxType 
            == TaxType_IN::GST || (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && taxTrans.TaxType == TaxType_IN::VAT)
            ? TaxReportHrchyStructDesignType_IN::GTE : TaxReportHrchyStructDesignType_IN::Setoff;

        if (!_hierarchyVersion)
        {
            hierarchyVersion = TaxReportSetoffHrchySetupHelper_IN::findSetOffHierarchyVersion(taxTrans.TransDate, taxReportHrchyStructDesignType);
        }
        else
        {
            hierarchyVersion = _hierarchyVersion;
        }

        setoffHierarchy = TaxReportHierarchy_IN::find(hierarchyVersion.TaxReportHierarchy_IN);

        if (hierarchyVersion.RecId)
        {
            rootNode = TaxReportHierarchyHelper_IN::findRootNode(hierarchyVersion.RecId);
            message = this.getTransComboDisplayValue(rootNode, _record);
            nodeDisplayValue = this.getDisplayCombination(taxTrans);

            Debug::assert(message != '');

            //Try to find from cache first
            cachedResult = TaxReportCache_IN::getValue(TaxReportCacheScope_IN::ComboDisplayValueNodeRecId, [message]);
            if (cachedResult == conNull())
            {
                //Find from Table
                select firstonly ComboDisplayValue, RecId
                from tableNode
                    where tableNode.TaxReportHierarchyVersion_IN == rootNode.parmTaxReportHierarchyVersion()
                    && tableNode.ComboDisplayValue == message
                    && tableNode.CanMatch == NoYes::Yes
                    && tableNode.Enable == NoYes::Yes;

                if (tableNode.RecId)
                {
                    tableNodeRecId = tableNode.RecId;
                    cachedResult = [tableNodeRecId];
                    TaxReportCache_IN::insertValue(TaxReportCacheScope_IN::ComboDisplayValueNodeRecId, [message], cachedResult);
                }
                else
                {
                    throw error(strFmt(
                        "@ErrorInfoForSetoffHrchySetup:TaxComponentNotFound",
                        nodeDisplayValue,
                        setoffHierarchy.Name,
                        hierarchyVersion.Version));
                }
            }
            else
            {
                tableNodeRecId = conPeek(cachedResult, 1);
            }
        }

        return tableNodeRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLevelNodeClass</Name>
				<Source><![CDATA[
    protected ClassId getNextLevelNodeClass(boolean _isRoot = false)
    {
        ClassId                              nextLevelClass;
        TaxReportHrchyTableNode_IN           componentNode;
        TaxComponentTable_IN                 taxComponentTable;

        if (_isRoot)
            return classNum(TaxReportHrchyRootNode_IN);

        switch (this.parmCurrentNode().parmClassId())
        {
            case classNum(TaxReportHrchyRootNode_IN):
                nextLevelClass = classNum(TaxReportHrchyTaxTypeNode_IN);
                break;

            case classNum(TaxReportHrchyTaxTypeNode_IN):
                nextLevelClass = classNum(TaxReportHrchyTaxComponentNode_IN);
                break;

            case classNum(TaxReportHrchyTaxComponentNode_IN):
                componentNode = this.parmCurrentNode() as TaxReportHrchyTaxComponentNode_IN;

                if (!componentNode)
                {
                    componentNode = this.parmCurrentNode() as TaxReportHrchyTableNode_IN;
                }

                select firstOnly RecId, TaxType from taxComponentTable
                    where taxComponentTable.RecId == componentNode.parmRefTableRecId()
                    &&  (taxComponentTable.TaxType == TaxType_IN::Excise
                        || taxComponentTable.TaxType == TaxType_IN::ServiceTax);

                switch (taxComponentTable.TaxType)
                {
                    case TaxType_IN::Excise:
                        nextLevelClass = classNum(TaxReportHrchyExciseRecordTypeNode_IN);
                        break;

                    case TaxType_IN::ServiceTax:
                        nextLevelClass = classNum(TaxReportHrchyServAcctCodeNode_IN);
                        break;

                    default:
                        nextLevelClass = classNum(TaxReportHrchyNode_IN);
                        break;
                }
                break;

            default:
                 nextLevelClass = classNum(TaxReportHrchyNode_IN);
                 break;
        }

        return nextLevelClass;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLevelNodes</Name>
				<Source><![CDATA[
    public List getNextLevelNodes(TaxReportHrchyNode_IN _currentNode, boolean _isRoot = false)
    {
        List nodeValues = super(_currentNode);

        switch (this.getNextLevelNodeClass(_isRoot))
        {
            case classNum(TaxReportHrchyRootNode_IN):
                nodeValues = this.getNodesForRoot();
                break;

            case classNum(TaxReportHrchyTaxTypeNode_IN):
                nodeValues = this.getNodesForTaxType();
                break;

            case classNum(TaxReportHrchyTaxComponentNode_IN):
                nodeValues = this.getNodesForTaxComponent();
                break;

            case classNum(TaxReportHrchyExciseRecordTypeNode_IN):
                nodeValues = this.getNodesForExciseRecordType();
                break;

            case classNum(TaxReportHrchyServAcctCodeNode_IN):
                nodeValues = this.getNodesForServiceAccountingCode();
                break;

            default:
                break;
        }
        return nodeValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodesForExciseRecordType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all ExciseRecordType <c>TaxReportHrchyNode_IN</c> nodes of the <c>TaxReportHierarchy_IN</c> instance.
    /// </summary>
    /// <returns>
    /// The list of all <c>TaxReportHrchyNode_IN</c> nodes.
    /// </returns>
    private List getNodesForExciseRecordType()
    {
        List                                    nodeList = new List(Types::Class);
        TaxReportHrchyExciseRecordTypeNode_IN   node;
        DictEnum                                dictEnumExciseRecordType = new DictEnum(enumNum(ExciseRecordType_IN));
        int                                     counter;

        for (counter = 0; counter < dictEnumExciseRecordType.values(); counter++)
        {
            node = TaxReportHrchyExciseRecordTypeNode_IN::construct();
            node.parmRefEnumValue(dictEnumExciseRecordType.index2Value(counter));
            node.parmCanMatch(NoYes::Yes);
            if (dictEnumExciseRecordType.index2Value(counter) != ExciseRecordType_IN::RG23D)
            {
                node.parmCanSettle(NoYes::Yes);
            }
            nodeList.addEnd(node);
        }

        return nodeList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodesForServiceAccountingCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all ServiceAccountingCode <c>TaxReportHrchyNode_IN</c> nodes of the <c>TaxReportHierarchy_IN</c> instance.
    /// </summary>
    /// <returns>
    /// The list of all <c>TaxReportHrchyNode_IN</c> nodes.
    /// </returns>
    private List getNodesForServiceAccountingCode()
    {
        List                                nodeList = new List(Types::Class);
        TaxReportHrchyServAcctCodeNode_IN   node;
        ServiceCodeTable_IN                 serviceCodeTable;

        while select RecId, Name from serviceCodeTable order by serviceCodeTable.Name
        {
            node = TaxReportHrchyServAcctCodeNode_IN::construct();
            node.parmRefTableRecId(serviceCodeTable.RecId);
            node.parmCanMatch(NoYes::Yes);
            node.parmCanSettle(NoYes::Yes);
            nodeList.addEnd(node);
        }

        return nodeList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodesForTaxComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all TaxComponent <c>TaxReportHrchyNode_IN</c> nodes of the <c>TaxReportHierarchy_IN</c> instance.
    /// </summary>
    /// <returns>
    /// The list of all <c>TaxReportHrchyNode_IN</c> nodes.
    /// </returns>
    private List getNodesForTaxComponent()
    {
        List                                nodeList = new List(Types::Class);
        TaxReportHrchyEnumNode_IN        taxTypeNode;
        TaxComponentTable_IN                taxComponentTable;
        TaxReportHrchyTaxComponentNode_IN   node;
        DictEnum                            dictEnumTaxType = new DictEnum(enumNum(TaxType_IN));

        taxTypeNode = this.parmCurrentNode() as TaxReportHrchyTaxTypeNode_IN;

        if (!taxTypeNode)
        {
            taxTypeNode = this.parmCurrentNode() as TaxReportHrchyEnumNode_IN;
        }

        while select RecId, TaxType, Name from taxComponentTable
            order by taxComponentTable.Name
            where taxComponentTable.TaxType == taxTypeNode.parmRefEnumValue()
        {
            node = TaxReportHrchyTaxComponentNode_IN::construct();
            node.parmRefTableRecId(taxComponentTable.RecId);
            node.parmCanPost(NoYes::Yes);
            if (taxComponentTable.TaxType != TaxType_IN::Excise)
            {
                node.parmCanMatch(NoYes::Yes);
                node.parmCanSettle(NoYes::Yes);
            }
            nodeList.addEnd(node);
        }
        return nodeList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNodesForTaxType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get all TaxType <c>TaxReportHrchyNode_IN</c> nodes of the <c>TaxReportHierarchy_IN</c> instance.
    /// </summary>
    /// <returns>
    /// The list of all <c>TaxReportHrchyNode_IN</c> nodes.
    /// </returns>
    private List getNodesForTaxType()
    {
        List                            nodeList = new List(Types::Class);
        DictEnum                        dictEnumTaxType = new DictEnum(enumNum(TaxType_IN));
        TaxReportHrchyTaxTypeNode_IN    node;
        int                             counter;

        for (counter = 0; counter < dictEnumTaxType.values(); counter++)
        {
            switch (dictEnumTaxType.index2Value(counter))
            {
                case TaxType_IN::Excise:
                case TaxType_IN::SalesTax:
                case TaxType_IN::ServiceTax:
                case TaxType_IN::VAT:
                    node = TaxReportHrchyTaxTypeNode_IN::construct();
                    node.parmRefEnumValue(dictEnumTaxType.index2Value(counter));
                    nodeList.addEnd(node);
                    break;
                default:
                    break;
            }
        }

        return nodeList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransComboDisplayValue</Name>
				<Source><![CDATA[
    protected TaxReportHrchyNodeComboDisplayValue_IN getTransComboDisplayValue(TaxReportHrchyNode_IN _rootNode,
                                                                               Common _record)
    {
        TaxTrans_IN                             taxTrans = _record as TaxTrans_IN;
        TaxReportHrchyNodeComboDisplayValue_IN  message;
        str                                     reportCodeDelimiter = DimensionParameters::getDimensionSegmentDelimiter();

        //Root node message and Tax type message and tax component message
        message += int642str(_rootNode.parmRecId()) + reportCodeDelimiter + int2str(taxTrans.TaxType) + reportCodeDelimiter + int642str(taxTrans.TaxComponentTable);

        switch (taxTrans.TaxType)
        {
            //Excise record type message
            case TaxType_IN::Excise:
                message += reportCodeDelimiter + int2str(taxTrans.ExciseRecordType);
                break;

            //Service accounting code message
            case TaxType_IN::ServiceTax:
                if (taxTrans.ServiceCodeTable)
                {
                    message += reportCodeDelimiter + int642str(taxTrans.ServiceCodeTable);
                }
                break;

            default:
                break;
        }

        return message;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSetoffable</Name>
				<Source><![CDATA[
    public boolean isSetoffable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRefClassId</Name>
				<Source><![CDATA[
    public ClassId parmRefClassId()
    {
        return classNum(TaxReportSetOffStructureDesign_IN);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setHistoryNodeTaxRegNumber</Name>
				<Source><![CDATA[
    private void setHistoryNodeTaxRegNumber(TaxSalesTaxPaymentHistory_IN _history)
    {
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetailNew, historyDetail;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans;

        update_recordSet historyDetail
            setting TaxRegistrationNumbers_IN = detailTrans.TaxRegistrationNumbers_IN
                where historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId
                  &&  historyDetail.TaxRegistrationNumbers_IN == 0
            join TaxRegistrationNumbers_IN from detailTrans
                where detailTrans.TaxSalesTaxPaymentHistoryDetails_IN == historyDetail.RecId;

        //Create new historyDetail node if there are more than 1 taxTrans with different reg Number is associated to the node
        insert_recordset historyDetailNew (TaxSalesTaxPaymentHistory_IN, TaxReportHierarchyNode_IN, TaxRegistrationNumbers_IN)
            select TaxSalesTaxPaymentHistory_IN, TaxReportHierarchyNode_IN from historyDetail
                group by detailTrans.TaxRegistrationNumbers_IN, historyDetail.TaxSalesTaxPaymentHistory_IN, historyDetail.TaxReportHierarchyNode_IN
                where historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId &&
                      historyDetail.TaxRegistrationNumbers_IN != 0
            join TaxRegistrationNumbers_IN from detailTrans
                where detailTrans.TaxSalesTaxPaymentHistoryDetails_IN == historyDetail.RecId &&
                      detailTrans.TaxRegistrationNumbers_IN != historyDetail.TaxRegistrationNumbers_IN;

        //Update the detailTrans link to the new node
        update_recordSet detailTrans
            setting TaxSalesTaxPaymentHistoryDetails_IN = historyDetailNew.RecId
                join RecId, TaxSalesTaxPaymentHistory_IN, TaxRegistrationNumbers_IN, TaxReportHierarchyNode_IN from historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN &&
                      historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId &&
                      historyDetail.TaxRegistrationNumbers_IN != detailTrans.TaxRegistrationNumbers_IN
                join TaxSalesTaxPaymentHistory_IN, TaxReportHierarchyNode_IN, TaxRegistrationNumbers_IN, RecId
                    from historyDetailNew
                    where historyDetailNew.TaxSalesTaxPaymentHistory_IN == _history.RecId &&
                          historyDetailNew.TaxReportHierarchyNode_IN == historyDetail.TaxReportHierarchyNode_IN &&
                          historyDetailNew.TaxRegistrationNumbers_IN == detailTrans.TaxRegistrationNumbers_IN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDetailsTransBalance</Name>
				<Source><![CDATA[
    private void updateDetailsTransBalance(TaxSalesTaxPaymentHistory_IN _history)
    {
        TaxSalesTaxPaymentHistoryDetails_IN         historyDetail;
        TaxSalesTaxPaymentHistoryDetailsTrans_IN    detailTrans, detailTransTmp;
        TaxSalesTaxPaymentTaxAdjView_IN             taxAdjustView;
        TaxTrans_IN                                 taxTransIN;

        //Set Recoverable Amount from TaxTrans
        update_recordSet detailTrans
        setting RecoverableAmountMST = taxTransIN.PostedTaxAmout
            join taxTransIN
                where detailTrans.TaxTrans_IN == taxTransIN.RecId
                &&    !(TaxTransIN.TaxType == TaxType_IN::Excise && taxTransIN.DeferredAmount != 0)
                &&    !(taxTransIN.TaxType == TaxType_IN::VAT && taxTransIN.RetentionAmount != 0)
                &&    (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable
                        || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::None
                                && taxTransIN.TaxDirection == TaxDirection::IncomingTax))
            join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        update_recordSet detailTrans
        setting RecoverableAmountMST = taxTransIN.PostedTaxAmout - taxTransIN.DeferredAmount
            join taxTransIN
                where detailTrans.TaxTrans_IN == taxTransIN.RecId
                &&    (TaxTransIN.TaxType == TaxType_IN::Excise && taxTransIN.DeferredAmount != 0)
                &&    (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable
                        || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::None
                                && taxTransIN.TaxDirection == TaxDirection::IncomingTax))
            join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        update_recordSet detailTrans
        setting RecoverableAmountMST = taxTransIN.RetentionAmount
            join taxTransIN
                where detailTrans.TaxTrans_IN == taxTransIN.RecId
                &&    (taxTransIN.TaxType == TaxType_IN::VAT && taxTransIN.RetentionAmount != 0)
                &&    (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxRecoverable
                        || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::None
                                && taxTransIN.TaxDirection == TaxDirection::IncomingTax))
            join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        //Set Payable Amount from TaxTrans
        update_recordSet detailTrans
        setting PayableAmountMST = taxTransIN.PostedTaxAmout
            join taxTransIN
                where detailTrans.TaxTrans_IN == taxTransIN.RecId
                &&    !(TaxTransIN.TaxType == TaxType_IN::Excise && taxTransIN.DeferredAmount != 0)
                &&    !(taxTransIN.TaxType == TaxType_IN::VAT && taxTransIN.RetentionAmount != 0)
                &&    (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                        || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::None
                                && taxTransIN.TaxDirection == TaxDirection::OutgoingTax))
            join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        update_recordSet detailTrans
        setting PayableAmountMST = taxTransIN.PostedTaxAmout - taxTransIN.DeferredAmount
            join taxTransIN
                where detailTrans.TaxTrans_IN == taxTransIN.RecId
                &&    (TaxTransIN.TaxType == TaxType_IN::Excise && taxTransIN.DeferredAmount != 0)
                 &&    (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                        || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::None
                                && taxTransIN.TaxDirection == TaxDirection::OutgoingTax))
            join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        update_recordSet detailTrans
        setting PayableAmountMST = taxTransIN.RetentionAmount
            join taxTransIN
                where detailTrans.TaxTrans_IN == taxTransIN.RecId
                &&    (taxTransIN.TaxType == TaxType_IN::VAT && taxTransIN.RetentionAmount != 0)
                 &&    (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::TaxPayable
                        || (taxTransIN.TaxAccountType == TaxAccountingPostingAccountType::None
                                && taxTransIN.TaxDirection == TaxDirection::OutgoingTax))
            join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        //Set utilized amount (utilized amount + settled amount) from history
        detailTransTmp.setTmp();
        insert_recordset detailTransTmp
            (UtilizedRecoverableAmountMST, UtilizedPayableAmountMST, TaxTrans_IN, TaxSalesTaxPaymentHistoryDetails_IN)
        select sum(ComputedUtilizedRecoverableAmt), sum(ComputedUtilizedPayableAmt), TaxTrans_IN
            from taxAdjustView
                group by taxAdjustView.TaxTrans_IN, historyDetail.RecId
            join detailTrans
                where taxAdjustView.TaxTrans_IN ==  detailTrans.TaxTrans_IN
            join RecId from historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;

        update_recordSet detailTrans
        setting UtilizedRecoverableAmountMST = detailTransTmp.UtilizedRecoverableAmountMST,
                UtilizedPayableAmountMST = detailTransTmp.UtilizedPayableAmountMST
        join detailTransTmp
            where detailTrans.TaxTrans_IN == detailTransTmp.TaxTrans_IN &&
                  detailTrans.TaxSalesTaxPaymentHistoryDetails_IN == detailTransTmp.TaxSalesTaxPaymentHistoryDetails_IN;

        //Calculate Recoverable to Settle and Payable to settle amount
        update_recordSet detailTrans
        setting RecoverableAmountToSettle = detailTrans.RecoverableAmountMST - detailTrans.UtilizedRecoverableAmountMST,
                PayableAmountToSettle = detailTrans.PayableAmountMST - detailTrans.UtilizedPayableAmountMST
        join historyDetail
                where historyDetail.RecId == detailTrans.TaxSalesTaxPaymentHistoryDetails_IN
                   && historyDetail.TaxSalesTaxPaymentHistory_IN == _history.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDisplayCombination</Name>
				<Source><![CDATA[
    public TaxReportHrchyNodeComboDisplayValue_IN getDisplayCombination(Common _record)
    {
        TaxReportHrchyRootNode_IN               rootNode;
        TaxReportHierarchyVersion_IN            hierarchyVersion;
        TaxTrans_IN                             taxTrans = _record as TaxTrans_IN;
        TaxReportHrchyNodeComboDisplayValue_IN  displayValue;

        TaxReportHrchyStructDesignType_IN taxReportHrchyStructDesignType = taxTrans.TaxType 
            == TaxType_IN::GST || (TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && taxTrans.TaxType == TaxType_IN::VAT)
            ? TaxReportHrchyStructDesignType_IN::GTE : TaxReportHrchyStructDesignType_IN::Setoff;

        hierarchyVersion = TaxReportSetoffHrchySetupHelper_IN::findSetOffHierarchyVersion(taxTrans.TransDate, taxReportHrchyStructDesignType);

        if (hierarchyVersion.RecId)
        {
            rootNode = TaxReportHierarchyHelper_IN::findRootNode(hierarchyVersion.RecId);
            displayValue = this.getTransComboDisplayString(rootNode, _record);
        }

        return displayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransComboDisplayString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the Combination display string for the specified record.
    /// </summary>
    /// <param name="_rootNode">
    /// The root node <c>TaxReportHrchyNode_IN</c> of the <c>TaxReportHierarchy_IN</c> instance.
    /// </param>
    /// <param name="_record">
    /// The record of TaxTrans.
    /// </param>
    /// <returns>
    /// The combination display string for the specified record.
    /// </returns>
    protected TaxReportHrchyNodeComboDisplayValue_IN getTransComboDisplayString(TaxReportHrchyNode_IN _rootNode,
                                                                                Common _record)
    {
        TaxTrans_IN                             taxTrans = _record as TaxTrans_IN;
        TaxComponentTable_IN                    taxComponentTable_IN;
        TaxReportHrchyNodeComboDisplayValue_IN  message;
        str                                     reportCodeDelimiter = DimensionParameters::getDimensionSegmentDelimiter();
        str                                     componentName;
        DictEnum                                dictEnumTaxType = new DictEnum(enumNum(TaxType_IN));
        DictEnum                                dictEnumExciseRecordType = new DictEnum(enumNum(ExciseRecordType_IN));

        taxComponentTable_IN = TaxComponentTable_IN::find(taxTrans.TaxComponentTable);
        if (!taxComponentTable_IN.Name)
        {
            componentName = taxComponentTable_IN.Name;
        }
        else
        {
            componentName = taxComponentTable_IN.Component;
        }

        //Root node message and Tax type message and tax component message
        message += _rootNode.parmComboDisplayValueStr() + reportCodeDelimiter
            + dictEnumTaxType.index2Label(taxTrans.TaxType)
            + reportCodeDelimiter + componentName;

        switch (taxTrans.TaxType)
        {
            //Excise record type message
            case TaxType_IN::Excise:
                message += reportCodeDelimiter + dictEnumExciseRecordType.index2Label(taxTrans.ExciseRecordType);
                break;

            //Service accounting code message
            case TaxType_IN::ServiceTax:
                if(taxTrans.ServiceCodeTable)
                {
                    message += reportCodeDelimiter + ServiceCodeTable_IN::find(taxTrans.ServiceCodeTable).Name;
                }
                break;

            default:
                break;
        }

        return message;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>