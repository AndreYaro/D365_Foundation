<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendCalcVolumeVATCAC_ES</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Extracts the data from Customer/Vendor transactions
/// and loads  it into the Tax Report tables to be used by the <c>TaxReport347</c> report.
/// </summary>
public class CustVendCalcVolumeVATCAC_ES extends CustVendCalcVolume
{
    Map mapVATNumOld2NewSales;
    Map mapVATNumOld2NewPurch;
    Map mapTaxGroupIsValid;
    Map mapCustVendId2LastInvoiceVatNum;

    Set invalidVATNumbersSales;
    Set invalidVATNumbersPurch;
    Map mapVendYearCashAccountingRegimeEnabled;

    boolean groupRelatedVATNums;
    TaxRep347Year reportYear;

    boolean customerPrepayment;
    boolean vendorPrepayment;
    boolean vendInvoicePrevYear;

    str vendInvoiceJourPrev = 'VendInvoiceJourPrev';
	
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accumCustPaymentInCash</Name>
				<Source><![CDATA[
    private void accumCustPaymentInCash(
        TaxReport347Table _taxReport347Table,
        CustInvoiceJour _custInvoiceJour,
        CustSettlement _custSettlement,
        CustTrans _paymentCustTrans)
	{
		TaxReport347CashInvoiceYear cashInvoiceYear = year(_custInvoiceJour.InvoiceDate);
		boolean cashAccountingRegime = this.cashAccountingRegimeEnabled(SalesPurch::Sales, _custInvoiceJour.InvoiceAccount, _custInvoiceJour.InvoiceDate);

		CustTable custTable = CustTable::find(_custInvoiceJour.InvoiceAccount);

		VATNum vatNum = this.custInvoiceJourVATNum(_custInvoiceJour);

		select firstonly forupdate tmpCustVendVolume
            index hint TypeVATNumIdx
            where tmpCustVendVolume.SalesPurch          == SalesPurch::Sales
                && tmpCustVendVolume.vatNum             == vatNum
                && tmpCustVendVolume.CountryRegionId    == this.countryRegionId(_custInvoiceJour, custTable)
                && tmpCustVendVolume.CashInvoiceYear    == cashInvoiceYear
                && tmpCustVendVolume.ReverseCharge_ES   == NoYes::No
                && tmpCustVendVolume.CashAccountingRegime_ES == cashAccountingRegime;

		if (!tmpCustVendVolume)
		{
			tmpCustVendVolume.vatNum                    = vatNum;
			tmpCustVendVolume.SalesPurch                = SalesPurch::Sales;
			tmpCustVendVolume.AmountMST                 = 0;
			tmpCustVendVolume.AmountInCash              = 0;
			tmpCustVendVolume.CashInvoiceYear           = cashInvoiceYear;

			tmpCustVendVolume.CountryRegionId           = this.countryRegionId(_custInvoiceJour, custTable);
			tmpCustVendVolume.CountryRegionType         = IntrastatCountryRegionParameters::type(tmpCustVendVolume.CountryRegionId);
			tmpCustVendVolume.CountyId                  = this.countyId(_custInvoiceJour, custTable);
			tmpCustVendVolume.Name                      = this.name( custTable);
			tmpCustVendVolume.CashAccountingRegime_ES   = cashAccountingRegime;
		}

		if (!tmpCustVendVolume.CashInvoiceDate || _custInvoiceJour.InvoiceDate < tmpCustVendVolume.CashInvoiceDate)
		{
			tmpCustVendVolume.CashInvoiceDate = _custInvoiceJour.InvoiceDate;
		}

		// Payment customer transactions contain negative value in AmountMST column, so we need to inverse the sign
		tmpCustVendVolume.AmountInCash += -_custSettlement.SettleAmountMST;

		tmpCustVendVolume.write();
	}

]]></Source>
			</Method>
			<Method>
				<Name>accumPaymentsInCash</Name>
				<Source><![CDATA[
    /// <summary>
	/// Includes the customer cash payments from the specified fiscal year.
	/// </summary>
	/// <param name="_taxReport347Table">
	/// The taxreporttable record where the cash payments should be included.
	/// </param>
	/// <param name="_reportYear">
	/// Fiscal year when the cash payments occured.
	/// </param>
	public void accumPaymentsInCash(
        TaxReport347Table _taxReport347Table,
        TaxRep347Year _reportYear)
	{
		#TaxReport347

		CustTrans                           paymentCustTrans;
		CustTrans                           invoiceCustTrans;
		CustTrans                           prePaymentCustTrans;
		CustInvoiceJour                     custInvoiceJour;
		ProjInvoiceJour                     projInvoiceJour;
		CustSettlement                      custSettlement;
		TaxReport347Account                 taxReport347Account;

		GeneralJournalAccountEntry          generalJournalAccountEntry;
		SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
		DimensionAttributeValueCombination  dimensionAttributeValueCombination;

		TransDate                           reportYearStartDate = mkDate(1, 1, _reportYear);
		TransDate                           reportYearEndDate = mkDate(31, 12, _reportYear);

		while select paymentCustTrans
            where paymentCustTrans.Invoice == ''
                && paymentCustTrans.Prepayment == NoYes::No
                && paymentCustTrans.TransDate >= reportYearStartDate
                && paymentCustTrans.TransDate <= reportYearEndDate
            join custSettlement
                where custSettlement.TransRecId == paymentCustTrans.RecId
            join Invoice, Voucher, TransDate, AccountNum from invoiceCustTrans
                where invoiceCustTrans.Invoice != ''
                    && invoiceCustTrans.RecId == custSettlement.OffsetRecid
                    && invoiceCustTrans.TransDate >= #MinCashInvDate
                    && invoiceCustTrans.TransDate <= reportYearEndDate
            // Filter payments posted to cash accounts
		exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == paymentCustTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == paymentCustTrans.TransDate
            exists join generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
            exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            exists join taxReport347Account
                where taxReport347Account.MainAccount == dimensionAttributeValueCombination.MainAccount
		{
			if (this.taxGroupIsValid(invoiceCustTrans.Voucher, invoiceCustTrans.TransDate))
			{
				custInvoiceJour = CustInvoiceJour::findFromCustTrans(invoiceCustTrans.Invoice, invoiceCustTrans.TransDate, invoiceCustTrans.AccountNum);

				if (custInvoiceJour)
				{
					this.accumCustPaymentInCash(_taxReport347Table, custInvoiceJour, custSettlement, paymentCustTrans);
				}

				projInvoiceJour = ProjInvoiceJour::find(invoiceCustTrans.Invoice, invoiceCustTrans.TransDate);

				if (projInvoiceJour)
				{
					this.accumProjPaymentInCash(_taxReport347Table, projInvoiceJour, custSettlement, paymentCustTrans);
				}
			}
		}

		while select prePaymentCustTrans
            where prePaymentCustTrans.Invoice == ''
                && prePaymentCustTrans.Prepayment == NoYes::Yes
                && prePaymentCustTrans.TransDate >= reportYearStartDate
                && prePaymentCustTrans.TransDate <= reportYearEndDate
            // Filter payments posted to cash accounts
		exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == prePaymentCustTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == prePaymentCustTrans.TransDate
            exists join generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
            exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == generalJournalAccountEntry.LedgerDimension
            exists join taxReport347Account
                where taxReport347Account.MainAccount == dimensionAttributeValueCombination.MainAccount
		{
			if (this.taxGroupIsValid(prePaymentCustTrans.Voucher, prePaymentCustTrans.TransDate))
			{
				this.accumPrePayment(_taxReport347Table, prePaymentCustTrans);
			}
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>accumPrePayment</Name>
				<Source><![CDATA[
    private void accumPrePayment(
        TaxReport347Table _taxReport347Table,
        CustTrans _prePaymentCustTrans)
	{
		CustTable                   custTable;

		VATNum                      vatNum;
		LogisticsPostalAddress      postalAddress;
		boolean                     cashAccountingRegime = this.cashAccountingRegimeEnabled(
				SalesPurch::Sales,
				_prePaymentCustTrans.AccountNum,
				_prePaymentCustTrans.TransDate);
		TaxReport347CashInvoiceYear cashInvoiceYear = year(_prePaymentCustTrans.TransDate);

		NoYes                       isReverseCharge;

		custTable = CustTable::find(_prePaymentCustTrans.AccountNum);

		vatNum = custTable.vatNum;
		postalAddress = custTable.postalAddress();

		isReverseCharge = !cashAccountingRegime
				&& this.isReverseCharge(_prePaymentCustTrans.Voucher, _prePaymentCustTrans.TransDate);

		select firstonly forupdate tmpCustVendVolume
            index hint TypeVATNumIdx
            where tmpCustVendVolume.SalesPurch          == SalesPurch::Sales
                && tmpCustVendVolume.vatNum             == vatNum
                && tmpCustVendVolume.CountryRegionId    == postalAddress.CountryRegionId
                && tmpCustVendVolume.CashInvoiceYear    == cashInvoiceYear
                && tmpCustVendVolume.ReverseCharge_ES   == isReverseCharge
                && tmpCustVendVolume.CashAccountingRegime_ES == cashAccountingRegime;

		if (!tmpCustVendVolume)
		{
			tmpCustVendVolume.vatNum                    = vatNum;
			tmpCustVendVolume.SalesPurch                = SalesPurch::Sales;
			tmpCustVendVolume.AmountMST                 = 0;
			tmpCustVendVolume.AmountInCash              = 0;
			tmpCustVendVolume.CashInvoiceYear           = cashInvoiceYear;

			tmpCustVendVolume.CountryRegionId           = postalAddress.CountryRegionId;
			tmpCustVendVolume.CountryRegionType         = IntrastatCountryRegionParameters::type(postalAddress.CountryRegionId);
			tmpCustVendVolume.CountyId                  = postalAddress.County;

			tmpCustVendVolume.Name                      = this.name(custTable);

			tmpCustVendVolume.CashAccountingRegime_ES   = cashAccountingRegime;
			tmpCustVendVolume.ReverseCharge_ES          = isReverseCharge;
		}

		tmpCustVendVolume.AmountInCash -= _prePaymentCustTrans.AmountMST;

		tmpCustVendVolume.write();
	}

]]></Source>
			</Method>
			<Method>
				<Name>accumProjPaymentInCash</Name>
				<Source><![CDATA[
    private void accumProjPaymentInCash(
        TaxReport347Table _taxReport347Table,
        ProjInvoiceJour _projInvoiceJour,
        CustSettlement _custSettlement,
        CustTrans _paymentCustTrans)
	{
		CustTable                   custTable;
		ProjInvoiceTable            projInvoiceTable;

		VATNum                      vatNum;
		boolean                     cashAccountingRegime;

		TaxReport347CashInvoiceYear cashInvoiceYear = year(_projInvoiceJour.InvoiceDate);

		cashAccountingRegime = this.cashAccountingRegimeEnabled(
            SalesPurch::Sales,
            _projInvoiceJour.InvoiceAccount,
            _projInvoiceJour.InvoiceDate);

		custTable = CustTable::find(_projInvoiceJour.InvoiceAccount);
		projInvoiceTable = ProjInvoiceTable::find(_projInvoiceJour.ProjInvoiceProjId);

		vatNum          = this.projInvoiceJourVATNum(_projInvoiceJour);

		select firstonly forupdate tmpCustVendVolume
            index hint TypeVATNumIdx
            where tmpCustVendVolume.SalesPurch          == SalesPurch::Sales
                && tmpCustVendVolume.vatNum             == vatNum
                && tmpCustVendVolume.CountryRegionId    == this.countryRegionId(_projInvoiceJour)
                && tmpCustVendVolume.CashInvoiceYear    == cashInvoiceYear
                && tmpCustVendVolume.ReverseCharge_ES   == NoYes::No
                && tmpCustVendVolume.CashAccountingRegime_ES == cashAccountingRegime;

		if (!tmpCustVendVolume)
		{
			tmpCustVendVolume.vatNum                    = vatNum;
			tmpCustVendVolume.SalesPurch                = SalesPurch::Sales;
			tmpCustVendVolume.AmountMST                 = 0;
			tmpCustVendVolume.AmountInCash              = 0;
			tmpCustVendVolume.CashInvoiceYear           = cashInvoiceYear;

			tmpCustVendVolume.CountryRegionId           = this.countryRegionId(_projInvoiceJour, custTable);
			tmpCustVendVolume.CountryRegionType         = IntrastatCountryRegionParameters::type(tmpCustVendVolume.CountryRegionId);
			tmpCustVendVolume.CountyId                  = this.countyId(_projInvoiceJour, custTable);

			tmpCustVendVolume.Name                      = this.name(custTable);

			tmpCustVendVolume.CashAccountingRegime_ES   = cashAccountingRegime;
		}

		if (!tmpCustVendVolume.CashInvoiceDate || _projInvoiceJour.InvoiceDate < tmpCustVendVolume.CashInvoiceDate)
		{
			tmpCustVendVolume.CashInvoiceDate = _projInvoiceJour.InvoiceDate;
		}

		// Payment customer transactions contain negative value in AmountMST column, so we need to inverse the sign
		tmpCustVendVolume.AmountInCash += -_custSettlement.SettleAmountMST;

		tmpCustVendVolume.write();
	}

]]></Source>
			</Method>
			<Method>
				<Name>accumulateInvoice</Name>
				<Source><![CDATA[
    /// <summary>
	/// Accumulates the data from the project/sales/purchase invoice journal.
	/// </summary>
	/// <param name="_custVendInvoiceJour">
	/// The invoice journal record.
	/// </param>
	public void accumulateInvoice(CustVendInvoiceJour _custVendInvoiceJour)
	{
		NoYes   isReverseCharge, cashAccountingEnabled;
		CustVendTable   custVendTable;
		VATNum  vatNum;

		if (this.taxGroupIsValid(
			_custVendInvoiceJour.LedgerVoucher,
			_custVendInvoiceJour.InvoiceDate))
		{
			custVendTable = this.custVendTable(_custVendInvoiceJour);
			vatNum = this.custVendInvoiceJourVATNum(_custVendInvoiceJour, custVendTable);

			if (!onlyDomesticInvoices || EUSalesListTransfer::isDomesticVATDutableVATNum(vatNum))
			{
				cashAccountingEnabled = this.cashAccountingRegimeEnabled(
					this.salesPurch(_custVendInvoiceJour),
					_custVendInvoiceJour.InvoiceAccount,
					_custVendInvoiceJour.InvoiceDate);

				if (year(_custVendInvoiceJour.InvoiceDate) != reportYear && !cashAccountingEnabled)
				{
					//previous year invoices used only for cash accounting calculation
					return;
				}

				isReverseCharge = !cashAccountingEnabled &&
					this.isReverseCharge(
					_custVendInvoiceJour.LedgerVoucher,
					_custVendInvoiceJour.InvoiceDate);

				ttsbegin;

				select firstonly forupdate tmpCustVendVolume
					index hint TypeVATNumIdx
					where tmpCustVendVolume.SalesPurch               == this.salesPurch(_custVendInvoiceJour)
						&& tmpCustVendVolume.vatNum                  == vatNum
                        && tmpCustVendVolume.CountryRegionId         == this.companyCountryRegionId(custVendTable)
						&& tmpCustVendVolume.CashInvoiceYear         == reportYear
						&& tmpCustVendVolume.ReverseCharge_ES        == isReverseCharge
						&& tmpCustVendVolume.CashAccountingRegime_ES == cashAccountingEnabled;

				if (!tmpCustVendVolume)
				{
					tmpCustVendVolume.SalesPurch                 = this.salesPurch(_custVendInvoiceJour);
					tmpCustVendVolume.AccountNum                 = _custVendInvoiceJour.InvoiceAccount;
					tmpCustVendVolume.vatNum                     = vatNum;
					tmpCustVendVolume.CashInvoiceYear            = reportYear;
                    tmpCustVendVolume.CountryRegionId            = this.companyCountryRegionId(custVendTable);
                    tmpCustVendVolume.CountyId                   = this.companyCountyId(custVendTable);
					tmpCustVendVolume.Name                       = this.name(custVendTable);
					tmpCustVendVolume.CountryRegionType          = IntrastatCountryRegionParameters::type(tmpCustVendVolume.CountryRegionId);
					tmpCustVendVolume.CashAccountingRegime_ES    = cashAccountingEnabled;
					tmpCustVendVolume.ReverseCharge_ES           = isReverseCharge;
				}

				if (year(_custVendInvoiceJour.InvoiceDate) == reportYear)
				{
					tmpCustVendVolume.addTransactionAmount(
						this.invoiceAmountMST(_custVendInvoiceJour),
						_custVendInvoiceJour.InvoiceDate);

					tmpCustVendVolume.GoodsInDeposit_ES          = tmpCustVendVolume.GoodsInDeposit_ES   || this.isGoodsInDeposit(_custVendInvoiceJour);

					if (separateTaxAmount)
					{
						tmpCustVendVolume.TaxAmount         += _custVendInvoiceJour.SumTax;
					}
				}

				if (cashAccountingEnabled)
				{
					tmpCustVendVolume.CashAccountingAmount_ES   += this.cashAccountingRegimeAmount(
						_custVendInvoiceJour,
						(year(_custVendInvoiceJour.InvoiceDate) == reportYear - 1));
				}

				tmpCustVendVolume.write();

				ttscommit;
			}
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>accumulatePrepayment</Name>
				<Source><![CDATA[
    /// <summary>
	/// Accumulates the data from the prepayments.
	/// </summary>
	/// <param name="_custVendTransPrepayment">
	/// The <c>CustVendTrans</c> record related to prepayment.
	/// </param>
	public void accumulatePrepayment(CustVendTrans _custVendTransPrepayment)
	{
		NoYes   isReverseCharge, cashAccountingEnabled;
		CustVendTable   custVendTable;
		VATNum   vatNum;

		ttsbegin;

		if (this.taxGroupIsValid(
            _custVendTransPrepayment.Voucher,
            _custVendTransPrepayment.TransDate))
		{
			custVendTable = this.custVendTable(_custVendTransPrepayment);
			vatNum = this.custVendInvoiceJourVATNum(_custVendTransPrepayment, custVendTable);

			if (!onlyDomesticInvoices || EUSalesListTransfer::isDomesticVATDutableVATNum(vatNum))
			{
				cashAccountingEnabled = this.cashAccountingRegimeEnabled(
                    this.salesPurch(_custVendTransPrepayment),
                    _custVendTransPrepayment.AccountNum,
                    _custVendTransPrepayment.TransDate);

				isReverseCharge = !cashAccountingEnabled &&
                    this.isReverseCharge(
                    _custVendTransPrepayment.Voucher,
                    _custVendTransPrepayment.TransDate);

				select firstonly forupdate tmpCustVendVolume
                    index hint TypeVATNumIdx
                    where tmpCustVendVolume.SalesPurch               == this.salesPurch(_custVendTransPrepayment)
                        && tmpCustVendVolume.vatNum                  == vatNum
                        && tmpCustVendVolume.CountryRegionId         == this.countryRegionId(_custVendTransPrepayment)
                        && tmpCustVendVolume.CashInvoiceYear         == reportYear
                        && tmpCustVendVolume.ReverseCharge_ES        == isReverseCharge
                        && tmpCustVendVolume.CashAccountingRegime_ES == cashAccountingEnabled;

				if (!tmpCustVendVolume)
				{
					tmpCustVendVolume.SalesPurch                 = this.salesPurch(_custVendTransPrepayment);
					tmpCustVendVolume.AccountNum                 = _custVendTransPrepayment.AccountNum;
					tmpCustVendVolume.vatNum                     = vatNum;
					tmpCustVendVolume.CashInvoiceYear            = reportYear;
					tmpCustVendVolume.CountryRegionId            = this.countryRegionId(_custVendTransPrepayment, custVendTable);
					tmpCustVendVolume.CountyId                   = this.countyId(_custVendTransPrepayment, custVendTable);
					tmpCustVendVolume.Name                       = this.name(custVendTable);
					tmpCustVendVolume.CountryRegionType          = IntrastatCountryRegionParameters::type(tmpCustVendVolume.CountryRegionId);
					tmpCustVendVolume.CashAccountingRegime_ES    = cashAccountingEnabled;
					tmpCustVendVolume.ReverseCharge_ES           = isReverseCharge;
				}

				tmpCustVendVolume.addTransactionAmount(
					this.prepaymentAmountMST(_custVendTransPrepayment),
					_custVendTransPrepayment.TransDate);

				if (cashAccountingEnabled)
				{
					tmpCustVendVolume.CashAccountingAmount_ES   += this.prepaymentAmountMST(_custVendTransPrepayment);
				}

				tmpCustVendVolume.write();
			}
		}
		ttscommit;
	}

]]></Source>
			</Method>
			<Method>
				<Name>accumulateVolume</Name>
				<Source><![CDATA[
    /// <summary>
	///  Fetches data from invoices and prepayments.
	/// </summary>
	/// <returns>
	///  <c>TmpCustVendVolume</c> temporary table.
	/// </returns>
	/// <remarks>
	///   Summarizes amounts from different sources into temporary table.
	/// </remarks>
	public TmpCustVendVolume accumulateVolume()
	{
		CustVendInvoiceJour custVendInvoiceJour;
		CustVendTrans       custVendTransPrepayment;

		this.findDataSources();

		ttsbegin;
		while(qCustVendVolume.next())
		{
			if (custInvoice && qCustVendVolume.changed(tableNum(CustInvoiceJour)))
			{
				custVendInvoiceJour = qCustVendVolume.get(tableNum(CustInvoiceJour));
			}

			if (vendInvoice && qCustVendVolume.changed(tableNum(VendInvoiceJour), 1))
			{
				custVendInvoiceJour = qCustVendVolume.get(tableNum(VendInvoiceJour), 1);
			}

			if (projInvoice && qCustVendVolume.changed(tableNum(ProjInvoiceJour)))
			{
				custVendInvoiceJour = qCustVendVolume.get(tableNum(ProjInvoiceJour));
			}

			if (customerPrepayment && qCustVendVolume.changed(tableNum(CustTrans)))
			{
				custVendTransPrepayment = qCustVendVolume.get(tableNum(CustTrans));
			}

			if (vendorPrepayment && qCustVendVolume.changed(tableNum(VendTrans)))
			{
				custVendTransPrepayment = qCustVendVolume.get(tableNum(VendTrans));
			}

			if (vendInvoicePrevYear && qCustVendVolume.changed(tableNum(VendInvoiceJour), 2))
			{
				custVendInvoiceJour = qCustVendVolume.get(tableNum(VendInvoiceJour), 2);
			}

			if (custVendInvoiceJour)
			{
				this.accumulateInvoice(custVendInvoiceJour);
			}

			if (custVendTransPrepayment)
			{
				this.accumulatePrepayment(custVendTransPrepayment);
			}

			custVendInvoiceJour = null;
			custVendTransPrepayment = null;
		}

		ttscommit;

		return tmpCustVendVolume;
	}

]]></Source>
			</Method>
			<Method>
				<Name>cashAccountingEnabledForVendor</Name>
				<Source><![CDATA[
    /// <summary>
	///   Determines, if cash accounting regime enabled for specified vendor at specified year.
	/// </summary>
	/// <param name="_transDate">
	///   Date at which value is checked.
	/// </param>
	/// <param name="_party">
	///   Party record id; Optional.
	/// </param>
	/// <returns>
	///   Method execution result cached into map.
	/// </returns>
	private boolean cashAccountingEnabledForVendor(TransDate _transDate, DirPartyRecId _party = CompanyInfo::current())
	{
		Yr  invoiceYear = year(_transDate);
		boolean ret;

		if (!mapVendYearCashAccountingRegimeEnabled)
		{
			mapVendYearCashAccountingRegimeEnabled = new Map(Types::Container, Types::Integer);
		}
		if (mapVendYearCashAccountingRegimeEnabled.exists([_party, invoiceYear]))
		{
			ret = mapVendYearCashAccountingRegimeEnabled.lookup([_party, invoiceYear]);
		}
		else
		{
			ret = CashAccountingRegime_ES::isEnabled(_transDate, _party);
			mapVendYearCashAccountingRegimeEnabled.insert([_party, invoiceYear], ret);
		}

		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>cashAccountingRegimeAmount</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates cash accounting regime amount.
	/// </summary>
	/// <param name="_custVendInvoiceJour">
	///   <c>CustVendInvoiceJour</c> for which amount is calculated.
	/// </param>
	/// <param name="_prevYearOpenPart">
	///   Indicates type of calculation for cash accounting regime amount. Selects settled payments in invoice year if true;
	///   otherwise calculats part of transaction open on 1st Jan of report year. Optional.
	/// </param>
	/// <returns>
	///   Amount, which must be reported as cash accounting.
	/// </returns>
	/// <remarks>
	///  Prepayments excluded from calculation for current year to avoid duplication, because they are counted separately/
	/// </remarks>
	private AmountMST cashAccountingRegimeAmount(CustVendInvoiceJour _custVendInvoiceJour, boolean _prevYearOpenPart = false)
	{
		CustVendTrans   custVendTrans, custVendTransNotPrepayment;
		CustVendSettlement  custVendSettlement = this.custVendSettlement(_custVendInvoiceJour);
		AmountMST   cashAccountingAmount;

		custVendTrans = this.custVendTrans(_custVendInvoiceJour);
		custVendTransNotPrepayment = custVendTrans.data();

		if (custVendTrans.SettleAmountCur)
		{
			select crossCompany sum(SettleAmountMST), sum(ExchAdjustment) from custVendSettlement
                where custVendSettlement.TransCompany    == custVendTrans.DataAreaId
                    && custVendSettlement.TransRecId     == custVendTrans.RecId
                    && custVendSettlement.TransDate      >= DateTimeUtil::getStartOfYearDate(new Session().preferredLocale(), custVendTrans.TransDate)
                    && custVendSettlement.TransDate      <= DateTimeUtil::getEndOfYearDate(new Session().preferredLocale(), custVendTrans.TransDate)
                exists join custVendTransNotPrepayment
                    where custVendTransNotPrepayment.DataAreaId  == custVendSettlement.OffsetCompany
                        && custVendTransNotPrepayment.RecId      == custVendSettlement.OffsetRecId
                    //prepayments are not accounted for report year here, because they are processed separately
					&& (_prevYearOpenPart || custVendTransNotPrepayment.Prepayment == NoYes::No);
		}

		if (_prevYearOpenPart)
		{
			cashAccountingAmount = custVendTrans.AmountMST - custVendSettlement.SettleAmountMST + custVendSettlement.ExchAdjustment;
		}
		else
		{
			cashAccountingAmount = custVendSettlement.SettleAmountMST - custVendSettlement.ExchAdjustment;
		}

		return custVendSettlement.TableId == tableNum(CustSettlement) ? cashAccountingAmount : -cashAccountingAmount;
	}

]]></Source>
			</Method>
			<Method>
				<Name>cashAccountingRegimeEnabled</Name>
				<Source><![CDATA[
    /// <summary>
	///   Determines, if cash accounting enabled for customer/vendor.
	/// </summary>
	/// <param name="_salesPurch">
	///   Sales or purchase side.
	/// </param>
	/// <param name="_custVendAC">
	///   Customer or vendor account.
	/// </param>
	/// <param name="_transDate">
	///   Date, at which value is checked.
	/// </param>
	/// <returns>
	///   True, if cash accounting enabled; Otherwise false.
	/// </returns>
	protected boolean cashAccountingRegimeEnabled(SalesPurch _salesPurch, CustVendAC _custVendAC, TransDate _transDate)
	{
		boolean ret = true;

		switch (_salesPurch)
		{
			case SalesPurch::Sales:
				ret = this.cashAccountingEnabledForVendor(_transDate);
				break;
			case SalesPurch::Purch:
				ret = this.cashAccountingEnabledForVendor(_transDate) ||
						  this.cashAccountingEnabledForVendor(_transDate, VendTable::find(_custVendAC).Party);
				break;
		}

		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>companyCountryRegionId</Name>
				<Source><![CDATA[
    private LogisticsAddressCountryRegionId companyCountryRegionId(CustVendTable _custVendTable)
    {
        LogisticsAddressCountryRegionId countryRegionId;

        switch (_custVendTable.TableId)
        {
            case tableNum(CustTable):
                CustTable custTable = _custVendTable;
                countryRegionId = custTable.countryRegionId();
                break;
            case tableNum(VendTable):
                VendTable vendTable = _custVendTable;
                countryRegionId = vendTable.countryRegionId();
                break;
        }

        return countryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countryRegionId</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates country value for given invoice or prepayment.
	/// </summary>
	/// <param name="_invoiceJourOrPrepayment">
	///   Invoice or prepayment record.
	/// </param>
	/// <param name="_custVendTable">
	///   Customer or vendor table record. Optional.
	/// </param>
	/// <returns>
	///   Country region value.
	/// </returns>
	private LogisticsAddressCountryRegionId countryRegionId(Common _invoiceJourOrPrepayment, CustVendTable _custVendTable = null)
	{
		CustVendTable custVendTable = _custVendTable;
		AddressCountryRegionId countryRegionId;

		CustInvoiceJour custInvoiceJour;
		ProjInvoiceJour projInvoiceJour;
		LogisticsPostalAddress  postalAddress;
		ProjFundingSource   projFundingSource;

		CustTable   custTable;
		VendTable   vendTable;

		switch (_invoiceJourOrPrepayment.TableId)
		{
			case tableNum(CustInvoiceJour):
				custInvoiceJour = _invoiceJourOrPrepayment;
				postalAddress = LogisticsPostalAddress::findRecId(custInvoiceJour.DeliveryPostalAddress);
				countryRegionId = postalAddress.CountryRegionId;
				break;
			case tableNum(VendInvoiceJour):
			case tableNum(CustTrans):
			case tableNum(VendTrans):
				break;
			case tableNum(ProjInvoiceJour):
				projInvoiceJour = _invoiceJourOrPrepayment;
				postalAddress = LogisticsPostalAddress::findRecId(projInvoiceJour.DeliveryPostalAddress);
				countryRegionId = postalAddress.CountryRegionId;

				if (!countryRegionId)
				{
					projFundingSource = ProjFundingSource::find(ProjProposalJour::find(projInvoiceJour.ProposalId).FundingSource);
					countryRegionId = LogisticsLocationEntity::location2PostalAddress(projFundingSource.InvoiceLocation).CountryRegionId;
				}
				break;

			}
		if (!countryRegionId)
		{
			if (!custVendTable)
			{
				custVendTable = this.custVendTable(_invoiceJourOrPrepayment);
			}

            countryRegionId = this.companyCountryRegionId(custVendTable);
		}

		return countryRegionId;
	}

]]></Source>
			</Method>
			<Method>
				<Name>companyCountyId</Name>
				<Source><![CDATA[
    private LogisticsAddressCountyId companyCountyId(CustVendTable _custVendTable)
    {
        LogisticsAddressCountyId countyId;

        switch (_custVendTable.TableId)
        {
            case tableNum(CustTable):
                CustTable custTable = _custVendTable;
                countyId = custTable.postalAddress().County;
                break;
            case tableNum(VendTable):
                VendTable vendTable = _custVendTable;
                countyId = vendTable.postalAddress().County;
                break;
        }

        return countyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countyId</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates county value for given invoice or prepayment.
	/// </summary>
	/// <param name="_invoiceJourOrPrepayment">
	///   Invoice or prepayment record.
	/// </param>
	/// <param name="_custVendTable">
	///   Customer or vendor table record. Optional.
	/// </param>
	/// <returns>
	///   County value.
	/// </returns>
	private LogisticsAddressCountyId countyId(Common _invoiceJourOrPrepayment, CustVendTable _custVendTable = null)
	{
		CustVendTable custVendTable = _custVendTable;
		AddressCountyId countyId;

		CustInvoiceJour custInvoiceJour;
		ProjInvoiceJour projInvoiceJour;
		LogisticsPostalAddress  postalAddress;
		ProjFundingSource   projFundingSource;

		CustTable   custTable;
		VendTable   vendTable;

		switch (_invoiceJourOrPrepayment.TableId)
		{
			case tableNum(CustInvoiceJour):
				custInvoiceJour = _invoiceJourOrPrepayment;
				postalAddress = LogisticsPostalAddress::findRecId(custInvoiceJour.DeliveryPostalAddress);
				countyId = postalAddress.County;
				break;
			case tableNum(VendInvoiceJour):
			case tableNum(CustTrans):
			case tableNum(VendTrans):
				break;
			case tableNum(ProjInvoiceJour):
				projInvoiceJour = _invoiceJourOrPrepayment;
				postalAddress = LogisticsPostalAddress::findRecId(projInvoiceJour.DeliveryPostalAddress);
				countyId = postalAddress.County;

				if (!countyId)
				{
					projFundingSource = ProjFundingSource::find(ProjProposalJour::find(projInvoiceJour.ProposalId).FundingSource);
					countyId = LogisticsLocationEntity::location2PostalAddress(projFundingSource.InvoiceLocation).County;
				}
				break;

		}
		if (!countyId)
		{
			if (!custVendTable)
			{
				custVendTable = this.custVendTable(_invoiceJourOrPrepayment);
			}

            countyId = this.companyCountyId(custVendTable);
		}

		return countyId;
	}

]]></Source>
			</Method>
			<Method>
				<Name>custInvoiceQuery</Name>
				<Source><![CDATA[
    /// <summary>
	/// Applies the specified filters to the customer invoices which should be transferred to the report.
	/// </summary>
	/// <param name="_invoiceDate">
	/// Invoice date.
	/// </param>
	/// <param name="_countryType">
	/// Country/region type.
	/// </param>
	/// <param name="_countryId">
	/// Country/region id.
	/// </param>
	/// <param name="_account">
	/// Customer account number.
	/// </param>
	/// <param name="_vatNum">
	/// VAT number.
	/// </param>
	/// <param name="_billingClassification">
	/// The billing classification.
	/// </param>
	/// <param name="_inclTransWithNoBillingClass">
	/// A boolean value indicating whether to include transactions with no billing classifications.
	/// </param>
	public void custInvoiceQuery(
        str   _invoiceDate = '',
        str   _countryType = '',
        str   _countryId   = '',
        str   _account     = '',
        str   _vatNum      = '',
        List  _billingClassification = null,
        NoYes _inclTransWithNoBillingClass = NoYes::No)
	{
		if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
		{
			super(
                _invoiceDate,
                _countryType,
                _countryId,
                _account,
                _vatNum,
                _billingClassification,
                _inclTransWithNoBillingClass);
		}
		else
		{
			super(_invoiceDate, _countryType, _countryId, _account, _vatNum);
		}

		qCustVendVolume.query().dataSourceTable(tableNum(CustInvoiceJour)).addSortField(fieldNum(CustInvoiceJour, vatNum),SortOrder::Ascending);
	}

]]></Source>
			</Method>
			<Method>
				<Name>custPrepaymentsQuery</Name>
				<Source><![CDATA[
    /// <summary>
	///   Creates query for selecting customer prepayments.
	/// </summary>
	/// <param name="_dateRange">
	///  Date range.
	/// </param>
	/// <param name="_countryRegionType">
	///   Country type range.
	/// </param>
	/// <param name="_countryRegionId">
	///   Country region id range.
	/// </param>
	/// <param name="_account">
	///   Customer account range.
	/// </param>
	/// <param name="_vatNum">
	///   VAT number range.
	/// </param>
	public void custPrepaymentsQuery(
        str   _dateRange,
        str   _countryRegionType,
        str   _countryRegionId,
        str   _account,
        str   _vatNum)
	{
		QueryBuildDataSource    custTrans_ds;
		QueryBuildDataSource    custTable_ds;
		QueryBuildDataSource    dirPartyLocation_ds;
		QueryBuildDataSource    address_ds;
		QueryBuildDataSource    intrastatCountryRegionParameters_ds;

		// Add table
		custTrans_ds = qCustVendVolume.query().addDataSource(tableNum(CustTrans));
		custTrans_ds.addRange(fieldNum(CustTrans, Prepayment)).value(queryValue(NoYes::Yes));

		// Add sorting order
		custTrans_ds.addSortField(fieldNum(CustTrans, TransDate),SortOrder::Ascending);

		// Add ranges
		if (_dateRange)
		{
			custTrans_ds.addRange(fieldNum(CustTrans, TransDate)).value(_dateRange);
		}
		if (_account)
		{
			custTrans_ds.addRange(fieldNum(CustTrans, TransDate)).value(_account);
		}
		if (_vatNum || _countryRegionId || _countryRegionType)
		{
			custTable_ds = custTrans_ds.addDataSource(tableNum(CustTable));
			custTable_ds.joinMode(JoinMode::ExistsJoin);
			custTable_ds.fetchMode(QueryFetchMode::One2One);
			custTable_ds.addLink(fieldNum(CustTrans, AccountNum), fieldNum(CustTable,AccountNum));

			if (_vatNum)
			{
				custTable_ds.addRange(fieldNum(CustTable,vatNum)).value(_vatNum);
			}

			if (_countryRegionId || _countryRegionType)
			{
				//Add join table
				dirPartyLocation_ds = custTable_ds.addDataSource(tableNum(DirPartyLocation));
				dirPartyLocation_ds.joinMode(JoinMode::ExistsJoin);
				dirPartyLocation_ds.fetchMode(QueryFetchMode::One2One);
				dirPartyLocation_ds.addLink(fieldNum(VendTable, Party), fieldNum(DirPartyLocation, Party));
				dirPartyLocation_ds.addRange(fieldNum(DirPartyLocation, IsPostalAddress)).value(queryValue(NoYes::Yes));
				dirPartyLocation_ds.addRange(fieldNum(DirPartyLocation, IsPrimary)).value(queryValue(NoYes::Yes));

				address_ds = dirPartyLocation_ds.addDataSource(tableNum(LogisticsPostalAddress));
				address_ds.addLink(fieldNum(DirPartyLocation, Location), fieldNum(LogisticsPostalAddress, Location));

				if (_countryRegionId)
				{
					address_ds.addRange(fieldNum(LogisticsPostalAddress, CountryRegionId)).value(_countryRegionId);
				}

				if (_countryRegionType)
				{
					intrastatCountryRegionParameters_ds = address_ds.addDataSource(tableNum(IntrastatCountryRegionParameters));
					intrastatCountryRegionParameters_ds.joinMode(JoinMode::ExistsJoin);
					intrastatCountryRegionParameters_ds.fetchMode(QueryFetchMode::One2One);
					intrastatCountryRegionParameters_ds.addLink(fieldNum(LogisticsPostalAddress, CountryRegionId), fieldNum(IntrastatCountryRegionParameters, CountryRegionId));
					intrastatCountryRegionParameters_ds.addRange(fieldNum(IntrastatCountryRegionParameters, CountryRegionType)).value(_countryRegionType);
				}
			}
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>custVendInvoiceJourVATNum</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates VATNumber for invoice or prepayment record.
	/// </summary>
	/// <param name="_invoiceJourOrPrepayment">
	///   Customer invoice or prepayment.
	/// </param>
	/// <param name="_custVendTable">
	///   Customer or vendor table record. Optional.
	/// </param>
	/// <returns>
	///   VAT number, which must be used for invoice.
	/// </returns>
	public VATNum custVendInvoiceJourVATNum(Common _invoiceJourOrPrepayment, CustVendTable _custVendTable = null)
	{
		VATNum      vatNum;
		VATNum      vatNumNew;
		CustVendTable   custVendTable = _custVendTable;
		CustVendInvoiceJour custVendInvoiceJour;
		SalesPurch  salesPurch = this.salesPurch(_invoiceJourOrPrepayment);

		if (!custVendTable)
		{
			custVendTable = this.custVendTable(_invoiceJourOrPrepayment);
		}

		if (_invoiceJourOrPrepayment.TableId == tableNum(CustInvoiceJour) ||
			_invoiceJourOrPrepayment.TableId == tableNum(VendInvoiceJour) ||
			_invoiceJourOrPrepayment.TableId == tableNum(ProjInvoiceJour))
		{
			custVendInvoiceJour = _invoiceJourOrPrepayment;
		}
		vatNum = (custVendInvoiceJour && custVendInvoiceJour.vatNum) ? custVendInvoiceJour.vatNum : custVendTable.vatNum;

		if (groupRelatedVATNums)
		{
			vatNumNew = custVendTable.vatNum ? custVendTable.vatNum : this.findVatNumOfLastInvoice(salesPurch, custVendTable.AccountNum);

			this.validateNewVATNum(vatNum, vatNumNew, custVendTable.AccountNum, salesPurch);

			vatNum = vatNumNew;
		}

		return vatNum;
	}

]]></Source>
			</Method>
			<Method>
				<Name>custVendSettlement</Name>
				<Source><![CDATA[
    /// <summary>
	///   Initializes customer or vendor settlement table buffer.
	/// </summary>
	/// <param name="_custVendInvoiceJour">
	///   Customer or vendor invoice transaction.
	/// </param>
	/// <returns>
	///   Customer or vendor settlement buffer.
	/// </returns>
	private CustVendSettlement custVendSettlement(CustVendInvoiceJour _custVendInvoiceJour)
	{
		CustSettlement  custSettlement;
		VendSettlement  vendSettlement;
		CustVendSettlement ret;

		switch (_custVendInvoiceJour.TableId)
		{
			case tableNum(CustInvoiceJour):
			case tableNum(ProjInvoiceJour):
				ret = custSettlement;
				break;
			case tableNum(VendInvoiceJour):
				ret = vendSettlement;
				break;
		}

		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>custVendTable</Name>
				<Source><![CDATA[
    /// <summary>
	///   Searches for customer or vendor table by given invoice journal or prepayment.
	/// </summary>
	/// <param name="_invoiceJourOrPrepayment">
	///   Invoice journal or prepayment record.
	/// </param>
	/// <returns>
	///   Customer or vendor table.
	/// </returns>
	protected CustVendTable custVendTable(Common _invoiceJourOrPrepayment)
	{
		CustVendTable ret;
		CustVendInvoiceJour custVendInvoiceJour;
		CustVendTrans   custVendTrans;

		switch (_invoiceJourOrPrepayment.TableId)
		{
			case tableNum(CustInvoiceJour):
			case tableNum(ProjInvoiceJour):
				custVendInvoiceJour = _invoiceJourOrPrepayment;
				ret = CustTable::find(custVendInvoiceJour.InvoiceAccount);
				break;
			case tableNum(VendInvoiceJour):
				custVendInvoiceJour = _invoiceJourOrPrepayment;
				ret = VendTable::find(custVendInvoiceJour.InvoiceAccount);
				break;
			case tableNum(CustTrans):
				custVendTrans = _invoiceJourOrPrepayment;
				ret = CustTable::find(custVendTrans.AccountNum);
				break;
			case tableNum(VendTrans):
				custVendTrans = _invoiceJourOrPrepayment;
				ret = VendTable::find(custVendTrans.AccountNum);
		}
		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>custVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
	///   Searches for customer or vendor transaction by given customer or vendor invoice journal.
	/// </summary>
	/// <param name="_custVendInvoiceJour">
	///   Customer/vendor/project invoice journal.
	/// </param>
	/// <returns>
	///   Customer or vendor transaction.
	/// </returns>
	protected CustVendTrans custVendTrans(CustVendInvoiceJour _custVendInvoiceJour)
	{
		CustVendTrans custVendTrans;

		CustTrans   custTrans;
		VendTrans   vendTrans;

		switch (_custVendInvoiceJour.TableId)
		{
			case tableNum(CustInvoiceJour):
			case tableNum(ProjInvoiceJour):
				custTrans = _custVendInvoiceJour.CustVendInvoiceJour::custVendTrans(custTrans);
				if (custTrans.BillOfExchangeStatus != CustVendNegInstStatus::Honored)
				{
					custVendTrans = custTrans;
				}
				break;
			case tableNum(VendInvoiceJour):
				vendTrans = _custVendInvoiceJour.CustVendInvoiceJour::custVendTrans(vendTrans);
				if(vendTrans.PromissoryNoteStatus != CustVendNegInstStatus::InvoiceRemitted &&
					   vendTrans.PromissoryNoteStatus != CustVendNegInstStatus::Honored)
				{
					custVendTrans = vendTrans;
				}
				break;
		}
		return custVendTrans;
	}

]]></Source>
			</Method>
			<Method>
				<Name>findDataSources</Name>
				<Source><![CDATA[
    /// <summary>
	///   Determines, if query has added datasource.
	/// </summary>
	public void findDataSources()
	{
		super();

		if (qCustVendVolume.query().dataSourceTable(tableNum(CustTrans)))
		{
			customerPrepayment = true;
		}

		if (qCustVendVolume.query().dataSourceTable(tableNum(VendTrans)))
		{
			vendorPrepayment = true;
		}

		if (qCustVendVolume.query().dataSourceName(vendInvoiceJourPrev))
		{
			vendInvoicePrevYear = true;
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>findLastInvoice</Name>
				<Source><![CDATA[
    /// <summary>
	///   Searches for latest invoice for a given customer or vendor account.
	/// </summary>
	/// <param name="_custVendAccount">
	///   Customer or vendor account.
	/// </param>
	/// <param name="_custVendInvoiceJour">
	///   Customer/vendor/project invoice, for which data is found.
	/// </param>
	/// <param name="_lastCustVendInvoiceJour">
	///   Customer or project invoice record. In case when sales side, we must choose latest of sales and project invoices for this customer. So, first we choose customer invoice, and then
	///   call method againg to find latest project invoice, which was posted later than lates customer invoice.
	/// </param>
	/// <returns>
	///   <c>CustVendInvoiceJour</c> record.
	/// </returns>
	private CustVendInvoiceJour findLastInvoice(
        CustVendAC _custVendAccount,
        CustVendInvoiceJour _custVendInvoiceJour,
        CustVendInvoiceJour _lastCustVendInvoiceJour = null)
	{
		CustVendInvoiceJour custVendInvoiceJourLocal = _custVendInvoiceJour.data();

		select firstonly vatNum from custVendInvoiceJourLocal
            order by custVendInvoiceJourLocal.InvoiceDate desc
            where  custVendInvoiceJourLocal.InvoiceAccount == _custVendInvoiceJour.InvoiceAccount
                && (!_lastCustVendInvoiceJour.InvoiceDate || custVendInvoiceJourLocal.InvoiceDate > _lastCustVendInvoiceJour.InvoiceDate)
                && custVendInvoiceJourLocal.vatNum;

		if (!custVendInvoiceJourLocal)
		{
			custVendInvoiceJourLocal = _lastCustVendInvoiceJour;
		}

		return custVendInvoiceJourLocal;
	}

]]></Source>
			</Method>
			<Method>
				<Name>findVatNumOfLastInvoice</Name>
				<Source><![CDATA[
    /// <summary>
	///   Searches for VATNum speccified at last invoice for given customer or vendor.
	/// </summary>
	/// <param name="_salesPurch">
	///   Sales or purchase side.
	/// </param>
	/// <param name="_custVendAccount">
	///   Customer or vendor account.
	/// </param>
	/// <returns>
	///   VAT number of last invoice.
	/// </returns>
	/// <remarks>
	///   In case of sales we must check both sales and project invoices. So, first last customer invoice found and then its trying to find project invoice later than customer invoice.
	/// </remarks>
	private VATNum findVatNumOfLastInvoice(SalesPurch _salesPurch, CustVendAC _custVendAccount)
	{
		VATNum              result;
		CustVendInvoiceJour custVendInvoiceJourLocal;

		CustInvoiceJour     custInvoiceJour;
		VendInvoiceJour     vendInvoiceJour;
		ProjInvoiceJour     projInvoiceJour;

		if (mapCustVendId2LastInvoiceVatNum.exists([_salesPurch, _custVendAccount]))
		{
			result = mapCustVendId2LastInvoiceVatNum.lookup([_salesPurch, _custVendAccount]);
		}
		else
		{
			switch (_salesPurch)
			{
				case SalesPurch::Purch:
					custVendInvoiceJourLocal = this.findLastInvoice(_custVendAccount, vendInvoiceJour);
					break;
				case SalesPurch::Sales:
					custVendInvoiceJourLocal = this.findLastInvoice(_custVendAccount, custInvoiceJour);
					custVendInvoiceJourLocal = this.findLastInvoice(_custVendAccount, projInvoiceJour, custVendInvoiceJourLocal);
					break;
			}

			result = custVendInvoiceJourLocal.vatNum;
			mapCustVendId2LastInvoiceVatNum.insert([_salesPurch, _custVendAccount], result);
		}

		return result;
	}

]]></Source>
			</Method>
			<Method>
				<Name>hasErrors</Name>
				<Source><![CDATA[
    /// <summary>
	/// Indicates whether any errors were encountered while accumulating the transactions.
	/// </summary>
	/// <returns>
	/// True if any errors were encountered while accumulating the transactions; otherwise, false.
	/// </returns>
	public boolean hasErrors()
	{
		return invalidVATNumbersSales.elements() > 0 || invalidVATNumbersPurch.elements() > 0;
	}

]]></Source>
			</Method>
			<Method>
				<Name>invoiceAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates invoice amount, which must be accounted for given <c>CustVendInvoiceJour</c> record.
	/// </summary>
	/// <param name="_custVendInvoiceJour">
	///   Customer, vendor or project invoice journal.
	/// </param>
	/// <returns>
	///   Amount which must be reflected at the report.
	/// </returns>
	/// <remarks>
	///   Prepayments settled with invoice in invoice year must be subtracted to avoid duplication, because they are processed separately.
	/// </remarks>
	private AmountMST invoiceAmountMST(CustVendInvoiceJour _custVendInvoiceJour)
	{
		CustVendTrans   custVendTrans, custVendTransPrepayment;
		CustVendSettlement  custVendSettlement = this.custVendSettlement(_custVendInvoiceJour);
		AmountMST     ret;

		custVendTrans = this.custVendTrans(_custVendInvoiceJour);
		custVendTransPrepayment = custVendTrans.data();

		select crossCompany sum(SettleAmountMST), sum(ExchAdjustment) from custVendSettlement
            where custVendSettlement.TransCompany == custVendTrans.DataAreaId
                && custVendSettlement.TransRecId == custVendTrans.RecId
            exists join custVendTransPrepayment
                where custVendTransPrepayment.DataAreaId == custVendSettlement.OffsetCompany
                    && custVendTransPrepayment.RecId == custVendSettlement.OffsetRecId
                    && custVendTransPrepayment.Prepayment == NoYes::Yes;

		ret = custVendTrans.AmountMST - custVendSettlement.SettleAmountMST + custVendSettlement.ExchAdjustment;

		if (_custVendInvoiceJour.TableId == tableNum(VendInvoiceJour))
		{
			ret = -ret;
		}

		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>isGoodsInDeposit</Name>
				<Source><![CDATA[
    /// <summary>
	///   Determines, if invoice represents goods in deposit.
	/// </summary>
	/// <param name="_custVendInvoiceJour">
	///   <c>CustVendInvoiceJour</c> record.
	/// </param>
	/// <returns>
	///   True, if goods in deposit; Otherwise false.
	/// </returns>
	protected boolean isGoodsInDeposit(CustVendInvoiceJour _custVendInvoiceJour)
	{
		Query queryGoods = new Query();
		QueryBuildDataSource qbdsInvoiceTrans, qbdsInventDim, qbdsInventLocation;
		QueryRun queryRunGoods;
		VendInvoiceJour vendInvoiceJour;

		switch (_custVendInvoiceJour.TableId)
		{
			case tableNum(CustInvoiceJour):
				qbdsInvoiceTrans = queryGoods.addDataSource(tableNum(CustInvoiceTrans));

				qbdsInvoiceTrans.addRange(fieldNum(CustInvoiceTrans, InvoiceId)).value(queryValue(_custVendInvoiceJour.InvoiceId));
				qbdsInvoiceTrans.addRange(fieldNum(CustInvoiceTrans, InvoiceDate)).value(queryValue(_custVendInvoiceJour.InvoiceDate));
				qbdsInvoiceTrans.addRange(fieldNum(CustInvoiceTrans, SalesId)).value(queryValue(_custVendInvoiceJour.Num));
				qbdsInvoiceTrans.addRange(fieldNum(CustInvoiceTrans, NumberSequenceGroup)).value(queryValue(_custVendInvoiceJour.NumberSequenceGroupId));
				break;
			case tableNum(ProjInvoiceJour):
				qbdsInvoiceTrans = queryGoods.addDataSource(tableNum(ProjInvoiceItem));

				qbdsInvoiceTrans.addRange(fieldNum(ProjInvoiceItem, ProjInvoiceId)).value(queryValue(_custVendInvoiceJour.InvoiceId));
				qbdsInvoiceTrans.addRange(fieldNum(ProjInvoiceItem, InvoiceDate)).value(queryValue(_custVendInvoiceJour.InvoiceDate));
				break;
			case tableNum(VendInvoiceJour):
				qbdsInvoiceTrans = queryGoods.addDataSource(tableNum(VendInvoiceTrans));

				vendInvoiceJour = _custVendInvoiceJour;

				qbdsInvoiceTrans.addRange(fieldNum(VendInvoiceTrans, InvoiceId)).value(queryValue(_custVendInvoiceJour.InvoiceId));
				qbdsInvoiceTrans.addRange(fieldNum(VendInvoiceTrans, InvoiceDate)).value(queryValue(_custVendInvoiceJour.InvoiceDate));
				qbdsInvoiceTrans.addRange(fieldNum(VendInvoiceTrans, PurchID)).value(queryValue(_custVendInvoiceJour.Num));
				qbdsInvoiceTrans.addRange(fieldNum(VendInvoiceTrans, NumberSequenceGroup)).value(queryValue(_custVendInvoiceJour.NumberSequenceGroupId));
				qbdsInvoiceTrans.addRange(fieldNum(VendInvoiceTrans, InternalInvoiceId)).value(queryValue(vendInvoiceJour.InternalInvoiceId));
				break;
		}

		qbdsInvoiceTrans.addSelectionField(fieldNum(Common, RecId));
		qbdsInvoiceTrans.firstOnly(true);

		qbdsInventDim = qbdsInvoiceTrans.addDataSource(tableNum(InventDim));
		qbdsInventDim.relations(true);
		qbdsInventDim.joinMode(JoinMode::ExistsJoin);

		qbdsInventLocation = qbdsInventDim.addDataSource(tableNum(InventLocation));
		qbdsInventLocation.relations(true);
		qbdsInventLocation.joinMode(JoinMode::ExistsJoin);
		qbdsInventLocation.addRange(fieldNum(InventLocation, VendAccount)).value(SysQuery::valueNotEmptyString());

		queryRunGoods = new QueryRun(queryGoods);

		return queryRunGoods.next();
	}

]]></Source>
			</Method>
			<Method>
				<Name>isReverseCharge</Name>
				<Source><![CDATA[
    /// <summary>
	/// Defines if the operation is related to the reverse charge.
	/// </summary>
	/// <param name="_voucher">
	/// The ledger voucher of the operation.
	/// </param>
	/// <param name="_transDate">
	/// The date of the operation.
	/// </param>
	/// <returns>
	/// true, if the operation is related to the reverse charge; false, otherwise.
	/// </returns>
	public boolean isReverseCharge(
        Voucher         _voucher,
        TransDate       _transDate)
	{
		TaxTrans    taxTransPos, taxTransNeg;

		select firstonly RecId from taxTransNeg
            where taxTransNeg.Voucher       == _voucher
                && taxTransNeg.TransDate    == _transDate
                && taxTransNeg.TaxValue     < 0
                && taxTransNeg.IntracomVAT;

		if (taxTransNeg)
		{
			select firstonly RecId from taxTransPos
                where taxTransPos.Voucher       == _voucher
                    && taxTransPos.TransDate    == _transDate
                    && taxTransPos.TaxValue     > 0;
		}

		return taxTransPos.RecId != 0 && taxTransNeg.RecId != 0;
	}

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates name of customer or vendor, which must be displayed at the report.
	/// </summary>
	/// <param name="_custVendTable">
	///   Customer or vendor table. Added from performance considerations. Optional.
	/// </param>
	/// <returns>
	///   Name of customer or vendor.
	/// </returns>
	public Name name(CustVendTable _custVendTable = null)
	{
		Name name;

		name = TaxVATNumTable::name(tmpCustVendVolume.vatNum, tmpCustVendVolume.CountryRegionId);

		if (!name)
		{
			name = _custVendTable.name();
		}

		return name;
	}

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
	/// Constructor
	/// </summary>
	/// <param name="_separateTaxAmount">
	/// Indicates whether tax amount needs to be stored separately in the TmpCustVendCalcVolume.TaxAmount field.
	/// </param>
	void new(boolean _separateTaxAmount = true)
	{
		mapVATNumOld2NewSales               = new Map(Types::String, Types::Container);
		mapVATNumOld2NewPurch               = new Map(Types::String, Types::Container);
		mapCustVendId2LastInvoiceVatNum     = new Map(Types::Container, Types::String);

		mapTaxGroupIsValid                  = new Map(Types::Container, Types::Enum);

		invalidVATNumbersSales              = new Set(Types::String);
		invalidVATNumbersPurch              = new Set(Types::String);

		super(_separateTaxAmount);
	}

]]></Source>
			</Method>
			<Method>
				<Name>parmGroupRelatedVATNums</Name>
				<Source><![CDATA[
    public boolean parmGroupRelatedVATNums(boolean _groupRelatedVATNums = groupRelatedVATNums)
	{
		groupRelatedVATNums = _groupRelatedVATNums;
		return groupRelatedVATNums;
	}

]]></Source>
			</Method>
			<Method>
				<Name>parmReportYear</Name>
				<Source><![CDATA[
    public TaxRep347Year parmReportYear(TaxRep347Year _reportYear =reportYear)
	{
		reportYear = _reportYear;
		return reportYear;
	}

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpCustVendVolume</Name>
				<Source><![CDATA[
    public TmpCustVendVolume parmTmpCustVendVolume()
	{
		return tmpCustVendVolume;
	}

]]></Source>
			</Method>
			<Method>
				<Name>prepaymentAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
	///   Calculates prepayment amount which must be displayed at report.
	/// </summary>
	/// <param name="_custVendTrans">
	///   Customer or vendor prepayment transaction.
	/// </param>
	/// <returns>
	///   Prepayment amount.
	/// </returns>
	private AmountMST prepaymentAmountMST(CustVendTrans _custVendTrans)
	{
		AmountMST ret;

		switch (_custVendTrans.TableId)
		{
			//For prepayments customer payments are credit while vendor are credit
		case tableNum(CustTrans):
			ret = -_custVendTrans.AmountMST;
			break;
		case tableNum(VendTrans):
			ret = _custVendTrans.AmountMST;
			break;
		}
		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>projInvoiceQuery</Name>
				<Source><![CDATA[
    /// <summary>
	/// Applies the specified filters to the project invoices which should be transferred to the report.
	/// </summary>
	/// <param name="_invoiceDate">
	///   Date range.
	/// </param>
	/// <param name="_countryType">
	///   Country type range.
	/// </param>
	/// <param name="_countryId">
	///   Country region id range.
	/// </param>
	/// <param name="_account">
	///   Customer account range.
	/// </param>
	/// <param name="_VATNum">
	///   VAT number range.
	/// </param>
	public void projInvoiceQuery(
        str   _invoiceDate = '',
        str   _countryType = '',
        str   _countryId   = '',
        str   _account     = '',
        str   _VATNum      = '')
	{
		super(_invoiceDate, _countryType, _countryId, _account, _vatNum);

		qCustVendVolume.query().dataSourceTable(tableNum(ProjInvoiceJour)).addSortField(fieldNum(ProjInvoiceJour, vatNum), SortOrder::Ascending);
	}

]]></Source>
			</Method>
			<Method>
				<Name>salesPurch</Name>
				<Source><![CDATA[
    /// <summary>
	///   Determines, if current transaction related to sales or purchases.
	/// </summary>
	/// <param name="_transOrInvoiceJour">
	///   Customer/vendor prepayment or invoice journal.
	/// </param>
	/// <returns>
	///   <c>SalesPurch</c> value.
	/// </returns>
	protected SalesPurch salesPurch(Common _transOrInvoiceJour)
	{
		SalesPurch ret;
		switch (_transOrInvoiceJour.TableId)
		{
			case tableNum(CustInvoiceJour):
			case tableNum(ProjInvoiceJour):
			case tableNum(CustTrans):
				ret = SalesPurch::Sales;
				break;
			case tableNum(VendInvoiceJour):
			case tableNum(VendTrans):
				ret = SalesPurch::Purch;
				break;
		}
		return ret;
	}

]]></Source>
			</Method>
			<Method>
				<Name>taxGroupIsValid</Name>
				<Source><![CDATA[
    private boolean taxGroupIsValid(Voucher _voucher, TransDate _transDate)
	{
		TaxTrans                taxTrans;
		TaxReport347Validation  taxReport347Validation;
		container               cacheLookupKey;
		boolean                 result;

		cacheLookupKey = [_voucher, _transDate];

		if (mapTaxGroupIsValid.exists(cacheLookupKey))
		{
			result = mapTaxGroupIsValid.lookup(cacheLookupKey);
		}
		else
		{
			select firstonly RecId from taxTrans
                index hint VoucherDateIdx
                where  taxTrans.TransDate   == _transDate
                    && taxTrans.Voucher     == _voucher
            exists join taxReport347Validation
                where taxReport347Validation.TaxGroup == taxTrans.TaxGroup;

			// If there is at least one taxTrans with TaxGroup from the validation list (TaxReport347Validation)
			// for the specified _voucher then the _voucher has an invalid taxGroup
			result = !taxTrans.RecId;

			mapTaxGroupIsValid.insert(cacheLookupKey, result ? NoYes::Yes : NoYes::No);
		}

		return result;
	}

]]></Source>
			</Method>
			<Method>
				<Name>validateNewVATNum</Name>
				<Source><![CDATA[
    protected void validateNewVATNum(VATNum vatNumOld, VATNum vatNumNew, CustVendAC accountNum, SalesPurch salesPurch)
	{
		container   conVATNumNew;       // Contents: [VATNum, AccountNum]
		Map         mapVATNumOld2New;
		Set         invalidVATNumbers;
		str         errorMessagePattern;

		invalidVATNumbers = salesPurch == SalesPurch::Sales ? invalidVATNumbersSales : invalidVATNumbersPurch;

		if (invalidVATNumbers.in(vatNumNew))
		{
			return;
		}

		mapVATNumOld2New = salesPurch == SalesPurch::Sales ? mapVATNumOld2NewSales : mapVATNumOld2NewPurch;

		if (mapVATNumOld2New.exists(vatNumOld))
		{
			conVATNumNew = mapVATNumOld2New.lookup(vatNumOld);

			if (conPeek(conVATNumNew, 1) != vatNumNew)
			{
				errorMessagePattern = salesPurch == SalesPurch::Sales ? "@SYS319372" : "@SYS319371";
				checkFailed(strFmt(errorMessagePattern, accountNum, vatNumNew, conPeek(conVATNumNew, 2), conPeek(conVATNumNew, 1)));

				invalidVATNumbers.add(vatNumNew);
			}
		}
		else
		{
			mapVATNumOld2New.insert(vatNumOld, [vatNumNew, accountNum]);
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>vendInvoicePrevQuery</Name>
				<Source><![CDATA[
    /// <summary>
	///   Creates query for selecting vendor invoices for previous year.
	/// </summary>
	/// <param name="_invoiceDate">
	///   Date range.
	/// </param>
	/// <param name="_countryRegionType">
	///   Country type range.
	/// </param>
	/// <param name="_countryRegionId">
	///   Country region id range.
	/// </param>
	/// <param name="_account">
	///   Vendor account range.
	/// </param>
	/// <param name="_VATNum">
	///   VAT number range.
	/// </param>
	public void vendInvoicePrevQuery(
        str   _invoiceDate = '',
        str   _countryRegionType = '',
        str   _countryRegionId   = '',
        str   _account     = '',
        str   _VATNum      = '')
	{
		QueryBuildDataSource    vendInvoiceJour_ds;
		QueryBuildDataSource    vendTable_ds;
		QueryBuildDataSource    countryRegion_ds;
		QueryBuildDataSource    address_ds;
		QueryBuildDataSource    qbd;
		QueryBuildDataSource    intrastatCountryRegionParameters_ds;
		QueryBuildDataSource    cashRegime_ds;

		// Add table
		vendInvoiceJour_ds = qCustVendVolume.query().addDataSource(tableNum(VendInvoiceJour), vendInvoiceJourPrev);
		// Add sorting order
		vendInvoiceJour_ds.addSortField(fieldNum(VendInvoiceJour, InvoiceDate),SortOrder::Ascending);

		// Add ranges
		if (_invoiceDate)
		{
			vendInvoiceJour_ds.addRange(fieldNum(VendInvoiceJour, InvoiceDate)).value(_invoiceDate);
		}

		if (_account)
		{
			vendInvoiceJour_ds.addRange(fieldNum(VendInvoiceJour, InvoiceAccount)).value(_account);
		}

		if (_vatNum && useJournalVATNum)
		{
			vendInvoiceJour_ds.addRange(fieldNum(VendInvoiceJour, vatNum)).value(_vatNum);
		}

		if (!CashAccountingRegime_ES::isEnabled(mkDate(1, 1, reportYear - 1)))
		{
			cashRegime_ds = vendInvoiceJour_ds.addDataSource(tableNum(CashAccountingRegime_ES));
			cashRegime_ds.joinMode(JoinMode::ExistsJoin);
			cashRegime_ds.fetchMode(QueryFetchMode::One2One);
			cashRegime_ds.addLink(fieldNum(VendInvoiceJour, InvoiceAccount), fieldNum(CashAccountingRegime_ES, VendAccount));
			cashRegime_ds.addRange(fieldNum(CashAccountingRegime_ES, Enable)).value(queryValue(NoYes::Yes));
			cashRegime_ds.addRange(fieldNum(CashAccountingRegime_ES, FromYear)).value(queryRange(SysQuery::valueUnlimited(), reportYear - 1));
			cashRegime_ds.addRange(fieldNum(CashAccountingRegime_ES, ToYear)).value(queryRange(reportYear - 1, SysQuery::valueUnlimited()));
			cashRegime_ds.addRange(fieldNum(CashAccountingRegime_ES, ToYear)).value(queryValue(0));
		}

		if (_countryRegionId || _countryRegionType || (_vatNum && !useJournalVATNum))
		{
			// Add join table (VendTable)
			vendTable_ds = vendInvoiceJour_ds.addDataSource(tableNum(VendTable));
			vendTable_ds.joinMode(JoinMode::ExistsJoin);
			vendTable_ds.fetchMode(QueryFetchMode::One2One);

			// Add Link
			vendTable_ds.addLink(fieldNum(VendInvoiceJour, InvoiceAccount),fieldNum(VendTable, AccountNum));

			if (_vatNum && !useJournalVATNum)
			{
				vendTable_ds.addRange(fieldNum(VendTable,vatNum)).value(_vatNum);
			}

			if (_countryRegionId)
			{
				//Add join table
				qbd = vendTable_ds.addDataSource(tableNum(DirPartyLocation));
				qbd.joinMode(JoinMode::ExistsJoin);
				qbd.fetchMode(QueryFetchMode::One2One);
				qbd.addLink(fieldNum(VendTable, Party), fieldNum(DirPartyLocation, Party));

				address_ds = qbd.addDataSource(tableNum(LogisticsPostalAddress));
				address_ds.joinMode(JoinMode::ExistsJoin);
				address_ds.fetchMode(QueryFetchMode::One2One);
				address_ds.addLink(fieldNum(DirPartyLocation, Location), fieldNum(LogisticsPostalAddress, Location));

				address_ds.addRange(fieldNum(LogisticsPostalAddress, CountryRegionId)).value(_countryRegionId);

			}

			if (_countryRegionType)
			{
				//Add join table
				qbd = vendTable_ds.addDataSource(tableNum(DirPartyLocation));
				qbd.joinMode(JoinMode::ExistsJoin);
				qbd.fetchMode(QueryFetchMode::One2One);
				qbd.addLink(fieldNum(VendTable, Party), fieldNum(DirPartyLocation, Party));

				address_ds = qbd.addDataSource(tableNum(LogisticsPostalAddress));
				address_ds.joinMode(JoinMode::ExistsJoin);
				address_ds.fetchMode(QueryFetchMode::One2One);
				address_ds.addLink(fieldNum(DirPartyLocation, Location), fieldNum(LogisticsPostalAddress, Location));

				countryRegion_ds = address_ds.addDataSource(tableNum(LogisticsAddressCountryRegion));
				countryRegion_ds.joinMode(JoinMode::ExistsJoin);
				countryRegion_ds.fetchMode(QueryFetchMode::One2One);
				// Add relation
				countryRegion_ds.addLink(fieldNum(LogisticsPostalAddress, CountryRegionId), fieldNum(LogisticsAddressCountryRegion, CountryRegionId));

				intrastatCountryRegionParameters_ds = countryRegion_ds.addDataSource(tableNum(IntrastatCountryRegionParameters));
				intrastatCountryRegionParameters_ds.joinMode(JoinMode::ExistsJoin);
				intrastatCountryRegionParameters_ds.fetchMode(QueryFetchMode::One2One);
				intrastatCountryRegionParameters_ds.relations(true);

				intrastatCountryRegionParameters_ds.addRange(fieldNum(IntrastatCountryRegionParameters, CountryRegionType)).value(_countryRegionType);
			}
		}

		qCustVendVolume.query().dataSourceTable(tableNum(VendInvoiceJour)).addSortField(fieldNum(VendInvoiceJour, vatNum),SortOrder::Ascending);
	}

]]></Source>
			</Method>
			<Method>
				<Name>vendInvoiceQuery</Name>
				<Source><![CDATA[
    /// <summary>
	///   Creates query for selecting vendor invoices.
	/// </summary>
	/// <param name="_invoiceDate">
	///   Date range.
	/// </param>
	/// <param name="_countryType">
	///   Country type range.
	/// </param>
	/// <param name="_countryId">
	///   Country region id range.
	/// </param>
	/// <param name="_account">
	///   Vendor account range.
	/// </param>
	/// <param name="_VATNum">
	///   VAT number range.
	/// </param>
	public void vendInvoiceQuery(
        str   _invoiceDate = '',
        str   _countryType = '',
        str   _countryId   = '',
        str   _account     = '',
        str   _VATNum      = '')
	{
		super(_invoiceDate, _countryType, _countryId, _account, _vatNum);

		qCustVendVolume.query().dataSourceTable(tableNum(VendInvoiceJour)).addSortField(fieldNum(VendInvoiceJour, vatNum),SortOrder::Ascending);
	}

]]></Source>
			</Method>
			<Method>
				<Name>vendPrepaymentsQuery</Name>
				<Source><![CDATA[
    /// <summary>
	///   Creates query for selecting vendor prepayments.
	/// </summary>
	/// <param name="_invoiceDate">
	///  Invoice dates range.
	/// </param>
	/// <param name="_countryRegionType">
	///   Country type range.
	/// </param>
	/// <param name="_countryRegionId">
	///   Country region id range.
	/// </param>
	/// <param name="_account">
	///   Vendor account range.
	/// </param>
	/// <param name="_VATNum">
	///   VAT number range.
	/// </param>
	public void vendPrepaymentsQuery(
        str   _invoiceDate,
        str   _countryRegionType,
        str   _countryRegionId,
        str   _account,
        str   _VATNum)
	{
		QueryBuildDataSource    vendTrans_ds;
		QueryBuildDataSource    vendTable_ds;
		QueryBuildDataSource    dirPartyLocation_ds;
		QueryBuildDataSource    address_ds;
		QueryBuildDataSource    intrastatCountryRegionParameters_ds;

		// Add table
		vendTrans_ds = qCustVendVolume.query().addDataSource(tableNum(VendTrans));
		vendTrans_ds.addRange(fieldNum(VendTrans, Prepayment)).value(queryValue(NoYes::Yes));

		// Add sorting order
		vendTrans_ds.addSortField(fieldNum(VendTrans, TransDate),SortOrder::Ascending);

		// Add ranges
		if (_invoiceDate)
		{
			vendTrans_ds.addRange(fieldNum(VendTrans, TransDate)).value(_invoiceDate);
		}
		if (_account)
		{
			vendTrans_ds.addRange(fieldNum(VendTrans, TransDate)).value(_account);
		}
		if (_vatNum || _countryRegionId || _countryRegionType)
		{
			vendTable_ds = vendTrans_ds.addDataSource(tableNum(VendTable));
			vendTable_ds.joinMode(JoinMode::ExistsJoin);
			vendTable_ds.fetchMode(QueryFetchMode::One2One);
			vendTable_ds.addLink(fieldNum(VendTrans, AccountNum), fieldNum(VendTable,AccountNum));

			if (_vatNum)
			{
				vendTable_ds.addRange(fieldNum(VendTable, vatNum)).value(_vatNum);
			}

			if (_countryRegionId || _countryRegionType)
			{
				//Add join table
				dirPartyLocation_ds = vendTable_ds.addDataSource(tableNum(DirPartyLocation));
				dirPartyLocation_ds.joinMode(JoinMode::ExistsJoin);
				dirPartyLocation_ds.fetchMode(QueryFetchMode::One2One);
				dirPartyLocation_ds.addLink(fieldNum(VendTable, Party), fieldNum(DirPartyLocation, Party));
				dirPartyLocation_ds.addRange(fieldNum(DirPartyLocation, IsPostalAddress)).value(queryValue(NoYes::Yes));
				dirPartyLocation_ds.addRange(fieldNum(DirPartyLocation, IsPrimary)).value(queryValue(NoYes::Yes));

				address_ds = dirPartyLocation_ds.addDataSource(tableNum(LogisticsPostalAddress));
				address_ds.addLink(fieldNum(DirPartyLocation, Location), fieldNum(LogisticsPostalAddress, Location));

				if (_countryRegionId)
				{
					address_ds.addRange(fieldNum(LogisticsPostalAddress, CountryRegionId)).value(_countryRegionId);
				}

				if (_countryRegionType)
				{
					intrastatCountryRegionParameters_ds = address_ds.addDataSource(tableNum(IntrastatCountryRegionParameters));
					intrastatCountryRegionParameters_ds.joinMode(JoinMode::ExistsJoin);
					intrastatCountryRegionParameters_ds.fetchMode(QueryFetchMode::One2One);
					intrastatCountryRegionParameters_ds.addLink(fieldNum(LogisticsPostalAddress, CountryRegionId), fieldNum(IntrastatCountryRegionParameters, CountryRegionId));
					intrastatCountryRegionParameters_ds.addRange(fieldNum(IntrastatCountryRegionParameters, CountryRegionType)).value(_countryRegionType);
				}
			}
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
	/// Creates a new instance of the <c>CustVendCalcVolumeVAT_ES</c> class.
	/// </summary>
	/// <returns>
	/// A new instance of the <c>CustVendCalcVolumeVAT_ES</c> class.
	/// </returns>
	public static CustVendCalcVolumeVATCAC_ES construct()
	{
		return new CustVendCalcVolumeVATCAC_ES();
	}

]]></Source>
			</Method>
			<Method>
				<Name>newGroupRelatedVATNums</Name>
				<Source><![CDATA[
    /// <summary>
	/// Creates a new instance of the <c>CustVendCalcVolumeVAT_ES</c> class.
	/// </summary>
	/// <param name="_groupRelatedVATNums">
	/// Indicates whether there is a need to handle the scenario when the VAT number changes during the fiscal year.
	/// </param>
	/// <returns>
	/// A new instance of the <c>CustVendCalcVolumeVAT_ES</c> class.
	/// </returns>
	public static CustVendCalcVolumeVATCAC_ES newGroupRelatedVATNums(boolean _groupRelatedVATNums = true)
	{
		CustVendCalcVolumeVATCAC_ES    custVendCalcVolumeVAT_ES;

		custVendCalcVolumeVAT_ES = new CustVendCalcVolumeVATCAC_ES();
		custVendCalcVolumeVAT_ES.parmGroupRelatedVATNums(_groupRelatedVATNums);

		return custVendCalcVolumeVAT_ES;
	}

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>