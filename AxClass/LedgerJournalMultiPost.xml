<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalMultiPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerJournalMultiPost</c> class is the entry point for all <c>LedgerJournalMultiPosting</c>
///    activities.
/// </summary>
/// <remarks>
///    The <c>main</c> method displays the <c>LedgerJournalMultiPost</c> form while the <c>run</c> method
///    is the entry point for the actual multipost task.
/// </remarks>
public class LedgerJournalMultiPost extends RunBaseMultiParm implements BatchRetryable
{
    Query query;
    Args args;
    LedgerJournalParmPost standardLedgerJournalParmPost;
    boolean isMultiSelectPostEnabled;
    boolean isLateSelectionChecked;
    static boolean parmSkipCheckBuffer;

    private boolean isSingleJournalPostEnabled;

    private const int CurrentVersion = 4;
    private const int Version3 = 3;

    private static boolean lateSelectionCache;

    #LOCALMACRO.CurrentList
        standardLedgerJournalParmPost,
        isMultiSelectPostEnabled,
        isLateSelectionChecked
    #ENDMACRO

    private boolean hasMultipleCompanies = false;
    private boolean isMultiCompanyPost = false;
    private DataAreaId firstDataArea;

    private boolean allowRunInNewSession = true;
    private boolean isOverLineLimit = false;
    private const int DefaultTopPickingBatchTasks = 8;
    private guid topPickingProcessId;
    private boolean isParmPostCleanupFlightEnabled = LedgerJournalParmPostCleanupFlight::instance().isEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    ///    true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    A class that can be used in a batch journal is a class for which the same parameters can be used
    ///    repeatedly. The dialog can be shown and the parameters can be changed but parameters of some
    ///    classes might build on data that is only valid for a short time. Not all classes can be run two
    ///    times with the same parameters. If the <c>canGoBatch</c> method returns false, this method will not
    ///    have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies whether the <c>LedgerJournalTable</c> record is valid.
    /// </summary>
    /// <param name = "_common">The <c>LedgerJournalTable</c> records.</param>
    /// <returns>True if the records are valid; otherwise, false.</returns>
    /// <remarks>The parent class this method takes a common record.</remarks>
    public boolean checkBuffer(Common _common)
    {
        LedgerJournalTable ledgerJournalTable = _common as LedgerJournalTable;
        LedgerJournalTableData ledgerJournalTableData = JournalTableData::newTable(ledgerJournalTable);
        boolean isValid = true;

        isValid = isValid && LedgerJournalParmPost::canPostJournalType(ledgerJournalTable.JournalType);
        isValid = isValid && ledgerJournalTableData.hasUserAccess();
        isValid = isValid && ledgerJournalTableData.checkOpen();
        isValid = isValid && this.verifyJournalIsNotInUse(ledgerJournalTable);
        isValid = isValid && ledgerJournalTable.approved();

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyJournalIsNotInUse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that a given journal is not in use by a session different than the current.
    /// </summary>
    /// <param name = "_ledgerJournalTable">The target journal.</param>
    /// <returns>True if the journal is either not in use or in use by the current session; else, false.</returns>
    private boolean verifyJournalIsNotInUse(LedgerJournalTable _ledgerJournalTable)
    {
        return JournalTableData::journalBlockLevel(_ledgerJournalTable) == JournalBlockLevel::None
           || _ledgerJournalTable.SessionId == sessionId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a way to clean up after a dialog box has been canceled.
    /// </summary>
    public void cleanupDialog()
    {
        LedgerJournalParmPost ledgerJournalParmPost = LedgerJournalParmPost::findByParmId(parmId);

        if (ledgerJournalParmPost == null)
        {
            LedgerJournalParmPost::deleteParameters(this.parmId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearSelection</Name>
				<Source><![CDATA[
    private void clearSelection()
    {
        // The [LateSelection=Yes] record contains the options for late selection.
        // The [LateSelection=No] records are the result of interactive selection or the previous results of recurring late selection.

        LedgerJournalParmPost ledgerJournalParmPost;
        delete_from ledgerJournalParmPost
            where ledgerJournalParmPost.ParmId == this.parmId() &&
                ledgerJournalParmPost.LateSelection == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultParmBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>LedgerJournalParmPost</c> record to use in a <c>ParmBuffer</c> map.
    /// </summary>
    /// <returns>The <c>ParmBuffer</c> record.</returns>
    public ParmBuffer defaultParmBuffer()
    {
        LedgerJournalParmPost   ledgerJournalParmPost;

        // This passes the late selection down to the base class when defining a range
        ledgerJournalParmPost.LateSelection = this.parmIsLateSelectionChecked();

        return ledgerJournalParmPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the form name.
    /// </summary>
    /// <returns>The form name.</returns>
    public formName formName()
    {
        return formstr(LedgerJournalParmPost);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the parm buffer.
    /// </summary>
    /// <param name = "_ledgerJournalParmPost">The <c>LedgerJournalParmPost</c> object to initialize.</param>
    public void initParmBuffer(ParmBuffer _ledgerJournalParmPost)
    {
        LedgerJournalParmPost ledgerJournalParmPost = _ledgerJournalParmPost;
        LedgerJournalParmPost savedLedgerJournalParmPost;

        savedLedgerJournalParmPost.data(ledgerJournalParmPost);
        ledgerJournalParmPost.data(standardLedgerJournalParmPost);

        ledgerJournalParmPost.ParmId            = savedLedgerJournalParmPost.ParmId;
        ledgerJournalParmPost.RecId             = savedLedgerJournalParmPost.RecId;
        ledgerJournalParmPost.LineNum           = savedLedgerJournalParmPost.LineNum;
        ledgerJournalParmPost.LedgerJournalId   = savedLedgerJournalParmPost.LedgerJournalId;
        ledgerJournalParmPost.JobStatus         = savedLedgerJournalParmPost.JobStatus;
        ledgerJournalParmPost.ExecutedDateTime  = savedLedgerJournalParmPost.ExecutedDateTime;
        ledgerJournalParmPost.LedgerJournalType = savedLedgerJournalParmPost.LedgerJournalType;
        ledgerJournalParmPost.LateSelection     = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>LedgerJournalParmPost</c> record that references to a <c>LedgerJournalTable</c> record.
    /// </summary>
    /// <param name = "_ledgerJournalTable">The instance of the <c>LedgerJournalTable</c> table.</param>
    /// <param name = "_ledgerJournalParmPost">The instance of the parm buffer records.</param>
    public void insert(
        Common _ledgerJournalTable,
        ParmBuffer _ledgerJournalParmPost)
    {
        LedgerJournalTable      ledgerJournalTable = _ledgerJournalTable as LedgerJournalTable;
        LedgerJournalParmPost   ledgerJournalParmPost = _ledgerJournalParmPost;

        super(ledgerJournalTable, ledgerJournalParmPost);

        ledgerJournalParmPost.JournalDataAreaId = ledgerJournalTable.DataAreaId;
        ledgerJournalParmPost.LedgerJournalType = ledgerJournalTable.JournalType;
        ledgerJournalParmPost.LedgerJournalId   = ledgerJournalTable.JournalNum;
        ledgerJournalParmPost.TransferErrors    = this.transferErrors(ledgerJournalParmPost);

        if (ledgerJournalParmPost.LedgerJournalType != LedgerJournalType::AssetBudgets)
        {
            ledgerJournalParmPost.insert();
        }

        if (!firstDataArea)
        {
            firstDataArea = ledgerJournalParmPost.JournalDataAreaId;
        }
        else if (firstDataArea != ledgerJournalParmPost.JournalDataAreaId)
        {
            hasMultipleCompanies = true;
        }

        if (LedgerJournalForcedJournalSplitFeature::isEnabled()
            && LedgerJournalTable::journalTypeAllowsSplitting(ledgerJournalTable.JournalType)
            && ledgerJournalTable.numOfLines() > LedgerJournalMaxLineLimit::getMaxLineLimit())
        {
            this.isOverLineLimit = true;
        }
        else
        {
            // Explicitly mark as false to cover the case where the feature is enabled, but the
            // journal type does not allow splitting
            this.isOverLineLimit = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastLineNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last line number.
    /// </summary>
    /// <returns>The number of the last line.</returns>
    public LineNum lastLineNum()
    {
        return LedgerJournalParmPost::lastLineNum(parmId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the dialog system should be used for dialogs or if the system should be the form
    ///    that is created in the <c>dialog</c> method.
    /// </summary>
    /// <returns>
    ///    true if the dialog system should be used; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    By using the dialog system, a Batch tab page is added to the form.
    /// </remarks>
    public boolean mustUseDialog()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the object into a container object.
    /// </summary>
    /// <returns>A packed container</returns>
    public container pack()
    {
        container packed = [CurrentVersion, #CurrentList, super(), this.query().pack()];
        packed = SysPackExtensions::appendVariableToPack(packed, classStr(LedgerJournalMultiPost), varStr(isMultiCompanyPost), this.parmIsMultiCompanyPost());
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        // When we post a single journal we want to use the journal that was initialized, not the one from SysLastValues.
        // We also do not put isSingleJournalPostEnabled into the pack list, so the correct choices can be packed, unpacked and run.
        if (isSingleJournalPostEnabled)
        {
            return true;
        }

        Version version = RunBase::getVersion(packedClass);
        container baseClass;
        container packedQuery;

        switch (version)
        {
            case CurrentVersion:
                [version, #CurrentList, baseClass, packedQuery] = packedClass;

                super(baseClass);

                query = new Query(packedQuery);
                isMultiCompanyPost = SysPackExtensions::extractPackedVariable(packedClass, classStr(LedgerJournalMultiPost), varStr(isMultiCompanyPost));

                break;
            case Version3:
                [version, #CurrentList, baseClass] = packedClass;

                super(baseClass);

                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmArgs</Name>
				<Source><![CDATA[
    private void parmArgs(Args _args)
    {
        args = _args;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsLateSelectionChecked</Name>
				<Source><![CDATA[
    /// <summary>
    /// A parameter that indicates if late selection is checked.
    /// </summary>
    /// <param name = "_isLateSelectionChecked">Indicates if late selection is checked.</param>
    /// <returns>True if late selection is checked; otherwise false.</returns>
    public boolean parmIsLateSelectionChecked(boolean _isLateSelectionChecked = isLateSelectionChecked)
    {
        isLateSelectionChecked = _isLateSelectionChecked;

        return isLateSelectionChecked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsMultiSelectPostEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// A parameter that indicates if multi select post is enabled.
    /// </summary>
    /// <param name = "_isMultiSelectPostEnabled">Indicates if multi select post is enabled.</param>
    /// <returns>True if multi select post is enabled; otherwise false.</returns>
    public boolean parmIsMultiSelectPostEnabled(boolean _isMultiSelectPostEnabled = isMultiSelectPostEnabled)
    {
        isMultiSelectPostEnabled = _isMultiSelectPostEnabled;

        return isMultiSelectPostEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStandardParm</Name>
				<Source><![CDATA[
    /// <summary>
    /// A parameter that stores the standard buffer.
    /// </summary>
    /// <param name = "_standard">The standard buffer.</param>
    /// <returns>The standard buffer.</returns>
    public ParmBuffer parmStandardParm(ParmBuffer _standard = standardLedgerJournalParmPost)
    {
        standardLedgerJournalParmPost = _standard;

        return standardLedgerJournalParmPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsMultiCompanyPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// A parameter that indicates if this post is from multi company journal post
    /// </summary>
    /// <param name = "_isMultiCompanyPost">Indicates if this journal post is from multi company journal post</param>
    /// <returns>True if post is initiated from multi company journal post</returns>
    internal boolean parmIsMultiCompanyPost(boolean _isMultiCompanyPost = isMultiCompanyPost)
    {
        isMultiCompanyPost = _isMultiCompanyPost;
        return isMultiCompanyPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTopPickingProcessId</Name>
				<Source><![CDATA[
    internal guid parmTopPickingProcessId(guid _topPickingProcessId = topPickingProcessId)
    {
        topPickingProcessId = _topPickingProcessId;
        return topPickingProcessId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>query</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a query object from ledger journal multi post settings.
    /// </summary>
    /// <returns>
    /// A query object.
    /// </returns>
    public Query query()
    {
        if (query == null)
        {
            query = new Query(querystr(LedgerJournalMultiPost));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the multi-post task.
    /// </summary>
    /// <remarks>
    /// This is the entry point for ledger journal multi-posting.
    /// </remarks>
    public void run()
    {
        BatchTaskBundleAssembler    batchTaskBundleAssembler; // Bulks together tasks

        setprefix(LedgerJournalMultiPost::description());

        LedgerJournalParmPost ledgerJournalParmPost;

        using (SysInstrumentationActivityContext activityContext = LedgerJournalPostingInstrumentation::getActivityContext(
            LedgerJournalInstrumentationConstants::SourceNameLedgerJournalPosting,
            classStr(LedgerJournalMultiPost),
            classStr(LedgerJournalMultiPost)))
        {

            if (this.isInBatch())
            {
                
                if (!isParmPostCleanupFlightEnabled)
                {
                    // This deletePosted() should not be used here.
                    // This deletion causes blocking & deadlock issue when multiple batch posting running at the same time,
                    // and it is searching for the whole LedgerJournalParmPost table, instead of the current parmId.
                    // This journal posting should only focus on the content based on 'parmId'
                    // If journal has been posted, it can be excluded from batch at the end of postSelectedJournals()
                    // For late selection, the parm records are based on late selection query, this function doesn't impact late selection.
                    // For recurring batch scenarios, check if journal has been posted later to avoid duplicate posting.
                    LedgerJournalParmPost::deletePosted();
                }

                // This is running in batch, so construct an object for bulking the tasks.
                batchTaskBundleAssembler = BatchTaskBundleAssembler::construct(this.parmCurrentBatch(), classnum(LedgerPostBatchTaskBundle));

                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::IsBatch, any2Str(true));
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::BatchJobId, any2Str(this.parmCurrentBatch().BatchJobId));
            }
            else
             {
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::IsBatch, any2Str(false));
            }

            if (isLateSelectionChecked)
            {
                select firstonly ledgerJournalParmPost
                order by ledgerJournalParmPost.RecId
                where ledgerJournalParmPost.ParmId == parmId &&
                    ledgerJournalParmPost.LateSelection == NoYes::Yes;

                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::IsLateSelection, any2Str(true));
                if (ledgerJournalParmPost == null || ledgerJournalParmPost.LateSelectionQuery == connull())
                {
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::Error, 'Empty LedgerJournalParamPost Object');
                    // nothing to do
                    return;
                }


                this.clearSelection();

                this.selectQueryResults(new Query(ledgerJournalParmPost.LateSelectionQuery), ledgerJournalParmPost.TransferErrors);

                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::ParmPostRecId, any2Str(ledgerJournalParmPost.RecId));
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::TransferErrors, any2Str(ledgerJournalParmPost.TransferErrors));
            }
            else
            {
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::IsLateSelection, any2Str(false));
            }
        }

        this.postSelectedJournals(batchTaskBundleAssembler);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doBatch</Name>
				<Source><![CDATA[
    protected void doBatch()
    {
        if (hasMultipleCompanies && LedgerJournalMultiCompanyPostFeature::isEnabled())
        {
            Map companyParmIdMap = this.moveParmRecordsToJournalCompanies();
            MapEnumerator companyParmIdMapEnum = companyParmIdMap.getEnumerator();
            while (companyParmIdMapEnum.moveNext())
            {
                changecompany(companyParmIdMapEnum.currentKey())
                {
                    LedgerJournalMultiCompanyPostController multiCompanyPost = new LedgerJournalMultiCompanyPostController();
                    multiCompanyPost.parmDialogCaption(strFmt('%1: %2', this.batchInfo().parmCaption(), companyParmIdMapEnum.currentKey()));
                    
                    LedgerJournalMultiCompanyPostContract contract = multiCompanyPost.getDataContractObject() as LedgerJournalMultiCompanyPostContract;
                    contract.parmMultiPostPackedContainer(this.pack());
                    contract.parmId(companyParmIdMapEnum.currentValue());

                    multiCompanyPost.runOperation();
                }
            }
        }
        else
        {
            // Let the default behavior happen
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSelectedJournals</Name>
				<Source><![CDATA[
    private void postSelectedJournals(BatchTaskBundleAssembler batchTaskBundleAssembler)
    {
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalParmPost ledgerJournalParmPost;
        LedgerJournalParmPostCounts ledgerJournalParmPostCount;
        boolean canUseTopPicking = this.canJournalPostUseTopPicking();
        RecordInsertList ledgerJournalPostQueueList;
        #OCCRetryCount

        insert_recordset ledgerJournalParmPostCount (LedgerJournalId, NumberOfLines)
            select JournalNum, count(RecId) from ledgerJournalTrans
                group by JournalNum
            join ledgerJournalParmPost
                where ledgerJournalParmPost.LedgerJournalId == ledgerJournalTrans.JournalNum
                    && ledgerJournalParmPost.ParmId == parmId;

        if (!isLateSelectionChecked)
        {
            // insert records for the selected journals with zero lines because
            // everything the user selected should be posted and they were not
            // added above because by definition no LedgerJournalTrans records exist
            LedgerJournalParmPostCounts ledgerJournalParmPostCountNotExist = ledgerJournalParmPostCount;

            insert_recordset ledgerJournalParmPostCount (LedgerJournalId)
                select LedgerJournalId from ledgerJournalParmPost
                    where ledgerJournalParmPost.ParmId == parmId
                notexists join ledgerJournalParmPostCountNotExist
                    where ledgerJournalParmPostCountNotExist.LedgerJournalId == ledgerJournalParmPost.LedgerJournalId;
        }

        if (canUseTopPicking)
        {
            LedgerJournalPostQueue::cleanUpJournalPostQueue();
            ledgerJournalPostQueueList = new RecordInsertList(tableNum(LedgerJournalPostQueue));
            topPickingProcessId = newGuid();
        }

        using (SysInstrumentationActivityContext activityContext = LedgerJournalPostingInstrumentation::getActivityContext(
            LedgerJournalInstrumentationConstants::SourceNameLedgerJournalPosting, classStr(LedgerJournalMultiPost),
            classStr(LedgerJournalMultiPost)))
        {
            activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::CanUseTopPicking, any2Str(canUseTopPicking));
            activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::IsMultiCompanyPost, any2Str(isMultiCompanyPost));
            if (canUseTopPicking)
            {
                activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::TopPickingProcessId, any2Str(topPickingProcessId));
            }

            int maxLineLimit = LedgerJournalMaxLineLimit::getMaxLineLimit();
            boolean hasPostedJournalSkipped = false;

            while select LedgerJournalId, TransferErrors from ledgerJournalParmPost
                where ledgerJournalParmPost.ParmId == parmId
                join NumberOfLines from ledgerJournalParmPostCount
                where ledgerJournalParmPostCount.LedgerJournalId == ledgerJournalParmPost.LedgerJournalId
            {
                try
                {
                    LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(ledgerJournalParmPost.LedgerJournalId);

                    activityContext.addCustomProperty(
                        LedgerJournalInstrumentationConstants::MagnitudeOfJournalLines,
                        ApplicationCommonInstrumentationMagnitude::log10magnitude(ledgerJournalParmPostCount.NumberOfLines));
                    activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::TransferErrors, any2Str(ledgerJournalParmPost.TransferErrors));

                    if (LedgerJournalForcedJournalSplitFeature::isEnabled()
                        && LedgerJournalTable::journalTypeAllowsSplitting(ledgerJournalTable.JournalType))
                    {
                        activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::JournalMaxLineLimit, any2Str(maxLineLimit));
                    }

                    // skip journal that has been posted
                    if (isParmPostCleanupFlightEnabled && ledgerJournalTable.Posted)
                    {
                        hasPostedJournalSkipped = true;
                        continue;
                    }

                    if (canUseTopPicking)
                    {
                        this.addToLedgerJournalPostQueueRecordList(
                            ledgerJournalPostQueueList,
                            ledgerJournalParmPost.LedgerJournalId,
                            ledgerJournalParmPost.TransferErrors,
                            any2Int(ledgerJournalParmPostCount.NumberOfLines));
                    }
                    else
                    {
                        LedgerJournalPostBatch ledgerJournalPostBatch = LedgerJournalPostBatch::construct(
                        ledgerJournalParmPost.LedgerJournalId,
                        ledgerJournalParmPost.TransferErrors,
                        false,
                        int642int(ledgerJournalParmPostCount.NumberOfLines));

                        if (batchTaskBundleAssembler != null)
                        {
                            // This is being run as batch, so add the task to a batch bundle.
                            batchTaskBundleAssembler.addTask(ledgerJournalPostBatch);
                        }
                        else
                        {
                            // This is being run outside of a batch, so just post the
                            // journal now.
                            ledgerJournalPostBatch.runOperation();
                        }
                    }
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::Deadlock;
                    }
                    else
                    {
                        retry;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (appl.ttsLevel() == 0)
                    {
                        if (xSession::currentRetryCount() >= #RetryNum)
                        {
                            throw Exception::UpdateConflictNotRecovered;
                        }
                        else
                        {
                            retry;
                        }
                    }
                    else
                    {
                        throw Exception::UpdateConflict;
                    }
                }
                catch (Exception::Error)
                {
                    // catch the errors so processing can continue
                    curext(); // avoids a warning about an empty block
                }
            }

            activityContext.addCustomProperty(LedgerJournalInstrumentationConstants::HasPostedJournalSkipped, any2Str(hasPostedJournalSkipped));
        }

        if (canUseTopPicking)
        {
            this.insertIntoTopPickingQueue(ledgerJournalPostQueueList);
            this.createTopPickingTasks(topPickingProcessId);
        }
        else if  (batchTaskBundleAssembler != null)
        {
            // This is in batch, so schedule the queued tasks.
            batchTaskBundleAssembler.scheduleBundledTasks();
        }

        // Every journal has been scheduled or run, clean the parm table
        if (isParmPostCleanupFlightEnabled 
            && (this.parmId() != ''))
        {
            if (isLateSelectionChecked)
            {
                this.clearSelection();
            }
            else
            {
                LedgerJournalParmPost::deleteParameters(this.parmId());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether this batch job will be run on the Application Object Server (AOS).
    /// </summary>
    /// <returns>
    ///    true if this batch job will be run on the AOS; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method always returns true.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectQueryResults</Name>
				<Source><![CDATA[
    private void selectQueryResults(Query _journalsQuery, boolean _transferErrors)
    {
        RecordInsertList insertList = new RecordInsertList(tableNum(LedgerJournalParmPost));

        QueryRun journalsQuery = new QueryRun(_journalsQuery);
        while (journalsQuery.next())
        {
            LedgerJournalTable ledgerJournalTable  = journalsQuery.get(tablenum(LedgerJournalTable));

            if (this.checkBuffer(ledgerJournalTable)
                && this.ledgerJournalNotExistInParmTable(ledgerJournalTable.JournalNum))
            {
                LedgerJournalParmPost ledgerJournalParmPostToAdd;
                ledgerJournalParmPostToAdd.LedgerJournalId = ledgerJournalTable.JournalNum;
                ledgerJournalParmPostToAdd.TransferErrors = _transferErrors;
                ledgerJournalParmPostToAdd.ParmId = parmId;

                insertList.add(ledgerJournalParmPostToAdd);
            }
        }

        insertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferErrors</Name>
				<Source><![CDATA[
    private boolean transferErrors(LedgerJournalParmPost _ledgerJournalParmPost)
    {
        if (args)
        {
            if (args.parmEnumType() == enumnum(UnknownNoYes))
            {
                switch (args.parmEnum())
                {
                    case UnknownNoYes::Yes :
                        return true;

                    case UnknownNoYes::No :
                        return false;
                }
            }
        }
        return _ledgerJournalParmPost.TransferErrors;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether validation should be called.
    /// </summary>
    /// <param name = "calledFrom">Indicates if it should be called from client or server.</param>
    /// <returns>True if validation should occure; otherwise false.</returns>
    public boolean validate(Object calledFrom = null)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerJournalMultiPost</c> class.
    /// </summary>
    /// <param name = "_args">The parameter arguments.</param>
    /// <returns>A new instance of a <c>LedgerJournalMultiPost</c> object.</returns>
    public static LedgerJournalMultiPost construct(Args _args)
    {
        LedgerJournalMultiPost  ledgerJournalMultiPost;

        ledgerJournalMultiPost = new LedgerJournalMultiPost();
        ledgerJournalMultiPost.parmArgs(_args);

        return ledgerJournalMultiPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the classe description
    /// </summary>
    /// <returns>The description.</returns>
    public static ClassDescription description()
    {
        return "@SYS86511";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// The entry point for the run base class.
    /// </summary>
    /// <param name = "_args">The arguments.</param>
    public static void main(Args _args)
    {
        LedgerJournalMultiPost  ledgerJournalMultiPost;

        if (_args.parmEnum() == RunChoose::Run)
        {
            ledgerJournalMultiPost = LedgerJournalMultiPost::construct(_args);
            RunBaseMultiParm::initFromForm(ledgerJournalMultiPost, _args);

            // Set this property so previous form usage from a multi-section posting
            // will not be carried forward from the "SyslastValues".
            ledgerJournalMultiPost.parmIsMultiSelectPostEnabled(false);

            // Restore the late selection value using the cache.
            // To preserve user preferences in ledgerJournalParamPost form.
            if (lateSelectionCache)
            {
                ledgerJournalMultiPost.parmIsLateSelectionChecked(lateSelectionCache);
            }

            // This ensures that the records in query are being refreshed every time the 'Post Journals' form is opened manually.
            ledgerJournalMultiPost.onLateSelectionModified(ledgerJournalMultiPost.defaultParmBuffer());

            if (!ledgerJournalMultiPost.prompt())
            {
                return;
            }

            ledgerJournalMultiPost.runOperation();

            // Reset the cache after the first run operation.
            if (lateSelectionCache)
            {
                lateSelectionCache = false;
            }
        }
        else
        {
            RunBaseMultiParm::runSpecial(_args);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>singleJournalPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post a single journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">Identifies the journal.</param>
    /// <remarks>
    /// This method allows the user to run the posting of a single journal in batch and the ability
    /// to split that journal into smaller journals for better performance.
    /// </remarks>
    public static void singleJournalPost(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalMultiPost ledgerJournalMultiPost = new LedgerJournalMultiPost();

        ledgerJournalMultiPost.initParmId();

        ledgerJournalMultiPost.parmIsMultiSelectPostEnabled(false);
        ledgerJournalMultiPost.parmIsSingleJournalPostEnabled(true);

        ParmBuffer parmBuffer = ledgerJournalMultiPost.defaultParmBuffer();
        ledgerJournalMultiPost.insert(_ledgerJournalTable, parmBuffer);

        if (!ledgerJournalMultiPost.prompt())
        {
            return;
        }

        ledgerJournalMultiPost.runOperation();

    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSingleJournalPostEnabled</Name>
				<Source><![CDATA[
    public boolean parmIsSingleJournalPostEnabled(boolean _isSingleJournalPostEnabled = isSingleJournalPostEnabled)
    {
        isSingleJournalPostEnabled = _isSingleJournalPostEnabled;

        return isSingleJournalPostEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>multiSelectPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Supports the multiselection posting functionality for a supplied list of <c>LedgerJournalTable</c>
    ///    records.
    /// </summary>
    /// <param name="_caller">
    ///    The object that calls the method.
    /// </param>
    /// <param name="_ledgerJournalTableSortedList">
    ///    A <c>RecordSortedList</c> of <c>LedgerJournalTable</c> records.
    /// </param>
    /// <param name="_transferErrors">
    ///    A <c>NoYes</c> enumeration value that controls the transfer of posting errors; optional.
    /// </param>
    /// <remarks>
    ///    This method is designed specifically for supporting a multiselection posting scenario from the
    ///    <c>LedgerJournalTable</c> form.
    /// </remarks>
    public static void multiSelectPost(Object _caller, RecordSortedList _ledgerJournalTableSortedList, NoYes _transferErrors = NoYes::No)
    {
        LedgerJournalTable          ledgerJournalTable;
        LedgerJournalMultiPost      ledgerJournalMultiPost;
        LedgerJournalParmPost       ledgerJournalParmPost;
        LedgerJournalFormTable      ledgerJournalFormTable;

        if (typeof(_caller) != typeof(ledgerJournalFormTable))
        {
            return;
        }

        //  There is nothing to do if the RecordSortedList is empty.
        if (!_ledgerJournalTableSortedList.first(ledgerJournalTable))
        {
            return;
        }

        //  Set the TransferErrors property.
        ledgerJournalParmPost.TransferErrors = _transferErrors;

        //
        //  Create a LedgerJournalMultiPost class instance using the supplied RecordSortedList and
        //  the current LedgerJournaLParmPost buffer.
        //
        ledgerJournalMultiPost = LedgerJournalTable::insertJournalsInLedgerJournalMultiPost(_ledgerJournalTableSortedList, ledgerJournalParmPost);

        if (ledgerJournalMultiPost)
        {
            //
            //  Set the isMultiSelectPostEnabled property to "true".
            //  This indicates that the LedgerJournalMultiPost instance
            //  was created to support a multi-select posting scenario.
            //
            ledgerJournalMultiPost.parmIsMultiSelectPostEnabled(true);

            // Reset and cache current late selection value when using multi select post.
            // Since late selection is not explicitly available through ledgerJournalFormTable.
            if (ledgerJournalMultiPost.parmIsLateSelectionChecked())
            {
                lateSelectionCache = ledgerJournalMultiPost.parmIsLateSelectionChecked();
                ledgerJournalMultiPost.parmIsLateSelectionChecked(false);
            }

            if (!LedgerJournalMultiPost::runSilent(ledgerJournalMultiPost, _caller, _ledgerJournalTableSortedList, _transferErrors) && !ledgerJournalMultiPost.prompt())
            {
                return;
            }

            //  Post the journals.
            ledgerJournalMultiPost.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runSilent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the posting should be done without prompting the user.
    /// </summary>
    /// <param name = "_ledgerJournalMultiPost">
    /// An instance of the <c>LedgerJournalMultiPost</c> class.
    /// </param>
    /// <param name="_caller">
    /// The object that calls the method.
    /// </param>
    /// <param name="_ledgerJournalTableSortedList">
    /// A <c>RecordSortedList</c> of <c>LedgerJournalTable</c> records.
    /// </param>
    /// <param name="_transferErrors">
    /// A <c>NoYes</c> enumeration value that controls the transfer of posting errors.
    /// </param>
    /// <returns>
    /// true if the posting should be done without prompting the user; otherwise, false.
    /// </returns>
    protected static boolean runSilent(LedgerJournalMultiPost _ledgerJournalMultiPost, Object _caller, RecordSortedList _ledgerJournalTableSortedList, NoYes _transferErrors)
    {
        // This method is used for extensibility.
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTableWithQueryResults</Name>
				<Source><![CDATA[
    protected void populateTableWithQueryResults(ParmBuffer _parmBuffer, RunBaseMultiParm _runBaseMultiParm, ParmId _parmId, QueryRun _queryRun)
    {
        query = _queryRun.query();

        if (_parmBuffer.TableId == tableNum(LedgerJournalParmPost) && _parmBuffer.LateSelection)
        {
            this.updateForLateSelection();
        }
        else
        {
            this.updateForQueryResults(_parmBuffer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLateSelectionModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>LedgerJournalParmPost</c> records based on the late selection setting.
    /// </summary>
    /// <param name = "_parmBuffer">The <c>ParmBuffer</c>.</param>
    public void onLateSelectionModified(ParmBuffer _parmBuffer)
    {
        if (this.parmIsLateSelectionChecked())
        {
            this.updateForLateSelection();
        }
        else
        {
            this.updateForQueryResults(_parmBuffer);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateForLateSelection</Name>
				<Source><![CDATA[
    private void updateForLateSelection()
    {
        LedgerJournalParmPost ledgerJournalParmPostTmp;

        ttsbegin;

        this.clearSelection();

        select forupdate ledgerJournalParmPostTmp
            where (ledgerJournalParmPostTmp.ParmId == this.parmId() &&
                ledgerJournalParmPostTmp.LateSelection == true);

        if (ledgerJournalParmPostTmp.RecId != 0)
        {
            ledgerJournalParmPostTmp.LateSelectionQuery = this.query().pack();
            ledgerJournalParmPostTmp.update();
        }
        else
        {
            ledgerJournalParmPostTmp.LineNum = this.nextLineNum();
            ledgerJournalParmPostTmp.ParmId = this.parmId();
            ledgerJournalParmPostTmp.LateSelectionQuery = this.query().pack();
            ledgerJournalParmPostTmp.LateSelection = true;

            ledgerJournalParmPostTmp.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateForQueryResults</Name>
				<Source><![CDATA[
    private void updateForQueryResults(ParmBuffer _parmBuffer)
    {
        // Remove any existing records before adding records for the new query.
        if (this.parmId() != '')
        {
            LedgerJournalParmPost::deleteParameters(this.parmId());
        }

        QueryRun queryRun = new QueryRun(this.query());

        ttsbegin;

        // Populate the mapped table for all the records in the query.
        while (queryRun.next())
        {
            try
            {
                if (this.checkBuffer(queryRun.get(tableNum(LedgerJournalTable))))
                {
                    _parmBuffer.Linenum++;
                    this.insert(queryRun.get(tableNum(LedgerJournalTable)), _parmBuffer);
                }
            }
            catch (Exception::Error)
            {
                exceptionTextFallThrough();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return allowRunInNewSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowRuninNewSession</Name>
				<Source><![CDATA[
    internal boolean parmAllowRuninNewSession(boolean _allowRunInNewSession = allowRunInNewSession)
    {
        allowRunInNewSession = _allowRunInNewSession;

        return allowRunInNewSession;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGoBatch</Name>
				<Source><![CDATA[
    public boolean mustGoBatch()
    {
        if (LedgerJournalForcedJournalSplitFeature::isEnabled()
            && this.isOverLineLimit)
        {
            return true;
        }

        if (LedgerJournalMultiCompanyPostFeature::isEnabled())
        {
            // If there are journals from multiple companies in the set for this run, force batch mode. Otherwise user can select batch or interactive.
            return super() || hasMultipleCompanies;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveParmRecordsToJournalCompanies</Name>
				<Source><![CDATA[
    internal Map moveParmRecordsToJournalCompanies()
    {
        Map companyParmIdMap = new Map(Types::String, Types::String);

        DataAreaId rootCompany = curExt();

        // For each distinct company in LedgerJournalParmPost, copy those records into the real companies so the DataAreaId column is correct
        LedgerJournalParmPost parmPostCompanies;
        while select JournalDataAreaId
            from parmPostCompanies
            group by parmPostCompanies.JournalDataAreaId
            where parmPostCompanies.ParmId == this.parmId()
              && parmPostCompanies.JournalDataAreaId != ''
        {
            changecompany(parmPostCompanies.JournalDataAreaId)
            {
                // Each company has its own ParmId number sequence, do not reuse the original one.
                ParmId companyParmPost = RunBaseMultiParm::getSysParmId();
                companyParmIdMap.insert(parmPostCompanies.JournalDataAreaId, companyParmPost);

                LedgerJournalParmPost sourceParmPost, destParmPost;

                RecordInsertList destParmPostList = new RecordInsertList(tableNum(LedgerJournalParmPost), true, true, true, true, false);

                while select crosscompany:[rootCompany] *
                    from sourceParmPost 
                where sourceParmPost.DataAreaId == rootCompany
                    && sourceParmPost.ParmId == this.parmId()
                    && sourceParmPost.JournalDataAreaId == parmPostCompanies.JournalDataAreaId
                {
                    destParmPost.clear();
                    destParmPost.data(sourceParmPost);
                    // Can't set DataAreaId column directly
                    destParmPost.setFieldValue(fieldStr(LedgerJournalParmPost, DataAreaId), destParmPost.JournalDataAreaId);
                    destParmPost.ParmId = companyParmPost;
                    destParmPost.JournalDataAreaId = '';
                    destParmPostList.add(destParmPost);
                }

                destParmPostList.insertDatabase();
            }
        }

        // Purge the source records to prevent incorrect or double posting.
        // There will be a new ParmId generated for each company so the records with the current ParmId are safe to delete.
        LedgerJournalParmPost::deleteParameters(this.parmId());

        return companyParmIdMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalNotExistInParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if this journal number exists in the LedgerJournalParmPost table it will check if same journal number exists with the same parmId.
    /// It does not care if there exists same journal number on DIFFERENT parmId.
    /// If there exists same journal number on DIFFERENT parmId, it means either the journal was posted before OR
    /// the journal is pending to be posted in another thread.    
    /// 
    /// NOTE: LedgerJournalParmPost table indicates which journal can be scheduled to post.
    /// if journal number is existed in parm table, it means this journal was posted before or the journal is pending to be posted.
    /// </summary>
    /// <param name = "_journalNum">ledger journal number</param>
    /// <returns>True if it exists in LedgerJournalParmPost, otherwise false</returns>
    private boolean ledgerJournalNotExistInParmTable(LedgerJournalId _journalNum)
    {
        return !LedgerJournalParmPost::exist(parmId, _journalNum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canJournalPostUseTopPicking</Name>
				<Source><![CDATA[
    private boolean canJournalPostUseTopPicking()
    {
        // support top picking feature when feature enabled and running in batch
        // For global journal, if there is multiple companies selected, do not use top picking.
        if (FeatureStateProvider::isFeatureEnabled(LedgerJournalPostTopPickingFeature::instance()) &&
            this.isInBatch() &&
            !this.parmIsMultiCompanyPost())
        {
            return true;
        }

        return false; 
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitJournalList</Name>
				<Source><![CDATA[
    private RecordSortedList getSplitJournalList(LedgerJournalTable _journalTable)
    {
        LedgerJournalTable ledgerJournalTable;
        RecordSortedList splittedJournals;

        ledgerJournalTable = _journalTable;

        // This will check if it is eligible for split, LedgerJournalForcedJournalSplitFeature check is inside this function
        if (ledgerJournalTable.isEligableForDistributionBeforePost())
        {
            // Split the journal; the pre-existing journal is not included in the returned list.
            splittedJournals = ledgerJournalTable.distributeJournalLines(true); // suppress client messages if inside of a batch process
        }
        else
        {
            splittedJournals = new RecordSortedList(tableNum(LedgerJournalTable));
        }

        // The journal was split.
        // Add the main table because splittedJournals only includes the newly created journals.
        splittedJournals.ins(_journalTable);

        return splittedJournals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToLedgerJournalPostQueueRecordList</Name>
				<Source><![CDATA[
    private void addToLedgerJournalPostQueueRecordList(
        RecordInsertList _journalPostQueueList,
        LedgerJournalId _journalId, 
        boolean _transferErrors,
        int _numberOfJournalLines = -1)
    {
        if (LedgerJournalPostTopPickingAutoSplitFixFlight::instance().isEnabled())
        {
            LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(_journalId);

            RecordSortedList journalsToPost = this.getSplitJournalList(ledgerJournalTable);

            // reset journal record link
            ledgerJournalTable = null;
            while (journalsToPost.next(ledgerJournalTable))
            {
                LedgerJournalPostQueue journalPostRecord;
                journalPostRecord.ProcessId = this.topPickingProcessId;
                journalPostRecord.JournalNum = ledgerJournalTable.JournalNum;
                journalPostRecord.TransferErrors = _transferErrors;
                journalPostRecord.NumberOfLines = any2Int(ledgerJournalTable.numOfLines());
                // split has been done, no need to check split again
                journalPostRecord.isJournalSplitForbidden = true;

                _journalPostQueueList.add(journalPostRecord);
            }
        }
        else
        {
            LedgerJournalPostQueue journalPostRecord;
            journalPostRecord.ProcessId = this.topPickingProcessId;
            journalPostRecord.JournalNum = _journalId;
            journalPostRecord.TransferErrors = _transferErrors;
            journalPostRecord.NumberOfLines = _numberOfJournalLines;
            journalPostRecord.isJournalSplitForbidden = false;

            _journalPostQueueList.add(journalPostRecord);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoTopPickingQueue</Name>
				<Source><![CDATA[
    private void insertIntoTopPickingQueue(RecordInsertList _journalPostQueueList)
    {
        _journalPostQueueList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTopPickingTasks</Name>
				<Source><![CDATA[
    private void createTopPickingTasks(guid _processId)
    {
        int maxTasks = this.getMaxNumberTopPickBatchTasks();
        var batchHeader = this.getOrCreateBatchHeader();

        for (int i = 1; i <= maxTasks; i++)
        {
            LedgerJournalPostBatch ledgerJournalPostBatchTask = LedgerJournalPostBatch::construct('', false);
            ledgerJournalPostBatchTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
            ledgerJournalPostBatchTask.parmIsTopPickingPost(true);
            ledgerJournalPostBatchTask.parmTopPickingProcessId(_processId);

            batchHeader.addRuntimeTask(ledgerJournalPostBatchTask, this.parmCurrentBatch().RecId);
        }
        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateBatchHeader</Name>
				<Source><![CDATA[
    private BatchHeader getOrCreateBatchHeader()
    {
        Batchheader batchHeader = BatchHeader::getCurrentBatchHeader();

        if (batchHeader == null)
        {
            batchHeader = BatchHeader::construct();
        }

        return batchHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxNumberTopPickBatchTasks</Name>
				<Source><![CDATA[
    private int getMaxNumberTopPickBatchTasks()
    {
        LedgerParameters ledgerParameters = LedgerParameters::find();

        if (ledgerParameters.LedgerJournalPostMaxTopPickingTasks <= 0)
        {
            return DefaultTopPickingBatchTasks;
        }
        else 
        {
            return ledgerParameters.LedgerJournalPostMaxTopPickingTasks;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>