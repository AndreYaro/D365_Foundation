<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetTransfer</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>AssetTransfer</c> class is used to transfer fixed assets from one dimension set to another,
/// to store the asset transfer history, to update the default dimensions of the value model, and to
/// make journal entries.
/// </summary>
public class AssetTransfer
{
    protected DimensionDefault newDefaultDimension;
    protected TransferDate transferDate;
    private TransferComment transferComment;
    private AssetTmpAssetTransferHistory assetTmpAssetTransferHistory;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addLedgerVoucherTransObjects</Name>
				<Source><![CDATA[
    private void addLedgerVoucherTransObjects(
        LedgerVoucherObject _ledgerVoucherObject,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        DimensionDefault _defaultDimension,
        DimensionDefault _transferHistoryDefaultDimension,
        TransDate _exchangeRateDate,
        TransferComment _transferComment)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount oldLedgerDimension;
        LedgerDimensionAccount newLedgerDimension;

        AssetTransferInitializeLedgerVoucherTransObjectParameters parameters = AssetTransferInitializeLedgerVoucherTransObjectParameters::construct();

        parameters.parmGeneralJournalAccountEntry(_generalJournalAccountEntry);
        parameters.parmDefaultDimension(_defaultDimension);
        parameters.parmTransferHistoryDefaultDimension(_transferHistoryDefaultDimension);
        parameters.parmExchangeRateDate(_exchangeRateDate);
        parameters.parmTransferComment(_transferComment);

        // For new transactions create a new ledger dimension with old main account and new DefaultDimension.
        newLedgerDimension = this.createLedgerDimension(_generalJournalAccountEntry.LedgerDimension, newDefaultDimension);
        parameters.parmNewLedgerDimension(newLedgerDimension);

        ledgerVoucherTransObject = this.initializeOldLedgerVoucherTransObject(parameters);
        _ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

        ledgerVoucherTransObject = this.initializeNewLedgerVoucherTransObject(parameters);
        _ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeNewLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> object.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>AssetTransferInitializeLedgerVoucherTransObjectParameters</c> instance with parameters to initialize <c>LedgerVoucherTransObject</c> object.
    /// </param>
    /// <returns>
    /// Initialized <c>LedgerVoucherTransObject</c> object.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeNewLedgerVoucherTransObject(AssetTransferInitializeLedgerVoucherTransObjectParameters _parameters)
    {
        // Create a new entry with new ledger dimension
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(_parameters.parmGeneralJournalAccountEntry());
        ledgerVoucherTransObject.parmLedgerDimensionId(_parameters.parmNewLedgerDimension());
        ledgerVoucherTransObject.parmHistoricalExchangeRateDate(_parameters.parmExchangeRateDate());

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeOldLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the fields of <c>LedgerVoucherTransObject</c> object.
    /// </summary>
    /// <param name = "_parameters">
    /// An <c>AssetTransferInitializeLedgerVoucherTransObjectParameters</c> instance with parameters to set the fields of <c>LedgerVoucherTransObject</c> object.
    /// </param>
    /// <returns>
    /// Returns the updated <c>LedgerVoucherTransObject</c> object.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initializeOldLedgerVoucherTransObject(AssetTransferInitializeLedgerVoucherTransObjectParameters _parameters)
    {
        LedgerDimensionAccount oldLedgerDimension;
        GeneralJournalAccountEntry generalJournalAccountEntry = _parameters.parmGeneralJournalAccountEntry();

        // Create a new entry to balance out the previous entry. The newGeneralJournal method will default the transaction attributes
        // from the existing generalJournalAccountEntry. Just overriding the amounts.
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newGeneralJournal(generalJournalAccountEntry);

        // If the asset and value model has been transferred before, the LedgerDimension should be specified as the one
        // on which it currently resides, and not the one on which it was initially acquired.
        if (_parameters.parmTransferHistoryDefaultDimension()
            && _parameters.parmTransferHistoryDefaultDimension() == _parameters.parmDefaultDimension())
        {
            oldLedgerDimension = this.createLedgerDimension(generalJournalAccountEntry.LedgerDimension, _parameters.parmDefaultDimension());
        }
        else
        {
            oldLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(generalJournalAccountEntry.LedgerDimension);
        }

        ledgerVoucherTransObject.parmLedgerDimensionId(oldLedgerDimension);
        ledgerVoucherTransObject.parmSkipDimensionValidation(true);

        ledgerVoucherTransObject.parmTransactionCurrencyAmount(generalJournalAccountEntry.TransactionCurrencyAmount * -1);
        ledgerVoucherTransObject.parmAccountingCurrencyAmount(generalJournalAccountEntry.AccountingCurrencyAmount * -1);
        ledgerVoucherTransObject.parmReportingCurrencyAmount(generalJournalAccountEntry.ReportingCurrencyAmount * -1);
        ledgerVoucherTransObject.parmHistoricalExchangeRateDate(_parameters.parmExchangeRateDate());
        ledgerVoucherTransObject.parmText(_parameters.parmTransferComment());

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger dimension from the old default dimension and main account.
    /// </summary>
    /// <param name="_oldLedgerDimension">
    /// The old record ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </param>
    /// <param name="_newDefaultDimension">
    /// The new record ID of the <c>DimensionAttributeValueSet</c> record.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The record ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </param>
    /// <param name="_mainAccountRecId">
    /// The record ID of the <c>MainAccount</c> record.
    /// </param>
    /// <returns>
    /// A new ledger dimension.
    /// </returns>
    /// <remarks>
    /// The <c>_ledgerDimension</c> value will be used only for the accumulated depreciation to get the
    /// dimension hierarchy.
    /// </remarks>
    protected recId createLedgerDimension(
        LedgerDimensionAccount  _oldLedgerDimension,
        DimensionDefault        _newDefaultDimension,
        LedgerDimensionAccount  _ledgerDimension = 0,
        MainAccountRecId        _mainAccountRecId = 0)
    {
        MainAccountRecId        mainAccountRecId;
        DimensionDefault        newLocalDefaultDimension;
        LedgerDimensionAccount  newLedgerDimension;

        // If the caller has passed the main account record ID use that otherwise, get the main account from old ledger dimension.
        mainAccountRecId = prmisDefault(_mainAccountRecId)
            ? LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_oldLedgerDimension)
            : _mainAccountRecId;

        if (_ledgerDimension)
        {
            newLocalDefaultDimension = _newDefaultDimension
                ? _newDefaultDimension
                : LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_ledgerDimension);
        }
        else
        {
            newLocalDefaultDimension = _newDefaultDimension;
        }

        newLedgerDimension = LedgerDimensionDefaultingEngine::getLedgerDimensionFromAccountAndDim(mainAccountRecId,
            DimensionHierarchy::getAccountStructure(mainAccountRecId), newLocalDefaultDimension);

        return newLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMiscTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates miscellaneous transfer transactions according to the business needs.
    /// </summary>
    /// <param name="_assetBook">
    /// The <c>AssetBook</c> record to use.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// A <c>LedgerVoucher</c> object that will be used to create transactions.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> object from the ledger voucher object.
    /// </param>
    /// <remarks>
    /// This method will be called by the <c>AssetTransfer.createTransactions</c> method to enable the
    /// derivatives to add miscellaneous transactions.
    /// </remarks>
    protected void createMiscTransactions(
        AssetBook           _assetBook,
        LedgerVoucher       _ledgerVoucher,
        LedgerVoucherObject _ledgerVoucherObject)
    {
        // No default implementation.
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates general ledger and fixed asset sub-ledger transactions for transfer of asset to a new financial dimension.
    /// </summary>
    /// <param name="_assetBookList">
    ///     A list of <c>AssetBook</c> table buffers sorted by RecId.
    /// </param>
    /// <remarks>
    ///     This method also updates the default financial dimension of the asset books to the transferred financial dimensions.
    /// </remarks>
    protected void createTransactions(RecordSortedList _assetBookList)
    {
        boolean haveMoreRecords;
        boolean hasDimensionWarnings;
        CurrentOperationsTax transactionPostingLayer;
        NumberSequenceCode numberSequenceCode;
        NumberSequenceReference numberSequenceReference;
        Voucher voucher;
        LedgerVoucher ledgerVoucher;
        LedgerVoucherObject ledgerVoucherObject;
        AssetBook assetBook;
        CurrencyExchangeHelper currencyExchangeHelper;
        RecId ledgerRecId;

        // <GIN>
        boolean isNotAssetGroupDepreciation = true;
        boolean isAssetParametersIndia = AssetParameters::checkAssetParameters_IN();
        // </GIN>

        // Initialize the number sequence related objects.
        numberSequenceReference = AssetParameters::numRefExtendedTypeId(extendedTypeNum(TransferSequenceNumber));
        numberSequenceCode = NumberSequenceTable::find(numberSequenceReference.NumberSequenceId).NumberSequence;

        // Initialize the ledger voucher which will contain multiple instances of LedgerVoucherObject.
        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail, SysModule::FixedAssets, numberSequenceCode);

        ledgerRecId = Ledger::primaryLedger(CompanyInfo::current());
        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(ledgerRecId, transferDate);

        haveMoreRecords = _assetBookList.first(assetBook);

        // Iterate over all the value models which are to be transferred.
        while (haveMoreRecords)
        {
            // <GIN>
            if (isAssetParametersIndia
                && assetBook.AssetGroupDepreciation_IN)
            {
                isNotAssetGroupDepreciation = False;
            }

            boolean skipBookTransfer = this.isSkipBookTransfer_FR(assetBook);

            if (isNotAssetGroupDepreciation && !skipBookTransfer)
            {
            // </GIN>

                if (newDefaultDimension == assetBook.DefaultDimension)
                {
                    if (!hasDimensionWarnings)
                    {
                        hasDimensionWarnings = true;
                    }

                    info(strFmt("@FixedAssets:FA_MessageNotification_AssetAndBookInformation", assetBook.AssetId, assetBook.BookId));
                }
                else
                {
                    // Generate a new voucher number from the number sequence reference.
                    voucher = NumberSeq::newGetNum(numberSequenceReference).num();
                    transactionPostingLayer = assetBook.currentOperationsTax();

                    // Initialize a ledger voucher object for the current value model.
                    ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher, transferDate, SysModule::FixedAssets, LedgerTransType::FixedAssets, NoYes::No, transactionPostingLayer);
                    ledgerVoucher.addVoucher(ledgerVoucherObject);

                    AssetTrans assetTransCheck;
                    TransactionReversalTrans transactionReversalTransHistory;
                    AssetTransferHistory assetTransferHistory;

                    // Verify for the Transfer Asset transaction are already posted.  If that is case, go through the transfer history records,
                    // use the default dimension information specified on the last transfer, and assign the value to the ledger dimension
                    // value of the reverse voucher instead of the value specified on the GeneralJournalAccountEntry record.
                    // Note: Ignore the Transfer Asset transaction that have been reversed.
                    if (AssetTransferHistoryCreatedDateTimeFlight::instance().isEnabled())
                    {
                        select firstonly TransferDate, ToDimension from assetTransferHistory
                            order by assetTransferHistory.CreatedDateTime desc,
                                assetTransferHistory.RecId desc
                        where assetTransferHistory.AssetId == assetBook.AssetId
                            && assetTransferHistory.BookId == assetBook.BookId
                        join assetTransCheck
                            where assetTransCheck.AssetId == assetTransferHistory.AssetId
                                && assetTransCheck.BookId == assetTransferHistory.BookId
                                && assetTransCheck.Voucher == assetTransferHistory.Voucher
                        notexists join transactionReversalTransHistory
                            where transactionReversalTransHistory.RefRecId == assetTransCheck.RecId
                                && transactionReversalTransHistory.RefTableId == tableNum(AssetTrans);
                    }
                    else
                    {
                        select firstonly TransferDate, ToDimension from assetTransferHistory
                            order by assetTransferHistory.RecId desc
                        where assetTransferHistory.AssetId == assetBook.AssetId
                            && assetTransferHistory.BookId == assetBook.BookId
                        join assetTransCheck
                            where assetTransCheck.AssetId == assetTransferHistory.AssetId
                                && assetTransCheck.BookId == assetTransferHistory.BookId
                                && assetTransCheck.Voucher == assetTransferHistory.Voucher
                        notexists join transactionReversalTransHistory
                            where transactionReversalTransHistory.RefRecId == assetTransCheck.RecId
                                && transactionReversalTransHistory.RefTableId == tableNum(AssetTrans);
                    }

                    boolean isAssetTransferred = this.createGLTransactionsForAssetBook(
                            ledgerVoucherObject,
                            assetBook,
                            assetTransferHistory,
                            transactionPostingLayer,
                            currencyExchangeHelper);

                    if (isAssetTransferred)
                    {
                        // Invoke createMiscTransactions in case it is overridden in a child class to add miscellaneous transactions
                        // which are not known by this class.
                        this.createMiscTransactions(assetBook, ledgerVoucher, ledgerVoucherObject);

                        // Insert a record to the AssetTrans table showing the asset transfer against the current value model.
                        this.insertAssetTrans(assetBook.AssetId, assetBook.BookId, assetBook.AssetGroup, voucher, transferDate, transferComment, newDefaultDimension);

                        // Insert a record to the AssetTransferHistory table using the old and new dimension value
                        this.insertTransferHistory(assetBook.AssetId, assetBook.BookId, newDefaultDimension, transferDate, transferComment, voucher);

                        // Update the DefaultDimension field of AssetTable with the new default dimension.
                        if (newDefaultDimension)
                        {
                            this.updateDefaultDimension(assetBook.AssetId, assetBook.BookId, newDefaultDimension);
                        }
                                                
                        if (assetBook.AssetDerogatoryModel_FR)
                        {
                            this.processDeragatoryBook_FR(_assetBookList, assetBook, voucher);
                        }
                    }
                }

            // <GIN>
            }
            // </GIN>

            haveMoreRecords = _assetBookList.next(assetBook);
        }

        if (hasDimensionWarnings)
        {
            info("@FixedAssets:FA_MessageNotification_BooksCannotBeTransferredSameFinancialDimensions");
        }

        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processDeragatoryBook_FR</Name>
				<Source><![CDATA[
    private void processDeragatoryBook_FR(
        RecordSortedList _assetBookList, 
        AssetBook _assetBook, 
        Voucher _voucher)
    {
        if (_assetBook.AssetDerogatoryModel_FR)
        {
            AssetBook derogatoryBook = AssetBook::find(_assetBook.AssetId, _assetBook.AssetDerogatoryModel_FR);

            if (_assetBookList.find(derogatoryBook))
            {
                this.insertAssetTrans(derogatoryBook.AssetId, derogatoryBook.BookId, derogatoryBook.AssetGroup, _voucher, transferDate, transferComment, newDefaultDimension);

                this.insertTransferHistory(derogatoryBook.AssetId, derogatoryBook.BookId, newDefaultDimension, transferDate, transferComment, _voucher);

                if (newDefaultDimension)
                {
                    this.updateDefaultDimension(derogatoryBook.AssetId, derogatoryBook.BookId, newDefaultDimension);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createGLTransactionsForAssetBook</Name>
				<Source><![CDATA[
    private boolean createGLTransactionsForAssetBook(
        LedgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        boolean isSubsequentTransferredTransactionsProcessed = this.processSubsequentTransferredTransactions(
                _ledgerVoucherObject,
                _assetBook,
                _assetTransferHistory,
                _transactionPostingLayer,
                _currencyExchangeHelper);

        boolean isFirstTimeTransferredTransactionsProcessed = this.processFirstTimeTransferredTransactions(
                _ledgerVoucherObject,
                _assetBook,
                _assetTransferHistory,
                _transactionPostingLayer,
                _currencyExchangeHelper);

        return isSubsequentTransferredTransactionsProcessed || isFirstTimeTransferredTransactionsProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSubsequentTransferredTransactions</Name>
				<Source><![CDATA[
    private boolean processSubsequentTransferredTransactions(
        LedgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        boolean isAssetTransferred = false;

        if (_assetTransferHistory)
        {
            AssetTransDate fromDateTransfer = dateNull();
            AssetTransDate toDateTransfer = _assetTransferHistory.TransferDate;

            isAssetTransferred = this.processVouchers(
                _ledgerVoucherObject,
                _assetBook,
                _assetTransferHistory,
                _transactionPostingLayer,
                _currencyExchangeHelper,
                toDateTransfer,
                fromDateTransfer);
        }

        return isAssetTransferred;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFirstTimeTransferredTransactions</Name>
				<Source><![CDATA[
    private boolean processFirstTimeTransferredTransactions(
        LedgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        AssetTransDate toDateTransfer = maxDate();
        AssetTransDate fromDateTransfer = dateNull();

        if (_assetTransferHistory)
        {
            fromDateTransfer = _assetTransferHistory.TransferDate + 1;
        }

        return this.processVouchers(
            _ledgerVoucherObject,
            _assetBook,
            _assetTransferHistory,
            _transactionPostingLayer,
            _currencyExchangeHelper,
            toDateTransfer,
            fromDateTransfer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVouchers</Name>
				<Source><![CDATA[
    private boolean processVouchers(
        LedgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer,
        CurrencyExchangeHelper _currencyExchangeHelper,
        AssetTransDate _toDateTransfer,
        AssetTransDate _fromDateTransfer)
    {
        CurrencyCode accountingCurrency;
        accountingCurrency = Ledger::accountingCurrency();

        boolean isRegularVouchersProcessed = this.processRegularVouchers(
                _fromDateTransfer,
                _toDateTransfer,
                _ledgerVoucherObject,
                _assetBook,
                _assetTransferHistory,
                _transactionPostingLayer);

        boolean isVendorVouchersProcessed = this.processVendorVouchers(
                _fromDateTransfer,
                _toDateTransfer,
                _ledgerVoucherObject,
                _currencyExchangeHelper,
                accountingCurrency,
                _assetBook,
                _assetTransferHistory,
                _transactionPostingLayer);

        return isRegularVouchersProcessed || isVendorVouchersProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRegularVouchers</Name>
				<Source><![CDATA[
    // This method will try to process the value models that have the exact amount matching assetTrans records with GL vouchers.
    private boolean processRegularVouchers(
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        ledgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer)
    {
        AssetTransferTransTmp assetTransferTransTmp = this.createAssetTransferTransTmp(
            _fromDateTransfer,
            _toDateTransfer,
            _assetBook,
            _transactionPostingLayer);

        if (this.updateAssetTransLedgerDimensionForDuplicates(assetTransferTransTmp) > 0)
        {
            assetTransferTransTmp = this.createAssetTransferTransTmp(
                _fromDateTransfer,
                _toDateTransfer,
                _assetBook,
                _transactionPostingLayer);
        }

        return this.processRegularVouchersFromTmpTable(
            _ledgerVoucherObject,
            _assetBook,
            _assetTransferHistory,
            assetTransferTransTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssetTransferTransTmp</Name>
				<Source><![CDATA[
    private AssetTransferTransTmp createAssetTransferTransTmp(
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        AssetBook _assetBook,
        CurrentOperationsTax _transactionPostingLayer)
    {
        AssetTransferTransTmp assetTransferTransTmp;

        if (AssetTransferInsertTransWithLedgerDimensionIntoTmpTableFlight::instance().isEnabled())
        {
            this.insertTransWithLedgerDimensionIntoTmpTableNew(
                _fromDateTransfer,
                _toDateTransfer,
                _assetBook,
                _transactionPostingLayer,
                assetTransferTransTmp);
        }
        else
        {
            this.insertTransWithLedgerDimensionIntoTmpTable(
                _fromDateTransfer,
                _toDateTransfer,
                _assetBook,
                _transactionPostingLayer,
                assetTransferTransTmp);
        }

        this.insertTransWithoutLedgerDimensionIntoTmpTable(
            _fromDateTransfer,
            _toDateTransfer,
            _assetBook,
            _transactionPostingLayer,
            assetTransferTransTmp);

        return assetTransferTransTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetTransLedgerDimensionForDuplicates</Name>
				<Source><![CDATA[
    private int updateAssetTransLedgerDimensionForDuplicates(AssetTransferTransTmp _assetTransferTransTmp)
    {
        Set assetTransDuplicates = this.getTransferTransTmpDuplicates(_assetTransferTransTmp);

        if (!assetTransDuplicates.empty())
        {
            this.updateMissingLedgerDimensionsInAssetTrans(assetTransDuplicates, _assetTransferTransTmp);
        }

        return assetTransDuplicates.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransferTransTmpDuplicates</Name>
				<Source><![CDATA[
    private Set getTransferTransTmpDuplicates(AssetTransferTransTmp _assetTransferTransTmp)
    {
        Set assetTransSet = new Set(Types::Int64);
        Set assetTransDuplicates = new Set(Types::Int64);

        AssetTrans AssetTrans;

        while select RecId from assetTrans
            join AssetTrans from _assetTransferTransTmp
            where _assetTransferTransTmp.AssetTrans == assetTrans.RecId
                && assetTrans.LedgerDimension == 0
        {
            if (_assetTransferTransTmp.AssetTrans)
            {
                if (assetTransSet.in(assetTrans.RecId))
                {
                    assetTransDuplicates.add(assetTrans.RecId);
                }
                else
                {
                    assetTransSet.add(assetTrans.RecId);
                }
            }
        }

        return assetTransDuplicates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMissingLedgerDimensionsInAssetTrans</Name>
				<Source><![CDATA[
    private void updateMissingLedgerDimensionsInAssetTrans(
        Set _assetTransSet,
        AssetTransferTransTmp _assetTransferTransTmp)
    {        
        SetEnumerator assetTransSetEnumerator = _assetTransSet.getEnumerator();

        while(assetTransSetEnumerator.moveNext())
        {
            RecId assetTransRecId = assetTransSetEnumerator.current();

            LedgerDimensionAccount ledgerDimension =  this.getLedgerDimensionForAssetTransRecord(
                assetTransRecId,
                _assetTransferTransTmp);

            this.updateAssetTransLedgerDimension(assetTransRecId, ledgerDimension);

            this.logUpdateResult(assetTransRecId, ledgerDimension != 0);
        }        
    }

]]></Source>
			</Method>
			<Method>
				<Name>logUpdateResult</Name>
				<Source><![CDATA[
    private void logUpdateResult(RecId _assetTransRecId, boolean _isFixed)
    {        
        SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(classStr(AssetTransfer));

        logger.logInformation(strFmt(AssetInstrumentationConstants::DuplicateAssetTransFound,
            _assetTransRecId,
            _isFixed));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForAssetTransRecord</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getLedgerDimensionForAssetTransRecord(
        RecId _assetTransRecId,
        AssetTransferTransTmp _assetTransferTransTmp)
    {
        while select LedgerDimension, MainAccount, DefaultDimension, RecId
            from _assetTransferTransTmp
            where _assetTransferTransTmp.AssetTrans == _assetTransRecId
        {
            LedgerDimensionDefaultAccount defaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromMainAccountRecId(_assetTransferTransTmp.MainAccount);

            LedgerDimensionAccount ledgerDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(
                    LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _assetTransferTransTmp.DefaultDimension));

            if (_assetTransferTransTmp.LedgerDimension == ledgerDimension)
            {
                return ledgerDimension;
            }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetTransLedgerDimension</Name>
				<Source><![CDATA[
    private void updateAssetTransLedgerDimension(
        RecId _assetTransRecId, 
        LedgerDimensionAccount _ledgerDimension)
    {
        AssetTrans assetTrans;

        assetTrans.skipDataMethods(true);
        assetTrans.skipEvents(true);
        assetTrans.skipDatabaseLog(true);

        update_recordset assetTrans
            setting LedgerDimension = _ledgerDimension
            where assetTrans.RecId == _assetTransRecId;

        AssetCache::clearScope(AssetCacheScope::AssetTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransWithLedgerDimensionIntoTmpTable</Name>
				<Source><![CDATA[
    private void insertTransWithLedgerDimensionIntoTmpTable(
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        AssetBook _assetBook,
        CurrentOperationsTax _transactionPostingLayer,
        AssetTransferTransTmp _assetTransferTransTmp)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        TransactionReversalTrans transactionReversalTrans;
        AssetTrans assetTrans;
        VendInvoiceJour vendInvoiceJour;

        insert_recordset _assetTransferTransTmp
            (
                AssetTrans,
                DefaultDimension,
                TransactionCurrencyAmount,
                AccountingCurrencyAmount,
                ReportingCurrencyAmount,
                TransactionCurrencyCode,
                LedgerDimension,
                MainAccount,
                PostingType
            )
        select RecId, DefaultDimension, AmountCur, AmountMST, ReportingCurrencyAmount
            from assetTrans
            where assetTrans.AssetId == _assetBook.AssetId
                && assetTrans.BookId == _assetBook.BookId
                && assetTrans.TransDate >= _fromDateTransfer
                && assetTrans.TransDate <= _toDateTransfer
                && assetTrans.LedgerDimension != 0
                && (assetTrans.TransType == AssetTransType::Acquisition
                    || assetTrans.TransType == AssetTransType::AcquisitionAdj
                    || assetTrans.TransType == AssetTransType::CapitalReserveTransfer
                    || assetTrans.TransType == AssetTransType::WriteUpAdj
                    || assetTrans.TransType == AssetTransType::WriteDownAdj
                    || assetTrans.TransType == AssetTransType::Revaluation
                    || assetTrans.TransType == AssetTransType::Depreciation
                    || assetTrans.TransType == AssetTransType::DepreciationAdj
                    || assetTrans.TransType == AssetTransType::BonusDepreciation
                    || assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation
                    || assetTrans.TransType == AssetTransType::AccumulatedDepreciation_PL
                    || assetTrans.TransType == AssetTransType::DerogatoryIncrease
                    || assetTrans.TransType == AssetTransType::DerogatoryDecrease)
                join TransactionCurrencyCode,
                    LedgerDimension,
                    MainAccount,
                    PostingType
                from generalJournalAccountEntry
                group by assetTrans.RecId, assetTrans.DefaultDimension, assetTrans.AmountCur, assetTrans.AmountMST,
                    assetTrans.ReportingCurrencyAmount, generalJournalAccountEntry.TransactionCurrencyCode,
                    generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.MainAccount, generalJournalAccountEntry.PostingType
                where generalJournalAccountEntry.AccountingCurrencyAmount == assetTrans.AmountMST
                    && generalJournalAccountEntry.LedgerDimension == assetTrans.LedgerDimension
                    && (generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsCredit
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense)
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == assetTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == assetTrans.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == curext()
            exists join generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.PostingLayer == _transactionPostingLayer
            notexists join vendInvoiceJour  // This join determines if the acquisitions originated from a Purchase Order
                    where vendInvoiceJour.LedgerVoucher == assetTrans.Voucher
            notexists join transactionReversalTrans
                where transactionReversalTrans.RefRecId == assetTrans.RecId
                    && transactionReversalTrans.RefTableId == tableNum(AssetTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransWithLedgerDimensionIntoTmpTableNew</Name>
				<Source><![CDATA[
    private void insertTransWithLedgerDimensionIntoTmpTableNew(
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        AssetBook _assetBook,
        CurrentOperationsTax _transactionPostingLayer,
        AssetTransferTransTmp _assetTransferTransTmp)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        TransactionReversalTrans transactionReversalTrans;
        AssetTrans assetTrans;
        VendInvoiceJour vendInvoiceJour;
        AssetTransferTransWorkTmp assetTransferTransWorkTmp;

        insert_recordset assetTransferTransWorkTmp
            (
                AssetTrans,
                DefaultDimension,
                TransactionCurrencyAmount,
                AccountingCurrencyAmount,
                ReportingCurrencyAmount,
                LedgerDimension,
                GeneralJournalEntry
            )
        select RecId, DefaultDimension, AmountCur, AmountMST, ReportingCurrencyAmount, LedgerDimension
            from assetTrans
            where assetTrans.AssetId == _assetBook.AssetId
                && assetTrans.BookId == _assetBook.BookId
                && assetTrans.TransDate >= _fromDateTransfer
                && assetTrans.TransDate <= _toDateTransfer
                && assetTrans.LedgerDimension != 0
                && (assetTrans.TransType == AssetTransType::Acquisition
                    || assetTrans.TransType == AssetTransType::AcquisitionAdj
                    || assetTrans.TransType == AssetTransType::CapitalReserveTransfer
                    || assetTrans.TransType == AssetTransType::WriteUpAdj
                    || assetTrans.TransType == AssetTransType::WriteDownAdj
                    || assetTrans.TransType == AssetTransType::Revaluation
                    || assetTrans.TransType == AssetTransType::Depreciation
                    || assetTrans.TransType == AssetTransType::DepreciationAdj
                    || assetTrans.TransType == AssetTransType::BonusDepreciation
                    || assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation
                    || assetTrans.TransType == AssetTransType::AccumulatedDepreciation_PL
                    || assetTrans.TransType == AssetTransType::DerogatoryIncrease
                    || assetTrans.TransType == AssetTransType::DerogatoryDecrease)
                join GeneralJournalEntry
                from subledgerVoucherGeneralJournalEntry
                group by assetTrans.RecId, assetTrans.DefaultDimension, assetTrans.AmountCur, assetTrans.AmountMST,
                    assetTrans.ReportingCurrencyAmount, assetTrans.LedgerDimension, subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == assetTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == assetTrans.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == curext()
            notexists join vendInvoiceJour  // This join determines if the acquisitions originated from a Purchase Order
                    where vendInvoiceJour.LedgerVoucher == assetTrans.Voucher
                    && vendInvoiceJour.InvoiceDate == assetTrans.TransDate
            notexists join transactionReversalTrans
                where transactionReversalTrans.RefRecId == assetTrans.RecId
                    && transactionReversalTrans.RefTableId == tableNum(AssetTrans);

        insert_recordset _assetTransferTransTmp
            (
                AssetTrans,
                DefaultDimension,
                TransactionCurrencyAmount,
                AccountingCurrencyAmount,
                ReportingCurrencyAmount,
                TransactionCurrencyCode,
                LedgerDimension,
                MainAccount,
                PostingType
            )
        select AssetTrans, DefaultDimension, TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount
            from assetTransferTransWorkTmp 
            join TransactionCurrencyCode,
                LedgerDimension,
                MainAccount,
                PostingType
            from generalJournalAccountEntry
            group by assetTransferTransWorkTmp.AssetTrans, assetTransferTransWorkTmp.DefaultDimension, 
                assetTransferTransWorkTmp.TransactionCurrencyAmount, assetTransferTransWorkTmp.AccountingCurrencyAmount,
                assetTransferTransWorkTmp.ReportingCurrencyAmount, generalJournalAccountEntry.TransactionCurrencyCode,
                generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.MainAccount, generalJournalAccountEntry.PostingType
            where generalJournalAccountEntry.AccountingCurrencyAmount == assetTransferTransWorkTmp.AccountingCurrencyAmount
                && generalJournalAccountEntry.LedgerDimension == assetTransferTransWorkTmp.LedgerDimension
                && (generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsCredit
                || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense)
            join generalJournalEntry
            where generalJournalEntry.RecId == assetTransferTransWorkTmp.GeneralJournalEntry
                && generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                && generalJournalEntry.PostingLayer == _transactionPostingLayer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransWithoutLedgerDimensionIntoTmpTable</Name>
				<Source><![CDATA[
    private void insertTransWithoutLedgerDimensionIntoTmpTable(
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        AssetBook _assetBook,
        CurrentOperationsTax _transactionPostingLayer,
        AssetTransferTransTmp _assetTransferTransTmp)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        TransactionReversalTrans transactionReversalTrans;
        AssetTrans assetTrans;
        VendInvoiceJour vendInvoiceJour;

        insert_recordset _assetTransferTransTmp
            (
                AssetTrans,
                DefaultDimension,
                TransactionCurrencyAmount,
                AccountingCurrencyAmount,
                ReportingCurrencyAmount,
                TransactionCurrencyCode,
                LedgerDimension,
                MainAccount,
                PostingType
            )
        select RecId, DefaultDimension from assetTrans
            where assetTrans.AssetId == _assetBook.AssetId
                && assetTrans.BookId == _assetBook.BookId
                && assetTrans.TransDate >= _fromDateTransfer
                && assetTrans.TransDate <= _toDateTransfer
                && assetTrans.LedgerDimension == 0
                && (assetTrans.TransType == AssetTransType::Acquisition
                    || assetTrans.TransType == AssetTransType::AcquisitionAdj
                    || assetTrans.TransType == AssetTransType::CapitalReserveTransfer
                    || assetTrans.TransType == AssetTransType::WriteUpAdj
                    || assetTrans.TransType == AssetTransType::WriteDownAdj
                    || assetTrans.TransType == AssetTransType::Revaluation
                    || assetTrans.TransType == AssetTransType::Depreciation
                    || assetTrans.TransType == AssetTransType::DepreciationAdj
                    || assetTrans.TransType == AssetTransType::BonusDepreciation
                    || assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation
                    || assetTrans.TransType == AssetTransType::AccumulatedDepreciation_PL
                    || assetTrans.TransType == AssetTransType::DerogatoryIncrease
                    || assetTrans.TransType == AssetTransType::DerogatoryDecrease)
            join TransactionCurrencyAmount, 
                AccountingCurrencyAmount, 
                ReportingCurrencyAmount, 
                TransactionCurrencyCode, 
                LedgerDimension, 
                MainAccount,
                PostingType
                from generalJournalAccountEntry
                where generalJournalAccountEntry.AccountingCurrencyAmount == assetTrans.AmountMST
                    && (generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsCredit
                    || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense)
            exists join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.Voucher == assetTrans.Voucher
                    && subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalAccountEntry.GeneralJournalEntry
                    && subledgerVoucherGeneralJournalEntry.AccountingDate == assetTrans.TransDate
                    && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == curext()
            exists join generalJournalEntry
                where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                    && generalJournalEntry.PostingLayer == _transactionPostingLayer
            notexists join vendInvoiceJour  // This join determines if the acquisitions originated from a Purchase Order
                    where vendInvoiceJour.LedgerVoucher == assetTrans.Voucher
            notexists join transactionReversalTrans
                where transactionReversalTrans.RefRecId == assetTrans.RecId
                    && transactionReversalTrans.RefTableId == tableNum(AssetTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRegularVouchersFromTmpTable</Name>
				<Source><![CDATA[
    private boolean processRegularVouchersFromTmpTable(
        ledgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        AssetTransferTransTmp _assetTransferTransTmp)
    {
        boolean isAssetTransferred = false;

        while select sum(TransactionCurrencyAmount),
                sum(AccountingCurrencyAmount),
                sum(ReportingCurrencyAmount),
                TransactionCurrencyCode,
                LedgerDimension,
                PostingType
            from _assetTransferTransTmp
            group by LedgerDimension, TransactionCurrencyCode, PostingType
        {
            GeneralJournalAccountEntry generalJournalAccountEntry = this.populateGeneralJournalAccountEntryFromTmp(_assetTransferTransTmp);

            this.addLedgerVoucherTransObjects(
                _ledgerVoucherObject,
                generalJournalAccountEntry,
                _assetBook.DefaultDimension,
                _assetTransferHistory.ToDimension,
                _assetBook.exchangeRateDate(),
                transferComment);

            isAssetTransferred = true;
        }

        return isAssetTransferred;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateGeneralJournalAccountEntryFromTmp</Name>
				<Source><![CDATA[
    private GeneralJournalAccountEntry populateGeneralJournalAccountEntryFromTmp(AssetTransferTransTmp _assetTransferTransTmp)
    {
        GeneralJournalAccountEntry generalJournalAccountEntry;

        generalJournalAccountEntry.AccountingCurrencyAmount = _assetTransferTransTmp.AccountingCurrencyAmount;
        generalJournalAccountEntry.LedgerDimension = _assetTransferTransTmp.LedgerDimension;
        generalJournalAccountEntry.PostingType = _assetTransferTransTmp.PostingType;
        generalJournalAccountEntry.ReportingCurrencyAmount = _assetTransferTransTmp.ReportingCurrencyAmount;
        generalJournalAccountEntry.TransactionCurrencyAmount = _assetTransferTransTmp.TransactionCurrencyAmount;
        generalJournalAccountEntry.TransactionCurrencyCode = _assetTransferTransTmp.TransactionCurrencyCode;

        return generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVendorVouchers</Name>
				<Source><![CDATA[
    /// <summary>
    /// Vendor based transactions can summarize transactions associated with multiple assets value model into the same GL Vouchers while posting the journal.
    /// This method will try to analyze further vendor specific transactions to determine how GL voucher amounts are related to AssetTrans records.
    /// </summary>
    /// <param name = "_fromDateTransfer">
    /// From date of transfer.
    /// </param>
    /// <param name = "_toDateTransfer">
    /// To date of transfer.
    /// </param>
    /// <param name = "_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> instance.
    /// </param>
    /// <param name = "_currencyExchangeHelper">
    /// An <c>CurrencyExchangeHelper</c> instance.
    /// </param>
    /// <param name = "_accountingCurrency">
    /// The accounting currency.
    /// </param>
    /// <param name = "_assetBook">
    /// The <c>AssetBook</c> table buffer.
    /// </param>
    /// <param name = "_assetTransferHistory">
    /// The <c>AssetTransferHistory</c> table buffer.
    /// </param>
    /// <param name = "_transactionPostingLayer">
    /// The transaction posting layer.
    /// </param>
    /// <returns>
    /// true if the vendor vouchers are processed successfully; otherwise, false.
    /// </returns>
    protected boolean processVendorVouchers(
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        ledgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _currencyExchangeHelper,
        CurrencyCode _accountingCurrency,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer)
    {
        
        RecordSortedList assetTransList = new RecordSortedList(tableNum(AssetTrans));
        assetTransList.sortOrder(fieldNum(AssetTrans, RecId));

        // we can process only fixed asset debit transactions with AssetTransVendInvoiceTrans table
        boolean processTransfer = this.processVendorVouchersFromVendorInvoiceTrans(
            assetTransList,
            _ledgerVoucherObject,
            _assetBook,
            _assetTransferHistory,
            _accountingCurrency,
            _fromDateTransfer,
            _toDateTransfer,
            _currencyExchangeHelper);
       
        // process transactions via AssetTransVoucher in case if not all of the transactions has corresponding link record and for purch ledger posting types.
        if (this.processVendorVouchersFromAssetTransVoucher(
            assetTransList,
            _fromDateTransfer,
            _toDateTransfer,
            _ledgerVoucherObject,
            _currencyExchangeHelper,
            _assetBook,
            _assetTransferHistory,
            _transactionPostingLayer))
        {
            processTransfer = true;
        }
        
        return processTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVendorVouchersFromVendorInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processing the vendor related vouchers from the asset Transaction vouchers.
    /// </summary>
    /// <param name = "_assetTransList">
    /// Record sorted list of <c>AssetTrans</c> table buffer.
    /// </param>
    /// <param name = "_ledgerVoucherObject">
    /// The <c>ledgerVoucherObject</c> instance.
    /// </param>
    /// <param name = "_assetBook">
    /// The <c>AssetBook</c> table buffer.
    /// </param>
    /// <param name = "_assetTransferHistory">
    /// The <c>AssetTransferHistory</c> table buffer.
    /// </param>
    /// <param name = "_accountingCurrency">
    /// Accounting currency code.
    /// </param>
    /// <param name = "_fromDateTransfer">
    /// From date.
    /// </param>
    /// <param name = "_toDateTransfer">
    /// To date.
    /// </param>
    /// <param name = "_currencyExchangeHelper">
    /// The <c>CurrencyExchangeHelper</c> instance.
    /// </param>
    /// <returns>
    /// true if asset transactions found and addeed to the record sorted list; otherwise, false.
    /// </returns>
    protected boolean processVendorVouchersFromVendorInvoiceTrans(
        RecordSortedList _assetTransList,
        ledgerVoucherObject _ledgerVoucherObject,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrencyCode _accountingCurrency,
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        boolean processTransfer;

        AssetTransVendInvoiceTrans assetTransVendInvoiceTrans;
        VendInvoiceTrans vendInvoiceTrans;
        VendInvoiceJour vendInvoiceJour;
        VendTrans vendTrans;
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        SubledgerJournalEntry subledgerJournalEntry;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        TransactionReversalTrans transactionReversalTrans;
        AssetTrans assetTrans;

        while select assetTrans
                where assetTrans.AssetId == _assetBook.AssetId
                    && assetTrans.BookId == _assetBook.BookId
                    && assetTrans.TransDate >= _fromDateTransfer
                    && assetTrans.TransDate <= _toDateTransfer
                    && (assetTrans.TransType == AssetTransType::Acquisition
                    || assetTrans.TransType == AssetTransType::AcquisitionAdj)
            join RecId from assetTransVendInvoiceTrans
                where assetTransVendInvoiceTrans.AssetTrans == assetTrans.RecId
            join RecId from vendInvoiceTrans
                where vendInvoiceTrans.RecId == assetTransVendInvoiceTrans.VendInvoiceTrans
                    && vendInvoiceTrans.SourceDocumentLine
            join RecId from vendInvoiceJour
                where vendInvoiceTrans.PurchID == vendInvoiceJour.PurchID
                    && vendInvoiceTrans.InvoiceId == vendInvoiceJour.InvoiceId
                    && vendInvoiceTrans.InvoiceDate == vendInvoiceJour.InvoiceDate
                    && vendInvoiceTrans.numberSequenceGroup == vendInvoiceJour.numberSequenceGroup
                    && vendInvoiceTrans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId
            join RecId from vendTrans
                where vendTrans.Voucher == vendInvoiceJour.ledgerVoucher
                    && vendTrans.AccountNum == vendInvoiceJour.InvoiceAccount
                    && vendTrans.TransDate == vendInvoiceJour.InvoiceDate
            join RecId from subledgerJournalEntry
                where subledgerJournalEntry.AccountingEvent == vendTrans.AccountingEvent
            join RecId from subledgerJournalAccountEntry
                where subledgerJournalAccountEntry.SubledgerJournalEntry == subledgerJournalEntry.RecId
                    && subledgerJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
            join TransactionCurrencyAmount, AccountingCurrencyAmount, ReportingCurrencyAmount,
                    TransactionCurrencyCode, LedgerDimension, PostingType from generalJournalAccountEntry
                where generalJournalAccountEntry.RecId == subledgerJournalAccountEntry.GeneralJournalAccountEntry
                    && (assetTrans.LedgerDimension == 0
                    || (assetTrans.LedgerDimension != 0 
                        && generalJournalAccountEntry.LedgerDimension == assetTrans.LedgerDimension))
            notexists join transactionReversalTrans
                where transactionReversalTrans.RefRecId == assetTrans.RecId
                    && transactionReversalTrans.RefTableId == tableNum(AssetTrans)
        {
            processTransfer = this.createVendorVoucherFromVendorInvoiceTrans(
               assetTrans, 
               generalJournalAccountEntry,
               _assetTransList,
               _ledgerVoucherObject,
               _assetBook,
               _assetTransferHistory,
               _currencyExchangeHelper);
        }    
        return processTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVendorVoucherFromVendorInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates vendor voucher transactions for the vendor invoice transactions.
    /// </summary>
    /// <param name = "_assetTrans">
    /// The <c>AssetTrans</c> table buffer.
    /// </param>
    /// <param name = "_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> table buffer.
    /// </param>
    /// <param name = "_assetTransList">
    /// Record sorted list of <c>AssetTrans</c> table buffer.
    /// </param>
    /// <param name = "_ledgerVoucherObject">
    /// The <c>ledgerVoucherObject</c> instance.
    /// </param>
    /// <param name = "_assetBook">
    /// The <c>AssetBook</c> table buffer.
    /// </param>
    /// <param name = "_assetTransferHistory">
    /// The <c>AssetTransferHistory</c> table buffer.
    /// </param>
    /// <param name = "_currencyExchangeHelper">
    /// The <c>CurrencyExchangeHelper</c> instance.
    /// </param>
    /// <returns>
    /// true if asset transactions found;otherwise, false.
    /// </returns>
    protected boolean createVendorVoucherFromVendorInvoiceTrans(
        AssetTrans _assetTrans, 
        GeneralJournalAccountEntry _generalJournalAccountEntry, 
        RecordSortedList _assetTransList,
        ledgerVoucherObject _ledgerVoucherObject, 
        AssetBook _assetBook, 
        AssetTransferHistory _assetTransferHistory, 
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        boolean processTransfer;
       
        if (!_assetTransList.find(_assetTrans))
        {
            if (_assetTrans.AmountCur && _assetTrans.AmountCur != _generalJournalAccountEntry.TransactionCurrencyAmount)
            {
                _generalJournalAccountEntry.TransactionCurrencyAmount = _assetTrans.AmountCur;
                _generalJournalAccountEntry.AccountingCurrencyAmount = _assetTrans.AmountMST;
                _generalJournalAccountEntry.ReportingCurrencyAmount =
                    _currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(_assetTrans.CurrencyCode, _assetTrans.AmountCur);
                _generalJournalAccountEntry.TransactionCurrencyCode = _assetTrans.CurrencyCode;
            }

            this.addLedgerVoucherTransObjects(
                _ledgerVoucherObject, 
                _generalJournalAccountEntry, 
                _assetBook.DefaultDimension, 
                _assetTransferHistory.ToDimension,
                _assetBook.exchangeRateDate(), 
                transferComment);

            _assetTransList.ins(_assetTrans);

            processTransfer = true;
        }

        return processTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processVendorVouchersFromAssetTransVoucher</Name>
				<Source><![CDATA[
    private boolean processVendorVouchersFromAssetTransVoucher(
        RecordSortedList _assetTransList,
        AssetTransDate _fromDateTransfer,
        AssetTransDate _toDateTransfer,
        ledgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _currencyExchangeHelper,
        AssetBook _assetBook,
        AssetTransferHistory _assetTransferHistory,
        CurrentOperationsTax _transactionPostingLayer)
    {
        boolean processTransfer;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        TransactionReversalTrans transactionReversalTrans;
        VendInvoiceJour vendInvoiceJour;
        AssetTrans assetTrans;
        AssetTrans assetTransFromPO;

        //
        //  Handle the case where Purchase Order with PO lines match the exact amounts to the corresponding AssetTrans transactions.
        //
        while select assetTrans
                group by generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.TransactionCurrencyCode, generalJournalAccountEntry.PostingType,
                    assetTrans.RecId
                where assetTrans.AssetId == _assetBook.AssetId
                    && assetTrans.BookId == _assetBook.BookId
                    && assetTrans.TransDate >= _fromDateTransfer
                    && assetTrans.TransDate <= _toDateTransfer
                    && (assetTrans.TransType == AssetTransType::Acquisition
                        || assetTrans.TransType == AssetTransType::AcquisitionAdj)
                join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == assetTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate == assetTrans.TransDate
                        && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == assetTrans.DataAreaId
                join generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalEntry.PostingLayer == _transactionPostingLayer
                join sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount), TransactionCurrencyCode, LedgerDimension, PostingType
                from generalJournalAccountEntry
                    where (assetTrans.LedgerDimension == 0
                        || (assetTrans.LedgerDimension != 0
                        && assetTrans.LedgerDimension == generalJournalAccountEntry.LedgerDimension))
                        && generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalAccountEntry.AccountingCurrencyAmount == assetTrans.AmountMST
                        && (generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense  // For acquisition through PO scenario
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump)
                exists join vendInvoiceJour  // This join determines if the acquisitions originated from a Purchase Order
                    where vendInvoiceJour.LedgerVoucher == assetTrans.Voucher
                        && vendInvoiceJour.InvoiceDate == assetTrans.TransDate
                notexists join transactionReversalTrans
                    where transactionReversalTrans.RefRecId == assetTrans.RecId
                        && transactionReversalTrans.RefTableId == tableNum(AssetTrans)
        {
            if (!_assetTransList.find(assetTrans))
            {
                this.addLedgerVoucherTransObjects(_ledgerVoucherObject, generalJournalAccountEntry, _assetBook.DefaultDimension, _assetTransferHistory.ToDimension,
                                _assetBook.exchangeRateDate(), transferComment);
                _assetTransList.ins(assetTrans);
                processTransfer = true;
            }
        }

        //
        //  Handle the Purchase Order with multiple lines and different assets scenario
        //  If the generalJournalAccountEntry originated from a Purchase order acquisition of a Fixed Asset, it could have multiple lines
        //  on the PO with multiple acquisitions against different AssetId/BookId combinations.  These will all be posted under a
        //  single voucher and generalJournalAccountEntry record.  So we need to pull out just the appropriate amount for this
        //  AssetId/BookId combination from AssetTrans.  Other AssetId/BookId combinations could potentially make up part of the overall
        //  generalJournalAccountEntry.TransactionCurrencyAmount and should be ignored.
        //

        // For single voucher scenarios, LedgerVoucher field is used to associate the transactions. Search with one field
        // instead of an OR statement with two columns has a better performance.
        if (SourceDocumentCompletionRule::useSingleVoucher())
        {
            while select assetTrans
                group by generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.TransactionCurrencyCode, generalJournalAccountEntry.PostingType,
                    assetTrans.RecId
                where assetTrans.AssetId == _assetBook.AssetId
                    && assetTrans.BookId == _assetBook.BookId
                    && assetTrans.TransDate >= _fromDateTransfer
                    && assetTrans.TransDate <= _toDateTransfer
                    && (assetTrans.TransType == AssetTransType::Acquisition
                        || assetTrans.TransType == AssetTransType::AcquisitionAdj)
                join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == assetTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate == assetTrans.TransDate
                        && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == assetTrans.DataAreaId
                join generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalEntry.PostingLayer == _transactionPostingLayer
                join sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount), TransactionCurrencyCode, LedgerDimension, PostingType
                from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalAccountEntry.AccountingCurrencyAmount != assetTrans.AmountMST
                        && (generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense  // For acquisition through PO scenario
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump)
                exists join vendInvoiceJour  // This join determines if the acquisitions originated from a Purchase Order
                    where vendInvoiceJour.LedgerVoucher == assetTrans.Voucher
                        && vendInvoiceJour.InvoiceDate == assetTrans.TransDate
                notexists join transactionReversalTrans
                    where transactionReversalTrans.RefRecId == assetTrans.RecId
                        && transactionReversalTrans.RefTableId == tableNum(AssetTrans)
            {
                if (!_assetTransList.find(assetTrans))
                {
                    assetTransFromPO = assetTrans::find(assetTrans.RecId);
                    if (assetTransFromPO)
                    {
                        if (assetTransFromPO.AmountCur && assetTransFromPO.AmountCur != generalJournalAccountEntry.TransactionCurrencyAmount)
                        {
                            generalJournalAccountEntry.TransactionCurrencyAmount = assetTransFromPO.AmountCur;
                            generalJournalAccountEntry.AccountingCurrencyAmount = assetTransFromPO.AmountMST;
                            generalJournalAccountEntry.ReportingCurrencyAmount = _currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTransFromPO.CurrencyCode, assetTransFromPO.AmountCur);
                            generalJournalAccountEntry.TransactionCurrencyCode = assetTransFromPO.CurrencyCode;
                        }
                    }

                    this.addLedgerVoucherTransObjects(_ledgerVoucherObject, generalJournalAccountEntry, _assetBook.DefaultDimension, _assetTransferHistory.ToDimension,
                                    _assetBook.exchangeRateDate(), transferComment);
                    processTransfer = true;
                }
            }
        }
        else
        {
            // For non-single voucher scenarios, LedgerVoucher and CostLedgerVoucher fields are used to associate the transactions.
            while select assetTrans
                group by generalJournalAccountEntry.LedgerDimension, generalJournalAccountEntry.TransactionCurrencyCode, generalJournalAccountEntry.PostingType
                where assetTrans.AssetId == _assetBook.AssetId
                    && assetTrans.BookId == _assetBook.BookId
                    && assetTrans.TransDate >= _fromDateTransfer
                    && assetTrans.TransDate <= _toDateTransfer
                    && (assetTrans.TransType == AssetTransType::Acquisition
                        || assetTrans.TransType == AssetTransType::AcquisitionAdj)
                join subledgerVoucherGeneralJournalEntry
                    where subledgerVoucherGeneralJournalEntry.Voucher == assetTrans.Voucher
                        && subledgerVoucherGeneralJournalEntry.AccountingDate == assetTrans.TransDate
                        && subledgerVoucherGeneralJournalEntry.VoucherDataAreaId == assetTrans.DataAreaId
                join generalJournalEntry
                    where generalJournalEntry.RecId == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalEntry.PostingLayer == _transactionPostingLayer
                join sum(TransactionCurrencyAmount), sum(AccountingCurrencyAmount), sum(ReportingCurrencyAmount), TransactionCurrencyCode, LedgerDimension, PostingType
                from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == subledgerVoucherGeneralJournalEntry.GeneralJournalEntry
                        && generalJournalAccountEntry.AccountingCurrencyAmount != assetTrans.AmountMST
                        && (generalJournalAccountEntry.PostingType == LedgerPostingType::PurchExpense  // For acquisition through PO scenario
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit
                        || generalJournalAccountEntry.PostingType == LedgerPostingType::PurchConsump)
                exists join vendInvoiceJour  // This join determines if the acquisitions originated from a Purchase Order
                    // If single voucher functionality is not used, Cost Ledger Voucher needs to be included in the transfer.
                    where (vendInvoiceJour.LedgerVoucher == assetTrans.Voucher
                        || vendInvoiceJour.CostLedgerVoucher == assetTrans.Voucher)
                notexists join transactionReversalTrans
                    where transactionReversalTrans.RefRecId == assetTrans.RecId
                        && transactionReversalTrans.RefTableId == tableNum(AssetTrans)
            {
                if (!_assetTransList.find(assetTrans))
                {
                    assetTransFromPO = assetTrans::find(assetTrans.RecId);
                    if (assetTransFromPO)
                    {
                        if (assetTransFromPO.AmountCur && assetTransFromPO.AmountCur != generalJournalAccountEntry.TransactionCurrencyAmount)
                        {
                            generalJournalAccountEntry.TransactionCurrencyAmount = assetTransFromPO.AmountCur;
                            generalJournalAccountEntry.AccountingCurrencyAmount = assetTransFromPO.AmountMST;
                            generalJournalAccountEntry.ReportingCurrencyAmount = _currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTransFromPO.CurrencyCode, assetTransFromPO.AmountCur);
                            generalJournalAccountEntry.TransactionCurrencyCode = assetTransFromPO.CurrencyCode;
                        }

                        this.addLedgerVoucherTransObjects(_ledgerVoucherObject, generalJournalAccountEntry, _assetBook.DefaultDimension, _assetTransferHistory.ToDimension,
                                        _assetBook.exchangeRateDate(), transferComment);
                        processTransfer = true;
                    }
                }
            }
        }

        return processTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransferHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new record in the <c>AssetTmpAssetTransferHistory</c> table when an asset is transferred
    ///    from one dimension to another.
    /// </summary>
    /// <param name="_assetTransferHistory">
    ///    The <c>AssetTransferHistory</c> table buffer to create for history.
    /// </param>
    /// <param name="_dimensionValue">
    ///    The dimension value of a value model.
    /// </param>
    /// <param name="_dimension">
    ///    The dimension name of a value model.
    /// </param>
    /// <param name="_isToValue">
    ///    A Boolean value that indicates whether to create records for a dimension from a value or from a
    ///    dimension to a value; optional.
    /// </param>
    /// <returns>
    ///    The <c>AssetTmpAssetTransferHistory</c> table buffer.
    /// </returns>
    protected AssetTmpAssetTransferHistory createTransferHistory(
        AssetTransferHistory _assetTransferHistory,
        DimensionValue       _dimensionValue,
        Name                 _dimension,
        boolean              _isToValue = false)
    {
        assetTmpAssetTransferHistory.RefRecId        = _assetTransferHistory.RecId;
        assetTmpAssetTransferHistory.AssetId         = _assetTransferHistory.AssetId;
        assetTmpAssetTransferHistory.BookId          = _assetTransferHistory.BookId;
        assetTmpAssetTransferHistory.TransferComment = _assetTransferHistory.TransferComment;
        assetTmpAssetTransferHistory.TransferDate    = _assetTransferHistory.TransferDate;
        assetTmpAssetTransferHistory.Voucher         = _assetTransferHistory.Voucher;
        assetTmpAssetTransferHistory.TransferValue   = _assetTransferHistory.TransferValue;
        assetTmpAssetTransferHistory.TransferValueReportingCurrency = _assetTransferHistory.TransferValueReportingCurrency;
        assetTmpAssetTransferHistory.Name            = _dimension;

        if (_isToValue)
        {
            assetTmpAssetTransferHistory.ToValue     = _dimensionValue;
        }
        else
        {
            assetTmpAssetTransferHistory.FromValue   = _dimensionValue;
        }

        return assetTmpAssetTransferHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>filterAssetBooks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Filters out unwanted value models based on the business need.
    /// </summary>
    /// <param name="_sourceAssetBookList">
    /// A list of value models that are selected by the user.
    /// </param>
    /// <returns>
    /// A list of value models after filtering out unwanted value models.
    /// </returns>
    /// <remarks>
    /// The default functionality is provided here. The derived classes can override this method to remove
    /// unwanted value models from the list.
    /// </remarks>
    protected RecordSortedList filterAssetBooks(RecordSortedList _sourceAssetBookList)
    {
        return _sourceAssetBookList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetTransferHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets all the <c>AssetTransferHistory</c> records for the fixed assets.
    /// </summary>
    /// <param name="_assetId">
    ///     The fixed asset Id whose transfer history is to be reviewed.
    /// </param>
    /// <returns>
    ///    The <c>AssetTmpAssetTransferHistory</c> table buffer.
    /// </returns>
    public AssetTmpAssetTransferHistory getAssetTransferHistory(AssetId _assetId = '0')
    {
        Query query;

        query = new Query(queryStr(AssetFromDimension));

        if (!prmisDefault(_assetId))
        {
            query.dataSourceTable(tableNum(AssetTransferHistory)).addRange(fieldNum(AssetTransferHistory, AssetId)).value(_assetId);
        }

        // Create the records for AssetTmpAssetTransferHistory table with the dimension from value.
        assetTmpAssetTransferHistory = this.setUpTransferData(query);

        query = new Query(queryStr(AssetToDimension));

        if (!prmisDefault(_assetId))
        {
            query.dataSourceTable(tableNum(AssetTransferHistory)).addRange(fieldNum(AssetTransferHistory, AssetId)).value(_assetId);
        }

        // Creates the records for AssetTmpAssetTransferHistory table with the dimension to value.
        assetTmpAssetTransferHistory = this.setUpTransferData(query, NoYes::Yes);

        return assetTmpAssetTransferHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertAssetTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the <c>AssetTrans</c> table.
    /// </summary>
    /// <param name="_assetId">
    /// An <c>AssetId</c> value.
    /// </param>
    /// <param name="_bookId">
    /// An <c>AssetBookId</c> value.
    /// </param>
    /// <param name="_assetGroup">
    /// An <c>AssetGroupId</c> value.
    /// </param>
    /// <param name="_voucher">
    /// The voucher that is posted in a sub ledger journal lines.
    /// </param>
    /// <param name="_transferDate">
    /// The transfer date of an asset.
    /// </param>
    /// <param name="_transferComment">
    /// The description of a transaction.
    /// </param>
    /// <param name="_newDefaultDimension">
    ///  New Default dimension of the Asset Transfer
    /// </param>
    protected void insertAssetTrans(
        AssetId         _assetId,
        AssetBookId     _bookId,
        AssetGroupId    _assetGroup,
        Voucher         _voucher,
        TransDate       _transferDate,
        TransferComment _transferComment = "",
        DimensionDefault  _newDefaultDimension = 0)
    {
        AssetNetBookValue netBookValue;
        AssetNetBookValue netBookValueReportingCurrency;
        AssetTrans assetTrans;

        netBookValue = AssetBook::find(_assetId, _bookId).assetNetBookValue();
        netBookValueReportingCurrency = AssetBook::find(_assetId, _bookId).assetNetBookValueReportingCurrency();

        assetTrans.TransType    = AssetTransType::AssetTransfer;
        assetTrans.AssetId      = _assetId;
        assetTrans.BookId       = _bookId;
        assetTrans.AssetGroup   = _assetGroup;
        assetTrans.TransDate    = _transferDate;
        assetTrans.CurrencyCode = Ledger::accountingCurrency();
        assetTrans.AmountCur    = netBookValue;
        assetTrans.AmountMST    = netBookValue;       
        assetTrans.ReportingCurrencyAmount = netBookValueReportingCurrency;        
        assetTrans.Voucher      = _voucher;
        assetTrans.Txt          = _transferComment;
        assetTrans.PostingProfile = AssetTable::find(_assetId).postingProfile(_bookId);
        assetTrans.DefaultDimension = _newDefaultDimension;

        assetTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransferHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the <c>AssetTransferHistory</c> table.
    /// </summary>
    /// <param name="_assetId">
    /// The <c>AssetId</c> value of the asset that is transferred.
    /// </param>
    /// <param name="_bookId">
    /// The <c>BookId</c> value of the value model that is transferred.
    /// </param>
    /// <param name="_toDimension">
    /// The new dimension to which the asset is transferred.
    /// </param>
    /// <param name="_transferDate">
    /// The date in which the asset is transferred.
    /// </param>
    /// <param name="_transferComment">
    /// The transfer comments.
    /// </param>
    /// <param name="_voucher">
    /// The voucher that is used in the transfer.
    /// </param>
    protected void insertTransferHistory(
        AssetId             _assetId,
        AssetBookId         _bookId,
        DimensionDefault    _toDimension,
        TransferDate        _transferDate,
        TransferComment     _transferComment,
        Voucher             _voucher)
    {
        AssetBook assetBook;
        AssetTransferHistory assetTransferHistory;

        assetBook = AssetBook::find(_assetId, _bookId);

        assetTransferHistory.AssetId                 = _assetId;
        assetTransferHistory.BookId                  = _bookId;
        assetTransferHistory.FromDimension           = assetBook.DefaultDimension;
        assetTransferHistory.ToDimension             = _toDimension;
        assetTransferHistory.TransferDate            = _transferDate;
        assetTransferHistory.TransferValue           = assetBook.assetNetBookValue();
        assetTransferHistory.TransferValueReportingCurrency = assetBook.assetNetBookValueReportingCurrency();
        assetTransferHistory.TransferComment         = _transferComment;
        assetTransferHistory.Voucher                 = _voucher;
        assetTransferHistory.TransferSequenceNumber  = _voucher;

        assetTransferHistory.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpTransferData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Prepares the asset transfer data by executing the AOT query for transfer from dimension and
    ///    transfer to dimension.
    /// </summary>
    /// <param name="_query">
    ///    The AOT query contains either a <c>AssetFromDimension</c> query or a <c>AssetToDimension</c> query.
    /// </param>
    /// <param name="_forUpdate">
    ///    A Boolean value that indicates whether to update the <c>AssetTmpAssetTransferHistory</c> record for
    ///    dimension to value or to insert the record; optional.
    /// </param>
    /// <returns>
    ///    The <c>AssetTmpAssetTransferHistory</c> table buffer.
    /// </returns>
    /// <remarks>
    ///    This method executes the AOT queries both for an asset transfer from dimension and a transfer to
    ///    dimension. For the transfer from dimension, records are inserted in the
    ///    <c>AssetTmpAssetTransferHistory</c> table. For the transfer to dimension, records are updated if
    ///    they are found; otherwise records are inserted with only transfer to dimension.
    /// </remarks>
    protected AssetTmpAssetTransferHistory setUpTransferData(Query _query, boolean _forUpdate = false)
    {
        AssetTransferHistory            assetTransferHistory;
        DimensionAttributeValueSetItem  dimensionAttributeValueSetItem;
        DimensionAttribute              dimensionAttribute;
        QueryRun                        queryRun;

        queryRun = new QueryRun(_query);

        while (queryRun.next())
        {
            assetTransferHistory            = queryRun.get(tableNum(AssetTransferHistory));
            dimensionAttributeValueSetItem  = queryRun.get(tableNum(DimensionAttributeValueSetItem));
            dimensionAttribute              = queryRun.get(tableNum(DimensionAttribute));

            if (_forUpdate)
            {
                select firstonly forupdate Name, RefRecId from assetTmpAssetTransferHistory
                    where assetTmpAssetTransferHistory.Name == dimensionAttribute.Name
                       && assetTmpAssetTransferHistory.RefRecId == assetTransferHistory.RecId;

                if (assetTmpAssetTransferHistory.RefRecId)
                {
                    assetTmpAssetTransferHistory.ToValue = dimensionAttributeValueSetItem.DisplayValue;
                    assetTmpAssetTransferHistory.update();
                }
                else
                {
                    if (dimensionAttribute.Name)
                    {
                        assetTmpAssetTransferHistory.data(this.createTransferHistory(
                                                            assetTransferHistory,
                                                            dimensionAttributeValueSetItem.DisplayValue,
                                                            dimensionAttribute.Name,
                                                            NoYes::Yes));
                        assetTmpAssetTransferHistory.insert();
                    }
                }
            }
            else if (dimensionAttribute.Name)
            {
                assetTmpAssetTransferHistory.data(this.createTransferHistory(
                                                        assetTransferHistory,
                                                        dimensionAttributeValueSetItem.DisplayValue,
                                                        dimensionAttribute.Name));
                assetTmpAssetTransferHistory.insert();
            }
        }

        return assetTmpAssetTransferHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferAsset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers all the assets that exist in the <c>RecordSortedList</c> object to the new dimension
    /// value and inserts history in the <c>AssetTransferHistory</c> table and updates the <c>AssetBook</c>
    /// table with the new dimension value.
    /// </summary>
    /// <param name="_assetBookList">
    /// A list that contains all the <c>AssetBook</c> records to transfer.
    /// </param>
    /// <param name="_newDimension">
    /// The new transfer to value of the dimension.
    /// </param>
    /// <param name="_transferDate">
    /// The asset transfer date.
    /// </param>
    /// <param name="_transferComment">
    /// The asset transfer comments.
    /// </param>
    /// <returns>
    /// true if the asset is transferred successfully; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method transfers the fixed asset to a new dimension, inserts history in the
    /// <c>AssetTransferHistory</c> table, and updates the <c>AssetBook</c> table with the new dimension
    /// values.
    /// </remarks>
    ///
    public boolean transferAsset(
        RecordSortedList  _assetBookList,
        DimensionDefault  _newDimension,
        TransferDate      _transferDate,
        TransferComment   _transferComment)
    {
        recId fiscalCalendarRecId;

        fiscalCalendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
        transferDate        = _transferDate;
        newDefaultDimension = _newDimension;
        transferComment     = _transferComment;

        if (LedgerFiscalCalendar::checkDateIsValid(fiscalCalendarRecId, transferDate))
        {
            this.createTransactions(_assetBookList);
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>DefaultDimension</c> field of the specified value model.
    /// </summary>
    /// <param name="_assetId">
    /// The <c>AssetId</c> of the asset.
    /// </param>
    /// <param name="_assetBookId">
    /// The <c>BookId</c> value of the <c>AssetBook</c> table.
    /// </param>
    /// <param name="_newDefaultDimension">
    /// A new default dimension ID.
    /// </param>
    protected void updateDefaultDimension(
        AssetId             _assetId,
        AssetBookId         _assetBookId,
        DimensionDefault    _newDefaultDimension)
    {
        AssetBook assetBook;

        assetBook = AssetBook::find(_assetId, _assetBookId, true);

        assetBook.DefaultDimension = _newDefaultDimension;
        assetBook.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static AssetTransfer construct()
    {
        return new AssetTransfer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromAndToDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets all the selected <c>AssetTransferHistory</c> records for the fixed assets.
    /// </summary>
    /// <param name="_recordSortedList">
    ///    A list of the <c>AssetBook</c> table record.
    /// </param>
    /// <param name="_toValue">
    ///    A record ID of the <c>DimensionAttributeValueSet</c> table.
    /// </param>
    /// <returns>
    ///    The <c>AssetTmpAssetTransferHistory</c> table buffer.
    /// </returns>
    public static AssetTmpAssetTransferHistory getFromAndToDimensions(
        RecordSortedList _recordSortedList,
        DimensionDefault _toValue)
    {
        DimensionAttributeValueSetItemView  dimensionAttributeValueSetItemView;
        DimensionAttribute                  dimensionAttribute;
        DimensionAttributeSetItem           dimensionAttributeSetItem;
        boolean                             haveMoreValues;
        AssetBook                           assetBook;
        AssetTmpAssetTransferHistory        localAssetTmpAssetTransferHistory;
        DimensionEnumeration                dimensionStructure;

        haveMoreValues = _recordSortedList.first(assetBook);

        dimensionStructure = DimensionCache::getDimensionAttributeSetForLedger();

        while (haveMoreValues)
        {
            while select DisplayValue, DimensionAttribute from dimensionAttributeValueSetItemView
                where dimensionAttributeValueSetItemView.DimensionAttributeValueSet == assetBook.DefaultDimension
            join Name from dimensionAttribute
                where dimensionAttribute.RecId == dimensionAttributeValueSetItemView.DimensionAttribute
            exists join dimensionAttributeSetItem
                where dimensionAttributeSetItem.DimensionAttribute == dimensionAttribute.RecId
                    && dimensionAttributeSetItem.DimensionAttributeSet == dimensionStructure
            {
                localAssetTmpAssetTransferHistory.clear();
                localAssetTmpAssetTransferHistory.FromValue = dimensionAttributeValueSetItemView.DisplayValue;
                localAssetTmpAssetTransferHistory.AssetId   = assetBook.AssetId;
                localAssetTmpAssetTransferHistory.BookId    = assetBook.BookId;
                localAssetTmpAssetTransferHistory.Name      = dimensionAttribute.Name;
                localAssetTmpAssetTransferHistory.insert();
            }

            while select DisplayValue, DimensionAttribute from dimensionAttributeValueSetItemView
                where dimensionAttributeValueSetItemView.DimensionAttributeValueSet == _toValue
            join Name from dimensionAttribute
                where dimensionAttribute.RecId == dimensionAttributeValueSetItemView.DimensionAttribute
            exists join dimensionAttributeSetItem
                where dimensionAttributeSetItem.DimensionAttribute == dimensionAttribute.RecId
                    && dimensionAttributeSetItem.DimensionAttributeSet == dimensionStructure
            {
                select firstonly forupdate localAssetTmpAssetTransferHistory
                    where localAssetTmpAssetTransferHistory.Name == dimensionAttribute.Name
                        && localAssetTmpAssetTransferHistory.AssetId == assetBook.AssetId
                        && localAssetTmpAssetTransferHistory.BookId == assetBook.BookId;

                if (localAssetTmpAssetTransferHistory)
                {
                    localAssetTmpAssetTransferHistory.ToValue = dimensionAttributeValueSetItemView.DisplayValue;
                    localAssetTmpAssetTransferHistory.update();
                }
                else
                {
                    localAssetTmpAssetTransferHistory.ToValue   = dimensionAttributeValueSetItemView.DisplayValue;
                    localAssetTmpAssetTransferHistory.AssetId   = assetBook.AssetId;
                    localAssetTmpAssetTransferHistory.BookId    = assetBook.BookId;
                    localAssetTmpAssetTransferHistory.Name      = dimensionAttribute.Name;
                    localAssetTmpAssetTransferHistory.insert();
                }
            }
            haveMoreValues = _recordSortedList.next(assetBook);
        }

        return localAssetTmpAssetTransferHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSkipBookTransfer_FR</Name>
				<Source><![CDATA[
    internal boolean isSkipBookTransfer_FR(AssetBook _assetBook)
    {
        #ISOCountryRegionCodes

        boolean skipBookTransfer;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR])
            && _assetBook.IsDerogatoryBook_FR)
        {
            AssetBook assetBookLocal;

            select firstOnly RecId from assetBookLocal
                where assetBookLocal.AssetId == _assetBook.AssetId
                    && assetBookLocal.AssetDerogatoryModel_FR == _assetBook.BookId;

            skipBookTransfer = assetBookLocal.RecId != 0;
        }

        return skipBookTransfer;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>