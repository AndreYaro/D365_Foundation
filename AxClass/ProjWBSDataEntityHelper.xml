<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjWBSDataEntityHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class ProjWBSDataEntityHelper
{
    internal const static str delimiter = ".";

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getTaskFieldsFromWBSId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the corresponding parent hierarchy task id, task sibling number, if task needs to be created and if a task is a child of a given WBS Id.
    /// </summary>
    /// <param name = "connection">
    /// <c>Connection</c> instance to be used for a direct-SQL call for querying <c>ProjPlanVersion<c> table
    /// </param>
    /// <param name = "_hierarchyId">
    /// Hierarchy Id of the task that is being searched
    /// </param>
    /// <param name = "_wbsId">
    /// WBS Id of that task that is being searched
    /// </param>
    /// <returns>
    /// Container that contains the ParentTaskId, the TaskSibiling number, a boolean to determine if it's a new or existing task, a boolean if it's a child task or not
    /// </returns>
    /// <remarks>
    /// This will do 2 direct-SQL connection calls, 1 for getting the parent Task ID and the other for
    /// getting the actual Task ID of the WBS ID
    /// </remarks>
    [SysObsoleteAttribute('This method is no longer needed as PathId is now a field in ProjPlanVersion which stores the WBS ID data.', false, 27\07\2019)]
    public static container getTaskFieldsFromWBSId(Connection connection, HierarchyIdBase _hierarchyId, str _wbsId)
    {
        return ['', ''];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaskIdFromWBSId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the corresponding hierarchy task id of a given WBS Id.
    /// </summary>
    /// <param name = "connection">
    /// <c>Connection</c> instance to be used for a direct-SQL call for querying <c>ProjPlanVersion<c> table
    /// </param>
    /// <param name = "_hierarchyId">
    /// Hierarchy Id of the task that is being searched
    /// </param>
    /// <param name = "_wbsId">
    /// WBS Id of that task that is being searched
    /// </param>
    /// <returns>
    /// HierarchyTaskId from <c>ProjPlanVersion</c>
    /// </returns>
    [SysObsoleteAttribute('This method is replaced by ProjPlanVersion::findByHierarchyAndPathId().HierarchyTaskId', false, 27\07\2019)]
    public static ProjHierarchyTaskId getTaskIdFromWBSId(Connection connection, HierarchyIdBase _hierarchyId, str _wbsId)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWBSIdFromTaskId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generate a WBS ID from a given task id of an existing WBS hierarchy
    /// </summary>
    /// <param name = "_hierarchyId">
    /// An existing hierarchy id from <c>ProjPlanVersion</c> table
    /// </param>
    /// <param name = "_taskId">
    /// The task Id
    /// </param>
    /// <returns>
    /// WBS Id string (example 1.1.1)
    /// </returns>
    [SysObsoleteAttribute('This method is replaced by ProjPlanVersion::findByHierarchyAndTaskId().PathId', false, 27\07\2019)]
    public static str getWBSIdFromTaskId(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadPredecessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the predecessors of a give hierarchy and task
    /// </summary>
    /// <param name = "_hierarchyId">
    /// ID of an existing hierarchy.
    /// </param>
    /// <param name = "_taskId">
    /// ID of an existing task in a hierarchy
    /// </param>
    /// <returns>
    /// List of WBS IDs delimited with comma that were predecesors of a given task
    /// </returns>
    public static str loadPredecessor(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId)
    {
        ProjDependency  projDependency;
        ProjPlanVersion planVersion;
        str             predecessorData;
        
        while select projDependency
                where projDependency.ProjPlanHierarchyId == _hierarchyId
                    && projDependency.SuccessorHierarchyTaskId == _taskId
            join HierarchyId, ParentHierarchyTaskId, TaskSiblingNumber, HierarchyTaskId from planVersion
                where planVersion.HierarchyId == _hierarchyId
                     && planVersion.HierarchyTaskId == projDependency.PredecessorHierarchyTaskId
        {
            if (projDependency.PredecessorHierarchyTaskId)
            {
                ProjHierarchyPathId wbsId = ProjPlanVersion::findByHierarchyAndTaskId(planVersion.HierarchyId, planVersion.HierarchyTaskId).PathId;
                    
                predecessorData = predecessorData ? strFmt('%1,%2', predecessorData, wbsId) : wbsId;
            }
        }

        return predecessorData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaskIdInPredecessorCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if a task is in predecessor cache. The cache is filled when a task was created with predecessors but the predecessors are not in the database yet
    /// </summary>
    /// <param name = "_hierarchyId">
    /// ID of an existing hierarchy
    /// </param>
    /// <param name = "_predecessorTaskId">
    /// Task ID of the predecessor
    /// </param>
    /// <param name = "_wbsId">
    /// WBS ID of the predecessor
    /// </param>
    public static void checkTaskIdInPredecessorCache(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _predecessorTaskId, str _wbsId)
    {
        // predecessor cache
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        container key;
        container cachedPredecessors;
        str cacheScope = strFmt('%1#%2', classStr(ProjWBSDataEntityHelper), _hierarchyId);

        key = [strFmt('%1#%2', _hierarchyId, _wbsId)];

        cachedPredecessors = objectCache.find(cacheScope, key);

        if (cachedPredecessors != conNull())
        {
            ProjHierarchyTaskId successorTaskId;

            for (int i =1; i <= conLen(cachedPredecessors); i++)
            {
                successorTaskId = conPeek(cachedPredecessors, i);

                // Update depedency
                ProjWBSDataEntityHelper::insertPredecessorToTask(_hierarchyId, successorTaskId, _predecessorTaskId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPredecessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the <c>ProjDependency</c> table for predecessors of a given task. If the predecessors don't exist yet in the database, add them to a cache
    /// </summary>
    /// <param name = "_hierarchyId">
    /// ID of an existing hierarchy.
    /// </param>
    /// <param name = "_taskId">
    /// ID of an existing task
    /// </param>
    /// <param name = "_predecessors">
    /// Comma delimited string of predecessors
    /// </param>
    public static void setPredecessor(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId, str _predecessors)
    {
        ttsbegin;
        ProjWBSDataEntityHelper::removeSuccessorByTask(_hierarchyId, _taskId);

        const str comma = ",";

        List listWbsPredecessors = strSplit(_predecessors, comma);

        if (listWbsPredecessors.elements() == 0)
        {
            return;
        }

        ListEnumerator listWbsPredecessorsEnum = listWbsPredecessors.getEnumerator();

        ProjHierarchyTaskId predecessorTaskId;
        
        // predecessor cache
        SysGlobalObjectCache objectCache = ClassFactory.globalObjectCache();
        container key;
        container cachedPredecessors;
        str cacheScope = strFmt('%1#%2', classStr(ProjWBSDataEntityHelper), _hierarchyId);

        // iterate to predecessors' WBSID
        while (listWbsPredecessorsEnum.moveNext())
        {
            ProjHierarchyPathId predecessorWBSId = listWbsPredecessorsEnum.current();

            // get the taskId of the predecessor's WBSID
            predecessorTaskId = ProjPlanVersion::findByHierarchyAndPathId(_hierarchyId, predecessorWBSId).HierarchyTaskId;

            if (predecessorTaskId != 0)
            {
                // Update depedency
                ProjWBSDataEntityHelper::insertPredecessorToTask(_hierarchyId, _taskId, predecessorTaskId);
            }
            else
            {
                // if predecessor task is not yet created, add it in the cache
                key = [strFmt('%1#%2',_hierarchyId, predecessorWBSId)];

                cachedPredecessors = objectCache.find(cacheScope, key);

                if (cachedPredecessors == conNull())
                {
                    objectCache.insert(cacheScope, key, [_taskId]);
                }
                else
                {
                    cachedPredecessors += _taskId;
                    objectCache.remove(cacheScope, key);
                    objectCache.insert(cacheScope, key, cachedPredecessors);
                }
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateEffortHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the effort hours from a given duration in days and working calendar.
    /// </summary>
    /// <param name = "_calendarId">
    /// The Calendar ID used by Project for scheduling.
    /// </param>
    /// <param name = "_duration">
    /// Duration in days.
    /// </param>
    /// <returns>
    /// Total number of hours
    /// </returns>
    [SysObsoleteAttribute('This method is replaced by ProjPlanVersion::calcTaskEffortHours()', false, 27\07\2019)]
    public static Hours calculateEffortHours(CalendarId _calendarId, DaysAsReal _duration)
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPredecessorToTask</Name>
				<Source><![CDATA[
    private static void insertPredecessorToTask(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _task, ProjHierarchyTaskId _predecessor)
    {
        ProjDependency projDependency;

        select firstonly RecId from projDependency
            where projDependency.ProjPlanHierarchyId == _hierarchyId
                && projDependency.SuccessorHierarchyTaskId == _task
                && projDependency.PredecessorHierarchyTaskId == _predecessor;

        if (projDependency.RecId == 0)
        {
            projDependency.SuccessorHierarchyTaskId = _task;
            projDependency.PredecessorHierarchyTaskId = _predecessor;
            projDependency.ProjPlanHierarchyId = _hierarchyId;
            projDependency.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeSuccessorByTask</Name>
				<Source><![CDATA[
    private static void removeSuccessorByTask(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _task)
    {
        ProjDependency projDependency;

        delete_from projDependency
            where projDependency.ProjPlanHierarchyId == _hierarchyId
                && projDependency.SuccessorHierarchyTaskId == _task;

    }

]]></Source>
			</Method>
			<Method>
				<Name>removePredecessorByTask</Name>
				<Source><![CDATA[
    private static void removePredecessorByTask(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _task)
    {
        ProjDependency projDependency;

        delete_from projDependency
            where projDependency.ProjPlanHierarchyId == _hierarchyId
                && projDependency.PredecessorHierarchyTaskId == _task;

    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInsertOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether insert operation will be valid.
    /// </summary>
    /// <param name = "_hierarchyLevel">Task hierarchy level.</param>
    /// <param name = "_parentHierarchyTaskId">Task parent hierarchy task ID.</param>
    /// <returns>true if insert operation will be valid; otherwise, false.</returns>
    public static boolean validateInsertOperation(ProjHierarchyLevel _hierarchyLevel, ProjHierarchyTaskId _parentHierarchyTaskId)
    {
        // Only valid if this is root or if the parent task ID can be identified.
        return _hierarchyLevel == 0 || _parentHierarchyTaskId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaskPredecessors</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether predecessors specified on task are valid. This is aligned with validation from UI.
    /// </summary>
    /// <param name = "_task">Task to be added or updated.</param>
    /// <param name = "_predecessors">Comma delimited string of predecessors.</param>
    protected static void validateTaskPredecessors(ProjPlanVersion _task, str _predecessors)
    {
        if (!_predecessors)
        {
            return;
        }

        const str comma = ",";
        List listWbsPredecessors = strSplit(_predecessors, comma);
        if (listWbsPredecessors.elements() == 0)
        {
            return;
        }

        ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(ProjWBSDataEntityHelper));
        using (var activityContext = logger.projOpsManagementActivity().validateTaskPredecessorsContext())
        {
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::HierarchyIdProperty, _task.HierarchyId);
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::TaskIdProperty, any2Str(_task.HierarchyTaskId));
            activityContext.addCustomProperty(ProjOpsInstrumentationBaseActitivies::PredecessorsProperty, _predecessors);

            // Prefetch dependency edges from the database
            List dependencyEdges = new List(Types::Container);
            {
                ProjDependency dependencyEdge;
                while select dependencyEdge
                        where dependencyEdge.ProjPlanHierarchyId == _task.HierarchyId
                {
                    dependencyEdges.addEnd([dependencyEdge.PredecessorHierarchyTaskId, dependencyEdge.SuccessorHierarchyTaskId]);
                }
            }

            // Create initial set of predecessors which may not be selected (current task and parent to root)
            Set invalidPredecessors = new Set(Types::Int64);
            ProjPlanVersion invalidPredecessor = ProjPlanVersion::findByHierarchyAndTaskId(_task.HierarchyId, _task.HierarchyTaskId);
            while (invalidPredecessor && invalidPredecessor.HierarchyTaskId)
            {
                invalidPredecessors.add(invalidPredecessor.HierarchyTaskId);
                invalidPredecessor = ProjPlanVersion::findByHierarchyAndTaskId(_task.HierarchyId, invalidPredecessor.ParentHierarchyTaskId);
            }

            // While the set of invalid predecessors has been changed
            boolean invalidPredecessorsChanged;
            do
            {
                invalidPredecessorsChanged = false;

                // Iterate over list of edges to try and prove more invalid predecesors
                ListIterator iter = new ListIterator(dependencyEdges);
                while (iter.more())
                {
                    ProjHierarchyTaskId predecessor, successor;
                    [predecessor, successor] = iter.value();

                    // If the predecessor of an edge has proven to be invalid, then the successor is invalid
                    if (invalidPredecessors.in(predecessor))
                    {
                        invalidPredecessorsChanged = invalidPredecessors.add(successor) || invalidPredecessorsChanged;
                        // If the successor of an edge has proven to be invalid, then parent of parents for invalid successor is invalid
                        ProjPlanVersion invalidPredecessorFromSuccessor = ProjPlanVersion::findByHierarchyAndTaskId(_task.HierarchyId, successor);
                        while (invalidPredecessorFromSuccessor)
                        {
                            invalidPredecessors.add(invalidPredecessorFromSuccessor.HierarchyTaskId);
                            invalidPredecessorFromSuccessor = ProjPlanVersion::findByHierarchyAndTaskId(_task.HierarchyId, invalidPredecessorFromSuccessor.ParentHierarchyTaskId);
                        }
                        iter.delete();
                    }
                    else
                    {
                        iter.next();
                    }
                }
            }
            while (invalidPredecessorsChanged);

            ListEnumerator listWbsPredecessorsEnum = listWbsPredecessors.getEnumerator();
            while (listWbsPredecessorsEnum.moveNext())
            {
                ProjHierarchyPathId predecessorWBSId = listWbsPredecessorsEnum.current();
                
                if (predecessorWBSId)
                {
                    ProjPlanVersion predecessorTask = ProjPlanVersion::findByHierarchyAndPathId(_task.HierarchyId, predecessorWBSId);
                    if (invalidPredecessors.in(predecessorTask.HierarchyTaskId))
                    {
                        // Invalid predecessor on task with WBS ID %1. Task's predecessor cannot be itself, or its parent, or other level in the hierarchy above it, or circularly referenced.
                        throw error(strFmt("@Proj:InvalidWbsTaskPredecessor", _task.PathId));
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preInsertOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre insert operation to set parameters for the <c>ProjPlanVersion</c> buffer to be inserted.
    /// </summary>
    /// <param name = "_insertTask"><c>ProjPlanVersion</c> buffer to be inserted.</param>
    /// <param name = "_parentTask"><c>ProjPlanVersion</c> buffer of the parent task be inserted.</param>
    /// <param name = "_predecessors">Comma delimited string of predecessors.</param>
    /// <param name = "_calendarId">Calendar ID; optional</param>
    /// <param name = "_CalendarStandardWorkDayHours">Calendar standard work day hours; optional</param>
    public static void preInsertOperation(ProjPlanVersion _insertTask, ProjPlanVersion _parentTask,
        str _predecessors, CalendarId _calendarId = '', Hours _calendarStandardWorkDayHours = 0)
    {
        if (ProjValidateTaskPredecessorsFlight::instance().isEnabled())
        {
            ProjWBSDataEntityHelper::validateTaskPredecessors(_insertTask, _predecessors);
        }

        //Remove existing task with the same WBSID if it already exists.
        ProjPlanVersion existingTask = ProjPlanVersion::findByHierarchyAndPathId(_insertTask.HierarchyId, _insertTask.PathId, true);
        if (existingTask)
        {
            ttsbegin;
            existingTask.delete();
            ttscommit;
        }

        _insertTask.HierarchyTaskId = ProjPlanVersion::getNextTaskId(_insertTask.HierarchyId, false);
        _insertTask.HierarchyLevel = ProjPlanVersion::getHierarchyLevelByPathId(_insertTask.PathId);
        _insertTask.ParentHierarchyTaskId = _parentTask.HierarchyTaskId;
        _insertTask.NumberOfResources = max(_insertTask.NumberOfResources, 1);

        if (_insertTask.ParentHierarchyTaskId)
        {
            _insertTask.TaskSiblingNumber = ProjPlanVersion::getNextSiblingNumber(_insertTask.HierarchyId, _insertTask.ParentHierarchyTaskId);
        }

        if (_insertTask.TaskStartDate != dateNull() && _insertTask.TaskFinishDate != dateNull())
        {
            // reset end date to start date if end date is < start date
            if (_insertTask.TaskFinishDate < _insertTask.TaskStartDate)
            {
                _insertTask.TaskFinishDate = _insertTask.TaskStartDate;
                _insertTask.TaskDuration = 1;
                _insertTask.TaskEffort = 0;
            }
            else
            {
                _insertTask.TaskDuration = any2Real(WorkCalendarCalculator::calcDuration(_insertTask.TaskStartDate, _insertTask.TaskFinishDate, _calendarId));
            }

            if (_insertTask.TaskStartDate < _insertTask.TaskFinishDate && !_insertTask.TaskEffort)
            {
                _insertTask.TaskEffort = ProjPlanVersion::calcTaskEffortHours(_insertTask, _calendarId, _calendarStandardWorkDayHours);
            }
        }

        ProjWBSDataEntityHelper::checkTaskIdInPredecessorCache(_insertTask.HierarchyId, _insertTask.HierarchyTaskId, _insertTask.PathId);

        if (_predecessors)
        {
            ProjWBSDataEntityHelper::setPredecessor(_insertTask.HierarchyId, _insertTask.HierarchyTaskId, _predecessors);
        }

        _insertTask.TaskEffortAtComplete = _insertTask.TaskEffort;
        
        if (!_insertTask.TaskCategory)
        {
            _insertTask.EndNode = FalseTrue::False;
        }
        else
        {
            _insertTask.EndNode = FalseTrue::True;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInsertOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post insert operation to sync estimates records and set cost at complete for the inserted task.
    /// </summary>
    /// <param name = "_wbsType">WBS type.</param>
    /// <param name = "_insertTask">The inserted task <c>ProjPlanVersion</c> buffer.</param>
    /// <param name = "_parentTask">The inserted task parent <c>ProjPlanVersion</c> buffer.</param>
    /// <param name = "_calendarId">Calendar ID; optional.</param>
    /// <param name = "_CalendarStandardWorkDayHours">Calendar standard work day hours; optional.</param>
    public static void postInsertOperation(ProjWBSType _wbsType, ProjPlanVersion _insertedTask, 
        ProjPlanVersion _parentTask, CalendarId _calendarId = '', Hours _calendarStandardWorkDayHours = 0)
    {
        ttsbegin;
        // If the hierarchy is a quotation, need to add related records
        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            ElementNumber parentTaskElementNumber = ProjWorkBreakdownStructureV2FormHelper::getCorrespondingTaskElementNumber(_parentTask.HierarchyId, _parentTask.HierarchyTaskId);
            _insertedTask.HierarchyTreeTableRefRecId = ProjTaskNormalized::addTask(
                _insertedTask.HierarchyId,
                parentTaskElementNumber,
                _insertedTask.TaskName,
                _insertedTask.TaskEffort,
                _insertedTask.TaskStartDate,
                _insertedTask.TaskFinishDate,
                _insertedTask.TaskDuration,
                _insertedTask.NumberOfResources);
            _insertedTask.update();
        }

        if (_insertedTask.TaskCategory)
        {
            ProjEstimate::syncEstimateLinesFromTask(_insertedTask.HierarchyId, _insertedTask.HierarchyTaskId , _wbsType);
            ProjPlanVersion::updateCostAtCompleteV2(_insertedTask);
        }

        // Make sure the parent is a summary task
        ProjPlanVersion::setEndNodeStateV2(_calendarId, _wbsType, _parentTask, FalseTrue::False, _calendarStandardWorkDayHours);

        // Update parent
        ProjPlanVersion::updateFromChildren(_calendarId, _parentTask);

        // Update parent scheduling status
        ProjActivityCapacity::updateSummaryTaskSchedulingStatus(_parentTask);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre update operation to set parameters for the <c>ProjPlanVersion</c> buffer to be updated.
    /// </summary>
    /// <param name = "_updateTask"><c>ProjPlanVersion</c> buffer to be updated.</param>
    /// <param name = "_predecessors">Comma delimited string of predecessors.</param>
    public static void preUpdateOperation(ProjPlanVersion _updateTask, str _predecessors)
    {
        if (ProjValidateTaskPredecessorsFlight::instance().isEnabled())
        {
            ProjWBSDataEntityHelper::validateTaskPredecessors(_updateTask, _predecessors);
        }

        if (_updateTask.orig().TaskEffort != _updateTask.TaskEffort)
        {
            _updateTask.TaskEffortAtComplete = _updateTask.TaskEffort;
        }
        
        if (_predecessors)
        {
            ProjWBSDataEntityHelper::setPredecessor(_updateTask.HierarchyId, _updateTask.HierarchyTaskId, _predecessors);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postUpdateOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post update operation to sync estimates records and set cost at complete for the updated task.
    /// </summary>
    /// <param name = "_wbsType">WBS type.</param>
    /// <param name = "_updatedTask">The updated task <c>ProjPlanVersion</c> buffer.</param>
    /// <param name = "_calendarId">Calendar ID; optional.</param>
    public static void postUpdateOperation(ProjWBSType _wbsType, ProjPlanVersion _updatedTask, CalendarId _calendarId = '')
    {
        ttsbegin;
        ProjEstimate::syncEstimateLinesFromTask(_updatedTask.HierarchyId, _updatedTask.HierarchyTaskId , _wbsType);
        ProjPlanVersion::updateCostAtCompleteV2(_updatedTask);
            
        // Update parent
        ProjPlanVersion parentTask = ProjPlanVersion::findByHierarchyAndTaskId(_updatedTask.HierarchyId, _updatedTask.ParentHierarchyTaskId, true);
        ProjPlanVersion::updateFromChildren(_calendarId, parentTask);

        // Update parent scheduling status
        ProjActivityCapacity::updateSummaryTaskSchedulingStatus(parentTask);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preDeleteOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Pre delete operation to remove the child task, the child task assoicated estimates record and the child task assoicated sorting records.
    /// </summary>
    /// <param name = "_wbsType">WBS type.</param>
    /// <param name = "_insertTask"><c>ProjPlanVersion</c> buffer to be deleted.</param>
    public static void preDeleteOperation(ProjWBSType _wbsType, ProjPlanVersion _deleteTask)
    {
        // Delete all the child tasks under the task to be deleted.
        ttsbegin;
        ProjPlanVersion childsPlanVersion;
        while select forupdate childsPlanVersion
            where childsPlanVersion.HierarchyId == _deleteTask.HierarchyId
                && childsPlanVersion.PathId like _deleteTask.PathId + '.*'
        {
            childsPlanVersion.delete();
            ProjWBSDataEntityHelper::deleteRecordsReferencedByDeletedTask(_wbsType, childsPlanVersion);
            
            PSAActivityEstimates::deleteEstimatesForTask(childsPlanVersion.HierarchyId, childsPlanVersion.HierarchyTaskId);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDeleteOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post delete operation to remove the assocated estimate and sorting record. Also update parent tasks and sibling tasks.
    /// </summary>
    /// <param name = "_wbsType">WBS type.</param>
    /// <param name = "_deletedTask">The deleted task <c>ProjPlanVersion</c> buffer.</param>
    /// <param name = "_parentTask">The deleted task parent <c>ProjPlanVersion</c> buffer.</param>
    /// <param name = "_calendarId">Calendar ID; optional.</param>
    /// <param name = "_CalendarStandardWorkDayHours">Calendar standard work day hours; optional.</param>
    public static void postDeleteOperation(ProjWBSType _wbsType, ProjPlanVersion _deletedTask, 
        ProjPlanVersion _parentTask, CalendarId _calendarId = '', Hours _calendarStandardWorkDayHours = 0)
    {
        ttsbegin;
        ProjWBSDataEntityHelper::deleteRecordsReferencedByDeletedTask(_wbsType, _deletedTask);
        
        // Remove associated estimate records.
        PSAActivityEstimates::deleteEstimatesForTask(_deletedTask.HierarchyId, _deletedTask.HierarchyTaskId);

        ProjWBSDataEntityHelper::postDeleteTaskUpdateParentTasks(_deletedTask.HierarchyId, _calendarId,
            _wbsType, _calendarStandardWorkDayHours, _deletedTask, _parentTask);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecordsReferencedByDeletedTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete records which referenced by the deleted task.
    /// </summary>
    /// <param name = "_wbsType">WBS type.</param>
    /// <param name = "_deletedTask">The deleted task <c>ProjPlanVersion</c> buffer.</param>
    private static void deleteRecordsReferencedByDeletedTask(ProjWBSType _wbsType, ProjPlanVersion _deletedTask)
    {
        ttsbegin;
        ProjWBSDataEntityHelper::removeSuccessorByTask(_deletedTask.HierarchyId, _deletedTask.HierarchyTaskId);
        ProjWBSDataEntityHelper::removePredecessorByTask(_deletedTask.HierarchyId, _deletedTask.HierarchyTaskId);

        ProjHierarchySorting hierarchySorting;
        delete_from hierarchySorting
            where hierarchySorting.Type == ProjHierarchySortingType::ProjWBS
                && hierarchySorting.RefId == _deletedTask.HierarchyId
                && hierarchySorting.RefNodeId == _deletedTask.HierarchyTaskId;

        if (_wbsType == ProjWBSType::ProjectQuotation)
        {
            PSAActivitySetup activitySetup;
            smmActivities   smmActivity;
            HierarchyTreeTable hierarchyTreeTable;

            delete_from activitySetup
                exists join smmActivity
                    where smmActivity.ActivityNumber == activitySetup.ActivityNumber
                exists join hierarchyTreeTable
                    where hierarchyTreeTable.RefRecId == smmActivity.RecId
                        && hierarchyTreeTable.RecId == _deletedTask.HierarchyTreeTableRefRecId;

            delete_from smmActivity
                exists join hierarchyTreeTable
                    where hierarchyTreeTable.RefRecId == smmActivity.RecId
                        && hierarchyTreeTable.RecId == _deletedTask.HierarchyTreeTableRefRecId;

            delete_from hierarchyTreeTable
                where hierarchyTreeTable.RecId == _deletedTask.HierarchyTreeTableRefRecId;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDeleteTaskUpdateParentTasks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post delete task to update all parent tasks
    /// </summary>
    /// <param name = "_hiearchyId">Id of the current hierarchy.</param>
    /// <param name = "_calendarId">Id of the calendar for this hierarchy.</param>
    /// <param name = "_wbsType">The type of the current wbs.</param>
    /// <param name = "_calendarStandardWorkDayHours">Calendar standard work day Hours.</param>
    /// <param name = "_deletedTask">Deleted <c>ProjPlanVersion</c> record.</param>
    /// <param name = "_parentTask">Parent <c>ProjPlanVersion</c> record.</param>
    private static void postDeleteTaskUpdateParentTasks(
        HierarchyIdBase _hierarchyId,
        CalendarId _calendarId,
        ProjWBSType _wbsType,
        Hours _calendarStandardWorkDayHours,
        ProjPlanVersion _deletedTask,
        ProjPlanVersion _parentTask)
    {
        // If the parent is now a leaf task, make it so
        if (ProjPlanVersion::getMaxSiblingNumber(_hierarchyId, _parentTask.HierarchyTaskId) == 0)
        {
            ttsbegin;
            if (_parentTask.isRoot())
            {
                // Deleting last child of root should make it have 0 effort
                _parentTask.TaskFinishDate = _parentTask.TaskStartDate;
                ProjPlanVersion::setEndNodeStateV2(_calendarId, _wbsType, _parentTask, FalseTrue::True, _calendarStandardWorkDayHours, 0.0);
            }
            else
            {
                ProjPlanVersion::setEndNodeStateV2(_calendarId, _wbsType, _parentTask, FalseTrue::True, _calendarStandardWorkDayHours, _deletedTask.TaskEffort);
            }
            ttscommit;
        }
        else
        {
            // Update younger sibling path ID and sibling number
            ProjWBSDataEntityHelper::updateYoungerSiblingPathIdAndSiblingNumberForDeletedTask(_hierarchyId, _deletedTask);

            // Update parent dates
            ProjPlanVersion::updateFromChildren(_calendarId, _parentTask);

            // Update parent scheduling status
            ProjActivityCapacity::updateSummaryTaskSchedulingStatus(_parentTask);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateYoungerSiblingPathIdAndSiblingNumberForDeletedTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update younger sibling path and sibling number.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "taskToDelete"><c>ProjPlanVersion</c> table buffer of the task to be deleted.</param>
    private static void updateYoungerSiblingPathIdAndSiblingNumberForDeletedTask(
        HierarchyIdBase _hierarchyId,
        ProjPlanVersion taskToDelete)
    {
        const str pathIdDelimiter = '.';
        
        ttsbegin;

        ProjPlanVersion youngerSiblingTasks;

        // Delete the sorting table record of the younger sibling so that it will be regenerated properly upon user re-opening WBS form.
        ProjHierarchySorting hierarchySorting;
        delete_from hierarchySorting
            where hierarchySorting.Type == ProjHierarchySortingType::ProjWBS
                && hierarchySorting.RefId == taskToDelete.HierarchyId
            exists join youngerSiblingTasks
            where youngerSiblingTasks.HierarchyId == hierarchySorting.RefId
                && youngerSiblingTasks.ParentHierarchyTaskId == taskToDelete.ParentHierarchyTaskId
                && youngerSiblingTasks.TaskSiblingNumber > taskToDelete.TaskSiblingNumber
                && youngerSiblingTasks.HierarchyTaskId == hierarchySorting.RefNodeId;

        while select forupdate youngerSiblingTasks
            where youngerSiblingTasks.HierarchyId == taskToDelete.HierarchyId
                && youngerSiblingTasks.ParentHierarchyTaskId == taskToDelete.ParentHierarchyTaskId
                && youngerSiblingTasks.TaskSiblingNumber > taskToDelete.TaskSiblingNumber
        {
            // Update the childs of the younger sibling path ID since the younger sibling path ID will move up by one.
            ProjPlanVersion childsOfNextSiblingTask;
            while select forupdate childsOfNextSiblingTask
                where childsOfNextSiblingTask.HierarchyId == taskToDelete.HierarchyId
                    && childsOfNextSiblingTask.PathId like (youngerSiblingTasks.PathId + pathIdDelimiter + '*')
            {
                childsOfNextSiblingTask.PathId = ProjWBSDataEntityHelper::updatedSiblingChildWBSIdValue(
                    ProjWBSDataEntityHelper::getPreviousWBSIdValue(youngerSiblingTasks.PathId), childsOfNextSiblingTask.PathId);
                childsOfNextSiblingTask.update();

                // Delete the sorting table record of the childs of younger sibling and it will be regenerated properly upon user re-opening WBS form.
                delete_from hierarchySorting
                    where hierarchySorting.Type == ProjHierarchySortingType::ProjWBS
                        && hierarchySorting.RefId == childsOfNextSiblingTask.HierarchyId
                        && hierarchySorting.RefNodeId == childsOfNextSiblingTask.HierarchyTaskId;
            }

            // Update the younger sibling path ID and sibling number since the youger sibling path ID will move up by one.
            youngerSiblingTasks.PathId = ProjWBSDataEntityHelper::getPreviousWBSIdValue(youngerSiblingTasks.PathId);
            youngerSiblingTasks.TaskSiblingNumber = (youngerSiblingTasks.TaskSiblingNumber - 1);
            youngerSiblingTasks.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentTaskByWBSId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get parent task <c>ProjPlanVersion</c> object by WBS ID.
    /// </summary>
    /// <param name = "_wbsId">WBS ID.</param>
    /// <param name = "_hierarchyId">Hierarchy ID.</param>
    /// <param name = "_forUpdate">A boolean flag to set whether the return object should allow update; optional.</param>
    /// <returns><c>ProjPlanVersion</c> object.</returns>
    public static ProjPlanVersion getParentTaskByWBSId(ProjHierarchyPathId _wbsId, HierarchyIdBase _hierarchyId, boolean _forUpdate = false)
    {
        ProjPlanVersion parentTask;
        const str pathIdDelimiter = '.';

        List pathIdSegment = strSplit(_wbsId, pathIdDelimiter);
        int hierarchyLevel = pathIdSegment.elements();
        
        if (hierarchyLevel > 0)
        {
            // Get the parent WBS task by parent WBS ID.
            ProjHierarchyPathId parentWBSId;
            ListEnumerator pathIdSegmentEnum = pathIdSegment.getEnumerator();
            for (int i = 1; i <= hierarchyLevel - 1; i++)
            {
                pathIdSegmentEnum.moveNext();
                if (parentWBSId)
                {
                    parentWBSId = strFmt('%1%2%3', parentWBSId, pathIdDelimiter, pathIdSegmentEnum.current());
                }
                else
                {
                    parentWBSId = pathIdSegmentEnum.current();
                }
            }

            // Get the parent hierarchy task ID by parent WBS ID.
            parentTask = ProjPlanVersion::findByHierarchyAndPathId(_hierarchyId, parentWBSId, _forUpdate);
        }
        else
        {
            parentTask = ProjPlanVersion::getRootTask(_hierarchyId, _forUpdate);
        }
        
        return parentTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPreviousWBSIdValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the previous WBS ID.
    /// </summary>
    /// <param name = "_wbsId">WBS ID.</param>
    /// <returns>The the previous path ID value.</returns>
    private static ProjHierarchyPathId getPreviousWBSIdValue(ProjHierarchyPathId _wbsId)
    {
        ProjHierarchyPathId previousWBSId;
        const str pathIdDelimiter = '.';

        List pathIdSegment = strSplit(_wbsId, pathIdDelimiter);
        int hierarchyLevel = pathIdSegment.elements();
        
        if (hierarchyLevel > 0)
        {
            ListEnumerator pathIdSegmentEnum = pathIdSegment.getEnumerator();
            for (int i = 1; i <= hierarchyLevel; i++)
            {
                pathIdSegmentEnum.moveNext();
                str currentSegmentValue = pathIdSegmentEnum.current();
                if (i == hierarchyLevel)
                {
                    currentSegmentValue = int2Str(str2Int(currentSegmentValue) - 1);
                }

                if (previousWBSId)
                {
                    previousWBSId = strFmt('%1%2%3', previousWBSId, pathIdDelimiter, currentSegmentValue);
                }
                else
                {
                    previousWBSId = currentSegmentValue;
                }
            }
        }
        
        return previousWBSId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatedSiblingChildWBSIdValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update sibling child WBS ID value after grand parenets has been deleted.
    /// </summary>
    /// <param name = "_newPrefixWBSId">New prefix WBS ID.</param>
    /// <param name = "_grandChildWBSId">Original grand child WBS ID.</param>
    /// <returns>The updated sibling child WBS ID.</returns>
    private static ProjHierarchyPathId updatedSiblingChildWBSIdValue(ProjHierarchyPathId _newPrefixWBSId, ProjHierarchyPathId _nextSiblingChildWBSId)
    {
        ProjHierarchyPathId updatedSiblingChildWBSId;

        const str pathIdDelimiter = '.';
        List newPrefixSegment = strSplit(_newPrefixWBSId, pathIdDelimiter);
        int newPrefixHierarchyLevel = newPrefixSegment.elements();
        str newPrefixLastSegmentValue;
        if (newPrefixHierarchyLevel > 0)
        {
            ListEnumerator newPrefixSegmentEnum = newPrefixSegment.getEnumerator();
            while (newPrefixSegmentEnum.moveNext())
            {
                newPrefixLastSegmentValue = newPrefixSegmentEnum.current();
            }
        }

        if (newPrefixHierarchyLevel && newPrefixLastSegmentValue)
        {
            List nextSiblingChildSegment = strSplit(_nextSiblingChildWBSId, pathIdDelimiter);
            int nextSiblingChildHierarchyLevel = nextSiblingChildSegment.elements();
            if (nextSiblingChildHierarchyLevel > newPrefixHierarchyLevel)
            {
                ListEnumerator nextSiblingChildSegmentEnum = nextSiblingChildSegment.getEnumerator();
                for (int i = 1; i <= nextSiblingChildHierarchyLevel; i++)
                {
                    nextSiblingChildSegmentEnum.moveNext();
                    str currentSegmentValue = nextSiblingChildSegmentEnum.current();
                    if (i == newPrefixHierarchyLevel)
                    {
                        currentSegmentValue = newPrefixLastSegmentValue;
                    }

                    if (updatedSiblingChildWBSId)
                    {
                        updatedSiblingChildWBSId = strFmt('%1%2%3', updatedSiblingChildWBSId, pathIdDelimiter, currentSegmentValue);
                    }
                    else
                    {
                        updatedSiblingChildWBSId = currentSegmentValue;
                    }
                }
            }
        }

        return updatedSiblingChildWBSId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>