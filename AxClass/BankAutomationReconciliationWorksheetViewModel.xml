<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BankAutomationReconciliationWorksheetViewModel</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>BankAutomationReconciliationWorksheetViewModel</c> is the view model for bank automation reconciliation worksheet.
/// </summary>
internal final class BankAutomationReconciliationWorksheetViewModel
{
    // Form view
    private BankAutomationReconciliationWorksheetFormView worksheetFormView;

    // Data sources
    private FormDataSource dsOpenStatement;
    private FormDataSource dsMatchedStatement;
    private FormDataSource dsOpenDocument;
    private FormDataSource dsMatchedDocument;
    private FormDataSource dsReconciliationHeader;

    // Records
    private BankReconciliationHeader reconciliation;

    private BankReconciliationDataManager dataManager;

    // Marked data
    private AmountCur markedMatchingGroupsAmount;
    private Map markedMap = new Map(Types::Int64, Types::Class);

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getImpactedEntriesOfUnmatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets impacted entries by the unmatching.
    /// </summary>
    /// <param name="_entryMatched">
    /// The entry to unmatch.
    /// </param>
    /// <returns>
    /// A container containing all the impacted entries.
    /// </returns>
    private container getImpactedEntriesOfUnmatch(Common _entryMatched)
    {
        BankReconciliationStatementOpenTmp statementFocused;
        BankReconciliationDocumentOpenTmp documentFocused;
        BankReconciliationMatchingItem matchingItem;
        if (_entryMatched.TableId == tableNum(BankReconciliationStatementOpenTmp))
        {
            statementFocused = _entryMatched;
            matchingItem = BankReconciliationMatchingItem::findValidByStatementLineRecId(statementFocused.BankStmtISOReportEntry);
        }
        else
        {
            documentFocused = _entryMatched;
            matchingItem = BankReconciliationMatchingItem::findValidByDocumentRecId(documentFocused.BankDocumentTableView);
        }
        List allMatchingItemsList = BankReconciliationMatching::getAllMatchingItemsList(matchingItem.BankReconciliationMatching);

        ListEnumerator enumerator = allMatchingItemsList.getEnumerator();

        BankReconciliationStatementOpenTmp statementMatched;
        statementMatched.linkPhysicalTableInstance(dsMatchedStatement.cursor());

        BankReconciliationDocumentOpenTmp documentmatched;
        documentmatched.linkPhysicalTableInstance(dsMatchedDocument.cursor());

        BankReconciliationMatchingEntryType entryType;
        RecId entryRecId;
        List impactedStatementIdList = new List(Types::Int64);
        List impactedDocumentIdList = new List(Types::Int64);
        while (enumerator.moveNext())
        {
            [entryType, entryRecId] = enumerator.current();

            if (entryType == BankReconciliationMatchingEntryType::BankStatement)
            {
                select firstonly RecId from statementMatched
                    where statementMatched.BankStmtISOReportEntry == entryRecId;

                impactedStatementIdList.addEnd(statementMatched.RecId);
            }
            else if (entryType == BankReconciliationMatchingEntryType::BankDocument)
            {
                select firstonly RecId from documentmatched
                    where documentmatched.BankDocumentTableView == entryRecId;

                impactedDocumentIdList.addEnd(documentmatched.RecId);
            }
        }

        return [impactedStatementIdList.pack(), impactedDocumentIdList.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes data sources.
    /// </summary>
    private void initDataSource()
    {
        dsOpenStatement = worksheetFormView.parmDSOpenStatement();
        dsOpenDocument = worksheetFormView.parmDSOpenDocument();
        dsMatchedStatement = worksheetFormView.parmDSMatchedStatement();
        dsMatchedDocument = worksheetFormView.parmDSMatchedDocument();
        dsReconciliationHeader = worksheetFormView.parmDSReconciliationHeader();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the bank statement view model.
    /// </summary>
    private void initialize()
    {
        this.initDataSource();
        this.initReconciliationBuffer();
        this.loadData();

        dataManager = BankReconciliationDataManager::construct(
            reconciliation,
            dsOpenStatement.cursor(),
            dsOpenDocument.cursor());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReconciliationBuffer</Name>
				<Source><![CDATA[
    private void initReconciliationBuffer()
    {
        reconciliation = worksheetFormView.parmWorksheetFormRun().args().record();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loads the reconciliation data.
    /// </summary>
    private void loadData()
    {
        BankReconciliationDataInitializer dataInit;

        if (reconciliation)
        {
            dataInit = this.createBankReconciliationDataInitializer(reconciliation);

            dataInit.loadData();
            this.setDocumentTmpData(dataInit.getDocumentData());
            this.setStatementTmpData(dataInit.getStatementData());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBankReconciliationDataInitializer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>BankReconciliationDataInitializer</c> instance.
    /// </summary>
    /// <param name = "_reconciliation">The <c>BankReconciliationHeader</c> buffer.</param>
    /// <returns>A new instance of the <c>BankReconciliationDataInitializer</c> class.</returns>
    private BankReconciliationDataInitializer createBankReconciliationDataInitializer(BankReconciliationHeader _reconciliation)
    {
        return BankReconciliationDataInitializer::construct(reconciliation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBankReconciliationHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the reconciliation header.
    /// </summary>
    /// <param name = "_reconciliation">The reconciliation header.</param>
    /// <returns>The reconciliation header.</returns>
    internal BankReconciliationHeader parmBankReconciliationHeader(BankReconciliationHeader _reconciliation = reconciliation)
    {
        reconciliation = _reconciliation;

        return reconciliation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorksheetFormView</Name>
				<Source><![CDATA[
    private BankAutomationReconciliationWorksheetFormView parmWorksheetFormView(BankAutomationReconciliationWorksheetFormView _worksheetFormView = worksheetFormView)
    {
        worksheetFormView = _worksheetFormView;

        return worksheetFormView;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performMatchingProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs manual matching.
    /// </summary>
    internal void performMatchingProcess()
    {
        BankReconciliationMatchingMatchProcessor matchingMatchProcessor = BankReconciliationMatchingMatchProcessor::construct(reconciliation);

        ttsBegin;
        BankReconciliationStatementOpenTmp statementTmpUpdate;
        statementTmpUpdate.linkPhysicalTableInstance(dsOpenStatement.cursor());
        BankReconciliationStatementOpenTmp statementTmpLocal = dsOpenStatement.getFirst(1);
        BankReconciliationMatchingEntry matchingEntry;
        List impactedStatementList = new List(Types::Int64);
        if (statementTmpLocal)
        {
            while (statementTmpLocal)
            {
                matchingEntry = BankReconciliationMatchingEntry::construct(
                    BankReconciliationMatchingEntryType::BankStatement,
                    statementTmpLocal.BankStmtISOReportEntry);
                matchingMatchProcessor.addEntry(matchingEntry);

                impactedStatementList.addEnd(statementTmpLocal.RecId);
                statementTmpLocal = dsOpenStatement.getNext();
            }
        }

        BankReconciliationDocumentOpenTmp documentTmpUpdate;
        documentTmpUpdate.linkPhysicalTableInstance(dsOpenDocument.cursor());

        BankReconciliationDocumentOpenTmp documentTmpLocal = dsOpenDocument.getFirst(1);
        List impactedBankDocumentList = new List(Types::Int64);
        if (documentTmpLocal)
        {
            while (documentTmpLocal)
            {
                matchingEntry = BankReconciliationMatchingEntry::construct(
                    BankReconciliationMatchingEntryType::BankDocument,
                    documentTmpLocal.BankDocumentTableView);
                matchingMatchProcessor.addEntry(matchingEntry);

                impactedBankDocumentList.addEnd(documentTmpLocal.RecId);
                documentTmpLocal = dsOpenDocument.getNext();
            }
        }

        boolean isValidMatchOperation = true;
        // it is invalid operation if single or none statement is selected when no document is selected
        // when no statement is selected, only the matching of two document lines with opposite value is supported
        if ((impactedStatementList.elements() == 0 || impactedStatementList.elements() == 1)
            && impactedBankDocumentList.elements() == 0)
        {
            isValidMatchOperation = checkFailed("@Bank:BankReconcileNoDataForMatchingError");
        }
        else if (impactedStatementList.elements() == 0 && impactedBankDocumentList.elements() != 2)
        {
            isValidMatchOperation = checkFailed("@Bank:BankReconcileTransactionLineNumberError");
        }

        boolean isMatchingSuccess;
        if (isValidMatchOperation)
        {
            isMatchingSuccess = matchingMatchProcessor.processMatch();
        }

        if (isMatchingSuccess)
        {
            dataManager.refreshMatchStatus(impactedStatementList, impactedBankDocumentList);
        }
        ttsCommit;

        if (isMatchingSuccess)
        {
            this.reQuery();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUnmatchingProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs unmatching process.
    /// </summary>
    internal void performUnmatchingProcess()
    {
        container impactedStatementOpenCon;
        container impactedDocumentOpenCon;
        List impactedBankDocumentList;
        List impactedStatementList;
        Common entryMatched;
        BankReconciliationMatchingEntryType entryMatchedType;
        FieldId entryMatchedReferenceField;
        boolean hasValidatedPayment = false;

        BankReconciliationStatementOpenTmp matchedStatement;
        matchedStatement.linkPhysicalTableInstance(dsMatchedStatement.cursor());

        BankReconciliationDocumentOpenTmp matchedDocument;
        matchedDocument.linkPhysicalTableInstance(dsMatchedDocument.cursor());

        MapEnumerator mapEnumerator = new MapEnumerator(markedMap);
        List unmatchIdList = new List(Types::Int64);

        ttsBegin;
        while (mapEnumerator.moveNext())
        {
            int64 matchId = mapEnumerator.currentKey();

            select firstonly matchedStatement
                where matchedStatement.IsMatched == NoYes::Yes
                    && matchedStatement.MatchingId == matchId;

            if (matchedStatement)
            {
                entryMatched = matchedStatement;
                entryMatchedType = BankReconciliationMatchingEntryType::BankStatement;
                entryMatchedReferenceField = fieldNum(BankReconciliationStatementOpenTmp, BankStmtISOReportEntry);
            }
            else
            {
                select firstonly matchedDocument
                    where matchedDocument.IsMatched == NoYes::Yes
                        && matchedDocument.MatchingId == matchId;

                entryMatched = matchedDocument;
                entryMatchedType = BankReconciliationMatchingEntryType::BankDocument;
                entryMatchedReferenceField = fieldNum(BankReconciliationDocumentOpenTmp, BankDocumentTableView);
            }

            [impactedStatementOpenCon, impactedDocumentOpenCon] = this.getImpactedEntriesOfUnmatch(entryMatched);

            impactedStatementList = List::create(impactedStatementOpenCon);

            if (!hasValidatedPayment && dataManager.hasPaymentMatched(impactedStatementList))
            {
                hasValidatedPayment = true;
                if (Box::yesNo("@CashManagement:BankStatementGeneratePaymentWorksheetMatchLinkConfirm", DialogButton::No) == DialogButton::No)
                {
                    ttsabort;
                    return;
                }
            }

            BankReconciliationMatchingMatchProcessor::processUnmatch(
                reconciliation.RecId,
                entryMatched.(entryMatchedReferenceField),
                entryMatchedType);

            impactedBankDocumentList = List::create(impactedDocumentOpenCon);

            dataManager.refreshMatchStatus(impactedStatementList, impactedBankDocumentList);

            unmatchIdList.addEnd(matchId);
        }

        if (unmatchIdList.elements() > 0)
        {
            this.unmarkByMatchingIdList(unmatchIdList);
        }
        ttsCommit;

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performUnmatchingAllProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs unmatching all process.
    /// </summary>
    internal void performUnmatchingAllProcess()
    {
        BankStmtISOAccountStatement statement;
        BankStmtISOReportEntry statementLine;
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;
        boolean paymentUnmatchConfirmed = false;

        // Check if there is any statement line that has linked generated payment journal, if yes, pops out dialog to let user confirm whether he/she wants to unmatch it.
        select firstonly RecId from statementLine
            where statementLine.BankPaymentType != BankPaymentType::None
            join BankReconciliationMatching from matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            join RecId from matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId;
        if (statementLine.RecId)
        {
            if (Box::yesNo("@CashManagement:BankStatementGeneratePaymentWorksheetMatchLinkConfirm", DialogButton::No) == DialogButton::No)
            {
                return;
            }
            paymentUnmatchConfirmed = true;
        }

        // Loop statement lines and add it to statementList for later unmatch process.
        List statementList = new List(Types::Record);
        while select statement
            exists join statementLine
                where statementLine.BankStmtISOAccountStatement == statement.RecId
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId
        {
            statementList.addEnd(statement);
        }

        ttsBegin;

        // Unmatch all statement lines that is linked to generated payment journal.
        if (paymentUnmatchConfirmed)
        {
            this.deletePaymentInformationAndUpateStatementLinePaymentType(reconciliation.RecId);
        }

        BankDocumentTable bankDocumentTable;
        bankDocumentTable.skipDatabaseLog(true);
        bankDocumentTable.skipDataMethods(true);
        bankDocumentTable.skipEvents(true);

        // Reset correction amount to 0 when unmatch
        update_recordset bankDocumentTable
            setting CorrectionBankCurrencyAmount = 0
            exists join matchingItem
                where matchingItem.BankDocumentTable == bankDocumentTable.RecId
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId;

        BankReconciliationStatementOpenTmp statementMatched;
        statementMatched.linkPhysicalTableInstance(dsMatchedStatement.cursor());
        statementMatched.skipDatabaseLog(true);
        statementMatched.skipDataMethods(true);
        statementMatched.skipEvents(true);

        // Reset statement and document status back to unmatched
        update_recordset statementMatched
            setting IsMatched = NoYes::No,
                MatchingId = 0,
                BankReconciliationMatchRule = 0,
                BankReconciliationMatchRuleId = ''
            where statementMatched.IsNewBankDocument == NoYes::No
            exists join matchingItem
                where matchingItem.BankStmtISOReportEntry == statementMatched.BankStmtISOReportEntry
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId;

        BankReconciliationDocumentOpenTmp documentMatched;
        documentMatched.linkPhysicalTableInstance(dsMatchedDocument.cursor());
        documentMatched.skipDatabaseLog(true);
        documentMatched.skipDataMethods(true);
        documentMatched.skipEvents(true);

        if (BankRedesignGenerateVoucherFlight::instance().isEnabled())
        {
            update_recordset documentMatched
                setting IsMatched = NoYes::No,
                    CorrectionBankCurrencyAmount = 0,
                    MatchingId = 0,
                    BankReconciliationMatchRule = 0,
                    BankReconciliationMatchRuleId = ''
                exists join matchingItem
                    where matchingItem.BankDocumentTable == documentMatched.BankDocumentTableView
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId
                        && matching.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement;
        }
        else
        {
            update_recordset documentMatched
                setting IsMatched = NoYes::No,
                    CorrectionBankCurrencyAmount = 0,
                    MatchingId = 0,
                    BankReconciliationMatchRule = 0,
                    BankReconciliationMatchRuleId = ''
                exists join matchingItem
                    where matchingItem.BankDocumentTable == documentMatched.BankDocumentTableView
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;
        }

        // Update clear date if feature is enabled
        if (FeatureStateProvider::isFeatureEnabled(BankTransClearedDateAdvancedBankReconciliationFeature::instance()))
        {
            BankAccountTrans bankAccountTrans;
            bankAccountTrans.skipDatabaseLog(true);
            bankAccountTrans.skipDataMethods(true);
            bankAccountTrans.skipEvents(true);

            update_recordset bankAccountTrans
                setting ClearedDate = dateNull()
                exists join bankDocumentTable
                    where bankDocumentTable.SourceRelationType == bankAccountTrans.SourceTableId
                        && bankDocumentTable.SourceRecId == bankAccountTrans.SourceRecId
                exists join matchingItem
                    where matchingItem.BankDocumentTable == bankDocumentTable.RecId
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;

            update_recordset bankAccountTrans
                setting ClearedDate = dateNull()
                exists join bankDocumentTable
                    where bankDocumentTable.SourceRelationType == bankAccountTrans.TableId
                        && bankDocumentTable.SourceRecId == bankAccountTrans.RecId
                exists join matchingItem
                    where matchingItem.BankDocumentTable == bankDocumentTable.RecId
                exists join matching
                    where matching.RecId == matchingItem.BankReconciliationMatching
                        && matching.BankReconciliationHeader == reconciliation.RecId;
        }

        // Delete all matching and matching item
        matchingItem.skipDatabaseLog(true);
        matchingItem.skipDataMethods(true);
        matchingItem.skipEvents(true);

        delete_from matchingItem
            exists join matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == reconciliation.RecId
                    && matching.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement;

        matching.skipDatabaseLog(true);
        matching.skipDataMethods(true);
        matching.skipEvents(true);

        delete_from matching
            where matching.BankReconciliationHeader == reconciliation.RecId
                && matching.BankReconciliationMatchingType != BankReconciliationMatchingType::SingleStatement;
        ttsCommit;

        // Refresh statement header status
        ListEnumerator enumerator = statementList.getEnumerator();
        while (enumerator.moveNext())
        {
            statement = enumerator.current();
            statement.refreshMatchingStatus();
        }

        this.reQuery();

        markedMatchingGroupsAmount = 0;
        markedMap = new Map(Types::Int64, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reLoadData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reloads the reconciliation data and refresh.
    /// </summary>
    internal void reLoadData()
    {
        this.loadData();

        dataManager = BankReconciliationDataManager::construct(
            reconciliation,
            dsOpenStatement.cursor(),
            dsOpenDocument.cursor());

        this.reQuery();
    }

]]></Source>
			</Method>
			<Method>
				<Name>reQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Re-queries all the data sources.
    /// </summary>
    private void reQuery()
    {
        dsOpenDocument.research(true);
        dsOpenStatement.research(true);
        dsMatchedDocument.research(true);
        dsMatchedStatement.research(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentTmpData</Name>
				<Source><![CDATA[
    private void setDocumentTmpData(BankReconciliationDocumentOpenTmp _documentTmp)
    {
        dsOpenDocument.cursor().linkPhysicalTableInstance(_documentTmp);
        dsMatchedDocument.cursor().linkPhysicalTableInstance(_documentTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatementTmpData</Name>
				<Source><![CDATA[
    private void setStatementTmpData(BankReconciliationStatementOpenTmp _statementTmp)
    {
        dsOpenStatement.cursor().linkPhysicalTableInstance(_statementTmp);
        dsMatchedStatement.cursor().linkPhysicalTableInstance(_statementTmp);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>BankAutomationReconciliationWorksheetViewModel</c> class.
    /// </summary>
    /// <returns>The <c>BankAutomationReconciliationWorksheetViewModel</c> instance.</returns>
    private static BankAutomationReconciliationWorksheetViewModel construct()
    {
        return new BankAutomationReconciliationWorksheetViewModel();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromWorksheetView</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>BankAutomationReconciliationWorksheetViewModel</c> class.
    /// </summary>
    /// <param name="_worksheetFormView">The instance of <c>BankAutomationReconciliationWorksheetFormView</c> class.</param>
    /// <returns>The instance of <c>BankAutomationReconciliationWorksheetViewModel</c> class.</returns>
    internal static BankAutomationReconciliationWorksheetViewModel newFromWorksheetView(BankAutomationReconciliationWorksheetFormView _worksheetFormView)
    {
        BankAutomationReconciliationWorksheetViewModel  worksheetViewModel;

        worksheetViewModel = BankAutomationReconciliationWorksheetViewModel::construct();
        worksheetViewModel.parmWorksheetFormView(_worksheetFormView);

        worksheetViewModel.initialize();

        return worksheetViewModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedOrCurrentOpenStatement</Name>
				<Source><![CDATA[
    private BankReconciliationStatementOpenTmp getMarkedOrCurrentOpenStatement()
    {
        return dsOpenStatement.anyMarked() ? dsOpenStatement.getFirst(1) : dsOpenStatement.cursor();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectOpenStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the selected open statement line.
    /// </summary>
    /// <returns>The selected open statement line.</returns>
    internal BankStmtISOReportEntry getSelectOpenStatement()
    {
        BankReconciliationStatementOpenTmp statementSelect = this.getMarkedOrCurrentOpenStatement();
        return BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectOpenStatementList</Name>
				<Source><![CDATA[
    internal List getSelectOpenStatementList()
    {
        List statementLines = new List(Types::Int64);
        boolean isMarked = dsOpenStatement.anyMarked();
        BankReconciliationStatementOpenTmp statementOpenTmp = this.getMarkedOrCurrentOpenStatement();
        statementLines.addEnd(statementOpenTmp.BankStmtISOReportEntry);

        if (isMarked)
        {
            statementOpenTmp = dsOpenStatement.getNext();
            while (statementOpenTmp)
            {
                statementLines.addEnd(statementOpenTmp.BankStmtISOReportEntry);
                statementOpenTmp = dsOpenStatement.getNext();
            }
        }

        return statementLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOpenStatementAllSelectAllowGenerate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the selected open statement line allowed generate payment or not.
    /// </summary>
    /// <returns>true if allowed generate payment, otherwise false.</returns>
    internal boolean isOpenStatementAllSelectAllowGenerate()
    {
        BankReconciliationStatementOpenTmp statementSelect = this.getMarkedOrCurrentOpenStatement();
        BankStmtISOReportEntry statementLine = BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry);
        boolean res = statementLine.allowGeneratePaymentJournal();

        if (res && dsOpenStatement.anyMarked())
        {
            while (statementSelect)
            {
                statementLine = BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry);
                if (!statementLine.allowGeneratePaymentJournal())
                {
                    return false;
                }

                statementSelect = dsOpenStatement.getNext();
            }
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOpenStatementAllSelectAllowGenerateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the selected open statement line allowed generate voucher or not.
    /// </summary>
    /// <returns>true if all allowed, otherwise false.</returns>
    internal boolean isOpenStatementAllSelectAllowGenerateVoucher()
    {
        BankReconciliationStatementOpenTmp statementSelect = this.getMarkedOrCurrentOpenStatement();
        BankStmtISOReportEntry statementLine = BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry);
        boolean res = statementLine.allowPostByLineTable();

        if (res && dsOpenStatement.anyMarked())
        {
            while (statementSelect)
            {
                statementLine = BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry);
                if (!statementLine.allowPostByLineTable())
                {
                    return false;
                }

                statementSelect = dsOpenStatement.getNext();
            }
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOpenStatementSelectGenerateJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the selected open statement line allowed generate payment or not.
    /// </summary>
    /// <returns>true if allowed generate payment, otherwise false.</returns>
    internal boolean isOpenStatementSelectGenerateJournal()
    {
        BankReconciliationStatementOpenTmp statementSelect = this.getMarkedOrCurrentOpenStatement();
        BankStmtISOReportEntry statementLine = BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry);
        return statementLine.isPayment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrentStatementLineGenerateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current statement line generate voucher or not.
    /// </summary>
    /// <returns>true if generate voucher, otherwise false.</returns>
    internal boolean isCurrentStatementLineGenerateVoucher()
    {
        BankReconciliationStatementOpenTmp currentStatementLine = dsMatchedStatement.cursor();
        return currentStatementLine ? currentStatementLine.Posted : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllMarkedStatementGenerateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the marked statement lines are all generate voucher or not.
    /// </summary>
    /// <returns>true if all generate voucher, otherwise false.</returns>
    internal boolean isAllMarkedStatementGenerateVoucher()
    {
        if (markedMap.elements() == 0)
        {
            return false;
        }

        MapEnumerator mapEnumerator = new MapEnumerator(markedMap);
        while (mapEnumerator.moveNext())
        {
            BankReconciliationMarkedObject obj = mapEnumerator.currentValue();

            if (!obj.isGenerateVoucher())
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllMarkedStatementNotGenerateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the marked statement lines are all not generate voucher or not.
    /// </summary>
    /// <returns>true if all not generate voucher, otherwise false.</returns>
    internal boolean isAllMarkedStatementNotGenerateVoucher()
    {
        if (markedMap.elements() == 0)
        {
            return false;
        }

        MapEnumerator mapEnumerator = new MapEnumerator(markedMap);
        while (mapEnumerator.moveNext())
        {
            BankReconciliationMarkedObject obj = mapEnumerator.currentValue();

            if (obj.isGenerateVoucher())
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedMatchedStatement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the marked matched statement line.
    /// </summary>
    /// <returns>The marked matched statement line.</returns>
    internal BankStmtISOReportEntry getMarkedMatchedStatement()
    {
        BankReconciliationStatementOpenTmp matchedStatement;
        matchedStatement.linkPhysicalTableInstance(dsMatchedStatement.cursor());

        MapEnumerator mapEnumerator = new MapEnumerator(markedMap);
        while (mapEnumerator.moveNext())
        {
            int64 matchId = mapEnumerator.currentKey();
            select firstonly BankStmtISOReportEntry from matchedStatement
                where matchedStatement.IsMatched == NoYes::Yes
                    && matchedStatement.MatchingId == matchId;
        }

        return BankStmtISOReportEntry::find(matchedStatement.BankStmtISOReportEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedMatchedStatementLineList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the marked matched statement line list.
    /// </summary>
    /// <returns>The marked matched statement line list.</returns>
    internal List getMarkedMatchedStatementLineList()
    {
        BankReconciliationStatementOpenTmp matchedStatement;
        matchedStatement.linkPhysicalTableInstance(dsMatchedStatement.cursor());

        List statementLines = new List(Types::Int64);
        MapEnumerator mapEnumerator = new MapEnumerator(markedMap);
        while (mapEnumerator.moveNext())
        {
            int64 matchId = mapEnumerator.currentKey();
            while select BankStmtISOReportEntry from matchedStatement
                where matchedStatement.IsMatched == NoYes::Yes
                    && matchedStatement.MatchingId == matchId
            {
                statementLines.addEnd(matchedStatement.BankStmtISOReportEntry);
            }
        }

        return statementLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrentMatchedStatementLineGeneratePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current matched statement line is generated payment or not.
    /// </summary>
    /// <returns>true if generated payment, otherwise false.</returns>
    internal boolean isCurrentMatchedStatementLineGeneratePayment()
    {
        BankStmtISOReportEntry currentStatementLine = this.getCurrentMatchedStatementLine();
        return currentStatementLine ? currentStatementLine.isPayment() : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deletePaymentInformationAndUpateStatementLinePaymentType</Name>
				<Source><![CDATA[
    private void deletePaymentInformationAndUpateStatementLinePaymentType(RecId _header)
    {
        // As X++ doesn't support inner join for delete_from, use workaround to delete payment information and update statement line payment type.
        // 1. Update BankStatementLinePaymentInformation's LedgerJournalTrans to 0
        // 2. Update BankStmtISOReportEntry's BankPaymentType to None
        // 3. Delete BankStatementLinePaymentInformation with LedgerJournalTrans = 0

        BankStatementLinePaymentInformation paymentInformationUpdate;
        paymentInformationUpdate.skipDatabaseLog(true);
        paymentInformationUpdate.skipDataMethods(true);
        paymentInformationUpdate.skipEvents(true);

        BankStmtISOReportEntry statementLine;
        BankReconciliationMatching matching;
        BankReconciliationMatchingItem matchingItem;
        update_recordset paymentInformationUpdate
            setting LedgerJournalTrans = 0
            join statementLine
                where statementLine.RecId == paymentInformationUpdate.BankStmtISOReportEntry
                    && statementLine.BankPaymentType != BankPaymentType::None
            join BankReconciliationMatching from matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            join RecId from matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == _header;

        statementLine.skipDatabaseLog(true);
        statementLine.skipDataMethods(true);
        statementLine.skipEvents(true);
        update_recordset statementLine
            setting BankPaymentType = BankPaymentType::None
            join statementLine
                where statementLine.BankPaymentType != BankPaymentType::None
            join BankReconciliationMatching from matchingItem
                where matchingItem.BankStmtISOReportEntry == statementLine.RecId
            join RecId from matching
                where matching.RecId == matchingItem.BankReconciliationMatching
                    && matching.BankReconciliationHeader == _header;

        BankStatementLinePaymentInformation paymentInformationDelete;
        paymentInformationDelete.skipDatabaseLog(true);
        paymentInformationDelete.skipDataMethods(true);
        paymentInformationDelete.skipEvents(true);
        delete_from paymentInformationDelete
            where paymentInformationDelete.LedgerJournalTrans == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStatementPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the cursor position to the first statement line with the specified matching id.
    /// </summary>
    /// <param name = "_matchingId">The matching id.</param>
    internal void setStatementPosition(int64 _matchingId)
    {
        BankReconciliationStatementOpenTmp matchedStatement;
        matchedStatement.linkPhysicalTableInstance(dsMatchedStatement.cursor());
        select firstonly matchedStatement
            where matchedStatement.IsMatched == NoYes::Yes
                && matchedStatement.MatchingId == _matchingId;
        if (matchedStatement.RecId)
        {
            dsMatchedStatement.positionToRecord(matchedStatement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentPosition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the cursor position to the first document line with the specified matching id.
    /// </summary>
    /// <param name = "_matchingId">The matching id.</param>
    internal void setDocumentPosition(int64 _matchingId)
    {
        BankReconciliationDocumentOpenTmp matchedDocument;
        matchedDocument.linkPhysicalTableInstance(dsMatchedDocument.cursor());
        select firstonly matchedDocument
            where matchedDocument.IsMatched == NoYes::Yes
                && matchedDocument.MatchingId == _matchingId;
        if (matchedDocument.RecId)
        {
            dsMatchedDocument.positionToRecord(matchedDocument);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mark</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks or unmarks the specified matching id.
    /// </summary>
    /// <param name = "_markTrans">Yes to mark, otherwise no.</param>
    /// <param name = "_matchingId">The matching id.</param>
    internal void mark(NoYes _markTrans, int64 _matchingId)
    {
        BankReconciliationMarkedObject obj;
        if (_markTrans == NoYes::Yes)
        {
            BankReconciliationStatementOpenTmp matchedStatement;
            matchedStatement.linkPhysicalTableInstance(dsMatchedStatement.cursor());
            select sum(BankCurrencyAmount) from matchedStatement
                where matchedStatement.IsMatched == NoYes::Yes
                    && matchedStatement.MatchingId == _matchingId;
            AmountCur amount = matchedStatement.BankCurrencyAmount;
            obj = BankReconciliationMarkedObject::construct(false, amount);

            select firstonly BankStmtISOReportEntry, Posted, RecId from matchedStatement
                where matchedStatement.IsMatched == NoYes::Yes
                    && matchedStatement.MatchingId == _matchingId;
            if (matchedStatement.RecId)
            {
                BankStmtISOReportEntry statementLine = BankStmtISOReportEntry::find(matchedStatement.BankStmtISOReportEntry);
                obj = BankReconciliationMarkedObject::construct(matchedStatement.Posted, amount);
            }
            markedMap.insert(_matchingId, obj);
            markedMatchingGroupsAmount += amount;
        }
        else
        {
            obj = markedMap.lookup(_matchingId);
            if (obj)
            {
                markedMatchingGroupsAmount -= obj.getAmount();
            }
            markedMap.remove(_matchingId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMarked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the mark status of the specified matching id.
    /// </summary>
    /// <param name = "_matchingId">The matching id.</param>
    /// <returns>Yes if it is marked, otherwise no.</returns>
    internal NoYes isMarked(int64 _matchingId)
    {
        return markedMap && markedMap.exists(_matchingId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkedMatchGroupsNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the marked matching groups number.
    /// </summary>
    /// <returns>The marked matching groups number.</returns>
    internal int getMarkedMatchGroupsNumber()
    {
        return markedMap.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMatchedGroupsAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the marked matching groups amount.
    /// </summary>
    /// <returns>The marked matching groups amount.</returns>
    internal AmountCur getMatchedGroupsAmount()
    {
        return markedMatchingGroupsAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkByMatchingIdList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmarks by the specified matching id list.
    /// </summary>
    /// <param name = "_matchingIdList">The matching id list.</param>
    internal void unmarkByMatchingIdList(List _matchingIdList)
    {
        ListEnumerator enumerator = _matchingIdList.getEnumerator();
        while (enumerator.moveNext())
        {
            int64 matchingId = enumerator.current();
            this.mark(NoYes::No, matchingId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentMatchedStatementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current matched statement line.
    /// </summary>
    /// <returns>The current matched statement line.</returns>
    internal BankStmtISOReportEntry getCurrentMatchedStatementLine()
    {
        BankReconciliationStatementOpenTmp statementSelect = dsMatchedStatement.cursor();
        return statementSelect ? BankStmtISOReportEntry::find(statementSelect.BankStmtISOReportEntry) : null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the bank reconciliation header.
    /// </summary>
    internal void refreshHeader()
    {
        TransDate oriCutOffDate = reconciliation.CutOffDate;
        reconciliation.reread();
        if (oriCutOffDate != reconciliation.CutOffDate)
        {
            // The cut-off date for the reconciliation worksheet has been updated to %1. This adjustment was necessary because the selected accounting date falls after the current cut-off date.
            Info(strFmt("@Bank:CutOffDateUpdated", reconciliation.CutOffDate));
            dsReconciliationHeader.research(true);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>