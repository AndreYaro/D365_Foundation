<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VendInvoiceMatch</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>VendInvoiceMatch</c> class is the <c>RunBaseBatch</c> class for
/// vendor invoices product receipt matching process.
/// </summary>
public class VendInvoiceMatch extends RunBaseBatch implements BatchRetryable
{
    container invoiceContainer;
    const int MaxRetryAttempts = 5;
    static int backOffWait = RandomGenerate::construct().randomInt(50, 1000);

    #define.CurrentVersion(1)
    #LOCALMACRO.InvoiceList
        invoiceContainer
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    /// true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A class that can be used in a batch journal is a class where the same parameters can be used
    /// repeatedly. The dialog box can be shown and the parameters can be changed but parameters of some
    /// classes might build on data that is only valid for a short time. Running a class two times with the
    /// same parameters is not always possible. If the <c>RunBaseBatch.canGoBatch</c> method returns false,
    /// this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    container pack()
    {
        return [#CurrentVersion, #InvoiceList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        if (VendInvoiceMatch::areDuplicatePackingSlipsAllowed())
        {
            throw error(strFmt("@SYS316750", "@SYS309663", "@SYS50897", "@SYS24976"));
        }

        VendInvoiceMatch::match(this.parmInvoiceContainer());
    }

]]></Source>
			</Method>
			<Method>
				<Name>areDuplicatePackingSlipsAllowed</Name>
				<Source><![CDATA[
    private static boolean areDuplicatePackingSlipsAllowed()
    {
        return (PurchParameters::find().CheckPackingSlip != ReuseVoucher::NoDuplicate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceContainer</Name>
				<Source><![CDATA[
    public container parmInvoiceContainer(container _invoiceContainer = invoiceContainer)
    {
        invoiceContainer = _invoiceContainer;
        return invoiceContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container _packedClass)
    {
        Integer version = conPeek(_packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #InvoiceList] = _packedClass;
                return true;
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    private static Query buildQuery(str _range)
    {
        Query query = new Query();
        QueryBuildDataSource rootQbds, lineQbds, subLineQbds, vpstQbds;
        QueryBuildRange qbr;

        // VendInvoiceInfoTable
        rootQbds = query.addDataSource(tableNum(VendInvoiceInfoTable));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, ParmId)).value(SysQuery::valueEmptyString());
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus)).value(SysQuery::value(VendInvoiceSaveStatus::Pending));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, ParmJobStatus)).value(SysQuery::value(ParmJobStatus::Waiting));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, ParmJobStatus)).value(SysQuery::value(ParmJobStatus::ContainErrors));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, VarianceApproved)).value(SysQuery::value(NoYes::No));

        if(_range)
        {
            // Add ranges for invoices selected
            rootQbds.addRange(fieldNum(VendInvoiceInfoTable, TableRefId)).value(_range);
        }
        else
        {
            // Select all invoices with a Match Status of Waiting
            rootQbds.addRange(fieldNum(VendInvoiceInfoTable, MatchStatus)).value(SysQuery::value(VendInvoiceMatchStatus::Waiting));
        }

        // VendInvoiceInfoLine
        lineQbds = rootQbds.addDataSource(tableNum(VendInvoiceInfoLine));
        lineQbds.joinMode(JoinMode::InnerJoin);
        lineQbds.addLink(fieldNum(VendInvoiceInfoTable, TableRefId), fieldNum(VendInvoiceInfoLine, TableRefId));
        lineQbds.addRange(fieldNum(VendInvoiceInfoLine, ReceiveNow)).value(SysQuery::valueNot(0));

        // VendInvoiceInfoSubLine
        subLineQbds = lineQbds.addDataSource(tableNum(VendInvoiceInfoSubLine));
        subLineQbds.joinMode(JoinMode::InnerJoin);
        subLineQbds.addRange(fieldNum(VendInvoiceInfoSubLine, JournalRefRecId)).value(SysQuery::value(0));
        subLineQbds.addRange(fieldNum(VendInvoiceInfoSubLine, JournalRefTableId)).value(SysQuery::value(tableNum(VendPackingSlipTrans)));
        subLineQbds.addLink(fieldNum(VendInvoiceInfoLine, RecId), fieldNum(VendInvoiceInfoSubLine, LineRefRecId));

        // VendPackingSlipTrans
        vpstQbds = subLineQbds.addDataSource(tableNum(VendPackingSlipTrans));
        vpstQbds.joinMode(JoinMode::InnerJoin);
        vpstQbds.addLink(fieldNum(VendInvoiceInfoSubLine, DocumentId), fieldNum(VendPackingSlipTrans, PackingSlipId));

        qbr = vpstQbds.addRange(fieldNum(VendPackingSlipTrans, PackingSlipId));
        
        // String format used in query -
        // VendInvoiceInfoLine_1.InventTransId == VendPackingSlipTrans_1.InventTransId
        qbr.value(strFmt('(%1.%2==%3.%4)',
            lineQbds.name(),
            fieldStr(VendInvoiceInfoLine, InventTransId),
            vpstQbds.name(),
            fieldStr(VendPackingSlipTrans, InventTransId)));

        qbr.status(RangeStatus::Hidden);

        VendInvoiceMatch::extendQuery(query, true);
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSetBasedQuery</Name>
				<Source><![CDATA[
    public static void updateSetBasedQuery(QueryBuildDataSource _vendInvoiceInfoLineQbds, QueryBuildDataSource _vendPackingSlipTransQbds)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSetBasedQuery</Name>
				<Source><![CDATA[
    private static Query buildSetBasedQuery(str _range, boolean _isInBatch = false, VendInvoiceAutomationInvoiceTmp _invoicesReadyForMatching = null)
    {
        Query query = new Query();
        QueryBuildDataSource rootQbds, lineQbds, subLineQbds, vpstQbds, tmpQbds, purchLineQbds, subLineSumQbds, quantityMatchQbds;
        
        // VendInvoiceInfoTable
        rootQbds = query.addDataSource(tableNum(VendInvoiceInfoTable));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, ParmId)).value(SysQuery::valueEmptyString());
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, VendInvoiceSaveStatus)).value(SysQuery::value(VendInvoiceSaveStatus::Pending));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, ParmJobStatus)).value(SysQuery::value(ParmJobStatus::Waiting));
        rootQbds.addRange(fieldNum(VendInvoiceInfoTable, ParmJobStatus)).value(SysQuery::value(ParmJobStatus::ContainErrors));
        
        // VendInvoiceInfoLine - only match lines with non-zero quantity
        lineQbds = rootQbds.addDataSource(tableNum(VendInvoiceInfoLine));
        lineQbds.addLink(fieldNum(VendInvoiceInfoTable, TableRefId), fieldNum(VendInvoiceInfoLine, TableRefId));
        lineQbds.addLink(fieldNum(VendInvoiceInfoTable, ParmId), fieldNum(VendInvoiceInfoLine, ParmId));
        lineQbds.fetchMode(QueryFetchMode::One2One);
        lineQbds.joinMode(JoinMode::InnerJoin);
        lineQbds.addRange(fieldNum(VendInvoiceInfoLine, ReceiveNow)).value(SysQuery::valueNot(0));

        if(_isInBatch)
        {
            // Remove invoice lines that does not reference to purchase order.
            lineQbds.addRange(fieldNum(VendInvoiceInfoLine, PurchLineRecId)).value(SysQuery::valueNot(0));
        }

        // VendPackingSlipTrans
        vpstQbds = lineQbds.addDataSource(tableNum(VendPackingSlipTrans));
        vpstQbds.addLink(fieldNum(VendInvoiceInfoLine, InventTransId), fieldNum(VendPackingSlipTrans, InventTransId));
        vpstQbds.fetchMode(QueryFetchMode::One2One);
        vpstQbds.joinMode(JoinMode::InnerJoin);
        vpstQbds.addOrderByField(fieldNum(VendPackingSlipTrans, PackingSlipId), SortOrder::Ascending);
        vpstQbds.addOrderByField(fieldNum(VendPackingSlipTrans, DeliveryDate), SortOrder::Ascending);

        // Only include packing slip lines that are not fully matched
        QueryBuildRange qbr = vpstQbds.addRange(fieldNum(VendPackingSlipTrans, FullyMatched));
        qbr.value(SysQuery::value(NoYes::No));
        qbr.status(RangeStatus::Hidden);

        // Only include packing slip lines with the same sign
        qbr = vpstQbds.addRange(fieldNum(VendPackingSlipTrans, Qty));

        // String format used in query -
        // (VendPackingSlipTrans_1.Qty*VendInvoiceInfoLine_1.ReceiveNow)>0
        qbr.value(strFmt('(%1.%2*%3.%4)>0',
            vpstQbds.name(),
            fieldStr(VendPackingSlipTrans, Qty),
            lineQbds.name(),
            fieldStr(VendInvoiceInfoLine, ReceiveNow)));

        qbr.status(RangeStatus::Hidden);

        // Remove invoice lines that does not have three way matching policy.
        purchLineQbds = lineQbds.addDataSource(tableNum(PurchLine));
        purchLineQbds.addLink(fieldNum(VendInvoiceInfoLine, PurchLineRecId), fieldNum(PurchLine, RecId));
        purchLineQbds.fetchMode(QueryFetchMode::One2One);
        purchLineQbds.joinMode(JoinMode::ExistsJoin);
        purchLineQbds.addRange(fieldNum(PurchLine, MatchingPolicy)).value(SysQuery::value(PurchMatchingPolicyOption::ThreeWayMatch));
        
        if (_isInBatch)
        {
            VendInvoiceAutomationInvoiceTmp invoicesForMatchingTmp;
            invoicesForMatchingTmp.linkPhysicalTableInstance(_invoicesReadyForMatching);

            // Vendor invoice eligible for automatic matching process.
            tmpQbds = rootQbds.addDataSource(tableNum(VendInvoiceAutomationInvoiceTmp));
            tmpQbds.addLink(fieldNum(VendInvoiceInfoTable, RecId), fieldNum(VendInvoiceAutomationInvoiceTmp, VendInvoiceRecId));
            tmpQbds.fetchMode(QueryFetchMode::One2One);
            tmpQbds.joinMode(JoinMode::ExistsJoin);
            tmpQbds.cursor(invoicesForMatchingTmp);
        }
        else
        {
            if (_range)
            {
                // Add ranges for invoices selected
                rootQbds.addRange(fieldNum(VendInvoiceInfoTable, TableRefId)).value(_range);
            }
            else
            {
                // Select all invoices with a Match Status of Waiting
                rootQbds.addRange(fieldNum(VendInvoiceInfoTable, MatchStatus)).value(SysQuery::value(VendInvoiceMatchStatus::Waiting));
            }
        }

        // VendInvoiceInfoSubLineSumAll - only match when not fully matched already
        subLineSumQbds = lineQbds.addDataSource(tableNum(VendInvoiceInfoSubLineSumAll));
        subLineSumQbds.addLink(fieldNum(VendInvoiceInfoLine, RecId), fieldNum(VendInvoiceInfoSubLineSumAll, LineRefRecId));
        subLineSumQbds.fetchMode(QueryFetchMode::One2One);
        subLineSumQbds.joinMode(JoinMode::NoExistsJoin);
        qbr = subLineSumQbds.addRange(fieldNum(VendInvoiceInfoSubLineSumAll, SumOfReceiveNow));
        qbr.value(strFmt('((%1.%2>=%3.%4) && (%3.%4>0)) || ((%1.%2<=%3.%4) && (%3.%4<0))',
            subLineSumQbds.name(),
            FieldStr(VendInvoiceInfoSubLineSumAll, SumOfReceiveNow),
            lineQbds.name(),
            fieldStr(VendInvoiceInfoLine, ReceiveNow)));
        qbr.status(RangeStatus::Hidden);

        // VendInvoicePackingSlipQuantityMatchSum - only match when not fully matched already
        quantityMatchQbds = vpstQbds.addDataSource(tableNum(VendInvoicePackingSlipQuantityMatchSum));
        quantityMatchQbds.addLink(fieldNum(VendPackingSlipTrans, SourceDocumentLine), fieldNum(VendInvoicePackingSlipQuantityMatchSum, PackingSlipSourceDocumentLine));
        quantityMatchQbds.fetchMode(QueryFetchMode::One2One);
        quantityMatchQbds.joinMode(JoinMode::OuterJoin);

        // VendInvoiceInfoSubLineSum - only match when not fully matched already
        subLineQbds = vpstQbds.addDataSource(tableNum(VendInvoiceInfoSubLineSum));
        subLineQbds.addLink(fieldNum(VendPackingSlipTrans, TableId), fieldNum(VendInvoiceInfoSubLineSum, JournalRefTableId));
        subLineQbds.addLink(fieldNum(VendPackingSlipTrans, RecId), fieldNum(VendInvoiceInfoSubLineSum, JournalRefRecId));
        subLineQbds.fetchMode(QueryFetchMode::One2One);
        subLineQbds.joinMode(JoinMode::NoExistsJoin);

        qbr = subLineQbds.addRange(fieldNum(VendInvoiceInfoSubLineSum, SumOfReceiveNow));
        qbr.value(strFmt('(((%1.%2+%3.%4-%5.%6>=0) && (%5.%6>0)) || ((%1.%2-%5.%6>=0) && (%5.%6>0)) || ((%1.%2+%3.%4-%5.%6<=0) && (%5.%6<0)) || ((%1.%2-%5.%6<=0) && (%5.%6<0)))',
            subLineQbds.name(),
            fieldStr(VendInvoiceInfoSubLineSum, SumOfReceiveNow),
            quantityMatchQbds.name(),
            fieldStr(VendInvoicePackingSlipQuantityMatchSum, SumOfQuantity),
            vpstQbds.name(),
            fieldStr(VendPackingSlipTrans, Qty)));
        qbr.status(RangeStatus::Hidden);

        // When this flight is changed to default on, need to consider when and how to log the telemetry for query
        if (VendInvoiceMatchAllowUpdateMatchQueryFlight::instance().isEnabled())
        {
            try
            {
                VendInvoiceMatch::updateSetBasedQuery(lineQbds, vpstQbds);
            }
            catch
            {
                VendInstrumentation::logTelemetry(
                    VendInvoiceMatchTaskConstants::InstrumentationNamespace,
                    classStr(VendInvoiceMatch),
                    VendInvoiceMatchTaskConstants::UpdateQueryExtensionError,
                    VendInvoiceMatchTaskConstants::UpdateQueryExtensionError,
                    VendInvoiceMatchTaskConstants::UpdateQueryExtensionErrorMessage);
                throw error(VendInvoiceMatchTaskConstants::UpdateQueryExtensionErrorMessage);
            }
            VendInstrumentation::logTelemetry(
                VendInvoiceMatchTaskConstants::InstrumentationNamespace,
                classStr(VendInvoiceMatch),
                funcName(),
                classStr(VendInvoiceMatch),
                strFmt("VendInvoiceMatch: query->%1", query));
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>completeVendInvoiceMatchingTask</Name>
				<Source><![CDATA[
    private static void completeVendInvoiceMatchingTask(recId _headerRecId)
    {
        WorkflowWorkItemTable workflowWorkItemTable;
        WorkflowElementTable workflowElementTable;

        while select * from workflowWorkItemTable
            exists join workflowElementTable
            where workflowWorkItemTable.RefTableId == tableNum(VendInvoiceInfoTable)
                && workflowWorkItemTable.RefRecId == _headerRecId
                && workflowWorkItemTable.ElementId == workflowElementTable.ElementId
                && workflowElementTable.ElementType == WorkflowElementType::Task
                && workflowElementTable.ElementName == workFlowTaskStr(VendInvoiceMatchingTask)
        {
            WorkflowWorkItem::takeAction(
                workflowWorkItemTable.Id,
                WorkflowWorkItemActionManager::findOutcomeNameForMenuItem(workflowWorkItemTable,
                    menuitemActionStr(VendInvoiceMatchingTaskComplete)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static VendInvoiceMatch construct()
    {
        return new VendInvoiceMatch();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS129835";
    }

]]></Source>
			</Method>
			<Method>
				<Name>endInvoice</Name>
				<Source><![CDATA[
    private static boolean endInvoice(recId _headerRecId, TradeLineRefId _tableRefId, boolean _atLeastPartiallyMatched)
    {
        boolean fullyMatched = false;

        if (_atLeastPartiallyMatched)
        {
            fullyMatched = VendInvoiceMatch::isFullyMatched(_tableRefId);
            if (fullyMatched)
            {
                // All instances of VendInvoiceMatchingTask for given invoice should be released
                VendInvoiceMatch::completeVendInvoiceMatchingTask(_headerRecId);
            }
        }

        return fullyMatched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extendQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Builds the queries that display data on the <c>PurchJournalMatch_PackingSlip</c> form.
    /// </summary>
    /// <param name = "_query">
    /// Query object to extend.
    /// </param>
    /// <param name = "_threeWayMatchOnly">
    /// A Boolean value that indicates whether the query is to be restricted to only lines that have a
    /// <c>MatchingPolicy</c> value equal to <c>PurchMatchingPolicyOption::ThreeWayMatch</c>.
    /// </param>
    /// <returns>
    /// A <c>QueryBuildRange</c> object that represents the <c>InventTransID</c> type range.
    /// </returns>
    public static QueryBuildRange extendQuery(Query _query, boolean _threeWayMatchOnly)
    {
        QueryBuildDataSource qbds, rootQbds;
        QueryBuildRange qbr, returnInventTransIdRange;

        rootQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
        if (rootQbds)
        {
            // Only packing slips that are not fully matched
            qbr = rootQbds.addRange(fieldNum(VendPackingSlipTrans, FullyMatched));
            qbr.value(SysQuery::value(NoYes::No));
            qbr.status(RangeStatus::Hidden);

            qbds = rootQbds.addDataSource(tableNum(PurchLine));
            qbds.joinMode(JoinMode::InnerJoin);
            qbds.addLink(fieldNum(VendPackingSlipTrans, InventTransId), fieldNum(PurchLine, InventTransId));
            qbds.firstOnly(true);
            qbr = qbds.addRange(fieldNum(PurchLine, PurchQty));

            qbr.value(strFmt('(%1.%2*%3.%4)>0',
                                rootQbds.name(),
                                fieldStr(VendPackingSlipTrans, Qty),
                                qbds.name(),
                                fieldStr(PurchLine, PurchQty))); // if both fields have same sign we want to allow VendPackingSlipTrans into grid
            qbr.status(RangeStatus::Hidden);

            if (_threeWayMatchOnly)
            {
                qbr = qbds.addRange(fieldNum(PurchLine, MatchingPolicy));
                qbr.value(SysQuery::value(PurchMatchingPolicyOption::ThreeWayMatch));
            }

            returnInventTransIdRange = qbds.addRange((fieldNum(PurchLine, InventTransId)));
        }

        return returnInventTransIdRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extendQueryExcludeMatchedPackingSlips</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the query that displays data on the <c>PurchJournalMatch_PackingSlip</c> form.
    /// </summary>
    /// <param name = "_query">
    /// The query object to extend.
    /// </param>
    /// <returns>
    /// A <c>QueryBuildRange</c> object that represents <c>TableRefId</c> value range.
    /// </returns>
    public static QueryBuildRange extendQueryExcludeMatchedPackingSlips(Query _query)
    {
        QueryBuildDataSource qbds, transQbds, rootQbds;
        QueryBuildRange qbr, returnTableRefIdRange;

        transQbds = _query.dataSourceTable(tableNum(VendPackingSlipTrans));

        if (transQbds)
        {
            rootQbds = transQbds.addDataSource(tableNum(VendInvoiceSubLineSum));
            rootQbds.joinMode(JoinMode::NoExistsJoin);

            qbr = rootQbds.addRange(fieldNum(VendInvoiceSubLineSum, SumOfReceiveNow));

            qbr.value(strFmt('(%1.%2)==(%3.%4)',
                transQbds.name(),
                fieldStr(VendPackingSlipTrans, Qty),
                rootQbds.name(),
                fieldStr(VendInvoiceSubLineSum, SumOfReceiveNow)));

            rootQbds.addLink(fieldNum(VendPackingSlipTrans, RecId), fieldNum(VendInvoiceSubLineSum, JournalRefRecId));

            qbds = rootQbds.addDataSource(tableNum(VendInvoiceInfoSubLine));
            qbds.joinMode(JoinMode::ExistsJoin);

            qbds.addLink(fieldNum(VendInvoiceSubLineSum, JournalRefRecId), fieldNum(VendInvoiceInfoSubLine, JournalRefRecId));
            qbds.addRange(fieldNum(VendInvoiceInfoSubLine, JournalRefTableId)).value(SysQuery::value(tableNum(VendPackingSlipTrans)));

            qbds = qbds.addDataSource(tableNum(VendInvoiceInfoLine));
            qbds.joinMode(JoinMode::ExistsJoin);

            qbds.addLink(fieldNum(VendInvoiceInfoSubLine, LineRefRecId), fieldNum(VendInvoiceInfoLine, RecId));

            qbds.addRange(fieldNum(VendInvoiceInfoLine, ParmId)).value(SysQuery::valueEmptyString());
            returnTableRefIdRange = qbds.addRange(fieldNum(VendInvoiceInfoLine, TableRefId));
        }

        return returnTableRefIdRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFormRecord</Name>
				<Source><![CDATA[
    private static container getFormRecord(FormDataSource invoiceRecord_ds)
    {
        Common invoiceRecord;
        List invoiceList = new List(Types::Record);

        if (invoiceRecord_ds.getFirst(true))
        {
            invoiceRecord = invoiceRecord_ds.getFirst(true);
        }
        else
        {
            invoiceRecord = invoiceRecord_ds.cursor();
        }

        while (invoiceRecord)
        {
            invoiceList.addEnd(invoiceRecord);
            invoiceRecord = invoiceRecord_ds.getNext();
        }

        return invoiceList.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFullyMatched</Name>
				<Source><![CDATA[
    private static boolean isFullyMatched(TradeLineRefId _tableRefId)
    {
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoLine vendInvoiceInfoLine;

        select firstonly RecId from vendInvoiceInfoSubLine
            exists join vendInvoiceInfoLine
            where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
                && vendInvoiceInfoLine.TableRefId == _tableRefId
                && vendInvoiceInfoLine.ParmId == ''
                && vendInvoiceInfoSubLine.JournalRefRecId == 0; // still not matched

        return vendInvoiceInfoSubLine.RecId == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        VendInvoiceMatch vendInvoiceMatch = VendInvoiceMatch::construct();
        Common record = _args.record();

        if (record)
        {
            FormDataSource recordDataSource = FormDataUtil::getFormDataSource(record);

            if (recordDataSource)
            {
                vendInvoiceMatch.parmInvoiceContainer(VendInvoiceMatch::getFormRecord(recordDataSource));
                vendInvoiceMatch.runOperation();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchingInBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs vendor invoice product receipts matching autoamtically through batch job.
    /// </summary>
    /// <param name = "_invoicesReadyForMatching">
    /// Selected vendor invoice records for automatic matching batch job.
    /// </param>
    /// <param name="_vendInvoiceAutomationMatchingLogHandler">
    /// Matching log handler for execution.
    /// </param>
    internal static void matchingInBatch(
        VendInvoiceAutomationInvoiceTmp _invoicesReadyForMatching,
        VendInvoiceAutomationMatchingLogHandler _vendInvoiceAutomationMatchingLogHandler)
    {
        #OCCRetryCount
        
        Microsoft.Dynamics.Ax.Xpp.ErrorException errorException;

        // build the query to generate <c>VendInvoiceInfoSubLine</c> records for batch job.
        Query query = VendInvoiceMatch::buildSetBasedQuery(null, true, _invoicesReadyForMatching);

        VendInvoiceAutomationInstrumentationMatchingActivities instrumentationMatchingActivities =
            VendInvoiceAutomationInstrumentationMatchingActivities::createFromLoggerName(classStr(VendInvoiceMatch));
        
        try
        {
            ttsbegin;
            // Perform vendor invoice product receipt matching process in set-based manner for batch job.
            VendInvoiceMatch::setBasedMatching(query);

            // Log automation matching process logs.
            _vendInvoiceAutomationMatchingLogHandler.logAutomationMatchingResults(_invoicesReadyForMatching);

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (currentRetryCount >= #RetryNum)
            {
                VendInvoiceAutomationInstrumentationDbErrorProperties errorProperties =
                    VendInvoiceAutomationInstrumentationDbErrorProperties::constructFromActivityContext(instrumentationMatchingActivities.matchingInBatchContext());

                errorProperties.deadLockProperty(_invoicesReadyForMatching.RecId);
            }
            else
            {
                sleep(currentRetryCount * backOffWait);
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                int currentRetryCount = xSession::currentRetryCount();
                if (currentRetryCount >= #RetryNum)
                {
                    VendInvoiceAutomationInstrumentationDbErrorProperties errorProperties =
                    VendInvoiceAutomationInstrumentationDbErrorProperties::constructFromActivityContext(instrumentationMatchingActivities.matchingInBatchContext());

                    errorProperties.updateConflictProperty(_invoicesReadyForMatching.RecId, true);
                }
                else
                {
                    sleep(currentRetryCount * backOffWait);
                    retry;
                }
            }
            else
            {
                VendInvoiceAutomationInstrumentationDbErrorProperties errorProperties =
                    VendInvoiceAutomationInstrumentationDbErrorProperties::constructFromActivityContext(instrumentationMatchingActivities.matchingInBatchContext());

                errorProperties.updateConflictProperty(_invoicesReadyForMatching.RecId);
            }
        }
        catch (errorException)
        {
            VendInvoiceAutomationInstrumentationDbErrorProperties errorProperties =
                    VendInvoiceAutomationInstrumentationDbErrorProperties::constructFromActivityContext(instrumentationMatchingActivities.matchingInBatchContext());

            errorProperties.exceptionProperty(_invoicesReadyForMatching.VendInvoiceRecId, errorException.ToString());
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>match</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs vendor invoice product receipts matching process.
    /// </summary>
    /// <param name = "_dataSourceRecordsPacked">
    /// Selected vendor invoice records for matching process.
    /// </param>
    public static void match(container _dataSourceRecordsPacked)
    {
        NumberOfRecords invoicesPartiallyMatched = 0;
        NumberOfRecords invoicesFullyMatched = 0;
        boolean displayMessages = (_dataSourceRecordsPacked != conNull());
        NumberOfRecords invoicesSelected = 0;
        str range = null;

        // gather the selected vendor invoice records.
        container gatherSelectedRecords = VendInvoiceMatch::gatherSelectedRecords(_dataSourceRecordsPacked);
        [range, invoicesSelected] = gatherSelectedRecords;

        if (displayMessages)
        {
            info(strFmt("@SYS319309", invoicesSelected));
            info("@SYS319310");
        }

        // check if the <c>VendAutomateVendorInvoicesFeature</c> is enabled
        // then perform vendor invoice product receipt matching process.
        if (VendAutomateVendorInvoicesFeature::isEnabled())
        {
            // build the query to generate <c>VendInvoiceInfoSubLine</c> records.
            Query query = VendInvoiceMatch::buildSetBasedQuery(range);
            VendInvoiceLineMatchingTmp vendInvoiceLineMatchingTmpInitial;
            Map insertRecordsetMap = new Map(Types::String,Types::Container);

            query.clearAllFields();

            QueryBuildDataSource qbdsVendInvoiceLine = query.dataSourceTable(tableNum(VendInvoiceInfoLine));
            QueryBuildFieldList qbfl = qbdsVendInvoiceLine.fields();
            VendInvoiceMatch::addFieldMappingsVendInvoiceLineForTmpTable(qbdsVendInvoiceLine, qbfl, insertRecordsetMap);

            vendInvoiceLineMatchingTmpInitial = null;
            vendInvoiceLineMatchingTmpInitial.skipDataMethods(true);
            vendInvoiceLineMatchingTmpInitial.skipDatabaseLog(true);
            vendInvoiceLineMatchingTmpInitial.skipEvents(true);
            Query::insert_recordset(vendInvoiceLineMatchingTmpInitial, insertRecordsetMap, query);

            // Perform vendor invoice product receipt matching process in set-based manner.
            VendInvoiceMatch::setBasedMatching(query);

            invoicesPartiallyMatched = VendInvoiceMatch::infoLogRecordsBasedOnMatchingStatus(VendInvoiceProductReceiptMatchingStatus::PartiallyMatched, vendInvoiceLineMatchingTmpInitial);
            invoicesFullyMatched = VendInvoiceMatch::infoLogRecordsBasedOnMatchingStatus(VendInvoiceProductReceiptMatchingStatus::FullyMatched, vendInvoiceLineMatchingTmpInitial);
            VendInvoiceMatch::infoLogRecordsBasedOnMatchingStatus(VendInvoiceProductReceiptMatchingStatus::OverlyMatched, vendInvoiceLineMatchingTmpInitial);
        }
        else
        {
            // build the query to generate <c>VendInvoiceInfoSubLine</c> records.
            Query query = VendInvoiceMatch::buildQuery(range);

            UnitofWork unitofWork = new UnitofWork();
            boolean saveUnitOfWork;
            TradeLineRefId lastHeaderTableRefId = '';
            RecId lastHeaderRecId = 0;
            Num lastHeaderNum = '';
            boolean partialMatchForInvoice; // true if any subline was matched for the invoice
            boolean overDelivery;
            QueryRun qr = new SysQueryRun(query);

            while (qr.next())
            {
                if (qr.changed(tableNum(VendInvoiceInfoTable)))
                {
                    VendInvoiceInfoTable vendInvoiceInfoTable = qr.get(tableNum(VendInvoiceInfoTable));

                    // finish processing of the previous invoice
                    if (lastHeaderRecId != 0)
                    {
                        [invoicesFullyMatched, invoicesPartiallyMatched] = VendInvoiceMatch::endHeader(lastHeaderTableRefId, lastHeaderRecId, lastHeaderNum, overDelivery, partialMatchForInvoice);
                    }

                    // init for new header
                    overDelivery = false;
                    partialMatchForInvoice = false;
                    lastHeaderTableRefId = vendInvoiceInfoTable.TableRefId;
                    lastHeaderRecId = vendInvoiceInfoTable.RecId;
                    lastHeaderNum = vendInvoiceInfoTable.Num;
                }
                
                VendInvoiceInfoLine vendInvoiceInfoLine;
                PurchQty receiveNow, totalRecieveNow;
                InventQty inventNow, totalInventNow, lineInventNow;

                if (qr.changed(tableNum(VendInvoiceInfoLine)))
                {
                    vendInvoiceInfoLine = qr.get(tableNum(VendInvoiceInfoLine));

                    if (saveUnitOfWork)
                    {
                        partialMatchForInvoice = true;
                        unitofWork.saveChanges();
                        saveUnitOfWork = false;
                    }
                    else
                    {
                        unitofWork.clear();
                    }

                    // Reset totals for each new line
                    totalRecieveNow = 0.0;
                    totalInventNow = 0.0;
                    lineInventNow = 0.0; // will be calculated based on packing slips
                }
                
                PurchLine purchLine;
                VendInvoiceInfoSubLine vendInvoiceInfoSubLine;

                if (qr.changed(tableNum(VendInvoiceInfoSubLine)))
                {
                    vendInvoiceInfoSubLine = qr.get(tableNum(VendInvoiceInfoSubLine));
                }

                if (qr.changed(tableNum(PurchLine)))
                {
                    // PurchLine is selected in its own query branch so we need separate buffers, otherwise the buffer will be reset at next iteration.
                    purchLine.data(qr.get(tableNum(PurchLine)).data());
                }

                if (qr.changed(tableNum(VendPackingSlipTrans)))
                {
                    VendPackingSlipTrans vendPackingSlipTrans = qr.get(tableNum(VendPackingSlipTrans));

                    inventNow = vendPackingSlipTrans.remainInventFinancial();
                    receiveNow = vendPackingSlipTrans.remainPurchFinancial();

                    totalInventNow += inventNow;
                    totalRecieveNow += receiveNow;

                    if (vendInvoiceInfoLine.ReceiveNow < totalRecieveNow)
                    {
                        // overdelivery
                        saveUnitOfWork = false;
                        overDelivery = true;
                    }
                    else
                    {
                        vendInvoiceInfoSubLine.JournalRefRecId = vendPackingSlipTrans.RecId;
                        vendInvoiceInfoSubLine.JournalRefTableId = tableNum(VendPackingSlipTrans);
                        vendInvoiceInfoSubLine.InventNow = inventNow;

                        unitofWork.updateonSaveChanges(vendInvoiceInfoSubLine);

                        lineInventNow += vendInvoiceInfoSubLine.InventNow;

                        // Refresh the remain before/after
                        if (vendInvoiceInfoLine.ReceiveNow == totalRecieveNow)
                        {
                            purchLine = PurchLine::findInventTransId(vendPackingSlipTrans.InventTransId);
                            
                            PurchQuantity purchQuantity = PurchQuantity::construct(DocumentStatus::Invoice, false);

                            [vendInvoiceInfoLine.InventNow, vendInvoiceInfoLine.RemainBeforeInvent, vendInvoiceInfoLine.RemainAfterInvent]
                            = purchQuantity.qtyInvent(purchLine, PurchUpdate::PackingSlip, lineInventNow, true);
                            vendInvoiceInfoLine.calcLineAmount();
                            unitofWork.updateonSaveChanges(vendInvoiceInfoLine);
                            saveUnitOfWork = true;
                        }
                    }
                }
            }

            // save the last unit
            if (saveUnitOfWork)
            {
                partialMatchForInvoice = true;
                unitofWork.saveChanges();
            }

            // finish processing of the last invoice
            if (lastHeaderRecId != 0)
            {
                [invoicesFullyMatched, invoicesPartiallyMatched] = VendInvoiceMatch::endHeader(lastHeaderTableRefId, lastHeaderRecId, lastHeaderNum, overDelivery, partialMatchForInvoice);
            }
        }

        // display info messages for selected vendor invoices product receipt matching process.
        if (displayMessages)
        {
            info("@SYS319311");
            info(strFmt("@SYS319312", invoicesFullyMatched, invoicesSelected));
            info(strFmt("@SYS319313", invoicesPartiallyMatched, invoicesSelected));
            info(strFmt("@SYS319314", invoicesSelected - invoicesFullyMatched - invoicesPartiallyMatched, invoicesSelected));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endHeader</Name>
				<Source><![CDATA[
    private static container endHeader(TradeLineRefId _lastHeaderTableRefId,
        RecId _lastHeaderRecId,
        Num _lastHeaderNum,
        boolean _overDelivery,
        boolean _partialMatchForInvoice)
    {
        boolean fullMatchForInvoice;
        NumberOfRecords invoicesPartiallyMatched = 0;
        NumberOfRecords invoicesFullyMatched = 0;

        fullMatchForInvoice = VendInvoiceMatch::endInvoice(_lastHeaderRecId, _lastHeaderTableRefId, _partialMatchForInvoice);

        if (fullMatchForInvoice)
        {
            invoicesFullyMatched++;
        }
        else if (_partialMatchForInvoice)
        {
            invoicesPartiallyMatched++;
        }

        if (_overDelivery)
        {
            // always display this one regardless of displayMessages
            warning(strFmt("@SYS322276", _lastHeaderNum));
        }
        return [invoicesFullyMatched, invoicesPartiallyMatched];
    }

]]></Source>
			</Method>
			<Method>
				<Name>infoLogRecordsBasedOnMatchingStatus</Name>
				<Source><![CDATA[
    private static NumberOfRecords infoLogRecordsBasedOnMatchingStatus(
        VendInvoiceProductReceiptMatchingStatus _vendInvoiceProductReceiptMatchingStatus,
        VendInvoiceLineMatchingTmp _vendInvoiceLineMatchingTmp)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoSubLineSumAll vendInvoiceInfoSubLineSumAll;
        NumberOfRecords recordsCount = 0;

        if (_vendInvoiceProductReceiptMatchingStatus == VendInvoiceProductReceiptMatchingStatus::PartiallyMatched)
        {
            select count(RecId) from vendInvoiceInfoTable
                exists join _vendInvoiceLineMatchingTmp
                    where vendInvoiceInfoTable.ParmId == _vendInvoiceLineMatchingTmp.ParmId &&
                        vendInvoiceInfoTable.TableRefId == _vendInvoiceLineMatchingTmp.TableRefId
                join vendInvoiceInfoSubLineSumAll
                    where vendInvoiceInfoSubLineSumAll.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId &&
                        _vendInvoiceLineMatchingTmp.ReceiveNow > vendInvoiceInfoSubLineSumAll.SumOfReceiveNow;
            
            recordsCount = vendInvoiceInfoTable.RecId;
        }
        else if (_vendInvoiceProductReceiptMatchingStatus == VendInvoiceProductReceiptMatchingStatus::FullyMatched)
        {
            VendInvoiceAutomationInvoiceTmp vendInvoiceAutomationInvoiceTmp;

            insert_recordset vendInvoiceAutomationInvoiceTmp(VendInvoiceRecId)
                select RecId from vendInvoiceInfoTable
                    exists join _vendInvoiceLineMatchingTmp
                        where vendInvoiceInfoTable.ParmId == _vendInvoiceLineMatchingTmp.ParmId &&
                            vendInvoiceInfoTable.TableRefId == _vendInvoiceLineMatchingTmp.TableRefId
                    join vendInvoiceInfoSubLineSumAll
                        where vendInvoiceInfoSubLineSumAll.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId &&
                            _vendInvoiceLineMatchingTmp.ReceiveNow == vendInvoiceInfoSubLineSumAll.SumOfReceiveNow;
            
            recordsCount = vendInvoiceAutomationInvoiceTmp.RowCount();
            
            VendInvoiceAutomationMatchingLogger matchingLogger =  new VendInvoiceAutomationMatchingLogger();

            matchingLogger.writeManualFullyMatchedInAutomation(vendInvoiceAutomationInvoiceTmp);
        }
        else if (_vendInvoiceProductReceiptMatchingStatus == VendInvoiceProductReceiptMatchingStatus::OverlyMatched)
        {
            while select Num, RecId from vendInvoiceInfoTable
                exists join _vendInvoiceLineMatchingTmp
                    where vendInvoiceInfoTable.ParmId == _vendInvoiceLineMatchingTmp.ParmId &&
                        vendInvoiceInfoTable.TableRefId == _vendInvoiceLineMatchingTmp.TableRefId
                join vendInvoiceInfoSubLineSumAll
                    where vendInvoiceInfoSubLineSumAll.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId &&
                        _vendInvoiceLineMatchingTmp.ReceiveNow < vendInvoiceInfoSubLineSumAll.SumOfReceiveNow
            {
                warning(strFmt("@SYS322276", vendInvoiceInfoTable.Num));
            }
        }

        return recordsCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>gatherSelectedRecords</Name>
				<Source><![CDATA[
    private static container gatherSelectedRecords(container _dataSourceRecordsPacked)
    {
        VendInvoiceInfoTable record;
        ListEnumerator recordListEnumerator;
        NumberOfRecords numberOfInvoicesSelected = 0;
        str range = null;

        if (_dataSourceRecordsPacked != conNull())
        {
            recordListEnumerator = List::create(_dataSourceRecordsPacked).getEnumerator();

            // Add ranges for invoices selected from the caller form
            while (recordListEnumerator.moveNext())
            {
                record = recordListEnumerator.current();
                range += record.TableRefId + ',';
                numberOfInvoicesSelected++;
            }
        }
        return [range, numberOfInvoicesSelected];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBasedMatching</Name>
				<Source><![CDATA[
    private static VendInvoiceLineMatchingTmp setBasedMatching(Query _query)
    {
        Map insertRecordsetMap;
        QueryBuildDataSource qbdsPackingSlipTrans, qbdsVendInvoiceLine, qbdsVendInvoiceHeader;
        QueryBuildFieldList qbfl;
        VendInvoiceLineMatchingTmp vendInvoiceLineMatchingTmp, vendInvoiceLineMatchingTmpLocal;
        boolean nextRunRequired;
        int round = 0;
        int maxRound = VendParameters::getAutomationMaximumSetBasedMatchingRounds();
        int numOfInvoiceLines = 0;
        
        do
        {
            insertRecordsetMap = new Map(Types::String,Types::Container);
            
            _query.clearAllFields();

            qbdsVendInvoiceLine = _query.dataSourceTable(tableNum(VendInvoiceInfoLine));
            qbfl = qbdsVendInvoiceLine.fields();
        
            VendInvoiceMatch::addFieldMappingsVendInvoiceLineForTmpTable(qbdsVendInvoiceLine, qbfl, insertRecordsetMap);
        
            vendInvoiceLineMatchingTmp = null;
            vendInvoiceLineMatchingTmp.skipDataMethods(true);
            vendInvoiceLineMatchingTmp.skipDatabaseLog(true);
            vendInvoiceLineMatchingTmp.skipEvents(true);

            vendInvoiceLineMatchingTmpLocal = null;
            vendInvoiceLineMatchingTmpLocal.skipDataMethods(true);
            vendInvoiceLineMatchingTmpLocal.skipDatabaseLog(true);
            vendInvoiceLineMatchingTmpLocal.skipEvents(true);

            // Generate the vendor invoice lines based on the selected vendor invoice header.
            Query::insert_recordset(vendInvoiceLineMatchingTmp, insertRecordsetMap, _query);

            insert_recordset vendInvoiceLineMatchingTmpLocal(ReceiveNow, TableRefId, RefRecId, ParmId, AutomationHistoryCount,
                ItemId, ProcurementCategory, InventNow, PdsCWReceiveNow)
            select ReceiveNow, TableRefId, RefRecId, ParmId, AutomationHistoryCount,
                ItemId, ProcurementCategory, InventNow, PdsCWReceiveNow from vendInvoiceLineMatchingTmp;

            _query.clearAllFields();
            insertRecordsetMap = new Map(Types::String,Types::Container);

            if (VendInvoiceAutomationMatchingSetBasedFlight::instance().isEnabled())
            {
                qbdsPackingSlipTrans = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
                qbfl = qbdsPackingSlipTrans.fields();
                VendInvoiceMatch::addFieldMappingsVendPackingSlipTransV2(qbdsPackingSlipTrans, qbfl, insertRecordsetMap);

                qbdsVendInvoiceLine = _query.dataSourceTable(tableNum(VendInvoiceInfoLine));
                qbfl = qbdsVendInvoiceLine.fields();
                VendInvoiceMatch::addFieldMappingsVendInvoiceLineV2(qbdsVendInvoiceLine, qbfl, insertRecordsetMap);

                qbdsVendInvoiceHeader = _query.dataSourceTable(tableNum(VendInvoiceInfoTable));
                qbfl = qbdsVendInvoiceHeader.fields();
                VendInvoiceMatch::addFieldMappingsVendInvoiceHeader(qbdsVendInvoiceHeader, qbfl, insertRecordsetMap);
        
                VendInvoiceInfoSubLineTmpV2 vendInvoiceInfoSubLineTmp;
                vendInvoiceInfoSubLineTmp.skipDataMethods(true);
                vendInvoiceInfoSubLineTmp.skipDatabaseLog(true);
                vendInvoiceInfoSubLineTmp.skipEvents(true);
                Query::insert_recordset(vendInvoiceInfoSubLineTmp, insertRecordsetMap, _query);

                delete_from vendInvoiceInfoSubLineTmp
                    notexists join vendInvoiceLineMatchingTmp
                        where vendInvoiceLineMatchingTmp.RefRecId == vendInvoiceInfoSubLineTmp.LineRefRecId;

                nextRunRequired = VendInvoiceMatch::rankVendInvoiceInfoSubLineForMatchingV2(vendInvoiceInfoSubLineTmp);
                round += 1;

                if (round == 1)
                {
                    select count(RecId) from vendInvoiceInfoSubLineTmp;
                    numOfInvoiceLines = vendInvoiceInfoSubLineTmp.RecId;
                }

                if (round mod 10 == 0 && numOfInvoiceLines)
                {
                    select count(RecId) from vendInvoiceInfoSubLineTmp;
                    int progress = 100 - Percent(vendInvoiceInfoSubLineTmp.RecId, numOfInvoiceLines);
                    VendInstrumentation::logTelemetry(
                        VendInvoiceMatchTaskConstants::InstrumentationNamespace,
                        classStr(VendInvoiceMatch),
                        funcName(),
                        classStr(VendInvoiceMatch),
                        strFmt("Round %1: %2\% invoice lines have been processed.", round, progress));
                }

                if (round >= maxRound && nextRunRequired)
                {
                    nextRunRequired = false;
                    VendInstrumentation::logTelemetry(
                        VendInvoiceMatchTaskConstants::InstrumentationNamespace,
                        classStr(VendInvoiceMatch),
                        funcName(),
                        classStr(VendInvoiceMatch),
                        strFmt("Number of executed rounds in one batch reaches maximum %1 rounds", maxRound));
                }

                VendInvoiceMatch::defaultQuantityPackingSlipV2(vendInvoiceLineMatchingTmpLocal, vendInvoiceInfoSubLineTmp);

                //save quantity for invoices lines subjected to matching for the first-time.
                VendInvoiceMatch::saveInventQuantity(vendInvoiceLineMatchingTmp);

                VendInvoiceMatch::updateVendInvoiceInfoLineFromMatchedV2(vendInvoiceInfoSubLineTmp);
            }

            else
            {
                qbdsPackingSlipTrans = _query.dataSourceTable(tableNum(VendPackingSlipTrans));
                qbfl = qbdsPackingSlipTrans.fields();
                VendInvoiceMatch::addFieldMappingsVendPackingSlipTrans(qbdsPackingSlipTrans, qbfl, insertRecordsetMap);

                qbdsVendInvoiceLine = _query.dataSourceTable(tableNum(VendInvoiceInfoLine));
                qbfl = qbdsVendInvoiceLine.fields();
                VendInvoiceMatch::addFieldMappingsVendInvoiceLine(qbdsVendInvoiceLine, qbfl, insertRecordsetMap);
        
                VendInvoiceInfoSubLineTmp vendInvoiceInfoSubLineTmp;
                vendInvoiceInfoSubLineTmp.skipDataMethods(true);
                vendInvoiceInfoSubLineTmp.skipDatabaseLog(true);
                vendInvoiceInfoSubLineTmp.skipEvents(true);
                Query::insert_recordset(vendInvoiceInfoSubLineTmp, insertRecordsetMap, _query);

                delete_from vendInvoiceInfoSubLineTmp
                    notexists join vendInvoiceLineMatchingTmp
                        where vendInvoiceLineMatchingTmp.RefRecId == vendInvoiceInfoSubLineTmp.LineRefRecId;

                nextRunRequired = VendInvoiceMatch::rankVendInvoiceInfoSubLineForMatching(vendInvoiceInfoSubLineTmp);

                VendInvoiceMatch::defaultQuantityPackingSlip(vendInvoiceLineMatchingTmp, vendInvoiceInfoSubLineTmp);

                //save quantity for invoices lines subjected to matching for the first-time.
                VendInvoiceMatch::saveInventQuantity(vendInvoiceLineMatchingTmp);

                VendInvoiceMatch::updateVendInvoiceInfoLineFromMatched(vendInvoiceInfoSubLineTmp);
            }            

        } while (nextRunRequired);

        return vendInvoiceLineMatchingTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveInventQuantity</Name>
				<Source><![CDATA[
    internal static void saveInventQuantity(VendInvoiceLineMatchingTmp _vendInvoiceLineMatchingTmp)
    {
        try
        {
            //self-join like below will suffice to prevent from duplicates due to matching only picking up unique documents for a run everytime via a ranking process above.
            //i.e. it means that during a run particular invoice will be processed once and only once.
            VendInvoiceInfoLineQuantities vendInvoiceInfoLineQty, vendInvoiceInfoLineQtySelf;
            vendInvoiceInfoLineQty.skipDataMethods(true);
            vendInvoiceInfoLineQty.skipDatabaseLog(true);
            vendInvoiceInfoLineQty.skipEvents(true);

            insert_recordset vendInvoiceInfoLineQty (LineRefRecId, InventNow)
                select RefRecId, InventNow from _vendInvoiceLineMatchingTmp
                    group by RefRecId, InventNow
                notexists join vendInvoiceInfoLineQtySelf
                    where vendInvoiceInfoLineQtySelf.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId;
        }
        catch (Exception::Deadlock)
        {
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= MaxRetryAttempts)
            {
                sleep(xSession::currentRetryCount() * backOffWait);
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= MaxRetryAttempts)
            {
                retry;
            }
            else
            {
                throw;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendInvoiceInfoLineFromMatched</Name>
				<Source><![CDATA[
    [SysObsolete("The method has been deprecated use updateVendInvoiceInfoLineFromMatchedV2 instead", false, 04\11\2022)]
    private static void updateVendInvoiceInfoLineFromMatched(VendInvoiceInfoSubLineTmp _vendInvoiceInfoSubLineTmp)
    {
        //_vendInvoiceInfoSubLineTmp is used for the list of linerefrecid that were processed in matching
        try
        {
            //vendInvoiceInfoSubLineSumAll now contains all the matching data generated in current run
            VendInvoiceInfoLine vendInvoiceInfoLine;
            VendInvoiceInfoSubLineSumAll vendInvoiceInfoSubLineSumAll;

            vendInvoiceInfoLine.skipDataMethods(true);
            vendInvoiceInfoLine.skipDatabaseLog(true);
            vendInvoiceInfoLine.skipEvents(true);

            //using _vendInvoiceInfoSubLineTmp for an exist join to only update the invoice lines that were actually matched this run
            update_recordset vendInvoiceInfoLine setting
                    InventNow = vendInvoiceInfoSubLineSumAll.SumOfInventNow
                join vendInvoiceInfoSubLineSumAll
                    where  vendInvoiceInfoLine.RecId == vendInvoiceInfoSubLineSumAll.LineRefRecId
                exists join _vendInvoiceInfoSubLineTmp
                    where _vendInvoiceInfoSubLineTmp.LineRefRecId == vendInvoiceInfoLine.RecId;
        }
        catch (Exception::Deadlock)
        {
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= MaxRetryAttempts)
            {
                sleep(xSession::currentRetryCount() * backOffWait);
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= MaxRetryAttempts)
            {
                retry;
            }
            else
            {
                throw;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendInvoiceInfoLineFromMatchedV2</Name>
				<Source><![CDATA[
    private static void updateVendInvoiceInfoLineFromMatchedV2(VendInvoiceInfoSubLineTmpV2 _vendInvoiceInfoSubLineTmp)
    {
        //_vendInvoiceInfoSubLineTmp is used for the list of linerefrecid that were processed in matching
        try
        {
            //vendInvoiceInfoSubLineSumAll now contains all the matching data generated in current run
            VendInvoiceInfoLine vendInvoiceInfoLine;
            VendInvoiceInfoSubLineSumAll vendInvoiceInfoSubLineSumAll;

            vendInvoiceInfoLine.skipDataMethods(true);
            vendInvoiceInfoLine.skipDatabaseLog(true);
            vendInvoiceInfoLine.skipEvents(true);

            //using _vendInvoiceInfoSubLineTmp for an exist join to only update the invoice lines that were actually matched this run
            update_recordset vendInvoiceInfoLine 
                setting InventNow = vendInvoiceInfoSubLineSumAll.SumOfInventNow
                join vendInvoiceInfoSubLineSumAll
                    where vendInvoiceInfoLine.RecId == vendInvoiceInfoSubLineSumAll.LineRefRecId
                exists join _vendInvoiceInfoSubLineTmp
                    where _vendInvoiceInfoSubLineTmp.LineRefRecId == vendInvoiceInfoLine.RecId;
        }
        catch (Exception::Deadlock)
        {
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= MaxRetryAttempts)
            {
                sleep(xSession::currentRetryCount() * backOffWait);
                retry;
            }
            else
            {
                throw;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0 && xSession::currentRetryCount() <= MaxRetryAttempts)
            {
                retry;
            }
            else
            {
                throw;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rankVendInvoiceInfoSubLineForMatching</Name>
				<Source><![CDATA[
    [SysObsolete("The method has been deprecated use rankVendInvoiceInfoSubLineForMatchingV2 instead", false, 04\11\2022)]
    private static boolean rankVendInvoiceInfoSubLineForMatching(VendInvoiceInfoSubLineTmp _vendInvoiceInfoSubLineTmp)
    {
        VendInvoiceInfoSubLineShadow::removeStaleVendInvoiceInfoSubLineShadowRecords();

        boolean nextRunRequired = false;
        using (ReqReaderWriterLock reqReaderWriterLock = ReqReaderWriterLock::construct())
        {
            try
            {
                if (reqReaderWriterLock.tryEnterWriterLock("Rank sublines"))
                {
                    VendInvoiceInfoSubLineShadow subLineShadow;

                    ttsbegin;

                    //VendInvoiceInfoSubLineShadow table is used in preparation of view VendInvoiceInfoSubLineShadowRanked
                    insert_recordset subLineShadow(JournalRefRecId, LineRefRecId, OrigRefPurchId)
                        select JournalRefRecId, LineRefRecId, OrigRefPurchId from _vendInvoiceInfoSubLineTmp;

                    VendInvoiceInfoSubLineShadowRanked subLineRanked;

                    if (VendorInvoiceAutomationMatchMinPackingSlipFeature::instance().isEnabled())
                    {
                        select firstonly minof(RankByLineRefRecId), RankByJournalRefRecId from subLineRanked
                            group by RankByJournalRefRecId
                            where subLineRanked.RankByOrigRefPurchId == 1;

                        int rankByLineRefRecIdMin = subLineRanked.RankByLineRefRecId;
                        int rankByJournalRefRecIdMin = subLineRanked.RankByJournalRefRecId;

                        select firstonly RecId from _vendInvoiceInfoSubLineTmp
                            exists join subLineRanked
                                where _vendInvoiceInfoSubLineTmp.JournalRefRecId == subLineRanked.JournalRefRecId
                                        && _vendInvoiceInfoSubLineTmp.LineRefRecId == subLineRanked.LineRefRecId
                                        && _vendInvoiceInfoSubLineTmp.OrigRefPurchId == subLineRanked.OrigRefPurchId
                                        && !(subLineRanked.RankByOrigRefPurchId == 1
                                        && subLineRanked.RankByLineRefRecId == rankByLineRefRecIdMin
                                        && subLineRanked.RankByJournalRefRecId == rankByJournalRefRecIdMin);

                        if (_vendInvoiceInfoSubLineTmp.RecId)
                        {
                            nextRunRequired = true;

                            delete_from _vendInvoiceInfoSubLineTmp
                                exists join subLineRanked
                                    where _vendInvoiceInfoSubLineTmp.JournalRefRecId == subLineRanked.JournalRefRecId
                                            && _vendInvoiceInfoSubLineTmp.LineRefRecId == subLineRanked.LineRefRecId
                                            && _vendInvoiceInfoSubLineTmp.OrigRefPurchId == subLineRanked.OrigRefPurchId
                                            && !(subLineRanked.RankByOrigRefPurchId == 1
                                            && subLineRanked.RankByLineRefRecId == rankByLineRefRecIdMin
                                            && subLineRanked.RankByJournalRefRecId == rankByJournalRefRecIdMin);
                        }
                    }
                    else 
                    {
                        select firstonly RecId from _vendInvoiceInfoSubLineTmp
                            exists join subLineRanked
                            where _vendInvoiceInfoSubLineTmp.JournalRefRecId == subLineRanked.JournalRefRecId
                                && _vendInvoiceInfoSubLineTmp.LineRefRecId == subLineRanked.LineRefRecId
                                && _vendInvoiceInfoSubLineTmp.OrigRefPurchId == subLineRanked.OrigRefPurchId
                                && subLineRanked.RankByJournalRefRecId != subLineRanked.RankByLineRefRecId
                                && subLineRanked.RankByLineRefRecId == subLineRanked.RankByOrigRefPurchId
                                && subLineRanked.RankByOrigRefPurchId != subLineRanked.RankByJournalRefRecId;

                        if(_vendInvoiceInfoSubLineTmp.RecId)
                        {
                            nextRunRequired = true;
                            delete_from _vendInvoiceInfoSubLineTmp
                                exists join subLineRanked
                                where _vendInvoiceInfoSubLineTmp.JournalRefRecId == subLineRanked.JournalRefRecId
                                    && _vendInvoiceInfoSubLineTmp.LineRefRecId == subLineRanked.LineRefRecId
                                    && _vendInvoiceInfoSubLineTmp.OrigRefPurchId == subLineRanked.OrigRefPurchId
                                    && subLineRanked.RankByJournalRefRecId != subLineRanked.RankByLineRefRecId
                                    && subLineRanked.RankByLineRefRecId == subLineRanked.RankByOrigRefPurchId
                                    && subLineRanked.RankByOrigRefPurchId != subLineRanked.RankByJournalRefRecId;
                        }
                    }
                    
                    delete_from subLineShadow;

                    ttscommit;
                }
            }
            catch
            {
                var currentRetryCount = xSession::currentRetryCount();

                if (currentRetryCount >= MaxRetryAttempts)
                {
                    throw Exception::Error;
                }
                else
                {
                    sleep(currentRetryCount * backOffWait);
                    retry;
                }
            }
            finally
            {
                reqReaderWriterLock.releaseAllLocks();
            }
        }
	
        return nextRunRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>rankVendInvoiceInfoSubLineForMatchingV2</Name>
				<Source><![CDATA[
    private static boolean rankVendInvoiceInfoSubLineForMatchingV2(VendInvoiceInfoSubLineTmpV2 _vendInvoiceInfoSubLineTmp)
    {
        VendInvoiceInfoSubLineShadowV2::removeStaleVendInvoiceInfoSubLineShadowRecords();

        boolean nextRunRequired = false;
        using (ReqReaderWriterLock reqReaderWriterLock = ReqReaderWriterLock::construct())
        {
            try
            {
                if (reqReaderWriterLock.tryEnterWriterLock("Rank sublines"))
                {
                    VendInvoiceInfoSubLineShadowV2 subLineShadow;

                    ttsbegin;

                    //VendInvoiceInfoSubLineShadow table is used in preparation of view VendInvoiceInfoSubLineShadowRanked
                    insert_recordset subLineShadow(JournalRefRecId, LineRefRecId, PurchLineRecId, DeliveryDate, InvoiceCreatedDate)
                        select JournalRefRecId, LineRefRecId, PurchLineRecId, DeliveryDate, InvoiceCreatedDate from _vendInvoiceInfoSubLineTmp;

                    VendInvoiceInfoSubLineShadowRankedV2 subLineRanked;

                    select firstonly RecId from _vendInvoiceInfoSubLineTmp
                        exists join subLineRanked
                        where _vendInvoiceInfoSubLineTmp.JournalRefRecId == subLineRanked.JournalRefRecId
                            && _vendInvoiceInfoSubLineTmp.LineRefRecId == subLineRanked.LineRefRecId
                            && _vendInvoiceInfoSubLineTmp.PurchLineRecId == subLineRanked.PurchLineRecId
                            && (subLineRanked.RankByJournalRefRecId != 1
                            || subLineRanked.RankByLineRefRecId != 1);

                    if(_vendInvoiceInfoSubLineTmp.RecId)
                    {
                        nextRunRequired = true;
                        delete_from _vendInvoiceInfoSubLineTmp
                            exists join subLineRanked
                            where _vendInvoiceInfoSubLineTmp.JournalRefRecId == subLineRanked.JournalRefRecId
                                && _vendInvoiceInfoSubLineTmp.LineRefRecId == subLineRanked.LineRefRecId
                                && _vendInvoiceInfoSubLineTmp.PurchLineRecId == subLineRanked.PurchLineRecId
                                && (subLineRanked.RankByJournalRefRecId != 1
                                || subLineRanked.RankByLineRefRecId != 1);
                    }
                    
                    delete_from subLineShadow;

                    ttscommit;
                }
            }
            catch
            {
                var currentRetryCount = xSession::currentRetryCount();

                if (currentRetryCount >= MaxRetryAttempts)
                {
                    throw Exception::Error;
                }
                else
                {
                    sleep(currentRetryCount * backOffWait);
                    retry;
                }
            }
            finally
            {
                reqReaderWriterLock.releaseAllLocks();
            }
        }
 
        return nextRunRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendPackingSlipTrans</Name>
				<Source><![CDATA[
    [SysObsolete("The method has been deprecated use addFieldMappingsVendPackingSlipTransV2 instead", false, 04\11\2022)]
    private static void addFieldMappingsVendPackingSlipTrans(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, RecId), fieldStr(VendPackingSlipTrans, RecId), fieldStr(VendInvoiceInfoSubLineTmp, JournalRefRecId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, PackingSlipId), fieldStr(VendPackingSlipTrans, PackingSlipId), fieldStr(VendInvoiceInfoSubLineTmp, DocumentId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, Qty), fieldStr(VendPackingSlipTrans, Qty), fieldStr(VendInvoiceInfoSubLineTmp, ReceiveNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, InventQty), fieldStr(VendPackingSlipTrans, InventQty), fieldStr(VendInvoiceInfoSubLineTmp, InventNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, PdsCWQty), fieldStr(VendPackingSlipTrans, PdsCWQty), fieldStr(VendInvoiceInfoSubLineTmp, PdsCWInventNow));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendInvoiceLine</Name>
				<Source><![CDATA[
    [SysObsolete("The method has been deprecated use addFieldMappingsVendInvoiceLineV2 instead", false, 04\11\2022)]
    private static void addFieldMappingsVendInvoiceLine(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, RecId), fieldStr(VendInvoiceInfoLine, RecId), fieldStr(VendInvoiceInfoSubLineTmp, LineRefRecId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, ParmId), fieldStr(VendInvoiceInfoLine, ParmId), fieldStr(VendInvoiceInfoSubLineTmp, ParmId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, OrigPurchId), fieldStr(VendInvoiceInfoLine, OrigPurchId), fieldStr(VendInvoiceInfoSubLineTmp, OrigRefPurchId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendPackingSlipTransV2</Name>
				<Source><![CDATA[
    private static void addFieldMappingsVendPackingSlipTransV2(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, RecId), fieldStr(VendPackingSlipTrans, RecId), fieldStr(VendInvoiceInfoSubLineTmpV2, JournalRefRecId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, PackingSlipId), fieldStr(VendPackingSlipTrans, PackingSlipId), fieldStr(VendInvoiceInfoSubLineTmpV2, DocumentId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, Qty), fieldStr(VendPackingSlipTrans, Qty), fieldStr(VendInvoiceInfoSubLineTmpV2, ReceiveNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, InventQty), fieldStr(VendPackingSlipTrans, InventQty), fieldStr(VendInvoiceInfoSubLineTmpV2, InventNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, PdsCWQty), fieldStr(VendPackingSlipTrans, PdsCWQty), fieldStr(VendInvoiceInfoSubLineTmpV2, PdsCWInventNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendPackingSlipTrans, DeliveryDate), fieldStr(VendPackingSlipTrans, DeliveryDate), fieldStr(VendInvoiceInfoSubLineTmpV2, DeliveryDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendInvoiceLineV2</Name>
				<Source><![CDATA[
    private static void addFieldMappingsVendInvoiceLineV2(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, RecId), fieldStr(VendInvoiceInfoLine, RecId), fieldStr(VendInvoiceInfoSubLineTmpV2, LineRefRecId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, ParmId), fieldStr(VendInvoiceInfoLine, ParmId), fieldStr(VendInvoiceInfoSubLineTmpV2, ParmId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, PurchLineRecId), fieldStr(VendInvoiceInfoLine, PurchLineRecId), fieldStr(VendInvoiceInfoSubLineTmpV2, PurchLineRecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendInvoiceHeader</Name>
				<Source><![CDATA[
    private static void addFieldMappingsVendInvoiceHeader(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoTable, CreatedDateTime), fieldStr(VendInvoiceInfoTable, CreatedDateTime), fieldStr(VendInvoiceInfoSubLineTmpV2, InvoiceCreatedDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFieldMappingsVendInvoiceLineForTmpTable</Name>
				<Source><![CDATA[
    private static void addFieldMappingsVendInvoiceLineForTmpTable(QueryBuildDataSource _queryBuildDataSource, QueryBuildFieldList _queryBuildFieldList, Map _insertRecordsetMap)
    {
        int dataSourceUniqueId = _queryBuildDataSource.uniqueId();
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, RecId), fieldStr(VendInvoiceInfoLine, RecId), fieldStr(VendInvoiceLineMatchingTmp, RefRecId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, ParmId), fieldStr(VendInvoiceInfoLine, ParmId), fieldStr(VendInvoiceLineMatchingTmp, ParmId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, TableRefId), fieldStr(VendInvoiceInfoLine, TableRefId), fieldStr(VendInvoiceLineMatchingTmp, TableRefId));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, ReceiveNow), fieldStr(VendInvoiceInfoLine, ReceiveNow), fieldStr(VendInvoiceLineMatchingTmp, ReceiveNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, InventNow), fieldStr(VendInvoiceInfoLine, InventNow), fieldStr(VendInvoiceLineMatchingTmp, InventNow));
        VendInvoiceMatch::addInsertFieldMapping(_queryBuildFieldList, _insertRecordsetMap, dataSourceUniqueId, fieldNum(VendInvoiceInfoLine, PdsCWReceiveNow), fieldStr(VendInvoiceInfoLine, PdsCWReceiveNow), fieldStr(VendInvoiceLineMatchingTmp, PdsCWReceiveNow));
    }

]]></Source>
			</Method>
			<Method>
				<Name>addInsertFieldMapping</Name>
				<Source><![CDATA[
    private static void addInsertFieldMapping(QueryBuildFieldList _fieldList, Map _fieldMapping, int _sourceTableUniqueId, FieldId _sourceFieldId, FieldName _sourceFieldName, FieldName _destinationFieldName)
    {
        _fieldList.addField(_sourceFieldId);
        _fieldMapping.insert(_destinationFieldName, [_sourceTableUniqueId, _sourceFieldName]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultQuantityPackingSlip</Name>
				<Source><![CDATA[
    [SysObsolete("The method has been deprecated use defaultQuantityPackingSlipV2 instead", false, 04\11\2022)]
    private static void defaultQuantityPackingSlip(
        VendInvoiceLineMatchingTmp _vendInvoiceLineMatchingTmp,
        VendInvoiceInfoSubLineTmp _vendInvoiceInfoSubLineTmp)
    {
        VendPackingSlipTrans vendPackingSlipTrans;
        VendInvoiceInfoSubLineSum vendInvoiceInfoSubLineSum;
        VendInvoiceInfoSubLineSumAll vendInvoiceInfoSubLineSumAll;
        VendInvoicePackingSlipQuantityMatchSum vendInvoicePackingSlipQuantityMatchSum;

        // Set quantities, reducing them for quantities already used on posted invoices
        // Using VendInvoiceInfoSubLineTmp to minimize time concurrent sessions work on VendInvoiceInfoSubLine table, will minimize DB locks.
        _vendInvoiceInfoSubLineTmp.skipDataMethods(true);
        _vendInvoiceInfoSubLineTmp.skipDatabaseLog(true);
        _vendInvoiceInfoSubLineTmp.skipEvents(true);
        _vendInvoiceInfoSubLineTmp.skipDeleteActions(true);
        _vendInvoiceInfoSubLineTmp.skipDeleteMethod(true);

        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceInfoSubLineTmp.ReceiveNow - vendInvoicePackingSlipQuantityMatchSum.SumOfQuantity,
            InventNow = _vendInvoiceInfoSubLineTmp.InventNow - vendInvoicePackingSlipQuantityMatchSum.SumOfInventQuantity,
            PdsCWInventNow = _vendInvoiceInfoSubLineTmp.PdsCWInventNow - vendInvoicePackingSlipQuantityMatchSum.SumOfPdsCWQuantity
        join _vendInvoiceLineMatchingTmp
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == _vendInvoiceInfoSubLineTmp.JournalRefRecId
        join vendInvoicePackingSlipQuantityMatchSum
            where vendInvoicePackingSlipQuantityMatchSum.PackingSlipSourceDocumentLine == vendPackingSlipTrans.SourceDocumentLine;

        // Reduce the subline for quantities already used on other unposted invoices
        // Not having the JournalRefTableId set during initial population of the VendInvoiceInfoSubLine,
        // the lines of the current invoice will be excluded
        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceInfoSubLineTmp.ReceiveNow - vendInvoiceInfoSubLineSum.SumOfReceiveNow,
            InventNow = _vendInvoiceInfoSubLineTmp.InventNow - vendInvoiceInfoSubLineSum.SumOfInventNow,
            PdsCWInventNow = _vendInvoiceInfoSubLineTmp.PdsCWInventNow - vendInvoiceInfoSubLineSum.SumOfPdsCWInventNow
        join _vendInvoiceLineMatchingTmp
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == _vendInvoiceInfoSubLineTmp.JournalRefRecId
        join vendInvoiceInfoSubLineSum
            where vendInvoiceInfoSubLineSum.JournalRefTableId == vendPackingSlipTrans.TableId &&
                  vendInvoiceInfoSubLineSum.JournalRefRecId == vendPackingSlipTrans.RecId;
        
        VendInvoiceInfoSubLineTmp vendInvoiceInfoSubLineSumAllTmp;

        // Generate sum of quantity for VendInvoiceInfoSubLines in matching currently
        insert_recordset vendInvoiceInfoSubLineSumAllTmp(
            ReceiveNow,
            InventNow,
            PdsCWInventNow,
            LineRefRecId)
        select
            sum(ReceiveNow),
            sum(InventNow),
            sum(PdsCWInventNow),
            LineRefRecId
        from _vendInvoiceInfoSubLineTmp
            group by LineRefRecId;

        // Add previously matched quantity to current sum of quantity for VendInvoiceInfoSubLines in matching currently
        update_recordset vendInvoiceInfoSubLineSumAllTmp setting
            ReceiveNow = vendInvoiceInfoSubLineSumAllTmp.ReceiveNow + vendInvoiceInfoSubLineSumAll.SumOfReceiveNow,
            InventNow = vendInvoiceInfoSubLineSumAllTmp.InventNow + vendInvoiceInfoSubLineSumAll.SumOfInventNow,
            PdsCWInventNow = vendInvoiceInfoSubLineSumAllTmp.PdsCWInventNow + vendInvoiceInfoSubLineSumAll.SumOfPdsCWInventNow
        join vendInvoiceInfoSubLineSumAll
                where vendInvoiceInfoSubLineSumAll.LineRefRecId == vendInvoiceInfoSubLineSumAllTmp.LineRefRecId;

        VendInvoiceInfoLineQuantities vendInvoiceInfoLineQty;
        // Correct subline records for any line where the sum of the sublines is greater than the line qty for records that are matched first time. 
        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceInfoSubLineTmp.ReceiveNow - (vendInvoiceInfoSubLineSumAllTmp.ReceiveNow - _vendInvoiceLineMatchingTmp.ReceiveNow),
            InventNow = _vendInvoiceInfoSubLineTmp.InventNow - (vendInvoiceInfoSubLineSumAllTmp.InventNow - _vendInvoiceLineMatchingTmp.InventNow),
            PdsCWInventNow = _vendInvoiceInfoSubLineTmp.PdsCWInventNow - (vendInvoiceInfoSubLineSumAllTmp.PdsCWInventNow - _vendInvoiceLineMatchingTmp.PdsCWReceiveNow)
        join _vendInvoiceLineMatchingTmp
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
        join vendInvoiceInfoSubLineSumAllTmp
            where vendInvoiceInfoSubLineSumAllTmp.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId &&
                  ((_vendInvoiceLineMatchingTmp.ReceiveNow < vendInvoiceInfoSubLineSumAllTmp.ReceiveNow && _vendInvoiceLineMatchingTmp.ReceiveNow > 0) ||
                    (_vendInvoiceLineMatchingTmp.ReceiveNow > vendInvoiceInfoSubLineSumAllTmp.ReceiveNow && vendInvoiceInfoSubLineSumAllTmp.ReceiveNow < 0))
        notexists join vendInvoiceInfoLineQty
            where vendInvoiceInfoLineQty.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId;

        // Correct subline records for any line where the sum of the sublines is greater than the line qty for records that already attempted matching.
        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceInfoSubLineTmp.ReceiveNow - (vendInvoiceInfoSubLineSumAllTmp.ReceiveNow - _vendInvoiceLineMatchingTmp.ReceiveNow),
            InventNow = _vendInvoiceInfoSubLineTmp.InventNow - (vendInvoiceInfoSubLineSumAllTmp.InventNow - vendInvoiceInfoLineQty.InventNow),
            PdsCWInventNow = _vendInvoiceInfoSubLineTmp.PdsCWInventNow - (vendInvoiceInfoSubLineSumAllTmp.PdsCWInventNow - _vendInvoiceLineMatchingTmp.PdsCWReceiveNow)
        join _vendInvoiceLineMatchingTmp
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
        join vendInvoiceInfoSubLineSumAllTmp
            where vendInvoiceInfoSubLineSumAllTmp.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId &&
                  ((_vendInvoiceLineMatchingTmp.ReceiveNow < vendInvoiceInfoSubLineSumAllTmp.ReceiveNow && _vendInvoiceLineMatchingTmp.ReceiveNow > 0) ||
                    (_vendInvoiceLineMatchingTmp.ReceiveNow > vendInvoiceInfoSubLineSumAllTmp.ReceiveNow && vendInvoiceInfoSubLineSumAllTmp.ReceiveNow < 0))
        join vendInvoiceInfoLineQty
            where vendInvoiceInfoLineQty.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId;

        // Delete subline records that have less than zero quantity remaining
        delete_from _vendInvoiceInfoSubLineTmp
            exists join _vendInvoiceLineMatchingTmp
                where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId &&
                     ((_vendInvoiceInfoSubLineTmp.ReceiveNow <= 0 && _vendInvoiceLineMatchingTmp.ReceiveNow > 0) ||
                        (_vendInvoiceInfoSubLineTmp.ReceiveNow >= 0 && _vendInvoiceLineMatchingTmp.ReceiveNow < 0));

        // Generate VendInvoiceInfoSubLine records
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        vendInvoiceInfoSubLine.skipDataMethods(true);
        vendInvoiceInfoSubLine.skipDatabaseLog(true);
        vendInvoiceInfoSubLine.skipEvents(true);

        RefTableId PackingSlipTransTableId = tableNum(VendPackingSlipTrans);

        insert_recordset vendInvoiceInfoSubLine(
            JournalRefRecId,
            JournalRefTableId,
            DocumentId,
            ReceiveNow,
            InventNow,
            PdsCWInventNow,
            LineRefRecId,
            ParmId)
        select
            JournalRefRecId,
            PackingSlipTransTableId,
            DocumentId,
            ReceiveNow,
            InventNow,
            PdsCWInventNow,
            LineRefRecId,
            ParmId
        from _vendInvoiceInfoSubLineTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultQuantityPackingSlipV2</Name>
				<Source><![CDATA[
    private static void defaultQuantityPackingSlipV2(
        VendInvoiceLineMatchingTmp _vendInvoiceLineMatchingTmp,
        VendInvoiceInfoSubLineTmpV2 _vendInvoiceInfoSubLineTmp)
    {
        VendPackingSlipTrans vendPackingSlipTrans;
        VendInvoiceInfoSubLineSum vendInvoiceInfoSubLineSum;
        VendInvoiceInfoSubLineSumAll vendInvoiceInfoSubLineSumAll;
        VendInvoicePackingSlipQuantityMatchSum vendInvoicePackingSlipQuantityMatchSum;

        // Set quantities, reducing them for quantities already used on posted invoices
        // Using VendInvoiceInfoSubLineTmp to minimize time concurrent sessions work on VendInvoiceInfoSubLine table, will minimize DB locks.
        _vendInvoiceInfoSubLineTmp.skipDataMethods(true);
        _vendInvoiceInfoSubLineTmp.skipDatabaseLog(true);
        _vendInvoiceInfoSubLineTmp.skipEvents(true);
        _vendInvoiceInfoSubLineTmp.skipDeleteActions(true);
        _vendInvoiceInfoSubLineTmp.skipDeleteMethod(true);

        // Calculate available quantity of product receipt line
        // Reduce the subline for quantities already used on posted invoices
        // Not having the JournalRefTableId set during initial population of the VendInvoiceInfoSubLine,
        // the lines of the current invoice will be excluded
        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceInfoSubLineTmp.ReceiveNow - vendInvoicePackingSlipQuantityMatchSum.SumOfQuantity,
            InventNow = _vendInvoiceInfoSubLineTmp.InventNow - vendInvoicePackingSlipQuantityMatchSum.SumOfInventQuantity,
            PdsCWInventNow = _vendInvoiceInfoSubLineTmp.PdsCWInventNow - vendInvoicePackingSlipQuantityMatchSum.SumOfPdsCWQuantity
        join _vendInvoiceLineMatchingTmp
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == _vendInvoiceInfoSubLineTmp.JournalRefRecId
        join vendInvoicePackingSlipQuantityMatchSum
            where vendInvoicePackingSlipQuantityMatchSum.PackingSlipSourceDocumentLine == vendPackingSlipTrans.SourceDocumentLine;

        // Reduce the subline for quantities already used on other unposted invoices
        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceInfoSubLineTmp.ReceiveNow - vendInvoiceInfoSubLineSum.SumOfReceiveNow,
            InventNow = _vendInvoiceInfoSubLineTmp.InventNow - vendInvoiceInfoSubLineSum.SumOfInventNow,
            PdsCWInventNow = _vendInvoiceInfoSubLineTmp.PdsCWInventNow - vendInvoiceInfoSubLineSum.SumOfPdsCWInventNow
        join _vendInvoiceLineMatchingTmp 
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
        join vendPackingSlipTrans
            where vendPackingSlipTrans.RecId == _vendInvoiceInfoSubLineTmp.JournalRefRecId
        join vendInvoiceInfoSubLineSum
            where vendInvoiceInfoSubLineSum.JournalRefTableId == vendPackingSlipTrans.TableId &&
                  vendInvoiceInfoSubLineSum.JournalRefRecId == vendPackingSlipTrans.RecId;
        
        VendInvoiceInfoLineQuantities vendInvoiceInfoLineQty;
        // Calculate available quantity of invoice lines for records that are matched first time.
        // Reduce for quantities already matched
        update_recordset _vendInvoiceLineMatchingTmp setting
            ReceiveNow = _vendInvoiceLineMatchingTmp.ReceiveNow - vendInvoiceInfoSubLineSumAll.SumOfReceiveNow,
            InventNow = _vendInvoiceLineMatchingTmp.InventNow - vendInvoiceInfoSubLineSumAll.SumOfInventNow,
            PdsCWReceiveNow = _vendInvoiceLineMatchingTmp.PdsCWReceiveNow - vendInvoiceInfoSubLineSumAll.SumOfPdsCWInventNow
        join vendInvoiceInfoSubLineSumAll
                where vendInvoiceInfoSubLineSumAll.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId
        notexists join vendInvoiceInfoLineQty
            where vendInvoiceInfoLineQty.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId;

        // Calculate available quantity of invoice line for records that are already attempted matching.
        // Reduce for quantities already matched
        update_recordset _vendInvoiceLineMatchingTmp setting
            ReceiveNow = _vendInvoiceLineMatchingTmp.ReceiveNow - vendInvoiceInfoSubLineSumAll.SumOfReceiveNow,
            InventNow = vendInvoiceInfoLineQty.InventNow - vendInvoiceInfoSubLineSumAll.SumOfInventNow,
            PdsCWReceiveNow = _vendInvoiceLineMatchingTmp.PdsCWReceiveNow - vendInvoiceInfoSubLineSumAll.SumOfPdsCWInventNow
        join vendInvoiceInfoSubLineSumAll
                where vendInvoiceInfoSubLineSumAll.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId
        join vendInvoiceInfoLineQty
            where vendInvoiceInfoLineQty.LineRefRecId == _vendInvoiceLineMatchingTmp.RefRecId;

        // Correct subline records for any line where invoice available quantity is less than product receipt quantity.
        update_recordset _vendInvoiceInfoSubLineTmp setting
            ReceiveNow = _vendInvoiceLineMatchingTmp.ReceiveNow,
            InventNow = _vendInvoiceLineMatchingTmp.InventNow,
            PdsCWInventNow = _vendInvoiceLineMatchingTmp.PdsCWReceiveNow
        join _vendInvoiceLineMatchingTmp
            where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId
            && ((_vendInvoiceLineMatchingTmp.ReceiveNow < _vendInvoiceInfoSubLineTmp.ReceiveNow && _vendInvoiceLineMatchingTmp.ReceiveNow > 0) ||
                (_vendInvoiceLineMatchingTmp.ReceiveNow > _vendInvoiceInfoSubLineTmp.ReceiveNow && _vendInvoiceLineMatchingTmp.ReceiveNow < 0));

        // Delete subline records that have less than zero quantity remaining
        delete_from _vendInvoiceInfoSubLineTmp
            exists join _vendInvoiceLineMatchingTmp
                where _vendInvoiceLineMatchingTmp.RefRecId == _vendInvoiceInfoSubLineTmp.LineRefRecId &&
                     ((_vendInvoiceInfoSubLineTmp.ReceiveNow <= 0 && _vendInvoiceLineMatchingTmp.ReceiveNow > 0) ||
                        (_vendInvoiceInfoSubLineTmp.ReceiveNow >= 0 && _vendInvoiceLineMatchingTmp.ReceiveNow < 0));

        // Generate VendInvoiceInfoSubLine records
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        vendInvoiceInfoSubLine.skipDataMethods(true);
        vendInvoiceInfoSubLine.skipDatabaseLog(true);
        vendInvoiceInfoSubLine.skipEvents(true);

        RefTableId PackingSlipTransTableId = tableNum(VendPackingSlipTrans);

        insert_recordset vendInvoiceInfoSubLine(
            JournalRefRecId,
            JournalRefTableId,
            DocumentId,
            ReceiveNow,
            InventNow,
            PdsCWInventNow,
            LineRefRecId,
            ParmId)
        select
            JournalRefRecId,
            PackingSlipTransTableId,
            DocumentId,
            ReceiveNow,
            InventNow,
            PdsCWInventNow,
            LineRefRecId,
            ParmId
        from _vendInvoiceInfoSubLineTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>