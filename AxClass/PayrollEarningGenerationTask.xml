<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PayrollEarningGenerationTask</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>PayrollEarningGenerationTask</c> class provides functions for creating recurring earning and salary earnings.
/// It also provide a function for adjusting salary earning line for a given worker and position.
/// </summary>
class PayrollEarningGenerationTask extends RunBaseBatch implements BatchRetryable
{
    #PayrollConstants
    TransDate               startDate, toDate;
    utcdatetime             startDateTime, toDateTime;
    PayrollPayPeriodRecId   payPeriodRecId;
    PayrollPayCycleRecId    payCycleRecId;
    LegalEntityRecId        legalEntityRecId;
    PayrollTimePeriod       timePeriod;
    int                     daysInYear;

    HcmWorkerRecId          workerRecId;
    HcmPositionRecId        positionRecId;
    PayrollPositionDetails  positiondetail;
    PayrollEarningStatementRecId    currentStatementRecId;
    PayrollWorkerTaxRegionRecId     currentWorkerTaxRegionRecId;
    RefRecId                        currentWorkerCompensationBenefit;

    // Schedule related variables
    boolean                 scheduleEnabledForPosition;
    List                    daysInPeriod;
    ListEnumerator          daysInPeriodEnumerator;
    Set                     unpaidLeaveDays;

    Map                     workCalendarDateLineMap;
    Map                     workCalendarDefinedMap;

    // This set stores the list of earning statement that are created or updated by the process
    Set                     earningStatementSet;
    boolean                 maintainEarningStatementSet;
    #PayrollConstants

    container               batchTaskGroupList;

    #DEFINE.CurrentVersion(1)

    #LOCALMACRO.CurrentList
        payPeriodRecId,
        batchTaskGroupList
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>cleanupWorkerScheduleEarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes the existing earning statement line records for the specified generation source.
    /// </summary>
    private void cleanupWorkerScheduleEarnings()
    {
        PayrollEarningStatementLine     payrollEarningStatementLine;

        // Cleanup old pre-existing auto generated leave and Position Schedule ESLs data
        if (currentStatementRecId)
        {
            ttsbegin;

            while select forupdate * from payrollEarningStatementLine
                where payrollEarningStatementLine.EarningStatement == currentStatementRecId
                    && payrollEarningStatementLine.Position == positionRecId
                    && payrollEarningStatementLine.IsEdited == false
                    && payrollEarningStatementLine.PaymentStatus != PayrollPaymentProcessingStatus::Processed
                    && (payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::PositionSchedule
                    || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::WorkerLeave)

            {
                payrollEarningStatementLine.delete(true);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEarningStatementForWorker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a record in the <c>PayrollEarningStatement</c> table if no matching record for the worker within the current LE and pay period.
    /// </summary>
    private void createEarningStatementForWorker()
    {
        PayrollEarningStatement         earningStatement;
        NumberSeq                       numberSeq;

        //create a statement
        if (currentStatementRecId == 0)
        {
            numberSeq = NumberSeq::newGetNum(PayrollParameters::numRefEarningStatDocumentNumber());
            earningStatement.DocumentNumber = numberSeq.num();
            earningStatement.Worker = workerRecId;
            earningStatement.PayPeriod = payPeriodRecId;
            earningStatement.AutoGeneratedSalary = PayrollAutoGenerateSalary::Active;
            if (earningStatement.validateWrite())
            {
                earningStatement.insert();
            }
            currentStatementRecId = earningStatement.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRecurringLine</Name>
				<Source><![CDATA[
    private PayrollEarningStatementLineRecId createRecurringLine(PayrollEarningCodeRecId _earningRecId, AmountMST _amount)
    {
        PayrollEarningStatementLine   earningStatementLine;

        earningStatementLine.clear();
        earningStatementLine.GenerationSource = PayrollGenerationSource::Recurring;
        earningStatementLine.PaymentStatus = PayrollPaymentProcessingStatus::None;
        earningStatementLine.EarningStatement = currentStatementRecId;
        earningStatementLine.Position = positionRecId;
        earningStatementLine.EarningCode = _earningRecId;
        earningStatementLine.EarningDate = toDate;
        earningStatementLine.WorkerTaxRegion = currentWorkerTaxRegionRecId;
        earningStatementLine.WorkerGLIBenefit = positiondetail.DefaultGLIBenefit;
        earningStatementLine.WorkerCompensationBenefit = currentWorkerCompensationBenefit;
        earningStatementLine.AccountingCurrencyAmount = CurrencyExchange::round(_amount, PayrollSetup::currencyCode());
        earningStatementLine.Quantity = 1;
        earningStatementLine.EarningRate = decRound(_amount, #RateDecimalPlaces);
        earningStatementLine.setDefaultDimension();
        earningStatementLine.setAccountingDistributionTemplate();

        this.insertEarningStatementLine(earningStatementLine);

        return earningStatementLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalaryLine</Name>
				<Source><![CDATA[
    private PayrollEarningStatementLineRecId createSalaryLine(PayrollEarningCodeRecId _earningRecId, AmountMST _amount, ProjQty _hours)
    {
        PayrollEarningStatementLine   earningStatementLine;

        earningStatementLine.clear();
        earningStatementLine.GenerationSource = PayrollGenerationSource::Salary;
        earningStatementLine.PaymentStatus = PayrollPaymentProcessingStatus::None;
        earningStatementLine.EarningStatement = currentStatementRecId;
        earningStatementLine.Position = positionRecId;
        earningStatementLine.EarningCode = _earningRecId;
        earningStatementLine.EarningDate = toDate;
        earningStatementLine.WorkerTaxRegion = currentWorkerTaxRegionRecId;
        earningStatementLine.WorkerGLIBenefit = positiondetail.DefaultGLIBenefit;
        earningStatementLine.WorkerCompensationBenefit = currentWorkerCompensationBenefit;
        earningStatementLine.AccountingCurrencyAmount = CurrencyExchange::round(_amount, PayrollSetup::currencyCode());
        earningStatementLine.Quantity = _hours;
        earningStatementLine.EarningRate = (_hours == 0)? 0 : decRound(_amount/_hours, #RateDecimalPlaces);
        earningStatementLine.setDefaultDimension();
        earningStatementLine.setAccountingDistributionTemplate();

        this.insertEarningStatementLine(earningStatementLine);

        return earningStatementLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createScheduleLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the individual leave earning statement line record.
    /// </summary>
    /// <param name="_earningCodeRecId">
    /// <c>PayrollEarningCode</c> table recid value.
    /// </param>
    /// <param name="_quantity">
    /// Number of hours.
    /// </param>
    /// <param name="_earningDate">
    /// Date of earnings.
    /// </param>
    /// <param name="_earningRate">
    /// Earning rate.
    /// </param>
    /// <param name="_generationSource">
    /// The enum value which identifies the type of earning statement line to generate.
    /// </param>
    /// <returns>
    /// <c>PayrollEarningStatementLine</c> table recid value.
    /// </returns>
    private PayrollEarningStatementLineRecId createScheduleLine(PayrollEarningCodeRecId _earningCodeRecId, ProjQty _quantity, TransDate _earningDate, AmountMST _earningRate, PayrollGenerationSource _generationSource)
    {
        PayrollEarningStatementLine         earningStatementLine;

        earningStatementLine.clear();
        earningStatementLine.GenerationSource = _generationSource;
        earningStatementLine.PaymentStatus = PayrollPaymentProcessingStatus::None;
        earningStatementLine.EarningStatement = currentStatementRecId;
        earningStatementLine.Position = positionRecId;
        earningStatementLine.EarningCode = _earningCodeRecId;
        earningStatementLine.EarningDate = _earningDate;
        earningStatementLine.WorkerTaxRegion = currentWorkerTaxRegionRecId;
        earningStatementLine.WorkerGLIBenefit = positiondetail.DefaultGLIBenefit;
        earningStatementLine.WorkerCompensationBenefit = currentWorkerCompensationBenefit;

        earningStatementLine.EarningRate = _earningRate;
        earningStatementLine.Quantity = decRound(_quantity, #QuantityDecimalPlaces);
        earningStatementLine.AccountingCurrencyAmount = CurrencyExchange::round(earningStatementLine.Quantity * earningStatementLine.EarningRate, PayrollSetup::currencyCode());

        earningStatementLine.setDefaultDimension();
        earningStatementLine.setAccountingDistributionTemplate();

        this.insertEarningStatementLine(earningStatementLine);

        return earningStatementLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkerPositionLeaveEarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the leave earning statement line for a specific Worker and Position combination
    /// </summary>
    /// <param name="_workCalendarDate">
    /// The <c>WorkCalendarDate</c> table record.
    /// </param>
    /// <param name="_periodDate">
    /// The individual date value for which the leave earning statement line to generate.
    /// </param>
    private void createWorkerPositionLeaveEarnings(WorkCalendarDate _workCalendarDate, TransDate _periodDate)
    {
        PayrollEarningStatementLine         payrollEarningStatementLine;
        WorkCalendarDateLine                workCalendarDateLine;
        HcmEmploymentLeave                  hcmEmploymentLeave;
        HcmLeaveType                        hcmLeaveType;
        HcmEmployment                       hcmEmployment;
        PayrollEarningCode                  payrollEarningCode;
        PayrollEarningCodeDetail            payrollEarningCodeDetail;
        ProjQty                             scheduledHours;
        utcdatetime                         minValue, maxValue;
        AmountMST                           earningRate, earningAmount;
        PayrollWorkerPositionEarningCode    workerPositionEarningCode;
        AmountCur                           earningCodeFormula;
        PayrollEarningCode                  earningCode;

        // Use the local caching of the aggregated hours per CalendarId, TransDate.
        workCalendarDateLine = this.getNumberOfScheduledHours(_workCalendarDate.CalendarId, _workCalendarDate.TransDate);

        if (workCalendarDateLine.TransDate)
        {
            // Check if on the selected day a leave is defined for an active employment in the working LE
            minValue = DateTimeUtil::minValue();
            maxValue = DateTimeUtil::maxValue();
            while select validTimeState(minValue, maxValue) * from hcmEmploymentLeave
                where hcmEmploymentLeave.StartDate <= _periodDate && hcmEmploymentLeave.EndDate >= _periodDate
            join EarningCode from hcmLeaveType
                where hcmLeaveType.RecId == hcmEmploymentLeave.LeaveType
            exists join hcmEmployment
                where hcmEmployment.RecId == hcmEmploymentLeave.Employment
                    && hcmEmployment.LegalEntity == legalEntityRecId
                    && hcmEmployment.Worker == workerRecId
            {
                // Check if the earning code detail is active on the pay period end date.
                payrollEarningCodeDetail = PayrollEarningCodeDetail::findByEarningCode(hcmLeaveType.EarningCode, toDate);

                scheduledHours = ((workCalendarDateLine.ToTime - workCalendarDateLine.FromTime)/60)/60;

                // only if found an active earning code detail record process further
                if (payrollEarningCodeDetail.RecId)
                {
                    earningCode = PayrollEarningCode::find(hcmLeaveType.EarningCode);

                    workerPositionEarningCode = PayrollWorkerPositionEarningCode::findByWorkerPositionEarningCode(
                                workerRecId,
                                positionRecId,
                                earningCode.RecId, _periodDate);

                    if (workerPositionEarningCode)
                    {
                        earningCodeFormula = workerPositionEarningCode.Formula;
                    }
                    else
                    {
                        earningCodeFormula = payrollEarningCodeDetail.DefaultFormula;
                    }

                    earningRate = PayrollEarningGenerationTask::computeEarningRate(workerRecId,
                                                    positionRecId,
                                                    _periodDate,
                                                    payrollEarningCodeDetail.RateBasis,
                                                    PayrollPayCycle::find(payCycleRecId).TimePeriod);

                    if (earningRate != 0
                        || (earningRate == 0 && this.hasFixedCompPlan(payrollEarningCodeDetail.RateBasis, positionRecId, workerRecId, _periodDate)))
                    {
                        earningAmount = decRound(earningCodeFormula * earningRate, #RateDecimalPlaces);

                        if (currentStatementRecId == 0)
                        {
                            // create a new ES
                            this.createEarningStatementForWorker();

                            // create a statementLine
                            this.createScheduleLine(hcmLeaveType.EarningCode, scheduledHours, _periodDate, earningAmount, PayrollGenerationSource::WorkerLeave);
                        }
                        else
                        {
                            select firstonly EarningCode from payrollEarningStatementLine
                                where payrollEarningStatementLine.EarningStatement == currentStatementRecId
                                    && payrollEarningStatementLine.Position == positionRecId
                                    && payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::WorkerLeave
                                    && payrollEarningStatementLine.EarningDate == _periodDate
                                    && payrollEarningStatementLine.IsEdited == false;

                            // Not to recreate the leave if already existing leave for the date for same earning code.
                            if ((payrollEarningStatementLine && payrollEarningStatementLine.EarningCode == hcmLeaveType.EarningCode))
                            {
                                continue;
                            }
                            else
                            {
                                // Don't create a line if edited line of generation source leave or Position schedule is found for the given date.
                                select firstonly RecId from payrollEarningStatementLine
                                    where payrollEarningStatementLine.EarningStatement == currentStatementRecId
                                        && payrollEarningStatementLine.Position == positionRecId
                                        && payrollEarningStatementLine.EarningDate == _periodDate
                                        && payrollEarningStatementLine.IsEdited == true
                                        && (payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::WorkerLeave
                                            || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::PositionSchedule
                                            || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::Imported);

                                if (payrollEarningStatementLine.RecId == 0)
                                {
                                    // check for manual entries
                                    select sum(Quantity) from payrollEarningStatementLine
                                        group by EarningDate
                                        where payrollEarningStatementLine.EarningStatement == currentStatementRecId
                                            && payrollEarningStatementLine.Position == positionRecId
                                            && payrollEarningStatementLine.EarningDate == _periodDate
                                            && (payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::UserEntry
                                            || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::Imported)
                                        join RecId, IsBaseEarningsComponent from payrollEarningCode
                                        where payrollEarningCode.RecId == payrollEarningStatementLine.EarningCode
                                            && payrollEarningCode.IsBaseEarningsComponent == true
                                            && payrollEarningCode.QuantityUnit == PayrollQuantityUnit::Hours;

                                    scheduledHours = scheduledHours - payrollEarningStatementLine.Quantity;
                                    if (scheduledHours > 0)
                                    {
                                        this.createScheduleLine(hcmLeaveType.EarningCode, scheduledHours, _periodDate, earningAmount, PayrollGenerationSource::WorkerLeave);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkerPositionPosSchEarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the position schedule earning statement line for a specific Worker and Position combination
    /// </summary>
    /// <param name="_workCalendarDate">
    /// The <c>WorkCalendarDate</c> table record.
    /// </param>
    /// <param name="_periodDate">
    /// The individual date value for which the leave earning statement line to generate.
    /// </param>
    /// <param name="_payrollEarningCodeDetail">
    /// <c>PayrollEarningCodeDetail</c> table record value.
    /// </param>
    private void createWorkerPositionPosSchEarnings(WorkCalendarDate _workCalendarDate, TransDate _periodDate, PayrollEarningCodeDetail _payrollEarningCodeDetail)
    {
        WorkCalendarDateLine                workCalendarDateLine;
        PayrollWorkCalendarLine             payrollWorkCalendarLine;
        PayrollEarningCode                  payrollEarningCode;
        PayrollEarningCodeDetail            payrollEarningCodeDetail;
        PayrollEarningCodeDetail            payrollEarningCodeDetailInternal;
        PayrollEarningStatementLine         payrollEarningStatementLine;
        ProjQty                             scheduledHours;
        ProjQty                             earningStatementLineHours;
        ProjQty                             earningStatementLineManualLeaveTotalHours;
        ProjQty                             earningStatementLineScheduledHours;
        Map                                 earningCodeHours;
        MapEnumerator                       earningCodeHoursIter;
        Map                                 earningCodeManualLeave;
        MapEnumerator                       earningCodeManualLeaveIter;
        Set                                 earningCodesDefinedInSchedule = new Set (Types::Int64);
        SetEnumerator                       earningCodesDefinedInScheduleIter;
        boolean                             conflictingEarningCodesFound = false;
        boolean                             editedLeaveOrPosSchNotFoundOrAllowed = true;

        ProjQty                             earningCodeHoursScheduledHours;
        PayrollEarningCodeRecId             earningCodeHoursEarningCode;
        ProjQty                             earningCodeManualLeaveLineHours;
        PayrollEarningCodeRecId             earningCodeManualLeaveEarningCode;
        PayrollEarningCodeRecId             earningCodesDefinedInScheduleEarningCode;

        CalendarId                          currentCalendarId;
        AmountMST                           earningRate, earningAmount;
        PayrollWorkerPositionEarningCode    workerPositionEarningCode;
        AmountCur                           earningCodeFormula;
        PayrollEarningCode                  earningCode;

        // Check if the period date is in the list of excluded days for Position Schedule source ESL, if it is then no action
        if (unpaidLeaveDays.in(_periodDate))
        {
            editedLeaveOrPosSchNotFoundOrAllowed = false;
        }

        if (editedLeaveOrPosSchNotFoundOrAllowed && currentStatementRecId)
        {
            if (PayrollEarningGenerationTask::isEditedOrProcessedLineExists(currentStatementRecId, positionRecId, _periodDate))
            {
                editedLeaveOrPosSchNotFoundOrAllowed = false;
            }
        }

        if (editedLeaveOrPosSchNotFoundOrAllowed)
        {
            earningCodeHours = new Map(Types::Int64, Types::Real);
            earningCodeManualLeave = new Map(Types::Int64, Types::Real);

            currentCalendarId = WorkCalendar::defined(_workCalendarDate.CalendarId, _workCalendarDate.TransDate);
            //Find all repeating earning code schedule detail records for a day
            while select sum(ToTime), sum(FromTime) from workCalendarDateLine
                group by TransDate
                where workCalendarDateLine.CalendarId == currentCalendarId
                    && workCalendarDateLine.TransDate == _workCalendarDate.TransDate
                    && workCalendarDateLine.Effectivity > 0
            outer join EarningCode from payrollWorkCalendarLine
                group by EarningCode
                where payrollWorkCalendarLine.WorkCalendarDateLine == workCalendarDateLine.RecId
            {
                if (payrollWorkCalendarLine.EarningCode)
                {
                    // Keeping a unique set of earning codes used on shcedule details
                    if (!(earningCodesDefinedInSchedule.in(payrollWorkCalendarLine.EarningCode)))
                    {
                        earningCodesDefinedInSchedule.add(payrollWorkCalendarLine.EarningCode);
                    }
                    // Get the active earning code detail on the pay period end date.
                    payrollEarningCodeDetail = PayrollEarningCodeDetail::findByEarningCode(payrollWorkCalendarLine.EarningCode, toDate);

                    if (payrollEarningCodeDetail.RecId == 0)
                    {
                        // Use the fallback default earning code if assigned earning code on schedule detail is found to be inactive.
                        payrollEarningCodeDetail = _payrollEarningCodeDetail;
                    }
                }
                else
                {
                    // using the fallback earning code on position detail
                    payrollEarningCodeDetail = _payrollEarningCodeDetail;
                }

                if (payrollEarningCodeDetail.RecId)
                {
                    scheduledHours = ((workCalendarDateLine.ToTime - workCalendarDateLine.FromTime)/60)/60;
                    earningStatementLineScheduledHours += scheduledHours;

                    if (earningCodeHours.exists(payrollEarningCodeDetail.EarningCode))
                    {
                        // Add the hours on repeating earning codes
                        scheduledHours += earningCodeHours.lookup(payrollEarningCodeDetail.EarningCode);
                        earningCodeHours.remove(payrollEarningCodeDetail.EarningCode);
                        earningCodeHours.insert(payrollEarningCodeDetail.EarningCode, scheduledHours);
                    }
                    else
                    {
                        earningCodeHours.insert(payrollEarningCodeDetail.EarningCode, scheduledHours);
                    }
                }
            }

            // get all the earning codes entered of type manual or leave esl for the day, sum them by earning code.
            if (currentStatementRecId && earningCodeHours.elements() > 0)
            {
                // check for manual and leave entries
                while select * from payrollEarningStatementLine
                    where payrollEarningStatementLine.EarningStatement == currentStatementRecId
                        && payrollEarningStatementLine.Position == positionRecId
                        && payrollEarningStatementLine.EarningDate == _periodDate
                        && (payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::UserEntry
                        || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::WorkerLeave
                        || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::Imported)
                    join RecId, IsBaseEarningsComponent from payrollEarningCode
                    where payrollEarningCode.RecId == payrollEarningStatementLine.EarningCode
                        && payrollEarningCode.IsBaseEarningsComponent == true
                        && payrollEarningCode.QuantityUnit == PayrollQuantityUnit::Hours
                {
                    earningStatementLineHours = payrollEarningStatementLine.Quantity;
                    earningStatementLineManualLeaveTotalHours += payrollEarningStatementLine.Quantity;

                    if (earningCodeManualLeave.exists(payrollEarningStatementLine.EarningCode))
                    {
                        // Add the hours on repeating earning codes
                        earningStatementLineHours += earningCodeManualLeave.lookup(payrollEarningStatementLine.EarningCode);
                        earningCodeManualLeave.remove(payrollEarningStatementLine.EarningCode);
                        earningCodeManualLeave.insert(payrollEarningStatementLine.EarningCode, earningStatementLineHours);
                    }
                    else
                    {
                        earningCodeManualLeave.insert(payrollEarningStatementLine.EarningCode, earningStatementLineHours);
                    }
                }

                // Condition when multiple schedule detail exists and more than one schedule detail has an EC defined on them
                if (earningCodesDefinedInSchedule.elements() > 1
                    && (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours) > 0)
                {
                    earningCodeManualLeaveIter = earningCodeManualLeave.getEnumerator();
                    while (earningCodeManualLeaveIter.moveNext())
                    {
                        earningCodeManualLeaveEarningCode = earningCodeManualLeaveIter.currentKey();
                        earningCodeManualLeaveLineHours = earningCodeManualLeaveIter.currentValue();

                        // Checking if EC used on manual line is not found in ECs used in schedule
                        if (!(earningCodesDefinedInSchedule.in(earningCodeManualLeaveEarningCode)))
                        {
                            conflictingEarningCodesFound = true;
                            earningCodeHours = new Map(Types::Int64, Types::Real);
                            earningCodeHours.insert(_payrollEarningCodeDetail.EarningCode, (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours));
                            break;
                        }

                        // Checking if EC used on manual line is found to be used in schedule detail and its quantity is over the schedule details hours
                        if (earningCodeHours.exists(earningCodeManualLeaveEarningCode)
                            && earningCodeManualLeaveLineHours > earningCodeHours.lookup(earningCodeManualLeaveEarningCode))
                        {
                            conflictingEarningCodesFound = true;
                            earningCodeHours = new Map(Types::Int64, Types::Real);
                            earningCodeHours.insert(_payrollEarningCodeDetail.EarningCode, (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours));
                            break;
                        }
                    }

                    if (conflictingEarningCodesFound == false)
                    {
                        earningCodeManualLeaveIter.reset();
                        while (earningCodeManualLeaveIter.moveNext())
                        {
                            earningCodeManualLeaveEarningCode = earningCodeManualLeaveIter.currentKey();
                            earningCodeManualLeaveLineHours = earningCodeManualLeaveIter.currentValue();

                            // Checking if EC used on manual line is found to be used in schedule detail and its quantity is under or equal the schedule details hours
                            if (earningCodeHours.exists(earningCodeManualLeaveEarningCode)
                                && earningCodeManualLeaveLineHours <= earningCodeHours.lookup(earningCodeManualLeaveEarningCode))
                            {
                                earningStatementLineHours = earningCodeHours.lookup(earningCodeManualLeaveEarningCode) - earningCodeManualLeaveLineHours;
                                earningCodeHours.remove(earningCodeManualLeaveEarningCode);
                                if (earningStatementLineHours > 0)
                                {
                                    earningCodeHours.insert(earningCodeManualLeaveEarningCode, earningStatementLineHours);
                                }
                            }
                        }
                    }
                }
                // Condition when multiple schedule detail exists but only one detail record EC is defined and manual entries exists
                else if (earningCodesDefinedInSchedule.elements() == 1
                    && earningCodeHours.elements() > 1
                    && earningCodeManualLeave.elements() > 0
                    && (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours) > 0)
                {
                    earningCodesDefinedInScheduleIter = earningCodesDefinedInSchedule.getEnumerator();
                    while (earningCodesDefinedInScheduleIter.moveNext())
                    {
                        earningCodesDefinedInScheduleEarningCode = earningCodesDefinedInScheduleIter.current();

                        //
                        // Checking when no manual ESL exists for the EC and the hours remaing to fill is equal to or less than the original shceduled hours on the only defined EC
                        // in schedule details
                        //
                        if (earningCodeManualLeave.exists(earningCodesDefinedInScheduleEarningCode) == false
                            && earningCodeHours.exists(earningCodesDefinedInScheduleEarningCode)
                            && earningCodeHours.lookup(earningCodesDefinedInScheduleEarningCode) >= (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours))
                        {
                            if (earningCodeHours.exists(_payrollEarningCodeDetail.EarningCode))
                            {
                                earningCodeHours.remove(_payrollEarningCodeDetail.EarningCode);
                            }
                        }
                        // Checking when manual ESL exists for the EC and all the hours to be filled for that only defined EC in schedule is already accounted for in the manual ESL line
                        else if (earningCodeManualLeave.exists(earningCodesDefinedInScheduleEarningCode)
                                    && earningCodeHours.exists(earningCodesDefinedInScheduleEarningCode)
                                    && earningCodeManualLeave.lookup(earningCodesDefinedInScheduleEarningCode) >= earningCodeHours.lookup(earningCodesDefinedInScheduleEarningCode))
                        {
                            earningCodeHours.remove(earningCodesDefinedInScheduleEarningCode);
                        }
                        //
                        // Checking when no manual ESL exists for the EC and the hours remaing to fill is greater than the original shceduled hours on the only defined EC
                        // in schedule details.
                        //
                        else if (earningCodeManualLeave.exists(earningCodesDefinedInScheduleEarningCode) == false
                                    && earningCodeHours.exists(earningCodesDefinedInScheduleEarningCode)
                                    && earningCodeHours.lookup(earningCodesDefinedInScheduleEarningCode) < (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours))

                        {
                            if (earningCodeHours.exists(_payrollEarningCodeDetail.EarningCode))
                            {
                                earningCodeHours.remove(_payrollEarningCodeDetail.EarningCode);
                                earningCodeHours.insert(_payrollEarningCodeDetail.EarningCode, (earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours) - earningCodeHours.lookup(earningCodesDefinedInScheduleEarningCode));
                            }
                        }
                        // Checking when manual ESL exists for the EC and not all the hours to be filled for that only defined EC in schedule is already accounted for in the manual ESL line
                        else if (earningCodeManualLeave.exists(earningCodesDefinedInScheduleEarningCode)
                                    && earningCodeHours.exists(earningCodesDefinedInScheduleEarningCode)
                                    && earningCodeManualLeave.lookup(earningCodesDefinedInScheduleEarningCode) < earningCodeHours.lookup(earningCodesDefinedInScheduleEarningCode))
                        {
                            earningStatementLineHours = earningCodeHours.lookup(earningCodesDefinedInScheduleEarningCode) - earningCodeManualLeave.lookup(earningCodesDefinedInScheduleEarningCode);
                            earningCodeHours.remove(earningCodesDefinedInScheduleEarningCode);
                            earningCodeHours.insert(earningCodesDefinedInScheduleEarningCode, earningStatementLineHours);
                        }
                    }
                }
            }

            earningCodeHoursIter = earningCodeHours.getEnumerator();
            while (earningCodeHoursIter.moveNext())
            {
                earningCodeHoursEarningCode = earningCodeHoursIter.currentKey();
                earningCodeHoursScheduledHours = earningCodeHoursIter.currentValue();

                payrollEarningCodeDetailInternal.clear();
                payrollEarningCodeDetailInternal = PayrollEarningCodeDetail::findByEarningCode(earningCodeHoursEarningCode, toDate);

                earningCode = PayrollEarningCode::find(payrollEarningCodeDetailInternal.EarningCode);

                workerPositionEarningCode = PayrollWorkerPositionEarningCode::findByWorkerPositionEarningCode(
                            workerRecId,
                            positionRecId,
                            earningCode.RecId, _periodDate);

                if (workerPositionEarningCode)
                {
                    earningCodeFormula = workerPositionEarningCode.Formula;
                }
                else
                {
                    earningCodeFormula = payrollEarningCodeDetailInternal.DefaultFormula;
                }

                earningRate = PayrollEarningGenerationTask::computeEarningRate(workerRecId,
                                                positionRecId,
                                                _periodDate,
                                                payrollEarningCodeDetail.RateBasis,
                                                PayrollPayCycle::find(payCycleRecId).TimePeriod);

                if (earningRate != 0
                   || (earningRate == 0 && this.hasFixedCompPlan(payrollEarningCodeDetail.RateBasis, positionRecId, workerRecId, _periodDate)))
                {
                    earningAmount = decRound(earningCodeFormula * earningRate, #RateDecimalPlaces);
                    if (currentStatementRecId == 0)
                    {
                        scheduledHours = earningCodeHoursScheduledHours;
                        earningStatementLineManualLeaveTotalHours += scheduledHours;

                        // create a new ES
                        this.createEarningStatementForWorker();

                        // create a statementLine
                        this.createScheduleLine(payrollEarningCodeDetailInternal.EarningCode, scheduledHours, _periodDate, earningAmount, PayrollGenerationSource::PositionSchedule);
                    }
                    else
                    {
                        scheduledHours = earningStatementLineScheduledHours - earningStatementLineManualLeaveTotalHours;
                        if (scheduledHours > 0)
                        {
                            if (conflictingEarningCodesFound == false && earningCodeHours.elements() > 1)
                            {
                                scheduledHours = earningCodeHoursScheduledHours;
                                earningStatementLineManualLeaveTotalHours += scheduledHours;
                            }

                            this.createScheduleLine(payrollEarningCodeDetailInternal.EarningCode, scheduledHours, _periodDate, earningAmount, PayrollGenerationSource::PositionSchedule);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkerPositionRecurringEarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the recurring earning lines for a specific Worker and Position combination
    /// </summary>
    /// <remarks>
    /// The method would create a record in the <c>PayrollEarningStatement</c> table if no matching record for the worker for this payperiod specified.
    /// </remarks>
    private void createWorkerPositionRecurringEarnings()
    {
        PayrollEarningCode                          earningCode;
        PayrollEarningCodeDetail                    earningCodeDetail;
        HcmPositionWorkerAssignment                 positionWorkerAssignment;
        PayrollWorkerPositionEarningCode            workerPositionEarningCode;
        PayrollCalculationFrequencyPayPeriod        calculationFrequencyPayPeriod;
        PayrollCalculationFrequency                 calculationFrequency;

        PayrollEarningStatementLine                 earningStatementLine;
        AmountMST                                   earningRate, earningAmount;

        if (workerRecId != 0 && positionRecId != 0 && positiondetail.RecId != 0)
        {
            select firstonly validTimeState(toDateTime) RecId from positionWorkerAssignment
                    where positionWorkerAssignment.Worker == workerRecId
                    && positionWorkerAssignment.Position == positionRecId;

            if (positionWorkerAssignment.RecId != 0)
            {
                //
                // can have multiple earning records exist for a given worker and position combination at the endDate of the pay period
                // and the calc frequency is defined for the pay period
                //
                while select validTimeState(toDate) RecId, Worker, Position, EarningCode, Formula, CalculationFrequency from workerPositionEarningCode
                    where workerPositionEarningCode.Position == positionWorkerAssignment.Position
                        && workerPositionEarningCode.Worker == positionWorkerAssignment.Worker
                        && workerPositionEarningCode.CalculationFrequency != 0
                    join RecId, CalculationFrequencyId from calculationFrequency
                        where calculationFrequency.RecId == workerPositionEarningCode.CalculationFrequency
                    // only calculate those with calculation frequency defined for this period
                    outer join RecId, PayPeriod from calculationFrequencyPayPeriod
                        where calculationFrequencyPayPeriod.CalculationFrequency == workerPositionEarningCode.CalculationFrequency
                            && calculationFrequencyPayPeriod.PayPeriod == payPeriodRecId
                {
                    if (calculationFrequencyPayPeriod.RecId == 0 && !calculationFrequency.isDefaultCalculationFrequency())
                    {
                        // no frenquency defined and the frenquency is not all, no calculation needed.
                        continue;
                    }

                    //
                    // the earning code on workerPositionEarningCode table is mandatory
                    // verify if the earning code is active and the QuantityUnit has to be 'Each' for generating a recurring earning line
                    //
                    select firstonly validTimeState(toDate) RecId, QuantityUnit from earningCode
                        where earningCode.RecId == workerPositionEarningCode.EarningCode
                                && earningCode.QuantityUnit == PayrollQuantityUnit::Each
                        join RateBasis, DefaultFormula from earningCodeDetail
                            where earningCodeDetail.EarningCode == earningCode.RecId;
                    if (earningCode.RecId == 0)
                    {
                        continue;
                    }

                    earningRate = PayrollEarningGenerationTask::computeEarningRate(workerRecId, positionRecId, toDate, earningCodeDetail.RateBasis, timePeriod);

                    if (earningRate != 0
                        || (earningRate == 0 && this.hasFixedCompPlan(earningCodeDetail.RateBasis, positionRecId, workerRecId, toDate)))
                    {
                        earningAmount = decRound(workerPositionEarningCode.Formula * earningRate, #RateDecimalPlaces);

                        if (currentStatementRecId == 0)
                        {
                            // create a earning statement for the worker and the recuring earning line
                            this.createEarningStatementForWorker();
                            this.createRecurringLine(earningCode.RecId, earningAmount);
                        }
                        else
                        {
                            // find the one previously created if there is one
                            select firstonly RecId from earningStatementLine
                                where earningStatementLine.EarningStatement == currentStatementRecId
                                    && earningStatementLine.EarningCode == earningCode.RecId
                                    && earningStatementLine.Position == positionRecId
                                    && earningStatementLine.GenerationSource == PayrollGenerationSource::Recurring;

                            if (earningStatementLine.RecId == 0)
                            {
                                // create a statementLine
                                this.createRecurringLine(earningCode.RecId, earningAmount);
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkerPositionSalaryEarning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the salary earning line for a specific Worker and Position combination
    /// </summary>
    /// <remarks>
    /// The method would create a record in the <c>PayrollEarningStatement</c> table if no matching record for the worker for this payperiod specified.
    /// </remarks>
    private void createWorkerPositionSalaryEarning()
    {
        PayrollEarningCode                          earningCode;
        PayrollEarningCodeDetail                    earningCodeDetail;

        PayrollEarningStatementLine                 earningStatementLineAmount,
                                                    earningStatementLineQuantity,
                                                    earningStatementLineSalary,
                                                    earningStatementLineSalaryNonEditable,
                                                    earningStatementLineSalaryEditable;
        PayrollEarningCode                          earningCodeTemp;
        AmountMST                                   payPeriodTotalAmount, amountTemp, payPeriodTotalAmountPaid;
        PayrollEarningQuantity                      payPeriodExpectedHours, hoursTemp, payPeriodExpectedHoursPaid;
        container                                   payPeriodExpected;

        if (workerRecId != 0 && positionRecId != 0 && positiondetail.AutoGenerateSalary == NoYes::Yes)
        {
            if (positiondetail.RecId != 0 && !(positiondetail.PayrollNormalHours > 0))
            {
               // Position need to be valid for the LE and Paycycle, and the AutoGenerateSalary is set
                checkFailed(strFmt("@Payroll:EarningsWereNotGeneratedForPosition1EnterTheAnnualNormalHour1", HcmPosition::find(positionRecId).PositionId));
            }

            // No further action needed if no qualified payroll position detail exists
            if (positiondetail.RecId != 0 && positiondetail.PayrollNormalHours > 0)
            {
                payPeriodExpected = PayrollCompensationCalculate::periodExpectedWages(positionRecId, workerRecId, startDate, toDate, timePeriod);

                payPeriodTotalAmount = CurrencyExchange::round(payPeriodTotalAmount + conPeek(payPeriodExpected, 1), PayrollSetup::currencyCode());
                if (conPeek(payPeriodExpected, 2) == 0)
                {
                    payPeriodExpectedHours = this.getPayPeriodHours(positiondetail.PayrollNormalHours, timePeriod);
                }
                else
                {
                    payPeriodExpectedHours = this.getPayPeriodDailyHours(positiondetail.PayrollNormalHours) * conPeek(payPeriodExpected, 2);
                }

                if (scheduleEnabledForPosition)
                {
                    payPeriodExpectedHoursPaid = decRound(payPeriodExpectedHours - this.getPayPeriodDailyHours(positiondetail.PayrollNormalHours) * unpaidLeaveDays.elements(), #QuantityDecimalPlaces);
                    payPeriodTotalAmountPaid = CurrencyExchange::round(payPeriodTotalAmount * payPeriodExpectedHoursPaid / payPeriodExpectedHours, PayrollSetup::currencyCode());
                }
                else
                {
                    payPeriodExpectedHoursPaid = payPeriodExpectedHours;
                    payPeriodTotalAmountPaid = payPeriodTotalAmount;
                }

                if (payPeriodTotalAmountPaid != 0)
                {
                    //
                    // The EarningCode is mandatory when AutoGenerateBaseEarnings == NoYes::Yes
                    // verify if the earning code is active
                    // and the QuantityUnit has to be 'Hours' for qualifing as salary earning to have a balancing line
                    //
                    select firstonly validTimeState(toDate) RecId from earningCode
                        where  earningCode.RecId == positiondetail.DefaultEarningCode
                            && earningCode.QuantityUnit == PayrollQuantityUnit::Hours
                        join RateBasis, DefaultFormula from earningCodeDetail
                            where earningCodeDetail.EarningCode == earningCode.RecId;

                    // No further action needed if no active earning code exists
                    if (earningCode.RecId != 0)
                    {
                        if (currentStatementRecId != 0)
                        {
                            if (PayrollEarningStatement::find(currentStatementRecId).AutoGeneratedSalary)
                            {
                                // Get the total amount for existing earning lines where the earning code is flaged as base earning component
                                select sum(AccountingCurrencyAmount) from earningStatementLineAmount
                                    where earningStatementLineAmount.EarningStatement == currentStatementRecId
                                        && earningStatementLineAmount.Position == positionRecId
                                        && earningStatementLineAmount.GenerationSource != PayrollGenerationSource::Salary
                                    join RecId from earningCodeTemp
                                        where earningStatementLineAmount.EarningCode == earningCodeTemp.RecId
                                            && earningCodeTemp.IsBaseEarningsComponent == NoYes::Yes;

                                // Get the total hours for existing earning lines where the earning code is flaged as base earning component and QantityUnit is Hours
                                select sum(Quantity) from earningStatementLineQuantity
                                    where earningStatementLineQuantity.EarningStatement == currentStatementRecId
                                        && earningStatementLineQuantity.Position == positionRecId
                                        && earningStatementLineQuantity.GenerationSource != PayrollGenerationSource::Salary
                                    join RecId from earningCodeTemp
                                        where earningStatementLineQuantity.EarningCode == earningCodeTemp.RecId
                                            && earningCodeTemp.IsBaseEarningsComponent == NoYes::Yes
                                            && earningCodeTemp.QuantityUnit == PayrollQuantityUnit::Hours;

                                // The total amount and hours of lines where the generatingSource is balancing earnings (salary)
                                select sum(AccountingCurrencyAmount), sum(Quantity) from earningStatementLineSalary
                                    where earningStatementLineSalary.EarningStatement == currentStatementRecId
                                        && earningStatementLineSalary.Position == positionRecId
                                        && earningStatementLineSalary.GenerationSource == PayrollGenerationSource::Salary;

                                // The total amount and hours of lines where the generatingSource is balancing earnings which is non editable (Released or processed)
                                select sum(Quantity), sum(AccountingCurrencyAmount) from earningStatementLineSalaryNonEditable
                                        where earningStatementLineSalaryNonEditable.EarningStatement == currentStatementRecId
                                            && earningStatementLineSalaryNonEditable.Position == positionRecId
                                            && earningStatementLineSalaryNonEditable.GenerationSource == PayrollGenerationSource::Salary
                                            && (earningStatementLineSalaryNonEditable.PaymentStatus == PayrollPaymentProcessingStatus::Processed
                                                || earningStatementLineSalaryNonEditable.PaymentStatus == PayrollPaymentProcessingStatus::Released);

                                // Comparing the totals of the pay period amount and the total amount from the qualified lines otherwise, no action needed
                                if (payPeriodTotalAmountPaid != earningStatementLineAmount.AccountingCurrencyAmount + earningStatementLineSalary.AccountingCurrencyAmount
                                || payPeriodExpectedHoursPaid != earningStatementLineQuantity.Quantity + earningStatementLineSalary.Quantity)
                                {
                                    //
                                    // If there is a difference, modify the existing balancing line if it is still editable (not Released or processed)
                                    // find exsiting line which can be updated
                                    //
                                    select forupdate firstonly Quantity, EarningRate, AccountingCurrencyAmount from earningStatementLineSalaryEditable
                                        where earningStatementLineSalaryEditable.EarningStatement == currentStatementRecId
                                            && earningStatementLineSalaryEditable.Position == positionRecId
                                            && earningStatementLineSalaryEditable.GenerationSource == PayrollGenerationSource::Salary
                                            && (earningStatementLineSalaryEditable.PaymentStatus == PayrollPaymentProcessingStatus::None
                                                || earningStatementLineSalaryEditable.PaymentStatus == PayrollPaymentProcessingStatus::OnHold);

                                    amountTemp = CurrencyExchange::round((payPeriodTotalAmountPaid - earningStatementLineAmount.AccountingCurrencyAmount - earningStatementLineSalaryNonEditable.AccountingCurrencyAmount), PayrollSetup::currencyCode());
                                    hoursTemp = decRound((payPeriodExpectedHoursPaid - earningStatementLineQuantity.Quantity - earningStatementLineSalaryNonEditable.Quantity), #QuantityDecimalPlaces);

                                    if (amountTemp == 0 && hoursTemp == 0)
                                    {
                                        if (earningStatementLineSalaryEditable.RecId != 0)
                                        {
                                            // Delete the balancing line which has amount and quantity equal to 0, no line needed
                                            ttsbegin;

                                            //
                                            // Set _skipAdjustSalaryline to true to avoid salary adjusting in the process.
                                            // Creating salary line will be called at the end of the process
                                            //
                                            earningStatementLineSalaryEditable.delete(true);

                                            ttscommit;
                                        }
                                    }
                                    else
                                    {
                                        if (earningStatementLineSalaryEditable.RecId != 0)
                                        {
                                            // Update the amount on the balancing line which need to considering there might be multiple balancing lines
                                            ttsbegin;
                                            earningStatementLineSalaryEditable.AccountingCurrencyAmount = amountTemp;
                                            earningStatementLineSalaryEditable.Quantity = hoursTemp;
                                            earningStatementLineSalaryEditable.EarningRate = (hoursTemp == 0)? 0 : decRound(amountTemp/hoursTemp, #RateDecimalPlaces);

                                            //
                                            // Set _skipAdjustSalaryline to true to avoid salary adjusting in the process.
                                            // Creating salary line will be called at the end of the process
                                            //
                                            earningStatementLineSalaryEditable.update(true);
                                            ttscommit;
                                        }
                                        else
                                        {
                                            // If there is no editable line or there is no line, create a line with the right balancing amount
                                            this.createSalaryLine(earningCode.RecId, amountTemp, hoursTemp);
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            // No statement exist
                            this.createEarningStatementForWorker();
                            this.createSalaryLine(earningCode.RecId, payPeriodTotalAmountPaid, payPeriodExpectedHoursPaid);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkerPositionScheduleEarnings</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the required common parameters between Leave and Position Schedule earning statement lines and
    /// routes the call to the actual earning statement line generation method depending upon the provided param
    /// enum value <c>_generationSource</c>.
    /// </summary>
    private void createWorkerPositionScheduleEarnings()
    {
        WorkCalendarDate                workCalendarDate;
        HcmPositionWorkerAssignment     hcmPositionWorkerAssignment;
        PayrollEarningCodeDetail        payrollEarningCodeDetail;
        utcdatetime                     periodStartDateTime, periodEndDateTime;
        TransDate                       daysListTransDate;

        if (workerRecId == 0 || positiondetail.RecId == 0 || strLen(positiondetail.Schedule) == 0)
        {
            return;
        }

        // Clean up previously generated ESLs by generation source type
        this.cleanupWorkerScheduleEarnings();

        // Get the active earning code detail on the pay period end date.
        payrollEarningCodeDetail = PayrollEarningCodeDetail::findByEarningCode(positiondetail.DefaultEarningCode, toDate);

        // loop through individual days one by one
        daysInPeriodEnumerator.reset();
        while (daysInPeriodEnumerator.moveNext())
        {
            daysListTransDate = daysInPeriodEnumerator.current();

            // Convert the date to date time for date effectivity.
            periodStartDateTime = datetobeginUtcDateTime(daysListTransDate, DateTimeUtil::getCompanyTimeZone());
            periodEndDateTime = datetoendUtcDateTime(daysListTransDate, DateTimeUtil::getCompanyTimeZone());

            // Get the count of how many DE effective active records on the day
            select firstonly ValidTimeState(periodStartDateTime, periodEndDateTime) RecId from hcmPositionWorkerAssignment
                where hcmPositionWorkerAssignment.Worker == workerRecId
                    && hcmPositionWorkerAssignment.Position == positionRecId;

            // Only proceed if the position assignment to the worker is active on the selected day.
            if (hcmPositionWorkerAssignment.RecId > 0)
            {
                // Check if a schedule is defined for the selected day in the calendar
                while select TransDate, CalendarId from workCalendarDate
                    where workCalendarDate.CalendarId == positiondetail.Schedule
                        && workCalendarDate.TransDate == daysListTransDate
                {
                    this.createWorkerPositionLeaveEarnings(workCalendarDate, daysListTransDate);

                    // First check generate shceduled earning flag is on and there is an active earning code detail
                    if (positiondetail.GenerateEarningsFromSchedule && payrollEarningCodeDetail.RecId != 0)
                    {
                        this.createWorkerPositionPosSchEarnings(workCalendarDate, daysListTransDate, payrollEarningCodeDetail);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findUnpaidLeaveDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate the unPaidLeave set with the days where the unpaid leave is found and the position worker assignment is active
    /// </summary>
    private void findUnpaidLeaveDays()
    {
        date dayInPeriod;

        unpaidLeaveDays = new Set (Types::Date);
        daysInPeriodEnumerator.reset();
        while (daysInPeriodEnumerator.moveNext())
        {
            dayInPeriod = daysInPeriodEnumerator.current();
            if (this.isPositionWorkerAssignmentActiveDay(dayInPeriod)
                && this.isWorkerUnpaidLeaveDay(dayInPeriod))
            {
                unpaidLeaveDays.add(dayInPeriod);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAnnualPayPeriodCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the count of pay period for a year
    /// </summary>
    /// <param name="_timePeriod">
    /// The time period for the count to be retruned
    /// </param>
    /// <returns>
    /// The count of pay periods
    /// </returns>
    public int getAnnualPayPeriodCount(PayrollTimePeriod _timePeriod)
    {
        int payPeriodCount;
        //to do: Feature team 276468 will replace this with salary schedule
        switch (_timePeriod)
        {
            case PayrollTimePeriod::Daily :
                payPeriodCount = daysInYear;
                break;
            case PayrollTimePeriod::Weekly :
                payPeriodCount = #PERIODSWEEKLY;
                break;
            case PayrollTimePeriod::Biweekly :
                payPeriodCount = #PERIODSBIWEEKLY;
                break;
            case PayrollTimePeriod::Semimonthly :
                payPeriodCount = #PERIODSSEMIMONTHLY;
                break;
            case PayrollTimePeriod::Monthly :
                payPeriodCount = #PERIODSMONTHLY;
                break;
            case PayrollTimePeriod::Quarterly :
                payPeriodCount = #PERIODSQUARTERLY;
                break;
            case PayrollTimePeriod::Semiannually :
                payPeriodCount = #PERIODSSEMIANNUALLY;
                break;
            case PayrollTimePeriod::Annually :
                payPeriodCount = #PERIODSANNUALLY;
                break;
        }
        return payPeriodCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEarningStatementCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number of earnings statements created or updated by the process.
    /// </summary>
    /// <returns>
    /// The number of earnings statements created or updated by the process.
    /// </returns>
    public int getEarningStatementCount()
    {
        int earningStatementCount;

        //
        // Note: The PayrollEarningStatementGeneration class has a dependency on this class,
        // Be sure to test the run method of that class when making modifications to this method.
        //
        if (maintainEarningStatementSet)
        {
            earningStatementCount = earningStatementSet.elements();
        }

        return earningStatementCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfScheduledHours</Name>
				<Source><![CDATA[
    private WorkCalendarDateLine getNumberOfScheduledHours(CalendarId _calendarId, TransDate _transDate)
    {
        str mapKey = strFmt("%1" + "%2", _calendarId, _transDate);

        if (!workCalendarDateLineMap.exists(mapKey))
        {
            this.setNumberOfScheduledHours(mapKey, _calendarId, _transDate);
        }

        return workCalendarDateLineMap.lookup(mapKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayPeriodDailyHours</Name>
				<Source><![CDATA[
    private PayrollEarningQuantity getPayPeriodDailyHours(PayrollHours _payrollNormalHours)
    {
        return decRound(_payrollNormalHours/daysInYear, #QuantityDecimalPlaces);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayPeriodHours</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calcultes the expected hours for the PayPeriod.
    /// </summary>
    /// <param name="_payrollNormalHours">
    ///     The normal hours for the position.
    /// </param>
    /// <param name="_timePeriod">
    ///     The Payroll time period for the calculation.
    /// </param>
    /// <returns>
    ///     The expected hours for the PayPeriod.
    /// </returns>
    public PayrollEarningQuantity getPayPeriodHours(PayrollHours _payrollNormalHours, PayrollTimePeriod _timePeriod)
    {
        return decRound(_payrollNormalHours/this.getAnnualPayPeriodCount(_timePeriod), #QuantityDecimalPlaces);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkCalendarDefined</Name>
				<Source><![CDATA[
    private CalendarId getWorkCalendarDefined(CalendarId _calendarId, TransDate _transDate)
    {
        str mapKey = strFmt("%1" + "%2", _calendarId, _transDate);

        if (!workCalendarDefinedMap.exists(mapKey))
        {
            // Get the work calendar of the Calendar and Date.
            workCalendarDefinedMap.insert(mapKey, WorkCalendar::defined(_calendarId, _transDate));
        }

        return workCalendarDefinedMap.lookup(mapKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDaysListFromPayPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the day list from the selected pay period.
    /// </summary>
    private void initDaysListFromPayPeriod()
    {
        date                periodDate;

        if (daysInPeriod.empty())
        {
            for (periodDate = startDate; periodDate <= toDate; periodDate++)
            {
                daysInPeriod.addEnd(periodDate);
            }
            daysInPeriodEnumerator = daysInPeriod.getEnumerator();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEarningStatement</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the currentStatementRecId from the selected worker and pay period.
    /// </summary>
    private void initEarningStatement()
    {
        currentStatementRecId = PayrollEarningStatement::findByWorkerPayPeriod(workerRecId, payPeriodRecId).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPayPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the values from the selected pay period.
    /// </summary>
    private void initFromPayPeriod()
    {
        PayrollPayPeriod    payPeriod;
        PreferredLocale     locale = new Session().preferredLocale();

        if (payPeriodRecId != 0)
        {
            legalEntityRecId = CompanyInfo::current();
            payPeriod = PayrollPayPeriod::find(payPeriodRecId);
            payCycleRecId = payPeriod.PayCycle;
            timePeriod = PayrollPayCycle::find(payCycleRecId).TimePeriod;
            startDate = payPeriod.PeriodStartDate;
            startDateTime = datetobeginUtcDateTime(startDate, DateTimeUtil::getCompanyTimeZone());
            toDate = payPeriod.PeriodEndDate;
            daysInYear = dayOfYr(DateTimeUtil::getEndOfYearDate(locale, toDate));
            toDateTime = datetoendUtcDateTime(toDate, DateTimeUtil::getCompanyTimeZone());
            daysInPeriod = new List(Types::Date);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the values from the selected worker and position.
    /// </summary>
    private void initFromSchedule()
    {
        if (positiondetail.RecId != 0 && strLen(positiondetail.Schedule) > 0)
        {
            scheduleEnabledForPosition = true;

            // populate the days in the current period
            this.initDaysListFromPayPeriod();

            // Populate the unpaid leave days
            this.findUnpaidLeaveDays();
        }
        else
        {
            scheduleEnabledForPosition = false;
        }

        workCalendarDateLineMap = new Map(Types::String, Types::Record);
        workCalendarDefinedMap = new Map(Types::String, Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromWorkerPosition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the values from the selected worker and position.
    /// </summary>
    /// <param name="_workerRecId">
    /// The RecId of the record in <c>HcmWorker</c> table.
    /// </param>
    /// <param name="_positionRecId">
    /// The RecId of the record in <c>HcmPosition</c> table.
    /// </param>
    private void initFromWorkerPosition(HcmWorkerRecId _workerRecId, HcmPositionRecId _positionRecId)
    {
        workerRecId = _workerRecId;
        positionRecId = _positionRecId;

        this.initPositionForCurrentLEPayCycle();
        this.initFromSchedule();
        this.initEarningStatement();
        currentWorkerCompensationBenefit = PayrollPositionWorkerCompensation::findByPosition(positionRecId, toDate, toDate).Benefit;
        currentWorkerTaxRegionRecId = PayrollPositionWorkerDefaultTaxRgn::findByWorkerPosition(positionRecId, workerRecId).WorkerTaxRegion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPositionForCurrentLEPayCycle</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initialize the position detail from the selected posiiton.
    /// </summary>
    private void initPositionForCurrentLEPayCycle()
    {
        select validTimeState(toDate) * from positiondetail
            where positiondetail.Position == positionRecId
                && positiondetail.PayCycle == payCycleRecId
                && positiondetail.PaidByLegalEntity == legalEntityRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEarningStatementLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts earnings statement line and keeps track of the earnings statements that were modified or created.
    /// </summary>
    /// <param name="_earningStatementLine">
    /// The <c>PayrollEarningStatementLine</c> record.
    /// </param>
    private void insertEarningStatementLine(PayrollEarningStatementLine   _earningStatementLine)
    {
        if (_earningStatementLine.validateWrite())
        {
            //
            // Set _skipAdjustSalaryline to true to avoid salary adjusting in the process.
            // Creating salary line will be called at the end of the process
            //
            _earningStatementLine.insert(true);
            if (maintainEarningStatementSet)
            {
                earningStatementSet.add(_earningStatementLine.EarningStatement);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPositionWorkerAssignmentActiveDay</Name>
				<Source><![CDATA[
    private boolean  isPositionWorkerAssignmentActiveDay(TransDate _periodDate)
    {
        HcmPositionWorkerAssignment hcmPositionWorkerAssignment;
        utcdatetime                 beginValue, endValue;

        beginValue = datetobeginUtcDateTime(_periodDate, DateTimeUtil::getCompanyTimeZone());
        endValue = datetoendUtcDateTime(_periodDate, DateTimeUtil::getCompanyTimeZone());

        select firstonly validTimeState(beginValue, endValue) RecId from hcmPositionWorkerAssignment
            where hcmPositionWorkerAssignment.Worker == workerRecId && hcmPositionWorkerAssignment.Position == positionRecId;

        return (hcmPositionWorkerAssignment.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPositionWorkerAssignmentActivePeriod</Name>
				<Source><![CDATA[
    private boolean isPositionWorkerAssignmentActivePeriod()
    {
        HcmPositionWorkerAssignment hcmPositionWorkerAssignment;

        select firstonly validTimeState(startDateTime, toDateTime) RecId from hcmPositionWorkerAssignment
            where hcmPositionWorkerAssignment.Worker == workerRecId && hcmPositionWorkerAssignment.Position == positionRecId;

        return (hcmPositionWorkerAssignment.RecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isWorkerUnpaidLeaveDay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the date specified qualifies as unpaid leave for the worker in current legal entity.
    /// If the same day qualifies as paid leave, checking it as unpaid leave is skipped.
    /// </summary>
    /// <param name="_periodDate">
    /// The date to check if it qualifies as unpaid leave
    /// </param>
    /// <returns>
    /// Returns true if the date specified qualifies as unpaid leave
    /// </returns>
    private boolean  isWorkerUnpaidLeaveDay(TransDate _periodDate)
    {
        HcmEmploymentLeave              hcmEmploymentLeave;
        HcmLeaveType                    hcmLeaveType;
        HcmEmployment                   hcmEmployment;
        boolean                         isUnPaidLeaveDay;
        utcdatetime                     minValue, maxValue;

        minValue = DateTimeUtil::minValue();
        maxValue = DateTimeUtil::maxValue();
        isUnPaidLeaveDay = false;

        select firstonly validTimeState(minValue, maxValue) RecId from hcmEmploymentLeave
            where hcmEmploymentLeave.StartDate <= _periodDate && hcmEmploymentLeave.EndDate >= _periodDate
        join EarningCode from hcmLeaveType
            where hcmLeaveType.RecId == hcmEmploymentLeave.LeaveType
                && hcmLeaveType.EarningCode != 0
        exists join hcmEmployment
            where hcmEmployment.RecId == hcmEmploymentLeave.Employment
                && hcmEmployment.LegalEntity == legalEntityRecId
                && hcmEmployment.Worker == workerRecId;

        if (hcmEmploymentLeave.RecId == 0)
        {
            select firstonly validTimeState(minValue, maxValue) RecId from hcmEmploymentLeave
                where hcmEmploymentLeave.StartDate <= _periodDate && hcmEmploymentLeave.EndDate >= _periodDate
            join EarningCode from hcmLeaveType
                where hcmLeaveType.RecId == hcmEmploymentLeave.LeaveType
                    && hcmLeaveType.EarningCode == 0
            exists join hcmEmployment
                where hcmEmployment.RecId == hcmEmploymentLeave.Employment
                    && hcmEmployment.LegalEntity == legalEntityRecId
                    && hcmEmployment.Worker == workerRecId;

            if (hcmEmploymentLeave.RecId != 0)
            {
                isUnPaidLeaveDay = true;
            }
        }

        return isUnPaidLeaveDay;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchTaskGroupList</Name>
				<Source><![CDATA[
    public container parmBatchTaskGroupList(container _batchTaskGroupList = batchTaskGroupList)
    {
        batchTaskGroupList = _batchTaskGroupList;

        return batchTaskGroupList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEarningStatementSet</Name>
				<Source><![CDATA[
    public Set parmEarningStatementSet(Set _earningStatementSet = earningStatementSet)
    {
        earningStatementSet = _earningStatementSet;

        return earningStatementSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMaintainEarningStatementSet</Name>
				<Source><![CDATA[
    public boolean parmMaintainEarningStatementSet(boolean _maintainEarningStatementSet = maintainEarningStatementSet)
    {
        maintainEarningStatementSet = _maintainEarningStatementSet;

        return maintainEarningStatementSet;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPayPeriodRecId</Name>
				<Source><![CDATA[
    public PayrollPayCycleRecId parmPayPeriodRecId(PayrollPayPeriodRecId _payPeriodRecId = payPeriodRecId)
    {
        payPeriodRecId = _payPeriodRecId;

        return payPeriodRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSingleWorkerPosition</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Create Recurring and Salary earnings for a given worker and position combination.
    /// </summary>
    /// <param name="_workerRecId">
    ///     The worker RecId for which the Recurring and Salary earnings are to be created.
    /// </param>
    /// <param name="_positionRecId">
    ///     The position RecId for which the Recurring and Salary earnings are to be created.
    /// </param>
    private void processSingleWorkerPosition(HcmWorkerRecId _workerRecId, HcmPositionRecId _positionRecId)
    {
        if (_workerRecId != 0 && _positionRecId != 0 )
        {
            this.initFromWorkerPosition(_workerRecId, _positionRecId);

            // only process when the position worker assignment is active during the specified pay period
            // Default Tax Region need to be set before creating any earnings for the worker and position
            if (this.isPositionWorkerAssignmentActivePeriod() && this.validateTaxRegionSetForWorkerPosition())
            {
                ttsbegin;
                this.createWorkerPositionRecurringEarnings();
                this.createWorkerPositionScheduleEarnings();
                this.createWorkerPositionSalaryEarning();
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        #OCCRetryCount
        HcmWorkerRecId          workerRecIdTemp;
        container               batchTaskWorkerList;
        List                    batchTaskPositionList;
        ListEnumerator          enumerator;
        int                     i;

        this.initFromPayPeriod();
        //
        // The calling process has supplied a container with a list of 1..n workers and the corresponding Positions for each worker
        // to create earnings, so loop through this list of workers, and also loop through the list of positions for each worker
        //
        for (i = 1; i <= conLen(batchTaskGroupList); i++)
        {
            batchTaskWorkerList = conPeek(batchTaskGroupList, i);
            workerRecIdTemp = conPeek(batchTaskWorkerList, 1);

            if (workerRecIdTemp == 0 )
            {
                // worker needs to be set for any calculation
                continue;
            }

            batchTaskPositionList = List::create(conPeek(batchTaskWorkerList, 2));
            enumerator = batchTaskPositionList.getEnumerator();

            while (enumerator.moveNext())
            {
                if (enumerator.current() == 0)
                {
                    // position needs to be set for any calculation
                    continue;
                }

                try
                {
                    this.processSingleWorkerPosition(workerRecIdTemp, enumerator.current());
                }
                catch (Exception::Error)
                {
                    // Assumes that any error message was already raised at the point that threw the exception,so continue to the next worker.
                    continue;
                }
                catch (Exception::Deadlock)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        error(strFmt("@Payroll:DeadlockCreatingEarningForWorker1", HcmWorker::find(workerRecIdTemp).PersonnelNumber));
                        continue;
                    }
                    else
                    {
                        retry;
                    }
                }
                catch (Exception::UpdateConflict)
                {
                    if (appl.ttsLevel() == 0)
                    {
                        if (xSession::currentRetryCount() >= #RetryNum)
                        {
                            error(strFmt("@Payroll:UpdateconfictCreatingEarningForWorker1", HcmWorker::find(workerRecIdTemp).PersonnelNumber));
                            continue;
                        }
                        else
                        {
                            retry;
                        }
                    }
                    else
                    {
                        error(strFmt("@Payroll:UpdateconfictCreatingEarningForWorker1", HcmWorker::find(workerRecIdTemp).PersonnelNumber));
                        continue;
                    }
                }
            }
            //posiitons
        }
        //workers
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNumberOfScheduledHours</Name>
				<Source><![CDATA[
    private void setNumberOfScheduledHours(str _mapKey, CalendarId _calendarId, TransDate _transDate)
    {
        WorkCalendarDateLine    workCalendarDateLine;
        CalendarId              currentCalendarId;

        currentCalendarId = this.getWorkCalendarDefined(_calendarId, _transDate);

        // Retrieve the combined number of hours scheduled to be worked.
        select sum(ToTime), sum(FromTime) from workCalendarDateLine
            group by TransDate
            where workCalendarDateLine.CalendarId == currentCalendarId
                && workCalendarDateLine.TransDate == _transDate
                && workCalendarDateLine.Effectivity > 0;

        // Cache the aggregated From and To time results per _calendarId, _transDate.
        workCalendarDateLineMap.insert(_mapKey, workCalendarDateLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Version     version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;

                break;

            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxRegionSetForWorkerPosition</Name>
				<Source><![CDATA[
    private boolean validateTaxRegionSetForWorkerPosition()
    {
        boolean                     ret;

        ret = true;

        if (currentWorkerTaxRegionRecId == 0)
        {
            ret = ret && checkFailed(strFmt("@Payroll:WorkerEarningsWereNotCreatedForPosition1SelectADefaultTaxReg", HcmPosition::find(positionRecId).PositionId, HcmWorker::find(workerRecId).PersonnelNumber));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustSalaryEarning</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates or updates the salary earning line for a specific Worker and Position combination for a given pay period
    /// </summary>
    /// <param name="_payPeriodRecId">
    /// The RecId of the record in <c>PayrollPayPeriod</c> table.
    /// </param>
    /// <param name="_workerRecId">
    /// The RecId of the record in <c>HcmWorker</c> table.
    /// </param>
    /// <param name="_positionRecId">
    /// The RecId of the record in <c>HcmPosition</c> table.
    /// </param>
    public static void adjustSalaryEarning(PayrollPayPeriodRecId _payPeriodRecId, HcmWorkerRecId _workerRecId, HcmPositionRecId _positionRecId)
    {
        PayrollEarningGenerationTask    earningGenerationTask = new PayrollEarningGenerationTask();

        earningGenerationTask.parmPayPeriodRecId(_payPeriodRecId);
        earningGenerationTask.initFromPayPeriod();
        earningGenerationTask.initFromWorkerPosition(_workerRecId, _positionRecId);
        if (earningGenerationTask.isPositionWorkerAssignmentActivePeriod() && earningGenerationTask.validateTaxRegionSetForWorkerPosition())
        {
            earningGenerationTask.createWorkerPositionSalaryEarning();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>PayrollEarningGenerationTask</c> class.
    /// </summary>
    /// <param name="_caller">
    ///     The <c>Object</c> calling the class.
    /// </param>
    /// <returns>
    ///    An instance of the <c>PayrollEarningGenerationTask</c> class.
    /// </returns>
    public static PayrollEarningGenerationTask construct(Object _caller = null)
    {
        PayrollEarningGenerationTask earningGenerationTask = new PayrollEarningGenerationTask();

        if (_caller != null && _caller is PayrollEarningStatementGeneration)
        {
            earningGenerationTask.parmEarningStatementSet(new Set(Types::Int64));
            earningGenerationTask.parmMaintainEarningStatementSet(true);
        }

        return earningGenerationTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEditedOrProcessedLineExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if any edited or payment processed earnings statement line exists for the provided period date.
    /// </summary>
    /// <param name="_statementRecId">
    /// The RecId of the record in <c>PayrollEarningStatement</c> table.
    /// </param>
    /// <param name="_positionRecId">
    /// The RecId of the record in <c>HcmPosition</c> table.
    /// </param>
    /// <param name="_periodDate">
    /// The individual date value for which the leave earning statement line to generate.
    /// </param>
    /// <returns>
    /// true if any edited or payment processed earnings statement line found; otherwise false.
    /// </returns>
    private static boolean  isEditedOrProcessedLineExists(PayrollEarningStatementRecId _statementRecId, HcmPositionRecId _positionRecId, TransDate _periodDate)
    {
        PayrollEarningStatementLine     payrollEarningStatementLine;

        select firstonly RecId from payrollEarningStatementLine
            where payrollEarningStatementLine.EarningStatement == _statementRecId
                && payrollEarningStatementLine.Position == _positionRecId
                && payrollEarningStatementLine.EarningDate == _periodDate
                && (payrollEarningStatementLine.IsEdited == true
                    || payrollEarningStatementLine.PaymentStatus == PayrollPaymentProcessingStatus::Processed)
                && (payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::WorkerLeave
                    || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::PositionSchedule
                    || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::Imported
                    || payrollEarningStatementLine.GenerationSource == PayrollGenerationSource::UserEntry);

        return payrollEarningStatementLine.RecId > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasFixedCompPlan</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there is a valid fixed comp plan for the worker/position in the given date,
    /// Only check if the earning has one of 4 rate basis: Annually, Hourly, Monthly and PeyPeriod.
    /// </summary>
    /// <param name="_rateBasis">
    ///     The PayrollRateBasis values for the earning
    /// </param>
    /// <param name="_position">
    ///     The position RecId
    /// </param>
    /// <param name="_worker">
    ///     The worker RecId
    /// </param>
    /// <param name="_wageRateDate">
    ///     The earning date for the earning line
    /// </param>
    /// <returns>
    ///     false if no fixed comp plan exists when the rate basis is one of the 4 rate basis settings, true for any other conditions
    /// </returns>
    private boolean hasFixedCompPlan(PayrollRateBasis _rateBasis, HcmPositionRecId _position, HcmWorkerRecId _worker, TransDate _wageRateDate)
    {
        HRMCompFixedEmpl        fixedEmpl;
        HRMCompFixedPlanTable   fixedPlan;
        boolean                 retValue = true;

        switch (_rateBasis)
        {
            case PayrollRateBasis::Annually :
            case PayrollRateBasis::Hourly :
            case PayrollRateBasis::Monthly :
            case PayrollRateBasis::PayPeriod :

                select firstonly RecId from fixedEmpl
                join CurrencyCode from fixedPlan
                where fixedEmpl.Position == _position
                    && fixedEmpl.Worker == _worker
                    && fixedPlan.PlanId == fixedEmpl.PlanId
                    && fixedEmpl.ValidFrom <= _wageRateDate
                    && fixedEmpl.ValidTo >= _wageRateDate
                    && fixedPlan.ValidFrom <= _wageRateDate
                    && fixedPlan.ValidTo >= _wageRateDate;

                if (fixedEmpl.RecId == 0)
                {
                    retValue = false;
                }
                break;
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcHoursOfEarningsQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the base earning quantity that the hours of earnings rate basis will use.
    /// </summary>
    /// <param name="_basisEarningsGroup">
    ///     The basis earnings group used for the calculation.
    /// </param>
    /// <param name="_earningStatementRecId">
    ///     The earning statement used for the calculation.
    /// </param>
    /// <returns>
    ///     The value of quantity.
    /// </returns>
    /// <remarks>
    ///     This method uses the earning code group for the calculation of the quantity.
    /// </remarks>
    private static PayrollEarningQuantity calcHoursOfEarningsQuantity(
        PayrollEarningCodeGroupRecId _basisEarningsGroup,
        PayrollEarningStatementRecId _earningStatementRecId)
    {
        PayrollEarningStatement     payrollEarningStatement;
        PayrollEarningStatementLine payrollEarningStatementLine;
        PayrollEarningCodeGroupCode payrollEarningCodeGroupCode;

        select sum(Quantity) from payrollEarningStatementLine
            join RecId from payrollEarningStatement
                where payrollEarningStatementLine.EarningStatement == payrollEarningStatement.RecId
                    && payrollEarningStatement.RecId == _earningStatementRecId
                    && payrollEarningStatementLine.PaymentStatus != PayrollPaymentProcessingStatus::OnHold
            exists join payrollEarningCodeGroupCode
                where payrollEarningCodeGroupCode.EarningCodeGroup == _basisEarningsGroup
                    && payrollEarningCodeGroupCode.EarningCode == payrollEarningStatementLine.EarningCode;

        return payrollEarningStatementLine.Quantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPercentOfEarningRateBaseAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Calculates the base earning amount that the percent of earnings rate basis will use.
    /// </summary>
    /// <param name="_workerRecId">
    ///     The worker for which the rate is calculated.
    /// </param>
    /// <param name="_basisEarningsGroup">
    ///     The basis earnings group used for the calculation.
    /// </param>
    /// <param name="_earningStatementRecId">
    ///     The earning statement used for the calculation.
    /// </param>
    /// <returns>
    ///     The value of earning rate.
    /// </returns>
    /// <remarks>
    ///     This method uses the earning code group for the calculation of the earning rate.
    /// </remarks>
    private static PayrollEarningRate calcPercentOfEarningRateBaseAmount(
        PayrollEarningCodeGroupRecId _basisEarningsGroup,
        PayrollEarningStatementRecId _earningStatementRecId)
    {
        PayrollEarningStatement     payrollEarningStatement;
        PayrollEarningStatementLine payrollEarningStatementLine;
        PayrollEarningCodeGroupCode payrollEarningCodeGroupCode;

        select sum(AccountingCurrencyAmount) from payrollEarningStatementLine
            join RecId from payrollEarningStatement
                where payrollEarningStatementLine.EarningStatement == payrollEarningStatement.RecId
                    && payrollEarningStatement.RecId == _earningStatementRecId
                    && payrollEarningStatementLine.PaymentStatus != PayrollPaymentProcessingStatus::OnHold
            exists join payrollEarningCodeGroupCode
                where payrollEarningCodeGroupCode.EarningCodeGroup == _basisEarningsGroup
                    && payrollEarningCodeGroupCode.EarningCode == payrollEarningStatementLine.EarningCode;

        return payrollEarningStatementLine.AccountingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateFormulaEarningRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the product of default formula from the <c>PayrollEarningCode</c> table with the earning rate of the worker.
    /// </summary>
    /// <param name="_workerRecId">
    /// The <c>HcmWorker</c> table record Id.
    /// </param>
    /// <param name="_positionRecId">
    /// The <c>HcmPosition</c> table record Id.
    /// </param>
    /// <param name="_toDate">
    /// The end date of the pay period.
    /// </param>
    /// <param name="_rateBasis">
    /// The <c>PayrollRateBasis</c> field values on wich the rate needs to be calculated.
    /// </param>
    /// <param name="_timePeriod">
    /// The Payroll time period for the calculation.
    /// </param>
    /// <param name="_earningCode">
    /// The buffer of earning code for the calculation; optional.
    /// </param>
    /// <param name="_earningStatementRecId">
    /// The earning statement used for the calculation; optional.
    /// </param>
    /// <returns>
    /// The product of compensation and default formula for the pay period.
    /// </returns>
    public static PayrollEarningRate calculateFormulaEarningRate(HcmWorkerRecId  _workerRecId,
                                                            HcmPositionRecId _positionRecId,
                                                            TransDate _toDate,
                                                            PayrollRateBasis _rateBasis,
                                                            PayrollTimePeriod _timePeriod,
                                                            PayrollEarningCode _earningCode = null,
                                                            PayrollEarningStatementRecId _earningStatementRecId = 0)
    {
        AmountCur           earningCodeDefaultFormula;
        PayrollEarningRate  earningRate;

        // Get the default formula value from the earning code
        earningCodeDefaultFormula = PayrollEarningGenerationTask::getEarningsMultiplier(_workerRecId,
                                                        _positionRecId,
                                                        _toDate,
                                                        _earningCode);

        // Calculating the worker compensation value
        earningRate = PayrollEarningGenerationTask::computeEarningRate(_workerRecId,
                                                        _positionRecId,
                                                        _toDate,
                                                        _rateBasis,
                                                        _timePeriod,
                                                        _earningCode,
                                                        _earningStatementRecId);

        return earningCodeDefaultFormula * earningRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>computeEarningRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A generic method to retrieves the PayrollEarningRate for the worker.
    /// </summary>
    /// <param name="_workerRecId">
    /// The worker record Id.
    /// </param>
    /// <param name="_positionRecId">
    ///  The position record Id.
    /// </param>
    /// <param name="_toDate">
    ///  The end date of the pay period.
    /// </param>
    /// <param name="_rateBasis">
    ///  The <c>PayrollRateBasis</c> field values on wich the rate needs to be calculated.
    /// </param>
    /// <param name="_timePeriod">
    ///  The Payroll time period for the calculation.
    /// </param>
    /// <param name="_earningCode">
    ///  The buffer of earning code for the calculation; optional.
    /// </param>
    /// <param name="_earningStatementRecId">
    ///  The earning statement used for the calculation; optional.
    /// </param>
    /// <returns>
    ///  The compensation for the pay period.
    /// </returns>
    public static PayrollEarningRate computeEarningRate(HcmWorkerRecId  _workerRecId, HcmPositionRecId _positionRecId, TransDate _toDate, PayrollRateBasis _rateBasis, PayrollTimePeriod _timePeriod, PayrollEarningCode _earningCode = null, PayrollEarningStatementRecId _earningStatementRecId = 0)
    {
        HRMCompPayRateCumAmountMst earningRate = 0;

        switch (_rateBasis)
        {
            case PayrollRateBasis::FlatAmount :
            case PayrollRateBasis::HoursOfEarnings:
                earningRate = 1;
                break;

            case PayrollRateBasis::Hourly :
                earningRate = PayrollCompensationCalculate::hourlyPayRate(_positionRecId, _workerRecId, _toDate, _toDate);
                break;

            case PayrollRateBasis::Annually :
                earningRate = PayrollCompensationCalculate::calcRecurringEarnings(_positionRecId, _workerRecId, PayrollTimePeriod::Annually, _toDate);
                break;

            case PayrollRateBasis::Monthly :
                earningRate = PayrollCompensationCalculate::calcRecurringEarnings(_positionRecId, _workerRecId, PayrollTimePeriod::Monthly, _toDate);
                break;

            case PayrollRateBasis::PayPeriod :
                earningRate = PayrollCompensationCalculate::calcRecurringEarnings(_positionRecId, _workerRecId, _timePeriod, _toDate);
                break;

            case PayrollRateBasis::PercentOfEarnings:
                Debug::assert(_earningCode != null);
                earningRate = PayrollEarningGenerationTask::calcPercentOfEarningRateBaseAmount(_earningCode.BasisEarningGroup, _earningStatementRecId);
                break;

            case PayrollRateBasis::RegularRatePay:
                Debug::assert(_earningCode != null);
                earningRate = PayrollEarningRegularRatePayCalculate::calculateOvertimePremium(_positionRecId, _earningStatementRecId, _earningCode.data(), _toDate);
                break;
        }

        return earningRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEarningQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the earning quantity for the earning statement line to be created.
    /// </summary>
    /// <param name="_rateBasis">
    /// The <c>PayrollRateBasis</c> enum value on which the rate needs to be calculated.
    /// </param>
    /// <param name="_earningCode">
    /// The buffer of earning code for the calculation.
    /// </param>
    /// <param name="_earningStatementRecId">
    /// The earning statement used for the calculation.
    /// </param>
    /// <returns>
    /// The quantity for the earning statement line.
    /// </returns>
    public static PayrollEarningQuantity getEarningQuantity(PayrollRateBasis _rateBasis,
                                                    PayrollEarningCode _earningCode,
                                                    PayrollEarningStatementRecId _earningStatementRecId)
    {
        PayrollEarningQuantity earningQuantity;

        Debug::assert(_earningCode != null);
        switch (_rateBasis)
        {
            case PayrollRateBasis::HoursOfEarnings:
                earningQuantity = PayrollEarningGenerationTask::calcHoursOfEarningsQuantity(_earningCode.BasisEarningGroup, _earningStatementRecId);
                break;

            case PayrollRateBasis::RegularRatePay:
                earningQuantity = 0;
                break;
            default:
                earningQuantity = 1;
        }

        return earningQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEarningsMultiplier</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the formula value from the earning code.
    /// </summary>
    /// <param name="_workerRecId">
    /// The <c>Hcmworker</c> table record Id.
    /// </param>
    /// <param name="_positionRecId">
    /// The <c>HcmPosition</c> table record Id.
    /// </param>
    /// <param name="_toDate">
    /// The date to retrieve earning code version.
    /// </param>
    /// <param name="_earningCode">
    /// The <c>PayrollEarningCode</c> table record Id.
    /// </param>
    /// <returns>
    /// The formula value associated with the earning code.
    /// </returns>
    public static PayrollEarningCodeDefaultFormula getEarningsMultiplier(HcmWorkerRecId  _workerRecId, HcmPositionRecId _positionRecId, TransDate _toDate, PayrollEarningCode _earningCode)
    {
        PayrollEarningCode                  earningCode;
        PayrollEarningCodeDetail            earningCodeDetail;
        PayrollWorkerPositionEarningCode    workerPositionEarningCode;
        AmountCur                           earningCodeFormula;

        earningCode = PayrollEarningCode::find(_earningCode.RecId);
        earningCodeDetail = PayrollEarningCodeDetail::findByEarningCode(earningCode.RecId, _toDate);

        workerPositionEarningCode = PayrollWorkerPositionEarningCode::findByWorkerPositionEarningCode(
                                _workerRecId,
                                _positionRecId,
                                earningCode.RecId, _toDate);

        if (workerPositionEarningCode.RecId && earningCodeDetail.RateBasis != PayrollRateBasis::FlatAmount)
        {
            earningCodeFormula = workerPositionEarningCode.Formula;
        }
        else
        {
            earningCodeFormula = earningCodeDetail.DefaultFormula;
        }

        if (earningCodeDetail.RateBasis == PayrollRateBasis::RegularRatePay)
        {
            if (earningCodeFormula > 1)
            {
                earningCodeFormula = earningCodeFormula - 1;
            }
        }

        return earningCodeFormula;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable() 
    {
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>