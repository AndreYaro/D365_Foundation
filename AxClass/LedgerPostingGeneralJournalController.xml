<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerPostingGeneralJournalController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerPostingGeneralJournalController</c> class manages the records that are created at the
/// time of a transfer to the general journal.
/// </summary>
/// <remarks>
/// This method manages the <c>GeneralJournalAccountEntry</c>, <c>LedgerEntry</c>, and
/// <c>TaxTransGeneralJournalAccountEntry</c> tables.
/// </remarks>
public final class LedgerPostingGeneralJournalController
{
    SysInstrumentationLogger instrumentationLogger;

    boolean isReversal;
    NumberSeq journalNumberNumberSeq;

    // single record support
    LedgerEntryJournal ledgerEntryJournal;

    RecordSortedList generalJournalEntryCollection;
    Map generalJournalEntryRecIdValues;
    Map generalJournalEntryNaturalKeys;
    private Map tempLineIdToLineIdCollection;

    Set reversalLineRecordIdCollection;

    RecordSortedList detailGeneralJournalAccountEntryCollection;
    RecordSortedList summaryGeneralJournalAccountEntryCollection;

    // <GEEU>
    RecordSortedList generalJournalEntryWs;
    RecordSortedList detailGeneralJournalAccountEntryWs;
    RecordSortedList summaryGeneralJournalAccountEntryWs;
    boolean useGeneralJournalEntry_W;
    boolean useGeneralJournalAccountEntry_W;
    // </GEEU>

    Map lineCountByHeader;

    RecordSortedList detailLedgerEntryCollection;
    RecordSortedList summaryLedgerEntryCollection;

    LedgerPostingOneToManyCollection detailConsolidateHistoryLinkCollection;
    LedgerPostingOneToManyCollection summaryConsolidateHistoryLinkCollection;

    RecordSortedList detailTaxLinkCollection;
    RecordSortedList summaryTaxLinkCollection;

    RecordSortedList taxLinkGeneralJournalAccountEntryTransactionLink;

    // <GIN>
    boolean          isVATDeferment;
    RecordSortedList detailTaxWHTLinkCollection;
    RecordSortedList summaryTaxWHTLinkCollection;
    // </GIN>

    // These collections contain the ID values of
    // previously used general journal account entry records.
    Set detailGeneralJournalAccountEntryRecIdCollection;
    Set summaryGeneralJournalAccountEntryRecIdCollection;

    // This collection contains a mapping from the sorting fields for a general
    // journal account entry record to its temporary record ID. Each unique combination of
    // sorting fields requires a unique temporary record ID for the ledger entry
    // link.
    Map summaryGeneralJournalAccountEntryToTempLineId;

    RecId nextTempRecId;
    private RecId nextTempLineRecId;

    // <GSA>
    boolean isZakatEnabled;
    //</GSA>

    private boolean isGeneralLedgerCore;
    private boolean isGeneralLedgerMemReduceFlightEnabled;
    private boolean isLedgerPostingTransferLinesV2ReduceSQLCallsFlightEnabled;

    #define.ThrowForDuplicates(false)

    // <GEEU>
    #define.NoGeneralJournalEntryW(null)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>add</Name>
				<Source><![CDATA[
    // </GEEU>

    /// <summary>
    ///    Adds the specified information to the collection.
    /// </summary>
    /// <param name="_transferLevel">
    ///    The transfer level of the information.
    /// </param>
    /// <param name="_generalJournalEntry">
    ///    The general journal entry information.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The general journal account entry information.
    /// </param>
    /// <param name="_ledgerEntryJournal">
    ///    The ledger entry journal information.
    /// </param>
    /// <param name="_ledgerEntry">
    ///    The ledger entry information.
    /// </param>
    /// <param name="_taxLinkCollection">
    /// The collection of associated <c>TaxTrans</c> records and tax relationship types.
    /// </param>
    /// <param name="_crossCompanyTaxLinkCollections">
    /// A collection of cross company tax link collections; optional.
    /// </param>
    /// <param name="_generalJournalEntryW">
    ///    The country specific general journal entry information; optional.
    /// </param>
    /// <param name="_generalJournalAccountEntryW">
    ///    The country specific general journal account entry information; optional.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The ledger entry information would have been summarized to a different GeneralJournalEntry record.
    /// </exception>
    public void add(
        DetailSummary _transferLevel,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntryJournal _ledgerEntryJournal,
        LedgerEntry _ledgerEntry,
        LedgerPostingOneToManyCollection _taxLinkCollection,
        Map _crossCompanyTaxLinkCollections = null // optional for backward compatibility
        , GeneralJournalEntry_W _generalJournalEntryW = null
        , GeneralJournalAccountEntry_W _generalJournalAccountEntryW = null
        )
    {
        this.addCore(
            _transferLevel,
            _generalJournalEntry,
            _generalJournalAccountEntry,
            // <GEEU>
            _generalJournalEntryW,
            _generalJournalAccountEntryW,
            // </GEEU>
            _ledgerEntryJournal,
            _ledgerEntry,
            null, // LedgerConsolidateHist
            _taxLinkCollection,
            _crossCompanyTaxLinkCollections);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConsolidateHistory</Name>
				<Source><![CDATA[
    protected void addConsolidateHistory(
        LedgerPostingOneToManyCollection _consolidateHistoryCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerConsolidateHist _ledgerConsolidateHist)
    {
        if (_ledgerConsolidateHist != null)
        {
            Debug::assert(_generalJournalAccountEntry.RecId != 0);

            _consolidateHistoryCollection.add(_generalJournalAccountEntry.RecId, _ledgerConsolidateHist.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCore</Name>
				<Source><![CDATA[
    protected void addCore(
        DetailSummary _transferLevel,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalEntry_W _generalJournalEntryW,
        GeneralJournalAccountEntry_W _generalJournalAccountEntryW,
        LedgerEntryJournal _ledgerEntryJournal,
        LedgerEntry _ledgerEntry,
        LedgerConsolidateHist _ledgerConsolidateHist,
        LedgerPostingOneToManyCollection _taxLinkCollection,
        Map _crossCompanyTaxLinkCollections)
    {
        if (isGeneralLedgerCore)
        {
            // Posting in detail, for processes which impact core General ledger transaction tables only
            // Required: GeneralJournalAccountEntry, GeneralJournalEntry
            // Optional: GeneralJournalAccountEntry_W, GeneralJournalEntry_W
            this.addForGeneralLedgerCore(_generalJournalEntry, _generalJournalAccountEntry, _generalJournalEntryW, _generalJournalAccountEntryW);
        }
        else
        {
            GeneralJournalAccountEntry lineCopy;
            GeneralJournalEntry referenceCopy;

            // LedgerEntryJournal depends on nothing
            this.addJournal(_ledgerEntryJournal);

            // GeneralJournalEntry depends on nothing
            referenceCopy = this.addReference(_generalJournalEntry);

            if (useGeneralJournalEntry_W)
            {
                this.addReferenceW(referenceCopy, _generalJournalEntryW);
            }

            if (_transferLevel == DetailSummary::Detail)
            {
                // GeneralJournalAccountEntry depends on GeneralJournalEntry
                lineCopy = this.addLine(
                    _transferLevel,
                    detailGeneralJournalAccountEntryCollection,
                    detailGeneralJournalAccountEntryRecIdCollection,
                    referenceCopy,
                    _generalJournalAccountEntry,
                    _generalJournalAccountEntryW);

                // LedgerConsolidateHist depends on GeneralJournalAccountEntry
                this.addConsolidateHistory(
                    detailConsolidateHistoryLinkCollection,
                    lineCopy,
                    _ledgerConsolidateHist);

                // LedgerEntry depends on GeneralJournalAccountEntry
                this.addEntry(
                    detailLedgerEntryCollection,
                    lineCopy,
                    _ledgerEntry);

                if (useGeneralJournalAccountEntry_W)
                {
                    // GeneralJournalAccountEntry_W depends on GeneralJournalAccountEntry
                    this.addLineW(detailGeneralJournalAccountEntryWs, lineCopy, _generalJournalAccountEntryW);
                }

                // Only handle on async logic for now
                if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode()
                    && !TaxTrans::existForVoucher(_generalJournalEntry.SubledgerVoucher))
                {
                    this.processTransactionLinks(
                        taxLinkGeneralJournalAccountEntryTransactionLink,
                        lineCopy,
                        _taxLinkCollection);
                }
                else
                {
                    // TaxTransGeneralJournalAccountEntry depends on GeneralJournalAccountEntry
                    this.processTaxLinks(
                        detailTaxLinkCollection,
                        lineCopy,
                        _taxLinkCollection,
                        _crossCompanyTaxLinkCollections);
                }

                // <GIN>
                if (TaxWithholdParameters_IN::checkTaxParameters()
                    && (lineCopy.PostingType == LedgerPostingType::TDS_IN
                        || lineCopy.PostingType == LedgerPostingType::TCS_IN))
                {
                    // TaxWHTTransGeneralJournalAccountEntry_IN depends on GeneralJournalAccountEntry
                    this.addTaxWithholdLink_IN(
                        detailTaxWHTLinkCollection,
                        lineCopy,
                        _taxLinkCollection);
                }
                // </GIN>
            }
            else
            {
                // GeneralJournalAccountEntry depends on GeneralJournalEntry
                lineCopy = this.addLine(
                    _transferLevel,
                    summaryGeneralJournalAccountEntryCollection,
                    summaryGeneralJournalAccountEntryRecIdCollection,
                    referenceCopy,
                    _generalJournalAccountEntry,
                    _generalJournalAccountEntryW
                );

                // LedgerConsolidateHist depends on GeneralJournalAccountEntry
                this.addConsolidateHistory(
                    summaryConsolidateHistoryLinkCollection,
                    lineCopy,
                    _ledgerConsolidateHist);

                // LedgerEntry depends on GeneralJournalAccountEntry
                this.addEntry(
                    summaryLedgerEntryCollection,
                    lineCopy,
                    _ledgerEntry);

                // <GEEU>
                // GeneralJournalAccountEntry_W depends on GeneralJournalAccountEntry
                if (useGeneralJournalAccountEntry_W)
                {
                    this.addLineW(summaryGeneralJournalAccountEntryWs, lineCopy, _generalJournalAccountEntryW);
                }
                // </GEEU>

                if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode()
                    && !TaxTrans::existForVoucher(_generalJournalEntry.SubledgerVoucher))
                {
                    this.processTransactionLinks(
                        taxLinkGeneralJournalAccountEntryTransactionLink,
                        lineCopy,
                        _taxLinkCollection);
                }
                else
                {
                    // TaxTransGeneralJournalAccountEntry depends on GeneralJournalAccountEntry
                    this.processTaxLinks(
                        summaryTaxLinkCollection,
                        lineCopy,
                        _taxLinkCollection,
                        _crossCompanyTaxLinkCollections);
                }

                // <GIN>
                if (TaxWithholdParameters_IN::checkTaxParameters()
                    && (lineCopy.PostingType == LedgerPostingType::TDS_IN
                        || lineCopy.PostingType == LedgerPostingType::TCS_IN))
                {
                    // TaxWHTTransGeneralJournalAccountEntry_IN depends on GeneralJournalAccountEntry
                    this.addTaxWithholdLink_IN(
                        summaryTaxWHTLinkCollection,
                        lineCopy,
                        _taxLinkCollection);
                }
                // </GIN>
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addEntry</Name>
				<Source><![CDATA[
    // LedgerEntry and Entry refer to the LedgerEntry table
    protected void addEntry(
        RecordSortedList _entryCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry)
    {
        LedgerEntry entryCopy;
        boolean success;

        if (_ledgerEntry.BankDataAreaId != ''
            || _ledgerEntry.CompanyBankAccount != ''
            || _ledgerEntry.ConsolidatedCompany != ''
            || _ledgerEntry.IsBridgingPosting
            || _ledgerEntry.IsExchangeAdjustment
            || _ledgerEntry.PaymentMode != ''
            || _ledgerEntry.ThirdPartyBankAccount != '')
        {
            Debug::assert(_generalJournalAccountEntry.RecId != 0);

            entryCopy.RecId = _generalJournalAccountEntry.RecId;
            if (!_entryCollection.find(entryCopy))
            {
                // duplicates occur naturally during summarization, ignore the duplicates and keep the first one added

                // each LedgerEntry relates to one GeneralJournalAccountEntry
                entryCopy.data(_ledgerEntry);
                entryCopy.RecId = _generalJournalAccountEntry.RecId;
                entryCopy.GeneralJournalAccountEntry = entryCopy.RecId;

                success = _entryCollection.ins(entryCopy);
                Debug::assert(success);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addForConsolidate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified information to the collection.
    /// </summary>
    /// <param name="_generalJournalEntry">
    ///    The general journal entry information.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The general journal account entry information.
    /// </param>
    /// <param name="_ledgerEntry">
    ///    The ledger entry information.
    /// </param>
    /// <param name="_ledgerConsolidateHist">
    ///    The ledger consolidation history.
    /// </param>
    /// <param name="_generalJournalAccountEntryW">
    ///    The general journal account entry country context information; optional.
    /// </param>
    /// <remarks>
    ///    This method is used for the ledger consolidation operation.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The ledger consolidation history is null.
    /// </exception>
    /// <exception cref="M:Exception::Error">
    ///    The ledger entry information would have been summarized to a different GeneralJournalEntry record.
    /// </exception>
    public void addForConsolidate(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry,
        LedgerConsolidateHist _ledgerConsolidateHist
        , GeneralJournalAccountEntry_W _generalJournalAccountEntryW = null
        )
    {
        if (_ledgerConsolidateHist == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        this.getGeneralJournalEntryRecId(_generalJournalEntry);

        this.addCore(
            DetailSummary::Detail,
            _generalJournalEntry,
            _generalJournalAccountEntry,
            // <GEEU>
            #NoGeneralJournalEntryW,
            _generalJournalAccountEntryW,
            // </GEEU>
            null, // LedgerEntryJournal
            _ledgerEntry,
            _ledgerConsolidateHist,
            null, // tax trans link collection
            null); // cross company tax link collection
    }

]]></Source>
			</Method>
			<Method>
				<Name>addForUtility</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified information to the collection.
    /// </summary>
    /// <param name="_generalJournalEntry">
    ///    The general journal entry information.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The general journal account entry information.
    /// </param>
    /// <param name="_ledgerEntry">
    ///    The ledger entry information; optional.
    /// </param>
    /// <param name="_generalJournalEntryW">
    ///    The country specific general journal entry information; optional.
    /// </param>
    /// <param name="_generalJournalAccountEntryW">
    ///    The country specific general journal account entry information; optional.
    /// </param>
    /// <remarks>
    ///    This method is used for utility operations that transfer core general journal data in detail.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The ledger entry information would have been summarized to a different GeneralJournalEntry record.
    /// </exception>
    public void addForUtility(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry = null
        , GeneralJournalEntry_W _generalJournalEntryW = null
        , GeneralJournalAccountEntry_W _generalJournalAccountEntryW = null
        )
    {

        this.getGeneralJournalEntryRecId(_generalJournalEntry);

        this.addCore(
            DetailSummary::Detail,
            _generalJournalEntry,
            _generalJournalAccountEntry,
            // <GEEU>
            _generalJournalEntryW,
            _generalJournalAccountEntryW,
            // </GEEU>
            null, // LedgerEntryJournal
            _ledgerEntry,
            null, // LedgerConsolidateHist
            null, // tax trans link collection
            null); // cross company tax link collection
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>addJournal</Name>
				<Source><![CDATA[
    protected void addJournal(LedgerEntryJournal _ledgerEntryJournal)
    {
        if (ledgerEntryJournal.JournalNumber == '')
        {
            ledgerEntryJournal = _ledgerEntryJournal;
        }
        else if (ledgerEntryJournal.JournalNumber != _ledgerEntryJournal.JournalNumber)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        // do nothing if non-empty journal numbers match
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>GeneralJournalAccountEntry</c> table.
    /// </summary>
    /// <param name = "_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> table buffer.
    /// </param>
    /// <param name = "_generalJournalEntry">
    /// The <c>GeneralJournalEntry</c> table buffer.
    /// </param>
    /// <param name = "_transferLevel">
    /// The Transfer level.
    /// </param>
    /// <param name = "_generalJournalAccountEntryW">
    /// The <c>GeneralJournalAccountEntry_W</c> table buffer.
    /// </param>
    /// <returns>
    /// The initialized <c>GeneralJournalAccountEntry</c> record.
    /// </returns>
    protected GeneralJournalAccountEntry initGeneralJournalAccountEntry(GeneralJournalAccountEntry _generalJournalAccountEntry, GeneralJournalEntry _generalJournalEntry, DetailSummary _transferLevel, GeneralJournalAccountEntry_W _generalJournalAccountEntryW)
    {
        GeneralJournalAccountEntry generalJournalAccountEntryCopy;

        generalJournalAccountEntryCopy.data(_generalJournalAccountEntry);
        generalJournalAccountEntryCopy.GeneralJournalEntry = _generalJournalEntry.RecId;

        return generalJournalAccountEntryCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLine</Name>
				<Source><![CDATA[
    // GeneralJournalAccountEntry and Line refer to the GeneralJournalAccountEntry table
    protected GeneralJournalAccountEntry addLine(
        DetailSummary _transferLevel,
        RecordSortedList _lineCollection,
        Set _tempLineIdCollection,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry
        , GeneralJournalAccountEntry_W _generalJournalAccountEntryW
        )
    {
        GeneralJournalAccountEntry lineCopy;
        boolean success;
        RecId tempLineId;
        container lineValues;

        if ((_transferLevel == DetailSummary::Summary) && (_generalJournalAccountEntry.RecId != 0))
        {
            // specifying the RecId when in summary is not allowed because it would have to be ignored
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        linecopy = this.initGeneralJournalAccountEntry(_generalJournalAccountEntry, _generalJournalEntry, _transferLevel, _generalJournalAccountEntryW);

        if (_transferLevel == DetailSummary::Detail && (lineCopy.RecId == 0 || isReversal))
        {
            // no summarization

            if (isReversal && lineCopy.RecId != 0)
            {
                // valid reversal

                if (reversalLineRecordIdCollection.in(lineCopy.RecId))
                {
                    // can't reverse the same record ID more than once
                    throw error(Error::wrongUseOfFunction(funcName()));
                }

                reversalLineRecordIdCollection.add(lineCopy.RecId);
            }
            else
            {
                // assign a temporary record ID even if it has a
                // record ID to make sure we don't get a duplicate
                lineCopy.RecId = this.getNextTemporaryRecId();
            }

            success = _lineCollection.ins(lineCopy);
            Debug::assert(success);

            Debug::assert(!_tempLineIdCollection.in(lineCopy.RecId));

            _tempLineIdCollection.add(lineCopy.RecId);

            this.incrementCountForRecId(lineCountByHeader, lineCopy.GeneralJournalEntry);
        }
        else
        {
            // summarization

            // convert the sort fields to a temporary record ID so that incoming
            // records with duplicate record ID values are appropriately combined
            // or kept separate which is important for ledger entry record linking

            lineValues = this.getLineValues(_transferLevel, lineCopy
                // <GEEU>
                , _generalJournalAccountEntryW
                // </GEEU>
                );

            if (summaryGeneralJournalAccountEntryToTempLineId.exists(lineValues))
            {
                lineCopy.RecId = summaryGeneralJournalAccountEntryToTempLineId.lookup(lineValues);
            }
            else
            {
                tempLineId = this.getNextTemporaryRecId();

                summaryGeneralJournalAccountEntryToTempLineId.insert(lineValues, tempLineId);

                lineCopy.RecId = tempLineId;
            }

            if (_lineCollection.find(lineCopy))
            {
                if (lineCopy.ReasonRef != _generalJournalAccountEntry.ReasonRef)
                {
                    lineCopy.ReasonRef = 0;
                }

                lineCopy.TransactionCurrencyAmount += _generalJournalAccountEntry.TransactionCurrencyAmount;
                lineCopy.AccountingCurrencyAmount += _generalJournalAccountEntry.AccountingCurrencyAmount;
                lineCopy.ReportingCurrencyAmount += _generalJournalAccountEntry.ReportingCurrencyAmount;

                lineCopy.Quantity += _generalJournalAccountEntry.Quantity;

                success = _lineCollection.ins(lineCopy, true);

                // RecordSortedList.Ins always returns false after a find so assert it is false
                Debug::assert(!success);
            }
            else
            {
                Debug::assert(!_tempLineIdCollection.in(lineCopy.RecId));

                _tempLineIdCollection.add(lineCopy.RecId);

                success = _lineCollection.ins(lineCopy);
                Debug::assert(success);

                this.incrementCountForRecId(lineCountByHeader, lineCopy.GeneralJournalEntry);
            }
        }

        return lineCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLineW</Name>
				<Source><![CDATA[
    // GeneralJournalAccountEntryW and LineW refer to the GeneralJournalAccountEntry_W table
    protected void addLineW(
        RecordSortedList _lineWCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalAccountEntry_W _generalJournalAccountEntryW)
    {
        GeneralJournalAccountEntry_W lineWCopy;
        boolean success;

        lineWCopy.GeneralJournalAccountEntry = _generalJournalAccountEntry.RecId;
        if (!_lineWCollection.find(lineWCopy))
        {
            // duplicates occur naturally during summarization, ignore the duplicates and keep the first one added
            lineWCopy.data(_generalJournalAccountEntryW);
            lineWCopy.GeneralJournalAccountEntry = _generalJournalAccountEntry.RecId;

            success = _lineWCollection.ins(lineWCopy);
            Debug::assert(success);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReference</Name>
				<Source><![CDATA[
    // GeneralJournalEntry, Reference, and Header all refer to the GeneralJournalEntry table
    protected GeneralJournalEntry addReference(GeneralJournalEntry _generalJournalEntry)
    {
        GeneralJournalEntry referenceCopy;
        boolean success;

        if (_generalJournalEntry.RecId == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        referenceCopy.RecId = _generalJournalEntry.RecId;

        if (generalJournalEntryCollection.find(referenceCopy))
        {
            referenceCopy.data(_generalJournalEntry);
            success = generalJournalEntryCollection.ins(referenceCopy, true);

            // RecordSortedList.Ins always returns false after a find so assert it is false
            Debug::assert(!success);
        }
        else
        {
            referenceCopy.data(_generalJournalEntry);
            success = generalJournalEntryCollection.ins(referenceCopy);
            Debug::assert(success);
        }

        return referenceCopy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReferenceW</Name>
				<Source><![CDATA[
    // GeneralJournalEntryW, ReferenceW, and HeaderW all refer to the GeneralJournalEntry_W table
    protected void addReferenceW(GeneralJournalEntry _generalJournalEntry, GeneralJournalEntry_W _generalJournalEntryW)
    {
        GeneralJournalEntry_W referenceWCopy;
        boolean success;

        _generalJournalEntryW.RecId = _generalJournalEntry.RecId;

        if (_generalJournalEntryW.RecId == 0)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        referenceWCopy.RecId = _generalJournalEntryW.RecId;
        if (generalJournalEntryWs.find(referenceWCopy))
        {
            referenceWCopy.data(_generalJournalEntry);
            success = generalJournalEntryWs.ins(referenceWCopy, true);

            // RecordSortedList.Ins always returns false after a find so assert it is false
            Debug::assert(!success);
        }
        else
        {
            referenceWCopy.data(_generalJournalEntryW);
            success = generalJournalEntryWs.ins(referenceWCopy);
            Debug::assert(success);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxLink</Name>
				<Source><![CDATA[
    protected void addTaxLink(
        RecordSortedList _taxLinkCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        TableId _linkTableId,
        LedgerPostingOneToManyCollection _taxLinks)
    {
        Set relationshipCollection;
        SetEnumerator enumerator;
        TaxTransGeneralJournalAccountEntry taxLink;
        TaxTransRelationshipType taxRelationshipType;
        boolean haveMore;
        boolean isTaxTrans;
        boolean success;
        RecId taxSource;
        AmountMST accountingCurrencyAmount;
        AmountCur transactionCurrencyAmount;

        isTaxTrans = _linkTableId == tableNum(TaxTrans);

        haveMore = _taxLinks.first();
        while (haveMore)
        {
            taxSource = _taxLinks.currentOne();
            relationshipCollection = _taxLinks.currentMany();

            enumerator = relationshipCollection.getEnumerator();
            while (enumerator.moveNext())
            {
                [taxRelationshipType, accountingCurrencyAmount, transactionCurrencyAmount] = enumerator.current();

                taxLink = null;
                taxLink.GeneralJournalAccountEntry = _generalJournalAccountEntry.RecId;
                taxLink.TaxTransRelationship = taxRelationshipType;

                if (isTaxTrans)
                {
                    taxLink.TaxTrans = taxSource;
                    taxLink.TaxUncommitted = 0;
                }
                else
                {
                    taxLink.TaxTrans = 0;
                    taxLink.TaxUncommitted = taxSource;
                }

                if (!_taxLinkCollection.find(taxLink))
                {
                    // duplicates occur naturally during summarization, ignore the duplicates and keep the first one added
                    taxLink.GeneralJournalAccountEntry = _generalJournalAccountEntry.RecId;
                    taxLink.TaxTransRelationship = taxRelationshipType;
                    taxLink.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;

                    if (isTaxTrans)
                    {
                        taxLink.TaxTrans = taxSource;
                        taxLink.TaxUncommitted = 0;
                    }
                    else
                    {
                        taxLink.TaxTrans = 0;
                        taxLink.TaxUncommitted = taxSource;
                    }

                    taxLink.AccountingCurrencyAmount = accountingCurrencyAmount;
                    taxLink.TransactionCurrencyAmount = transactionCurrencyAmount;
                    taxLink.TransactionCurrency = _generalJournalAccountEntry.TransactionCurrencyCode;
                    // In legacy posting allocation factor is always 1.
                    taxLink.AllocationFactor = 1;

                    success = _taxLinkCollection.ins(taxLink);
                    Debug::assert(success);
                }
            }

            haveMore = _taxLinks.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTaxWithholdLink_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified information to the collection.
    /// </summary>
    /// <param name="_taxWHTLinkCollection">
    ///    The collection of associated taxWithhold transactions records are to be in sorted List.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The general journal account entry information.
    /// </param>
    /// <param name="_taxWHTLinks">
    ///    The collection of associated taxWithhold transactions and tax relationship types.
    /// </param>
    protected void addTaxWithholdLink_IN(
        RecordSortedList _taxWHTLinkCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerPostingOneToManyCollection _taxWHTLinks)
    {
        Set                                         relationshipCollection;
        SetEnumerator                               enumerator;
        TaxWHTTransGeneralJournalAccountEntry_IN    taxWHTLink;
        TaxTransRelationshipType                    taxRelationshipType;
        boolean                                     haveMore;
        boolean                                     success;
        RecId                                       taxWithholdTrans;

        if (_taxWHTLinks == null)
        {
            return;
        }

        Debug::assert(_generalJournalAccountEntry.RecId != 0);

        haveMore = _taxWHTLinks.first();
        while (haveMore)
        {
            taxWithholdTrans = _taxWHTLinks.currentOne();
            relationshipCollection = _taxWHTLinks.currentMany();

            enumerator = relationshipCollection.getEnumerator();
            while (enumerator.moveNext())
            {
                // the TaxTransRelationshipType is the first object in the container
                taxRelationshipType = conPeek(enumerator.current(), 1);

                taxWHTLink.GeneralJournalAccountEntry = _generalJournalAccountEntry.RecId;
                taxWHTLink.TaxWithholdTrans           = taxWithholdTrans;
                taxWHTLink.TaxWHTTransRelationship    = taxRelationshipType;

                if (!_taxWHTLinkCollection.find(taxWHTLink))
                {
                    // duplicates occur naturally during summarization, ignore the duplicates and keep the first one added
                    taxWHTLink.GeneralJournalAccountEntry   = _generalJournalAccountEntry.RecId;
                    taxWHTLink.TaxWithholdTrans             = taxWithholdTrans;
                    taxWHTLink.TaxWHTTransRelationship      = taxRelationshipType;
                    taxWHTLink.LedgerDimension              = _generalJournalAccountEntry.LedgerDimension;

                    success = _taxWHTLinkCollection.ins(taxWHTLink);
                    Debug::assert(success);
                }
            }

            haveMore = _taxWHTLinks.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReferenceCollection</Name>
				<Source><![CDATA[
    private RecordSortedList createReferenceCollection()
    {
        RecordSortedList newList;

        newList = new RecordSortedList(tableNum(GeneralJournalEntry));
        newList.sortOrder(fieldNum(GeneralJournalEntry, RecId));

        return newList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalEntryRecId</Name>
				<Source><![CDATA[
    private void getGeneralJournalEntryRecId(GeneralJournalEntry _generalJournalEntry)
    {
        #localMacro.GeneralJournalEntryNaturalKey
            _generalJournalEntry.Ledger,
            _generalJournalEntry.SubledgerVoucher,
            _generalJournalEntry.SubledgerVoucherDataAreaId,
            _generalJournalEntry.AccountingDate,
            _generalJournalEntry.FiscalCalendarPeriod,
            _generalJournalEntry.PostingLayer
        #endMacro

        if (_generalJournalEntry.RecId != 0)
        {
            return;
        }

        if (generalJournalEntryNaturalKeys == null)
        {
            generalJournalEntryNaturalKeys = new Map(Types::Container, Types::Int64);
        }

        if (generalJournalEntryNaturalKeys.exists([#GeneralJournalEntryNaturalKey]))
        {
            _generalJournalEntry.RecId = generalJournalEntryNaturalKeys.lookup([#GeneralJournalEntryNaturalKey]);
        }
        else
        {
            _generalJournalEntry.RecId = this.getNextTemporaryRecId();
            generalJournalEntryNaturalKeys.insert([#GeneralJournalEntryNaturalKey], _generalJournalEntry.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGeneralJournalEntryRecIdValues</Name>
				<Source><![CDATA[
    public Map getGeneralJournalEntryRecIdValues()
    {
        return generalJournalEntryRecIdValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerEntrySortOrder</Name>
				<Source><![CDATA[
    private container getLedgerEntrySortOrder()
    {
        return [fieldNum(LedgerEntry, RecId)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineValues</Name>
				<Source><![CDATA[
    protected container getLineValues(
        DetailSummary _transferLevel,
        GeneralJournalAccountEntry _generalJournalAccountEntry
        , GeneralJournalAccountEntry_W _generalJournalAccountEntryW
        )
    {
        container lineValues = this.initLineValuesContainer(_generalJournalAccountEntry, _generalJournalAccountEntryW);

        if (_transferLevel == DetailSummary::Detail)
        {
            // The detail option supports summarization using the RecId and
            // requires the same initial sorting as the summary option.
            lineValues += _generalJournalAccountEntry.RecId;
        }

        return lineValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLineValuesContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the required field values from <c>GeneralJournalAccountEntry</c> record into container.
    /// </summary>
    /// <param name = "_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <param name = "_generalJournalAccountEntryW">
    /// The country specific <c>GeneralJournalAccountEntry_W</c> record.
    /// </param>
    /// <returns>
    /// The initialized container.
    /// </returns>
    protected container initLineValuesContainer(GeneralJournalAccountEntry _generalJournalAccountEntry,
                                                GeneralJournalAccountEntry_W _generalJournalAccountEntryW)
    {
        container lineValues = [_generalJournalAccountEntry.LedgerDimension,
                               _generalJournalAccountEntry.TransactionCurrencyCode,
                               _generalJournalAccountEntry.AllocationLevel,
                               _generalJournalAccountEntry.HistoricalExchangeRateDate,
                               _generalJournalAccountEntry.IsCorrection,
                               _generalJournalAccountEntry.PostingType,
                               _generalJournalAccountEntry.PaymentReference,
                               _generalJournalAccountEntry.GeneralJournalEntry,
                               // <GEERU>
                               _generalJournalAccountEntryW.BondBatchTrans_RU
                               // </GEERU>
                               ];

        return lineValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextTemporaryRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a temporary record ID.
    /// </summary>
    /// <returns>
    /// A temporary record ID.
    /// </returns>
    /// <remarks>
    /// The values start at one to avoid conflict with actual record ID values that
    /// are provided by callers.
    /// </remarks>
    public RecId getNextTemporaryRecId()
    {
        nextTempRecId++;

        return nextTempRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextTemporaryLineRecId</Name>
				<Source><![CDATA[
    private RecId getNextTemporaryLineRecId()
    {
        nextTempLineRecId++;

        return nextTempLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxLinkSortOrder</Name>
				<Source><![CDATA[
    private container getTaxLinkSortOrder()
    {
        return
            [fieldNum(TaxTransGeneralJournalAccountEntry, GeneralJournalAccountEntry),
            // both the TaxTrans and TaxUncommitted fields are included but the
            // value of one of them is always zero because the table contains two
            // different kinds of records
            fieldNum(TaxTransGeneralJournalAccountEntry, TaxTrans),
            fieldNum(TaxTransGeneralJournalAccountEntry, TaxUncommitted),
            fieldNum(TaxTransGeneralJournalAccountEntry, TaxTransRelationship)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdLinkSortOrder_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// To get the collection of associated taxWithhold transactions records in sorted order.
    /// </summary>
    /// <returns>
    ///  To return the field values of the Table TaxWHTTransGeneralJournalAccountEntry_IN.
    /// </returns>
    private container getTaxWithholdLinkSortOrder_IN()
    {
        return
            [fieldNum(TaxWHTTransGeneralJournalAccountEntry_IN, GeneralJournalAccountEntry),
            fieldNum(TaxWHTTransGeneralJournalAccountEntry_IN, TaxWithholdTrans),
            fieldNum(TaxWHTTransGeneralJournalAccountEntry_IN, TaxWHTTransRelationship)];
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementCountForRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Increments the count value in a specified map for a specified record ID key.
    /// </summary>
    /// <param name="_countMap">
    /// The specified map.
    /// </param>
    /// <param name="_recIdKey">
    /// The specified record ID key.
    /// </param>
    /// <returns>
    /// The updated count for the record ID key.
    /// </returns>
    /// <remarks>
    /// The value is used as the count.
    /// </remarks>
    private int64 incrementCountForRecId(Map _countMap, RecId _recIdKey)
    {
        int64 value;

        if (_countMap.exists(_recIdKey))
        {
            value = _countMap.lookup(_recIdKey) + 1;
        }
        else
        {
            value = 1;
        }

        _countMap.insert(_recIdKey, value);

        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineIsValidForTransfer</Name>
				<Source><![CDATA[
    private boolean lineIsValidForTransfer(
       DetailSummary _transferLevel,
       GeneralJournalAccountEntry _line,
       int64 _currentLine,
       int64 _lineCount,
       Set _lineCreatedForHeader,
       boolean _lineHasAmount,
       Map _allLinesSummarizedToZeroForHeaderStatusCollection)
    {
        boolean isValid;

        if (_transferLevel == DetailSummary::Detail)
        {
            isValid = (_lineHasAmount 
                || (_currentLine == _lineCount && !_lineCreatedForHeader.in(_line.GeneralJournalEntry)));
        }
        else
        {
            if (_lineHasAmount)
            {
                isValid = true;
            }
            else if (!_lineHasAmount)
            {
                // If other transactions have been added to the journal which are not summarized to zero, they should be ignored
                boolean headerAllLinesSummarizedToZero = _allLinesSummarizedToZeroForHeaderStatusCollection.lookup(_line.GeneralJournalEntry);

                if (headerAllLinesSummarizedToZero)
                {
                    isValid = true;
                }
            }
        }
        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        journalNumberNumberSeq = NumberSeq::newGetNum(LedgerParameters::numRefGeneralJournalEntryJournalNumber());

        summaryGeneralJournalAccountEntryToTempLineId = new Map(Types::Container, Types::Int64);

        // <GEEU>
        useGeneralJournalEntry_W = GeneralJournalEntry_W::isLegalEntityInCountryRegion();
        useGeneralJournalAccountEntry_W = GeneralJournalAccountEntry_W::isLegalEntityInCountryRegion();

        if (useGeneralJournalEntry_W)
        {
            generalJournalEntryWs = new RecordSortedList(tableNum(GeneralJournalEntry_W));
            generalJournalEntryWs.sortOrder(fieldNum(GeneralJournalEntry_W, RecId));
        }

        if (useGeneralJournalAccountEntry_W)
        {
            detailGeneralJournalAccountEntryWs = new RecordSortedList(tableNum(GeneralJournalAccountEntry_W));
            summaryGeneralJournalAccountEntryWs = new RecordSortedList(tableNum(GeneralJournalAccountEntry_W));

            detailGeneralJournalAccountEntryWs.sortOrder(fieldNum(GeneralJournalAccountEntry_W, GeneralJournalAccountEntry));
            summaryGeneralJournalAccountEntryWs.sortOrder(fieldNum(GeneralJournalAccountEntry_W, GeneralJournalAccountEntry));
        }
        // </GEEU>

        generalJournalEntryCollection = this.createReferenceCollection();
        generalJournalEntryRecIdValues = new Map(Types::Container, Types::Int64);

        reversalLineRecordIdCollection = new Set(Types::Int64);

        detailGeneralJournalAccountEntryCollection = new RecordSortedList(tableNum(GeneralJournalAccountEntry));

        summaryGeneralJournalAccountEntryCollection = new RecordSortedList(tableNum(GeneralJournalAccountEntry));

        detailGeneralJournalAccountEntryCollection.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));
        summaryGeneralJournalAccountEntryCollection.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));

        lineCountByHeader = new Map(Types::Int64, Types::Int64);

        detailGeneralJournalAccountEntryRecIdCollection = new Set(Types::Int64);
        summaryGeneralJournalAccountEntryRecIdCollection = new Set(Types::Int64);

        detailLedgerEntryCollection = new RecordSortedList(tableNum(LedgerEntry));
        detailLedgerEntryCollection.sortOrderFromContainer(this.getLedgerEntrySortOrder());

        summaryLedgerEntryCollection = new RecordSortedList(tableNum(LedgerEntry));
        summaryLedgerEntryCollection.sortOrderFromContainer(this.getLedgerEntrySortOrder());

        detailConsolidateHistoryLinkCollection =
            LedgerPostingOneToManyCollection::construct(Types::Int64, Types::Int64, #ThrowForDuplicates);
        summaryConsolidateHistoryLinkCollection =
            LedgerPostingOneToManyCollection::construct(Types::Int64, Types::Int64, #ThrowForDuplicates);

        detailTaxLinkCollection = new RecordSortedList(tableNum(TaxTransGeneralJournalAccountEntry));
        detailTaxLinkCollection.sortOrderFromContainer(this.getTaxLinkSortOrder());

        summaryTaxLinkCollection = new RecordSortedList(tableNum(TaxTransGeneralJournalAccountEntry));
        summaryTaxLinkCollection.sortOrderFromContainer(this.getTaxLinkSortOrder());

        taxLinkGeneralJournalAccountEntryTransactionLink = new RecordSortedList(tableNum(GeneralJournalAccountEntryTransactionLink));
        taxLinkGeneralJournalAccountEntryTransactionLink.sortOrderFromContainer(
            [fieldNum(GeneralJournalAccountEntryTransactionLink, SourceRecId),
            fieldNum(GeneralJournalAccountEntryTransactionLink, SourceTableId)]);

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            detailTaxWHTLinkCollection = new RecordSortedList(tableNum(TaxWHTTransGeneralJournalAccountEntry_IN));
            detailTaxWHTLinkCollection.sortOrderFromContainer(this.getTaxWithholdLinkSortOrder_IN());

            summaryTaxWHTLinkCollection = new RecordSortedList(tableNum(TaxWHTTransGeneralJournalAccountEntry_IN));
            summaryTaxWHTLinkCollection.sortOrderFromContainer(this.getTaxWithholdLinkSortOrder_IN());
        }
        // </GIN>

        isZakatEnabled = LedgerParameters::find().IsZakatEnabled_SA;

        instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(classStr(LedgerPostingGeneralJournalController));

        isGeneralLedgerMemReduceFlightEnabled = FeatureStateProvider::isFeatureEnabled(LedgerPostingGeneralJournalControllerMemReduceFlight::instance());
        isLedgerPostingTransferLinesV2ReduceSQLCallsFlightEnabled = LedgerPostingTransferLinesV2ReduceSQLCallsFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSummaryTaxLinkCollection</Name>
				<Source><![CDATA[
    public RecordSortedList parmSummaryTaxLinkCollection(RecordSortedList _summaryTaxLinkCollection = summaryTaxLinkCollection)
    {
        summaryTaxLinkCollection = _summaryTaxLinkCollection;

        return summaryTaxLinkCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsReversal</Name>
				<Source><![CDATA[
    public boolean parmIsReversal(boolean _isReversal = isReversal)
    {
        isReversal = _isReversal;

        return isReversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsVATDeferment_IN</Name>
				<Source><![CDATA[
    public boolean parmIsVATDeferment_IN(boolean _isVATDeferment = isVATDeferment)
    {
        isVATDeferment = _isVATDeferment;

        return isVATDeferment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTempLineIdToLineIdCollection</Name>
				<Source><![CDATA[
    protected Map parmTempLineIdToLineIdCollection()
    {
        return tempLineIdToLineIdCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTaxLinks</Name>
				<Source><![CDATA[
    internal void processTaxLinks(
        RecordSortedList _taxLinkCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerPostingOneToManyCollection _taxLinks,
        Map _crossCompanyTaxLinkCollections)
    {
        LedgerPostingOneToManyCollection taxLinks;
        MapEnumerator enumerator;
        TableId tableId;
        CompanyId companyId;

        if (_taxLinks != null)
        {
            this.addTaxLink(_taxLinkCollection, _generalJournalAccountEntry, tableNum(TaxTrans), _taxLinks);
        }

        if (_crossCompanyTaxLinkCollections != null)
        {
            enumerator = _crossCompanyTaxLinkCollections.getEnumerator();
            while (enumerator.moveNext())
            {
                [tableId, companyId] = enumerator.currentKey();
                taxLinks = enumerator.currentValue();

                changeCompany(companyId)
                {
                    this.addTaxLink(_taxLinkCollection, _generalJournalAccountEntry, tableId, taxLinks);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processTransactionLinks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified information to the record list.
    /// </summary>
    /// <param name="_transactionLinkCollection">
    ///    The collection of associated tax transactions records are to be in sorted List.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The general journal account entry information.
    /// </param>
    /// <param name="_taxLinks">
    ///    The collection of associated tax transaction record id and tax transaction table id.
    /// </param>
    internal void processTransactionLinks(
        RecordSortedList _transactionLinkCollection,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerPostingOneToManyCollection _taxLinks)
    {
        if (_taxLinks != null)
        {
            Set relationshipCollection;
            SetEnumerator enumerator;
            GeneralJournalAccountEntryTransactionLink transactionLink;
            boolean haveMore;
            boolean success;
            RecId taxSource;
            TableId taxParentReferenceTableId;
            RecId taxParentReferenceRecId;
            AmountMST accountingCurrencyAmount;
            AmountCur transactionCurrencyAmount;

            haveMore = _taxLinks.first();
            while (haveMore)
            {
                taxParentReferenceRecId = _taxLinks.currentOne();
                relationshipCollection = _taxLinks.currentMany();

                enumerator = relationshipCollection.getEnumerator();
                while (enumerator.moveNext())
                {
                    [taxParentReferenceTableId, accountingCurrencyAmount, transactionCurrencyAmount] = enumerator.current();

                    transactionLink = null;
                    transactionLink.GeneralJournalAccountEntry  = _generalJournalAccountEntry.RecId;
                    transactionLink.LedgerDimension             = _generalJournalAccountEntry.LedgerDimension;
                    transactionLink.SourceRecId                 = taxParentReferenceRecId;
                    transactionLink.SourceTableId               = taxParentReferenceTableId;
                    transactionLink.AccountingCurrentAmount     = accountingCurrencyAmount;
                    transactionLink.TransactionCurrency         = _generalJournalAccountEntry.TransactionCurrencyCode;
                    transactionLink.TransactionCurrencyAmount   = transactionCurrencyAmount;
                    
                    success = _transactionLinkCollection.ins(transactionLink);
                    Debug::assert(success);
                }

                haveMore = _taxLinks.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the information to the general journal.
    /// </summary>
    public void transfer()
    {
        using (SysInstrumentationActivityContext activityContext = this.getActivityContextForLedgerPostingGeneralJournalController(classStr(LedgerPostingGeneralJournalController)))
        {
            activityContext.addCustomProperty('isGeneralLedgerCore', int2Str(isGeneralLedgerCore));
            activityContext.addCustomProperty('isGeneralLedgerMemReduceFlightEnabled', int2Str(isGeneralLedgerMemReduceFlightEnabled));
            activityContext.addCustomProperty('action', 'transfer');

            ttsbegin;

            this.transferJournals();

            this.transferReferences();

            ttscommit;

            // ledgerEntryJournal is inserted to db after transferJournals()
            activityContext.addCustomProperty('ledgerEntryJournalRecId', ledgerEntryJournal ? any2Str(ledgerEntryJournal.RecId) : '');

        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferConsolidateHistoryLinks</Name>
				<Source><![CDATA[
    private void transferConsolidateHistoryLinks(
        LedgerPostingOneToManyCollection _linkCollection,
        Map _tempLineIdToLineIdCollection)
    {
        LedgerConsolidateHistRef consolidateHistoryLink;
        RecordInsertList linkRecords;
        Set consolidateHistoryCollection;
        SetEnumerator consolidateHistoryEnumerator;
        RecId lineId;
        boolean haveRecord;

        linkRecords = new RecordInsertList(tableNum(LedgerConsolidateHistRef));

        haveRecord = _linkCollection.first();
        while (haveRecord)
        {
            lineId = _tempLineIdToLineIdCollection.lookup(_linkCollection.currentOne());
            consolidateHistoryCollection = _linkCollection.currentMany();

            consolidateHistoryEnumerator = consolidateHistoryCollection.getEnumerator();
            while (consolidateHistoryEnumerator.moveNext())
            {
                consolidateHistoryLink = null;
                consolidateHistoryLink.RefRecId = consolidateHistoryEnumerator.current();
                consolidateHistoryLink.TransTableId = tableNum(GeneralJournalAccountEntry);
                consolidateHistoryLink.TransRecid = lineId;

                linkRecords.add(consolidateHistoryLink);
            }

            haveRecord = _linkCollection.next();
        }

        // create the permanent LedgerConsolidateHistRef records
        linkRecords.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferEntries</Name>
				<Source><![CDATA[
    // LedgerEntry and Entry refer to the LedgerEntry table
    private void transferEntries(
        RecordSortedList _ledgerEntryCollection,
        Map _tempLineIdToLineIdCollection)
    {
        LedgerEntry entry;
        boolean isExtraProcesssingNeeded = false;

        RecordSortedList newEntryCollection = new RecordSortedList(tableNum(LedgerEntry));
        newEntryCollection.sortOrderFromContainer(this.getLedgerEntrySortOrder());

        boolean haveRecord = _ledgerEntryCollection.first(entry);
        while (haveRecord)
        {
            if (_tempLineIdToLineIdCollection.exists(entry.GeneralJournalAccountEntry))
            {
                // the entry will be created because a line was created

                entry.GeneralJournalAccountEntry = _tempLineIdToLineIdCollection.lookup(entry.GeneralJournalAccountEntry);

                // add to a new list because not all records from the original list will be created
                boolean success = newEntryCollection.ins(entry);
                Debug::assert(success);

                if (entry.isExtraProcessingNeeded())
                {
                    isExtraProcesssingNeeded = true;
                }
            }

            haveRecord = _ledgerEntryCollection.next(entry);
        }

        if (newEntryCollection.len() > 0)
        {
            // create the permanent LedgerEntry records
            newEntryCollection.insertDatabase();

            if (isExtraProcesssingNeeded)
            {
                haveRecord = newEntryCollection.first(entry);
                while (haveRecord)
                {
                    if (entry.IsBridgingPosting)
                    {
                        GeneralJournalEntry generalJournalEntry = GeneralJournalEntry::findByGeneralJournalAccountEntry(entry.GeneralJournalAccountEntry);

                        entry.createBridgingPosting(ledgerEntryJournal, generalJournalEntry);
                    }

                    haveRecord = newEntryCollection.next(entry);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferJournals</Name>
				<Source><![CDATA[
    private void transferJournals()
    {
        if (ledgerEntryJournal.JournalNumber == '')
        {
            ledgerEntryJournal = null;
        }
        else
        {
            // create the permanent LedgerEntryJournal record
            ledgerEntryJournal.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the lines information to the General Journal.
    /// </summary>
    /// <param name = "_transferLevel">
    /// The Enumeration value of the transfer level.
    /// </param>
    /// <param name = "_lineCollection">
    /// The collection of lines.
    /// </param>
    /// <param name = "_consolidateHistoryLinkCollection">
    /// The <c>LedgerPostingOneToManyCollection</c> class object.
    /// </param>
    /// <param name = "_ledgerEntryCollection">
    /// The collection of Ledger entries.
    /// </param>
    /// <param name = "_taxLinkCollection">
    /// The collection of tax that are linked.
    /// </param>
    /// <param name = "_tempHeaderIdToHeaderCollection">
    /// The Map containing header record ID and header record.
    /// </param>
    /// <param name = "_tempHeaderIdToSubledgerVoucherLinkCollection">
    /// The Map containing header record ID and Subledger voucher link.
    /// </param>
    /// <param name = "_lineWCollection">
    /// The collection of lines.
    /// </param>
    /// <param name = "_allLinesSummarizedToZeroForHeaderStatusCollection">
    /// The map containing the lines summarized and header status.
    /// </param>
    [Wrappable(true)]
    protected final void transferLines(
        DetailSummary _transferLevel,
        RecordSortedList _lineCollection,
        LedgerPostingOneToManyCollection _consolidateHistoryLinkCollection,
        RecordSortedList _ledgerEntryCollection,
        RecordSortedList _taxLinkCollection,
        Map _tempHeaderIdToHeaderCollection,
        Map _tempHeaderIdToSubledgerVoucherLinkCollection,
        RecordSortedList _lineWCollection,
        Map _allLinesSummarizedToZeroForHeaderStatusCollection)
    {
        if (isGeneralLedgerMemReduceFlightEnabled)
        {
            this.transferLinesV2(
                _transferLevel,
                _lineCollection,
                _consolidateHistoryLinkCollection,
                _ledgerEntryCollection,
                _taxLinkCollection,
                _tempHeaderIdToHeaderCollection,
                _tempHeaderIdToSubledgerVoucherLinkCollection,
                _lineWCollection,
                _allLinesSummarizedToZeroForHeaderStatusCollection);
        }
        else
        {
            this.transferLinesOriginal(
                _transferLevel,
                _lineCollection,
                _consolidateHistoryLinkCollection,
                _ledgerEntryCollection,
                _taxLinkCollection,
                _tempHeaderIdToHeaderCollection,
                _tempHeaderIdToSubledgerVoucherLinkCollection,
                _lineWCollection,
                _allLinesSummarizedToZeroForHeaderStatusCollection);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferLinesOriginal</Name>
				<Source><![CDATA[
    private void transferLinesOriginal(
        DetailSummary _transferLevel,
        RecordSortedList _lineCollection,
        LedgerPostingOneToManyCollection _consolidateHistoryLinkCollection,
        RecordSortedList _ledgerEntryCollection,
        RecordSortedList _taxLinkCollection,
        Map _tempHeaderIdToHeaderCollection,
        Map _tempHeaderIdToSubledgerVoucherLinkCollection,
        RecordSortedList _lineWCollection,
        Map _allLinesSummarizedToZeroForHeaderStatusCollection)
    {
        // If posting to general ledger core transaction tables only (which only applies to posting in Detail, not Summary), short-circuit the rest of the execution
        // Called here to maintain extensibility hook point
        if (_transferLevel == DetailSummary::Detail && isGeneralLedgerCore)
        {
            this.transferLinesForGeneralLedgerCore(
                detailGeneralJournalAccountEntryCollection,
                _tempHeaderIdToHeaderCollection,
                _tempHeaderIdToSubledgerVoucherLinkCollection,
                detailGeneralJournalAccountEntryWs);

            return;
        }
        else if (_transferLevel == DetailSummary::Summary && isGeneralLedgerCore)
        {
            return;
        }

        GeneralJournalAccountEntry line;
        GeneralJournalEntry generalJournalEntry;
        boolean success;
        int64 currentLine;
        int64 lineCount;
        boolean lineHasAmount;
        boolean allLinesSummarizedToZeroForHeaderResult;
        
        boolean reverseOppositeSignAmounts = LedgerParameters::find().ReverseOppositeSignAmounts;

        Map currentLineCountByHeader = new Map(Types::Int64, Types::Int64);
        Map lineIdToTempHeaderIdCollection = new Map(Types::Int64, Types::Int64);
        Map tempLineIdToTempHeaderIdCollection = new Map(Types::Int64, Types::Int64);
        Set lineCreatedForHeader = new Set(Types::Int64);
        tempLineIdToLineIdCollection = new Map(Types::Int64, Types::Int64);

        RecordSortedList newLineCollection = new RecordSortedList(tableNum(GeneralJournalAccountEntry));
        newLineCollection.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));

        RecordSortedList summarizedToZeroLine = new RecordSortedList(tableNum(GeneralJournalAccountEntry));
        summarizedToZeroLine.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));

        boolean haveRecord = _lineCollection.first(line);
        while (haveRecord)
        {
            this.validateGeneralJournalAccountEntry(line);

            currentLine = this.incrementCountForRecId(currentLineCountByHeader, line.GeneralJournalEntry);
            lineCount = lineCountByHeader.lookup(line.GeneralJournalEntry);

            lineHasAmount = (line.hasAmount()
                || FeatureStateProvider::isFeatureEnabled(PostingZeroInvoicesInGeneralLedgerFeature::instance())
                || this.allowTaxPostingTypeSummarizedToZero(line, _transferLevel, _tempHeaderIdToHeaderCollection));

            if (lineHasAmount)
            {
                _allLinesSummarizedToZeroForHeaderStatusCollection.insert(line.GeneralJournalEntry, false);
            }

            if (this.lineIsValidForTransfer(
                   _transferLevel,
                   line,
                   currentLine,
                   lineCount,
                   lineCreatedForHeader,
                   lineHasAmount,
                   _allLinesSummarizedToZeroForHeaderStatusCollection))
            {
                // the line will be created because at least one amount field has a value or it is the only line for the header
                lineCreatedForHeader.add(line.GeneralJournalEntry);
                tempLineIdToTempHeaderIdCollection.insert(line.RecId, line.GeneralJournalEntry);

                generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(line.GeneralJournalEntry);

                this.finalizeGeneralJournalAccountEntryForInsert(line, generalJournalEntry, reverseOppositeSignAmounts);

                if (lineHasAmount)
                {
                    success = newLineCollection.ins(line);
                }
                else
                {
                    success = summarizedToZeroLine.ins(line);
                }

                Debug::assert(success);
            }

            haveRecord = _lineCollection.next(line);
        }

        /// For general journal entries which have only transactions summarized to zero, add the
        /// transactions to the insert list.

        GeneralJournalEntryRecId tempGeneralJournalEntryRecId;
        haveRecord = summarizedToZeroLine.first(line);

        while (haveRecord)
        {
            tempGeneralJournalEntryRecId = tempLineIdToTempHeaderIdCollection.lookup(line.RecId);

            if (_allLinesSummarizedToZeroForHeaderStatusCollection.exists(tempGeneralJournalEntryRecId))
            {
                allLinesSummarizedToZeroForHeaderResult = _allLinesSummarizedToZeroForHeaderStatusCollection.lookup(tempGeneralJournalEntryRecId);

                if (allLinesSummarizedToZeroForHeaderResult)
                {
                    newLineCollection.ins(line);
                }
            }

            haveRecord = summarizedToZeroLine.next(line);
        }

        List parallelRecIdCollection = new List(Types::Int64);

        haveRecord = newLineCollection.first(line);
        while (haveRecord)
        {
            // capture the temp RecId values in order
            parallelRecIdCollection.addEnd(line.RecId);

            haveRecord = newLineCollection.next(line);
        }

        if (!TransactionlogUpdateTTSControl::Instance().isInvoked())
        {
            TransactionlogUpdateTTSControl::Instance().invoke();
        }

        // create the permanent GeneralJournalAccountEntry records
        newLineCollection.insertDatabase();

        Debug::assert(newLineCollection.len() == parallelRecIdCollection.elements());

        ListEnumerator parallelEnumerator = parallelRecIdCollection.getEnumerator();
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        RecId tempHeaderId;
        RecId tempLineId;

        haveRecord = newLineCollection.first(line);
        success = parallelEnumerator.moveNext();
        while (haveRecord && success)
        {
            tempLineId = parallelEnumerator.current();
            tempHeaderId = tempLineIdToTempHeaderIdCollection.lookup(tempLineId);

            generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(tempHeaderId);
            subledgerVoucherLink = _tempHeaderIdToSubledgerVoucherLinkCollection.lookup(tempHeaderId);

            lineIdToTempHeaderIdCollection.insert(line.RecId, tempHeaderId);
            tempLineIdToLineIdCollection.insert(tempLineId, line.RecId);

            if (isZakatEnabled && !isReversal)
            {
                GeneralJournalAccountEntryZakat_SA::insertZakatInformation(line, subledgerVoucherLink.Voucher, generalJournalEntry.AccountingDate);
            }

            if (isReversal)
            {
                if (reversalLineRecordIdCollection.in(tempLineId))
                {
                    line.reverseSettlement(tempLineId);
                }

                if (isZakatEnabled)
                {
                    GeneralJournalAccountEntryZakat_SA::insertReversalTrans(tempLineId, line.RecId, generalJournalEntry.AccountingDate);
                }
            }

            haveRecord = newLineCollection.next(line);
            success = parallelEnumerator.moveNext();
        }

        // <GEEU>
        if (useGeneralJournalAccountEntry_W)
        {
            this.transferLineWs(_lineWCollection, tempLineIdToLineIdCollection, lineIdToTempHeaderIdCollection, _tempHeaderIdToHeaderCollection);
        }
        // </GEEU>

        this.transferEntries(_ledgerEntryCollection, tempLineIdToLineIdCollection);

        // <GIN>
        if (TaxParameters::isVATEnable_IN() && isVATDeferment)
        {
            this.transferVATDefermentTaxLinks_IN(
                 _taxLinkCollection,
                 tempLineIdToLineIdCollection);
        }
        else
        {
            // </GIN>

            if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode()
                && !TaxTrans::existForVoucher(subledgerVoucherLink.Voucher))
            {
                this.transferTransactionLinks(
                    taxLinkGeneralJournalAccountEntryTransactionLink,
                    tempLineIdToLineIdCollection);
            }
            else
            {
                this.transferTaxLinks(
                    _taxLinkCollection,
                    tempLineIdToLineIdCollection);
            }
            // <GIN>
        }
        // </GIN>

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if ( _transferLevel == DetailSummary::Detail)
            {
                this.transferTaxWithholdLinks_IN(
                    detailTaxWHTLinkCollection,
                    tempLineIdToLineIdCollection);
            }
            else
            {
                this.transferTaxWithholdLinks_IN(
                    summaryTaxWHTLinkCollection,
                    tempLineIdToLineIdCollection);
            }
        }
        // </GIN>

        this.transferConsolidateHistoryLinks(
            _consolidateHistoryLinkCollection,
            tempLineIdToLineIdCollection);

        // <GEERU>
        LedgerPostingGeneralJournalTurnover_RU::postTransferLinesEventHandler(
            _transferLevel,
            _lineCollection,
            _consolidateHistoryLinkCollection,
            _ledgerEntryCollection,
            _taxLinkCollection,
            _tempHeaderIdToHeaderCollection,
            _tempHeaderIdToSubledgerVoucherLinkCollection,
            _lineWCollection);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferLineWs</Name>
				<Source><![CDATA[
    // GeneralJournalAccountEntryW and LineW refer to the GeneralJournalAccountEntry_W table
    private void transferLineWs(
        RecordSortedList _lineWCollection,
        Map _tempLineIdToLineIdCollection,
        Map _lineIdToTempHeaderIdCollection,
        Map _tempHeaderIdToHeaderCollection) // only used in an edge case
    {
        GeneralJournalAccountEntry_W generalJournalAccountEntryW;
        GeneralJournalEntry generalJournalEntry;
        RecordSortedList newLineWCollection;
        boolean haveRecord;
        boolean success;
        RecId tempHeaderId;

        Debug::assert(_lineWCollection != null);

        newLineWCollection = new RecordSortedList(tableNum(GeneralJournalAccountEntry_W));
        newLineWCollection.sortOrder(fieldNum(GeneralJournalAccountEntry_W, GeneralJournalAccountEntry));

        haveRecord = _lineWCollection.first(generalJournalAccountEntryW);
        while (haveRecord)
        {
            if (_tempLineIdToLineIdCollection.exists(generalJournalAccountEntryW.GeneralJournalAccountEntry))
            {
                // the lineW will be created because a line was created
                generalJournalAccountEntryW.GeneralJournalAccountEntry = _tempLineIdToLineIdCollection.lookup(generalJournalAccountEntryW.GeneralJournalAccountEntry);

                // Denormalize the GeneralJournalEntry recid to the GeneralJournalAccountEntry_W
                // table. This is static data that never changes so this denormalization does not
                // need to be maintained anywhere else in the process.
                if (isGeneralLedgerMemReduceFlightEnabled)
                {
                    GeneralJournalAccountEntry generalJournalAccountEntry = GeneralJournalAccountEntry::find(generalJournalAccountEntryW.GeneralJournalAccountEntry);
                    generalJournalAccountEntryW.GeneralJournalEntry = generalJournalAccountEntry.GeneralJournalEntry;
                }
                else
                {
                    tempHeaderId = _lineIdToTempHeaderIdCollection.lookup(generalJournalAccountEntryW.GeneralJournalAccountEntry);
                    generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(tempHeaderId);
                    generalJournalAccountEntryW.GeneralJournalEntry = generalJournalEntry.RecId;
                }

                // add to a new list because not all records from the original list will be created
                success = newLineWCollection.ins(generalJournalAccountEntryW);
                Debug::assert(success);
            }

            haveRecord = _lineWCollection.next(generalJournalAccountEntryW);
        }

        // create the permanent GeneralJournalAccountEntry_W records
        newLineWCollection.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertGeneralJournalEntryCollection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a new record in a RecordSortedList, unless it is a duplicate.
    /// </summary>
    /// <param name="_generalJournalEntry">
    /// A general journal entiry record buffer to be inserted into the list.
    /// </param>
    /// <param name="_updateIfExists">
    /// Whether to discard or replace duplicate records; optional
    /// </param>
    /// <returns>
    /// true if the record was added or replaced; otherwise false.
    /// </returns>
    protected boolean insertGeneralJournalEntryCollection(GeneralJournalEntry _generalJournalEntry, boolean _updateIfExists = false)
    {
        return generalJournalEntryCollection.ins(_generalJournalEntry, _updateIfExists);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferReferences</Name>
				<Source><![CDATA[
    // GeneralJournalEntry, Reference, and Header all refer to the GeneralJournalEntry table
    private void transferReferences()
    {
        Map tempHeaderIdToHeaderCollection = new Map(Types::Int64, Types::Record);
        Map tempHeaderIdToSubledgerVoucherLinkCollection = new Map(Types::Int64, Types::Record);

        if (isGeneralLedgerMemReduceFlightEnabled)
        {
            this.transferHeadersV2(tempHeaderIdToHeaderCollection, tempHeaderIdToSubledgerVoucherLinkCollection);
        }
        else
        {
            this.transferHeaders(tempHeaderIdToHeaderCollection, tempHeaderIdToSubledgerVoucherLinkCollection);
        }

        Map allLinesSummarizedToZeroForHeaderStatusCollection = new Map(Types::Int64, Types::Enum);
        MapEnumerator journalHeaderEnumerator = tempHeaderIdToHeaderCollection.getEnumerator();

        // Initialize collection which maintains the general journal entry status as to whether any transactions
        // are added to the journal which are a non-zero value (no accounting, reporting, transaction amount, or quantity).
        if (isGeneralLedgerMemReduceFlightEnabled)
        {
            while (journalHeaderEnumerator.moveNext())
            {
                GeneralJournalEntry header = journalHeaderEnumerator.currentValue();
                allLinesSummarizedToZeroForHeaderStatusCollection.insert(header.RecId, true);
            }
        }
        else
        {
            while (journalHeaderEnumerator.moveNext())
            {
                allLinesSummarizedToZeroForHeaderStatusCollection.insert(journalHeaderEnumerator.currentKey(), true);
            }
        }

        this.transferLines(
            DetailSummary::Detail,
            detailGeneralJournalAccountEntryCollection,
            detailConsolidateHistoryLinkCollection,
            detailLedgerEntryCollection,
            detailTaxLinkCollection,
            tempHeaderIdToHeaderCollection,
            tempHeaderIdToSubledgerVoucherLinkCollection,
            detailGeneralJournalAccountEntryWs,
            allLinesSummarizedToZeroForHeaderStatusCollection);

        this.transferLines(
            DetailSummary::Summary,
            summaryGeneralJournalAccountEntryCollection,
            summaryConsolidateHistoryLinkCollection,
            summaryLedgerEntryCollection,
            summaryTaxLinkCollection,
            tempHeaderIdToHeaderCollection,
            tempHeaderIdToSubledgerVoucherLinkCollection,
            summaryGeneralJournalAccountEntryWs,
            allLinesSummarizedToZeroForHeaderStatusCollection);

        this.addGeneralJournalEntriesToPostingProcessor();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferHeaders</Name>
				<Source><![CDATA[
    private void transferHeaders(Map _tempHeaderIdToHeaderCollection, Map _tempHeaderIdToSubledgerVoucherLinkCollection)
    {
        GeneralJournalEntry generalJournalEntry;
        GeneralJournalEntry_W generalJournalEntryW;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
        List parallelReferenceCollection = new List(Types::Int64);
        boolean success;

        boolean haveRecord = generalJournalEntryCollection.first(generalJournalEntry);
        while (haveRecord)
        {
            generalJournalEntry.JournalNumber = journalNumberNumberSeq.num();

            this.validateGeneralJournalEntry(generalJournalEntry);

            // set the LedgerEntryJournal FK (may be empty)
            generalJournalEntry.LedgerEntryJournal = ledgerEntryJournal.RecId;

            success = this.insertGeneralJournalEntryCollection(generalJournalEntry, true);

            // RecordSortedList.ins always returns false for an update so assert it is false
            Debug::assert(!success);

            // capture the temp RecId values in order
            parallelReferenceCollection.addEnd(generalJournalEntry.RecId);

            haveRecord = generalJournalEntryCollection.next(generalJournalEntry);
        }

        // create the permanent GeneralJournalEntry records
        generalJournalEntryCollection.insertDatabase();

        RecordInsertList subledgerVoucherLinkList = new RecordInsertList(tableNum(SubledgerVoucherGeneralJournalEntry));
        ListEnumerator parallelEnumerator = parallelReferenceCollection.getEnumerator();
        RecId tempHeaderId;

        // go through the main collection and parallel collection in parallel
        // because together we can determine the perm RecId to temp RecId mapping
        haveRecord = generalJournalEntryCollection.first(generalJournalEntry);
        boolean haveRecordId = parallelEnumerator.moveNext();
        while (haveRecord && haveRecordId)
        {
            tempHeaderId = parallelEnumerator.current();

            // create the temporary record ID to record mappings
            _tempHeaderIdToHeaderCollection.insert(tempHeaderId, generalJournalEntry);

            generalJournalEntryRecIdValues.insert(
                [generalJournalEntry.SubledgerVoucher, generalJournalEntry.AccountingDate],
                generalJournalEntry.RecId);

            subledgerVoucherLink.Voucher = generalJournalEntry.SubledgerVoucher;
            subledgerVoucherLink.VoucherDataAreaId = generalJournalEntry.SubledgerVoucherDataAreaId;
            subledgerVoucherLink.AccountingDate = generalJournalEntry.AccountingDate;
            subledgerVoucherLink.GeneralJournalEntry = generalJournalEntry.RecId;
            subledgerVoucherLinkList.add(subledgerVoucherLink);

            _tempHeaderIdToSubledgerVoucherLinkCollection.insert(tempHeaderId, subledgerVoucherLink);

            haveRecord = generalJournalEntryCollection.next(generalJournalEntry);
            haveRecordId = parallelEnumerator.moveNext();
        }

        // create the permanent SubledgerVoucherGeneralJournalEntry records
        subledgerVoucherLinkList.insertDatabase();

        if (useGeneralJournalEntry_W)
        {
            haveRecord = generalJournalEntryWs.first(generalJournalEntryW);
            while (haveRecord)
            {
                generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(generalJournalEntryW.RecId);
                generalJournalEntryW.GeneralJournalEntry = generalJournalEntry.RecId;

                success = generalJournalEntryWs.ins(generalJournalEntryW, true);

                // RecordSortedList.ins always returns false for an update so assert it is false
                Debug::assert(!success);

                haveRecord = generalJournalEntryWs.next(generalJournalEntryW);
            }

            // create the GeneralJournalEntry_W records
            generalJournalEntryWs.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGeneralJournalEntriesToPostingProcessor</Name>
				<Source><![CDATA[
    private void addGeneralJournalEntriesToPostingProcessor()
    {
        LedgerPostingProcessor ledgerPostingProcessor = LedgerPostingProcessor::Instance();

        GeneralJournalEntry generalJournalEntry;
        boolean haveRecord = generalJournalEntryCollection.first(generalJournalEntry);
        while (haveRecord)
        {
            ledgerPostingProcessor.addGeneralJournalEntryRecId(generalJournalEntry.RecId);

            haveRecord = generalJournalEntryCollection.next(generalJournalEntry);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferTaxLinks</Name>
				<Source><![CDATA[
    private void transferTaxLinks(
        RecordSortedList _linkCollection,
        Map _tempLineIdToLineIdCollection)
    {
        RecordSortedList newTaxLinkCollection;
        TaxTransGeneralJournalAccountEntry taxLink;
        boolean haveLink;
        boolean success;
        RecId tempLineId;
        RecId lineId;

        tempLineId = -1;

        // use a new list because we can't update a key field while iterating
        newTaxLinkCollection = new RecordSortedList(tableNum(TaxTransGeneralJournalAccountEntry));
        newTaxLinkCollection.sortOrderFromContainer(this.getTaxLinkSortOrder());

        haveLink = _linkCollection.first(taxLink);
        while (haveLink)
        {
            if (tempLineId != taxLink.GeneralJournalAccountEntry)
            {
                tempLineId = taxLink.GeneralJournalAccountEntry;

                if (_tempLineIdToLineIdCollection.exists(tempLineId))
                {
                    lineId = _tempLineIdToLineIdCollection.lookup(tempLineId);
                }
                else
                {
                    lineId = 0;
                }
            }

            if (lineId != 0)
            {
                taxLink.GeneralJournalAccountEntry = lineId;

                success = newTaxLinkCollection.ins(taxLink);
                Debug::assert(success);
            }

            haveLink = _linkCollection.next(taxLink);
        }

        // create the permanent TaxTransGeneralJournalAccountEntry records
        newTaxLinkCollection.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferTransactionLinks</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the transaction information to the General Journal.
    /// </summary>
    /// <param name = "_linkCollection">The RecordSortedList</param>
    /// <param name = "_tempLineIdToLineIdCollection">The Map</param>
    private void transferTransactionLinks(
        RecordSortedList _linkCollection,
        Map _tempLineIdToLineIdCollection)
    {
        RecordSortedList newTaxLinkCollection;
        GeneralJournalAccountEntryTransactionLink taxLink;
        boolean haveLink;
        boolean success;
        RecId tempLineId;
        RecId lineId;

        tempLineId = -1;

        // use a new list because we can't update a key field while iterating
        newTaxLinkCollection = new RecordSortedList(tableNum(GeneralJournalAccountEntryTransactionLink));
        newTaxLinkCollection.sortOrderFromContainer(
            [fieldNum(GeneralJournalAccountEntryTransactionLink, SourceRecId),
            fieldNum(GeneralJournalAccountEntryTransactionLink, SourceTableId)]);

        haveLink = _linkCollection.first(taxLink);
        while (haveLink)
        {
            tempLineId = taxLink.GeneralJournalAccountEntry;

            if (_tempLineIdToLineIdCollection.exists(tempLineId))
            {
                lineId = _tempLineIdToLineIdCollection.lookup(tempLineId);
            }
            else
            {
                lineId = 0;
            }

            if (lineId != 0)
            {
                taxLink.GeneralJournalAccountEntry = lineId;

                success = newTaxLinkCollection.ins(taxLink);
                Debug::assert(success);
            }

            haveLink = _linkCollection.next(taxLink);
        }

        // create the permanent GeneralJournalAccountEntryTransactionLink records
        newTaxLinkCollection.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferTaxWithholdLinks_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the information to the general journal.
    /// </summary>
    /// <param name="_linkCollection">
    ///    The collection of associated taxWithhold transactions records are to be in sorted List.
    /// </param>
    /// <param name="_tempLineIdToLineIdCollection">
    ///    To Map the collection of temperary LineId To LineId.
    /// </param>
    private void transferTaxWithholdLinks_IN(
        RecordSortedList _linkCollection,
        Map _tempLineIdToLineIdCollection)
    {
        RecordSortedList                         newTaxLinkCollection;
        TaxWHTTransGeneralJournalAccountEntry_IN taxWithholdLink;
        boolean haveLink;
        boolean success;
        RecId tempLineId;
        RecId lineId;

        tempLineId = -1;

        // use a new list because we can't update a key field while iterating
        newTaxLinkCollection = new RecordSortedList(tableNum(TaxWHTTransGeneralJournalAccountEntry_IN));
        newTaxLinkCollection.sortOrderFromContainer(this.getTaxWithholdLinkSortOrder_IN());

        haveLink = _linkCollection.first(taxWithholdLink);
        while (haveLink)
        {
            if (tempLineId != taxWithholdLink.GeneralJournalAccountEntry)
            {
                tempLineId = taxWithholdLink.GeneralJournalAccountEntry;

                if (_tempLineIdToLineIdCollection.exists(tempLineId))
                {
                    lineId = _tempLineIdToLineIdCollection.lookup(tempLineId);
                }
                else
                {
                    lineId = 0;
                }
            }

            if (lineId != 0)
            {
                taxWithholdLink.GeneralJournalAccountEntry = lineId;

                success = newTaxLinkCollection.ins(taxWithholdLink);
                Debug::assert(success);
            }

            haveLink = _linkCollection.next(taxWithholdLink);
        }

        // create the permanent TaxWithholdTransLedgerEntry records
        newTaxLinkCollection.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferVATDefermentTaxLinks_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the information to the general journal.
    /// </summary>
    /// <param name="_linkCollection">
    ///    The collection of associated tax transactions records are to be in sorted List.
    /// </param>
    /// <param name="_tempLineIdToLineIdCollection">
    ///    To Map the collection of temperary LineId To LineId.
    /// </param>
    private void transferVATDefermentTaxLinks_IN(
        RecordSortedList _linkCollection,
        Map _tempLineIdToLineIdCollection)
    {
        TaxTransGeneralJournalAccountEntry  taxLink;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        boolean                             haveLink;
        RecId                               generalJournalAccountEntryRecId;

        haveLink = _linkCollection.first(taxLink);
        while (haveLink)
        {
            generalJournalAccountEntryRecId = _tempLineIdToLineIdCollection.lookup(taxLink.GeneralJournalAccountEntry);

            ttsBegin;

            update_recordSet taxTransGeneralJournalAccountEntry
                setting GeneralJournalAccountEntry = generalJournalAccountEntryRecId
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == 0
                    && taxTransGeneralJournalAccountEntry.LedgerDimension == generalJournalAccountEntry::find(generalJournalAccountEntryRecId).LedgerDimension;

            ttsCommit;

            haveLink = _linkCollection.next(taxLink);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>LedgerPostingGeneralJournalController</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>LedgerPostingGeneralJournalController</c> class.
    /// </returns>
    public static LedgerPostingGeneralJournalController construct()
    {
        return new LedgerPostingGeneralJournalController();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForGeneralLedgerCore</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>LedgerPostingGeneralJournalController</c> class for core general ledger posting.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>LedgerPostingGeneralJournalController</c> class.
    /// </returns>
    internal static LedgerPostingGeneralJournalController newForGeneralLedgerCore()
    {
        LedgerPostingGeneralJournalController postingController = new LedgerPostingGeneralJournalController();

        postingController.isGeneralLedgerCore = true;

        return postingController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addForGeneralLedgerCore</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the specified information to the collection.
    /// </summary>
    /// <param name="_generalJournalEntry">
    ///    The general journal entry information.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    ///    The general journal account entry information.
    /// </param>
    /// <param name="_generalJournalEntryW">
    ///    The country specific general journal entry information; optional.
    /// </param>
    /// <param name="_generalJournalAccountEntryW">
    ///    The country specific general journal account entry information; optional.
    /// </param>
    /// <remarks>
    ///    This method is used for utility operations that transfer core general journal data in detail.
    /// </remarks>
    private void addForGeneralLedgerCore(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalEntry_W _generalJournalEntryW = null,
        GeneralJournalAccountEntry_W _generalJournalAccountEntryW = null)
    {
        // GeneralJournalEntry depends on nothing
        GeneralJournalEntry referenceCopy = this.addReference(_generalJournalEntry);

        if (useGeneralJournalEntry_W)
        {
            this.addReferenceW(referenceCopy, _generalJournalEntryW);
        }

        // GeneralJournalAccountEntry depends on GeneralJournalEntry
        this.addLineForGeneralLedgerCore(
            detailGeneralJournalAccountEntryCollection,
            detailGeneralJournalAccountEntryRecIdCollection,
            referenceCopy,
            _generalJournalAccountEntry,
            _generalJournalAccountEntryW);

        if (useGeneralJournalAccountEntry_W)
        {
            // GeneralJournalAccountEntry_W depends on GeneralJournalAccountEntry
            this.addLineW(detailGeneralJournalAccountEntryWs, _generalJournalAccountEntry, _generalJournalAccountEntryW);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLineForGeneralLedgerCore</Name>
				<Source><![CDATA[
    private void addLineForGeneralLedgerCore(
        RecordSortedList _lineCollection,
        Set _tempLineIdCollection,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalAccountEntry_W _generalJournalAccountEntryW)
    {
        if (_generalJournalAccountEntry.hasAmount())
        {
            // assign a temporary record ID even if it has a
            // record ID to make sure we don't get a duplicate
            _generalJournalAccountEntry.RecId = this.getNextTemporaryLineRecId();
            _generalJournalAccountEntry.GeneralJournalEntry = _generalJournalEntry.RecId;

            // Add GeneralJournalAccountEntry buffer to the record insert list
            _lineCollection.ins(_generalJournalAccountEntry);

            // Add the GeneralJournalAccountEntry temporary RecId if an optional GeneralJournalAccountEntry_W record is to be created
            if (useGeneralJournalAccountEntry_W)
            {
                _tempLineIdCollection.add(_generalJournalAccountEntry.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferLinesForGeneralLedgerCore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfers the lines information to the General Journal.
    /// </summary>
    /// <param name = "_lineCollection">
    /// The collection of lines.
    /// </param>
    /// <param name = "_tempHeaderIdToHeaderCollection">
    /// The Map containing header record ID and header record.
    /// </param>
    /// <param name = "_tempHeaderIdToSubledgerVoucherLinkCollection">
    /// The Map containing header record ID and Subledger voucher link.
    /// </param>
    /// <param name = "_lineWCollection">
    /// The collection of lines.
    /// </param>
    private void transferLinesForGeneralLedgerCore(
        RecordSortedList _lineCollection,
        Map _tempHeaderIdToHeaderCollection,
        Map _tempHeaderIdToSubledgerVoucherLinkCollection,
        RecordSortedList _lineWCollection)
    {
        GeneralJournalAccountEntry genralJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        
        // This collection links the temporary GeneralJournalAcountEntry.RecId to the the actual header (GeneralJournalEntry.RecId) value
        // committed to the database.
        Map tempLineIdToTempHeaderIdCollection = new Map(Types::Int64, Types::Int64);
        boolean reverseOppositeSignAmounts = LedgerParameters::find().ReverseOppositeSignAmounts;
      
        boolean haveRecord = _lineCollection.first(genralJournalAccountEntry);
        while (haveRecord)
        {
            this.validateGeneralJournalAccountEntry(genralJournalAccountEntry);

            // Only track the line recid values if they are needed for GeneralJournalAccountEntry_W creation
            if (useGeneralJournalAccountEntry_W)
            {
                tempLineIdToTempHeaderIdCollection.insert(genralJournalAccountEntry.RecId, genralJournalAccountEntry.GeneralJournalEntry);
            }

            generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(genralJournalAccountEntry.GeneralJournalEntry);
            genralJournalAccountEntry = this.finalizeGeneralJournalAccountEntryForInsert(genralJournalAccountEntry, generalJournalEntry, reverseOppositeSignAmounts);

            // Update the record insert list with the updated line values
            _lineCollection.ins(genralJournalAccountEntry, true);

            haveRecord = _lineCollection.next(genralJournalAccountEntry);
        }

        if (!TransactionlogUpdateTTSControl::Instance().isInvoked())
        {
            TransactionlogUpdateTTSControl::Instance().invoke();
        }

        // create the permanent GeneralJournalAccountEntry records
        _lineCollection.insertDatabase();

        if (useGeneralJournalAccountEntry_W)
        {
            // This collection contains temporary GeneralJournalAcountEntry.RecId linked to the the actual GeneralJournalAcountEntry RecId committed ot the database.
            tempLineIdToLineIdCollection = new Map(Types::Int64, Types::Int64);

            // This collection contains a link between the actual GeneralJournalAcountEntry RecId committed to the database, and the logical (temporary) header
            // (GeneralJournalEntry.RecId) used for linking related records such as GeneralJournalAccountEntry_W
            Map lineIdToTempHeaderIdCollection = new Map(Types::Int64, Types::Int64);

            SetEnumerator temporaryLineRecIdEnumerator = detailGeneralJournalAccountEntryRecIdCollection.getEnumerator();

            haveRecord = _lineCollection.first(genralJournalAccountEntry);
            boolean success = temporaryLineRecIdEnumerator.moveNext();
            RecId tempLineRecId;
            RecId tempHeaderRecId;

            while (haveRecord && success)
            {
                // Get the temporary GeneralJournalAccountEntry.RecId value to link to the actual for linking the child records
                tempLineRecId = temporaryLineRecIdEnumerator.current();

                // Get the temporary GeneralJournalEntry.RecId value to link to the actual GeneralJournalAccountEntry.RecId value commited to the database
                tempHeaderRecId = tempLineIdToTempHeaderIdCollection.lookup(tempLineRecId);

                // Link the temporary GeneralJournalAcountEntry.RecId with the actual
                tempLineIdToLineIdCollection.insert(tempLineRecId, genralJournalAccountEntry.RecId);

                // Link the actual GeneralJournalAcountEntry.RecId with the temporary header value (GeneralJournalEntry.RecId)
                lineIdToTempHeaderIdCollection.insert(genralJournalAccountEntry.RecId, tempHeaderRecId);

                success = temporaryLineRecIdEnumerator.moveNext();
                haveRecord = _lineCollection.next(genralJournalAccountEntry);
            }
            
            this.transferLineWs(_lineWCollection, tempLineIdToLineIdCollection, lineIdToTempHeaderIdCollection, _tempHeaderIdToHeaderCollection);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalizeGeneralJournalAccountEntryForInsert</Name>
				<Source><![CDATA[
    private GeneralJournalAccountEntry finalizeGeneralJournalAccountEntryForInsert(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalEntry _generalJournalEntry,
        boolean _reverseOppositeSignAmounts)
    {
        _generalJournalAccountEntry.GeneralJournalEntry = _generalJournalEntry.RecId;

        // If the account denormalization values have not already been set, set them
        if (_generalJournalAccountEntry.LedgerAccount == '' || _generalJournalAccountEntry.MainAccount == 0)
        {
            DimensionAttributeValueCombination dimAttrValueCombo;

            select firstOnly DisplayValue, MainAccount from dimAttrValueCombo
                where dimAttrValueCombo.RecId == _generalJournalAccountEntry.LedgerDimension;

            _generalJournalAccountEntry.LedgerAccount = dimAttrValueCombo.DisplayValue;
            _generalJournalAccountEntry.MainAccount = dimAttrValueCombo.MainAccount;
        }

        // update the internal values because insert has no override
        _generalJournalAccountEntry.calculateInternalValues(_reverseOppositeSignAmounts);

        return _generalJournalAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGeneralJournalAccountEntry</Name>
				<Source><![CDATA[
    private void validateGeneralJournalAccountEntry(GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        if (!_generalJournalAccountEntry.GeneralJournalEntry)
        {
            throw error("@GeneralLedger:TransactionMissingGeneralJournalEntry");
        }

        if (!_generalJournalAccountEntry.LedgerDimension)
        {
            throw error("@GeneralLedger:TransactionMissingLedgerDimension");
        }

        if (!_generalJournalAccountEntry.TransactionCurrencyCode)
        {
            throw error("@GeneralLedger:TransactionMissingCurrencyCode");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateGeneralJournalEntry</Name>
				<Source><![CDATA[
    private void validateGeneralJournalEntry(GeneralJournalEntry _generalJournalEntry)
    {
        if (_generalJournalEntry.JournalNumber == '')
        {
            throw error("@SYS24569");
        }

        if (!_generalJournalEntry.AccountingDate)
        {
            throw error("@GeneralLedger:JournalMissingAccountingDate");
        }

        if (!_generalJournalEntry.Ledger)
        {
            throw error("@GeneralLedger:JournalMissingLedger");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowTaxPostingTypeSummarizedToZero</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate the <c>GeneralJournalAccountEntry</c> posting type equals to sales tax and DetailSummary equals to Summary.
    /// </summary>
    /// <param name = "_line">The buffer of <c>GeneralJournalAccountEntry</c></param>
    /// <param name = "_transferLevel">The enum value for DetailSummary</param>
    /// <param name = "_tempHeaderIdToHeaderCollection">The map of temp header id.</param>
    /// <returns>true if posting type equals to sales tax and transferLevel equals to Summary when transaction type is General journal; otherwise, false.</returns>
    private boolean allowTaxPostingTypeSummarizedToZero(
        GeneralJournalAccountEntry _line,
        DetailSummary _transferLevel,
        Map _tempHeaderIdToHeaderCollection)
    {
        boolean ret = false;
        GeneralJournalEntry generalJournalEntry = null;

        if (isGeneralLedgerMemReduceFlightEnabled)
        {
            generalJournalEntry = GeneralJournalEntry::find(_line.GeneralJournalEntry);
        }
        else
        {
            if (_tempHeaderIdToHeaderCollection && _tempHeaderIdToHeaderCollection.exists(_line.GeneralJournalEntry))
            {
                generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(_line.GeneralJournalEntry);
            }
        }

        if (_line.PostingType == LedgerPostingType::Tax
            && _transferLevel == DetailSummary::Summary
            && (generalJournalEntry != null))
        {
            CustVendSettlement custVendSettlement;
            select firstOnly TransRecId from custVendSettlement
                where custVendSettlement.SettlementVoucher == generalJournalEntry.SubledgerVoucher;

            LedgerJournalTrans ledgerJournalTrans;
            select firstonly TransactionType from ledgerJournalTrans
                where (ledgerJournalTrans.CustTransId != 0
                        && custVendSettlement.TableId == tableNum(CustSettlement)
                        && ledgerJournalTrans.CustTransId == custVendSettlement.TransRecId)
                    || (ledgerJournalTrans.VendTransId != 0
                        && custVendSettlement.TableId == tableNum(VendSettlement)
                        && ledgerJournalTrans.VendTransId == custVendSettlement.TransRecId);

            ret = ledgerJournalTrans.TransactionType == LedgerTransType::GeneralJournal;

            // When <c>TaxPostingZeroAmountInSalesOrderFlight</c> is enabled, the system allows to post sales order invoice with zero tax amount in voucher transactions.
            if (!ret && TaxPostingZeroAmountInSalesOrderFlight::instance().isEnabled())
            {
                CustInvoiceJour custInvoiceJour;

                select firstonly RecId from custInvoiceJour
                    where custInvoiceJour.LedgerVoucher == generalJournalEntry.SubledgerVoucher
                        && custInvoiceJour.InvoiceDate == generalJournalEntry.AccountingDate
                        && custInvoiceJour.SalesId != '';

                ret = (custInvoiceJour.RecId != 0);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivityContextForLedgerPostingGeneralJournalController</Name>
				<Source><![CDATA[
    private SysInstrumentationActivityContext getActivityContextForLedgerPostingGeneralJournalController(str _activityName)
    {
        str instrumentationNamespace = classStr(LedgerPostingGeneralJournalController);

        if (instrumentationLogger == null)
        {
            instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(classStr(LedgerPostingGeneralJournalController));
        }

        return instrumentationLogger.activityContext(_activityName, instrumentationNamespace);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferHeadersV2</Name>
				<Source><![CDATA[
    private void transferHeadersV2(Map _tempHeaderIdToHeaderCollection, Map _tempHeaderIdToSubledgerVoucherLinkCollection)
    {
        GeneralJournalEntry generalJournalEntry;
        TableId headerTableId = tableNum(GeneralJournalEntry);

        RecordSortedList newGeneralJournalEntryCollection = this.createReferenceCollection();
        RecordInsertList subledgerVoucherLinkList = new RecordInsertList(tableNum(SubledgerVoucherGeneralJournalEntry));

        SystemSequence sysSeqHeader = new SystemSequence();

        try
        {
            sysSeqHeader.suspendRecIds(headerTableId);
            RecId nextHeaderRecId = sysSeqHeader.reserveValues(generalJournalEntryCollection.len(), headerTableId);

            boolean haveRecord = generalJournalEntryCollection.first(generalJournalEntry);
            while (haveRecord)
            {
                generalJournalEntry.JournalNumber = journalNumberNumberSeq.num();

                this.validateGeneralJournalEntry(generalJournalEntry);

                // set the LedgerEntryJournal FK (may be empty)
                generalJournalEntry.LedgerEntryJournal = ledgerEntryJournal.RecId;

                boolean success = this.insertGeneralJournalEntryCollection(generalJournalEntry, true);

                // RecordSortedList.ins always returns false for an update so assert it is false
                Debug::assert(!success);

                RecId tempHeaderId = generalJournalEntry.RecId;
                generalJournalEntry.RecId = nextHeaderRecId;
                nextHeaderRecId++;
                _tempHeaderIdToHeaderCollection.insert(tempHeaderId, generalJournalEntry);
            
                // add it to a new collection because RecId can't be updated in generalJournalEntryCollection because it is the key
                success = newGeneralJournalEntryCollection.ins(generalJournalEntry, false);
                Debug::assert(success);

                generalJournalEntryRecIdValues.insert(
                    [generalJournalEntry.SubledgerVoucher, generalJournalEntry.AccountingDate],
                    generalJournalEntry.RecId);

                SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;
                subledgerVoucherLink.Voucher = generalJournalEntry.SubledgerVoucher;
                subledgerVoucherLink.VoucherDataAreaId = generalJournalEntry.SubledgerVoucherDataAreaId;
                subledgerVoucherLink.AccountingDate = generalJournalEntry.AccountingDate;
                subledgerVoucherLink.GeneralJournalEntry = generalJournalEntry.RecId;
                subledgerVoucherLinkList.add(subledgerVoucherLink);

                _tempHeaderIdToSubledgerVoucherLinkCollection.insert(tempHeaderId, subledgerVoucherLink);

                // reset for the next
                generalJournalEntry.RecId = tempHeaderId;

                haveRecord = generalJournalEntryCollection.next(generalJournalEntry);
            }

            // create the permanent GeneralJournalEntry records
            newGeneralJournalEntryCollection.insertDatabase();
        }
        finally
        {
            if (sysSeqHeader != null)
            {
                // this has to be done after the records have been created
                sysSeqHeader.removeRecIdSuspension(headerTableId);
            }
        }

        // create the permanent SubledgerVoucherGeneralJournalEntry records
        subledgerVoucherLinkList.insertDatabase();

        // remove the temp records from the instance because the instance is public
        boolean haveRecord = generalJournalEntryCollection.first(generalJournalEntry);
        while (haveRecord)
        {
            generalJournalEntryCollection.del(generalJournalEntry);

            haveRecord = generalJournalEntryCollection.next(generalJournalEntry);
        }

        // add the permanent records to the the instance because the instance is public
        haveRecord = newGeneralJournalEntryCollection.first(generalJournalEntry);
        while (haveRecord)
        {
            boolean success = generalJournalEntryCollection.ins(generalJournalEntry);
            Debug::assert(success);

            haveRecord = newGeneralJournalEntryCollection.next(generalJournalEntry);
        }

        if (useGeneralJournalEntry_W)
        {
            GeneralJournalEntry_W generalJournalEntryW;

            haveRecord = generalJournalEntryWs.first(generalJournalEntryW);
            while (haveRecord)
            {
                generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(generalJournalEntryW.RecId);
                generalJournalEntryW.GeneralJournalEntry = generalJournalEntry.RecId;

                boolean success = generalJournalEntryWs.ins(generalJournalEntryW, true);

                // RecordSortedList.ins always returns false for an update so assert it is false
                Debug::assert(!success);

                haveRecord = generalJournalEntryWs.next(generalJournalEntryW);
            }

            // create the GeneralJournalEntry_W records
            generalJournalEntryWs.insertDatabase();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferLinesV2</Name>
				<Source><![CDATA[
    private void transferLinesV2(
        DetailSummary _transferLevel,
        RecordSortedList _lineCollection,
        LedgerPostingOneToManyCollection _consolidateHistoryLinkCollection,
        RecordSortedList _ledgerEntryCollection,
        RecordSortedList _taxLinkCollection,
        Map _tempHeaderIdToHeaderCollection,
        Map _tempHeaderIdToSubledgerVoucherLinkCollection,
        RecordSortedList _lineWCollection,
        Map _allLinesSummarizedToZeroForHeaderStatusCollection)
    {
        // If posting to general ledger core transaction tables only (which only applies to posting in Detail, not Summary), short-circuit the rest of the execution
        // Called here to maintain extensibility hook point
        if (_transferLevel == DetailSummary::Detail && isGeneralLedgerCore)
        {
            this.transferLinesForGeneralLedgerCore(
                detailGeneralJournalAccountEntryCollection,
                _tempHeaderIdToHeaderCollection,
                _tempHeaderIdToSubledgerVoucherLinkCollection,
                detailGeneralJournalAccountEntryWs);

            return;
        }
        else if (_transferLevel == DetailSummary::Summary && isGeneralLedgerCore)
        {
            return;
        }

        GeneralJournalAccountEntry line;
        boolean success;
        boolean reverseOppositeSignAmounts = LedgerParameters::find().ReverseOppositeSignAmounts;
        TableId lineTableId = tableNum(GeneralJournalAccountEntry);
        
        Map currentLineCountByHeader = new Map(Types::Int64, Types::Int64);
        Map lineIdToTempLineIdCollection = new Map(Types::Int64, Types::Int64);
        Set lineCreatedForHeader = new Set(Types::Int64);
        tempLineIdToLineIdCollection = new Map(Types::Int64, Types::Int64);

        RecordSortedList newLineCollection = new RecordSortedList(tableNum(GeneralJournalAccountEntry));
        newLineCollection.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));

        RecordSortedList summarizedToZeroLine = new RecordSortedList(tableNum(GeneralJournalAccountEntry));
        summarizedToZeroLine.sortOrder(fieldNum(GeneralJournalAccountEntry, RecId));

        SystemSequence sysSeqLine = new SystemSequence();

        Map gjeAccountingDateCollection = new Map(Types::Int64, Types::Date);
        Map gjeTmpHeaderToActualRecIdCollection = new Map(Types::Int64, Types::Int64);

        try
        {
            sysSeqLine.suspendRecIds(lineTableId);
            RecId nextLineRecId = sysSeqLine.reserveValues(_lineCollection.len(), lineTableId);

            boolean haveRecord = _lineCollection.first(line);
            while (haveRecord)
            {
                this.validateGeneralJournalAccountEntry(line);

                RecId tempHeaderId = line.GeneralJournalEntry;

                GeneralJournalEntry generalJournalEntry = _tempHeaderIdToHeaderCollection.lookup(tempHeaderId);
                line.GeneralJournalEntry = generalJournalEntry.RecId;

                if (isLedgerPostingTransferLinesV2ReduceSQLCallsFlightEnabled)
                {
                    if (!gjeAccountingDateCollection.exists(generalJournalEntry.RecId))
                    {
                        gjeAccountingDateCollection.add(generalJournalEntry.RecId, generalJournalEntry.AccountingDate);
                    }

                    if (!gjeTmpHeaderToActualRecIdCollection.exists(generalJournalEntry.RecId))
                    {
                        gjeTmpHeaderToActualRecIdCollection.add(generalJournalEntry.RecId, tempHeaderId);
                    }
                }

                int64 currentLine = this.incrementCountForRecId(currentLineCountByHeader, tempHeaderId);
                int64 lineCount = lineCountByHeader.lookup(tempHeaderId);

                boolean lineHasAmount = (line.hasAmount()
                    || FeatureStateProvider::isFeatureEnabled(PostingZeroInvoicesInGeneralLedgerFeature::instance())
                    || this.allowTaxPostingTypeSummarizedToZero(line, _transferLevel, null));

                if (lineHasAmount)
                {
                    _allLinesSummarizedToZeroForHeaderStatusCollection.insert(line.GeneralJournalEntry, false);
                }

                if (this.lineIsValidForTransfer(
                       _transferLevel,
                       line,
                       currentLine,
                       lineCount,
                       lineCreatedForHeader,
                       lineHasAmount,
                       _allLinesSummarizedToZeroForHeaderStatusCollection))
                {
                    // the line will be created because at least one amount field has a value or it is the only line for the header
                    RecId tempLineId = line.RecId;
                    line.RecId = nextLineRecId;
                    nextLineRecId++;

                    lineCreatedForHeader.add(line.GeneralJournalEntry);

                    tempLineIdToLineIdCollection.insert(tempLineId, line.RecId);

                    if (isZakatEnabled || isReversal)
                    {
                        lineIdToTempLineIdCollection.insert(line.RecId, tempLineId);
                    }

                    this.finalizeGeneralJournalAccountEntryForInsert(line, generalJournalEntry, reverseOppositeSignAmounts);

                    if (lineHasAmount)
                    {
                        success = newLineCollection.ins(line);
                    }
                    else
                    {
                        success = summarizedToZeroLine.ins(line);
                    }

                    Debug::assert(success);
                }

                haveRecord = _lineCollection.next(line);
            }

            /// For general journal entries which have only transactions summarized to zero, add the
            /// transactions to the insert list.
            haveRecord = summarizedToZeroLine.first(line);
            while (haveRecord)
            {
                if (_allLinesSummarizedToZeroForHeaderStatusCollection.exists(line.GeneralJournalEntry))
                {
                    boolean allLinesSummarizedToZeroForHeaderResult = _allLinesSummarizedToZeroForHeaderStatusCollection.lookup(line.GeneralJournalEntry);
                    if (allLinesSummarizedToZeroForHeaderResult)
                    {
                        newLineCollection.ins(line);
                    }
                }

                haveRecord = summarizedToZeroLine.next(line);
            }

            if (!TransactionlogUpdateTTSControl::Instance().isInvoked())
            {
                TransactionlogUpdateTTSControl::Instance().invoke();
            }

            // create the permanent GeneralJournalAccountEntry records
            newLineCollection.insertDatabase();
        }
        finally
        {
            if (sysSeqLine != null)
            {
                // this has to be done after the records have been created
                sysSeqLine.removeRecIdSuspension(lineTableId);
            }
        }

        // the TaxTrans voucher is global from this point on because that is the legacy behavior
        Voucher taxTransVoucher = '';

        if (isZakatEnabled || isReversal)
        {
            boolean haveRecord = newLineCollection.first(line);
            while (haveRecord)
            {
                RecId tempLineId = lineIdToTempLineIdCollection.lookup(line.RecId);
                TransDate accountingDate;
                SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;

                if (isLedgerPostingTransferLinesV2ReduceSQLCallsFlightEnabled)
                {
                    accountingDate = gjeAccountingDateCollection.lookup(line.GeneralJournalEntry);
                    RecId tempHeaderId = gjeTmpHeaderToActualRecIdCollection.lookup(line.GeneralJournalEntry);
                    subledgerVoucherLink = _tempHeaderIdToSubledgerVoucherLinkCollection.lookup(tempHeaderId);

                    // this statement is needed to support the TaxTrans voucher legacy behavior even though it was most likely not intentional in the original implementation
                    taxTransVoucher = subledgerVoucherLink.Voucher;
                }
                else
                {
                    GeneralJournalEntry generalJournalEntry = GeneralJournalEntry::find(line.GeneralJournalEntry);
                    accountingDate = generalJournalEntry.AccountingDate;
                    subledgerVoucherLink = SubledgerVoucherGeneralJournalEntry::findByGeneralJournalEntryRecId(line.GeneralJournalEntry);
                    
                    // this statement is needed to support the TaxTrans voucher legacy behavior even though it was most likely not intentional in the original implementation
                    taxTransVoucher = subledgerVoucherLink.Voucher;
                }

                if (isReversal)
                {
                    if (reversalLineRecordIdCollection.in(tempLineId))
                    {
                        line.reverseSettlement(tempLineId);
                    }

                    if (isZakatEnabled)
                    {
                        GeneralJournalAccountEntryZakat_SA::insertReversalTrans(tempLineId, line.RecId, accountingDate);
                    }
                }
                else if (isZakatEnabled)
                {
                    GeneralJournalAccountEntryZakat_SA::insertZakatInformation(line, subledgerVoucherLink.Voucher, accountingDate);
                }

                haveRecord = newLineCollection.next(line);
            }
        }
        else
        {
            // this loop is needed to support the TaxTrans voucher legacy behavior even though it was most likely not intentional in the original implementation
            boolean haveRecord = newLineCollection.first(line);
            SubledgerVoucherGeneralJournalEntry subledgerVoucherLink;

            while (haveRecord)
            {
                if (isLedgerPostingTransferLinesV2ReduceSQLCallsFlightEnabled)
                {
                    RecId tempHeaderId = gjeTmpHeaderToActualRecIdCollection.lookup(line.GeneralJournalEntry);
                    subledgerVoucherLink = _tempHeaderIdToSubledgerVoucherLinkCollection.lookup(tempHeaderId);
                    taxTransVoucher = subledgerVoucherLink.Voucher;
                }
                else
                {
                    subledgerVoucherLink = SubledgerVoucherGeneralJournalEntry::findByGeneralJournalEntryRecId(line.GeneralJournalEntry);
                    taxTransVoucher = subledgerVoucherLink.Voucher;
                }

                haveRecord = newLineCollection.next(line);
            }
        }

        // <GEEU>
        if (useGeneralJournalAccountEntry_W)
        {
            this.transferLineWs(_lineWCollection, tempLineIdToLineIdCollection, null, null); // last two parameters are not used for V2 calls
        }
        // </GEEU>

        this.transferEntries(_ledgerEntryCollection, tempLineIdToLineIdCollection);

        // <GIN>
        if (TaxParameters::isVATEnable_IN() && isVATDeferment)
        {
            this.transferVATDefermentTaxLinks_IN(
                 _taxLinkCollection,
                 tempLineIdToLineIdCollection);
        }
        else
        {
            // </GIN>

            if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode()
                && !TaxTrans::existForVoucher(taxTransVoucher))
            {
                this.transferTransactionLinks(
                    taxLinkGeneralJournalAccountEntryTransactionLink,
                    tempLineIdToLineIdCollection);
            }
            else
            {
                this.transferTaxLinks(
                    _taxLinkCollection,
                    tempLineIdToLineIdCollection);
            }
            // <GIN>
        }
        // </GIN>

        // <GIN>
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if ( _transferLevel == DetailSummary::Detail)
            {
                this.transferTaxWithholdLinks_IN(
                    detailTaxWHTLinkCollection,
                    tempLineIdToLineIdCollection);
            }
            else
            {
                this.transferTaxWithholdLinks_IN(
                    summaryTaxWHTLinkCollection,
                    tempLineIdToLineIdCollection);
            }
        }
        // </GIN>

        this.transferConsolidateHistoryLinks(
            _consolidateHistoryLinkCollection,
            tempLineIdToLineIdCollection);

        // <GEERU>
        LedgerPostingGeneralJournalTurnover_RU::postTransferLinesEventHandler(
            _transferLevel,
            _lineCollection,
            _consolidateHistoryLinkCollection,
            _ledgerEntryCollection,
            _taxLinkCollection,
            _tempHeaderIdToHeaderCollection,
            _tempHeaderIdToSubledgerVoucherLinkCollection,
            _lineWCollection);
        // </GEERU>
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>