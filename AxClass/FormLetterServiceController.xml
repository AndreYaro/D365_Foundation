<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>FormLetterServiceController</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>FormletterServiceController</c> class acts as the controller for the
///    <c>FormletterService</c> class.
/// </summary>
abstract class  FormLetterServiceController
extends SysOperationServiceController
{
    FormLetterContract          contract;
    FormletterOutputContract    formletterOutputContract;

    boolean                 reArrangeNow;
    boolean                 validateAll;

    FormLetterServiceController interCompanyCalledFromFormLetter;
    FormLetterServiceController interCompanyCreatedFormLetter;

    boolean                 printerSetupError;
    Query                   queryUsed;

    boolean                 contractIsFromPreviousVersion;
    // The caller form name is used as a differentiator for SysLastValue retrieval.
    str                     callerFormName;

    // <GEERU>
    TradeLineRefId          tradeLineRefId;
    // </GEERU>

    private boolean         openedWithArgs;
    private boolean         historyReadOnly;

    #localmacro.LinePrefix
        setPrefix(#PreFixField(%1, ItemId)  + ' '
                + %2 );
    #endmacro

    const str contractConst = '_contract';
    protected const int TransactionLineNameLengthLimit = 256;
    }
]]></Declaration>
		<Methods>
			<Method>
				<Name>afterOperation</Name>
				<Source><![CDATA[
    protected void afterOperation(
        SysOperationExecutionMode   _executionMode,
        AifAsyncResult              _asyncResult)
    {
        super(_executionMode, _asyncResult);
        formletterOutputContract = this.operationReturnValue();
        this.afterOperationBody();
        this.afterOperationEnd();
        this.afterOperationUpdateError(formletterOutputContract.parmUpdateError());
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterOperationBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the main logic for after the operation, before cleanup.
    /// </summary>
    protected void afterOperationBody()
    {
        this.afterOperationPrint();
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterOperationEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the post-operation closure.
    /// </summary>
    protected void afterOperationEnd()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterOperationPrint</Name>
				<Source><![CDATA[
    private void afterOperationPrint()
    {
        FormletterJournalPrint  journalPrint;
        Set                     journalSet;
        // <GEERU>
        Set                     factureSet;
        // </GEERU>
        boolean                 isPrint =  contract.parmIsPrintingInAfterOperation();

        if (isPrint || args)
        {
            journalSet = Set::create(formletterOutputContract.parmAllJournalsPacked());
            journalPrint = FormletterJournalPrint::newFromFormletterContract(contract);

            if (isPrint)
            {
                // <GEERU>
                if (formletterOutputContract.parmFactureJournals_RU())
                {
                    factureSet = Set::create(SysOperationHelper::base64Decode(formletterOutputContract.parmFactureJournals_RU()));
                    journalPrint.parmFactureList_RU(factureSet);
                }
                // </GEERU>

                journalPrint.printJournal(journalSet);
            }

            if (args)
            {
                journalPrint.printLabels(args, journalSet);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>afterOperationUpdateError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs error handling after the operation.
    /// </summary>
    /// <param name="_updateError">
    /// A Boolean value that indicates whether error messages should be reported.
    /// </param>
    protected void afterOperationUpdateError(boolean _updateError)
    {
        if (_updateError)
        {
            throw error("@SYS78886");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEmptyTable</Name>
				<Source><![CDATA[
    public boolean  allowEmptyTable(boolean  _allowEmptyTable = contract.parmAllowEmptyTable())
    {
        return contract.parmAllowEmptyTable(_allowEmptyTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkClientOutput</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the destination for printing the original or copy of a report is client based.
    /// </summary>
    /// <param name="_showError">
    /// A Boolean value that indicates whether error messages should be reported; optional.
    /// </param>
    /// <returns>
    /// true if the destination for either the original or copy of the report is screen; otherwise,
    /// false.false.
    /// </returns>
    protected boolean checkClientOutput(boolean _showError = true)
    {
        return FormLetter::isClientOutput(this.printerSettingsFormletter(PrintSetupOriginalCopy::Original)) ||
                FormLetter::isClientOutput(this.printerSettingsFormletter(PrintSetupOriginalCopy::Copy));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkClientOutputPrintManagement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies that the selected printers in print management, for printing an original and a copy of
    /// reports, are using client output options.
    /// </summary>
    /// <param name="_showError">
    /// A Boolean value that indicates whether error messages should be reported; optional.
    /// </param>
    /// <returns>
    /// true if the report destination is screen; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The method is used for finding the default printer setup in print management for the specific
    /// document.
    /// </remarks>
    protected boolean checkClientOutputPrintManagement(boolean _showError = true)
    {
        FormLetterPrintManagementValidate formLetterPrintManagementValidate = new FormLetterPrintManagementValidate();
        return formLetterPrintManagementValidate.checkClientOutputPrintManagement(this.printMgmtDocumentType(), this.printMgmtNodeType());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrinterSettingsMultiThread</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether the selected printers for printing journals are Application Object Server (AOS)
    ///    configured printers.
    /// </summary>
    /// <returns>
    ///    true if the selected printers are AOS configured printers; otherwise, false.
    /// </returns>
    public boolean checkPrinterSettingsMultiThread()
    {
        if (this.printFormLetter() && this.batchInfo().parmBatchExecute())
        {
            FormLetterPrintManagementValidate formLetterPrintManagementValidate = new FormLetterPrintManagementValidate();
            return formLetterPrintManagementValidate.checkPrinterSettingsMultiThread(this.usePrintManagement(), printerSetupError, this.checkClientOutput(), this.printMgmtDocumentType(), this.printMgmtNodeType());
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrintOut</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the <c>PrintOut</c> setting.
    /// </summary>
    /// <param name="_printout">
    /// The <c>PrintOut</c> value to check.
    /// </param>
    /// <returns>
    /// true if the setting is valid; otherwise false.
    /// </returns>
    public boolean checkPrintOut(Printout _printout)
    {
        boolean valid = true;

        if (_printout == Printout::Current
        &&  FormLetterServiceControllerCheckPrintSettingsToggle::instance().isEnabled()
        &&  this.mustPrintInAfterOperation())
        {
            //'%1' is not allowed when printer settings are set to a client target.
            valid = checkFailed(strFmt("@SYS340046", enum2Value(Printout::Current)));
        }

        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesQuery</Name>
				<Source><![CDATA[
    SysQueryRun  chooseLinesQuery(SysQueryRun  _chooseLines = new SysQueryRun(SysOperationHelper::base64Decode(contract.parmChooseLinesQueryPacked())))
    {
        if (_chooseLines != null)
        {
            return new SysQueryRun(SysOperationHelper::base64Decode(contract.parmChooseLinesQueryPacked(SysOperationHelper::base64Encode(_chooseLines.pack()))));
        }
        else
        {
            contract.parmChooseLinesQueryPacked('');
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDialog</Name>
				<Source><![CDATA[
    protected void  cleanupDialog()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromLines</Name>
				<Source><![CDATA[
    public boolean createFromLines(boolean _createFromLines = contract.parmCreateFromLines())
    {
        return contract.parmCreateFromLines(_createFromLines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogMake</Name>
				<Source><![CDATA[
    /// <summary>
    ///  internal use only.
    /// </summary>
    /// <returns>
    /// An instance of the <c>Object</c> class.
    /// </returns>
    protected IDialogable dialogMake()
    {
        IDialogable dlg = this.dialog();

        if (this.canGoBatch())
        {
            this.batchInfo().dialog(dlg);
        }

        return dlg;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///  internal use only.
    /// </summary>
    protected void dialogPostRun()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogRun</Name>
				<Source><![CDATA[
    protected SysOperationStartResult dialogRun()
    {
        SysOperationStartResult result;
        CompanyId               companyId = curext();

        result = super();

        if (result == SysOperationStartResult::Canceled)
        {
            this.cleanupDialog();
        }

        if (companyId != curext())
        {
            appl.setDefaultCompany(companyId, false);
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    abstract public DocumentStatus documentStatus()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceSaveLast</Name>
				<Source><![CDATA[
    public void forceSaveLast()
    {
        this.saveLast();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContract</Name>
				<Source><![CDATA[
    public FormLetterContract getContract()
    {
        return contract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    public void getLast(boolean _skipReset = false)
    {
        this.setNewContract(this.getDataContractObject(contractConst));

        if (!_skipReset)
        {
            this.resetParmListCommonCS();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastFromCallerFormName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>SysLastValue</c> value for the <c>FormLetter</c> form with the caller form name as a
    /// differentiator.
    /// </summary>
    /// <remarks>
    /// If no caller form name is specified then the ordinary retrieval is performed.
    /// </remarks>
    protected void getLastFromCallerFormName()
    {
        str tmpCallerFormName;
        dataContractsInitialized = false;
        // Retrieve SysLastValue also based on caller form name
        if (callerFormName)
        {
            if (xSysLastValue::existLast(this))
            {
                // getLast() calls this.lastValueDesignName() which returns the caller form name.
                this.getLast();
            }
            else
            {
                // If the retrieval failed, then try without the caller form name to get legacy values.
                tmpCallerFormName   = callerFormName;
                callerFormName      = '';
                this.getLast();
                callerFormName      = tmpCallerFormName;
            }
        }
        else
        {
            // For normal retrieval when no caller form is specified.
            this.getLast();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumAndVoucher</Name>
				<Source><![CDATA[
    public container  getNumAndVoucher()
    {
        return [contract.parmNumber(), contract.parmVoucher()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOutputContract</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the output data contract of the last service call.
    /// </summary>
    /// <returns>
    ///    A <c>FormletterOutputContract</c> object.
    /// </returns>
    public FormletterOutputContract getOutputContract()
    {
        return formletterOutputContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init()
    {
        this.setNewContract(this.getDataContractObject(contractConst));

        // When originally initializing, default the showQueryForm to false
        // regardless of how it was packed in SysLastValue since showing
        // the form should default to false
        contract.parmShowQueryForm(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAllowEmptyTable</Name>
				<Source><![CDATA[
    public boolean  initAllowEmptyTable(boolean  _initAllowEmptyTable = contract.parmInitAllowEmptyTable())
    {
        return contract.parmInitAllowEmptyTable(_initAllowEmptyTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeServiceParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>SysDictClass</c> class for each data contract that is found in a
    /// service operation contract.
    /// </summary>
    /// <param name="dictMethod">
    /// The <c>DictMethod</c> object that describes the service operation.
    /// </param>
    /// <param name="parameterIndex">
    /// The index of the service parameter.
    /// </param>
    /// <returns>
    /// An instance of the <c>SysDictClass</c> class.
    /// </returns>
    /// <remarks>
    /// Override this method if custom initialization of the data contract class is required.
    /// </remarks>
    protected Object initializeServiceParameter(DictMethod dictMethod, int parameterIndex)
    {
        Object dataContract;

        dataContract = super(dictMethod, parameterIndex);
        if (dataContract != null)
        {
            this.setNewContract(dataContract);
        }

        return dataContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCalledFromFormletter</Name>
				<Source><![CDATA[
    public FormLetterServiceController interCompanyCalledFromFormletter(FormLetterServiceController _formLetter = interCompanyCalledFromFormLetter)
    {
        interCompanyCalledFromFormLetter = _formLetter;
        return interCompanyCalledFromFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCreatedFormletter</Name>
				<Source><![CDATA[
    public FormLetterServiceController interCompanyCreatedFormletter(FormLetterServiceController _formLetter = interCompanyCreatedFormLetter)
    {
        interCompanyCreatedFormLetter = _formLetter;
        return interCompanyCreatedFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMap</Name>
				<Source><![CDATA[
    public Map interCompanyMap(Map _map = Map::create(SysOperationHelper::base64Decode(contract.parmIntercompanyMapPacked())))
    {
        if (_map)
        {
            contract.parmIntercompanyMapPacked(SysOperationHelper::base64Encode(_map.pack()));
        }
        return _map;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmId</Name>
				<Source><![CDATA[
    public ParmId  interCompanyParmId(ParmId _interCompanyParmId = contract.parmIntercompanyParmId())
    {
        return contract.parmIntercompanyParmId(_interCompanyParmId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmSelectFromJournal</Name>
				<Source><![CDATA[
    public boolean interCompanyParmSelectFromJournal(boolean _selectFromJournal = contract.parmIntercompanySelectFromJournal())
    {
        return contract.parmIntercompanySelectFromJournal(_selectFromJournal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPosted</Name>
				<Source><![CDATA[
    public InterCompanyPosted interCompanyPosted(InterCompanyPosted _interCompanyPosted = contract.parmIntercompanyPosted())
    {
        return contract.parmIntercompanyPosted(_interCompanyPosted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySelectFromJournal</Name>
				<Source><![CDATA[
    boolean interCompanySelectFromJournal()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVersioningCorrectionOrCancel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a versioning update type is Correction or Cancel.
    /// </summary>
    /// <returns>
    /// true if a versioning update type is Correction or Cancel; otherwise, false.
    /// </returns>
    /// <remarks>
    /// See <c>VersioningUpdateType</c>.
    /// </remarks>
    public boolean isVersioningCorrectionOrCancel()
    {
        return    this.parmVersioningUpdateType() == VersioningUpdateType::Correction
               || this.parmVersioningUpdateType() == VersioningUpdateType::Cancel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the design name that is used as a differentiator for the retrieval of a
    ///    <c>SysLastValue</c> value.
    /// </summary>
    /// <returns>
    ///    The caller form name for the form letter.
    /// </returns>
    /// <remarks>
    ///    If the caller form name is empty then the retrieval differentiates based on the class name.
    /// </remarks>
    public IdentifierName lastValueDesignName()
    {
        if (callerFormName)
        {
            return callerFormName;
        }
        else
        {
            return super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateSelection</Name>
				<Source><![CDATA[
    public boolean lateSelection()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>multiForm</Name>
				<Source><![CDATA[
    public boolean  multiForm(boolean  _multiForm = contract.parmMultiForm())
    {
        return contract.parmMultiForm(_multiForm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPrintInAfterOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether printing must occur in the after operation instead of in the service.
    /// </summary>
    /// <returns>
    /// true if printing must occur in the after operation; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Printing to a client target cannot occur from a service; therefore, printing must be performed in
    /// the after operation method.
    /// </remarks>
    protected boolean mustPrintInAfterOperation()
    {
        if (this.proforma())
        {//proforma does not execute in IL.
            return false;
        }

        // <GEERU>
        if (!this.printFormLetter()              &&
           ! this.printFacture_RU()             &&
           ! this.printAcceptanceReport_RU()    &&
           ! this.printInventBaileeReport_RU()  &&
           ! this.printBillOfLading_RU()        &&
           ! this.printTransportInvoice_RU()    &&
        // </GEERU>
           ! this.printExtraDocuments()
          )
        {
            return false;
        }

        if (this.usePrintManagement())
        {
            return this.checkClientOutputPrintManagement(false);
        }
        else
        {
            return this.checkClientOutput(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>name</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the name of the <c>SysOperationController</c> class.
    /// </summary>
    /// <returns>
    /// The name of the <c>SysOperationController</c> class.
    /// </returns>
    /// <remarks>
    /// This method should not typically be overridden.
    /// </remarks>
    public IdentifierName name()
    {
        return classId2Name(classIdGet(this));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void  new(
        IdentifierName _className='',
        IdentifierName _methodName='',
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::ReliableAsynchronous)
    {
        super(_className,_methodName,_executionMode);

        showDialog              = true;
        this.validateAll(true);
        formletterOutputContract = FormletterOutputContract::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>onPostingSuccess</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method gets called when some documents are posted. Child classes override
    ///     this method to handle successful posting of docuemnts.
    /// </summary>
    /// <param name="_postedJournalSet">
    ///     A <c>Set</c> object containing the journal entries for posted documents.
    /// </param>
    public void onPostingSuccess(Set _postedJournalSet)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>packDataContract</Name>
				<Source><![CDATA[
    protected container packDataContract(FormLetterContract _contract)
    {
        return _contract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate(AccountingDate _accountingDate = contract.parmAccountingDate())
    {
        return contract.parmAccountingDate(_accountingDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchCreatedBy</Name>
				<Source><![CDATA[
    public UserId parmBatchCreatedBy(UserId _batchCreatedBy = contract.parmBatchCreatedBy())
    {
        return contract.parmBatchCreatedBy(_batchCreatedBy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchGroupId</Name>
				<Source><![CDATA[
    public BatchGroupId parmBatchGroupId(BatchGroupId _batchGroupId = contract.parmBatchGroupId())
    {
        return contract.parmBatchGroupId(_batchGroupId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBatchJobId</Name>
				<Source><![CDATA[
    public RefRecId parmBatchJobId(RefRecId _batchJobId = contract.parmBatchJobId())
    {
        return contract.parmBatchJobId(_batchJobId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerFormName</Name>
				<Source><![CDATA[
    public IdentifierName parmCallerFormName(IdentifierName _callerFormName = callerFormName)
    {
        callerFormName = _callerFormName;

        return callerFormName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerMenuItem</Name>
				<Source><![CDATA[
    public MenuItemNameAction parmCallerMenuItem(MenuItemNameAction _callerMenuItem = contract.parmCallerMenuItem())
    {
        return contract.parmCallerMenuItem(_callerMenuItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCallerTable</Name>
				<Source><![CDATA[
    public Common parmCallerTable(Common _callerTable = contract.parmCallerTable())
    {
        return contract.parmCallerTable(_callerTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateFromHistory</Name>
				<Source><![CDATA[
    public boolean parmCreateFromHistory(boolean _createFromHistory = contract.parmCreateFromHistory())
    {
        return contract.parmCreateFromHistory(_createFromHistory);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDataSourceRecordsPacked</Name>
				<Source><![CDATA[
    public container parmDataSourceRecordsPacked(container _dataSourceRecordsPacked = contract.parmDataSourceRecordMapPacked())
    {
        contract.parmDataSourceRecordMapPacked(_dataSourceRecordsPacked);

        return contract.parmDataSourceRecordMapPacked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoryRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the history list based on the specified packed map of data source records
    /// </summary>
    /// <param name = "_dataSourceRecordsMapPacked">A packed map of data source records.</param>
    /// <returns>The packed list of data source history records.</returns>
    public container parmHistoryRecords(container _dataSourceRecordsMapPacked)
    {
        container dataSourceRecordsListPacked = this.datasourceRecordList(_dataSourceRecordsMapPacked);
        return this.parmHistoryList(dataSourceRecordsListPacked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoryList</Name>
				<Source><![CDATA[
    public container parmHistoryList(container _packedHistoryList = contract.parmHistoryListContainerPacked())
    {
        if (FormLetterContractPackingUseContainerFlight::instance().isEnabled())
        {
            contract.parmHistoryListContainerPacked(_packedHistoryList);
            return contract.parmHistoryListContainerPacked();
        }
        else
        {
            if (!_packedHistoryList)
            {
                _packedHistoryList = SysOperationHelper::base64Decode(contract.parmHistoryListPacked());
            }
            return SysOperationHelper::base64Decode(contract.parmHistoryListPacked(SysOperationHelper::base64Encode(_packedHistoryList)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmId</Name>
				<Source><![CDATA[
    ParmId  parmId(ParmId  _parmId = contract.parmParmId())
    {
        return contract.parmParmId(_parmId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIdSynched</Name>
				<Source><![CDATA[
    ParmId  parmIdSynched(ParmId  _parmIdSynched = contract.parmParmIdSynched())
    {
        return contract.parmParmIdSynched(_parmIdSynched);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterCompanyCompanyId</Name>
				<Source><![CDATA[
    DataAreaId  parmInterCompanyCompanyId(DataAreaId _interCompanyCompanyId = contract.parmIntercompanyCompanyId())
    {
        return contract.parmIntercompanyCompanyId(_interCompanyCompanyId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalRecord</Name>
				<Source><![CDATA[
    public Common parmJournalRecord(Common _journalRecord = formletterOutputContract.parmJournal())
    {
        return formletterOutputContract.parmJournal(_journalRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineIdSet</Name>
				<Source><![CDATA[
    public container parmLineIdSet(container _packedLineIdSet = SysOperationHelper::base64Decode(contract.parmLineIdSetPacked()))
    {
        if (_packedLineIdSet)
        {
            return SysOperationHelper::base64Decode(contract.parmLineIdSetPacked(SysOperationHelper::base64Encode(_packedLineIdSet)));
        }
        else
        {
            contract.parmLineIdSetPacked('');
            return conNull();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the line list based on the specified packed map of data source records
    /// </summary>
    /// <param name = "_dataSourceRecordsMapPacked">A packed map of data source records.</param>
    /// <returns>The packed list of data source records.</returns>
    public container parmLineRecords(container _dataSourceRecordsMapPacked)
    {
        container dataSourceRecordsListPacked = this.datasourceRecordList(_dataSourceRecordsMapPacked);
        return this.parmLineList(dataSourceRecordsListPacked);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineList</Name>
				<Source><![CDATA[
    public container parmLineList(container _packedLineList = contract.parmLineListContainerPacked())
    {
        if (FormLetterContractPackingUseContainerFlight::instance().isEnabled())
        {
            contract.parmLineListContainerPacked(_packedLineList);
            return contract.parmLineListContainerPacked();
        }
        else
        {
            if (!_packedLineList)
            {
                _packedLineList = SysOperationHelper::base64Decode(contract.parmLineListPacked());
            }
            return SysOperationHelper::base64Decode(contract.parmLineListPacked(SysOperationHelper::base64Encode(_packedLineList)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQueryUsed</Name>
				<Source><![CDATA[
    public Query parmQueryUsed(Query _queryUsed = queryUsed)
    {
        queryUsed = _queryUsed;
        return queryUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSpecQtyIsSet</Name>
				<Source><![CDATA[
    public boolean parmSpecQtyIsSet(boolean _specQtyIsSet = contract.parmSpecQtyIsSet())
    {
        return contract.parmSpecQtyIsSet(_specQtyIsSet);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTradeLineRefId_RU</Name>
				<Source><![CDATA[
    public TradeLineRefId parmTradeLineRefId_RU(TradeLineRefId _tradeLineRefId = tradeLineRefId)
    {
        tradeLineRefId = _tradeLineRefId;
        return tradeLineRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseUserDefinedDestinations</Name>
				<Source><![CDATA[
    public boolean parmUseUserDefinedDestinations(boolean _useUserDefinedDestinations = contract.parmUseUserDefinedDestinations())
    {
        return contract.parmUseUserDefinedDestinations(_useUserDefinedDestinations);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersionDateTime</Name>
				<Source><![CDATA[
    public VersioningTimeStamp parmVersionDateTime(VersioningTimeStamp _versionDateTime = contract.parmVersionDateTime())
    {
        return contract.parmVersionDateTime(_versionDateTime);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersioningUpdateType</Name>
				<Source><![CDATA[
    public VersioningUpdateType parmVersioningUpdateType(VersioningUpdateType _versioningUpdateType = contract.parmVersioningUpdateType())
    {
        return contract.parmVersioningUpdateType(_versioningUpdateType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsSimulatePosting</Name>
				<Source><![CDATA[
    internal boolean parmIsSimulatePosting(boolean _isSimulatePosting = contract.parmIsSimulatePosting())
    {
        return contract.parmIsSimulatePosting(_isSimulatePosting);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInfologPrefix</Name>
				<Source><![CDATA[
    internal str parmInfologPrefix(str _infologPrefix = contract.parmInfologPrefix())
    {
        return contract.parmInfologPrefix(_infologPrefix);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAcceptanceReport_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should Acceptance report be printed when posting document
    /// </summary>
    /// <param name="_printAcceptanceReport">
    /// Should Acceptance report be printed when posting document
    /// </param>
    /// <returns>
    /// If true, acceptance report must be printed when posting document
    /// </returns>
    public boolean printAcceptanceReport_RU(boolean _printAcceptanceReport = contract.parmPrintAcceptanceReport_RU())
    {
        return contract.parmPrintAcceptanceReport_RU(_printAcceptanceReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printBillOfLading_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should bill of lading be printed when posting document
    /// </summary>
    /// <param name="_printBillOfLading">
    /// Should bill of lading be printed when posting document
    /// </param>
    /// <returns>
    /// If true, bill of lading must be printed when posting document
    /// </returns>
    public boolean printBillOfLading_RU(boolean _printBillOfLading = contract.parmPrintBillOfLading_RU())
    {
        return contract.parmPrintBillOfLading_RU(_printBillOfLading);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printerSettingsFormletter</Name>
				<Source><![CDATA[
    container printerSettingsFormletter(PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        if (_originalCopy == PrintSetupOriginalCopy::Copy)
        {
            return SysOperationHelper::base64Decode(contract.parmPrintersettingsFormletterCopy());
        }
        else
        {
            return SysOperationHelper::base64Decode(contract.parmPrintersettingsFormletter());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printManagementExtensionsSettings</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Returns packed settings for print management extensions.
    /// </summary>
    /// <returns>A container with packed settings.</returns>
    container printManagementExtensionsSettings()
    {
        return SysOperationHelper::base64Decode(contract.parmPrintManagementExtensionsSettings());
    }

]]></Source>
			</Method>
			<Method>
				<Name>printExtraDocuments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    The method shows if there are extra documents must be printed during posting except the form letter document.
    /// </summary>
    /// <returns>
    ///    True, if extra documents must be printed. False otherwise.
    /// </returns>
    protected boolean printExtraDocuments()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printFacture_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should facture be printed when posting document
    /// </summary>
    /// <param name="_printFacture">
    /// Should facture be printed when posting document
    /// </param>
    /// <returns>
    /// If true, facture must be printed when posting document
    /// </returns>
    public boolean printFacture_RU(boolean _printFacture = contract.parmPrintFacture_RU())
    {
        return contract.parmPrintFacture_RU(_printFacture);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printFormLetter</Name>
				<Source><![CDATA[
    boolean  printFormLetter(boolean  _printFormletter = contract.parmPrintFormletter())
    {
        return contract.parmPrintFormletter(_printFormletter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printInventBaileeReport_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should invent bailee be printed when posting document
    /// </summary>
    /// <param name="_printInventBaileeReport">
    /// Should invent bailee be printed when posting document
    /// </param>
    /// <returns>
    /// If true, invent bailee must be printed when posting document
    /// </returns>
    public boolean printInventBaileeReport_RU(boolean _printInventBaileeReport = contract.parmPrintInventBaileeReport_RU())
    {
        return contract.parmPrintInventBaileeReport_RU(_printInventBaileeReport);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the print management document type.
    /// </summary>
    /// <returns>
    ///    The print management document type.
    /// </returns>
    /// <remarks>
    ///    The print management document type identifies which document type relates to print management.
    /// </remarks>
    abstract protected PrintMgmtDocumentType printMgmtDocumentType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtNodeType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies the print management node type.
    /// </summary>
    /// <returns>
    /// The print management node type.
    /// </returns>
    abstract protected PrintMgmtNodeType printMgmtNodeType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>printout</Name>
				<Source><![CDATA[
    Printout  printout(Printout _printout = contract.parmPrintOut())
    {
        return contract.parmPrintOut(_printout);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printTransportInvoice_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should transport invoice be printed when posting document
    /// </summary>
    /// <param name="_printTransportInvoice">
    /// Should transport invoice be printed when posting document
    /// </param>
    /// <returns>
    /// If true, transport invoice must be printed when posting document
    /// </returns>
    public boolean printTransportInvoice_RU(boolean _printTransportInvoice = contract.parmPrintTransportInvoice_RU())
    {
        return contract.parmPrintTransportInvoice_RU(_printTransportInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>proforma</Name>
				<Source><![CDATA[
    public boolean proforma()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeNow</Name>
				<Source><![CDATA[
    boolean  reArrangeNow(boolean  _reArrangeNow = reArrangeNow)
    {
        reArrangeNow = _reArrangeNow;
        return reArrangeNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetParmListCommonCS</Name>
				<Source><![CDATA[
    public void resetParmListCommonCS()
    {
        contract.parmNumber('');
        contract.parmVoucher('');
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        super();
        formletterOutputContract = this.operationReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournal</Name>
				<Source><![CDATA[
    public void selectFromJournal(container _packedTmpFrmVirtualList)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournalLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates document lines that are based on the specified records.
    /// </summary>
    /// <param name="_packedRecordList">
    ///    A packed set of records which describes how the document lines should be updated.
    /// </param>
    public void selectFromJournalLines(container _packedRecordList)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewContract</Name>
				<Source><![CDATA[
    protected void setNewContract(FormLetterContract _contract)
    {
        if (!contractIsFromPreviousVersion && _contract)
        {
            contract = _contract;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNumAndVoucher</Name>
				<Source><![CDATA[
    void  setNumAndVoucher(Num      _number,
                           Voucher  _voucher)
    {
        contract.parmNumber(_number);
        contract.parmVoucher(_voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryForm</Name>
				<Source><![CDATA[
    public boolean  showQueryForm(boolean  _showQueryForm = contract.parmShowQueryForm())
    {
        return contract.parmShowQueryForm(_showQueryForm);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    public TransDate transDate(TransDate  _transDate = contract.parmTransDate())
    {
        if (!_transDate)
        {
            _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }

        return contract.parmTransDate(_transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackFormletterParmDataOutputContract</Name>
				<Source><![CDATA[
    protected FormLetterParmDataOutputContract unpackFormletterParmDataOutputContract(container _outputContract)
    {
        FormLetterParmDataOutputContract formLetterParmDataOutputContract = FormLetterParmDataOutputContract::construct();

        formLetterParmDataOutputContract.unpack(_outputContract);

        return formLetterParmDataOutputContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrinterSettingsFormLetter</Name>
				<Source><![CDATA[
    void updatePrinterSettingsFormLetter(container   _printerSettings, PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        if (_originalCopy == PrintSetupOriginalCopy::Copy)
        {
            contract.parmPrintersettingsFormletterCopy(SysOperationHelper::base64Encode(_printerSettings));
        }
        else
        {
            contract.parmPrintersettingsFormletter(SysOperationHelper::base64Encode(_printerSettings));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrintManagementExtensionsSettings</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Sets given value to settings for print managements extensions.
    /// </summary>
    /// <param name = "_settings">Packed settings.</param>
    public void updatePrintManagementExtensionsSettings(container _settings)
    {
        contract.parmPrintManagementExtensionsSettings(SysOperationHelper::base64Encode(_settings));
    }

]]></Source>
			</Method>
			<Method>
				<Name>usePrintManagement</Name>
				<Source><![CDATA[
    boolean  usePrintManagement(boolean _usePrintManagement = contract.parmUsePrintManagement())
    {
        return contract.parmUsePrintManagement(_usePrintManagement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates whether it is okay to continue.
    /// </summary>
    /// <param name="_calledFrom">
    ///    Identifies the object from which this method is called.
    /// </param>
    /// <returns>
    ///    true if it is okay to continue; otherwise, false.
    /// </returns>
    boolean validate(Object _calledFrom = null)
    {
        return this.checkPrinterSettingsMultiThread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAll</Name>
				<Source><![CDATA[
    boolean  validateAll(boolean  _validateAll = validateAll)
    {
        validateAll = _validateAll;
        return validateAll;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMenuItemProforma</Name>
				<Source><![CDATA[
    static public boolean isMenuItemProforma(str _menuItemName)
    {
        const str proforma = 'Proforma';
        return strScan(_menuItemName, proforma, 0, strLen(_menuItemName));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newClientArgs</Name>
				<Source><![CDATA[
    static Args  newClientArgs(str _formName, FormLetterServiceController _formLetter)
    {
        Args  args = new  Args();
        args.name(_formName);
        args.caller(_formLetter);
        return args;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>FormLetterServiceController</c> based on the passed <c>FormLetterContract</c>.
    /// </summary>
    /// <param name = "_formLetterContract">
    /// The <c>FormLetterContract</c> instance.
    /// </param>
    /// <returns>
    /// A <c>FormLetterServiceController</c> instance.
    /// </returns>
    public static FormLetterServiceController newFromContract(FormLetterContract _formLetterContract)
    {
        FormLetterServiceController serviceController = FormLetterServiceController::formLetterServiceController(_formLetterContract);
        if (!serviceController)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }
        serviceController.setNewContract(_formLetterContract);
        return serviceController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formLetterServiceController</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an instance of <c>FormLetterServiceController</c> based on the passed <c>FormLetterContract</c>.
    /// </summary>
    /// <param name = "_formLetterContract">
    /// The <c>FormLetterContract</c> instance.
    /// </param>
    /// <returns>
    /// <c>FormLetterServiceController</c> instance.
    /// </returns>
    protected static FormLetterServiceController formLetterServiceController(FormLetterContract _formLetterContract)
    {
        FormLetterServiceController serviceController;
        switch (_formLetterContract.getFormLetterType())
        {
            case FormletterType::Sales :
                serviceController = SalesFormLetter::construct(_formLetterContract.getDocumentStatus());
                break;

            case FormletterType::Purchase :
                serviceController = PurchFormLetter::construct(_formLetterContract.getDocumentStatus());
                break;
        }
        return serviceController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packDataContractObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a container after packing the specified <c>FormLetterContract</c> object.
    /// </summary>
    /// <param name="_formLetterContract">
    /// An instance of the <c>FormLetterContract</c> class.
    /// </param>
    /// <returns>
    /// A <c>container</c> that contains the packed instance of the <c>FormLetterContract</c> class.
    /// </returns>
    public static container packDataContractObject(FormLetterContract _formLetterContract)
    {
        return _formLetterContract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parseServiceInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gest the service information from the specified <c>Args</c> object.
    /// </summary>
    /// <param name="_args">
    /// An instance of the <c>Args</c> class.
    /// </param>
    /// <returns>
    /// A <c>container</c> that contains the service information.
    /// </returns>
    static public container parseServiceInfo(Args _args)
    {
        container serviceInfo = SysOperationServiceController::parseServiceInfo(_args);
        if (serviceInfo == conNull())
        {
            serviceInfo = ['','',0];
        }
        return serviceInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reFreshCallerDataSource</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Refreshes the calling form data source.
    /// </summary>
    /// <param name="_callerFormDataSource">
    ///    The calling form data source.
    /// </param>
    /// <param name="_recordExists">
    ///    A Boolean value that indicates whether the updated record exists in the form data source.
    /// </param>
    /// <param name="_doReSearch">
    ///    A Boolean value that indicates whether <c>reSearch</c> parameter must executed on the form data
    ///    source.
    /// </param>
    /// <remarks>
    ///    This method set to client static to be run on the client to minimize the interaction between tiers.
    /// </remarks>
    protected static void reFreshCallerDataSource(Object          _callerFormDataSource,
                                                         boolean         _recordExists,
                                                         boolean         _doReSearch)
    {
        if (_recordExists)
        {
            if (_doReSearch)
            {
                _callerFormDataSource.reSearch();
            }
            else
            {
                _callerFormDataSource.reRead();
                _callerFormDataSource.reFresh();
                if (formDataSourceHasMethod(_callerFormDataSource, identifierStr(reReadLines)))
                {
                    _callerFormDataSource.reReadLines();
                }
                _callerFormDataSource.active();
            }
        }
        else
        {
            _callerFormDataSource.reSearch();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackDataContractObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a <c>FormLetterContract</c> object after unpacking the specified <c>container</c>.
    /// </summary>
    /// <param name="_packedFormletterContract">
    /// A <c>container</c> that contains a packed instance of the <c>FormLetterContract</c> class.
    /// </param>
    /// <param name="_formletterType">
    /// The <c>FormletterType</c> enumeration value based on the type of contract to initialize.
    /// </param>
    /// <returns>
    /// An instance of the <c>FormLetterContract</c> class.
    /// </returns>
    public static FormLetterContract unpackDataContractObject(container _packedFormletterContract, FormletterType _formletterType)
    {
        if (_packedFormletterContract == conNull())
        {
            return null;
        }
        else
        {
            return FormLetterContract::newFromPackedVersion(_packedFormletterContract, _formletterType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printExciseFormLetter_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Should excise be printed when posting document
    /// </summary>
    /// <param name="_printExciseFormLetter_IN">
    /// The value to be set
    /// </param>
    /// <returns>
    /// Returns true if it is of excise printed, otherwise false
    /// </returns>
    boolean printExciseFormLetter_IN(boolean _printExciseFormLetter_IN = contract.parmPrintExciseFormletter_IN())
    {
        return contract.parmPrintExciseFormletter_IN(_printExciseFormLetter_IN);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printExciseInvoiceAddress_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the printExciseInvoiceAddress_IN parameter.
    /// </summary>
    /// <param name="_exciseInvoiceAddress_IN">
    /// The value to be set
    /// </param>
    /// <returns>
    /// The value of the printExciseInvoiceAddress_IN parameter.
    /// </returns>
    ExciseInvoiceAddressType_IN printExciseInvoiceAddress_IN(ExciseInvoiceAddressType_IN _exciseInvoiceAddress_IN = contract.parmExciseInvoiceAddress_IN())
    {
        return contract.parmExciseInvoiceAddress_IN(_exciseInvoiceAddress_IN);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies, that an operation supports running in a different, non interactive
    /// session than the one from which it was launched from the client
    /// </summary>
    /// <returns>true, if an operation can be run synchrnously in an non GUI async session; otherwsie - false</returns>
    protected boolean checkRunInNewSession()
    {
        boolean isPrinting = this.getContract().isPrinting();

        return !isPrinting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the specified packed map of data source records into a packed list.
    /// </summary>
    /// <param name = "_dataSourceRecordsPacked">The packed map to be converted.</param>
    /// <returns>The packed list of data source records.</returns>
    protected container datasourceRecordList(container _dataSourceRecordsPacked)
    {
        List list = new List(Types::Record);

        MapEnumerator mapEnumerator = Map::create(_dataSourceRecordsPacked).getEnumerator();

        while (mapEnumerator.moveNext())
        {
            list.addEnd(mapEnumerator.currentValue());
        }

        return list.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>needValidateLineName_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether validating the length of the transaction line name is needed during posting sales packing slip, 
    /// sales invoicing, purchase receiving and purchase invoicing.
    /// </summary>
    /// <returns>
    /// true if the validation is needed; otherwise false.
    /// </returns>
    protected boolean needValidateLineName_PL()
    {
        #ISOCountryRegionCodes

        return (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL])
            && PurchSalesTransNameValidation_PLFlight::instance().isEnabled()
            && TaxParameters::find().SAFTInventoryERFormatMapping_PL != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOpenedWithArgs</Name>
				<Source><![CDATA[
    protected internal boolean parmOpenedWithArgs(boolean _openedWithArgs = openedWithArgs)
    {
        openedWithArgs = _openedWithArgs;
        return openedWithArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHistoryReadOnly</Name>
				<Source><![CDATA[
    protected internal boolean parmHistoryReadOnly(boolean _historyReadOnly = historyReadOnly)
    {
        historyReadOnly = _historyReadOnly;
        return historyReadOnly;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>