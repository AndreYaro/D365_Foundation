<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesInvoiceDPBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SalesInvoiceDPBase</c> class provides base implementation of a data provider class for
/// invoice reports.
/// </summary>
public abstract class SalesInvoiceDPBase extends SrsReportDataProviderPreProcess
{
    List lineHeaderPrintedList;
    LineHeader lineHeader;
    CustInvoiceJour custInvoiceJour;
    RecId formLetterRecId;
    PrintCopyOriginal printCopyOriginal;
    CompanyInfo companyInfo;
    CustFormletterParameters custFormLetterParameters;
    CustFormletterDocument custFormLetterDocument;
    CustParameters custParameters;
    Bitmap companyLogo;
    boolean cashDiscOnInvoice;
    boolean isSummaryUpdated;
    Notes correctedInvoiceId;
    CustVendCorrectiveReason correctiveReason_header;
    CustVendCorrectiveReason correctiveReason_lines;
    AmountMST originalInvoiceAmount;
    AmountMST originalInvoiceVATAmount;
    str originalInvoiceIds;
    BankAccountTable companyBankAccountTable;
    boolean isTaxAmountMSTVisible;
    TaxCode taxCode;
    MarkupValue markupValue;
    MarkupCode markupCode;
    // <GEELV>
    RNumDateInWordConverter rNumDateInWordConverter;
    // </GEELV>
    // <GEEHU>
    EcoResCategoryCommodityCode intrastatCode;
    // </GEEHU>
    // <GEEPL>
    LineAmount previousRunningTotal;
    // </GEEPL>
    // <GEEHU>
    TaxRegulationAmountCur totalExcludedTaxAmount;
    // </GEELT>
    // <GTH>
    boolean isSalesInvoiceDP;
    boolean isTaxInvoice;
    boolean isUnrealizedVATEnabled;
    ItemType itemType;
    TaxUnrealizedDocuPrintHeader documentPrintHeader;
    // </GTH>
    // <GEECZ>
    InvoiceId originalInvoiceId_CZ;
    // </GEECZ>
    // <GMY>
    boolean isGSTInvoice;
    ReasonCode debitCreditNoteReasonCode_MY;
    TaxGSTReliefGroupRecId_MY reliefGroupRecId;
    // </GMY>
    CustDirectDebitMandate custDirectDebitMandate;
    CustBankAccount custDirectDebitMandateBankAccount;

    //SalesInvoiceHeaderFooterTmp/FreeTextInvoiceHeaderFooterTmp
    HcmWorkerName cachedSalesAdministratorName;
    Phone cachedSalesAdministratorPhone;
    Email cachedSalesAdministratorEmail;
    DirPartyName cachedCompanyInfoName;
    Addressing cachedCompanyInfoAddress;
    Phone cachedCompanyInfoPhone;
    TeleFax cachedCompanyInfoTeleFax;
    CustName cachedInvoicingName;
    LogisticsAddressing cachedInvoicingAddress;
    ContactPersonName cachedContactPersonName;
    TaxPackagingLicenseNum cachedTaxLicenseNum;
    PaymTxt cachedPaymentCondition;

    //SalesInvoiceTmp/FreeTextInvoiceTmp
    NoYes cachedPrintEuroTotals;
    AmountCur cachedPrepaidAmount;
    AmountCur cachedPrepaidAmountEuro;
    AmountCur cachedInvoiceAmountEuro;
    AmountCur cachedRemainAmountToBePaidEuro;
    AmountCur cachedSalesBalanceEuro;
    SalesEndDiscAmount cachedEndDiscEuro;
    MarkupSumSales cachedSumMarkupEuro;
    TaxAmountCur cachedSumTaxEuro;
    RoundOff cachedInvoiceRoundOffEuro;
    AmountCurNet cachedNetAmount;
    AmountCurNet cachedNetAmountEuro;
    ExchRate cachedExchRate;
    Notes cachedHeaderNotes;
    CashDiscFreeTxt cachedCashDiscTxt_LanguageId;
    TaxTaxableAmountCur cachedTaxableBalanceEuro;
    TaxTaxFreeAmountCur cachedTaxFreeBalanceEuro;
    TaxTaxableAmountCur cachedTaxableBalance;
    TaxTaxFreeAmountCur cachedTaxFreeBalance;
    CustCashDiscAmount cachedCashDiscEuro;

    //localization tables
    TaxTaxFreeAmountCur cachedTaxFreeBalanceMST;
    TaxTaxableAmountCur cachedTaxableBalanceMST;
    ExchRate cachedEuroExchangeRate;
    AmountMSTNet cachedNetAmountMST;

    // <GEEU>
    LogisticsAddressCountryRegionISOCode isoCountryCode = SysCountryRegionCode::countryInfo();
    // </GEEU>

    protected KittingSrsReportDataProviderPreProcess kittingReportHandler;

    internal Amount settledAmountCur;

    #ISOCountryRegionCodes
    #EECountryRegionCodes
    #define.emptyString('')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTmpTaxWorkFromInvoiceJour_CZ</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>TmpTaxWorkTrans</c> from the <c>CustInvoiceJour</c> by lines
    /// </summary>
    /// <param name="_tmpTaxWorkTrans">
    /// The buffer in which records will be created
    /// </param>
    /// <param name="_custInvoiceJour">
    /// The invoice according to which records will be created
    /// </param>
    protected void addTmpTaxWorkFromInvoiceJour_CZ(
        TmpTaxWorkTrans _tmpTaxWorkTrans,
        custInvoiceJour _custInvoiceJour)
    {
        CustInvoiceTrans custInvoiceTransTax;
        CustInvoiceTrans custInvoiceTransTaxOrig;
        CustInvoiceTrans_W custInvoiceTransTax_W;

        void initTmpTaxWorkTrans(CustInvoiceTrans _custInvoiceTrans)
        {
            TmpTaxWorkTrans tmpTaxWork;
            Tax tax = Tax::construct();

            tax.taxCalcWithoutSource(_custInvoiceTrans.TaxGroup,
                                        _custInvoiceTrans.TaxItemGroup,
                                        _custInvoiceTrans.InvoiceDate,
                                        _custInvoiceTrans.CurrencyCode,
                                        -_custInvoiceTrans.LineAmount,
                                        TaxModuleType::Sales,
                                        0,
                                        '',
                                        '',
                                        TaxDirection::OutgoingTax);
            tmpTaxWork = tax.tmpTaxWorkTrans();

            while select tmpTaxWork
            {
                _tmpTaxWorkTrans.data(tmpTaxWork);
                _tmpTaxWorkTrans.Voucher = _custInvoiceJour.LedgerVoucher;
                _tmpTaxWorkTrans.TransDate = _custInvoiceJour.InvoiceDate;
                _tmpTaxWorkTrans.HeadingTableId = _custInvoiceJour.TableId;
                _tmpTaxWorkTrans.HeadingRecId = _custInvoiceJour.RecId;
                _tmpTaxWorkTrans.InvoiceRecId = _tmpTaxWorkTrans.HeadingRecId;

                _tmpTaxWorkTrans.SourceRecId = _custInvoiceTrans.RecId;
                _tmpTaxWorkTrans.InvoiceId = _custInvoiceTrans.InvoiceId;
                _tmpTaxWorkTrans.insert();
            }
        }

        while select custInvoiceTransTax
            where custInvoiceTransTax.SalesId == _custInvoiceJour.SalesId
                && custInvoiceTransTax.InvoiceId == _custInvoiceJour.InvoiceId
                && custInvoiceTransTax.InvoiceDate == _custInvoiceJour.InvoiceDate
                && custInvoiceTransTax.NumberSequenceGroup == _custInvoiceJour.NumberSequenceGroup
            join RefReturnInvoiceTrans_W from custInvoiceTransTax_W
                where custInvoiceTransTax_W.CustInvoiceTrans == custInvoiceTransTax.RecId
            outer join custInvoiceTransTaxOrig
                where custInvoiceTransTaxOrig.RecId == custInvoiceTransTax_W.RefReturnInvoiceTrans_W
        {
            initTmpTaxWorkTrans(custInvoiceTransTax);

            if (custInvoiceTransTaxOrig)
            {
                initTmpTaxWorkTrans(custInvoiceTransTaxOrig);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTmpTaxWorkTransFromMarkupTrans</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void initTmpTaxWorkTransFromMarkupTrans(TmpTaxWorkTrans _tmpTaxWorkTrans, CustInvoiceJour _custInvoiceJour, MarkupTrans _markupTrans)
    {
        TmpTaxWorkTrans tmpTaxWork;
        Tax tax = Tax::construct();

        tax.taxCalcWithoutSource(_markupTrans.TaxGroup,
                                _markupTrans.TaxItemGroup,
                                _custInvoiceJour.InvoiceDate,
                                _markupTrans.CurrencyCode,
                                -_markupTrans.Value,
                                TaxModuleType::Sales,
                                0,
                                '',
                                '',
                                TaxDirection::OutgoingTax);

        tmpTaxWork = tax.tmpTaxWorkTrans();

        while select tmpTaxWork
        {
            _tmpTaxWorkTrans.data(tmpTaxWork);
            _tmpTaxWorkTrans.Voucher = _custInvoiceJour.LedgerVoucher;
            _tmpTaxWorkTrans.TransDate = _custInvoiceJour.InvoiceDate;
            _tmpTaxWorkTrans.HeadingTableId = _custInvoiceJour.TableId;
            _tmpTaxWorkTrans.HeadingRecId = _custInvoiceJour.RecId;
            _tmpTaxWorkTrans.InvoiceRecId = _tmpTaxWorkTrans.HeadingRecId;

            _tmpTaxWorkTrans.SourceTableId = _markupTrans.TableId;
            _tmpTaxWorkTrans.SourceRecId = _markupTrans.RecId;
            _tmpTaxWorkTrans.InvoiceId = _custInvoiceJour.InvoiceId;
            _tmpTaxWorkTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTmpTaxWorkFromChargesProforma_CZ</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void addTmpTaxWorkFromChargesProforma_CZ(TmpTaxWorkTrans _tmpTaxWorkTrans, CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTmpTaxWorkFromCharges_CZ</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void addTmpTaxWorkFromCharges_CZ(TmpTaxWorkTrans _tmpTaxWorkTrans, CustInvoiceJour _custInvoiceJour)
    {
        if (_custInvoiceJour.isProforma())
        {
            this.addTmpTaxWorkFromChargesProforma_CZ(_tmpTaxWorkTrans, _custInvoiceJour);
        }
        else
        {
            MarkupTrans custInvoiceJourMarkupTrans;
            while select custInvoiceJourMarkupTrans
                where custInvoiceJourMarkupTrans.TransTableId == tableNum(CustInvoiceJour)
                    && custInvoiceJourMarkupTrans.TransRecId == _custInvoiceJour.RecId
            {
                this.initTmpTaxWorkTransFromMarkupTrans(_tmpTaxWorkTrans, _custInvoiceJour, custInvoiceJourMarkupTrans);
            }
      
            MarkupTrans custInvoiceTransMarkupTrans;
            CustInvoiceTrans custInvoiceTransTax;
            while select custInvoiceTransMarkupTrans
                exists join custInvoiceTransTax
                where custInvoiceTransMarkupTrans.TransTableId == tableNum(CustInvoiceTrans)
                    && custInvoiceTransMarkupTrans.TransRecId == custInvoiceTransTax.RecId
                    && custInvoiceTransTax.SalesId == _custInvoiceJour.SalesId
                    && custInvoiceTransTax.InvoiceId == _custInvoiceJour.InvoiceId
                    && custInvoiceTransTax.InvoiceDate == _custInvoiceJour.InvoiceDate
                    && custInvoiceTransTax.NumberSequenceGroup == _custInvoiceJour.NumberSequenceGroup
            {
                this.initTmpTaxWorkTransFromMarkupTrans(_tmpTaxWorkTrans, _custInvoiceJour, custInvoiceTransMarkupTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotalExcludedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of all <c>TaxTrans</c> records for the specified sales invoice record that
    /// have been excluded from the invoice.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The voucher number of the sales invoice.
    /// </param>
    private void calculateTotalExcludedTaxAmount(Voucher _ledgerVoucher)
    {
        TaxTrans taxTrans;
        TaxTransExcludeFromInvoice taxTransExcludeFromInvoice;

        select sum(SourceRegulateAmountCur) from taxTrans
            where taxTrans.Voucher == _ledgerVoucher &&
                  taxTrans.SourceTableId == tableNum(CustInvoiceTrans)
            exists join taxTransExcludeFromInvoice
                where taxTransExcludeFromInvoice.TaxTrans == taxTrans.RecId;

        totalExcludedTaxAmount = -taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrintLineHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the line summary if the invoice has been summarized during posting.
    /// </summary>
    /// <param name="_custInvoiceTrans">
    /// The <c>CustInoviceTrans</c> record.
    /// </param>
    /// <param name="_isSummaryUpdated">
    /// true if the invoice is summarized; otherwise, false.
    /// </param>
    protected void checkPrintLineHeader(CustInvoiceTrans _custInvoiceTrans, boolean _isSummaryUpdated)
    {
        if (!_isSummaryUpdated)
        {
            return;
        }

        lineHeader = _custInvoiceTrans.LineHeader;

        if (!lineHeaderPrintedList)
        {
            lineHeaderPrintedList = new List(Types::String);
        }

        ListEnumerator enumerator = lineHeaderPrintedList.getEnumerator();

        while (enumerator.moveNext())
        {
            str currentLineHeader = enumerator.current();
            if (currentLineHeader == _custInvoiceTrans.LineHeader)
            {
                break;
            }
            else if (currentLineHeader == subStr(_custInvoiceTrans.LineHeader, 1, strLen(currentLineHeader)))
            {
                lineHeader = strLTrim(subStr(_custInvoiceTrans.LineHeader, strLen(currentLineHeader) + 1, strLen(_custInvoiceTrans.LineHeader)));
            }
        }

        if (lineHeader)
        {
            lineHeaderPrintedList.addEnd(_custInvoiceTrans.LineHeader);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustInvoiceTransQueryRun</Name>
				<Source><![CDATA[
    protected QueryRun getCustInvoiceTransQueryRun()
    {
        return new TradeLoopTrans(custInvoiceJour, tableNum(CustInvoiceTrans)).buildQueryRun();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustInvoiceTransRecords</Name>
				<Source><![CDATA[
    protected void processCustInvoiceTransRecords(QueryRun _tradeLoopTrans)
    {
        // Process CustInvoiceTrans records.
        while (_tradeLoopTrans.next())
        {
            CustInvoiceTrans custInvoiceTrans = _tradeLoopTrans.get(tableNum(CustInvoiceTrans));

            if (this.canProcessRecord(custInvoiceTrans))
            {
                this.processRecord(custInvoiceJour, custInvoiceTrans);

                if (MarkupPeriodChargeFeature::instance().isEnabled())
                {
                    this.insertPeriodCharge(custInvoiceJour, custInvoiceTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProcessRecord</Name>
				<Source><![CDATA[
    protected boolean canProcessRecord(CustInvoiceTrans _custInvoiceTrans)
    {
        boolean canProcessRecord = true;
        // <GTH>
        if (isUnrealizedVATEnabled 
            && isSalesInvoiceDP 
            && documentPrintHeader
            && (itemType == ItemType::Item || itemType == ItemType::Service)
            && InventTable::find(_custInvoiceTrans.ItemId).ItemType != itemType)
        {
            canProcessRecord = false;
        }
        // </GTH>

        return canProcessRecord;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs <c>CustInvoiceTrans</c> record processing to add printable line.
    /// </summary>
    /// <param name = "_custInvoiceJour">The <c>CustInvoiceJour</c> to print invoice for.</param>
    /// <param name = "_custInvoiceTrans">The <c>CustInvoiceTrans</c> record to be processed.</param>
    protected void processRecord(CustInvoiceJour _custInvoiceJour, CustInvoiceTrans _custInvoiceTrans)
    {
        // <GEEHU>
        if (isoCountryCode == #isoHU)
        {
            intrastatCode = EcoResCategory::commodityCode(_custInvoiceTrans.IntrastatCommodity);
        }
        // </GEEHU>

        // Reset this flag to false so that the inventory dimensions like size, color etc are not
        // always visible in the report.
        boolean isInventDimVisible = false;

        // Italian feature
        if (this.isCreditInvoicingReportEnabled(_custInvoiceJour))
        {
            this.creditInvoicingLines(_custInvoiceTrans);
        }

        this.checkPrintLineHeader(_custInvoiceTrans, isSummaryUpdated);

        // Generate other information related to Sales invoice lines.
        boolean isRowInserted = this.generateInvoiceLinesRelatedInformation(_custInvoiceJour, _custInvoiceTrans);

        if (!isRowInserted)
        {
            // Insert the invoice line information .
            this.insertInvoiceDetailsInformation(_custInvoiceJour, _custInvoiceTrans, null, null, null);
        }

        // <GEEPL>
        if (isoCountryCode == #isoPL)
        {
            previousRunningTotal += _custInvoiceTrans.LineAmount + _custInvoiceTrans.TaxAmount;
        }

        this.insertCreditNoteSummaryLine_PL(_custInvoiceJour, _custInvoiceTrans);
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates data for the report.
    /// </summary>
    public void createData()
    {
        this.getDataFromContract();
        this.init(custInvoiceJour);

        if (isoCountryCode == #isoSG && CompanyInfoHelper::standardCurrency() != custInvoiceJour.CurrencyCode)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceSG00002, funcName());
        }

        this.insertInvoiceHeaderInformation(custInvoiceJour, companyInfo);
        
        QueryRun tradeLoopTrans = this.getCustInvoiceTransQueryRun();

        if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
        {
            kittingReportHandler = new KittingSrsReportDataProviderPreProcess();
            tradeLoopTrans = kittingReportHandler.kittingGetQueryRun(tradeLoopTrans, tableNum(CustInvoiceJour));
        }

        if (tradeLoopTrans.query().dataSourceTable(tableNum(CustInvoiceTrans)))
        {
            tradeLoopTrans.query().dataSourceTable(tableNum(CustInvoiceTrans)).addSortField(fieldNum(CustInvoiceTrans, OrigSalesId));
            tradeLoopTrans.query().dataSourceTable(tableNum(CustInvoiceTrans)).addSortField(fieldNum(CustInvoiceTrans, LineNum));
        }

        this.processCustInvoiceTransRecords(tradeLoopTrans);

        if (isoCountryCode == #isoFI)
        {
            this.insertMarkupSpec(custInvoiceJour);
        }

        if (this.taxSpecPrintLevel() == TaxSpecPrintLevel::None && (isoCountryCode == #isoLT || isoCountryCode == #isoHU)
               || this.taxSpecPrintLevel() != TaxSpecPrintLevel::None)
        {
            this.insertTaxes(custInvoiceJour);
        }

        this.insertPaymentSchedule(custInvoiceJour);

        if (cachedPrepaidAmount)
        {
            if (custInvoiceJour.isProforma())
            {
                this.printPrepaymentProforma(custInvoiceJour);
            }
            else
            {
                this.printPrepayment(custInvoiceJour);
            }
        }

        // Generates any other data related to the invoice.
        this.generateInvoiceRelatedInformation(custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditInvoicingHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the information about credit invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record.
    /// </param>
    protected void creditInvoicingHeader(CustInvoiceJour _custInvoiceJour)
    {
        CustInvoiceJour localCustInvoiceJour;
        CustInvoiceTable localCustInvoiceTable;

        CustVendCreditInvoicingJour custVendCreditInvoicingJour = CustVendCreditInvoicingJour::findInvoiceId(_custInvoiceJour.TableId, _custInvoiceJour.RecId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL, #isoTH]))
        {
            correctedInvoiceId = custVendCreditInvoicingJour.CustVendCorrectedInvoiceId;
            correctiveReason_header = custVendCreditInvoicingJour.CustVendCorrectiveReason;

            select InvoiceAmount, SumTaxMST, TableId, RecId from localCustInvoiceJour
                where localCustInvoiceJour.RecId == custVendCreditInvoicingJour.CorrectedInvoiceRecId;

            originalInvoiceAmount = localCustInvoiceJour.InvoiceAmount;
            originalInvoiceVATAmount = localCustInvoiceJour.SumTaxMST;
        }
        else
        {
            if (_custInvoiceJour.isProforma())
            {
                // When printing a proforma Free Text Invoice ID, the custInvoiceJour.InvoiceId is a concatenation of # and the custInvoiceJour.RecId
                // see FreeTextInvoiceController.invoiceId2RecID()
                select firstOnly RecId from localCustInvoiceTable
                    where localCustInvoiceTable.RecId == str2int64(subStr(_custInvoiceJour.InvoiceId, 2, strLen(_custInvoiceJour.InvoiceId)));
            }

            if (localCustInvoiceTable)
            {
                CustVendCreditInvoicingTable custVendCreditInvoicingTable = custVendCreditInvoicingTable::find(localCustInvoiceTable.TableId, localCustInvoiceTable.RecId);
                correctedInvoiceId = strFmt("@SYS26868", custVendCreditInvoicingTable.CustVendCorrectedInvoiceId,
                    custVendCreditInvoicingTable.CustVendCorrectedInvoiceDate);
                correctiveReason_header = ReasonTableRef::find(custVendCreditInvoicingTable.ReasonRefRecID).ReasonComment;
            }
            else
            {
                correctedInvoiceId = custVendCreditInvoicingJour.CustVendCorrectedInvoicesInfo
                    ? custVendCreditInvoicingJour.CustVendCorrectedInvoicesInfo
                    : strFmt("@SYS26868", custVendCreditInvoicingJour.CustVendCorrectedInvoiceId, custVendCreditInvoicingJour.CustVendCorrectedInvoiceDate);

                correctiveReason_header = ReasonTableRef::find(custVendCreditInvoicingJour.ReasonRefRecID).ReasonComment;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditInvoicingLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the corrective reason for the invoice line.
    /// </summary>
    /// <param name="_custInvoiceTrans">
    /// The <c>CustInvoiceTrans</c> record.
    /// </param>
    protected void creditInvoicingLines(CustInvoiceTrans _custInvoiceTrans)
    {
        correctiveReason_lines = CustVendCreditInvoicingTrans::findTransId(_custInvoiceTrans.TableId,
                                    _custInvoiceTrans.RecId).CustVendCorrectiveReason;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateInvoiceLinesRelatedInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates additional information related to invoice line.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The record of the <c>CustInvoiceJour</c> table.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// The record of the <c>CustInvoiceTrans</c> table.
    /// </param>
    /// <returns>
    /// true if invoice line information have been inserted along with other related data; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method will be overridden in the sub class to generate any additional information needed for
    /// <c>CustInvoiceTrans</c> record, such as customer packing slips, inventory dimensions for sales
    /// invoice and any other custom data.
    /// </remarks>
    protected boolean generateInvoiceLinesRelatedInformation(CustInvoiceJour _custInvoiceJour, CustInvoiceTrans _custInvoiceTrans)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateInvoiceRelatedInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates additional information related to the invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The record of <c>CustInvoiceJour</c> table.
    /// </param>
    /// <remarks>
    /// This method will be overridden in the sub class to generate any additional information needed for <c>CustInvoiceJour</c> record,
    /// such as packaging material weight and any other custom data
    /// </remarks>
    protected void generateInvoiceRelatedInformation(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the currency exchange rate of the accounting currency.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record that contains the invoice information.
    /// </param>
    /// <returns>
    /// An exchange rate that can be displayed to the user.
    /// </returns>
    protected CurrencyExchangeRate getAccountingExchangeRate(CustInvoiceJour _custInvoiceJour)
    {
        CurrencyExchangeRate currentTransactionCurrencyExchangeRate = ExchangeRateHelper::getCrossRate_Static(
            Ledger::current(),
            _custInvoiceJour.CurrencyCode,
            _custInvoiceJour.InvoiceDate);

        return CurrencyEuroDenomination::displayStoredExchangeRate_Static(currentTransactionCurrencyExchangeRate, ExchangeRateDisplayFactor::One);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDataFromContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes data from the contract class.
    /// </summary>
    abstract void getDataFromContract()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the note that has been attached to the invoice.
    /// </summary>
    /// <param name="_common">
    /// A <c>Common</c> record that either contains the header information or line information.
    /// </param>
    /// <param name="_custFormLetterDocument">
    /// The <c>CustFormLetterDocument</c> record.
    /// </param>
    /// <returns>
    /// The note that has been attached to the invoice.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// If the <c>common</c> record is not a <c>CustInvoiceJour</c> record or <c>CustInvoiceTrans</c>
    /// record.
    /// </exception>
    public Notes getDocumentNote(Common _common, CustFormLetterDocument _custFormLetterDocument)
    {
        Notes notes;
        var docuOnFormular = this.getDocuOnFormular(_common);

        if (_custFormLetterDocument.DocuOnInvoice == docuOnFormular ||
            _custFormLetterDocument.DocuOnInvoice == DocuOnFormular::All)
        {
            var docuRefSearch = DocuRefSearch::newTypeIdAndRestriction(_common,
                                                                       _custFormLetterDocument.DocuTypeInvoice,
                                                                       DocuRestriction::External);
            notes = Docu::concatDocuRefNotes(docuRefSearch);
        }

        return notes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocuOnFormular</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>DocuOnFormular</c> value that is associated with the given <c>Common</c> record.
    /// </summary>
    /// <param name = "_common">
    /// A <c>Common</c> record for which to determine the <c>DocuOnFormular</c> value.
    /// </param>
    /// <returns>
    /// The <c>DocuOnFormular</c> value for the specified <c>Common</c> record.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// If the <c>Common</c> record is not a <c>CustInvoiceJour</c> record or <c>CustInvoiceTrans</c> record.
    /// </exception>
    protected DocuOnFormular getDocuOnFormular(Common _common)
    {
        switch (_common.TableId)
        {
            case tableNum(CustInvoiceJour):
            case tableNum(SalesTable):
                return DocuOnFormular::Head;

            case tableNum(CustInvoiceTrans):
            case tableNum(SalesLine):
                return DocuOnFormular::Line;

            default:
                // Exit the method if the record is not CustInvoiceJour or CustInvoiceTrans.
                throw error(Error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEuroExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the currency exchange rate of the EURO currency.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record that contains the invoice information.
    /// </param>
    /// <returns>
    /// An exchange rate that can be displayed to the user.
    /// </returns>
    protected CurrencyExchangeRate getEuroExchangeRate(CustInvoiceJour _custInvoiceJour)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrencyToCurrency(Ledger::accountingCurrency(),
            Currency::findEuroCurrencyCode());

        exchangeRateHelper.parmExchangeDate(_custInvoiceJour.InvoiceDate);
        exchangeRateHelper.parmLedgerRecId(Ledger::current());
        CurrencyExchangeRate currentTransactionCurrencyExchangeRate = exchangeRateHelper.getCrossRate();

        return CurrencyEuroDenomination::displayStoredExchangeRate_Static(currentTransactionCurrencyExchangeRate, 1);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExcludedTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the sum of all <c>TaxTrans</c> records for the specified invoice line record that
    /// have been excluded from the invoice.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The voucher number.
    /// </param>
    /// <param name="_invoiceLine">
    /// The invoice line record.
    /// </param>
    /// <returns>
    /// The total tax amount that was excluded from the invoice.
    /// </returns>
    protected TaxRegulationAmountCur getExcludedTaxAmount(Voucher _ledgerVoucher, CustInvoiceTrans _invoiceLine)
    {
        TaxTrans taxTrans;
        TaxTransExcludeFromInvoice taxTransExcludeFromInvoice;

        select sum(SourceRegulateAmountCur) from taxTrans
            where taxTrans.Voucher == _ledgerVoucher &&
                  taxTrans.SourceTableId == _invoiceLine.TableId &&
                  taxTrans.SourceRecId == _invoiceLine.RecId
            exists join taxTransExcludeFromInvoice
                where taxTransExcludeFromInvoice.TaxTrans == taxTrans.RecId;

        return -taxTrans.SourceRegulateAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLinePKWiU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>PlPKWiUCode</c> value for the <c>CustInvoiceTrans</c> record.
    /// </summary>
    /// <param name="_custInvoiceTrans">
    /// The <c>CustInvoiceTrans</c> record.
    /// </param>
    /// <returns>
    /// The value of the <c>PlPKWiUCode</c>.
    /// </returns>
    protected PlPKWiUCode getInvoiceLinePKWiU(CustInvoiceTrans _custInvoiceTrans)
    {
        CustInvoiceTrans_W custInvoiceTrans_W = _custInvoiceTrans.custInvoiceTrans_W();

        return custInvoiceTrans_W.pkWiUCode_PL ?
            custInvoiceTrans_W.pkWiUCode_PL : InventTable::find(_custInvoiceTrans.ItemId).pkWiUCode_PL;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMarkupCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the markup code from the invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record contains the invoice information.
    /// </param>
    /// <param name="_markupTrans">
    /// A <c>MarkupTrans</c> record contains the markup transaction information related to the invoice.
    /// </param>
    /// <param name="_markupTmpTrans">
    /// A <c>MarkupTmpTrans_FI</c> record that contains the markup transaction information related to the
    /// pro forma.
    /// </param>
    /// <returns>
    /// The <c>MarkupCode</c> value of the markup transaction.
    /// </returns>
    [Wrappable(true)]
    protected final MarkupCode getMarkupCode(CustInvoiceJour _custInvoiceJour, MarkupTrans _markupTrans, MarkupTmpTrans_FI _markupTmpTrans)
    {
        MarkupCode ret;

        if (hasFieldAccess(tableNum(MarkupTrans), fieldNum(MarkupTrans, MarkupCode)))
        {
            if (_custInvoiceJour.isProforma())
            {
                ret = _markupTmpTrans.MarkupCode;
            }
            else
            {
                ret = _markupTrans.MarkupCode;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveMarkUpTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>PrintCode</c> value that relates to the markup record.
    /// </summary>
    /// <param name="_taxCode">
    /// The <c>TaxCode</c> value of the tax transaction record.
    /// </param>
    /// <returns>
    /// The <c>PrintCode</c> value from the tax transaction record if exists; otherwise return the tax code of the markup transaction record.
    /// </returns>
    protected TaxCode retrieveMarkUpTaxCode(TaxCode _taxCode)
    {
        TaxCode ret;

        if (hasTableAccess(tableNum(TaxTable), AccessType::View))
        {
            TaxTable taxTable = TaxTable::find(_taxCode);

            if (taxTable && taxTable.PrintCode)
            {
                ret = taxTable.PrintCode;
            }
            else
            {
                ret = _taxCode;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumDateInWordConverter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an instance of <c>RNumDateInWordConverter</c> class.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>custInvoiceJour</c> that will be used to get the language ID from.
    /// </param>
    /// <returns>
    /// An instance of <c>RNumDateInWordConverter</c> class.
    /// </returns>
    /// <remarks>
    /// Initializes an instance of <c>RNumDateInWordConverter_LV</c> if none is being initalized before; otherwise return
    /// the initialized one. When initializing an instance of the class, a language id from <c>CustInvoiceJour</c> record will be
    /// passed to the instance to convert the numbers and dates to the language of the customer.
    /// </remarks>
    protected RNumDateInWordConverter getNumDateInWordConverter(CustInvoiceJour _custInvoiceJour)
    {
        if (!rNumDateInWordConverter)
        {
            rNumDateInWordConverter = RNumDateInWordConverter::construct(_custInvoiceJour.LanguageId);
        }

        return rNumDateInWordConverter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrepaymentTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the prepayment taxes.
    /// </summary>
    /// <param name="_custTrans">
    /// The <c>CustTrans</c> record.
    /// </param>
    /// <returns>
    /// A container that contains prepayment's taxes in transaction currency and accounting currency.
    /// </returns>
    public container getPrepaymentTaxAmount(CustTrans _custTrans)
    {
        TaxAmountCur taxAmount;
        TaxAmount taxAmountMST;

        TaxSpec prePaymentTaxSpec = TaxSpec::construct(_custTrans.Voucher, _custTrans.TransDate, _custTrans.RecId);

        while (prePaymentTaxSpec.parmTaxSpec(false))
        {
            taxAmount = prePaymentTaxSpec.taxAmount() + taxAmount;
            taxAmountMST = prePaymentTaxSpec.taxAmountMST() + taxAmountMST;
        }

        return [taxAmount, taxAmountMST];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrepaymentCustTransProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>CustTrans</c> record of the prepayment for proforma invoice.
    /// </summary>
    /// <param name = "_record">Source table buffer related to current invoice journal.</param>
    /// <returns><c>CustTrans</c> record of the prepayment.</returns>
    protected CustTrans getPrepaymentCustTransProforma(Common _record)
    {
        CustTrans custTrans;
        return custTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTaxTransactionExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the sales tax exchange rate of the sales invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record of the sales invoice.
    /// </param>
    /// <returns>
    /// A <c>SalesTaxTransactionExchangeRate</c> record that has the sales tax exchange rate information.
    /// </returns>
    protected SalesTaxTransactionExchangeRate getSalesTaxTransactionExchangeRate(CustInvoiceJour _custInvoiceJour)
    {
        return SalesTaxTransactionExchangeRate::findBySourceRecord(_custInvoiceJour.TableId, _custInvoiceJour.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxSpecificExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Tax specific exchange rate of the sales invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record of the sales invoice.
    /// </param>
    /// <returns>
    /// Exchange rate information.
    /// </returns>
    protected CurrencyExchangeRate getTaxSpecificExchangeRate(CustInvoiceJour _custInvoiceJour)
    {
        return TaxSpecificExchangeRate::findBySourceRecord(_custInvoiceJour.TableId, _custInvoiceJour.RecId).ExchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax percentage.
    /// </summary>
    /// <param name="_taxSpec">
    /// An instance of <c>TaxSpec</c> class that contains the tax information.
    /// </param>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains the invoice date.
    /// </param>
    /// <returns>
    /// The tax percentage.
    /// </returns>
    protected TaxValue getTaxValue(TaxSpec _taxSpec, CustInvoiceJour _custInvoiceJour)
    {
        return TaxData::percent(_taxSpec.taxCode(), _custInvoiceJour.InvoiceDate, _taxSpec.taxBaseAmount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>goodsDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the goods discount information related to the sales invoice line.
    /// </summary>
    /// <param name="_custInvoiceTrans">
    /// A <c>CustInvoiceTrans</c> record that has the invoice line information.
    /// </param>
    /// <returns>
    /// true if there is a goods discount; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method will only be used for Italy feature. If country context is Italy and the line amount does not include taxes,
    /// then there should not be discount percentage or amount.
    /// </remarks>
    protected boolean goodsDiscount(CustInvoiceTrans _custInvoiceTrans)
    {
        boolean goodsDiscount;

        if ((isoCountryCode == #isoIT) && !_custInvoiceTrans.lineAmountInclTax())
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00004, funcName());

            _custInvoiceTrans.DiscPercent = 0;
            _custInvoiceTrans.DiscAmount = 0;
            _custInvoiceTrans.TaxWriteCode = "@SYS95975";
            goodsDiscount = true;
        }

        return goodsDiscount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes required data before it starts process the report.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that has the sales invoice header information.
    /// </param>
    /// <remarks>
    /// This method will initialize some variables which will be used during processing the report.
    /// </remarks>
    protected void init(CustInvoiceJour _custInvoiceJour)
    {
        companyInfo = CompanyInfo::find();
        custFormletterParameters = CustFormletterParameters::find();
        custFormletterDocument = CustFormletterDocument::find();
        custParameters = CustParameters::find();

        if (custFormletterParameters.PrePrintLevelInvoice == PrePrintLevel::BlankPaper)
        {
            companyLogo = FormLetter::companyLogo();
        }

        cashDiscOnInvoice = TaxParameters::find().CashDiscOnInvoice;

        isSummaryUpdated = _custInvoiceJour.isSummaryUpdated();

        if (this.isCreditInvoicingReportEnabled(_custInvoiceJour))
        {
            this.creditInvoicingHeader(_custInvoiceJour);
        }

        if (this.taxSpecPrintLevel() != TaxSpecPrintLevel::None)
        {
            // <GEEPL>
            if (isoCountryCode == #isoPL)
            {
                if (_custInvoiceJour.CurrencyCode == Ledger::accountingCurrency(companyInfo.RecId))
                {
                    isTaxAmountMSTVisible = false;
                }
                else
                {
                    isTaxAmountMSTVisible = true;
                }
            }
            else
            {
                // </GEEPL>
                if (this.taxSpecPrintLevel() == TaxSpecPrintLevel::Currency
                    || _custInvoiceJour.CurrencyCode == Ledger::accountingCurrency(companyInfo.RecId))
                {
                    isTaxAmountMSTVisible = false;
                }
                else
                {
                    isTaxAmountMSTVisible = true;
                }
                // <GEEPL>
            }
            // </GEEPL>
        }
        else
        {
            isTaxAmountMSTVisible = false;
        }

        HcmWorker salesAdministrator = HcmWorker::find(_custInvoiceJour.WorkerSalesTaker);

        cachedSalesAdministratorName = salesAdministrator.name();
        cachedSalesAdministratorEmail = salesAdministrator.email();
        cachedSalesAdministratorPhone = salesAdministrator.phone();
        cachedCompanyInfoName = companyInfo.Name;
        cachedCompanyInfoAddress = DirUtility::replaceAddressTokenLanguage(companyInfo.postalAddress(), this.parmCustInvoiceJour().LanguageId);
        cachedCompanyInfoPhone = companyInfo.phone();
        cachedCompanyInfoTeleFax = companyInfo.teleFax();
        cachedInvoicingName = _custInvoiceJour.invoiceName();
        cachedInvoicingAddress = _custInvoiceJour.invoicingAddress();
        cachedContactPersonName = _custInvoiceJour.contactPersonName();
        cachedTaxLicenseNum = _custInvoiceJour.taxLicenseNum();
        cachedPaymentCondition = _custInvoiceJour.paymentCondition();

        cachedPrintEuroTotals = this.printEuroTotals(_custInvoiceJour);
        cachedInvoiceAmountEuro = _custInvoiceJour.invoiceAmountEuro();

        if (_custInvoiceJour.isProforma())
        {
            this.setPrepaidAmountsProforma(_custInvoiceJour);
        }
        else
        {
            cachedPrepaidAmount = _custInvoiceJour.prepaidAmount();
            cachedPrepaidAmountEuro = _custInvoiceJour.prepaidAmountEuro();
        }

        cachedRemainAmountToBePaidEuro = _custInvoiceJour.remainAmountToBePaidEuro();
        cachedSalesBalanceEuro = _custInvoiceJour.salesBalanceEuro();
        cachedEndDiscEuro = _custInvoiceJour.endDiscEuro();
        cachedSumMarkupEuro = _custInvoiceJour.sumMarkupEuro();
        cachedSumTaxEuro = _custInvoiceJour.sumTaxEuro();
        cachedInvoiceRoundOffEuro = _custInvoiceJour.invoiceRoundOffEuro();
        cachedNetAmount = _custInvoiceJour.netAmount();
        cachedNetAmountEuro = _custInvoiceJour.netAmountEuro();
        cachedExchRate = this.getAccountingExchangeRate(_custInvoiceJour);
        cachedHeaderNotes = this.getDocumentNote(_custInvoiceJour, custFormLetterDocument);
        cachedCashDiscTxt_LanguageId = _custInvoiceJour.cashDiscTxt_LanguageId();

        // <GMY>
        if (isoCountryCode == #isoMY)
        {
            if (custInvoiceJour.custInvoiceJour_W().InvoiceType_MY == InvoiceType_MY::GST)
            {
                isGSTInvoice = true;
                debitCreditNoteReasonCode_MY = ReasonTableRef::find(custInvoiceJour.ReasonTableRef).Reason;
                reliefGroupRecId = custInvoiceJour.custTable_InvoiceAccount().TaxGSTReliefGroupHeading_MY;
            }
        }
        // </GMY>

        this.initializeLocalizationData(_custInvoiceJour);

        this.featureRunForPaymentSlip(_custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxSpecPrintLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves tax specification print level value from <c>CustFormletterParameters</c>.
    /// </summary>
    /// <returns>
    /// The tax specification print level value.
    /// </returns>
    protected TaxSpecPrintLevel taxSpecPrintLevel()
    {
        return custFormletterParameters.TaxSpecPrintLevel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>featureRunForPaymentSlip</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Feature execution for different payment slips.
    /// </summary>
    /// <param name = "_custInvoiceJour">
    ///     A <c>CustInvoiceJour</c> buffer.
    /// </param>
    protected void featureRunForPaymentSlip(CustInvoiceJour _custInvoiceJour)
    {
        switch (_custInvoiceJour.GiroType)
        {
            case PaymentStub::ESR_red_bank:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceCH00007, funcName());
                break;
            case PaymentStub::ESR_orange:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceCH00008, funcName());
                break;
            case PaymentStub::FIK751:
            case PaymentStub::FIK752:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceDK00007, funcName());
                break;
            case PaymentStub::BBS:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceNO00004, funcName());
                break;
            case PaymentStub::Finnish:
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceFI00002, funcName());
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initItemTypeByProdType_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes item type according to prod type.
    /// </summary>
    /// <param name="_prodType">
    /// The enum type to find the item type.
    /// </param>
    protected void initItemTypeByProdType_TH(TaxUnrealizedDocuProdType _prodType)
    {
        if (_prodType == TaxUnrealizedDocuProdType::Item)
        {
            itemType = ItemType::Item;
        }
        else
        {
            itemType = ItemType::Service;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLocalizationData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes customized data before processing the report.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that has the sales invoice header information.
    /// </param>
    /// <remarks>
    /// This method will initialize some variables which will be used during processing the report for Eastern Europe customization.
    /// </remarks>
    protected void initializeLocalizationData(CustInvoiceJour _custInvoiceJour)
    {
        str invoicesOnly = '%1';
        str separator = '\n';

        switch (isoCountryCode)
        {
            case #isoEE, #isoLT, #isoHU, #isoLV, #isoCZ, #isoPL:
                // If the custInvoiceJour has credit note lines, get the original invoice Ids.
                if (_custInvoiceJour.returnLinesExist_W())
                {
                    if (isoCountryCode == #isoHU || isoCountryCode == #isoPL || isoCountryCode == #isoLT)
                    {
                        originalInvoiceIds = _custInvoiceJour.originalInvoices_W(separator);
                    }
                    else
                    {
                        originalInvoiceIds = _custInvoiceJour.originalInvoices_W(separator, invoicesOnly);
                        //Following line is handling of situation when non-localized report format is used
                        //as in case of non-localized report we use "correctedInvoiceID instead of originalInvoiceIds
                        correctedInvoiceId = strFmt("@SYS26868", originalInvoiceIds, _custInvoiceJour.InvoiceDate);
                    }

                    correctiveReason_header = ReasonTableRef::find(_custInvoiceJour.ReasonTableRef).ReasonComment;
                }

                // Gets the right bank information.
                CustInvoiceJour_W custInvoiceJourW = _custInvoiceJour.custInvoiceJour_W();
                companyBankAccountTable = custInvoiceJourW.BankAccount_W ? BankAccountTable::find(custInvoiceJourW.BankAccount_W) : BankAccountTable::find(companyInfo.Bank);
            // fall through

            case #isoLT:
                this.calculateTotalExcludedTaxAmount(_custInvoiceJour.LedgerVoucher);

            default:
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditNoteSummaryLine_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Insert the credit note summary line.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record that has the invoice header information.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// The <c>CustInvoiceTrans</c> record that has the invoice details information.
    /// </param>
    protected void insertCreditNoteSummaryLine_PL(CustInvoiceJour _custInvoiceJour, CustInvoiceTrans _custInvoiceTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInvoiceDetailsInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts invoice detail information.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that has the invoice header information.
    /// </param>
    /// <param name="_custInvoiceTrans">
    /// A <c>CustInvoiceTrans</c> record that has the invoice details information.
    /// </param>
    /// <param name="_custPaymSchedLine">
    /// A <c>CustPaymSchedLine</c> record that has the payment schedule information.
    /// </param>
    /// <param name="_prepaymentCustTrans">
    /// A <c>CustTrans</c> record that has the prepayment information.
    /// </param>
    /// <param name="prepaymentTaxTrans">
    /// A <c>TaxTrans</c> record that has the prepayment taxes information.
    /// </param>
    /// <remarks>
    /// The method will insert the invoice details information. It should be overridden in the sub classes to insert the data in the right temp tables.
    /// </remarks>
    protected abstract void insertInvoiceDetailsInformation(CustInvoiceJour _custInvoiceJour,
        CustInvoiceTrans _custInvoiceTrans,
        CustPaymSchedLine _custPaymSchedLine,
        CustTrans _prepaymentCustTrans,
        TaxTrans prepaymentTaxTrans
        )
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertInvoiceHeaderInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the invoice header information.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that has the invoice header information.
    /// </param>
    /// <param name="_companyInfo">
    /// A <c>CompanyInfo</c> record that has the company information.
    /// </param>
    /// <remarks>
    /// The method will insert the invoice header information. It should be overridden in the sub classes to insert the data in the right temp tables.
    /// </remarks>
    protected abstract void insertInvoiceHeaderInformation(CustInvoiceJour _custInvoiceJour, CompanyInfo _companyInfo)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPeriodCharge</Name>
				<Source><![CDATA[
    internal protected void insertPeriodCharge(CustInvoiceJour _custInvoiceJour, CustInvoiceTrans _custInvoiceTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMarkupSpec</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the <c>MarkupTrans</c> records that relates to the invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    protected void insertMarkupSpec(CustInvoiceJour _custInvoiceJour)
    {
        SalesLine salesLine;
        TaxGroupData taxGroupData;
        TaxOnItem taxOnItem;
        TaxTrans taxTrans;
        MarkupTrans markupTrans;
        MarkupTmpTrans_FI tmpMarkupTrans;
        TaxCode localTaxCode;

        tmpMarkupTrans.recordLevelSecurity(true);

        if (_custInvoiceJour.isProforma())
        {
            SalesTable salesTable = SalesTable::find(_custInvoiceJour.SalesId);

            while select markupTrans
                where markupTrans.TransRecId == salesTable.RecId &&
                      markupTrans.TransTableId == salesTable.TableId &&
                      !markupTrans.IsDeleted
            {
                tmpMarkupTrans.TransTableId = markupTrans.TransTableId;
                tmpMarkupTrans.TransRecId = markupTrans.TransRecId;
                tmpMarkupTrans.LineNum = markupTrans.LineNum;
                tmpMarkupTrans.MarkupCode = markupTrans.MarkupCode;
                tmpMarkupTrans.MarkupValue = Markup::calcMarkupAmount(
                    markupTrans,
                    _custInvoiceJour.Qty,
                    _custInvoiceJour.SalesBalance,
                    0.0,
                    salesTable.InclTax);
                tmpMarkupTrans.TaxGroup = markupTrans.TaxGroup;
                tmpMarkupTrans.TaxItemGroup = markupTrans.TaxItemGroup;
                tmpMarkupTrans.SalesId = _custInvoiceJour.SalesId;
                if (!MarkupTmpTrans_FI::doesExist(markupTrans.TransTableId, markupTrans.TransRecId, markupTrans.LineNum))
                {
                    tmpMarkupTrans.insert();
                }
            }

            QueryRun tradeLoopTrans = this.getCustInvoiceTransQueryRun();

            if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
            {
                kittingReportHandler = new KittingSrsReportDataProviderPreProcess();
                tradeLoopTrans = kittingReportHandler.kittingGetQueryRun(tradeLoopTrans, tableNum(CustInvoiceJour));
            }
  
            // Process CustInvoiceTrans records.
            while (tradeLoopTrans.next())
            {
                CustInvoiceTrans custInvoiceTrans = tradeLoopTrans.get(tableNum(CustInvoiceTrans));
                salesLine = custInvoiceTrans.salesLine();

                while select markupTrans
                    where markupTrans.TransRecId == salesLine.RecId &&
                          markupTrans.TransTableId == salesLine.TableId
                {
                    tmpMarkupTrans.TransTableId = markupTrans.TransTableId;
                    tmpMarkupTrans.TransRecId = markupTrans.TransRecId;
                    tmpMarkupTrans.LineNum = markupTrans.LineNum;
                    tmpMarkupTrans.MarkupCode = markupTrans.MarkupCode;
                    tmpMarkupTrans.MarkupValue = Markup::calcMarkupAmount(
                        markupTrans,
                        salesLine.SalesQty,
                        salesLine.LineAmount,
                        0.0,
                        salesTable.InclTax);
                    tmpMarkupTrans.TaxGroup = markupTrans.TaxGroup;
                    tmpMarkupTrans.TaxItemGroup = markupTrans.TaxItemGroup;
                    tmpMarkupTrans.SalesId = _custInvoiceJour.SalesId;
                    if (!MarkupTmpTrans_FI::doesExist(markupTrans.TransTableId, markupTrans.TransRecId, markupTrans.LineNum))
                    {
                        tmpMarkupTrans.insert();
                    }
                }
            }

            while select SalesId, MarkupCode, TaxGroup, TaxItemGroup, sum(MarkupValue) from tmpMarkupTrans
                group by SalesId, MarkupCode, TaxGroup, TaxItemGroup
                where tmpMarkupTrans.SalesId == _custInvoiceJour.SalesId
            {
                select firstonly taxGroupData
                    where taxGroupData.TaxGroup == tmpMarkupTrans.TaxGroup
                    join TaxItemGroup, TaxCode from taxOnItem
                        where taxOnItem.TaxItemGroup == tmpMarkupTrans.TaxItemGroup
                            && taxOnItem.TaxCode == taxGroupData.TaxCode;

                if (taxGroupData)
                {
                    localTaxCode = taxGroupData.TaxCode;
                }
                else
                {
                    localTaxCode = #emptyString;
                }

                this.parmMarkupAmount(tmpMarkupTrans.MarkupValue);
                this.parmMarkupTaxCode(this.retrieveMarkUpTaxCode(localTaxCode));
                this.parmMarkupCode(this.getMarkupCode(_custInvoiceJour, markupTrans, tmpMarkupTrans));
                this.insertInvoiceDetailsInformation(_custInvoiceJour, null, null, null
                // <GEECZ>
                , null
                // </GEECZ>
                );
            }
        }
        else
        {
            QueryRun queryRun = new QueryRun(this.buildNonProformaMarkupTransQuery(_custInvoiceJour));

            while (queryRun.next())
            {
                markupTrans = queryRun.get(tableNum(MarkupTrans));

                select firstonly taxTrans
                    where taxTrans.Voucher == markupTrans.Voucher &&
                        taxTrans.TaxGroup == markupTrans.TaxGroup &&
                        taxTrans.TaxItemGroup == markupTrans.TaxItemGroup;
                if (taxTrans)
                {
                    localTaxCode = taxTrans.TaxCode;
                }
                else
                {
                    localTaxCode = #emptyString;
                }

                this.initFromMarkUpTransAndInvoiceJour(markupTrans, _custInvoiceJour, localTaxCode);
                this.insertInvoiceDetailsInformation(_custInvoiceJour, null, null, null, null);
            }
        }

        this.parmMarkupAmount(0);
        this.parmMarkupTaxCode(#emptyString);
        this.parmMarkupCode(#emptyString);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildNonProformaMarkupTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query to select markup transactions.
    /// </summary>
    /// <param name = "_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    /// <returns>
    /// The query with the selected markup transaction records.
    /// </returns>
    protected Query buildNonProformaMarkupTransQuery(CustInvoiceJour _custInvoiceJour)
    {
        Query query = new Query();

        QueryBuildDataSource qbds = query.addDataSource(tableNum(MarkupTrans));

        qbds.addGroupByField(fieldNum(MarkupTrans, Voucher));
        qbds.addGroupByField(fieldNum(MarkupTrans, MarkupCode));
        qbds.addGroupByField(fieldNum(MarkupTrans, TaxGroup));
        qbds.addGroupByField(fieldNum(MarkupTrans, TaxItemGroup));
     
        qbds.addSelectionField(fieldNum(MarkupTrans, MarkupCode));
        qbds.addSelectionField(fieldNum(MarkupTrans, Voucher));
        qbds.addSelectionField(fieldNum(MarkupTrans, TaxGroup));
        qbds.addSelectionField(fieldNum(MarkupTrans, TaxItemGroup));
        qbds.addSelectionField(fieldNum(MarkupTrans, CalculatedAmount), SelectionField::Sum);

        qbds.addRange(fieldNum(MarkupTrans, Voucher)).value(SysQuery::value(_custInvoiceJour.LedgerVoucher));
        qbds.addRange(fieldNum(MarkupTrans, IsDeleted)).value(SysQuery::value(NoYes::No));
            
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromMarkUpTransAndInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the markup transaction information related to the invoice.
    /// </summary>
    /// <param name = "_markupTrans">
    /// A <c>MarkupTrans</c> record contains the markup transaction information.
    /// </param>
    /// <param name = "_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    /// <param name = "_localTaxCode">
    /// The <c>TaxCode</c> value of the tax transaction record.
    /// </param>
    protected void initFromMarkUpTransAndInvoiceJour(MarkupTrans _markupTrans, CustInvoiceJour _custInvoiceJour, TaxCode _localTaxCode)
    {
        this.parmMarkupAmount(_markupTrans.CalculatedAmount);
        this.parmMarkupTaxCode(this.retrieveMarkUpTaxCode(_localTaxCode));
        this.parmMarkupCode(this.getMarkupCode(_custInvoiceJour, _markupTrans, null));
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPaymentSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the payment schedule information.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    protected void insertPaymentSchedule(CustInvoiceJour _custInvoiceJour)
    {
        CustPaymSched custPaymSched;
        CustPaymSchedLine custPaymSchedLine;

        if (_custInvoiceJour.PaymentSched && _custInvoiceJour.RecId)
        {
            while select custPaymSchedLine
            exists join custPaymSched
                where custPaymSchedLine.ParentRecID == custPaymSched.RecId
                    && custPaymSched.ExtRecId == _custInvoiceJour.RecId
                    && custPaymSched.ExtTableId == tableNum(CustInvoiceJour)
            {
                this.insertInvoiceDetailsInformation(_custInvoiceJour,
                    null,
                    custPaymSchedLine,
                    null
                    // <GEECZ>
                    , null
                    // </GEECZ>
                    );
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the invoice taxes information.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    /// <remarks>
    /// This method should be overridden in the sub classes to get the right taxes information and be inserted in the right tables.
    /// </remarks>
    protected abstract void insertTaxes(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceTxt_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method returns the printed invoice text.
    /// </summary>
    /// <param name="_custInvoiceJour">
    ///     Given <c>CustInvoiceJour</c> buffer.
    /// </param>
    /// <returns>
    /// Return the invoice text.
    /// </returns>
    protected str invoiceTxt_TH(CustInvoiceJour _custInvoiceJour)
    {
        str invoiceTxt;
        boolean isProforma = _custInvoiceJour.isProforma();
        boolean isPrepayment = _custInvoiceJour.Prepayment;
        boolean isCreditInvoicingReport = custParameters.CreditInvoicingReport;
        LanguageId languageId = _custInvoiceJour.LanguageId ? _custInvoiceJour.LanguageId : infolog.language();
        
        if (printCopyOriginal == PrintCopyOriginal::Copy)
        {
            boolean isCopy = true;
        }

        if (_custInvoiceJour.InvoiceAmount >= 0)
        {
            if (isProforma)
            {
                if (isPrepayment)
                {
                    invoiceTxt = SysLabel::labelId2String(literalStr("@SYS87979"), languageId);
                }
                else
                {
                    if (isTaxInvoice)
                    {
                        invoiceTxt = SysLabel::labelId2String(literalStr("@SYS121362"), languageId);
                    }
                    else
                    {
                        invoiceTxt = SysLabel::labelId2String(literalStr("@SYS4701"), languageId);
                    }
                }
            }
            else
            {
                if (isTaxInvoice)
                {
                    if (PaymTerm::find(_custInvoiceJour.Payment).PaymMethod == NetCurrent::COD)
                    {
                        invoiceTxt = SysLabel::labelId2String(literalStr("@AccountsReceivable:SubstitutionInvoices_TaxInvoiceReceipt"), languageId);
                    }
                    else
                    {
                        invoiceTxt = SysLabel::labelId2String(literalStr("@SYS115505"), languageId);
                    }
                }
                else
                {
                    invoiceTxt = SysLabel::labelId2String(literalStr("@SYS12128"), languageId);
                }
            }
        }
        else
        {
            if (isProforma)
            {
                if (isPrepayment)
                {
                    invoiceTxt = SysLabel::labelId2String(literalStr("@SYS87981"), languageId);
                }
                else
                {
                    if (isCreditInvoicingReport)
                    {
                        invoiceTxt = SysLabel::labelId2String(literalStr("@SYS99735"), languageId);
                    }
                    else
                    {
                        invoiceTxt = SysLabel::labelId2String(literalStr("@SYS24608"), languageId);
                    }
                }
            }
            else
            {
                if (isCreditInvoicingReport)
                {
                    invoiceTxt = SysLabel::labelId2String(literalStr("@SYS99734"), languageId);
                }
                else
                {
                    invoiceTxt = SysLabel::labelId2String(literalStr("@SYS8125"), languageId);
                }
            }
        }

        return invoiceTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceTxtNote_TH</Name>
				<Source><![CDATA[
    public static str invoiceTxtNote_TH(CustInvoiceJour _custInvoiceJour, CustInvoiceJourAdjustment _custInvoiceJourAdjustment, PrintCopyOriginal _printCopyOriginal)
    {
        str invoiceTxtNote;
        LanguageId languageId = _custInvoiceJour.LanguageId ? _custInvoiceJour.LanguageId : infolog.language();

        if (_custInvoiceJourAdjustment.AdjustmentType == CustInvoiceJourAdjustmentType_TH::Substitution)
        {
            if (_printCopyOriginal == PrintCopyOriginal::Copy)
            {
                invoiceTxtNote = SysLabel::labelId2String(literalStr("@AccountsReceivable:SubstitutionInvoices_SubstitutionCopy"), languageId);
            }
            else
            {
                invoiceTxtNote = SysLabel::labelId2String(literalStr("@AccountsReceivable:SubstitutionInvoices_Substitution"), languageId);
            }
        }
        else if (_custInvoiceJourAdjustment.AdjustmentType == CustInvoiceJourAdjustmentType_TH::Adjustment)
        {
            if (_printCopyOriginal == PrintCopyOriginal::Copy)
            {
                invoiceTxtNote = SysLabel::labelId2String(literalStr("@AccountsReceivable:SubstitutionInvoices_AdjustmentCopy"), languageId);
            }
            else
            {
                invoiceTxtNote = SysLabel::labelId2String(literalStr("@AccountsReceivable:SubstitutionInvoices_Original"), languageId);
            }
        }
        else if (_printCopyOriginal == PrintCopyOriginal::Copy)
        {
            invoiceTxtNote = SysLabel::labelId2String(literalStr("@SYS6896"), languageId);
        }
        else
        {
            invoiceTxtNote = SysLabel::labelId2String(literalStr("@AccountsReceivable:SubstitutionInvoices_Original"), languageId);
        }

        return invoiceTxtNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditInvoicingReportEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the invoice is a credit invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    /// <returns>
    /// true if the invoice is a credit one; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is only used for ES, SE, and PL countries.
    /// </remarks>
    protected boolean isCreditInvoicingReportEnabled(CustInvoiceJour _custInvoiceJour)
    {
        return custParameters.CreditInvoicingReport && _custInvoiceJour.InvoiceAmount < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompanyBankAccountTable</Name>
				<Source><![CDATA[
    protected BankAccountTable parmCompanyBankAccountTable(BankAccountTable _companyBankAccountTable = companyBankAccountTable)
    {
        companyBankAccountTable = _companyBankAccountTable;
        return companyBankAccountTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCompanyInfo</Name>
				<Source><![CDATA[
    protected CompanyInfo parmCompanyInfo(CompanyInfo _companyInfo = companyInfo)
    {
        companyInfo = _companyInfo;
        return companyInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustDirectDebitMandate</Name>
				<Source><![CDATA[
    protected CustDirectDebitMandate parmCustDirectDebitMandate(CustDirectDebitMandate _custDirectDebitMandate = custDirectDebitMandate)
    {
        custDirectDebitMandate = _custDirectDebitMandate;
        return custDirectDebitMandate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustDirectDebitMandateBankAccount</Name>
				<Source><![CDATA[
    protected CustBankAccount parmCustDirectDebitMandateBankAccount(CustBankAccount _custDirectDebitMandateBankAccount = custDirectDebitMandateBankAccount)
    {
        custDirectDebitMandateBankAccount = _custDirectDebitMandateBankAccount;
        return custDirectDebitMandateBankAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceJour</Name>
				<Source><![CDATA[
    protected CustInvoiceJour parmCustInvoiceJour(CustInvoiceJour _custInvoiceJour = custInvoiceJour)
    {
        custInvoiceJour = _custInvoiceJour;
        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIntrastatCode</Name>
				<Source><![CDATA[
    protected EcoResCategoryCommodityCode parmIntrastatCode(EcoResCategoryCommodityCode _intrastatCode = intrastatCode)
    {
        intrastatCode = _intrastatCode;
        return intrastatCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxAmountMSTVisible</Name>
				<Source><![CDATA[
    protected boolean parmIsTaxAmountMSTVisible(boolean _isTaxAmountMSTVisible = isTaxAmountMSTVisible)
    {
        isTaxAmountMSTVisible = _isTaxAmountMSTVisible;
        return isTaxAmountMSTVisible;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineHeader</Name>
				<Source><![CDATA[
    public LineHeader parmLineHeader()
    {
        return lineHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupAmount</Name>
				<Source><![CDATA[
    public MarkupValue parmMarkupAmount(MarkupValue _markupValue = markupValue)
    {
        markupValue = _markupValue;

        return markupValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupCode</Name>
				<Source><![CDATA[
    protected MarkupCode parmMarkupCode(MarkupCode _markupCode = markupCode)
    {
        markupCode = _markupCode;

        return markupCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupTaxCode</Name>
				<Source><![CDATA[
    protected TaxCode parmMarkupTaxCode(TaxCode _taxCode = taxCode)
    {
        taxCode = _taxCode;
        return taxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalInvoiceId_CZ</Name>
				<Source><![CDATA[
    protected InvoiceId parmOriginalInvoiceId_CZ(InvoiceId _originalInvoiceId_CZ = originalInvoiceId_CZ)
    {
        originalInvoiceId_CZ = _originalInvoiceId_CZ;
        return originalInvoiceId_CZ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginalInvoiceIds</Name>
				<Source><![CDATA[
    protected str parmOriginalInvoiceIds(str _originalInvoiceIds = originalInvoiceIds)
    {
        originalInvoiceIds = _originalInvoiceIds;
        return originalInvoiceIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreviousRunningTotal</Name>
				<Source><![CDATA[
    protected LineAmount parmPreviousRunningTotal(LineAmount _previousRunningTotal = previousRunningTotal)
    {
        previousRunningTotal = _previousRunningTotal;

        return previousRunningTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintCopyOriginal</Name>
				<Source><![CDATA[
    protected PrintCopyOriginal parmPrintCopyOriginal(PrintCopyOriginal _printCopyOriginal = printCopyOriginal)
    {
        printCopyOriginal = _printCopyOriginal;
        return printCopyOriginal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTotalExcludedTaxAmount</Name>
				<Source><![CDATA[
    public TaxRegulationAmountCur parmTotalExcludedTaxAmount()
    {
        return totalExcludedTaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printEuroTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the totals must be printed in EURO currency.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    /// <returns>
    /// true if the totals must be printed in EURO; otherwise, false.
    /// </returns>
    protected boolean printEuroTotals(CustInvoiceJour _custInvoiceJour)
    {
        CurrencyCode euroCurrency = Currency::findEuroCurrencyCode();
        boolean doPrintEuroTotals;

        switch (isoCountryCode)
        {
            case #isoEE, #isoLT, #isoHU, #isoLV, #isoCZ, #isoPL:
                doPrintEuroTotals = custFormletterParameters.PrintEuroAmount && euroCurrency && (_custInvoiceJour.CurrencyCode != euroCurrency);
                break;

            default:
                doPrintEuroTotals = custFormletterParameters.PrintEuroAmount && euroCurrency;
                break;
        }

        return doPrintEuroTotals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the prepayment information related to the invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    protected void printPrepayment(CustInvoiceJour _custInvoiceJour)
    {
        CustTrans custTrans;
        CompanyId offsetCompany = curext();
        CustSettlement custSettlement;
        CustVendTransPostingLog_RU postingLog;
        TaxTrans taxTrans;

        // Get the CustTrans record for the current custInvoiceJour record.
        CustTrans invoiceCustTrans = _custInvoiceJour.custTrans();

        if (invoiceCustTrans)
        {
            // Find settlement records for this invoice.
            while select OffsetCompany, OffsetRecid, SettleAmountCur from custSettlement
                where custSettlement.TransRecId == invoiceCustTrans.RecId
                    && custSettlement.CanBeReversed == NoYes::Yes
            {
                if (custSettlement.OffsetCompany)
                {
                    offsetCompany = custSettlement.OffsetCompany;
                }
                else
                {
                    offsetCompany = curext();
                }

                changecompany (offsetCompany)
                {
                    // This is necessary to clear the DataAreaId in order to get
                    // data from other companies.
                    select firstonly TransDate, Txt, AmountCur, CurrencyCode, Voucher from custTrans
                        where custTrans.RecId == custSettlement.OffsetRecid
                              && (custTrans.Prepayment == NoYes::Yes || custTrans.TransType == LedgerTransType::Payment);

                    if (custTrans)
                    {
                        settledAmountCur = custSettlement.SettleAmountCur;

                        if (isoCountryCode == #isoCZ)
                        {
                            while select TransRecId, PostingLogType, RefTableId, OffSetRecId, TransCompany, OffsetCompany,
                                TransDate, Voucher
                            from postingLog
                                group by postingLog.TransRecId, postingLog.PostingLogType, postingLog.RefTableId,
                                    postingLog.OffSetRecId, postingLog.TransCompany, postingLog.OffsetCompany,
                                    postingLog.TransDate, postingLog.Voucher
                                where postingLog.PostingLogType == CustVendTransPostingLogType_RU::PrepaymentStornoVAT &&
                                        postingLog.RefTableId == custTrans.TableId &&
                                        ((postingLog.TransRecId == custTrans.RecId &&
                                        postingLog.TransCompany == custTrans.DataAreaId &&
                                        postingLog.OffSetRecId == invoiceCustTrans.RecId &&
                                        postingLog.OffsetCompany == invoiceCustTrans.DataAreaId)
                                        ||
                                        (postingLog.OffSetRecId == custTrans.RecId &&
                                            postingLog.OffsetCompany == custTrans.DataAreaId &&
                                            postingLog.TransRecId == invoiceCustTrans.RecId &&
                                            postingLog.TransCompany == invoiceCustTrans.DataAreaId))
                            {
                                select taxTrans
                                    where taxTrans.Voucher == postingLog.Voucher &&
                                            (taxTrans.TransDate == postingLog.TransDate ||
                                            taxTrans.TransDate == postingLog.reverseDate());

                                while (taxTrans)
                                {
                                    this.insertInvoiceDetailsInformation(_custInvoiceJour, null, null, custTrans, taxTrans);
                                    next taxTrans;
                                }
                            }
                        }

                        this.insertInvoiceDetailsInformation(_custInvoiceJour, null, null, custTrans, null);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printPrepaymentProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prints the prepayment information related to the proforma invoice.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    protected void printPrepaymentProforma(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the report business logic.
    /// </summary>
    /// <remarks>
    /// Provides the ability to write the report business logic. This method will be called by SSRS at
    /// runtime. The method should compute data and populate the data tables that will be returned to SSRS.
    /// Note that this is a framework class. Customizing this class may cause problems with future upgrades
    /// to the software.
    /// </remarks>
    public void processReport()
    {
        if (!this.useExistingReportData())
        {
            this.setTableConnections();

            this.createData();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIsSalesInvoiceDP_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets whether data provider is for sales invoice.
    /// </summary>
    /// <param name="_isSalesInvoiceDP">
    /// Indicates whether data provider is for sales invoice.
    /// </param>
    protected void setIsSalesInvoiceDP_TH(boolean _isSalesInvoiceDP = false)
    {
        isSalesInvoiceDP = _isSalesInvoiceDP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTableConnections</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the user connection to use on table.
    /// </summary>
    /// <remarks>
    /// This is required to guarantee that <c>createdTransactionId</c> of inserted record is different than
    /// default transaction.
    /// </remarks>
    abstract void setTableConnections()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPrepaidAmountsProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the prepayment amounts.
    /// </summary>
    /// <param name = "_custInvoiceJour">Invoice journal to set prepaid amounts.</param>
    protected void setPrepaidAmountsProforma(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>showCashDiscOnInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the cash discount must be shown on the report.
    /// </summary>
    /// <returns>
    /// true if the cash discount must be shown on the report; otherwise, false.
    /// </returns>
    protected boolean showCashDiscOnInvoice()
    {
        return cashDiscOnInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showSepaNotification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the SEPA Direct Debit Mandate Notification must be printed.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// A <c>CustInvoiceJour</c> record that contains invoice data.
    /// </param>
    /// <returns>
    /// true if the notification must be printed; otherwise, false.
    /// </returns>
    protected boolean showSepaNotification(CustInvoiceJour _custInvoiceJour)
    {
        if (_custInvoiceJour.InvoiceAmount >= 0 && _custInvoiceJour.DirectDebitMandate)
        {
            select firstOnly custDirectDebitMandate
                    where custDirectDebitMandate.RecId == _custInvoiceJour.DirectDebitMandate
                join custDirectDebitMandateBankAccount
                    where custDirectDebitMandateBankAccount.AccountID == custDirectDebitMandate.BankAccount &&
                            custDirectDebitMandateBankAccount.CustAccount == custDirectDebitMandate.CustAccount;

            if (custDirectDebitMandate && custDirectDebitMandateBankAccount)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useExistingReportData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there is existing report data that will be used.
    /// </summary>
    /// <returns>
    /// true if there is existing report data; otherwise, false.
    /// </returns>
    protected boolean useExistingReportData()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSplitPaymentNote_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the split payment note.
    /// </summary>
    /// <param name = "_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> record that has the invoice header information.
    /// </param>
    /// <param name = "_notes">
    /// The <c>Notes</c> object.
    /// </param>
    /// <returns>The <c>Notes</c> object.</returns>
    [Hookable(false)]
    internal Notes addSplitPaymentNote_W(custInvoiceJour _custInvoiceJour, Notes _notes)
    {
        Notes ret = _notes;
        const str NewLine = '\n';

        if (FeatureStateProvider::isFeatureEnabled(SplitPaymentMandatoryRuleFeature_PL::instance()))
        {
            CustTrans custTrans = _custInvoiceJour.custTrans();

            if (custTrans.custTrans_W().SplitPayment_W == NoYes::Yes)
            {
                if (ret)
                {
                    ret += NewLine;
                }

                ret += CustPaymModeTable::find(custTrans.PaymMode).Name;
            }
        }
        else
        {
            CustPaymModeTable custPaymModeTable = CustPaymModeTable::find(_custInvoiceJour.paymMode());

            if (custPaymModeTable.SplitPayment_W == NoYes::Yes)
            {
                if (ret)
                {
                    ret += NewLine;
                }

                ret += custPaymModeTable.Name;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>