<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailPricingEngineHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
using System.Collections.Generic;
using System.Reflection;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
using CommerceRunTimeDataModel = Microsoft.Dynamics.Commerce.Runtime.DataModel;
using CrtSalesTransaction = Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesTransaction;
using CrtSalesLine = Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesLine;
using CrtUnitOfMeasureConversion = Microsoft.Dynamics.Commerce.Runtime.DataModel.UnitOfMeasureConversion;
using CrtSalesAffiliationLoyaltyTier = Microsoft.Dynamics.Commerce.Runtime.DataModel.SalesAffiliationLoyaltyTier;
using CrtLineDiscountCalculationType = Microsoft.Dynamics.Commerce.Runtime.DataModel.LineDiscountCalculationType;
using CrtRetailAffiliationType = Microsoft.Dynamics.Commerce.Runtime.DataModel.RetailAffiliationType;

/// <summary>
/// This contains some utilities and implementations for use with
///  the RetailPricingEngine class and Channels.Headquarters.PricingProxy project.
/// </summary>
class RetailPricingEngineHelper
{
    private const str discountOfferIdProperty = 'DiscountOfferId';
    private const str discountCodeProperty = 'Code';
    private const str salesTransactionCouponsProperty = 'Coupons';

    private const str SavedQuantityProperty = 'SavedQuantity';
    private const str IsSavedDiscountProperty = 'IsSavedDiscount';
    private const str SavedEffectiveAmountProperty = 'SavedEffectiveAmount';

    private static Map salesLineIsPriceOverriddenMap = new Map(Types::String, Types::Integer);

    private static CommerceHQEventSource eventSource = CommerceHQEventSource::Log;

    /// <summary>
    /// Bundle Id column.
    /// </summary>
    public const str bundleIdColumn = 'BundleId';

    RecId mChannelRecId;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    private void new(RecId _channelRecordId)
    {
        mChannelRecId = _channelRecordId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a numeric value, round it according to the channel's currency
    /// </summary>
    /// <param name="_price">
    /// Unrounded price amount
    /// </param>
    /// <returns>
    /// Rounded price amount
    /// </returns>
    public real roundAmount(real _price)
    {
        RetailChannelTable channel = RetailChannelTable::findByRecId(mChannelRecId);
        CurrencyCode currency = '';

        if (channel.RecId)
        {
            currency = channel.Currency;
        }

        return CurrencyExchange::round(_price, currency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>toString</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns description of this pricing helper
    /// </summary>
    /// <returns>
    /// Returns description of this pricing helper
    /// </returns>
    public str toString()
    {
        return strFmt('Service helper for channel %1', mChannelRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs new instance of a RetailPricingEngineHelper which operates in context of given channel
    /// </summary>
    /// <param name="_channelRecordId">
    /// The record Id of the channel the pricing helper operates under
    /// </param>
    /// <returns>
    /// Instance of the data manager which retrieves data from AX under given channel context
    /// </returns>
    public static RetailPricingEngineHelper construct(RecId _channelRecordId)
    {
        RetailPricingEngineHelper pricingHelper = new RetailPricingEngineHelper(_channelRecordId);

        return pricingHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrtCustAffiliation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a Commerce Runtime SalesAffiliationLoyaltyTier Object from the customer affiliation.
    /// </summary>
    /// <param name="_retailCustAffiliation">
    /// The RetailCustAffiliation record.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime SalesAffiliationLoyaltyTier Object.
    /// </returns>
    private static CrtSalesAffiliationLoyaltyTier getCrtCustAffiliation(RetailCustAffiliation _retailCustAffiliation)
    {
        CrtSalesAffiliationLoyaltyTier crlSalesAffiliationLoyaltyTier = new CrtSalesAffiliationLoyaltyTier();
        crlSalesAffiliationLoyaltyTier.set_AffiliationId(_retailCustAffiliation.RetailAffiliationId);
        return crlSalesAffiliationLoyaltyTier;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrtRetailSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a SalesLine object from the Commerce Runtime from the
    ///  SalesLine AX table record.
    /// </summary>
    /// <param name="_salesLine">
    /// The SalesLine record to convert to a Commerce Runtime SalesLine object.
    /// </param>
    /// <param name="_retailSalesLine">
    /// The RetailSalesPurchLineMap record.
    /// </param>
    /// <param name="_defaultSalesUnit">
    /// Default unit of measure for sales.
    /// </param>
    /// <param name="_salesTable">
    /// Sales or quotation table.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime SalesLine object.
    /// </returns>
    public static CrtSalesLine getCrtRetailSalesLine(
        SalesPurchLine _salesLine,
        RetailSalesPurchLineMap _retailSalesLine,
        SalesUnit _defaultSalesUnit,
        SalesPurchTable _salesTable = null)
    {
        return RetailPricingEngineHelper::getCrtRetailSalesLineBasedOnDateType(_salesLine, _retailSalesLine, _defaultSalesUnit, _salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrtRetailSalesLineBasedOnDateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a SalesLine object from the Commerce Runtime from the
    ///  SalesLine AX table record.
    /// </summary>
    /// <param name="_salesLine">
    /// The SalesLine record to convert to a Commerce Runtime SalesLine object.
    /// </param>
    /// <param name="_retailSalesLine">
    /// The RetailSalesPurchLineMap record.
    /// </param>
    /// <param name="_defaultSalesUnit">
    /// Default unit of measure for sales.
    /// </param>
    /// <param name="_salesTable">
    /// Sales or quotation table.
    /// </param>
    /// <param name="_dateType">
    /// Date type.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime SalesLine object.
    /// </returns>
    public static CrtSalesLine getCrtRetailSalesLineBasedOnDateType(
        SalesPurchLine _salesLine,
        RetailSalesPurchLineMap _retailSalesLine,
        SalesUnit _defaultSalesUnit,
        SalesPurchTable _salesTable = null,
        SalesPriceDateType _dateType = SalesPriceDateType::Today)
    {
        InventTable inventTable;
        System.Guid lineId;
        System.String lineIdString;
        InventDimCombination inventDimCombination;
        System.Decimal localDecimal;
        RetailSalesPurchTableMap retailSalesTable;
        RetailChannelTable retailChannel;
        PriceDiscPolicyCheckPolicy checkPolicy;
        SalesPurchLineInterface salesPurchLineInterface = _salesLine.salesPurchLineInterface();

        CrtSalesLine crtSalesLine = new CrtSalesLine();
        crtSalesLine.set_ItemId(salesPurchLineInterface.parmItemId());
        crtSalesLine.set_InventoryDimensionId('');
        crtSalesLine.set_Quantity(salesPurchLineInterface.parmQty());
        
        if (RetailSalesLineAddQtyOrderedColumnFlight::instance().isEnabled())
        {
            crtSalesLine.set_QuantityOrdered(salesPurchLineInterface.calcQtyOrdered());
        }

        crtSalesLine.set_SalesOrderUnitOfMeasure(salesPurchLineInterface.parmUnitId());
        crtSalesLine.set_OriginalSalesOrderUnitOfMeasure(_defaultSalesUnit);
        crtSalesLine.set_LineNumber(salesPurchLineInterface.parmLineNum());

        // Use AX SalesLine.InventTransId if available.
        if (salesPurchLineInterface.parmInventTransId())
        {
            lineIdString = salesPurchLineInterface.parmInventTransId();
        }
        else
        {
            lineId = System.Guid::NewGuid();
            lineIdString = lineId.ToString();
        }
        crtSalesLine.set_LineId(lineIdString);
        crtSalesLine.set_CatalogId(_retailSalesLine.Catalog);
        crtSalesLine.set_SalesTaxGroupId(salesPurchLineInterface.parmTaxGroup());
        crtSalesLine.set_ItemTaxGroupId(salesPurchLineInterface.parmTaxItemGroup());

        // Set productId and masterProducId before we try to update unit conversion since now SCM supports variant based conversion.
        inventTable = inventTable::find(salesPurchLineInterface.parmItemId());
        if (inventTable.RecId)
        {
            crtSalesLine.set_ProductId(inventTable.Product);

            if (salesPurchLineInterface.parmRetailVariantId())
            {
                inventDimCombination = InventDimCombination::findVariantId(salesPurchLineInterface.parmRetailVariantId());
                crtSalesLine.set_InventoryDimensionId(inventDimCombination.InventDimId);
                crtSalesLine.set_ProductId(inventDimCombination.DistinctProductVariant);
                crtSalesLine.set_MasterProductId(inventTable.Product);
            }
            else
            {
                crtSalesLine.set_ProductId(inventTable.Product);
            }
        }

        RetailPricingUnitOfMeasureConversionHelper::updateCrtUnitOfMeasureConversion(
            crtSalesLine, salesPurchLineInterface.parmItemId(), salesPurchLineInterface.parmUnitId(), _defaultSalesUnit);

        if (RetailPricingEngineHelper::isPriceOverridden(_salesLine))
        {
            crtSalesLine.set_IsPriceOverridden(true);
        }

        crtSalesLine.set_Price(salesPurchLineInterface.parmPrice());
        localDecimal = _retailSalesLine.LineManualDiscountAmount;
        crtSalesLine.set_LineManualDiscountAmount(localDecimal);
        localDecimal = _retailSalesLine.LineManualDiscountPercentage;
        crtSalesLine.set_LineManualDiscountPercentage(localDecimal);

        if (inventTable.RecId)
        {
            if (_salesTable == null)
            {
                _salesTable = _salesLine.salesPurchLineInterface().salesPurchTable();
            }

            if (_salesLine.TableId == tableNum(SalesLine) || _salesLine.TableId == tableNum(SalesQuotationLine))
            {
                if (_salesLine.SystemEntrySource == PriceDiscSystemSource::ProductConfig)
                {
                    crtSalesLine.IsPriceLocked = true;
                }
            }

            if (_salesLine.TableId == tableNum(SalesLine))
            {
                SalesTable localSalesTable = _salesTable;
                SalesLine localSalesLine = _salesLine;

                RetailSalesLine localRetailSalesLine = _retailSalesLine;
                InventDim inventDim = InventDim::find(localSalesLine.InventDimId);

                crtSalesLine.set_DeliveryMode(localSalesLine.DlvMode);
                crtSalesLine.set_FulfillmentStoreId(localRetailSalesLine.FulfillmentStoreId);
                crtSalesLine.set_InventorySiteId(inventDim.InventSiteId);
                crtSalesLine.set_InventoryLocationId(inventDim.InventLocationId);
                crtSalesLine.set_SerialNumber(inventDim.InventSerialId);
                crtSalesLine.set_SalesAgreementLineRecordId(localSalesLine.MatchingAgreementLine);
                crtSalesLine.set_IsSalesAgreementSkipped(localSalesLine.AgreementSkipAutoLink);

                // Return/credit note lines should be treated slightly different from regular lines.
                // 1. For returns the "return quantity" is set on SalesLine.ExpectedRetQty, for credit notes SalesLineQty.Ordered is set.
                // 2. If doing a "return by receipt", we also have to populate certain fields of the CRT.SalesLine so that discount is properly calculated.
                SalesLineType type = localSalesLine.type();
                if ( (localSalesTable.SalesType == SalesType::ReturnItem && localSalesLine.SalesType == SalesType::ReturnItem && localSalesLine.ExpectedRetQty != 0)
                        || (localSalesLine.InventTransIdReturn && type.creditNoteLine()))
                {
                    if (type.returnItem())
                    {
                        crtSalesLine.set_Quantity(localSalesLine.ExpectedRetQty);
                    }
                    else
                    {
                        crtSalesLine.set_Quantity(localSalesLine.QtyOrdered);
                    }

                    InventTransId inventTransIdBeingReturned = localSalesLine.InventTransIdReturn;

                    // If doing a return for an existing sales order, set the CRT.SalesLine and CRT.DiscountLine fields appropriately so that
                    //. the Discount Engine wont't try to recalculate the discounts,
                    // just divide them proportionally (in case there's a partial return).
                    if (inventTransIdBeingReturned != '')
                    {
                        SalesLine salesLineBeingReturned = SalesLine::findInventTransId(inventTransIdBeingReturned);

                        crtSalesLine.IsReturnByReceipt = true;
                        RetailPricingEngineHelper::setRealPropertyIfExistsInClass(crtSalesLine, RetailPricingEngineHelper::SavedQuantityProperty, salesLineBeingReturned.SalesQty);
                        RetailPricingEngineHelper::setBooleanPropertyIfExistsInClass(crtSalesLine, RetailPricingEngineHelper::IsSavedDiscountProperty, true);

                        RetailPricingEngineHelper::populateCrtDiscountLines(salesLineBeingReturned, crtSalesLine);
                    }
                }
                else // Excluding the "PriceLock" logic from returns so that proportional discounts can still be calculated for partial returns.
                {
                    if (RetailPricingEngineHelper::isPriceLocked(localSalesTable, localSalesLine, localRetailSalesLine))
                    {
                        crtSalesLine.IsPriceLocked = true;
                        RetailPricingEngineHelper::populateCrtDiscountLines(localSalesLine, crtSalesLine);
                    }
                }
            }
            else if (_salesLine.TableId == tableNum(SalesQuotationLine))
            {
                SalesQuotationLine salesQuotationLine = _salesLine;
                RetailSalesQuotationLine localRetailSalesQuotationLine = _retailSalesLine;
                InventDim inventDim = InventDim::find(salesQuotationLine.InventDimId);

                crtSalesLine.set_DeliveryMode(salesQuotationLine.DlvMode);
                crtSalesLine.set_InventorySiteId(inventDim.InventSiteId);
                crtSalesLine.set_InventoryLocationId(inventDim.InventLocationId);

                if (RetailPricingEngineHelper::isSalesQuotationPriceLocked(localRetailSalesQuotationLine))
                {
                    crtSalesLine.IsPriceLocked = true;
                    RetailPricingEngineHelper::populateCrtDiscountLinesForSalesQuotation(salesQuotationLine, crtSalesLine);
                }
            }

            // For orders coming from all channels, we get all available catalogs for each item.
            if (_retailSalesLine.Catalog)
            {
                crtSalesLine.AddCatalogId(_retailSalesLine.Catalog);
            }
        }

        return crtSalesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPriceLocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not price/discount is considered locked for a given line.
    /// Criteria for locking the lines is the following:
    /// - The line is partially invoiced or fully invoiced
    /// - Or the line is a call center order which is completed
    /// - Or the line has field IsPriceLocked = true
    /// </summary>
    /// <param name = "_salesTable">A SalesTable record.</param>
    /// <param name = "_salesLine">The SalesLine to be checked.</param>
    /// <param name = "_retailSalesLine">The RetailSalesLine associated with _salesLine.</param>
    /// <returns>True if price/discount is considered locked; otherwise, false.</returns>
    public static boolean isPriceLocked(SalesTable _salesTable, SalesLine _salesLine, RetailSalesLine _retailSalesLine)
    {
        boolean ret = _retailSalesLine.IsPriceLocked;

        if (ret)
        {
            using(var t = RetailPricingInstrumentationSegment::construct(
                classstr(RetailPricingEngineHelper), staticMethodStr(RetailPricingEngineHelper, isPriceLocked)))
            {
                t.addExtendedData(RetailPricingInstrumentationSegmentConstants::TableName, tableStr(RetailSalesLine));
                t.addExtendedData(RetailPricingInstrumentationSegmentConstants::RecordId, int642Str(_retailSalesLine.RecId));
            }
        }

        if (!ret)
        {
            if (RetailMCRChannelTable::mcrEnableOrderCompletion(_salesTable) && !_salesTable.MCROrderStopped && !_salesTable.InterCompanyOrder)
            {
                // Order is complete, price/discount should be locked.
                // For intercompany orders, even the call center enables order completion, there won't be a complete function.
                // Cites from order's team:
                //   Intercompany orders are not controlled because these orders are automatically processed based on the ‘other’ order, 
                //   created in the other company, and completion will only work using the UI, the order might change because another is changed, 
                //   and in this case, the amounts might change, breaking our premise that a call center order must be fully paid at all times.
                ret = true;
            }
            else
            {
                // If the line is either partially invoiced or fully invoiced, price/discount should be locked.
                // Using SalesStatus as the first check so that fully invoiced stocked & non-stocked items are removed from the calculation
                // (fulfillment status only works on stocked products).
                // For stocked products, check fulfillment status for partially invoiced orders.
                if (_salesLine.SalesStatus == SalesStatus::Invoiced ||
                    _retailSalesLine.FulfillmentStatus == RetailFulfillmentLineStatus::PartiallyInvoiced)
                {
                    ret = true;
                }
                else if (_salesLine.SalesStatus == SalesStatus::Canceled)
                {
                    ret = true;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesQuotationPriceLocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether or not price/discount is considered locked for a sales quotation line.
    /// </summary>
    /// <param name = "_retailSalesQuotationLine">A RetailSalesQuotationLine record.</param>
    /// <returns>true if price/discount is considered locked; otherwise, false.</returns>
    internal static boolean isSalesQuotationPriceLocked(RetailSalesQuotationLine _retailSalesQuotationLine)
    {
        return _retailSalesQuotationLine.IsPriceLocked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPriceOverridden</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if price is overriden for a given line.
    /// </summary>
    /// <param name = "_salesLine">The SalesLine to be checked.</param>
    /// <returns>true if price is overriden, otherwise false.</returns>
    /// <remarks>
    /// Returns true if:
    ///  - the price is manually overriden, when price override is enabled
    ///  - the price is overriden on continuity order, if price is set then system must honor it
    /// </remarks>
    public static boolean isPriceOverridden(SalesPurchLine _salesLine)
    {
        boolean isPriceOverridden = false;

        // If SalesLine, isPriceOverridden is determined by MCRSalesLinePriceOverride, RetailSalesLine and policy.
        // If SalesLine is not saved yet, i.e., when RecId is 0, skip caching since there is no way to uniquely identify the line.
        if (_salesLine.TableId == tableNum(SalesLine) && _salesLine)
        {
            str mapKey = RetailPricingEngineHelperCache::generateKeyForSalesLineInMap(_salesLine);

            // If the mapKey exists in salesLineIsPriceOverriddenMap, get the value directly. 
            // Else, determine and store the result in salesLineIsPriceOverriddenMap.
            if (salesLineIsPriceOverriddenMap.exists(mapKey))
            {
                isPriceOverridden = salesLineIsPriceOverriddenMap.lookup(mapKey);
            }
            else
            {
                MCRSalesLinePriceOverride mcrSalesLinePriceOverride;
                select mcrSalesLinePriceOverride
                    where mcrSalesLinePriceOverride.SalesLine == _salesLine.RecId;

                RetailSalesLine retailSalesLine;
                select retailSalesLine
                    where retailSalesLine.SalesLine == _salesLine.RecId;

                isPriceOverridden = RetailPricingEngineHelperCache::isPriceOverriddenForSalesLine(_salesLine, mcrSalesLinePriceOverride, retailSalesLine);
                salesLineIsPriceOverriddenMap.insert(mapKey, isPriceOverridden);
            }
        }
        else // Else SalesQuotationLine, isPriceOverridden is determined by policy.
        {
            PriceDiscPolicyCheckPolicy checkPolicy;
            checkPolicy = PriceDiscPolicyCheckPolicy::newFromParm(_salesline);
            isPriceOverridden = checkPolicy.hasManualPolicyField(PriceDiscPolicyField::newPriceDiscResultsField(fieldNum(PriceDiscResultFields, Price)));
        }

        return isPriceOverridden;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateDeliverRemainder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if updating deliver remainder is allowed or not.
    /// * If order completion is enabled and the order is not complete, allow updates.
    /// * If order completion is enabled and the order is complete, don't allow any change.
    /// * If order completion is disabled, allow updates.
    /// </summary>
    /// <param name = "_salesLine">The Sales Line being updated.</param>
    /// <returns>true, if can be updated; otherwise, false.</returns>
    /// <remarks>This method should only be used on SalesLine records that are bound to a Form Data Source.</remarks>
    public static boolean canUpdateDeliverRemainder(SalesLine _salesLine)
    {
        FormDataSource callerDataSource = FormDataUtil::getFormDataSource(_salesLine);

        if (!callerDataSource)
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        SalesTable localSalesTable = _salesLine.salesTable();
            
        boolean canUpdateRemainder = false;
        boolean isOrderCompletionEnabled = RetailMCRChannelTable::mcrEnableOrderCompletion(localSalesTable);

        if (isOrderCompletionEnabled)
        {
            if (localSalesTable.MCROrderStopped)
            {
                // Order completion is enabled and the order is not complete, allow updates.
                canUpdateRemainder = true;
            }
            else
            {
                // Order completion is enabled and the order is complete, don't allow any update.
                canUpdateRemainder = false;
            }
        }
        else
        {
            // Order completion is disabled, allow updates.
            canUpdateRemainder = true;
        }

        return canUpdateRemainder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCrtDiscountLines</Name>
				<Source><![CDATA[
    private static void populateCrtDiscountLines(SalesLine _salesLine, CrtSalesLine _crtSalesLine)
    {
        CLRObject discountList = _crtSalesLine.DiscountLines;

        RetailSalesDiscountLine discountLine;

        while select discountLine
            where discountLine.InventTransId == _salesLine.InventTransId
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine crtDiscountLine = RetailPricingEngineHelper::getCrtDiscountLine(discountLine);

            discountList.Add(crtDiscountLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCrtDiscountLinesForSalesQuotation</Name>
				<Source><![CDATA[
    private static void populateCrtDiscountLinesForSalesQuotation(SalesQuotationLine _salesQuotationLine, CrtSalesLine _crtSalesLine)
    {
        CLRObject discountList = _crtSalesLine.DiscountLines;

        RetailSalesQuotationDiscountLine discountLine;

        while select discountLine
            where discountLine.InventTransId == _salesQuotationLine.InventTransId
        {
            Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine crtDiscountLine = RetailPricingEngineHelper::getCrtDiscountLine(discountLine);

            discountList.Add(crtDiscountLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrtDiscountLine</Name>
				<Source><![CDATA[
    protected static Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine getCrtDiscountLine(RetailSalesQuotesDiscountLineMap _discountLine)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine crtDiscountLine = new Microsoft.Dynamics.Commerce.Runtime.DataModel.DiscountLine();

        crtDiscountLine.EffectiveAmount = _discountLine.Amount;
        crtDiscountLine.DealPrice = _discountLine.DealPrice;
        crtDiscountLine.Amount = _discountLine.DiscountAmount;
        crtDiscountLine.Percentage = _discountLine.Percentage;
        crtDiscountLine.DiscountCode = _discountLine.DiscountCode;
        crtDiscountLine.DiscountLineTypeValue = _discountLine.DiscountOriginType;
        crtDiscountLine.CustomerDiscountTypeValue = _discountLine.CustomerDiscountType;
        crtDiscountLine.ManualDiscountTypeValue = _discountLine.ManualDiscountType;
        crtDiscountLine.BundleId = _discountLine.BundleId;
        crtDiscountLine.SavedEffectiveAmount = _discountLine.Amount;
        crtDiscountLine.OfferId = _discountLine.PeriodicDiscountOfferId;

        return crtDiscountLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCrtSalesAffiliationLoyaltyTier</Name>
				<Source><![CDATA[
    private static CrtSalesAffiliationLoyaltyTier getCrtSalesAffiliationLoyaltyTier(RetailSalesAffiliationMap _retailSalesAffiliation)
    {
        CrtSalesAffiliationLoyaltyTier crlSalesAffiliationLoyaltyTier = new CrtSalesAffiliationLoyaltyTier();
        crlSalesAffiliationLoyaltyTier.set_AffiliationId(_retailSalesAffiliation.Affiliation);
        crlSalesAffiliationLoyaltyTier.set_LoyaltyTierId(_retailSalesAffiliation.LoyaltyTier);

        // Here probe the AffiliationType by checking the LoyaltyTierId - affiliations don't have a LoyaltyTierId.
        // So we don't need to query db once more.
        if (_retailSalesAffiliation.LoyaltyTier)
        {
            crlSalesAffiliationLoyaltyTier.AffiliationType = CrtRetailAffiliationType::Loyalty;
        }
        else
        {
            crlSalesAffiliationLoyaltyTier.AffiliationType = CrtRetailAffiliationType::General;
        }
        return crlSalesAffiliationLoyaltyTier;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemQuantityOnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Given a sales line, find the total quantity with the same item Id across the sales order.
    /// </summary>
    /// <param name="_newSalesLine">
    /// The sales line as map to base tally on. May or may not already be persisted.
    /// </param>
    /// <returns>
    /// Quantity of the line's item across the order, including the new line.
    /// </returns>
    public static SalesQty getItemQuantityOnOrder(SalesPurchLine _newSalesLine)
    {
        SalesPurchLineInterface salesPurchLineInterface = _newSalesLine.salesPurchLineInterface();
        SalesPurchTable salesPurchTable;
        SalesLine salesLine;
        SalesQuotationLine salesQuotationLine;
        SalesQty salesQty;

        salesPurchTable = salesPurchLineInterface.salesPurchTable();

        // get sum for any other sales lines on the order
        if (_newSalesLine.TableId == tableNum(SalesLine))
        {
            select sum(SalesQty) from salesLine
                where salesLine.SalesId == salesPurchLineInterface.parmOrderId()
                    && salesLine.ItemId == salesPurchLineInterface.parmItemId()
                    && salesLine.RecId != _newSalesLine.RecId;

             salesQty = salesLine.SalesQty;
        }
        else
        {
            select sum(SalesQty) from salesQuotationLine
                where salesQuotationLine.QuotationId == salesPurchLineInterface.parmOrderId()
                    && salesQuotationLine.ItemId == salesPurchLineInterface.parmItemId()
                    && salesQuotationLine.RecId != _newSalesLine.RecId;

            salesQty = salesQuotationLine.SalesQty;
        }

        // return sum of existing and current line
        return salesQty + salesPurchLineInterface.parmQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProductVariant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a productVariant object from the Commerce Runtime from product information in AX.
    /// </summary>
    /// <param name="_variantId">
    /// Variant Id to convert to a Commerce Runtime productVariant object.
    /// </param>
    /// <param name="_itemId">
    /// Item Id to convert to a Commerce Runtime productVariant object.
    /// </param>
    /// <param name="_inventDimId">
    /// Invent Dim Id to convert to a Commerce Runtime productVariant object.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime productVariant object.
    /// </returns>
    public static Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant getProductVariant(RetailValidationId _variantId,
                                                                                                 ItemId _itemId,
                                                                                                 InventDimId    _inventDimId)
    {
        Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant    productVariant;
        InventDim inventDim = InventDim::find(_inventDimId);

        productVariant = Microsoft.Dynamics.Commerce.Runtime.DataModel.ProductVariant::CreateVariant(
            inventDim.InventColorId, inventDim.InventSizeId, inventDim.InventStyleId, inventDim.configId);

        productVariant.set_VariantId(_variantId);
        productVariant.set_ItemId(_itemId);
        productVariant.set_InventoryDimensionId(_inventDimId);
        productVariant.set_DistinctProductVariantId(InventDimCombination::findByInventDim(_itemId, inventDim).DistinctProductVariant);

        return productVariant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTransactionFromOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a SalesTransaction object from the Commerce Runtime from the
    ///  SalesTable AX table record. Includes any sales lines on the order.
    /// </summary>
    /// <param name="_salesTable">
    /// The SalesTable record to convert to a Commerce Runtime SalesTransaction object.
    /// </param>
    /// <param name="_newSalesLine">
    /// Optional. New line created in form but not yet saved to DB, so we can pass them here if they need to be considered part of the order.
    /// </param>
    /// <param name="_lineIdMap">
    /// This is actually part of return. It fills map of CRT lineId to AX SalesLine inventTransId.
    /// Not really optional, but made so for FPK backward-compatibility.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime SalesTransaction object.
    /// </returns>
    public static CrtSalesTransaction getSalesTransactionFromOrder(
        SalesPurchTable _salesTable,
        SalesPurchLine _newSalesLine = null,
        Map _lineIdMap = new Map(Types::String, Types::String))
    {
        return RetailPricingEngineHelper::getSalesTransactionFromOrderBasedOnDateType(
            _salesTable, _newSalesLine, _lineIdMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTransactionFromOrderBasedOnDateType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a SalesTransaction object from the Commerce Runtime from the
    ///  SalesTable AX table record. Includes any sales lines on the order.
    /// </summary>
    /// <param name="_salesTable">
    /// The SalesTable record to convert to a Commerce Runtime SalesTransaction object.
    /// </param>
    /// <param name="_newSalesLine">
    /// Optional. When not null, the data in this buffer will be included in order to calculate.
    /// This is because the insert/update in the buffer may not be saved to DB yet, so need to pass the buffer to accurate calculation.
    /// A whole order calculation can leave this as null since all order lines will be read from DB.
    /// </param>
    /// <param name="_lineIdMap">
    /// This is actually part of return. It fills map of CRT lineId to AX SalesLine inventTransId.
    /// Not really optional, but made so for FPK backward-compatibility.
    /// </param>
    /// <param name="_dateType">
    /// Date type.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime SalesTransaction object.
    /// </returns>
    /// <remarks>
    /// When retailParameters.EnableDelayedPriceAndDiscountCalculation is enabled,
    /// this will create CRT sales transation object with only the current line.
    /// </remarks>
    public static CrtSalesTransaction getSalesTransactionFromOrderBasedOnDateType(
        SalesPurchTable _salesTable,
        SalesPurchLine _newSalesLine = null,
        Map _lineIdMap = new Map(Types::String, Types::String),
        SalesPriceDateType _dateType = SalesPriceDateType::Today)
    {
        using(var t = RetailPricingInstrumentationSegment::construct(
            classstr(RetailPricingEngineHelper), staticMethodStr(RetailPricingEngineHelper, getSalesTransactionFromOrder)))
        {
            Set salesLineSet = new Set(Types::String);

            try
            {
                return RetailPricingEngineHelper::getSalesTransactionFromOrderInternalBasedOnDateType(
                    _salesTable,
                    _newSalesLine,
                    _lineIdMap,
                    salesLineSet,
                    t,
                    _dateType);
            }
            finally
            {
                RetailPricingEngineHelperCache::removeFromSalesLineMap(salesLineIsPriceOverriddenMap, salesLineSet);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTransactionFromOrderInternalBasedOnDateType</Name>
				<Source><![CDATA[
    private static CrtSalesTransaction getSalesTransactionFromOrderInternalBasedOnDateType(
        SalesPurchTable _salesTable,
        SalesPurchLine _newSalesLine,
        Map _lineIdMap,
        Set _salesLineSet,
        RetailPricingInstrumentationSegment _logger,
        SalesPriceDateType _dateType = SalesPriceDateType::Today)
    {
        SalesPurchLine salesPurchLine;
        SalesLine salesLine;
        SalesQuotationLine salesQuotationLine;
        boolean isSalesOrder;
        SalesPurchTableInterface salesPurchTableInterface = _salesTable.salesPurchTableInterface();

        RetailSalesPurchTableMap retailSalesTable = salesPurchTableInterface.getRetailSalesPurchTable();
        CrtSalesTransaction salesTransaction;
        System.Guid transactionId;
        container discountCodes;
        int i, length;
        str code;
        System.Decimal localDecimal;

        RetailSalesLine retailSalesLineLocal;
        RetailSalesQuotationLine retailSalesQuotationLineLocal;

        RetailSalesPurchLineMap retailSalesPurchLineMapLocal;

        RetailSalesAffiliationMap retailSalesAffiliationMap;
        RetailSalesAffiliation retailSalesAffiliation;
        RetailSalesQuotationAffiliation retailSalesQuotationAffiliation;
        InventTableModule inventTableSales;
        CLRObject clrObjectSalesLines, clrObjectCoupons, clrSalesAffiliations;
        CrtSalesAffiliationLoyaltyTier crtSalesAffiliationLoyaltyTier;

        salesTransaction = new CrtSalesTransaction();
        transactionId = System.Guid::NewGuid();

        // find right buffer
        switch (retailSalesTable.TableId)
        {
            case tableNum(RetailSalesTable):
                RetailPricingEngineHelperCache::cacheIsPriceOverriddenForSalesLineInMap(
                    salesPurchTableInterface.parmOrderId(),
                    _newSalesLine,
                    salesLineIsPriceOverriddenMap,
                    _salesLineSet);

                salesPurchLine = salesLine;
                retailSalesPurchLineMapLocal = retailSalesLineLocal;
                retailSalesAffiliationMap = retailSalesAffiliation;
                isSalesOrder = true;
                _logger.addExtendedData(RetailPricingInstrumentationSegmentConstants::TableName, tableStr(SalesTable));
                _logger.addExtendedData(RetailPricingInstrumentationSegmentConstants::RecordId, int642Str(_salesTable.RecId));

                SalesTable localSalesTable = _salesTable;
                salesTransaction.set_SalesId(localSalesTable.SalesId);

                // Set sales agreement record id for sales order.
                if (localSalesTable.MatchingAgreement != 0)
                {
                    eventSource.EventWritePricingEngineCalculatePriceWithSalesAgreement(localSalesTable.RecId, localSalesTable.MatchingAgreement);
                    salesTransaction.set_SalesAgreementRecordId(localSalesTable.MatchingAgreement);
                }

                break;

            case tableNum(RetailSalesQuotationTable):
                salesPurchLine = salesQuotationLine;
                retailSalesPurchLineMapLocal = retailSalesQuotationLineLocal;
                retailSalesAffiliationMap = retailSalesQuotationAffiliation;
                _logger.addExtendedData(RetailPricingInstrumentationSegmentConstants::TableName, tableStr(SalesQuotationTable));
                _logger.addExtendedData(RetailPricingInstrumentationSegmentConstants::RecordId, int642Str(_salesTable.RecId));
                break;
        }

        SalesPurchLineInterface salesPurchLineInterface = salesPurchLine.salesPurchLineInterface();

        boolean isCurrentLineNull = RetailPricingEngineHelper::isEmptyLineBuffer(_newSalesLine);
        boolean isCurrentLineNotInserted = RetailPricingEngineHelper::isSalesLineBufferButNotInsertedToDb(
            _newSalesLine, salesPurchTableInterface.parmOrderId());

        // Is it an intercompany buffer?
        boolean isNewLineInterCompanyBuffer = false;
        InventTransId interCompanyBufferInventTransId = '';
        if (isCurrentLineNotInserted)
        {
            interCompanyBufferInventTransId = _newSalesLine.salesPurchLineInterface().parmInventTransId();
            isNewLineInterCompanyBuffer = interCompanyBufferInventTransId != '';
        }

        // need to loop over all sales order lines and create SalesLines on the transaction
        clrObjectSalesLines = salesTransaction.get_SalesLines();

        // If current line is null, then it is full order calculation regardless if delayed calculation is enabled.
        if (!isCurrentLineNull &&
            RetailParameters::find().EnableDelayedPriceAndDiscountCalculation)
        {
            // If the current line has been inserted into DB (but the buffer might contains updated values not committed yet),
            // Then only add the current line.
            if (!isCurrentLineNotInserted)
            {
                select firstonly salesPurchLine
                where salesPurchLine.SalesPurchId == salesPurchTableInterface.parmOrderId()
                    && salesPurchLine.RecId == _newSalesLine.RecId
                outer join retailSalesPurchLineMapLocal
                    where retailSalesPurchLineMapLocal.LineId == _newSalesLine.RecId;

                if (salesPurchLine &&
                !RetailPricingEngineHelper::shouldSkipCreateCRTRetailSalesLine(retailSalesTable, isNewLineInterCompanyBuffer, interCompanyBufferInventTransId, salesPurchLine))
                {
                    RetailPricingEngineHelper::createCrtSalesLineFromBufferAndAddToCrtTransaction(
                    clrObjectSalesLines,
                    _lineIdMap,
                    _newSalesLine,
                    _salesTable,
                    retailSalesTable,
                    _dateType,
                    true);
                }
            }
        }
        else
        {
            while select salesPurchLine
                where salesPurchLine.SalesPurchId == salesPurchTableInterface.parmOrderId()
                outer join retailSalesPurchLineMapLocal
                    where retailSalesPurchLineMapLocal.LineId == salesPurchLine.RecId
            {
                if (RetailPricingEngineHelper::shouldSkipCreateCRTRetailSalesLine(retailSalesTable, isNewLineInterCompanyBuffer, interCompanyBufferInventTransId, salesPurchLine))
                {
                    continue;
                }

                // if the salesline matches current salesLine, use the current buffer
                if (salesPurchLine.RecId == _newSalesLine.RecId)
                {
                    RetailPricingEngineHelper::createCrtSalesLineFromBufferAndAddToCrtTransaction(
                        clrObjectSalesLines,
                        _lineIdMap,
                        _newSalesLine,
                        _salesTable,
                        retailSalesTable,
                        _dateType,
                        true);
                }
                else
                {
                    RetailPricingEngineHelper::createCrtSalesLineFromBufferAndAddToCrtTransaction(
                        clrObjectSalesLines,
                        _lineIdMap,
                        salesPurchLine,
                        _salesTable,
                        retailSalesTable,
                        _dateType,
                        true);
                }
            }
            // End of looping through sales lines in the order.
        }

        // The new line is not yet insertd into DB so need to convert and add to the CRT sales transaction object.
        if (isCurrentLineNotInserted)
        {
            RetailPricingEngineHelper::createCrtSalesLineFromBufferAndAddToCrtTransaction(
                clrObjectSalesLines,
                _lineIdMap,
                _newSalesLine,
                _salesTable,
                retailSalesTable,
                _dateType,
                false);
        }

        // set transaction properties
        salesTransaction.set_Id(transactionId.ToString());
        salesTransaction.set_CustomerId(salesPurchTableInterface.parmOrderAccount());
        localDecimal = retailSalesTable.TotalManualDiscountAmount;
        salesTransaction.set_TotalManualDiscountAmount(localDecimal);
        localDecimal = retailSalesTable.TotalManualDiscountPercentage;
        salesTransaction.set_TotalManualDiscountPercentage(localDecimal);
        salesTransaction.set_ChannelId(retailSalesTable.RetailChannel);

        // add transaction discount codes
        discountCodes = retailSalesTable.DiscountCodes;
        length = conLen(discountCodes);
        clrObjectCoupons =salesTransaction.get_DiscountCodes();
        for (i = 1; i <= length; i++)
        {
            code = conPeek(discountCodes, i);
            clrObjectCoupons.Add(code);
        }

        clrSalesAffiliations = salesTransaction.get_AffiliationLoyaltyTierLines();

        while select retailSalesAffiliationMap
                where retailSalesAffiliationMap.Id == salesPurchTableInterface.parmOrderId()
        {
            crtSalesAffiliationLoyaltyTier = RetailPricingEngineHelper::getCrtSalesAffiliationLoyaltyTier(retailSalesAffiliationMap);
            clrSalesAffiliations.Add(crtSalesAffiliationLoyaltyTier);
        }

        // populate setting for resolving line/multiline TA discount conflicts
        RetailPricingEngineHelper::setTransactionLineDiscountMethod(salesTransaction);

        RetailPricingEngineHelper::SetCouponsForSalesOrder(salesTransaction, salesPurchTableInterface.parmOrderId());

        return salesTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipCreateCRTRetailSalesLine</Name>
				<Source><![CDATA[
    protected static boolean shouldSkipCreateCRTRetailSalesLine(
        RetailSalesPurchTableMap _retailSalesTable,
        boolean _isNewLineInterCompanyBuffer,
        InventTransId _interCompanyBufferInventTransId,
        SalesPurchLine _salesPurchLine)
    {
        // In the case of intercompany, the buffer without recId is used to update existing line in the other company,
        // so skip adding the existing line here since it contains the old value. The buffer will be added in code below.
        return _retailSalesTable.TableId == tableNum(RetailSalesTable)
            && _isNewLineInterCompanyBuffer
            && _interCompanyBufferInventTransId == _salesPurchLine.salesPurchLineInterface().parmInventTransId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTransactionFromOrderForShippingDiscounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a SalesTransaction object from the Commerce Runtime <c>SalesPurchTable</c> map for shipping discount calculation. 
    /// Includes any sales lines on the order.
    /// </summary>
    /// <param name="_salesTable">
    /// The SalesTable record to convert to a Commerce Runtime SalesTransaction object.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime SalesTransaction object.
    /// </returns>
    internal static CrtSalesTransaction getSalesTransactionFromOrderForShippingDiscounts(SalesPurchTable _salesTable)
    {
        SalesPurchLine salesPurchLine;
        boolean isSalesOrder;
        SalesPurchTableInterface salesPurchTableInterface = _salesTable.salesPurchTableInterface();

        RetailSalesPurchTableMap retailSalesTable = salesPurchTableInterface.getRetailSalesPurchTable();
        CrtSalesTransaction salesTransaction;
        System.Guid transactionId;

        RetailSalesPurchLineMap retailSalesPurchLineMapLocal;

        RetailSalesAffiliationMap retailSalesAffiliationMap;
        CLRObject clrObjectSalesLines, clrObjectCoupons, clrSalesAffiliations;
        CrtSalesAffiliationLoyaltyTier crtSalesAffiliationLoyaltyTier;

        salesTransaction = new CrtSalesTransaction();
        transactionId = System.Guid::NewGuid();

        // find right buffer
        switch (retailSalesTable.TableId)
        {
            case tableNum(RetailSalesTable):
                SalesLine salesLine;
                RetailSalesLine retailSalesLineLocal;
                RetailSalesAffiliation retailSalesAffiliation;

                salesPurchLine = salesLine;
                retailSalesPurchLineMapLocal = retailSalesLineLocal;
                retailSalesAffiliationMap = retailSalesAffiliation;
                isSalesOrder = true;
                break;

            case tableNum(RetailSalesQuotationTable):
                SalesQuotationLine salesQuotationLine;
                RetailSalesQuotationLine retailSalesQuotationLineLocal;
                RetailSalesQuotationAffiliation retailSalesQuotationAffiliation;

                salesPurchLine = salesQuotationLine;
                retailSalesPurchLineMapLocal = retailSalesQuotationLineLocal;
                retailSalesAffiliationMap = retailSalesQuotationAffiliation;
                break;
        }

        SalesPurchLineInterface salesPurchLineInterface = salesPurchLine.salesPurchLineInterface();

        // need to loop over all sales order lines and create SalesLines on the transaction
        clrObjectSalesLines = salesTransaction.get_SalesLines();
        while select salesPurchLine
            where salesPurchLine.SalesPurchId == salesPurchTableInterface.parmOrderId()
            outer join retailSalesPurchLineMapLocal
                where retailSalesPurchLineMapLocal.LineId == salesPurchLine.RecId
        {
            if (RetailPricingEngineHelper::shouldSkipCreateCRTRetailSalesLine(retailSalesTable, false, '', salesPurchLine))
            {
                continue;
            }

            CrtSalesLine crtSalesLine = RetailPricingEngineHelper::getCrtRetailSalesLine(
                salesPurchLine,
                retailSalesPurchLineMapLocal,
                InventTableModule::find(salesPurchLineInterface.parmItemId(), ModuleInventPurchSales::Sales).UnitId,
                _salesTable);

            crtSalesLine.set_Price(salesPurchLine.Price);
            crtSalesLine.set_UnitQuantity(salesPurchLine.PriceUnit);
            clrObjectSalesLines.Add(crtSalesLine);
        }

        // set transaction properties
        salesTransaction.set_Id(transactionId.ToString());
        salesTransaction.set_CustomerId(salesPurchTableInterface.parmOrderAccount());
        salesTransaction.set_ChannelId(retailSalesTable.RetailChannel);

        // add transaction discount codes
        container discountCodes = retailSalesTable.DiscountCodes;
        int length = conLen(discountCodes);
        clrObjectCoupons = salesTransaction.get_DiscountCodes();
        for (int i = 1; i <= length; i++)
        {
            str code = conPeek(discountCodes, i);
            clrObjectCoupons.Add(code);
        }

        clrSalesAffiliations = salesTransaction.get_AffiliationLoyaltyTierLines();

        while select retailSalesAffiliationMap
            where retailSalesAffiliationMap.Id == salesPurchTableInterface.parmOrderId()
        {
            crtSalesAffiliationLoyaltyTier = RetailPricingEngineHelper::getCrtSalesAffiliationLoyaltyTier(retailSalesAffiliationMap);
            clrSalesAffiliations.Add(crtSalesAffiliationLoyaltyTier);
        }

        RetailPricingEngineHelper::SetCouponsForSalesOrder(salesTransaction, salesPurchTableInterface.parmOrderId());

        return salesTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>SetCouponsForSalesOrder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set CRT coupons for sales order.
    /// </summary>
    /// <param name = "_crtSalesTransaction">The CRT sales transaction.</param>
    /// <param name = "_salesId">Sales id for the sales order</param>
    public static void SetCouponsForSalesOrder(CrtSalesTransaction _crtSalesTransaction, SalesIdBase _salesId)
    {

        CLRObject couponCollection = RetailPricingEngineHelper::CreateCRTCoupons(_crtSalesTransaction);

        System.Type couponType = RetailPricingEngineHelper::getFirstGenericArgumentType(couponCollection);

        if (couponType)
        {
            PropertyInfo discountOfferIdPropertyInfo = couponType.GetProperty(discountOfferIdProperty);
            PropertyInfo codePropertyInfo = couponType.GetProperty(discountCodeProperty);
        
            if (discountOfferIdPropertyInfo && codePropertyInfo)
            {
                RetailCouponUsage retailCouponUsage;
                RetailCouponCodeTable retailCouponCodeTable;
                RetailCoupon retailCoupon;

                while select * from retailCouponUsage
                    where retailCouponUsage.SalesId == _salesId
                join * from retailCouponCodeTable
                    where retailCouponCodeTable.CouponCodeId == retailCouponUsage.CouponCodeId
                join * from retailCoupon
                    where retailCoupon.CouponNumber == retailCouponCodeTable.CouponNumber
                {
                    SalesTable salesTable = SalesTable::find(_salesId);
                    RetailSalesTable retailSalesTable = RetailSalesTable::findSalesTable(salesTable);
                    
                    if(!RetailCouponHelper::hasChannel(retailSalesTable.RetailChannel))
                    {
                        throw error("@Retail:CouponChannelNotFound");
                    }

                    // Add coupon to list if valid.
                    if (RetailCouponHelper::validateCoupon(retailCouponCodeTable, retailSalesTable.RetailChannel)
                        && RetailCouponHelper::ValidateCouponLimits(retailCouponCodeTable.CouponCodeId, _crtSalesTransaction.SalesId, _crtSalesTransaction.CustomerId, _salesId))
                    {
                        CLRObject coupon = System.Activator::CreateInstance(couponType);
                        discountOfferIdPropertyInfo.SetValue(coupon, retailCoupon.DiscountOfferId);
                        codePropertyInfo.SetValue(coupon, retailCouponCodeTable.CouponCode);
                        couponCollection.Add(coupon);
                    }
                }
            }
            else
            {
                throw error("@Retail:CouponsCreationError");
            }
        }
        else
        {
            throw error("@Retail:CouponsCreationError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>SetCouponsForPriceSimulator</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set CRT coupons for sales order.
    /// </summary>
    /// <param name = "_crtSalesTransaction">The CRT sales transaction.</param>
    /// <param name = "_simulationTransactionId">Transaction id for the price simulation.</param>
    public static void SetCouponsForPriceSimulator(CrtSalesTransaction _crtSalesTransaction, RefRecId _simulationTransactionId)
    {
        RetailPricingSimulatorSalesTransaction psTransaction;
        RetailPricingSimulatorDiscountCode  psDiscountCodes;
        RetailCouponCodeTable               retailCouponCodeTable;
        RetailCoupon                        retailCoupon;

        CLRObject couponCollection = RetailPricingEngineHelper::CreateCRTCoupons(_crtSalesTransaction);

        System.Type couponType = RetailPricingEngineHelper::getFirstGenericArgumentType(couponCollection);

        if (couponType)
        {
            PropertyInfo discountOfferIdPropertyInfo = couponType.GetProperty(discountOfferIdProperty);
            PropertyInfo codePropertyInfo = couponType.GetProperty(discountCodeProperty);
        
            if (discountOfferIdPropertyInfo && codePropertyInfo)
            {
                while select RetailPricingSimulatorSalesTransaction, RetailDiscountCode
                    from psDiscountCodes
                        where psDiscountCodes.RetailPricingSimulatorSalesTransaction == _simulationTransactionId
                    join retailCouponCodeTable
                        where retailCouponCodeTable.RecId == psDiscountCodes.RetailDiscountCode
                    join retailCoupon
                        where RetailCoupon.CouponNumber == retailCouponCodeTable.CouponNumber
                    join psTransaction
                        where psTransaction.RecId == _simulationTransactionId
                {
                    System.DateTimeOffset channelDateTime = RetailPricingEngineHelper::getSessionDateTimeInChannelTimeZone(psTransaction.RetailChannelTable, psTransaction.SimulationDateTime);
                    date checkDate = mkDate(channelDateTime.get_Day(), channelDateTime.get_Month(), channelDateTime.get_Year());

                    if (RetailCouponHelper::validateCoupon(retailCouponCodeTable, psTransaction.RetailChannelTable, checkDate))
                    {
                        CLRObject coupon = System.Activator::CreateInstance(couponType);
                        discountOfferIdPropertyInfo.SetValue(coupon, RetailCoupon.DiscountOfferId);
                        codePropertyInfo.SetValue(coupon, retailCouponCodeTable.CouponCode);
                        couponCollection.Add(coupon);
                    }
                }
            }
        }
        else
        {
            throw error("@Retail:CouponsCreationError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CreateCRTCoupons</Name>
				<Source><![CDATA[
    private static CLRObject CreateCRTCoupons(CrtSalesTransaction _crtSalesTransaction)
    {
        CLRObject coupons;
        PropertyInfo propertyInfo = _crtSalesTransaction.GetType().GetProperty(salesTransactionCouponsProperty);
        
        if (propertyInfo)
        {
            coupons = System.Activator::CreateInstance(propertyInfo.PropertyType);
            propertyInfo.SetValue(_crtSalesTransaction, coupons);
        }
        else
        {
            throw error("@Retail:CouponsCreationError");
        }

        return coupons;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstGenericArgumentType</Name>
				<Source><![CDATA[
    private static System.Type getFirstGenericArgumentType(CLRObject _genericCLRObject)
    {
        System.Type resultType;

        if (_genericCLRObject)
        {
            System.Type[] argumentTypes = _genericCLRObject.GetType().GetGenericArguments();

            if (argumentTypes && argumentTypes.Length > 0)
            {
                // Get the first generic argument for the collection.
                resultType = argumentTypes.GetValue(0);
            }
        }
        return resultType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitOfMeasureConversion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct a UnitOfMeasureConversion object from the Commerce Runtime from product information in AX.
    /// </summary>
    /// <param name="_itemId">
    /// Item Id to convert to a Commerce Runtime UnitOfMeasureConversion object.
    /// </param>
    /// <param name="_uomId">
    /// Unit Of Measure Symbol to convert to a Commerce Runtime UnitOfMeasureConversion object.
    /// </param>
    /// <param name="_uomConversion">
    /// Record in the <c>UnitOfMeasureConversion</c> table to convert to a Commerce Runtime UnitOfMeasureConversion object.
    /// </param>
    /// <param name="_isBackwardConversion">
    /// A flag indicating whether it's backward conversion.
    /// </param>
    /// <returns>
    /// The new Commerce Runtime UnitOfMeasureConversion object.
    /// </returns>
    public static CrtUnitOfMeasureConversion getUnitOfMeasureConversion(
        ItemId _itemId, UnitOfMeasureSymbol _uomId, UnitOfMeasureConversion _uomConversion, boolean _isBackwardConversion = false)
    {
        CrtUnitOfMeasureConversion unitOfMeasureConversion = new CrtUnitOfMeasureConversion();

        unitOfMeasureConversion.set_ItemId(_itemId);
        unitOfMeasureConversion.set_ToUnitOfMeasureSymbol(_uomId);
        unitOfMeasureConversion.set_Factor(_uomConversion.Factor);
        unitOfMeasureConversion.set_Denominator(_uomConversion.Denominator);
        unitOfMeasureConversion.set_Numerator(_uomConversion.Numerator);
        unitOfMeasureConversion.set_IsBackward(_isBackwardConversion);

        return unitOfMeasureConversion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionLineDiscountMethod</Name>
				<Source><![CDATA[
    private static void setTransactionLineDiscountMethod(CrtSalesTransaction _salesTransaction)
    {
        SalesParameters salesParameters;

        salesParameters = SalesParameters::find();

        switch (salesParameters.Disc)
        {
            case LineMultiLn::Linie:
                _salesTransaction.set_LineDiscountCalculationType(CrtLineDiscountCalculationType::Line);
                break;

            case LineMultiLn::MultiLn:
                _salesTransaction.set_LineDiscountCalculationType(CrtLineDiscountCalculationType::Multiline);
                break;

            case LineMultiLn::MinLineMultiLine:
                _salesTransaction.set_LineDiscountCalculationType(CrtLineDiscountCalculationType::MinLineMultiline);
                break;

            case LineMultiLn::MaxLineMultiLine:
                _salesTransaction.set_LineDiscountCalculationType(CrtLineDiscountCalculationType::MaxLineMultiline);
                break;

            case LineMultiLn::LinePlusMultiLn:
                _salesTransaction.set_LineDiscountCalculationType(CrtLineDiscountCalculationType::LinePlusMultiline);
                break;

            case LineMultiLn::LineTimesMultiLn:
                _salesTransaction.set_LineDiscountCalculationType(CrtLineDiscountCalculationType::LineMultiplyMultiline);
                break;

            default:
                // otherwise throw value out of range exception error
                throw error("@SYS27409");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSessionDateTimeInChannelTimeZone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the session date after applying channel time zone.
    /// </summary>
    /// <param name="_channelId">
    /// The Channel Id.
    /// </param>
    /// <param name="_sessionDateTime">
    /// The Session date time, default to system date time.
    /// </param>
    /// <returns>
    /// The CLR converted date time.
    /// </returns>
    /// <remarks>
    /// This function is called while creating retail sales order and retail sales quote.
    /// </remarks>
    public static System.DateTimeOffset getSessionDateTimeInChannelTimeZone(RecId _channelId, utcDateTime _sessionDateTime = DateTimeUtil::getSystemDateTime())
    {
        System.DateTime dateTime, dateTimeUtc;
        System.DateTimeOffset dateTimeOffsetUtc, dateTimeOffsetChannel;
        RetailChannelTable channel = RetailChannelTable::findByRecId(_channelId);
        
        dateTime = Global::utcDateTime2SystemDateTime(_sessionDateTime);
        dateTimeUtc = new System.DateTime(dateTime.get_Ticks(), System.DateTimeKind::Utc);

        dateTimeOffsetUtc = new System.DateTimeOffset(dateTimeUtc, System.TimeSpan::Zero);
        if (_channelId != 0)
        {
            dateTimeOffsetChannel =  System.TimeZoneInfo::ConvertTimeBySystemTimeZoneId(dateTimeOffsetUtc, channel.ChannelTimeZoneInfoId);
        }
        else
        {
            // Get the company timezone
            DataArea dataArea;
            select firstonly TimeZone from dataArea where dataArea.Id == curExt();

            dateTimeOffsetChannel = System.TimeZoneInfo::ConvertTimeBySystemTimeZoneId(
                dateTimeOffsetUtc, 
                DateTimeUtil::getTimeZoneId(dataArea.timeZone));
        }
        return dateTimeOffsetChannel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrtUnitOfMeasureConversion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update Crt SalesLine.UnitOfMeasureConversion.
    /// </summary>
    /// <param name="_crtSalesLine">
    /// Commerce Runtime SalesLine object.
    /// </param>
    /// <param name="_itemId">
    /// Item Id to convert to a Commerce Runtime UnitOfMeasureConversion object.
    /// </param>
    /// <param name="_salesUnitOfMeasure">
    /// Sales Unit Of Measure Symbol.
    /// </param>
    /// <param name="_defaultUnitOfMeasure">
    /// Default sales unit of measure symbol.
    /// </param>
    public static void updateCrtUnitOfMeasureConversion(
        CrtSalesLine _crtSalesLine,
        ItemId _itemId,
        UnitOfMeasureSymbol _salesUnitOfMeasure,
        UnitOfMeasureSymbol _defaultUnitOfMeasure)
    {
        RetailPricingUnitOfMeasureConversionHelper::updateCrtUnitOfMeasureConversion(_crtSalesLine, _itemId, _salesUnitOfMeasure, _defaultUnitOfMeasure);
    }

]]></Source>
			</Method>
			<Method>
				<Name>classHasProperty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify if the property exists in the object.
    /// </summary>
    /// <param name="_class">The object where the property should exist.</param>
    /// <param name="_propertyName">The name of the property</param>
    /// <returns>true if the property exists; otherwise, false.</returns>
    public static boolean classHasProperty(System.Type _class, str _propertyName)
    {
        System.Reflection.PropertyInfo propertyInfo = _class.GetProperty(_propertyName);
        
        if (propertyInfo != null)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getObjectPropertyIfExistsInClass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an CLRObject property if the property exists in the object.
    /// </summary>
    /// <param name="source">The object where the property should exist.</param>
    /// <param name="propertyName">The name of the property</param>
    /// <returns>The value of the property; otherwise, null.</returns>
    public static CLRObject getObjectPropertyIfExistsInClass(System.Object source, str propertyName)
    {
        System.Reflection.PropertyInfo propertyInfo = source.GetType().GetProperty(propertyName);
        
        if (propertyInfo != null)
        {
            return propertyInfo.GetValue(source);
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIntPropertyIfExistsInClass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets an integer property if the property exists in the object.
    /// </summary>
    /// <param name="source">The object where the property should exist.</param>
    /// <param name="propertyName">The name of the property</param>
    /// <returns>The value of the property, zero otherwise.</returns>
    public static int getIntPropertyIfExistsInClass(System.Object source, str propertyName)
    {
        System.Reflection.PropertyInfo propertyInfo = source.GetType().GetProperty(propertyName);
        
        if (propertyInfo != null)
        {
            return propertyInfo.GetValue(source);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBooleanPropertyIfExistsInClass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a boolean property if the property exists in the object.
    /// </summary>
    /// <param name="source">The object where the property should exist.</param>
    /// <param name="propertyName">The name of the property</param>
    /// <returns>The value of the property, false otherwise.</returns>
    public static boolean getBooleanPropertyIfExistsInClass(System.Object source, str propertyName)
    {
        System.Reflection.PropertyInfo propertyInfo = source.GetType().GetProperty(propertyName);
        
        if (propertyInfo != null)
        {
            return propertyInfo.GetValue(source);
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIntPropertyIfExistsInClass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a int property if the property exists in the object.
    /// </summary>
    /// <param name="target">The object where the property should exist.</param>
    /// <param name="propertyName">The name of the property.</param>
    /// <param name="propertyValue">Property value.</param>
    public static void setIntPropertyIfExistsInClass(System.Object target, str propertyName, int propertyValue)
    {
        System.Reflection.PropertyInfo propertyInfo = target.GetType().GetProperty(propertyName);
        
        if (propertyInfo != null)
        {
            propertyInfo.SetValue(target, propertyValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRealPropertyIfExistsInClass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a real property if the property exists in the object.
    /// </summary>
    /// <param name="target">The object where the property should exist.</param>
    /// <param name="propertyName">The name of the property.</param>
    /// <param name="propertyValue">Property value.</param>
    public static void setRealPropertyIfExistsInClass(System.Object target, str propertyName, real propertyValue)
    {
        System.Reflection.PropertyInfo propertyInfo = target.GetType().GetProperty(propertyName);
        
        if (propertyInfo != null)
        {
            propertyInfo.SetValue(target, propertyValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBooleanPropertyIfExistsInClass</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a boolean property if the property exists in the object.
    /// </summary>
    /// <param name="target">The object where the property should exist.</param>
    /// <param name="propertyName">The name of the property.</param>
    /// <param name="propertyValue">Property value.</param>
    public static void setBooleanPropertyIfExistsInClass(System.Object target, str propertyName, boolean propertyValue)
    {
        System.Reflection.PropertyInfo propertyInfo = target.GetType().GetProperty(propertyName);
        
        if (propertyInfo != null)
        {
            propertyInfo.SetValue(target, propertyValue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipPriceDiscCalcForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if the sales line should skip price and discount calculation.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales order line to check for retail pricing
    /// </param>
    /// <returns>
    /// True if the line should skip price and discount calculation. False, otherwise.
    /// </returns>
    internal static boolean shouldSkipPriceDiscCalcForLine(SalesPurchLine _salesLine)
    {
        if (_salesLine.TableId == tableNum(SalesLine))
        {
            SalesLine salesLine = _salesLine as SalesLine;
            return salesLine.SkipPriceDiscCalcInBulkCreation;
        }
        else if (_salesLine.TableId == tableNum(SalesQuotationLine))
        {
            SalesQuotationLine salesQuotationLine = _salesLine as SalesQuotationLine;
            return salesQuotationLine.SkipPriceDiscCalc;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCrtSalesLineFromBufferAndAddToCrtTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Crt SalesLine from SalesLine / SalesQuotationLine table buffer and add to given CRT transaction object.
    /// </summary>
    /// <param name = "_clrObjectSalesLines">Collection of CRT SalesLine.</param>
    /// <param name = "_lineIdMap">Line Id map to be updated.</param>
    /// <param name = "_lineBuffer">Buffer of the line to be created as CRT SalesLine.</param>
    /// <param name = "_salesTable">SalesTable buffer.</param>
    /// <param name = "_retailSalesTable">RetailSalesTable buffer.</param>
    /// <param name = "_dateType">Date type.</param>
    /// <param name = "_savedToDb">Whether the buffer has been saved to DB before.</param>
    private static void createCrtSalesLineFromBufferAndAddToCrtTransaction(
        CLRObject _clrObjectSalesLines,
        Map _lineIdMap,
        SalesPurchLine _lineBuffer,
        SalesPurchTable _salesTable,
        RetailSalesPurchTableMap _retailSalesTable,
        SalesPriceDateType _dateType,
        boolean _savedToDb)
    {
        SalesPurchLineInterface newSalesPurchLineInterface = _lineBuffer.salesPurchLineInterface();
        RetailSalesPurchLineMap retailSalesPurchLineMapLocal;
        CrtSalesLine crtSalesLine;

        if (_retailSalesTable.TableId == tableNum(RetailSalesTable))
        {
            SalesLine salesLineLocal = _lineBuffer;
            RetailSalesLine retailSalesLineLocal = salesLineLocal.retailSalesLine();
            retailSalesPurchLineMapLocal = retailSalesLineLocal;

            // This only needs to be triggered for line not yet saved to DB since this is supposed to be done for saved line already.
            if (!_savedToDb && !retailSalesPurchLineMapLocal.Catalog)
            {
                MCRSourceCodeSetup mcrSourceCodeSetup;

                if (!_lineBuffer || !newSalesPurchLineInterface.parmInventTransId())
                {
                    MCRSalesTable mcrSalesTable;
                    select SalesTable from mcrSalesTable
                    where mcrSalesTable.SalesTable == _salesTable.RecId
                        join Catalog from mcrSourceCodeSetup
                        where mcrSourceCodeSetup.SourceId == mcrSalesTable.SourceId;
                }

                retailSalesPurchLineMapLocal.Catalog = mcrSourceCodeSetup.Catalog;
            }

            crtSalesLine = RetailPricingEngineHelper::getCrtRetailSalesLineBasedOnDateType(
                salesLineLocal,
                retailSalesPurchLineMapLocal,
                InventTableModule::find(newSalesPurchLineInterface.parmItemId(), ModuleInventPurchSales::Sales).UnitId,
                _salesTable,
                _dateType);
        }
        else if (_retailSalesTable.TableId == tableNum(RetailSalesQuotationTable))
        {
            SalesQuotationLine salesQuotationLineLocal = _lineBuffer;
            RetailSalesQuotationLine retailSalesQuotationLineLocal = salesQuotationLineLocal.retailSalesQuotationLine();
            retailSalesPurchLineMapLocal = retailSalesQuotationLineLocal;

            // This only needs to be triggered for line not yet saved to DB since this is supposed to be done for saved line already.
            if (!_savedToDb && !retailSalesPurchLineMapLocal.Catalog)
            {
                MCRSourceCodeSetup mcrSourceCodeSetup;
                MCRSalesQuotationTable mcrSalesQuotationTable;

                if (!_lineBuffer || !newSalesPurchLineInterface.parmInventTransId())
                {
                    if (salesQuotationLineLocal.RecId)
                    {
                        select SalesQuotationTable from mcrSalesQuotationTable
                            where mcrSalesQuotationTable.SalesQuotationTable == _salesTable.RecId
                                join Catalog from mcrSourceCodeSetup
                                where mcrSourceCodeSetup.SourceId == mcrSalesQuotationTable.SourceId;
                    }
                }

                retailSalesPurchLineMapLocal.Catalog = mcrSourceCodeSetup.Catalog;
            }

            crtSalesLine = RetailPricingEngineHelper::getCrtRetailSalesLineBasedOnDateType(
                salesQuotationLineLocal,
                retailSalesPurchLineMapLocal,
                InventTableModule::find(newSalesPurchLineInterface.parmItemId(), ModuleInventPurchSales::Sales).UnitId,
                _salesTable,
                _dateType);
        }

        if (crtSalesLine != null)
        {
            _clrObjectSalesLines.Add(crtSalesLine);
            str lineId = crtSalesLine.get_LineId();
            _lineIdMap.insert(lineId, _lineBuffer.salesPurchLineInterface().parmInventTransId());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEmptyLineBuffer</Name>
				<Source><![CDATA[
    private static boolean isEmptyLineBuffer(SalesPurchLine _currentSalesLine)
    {
        boolean isSalesLineBufferWithEmptyOrderId =
            (_currentSalesLine.TableId == tableNum(SalesLine) || _currentSalesLine.TableId == tableNum(SalesQuotationLine)) &&
            _currentSalesLine.salesPurchLineInterface().parmOrderId() == '';
        boolean isNotSalesLineBuffer = _currentSalesLine.TableId != tableNum(SalesLine) && _currentSalesLine.TableId != tableNum(SalesQuotationLine);
        return _currentSalesLine.RecId == 0 &&
            (isSalesLineBufferWithEmptyOrderId || isNotSalesLineBuffer);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesLineBufferButNotInsertedToDb</Name>
				<Source><![CDATA[
    private static boolean isSalesLineBufferButNotInsertedToDb(SalesPurchLine _currentSalesLine, SalesId _currentOrderId)
    {
        return _currentSalesLine.RecId == 0 &&
            (_currentSalesLine.TableId == tableNum(SalesLine) || _currentSalesLine.TableId == tableNum(SalesQuotationLine)) &&
            _currentSalesLine.salesPurchLineInterface().parmOrderId() == _currentOrderId;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>