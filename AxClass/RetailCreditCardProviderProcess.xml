<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailCreditCardProviderProcess</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Retail = Microsoft.Dynamics.Retail;
using RetailConst = Microsoft.Dynamics.Retail.PaymentSDK.Portable.Constants;
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;

/// <summary>
/// The <c>RetailCreditCardProviderProcess</c> class implements credit card processing of POS and ECommerce channel payments.
/// </summary>
public class RetailCreditCardProviderProcess extends CreditCardProcess
{
    private CompanyInfo companyInfo;
    private CreditCardPreAuthorization creditCardPreAuthorization;
    private CreditCardProviderResult providerResult;

    // values from the current request, saved for use in processing the response
    private str cardTokenRequest;
    private CreditCardNumber creditCardNumber;

    private boolean isProcessSuccess;
    private str displayedMessage;
    private str responseMessage;

    private const str TaxTypeIdentifier = 'AlternateTax';

    private static CommerceHQEventSource eventWriter = CommerceHQEventSource::Log;

    internal CreditCardCust creditCardCust;

    #CreditCard

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkForAddressVerification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if AVS is needed.
    /// </summary>
    /// <returns>
    /// true if AVS is needed; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean checkForAddressVerification()
    {
        eventWriter.EventWritePaymentsSkippedAddressVerificationCheck(salesTable.RecId, mcrCustPaymTable.RecId, creditCardTrans.RecId);
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForCardVerificationValue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if CVV is needed.
    /// </summary>
    /// <returns>
    /// true if CVV is needed; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean checkForCardVerificationValue()
    {
        eventWriter.EventWritePaymentsSkippedCardVerificationCheck(salesTable.RecId, mcrCustPaymTable.RecId, creditCardTrans.RecId);
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static RetailCreditCardProviderProcess construct()
    {
        return new RetailCreditCardProviderProcess();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldConstructForRetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies whether an instance of <c>RetailCreditCardProviderProcess</c> should be initialized for a given order.
    /// </summary>
    /// <param name = "_operation">Card operation being performed.</param>
    /// <param name = "_record">The record to use to retrive the MCRCustPaymTable record.</param>
    /// <returns>True if order is a commerce payments feature enabled order; otherwise, false.</returns>
    [Hookable(false)]
    protected static boolean shouldConstructForRetail(CreditCardOperation _operation, Common _record)
    {
        boolean result = false;

        // Locate the MCR Cust Paym Table record if possible.
        MCRCustPaymTable mcrCustPaymTable = RetailCreditCardProviderProcess::getMcrCustPaymTableRecord(_record);
        boolean isCommercePaymentsFeatureEnabled = RetailCommercePaymentsFeatureExposure::IsEnabled();

        // Check if the sales order being processed was created under the Commerce payments feature flag.
        if (isCommercePaymentsFeatureEnabled && mcrCustPaymTable)
        {
            // Find associated salesTable.
            SalesTable salesTableRecord;
            select firstonly salesTableRecord where salesTableRecord.RecId == mcrCustPaymTable.RefRecId;

            // Find type of the channel where payment originated.
            RetailChannelTable retailChannelTable;
            select firstonly ChannelType from retailChannelTable where retailChannelTable.RecId == mcrCustPaymTable.Channel;

            RetailPaymentsType salesOrderPaymentType = salesTableRecord.retailSalesTable().PaymentsType;
            if (salesOrderPaymentType == RetailPaymentsType::Commerce
                    && (retailChannelTable.ChannelType == RetailChannelType::RetailStore
                        || retailChannelTable.ChannelType == RetailChannelType::OnlineStore
                        || retailChannelTable.ChannelType == RetailChannelType::SharePointOnlineStore))
            {
                eventWriter.EventWritePaymentsRetailCreditCardProviderProcessInitialized(
                    salesTableRecord.RecId,
                    enum2Str(_operation),
                    enum2Str(salesOrderPaymentType),
                    enum2Str(retailChannelTable.ChannelType),
                    mcrCustPaymTable.RecId);
                result = true;
            }
            else
            {
                eventWriter.EventWritePaymentsRetailCreditCardProviderProcessInitializationSkipped(
                    salesTableRecord.RecId,
                    enum2Str(_operation),
                    enum2Str(salesOrderPaymentType),
                    enum2Str(retailChannelTable.ChannelType),
                    mcrCustPaymTable.RecId);
            }
        }
        else
        {
            eventWriter.EventWritePaymentsRetailCreditCardProviderProcessInitializationSkippedDuetoFeatureRequirements(
                isCommercePaymentsFeatureEnabled,
                enum2Str(_operation),
                mcrCustPaymTable.RecId);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMcrCustPaymTableRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the mcrCustPaymTable record for a retail order, if possible.
    /// </summary>
    /// <param name = "_record">The record to use to retrive the MCRCustPaymTable record.</param>
    /// <returns>The McrCustPaymTable record, if available.</returns>
    private static MCRCustPaymTable getMcrCustPaymTableRecord(Common _record)
    {
        MCRCustPaymTable result;

        switch (_record.TableId)
        {
            case tableNum(CreditCardAuthTrans):
                CreditCardAuthTrans authTrans = _record;
                result = MCRCustPaymTable::findByRecID(authTrans.MCRPaymRecId);
                break;
            case tableNum(MCRCustPaymTable):
                result = _record;
                break;
            case tableNum(SalesTable):
                SalesTable salesTableRecord = _record;
                result = MCRCustPaymTable::findByRefRecIDRefTableID(salesTableRecord.RecId, tableNum(SalesTable));
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProcessResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a process response.
    /// </summary>
    /// <param name="_successDescriptionOverride">
    /// Transaction description on success.
    /// </param>
    /// <returns>
    /// true if the process executes successfully; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public boolean createProcessResponse(str _successDescriptionOverride = '')
    {
        CreditCardApprovalRejectReason description = strLen(_successDescriptionOverride) != 0 ? _successDescriptionOverride : this.getRejectionReason();

        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            CreditCard_ExtendedParameters creditCard_ExtendedParameters = CreditCard::extendedParameters;
            creditCard_ExtendedParameters.parmInitCreditCardAuthTrans_ProcessorErrorCode(firstErrorCode);
        }

        switch (this.parmOperation())
        {
            case CreditCardOperation::Authorize:
                CreditCard::recordAuthorization(providerResult,
                                            salesTable,
                                            0,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);

                if (RetailNonRecurringTokenFeatureExposure::isEnabled()
                    && mcrCustPaymTable.IsNonRecurring == NoYes::Yes
                    && this.processSucceed())
                {
                    var newCreditCardCust = CreditCard::createNonRecurringCreditCardFromAuthResponse(providerResult, mcrCustPaymTable.RecId, mcrCustPaymTable.CustAccount, this.parmCreditCardProcessor());
                    eventSource.EventWriteRetailNonRecurringTokenAuthorized(mcrCustPaymTable.RecId, newCreditCardCust.RecId, this.processSucceed());
                    RetailPaymentAccessTokenContext::instance().removeAccessCode(mcrCustPaymTable.RecId);
                }
                break;

            case CreditCardOperation::Reauthorize:
                CreditCard::recordReauthorization(providerResult,
                                            salesTable,
                                            this.parmCreditCardProcessor(),
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);
                break;

                break;
            case CreditCardOperation::CaptureAfterAuthorize:
                CreditCard::recordCapture(providerResult,
                                            salesTable,
                                            this.parmSalesInvoiceId(),
                                            0,
                                            false,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);
                break;
            case CreditCardOperation::AuthorizeAndCapture:
                CreditCard::recordCapture(providerResult,
                                            salesTable,
                                            this.parmSalesInvoiceId(),
                                            0,
                                            true,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);
                break;
            case CreditCardOperation::Refund:
                CreditCard::recordRefund(providerResult,
                                            salesTable,
                                            0,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);
                break;
            case CreditCardOperation::Void:
                CreditCard::recordVoid(providerResult,
                                            salesTable,
                                            0,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable);
                break;
            case CreditCardOperation::Balance:
                CreditCard::recordBalance(providerResult,
                                            salesTable,
                                            0,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable,
                                            this.paramRetailExternalGiftCard());
                break;
            case CreditCardOperation::Activation:
                CreditCard::recordActivation(providerResult,
                                            salesTable,
                                            0,
                                            this.processSucceed(),
                                            description,
                                            cardTokenRequest,
                                            true,
                                            mcrCustPaymTable,
                                            this.paramRetailExternalGiftCard());
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRejectionReason</Name>
				<Source><![CDATA[
    protected internal CreditCardApprovalRejectReason getRejectionReason()
    {
        CreditCardApprovalRejectReason reason = this.failedDescription();

        if (this.processSucceed())
        {
            if (salesTable)
            {
                reason = strFmt("@SYS327114", salesTable.SalesId);
            }
            else if (RetailMCRChannelTable::findForCurrentUser().MCREnableOrderCompletion)
            {
                if (custInvoiceTable)
                {
                    reason = strFmt("@MCR40436", custInvoiceTable.InvoiceId);
                }
                else if (ledgerJournalTrans)
                {
                    reason = strFmt("@MCR40415", ledgerJournalTrans.JournalNum, ledgerJournalTrans.LineNum);
                }
            }
        }

        return reason;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRequest</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected Retail.PaymentSDK.Portable.Request createRequest(CreditCardPaymentProperties _properties)
    {
        var request = new Retail.PaymentSDK.Portable.Request();

        request.set_Locale(currentUserLanguage());
        request.set_Properties(_properties.toArray());

        return request;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the tax detail for level 2 or 3.
    /// </summary>
    /// <param name="_id">
    /// A tax identifier.
    /// </param>
    /// <param name="_description">
    /// The description of the tax.
    /// </param>
    /// <param name="_rate">
    /// The tax rate.
    /// </param>
    /// <param name="_tax">
    /// The value of the tax.
    /// </param>
    /// <param name="_taxNum">
    /// The sequence number for a tax detail line.
    /// </param>
    /// <returns>
    /// A property.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperty createTaxDetail(str _id, str _description, TaxValue _rate, TaxAmountCur _tax, int _taxNum)
    {
        var taxProperties = CreditCardPaymentProperties::construct();
        str ns = RetailConst.GenericNamespace::get_TaxDetail();

        taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxTypeIdentifier(), _id));
        taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxDescription(), _description));
        if (_rate)
        {
            taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxRate(), _rate));
        }
        taxProperties.add(CreditCardPaymentProperty::newValue(ns, RetailConst.TaxDetailProperties::get_TaxAmount(), _tax));

        var taxDetail = CreditCardPaymentProperty::newName(RetailConst.GenericNamespace::get_TaxDetails(), this.NameAndSeq(RetailConst.TaxDetailProperties::get_TaxDetail(), _taxNum));
        taxDetail.parmPropertyListValue(taxProperties);

        return taxDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedDescription</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the detailed exception with the response message.
    /// </summary>
    /// <returns>
    ///    The detailed exception message that has the response message.
    /// </returns>
    [Hookable(false)]
    protected str failedDescription()
    {
        return this.processSucceed() ? '' : responseMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedDOLAPI</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a message identifying the API causing an error.
    /// </summary>
    /// <param name="_api">
    /// The name of the API.
    /// </param>
    /// <param name="_msg">
    /// An error message.
    /// </param>
    /// <returns>
    /// The formatted message.
    /// </returns>
    [Hookable(false)]
    protected str failedDOLAPI(str _api, str _msg)
    {
        return strFmt("@SYS329019", _api, _msg);
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedReason</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the user visible response message.
    /// </summary>
    /// <returns>
    ///    An message.
    /// </returns>
    [Hookable(false)]
    public str failedReason()
    {
        return displayedMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>failedStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the text of the failure description.
    /// </summary>
    /// <param name="_status">
    /// The reason for a failure.
    /// </param>
    /// <remarks>
    /// The text is only set if the process failed.
    /// </remarks>
    [Hookable(false)]
    public void failedStatus(str _status)
    {
        if (!this.processSucceed())
        {
            responseMessage = strFmt("@SYS327137", _status);
            displayedMessage = responseMessage;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReauthorizationRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties required for a reauthorization request.
    /// </summary>
    /// <returns>
    /// An instance of CreditCardPaymentProperties required for the reauthorization request.
    /// </returns>
    protected CreditCardPaymentProperties getReauthorizationRequest()
    {
        var props = this.getCardToken(creditCardTrans, false);
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        props = this.setTransactionalData(transNamespace, props);
        props.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));
        return props;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAuthRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties needed for an authorization request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getAuthRequest()
    {
        var properties = this.getCardToken(creditCardTrans, true);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }

        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        if (this.parmCardVerificationValue())
        {
            properties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_CardVerificationValue(), this.parmCardVerificationValue()));
        }

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCaptureRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties needed for a capture request.
    /// </summary>
    /// <param name="_properties">
    /// Properties from an authorization result to use in the request.
    /// </param>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getCaptureRequest(CreditCardPaymentProperties _properties)
    {
        var properties = CreditCardPaymentProperties::fromProperties(_properties.toArray());
        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCardToken</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the appropriate payment card properties.
    /// </summary>
    /// <param name="_creditCardAuthTrans">
    /// A <c>CreditCardAuthTrans</c> table record.
    /// </param>
    /// <param name="_useCard">
    /// Forces use of the card token from the <c>CreditCardCust</c> table.
    /// </param>
    /// <returns>
    /// The credit card properties.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getCardToken(CreditCardAuthTrans _creditCardAuthTrans, boolean _useCard)
    {
        str cardToken;
        CreditCardCust savedCreditCard;
        RetailPaymentAccessTokenArgs retailPaymentAccessTokenArgs;

        if (!creditCardNumber && _creditCardAuthTrans.CreditCardNumber)
        {
            creditCardNumber = _creditCardAuthTrans.CreditCardNumber;
        }

        // Always use the last card token from credit card history table if available
        if (_creditCardAuthTrans.CardTokenResult && !_useCard)
        {
            if (RetailNonRecurringTokenFeatureExposure::isEnabled()
                && mcrCustPaymTable
                && (this.parmOperation() == CreditCardOperation::Reauthorize
                || this.parmOperation() == CreditCardOperation::CaptureAfterAuthorize))
            {
                var latestRequthorization = CreditCardAuthTrans::findLatestReauthorization(mcrCustPaymTable.RecId);
                if (latestRequthorization.RecId)
                {
                    cardToken = latestRequthorization.CardTokenResult;
                }
                else
                {
                    cardToken = _creditCardAuthTrans.CardTokenResult;
                }
            }
            else
            {
                cardToken = _creditCardAuthTrans.CardTokenResult;
            }
        }
        else if (mcrCustPaymTable.RecId != 0
            && mcrCustPaymTable.PaymInfoRecId != 0
            && mcrCustPaymTable.PaymInfoTableId == tableNum(CreditCardCust))
        {
            savedCreditCard = creditCardCust::find(mcrCustPaymTable.PaymInfoRecId);
            cardToken = savedCreditCard.CardToken;

            if (!cardToken)
            {
                eventSource.EventWritePaymentsCardTokenNotFoundInCreditCardCust(mcrCustPaymTable.RecId, salesTable.RecId);
            }
        }
        else if (mcrCustPaymTable.RecId != 0
                && mcrCustPaymTable.IsNonRecurring == NoYes::Yes
                && RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
        {
            retailPaymentAccessTokenArgs = RetailPaymentAccessTokenContext::instance().getAccessCode(mcrCustPaymTable.RecId);
            cardToken = retailPaymentAccessTokenArgs.parmCardPropertiesXmlString();
        }
        else if (this.creditCardCust)
        {
            savedCreditCard = this.creditCardCust;
            cardToken = this.creditCardCust.CardToken;
        }

        if (savedCreditCard && savedCreditCard.TokenScope == RetailTokenScope::NonRecurring)
        {
            eventWriter.EventWriteNonRecurringTokenReuseAttempt(_creditCardAuthTrans.RecId, savedCreditCard.RecId);
            isProcessSuccess = false;
            this.displayedMessage = strFmt("@Retail:CannotReuseNonRecurringToken", salesTable.SalesId);
            this.responseMessage = this.displayedMessage;
        }

        CreditCardPaymentProperties properties;
        if (RetailNonRecurringTokenFeatureExposure::isEnabled()
            && this.parmOperation() == CreditCardOperation::Authorize
            && RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
        {
            properties = CreditCardPaymentProperties::fromXmlString(cardToken);
            properties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_TransactionData(), RetailConst.TransactionDataProperties::get_PaymentAcceptResultAccessCode(), retailPaymentAccessTokenArgs.parmAccessCode()));
        }
        else
        {
            properties = CreditCardPaymentProperties::fromXmlString(cardToken);
            var property = properties.find(RetailConst.GenericNamespace::get_PaymentCard(), RetailConst.PaymentCardProperties::get_Last4Digits());
            if (property && property.parmStringValue())
            {
                creditCardNumber = property.parmStringValue();
            }
        }

        this.updateGiftCardProperties(properties);

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getClrExceptionMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the exception message of the last exception thrown.
    /// </summary>
    /// <param name="_logException">
    /// True if last CLR exception should be logged in commerce event writer. Otherwise, false.
    /// </param>
    /// <returns>
    /// The text of the last thrown exception.
    /// </returns>
    private str getClrExceptionMessage(boolean _logException)
    {
        var perm = new InteropPermission(InteropKind::ClrInterop);
        perm.assert();

        str exceptionMessage;
        str innerExceptionType;
        str innerExceptionStackTrace;

        System.Exception exception = CLRInterop::getLastException();
        if (exception)
        {
            exceptionMessage = exception.get_Message();

            System.Exception innerException = exception.get_InnerException();
            if (innerException)
            {
                exceptionMessage = innerException.get_Message();
                innerExceptionType = innerException.GetType().ToString();
                innerExceptionStackTrace = innerException.StackTrace;
            }

            if (_logException)
            {
                eventWriter.EventWritePaymentProcessingException(exception.GetType().ToString(), exception.StackTrace, innerExceptionType, innerExceptionStackTrace);
            }
        }

        CodeAccessPermission::revertAssert();

        isProcessSuccess = false;

        return exceptionMessage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGiftCardProperties</Name>
				<Source><![CDATA[
    private void updateGiftCardProperties(CreditCardPaymentProperties _properties)
    {
        CreditCardPaymentProperties giftProperties;

        if (this.paramRetailExternalGiftCard())
        {
            if (mcrCustPaymTable.isExternalGiftCardPayment())
            {
                giftProperties = this.paramRetailExternalGiftCard().generateMCRPaymentCardRequest(mcrCustPaymTable);
            }
            else
            {
                CreditCardAccountSetup creditCardAccountSetup = CreditCardAccountSetup::find(this.paramRetailExternalGiftCard().ActivationProcessorsRecId);
                giftProperties = this.paramRetailExternalGiftCard().generatePaymentCardRequest(creditCardAccountSetup);
            }
        }

        if (giftProperties)
        {
            // Combine properties card token with external gift card
            var enumerator = giftProperties.enumerator();

            while (enumerator.moveNext())
            {
                CreditCardPaymentProperty giftProperty = enumerator.current();

                var singleProperty = _properties.find(giftProperty.parmNamespace(), giftProperty.parmName());
                if (singleProperty)
                {
                    // Found, update
                    switch (singleProperty.parmValueType())
                    {
                        case CreditCardPropertyDataType::DateTime:
                            singleProperty.parmDateTimeValue(giftProperty.parmDateTimeValue());
                            break;
                        case CreditCardPropertyDataType::Decimal:
                            singleProperty.parmDecimalValue(giftProperty.parmDecimalValue());
                            break;
                        case CreditCardPropertyDataType::String:
                            singleProperty.parmStringValue(giftProperty.parmStringValue());
                            break;
                        default:
                            break;
                    }
                }
                else
                {
                    // Not found
                    _properties.add(giftProperty);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMiscCharge</Name>
				<Source><![CDATA[
    private CreditCardPaymentProperty getMiscCharge(MarkupTrans _markupTrans)
    {
        CreditCardPaymentProperties miscChargeProperties = CreditCardPaymentProperties::construct();
        miscChargeProperties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_MiscellaneousCharge(), RetailConst.MiscellaneousChargeProperties::get_ChargeType(), _markupTrans.Txt));
        miscChargeProperties.add(CreditCardPaymentProperty::newValue(RetailConst.GenericNamespace::get_MiscellaneousCharge(), RetailConst.MiscellaneousChargeProperties::get_ChargeAmount(), _markupTrans.getCalculatedAmountRepresentable()));

        CreditCardPaymentProperty miscCharge = CreditCardPaymentProperty::newName(RetailConst.GenericNamespace::get_MiscellaneousCharge(), RetailConst.MiscellaneousChargeProperties::get_MiscellaneousCharge());
        miscCharge.parmPropertyListValue(miscChargeProperties);

        return miscCharge;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the payment connector by the passed connector name.
    /// </summary>
    /// <param name = "_connectorName">The connector name.</param>
    /// <returns>The payment connector, otherwise null.</returns>
    [Hookable(false)]
    protected Retail.PaymentSDK.Portable.IPaymentProcessor getProcessor(CreditCardConnectorName _connectorName)
    {
        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();

        Retail.PaymentSDK.Portable.IPaymentProcessor processor;
        System.Exception exception;

        eventWriter.EventWriteCreatePaymentProcessor(_connectorName);

        try
        {
            processor = new CreditCardPaymentProcessorFactory().getProcessor(_connectorName);
        }
        catch(Exception::CLRError)
        {
            isProcessSuccess = false;
            responseMessage = this.getClrExceptionMessage(true);
            displayedMessage = "@SYS116968";
        }
        catch(exception)
        {
            eventWriter.EventWritePaymentProcessingException(exception.GetType().ToString(), exception.StackTrace, '', '');
            isProcessSuccess = false;
            displayedMessage = "@SYS116968";
            if (!responseMessage)
            {
                responseMessage = displayedMessage;
            }
        }

        CodeAccessPermission::revertAssert();

        return processor;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRefundRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the properties needed for an refund request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getRefundRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);

        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }

        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoidRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the propeties needed for a void request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getVoidRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }

        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBalanceRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the propeties needed for a balance request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getBalanceRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }

        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getActivationRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the propeties needed for an activation request.
    /// </summary>
    /// <returns>
    /// The properties needed.
    /// </returns>
    [Hookable(false)]
    protected CreditCardPaymentProperties getActivationRequest()
    {
        var properties = this.getCardToken(creditCardTrans, false);
        if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
        {
            return properties;
        }

        var transNamespace = RetailConst.GenericNamespace::get_TransactionData();

        properties = this.setTransactionalData(transNamespace, properties);

        properties.add(CreditCardPaymentProperty::newValue(transNamespace, RetailConst.TransactionDataProperties::get_Amount(), this.parmTotalAmountCur()));

        return properties;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleAuthResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of an authorization operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleAuthResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Authorize');
        CreditCardProviderAuthorizationResult authResult = _response ? CreditCardProviderAuthorizationResult::constructFromResponse(_response) : null;

        providerResult = authResult;

        if (resultOK && authResult && authResult.parmAuthorizationResult() != CreditCardAuthorizationResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(authResult.parmAuthorizationResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleReauthorizationResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a reauthorize operation.
    /// </summary>
    /// <param name = "response">A response.</param>
    protected void handleReauthorizationResponse(Retail.PaymentSDK.Portable.Response response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(response, 'Reauthorize');
        CreditCardProviderReauthorizationResult reauthorizationResult = response ? CreditCardProviderReauthorizationResult::constructFromResponse(response) : null;
        providerResult = reauthorizationResult;

        if (resultOK && reauthorizationResult && reauthorizationResult.parmReauthorizationResult() != CreditCardAuthorizationResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(reauthorizationResult.parmReauthorizationResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleCaptureResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a capture operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    /// <param name="_authorization">
    /// An authorization.
    /// </param>
    [Hookable(false)]
    protected void handleCaptureResponse(Retail.PaymentSDK.Portable.Response _response, CreditCardAuthorization _authorization)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Capture');
        CreditCardProviderCaptureResult captureResult = _response ? CreditCardProviderCaptureResult::constructFromResponse(_response, this.parmTotalAmountCur(), _authorization) : null;

        providerResult = captureResult;

        if (resultOK && captureResult && captureResult.parmCaptureResult() != CreditCardCaptureResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(captureResult.parmCaptureResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRefundResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a refund operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleRefundResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Refund');
        CreditCardProviderRefundResult refundResult = _response ? CreditCardProviderRefundResult::constructFromResponse(_response, this.parmTotalAmountCur()) : null;

        providerResult = refundResult;

        if (resultOK && refundResult && refundResult.parmRefundResult() != CreditCardRefundResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(refundResult.parmRefundResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Setup the standard properties needed to request a credit card operation.
    /// </summary>
    /// <param name="_requestProperties">
    /// The request properties.
    /// </param>
    /// <returns>
    /// A connector name.
    /// </returns>
    [Hookable(false)]
    protected CreditCardConnectorName handleRequest(CreditCardPaymentProperties _requestProperties)
    {
        cardTokenRequest = _requestProperties.toXmlString();

        return CreditCard::addMerchantAccountProperties(_requestProperties);
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a credit card operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    /// <param name="_operation">
    /// Name of the operation.
    /// </param>
    /// <returns>
    /// true if the operation was successful.
    /// </returns>
    [Hookable(false)]
    protected CreditCardProviderResultOK handleResponse(Retail.PaymentSDK.Portable.Response _response, str _operation)
    {
        firstErrorCode = 0;
        CreditCardPaymentErrors errors = CreditCardPaymentErrors::fromPaymentErrors(_response.get_Errors());
        CreditCardProviderResultOK resultOK = true;

        if (errors.count() > 0)
        {
            isProcessSuccess = false;
            displayedMessage = "@SYS34720";
            responseMessage = this.failedDOLAPI(_operation, strReplace(errors.toString(), '\n', '; '));
            resultOK = false;
            firstErrorCode = errors.getError(1).parmCode();
        }

        RetailEventNotificationAction::CreditCardProcessCompletion(this.processSucceed(), errors, this.parmOperation(), _operation == 'Authorize', salesTable);

        return resultOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleVoidResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a void operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleVoidResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Void');
        CreditCardProviderVoidResult voidResult = _response ? CreditCardProviderVoidResult::constructFromResponse(_response) : null;

        providerResult = voidResult;

        if (resultOK && voidResult && voidResult.parmVoidResult() != CreditCardVoidResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(voidResult.parmVoidResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleBalanceResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a balance operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleBalanceResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Balance');
        CreditCardProviderBalanceResult balanceResult = _response ? CreditCardProviderBalanceResult::constructFromResponse(_response) : null;

        providerResult = balanceResult;

        if (resultOK && balanceResult && balanceResult.parmBalanceResult() != CreditCardBalanceResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(balanceResult.parmBalanceResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>handleActivationResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the results of a activation operation.
    /// </summary>
    /// <param name="_response">
    /// A response.
    /// </param>
    [Hookable(false)]
    protected void handleActivationResponse(Retail.PaymentSDK.Portable.Response _response)
    {
        CreditCardProviderResultOK resultOK = this.handleResponse(_response, 'Activation');
        CreditCardProviderActivationResult activationResult = _response ? CreditCardProviderActivationResult::constructFromResponse(_response) : null;

        providerResult = activationResult;

        if (resultOK && activationResult && activationResult.parmActivationResult() != CreditCardActivationResult::Success)
        {
            isProcessSuccess = false;
            this.failedStatus(enum2str(activationResult.parmActivationResult()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize internal state.
    /// </summary>
    /// <param name="_record">
    /// A record.
    /// </param>
    /// <exception cref="Exception::Error">
    /// The record is not related to a sales order using a credit card for payment.
    /// </exception>
    [Hookable(false)]
    protected void init(Common _record)
    {
        boolean skipcreditCardCustCheck = false;
        RetailExternalGiftCardTable retailExternalGiftCardTable;

        super(_record);

        if (mcrCustPaymTable.isExternalGiftCardPayment())
        {
            retailExternalGiftCardTable = RetailExternalGiftCardTable::findById(mcrCustPaymTable.PaymInfoRecId);
        }
        else if (mcrCustPaymTable)
        {
            creditCardCust = creditCardCust::find(mcrCustPaymTable.PaymInfoRecId);

            if (!creditCardCust)
            {
                // Credit card cust record does not exist, probably deleted, try and use creditCardTrans if exists
                creditCardTrans = CreditCardAuthTrans::mcrFindAvailablePreApproval(mcrCustPaymTable.RecId);

                if (creditCardTrans)
                {
                    skipcreditCardCustCheck = true;
                }

                if (!skipcreditCardCustCheck
                    && (mcrCustPaymTable.IsNonRecurring == NoYes::Yes
                    && this.parmOperation() == CreditCardOperation::Authorize))
                {
                    if (RetailPaymentAccessTokenContext::instance().accessCodeExists(mcrCustPaymTable.RecId))
                    {
                        skipcreditCardCustCheck = true;
                    }
                    else
                    {
                        throw error("@Retail:RetailNonRecurringTokenAuthorizationCodeMissing");
                    }
                }
            }
        }
        else if (creditCardTrans)
        {
            if (creditCardTrans.ApprovalType == CreditCardOperation::Activation)
            {
                skipcreditCardCustCheck = true;
            }
        }
        else if (salesTable && salesTable.CreditCardCustRefId)
        {
            creditCardCust = CreditCardCust::find(salesTable.CreditCardCustRefId);
        }

        if (!retailExternalGiftCardTable)
        {
            if (!creditCardCust && !skipcreditCardCustCheck)
            {
                SalesId salesId = mcrCustPaymTable.RecId ? mcrCustPaymTable.displaySalesId() : salesTable.SalesId;
 
                if (salesId)
                {
                    throw error(strFmt("@Retail:RetailCreditCardNotFoundForSalesOrder", salesId));
                }
                else
                {
                    throw error(Error::wrongUseOfFunction(funcName()));
                }
            }

            if (creditCardTrans && creditCardTrans.CreditCardNumber)
            {
                creditCardNumber = creditCardTrans.CreditCardNumber;
            }
            else
            {
                if (!salesTable.mcrIsCallCenter() || salesTable.CreditCardCustRefId )
                {
                    creditCardNumber = CreditCardCust::find(salesTable.CreditCardCustRefId).CardNumber;
                }
                else
                {
                    creditCardNumber = CreditCardCust::find(mcrCustPaymTable.PaymInfoRecId).CardNumber;
                }
            }
        }

        this.initializeCommonProperties();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initActivation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void initActivation(SalesTable _salesTable, RetailExternalGiftCard _retailExternalGiftCard)
    {
        super(_salesTable, _retailExternalGiftCard);

        this.initializeCommonProperties();
    }

]]></Source>
			</Method>
			<Method>
				<Name>NameAndSeq</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected str NameAndSeq(str _name, int _seq)
    {
        return _name + int2str(_seq);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();

        try
        {
            Retail.SDKManager.Portable.PaymentProcessorManager::LoadAllAssemblies(CreditCardConnectorSetup::getConnectorsDirectories());
        }
        catch (Exception::CLRError)
        {
            isProcessSuccess = false;
            responseMessage = this.getClrExceptionMessage(true);
            displayedMessage = "@SYP4910242" + " " + responseMessage;
            error(displayedMessage);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditCardProcessor</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CreditCardProcessorsId parmCreditCardProcessor()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareSubmission</Name>
				<Source><![CDATA[
    /// <summary>
    /// Establishes the connection to the processor.
    /// </summary>
    /// <returns>
    /// true if successful.
    /// </returns>
    [Hookable(false)]
    public boolean prepareSubmission()
    {
        return this.processSucceed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSucceed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reports the overall success of the credit card operation.
    /// </summary>
    /// <returns>
    /// true if the operation is successful.
    /// </returns>
    [Hookable(false)]
    public boolean processSucceed()
    {
        return isProcessSuccess;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCommonProperties</Name>
				<Source><![CDATA[
    internal void initializeCommonProperties()
    {
        companyInfo = CompanyInfo::find();
        creditCardPreAuthorization = CustParameters::find().CreditCardPreAuthorization;
        isProcessSuccess = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPaymentProperty</Name>
				<Source><![CDATA[
    private void addPaymentProperty(System.String _dataLevel, CreditCardPaymentProperties _properties, str _name, anytype _value)
    {
        if (_value)
        {
            _properties.add(CreditCardPaymentProperty::newValue(_dataLevel, _name, _value));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>submit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the actual credit card operation.
    /// </summary>
    /// <returns>
    /// true on success.
    /// </returns>
    [Hookable(false)]
    public boolean submit()
    {
        void processAuthorize()
        {
            CreditCardPaymentProperties properties = this.getAuthRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleAuthResponse(processor.Authorize(this.createRequest(properties), null));
        }

        void processCapture(CreditCardPaymentProperties _properties, CreditCardAuthorization _authorization)
        {
            CreditCardPaymentProperties properties = this.getCaptureRequest(_properties);
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleCaptureResponse(processor.Capture(this.createRequest(properties)), _authorization);
        }

        void processRefund()
        {
            CreditCardPaymentProperties properties;
            Retail.PaymentSDK.Portable.IPaymentProcessor processor;

            if (!creditCardTrans && mcrCustPaymTable && !mcrCustPaymTable.allowAlternatePaymentMethod())
            {
                isProcessSuccess = false;
                responseMessage = "@SYS327119";
            }
            else if (!CreditCard::sameCard(salesTable, creditCardTrans) && mcrCustPaymTable && !mcrCustPaymTable.allowAlternatePaymentMethod())
            {
                isProcessSuccess = false;
                responseMessage = "@SYS327136"; // Credit card refunds can be processed only for the same card as the original sales order.
                displayedMessage = responseMessage;
            }
            else
            {
                properties = this.getRefundRequest();
                if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
                {
                    return;
                }
                
                processor = this.getProcessor(this.handleRequest(properties));

                this.handleRefundResponse(processor.Refund(this.createRequest(properties), null));
            }
        }

        void processVoid()
        {
            CreditCardPaymentProperties properties = this.getVoidRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleVoidResponse(processor.Void(this.createRequest(properties)));
        }

        void processBalance()
        {
            CreditCardPaymentProperties properties = this.getBalanceRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleBalanceResponse(processor.BalanceOnGiftCard(this.createRequest(properties), null));
        }

        void processActivation()
        {
            CreditCardPaymentProperties properties = this.getActivationRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }
            
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(this.handleRequest(properties));

            this.handleActivationResponse(processor.ActivateGiftCard(this.createRequest(properties), null));
        }

        void processReauthorize()
        {
            // get request properties for reauthorization e.g. this.getReauthorizationRequest()
            CreditCardPaymentProperties properties = this.getReauthorizationRequest();
            if (!this.processSucceed() && RetailNonRecurringTokenFeatureExposure::isEnabled())
            {
                return;
            }

            // get the connector name e.g. this.handleRequest()
            CreditCardConnectorName connectorName = this.handleRequest(properties);

            // get the IPaymentProcessor instance e.g. this.getProcessor()
            Retail.PaymentSDK.Portable.IPaymentProcessor processor = this.getProcessor(connectorName);

            // create the request using properties e.g. this.createRequest()
            Retail.PaymentSDK.Portable.Request request = this.createRequest(properties);

            // call the /Reauthorize SDK method e.g. processor.Reauthorize()
            Retail.PaymentSDK.Portable.Response response = processor.Reauthorize(request, null);

            // handle the reauthorization response e.g. this.handleReauthorizationResponse()
            this.handleReauthorizationResponse(response);
        }

        if (this.parmOperation() != CreditCardOperation::Refund && this.parmTotalAmountCur() < 0)
        {
            isProcessSuccess = false;
            responseMessage = "@SYS327120";
            return true;
        }

        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);
        System.Exception exception;

        eventWriter.EventWritePaymentOperationProcessingStart(enum2Str(this.parmOperation()), salesTable.RecId, mcrCustPaymTable.RecId, creditCardTrans.RecId, creditCardCust.RecId);

        perm.assert();

        try
        {
            switch (this.parmOperation())
            {
                case CreditCardOperation::Authorize:
                    processAuthorize();
                    break;
                case CreditCardOperation::CaptureAfterAuthorize:
                    var properties = this.getCardToken(creditCardTrans, false);

                    //we are checking the non-recurring token flight since we did not check processSucceed before
                    if (this.processSucceed() || !RetailNonRecurringTokenFeatureExposure::isEnabled())
                    {
                        processCapture(properties, creditCardTrans.Authorization);
                    }
                    break;
                case CreditCardOperation::Refund:
                    processRefund();
                    break;
                case CreditCardOperation::Void:
                    processVoid();
                    break;
                case CreditCardOperation::AuthorizeAndCapture:
                    processAuthorize();
                    if (this.processSucceed())
                    {
                        this.recordAuthorizationForIncrementalCapture();
                        processCapture(providerResult.parmProperties(), providerResult.parmAuthorization());
                    }
                    break;
                case CreditCardOperation::Balance:
                    processBalance();
                    break;
                case CreditCardOperation::Activation:
                    processActivation();
                    break;
                case CreditCardOperation::Reauthorize:
                    processReauthorize();
                    break;
                default:
                    isProcessSuccess = false;
                    responseMessage = strFmt("@SYS122465", this.parmOperation()); // "Current version doesn't handle credit card '%1'."
                    break;
            }
        }
        catch(Exception::CLRError)
        {
            isProcessSuccess = false;
            responseMessage = this.getClrExceptionMessage(true);
            displayedMessage = "@SYS116968";
        }
        catch(exception)
        {
            eventWriter.EventWritePaymentProcessingException(exception.GetType().ToString(), exception.StackTrace, '', '');
            isProcessSuccess = false;
            displayedMessage = "@SYS34720";
            if (!responseMessage)
            {
                responseMessage = displayedMessage;
            }
        }

        CodeAccessPermission::revertAssert();

        eventWriter.EventWritePaymentOperationProcessingEnd(enum2Str(this.parmOperation()), this.processSucceed());

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>recordAuthorizationForIncrementalCapture</Name>
				<Source><![CDATA[
    private void recordAuthorizationForIncrementalCapture()
    {
        if (RetailIncrementalCaptureFeatureExposure::isEnabled())
        {
            // need to record authorization in CreditCardAuthTran
            this.parmOperation(CreditCardOperation::Authorize);
            // Do not have access to description so empty string will use default description.
            this.createProcessResponse('');

            // Now process capture, with its own tracking id.
            this.parmMCRPaymentTrackingId(this.getMCRPaymentTrackingId());
            // Originally was using CaptureAfterAuthorize but this might impact customization.
            this.parmOperation(CreditCardOperation::AuthorizeAndCapture);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFailedDescription</Name>
				<Source><![CDATA[
    private void updateFailedDescription(RefRecId _creditCardAuthTransRecId, str _additionalDescription)
    {
        if (_additionalDescription)
        {
            ttsbegin;

            CreditCardAuthTrans ccAuthTransUpdate = CreditCardAuthTrans::find(_creditCardAuthTransRecId, true);
            ccAuthTransUpdate.Description += ' ' + _additionalDescription;
            ccAuthTransUpdate.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the sales table.
    /// </summary>
    /// <returns>
    ///    true if the sales table is updated successfully; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public boolean updateSalesTable()
    {
        return CreditCard::updateSalesTable(salesTable.RecId, providerResult, this.processSucceed());
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check AVS and CVV values if needed.
    /// </summary>
    /// <returns>
    /// true if successful.
    /// </returns>
    [Hookable(false)]
    protected boolean validateTransaction()
    {
        InteropPermission perm = new InteropPermission(InteropKind::ClrInterop);

        perm.assert();

        CodeAccessPermission::revertAssert();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsoCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Convert an AX currency code to an ISO currency code.
    /// </summary>
    /// <param name="_currencyCode">
    /// A currency code.
    /// </param>
    /// <returns>
    /// An ISO currency code.
    /// </returns>
    [Hookable(false)]
    public static CurrencyCodeISO getIsoCurrency(CurrencyCode _currencyCode)
    {
        return (select CurrencyCodeISO from currency where currency.CurrencyCode == _currencyCode).CurrencyCodeISO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    /// Carries out all steps that are necessary to complete a credit card operation.
    /// Short circuits and returns a success if the total amount is zero and we have chosen to skip processing for zero amounts.
    /// </summary>
    /// <param name="_showSuccessMessage">
    ///    A Boolean value that specifies whether to display a message upon successful completion of the
    ///    operation.
    /// </param>
    /// <param name="_successDescriptionOverride">
    ///    A description that is logged for successful completion.
    /// </param>
    /// <returns>
    ///    true if the operation completed successfully; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public boolean process(boolean _showSuccessMessage = true, str _successDescriptionOverride = '')
    {
        if (this.parmTotalAmountCur() == 0 && this.operation != CreditCardOperation::Activation && this.operation != CreditCardOperation::Balance)
        {
            return true;
        }

        return super(_showSuccessMessage, _successDescriptionOverride);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionalData</Name>
				<Source><![CDATA[
    private CreditCardPaymentProperties setTransactionalData(str _transNamespace, CreditCardPaymentProperties _properties)
    {
        CustAccount invoiceAccount;
        CurrencyCode currencyCodeLocal;
        Num transactionId;

        if (salesTable)
        {
            invoiceAccount = salesTable.CustAccount;
            currencyCodeLocal = salesTable.CurrencyCode;
            transactionId = salesTable.SalesId;
        }

        if (this.parmMCRPaymentTrackingId() != '')
        {
            _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_PaymentTrackingId(), this.parmMCRPaymentTrackingId()));
        }

        if (this.parmAdjustAuthorizationAmount() != 0)
        {
            _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_IncrementalOffsetAmount(), this.parmAdjustAuthorizationAmount()));
        }

        if (this.parmIncrementalOffsetReference() != '')
        {
            _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_IncrementalOffsetReference(), this.parmIncrementalOffsetReference()));
        }

        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_CurrencyCode(), CreditCardProviderProcess::getIsoCurrency(currencyCodeLocal)));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_Description(), xInfo::productName()));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_ExternalCustomerId(), invoiceAccount));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_ExternalInvoiceNumber(), transactionId));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_ExternalReferenceId(), CreditCardPaymentProperty::clrString2Str(System.Guid::NewGuid().ToString())));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::get_SupportCardTokenization(), 'true'));
        _properties.add(CreditCardPaymentProperty::newValue(_transNamespace, RetailConst.TransactionDataProperties::IndustryType, enum2Str(Retail.PaymentSDK.Portable.IndustryType::DirectMarketing)));

        return _properties;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>