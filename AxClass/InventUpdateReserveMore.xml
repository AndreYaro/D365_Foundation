<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpdateReserveMore</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventUpdateReserveMore</c> handles the inventory update reserve more logic.
/// </summary>
public class InventUpdateReserveMore
{
    #ISOCountryRegionCodes

    protected InventMovement                    movement;
    protected InventUpd_Reservation             inventUpdate;
    protected InventUpdateReserveMoreParameters parameters;
    protected Query                             querySum;
    protected Query                             queryDelta;

    private PdsCWInventQty                      cwAddReserv;
    private InventQty                           addReserv;
    private InventOnHandCompositeCriteria       inventOnHandCompositeCriteria;
    private QueryRun                            queryRunSum;
    private QueryRun                            queryRunDelta;
    private InventSum                           inventSum;
    private InventSum                           inventSumSelect;
    private InventSumDelta                      inventSumDeltaSelect;
    private InventDim                           inventDim;
    protected InventDimParm                     inventDimParmFixed;
    private InventDimFixed                      inventDimFixed;
    private InventDimParm                       inventDimParmPhysical;
    private boolean                             sumRecordsExist;
    private boolean                             deltaRecordsExist;
    private Integer                             loopReserveType;
    private boolean                             inventSumActive;
    private Map                                 maxReservPhysMap;
    // <GEERU>
    protected boolean                           countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
    // </GEERU>
    private Map                                 cwMaxReservPhysMap;
    private boolean                             pdsIsLastBoxCompletionLoop;

    private const int                           AvailPhysical = 1;
    private const int                           AvailOrdered = 2;
    private const int                           SkipLoop = 3;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    private void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    static private InventUpdateReserveMore construct()
    {
        return new InventUpdateReserveMore();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create new instance from an <c>InventUpdateReserveMoreParameters</c> class.
    /// </summary>
    /// <param name = "_parameters">The parameters class to create the instance from.</param>
    /// <returns>A new instance.</returns>
    [Hookable(false)]
    static public InventUpdateReserveMore newFromParameters(InventUpdateReserveMoreParameters _parameters)
    {
        InventUpdateReserveMore instance = InventUpdateReserveMore::construct();
        instance.parameters = _parameters;

        instance.initialize();

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    private void initialize()
    {
        inventUpdate = parameters.inventUpdate;
        movement = inventUpdate.movement();

        inventDimFixed = inventUpdate.parmInventDimFixed();
        addReserv = inventUpdate.parmReservation();
        cwAddReserv = inventUpdate.parmPdsCWInventQty();

        loopReserveType = inventUpdate.parmAllowReservePhysical() ? 0 : (inventUpdate.parmAllowReserveOrdered() ? AvailPhysical : SkipLoop);

        this.initializeInventOnHandCompositeCriteria();
        this.initializeInventDimParmPhysical();
        this.initializeInventDimParmFixed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventOnHandCompositeCriteria</Name>
				<Source><![CDATA[
    private void initializeInventOnHandCompositeCriteria()
    {
        inventOnHandCompositeCriteria = InventReservationCriteriaBuilder::newUpdate(inventUpdate).buildCriteria();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimParmPhysical</Name>
				<Source><![CDATA[
    private void initializeInventDimParmPhysical()
    {
        movement.inventDimGroupSetup().inventDimParmActivePhysicalInventory(inventDimParmPhysical);

        // Transfers need to enforce warehouse for the reservation even when they may have not
        // have it set as physical inventory. Otherwise circular reservations may occur.
        if (movement.inventdim().InventLocationId != ''
            && movement.parentMovement().isTransfer())
        {
            inventDimParmPhysical.InventLocationIdFlag = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimParmFixed</Name>
				<Source><![CDATA[
    private void initializeInventDimParmFixed()
    {
        InventDimFixedClass::newFixedDim(inventDimFixed).initInventDimParm(inventDimParmFixed);

        if (movement.pdsSameLotReservation())
        {
            if (InventSameBatchReserveCheck::newFromDim(movement, parameters.inventDimCriteria, parameters.inventDimParm, false).run() != PdsSameLotError::None)
            {
                loopReserveType = SkipLoop;
            }
            else if (parameters.inventDimParm.InventBatchIdFlag)
            {
                inventDimFixed = InventDimFixedClass::setField(
                                            inventDimFixed,
                                            InventDimFixedClass::fieldId2Idx(
                                                fieldNum(InventDim, InventBatchId)));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservMaxPhysDim</Name>
				<Source><![CDATA[
    private InventQty reservMaxPhysDim(InventDim _inventDim, InventQty _reduceQty = 0)
    {
        InventDim inventDimReservMaxPhys;

        inventDimReservMaxPhys.data(_inventDim);
        inventDimReservMaxPhys.clearNotSelectedDim(inventDimParmPhysical);
        str mapKey = inventDimReservMaxPhys.mapKey();

        if (!maxReservPhysMap.exists(mapKey))
        {
            InventOnHandQty inventOnhandQtyMaxPhys = InventOnHandQty::newPhysicalInvent(movement, _inventDim);
            maxReservPhysMap.insert(
                mapKey,
                loopReserveType == 0 ?
                inventOnhandQtyMaxPhys.availPhysical() :
                inventOnhandQtyMaxPhys.availOrdered(false));
        }

        if (_reduceQty != 0)
        {
            maxReservPhysMap.insert(mapKey, maxReservPhysMap.lookup(mapKey)-_reduceQty);
        }

        return maxReservPhysMap.lookup(mapKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWReservMaxPhysDim</Name>
				<Source><![CDATA[
    private PdsCWInventQty pdsCWReservMaxPhysDim(
            InventDim _inventDim,
            PdsCWInventQty _cwReduceQty = 0)
    {
        InventDim inventDimReservMaxPhys;

        inventDimReservMaxPhys.data(_inventDim);
        inventDimReservMaxPhys.clearNotSelectedDim(inventDimParmPhysical);
        str mapKey = inventDimReservMaxPhys.mapKey();

        if (!cwMaxReservPhysMap.exists(mapKey))
        {
            InventOnHandQty inventOnhandQtyMaxPhys = InventOnHandQty::newPhysicalInvent(movement, _inventDim);
            cwMaxReservPhysMap.insert(
                    mapKey,
                    loopReserveType == 0
                        ? inventOnhandQtyMaxPhys.pdsCWAvailPhysical()
                        : inventOnhandQtyMaxPhys.pdsCWAvailOrdered(false));
        }
        if (_cwReduceQty != 0)
        {
            cwMaxReservPhysMap.insert(mapKey, cwMaxReservPhysMap.lookup(mapKey)-_cwReduceQty);
        }
        return cwMaxReservPhysMap.lookup(mapKey);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRecord</Name>
				<Source><![CDATA[
    private void setRecord(boolean _activateInventSum)
    {
        if (_activateInventSum)
        {
            inventSum.data(inventSumSelect);
            inventDim = queryRunSum.get(tableNum(InventDim));
            inventSumActive = true;
        }
        else
        {
            inventSum.addInventSumDelta(inventSumDeltaSelect);
            inventDim = queryRunDelta.get(tableNum(InventDim));
            inventSumActive = false;
        }
        // Fields might not have been selected on the specified buffers
        inventDim.checkInvalidFieldAccess(false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventSum</Name>
				<Source><![CDATA[
    private boolean setInventSum(boolean _firstTime = false)
    {
        pdsIsLastBoxCompletionLoop = false;

        if (!sumRecordsExist && !deltaRecordsExist)
        {
            return false;
        }

        inventSum.clear();

        if (!_firstTime)
        {
            if (inventSumActive)
            {
                if (queryRunSum.next())
                {
                    inventSumSelect = queryRunSum.get(tableNum(InventSum));
                }
                else
                {
                    inventSumSelect.clear();
                }
            }
            else
            {
                if (queryRunDelta.next())
                {
                    inventSumDeltaSelect = InventSumDelta::newFromInventSumDeltaAggrSumView(queryRunDelta.get(tableNum(InventSumDeltaAggrSumView)));
                }
                else
                {
                    inventSumDeltaSelect.clear();
                }
            }
        }
        else // first time: set both InventSumSum and InventSumDelta
        {
            if (sumRecordsExist)
            {
                inventSumSelect = queryRunSum.get(tableNum(InventSum));
            }
            else
            {
                inventSumSelect = null;
            }

            if (deltaRecordsExist)
            {
                inventSumDeltaSelect = InventSumDelta::newFromInventSumDeltaAggrSumView(queryRunDelta.get(tableNum(InventSumDeltaAggrSumView)));
            }
            else
            {
                inventSumDeltaSelect = null;
            }
        }

        if (parameters.allowReserveByDate && inventSumSelect.ItemId && inventSumDeltaSelect.ItemId) // Do date comparison between InventSumSelect and InventSumDeltaSelect
        {
            if (loopReserveType == 0) // physical
            {
                this.setRecord(inventSumSelect.LastUpdDatePhysical < inventSumDeltaSelect.LastUpdDatePhysical);
            }
            else  // ordered
            {
                if (parameters.allowReserveReversed)
                {
                    this.setRecord(inventSumSelect.LastUpdDatePhysical > inventSumDeltaSelect.LastUpdDatePhysical);
                }
                else
                {
                    this.setRecord(inventSumSelect.LastUpdDatePhysical < inventSumDeltaSelect.LastUpdDatePhysical);
                }
            }

            return true;
        }
        if (inventSumDeltaSelect.ItemId)
        {
            this.setRecord(false);
        }
        else if (inventSumSelect.ItemId)
        {
            this.setRecord(true);
        }
        else
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventSumApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>InventSum</c> is applicable for reservation.
    /// </summary>
    /// <param name = "_inventSum">The invent sum.</param>
    /// <param name = "_inventDim">The associated inventory dimensions.</param>
    /// <returns>true if applicable; otherwise, false.</returns>
    protected boolean isInventSumApplicable(InventSum _inventSum, InventDim _inventDim)
    {
        if (!inventOnHandCompositeCriteria.isMatchedByInventDim(_inventDim))
        {
            return false;
        }

        if (countryRegion_RU && !movement.checkDimInventOwnerId_RU(_inventDim, false))
        {
            return false;
        }

        if (_inventSum.AvailOrdered + _inventSum.OnOrder != 0)
        {
            return true;
        }

        if (!countryRegion_RU && loopReserveType == 0)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFindInventTransByInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>InventTrans</c> record can be found using an <c>InventDimId</c>.
    /// </summary>
    /// <returns>true, if <c>InventDimId</c> can be used; otherwise, false.</returns>
    protected boolean canFindInventTransByInventDimId()
    {
        return parameters.inventDimParmIsAllYes && parameters.inventDimCriteria.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>InventTrans</c> record for the reservation.
    /// </summary>
    /// <returns>The found <c>InventTrans</c> record.</returns>
    protected InventTrans findInventTrans()
    {
        InventTrans inventTrans;
        
        if (this.canFindInventTransByInventDimId())
        {
            select firstonly forupdate inventTrans
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                    && inventTrans.TransChildType        == movement.transChildType()
                    && inventTrans.TransChildRefId       == movement.transChildRefId()
                    && inventTrans.StatusReceipt         == StatusReceipt::None
                    && inventTrans.StatusIssue           == StatusIssue::OnOrder
                    && inventTrans.InventDimId           == parameters.inventDimCriteria.InventDimId
                    && (!parameters.markingRefInventTransOrigin || inventTrans.MarkingRefInventTransOrigin == parameters.markingRefInventTransOrigin);
        }
        else
        {
            select firstonly forupdate inventTrans
                where inventTrans.InventTransOrigin     == movement.inventTransOriginId()
                    && inventTrans.TransChildType        == movement.transChildType()
                    && inventTrans.TransChildRefId       == movement.transChildRefId()
                    && inventTrans.StatusReceipt         == StatusReceipt::None
                    && inventTrans.StatusIssue           == StatusIssue::OnOrder
                    && (!parameters.markingRefInventTransOrigin || inventTrans.MarkingRefInventTransOrigin == parameters.markingRefInventTransOrigin);
        }
        return inventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildInventSumQueryWithoutDeltas</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds an <c>InventSum</c> query for querying without including <c>InventSumDelta</c> table.
    /// </summary>
    /// <returns>The query.</returns>
    [Replaceable]
    protected Query buildInventSumQueryWithoutDeltas()
    {
        if (parameters.isShelfLifeChecksRequired
            && parameters.isBatchActive
            && !inventDimParmFixed.InventBatchIdFlag
            && movement.itemId())
        {
            Query query = InventSum::pds_FEFOQuery(
                movement.itemId(),
                parameters.inventDimCriteria,
                parameters.inventDimParm,
                InventDimParm::activeDimFlag(movement.inventDimGroupSetup()));            

            // Only consider records with quantity values.
            SysQuery::findOrCreateRange(query.dataSourceTable(tableNum(InventSum)), fieldNum(InventSum, ClosedQty)).value(queryValue(NoYes::No));

            return query;
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the main queries for the reservations.
    /// </summary>
    protected void buildQueries()
    {
        boolean mustIncludeInventSumDelta = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().mustAddInventSumDeltaOnhand(movement.itemId());
        boolean mustIncludeDeltaQueryAggregated = mustIncludeInventSumDelta;

        Query querySumWithoutDeltas = this.buildInventSumQueryWithoutDeltas();
        if (querySumWithoutDeltas)
        {
            querySum = querySumWithoutDeltas;
            mustIncludeInventSumDelta = false;
        }
        else
        {
            using (InventReserveByDateForInventoryOwnerContext context = new InventReserveByDateForInventoryOwnerContext())
            {
                context.inventReserveByDateForInventoryOwner = this.mustInventReserveByDateForInventoryOwner(parameters.allowReserveByDate, loopReserveType);

                querySum = InventSum::newQueryReservation(
                movement.itemId(),
                parameters.inventDimCriteria,
                parameters.inventDimParm,
                InventDimParm::activeDimFlag(movement.inventDimGroupSetup()),
                parameters.isCWItem);
            }
        }
        
        if (mustIncludeInventSumDelta || mustIncludeDeltaQueryAggregated)
        {
            queryDelta = InventSumDelta::newQueryAggregatedView(
                movement.itemId(),
                parameters.inventDimCriteria,
                parameters.inventDimParm,
                inventDimParm::activeDimFlag(movement.inventDimGroupSetup()));
        }

        if (mustIncludeInventSumDelta)
        {
            QueryBuildDataSource qbD = querySum.dataSourceTable(tableNum(InventDim));
            QueryBuildDataSource qbd2 = qbD.addDataSource(tableNum(InventSumDelta));
            qbd2.joinMode(JoinMode::NoExistsJoin);
            qbd2.relations(true);
            qbd2.addRange(fieldNum(InventSumDelta, SQLTransactionId)).value(queryValue(InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().sqlTransactionId()));
            qbd2.addRange(fieldNum(InventSumDelta, ItemId)).value(queryValue(movement.itemId()));
        }

        inventOnHandCompositeCriteria.applyToOnHand(querySum);
        if (queryDelta)
        {
            inventOnHandCompositeCriteria.applyToOnHand(queryDelta);
        }

        switch ((loopReserveType!=0) ? AvailOrdered : AvailPhysical)
        {
            case AvailPhysical :
                querySum.dataSourceTable(tableNum(InventSum)).addRange(fieldNum(InventSum, AvailPhysical)).value('!0');
                if (mustIncludeInventSumDelta)
                {
                    queryDelta.dataSourceTable(tableNum(InventSumDeltaAggrSumView)).addRange(fieldNum(InventSumDeltaAggrSumView, AvailPhysical)).value('!0');
                }

                if (parameters.allowReserveByDate)
                {
                    querySum.dataSourceTable(tableNum(InventSum)).addSortField(fieldNum(InventSum, LastUpdDatePhysical));
                    if (mustIncludeInventSumDelta)
                    {
                        queryDelta.dataSourceTable(tableNum(InventSumDeltaAggrSumView)).addSortField(fieldNum(InventSumDeltaAggrSumView, LastUpdDatePhysical));
                    }
                }
                break;

            case AvailOrdered :
                QueryBuildRange qrAvailOrdered = querySum.dataSourceTable(tableNum(InventSum)).addRange(fieldNum(InventSum, AvailOrdered));
                qrAvailOrdered.value(strFmt('((%1 != 0.0) || (%2 != 0.0))',
                                                        fieldStr(InventSum, AvailOrdered),
                                                        fieldStr(InventSum, OnOrder))); // We check OnOrder to handle negative physical scenarios with no existing on-hand
                qrAvailOrdered.status(RangeStatus::Locked);
                if (mustIncludeInventSumDelta)
                {
                    qrAvailOrdered = queryDelta.dataSourceTable(tableNum(InventSumDeltaAggrSumView)).addRange(fieldNum(InventSumDeltaAggrSumView, AvailOrdered));
                    qrAvailOrdered.value(strFmt('((%1 != 0.0) || (%2 != 0.0))',
                                                            fieldStr(InventSumDeltaAggrSumView, AvailOrdered),
                                                            fieldStr(InventSumDeltaAggrSumView, OnOrder))); // We check OnOrder to handle negative physical scenarios with no existing on-hand
                    qrAvailOrdered.status(RangeStatus::Locked);
                }

                if (parameters.allowReserveByDate)
                {
                    if (loopReserveType == 1 && parameters.allowReserveReversed)
                    {
                        querySum.dataSourceTable(tableNum(InventSum)).addSortField(fieldNum(InventSum, LastUpdDateExpected),SortOrder::Descending);
                        querySum.dataSourceTable(tableNum(InventSum)).addRange(fieldNum(InventSum, LastUpdDateExpected)).value('..'+queryValue(movement.transDate()));
                        if (mustIncludeInventSumDelta)
                        {
                            queryDelta.dataSourceTable(tableNum(InventSumDeltaAggrSumView)).addSortField(fieldNum(InventSumDeltaAggrSumView, LastUpdDateExpected),SortOrder::Descending);
                            queryDelta.dataSourceTable(tableNum(InventSumDeltaAggrSumView)).addRange(fieldNum(InventSumDeltaAggrSumView, LastUpdDateExpected)).value('..'+queryValue(movement.transDate()));
                        }
                    }
                    else
                    {
                        querySum.dataSourceTable(tableNum(InventSum)).addSortField(fieldNum(InventSum, LastUpdDateExpected),SortOrder::Ascending);
                        if (mustIncludeInventSumDelta)
                        {
                            queryDelta.dataSourceTable(tableNum(InventSumDeltaAggrSumView)).addSortField(fieldNum(InventSumDeltaAggrSumView, LastUpdDateExpected),SortOrder::Ascending);
                        }
                    }
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustInventReserveByDateForInventoryOwner</Name>
				<Source><![CDATA[
    Private boolean mustInventReserveByDateForInventoryOwner(boolean _allowReserveByDate, int _loopReserveType)
    {
        return _allowReserveByDate && _loopReserveType == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQueryRuns</Name>
				<Source><![CDATA[
    private void createQueryRuns()
    {
        queryRunSum = this.createInventSumQueryRun(querySum);
        queryRunDelta = this.createInventSumDeltaQueryRun(queryDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQueriesAndQueryRuns</Name>
				<Source><![CDATA[
    private void createQueriesAndQueryRuns()
    {
        this.buildQueries();
        this.createQueryRuns();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventSumQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>QueryRun</c> class.
    /// </summary>
    /// <param name = "_querySum">
    /// A <c>Query</c> object
    /// </param>
    /// <returns>
    /// The <c>QueryRun</c> instance.
    /// </returns>
    protected QueryRun createInventSumQueryRun(Query _querySum)
    {
        return new QueryRun(_querySum);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventSumDeltaQueryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of <c>QueryRun</c> class.
    /// </summary>
    /// <param name = "_queryDelta">
    /// A <c>Query</c> object.
    /// </param>
    /// <returns>
    /// The <c>QueryRun</c> instance.
    /// </returns>
    protected QueryRun createInventSumDeltaQueryRun(Query _queryDelta)
    {
        if (_queryDelta == null)
        {
            return null;
        }
        return new QueryRun(_queryDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_inventTrans">The record to update.</param>
    /// <param name = "_inventDim">The associated inventory dimension.</param>
    protected void updateInventTrans(InventTrans _inventTrans, InventDim _inventDim)
    {
        _inventTrans.update(NoYes::No, _inventDim.InventSerialId && parameters.isSerialNumberControlled);
        // Second parameter: just update the InventSum record as no other process should be able to succeed in updating this record as it only allows +- 1 on hands.
        // Note a small risk of blocking other users if they try to update the same on hand.

        _inventTrans.updateSumUp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeResult</Name>
				<Source><![CDATA[
    private InventUpdateReserveResult initializeResult()
    {
        InventUpdateReserveResult result = InventUpdateReserveResult::construct();
        
        result.updReservOrdered = parameters.updReservOrdered;
        result.updReservPhysical = parameters.updReservPhysical;
        result.cwUpdReservOrdered = parameters.cwUpdReservOrdered;
        result.cwUpdReservPhysical = parameters.cwUpdReservPhysical;

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateReserveMax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the maximum quantity that can be reserved.
    /// </summary>
    /// <param name = "_inventSum">
    /// An <c>InventSum</c> record buffer.
    /// </param>
    /// <param name = "_inventDim">
    /// The associated inventory dimension.
    /// </param>
    /// <param name = "_loopReserveType">
    /// An integer value that describes the reservation type.
    /// </param>
    /// <param name = "_tmpReserved">
    /// The already reserved quantity value.
    /// </param>
    /// <returns>
    /// The maximum quantity that can be reserved.
    /// </returns>
    protected InventQty calculateReserveMax(
        InventSum   _inventSum,
        InventDim   _inventDim,
        Integer     _loopReserveType,
        InventQty   _tmpReserved)
    {
        InventQty reserveMaxPhysDim = -this.reservMaxPhysDim(_inventDim);
        InventQty reserveMax = -(_loopReserveType == 0 ? _inventSum.AvailPhysical : _inventSum.AvailOrdered - _inventSum.AvailPhysical + _inventSum.OnOrder - _tmpReserved);
        
        reserveMax = max(reserveMaxPhysDim, reserveMax); // quantities are negative --> 'max' = 'min'

        return reserveMax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserve</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves the inventory.
    /// </summary>
    /// <returns>The result of the reservation.</returns>
    [Hookable(false)]
    public InventUpdateReserveResult reserve()
    {
        InventUpdateReserveResult result = this.initializeResult();

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            if (this.updateReserveMore_CreditNote_PL())
            {
                return result;
            }
        }
        // </GEEPL>

        if (!this.mustReserveInventory(result))
        {
            return result;
        }

        using (var cache = movement.constructRecordViewCache())
        {
            this.reservationExecution(result);

            this.reservationOnHandValidation(result);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservationExecution</Name>
				<Source><![CDATA[
    /// <summary>
    ///	Execute the reservation logic.
    /// </summary>
    /// <param name = "_result">
    ///	An instance of <c>InventUpdateReserveResult</c> class.
    /// </param>
    protected void reservationExecution(InventUpdateReserveResult _result)
    {
        boolean doSelect = true;
        boolean pdsLastBox = false;
        InventTrans inventTrans;
        PdsCWInventQty cwAddQty;
        InventQty tmpMaxAddQty;
        InventQty pdsLastBoxQty;
        InventQty inventQtyAdjustment;

        // Reservation Logic for WHS items is completely different so we should not get here with the base class
        if (movement.isItemWHSEnabled())
        {
            throw Error(Error::wrongUseOfFunction(funcName()));
        }

        while (loopReserveType < SkipLoop)
        {
            maxReservPhysMap = new Map(Types::String, Types::Real);  // Map for holding max available quantities for reservation on the PHYSICAL dimensions
            cwMaxReservPhysMap = new Map(Types::String, Types::Real);
                
            if (loopReserveType == AvailPhysical && (! parameters.allowReserveByDate || ! parameters.allowReserveReversed))
            {
                loopReserveType = AvailOrdered;
            }
                
            InventQty tmpReserved = 0;
            PdsCWInventQty cwTmpReserved = 0;
            InventQty pdsOverageQty = 0;

            this.createQueriesAndQueryRuns();

            sumRecordsExist     = queryRunSum.next();
            deltaRecordsExist   = queryRunDelta ? queryRunDelta.next() : false;
            boolean doNext = this.setInventSum(true);
                
            while (doNext)
            {
                if (!this.isInventSumApplicable(inventSum, inventDim))
                {
                    doNext = this.setInventSum(false);
                    continue;
                }

                if (doSelect)
                {
                    inventTrans = this.findInventTrans();
                }

                if (!inventTrans)
                {
                    break;
                }

                InventQty addQty            = inventTrans.Qty > addReserv   ? inventTrans.Qty           : addReserv;
                InventQty reserveMax        = this.calculateReserveMax(inventSum, inventDim, loopReserveType, tmpReserved);

                if (parameters.isCWItem)
                {
                    cwAddQty = inventTrans.PdsCWQty > cwAddReserv
                                        ? inventTrans.PdsCWQty
                                        : cwAddReserv;
                    PdsCWInventQty cwReserveMaxPhysDim = -this.pdsCWReservMaxPhysDim(inventDim);
                    PdsCWInventQty cwReserveMax =
                                        -(loopReserveType == 0
                                            ? inventSum.PdsCWAvailPhysical
                                            : inventSum.PdsCWAvailOrdered - inventSum.PdsCWAvailPhysical
                                                + inventSum.PdsCWOnOrder - cwTmpReserved);
                    cwReserveMax = max(cwReserveMaxPhysDim,cwReserveMax);

                    if (cwAddQty <= cwReserveMax)
                    {
                        cwAddQty = cwReserveMax;
                        cwTmpReserved = 0;

                        [pdsLastBox, pdsLastBoxQty]
                        = inventUpdate.pdsLastCWUnit(
                                                inventDim,
                                                cwReserveMax > inventTrans.PdsCWQty
                                                    ? cwReserveMax
                                                    : inventTrans.PdsCWQty);
                    }
                    else
                    {
                        doNext = false;
                    }

                    if (!pdsLastBox || pdsLastBoxQty == 0)
                    {
                        if (parameters.cwForceActual || pdsIsLastBoxCompletionLoop)
                        {
                            tmpMaxAddQty = reserveMax;
                        }
                        else
                        {
                            tmpMaxAddQty = PdsCatchWeight::minInventQty(
                                                                inventTrans.ItemId,
                                                                cwAddQty);
                        }
                        if (tmpMaxAddQty < reserveMax)
                        {
                            cwAddQty = PdsCatchWeight::maxCWQty(
                                                                inventTrans.ItemId,
                                                                reserveMax);
                            tmpMaxAddQty = PdsCatchWeight::minInventQty(
                                                                inventTrans.ItemId,
                                                                cwAddQty);
                            doNext = true;
                        }
                        if (addQty <= tmpMaxAddQty)
                        {
                            addQty = tmpMaxAddQty;
                            doNext = true;
                            tmpReserved = 0;
                        }
                    }
                    else
                    {
                        tmpMaxAddQty = pdsLastBoxQty;
                        if (addQty != tmpMaxAddQty)
                        {
                            addQty  = tmpMaxAddQty;
                            doNext  = true;
                            tmpReserved = 0;
                        }
                        if (!(parameters.cwForceActual || pdsIsLastBoxCompletionLoop))
                        {
                            addReserv += (addQty - PdsCatchWeight::minInventQty(inventTrans.ItemId,cwAddQty));
                        }
                    }
                            
                    pdsLastBoxQty = 0;
                }
                else if (addQty <= reserveMax)
                {
                    addQty      = reserveMax;
                    doNext      = true;
                    tmpReserved = 0;
                }
                else
                {
                    doNext = false;
                }

                if (addQty < 0)
                {
                    if (addQty > inventTrans.Qty)
                    {
                        if (parameters.isCWItem)
                        {
                            inventQtyAdjustment = inventUpdate.pdsCalculateInventoryQuantityAdjustment(
                                        movement.itemId(),
                                        inventTrans.PdsCWQty,
                                        inventTrans.Qty,
                                        cwAddQty,
                                        addQty);
                        }

                        inventTrans.updateSplit(addQty, cwAddQty);

                        pdsLastBox = false;
                    }
                    else if (pdsLastBox)
                    {
                        if (cwAddQty > inventTrans.PdsCWQty)
                        {
                            inventTrans.updateSplit(
                                        max(addQty, inventTrans.Qty - PdsCatchWeight::minInventQty(
                                            inventTrans.ItemId,
                                            inventTrans.PdsCWQty - cwAddQty)),
                                        cwAddQty);
                        }
                            
                        pdsOverageQty = addQty - inventTrans.Qty;
                        addQty = max(addQty, inventTrans.Qty);
                        pdsIsLastBoxCompletionLoop = true;
                    }

                    InventDimId inventDimIdOrig = inventTrans.InventDimId;
                    inventDim = this.initializeInventoryDimension(inventDim);
                    inventTrans.InventDimId = inventDim.InventDimId;
                    InventTrans inventTransOrig = inventTrans.orig();

                    if (inventTransOrig
                            && inventTrans.InventDimId != inventTransOrig.InventDimId
                            && !inventUpdate.checkInventDimChangeOnInventTransUpdate(inventTransOrig.inventDim(), inventDim))
                    {
                        throw error("@SYS18447");
                    }
                        
                    inventTrans.InventDimFixed = inventDimFixed;

                    InventUpdate::updateTransDimTransferReceipt(movement, inventTrans, inventDim);

                    movement.transIdSum().setInventTransStatus(inventTrans, StatusReceipt::None, (loopReserveType ? StatusIssue::ReservOrdered : StatusIssue::ReservPhysical));

                    this.updateInventTrans(inventTrans, inventDim);

                    if (parameters.isCWItem)
                    {
                        inventUpdate.pdsAdjustInventoryQuantity(pdsOverageQty + inventQtyAdjustment,inventDimIdOrig);
                    }
                            
                    inventQtyAdjustment = 0;
                    pdsLastBox = false;

                    addReserv -= addQty;

                    if (loopReserveType)
                    {
                        _result.updReservOrdered += addQty;
                    }
                    else
                    {
                        _result.updReservPhysical += addQty;
                    }

                    this.reservMaxPhysDim(inventDim, -addQty);  // reduce available quantity on physical dimensions

                    tmpReserved -= addQty;
                    doSelect = true;

                    if (parameters.isCWItem)
                    {
                        cwAddReserv -= cwAddQty;
                        if (loopReserveType)
                        {
                            _result.cwUpdReservOrdered += cwAddQty;
                        }
                        else
                        {
                            _result.cwUpdReservPhysical += cwAddQty;
                        }

                        this.pdsCWReservMaxPhysDim(inventDim, -cwAddQty);  // reduce available quantity on physical dimensions

                        cwTmpReserved -= cwAddQty;
                    }
                }
                else
                {
                    doSelect = false;
                }
                    
                if (!parameters.isCWItem ? (addReserv >= 0) : (addReserv >= 0 && cwAddReserv >= 0))
                {
                    doNext = false;
                }
                else if (doNext && !pdsOverageQty)
                {
                    doNext = this.setInventSum(false);
                    tmpReserved = 0;
                }
                else
                {
                    pdsOverageQty = 0;
                    doNext = true;
                }
            }

            if (addReserv >= 0)
            {
                break;
            }

            if (!parameters.allowReserveOrdered)
            {
                break;
            }

            loopReserveType += 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reservationOnHandValidation</Name>
				<Source><![CDATA[
    /// <summary>
    ///	Validate the Onhand quantity after reservation.
    /// </summary>
    /// <param name = "_result">
    ///	An instance of <c>InventUpdateReserveResult</c> class.
    /// </param>
    private void reservationOnHandValidation(InventUpdateReserveResult _result)
    {
        // non-WMS movements should care only for InventQty
        if (!this.isAllQuantityReserved() && !parameters.allowReserveReduction)
        {
            InventOnHandQty inventOnHandQty = InventOnHandQty::newEstimatedUpdate(movement, parameters.inventDimCriteria);
            inventOnHandQty.parmAdvancedCriteria(inventOnHandCompositeCriteria);

            if (!inventOnHandQty.checkReservation(
                                        inventUpdate.parmReservation(),
                                        parameters.allowNegativePhysical,
                                        parameters.allowReserveOrdered,
                                        -_result.updReservPhysical - _result.updReservOrdered,
                                        inventUpdate.parmPdsCWInventQty(),
                                        -_result.cwUpdReservPhysical -_result.cwUpdReservOrdered))
            {
                throw error("@SYS18447");
            }

            inventOnHandQty.addReservationCheck(parameters.allowNegativePhysical);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAllQuantityReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///	Check whether all trans quantity has been reserved.
    /// </summary>
    /// <returns>
    ///	true, if the inventory quantity is full reserved; otherwise, false.
    /// </returns>
    protected boolean isAllQuantityReserved()
    {
        return !((!inventUpdate.parmWmsMovement() && addReserv)
            || (inventUpdate.parmWmsMovement() && (parameters.isCWItem ? cwAddReserv : addReserv)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustReserveInventory</Name>
				<Source><![CDATA[
    /// <summary>
    ///	Determines whether the inventory must be reserved.
    /// </summary>
    /// <param name = "_result">
    ///	An instance of <c>InventUpdateReserveResult</c> class.
    /// </param>
    /// <returns>
    ///	true, if the inventory must be reserved; otherwise, false.
    /// </returns>
    protected boolean mustReserveInventory(InventUpdateReserveResult _result)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventoryDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the inventory dimension record.
    /// </summary>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    /// <returns>The inventory dimension record.</returns>
    protected InventDim initializeInventoryDimension(InventDim _inventDim)
    {
        return InventDim::findOrCreate(inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveMore_CreditNote_PL</Name>
				<Source><![CDATA[
    private boolean updateReserveMore_CreditNote_PL()
    {
        if (!inventUpdate.parmRefInventTransId())
        {
            return false;
        }
        
        boolean     ret;
        InventQty   remainToReserve;

        using (var cache = movement.constructRecordViewCache())
        {
            InventTrans inventTrans, refInventTrans;
            InventTransOrigin   inventTransOrigin, refInventTransOrigin;
            InventQty   availQty, splitQty;

            SalesLine refLine = movement.buffer();

            while select RecId From refInventTransOrigin
                where refInventTransOrigin.InventTransId == inventUpdate.parmRefInventTransId()
                join StatusIssue, StatusReceipt, Qty, InventDimId from refInventTrans
                where refInventTransOrigin.RecId == refInventTrans.InventTransOrigin &&
                      refInventTrans.StatusIssue      == StatusIssue::None           &&
                      refInventTrans.StatusReceipt    == StatusReceipt::Ordered      &&
                      refInventTrans.Qty              != 0
            {
                select firstonly forupdate inventTrans
                    join inventTransOrigin
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId   &&
                          inventTransOrigin.InventTransId   == movement.transId()    &&
                          inventTrans.StatusReceipt   == StatusReceipt::None         &&
                          inventTrans.StatusIssue     == StatusIssue::OnOrder        &&
                          inventTrans.Qty             != 0;

                if (! inventTrans)
                {
                    break;
                }

                remainToReserve     = inventTrans.Qty;
                InventDim inventDimPL = InventDim::find(refInventTrans.InventDimId);
                availQty            = InventOnhand::newEstimatedUpdate(movement, inventDimPL).availOrdered(false);

                if (availQty <= 0)
                {
                    continue;
                }

                splitQty = 0;

                if (availQty < -inventTrans.Qty || refInventTrans.Qty < -inventTrans.Qty)
                {
                    splitQty = min(availQty, refInventTrans.Qty);
                }

                if (splitQty)
                {
                    inventTrans.updateSplit(-splitQty);
                }

                inventDimPL = InventDim::find(refInventTrans.InventDimId);

                inventTrans.InventDimId = inventDimPL.InventDimId;
                InventUpdate::updateTransDimTransferReceipt(movement, inventTrans, inventDimPL);

                movement.transIdSum().setInventTransStatus(inventTrans,
                                                           StatusReceipt::None,
                                                           StatusIssue::ReservOrdered);

                inventTrans.update();

                remainToReserve -= inventTrans.Qty;

                ret = true;
            }
        }
        return ret && ! remainToReserve;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>