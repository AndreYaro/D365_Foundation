<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesTableType</Name>
	<SourceCode>
		<Declaration><![CDATA[
abstract class SalesTableType extends InventType implements SalesPurchIModifiedDefaulter
{
    SalesTable              salesTable;
    SalesLine               salesLineCaller;

    NumberSeqFormHandler    numberSeqFormHandlerSalesId;
    ProjId                  projId;

    SalesPurchCycle         salesPurchCycle;
    boolean                 salesCycle;

    boolean                 allowSalesLineCaching;
    SalesTableCheckQuantity salesTableCheckQuantity;
    TradeCommonIEnumerable  defaultSalesLineEnumerable;
    TradeCommonIEnumerable  pickingListRegistrationSalesLineEnumerable;
    #ISOCountryRegionCodes
    boolean                 checkScrapLineResult;
    boolean                 checkScrapLineIsExecuted;
    Map                     checkSalesQtyDocumentStatus;

    boolean                 isDirectDeliveryCreation;

    protected TradeCommonIEnumerable kittingDefaultSalesLineEnumerable;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountCustLedgerDimension</Name>
				<Source><![CDATA[
    LedgerDimensionDefaultAccount accountCustLedgerDimension(CustPostingProfile _postingProfile_RU = '')
    {
        if (_postingProfile_RU)
        {
            return CustLedgerAccounts::summaryLedgerDimension(salesTable.InvoiceAccount,
                                                              _postingProfile_RU);
        }
        return CustLedgerAccounts::summaryLedgerDimension(salesTable.InvoiceAccount,
                                              salesTable.PostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>blockManualTypeChange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Blocks for order type changes for the specified types.
    /// </summary>
    /// <returns>
    ///    true if the type is not changed; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method should be called from an overridden <c>ValidateField</c> method in a derived class.By
    ///    passing in the order type that matches the derived class, it will block for manual change of that
    ///    particular type.
    /// </remarks>
    protected boolean blockManualTypeChange()
    {
        boolean ok = true;

        if (FormDataUtil::isFormDataSource(salesTable)
            && salesTable.SalesType != salesTable.orig().SalesType)
        {
            //The %1 order type cannot be selected manually.
            ok = checkFailed(strFmt("@SYS307927", salesTable.SalesType));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAgreementBeLinked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the agreement should be linked to an order.
    /// </summary>
    /// <returns>
    ///    true if the agreement should be linked; otherwise, false.
    /// </returns>
    public boolean canAgreementBeLinked()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchaseType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the corresponding <c>PurchaseType</c> value.
    /// </summary>
    /// <returns>Purchase order type value 'Purchase'.</returns>
    public PurchaseType purchaseType()
    {
        return PurchaseType::Purch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAvailableDlvDatesBeCalculated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether delivery date calculation can be performed.
    /// </summary>
    /// <returns>
    ///    true if delivery date calculation can be performed; otherwise, false.
    /// </returns>
    public boolean canAvailableDlvDatesBeCalculated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canBePartlyConfirmed</Name>
				<Source><![CDATA[
    public boolean canBePartlyConfirmed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCommFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies whether facture with type Commission can be updated.
    /// </summary>
    /// <returns>
    /// True if facture can be updated.
    /// </returns>
    /// <remarks>
    /// Identification occurs by agreement property AgencyAgreement.
    /// </remarks>
    public boolean canCommFactureBeUpdated_RU()
    {
        boolean                 ok = true;
        AgreementHeaderExt_RU   agreementHeader = AgreementHeaderExt_RU::find(salesTable.agreementHeaderExt_RU());

        if (agreementHeader.AgencyAgreement == AgencyAgreement_RU::PurchaseCommission)
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canConfirmationBeUpdated</Name>
				<Source><![CDATA[
    boolean  canConfirmationBeUpdated(DocumentStatus _documentStatus = DocumentStatus::Confirmation)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::Confirmation)
        {
            ok = this.mayConfirmationBeUpdated();
        }

        if (ok)
        {
            if (salesTable.SalesStatus != SalesStatus::Backorder ||
                !(salesTable.existInterCompanySales() || salesTable.existDirectDelivery()))
            {
                ok = this.canPackingslipBeUpdated(_documentStatus);
            }
            else
            {
                if (!salesTable.canCustomerBeUpdated(_documentStatus))
                {
                    ok = false;
                }
            }
        }

        if (ok)
        {
            RetailSalesTableParameters::setDocumentStatus = _documentStatus;
            ok = salesTable.checkCreditCard();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateDropShipment</Name>
				<Source><![CDATA[
    boolean canCreateDropShipment()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreatePurchOrder</Name>
				<Source><![CDATA[
    boolean canCreatePurchOrder()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreditCardPaymentJournalPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the payment journal for a credit card payment can be posted.
    /// </summary>
    /// <returns>
    /// true if posting will be be successful; otherwise, false.
    /// </returns>
    /// <remarks>
    /// When the payment type is not a credit card this method always returns true.
    /// </remarks>
    public boolean canCreditCardPaymentJournalPost()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreditNoteBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the sales order can be credited.
    /// </summary>
    /// <returns>
    ///    true if the sales order can be credited; otherwise, false.
    /// </returns>
    public boolean canCreditNoteBeCreated()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            return !salesTable.returnItem() && !this.isItemRequirement() && !salesTable.isInterCompanyPOInvoiceMatched();
        }
        else
        {
            return !salesTable.returnItem() && !this.isItemRequirement() && !salesTable.isInterCompanyPOInvoiceMatched() && !salesTable.isCallCenterOrderOpened();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeliverySlipBeUpdated_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if delivery slip can be updated.
    /// </summary>
    /// <param name="_documentStatus">The current sales order document status.</param>
    /// <returns>true if delivery slip can be updated; otherwise, false.</returns>
    public boolean canDeliverySlipBeUpdated_BR(DocumentStatus _documentStatus = DocumentStatus::DeliverySlip_BR)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::DeliverySlip_BR)
        {
            ok = this.mayPackingSlipBeUpdated();

            if (ok)
            {
                if (!salesTable.canCustomerBeUpdated(DocumentStatus::PackingSlip))
                {
                    ok = false;
                }
            }

            if (ok)
            {
                ok = this.checkSalesQty(DocumentStatus::PackingSlip, this.parmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::PackingSlip);
            }

            ok = salesTable.checkCreditCard();

            if (ok)
            {
                ok = this.checkScrapLine();
            }
        }

        if (ok
            && (!salesTable.canDeliverySlipBeUpdatedBR()
                || salesTable.salesTable_BR().InvoiceRefRecID_BR))
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditSalesPurchOperationType_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true when SalesPurchOperationType_BR can be edited.
    /// </summary>
    /// <returns>
    /// Returns true when <c>SalesTable</c> is not a cancelling fiscal document order
    /// Returns false when <c>SalesTable</c> is a cancelling fiscal document order
    /// </returns>
    public boolean canEditSalesPurchOperationType_BR()
    {
        return salesTable.salesTable_BR().InvoiceRefRecID_BR == 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExplosionBeExecuted</Name>
				<Source><![CDATA[
    boolean canExplosionBeExecuted()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    boolean canFactureBeUpdated_RU(DocumentStatus _documentStatus = DocumentStatus::Facture_RU)
    {
        boolean                 ok = true;
        CustInvoiceSalesLink    invoiceSalesLink;
        CustInvoiceJour         invoiceJour;
        CustInvoiceJour_RU      custInvoiceJour_RU;

        if (_documentStatus == DocumentStatus::Facture_RU)
        {
            ok = this.mayFactureBeUpdated_RU();
        }

        if (ok)
        {
            select firstonly RecId from invoiceSalesLink
                index hint origSalesIdx
                where invoiceSalesLink.OrigSalesId == salesTable.SalesId
            join RecId from invoiceJour
                where   invoiceJour.SalesId        == invoiceSalesLink.SalesId     &&
                        invoiceJour.InvoiceId      == invoiceSalesLink.InvoiceId   &&
                        invoiceJour.InvoiceDate    == invoiceSalesLink.InvoiceDate
            exists join custInvoiceJour_RU
                where custInvoiceJour_RU.CustInvoiceJour == invoiceJour.RecId
                      && !custInvoiceJour_RU.FacturedFully_RU;

            ok = ok && invoiceJour.RecId;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canFiscalDocTextBeRegistrated_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if Fiscal document texts can be registered to the Sales header
    /// </summary>
    /// <returns>
    /// True if the Fiscal document text can be registered; false otherwise.
    /// </returns>
    public boolean canFiscalDocTextBeRegistrated_BR()
    {
        return  salesTable.RecId
                &&  (salesTable.SalesType == SalesType::Sales
                    || salesTable.SalesType == SalesType::ReturnItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveAttachedOrders</Name>
				<Source><![CDATA[
    boolean canHaveAttachedOrders()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canHaveCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if sales order can have credit card.
    /// </summary>
    /// <returns>
    ///    true if the sales order can have credit card assigned; otherwise, false.
    /// </returns>
    public boolean canHaveCreditCard()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoice4PaymBeUpdated_RU</Name>
				<Source><![CDATA[
    boolean canInvoice4PaymBeUpdated_RU(DocumentStatus _documentStatus = DocumentStatus::Invoice4Paym_RU)
    {
        boolean ok = true;

        if (_documentStatus == DocumentStatus::Invoice4Paym_RU)
        {
            ok = this.mayInvoice4PaymBeUpdated_RU();
        }

        ok = ok && salesTable.canCustomerBeUpdated(_documentStatus);

        ok = ok && this.checkSalesQty(DocumentStatus::Invoice4Paym_RU, this.parmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::Invoice4Paym_RU);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInvoiceBeUpdated</Name>
				<Source><![CDATA[
    boolean  canInvoiceBeUpdated()
    {
        boolean  ok = true;

        ok = this.mayInvoiceBeUpdated();

        if (ok)
        {
            if (salesTable.SalesType != SalesType::ReturnItem)
            {
                if (!salesTable.canCustomerBeUpdated(DocumentStatus::Invoice))
                {
                    ok = false;
                }
            }
        }

        if (ok)
        {
            ok = this.checkSalesQty(DocumentStatus::Invoice, this.parmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::Invoice);
        }

        if (ok)
        {
            RetailSalesTableParameters::setDocumentStatus = DocumentStatus::Invoice;
            ok = salesTable.checkCreditCard();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPackingslipBeUpdated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether sales order can be updated for certain document status.
    /// </summary>
    /// <param name="_documentStatus">
    /// The <c>DocumentStatus</c> value.
    /// </param>
    /// <returns>
    /// True if sales order can be updated; otherwise, false.
    /// </returns>
    public boolean  canPackingslipBeUpdated(DocumentStatus _documentStatus = DocumentStatus::PackingSlip)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::PackingSlip)
        {
            ok = this.mayPackingSlipBeUpdated();
        }

        if (ok)
        {
            if (!salesTable.canCustomerBeUpdated(_documentStatus))
            {
                ok = false;
            }
        }

        if (ok)
        {
            ok = this.checkSalesQty(DocumentStatus::PackingSlip, this.parmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::PackingSlip);
        }

        if (ok && _documentStatus != DocumentStatus::ProjectPackingSlip)
        {
            RetailSalesTableParameters::setDocumentStatus = _documentStatus;
            ok = salesTable.checkCreditCard();
        }

        if (ok)
        {
            ok = this.checkScrapLine();
        }

        if (BrazilParameters::isEnabled())
        {
            return this.postCanPackingslipBeUpdatedBR(_documentStatus, ok);
        }

        if (ok)
        {
            ok = !RetailCommercePaymentsFeatureHelper::commercePaymentsOrderWhenFeatureDisabled(salesTable);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPickingListBeRegistrated</Name>
				<Source><![CDATA[
    boolean  canPickingListBeRegistrated()
    {
        boolean             ok = true;

        ok = this.mayPickingListBeRegistered();

        if (ok)
        {
            if (!salesTable.canCustomerBeUpdated(DocumentStatus::PickingList))
            {
                ok = false;
            }
        }

        if (ok)
        {
            ok = this.checkSalesQty(DocumentStatus::PackingSlip, this.parmPickingListRegistrationEnumerable(), SalesCheckQtyCachKey::PickingListRegistration);
        }

        if (ok)
        {
            RetailSalesTableParameters::setDocumentStatus = DocumentStatus::PickingList;
            ok = salesTable.checkCreditCard();
        }

        if (ok)
        {
            ok = this.checkScrapLine();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPickingListBeUpdated</Name>
				<Source><![CDATA[
    boolean  canPickingListBeUpdated()
    {
        boolean  ok = true;

        ok = this.mayPickingListBeRegistered();

        if (ok)
        {
            if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
            {
                ok = this.checkSalesQty(DocumentStatus::PickingList, this.kittingParmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::PickingList);
            }
            else
            {
                ok = this.checkSalesQty(DocumentStatus::PickingList, this.parmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::PickingList);
            }
        }

        if (ok)
        {
            ok = this.canPackingslipBeUpdated(DocumentStatus::PickingList);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProjectPackingSlipBeUpdated</Name>
				<Source><![CDATA[
    boolean  canProjectPackingSlipBeUpdated(DocumentStatus _documentStatus = DocumentStatus::ProjectPackingSlip)
    {
        boolean  ok = true;

        if (_documentStatus == DocumentStatus::ProjectPackingSlip)
        {
            ok = this.mayProjectPackingSlipBeUpdated();
        }

        if (ok)
        {
            ok = this.canPackingslipBeUpdated(_documentStatus);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canProjectPickingListBeUpdated</Name>
				<Source><![CDATA[
    boolean canProjectPickingListBeUpdated()
    {
        boolean  ok = true;

        ok = this.mayPickingListBeRegistered();

        ok = ok && this.checkSalesQty(DocumentStatus::ProjectPickingList, this.parmDefaultSalesLineEnumerable(), SalesCheckQtyCachKey::PickingList);

        ok = ok && this.canProjectPackingslipBeUpdated(DocumentStatus::ProjectPickingList);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTypeBeChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an order type can be changed.
    /// </summary>
    /// <returns>
    /// true when all lines in the order correspond to order type change conditions; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The order type cannot be changed if any of the lines are not in the status open order.The order
    /// type cannot be changed for intercompany orders.The order type cannot be changed to order types
    /// apart from <c>Journal</c> and <c>Purch</c>, where delivery lines are part of the order.The order
    /// type cannot be changed to <c>Journal</c> if any of the lines do not satisfy the conditions for
    /// changing <c>StockedProduct</c>.The order type cannot be changed if the related <c>Bank</c> document
    /// has been created.
    /// </remarks>
    public boolean canTypeBeChanged()
    {
        boolean               ok = true;
        SalesLine             salesLine;
        PdsCatchWeightItem  cwItem;
        SalesDeliverySchedule salesDeliverySchedule;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])          &&
            TaxParameters::find().Customs_IN                &&
            salesTable.CustomsExportOrder_IN == NoYes::Yes  &&
            salesTable.SalesType             != SalesType::Sales)
        {
            ok = checkFailed("@GLS5760");
        }
        if (salesTable.SalesType != salesTable.orig().SalesType)
        {
            SalesStatus highestLineStatus = SalesLine::highestSalesStatus(salesTable.SalesId);

            if (highestLineStatus == SalesStatus::Delivered
                || highestLineStatus == SalesStatus::Invoiced
                || (highestLineStatus == SalesStatus::Canceled
                    && !(salesTable.orig().SalesType == SalesType::Journal
                        && salesTable.SalesType == SalesType::Sales)))
            {
                ok = checkFailed(strFmt("@SYS99056", salesTable.orig().SalesType, salesTable.SalesType));
            }

            if (ok
                && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
            {
                this.mcrTypeCheck();
            }

            if (#PdsCatchWeightEnabled && ok)
            {
                while select salesLine
                    where salesLine.SalesId == salesTable.SalesId
                    join RecId
                    from cwItem
                    where cwItem.ItemId == salesLine.ItemId
                {
                    salesLine.SalesType = salesTable.SalesType;
                    SalesLineType salesLineType = SalesLineType::construct(salesLine,salesTable);
                    if (!salesLineType.pdsIsCWItemAllowed())
                    {
                        ok = checkFailed(strFmt("@PDS611",salesTable.orig().SalesType,salesTable.SalesType));
                        break;
                    }
                }
            }
        }

        if ((salesTable.InterCompanyPurchId      && !this.interCompanyCreateAllowed())
        ||  (salesTable.existInterCompanyPurch() && !this.canCreatePurchOrder()))
        {
            ok = checkFailed(strFmt("@SYS4002135",salesTable.SalesType));
        }

        if (ok
            && salesTable.SalesType != SalesType::Journal
            && salesTable.SalesType != SalesType::Sales
            && (   salesTable.orig().SalesType == SalesType::Journal
                || salesTable.orig().SalesType == SalesType::Sales))
        {
            select firstonly RecId from salesLine
                where salesLine.SalesId == salesTable.SalesId
                join RecId from salesDeliverySchedule
                    where salesDeliverySchedule.DeliveryLine == salesLine.InventTransId;
            if (salesLine.RecId)
            {
                // Orders with Delivery Schedules cannot be converted to type %1.
                ok = checkFailed(strFmt("@SYS131416",salesTable.SalesType));
            }
        }

        ok = ok && salesTable.checkCreditCardPaymentType();

        if (ok
            && salesTable.SalesType != salesTable.orig().SalesType
            && salesTable.SalesType == SalesType::Journal)
        {
            //Only lines which are not inventoried are checked here.
            //Inventoried lines are checked through the inventory module
            if (!this.canTypeBeChangedNonInventoried())
            {
                ok = checkFailed(strFmt("@SYS190600", salesTable.SalesType));
            }
        }

        if (ok)
        {
            if (BankLCExportFeatureChecker::checkBankLCExportEnabled())
            {
                if (salesTable.isBankLCCreated())
                {
                    // The Bank document has been created for this order. Order type could not be changed.
                    ok = checkFailed("@SYS316265");
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTypeBeChangedNonInventoried</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the order type can be changed.
    /// </summary>
    /// <returns>
    ///    true when all lines in the order continue to use the change in the order type; otherwise, false.
    /// </returns>
    protected boolean canTypeBeChangedNonInventoried()
    {
        SalesLine salesLine;

        select firstonly RecId from salesLine
            where salesLine.SalesId       == salesTable.SalesId
            &&  salesLine.StockedProduct == NoYes::No
            && (salesLine.InventRefTransId != '' || salesLine.InventRefId != '');

        return(salesLine.RecId == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateRemainingQty</Name>
				<Source><![CDATA[
    boolean canUpdateRemainingQty()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether it is allowed to delete the sales order.
    /// </summary>
    /// <param name = "_useWarning">
    /// A boolean value that indicates whether the user must be notified about the reasons why the changes are not allowed; optional.
    /// </param>
    /// <param name = "_treatInvoicedOrderUpdateWarningAsError">
    /// A boolean value that indicates whether the "Warning" access level to invoiced orders must be treated as "Locked".
    /// </param>
    /// <returns>true if delete is allowed; otherwise, false.</returns>
    public boolean checkDelete(
        boolean _useWarning = true,
        boolean _treatInvoicedOrderUpdateWarningAsError = false)
    {
        boolean ok = salesTable ? true : false;

        // For retail cash and carry orders, we will only allow the deletion after the retail statement that generates this sales order is posted.
        // To determine whether the retail statement is posted or not, we check whether the RetailStatementTable is already deleted.
        // We cannot rely on whether RetailStatementJour exists to determine because once RetailStatementJour is archived, it's giving us a wrong signal and stopping the sales order to be deleted / archived.
        // isRetailCashAndCarrySalesNoCache()
        if (salesTable.isRetailCashAndCarrySalesNoCache())
        {
            if (RetailSalesTableAllowDeleteForCashAndCarryOrdersFlight::instance().isEnabled() && salesTable.isPostedRetailCashAndCarrySales())
            {
                ok = true;
            }
            else
            {
                ok = false;
            }
        }
        else if (salesTable && salesTable.lastInvoice() != '')
        {
            switch (SalesParameters::find().accesLevelInvoiced(_treatInvoicedOrderUpdateWarningAsError))
            {
                case SalesPurchAccesLevel::Warning:
                    if (_useWarning)
                    {
                        str message = salesTable.SalesStatus == SalesStatus::Invoiced ? "@SYS78815" : "@SYS78817";
                        if (Box::yesNo(message, DialogButton::Yes) != DialogButton::Yes)
                        {
                            ok = false;
                        }
                    }
                    break;

                case SalesPurchAccesLevel::Locked:
                    if (_useWarning)
                    {
                        warning("@SCM:SalesOrderIsInvoicedAndCannotBeDeleted");
                    }
                    ok = false;
                    break;
            }
        }
        // Check condition of posted payment, inventory picked, or direct ship
        // with PO to determine if delete should be allowed.
        else if (salesTable.mcrIsCallCenter())
        {
            ok = MCRAllowSODeletion::allowSalesOrderDeletion(salesTable);
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIfUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the various posting updates for the order are enabled.
    /// </summary>
    /// <param name="_packedCheckIfUpdateContract">
    /// Specifies which of the posting update allowance values to obtain for the order.
    /// </param>
    /// <returns>
    /// A packed <c>SalesTableCanBeUpdatedContract</c> object that has the values that indicate whether the
    /// order can do a posting of a given type.
    /// </returns>
    container checkIfUpdate(container _packedCheckIfUpdateContract)
    {
        SalesTableCheckIfUpdateContract checkIfUpdateContract;
        SalesTableCanBeUpdatedContract  canBeUpdatedContract       = SalesTableCanBeUpdatedContract::construct();
        boolean                         localAllowSalesLineCaching = this.parmAllowSalesLineCaching();
        if (_packedCheckIfUpdateContract == conNull())
        {
            checkIfUpdateContract = SalesTableCheckIfUpdateContract::newCheckAll();
        }
        else
        {
            checkIfUpdateContract = SalesTableCheckIfUpdateContract::create(_packedCheckIfUpdateContract);
        }
        this.parmAllowSalesLineCaching(true);

        if (checkIfUpdateContract.parmCheckConfirmation())
        {
            canBeUpdatedContract.parmCanConfirmationBeUpdated(this.canConfirmationBeUpdated());
        }
        if (checkIfUpdateContract.parmCheckPickingList())
        {
            canBeUpdatedContract.parmCanPickingListBeUpdated(this.canPickingListBeUpdated());
        }
        if (checkIfUpdateContract.parmCheckPickingListRegistration())
        {
            canBeUpdatedContract.parmCanPickingListBeRegistrated(this.canPickingListBeRegistrated());
        }
        if (checkIfUpdateContract.parmCheckPackingSlip())
        {
            canBeUpdatedContract.parmCanPackingSlipBeUpdated(this.canPackingslipBeUpdated());
        }
        if (checkIfUpdateContract.parmCheckInvoice())
        {
            canBeUpdatedContract.parmCanInvoiceBeUpdated(this.canInvoiceBeUpdated());
        }
        if (checkIfUpdateContract.parmCheckProjectPackingSlip())
        {
            canBeUpdatedContract.parmCanProjectPackingSlipBeUpdated(this.canProjectPackingSlipBeUpdated());
        }
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (checkIfUpdateContract.parmCheckInvoice4Paym_RU())
            {
                canBeUpdatedContract.parmCanInvoice4PaymBeUpdated_RU(this.canInvoice4PaymBeUpdated_RU());
            }
            if (checkIfUpdateContract.parmCheckFacture_RU())
            {
                canBeUpdatedContract.parmCanFactureBeUpdated_RU(this.canFactureBeUpdated_RU());
            }
            if (checkIfUpdateContract.parmCheckCommFacture_RU())
            {
                canBeUpdatedContract.parmCanCommFactureBeUpdated_RU(this.canCommFactureBeUpdated_RU());
            }
        }

        if (BrazilParameters::isEnabled())
        {
            if (checkIfUpdateContract.parmCheckDeliverySlip_BR())
            {
                canBeUpdatedContract.parmCanDeliverySlipBeUpdated_BR(this.canDeliverySlipBeUpdated_BR());
            }
            if (checkIfUpdateContract.parmCheckFiscalDocumentText_BR())
            {
                canBeUpdatedContract.parmCanFiscalDocTextBeRegistrated_BR(this.canFiscalDocTextBeRegistrated_BR());
            }
        }

        this.parmAllowSalesLineCaching(
        localAllowSalesLineCaching
        );

        return canBeUpdatedContract.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventOwner_RU</Name>
				<Source><![CDATA[
    public boolean checkInventOwner_RU()
    {
        SalesTable          salesTable_Orig = salesTable.orig();
        SalesLine           salesLine;
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;
        InventDim           inventDim;
        InventProfile_RU    inventProfile;

        SalesTable_RU salesTableOrigRU = salesTable_Orig.salesTable_RU();

        if (salesTable_Orig &&
            (salesTable.CustAccount != salesTable_Orig.CustAccount ||
             salesTable.salesTable_RU().AgreementHeaderExt_RU != salesTableOrigRU.AgreementHeaderExt_RU))
        {
            InventOwner_RU inventOwner = InventOwner_RU::findCustAccount(salesTable_Orig.CustAccount,
                                                                         salesTableOrigRU.AgreementHeaderExt_RU);
            if (inventOwner)
            {
                select firstonly RecId from salesLine
                    where salesLine.SalesId             == salesTable.SalesId
                join RecId from inventTransOrigin
                    where inventTransOrigin.InventTransId == salesLine.InventTransId
                join RecId from inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                       && (inventTrans.StatusIssue      == StatusIssue::ReservOrdered ||
                           inventTrans.StatusIssue      == StatusIssue::ReservPhysical ||
                           inventTrans.StatusIssue      == StatusIssue::Picked ||
                           inventTrans.StatusReceipt    == StatusReceipt::Registered)
                join RecId from inventDim
                    where inventDim.InventDimId         == inventTrans.InventDimId
                       && inventDim.InventOwnerId_RU    == inventOwner.InventOwnerId
                join RecId from inventProfile
                    where inventProfile.InventProfileId == inventDim.InventProfileId_RU
                       && inventProfile.InventOwnerIdCheckSalesOrder;

                if (salesLine)
                {
                    return checkFailed("@GLS115643");
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesQty</Name>
				<Source><![CDATA[
    [Hookable]
    private boolean  checkSalesQty(DocumentStatus  _documentStatus, TradeCommonIEnumerable _salesLineEnumerable, SalesCheckQtyCachKey _cachKey)
    {
        boolean ret;

        if (this.parmAllowSalesLineCaching()
            &&  this.parmCheckSalesQtyDocumentStatus().exists(_cachKey))
        {
            ret = this.parmCheckSalesQtyDocumentStatus().lookup(_cachKey);
        }
        else
        {
            ret = this.parmSalesTableCheckQuantity().checkQuantity(_documentStatus, _salesLineEnumerable);
            this.parmCheckSalesQtyDocumentStatus().insert(_cachKey, ret);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkScrapLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether any non scraped open lines exist.
    /// </summary>
    /// <returns>
    /// true when there exists an open not scraped line; otherwise, false.
    /// </returns>
    protected boolean checkScrapLine()
    {
        SalesLine   salesLine;

        if (!checkScrapLineIsExecuted
        ||  !this.parmAllowSalesLineCaching())
        {
            select firstonly RecId from salesLine
                where salesLine.SalesId == salesTable.SalesId
                   && salesLine.Scrap == NoYes::No
                   && (salesLine.SalesStatus == SalesStatus::Backorder || salesLine.SalesDeliverNow != 0) ;

            checkScrapLineIsExecuted = true;
            checkScrapLineResult     = salesLine.RecId ? true : false;
        }

        return  checkScrapLineResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkShipCarrierAddress</Name>
				<Source><![CDATA[
    public boolean checkShipCarrierAddress()
    {
        return LogisticsLocationAppUtil::shipCarrierCheck(salesTable.TableId,
                    LogisticsLocation::find(salesTable.shipCarrierLocation()),
                    salesTable.DlvMode,
                    salesTable.DlvTerm,
                    salesTable.ShipCarrierAccount,
                    salesTable.CustAccount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustValidateInterCompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether  if the intercompany check must be performed.
    /// </summary>
    /// <param name = "_interCompanyCheck">
    /// A boolean value that indicates whether the intercompany check must be performed.
    /// </param>
    /// <returns>
    /// true if the intercompany check must be performed; otherwise, false.
    /// </returns>
    protected boolean mustValidateInterCompany(boolean _interCompanyCheck)
    {
        return _interCompanyCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesCreditNote_PL</Name>
				<Source><![CDATA[
    protected boolean isSalesCreditNote_PL()
    {
        return salesTable.isCreditNote_PL();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the sales order can be modified.
    /// </summary>
    /// <param name = "_useWarning">
    /// A boolean value that indicates whether the user must be notified about the reasons why the changes are not allowed; optional.
    /// </param>
    /// <param name = "_interCompanyCheck">
    /// A boolean value that indicates whether the intercompany check must be performed; optional.
    /// </param>
    /// <param name = "_treatInvoicedOrderUpdateWarningAsError">
    /// A boolean value that indicates whether the "Warning" access level to invoiced orders must be treated as "Locked".
    /// </param>
    /// <returns>true if the modification is allowed; otherwise, false.</returns>
    public boolean checkUpdate(boolean _useWarning                             = true,
                               boolean _interCompanyCheck                      = true,
                               boolean _treatInvoicedOrderUpdateWarningAsError = false)
    {
        boolean                             ok = (salesTable ? true : false);
        PurchTable                          purchTable;
        InterCompanyPurchSalesReference     interCompanyPurchSalesReference;
        PurchLine                           purchLine;

        SalesTable salesTableLocal = SalesTable::find(salesTable.SalesId);

        if (this.shouldValidateSalesTableUpdateAccess(salesTableLocal))
        {
            if (this.isSalesCreditNote_PL())
            {
                return false;
            }

            switch (SalesParameters::find().accesLevelInvoiced(_treatInvoicedOrderUpdateWarningAsError))
            {
                case SalesPurchAccesLevel::Warning:
                    if (_useWarning && Box::yesNo("@SYS27045", DialogButton::Yes) != DialogButton::Yes)
                    {
                        ok = false;
                    }
                    break;

                case SalesPurchAccesLevel::Locked:
                    if (_useWarning)
                    {
                        warning("@SYP4861022");
                    }
                    ok = false;
                    break;
            }
        }

        if (this.mustValidateInterCompany(_interCompanyCheck))
        {
            if (!ok && salesTable && salesTable.isInterCompanyOrder())
            {
                warning("@SYS106306");
            }

            if (ok
            && salesTable.SkipUpdate != InterCompanySkipUpdate::InterCompany
            && salesTable.SkipUpdate != InterCompanySkipUpdate::Both
            && salesTable.isInterCompanyOrder())
            {
                changecompany(salesTable.InterCompanyCompanyId)
                {
                    purchTable = PurchTable::find(salesTable.InterCompanyPurchId);
                    if (purchTable)
                    {
                        purchTable.SkipUpdate = InterCompanySkipUpdate::InterCompany;
                        ok = purchTable.checkUpdate(false, _interCompanyCheck, _treatInvoicedOrderUpdateWarningAsError);
                    }
                }
            }

            if (ok
            && salesTable.SkipUpdate != InterCompanySkipUpdate::Internal
            && salesTable.SkipUpdate != InterCompanySkipUpdate::Both)
            {
                while select PurchId from interCompanyPurchSalesReference
                      where interCompanyPurchSalesReference.SalesId == salesTable.SalesId
                      exists join purchLine
                          where purchLine.PurchId == interCompanyPurchSalesReference.PurchId
                              && (!salesLineCaller.RecId || purchLine.InventRefTransId == salesLineCaller.InventTransId)
                              && (!salesLineCaller.RecId || purchLine.InventRefId      == salesLineCaller.SalesId)
                {
                    purchTable = PurchTable::find(interCompanyPurchSalesReference.PurchId);
                    if (purchTable && (purchTable.isInterCompanyOrder() || purchTable.InterCompanyDirectDelivery))
                    {
                        purchTable.SkipUpdate = InterCompanySkipUpdate::Internal;
                        ok = purchTable.checkUpdate(false, _interCompanyCheck, _treatInvoicedOrderUpdateWarningAsError);
                    }

                    if (!ok)
                    {
                        break;
                    }
                }
            }
        }

        // Disable edition for Retail Orders from POS with Channel
        if (salesTable.isRetailCashAndCarrySales())
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldValidateSalesTableUpdateAccess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the update access for the <c>SalesTable</c> record should be validated.
    /// </summary>
    /// <param name = "_salesTableLocal">
    /// The <c>SalesTable</c> record.
    /// </param>
    /// <returns>
    /// true if the update access for the <c>SalesTable</c> record should be validated; otherwise, false.
    /// </returns>
    protected boolean shouldValidateSalesTableUpdateAccess(SalesTable _salesTableLocal)
    {
        return salesTable && _salesTableLocal.SalesStatus == SalesStatus::Invoiced;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAllPriceDiscChangePolicies</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all previously set Price Discount Change Policies for the corresponding <c>SalesTable</c>
    /// record.
    /// </summary>
    /// <remarks>
    /// Removes policies from both Manual and System groups.
    /// </remarks>
    void clearAllPriceDiscChangePolicies()
    {
        salesTable.ManualEntryChangepolicy = 0;
        salesTable.SystemEntryChangePolicy = 0;
        salesTable.SystemEntrySource       = PriceDiscSystemSource::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearingLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount clearingLedgerDimension(CustPostingProfile _postingProfile_RU = '')
    {
        PaymTerm    paymTerm = salesTable.payment();

        if (paymTerm.CashLedgerDimension)
        {
            return paymTerm.CashLedgerDimension;
        }
        if (_postingProfile_RU)
        {
            return CustLedgerAccounts::clearingLedgerDimension(salesTable.InvoiceAccount,
                                                      _postingProfile_RU);
        }
        return CustLedgerAccounts::clearingLedgerDimension(salesTable.InvoiceAccount,
                                                            salesTable.PostingProfile );
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a sales order record is deleted.
    /// </summary>
    public void deleting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a sales order record has been deleted.
    /// </summary>
    public void deleted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dlvModeMandatory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the payment method for the sales order is COD.
    /// </summary>
    /// <returns>
    ///    true if payment method for the sales order is COD; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Child classes may override this method if it is necessary.
    /// </remarks>
    boolean dlvModeMandatory()
    {
        return (salesTable.payment().PaymMethod == NetCurrent::COD);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doDeliveryDateControl</Name>
				<Source><![CDATA[
    boolean doDeliveryDateControl()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the currency code is editable.
    /// </summary>
    /// <returns>
    /// true if currency code is editable; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Child classes may override this method if it is necessary.
    /// </remarks>
    public boolean editCurrencyCode()
    {
        return !salesTable.RecId || !salesTable.isInterCompanyPOInvoiceMatched();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditReportingCurrencyFixedExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the fixed exchange rate of the reporting currency is editable.
    /// </summary>
    /// <returns>
    /// true if the fixed exchange rate of reporting currency is editable; otherwise, false.
    /// </returns>
    public boolean canEditReportingCurrencyFixedExchangeRate()
    {
        return salesTable.CustVendReportingCurrencyFixedExchangeRate::canEditReportingCurrencyFixedExchangeRate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editCustAccount</Name>
				<Source><![CDATA[
    boolean editCustAccount()
    {
        boolean ret = !salesTable.RecId || !salesTable.isInterCompanyOrder();
        ret = ret && (salesTable.DocumentStatus == DocumentStatus::None
                   || salesTable.DocumentStatus == DocumentStatus::Confirmation);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editDisc</Name>
				<Source><![CDATA[
    // Can discount fields be edited
    boolean editDisc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editInclTax</Name>
				<Source><![CDATA[
    boolean  editInclTax()
    {
        return !salesTable.ProjId && (!salesTable.RecId || !salesTable.isInterCompanyPOInvoiceMatched());
    }

]]></Source>
			</Method>
			<Method>
				<Name>editInvoiceAccount</Name>
				<Source><![CDATA[
    boolean  editInvoiceAccount()
    {
        return !salesTable.RecId || !salesTable.isInterCompanyOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>editSalesType</Name>
				<Source><![CDATA[
    boolean editSalesType()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editVATNum</Name>
				<Source><![CDATA[
    boolean editVATNum()
    {
        return ! salesTable.ProjId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodClose</Name>
				<Source><![CDATA[
    public void formMethodClose()
    {
        if (numberSeqFormHandlerSalesId)
        {
            numberSeqFormHandlerSalesId.formMethodClose();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceCreate</Name>
				<Source><![CDATA[
    public void formMethodDataSourceCreate(FormRun _element, FormDataSource _salestable_ds)
    {
        this.numberSeqFormHandlerSalesId(_element, _salestable_ds).formMethodDataSourceCreate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceDelete</Name>
				<Source><![CDATA[
    public void formMethodDataSourceDelete(FormRun _element, FormDataSource _salestable_ds, boolean _forced = false)
    {
        this.numberSeqFormHandlerSalesId(_element, _salestable_ds).formMethodDataSourceDelete(_forced);
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceLinkActive</Name>
				<Source><![CDATA[
    public void formMethodDataSourceLinkActive(FormRun _element, FormDataSource _salestable_ds)
    {
        this.numberSeqFormHandlerSalesId(_element, _salestable_ds).formMethodDataSourceLinkActive();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceValidateWrite</Name>
				<Source><![CDATA[
    public boolean formMethodDataSourceValidateWrite(FormRun _element, FormDataSource _salestable_ds)
    {
        boolean ret = true;

        if (!this.numberSeqFormHandlerSalesId(_element, _salestable_ds).formMethodDataSourceValidateWrite())
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodDataSourceWrite</Name>
				<Source><![CDATA[
    public void formMethodDataSourceWrite(FormRun _element, FormDataSource _salestable_ds)
    {
        this.numberSeqFormHandlerSalesId(_element, _salestable_ds).formMethodDataSourceWrite();
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodSalesTypeModifiedPostChange</Name>
				<Source><![CDATA[
    public void formMethodSalesTypeModifiedPostChange(FormRun         _element,
                                                      FormDataSource  _salestable_ds,
                                                      boolean         _forced = false
                                                     )
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>formMethodSalesTypeModifiedPreChange</Name>
				<Source><![CDATA[
    public void formMethodSalesTypeModifiedPreChange(FormRun          _element,
                                                     FormDataSource   _salestable_ds,
                                                     boolean          _forced = false
                                                    )
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPriceDiscChangePolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether price discount policies exist for a record.
    /// </summary>
    /// <returns>
    /// true if price discount policies exist; otherwise, false.
    /// </returns>
    public boolean hasPriceDiscChangePolicy()
    {
        return salesTable.SystemEntryChangePolicy
               || salesTable.SystemEntrySource
               || salesTable.ManualEntryChangepolicy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initValue</Name>
				<Source><![CDATA[
    public void  initValue()
    {
        SalesParameters     salesParameters     = SalesParameters::find();
        CustParameters      custParameters      = CustParameters::find();
        IntrastatParameters intrastatParameters = IntrastatParameters::find();
        // <GMY>
        // </GMY>

        salesTable.DeliveryDateControlType  = salesParameters.DeliveryDateControlType;
        SalesCalcAvailableDlvDates::initDateFields(salesTable);

        salesTable.SalesStatus              = SalesStatus::Backorder;

        if (salesParameters.ValidDays)
        {
            salesTable.Deadline             = InventOrderEntryDeadlineTable::effectiveOrderDate('','') + salesParameters.ValidDays;
        }
        salesTable.TransactionCode          = intrastatParameters.DefaultSalePurchase;
        salesTable.Transport                = intrastatParameters.TransportModeParm;
        salesTable.Port                     = intrastatParameters.PortParm;
        salesTable.StatProcId               = intrastatParameters.StatProcIdParm;
        salesTable.CountyOrigDest           = intrastatParameters.CountyOrigDest;
        salesTable.SalesPoolId              = salesParameters.SalesPoolId;
        salesTable.Reservation              = salesParameters.Reservation;
        if (#PdsBatchAttribEnabled)
        {
            salesTable.PdsBatchAttribAutoRes
                = salesParameters.PdsBatchAttribAutoRes;
        }
        salesTable.SalesOriginId            = salesParameters.SalesOriginId;

        if (custParameters.AutoSettle == NoYes::Yes)
        {
            salesTable.SettleVoucher = SettlementType::OpenTransact;
        }
        salesTable.PostingProfile           = custParameters.PostingProfile;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            SalesTable_RU salesTableRU = salesTable.salesTable_RU();

            salesTableRU.InventProfileId_RU            = salesParameters.InventProfileId_RU;
            salesTableRU.InventProfileType_RU          = InventProfile_RU::find(salesTableRU.InventProfileId_RU).InventProfileType;
            salesTableRU.InventProfileUseRelated_RU    = salesParameters.InventProfileUseRelated_RU;
            salesTableRU.InvoicePostingType_RU         = salesParameters.InvoicePostingType_RU;

            salesTable.packSalesTable_RU(salesTableRU);
        }

        // <GMY>
        if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
        {
            SalesTable_W salesTable_W = salesTable.salesTable_W();
            salesTable_W.initValue();
            salesTable.packSalesTable_W(salesTable_W);
        }
        // </GMY>
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a sales order record is inserted.
    /// </summary>
    public void inserting()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inserted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a sales order record has been inserted.
    /// </summary>
    public void inserted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCheckWMS</Name>
				<Source><![CDATA[
    public boolean interCompanyCheckWMS()
    {
        boolean                             ok = true;
        SalesLine                           salesLine;
        PurchLine                           purchLine;
        PurchTable                          purchTable;
        InventTable                         inventTable;
        EcoResStorageDimensionGroupItem     ecoResStorageDimensionGroupItem;
        EcoResStorageDimensionGroupFldSetup ecoResStorageDimensionGroupFldSetup;
        int                                 fieldNumWMSLocationId = fieldNum(InventDim,wmsLocationId);

        select firstonly forceplaceholders ItemId from salesLine
              where salesLine.SalesId       == salesTable.SalesId
              &&    salesLine.InventRefType == InventRefType::Purch
        join  RecId from inventTable
              where inventTable.ItemId == salesLine.ItemId
        join  RecId from ecoResStorageDimensionGroupItem
              where ecoResStorageDimensionGroupItem.ItemDataAreaId  == inventTable.DataAreaId
                 && ecoResStorageDimensionGroupItem.ItemId          == inventTable.ItemId
        join  RecId from ecoResStorageDimensionGroupFldSetup
              where ecoResStorageDimensionGroupFldSetup.StorageDimensionGroup       == ecoResStorageDimensionGroupItem.StorageDimensionGroup
              &&   ecoResStorageDimensionGroupFldSetup.DimensionFieldId            == fieldNumWMSLocationId
              &&    ecoResStorageDimensionGroupFldSetup.IsActive                    == NoYes::Yes
              &&   (ecoResStorageDimensionGroupFldSetup.IsAllowBlankIssueEnabled    == NoYes::No
                 || ecoResStorageDimensionGroupFldSetup.IsAllowBlankReceiptEnabled  == NoYes::No)
        join  RecId from purchLine
              where purchLine.InventTransId == salesLine.InventRefTransId
                && !purchLine.IsDeleted
        join  RecId from purchTable
              where purchTable.PurchId           == purchLine.PurchId
              &&    purchTable.InterCompanyOrder == true;

        if (salesLine.ItemId)
        {
            ok = checkFailed(strFmt("@SYS99181", salesLine.ItemId));
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyCreateAllowed</Name>
				<Source><![CDATA[
    boolean interCompanyCreateAllowed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyDelete</Name>
				<Source><![CDATA[
    void  interCompanyDelete()
    {
        if (salesTable.SkipUpdate == InterCompanySkipUpdate::InterCompany
        ||  salesTable.SkipUpdate == InterCompanySkipUpdate::Both
        || !this.interCompanyCreateAllowed())
        {
            return;
        }

        if (! TradeInterCompany::checkDataAreaAccess(salesTable.InterCompanyCompanyId))
        {
            return;
        }

        changecompany(salesTable.InterCompanyCompanyId)
        {
            PurchTable purchTable = PurchTable::find(salesTable.InterCompanyPurchId, true);

            if (purchTable)
            {
                purchTable.SkipUpdate = InterCompanySkipUpdate::InterCompany;
                purchTable.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyIsBeingUpdated</Name>
				<Source><![CDATA[
    boolean interCompanyIsBeingUpdated(boolean _checkThis = false)
    {
        InterCompanyPurchSalesReference interCompanyPurchSalesReference;
        PurchTable                      purchTable;
        SalesLine                       salesLineLocal;
        boolean                         ret = false;

        void checkSalesLine(SalesId _salesId)
        {
            salesLineLocal = null;
            while select salesLineLocal
                index hint SalesLineIdx
                where salesLineLocal.SalesId == _salesId
            {
                ret = salesLineLocal.SalesStatus == SalesStatus::Delivered
                    || salesLineLocal.SalesStatus == SalesStatus::Invoiced
                    || salesLineLocal.SalesStatus == SalesStatus::Canceled;

                if (!ret)
                {
                    ret = salesLineLocal.interCompanyIsBeingUpdated(false, _checkThis);
                }
                if (ret)
                {
                    break;
                }
            }
        }

        if (_checkThis)
        {
            checkSalesLine(salesTable.SalesId);
        }

        if (!ret)
        {
            while select forceplaceholders RecId from interCompanyPurchSalesReference
                  where interCompanyPurchSalesReference.SalesId == salesTable.SalesId
            join  InterCompanyCompanyId, InterCompanySalesId from purchTable
                  where purchTable.PurchId == interCompanyPurchSalesReference.PurchId
                  &&    purchTable.InterCompanyOrder
                  &&    purchTable.InterCompanyCompanyId
            {
                changecompany(purchTable.InterCompanyCompanyId)
                {
                    checkSalesLine(purchTable.InterCompanySalesId);
                }

                if (ret)
                {
                    break;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyIsDerivedOrder</Name>
				<Source><![CDATA[
    public boolean interCompanyIsDerivedOrder()
    {
        return (salesTable.InterCompanyOrigin == InterCompanyOrigin::Derived && salesTable.isInterCompanyOrder())
            || (salesTable.InterCompanyCompanyId && salesTable.InterCompanyOriginalSalesId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyMarkupMirror</Name>
				<Source><![CDATA[
    void  interCompanyMarkupMirror()
    {
        MarkupTrans markupTrans;

        changecompany(salesTable.InterCompanyCompanyId)
        {
            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            PurchTable purchTable = PurchTable::find(salesTable.InterCompanyPurchId);
            if (purchTable)
            {
                while select forupdate markupTrans
                      index hint TableRecIdIdx
                      where markupTrans.TransTableId == purchTable.TableId
                      &&    markupTrans.TransRecId   == purchTable.RecId
                      &&   !markupTrans.IsDeleted
                {
                    markupTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySyncEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the header-level synchronization engine for intercompany trade.
    /// </summary>
    /// <returns>A new instance of <c>InterCompanySyncSalesTableType</c> or one of its subclasses.</returns>
    public InterCompanySyncSalesTableType interCompanySyncEngine()
    {
        return InterCompanySyncSalesTableType::newFromSalesTableType(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>forceIntercompanyLineSynchronization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Force intercompany synchronization of all sales order lines.
    /// </summary>
    public void forceIntercompanyLineSynchronization()
    {
        SalesLine salesLine;

        while select forupdate salesLine
                index hint SalesLineIdx
                where salesLine.SalesId == salesTable.SalesId
        {
            salesLine.forceIntercompanySynchronization();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanySalesReferenceExist</Name>
				<Source><![CDATA[
    boolean interCompanySalesReferenceExist()
    {
        return salesTable.existInterCompanySales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventLotInvoke</Name>
				<Source><![CDATA[
    boolean  inventLotInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventOnHandInvoke</Name>
				<Source><![CDATA[
    boolean  inventOnHandInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReservationInvoke</Name>
				<Source><![CDATA[
    boolean  inventReservationInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransactInvoke</Name>
				<Source><![CDATA[
    boolean  inventTransactInvoke()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditCheckEligible</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a sale is eligible for a credit check.
    /// </summary>
    /// <returns>
    ///    true if this sale is eligible for a credit check; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This base class method unconditionally returns true.If certain specialized types of sales order are
    ///    not eligible to the credit limit check they should override this method to return false;
    /// </remarks>
    boolean isCreditCheckEligible()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isItemRequirement</Name>
				<Source><![CDATA[
    boolean isItemRequirement()
    {
        return (salesTable.SalesType == SalesType::ItemReq);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lowestSalesStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the lowest status on sales lines.
    /// </summary>
    /// <returns>
    /// The lowest status on the sales lines.
    /// </returns>
    public SalesStatus lowestSalesStatus()
    {
        SalesLine               salesLine;
        Set                     salesOrderStatusesSet = new Set(Types::Enum);

        while select SalesStatus from salesLine
            group by SalesStatus
            where salesLine.SalesId == salesTable.SalesId
                && salesLine.SalesStatus != SalesStatus::None
        {
            salesOrderStatusesSet.add(salesLine.SalesStatus);
        }

        SalesStatusOrderedList  salesStatusOrderedList = SalesStatusOrderedList::newFromOrder(SortOrder::Ascending);
        ListEnumerator salesStatusEnumerator = salesStatusOrderedList.getEnumerator();
        while (salesStatusEnumerator.moveNext())
        {
            if (salesOrderStatusesSet.in(salesStatusEnumerator.current()))
            {
                return salesStatusEnumerator.current();
            }
        }

        return SalesStatus::Backorder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupAllowed</Name>
				<Source><![CDATA[
    public boolean markupAllowed()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayBankDocumentTypeBeModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>BankDocumentType</c> field can be modified.
    /// </summary>
    /// <returns>
    /// true if the field can be modified; otherwise, false.
    /// </returns>
    public boolean mayBankDocumentTypeBeModified()
    {
        boolean ok              = false;
        boolean enableLCFeature = BankLCExportFeatureChecker::checkBankLCExportEnabled();
        boolean enableLGFeature = BankLGFeatureChecker::checkBankLGEnabled();

        if (enableLCFeature || enableLGFeature)
        {
            if (!salesTable.isBankDocumentCreated())
            {
                if (enableLCFeature)
                {
                    if (salesTable.mayBankDocumentTypeBeBankLCExport())
                    {
                        ok = true;
                    }
                }

                if (!ok && enableLGFeature)
                {
                    if (salesTable.mayBankDocumentTypeBeBankLG())
                    {
                        ok = true;
                    }
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayConfirmationBeUpdated</Name>
				<Source><![CDATA[
    boolean mayConfirmationBeUpdated()
    {
        boolean ok = (!(salesTable.SalesStatus  == SalesStatus::Invoiced    ||
                salesTable.SalesStatus  == SalesStatus::Delivered   ||
                salesTable.SalesStatus  == SalesStatus::Canceled)
                && (salesTable.mcrOrderStopped == NoYes::No
                    || !isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
                );

        if (ok && salesCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::Confirmation, SalesPurchCycleModuleParameter::Cust, salesTable.CustAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::Confirmation, SalesPurchCycleModuleParameter::CustParameter, '').Active)
                {
                    ok = false;
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayFactureBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean mayFactureBeUpdated_RU()
    {
        return this.mayInvoiceBeUpdated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayInvoice4PaymBeUpdated_RU</Name>
				<Source><![CDATA[
    public boolean mayInvoice4PaymBeUpdated_RU()
    {
        return this.mayConfirmationBeUpdated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayInvoiceBeUpdated</Name>
				<Source><![CDATA[
    boolean mayInvoiceBeUpdated()
    {
        boolean ok = true;

        if (salesTable.mcrOrderStopped == NoYes::Yes
            || salesTable.SalesStatus == SalesStatus::Canceled
            || RetailCommercePaymentsFeatureHelper::commercePaymentsOrderWhenFeatureDisabled(salesTable))
        {
            ok = false;
        }

        if (ok && salesCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::Invoice, SalesPurchCycleModuleParameter::Cust, salesTable.CustAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::Invoice, SalesPurchCycleModuleParameter::CustParameter, '').Active)
                {
                    ok = false;
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPackingSlipBeUpdated</Name>
				<Source><![CDATA[
    boolean mayPackingSlipBeUpdated()
    {
        boolean ok = true;

        if (salesTable.mcrOrderStopped == NoYes::Yes
            || salesTable.SalesStatus == SalesStatus::Canceled)
        {
            ok = false;
        }

        if (ok && salesCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PackingSlip, SalesPurchCycleModuleParameter::Cust, salesTable.CustAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PackingSlip, SalesPurchCycleModuleParameter::CustParameter, '').Active)
                {
                    ok = false;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPickingListBeRegistered</Name>
				<Source><![CDATA[
    boolean  mayPickingListBeRegistered()
    {
        boolean ok = true;

        if (ok && salesCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PickingListRegistrate, SalesPurchCycleModuleParameter::Cust, salesTable.CustAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PickingListRegistrate, SalesPurchCycleModuleParameter::CustParameter, '').Active)
                {
                    ok = false;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayPickingListBeUpdated</Name>
				<Source><![CDATA[
    boolean mayPickingListBeUpdated()
    {
        boolean ok = true;

        if (salesTable.mcrOrderStopped == NoYes::Yes
            || salesTable.SalesStatus == SalesStatus::Canceled)
        {
            ok = false;
        }

        if (ok && salesCycle)
        {
            salesPurchCycle = SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PickingList, SalesPurchCycleModuleParameter::Cust, salesTable.CustAccount);

            if (salesPurchCycle)
            {
                if (!salesPurchCycle.Active)
                {
                    ok = false;
                }
            }
            else
            {
                if (!SalesPurchCycle::findBySalesPurchaseCycle(SalesPurchCycleAction::PickingList, SalesPurchCycleModuleParameter::CustParameter, '').Active)
                {
                    ok = false;
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayProjectPackingSlipBeUpdated</Name>
				<Source><![CDATA[
    boolean mayProjectPackingSlipBeUpdated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayProjectPickingListBeUpdated</Name>
				<Source><![CDATA[
    boolean mayProjectPickingListBeUpdated()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrAllowOpenOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the sales order is allowed to remain in an "open order" status.
    /// </summary>
    /// <returns>
    ///     true.
    /// </returns>
    public boolean mcrAllowOpenOrder()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrAllowPaymentAccess</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the sales order user is allowed to access payments.
    /// </summary>
    /// <returns>
    ///     true.
    /// </returns>
    public boolean mcrAllowPaymentAccess()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrSetReturnStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the return status of the sales order.
    /// </summary>
    protected void mcrSetReturnStatus()
    {
        if (salesTable.SalesType == SalesType::ReturnItem &&
           salesTable.orig().SalesStatus != salesTable.SalesStatus)
        {
            salesTable.ReturnStatus = this.mcrGetReturnStatus();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetReturnStatusDelegate</Name>
				<Source><![CDATA[
    delegate void mcrGetReturnStatusDelegate(SalesTable _salesTable, EventHandlerResult _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrGetReturnStatus</Name>
				<Source><![CDATA[
    protected ReturnStatusHeader mcrGetReturnStatus()
    {
        switch (salesTable.SalesStatus)
        {
            case SalesStatus::Canceled:
                return ReturnStatusHeader::Canceled;
            case SalesStatus::Invoiced:
                return ReturnStatusHeader::Closed;
            case SalesStatus::Backorder:
                return ReturnStatusHeader::Created;
            default:
                EventHandlerResult result = EventHandlerResult::newSingleResponse();
                this.mcrGetReturnStatusDelegate(salesTable, result);

                if (result.hasResult())
                {
                    return result.result();
                }

                // sales status is either in processing, delivered or none
                if ((select firstonly RecId from salesLine
                            where salesLine.SalesId == salesTable.SalesId
                               && salesLine.ReturnStatus != ReturnStatusLine::Awaiting).RecId == 0)
                {
                    return ReturnStatusHeader::Created;
                }

                if ((select firstonly RecId from salesLine
                            where salesLine.SalesId == salesTable.SalesId
                                && (salesLine.ReturnStatus == ReturnStatusLine::Received
                                 || salesLine.ReturnStatus == ReturnStatusLine::Registered )).RecId != 0)
                {
                    return ReturnStatusHeader::Open;
                }

                return salesTable.ReturnStatus;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTypeCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks sales order lines to be sure the type can be changed.
    /// </summary>
    /// <returns>
    ///     true if the sales line type can be changed; otherwise, false.
    /// </returns>
    boolean mcrTypeCheck()
    {
        SalesLine           salesLine;
        InventTrans         inventTrans;
        InventTransOrigin   inventTransOrigin;
        MCRSalesLine        mcrSalesLine;

        // If it's a sales order, can change type
        if (salesTable.SalesType == SalesType::Sales)
        {
            return true;
        }

        while select QtyOrdered from salesLine
            where salesLine.SalesId == salesTable.SalesId
            join RecId from inventTransOrigin
            where inventTransOrigin.InventTransId == salesLine.InventTransId
            join StatusIssue from inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
            outer join ContinuityScheduleId from mcrSalesLine
            where mcrSalesLine.SalesLine == salesLine.RecId
        {
            // If it's a continuity line do not allow order change
            if (mcrSalesLine.ContinuityScheduleId)
            {
                salesTable.SalesType = salesTable.orig().SalesType;
                checkFailed("@MCR24291");
                return false;
            }
            // If it's a return order, quantity on lines must be negative
            else if (salesTable.SalesType == SalesType::ReturnItem)
            {
                if (salesLine.QtyOrdered > 0)
                {
                    salesTable.SalesType = salesTable.orig().SalesType;
                    checkFailed(strFmt("@MCR24290", salesTable.orig().SalesType, salesTable.SalesType));
                    return false;
                }
            }
            // If the line has been processed in inventory do not allow change
            if (inventTrans.StatusIssue != StatusIssue::OnOrder &&
                inventTrans.StatusIssue != StatusIssue::None)
            {
                salesTable.SalesType = salesTable.orig().SalesType;
                checkFailed(strFmt("@MCR24289", salesTable.orig().SalesType, salesTable.SalesType));
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUpdateSalesLineDropShipStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates all sales order lines with the passed dropship status and clears the reference type.
    /// </summary>
    /// <param name="_mcrDropShipStatus">
    ///     The drop shipment status to be deleted.
    /// </param>
    /// <remarks>
    ///     This method is used when cancelling a sales order and all related purchase orders are deleted.
    /// </remarks>
    void mcrUpdateSalesLineDropShipStatus(MCRDropShipStatus _mcrDropShipStatus)
    {
        SalesLine                   salesLine;
        MCRSalesLineDropShipment    mcrSalesLineDropShipment;

        update_recordset salesLine
            setting InventRefId = "",
            InventRefTransId    = "",
            InventRefType       = InventRefType::None
        where salesLine.SalesId == salesTable.SalesId;

        MCRDropShipStatusInstrumentationActivities dropShipStatusActivities = MCRDropShipInstrumentationLogger::createLogger(classId2Name(classIdGet(this))).dropShipStatusActivities();

        using (var activityContext = dropShipStatusActivities.updateRecordSetSalesTableTypeDropShipStatus(salesTable))
        {
            update_recordset mcrSalesLineDropShipment
                setting DropShipStatus = _mcrDropShipStatus
                join salesLine
                where salesLine.SalesId == salesTable.SalesId
                    && mcrSalesLineDropShipment.SalesLine == salesLine.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedBankDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the fields that are affected by the <c>BankDocumentType</c> field.
    /// </summary>
    /// <remarks>
    /// This method should be called after the <c>BankDocumentType</c> field has been modified.
    /// </remarks>
    public void modifiedBankDocumentType()
    {
        if (salesTable.isMarkedForBankLC())
        {
            salesTable.Payment              = "";
            salesTable.FixedDueDate         = dateNull();
            salesTable.PaymMode             = "";
            salesTable.PaymSpec             = "";
            salesTable.PaymentSched         = "";
            salesTable.CashDisc             = "";
            salesTable.CashDiscPercent      = 0;
            salesTable.CreditCardCustRefId  = 0;
            salesTable.SettleVoucher        = SettlementType::None;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifiedField</Name>
				<Source><![CDATA[
    public void modifiedField(FieldId _fieldId
        , TableId _tableId = tableNum(SalesTable)
        , boolean _uiEnabled = true
        )
    {
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        if (_tableId == tableNum(SalesTable))
        {
            switch (_fieldId)
            {
                case fieldNum(SalesTable, DlvMode):
                    DlvMode dlvMode = DlvMode::find(salesTable.DlvMode);
                    salesTable.ShipCarrierId          = dlvMode.ShipCarrierId;
                    salesTable.ShipCarrierAccountCode = dlvMode.ShipCarrierAccountCode;
                    salesTable.ShipCarrierDlvType     = dlvMode.ShipCarrierDlvType;
                    salesTable.Transport              = dlvMode.Transport;
                    break;

                case fieldNum(SalesTable, ReturnDeadline):
                    salesTable.updateDeadlineOnLine();
                    break;

                case fieldNum(SalesTable, DeliveryPostalAddress):
                    LogisticsLocationSelectForm_SalesTable::construct(salesTable).copyAddressToCaller(salesTable.getDeliveryEntityRecord(),
                        salesTable.DeliveryPostalAddress);
                    break;

                case fieldNum(SalesTable, OneTimeCustomer):
                    salesTable.modifiedOneTimeCustomer();
                    break;

                case fieldNum(SalesTable, ContactPersonId):
                    salesTable.initFromContactInfo();
                    break;

                case fieldNum(SalesTable, CustAccount):
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                        && salesTable.CustAccount
                        && TaxParameters::find().Customs_IN == NoYes::Yes)
                    {
                        salesTable.CustomsExportOrder_IN = CustTable::find(salesTable.CustAccount).isForeign();
                    }

                    if (salesTable.RecId && salesTable.MatchingAgreement && salesTable.CustAccount != salesTable.orig().CustAccount )
                    {
                        if (!salesTable.unlinkAgreementPrompt(
                                                              false
                                                              ))
                        {
                            salesTable.CustAccount = salesTable.orig().CustAccount;
                            break;
                        }
                    }

                    if (salesTable.CustAccount && salesTable.DeliveryPostalAddress)
                    {
                        salesTable.DeliveryPostalAddress = 0;
                    }
                    if (salesTable.CustAccount && salesTable.ShipCarrierPostalAddress)
                    {
                        salesTable.ShipCarrierPostalAddress = 0;
                        salesTable.ShipCarrierName = "";
                    }

                    if (salesTable.existMarkedSettlement(_fieldId))
                    {
                        salesTable.CustAccount = salesTable.orig().CustAccount;
                    }
                    else if (salesTable.CreditCardCustRefId && salesTable.CustAccount != salesTable.orig().CustAccount)
                    {
                        // If this is a credit card sales order try to find valid authorization.
                        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::findValidPreApproval(salesTable.SalesId);
                        if (creditCardAuthTrans)
                        {
                            // save old customer and persist all uncommitted fields to the DB
                            CustAccount oldCustAccount = salesTable.orig().CustAccount;
                            salesTable.write();
                            // try voiding authorization
                            if (CreditCardProcess::doVoidAuth(creditCardAuthTrans))
                            {
                                // If voided successfully then read updated salesTable, transfer new customer information and erase credit card number.
                                salesTable.reread();
                                salesTable.transferCustAccount();
                                this.clearCreditCardCustomerReference();
                            }
                            else
                            {
                                // If void failed then re-assign old customer.
                                // No need in transferring customer data because salesTable should still have old one.
                                salesTable.CustAccount = oldCustAccount;
                            }
                            salesTable.write();
                        }
                        else
                        {
                            salesTable.transferCustAccount();
                            this.clearCreditCardCustomerReference();
                        }
                    }
                    else
                    {
                        salesTable.transferCustAccount();
                    }

                    if (salesTable && salesTable.CustAccount != salesTable.orig().CustAccount && SalesParameters::find().mcrCopyNotes)
                    {
                        this.removeDocuRef(salesTable, salesTable.orig().CustAccount);

                        DocuType docuType;

                        while select TypeId from docuType
                            where docuType.TypeGroup == DocuTypeGroup::Note
                        {
                            Docu::copy(salesTable.custTable_CustAccount(), salesTable, docuType.TypeId);
                        }
                    }

                    if (RetailEnableB2b2bAndEnhanceB2bOrdersFeature::isEnabled())
                    {
                        if (salesTable && salesTable.CustAccount != salesTable.orig().CustAccount)
                        {
                            RetailSalesTable retailSalesTable = salesTable.retailSalesTable();

                            if (retailSalesTable.RetailChannel && retailSalesTable.OriginChannel)
                            {
                                RetailCallCenterEventLog::EventWriteCustomerAndChannelUpdatedForRetailOrder(funcName(),
                                    salesTable.RecId,
                                    salesTable.RetailChannelTable,
                                    retailSalesTable.RetailChannel,
                                    retailSalesTable.OriginChannel);

                                retailSalesTable.RetailChannel = retailSalesTable.OriginChannel;
                                salesTable.RetailChannelTable = retailSalesTable.OriginChannel;
                            }
                        }
                    }

                    if (RetailCallCenterChannelFinancialDimensionToggle::instance().isEnabled())
                    {
                        RetailSalesTable retailSalesTable = this.salesTable().retailSalesTable();

                        if (retailSalesTable.RetailChannel)
                        {
                            RetailChannelTable retailChannelTable = RetailChannelTable::findByRecId(retailSalesTable.RetailChannel);
                            salesTable.DefaultDimension = this.salesTable().mergeDimension(retailChannelTable.DefaultDimension);

                            if (!salesTable.InventSiteId)
                            {
                                // Default warehouse on call centre should be used as a fallback warehouse for call centre sales orders when none provided.
                                salesTable.InventLocationId = retailChannelTable.inventLocation;
                                // Fallback to call center channel warehouse site in case none is defined.
                                salesTable.InventSiteId = InventLocation::findInLegalEntity(retailChannelTable.inventLocation, retailChannelTable.inventLocationDataAreaId).InventSiteId;
                            }
                        }
                    }
                    break;

                case fieldNum(SalesTable, RetailChannelTable):
                    if (B2B2BDataHelper::isMultipleCatalogsAvailableInB2b2bOrders())
                    {
                        if (salesTable && salesTable.orig().isB2b2bOrder() && salesTable.RetailChannelTable != salesTable.orig().RetailChannelTable)
                        {
                            if (salesTable.isB2b2bOrder())
                            {
                                // When RetailChannelTable field is changed from a b2b online channel to another b2b online channel,
                                // validate catalogs on lines.
                                salesTable.validateAllCatalogsForRetailB2b2bOrder();
                            }
                        }
                    }
                    break;

                case fieldNum(SalesTable, ProjId):
                    salesTable.modifiedProjId();
                    break;

                case fieldNum(SalesTable, Payment):
                    salesTable.initFromPayment();
                    break;

                case fieldNum(SalesTable, PaymMode):
                    salesTable.paymModeModified();
                    salesTable.DirectDebitMandate = CustDirectDebitMandate::defaultAndDisplayMandate(
                        salesTable.InvoiceAccount,
                        salesTable.PaymMode,
                        salesTable.DirectDebitMandate,
                        false,
                        FormDataUtil::getFormDataSource(salesTable),
                        fieldNum(SalesTable, DirectDebitMandate));
                    break;

                case fieldNum(SalesTable, InterCompanyOrder):
                    salesTable.modifiedInterCompanyOrder();
                    break;

                case fieldNum(SalesTable, BankDocumentType):
                    this.modifiedBankDocumentType();
                    break;

                case fieldNum(SalesTable, SalesType):
                    if (salesTable.SalesType != SalesType::Sales && salesTable.isMarkedForBankLC())
                    {
                        salesTable.BankDocumentType = BankDocumentType::None;
                    }
                    break;

                case fieldNum(SalesTable, InvoiceAccount):
                    if (countryRegion_RU)
                    {
                        if (salesTable.RecId && salesTable.MatchingAgreement && salesTable.InvoiceAccount != salesTable.orig().InvoiceAccount)
                        {
                            if (!salesTable.unlinkAgreementPrompt())
                            {
                                salesTable.InvoiceAccount = salesTable.orig().InvoiceAccount;
                                break;
                            }
                        }
                    }

                    if (salesTable.existMarkedSettlement(_fieldId))
                    {
                        salesTable.InvoiceAccount = salesTable.orig().InvoiceAccount;
                    }
                    else if (salesTable.CreditCardCustRefId && salesTable.InvoiceAccount != salesTable.orig().InvoiceAccount)
                    {
                        CreditCardAuthTrans creditCardAuthTrans = CreditCardAuthTrans::findValidPreApproval(salesTable.SalesId);
                        if (creditCardAuthTrans)
                        {
                            ttsbegin;

                            CustAccount oldInvoiceAccount = salesTable.orig().InvoiceAccount;
                            salesTable.write();

                            if (CreditCardProcess::doVoidAuth(creditCardAuthTrans))
                            {
                                salesTable.reread();
                                salesTable.transferInvoiceAccount();
                                this.clearCreditCardCustomerReference();
                            }
                            else
                            {
                                salesTable.InvoiceAccount = oldInvoiceAccount;
                            }
                            salesTable.write();

                            ttscommit;
                        }
                        else
                        {
                            salesTable.transferInvoiceAccount();
                            this.clearCreditCardCustomerReference();
                        }
                    }
                    else
                    {
                        salesTable.transferInvoiceAccount();
                    }

                    if (SalesDirectDebitMandateFromInvoiceAccountFlight::instance().isEnabled())
                    {
                        salesTable.DirectDebitMandate = CustDirectDebitMandate::defaultAndDisplayMandate(
                                                                                    salesTable.InvoiceAccount,
                                                                                    salesTable.PaymMode,
                                                                                    salesTable.DirectDebitMandate,
                                                                                    true,
                                                                                    FormDataUtil::getFormDataSource(salesTable),
                                                                                    fieldNum(SalesTable, DirectDebitMandate));
                    }

                    break;

                case fieldNum(SalesTable, ReceiptDateRequested):
                    if (salesTable.ShippingDateRequested > salesTable.ReceiptDateRequested)
                    {
                        salesTable.ShippingDateRequested = salesTable.ReceiptDateRequested;
                        salesTable.DeliveryDate          = salesTable.ShippingDateConfirmed ? salesTable.ShippingDateConfirmed : salesTable.ShippingDateRequested;
                    }
                    break;

                case fieldNum(SalesTable, ShippingDateRequested):
                    salesTable.DeliveryDate = salesTable.ShippingDateConfirmed ? salesTable.ShippingDateConfirmed : salesTable.ShippingDateRequested;

                    if (salesTable.ShippingDateRequested > salesTable.ReceiptDateRequested)
                    {
                        salesTable.ReceiptDateRequested = salesTable.ShippingDateRequested;
                    }
                    break;

                case fieldNum(SalesTable, ShippingDateConfirmed):
                    salesTable.DeliveryDate = salesTable.ShippingDateConfirmed ? salesTable.ShippingDateConfirmed : salesTable.ShippingDateRequested;

                    if (salesTable.ShippingDateConfirmed > salesTable.ReceiptDateConfirmed)
                    {
                        salesTable.ReceiptDateConfirmed = salesTable.ShippingDateConfirmed;
                    }
                    break;
                case fieldNum(SalesTable, Reservation):
                    if (salesTable.Reservation != ItemReservation::Automatic
                        && salesTable.PdsBatchAttribAutoRes)
                    {
                        salesTable.PdsBatchAttribAutoRes = NoYes::No;
                    }
                    break;

                case fieldNum(SalesTable, ReceiptDateConfirmed):
                    if (salesTable.ShippingDateConfirmed > salesTable.ReceiptDateConfirmed)
                    {
                        salesTable.ShippingDateConfirmed = salesTable.ReceiptDateConfirmed;
                        salesTable.DeliveryDate          = salesTable.ShippingDateConfirmed ? salesTable.ShippingDateConfirmed : salesTable.ShippingDateRequested;
                    }
                    break;
                case fieldNum(SalesTable, BankCentralBankPurposeCode):
                    salesTable.BankCentralBankPurposeText = BankCentralBankPurpose::find(salesTable.BankCentralBankPurposeCode).Text;
                    break;

                case fieldNum(SalesTable, CurrencyCode):
                    if (salesTable.ProjId)
                    {
                        salesTable.FixedExchRate = ProjInvoiceCurrency::find(salesTable.projTable().projInvoice().ProjInvoiceProjId,salesTable.CurrencyCode).ExchRate;
                        salesTable.setReportingCurrencyFixedExchangeRate();
                    }

                    if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByBusinessProcess(TaxIntegrationBusinessProcess::Sales))
                    {
                        TaxSpecificExchangeRate::deleteBySourceRecord(salesTable.TableId, salesTable.RecId);
                    }
                    else if (TaxParameters::isBankExchRateEnabled_W())
                    {
                        SalesTaxTransactionExchangeRate salesTaxTransactionExchangeRate = SalesTaxTransactionExchangeRate::findBySourceRecord(salesTable.TableId, salesTable.RecId);

                        if (salesTaxTransactionExchangeRate)
                        {
                            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00009, funcName());
                            SalesTaxExchangeRateHelper::maintainSalesTaxTransactionExchangeRate(
                                salesTable, salesTable.CurrencyCode, TransactionType::Sales, salesTaxTransactionExchangeRate.DateOfVATRegister);
                        }
                    }
                    break;

                case fieldNum(SalesTable, InventSiteId):
                    salesTable.InventStorageDimMap::modifiedField(fieldNum(InventStorageDimMap, InventSiteId));
                    if (!salesTable.RecId)
                    {
                        SalesCalcAvailableDlvDates::initDateFieldsOrderEntryDeadline(salesTable);
                    }
                    salesTable.modifiedInventSiteFromParent();
                    break;

                case fieldNum(SalesTable, InventLocationId):
                    salesTable.InventStorageDimMap::modifiedField(fieldNum(InventStorageDimMap, InventLocationId));
                    break;

                case fieldNum(SalesTable, DiscPercent):
                    salesTable.setPriceDiscChangePolicy(PriceDiscSystemSource::ManualEntry, _fieldId);
                    break;

                case fieldNum(SalesTable, MatchingAgreement):
                    if (countryRegion_RU)
                    {
                        SalesTable_RU salesTableRU = salesTable.salesTable_RU();
                        salesTableRU.AgreementHeaderExt_RU = SalesAgreementHeaderExt_RU::findBySalesAgreementHeader(salesTable.MatchingAgreement).RecId;
                        salesTable.packSalesTable_RU(salesTableRU);

                        salesTable.setAgreement_RU();
                    }
                    break;

                case fieldNum(SalesTable, DlvTerm):
                    this.setTaxGroup(TaxSales::custTaxGroup(salesTable.DlvTerm, salesTable.TaxGroup, salesTable.deliveryLocation()));
                    LogisticsLocationSelectForm_SalesTable::construct(salesTable).copyThirtyPartyAddressToCaller();
                    break;

                case fieldNum(SalesTable, CashDisc):
                    salesTable.CashDiscPercent = CashDisc::find(salesTable.CashDisc).Percent;
                    break;

                default: break;
            }

            salesTable.modifiedFieldDDC(_fieldId, _uiEnabled);
        }
        else if (countryRegion_RU && _tableId == tableNum(SalesTable_RU))
        {
            switch (_fieldId)
            {
                case fieldNum(SalesTable_RU, AgreementHeaderExt_RU):
                    salesTable.setAgreement_RU();
                    break;

                case fieldNum(SalesTable_RU, InventProfileType_RU):
                    salesTable.salesTable_RU().setInventProfileId_RU();
                    break;
            }
        }

        if (BrazilParameters::isEnabled())
        {
            this.postModifiedField_BR(_fieldId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCreditCardCustomerReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears credit card customer reference.
    /// </summary>
    protected void clearCreditCardCustomerReference()
    {
        salesTable.CreditCardCustRefId = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeCovPlanned</Name>
				<Source><![CDATA[
    boolean  mustBeCovPlanned()
    {
        SalesLine  salesLine;

        if (salesTable.SalesStatus != SalesStatus::Invoiced)
        {
            while select salesLine
                     where salesLine.SalesId == salesTable.SalesId
            {
                if (salesLine.mustBeCovPlanned())
                {
                    return true;
                }
            }
        }
        else
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void  new(SalesTable  _salesTable)
    {
        salesTable      = _salesTable;
        salesCycle      = CustParameters::find().SalesCycle;

        super(_salesTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberSeqFormHandlerSalesId</Name>
				<Source><![CDATA[
    protected NumberSeqFormHandler numberSeqFormHandlerSalesId(FormRun _element, FormDataSource _salestable_ds)
    {
        if (!numberSeqFormHandlerSalesId)
        {
            numberSeqFormHandlerSalesId = NumberSeqFormHandler::newForm(SalesParameters::numRefSalesId().NumberSequenceId,
                                                                 _element,
                                                                 _salestable_ds,
                                                                 fieldNum(SalesTable, SalesId)
                                                                );
        }
        return numberSeqFormHandlerSalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowSalesLineCaching</Name>
				<Source><![CDATA[
    public boolean parmAllowSalesLineCaching(boolean _allowSalesLineCaching = allowSalesLineCaching)
    {
        allowSalesLineCaching = _allowSalesLineCaching;

        return allowSalesLineCaching;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDirectDeliveryCreation</Name>
				<Source><![CDATA[
    public boolean parmIsDirectDeliveryCreation(boolean _isDirectDeliveryCreation = isDirectDeliveryCreation)
    {
        isDirectDeliveryCreation = _isDirectDeliveryCreation;

        return isDirectDeliveryCreation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCheckSalesQtyDocumentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a <c>Map</c> object.
    /// </summary>
    /// <returns>
    /// An instantiated <c>Map</c> object.
    /// </returns>
    protected Map parmCheckSalesQtyDocumentStatus()
    {
        if (!checkSalesQtyDocumentStatus)
        {
            checkSalesQtyDocumentStatus = new Map(Types::Enum, Types::Integer);
        }
        return checkSalesQtyDocumentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultSalesLineEnumerable</Name>
				<Source><![CDATA[
    protected TradeCommonIEnumerable parmDefaultSalesLineEnumerable()
    {
        SalesLine   salesLineNoFetch;

        if (!defaultSalesLineEnumerable || !this.parmAllowSalesLineCaching() || !defaultSalesLineEnumerable.canBeReset())
        {
            select nofetch salesLineNoFetch
                where salesLineNoFetch.SalesId == salesTable.SalesId
                && ((salesLineNoFetch.SalesStatus == SalesStatus::None
                        || salesLineNoFetch.SalesStatus == SalesStatus::Backorder
                        || salesLineNoFetch.SalesStatus == SalesStatus::Delivered)
                    || (salesLineNoFetch.SalesDeliverNow != 0));

            defaultSalesLineEnumerable = TradeCommonEnumerableNoFetchSelect::newFromNoFetchStatement(salesLineNoFetch);
            if (this.parmAllowSalesLineCaching())
            {
                defaultSalesLineEnumerable = TradeCommonEnumerableCache::newFromTradeCommonIEnumerable(defaultSalesLineEnumerable);
            }
        }
        return defaultSalesLineEnumerable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberSeqFormHandlerSalesId</Name>
				<Source><![CDATA[
    public NumberSeqFormHandler parmNumberSeqFormHandlerSalesId(NumberSeqFormHandler _numberSeqFormHandlerSalesId = numberSeqFormHandlerSalesId)
    {
        numberSeqFormHandlerSalesId = _numberSeqFormHandlerSalesId;
        return numberSeqFormHandlerSalesId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPickingListRegistrationEnumerable</Name>
				<Source><![CDATA[
    protected TradeCommonIEnumerable parmPickingListRegistrationEnumerable()
    {
        SalesLine   salesLineNoFetch;
        WMSOrder    wmsOrderNoFetch;

        if (!pickingListRegistrationSalesLineEnumerable || !this.parmAllowSalesLineCaching() || !pickingListRegistrationSalesLineEnumerable.canBeReset())
        {
            if (FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance()))
            {
                salesLineNoFetch = this.kittingSalesLineNoFetch_Picking();
            }
            else
            {
                select nofetch salesLineNoFetch
                    where salesLineNoFetch.SalesId == salesTable.SalesId
                        && ((salesLineNoFetch.SalesStatus == SalesStatus::None
                            || salesLineNoFetch.SalesStatus == SalesStatus::Backorder
                            || salesLineNoFetch.SalesStatus == SalesStatus::Delivered)
                        || (salesLineNoFetch.SalesDeliverNow != 0))
                exists join wmsOrderNoFetch
                    where wmsOrderNoFetch.InventTransId == salesLineNoFetch.InventTransId
                    &&    wmsOrderNoFetch.Type          == WMSOrderType::OrderPick;
            }

            pickingListRegistrationSalesLineEnumerable = TradeCommonEnumerableNoFetchSelect::newFromNoFetchStatement(salesLineNoFetch);
            if (this.parmAllowSalesLineCaching())
            {
                pickingListRegistrationSalesLineEnumerable = TradeCommonEnumerableCache::newFromTradeCommonIEnumerable(pickingListRegistrationSalesLineEnumerable);
            }
        }
        return pickingListRegistrationSalesLineEnumerable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTable</Name>
				<Source><![CDATA[
    public SalesTable parmSalesTable()
    {
        return salesTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLineCaller</Name>
				<Source><![CDATA[
    public SalesLine parmSalesLineCaller(SalesLine _salesLineCaller)
    {
        salesLineCaller = _salesLineCaller;
        return salesLineCaller;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesTableCheckQuantity</Name>
				<Source><![CDATA[
    private SalesTableCheckQuantity parmSalesTableCheckQuantity()
    {
        if (!salesTableCheckQuantity)
        {
            salesTableCheckQuantity = SalesTableCheckQuantity::newFromSalesTable(salesTable);
        }
        return salesTableCheckQuantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCanPackingslipBeUpdatedBR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a sales line with a packing slip status exists.
    /// </summary>
    /// <param name="_documentStatus">
    /// A <c>DocumentStatus</c> document type; optional.
    /// </param>
    /// <param name="_returnValue">
    /// A Boolean value that indicates whether the <paramref name="_documentStatus" /> parameter is a
    /// <c>DocumentStatus::PackingSlip</c> enumeration value; optional.
    /// </param>
    /// <returns>
    /// true if sales line with packing slip status exists; otherwise, false.
    /// </returns>
    public boolean postCanPackingslipBeUpdatedBR(DocumentStatus _documentStatus = DocumentStatus::PackingSlip,
                                                 boolean _returnValue = 0)
    {
        SalesLine    salesLine;
        SalesLine_BR salesLine_BR;

        if (_documentStatus != DocumentStatus::PackingSlip)
        {
            return _returnValue;
        }

        if (_returnValue)
        {
            select firstonly RecId from salesLine
                where  salesLine.SalesId == salesTable.SalesId
                    && (salesLine.SalesStatus == SalesStatus::Backorder || salesLine.SalesDeliverNow != 0)
                exists join salesLine_BR
                    where  salesLine_BR.SalesLine == salesLine.RecId
                        && salesLine_BR.DeliveryCFOPTable_BR == 0 ;
        }

        return salesLine.RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postModifiedField_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after a Brazilian field modification.
    /// </summary>
    /// <param name="_fieldId">The modified Brazilian field ID.</param>
    public void postModifiedField_BR(FieldId _fieldId)
    {
        switch (_fieldId)
        {
            case fieldNum(SalesTable, CustAccount):
            case fieldNum(SalesTable, SalesType):
                this.updateFiscalDocumentText_BR(FiscalDocumentTextType_BR::CustVend);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>purchTableDelete</Name>
				<Source><![CDATA[
    void purchTableDelete(SalesTable _salesTable)
    {
        InterCompanyPurchSalesReference interCompanyPurchSalesReference;
        PurchTable                      purchTable;

        if (!_salesTable)
        {
            return;
        }

        if (_salesTable.SkipUpdate == InterCompanySkipUpdate::Internal
        ||  _salesTable.SkipUpdate == InterCompanySkipUpdate::Both
        || !this.canCreatePurchOrder())
        {
            return;
        }

        while select PurchId from interCompanyPurchSalesReference
             index hint SalesPurchIdx
             where interCompanyPurchSalesReference.SalesId == _salesTable.SalesId
        {
            select forupdate purchTable
                   index hint PurchIdx
                   where purchTable.PurchId == interCompanyPurchSalesReference.PurchId
                   &&    purchTable.InterCompanyOrder;
            if (purchTable.isInterCompanyOrder())
            {
                purchTable.SkipUpdate = InterCompanySkipUpdate::Internal;
                purchTable.delete();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the current item is the return item.
    /// </summary>
    /// <returns>
    ///    true if the current item is the return item; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This base class method always returns false.Child class for return item
    ///    (<c>SalesTableClass_ReturnItem</c>) overrides this method to return true.
    /// </remarks>
    boolean returnItem()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesTable</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmSalesTable method instead.', false, 31\05\2017)]
    public final SalesTable salesTable()
    {
        return this.parmSalesTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTaxGroup</Name>
				<Source><![CDATA[
    void setTaxGroup(TaxGroup _taxGroup)
    {
        salesTable.TaxGroup = _taxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProductionMenu</Name>
				<Source><![CDATA[
    boolean  showProductionMenu()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncPurchTable</Name>
				<Source><![CDATA[
    AxPurchTable syncPurchTable(SalesTable _salesTable, PurchTable _purchTable, boolean _forceAddressSync = false)
    {
        boolean                                     create;
        InterCompanyEndpointActionPolicyTransfer    transferInternal = _purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal);
        
        AxPurchTable axPurchTable = this.constructAxPurchTable(_purchTable);

        if (!_purchTable)
        {
            create = true;
        }

        if (_salesTable.fieldChanged(fieldNum(SalesTable, SalesType)))
        {
            axPurchTable.parmPurchaseType(SalesTableType::construct(salesTable).purchaseType());
        }

        if (create || _salesTable.fieldChanged(fieldNum(SalesTable, SalesId)))
        {
            axPurchTable.parmInterCompanyOriginalSalesId(_salesTable.SalesId);
        }

        if (create || _salesTable.fieldChanged(fieldNum(SalesTable, CustAccount)))
        {
            axPurchTable.parmInterCompanyOriginalCustAccount(_salesTable.CustAccount);
        }

        if (SalesPurchSyncDeliveryInfoFeature::instance().isEnabled())
        {
            this.setStockPurchaseDeliveryInformation(axPurchTable, _salesTable, _purchTable, create);
        }
        else
        {
            if (!PurchaseDlvUpdatedWithSalesTableFlighting::instance().isEnabled())
            {
                if (create || _salesTable.fieldChanged(fieldNum(SalesTable, DlvTerm)))
                {
                    axPurchTable.parmDlvTerm(_salesTable.DlvTerm);
                }
                if (create || _salesTable.fieldChanged(fieldNum(SalesTable, DlvMode)))
                {
                    axPurchTable.parmDlvMode(_salesTable.DlvMode);
                }
            }
        }

        if (_purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal).CustomerInfo)
        {
            if (create || _salesTable.fieldChanged(fieldNum(SalesTable, PurchOrderFormNum)))
            {
                axPurchTable.parmInterCompanyCustPurchOrderFormNum(_salesTable.PurchOrderFormNum);
            }
            if (create || _salesTable.fieldChanged(fieldNum(SalesTable, CustomerRef)))
            {
                axPurchTable.parmVendorRef(_salesTable.CustomerRef);
            }
        }

        if (_purchTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::Internal).ReturnItemNum)
        {
            if (create || _salesTable.fieldChanged(fieldNum(SalesTable, ReturnItemNum)))
            {
                axPurchTable.parmReturnItemNum(_salesTable.ReturnItemNum);
            }
        }

        if (create || _salesTable.fieldChanged(fieldNum(SalesTable, InterCompanyDirectDelivery)))
        {
            axPurchTable.parmInterCompanyDirectDelivery(_salesTable.InterCompanyDirectDelivery);
        }

        if (create || _salesTable.fieldChanged(fieldNum(SalesTable, InterCompanyAllowIndirectCreation)))
        {
            axPurchTable.parmInterCompanyAllowIndirectCreation(_salesTable.InterCompanyAllowIndirectCreation);
        }

        if (create || _salesTable.fieldChanged(fieldNum(SalesTable, ReturnReasonCodeId)))
        {
            axPurchTable.parmReturnReasonCodeId(_salesTable.ReturnReasonCodeId);
        }

        if (create || _salesTable.fieldChanged(fieldNum(SalesTable, ReturnReplacementCreated)))
        {
            axPurchTable.parmReturnReplacementCreated(_salesTable.ReturnReplacementCreated);
        }

        SalesTableType::syncDeliveryAddress(_salesTable, axPurchTable, _forceAddressSync);
        
        if (SalesPurchSyncDeliveryInfoFeature::instance().isEnabled())
        {
            this.setDirectDeliveryPurchaseDeliveryInformation(axPurchTable, _salesTable, _purchTable, create);
        }
        else
        {
            if (_salesTable.InterCompanyDirectDelivery)
            {
                if (create || _salesTable.fieldChanged(fieldNum(SalesTable, DlvTerm)))
                {
                    axPurchTable.parmDlvTerm(_salesTable.DlvTerm);
                }

                if (create || _salesTable.fieldChanged(fieldNum(SalesTable, DlvMode)))
                {
                    axPurchTable.parmDlvMode(_salesTable.DlvMode);
                }
            }
        }

        if (transferInternal.PriceDiscount
        && (create || _salesTable.fieldChanged(fieldNum(SalesTable, DiscPercent))))
        {
            axPurchTable.parmDiscPercent(_salesTable.DiscPercent);
        }

        if (_salesTable.InterCompanyDirectDelivery)
        {
            if (new DictConfigurationKey(configurationKeyNum(SalesDeliveryDateControl)).enabled())
            {
                if (SalesTableTypeSyncDatesExtensibilityFlight::instance().isEnabled())
                {
                    this.synchronizePurchaseOrderRequestedDates(_salesTable, axPurchTable);
                }
                else
                {
                    if (_salesTable.ReceiptDateRequested != dateNull()
                        &&  _salesTable.ReceiptDateRequested  < axPurchTable.parmDeliveryDate())
                    {
                        warning(strFmt("@SYS94309", date2StrUsr(_salesTable.ReceiptDateRequested, DateFlags::FormatAll), date2StrUsr(axPurchTable.parmDeliveryDate(), DateFlags::FormatAll)));
                    }
                    axPurchTable.parmDeliveryDate         (_salesTable.ReceiptDateRequested);
                    axPurchTable.parmShippingDateRequested(_salesTable.ShippingDateRequested);
                }
            }
            else
            {
                axPurchTable.parmDeliveryDate         (_salesTable.ShippingDateRequested);
            }
        }
        else
        {
            if (create
            || _salesTable.fieldChanged(fieldNum(SalesTable, ShippingDateRequested))
            || _salesTable.fieldChanged(fieldNum(SalesTable, InterCompanyDirectDelivery)))
            {
                ReqPlanSched reqPlanSched     = ReqPlanSched::find(ReqParameters::find().CurrentReqPlanIdSchedStatic);
                LeadTime     leadTimeInternal = reqPlanSched.IssueMargin + reqPlanSched.ReceiptMargin;
                DlvDate      syncDate         = _salesTable.ShippingDateRequested - leadTimeInternal;
                if (syncDate < DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
                {
                    warning(strFmt("@SYS98070", date2StrUsr(syncDate, DateFlags::FormatAll)));
                    syncDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                }
                else
                {
                    if (!create
                    &&  axPurchTable.parmDeliveryDate() != dateNull()
                    &&  syncDate < axPurchTable.parmDeliveryDate())
                    {
                        warning(strFmt("@SYS94310", date2StrUsr(syncDate, DateFlags::FormatAll), date2StrUsr(axPurchTable.purchTable().DeliveryDate, DateFlags::FormatAll)));
                    }
                }
                axPurchTable.parmDeliveryDate(syncDate);
            }
        }

        return axPurchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizePurchaseOrderRequestedDates</Name>
				<Source><![CDATA[
    protected void synchronizePurchaseOrderRequestedDates(SalesTable _salesTable, AxPurchTable _axPurchTable)
    {
        if (!_axPurchTable)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        if (_salesTable.ReceiptDateRequested != dateNull()
                &&  _salesTable.ReceiptDateRequested  < _axPurchTable.parmDeliveryDate())
        {
            warning(strFmt("@SYS94309", date2StrUsr(_salesTable.ReceiptDateRequested, DateFlags::FormatAll), date2StrUsr(_axPurchTable.parmDeliveryDate(), DateFlags::FormatAll)));
        }
        _axPurchTable.parmDeliveryDate         (_salesTable.ReceiptDateRequested);
        _axPurchTable.parmShippingDateRequested(_salesTable.ShippingDateRequested);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPurchTableWithDeliveryInformation</Name>
				<Source><![CDATA[
    internal AxPurchTable createPurchTableWithDeliveryInformation(SalesTable _salesTable, PurchTable _purchTable, boolean _create = false)
    {  
        AxPurchTable axPurchTable = this.constructAxPurchTable(_purchTable);
        this.setStockPurchaseDeliveryInformation(axPurchTable, _salesTable, _purchTable, _create);

        return axPurchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAxPurchTable</Name>
				<Source><![CDATA[
    private AxPurchTable constructAxPurchTable(PurchTable _purchTable)
    {
        AxPurchTable axPurchTable;

        if (_purchTable)
        {
            if (_purchTable.RecId)
            {
                // Uses _purchTable buffer because its field value may have been changed outside but not updated
                // into database yet, For example, intercompany related fields value is changed in firming planned purchase order.
                if (!_purchTable.selectForUpdate())
                {
                    _purchTable.selectForUpdate(true);
                }
                axPurchTable = AxPurchTable::newPurchTable(_purchTable);
            }
            else
            {
                axPurchTable = AxPurchTable::newPurchTable(PurchTable::find(_purchTable.PurchId, true));
            }
        }
        else
        {
            axPurchTable = AxPurchTable::newPurchTable(_purchTable);
        }

        return axPurchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDirectDeliveryPurchaseDeliveryInformation</Name>
				<Source><![CDATA[
    private void setDirectDeliveryPurchaseDeliveryInformation(AxPurchTable _axPurchTable, SalesTable _salesTable, PurchTable _purchTable, boolean _create)
    {
        if (_salesTable.InterCompanyDirectDelivery
                || isDirectDeliveryCreation
                || (_purchTable.isDropShipment()
                    && _salesTable.isAllLinesDeliveryTypeIdentical()
                    && _purchTable.isAllLinesDeliveryTypeIdentical()))
        {
            PurchParameters purchParameters = PurchParameters::find();

            if (purchParameters.isDirectDeliveryInformationCreateOrUpdateAllowed(_salesTable, fieldNum(SalesTable, DlvTerm), _create))
            {
                _axPurchTable.parmDlvTerm(_salesTable.DlvTerm);
            }
            
            if (purchParameters.isDirectDeliveryInformationCreateOrUpdateAllowed(_salesTable, fieldNum(SalesTable, DlvMode), _create))
            {
                _axPurchTable.parmDlvMode(_salesTable.DlvMode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setStockPurchaseDeliveryInformation</Name>
				<Source><![CDATA[
    private void setStockPurchaseDeliveryInformation(AxPurchTable _axPurchTable, SalesTable _salesTable, PurchTable _purchTable = null, boolean _create = false)
    {
        boolean canDeliveryInfoSync = _purchTable.isAllLinesDeliveryTypeIdentical() && _salesTable.isAllLinesDeliveryTypeIdentical();

        if (!_salesTable.InterCompanyDirectDelivery
                && (!_purchTable.isDropShipment() || _create)
                && !isDirectDeliveryCreation
                && (canDeliveryInfoSync
                    || _purchTable.InterCompanyOrder
                    || _create))
        {
            PurchParameters purchParameters = PurchParameters::find();

            if (purchParameters.isStockDeliveryInformationCreateOrUpdateAllowed(_salesTable, fieldNum(SalesTable, DlvTerm), _create))
            {
                _axPurchTable.parmDlvTerm(_salesTable.DlvTerm);
            }
            if (purchParameters.isStockDeliveryInformationCreateOrUpdateAllowed(_salesTable, fieldNum(SalesTable, DlvMode), _create))
            {
                _axPurchTable.parmDlvMode(_salesTable.DlvMode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncPurchTableSave</Name>
				<Source><![CDATA[
    void syncPurchTableSave(SalesTable _salesTable)
    {
        InterCompanyPurchSalesReference interCompanyPurchSalesReference;
        PurchTable                      purchTable;

        if (!_salesTable)
        {
            return;
        }

        if (_salesTable.SkipUpdate == InterCompanySkipUpdate::Internal
        ||  _salesTable.SkipUpdate == InterCompanySkipUpdate::Both
        || !this.canCreatePurchOrder())
        {
            return;
        }

        while select forceplaceholders PurchId from interCompanyPurchSalesReference
              index hint SalesPurchIdx
              where interCompanyPurchSalesReference.SalesId == _salesTable.SalesId
        join purchTable
              index hint PurchIdx
              where purchTable.PurchId                     == interCompanyPurchSalesReference.PurchId
              &&    purchTable.InterCompanyOriginalSalesId == _salesTable.SalesId
        {
            if (this.shouldSkipSyncPurchTable(purchTable))
            {
                continue;
            }
            AxPurchTable axPurchTable = this.syncPurchTable(_salesTable,purchTable);
            axPurchTable.parmSkipUpdate(InterCompanySkipUpdate::Internal);
            axPurchTable.save();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveNonIntercompanyPurchTable</Name>
				<Source><![CDATA[
    internal void saveNonIntercompanyPurchTable(SalesTable _salesTable)
    {
        if (!_salesTable)
        {
            return;
        }

        if (_salesTable.SkipUpdate == InterCompanySkipUpdate::Internal
            ||  _salesTable.SkipUpdate == InterCompanySkipUpdate::Both
            || !this.canCreatePurchOrder())
        {
            return;
        }
        
        InterCompanyPurchSalesReference interCompanyPurchSalesReference;
        PurchTable                      purchTable;

        while select forceplaceholders PurchId from interCompanyPurchSalesReference
              index hint SalesPurchIdx
              where interCompanyPurchSalesReference.SalesId == _salesTable.SalesId
        join purchTable
              index hint PurchIdx
              where purchTable.PurchId                     == interCompanyPurchSalesReference.PurchId
              &&    purchTable.InterCompanyOriginalSalesId == _salesTable.SalesId
        {
            AxPurchTable axPurchTable = this.createPurchTableWithDeliveryInformation(_salesTable, purchTable);
            axPurchTable.parmSkipUpdate(InterCompanySkipUpdate::Internal);
            axPurchTable.save();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSkipSyncPurchTable</Name>
				<Source><![CDATA[
    private boolean shouldSkipSyncPurchTable(PurchTable _purchTable)
    {
        boolean ret = false;
        SalesTableTypeSyncPurchTableSaveContext salesTableTypeSyncPurchTableSaveContext = salesTableTypeSyncPurchTableSaveContext::current();
        if (salesTableTypeSyncPurchTableSaveContext != null)
        {
            boolean syncDirectDelivery = salesTableTypeSyncPurchTableSaveContext.parmSyncDirectDelivery();
            boolean syncInterCompanyDirectDelivery = salesTableTypeSyncPurchTableSaveContext.parmSyncInterCompanyDirectDelivery();
            if (syncDirectDelivery != syncInterCompanyDirectDelivery)
            {
                if (syncDirectDelivery)
                {
                    ret = !_purchTable.isDropShipment();
                }
                else
                {
                    ret = _purchTable.InterCompanyDirectDelivery != salesTableTypeSyncPurchTableSaveContext.parmInterCompanyDirectDeliveryOrig();
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmsModifiedDlvMode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies all the fields of the correspondent <c>TMSSalesTable</c> record that depend on delivery mode field.
    /// </summary>
    /// <param name="_insert">
    /// A <c>Boolean</c> value specifies if the corresponding <c>TMSSalesTable</c> should be inserted or updated.
    /// </param>
    /// <param name="_syncAgentSales">
    /// A instance of <c>TMSDeliveryModeSyncAgentSales</c> class.
    /// </param>
    public void tmsModifiedDlvMode(
        boolean _insert = false,
        TMSDeliveryModeSyncAgentSales _syncAgentSales = null)
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(WHSandTMS)))
        {
            if (_syncAgentSales == null)
            {
                _syncAgentSales = TMSDeliveryModeSyncAgentSales::newFromBuffer(salesTable);
            }

            if (_insert)
            {
                _syncAgentSales.syncOnInsert(salesTable.DlvMode);
            }
            else
            {
                _syncAgentSales.syncOnUpdate(salesTable.DlvMode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic before a sales order record is updated.
    /// </summary>
    public void updating()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles logic after a sales order record has been updated.
    /// </summary>
    /// <param name="_salesTableOrig">
    /// The original sales order which is updated.
    /// </param>
    public void updated(SalesTable _salesTableOrig)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBackStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates status of the order.
    /// </summary>
    public void  updateBackStatus()
    {
        boolean                     mcrOOB = true;
        MCROrderStopped             mcrOrderStopped = NoYes::No;

        if (salesTable.mcrIsCallCenter())
        {
            salesTable.reread();

            SalesStatus retStatus = this.lowestSalesStatus();

            if (!salesTable.mcrOrderStopped
                && RetailMCRChannelTable::mcrEnableOrderCompletion(salesTable)
                && (!RetailInterCompanyOrderPickingListDoNotProcessFlight::instance().isEnabled() || !salesTable.InterCompanyOrder))
            {
                if (SalesLine::exist(salesTable.SalesId))
                {
                    // If the order was previously under/overpaid and
                    // then released, don't recheck out of balance just keept it In processing
                    if (retStatus != SalesStatus::Canceled
                        && salesTable.mcrSalesTable().OutOfBalanceReleased == MCROutOfBalanceReleaseType::None)
                    {
                        // Check out of balance
                        mcrOOB = MCRPaymentReview::outOfBalance(MCRCustPaymTotals::construct(salesTable.TableId, salesTable.RecId));
                        if (!mcrOOB)
                        {
                            mcrOrderStopped = NoYes::Yes;
                        }
                    }
                }

                if (!MCRCustPaymTotals::verifyAllPaymentsApproved(salesTable.TableId, salesTable.RecId))
                {
                    mcrOrderStopped = NoYes::Yes;
                }
            }
            else if (FeatureStateProvider::isFeatureEnabled(RetailPaymentsAdvancedDeclinedAuthorizationsDuringPickAndPackFeature::instance())
                && !salesTable.mcrOrderStopped
                && CreditCardAuthTrans::findLatest(salesTable.SalesId).ProcessorStatus == CreditCardProcessorStatus::Declined
                && (!RetailInterCompanyOrderPickingListDoNotProcessFlight::instance().isEnabled() || !salesTable.InterCompanyOrder))
            {
                mcrOrderStopped = NoYes::Yes;
            }
            else
            {
                mcrOrderStopped = salesTable.mcrOrderStopped;
            }

            ttsbegin;
            salesTable = SalesTable::find(salesTable.SalesId, true);
            salesTable.SalesStatus = retStatus;

            // Return Call Center Sales Order that pay with Gift Card
            // will refund the amount after posted invoice
            // unless AdvanceCredit is checked in sales head.
            // So mcrOrderStopped should not be updated until post invoice,
            // or else it will make Complete button visible and cannot post packing slip and invoice.
            if (salesTable.SalesType == SalesType::ReturnItem
                && salesTable.SalesStatus != SalesStatus::Invoiced)
            {
                MCRCustPaymTable mcrCustPaymTable;
                select firstonly RecId from mcrCustPaymTable
                    where mcrCustPaymTable.RefRecId == salesTable.RecId &&
                    mcrCustPaymTable.RefTableId == salesTable.TableId &&
                    mcrCustPaymTable.CustPaymType == MCRCustPaymType::GiftCard;
                if (mcrCustPaymTable && salesTable.isAdvanceCreditOnReturn())
                {
                    salesTable.mcrOrderStopped = mcrOrderStopped;
                }
                else
                {
                    salesTable.mcrOrderStopped = mcrOrderStopped;
                }
            }
            else
            {
                salesTable.mcrOrderStopped = mcrOrderStopped;
            }
            ReturnStatusHeader prevReturnStatus = salesTable.ReturnStatus;
            this.mcrSetReturnStatus();
            salesTable.doUpdate();

            if (!RetailByPassSystematicHoldCodeRemovalFlight::instance().isEnabled())
            {
                this.updateOrderStopStatus();
            }
            ttscommit;

            // generate intercompany order for exchange SO once all
            // holds released and payment methods approved.
            if (salesTable.mcrReturnSalesTable().IsExchange
                && salesTable.SalesStatus == SalesStatus::Backorder
                && salesTable.mcrOrderStopped ==  NoYes::No)
            {
                salesTable.mcrInterCompanyAutoCreateOrders();
            }
        }
        else
        {
            ttsbegin;
            SalesTable salesTableLocal = SalesTable::find(salesTable.SalesId,true);
            salesTableLocal.SalesStatus = this.lowestSalesStatus();
            if (salesTableLocal.isInterCompanyOrder()
                && salesTableLocal.SalesType   == SalesType::ReturnItem
                && salesTableLocal.SalesStatus == SalesStatus::Canceled)
            {
                salesTableLocal.ReturnStatus = ReturnStatusHeader::Canceled;
            }

            salesTableLocal.SkipUpdate = InterCompanySkipUpdate::Internal;
            salesTableLocal.update();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOrderStopStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update order stop field in return order form.
    /// </summary>
    protected void updateOrderStopStatus()
    {
        SalesTable                  salesTableReplacement;
        MCRHoldCodeTrans            mcrHoldCodeTrans;

        // only one replacement order header for multi-line items
        select firstOnly forUpdate salesTableReplacement
                where salesTableReplacement.SalesId == salesTable.ReturnReplacementId
                && salesTableReplacement.ReturnItemNum == salesTable.ReturnItemNum;

        if (salesTableReplacement)
        {
            if (RetailNotRemoveReplacementManualOrderHolds::instance().isEnabled()
                && MCRHoldCodeTrans::existsManualHolds(salesTableReplacement.SalesId))
            {
                // When there is manual order holds, we stop here and do not clear the order holds automatically.
                return;
            }

            salesTableReplacement.mcrOrderStopped = salesTable.mcrOrderStopped;
            salesTableReplacement.doUpdate();

            // if replacement order with multi items, 'Do-Not-Process' flag is auto checked with holds 'Pending ex'
            // multi holds will be generated if you post packing slip for partial quantity.
            // Need to move holds for replacement order header.
                while select forUpdate mcrHoldCodeTrans
                    where mcrHoldCodeTrans.InventRefId == salesTableReplacement.SalesId
                    && mcrHoldCodeTrans.mcrCleared == NoYes::No
                {
                    if (mcrHoldCodeTrans)
                    {
                        mcrHoldCodeTrans.mcrCleared = NoYes::Yes;
                        mcrHoldCodeTrans.doUpdate();
                    }
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDeadline</Name>
				<Source><![CDATA[
    void  updateDeadline(SalesDeadline _deadline)
    {
        ttsbegin;
        if (_deadline)
        {
            salesTable.Deadline = _deadline;
            salesTable.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatusOrder</Name>
				<Source><![CDATA[
    private Map documentStatusOrder()
    {
        Map orderedDocumentStatus = new Map(Types::Enum, Types::Integer);

        orderedDocumentStatus.insert(DocumentStatus::None, 1);
        orderedDocumentStatus.insert(DocumentStatus::Quotation, 2);
        orderedDocumentStatus.insert(DocumentStatus::PurchaseOrder, 3);
        orderedDocumentStatus.insert(DocumentStatus::Confirmation, 4);
        orderedDocumentStatus.insert(DocumentStatus::Invoice4Paym_RU, 5);
        orderedDocumentStatus.insert(DocumentStatus::PickingList, 6);
        orderedDocumentStatus.insert(DocumentStatus::PackingSlip, 7);
        orderedDocumentStatus.insert(DocumentStatus::ProjectPackingSlip, 8);
        orderedDocumentStatus.insert(DocumentStatus::Invoice, 9);
        orderedDocumentStatus.insert(DocumentStatus::ProjectInvoice, 10);
        orderedDocumentStatus.insert(DocumentStatus::Facture_RU, 11);
        orderedDocumentStatus.insert(DocumentStatus::ReceiptsList, 12);

        return orderedDocumentStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDocumentStatus</Name>
				<Source><![CDATA[
    void updateDocumentStatus(DocumentStatus _documentStatus)
    {
        Map orderedDocumentStatus = this.documentStatusOrder();

        boolean allowUpdate;

        if (orderedDocumentStatus.exists(_documentStatus))
        {
            if (orderedDocumentStatus.exists(salesTable.DocumentStatus))
            {
                //Prevent transitions backwards in the sequence
                allowUpdate = orderedDocumentStatus.lookup(salesTable.DocumentStatus) < orderedDocumentStatus.lookup(_documentStatus);
            }
            else
            {
                //Prevent transitions from a status without restrictions back into the sequence
                allowUpdate = false;
            }
        }
        else
        {
            //It is a transistion to a status without restrictions.
            allowUpdate = true;
        }

        if (allowUpdate)
        {
            ttsbegin;
            salesTable.DocumentStatus = _documentStatus;
            salesTable.SkipUpdate     = InterCompanySkipUpdate::Both;
            salesTable.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFiscalDocumentText_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Fiscal document texts of a specific type on the Sales header.
    /// </summary>
    /// <param name="_type">
    /// A <c>FiscalDocumentTextType_BR</c> value indicating the type.
    /// </param>
    /// <remarks>
    /// This method does nothing if the Sales header has not been inserted yet.
    /// </remarks>
    public void updateFiscalDocumentText_BR(FiscalDocumentTextType_BR _type)
    {
        if (this.canFiscalDocTextBeRegistrated_BR())
        {
            FiscalDocumentTextUpdate_BR::newFromRecord(salesTable).updateTexts(_type);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerCov</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates cash flow forecasts for the <c>SalesTable</c> record.
    /// </summary>
    /// <param name = "_ledgerCoverage">The cash flow forecasting calculations.</param>
    public void  updateLedgerCov(LedgerCoverage _ledgerCoverage)
    {
        if (salesTable.mustBeCovPlanned())
        {
            _ledgerCoverage.init(salesTable);

            SalesPurchTableLedgerCovIUpdateLedgerCov ledgerCovIUpdateLedgerCov = SalesPurchTableLedgerCovType::newFromDocument(_ledgerCoverage, salesTable);
            ledgerCovIUpdateLedgerCov.updateLedgerCov();

            _ledgerCoverage.endCov();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLineDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes <c>SalesLine</c> table deletion-related updates to the <c>SalesTable</c> table.
    /// </summary>
    public void updateSalesLineDelete()
    {
        if (salesTable.PriceDiscResultFields::multiLineDiscPolicyExist()
            && !salesTable.existSalesLine())
        {
            salesTable.PriceDiscResultFields::removeMultiLineDiscCodeFromPolicy();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesType</Name>
				<Source><![CDATA[
    void  updateSalesType()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateSalesLineDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the sales order line record before delete.
    /// </summary>
    /// <param name="_salesLine">
    /// The sales order line line record which is to be validated.
    /// </param>
    /// <param name="_mcrCancel">
    /// For order cancellation pass true.
    /// </param>
    /// <returns>
    /// true if the sales order line record is valid; otherwise, false.
    /// </returns>
    protected boolean validateSalesLineDelete(SalesLine _salesLine, boolean _mcrCancel = false)
    {
        return _salesLine.validateDelete(true, _mcrCancel);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    boolean validateDelete(boolean _mcrCancel = false)
    {
        boolean                 ok          = true;
        boolean                 linesExist  = false;
        SalesLine               salesLine;
        List                    warningList = new List(Types::String);
        str                     warningTxt;
        SalesDeliverySchedule   salesDeliverySchedule;

        flush  SalesLine;

        setPrefix(#prefixfield(SalesTable,SalesId));

        if (salesTable.isInterCompanyOrder()
        &&  salesTable.SkipUpdate         != InterCompanySkipUpdate::InterCompany
        &&  salesTable.SkipUpdate         != InterCompanySkipUpdate::Both
        &&  salesTable.InterCompanyOrigin == InterCompanyOrigin::Derived)
        {
            ok = checkFailed("@SYS98650");
        }

        // Open return order cannot be deleted
        if (salesTable.returnItem()
            && salesTable.ReturnStatus == ReturnStatusHeader::Open)
        {
            ok = checkFailed("@SYS106101");
        }

        if (SalesParmTable::checkActivePerSalesId(salesTable.SalesId))
        {
            ok = checkFailed("@SCM:SalesOrderCanNotBeDeletedPleaseCleanupHistory");
        }

        if (ok && FormDataUtil::isFormDataSource(salesTable))
        {
            ok = this.checkDelete();
        }

        if (ok)
        {
            boolean isKittingEnabled = FeatureStateProvider::IsFeatureEnabled(KittingFeature::instance());

            while select salesLine
                    index hint SalesLineIdx
                    where salesLine.SalesId == salesTable.SalesId
                    notexists join salesDeliverySchedule
                        where salesDeliverySchedule.OrderLine == salesLine.InventTransId
            {
                if (isKittingEnabled)
                {
                    if (!this.kittingCanDeleteLine(salesLine))
                    {
                        continue;
                    }
                }

                linesExist = true;

                // For order cancellation pass the _mcrCancel into the validateDelete routine.
                if (!this.validateSalesLineDelete(salesLine, _mcrCancel))
                {
                    ok = false;
                    break;
                }
                if (ok && FormDataUtil::isFormDataSource(salesTable))
                {
                    warningTxt = salesLine.referenceWarningTxt();
                    if (warningTxt)
                    {
                        warningList.addEnd(warningTxt);
                    }
                }
            }
        }

        if (ok  &&  linesExist  &&  salesTable.SalesStatus == SalesStatus::Backorder)
        {
            if (FormDataUtil::isFormDataSource(salesTable)) // the dialog must only appear when called from a form
            {
                if (warningList.elements())
                {
                    warningTxt = '';
                    ListEnumerator warningListEnumerator = warningList.getEnumerator();
                    while (warningListEnumerator.moveNext())
                    {
                        warningTxt += warningListEnumerator.current() + '\n';
                    }
                    warningTxt += '\n';

                    // If _mcrCancel is true, don't display message - it display message earlier
                    if (!_mcrCancel)
                    {
                        warningTxt += "@SYS75608";
                        if (Box::yesNo(warningTxt, DialogButton::No) == DialogButton::No)
                        {
                            ok = checkFailed("@SYS19437");
                        }
                    }
                }
            }
        }

        if (ok)
        {
            if (BankLCExportFeatureChecker::checkBankLCExportEnabled())
            {
                if (salesTable.isMarkedForBankLC())
                {
                    BankLCExport bankLCExportLocal = BankLCExport::findBySalesTable(salesTable.SalesId);

                    if (bankLCExportLocal.RecId != 0
                        && !bankLCExportLocal.validateDelete())
                    {
                        // The order could not be deleted, because the related Letter of Credit is still existed.
                        ok = checkFailed("@SYS316256");
                    }
                }
            }
        }

        if (ok && WHSParameters::find().AutoCleanEmptyLoadManifest && !salesTable.validateDeleteWHSWorkTable())
        {
            ok = checkFailed("@WAX:AssociatedWorkCannotBeDeleted");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateField</Name>
				<Source><![CDATA[
    public boolean  validateField(FieldId  _fieldId, TableId _tableId = tableNum(SalesTable))
    {
        boolean         ok = true;
        boolean         countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean         countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        CreditCardCust creditCardCust;
        CreditCardProcessors creditCardProcessors;

        if (_tableId == tableNum(SalesTable))
        {
            switch (_fieldId)
            {
                case(fieldNum(SalesTable, CustAccount))     :
                    ok = salesTable.checkAccount();
                    // Checking against Filters
                    ok = ok && WHSFilter::orderFilterMatch(salesTable.CustAccount, salesTable.SalesId, ModuleCustVend::Cust);
                    ok = ok && salesTable.canChangeCreditCardNumber();
                    break;

                case(fieldNum(SalesTable, InvoiceAccount))  :
                    ok = salesTable.checkInvoiceAccount();
                    ok = ok && salesTable.canChangeCreditCardNumber();
                    break;

                case(fieldNum(SalesTable, vatNum))          :
                    ok = TaxVATNumTable::checkVATNum(salesTable.vatNum, salesTable, _fieldId);
                    ok = ok && TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(salesTable.EnterpriseNumber, salesTable.vatNum, true);
                    break;

                case(fieldNum(SalesTable, ContactPersonId)) :
                    ok = salesTable.checkContactPerson();
                    break;

                case fieldNum(SalesTable, EnterpriseNumber) :
                    ok = TaxEnterpriseBranchNumber_BE::checkEnterPriseNumber(salesTable.EnterpriseNumber);
                    break;

                case fieldNum(SalesTable, SalesType)        :
                    ok = this.canTypeBeChanged();
                    break;

                case fieldNum(SalesTable, InterCompanyAutoCreateOrders):
                    if (salesTable.existInterCompanySales())
                    {
                        if (!this.canCreatePurchOrder())
                        {
                            ok = checkFailed(strFmt("@SYS99545",fieldId2pname(tableNum(SalesTable),fieldNum(SalesTable,InterCompanyAutoCreateOrders))));
                        }
                        if (this.interCompanyIsBeingUpdated(true))
                        {
                            ok = ok && checkFailed(strFmt("@SYS99546",fieldId2pname(tableNum(SalesTable),fieldNum(SalesTable,InterCompanyAutoCreateOrders))));
                        }
                        if (salesTable.InterCompanyDirectDelivery)
                        {
                            ok = ok && this.interCompanyCheckWMS();
                        }
                    }
                    if (salesTable.InterCompanyAutoCreateOrders && salesTable.MCROrderStopped)
                    {
                        ok = ok && checkFailed("@SCM:AutomaticIntercompanyFailed");
                    }
                    break;

                case fieldNum(SalesTable, InterCompanyDirectDelivery):
                    if (salesTable.existInterCompanySales())
                    {
                        if (!this.canCreatePurchOrder())
                        {
                            ok = checkFailed(strFmt("@SYS99545",fieldId2pname(tableNum(SalesTable),fieldNum(SalesTable,InterCompanyDirectDelivery))));
                        }
                        if (this.interCompanyIsBeingUpdated(true))
                        {
                            ok = ok && checkFailed(strFmt("@SYS99546",fieldId2pname(tableNum(SalesTable),fieldNum(SalesTable,InterCompanyDirectDelivery))));
                        }
                        if (salesTable.InterCompanyDirectDelivery)
                        {
                            ok = ok && this.interCompanyCheckWMS();
                        }
                    }
                    break;

                case(fieldNum(SalesTable, Reservation))  : ok = salesTable.checkReservation();
                    break;

                case(fieldNum(SalesTable, CurrencyCode)):
                    ok = salesTable.interCompanyCheckCurrency();
                    if (ok && salesTable.payment().CreditCardPaymentType == CreditCardPaymentType::CreditCard && salesTable.CreditCardCustRefId)
                    {
                        creditCardCust = CreditCardCust::find(salesTable.CreditCardCustRefId);
                        creditCardProcessors = CreditCardProcessors::find(creditCardCust.CreditCardProcessors);
                        if (!CreditCardProcessors::validateCurrencyForProcessor(creditCardProcessors, salesTable.CurrencyCode, creditCardCust.CreditCardTypeName) ||
                                    !salesTable.checkPaymMode())
                        {
                            // The active credit card processor does not support the currency.
                            ok = checkFailed(strFmt("@SYS327527", creditCardProcessors.Name, salesTable.CurrencyCode));
                        }
                    }
                    salesTable.initBankAccounts_LV();
                    break;

                case fieldNum(SalesTable, url) :

                    if (salesTable.url)
                    {
                        ok = isValidURL(salesTable.url);
                        if (!ok)
                        {
                            ok = checkFailed("@SYS91305");
                        }
                    }
                    break;

                case fieldNum(SalesTable, InventLocationId):
                    ok = salesTable.InventStorageDimMap::validateField(fieldNum(InventStorageDimMap, InventLocationId));
                    break;

                case fieldNum(SalesTable, Payment):
                    ok = salesTable.checkCreditCardPaymentType();
                    ok = ok && this.canCreditCardPaymentJournalPost();
                    if (ok)
                    {
                        PaymTerm paymTerm = salesTable.payment();
                        if (paymTerm.CreditCardPaymentType == CreditCardPaymentType::NA)
                        {
                            if (!salesTable.cancelPreAuthorization())
                            {
                                return false;
                            }
                            salesTable.Payment = paymTerm.PaymTermId;
                            salesTable.CreditCardCustRefId = 0;
                        }
                        else if (paymTerm.CreditCardPaymentType == CreditCardPaymentType::CreditCard && salesTable.CreditCardCustRefId)
                        {
                            if (!salesTable.checkPaymMode())
                            {
                                // The active credit card processor does not support the currency.
                                creditCardCust = CreditCardCust::find(salesTable.CreditCardCustRefId);
                                creditCardProcessors = CreditCardProcessors::find(creditCardCust.CreditCardProcessors);
                                ok = checkFailed(strFmt("@SYS327527", creditCardProcessors.Name, salesTable.CurrencyCode));
                            }
                        }
                    }
                    break;

                case fieldNum(SalesTable, CreditCardCustRefId):
                    creditCardCust = CreditCardCust::find(salesTable.CreditCardCustRefId);
                    ok = salesTable.checkCreditCardPaymentType();
                    ok = ok && salesTable.canCreditNoteUseCreditCard();
                    if (ok && !this.canCreditCardPaymentJournalPost())
                    {
                        salesTable.CreditCardCustRefId = 0;
                        ok = false;
                    }
                    break;

                case fieldNum(SalesTable, PaymMode):
                    if (!salesTable.checkPaymMode())
                    {
                        // The active credit card processor does not support the currency.
                        creditCardCust = CreditCardCust::find(salesTable.CreditCardCustRefId);
                        creditCardProcessors = CreditCardProcessors::find(creditCardCust.CreditCardProcessors);
                        ok = checkFailed(strFmt("@SYS327527", creditCardProcessors.Name, salesTable.CurrencyCode));
                    }
                    ok = ok && this.canCreditCardPaymentJournalPost();
                    break;

                case fieldNum(SalesTable, BankDocumentType):
                    if (salesTable.BankDocumentType != salesTable.orig().BankDocumentType)
                    {
                        if (salesTable.orig().isBankDocumentCreated())
                        {
                            // Bank document type could not be changed.
                            ok = checkFailed("@SYS316266");
                        }

                        if (ok)
                        {
                            switch (salesTable.BankDocumentType)
                            {
                                case BankDocumentType::ImportCollection:
                                case BankDocumentType::LetterOfCredit:
                                    if (BankLCExportFeatureChecker::checkBankLCExportEnabled())
                                    {
                                        if (!salesTable.mayBankDocumentTypeBeBankLCExport())
                                        {
                                            // It is not allowed to set to %1 at the current status.
                                            ok = checkFailed(strFmt("@SYS318015", enum2Value(salesTable.BankDocumentType)));
                                        }
                                    }
                                    else
                                    {
                                        // It is not allowed to set to %1 because the Export Letter of Credit feature is not enabled.
                                        ok = checkFailed(
                                            strFmt("@SYS318002", enum2Value(salesTable.BankDocumentType)),
                                            '',
                                            SysInfoAction_Formrun::newFormnameControlnameDesc(
                                                formStr(BankParameters),
                                                formControlStr(BankParameters, BankLC_BankLCExportEnable),
                                                "@SYS24215"));
                                    }
                                    break;
                                case BankDocumentType::LetterOfGuarantee:
                                    if (BankLGFeatureChecker::checkBankLGEnabled())
                                    {
                                        if (!salesTable.mayBankDocumentTypeBeBankLG())
                                        {
                                            // It is not allowed to set to %1 at the current status.
                                            ok = checkFailed(strFmt("@SYS318015", enum2Value(salesTable.BankDocumentType)));
                                        }
                                    }
                                    else
                                    {
                                        // It is not allowed to set to Letter of Guarantee because the Letter of Guarantee feature is not enabled.
                                        ok = checkFailed(
                                            "@SYS318001",
                                            '',
                                            SysInfoAction_Formrun::newFormnameControlnameDesc(
                                                formStr(BankParameters),
                                                formControlStr(BankParameters, BankLG_BankLGEnable),
                                                "@SYS24215"));
                                    }
                                    break;
                                default:
                                    break;
                            }
                        }
                    }
                    break;

                case fieldNum(SalesTable, InterCompanyOrder):
                    if (BankLCExportFeatureChecker::checkBankLCExportEnabled())
                    {
                        if (salesTable.InterCompanyOrder
                            && salesTable.isBankLCCreated())
                        {
                            // The Bank document has been created for this order.
                            // Order could not be changed to inter-company order.
                            ok = checkFailed("@SYS316279");
                        }
                    }
                    break;

                case fieldNum(SalesTable, MatchingAgreement):
                    if (countryRegion_RU)
                    {
                        ok = salesTable.checkAgreement_RU(
                            SalesAgreementHeaderExt_RU::findBySalesAgreementHeader(salesTable.MatchingAgreement).RecId);
                    }
                    else
                    {
                        if (salesTable.MatchingAgreement)
                        {
                            if (SalesAgreementHeader::find(salesTable.MatchingAgreement).canReleaseAgreement() != true)
                            {
                                ok = checkFailed("@SYS103075");
                            }
                        }
                    }
                    break;

                case fieldNum(SalesTable, BankAccount_LV):
                    if (salesTable.BankAccount_LV && BankParameters::checkCurrCodeControl_W() && BankAccountTable::find(salesTable.BankAccount_LV).CurrencyCode != CompanyInfoHelper::standardCurrency())
                    {
                        ok = checkFailed(strFmt("@SYS112224",
                                salesTable.BankAccount_LV,
                                fieldId2pname(tableNum(SalesTable), fieldNum(SalesTable, BankAccount_LV)),
                                tableId2pname(tableNum(BankAccountTable))));
                    }
                    break;
                case fieldNum(SalesTable, CurBankAccount_LV):
                    if (salesTable.CurBankAccount_LV && BankParameters::checkCurrCodeControl_W() && BankAccountTable::find(salesTable.CurBankAccount_LV).CurrencyCode != salesTable.CurrencyCode)
                    {
                        ok = checkFailed(strFmt("@SYS112224",
                                salesTable.CurBankAccount_LV,
                                fieldId2pname(tableNum(SalesTable), fieldNum(SalesTable, CurBankAccount_LV)),
                                tableId2pname(tableNum(BankAccountTable))));
                    }
                    break;

                case fieldNum(SalesTable, tdsGroup_IN):
                    if (countryRegion_IN
                        && TaxWithholdParameters_IN::find().tdsActivate && salesTable.tdsGroup_IN)
                    {
                        if (TaxWithholdGroupHeading::find(salesTable.tdsGroup_IN).TaxType_IN != TaxWithholdCodeType_IN::TDS)
                        {
                            ok = checkFailed(strFmt("@GLS5461", salesTable.tdsGroup_IN, TaxWithholdCodeType_IN::TDS));
                        }
                    }
                    break;

                case fieldNum(SalesTable, tcsGroup_IN):
                    if (countryRegion_IN
                        && TaxWithholdParameters_IN::find().tcsActivate && salesTable.tcsGroup_IN)
                    {
                        if (TaxWithholdGroupHeading::find(salesTable.tcsGroup_IN).TaxType_IN != TaxWithholdCodeType_IN::TCS)
                        {
                            ok = checkFailed(strFmt("@GLS5461", salesTable.tcsGroup_IN, TaxWithholdCodeType_IN::TCS));
                        }
                    }
                    break;

                case fieldNum(SalesTable, CustomsExportOrder_IN) :
                    if (countryRegion_IN
                        && TaxParameters::find().Customs_IN && salesTable.CustomsExportOrder_IN == NoYes::Yes &&
                        salesTable.SalesType != SalesType::Sales)
                    {
                        ok = checkFailed("@GLS5760");
                    }
                    break;

                case fieldNum(SalesTable, ShippingDateRequested):
                    if (countryRegion_RU)
                    {
                        SalesTable_RU salesTableRU = salesTable.salesTable_RU();
                        if (salesTableRU.AgreementHeaderExt_RU)
                        {
                            if (SalesAgreementHeaderExt_RU::salesAgreementHeader(salesTableRU.AgreementHeaderExt_RU).canReleaseAgreement(salesTable.ShippingDateRequested) != true)
                            {
                                ok = checkFailed(strFmt("@GLS221056", fieldPName(SalesTable, ShippingDateRequested)));
                            }
                        }
                    }
                    break;
            }
        }
        else if (countryRegion_RU && _tableId == tableNum(SalesTable_RU))
        {
            switch (_fieldId)
            {
                case fieldNum(SalesTable_RU, AgreementHeaderExt_RU):
                    ok = salesTable.checkAgreement_RU();
                    break;

                case(fieldNum(SalesTable_RU, InventProfileType_RU)):
                    // fall through
                    case(fieldNum(SalesTable_RU, InventProfileId_RU)):
                    ok = salesTable.checkInventProfile_RU();
                    break;

                case(fieldNum(SalesTable_RU, InventProfileUseRelated_RU)):
                    ok = salesTable.checkInventProfile_RU(true);
                    break;

                case fieldNum(SalesTable_RU, InvoicePostingType_RU):
                    ok = salesTable.checkInvoicePostingType_RU();
                    break;
            }
        }
        else if ( _tableId == tableNum(MCRSalesTable)
                 && isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            switch (_fieldId)
            {
                // Check source code
                case(fieldNum(MCRSalesTable, SourceId)):
                    ok = MCRSourceCodeSetup::validateSourceCode(salesTable.mcrSalesTable().SourceId);
                    break;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoteFormat</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates whether referenece invoice, invoice amount and reason code is filled in when note format is not NONE.
    /// </summary>
    /// <returns>
    ///     Returns false when at least one of them is not filled in. Otherwise, returns true.
    /// </returns>
    private boolean validateNoteFormat()
    {
        SalesTableExtensionTH salesTableExtensionTH = salesTable.salesTableExtensionTH();
        boolean ret = true;

        if (salesTableExtensionTH.NoteFormat != TaxUnrealizedSalesNoteFormat::None)
        {
            if (!salesTableExtensionTH.RefInvoiceId
                || !salesTableExtensionTH.RefInvoiceAmountCur
                || (!salesTableExtensionTH.ReasonTableRef && CustParameters::find().CreditNoteReasonReq))
            {
                // The reference invoice, reference invoice value and reason code must be filled in for debit/credit note.
                ret = checkFailed("@SYS4082911");
            }
        }
        else
        {
            salesTableExtensionTH.RefInvoiceId = '';
            salesTableExtensionTH.RefInvoiceAmountCur = 0;
            salesTableExtensionTH.ReasonTableRef = 0;

            salesTable.SysExtensionSerializerMap::packExtensionTable(salesTableExtensionTH);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    boolean  validateWrite()
    {
        SalesTable          salesTable_Orig = salesTable.orig();
        boolean ok        = true;
        boolean isChanged = true;

        if (!salesTable.RecId  &&  SalesTable::exist(salesTable.SalesId))
        {
            ok = checkFailed(strFmt("@SYS53144", salesTable.SalesId));
        }

        if (salesTable_Orig.RecId)
        {
            if (salesTable.SalesId != salesTable_Orig.SalesId)
            {
                ok = checkFailed("@SYS2650");
            }
            isChanged = !salesTable_Orig.equal(salesTable);
        }

        if (isChanged)
        {
            if (!salesTable.checkAccount())
            {
                ok = false;
            }

            if (!salesTable.checkInvoiceAccount())
            {
                ok = false;
            }
        }

        if (!salesTable.checkPayment())
        {
            ok = false;
        }

        if (!salesTable.checkCashPayment())
        {
            ok = false;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            // If there is a source code
            // and you are not doing a return Validate
            // Don't validate if allow expired source code is true, AND you are doing exchange.
            MCRSalesTable mcrSalesTable = salesTable.mcrSalesTable();
            if (mcrSalesTable.SourceId
                && salesTable.SalesType != SalesType::ReturnItem
                && !(MCROrderParameters::find().mcrAllowExpiredSourceCode && salesTable.mcrReturnSalesTable().IsExchange))
            {
                if (!MCRSourceCodeSetup::validateSourceEffective(mcrSalesTable.SourceId))
                {
                    ok = false;
                }
            }
        }
        // checking credit limit is executed in SalesTable.validateWrite to prevent incorrent info prefix()

        ok = ok && this.checkShipCarrierAddress();

        if (TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled())
        {
            ok = ok && this.validateNoteFormat();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ok = ok && salesTable.checkInvoicePostingType_RU();
            ok = ok && this.checkInventOwner_RU();
        }

        if (ok && #PdsMRCEnabled
            && PdsMRCParameters::find().RegulationWarningOnSales)
        {
            ok = !SalesLine::pdsMRCCheckRestrictedForAllSalesLines(salesTable);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAgainstCreditLimit</Name>
				<Source><![CDATA[
    static boolean checkAgainstCreditLimit(SalesTable _salesTable, SalesTotals _salesTotals = null)
    {
        boolean ret = true;

        /**
            Since totals calculations uses the inclTax from database the result will be wrong
            so creditlimit can not be done at this point.
        **/
        if (_salesTable.mustDoCreditLimitAfterUpdate())
        {
            return ret;
        }

        if (!_salesTotals)
        {
            _salesTotals = SalesTotals::construct(_salesTable);
        }

        if (!_salesTable.Estimate || _salesTable.Touched)
        {
            _salesTable.setEstimate(_salesTotals);
        }

        boolean isCallCenterOrder = _salesTable.mcrIsCallCenter();

        // Credit limit error should display for the below reasons.
        // Either the order is standard sales order and satisfies the credit limt parameters
        // Or the order is call center order with enable order completion set to 'NO'.
        if ((CustParameters::find().salesCheckCreditOnHeader() ||
            _salesTable.custTable_InvoiceAccount().MandatoryCreditLimit) &&
            (!isCallCenterOrder ||
            (!RetailMCRChannelTable::mcrEnableOrderCompletion(_salesTable) && RetailCallCenterOrderCreditLimitErrorToggle::instance().isEnabled())))
        {
            ret = _salesTable.checkAgainstCreditLimit(_salesTable, _salesTotals);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SalesTableType construct(SalesTable _salesTable)
    {
        NoYes                               isProject       = _salesTable.ProjId ? NoYes::Yes : NoYes::No;
        SalesLineTypeFactoryAttribute       attribute       = new SalesLineTypeFactoryAttribute(_salesTable.SalesType, isProject);
        SysExtensionGenericInstantiation    instantiation   = new SysExtensionGenericInstantiation(_salesTable);

        SalesTableType instance = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(SalesTableType), attribute, instantiation) as SalesTableType;

        if (!instance)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posConfirmation</Name>
				<Source><![CDATA[
    static int  posConfirmation()
    {
        return 2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posFacture_RU</Name>
				<Source><![CDATA[
    public static int posFacture_RU()
    {
        return 9;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoice</Name>
				<Source><![CDATA[
    static int  posInvoice()
    {
        return 5;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posInvoice4Paym_RU</Name>
				<Source><![CDATA[
    public static int posInvoice4Paym_RU()
    {
        return 8;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPackingSlip</Name>
				<Source><![CDATA[
    static int  posPackingSlip()
    {
        return 4;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPickingList</Name>
				<Source><![CDATA[
    static int  posPickingList()
    {
        return 3;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posPickingListRegistration</Name>
				<Source><![CDATA[
    static int  posPickingListRegistration()
    {
        return 6;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posProjectPackingSlip</Name>
				<Source><![CDATA[
    static int  posProjectPackingSlip()
    {
        return 7;
    }

]]></Source>
			</Method>
			<Method>
				<Name>posQuotation</Name>
				<Source><![CDATA[
    static int  posQuotation()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDeliveryAddress</Name>
				<Source><![CDATA[
    static void syncDeliveryAddress(SalesTable   _salesTable,
                                    AxPurchTable _axPurchTable,
                                    boolean      _forceAddressSync)
    {
        if ( _forceAddressSync
            || !_axPurchTable.purchTable()
            || _salesTable.fieldChanged(fieldNum(SalesTable, InterCompanyDirectDelivery))
            )
        {
            if (_salesTable.InterCompanyDirectDelivery)
            {
                _axPurchTable.parmDeliveryPostalAddress(_salesTable.DeliveryPostalAddress);
                _axPurchTable.parmDeliveryName(_salesTable.DeliveryName);
            }
            else
            {
                _axPurchTable.purchTable().type().setDefaultDeliveryAddress();
            }
        }
        else
        {
            if (_salesTable.InterCompanyDirectDelivery || _salesTable.existDirectDelivery())
            {
                if (_salesTable.fieldChanged(fieldNum(SalesTable, DeliveryPostalAddress)))
                {
                    _axPurchTable.parmDeliveryPostalAddress(_salesTable.DeliveryPostalAddress);
                }
                else
                {
                    _axPurchTable.parmDeliveryPostalAddress(_axPurchTable.purchTable().DeliveryPostalAddress);
                }

                if (_salesTable.fieldChanged(fieldNum(SalesTable, DeliveryName)))
                {
                    _axPurchTable.parmDeliveryName(_salesTable.DeliveryName);
                }
                else
                {
                    _axPurchTable.parmDeliveryName(_axPurchTable.purchTable().DeliveryName);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultingFields</Name>
				<Source><![CDATA[
    public List defaultingFields()
    {
        List result = new List(Types::Integer);

        result.addEnd(fieldNum(SalesTable, ProjId));
        result.addEnd(fieldNum(SalesTable, OneTimeCustomer));
        result.addEnd(fieldNum(SalesTable, CustAccount));
        result.addEnd(fieldNum(SalesTable, InvoiceAccount));
        result.addEnd(fieldNum(SalesTable, DeliveryPostalAddress));
        result.addEnd(fieldNum(SalesTable, DlvTerm));
        result.addEnd(fieldNum(SalesTable, DlvMode));
        result.addEnd(fieldNum(SalesTable, ReturnDeadline));
        result.addEnd(fieldNum(SalesTable, ContactPersonId));
        result.addEnd(fieldNum(SalesTable, Payment));
        result.addEnd(fieldNum(SalesTable, PaymMode));
        result.addEnd(fieldNum(SalesTable, InterCompanyOrder));
        result.addEnd(fieldNum(SalesTable, BankDocumentType));
        result.addEnd(fieldNum(SalesTable, SalesType));
        result.addEnd(fieldNum(SalesTable, Reservation));
        result.addEnd(fieldNum(SalesTable, BankCentralBankPurposeCode));
        result.addEnd(fieldNum(SalesTable, CurrencyCode));
        result.addEnd(fieldNum(SalesTable, InventSiteId));
        result.addEnd(fieldNum(SalesTable, InventLocationId));
        result.addEnd(fieldNum(SalesTable, DiscPercent));
        result.addEnd(fieldNum(SalesTable, MatchingAgreement));
        result.addEnd(fieldNum(SalesTable, CashDisc));
        result.addEnd(fieldNum(SalesTable, DeliveryPostalAddress));
        result.addEnd(fieldNum(SalesTable, DlvMode));
        result.addEnd(fieldNum(SalesTable, DeliveryDateControlType));
        result.addEnd(fieldNum(SalesTable, ReceiptDateRequested));
        result.addEnd(fieldNum(SalesTable, ShippingDateRequested));
        result.addEnd(fieldNum(SalesTable, ShippingDateConfirmed));
        result.addEnd(fieldNum(SalesTable, ReceiptDateConfirmed));

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultFromField</Name>
				<Source><![CDATA[
    public void defaultFromField(FieldId _fieldId, boolean _userInput)
    {
        this.modifiedField(_fieldId, tableNum(SalesTable), false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaults</Name>
				<Source><![CDATA[
    public void initDefaults()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeChanges</Name>
				<Source><![CDATA[
    public void mergeChanges()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergableFields</Name>
				<Source><![CDATA[
    public Set mergableFields()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeDocuRef</Name>
				<Source><![CDATA[
    private void removeDocuRef(SalesTable _salesTable, CustAccount _custAccount)
    {
        DocuRef custDocuRef;
        DocuRef salesDocuRef;
        CustTable custTable = CustTable::find(_custAccount);

        ttsbegin;

        delete_from salesDocuRef
            where salesDocuRef.RefTableId == tableNum(SalesTable)
                && salesDocuRef.RefRecId == _salesTable.RecId
                && salesDocuRef.RefCompanyId == _salesTable.DataAreaId
                && salesDocuRef.RecVersion == 1
            exists join custDocuRef
                where custDocuRef.RefTableId == tableNum(CustTable)
                    && custDocuRef.RefRecId == custTable.RecId
                    && custDocuRef.RefCompanyId == custTable.DataAreaId
                    && custDocuRef.Name == salesDocuRef.Name
                    && custDocuRef.Notes == salesDocuRef.Notes;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingParmDefaultSalesLineEnumerable_delegate</Name>
				<Source><![CDATA[
    delegate void kittingParmDefaultSalesLineEnumerable_delegate(TradeCommonIEnumerable _defaultSalesLineKitEnumerable, boolean _allowSalesLineCaching, SalesId _salesId, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingParmDefaultSalesLineEnumerable</Name>
				<Source><![CDATA[
    protected TradeCommonIEnumerable kittingParmDefaultSalesLineEnumerable()
    {
        EventHandlerResult resultValue = new EventHandlerResult();
        this.kittingParmDefaultSalesLineEnumerable_delegate(kittingDefaultSalesLineEnumerable, this.parmAllowSalesLineCaching(), salesTable.SalesId, resultValue);
        if (resultValue.hasResult())
        {
            kittingDefaultSalesLineEnumerable = resultValue.result() as TradeCommonIEnumerable;
            return kittingDefaultSalesLineEnumerable;
        }
        return this.parmDefaultSalesLineEnumerable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingCanDeleteLine_delegate</Name>
				<Source><![CDATA[
    delegate void kittingCanDeleteLine_delegate(SalesLine _salesLine, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingCanDeleteLine</Name>
				<Source><![CDATA[
    protected boolean kittingCanDeleteLine(SalesLine _salesLine)
    {
        EventHandlerResult resultValue = new EventHandlerResult();
        this.kittingCanDeleteLine_delegate(_salesLine, resultValue);
        return !resultValue.hasResult() || resultValue.booleanResult();
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSalesLineNoFetch_Picking_delegate</Name>
				<Source><![CDATA[
    delegate void kittingSalesLineNoFetch_Picking_delegate(SalesId _salesId, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>kittingSalesLineNoFetch_Picking</Name>
				<Source><![CDATA[
    protected SalesLine kittingSalesLineNoFetch_Picking()
    {
        SalesLine salesLineNoFetch;
        WMSOrder wmsOrderNoFetch;
        EventHandlerResult resultValue = new EventHandlerResult();
        this.kittingSalesLineNoFetch_Picking_delegate(salesTable.SalesId, resultValue);
        if (resultValue.hasResult())
        {
            salesLineNoFetch = resultValue.result() as SalesLine;
        }
        else
        {
            select nofetch salesLineNoFetch
                where salesLineNoFetch.SalesId == salesTable.SalesId
                    && ((salesLineNoFetch.SalesStatus == SalesStatus::None
                        || salesLineNoFetch.SalesStatus == SalesStatus::Backorder
                        || salesLineNoFetch.SalesStatus == SalesStatus::Delivered)
                    || (salesLineNoFetch.SalesDeliverNow != 0))
            exists join wmsOrderNoFetch
                where wmsOrderNoFetch.InventTransId == salesLineNoFetch.InventTransId
                &&    wmsOrderNoFetch.Type          == WMSOrderType::OrderPick;
        }
        return salesLineNoFetch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReplacementOrderDetailsOnReturnOrder</Name>
				<Source><![CDATA[
    protected internal void updateReplacementOrderDetailsOnReturnOrder()
    {
        if (salesTable.ReturnItemNum)
        {
            SalesTable returnOrder = SalesTable::findReturnItemNum(salesTable.ReturnItemNum, true);

            if (returnOrder.ReturnReplacementId == salesTable.SalesId)
            {
                returnOrder.ReturnReplacementId = '';
                returnOrder.ReturnReplacementCreated    = NoYes::No;

                if (RetailMCRChannelTable::mcrEnableOrderCompletion(returnOrder))
                {
                    MCRReturnSalesTable mcrReturnSalesTable = returnOrder.mcrReturnSalesTable();
                    if (mcrReturnSalesTable.ApplyCreditToExchange || mcrReturnSalesTable.AdvanceExchange)
                    {
                        mcrReturnSalesTable.ApplyCreditToExchange = NoYes::No;
                        mcrReturnSalesTable.AdvanceExchange = MCRAdvanceExchange::BLANK;
                        returnOrder.mcrPackMCRReturnSalesTable(mcrReturnSalesTable);
                    }
                }
                returnOrder.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteTaxUncommitted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes <c>TaxUncommitted</c> records for the entire document.
    /// </summary>
    internal void deleteTaxUncommitted()
    {
        if (TaxIntegrationCacheCalculationResultFlight::instance().isEnabled()
            && Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Sales))
        {
            TaxUncommitted::deleteForDocumentHeader(salesTable.TableId, salesTable.RecId, false);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>