<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerTransactionReportDataGenerator</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Generates the data into the <c>LedgerTrialBalanceDetailTmp</c> table for the trial balance detail report based on parameters.
/// </summary>
internal final class LedgerTransactionReportDataGenerator
{
    private const str NoVoucher = "@GeneralLedger:TrialBalanceDetailNoVoucher";
    private const str MultipleDocumentSymbol = "@GeneralLedger:TrialBalanceDetailMultipleIndicator";

    private LedgerTransactionsDetailTmp transactionDetailTable;
    private LedgerTrialBalanceDetailTmp trialBalanceDetailTable;
    private RecordInsertList transactionsDetailTmpRecordInsertList;
    private LedgerTransactionReportDataParameters reportParameters;
    private CurrencyExchangeHelper currencyExchangeHelper;
    private LedgerDistinctAccountTmp distinctAccount;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>newFromReportParameters</Name>
				<Source><![CDATA[
    internal static LedgerTransactionReportDataGenerator newFromReportParameters(LedgerTransactionReportDataParameters _reportParameters)
    {
        LedgerTransactionReportDataGenerator ledgerTransactionReportDataGenerator = new LedgerTransactionReportDataGenerator();

        ledgerTransactionReportDataGenerator.init(_reportParameters);

        return ledgerTransactionReportDataGenerator;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    private void new()
    {
        super();

        transactionsDetailTmpRecordInsertList = this.initializeDetailRecordInsertList(transactionDetailTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionDataAndSummarizeDetailWithNameDescription</Name>
				<Source><![CDATA[
    internal void updateTransactionDataAndSummarizeDetailWithNameDescription(str _mainAccountFilterValues = '')
    {
        this.generateLedgerAccountNameAndPrimaryFocusName();
        this.updateTransactionTypeForOpeningData();

        this.generateDetailSummaryBalanceRecords(_mainAccountFilterValues);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addGeneralLedgerDataToInsertList</Name>
				<Source><![CDATA[
    internal void addGeneralLedgerDataToInsertList(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        if (!transactionsDetailTmpRecordInsertList)
        {
            transactionsDetailTmpRecordInsertList = this.initializeDetailRecordInsertList(transactionDetailTable);
        }

        this.populateDetailDataFromGeneralJournal(_generalJournalEntry, _generalJournalAccountEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransactionDetailData</Name>
				<Source><![CDATA[
    internal void insertTransactionDetailData()
    {
        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    internal void init(LedgerTransactionReportDataParameters _reportParameters)
    {
        reportParameters = _reportParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTrialBalanceDetailData</Name>
				<Source><![CDATA[
    internal LedgerTrialBalanceDetailTmp getTrialBalanceDetailData()
    {
        select trialBalanceDetailTable;

        return trialBalanceDetailTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareDetailFromUnpostedDocumentTransaction</Name>
				<Source><![CDATA[
    internal void prepareDetailFromUnpostedDocumentTransaction()
    {
        date periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), reportParameters.parmFromDate());

        this.populateUnpostedLedgerJournalData(periodStartDate);

        if (reportParameters.parmIncludePendingAdvancedLedgerEntry())
        {
            this.populateUnpostedAdvancedLedgerEntry(periodStartDate);
        }

        if (reportParameters.parmIncludePendingBudgetRegisterEntry())
        {
            this.populateUnpostedBudgetRegisterEntry(periodStartDate);
        }

        if (reportParameters.parmIncludePendingFreeTextInvoice())
        {
            this.populateUnpostedFreeTextInvoice(periodStartDate);
        }

        if (reportParameters.parmIncludePendingVendorInvoice())
        {
            this.populateUnpostedVendorInvoice(periodStartDate);
        }

        if (reportParameters.parmIncludePendingProjInvoice())
        {
            this.populateUnpostedProjectInvoice(periodStartDate);
        }

        if (reportParameters.parmIncludePendingPurchaseOrder())
        {
            this.populateUnpostedPurchaseOrder(periodStartDate);
        }

        if (reportParameters.parmIncludePendingPurchReq())
        {
            this.populateUnpostedPurchaseRequisition(periodStartDate);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDetailDataFromGeneralJournal</Name>
				<Source><![CDATA[
    private void populateDetailDataFromGeneralJournal(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        AccountingDistribution accountingDistribution;
        boolean hasDetailData;

        this.setBasicDetailInfoFromGeneralJournal(_generalJournalEntry, _generalJournalAccountEntry);

        this.fillSourceDocumentInformationForGeneralJournalEntry(_generalJournalEntry, _generalJournalAccountEntry);

        this.setAmountFromGeneralJournalEntry(_generalJournalAccountEntry);

        this.setQuantity(_generalJournalAccountEntry.Quantity);
        
        if (transactionDetailTable.TransactionType == FiscalPeriodType::Operating)
        {
            if (_generalJournalEntry.LedgerEntryJournal)
            {
                hasDetailData = true;

                this.populatePaymentVouchers(_generalJournalEntry, _generalJournalAccountEntry);
            }
            else if (_generalJournalAccountEntry.PostingType == LedgerPostingType::ProjTurnover)
            {
                hasDetailData = hasDetailData || this.populateProjectInvoice(_generalJournalEntry.SubledgerVoucher, _generalJournalEntry.AccountingDate);
            }
            else if (_generalJournalAccountEntry.PostingType == LedgerPostingType::CustBalance)
            {
                hasDetailData = hasDetailData || this.populateCustTrans(_generalJournalEntry.SubledgerVoucher, _generalJournalEntry.AccountingDate);
            }

            if (!hasDetailData)
            {
                this.setGenericPostingInformation(_generalJournalEntry, _generalJournalAccountEntry);
            }
        }

        transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
    
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGenericPostingInformation</Name>
				<Source><![CDATA[
    private void setGenericPostingInformation(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        transactionDetailTable.Document = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailPostingTypePrefix", enum2str(_generalJournalAccountEntry.PostingType));
        transactionDetailTable.Description = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailJournalPrefix", _generalJournalEntry.JournalNumber);
        transactionDetailTable.DescriptionSupplement = _generalJournalAccountEntry.Text;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillSourceDocumentInformationForGeneralJournalEntry</Name>
				<Source><![CDATA[
    private void fillSourceDocumentInformationForGeneralJournalEntry(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        SubledgerJournalAccountEntry subledgerJournalAccountEntry;
        SubledgerJournalAccountEntryDistribution accountEntryDistribution;
        AccountingDistribution accountingDistribution;
        SourceDocumentLine sourceDocumentLine;
        int numberOfRelatedSourceDocuments;
    
        // For multiple source documents, only need to know if there are more than one source documents and get some general info from the first document.
        // No need to retrieve all source documents.
        while select firstonly10 SourceDocumentHeader from accountingDistribution
            group by accountingDistribution.SourceDocumentHeader
            exists join accountEntryDistribution
                where accountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
            exists join subledgerJournalAccountEntry
                where subledgerJournalAccountEntry.RecId == accountEntryDistribution.SubledgerJournalAccountEntry
                    && subledgerJournalAccountEntry.GeneralJournalAccountEntry == _generalJournalAccountEntry.RecId
                    && subledgerJournalAccountEntry.ledgerDimension == _generalJournalAccountEntry.LedgerDimension
        {
            numberOfRelatedSourceDocuments++;

            if (numberOfRelatedSourceDocuments > 1)
            {
                break;
            }
            else
            {
                AccountingDistribution accountingDistributionLocal;

                select firstonly RecId, TypeEnumName, ParentSourceDocumentLine, TypeEnumValue, SourceDocumentHeader from sourceDocumentLine
                    exists join accountingDistributionLocal
                        where accountingDistributionLocal.SourceDocumentLine == sourceDocumentLine.RecId
                            && sourceDocumentLine.SourceDocumentHeader == accountingDistribution.SourceDocumentHeader;

                if (sourceDocumentLine)
                {
                    this.setSourceDocumentInformationToDetail(_generalJournalEntry, _generalJournalAccountEntry, sourceDocumentLine);
                }
            }
        }

        if (numberOfRelatedSourceDocuments > 1)
        {
            transactionDetailTable.AccountNum = MultipleDocumentSymbol;
            transactionDetailTable.Document = this.getDocumentTitleForMultiple(sourceDocumentLine);
            transactionDetailTable.DocumentSubtitle = transactionDetailTable.Document;
        }
        else if (numberOfRelatedSourceDocuments == 1)
        {
            transactionDetailTable.DocumentSubtitle = transactionDetailTable.Document + transactionDetailTable.DocumentSubtitle;
        }

        if (numberOfRelatedSourceDocuments >= 1)
        {
            this.setGenericPostingInformation(_generalJournalEntry, _generalJournalAccountEntry);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentTitleForMultiple</Name>
				<Source><![CDATA[
    private str getDocumentTitleForMultiple( SourceDocumentLine _sourceDocumentLine)
    {
        str documentTitle;

        switch (_sourceDocumentLine.TypeEnumName)
        {
            case enumStr(SourceDocumentLine_VendorInvoice):
                documentTitle = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailInvoicePrefix", MultipleDocumentSymbol);
                break;

            case enumStr(SourceDocumentLine_AdvancedLedgerEntry):
                documentTitle = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailALEPrefix", MultipleDocumentSymbol);;
                break;

            case enumStr(SourceDocumentLine_CustomerInvoice):
                if (_sourceDocumentLine.TypeEnumValue == SourceDocumentLine_CustomerInvoice::CustomerFreeTextInvoiceLine)
                {
                    documentTitle = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailFTIPrefix", MultipleDocumentSymbol);
                }
                break;

            case enumStr(BudgetReservation_SourceDocumentLine_PSN):
                documentTitle =  this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailGBRPrefix", MultipleDocumentSymbol);
                break;

            default:
                documentTitle = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailDocumentPrefix", MultipleDocumentSymbol);
                break;
        }

        return documentTitle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDetailDataByGeneralJournal</Name>
				<Source><![CDATA[
    private void getDetailDataByGeneralJournal(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        SubledgerJournalAccountEntry _subledgerJournalAccountEntry,
        AccountingDistribution _accountingDistribution)
    {
        this.setBasicDetailInfoFromGeneralJournal(_generalJournalEntry, _generalJournalAccountEntry);

        this.setAmountFromGeneralJournalEntry(_generalJournalAccountEntry);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmountFromGeneralJournalEntry</Name>
				<Source><![CDATA[
    private void setAmountFromGeneralJournalEntry(GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        this.setDebitOrCreditAmount(_generalJournalAccountEntry.AccountingCurrencyAmount, _generalJournalAccountEntry.IsCredit != NoYes::Yes, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBasicDetailInfoFromGeneralJournal</Name>
				<Source><![CDATA[
    private void setBasicDetailInfoFromGeneralJournal(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        transactionDetailTable.clear();

        transactionDetailTable.GeneralJournalEntry = _generalJournalAccountEntry.GeneralJournalEntry;
        transactionDetailTable.Document = _generalJournalAccountEntry.Text;
        transactionDetailTable.Voucher = _generalJournalEntry.SubledgerVoucher;
        transactionDetailTable.TransDate = _generalJournalEntry.AccountingDate;
        transactionDetailTable.PostingLayer = _generalJournalEntry.PostingLayer;
        transactionDetailTable.TransactionType = FiscalPeriodType::Operating;
        transactionDetailTable.Description = _generalJournalAccountEntry.Text;
        transactionDetailTable.LedgerAccount = _generalJournalAccountEntry.LedgerAccount;
        transactionDetailTable.LedgerDimension = _generalJournalAccountEntry.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDebitOrCreditAmount</Name>
				<Source><![CDATA[
    private void setDebitOrCreditAmount(AmountMST _transAmount, boolean _isDebit, boolean _isFromJournalEntry)
    {
        if (_isFromJournalEntry)
        {
            if (_isDebit)
            {
                transactionDetailTable.AmountDebit = _transAmount;
            }
            else
            {
                transactionDetailTable.AmountCredit = _transAmount * -1;
            }
        }
        else
        {
            if (_isDebit)
            {
                if (_transAmount > 0)
                {
                    transactionDetailTable.AmountDebit = _transAmount;
                }
                else
                {
                    transactionDetailTable.AmountCredit = _transAmount * -1;
                }
            }
            else
            {
                if (_transAmount > 0)
                {
                    transactionDetailTable.AmountCredit = _transAmount;
                }
                else
                {
                    transactionDetailTable.AmountDebit = _transAmount * -1;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTransactionDetails</Name>
				<Source><![CDATA[
    private void populateTransactionDetails(
        SubledgerJournalAccountEntry _subledgerJournalAccountEntry,
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        AccountingDistribution _accountingDistribution)
    {
        SourceDocumentLine sourceDocumentLine;
        boolean isBalanceAccount;

        select firstonly RecId, TypeEnumName, ParentSourceDocumentLine, TypeEnumValue from sourceDocumentLine
            where sourceDocumentLine.RecId == _accountingDistribution.SourceDocumentLine;

        if (!sourceDocumentLine)
        {
            isBalanceAccount = true;
            SubledgerJournalAccountEntryDistribution subledgerJournalAccountEntryDistribution;
            AccountingDistribution accountingDistribution;

            select firstonly RecId, TypeEnumName, ParentSourceDocumentLine, TypeEnumValue from sourceDocumentLine
                exists join accountingDistribution
                    where accountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
                exists join subledgerJournalAccountEntryDistribution
                    where subledgerJournalAccountEntryDistribution.AccountingDistribution == accountingDistribution.RecId
                        && subledgerJournalAccountEntryDistribution.SubledgerJournalAccountEntry == _subledgerJournalAccountEntry.RecId;
        }

        this.setSourceDocumentInformationToDetail(_generalJournalEntry, _generalJournalAccountEntry, sourceDocumentLine);

        if (!isBalanceAccount && transactionDetailTable.Description)
        {
            transactionDetailTable.Description = transactionDetailTable.DescriptionSupplement;
            transactionDetailTable.DescriptionSupplement = transactionDetailTable.DescriptionComment;
            transactionDetailTable.DescriptionComment = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSourceDocumentInformationToDetail</Name>
				<Source><![CDATA[
    private void setSourceDocumentInformationToDetail(
        GeneralJournalEntry _generalJournalEntry,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        SourceDocumentLine sourceDocumentLine)
    {
        switch (sourceDocumentLine.TypeEnumName)
        {
            case enumStr(SourceDocumentLine_VendorInvoice):
                this.populateVendorInvoice(sourceDocumentLine, BudgetSourceTrackingStatus::Confirmed);
                break;

            case enumStr(SourceDocumentLine_AdvancedLedgerEntry):
                this.populateAdvanceLedgerEntry(sourceDocumentLine);
                break;

            case enumStr(SourceDocumentLine_CustomerInvoice):
                if (sourceDocumentLine.TypeEnumValue == SourceDocumentLine_CustomerInvoice::CustomerFreeTextInvoiceLine)
                {
                    this.populateFreeTextInvoiceDetails(sourceDocumentLine);
                }
                break;

            case enumStr(BudgetReservation_SourceDocumentLine_PSN):
                this.populateGeneralBudgetReservation(sourceDocumentLine);
                break;

            default:
                transactionDetailTable.DocumentSubtitle = _generalJournalAccountEntry.Text;
                transactionDetailTable.Document = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailDocumentPrefix", _generalJournalEntry.DocumentNumber);
                transactionDetailTable.Description = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailJournalPrefix", _generalJournalEntry.JournalNumber);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustTrans</Name>
				<Source><![CDATA[
    private boolean populateCustTrans(Voucher _voucher, TransDate _transDate)
    {
        CustTrans custTrans;
        boolean isSuccessful;

        select firstonly RecId, TransType, AccountNum from custTrans
            where custTrans.Voucher == _voucher
                && custTrans.TransDate == _transDate;

        transactionDetailTable.AccountNum = custTrans.AccountNum;

        if (custTrans && custTrans.TransType == LedgerTransType::Project)
        {
            isSuccessful = this.populateProjectInvoice(_voucher, _transDate);
        }

        return isSuccessful;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateFreeTextInvoiceDetails</Name>
				<Source><![CDATA[
    private void populateFreeTextInvoiceDetails(SourceDocumentLine _sourceDocumentLine)
    {
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;

        select firstonly InvoiceTxt, BillingCode
            from custInvoiceLine
                where custInvoiceLine.SourceDocumentLine == _sourceDocumentLine.RecId
            join InvoiceAccount, InvoiceId from custInvoiceTable
                where custInvoiceLine.ParentRecId == custInvoiceTable.RecId;

        this.setDocumentLineAndDescriptionForFreeTextInvoice(custInvoiceTable, custInvoiceLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateGeneralBudgetReservation</Name>
				<Source><![CDATA[
    private boolean populateGeneralBudgetReservation(SourceDocumentLine _sourceDocumentLine)
    {
        BudgetReservationHeader_PSN budgetReservationHeader;
        BudgetReservationLine_PSN budgetReservationLine;
        boolean isFinalizedOrCancelled;

        select firstonly LineNumber, TransactionText, RecId
            from budgetReservationLine
                where budgetReservationLine.SourceDocumentLine == _sourceDocumentLine.RecId
            join DocumentStatus, DocumentNumber, DocumentTitle, RecId from budgetReservationHeader
                where budgetReservationLine.BudgetReservationHeader_PSN == budgetReservationHeader.RecId;

        if (budgetReservationLine && budgetReservationHeader)
        {
            isFinalizedOrCancelled = budgetReservationHeader.DocumentStatus == BudgetReservationDocumentStatus_PSN::Finalized
                || budgetReservationHeader.DocumentStatus == BudgetReservationDocumentStatus_PSN::Canceled
                || budgetReservationHeader.DocumentStatus == BudgetReservationDocumentStatus_PSN::Rejected;

            transactionDetailTable.Document = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailGBRPrefix",
                budgetReservationHeader.DocumentNumber);

            transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailLinePrefix",
                int2Str(budgetReservationLine.LineNumber));

            transactionDetailTable.Description = budgetReservationHeader.DocumentTitle;
            transactionDetailTable.DescriptionSupplement = budgetReservationLine.TransactionText;
        }

        return !isFinalizedOrCancelled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePaymentVouchers</Name>
				<Source><![CDATA[
    private void populatePaymentVouchers(GeneralJournalEntry _generalJournalEntry, GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerEntryJournal ledgerEntryJournal;

        boolean budgetRecordfound;
        boolean isMultipleAccounts;

        // Using generalJournalEntry table to filter the payment line account number and name info.
        if (_generalJournalEntry.JournalCategory == LedgerTransType::GeneralJournal
            && LedgerTransactionReportCorrectTextForCustAndVendFlight::instance().isEnabled())
        {
            LedgerJournalACType ledgerJournalACType;

            if (_generalJournalAccountEntry.PostingType == LedgerPostingType::CustBalance)
            {
                CustTrans custTrans;
                CustTable custTable;
                ledgerJournalACType = LedgerJournalACType::Cust;

                select count(RecId) from custTable
                    exists join custTrans
                        where custTrans.AccountNum == custTable.AccountNum
                        join ledgerJournalTrans
                            where ledgerJournalTrans.Voucher == _generalJournalEntry.SubledgerVoucher
                                && ledgerJournalTrans.AccountType == ledgerJournalACType
                                && ledgerJournalTrans.CustTransId == custTrans.RecId
                        join ledgerEntryJournal
                            where ledgerEntryJournal.RecId == _generalJournalEntry.LedgerEntryJournal
                                && ledgerEntryJournal.JournalNumber == ledgerJournalTrans.JournalNum;

                if (custTable.RecId > 1)
                {
                    isMultipleAccounts = true;
                }
            }
            else if (_generalJournalAccountEntry.PostingType == LedgerPostingType::VendBalance)
            {
                VendTrans vendTrans;
                VendTable vendTable;
                ledgerJournalACType = LedgerJournalACType::Vend;

                select count(RecId) from vendTable
                    exists join vendTrans
                        where VendTrans.AccountNum == vendTable.AccountNum
                        join ledgerJournalTrans
                            where ledgerJournalTrans.Voucher == _generalJournalEntry.SubledgerVoucher
                                && ledgerJournalTrans.AccountType == ledgerJournalACType
                                && ledgerJournalTrans.VendTransId == vendTrans.RecId
                        join ledgerEntryJournal
                            where ledgerEntryJournal.RecId == _generalJournalEntry.LedgerEntryJournal
                                && ledgerEntryJournal.JournalNumber == ledgerJournalTrans.JournalNum;

                if (vendTable.RecId > 1)
                {
                    isMultipleAccounts = true;
                }
            }

            if (ledgerJournalACType == LedgerJournalACType::Cust || ledgerJournalACType == LedgerJournalACType::Vend)
            {
                // Select ledgerJournalTrans of which type is either Vend or Cust.
                select firstonly RecId, JournalNumber from ledgerEntryJournal
                    where ledgerEntryJournal.RecId == _generalJournalEntry.LedgerEntryJournal
                    join Name, JournalName from ledgerJournalTable
                        where ledgerEntryJournal.JournalNumber == ledgerJournalTable.JournalNum
                    join Txt, JournalNum, BankChequeNum, TransDate, CustTransId, VendTransId, AccountType from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                            && ledgerJournalTrans.Voucher == _generalJournalEntry.SubledgerVoucher
                            && ledgerJournalTrans.AccountType == ledgerJournalACType;
            }
            else
            {
                // Select ledgerJournalTrans of which type is neither Vend nor Cust.
                select firstonly RecId, JournalNumber from ledgerEntryJournal
                    where ledgerEntryJournal.RecId == _generalJournalEntry.LedgerEntryJournal
                    join Name, JournalName from ledgerJournalTable
                        where ledgerEntryJournal.JournalNumber == ledgerJournalTable.JournalNum
                    join Txt, JournalNum, BankChequeNum, TransDate, CustTransId, VendTransId from ledgerJournalTrans
                        where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                            && ledgerJournalTrans.Voucher == _generalJournalEntry.SubledgerVoucher
                            && ledgerJournalTrans.AccountType != LedgerJournalACType::Vend
                            && ledgerJournalTrans.AccountType != LedgerJournalACType::Cust;
            }
        }
        else
        {
            select firstonly RecId, JournalNumber from ledgerEntryJournal
                where ledgerEntryJournal.RecId == _generalJournalEntry.LedgerEntryJournal
                join Name, JournalName from ledgerJournalTable
                    where ledgerEntryJournal.JournalNumber == ledgerJournalTable.JournalNum
                join Txt, JournalNum, BankChequeNum, TransDate, CustTransId, VendTransId from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
                        && ledgerJournalTrans.Voucher == _generalJournalEntry.SubledgerVoucher;
        }

        if (LedgerParameters::find().IsBudgetAppropriationEnabled == NoYes::Yes
            && ledgerJournalTable.JournalName == BudgetParameters::find().LedgerJournalName)
        {
            this.populateBudgetRegisterEntry(_generalJournalEntry.RecId);
            budgetRecordfound = true;
        }

        if (!budgetRecordfound)
        {
            if (isMultipleAccounts)
            {
                this.setAccountNumAndDocumentForMultiple(ledgerJournalTrans.AccountType);
            }
            else
            {
                transactionDetailTable.Document = this.getConcatenationStringWithColon(
                    "@GeneralLedger:TrialBalanceDetailPayPrefix",
                    ledgerJournalTrans.BankChequeNum);

                transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                    "@GeneralLedger:TrialBalanceDetailPayDatePrefix",
                    date2StrUsr(ledgerJournalTrans.TransDate, 1));

                if (ledgerJournalTrans.VendTransId || ledgerJournalTrans.CustTransId)
                {
                    this.setDescriptionForCustomerOrVendor(ledgerJournalTrans);
                }
                else
                {
                    transactionDetailTable.Document = ledgerJournalTrans.journalNum;
                    transactionDetailTable.DocumentSubtitle = ledgerJournalTable.Name;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePreEncumbranceDetails</Name>
				<Source><![CDATA[
    private void populatePreEncumbranceDetails(SourceDocumentLine _sourceDocumentLine)
    {
        PurchReqTable purchReqTable;
        PurchReqLine purchReqLine;

        select firstonly ItemIdNonCatalog, ItemId, BuyingLegalEntity, InventDimId, ItemIdDataArea, LineNum
            from purchReqLine
                where purchReqLine.SourceDocumentLine == _sourceDocumentLine.RecId
            join PurchReqName, PurchReqId from PurchReqTable
                where PurchReqTable.RecId == purchReqLine.PurchReqTable;

        this.setDocumentLineAndDescriptionForPurchaseRequisition(purchReqTable, purchReqLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjectInvoice</Name>
				<Source><![CDATA[
    private boolean populateProjectInvoice(Voucher _voucher, TransDate _accountingDate)
    {
        boolean found;
        ProjProposalJour projProposalJour;
        ProjTable projTable;
        CustTable custTable;

        select firstonly ProjInvoiceId, InvoiceDate, ProposalId, InvoiceAccount, DefaultDimension, InvoiceAmount, LineProperty, LedgerVoucher
            from projProposalJour
                where projProposalJour.InvoiceDate >= _accountingDate
                    && projProposalJour.LedgerVoucher == _voucher
            outer join Party from custTable
                where custTable.AccountNum == projProposalJour.InvoiceAccount;

        if (projProposalJour)
        {
            found = true;

            this.setDocumentLineAndDescriptionForProjectInvoice(projProposalJour);
        }
        else
        {
            ProjJournalTrans projJournalTrans;

            select firstonly TransId, Txt, ProjId
                from projJournalTrans
                    where projJournalTrans.TransDate == _accountingDate
                        && projJournalTrans.Voucher == _voucher
                outer join Name, CustAccount from projTable
                    where projJournalTrans.ProjId == projTable.ProjId
                outer join Party from custTable
                    where custTable.AccountNum == projTable.CustAccount;

            if (projJournalTrans)
            {
                found = true;

                transactionDetailTable.Document = this.getConcatenationStringWithColon(
                    "@GeneralLedger:TrialBalanceDetailProjectTransIdPrefix",
                    projJournalTrans.TransId);

                transactionDetailTable.DocumentSubtitle = projJournalTrans.Txt;

                if (projTable)
                {
                    transactionDetailTable.AccountNum = projTable.CustAccount;
                    transactionDetailTable.DescriptionSupplement = this.concatenateTwoStringWithSeparator(projJournalTrans.ProjId, projTable.Name);
                }

                if (custTable)
                {
                    transactionDetailTable.Description = this.concatenateTwoStringWithSeparator(projTable.CustAccount, custTable.name());
                }
            }
        }

        return found;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBudgetRegisterEntry</Name>
				<Source><![CDATA[
    private void populateBudgetRegisterEntry(GeneralJournalEntryRecId _generalJournalEntryRecId)
    {
        BudgetTransactionHeader budgetTransactionHeader;
        BudgetTransactionLine budgetTransactionLine;

        select TransactionNumber, BudgetTransactionCode, ReasonTableRef
            from budgetTransactionHeader
                where budgetTransactionHeader.TransactionStatus == BudgetTransactionStatus::Completed
            join LedgerDimension, Comment from budgetTransactionLine
                where budgetTransactionLine.BudgetTransactionHeader == budgetTransactionHeader.RecId
                    && budgetTransactionLine.GeneralJournalEntry == _generalJournalEntryRecId;

        this.setDocumentLineAndDescriptionForBudgetRegisterEntry(budgetTransactionHeader, budgetTransactionLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForBudgetRegisterEntry</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForBudgetRegisterEntry(BudgetTransactionHeader _budgetTransactionHeader, BudgetTransactionLine _budgetTransactionLine)
    {
        transactionDetailTable.Document = this.getConcatenationStringWithColon(
            "@GeneralLedger:TrialBalanceDetailBREPrefix",
            _budgetTransactionHeader.TransactionNumber);
        
        Description transactionCodeDescription = BudgetTransactionCode::find(_budgetTransactionHeader.BudgetTransactionCode).Description;
        ReasonCode reasonCode = ReasonTableRef::find(_budgetTransactionHeader.ReasonTableRef).Reason;
        transactionDetailTable.DocumentSubtitle = '';

        if (transactionCodeDescription)
        {
            transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailBillingCodePrefix",
                transactionCodeDescription);
        }

        transactionDetailTable.Description = DimensionAttributeValueCombination::find(_budgetTransactionLine.LedgerDimension).DisplayValue;

        transactionDetailTable.DescriptionSupplement = this.concatenateTwoStringWithSeparator(
            reasonCode,
            _budgetTransactionLine.Comment);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateVendorInvoice</Name>
				<Source><![CDATA[
    private void populateVendorInvoice(SourceDocumentLine _sourceDocumentLine, BudgetSourceTrackingStatus _status)
    {
        SourceDocumentLine parentSourceDocumentLine;

        if (_status == BudgetSourceTrackingStatus::Confirmed)
        {
            VendInvoiceTrans vendInvoiceTrans;

            if (_sourceDocumentLine.ParentSourceDocumentLine)
            {
                select firstonly PurchID, InvoiceId, InvoiceDate, numberSequenceGroup, InternalInvoiceId, Name, BudgetReservationLine_PSN from vendInvoiceTrans
                    exists join parentSourceDocumentLine
                        where vendInvoiceTrans.SourceDocumentLine == parentSourceDocumentLine.Recid
                            && parentSourceDocumentLine.RecId == _sourceDocumentLine.ParentSourceDocumentLine;
            }
            else
            {
                select PurchID, InvoiceId, InvoiceDate, numberSequenceGroup, InternalInvoiceId, Name, BudgetReservationLine_PSN from vendInvoiceTrans
                    where vendInvoiceTrans.SourceDocumentLine == _sourceDocumentLine.RecId;
            }

            if (vendInvoiceTrans)
            {
                this.populateVendorInvoiceDetails(vendInvoiceTrans);
            }
        }
        else
        {
            VendInvoiceInfoTable vendInvoiceInfoTable;
            VendInvoiceInfoLine vendInvoiceInfoLine;

            if (_sourceDocumentLine.ParentSourceDocumentLine)
            {
                select firstonly Description, BudgetReservationLine_PSN from vendInvoiceInfoLine
                    join DocumentDate, InvoiceAccount, PurchAgreementHeader_PSN, Num, PurchId from vendInvoiceInfoTable
                        where vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::Pending
                            && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
                            && vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId
                    exists join parentSourceDocumentLine
                        where vendInvoiceInfoLine.SourceDocumentLine == parentSourceDocumentLine.RecId
                            && parentSourceDocumentLine.RecId == _sourceDocumentLine.ParentSourceDocumentLine;
            }
            else
            {
                select firstonly Description, BudgetReservationLine_PSN from vendInvoiceInfoLine
                    join DocumentDate, InvoiceAccount, PurchAgreementHeader_PSN, Num, PurchId from vendInvoiceInfoTable
                        where vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::Pending
                            && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
                            && vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId
                            && vendInvoiceInfoLine.SourceDocumentLine == _sourceDocumentLine.RecId;
            }

            this.setDocumentLineAndDescriptionForVendorInvoice(vendInvoiceInfoTable, vendInvoiceInfoLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateVendorInvoiceDetails</Name>
				<Source><![CDATA[
    private void populateVendorInvoiceDetails(VendInvoiceTrans _vendInvoiceTrans)
    {
        if (_vendInvoiceTrans)
        {
            VendInvoiceJour vendInvoiceJour;
            VendTrans vendTrans;

            select firstonly PurchAgreementHeader_PSN, PurchId, InvoiceAccount, DocumentDate
                from vendInvoiceJour
                    where _vendInvoiceTrans.PurchID == vendInvoiceJour.PurchId
                        && _vendInvoiceTrans.InvoiceId == vendInvoiceJour.InvoiceId
                        && _vendInvoiceTrans.InvoiceDate == vendInvoiceJour.InvoiceDate
                        && _vendInvoiceTrans.numberSequenceGroup == vendInvoiceJour.numberSequenceGroup
                        && _vendInvoiceTrans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId
                join LastSettleDate, RecId, OffsetRecid from vendTrans
                    where vendTrans.Voucher == vendInvoiceJour.LedgerVoucher
                        && vendTrans.AccountNum == vendInvoiceJour.InvoiceAccount
                        && vendTrans.TransDate == vendInvoiceJour.InvoiceDate;

            this.setAPInvoiceDescription(
                _vendInvoiceTrans.InvoiceId,
                vendInvoiceJour.PurchAgreementHeader_PSN,
                vendInvoiceJour.InvoiceAccount,
                vendInvoiceJour.DocumentDate,
                _vendInvoiceTrans.Name,
                vendInvoiceJour.PurchId,
                _vendInvoiceTrans.BudgetReservationLine_PSN);

            transactionDetailTable.AccountNum = vendInvoiceJour.InvoiceAccount;
            transactionDetailTable.DocumentComment = this.getTextByLedgerJournalTransaction(vendTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTextByLedgerJournalTransaction</Name>
				<Source><![CDATA[
    private Description255 getTextByLedgerJournalTransaction(VendTrans _vendTrans)
    {
        VendTransOpen vendTransOpen;
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from vendTransOpen
            where vendTransOpen.RefRecId == _vendTrans.RecId;

        if (vendTransOpen)
        {
            SpecTrans specTrans;
            select firstonly BankChequeNum, TransDate from ledgerJournalTrans
                exists join specTrans
                    where specTrans.RefRecId == vendTransOpen.RecId
                        && specTrans.RefTableId == tableNum(VendTransOpen)
                        && specTrans.SpecRecId == ledgerJournalTrans.RecId
                        && specTrans.SpecTableId == tableNum(LedgerJournalTrans);
        }
        else
        {
            select firstonly BankChequeNum, TransDate from ledgerJournalTrans
                where (ledgerJournalTrans.VendTransId == _vendTrans.RecId
                    || (ledgerJournalTrans.VendTransId == _vendTrans.OffsetRecid
                        && _vendTrans.OffsetRecid != 0));
        }

        Description255 textString;

        if (ledgerJournalTrans)
        {
            textString = this.getPayCheckText(ledgerJournalTrans);
        }

        return textString;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPayCheckText</Name>
				<Source><![CDATA[
    private Description255 getPayCheckText(LedgerJournalTrans _ledgerJournalTrans)
    {
        Description255 paidText;

        if (_ledgerJournalTrans.BankChequeNum != '')
        {
            paidText = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailPaidPrefix",
                this.concatenateTwoStringWithSeparator(strLRTrim(_ledgerJournalTrans.BankChequeNum),
                    date2StrUsr(_ledgerJournalTrans.TransDate, DateFlags::None)));
        }

        return paidText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateAdvanceLedgerEntry</Name>
				<Source><![CDATA[
    private void populateAdvanceLedgerEntry(SourceDocumentLine _sourceDocumentLine)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;
        AdvancedLedgerEntryLine advancedLedgerEntryLine;

        select firstonly TransactionText, RecId
            from advancedLedgerEntryLine
                where advancedLedgerEntryLine.SourceDocumentLine == _sourceDocumentLine.RecId
            join TransactionNumber, TransactionText, RecId from advancedLedgerEntryHeader
                where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == advancedLedgerEntryHeader.RecId;

        this.setDocumentLineAndDescriptionForAdvancedLedgerEntry(advancedLedgerEntryHeader, advancedLedgerEntryLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAPInvoiceDescription</Name>
				<Source><![CDATA[
    private void setAPInvoiceDescription(
        VendInvoiceId _invoiceId,
        RefRecId _purchaseAgreementRecId,
        AccountNum _vendAccount,
        TransDate _invoiceDate,
        ItemFreeTxt _invoiceName,
        PurchIdBase _purchId,
        RefRecId _generalReservationBudgetRecId)
    {
        transactionDetailTable.Document = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailInvoicePrefix", _invoiceId);
        transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailInvoiceDatePrefix", date2StrUsr(_invoiceDate, DateFlags::None));
        transactionDetailTable.DescriptionSupplement = _invoiceName;

        VendTable vendTable = VendTable::find(_vendAccount);
        transactionDetailTable.AccountNum = vendTable.AccountNum;
        transactionDetailTable.Description = vendTable.name();
        transactionDetailTable.DescriptionComment = this.getDescriptionCommentForAPInvoice(
            _purchId,
            _purchaseAgreementRecId,
            _generalReservationBudgetRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDescriptionCommentForAPInvoice</Name>
				<Source><![CDATA[
    private str getDescriptionCommentForAPInvoice(
        PurchIdBase _purchId,
        RefRecId _purchaseAgreementRecId,
        RefRecId _generalReservationBudgetRecId)
    {
        str descriptionComment;

        if (_purchId)
        {
            descriptionComment = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailPOLinePrefix", _purchId);
        }

        PurchAgreementHeader purchAgreementHeader = PurchAgreementHeader::find(_purchaseAgreementRecId);

        if (purchAgreementHeader.PurchNumberSequence)
        {
            str purchAggreenmentString = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailPAPrefix", purchAgreementHeader.PurchNumberSequence);
            descriptionComment = this.concatenateTwoStringWithSeparator(descriptionComment, purchAggreenmentString, ' | ');
        }

        if (_generalReservationBudgetRecId)
        {
            BudgetReservationLine_PSN budgetReservationLine;
            BudgetReservationHeader_PSN budgetReservationHeader;

            select firstonly DocumentNumber, RecId from budgetReservationHeader
                exists join budgetReservationLine
                    where budgetReservationLine.BudgetReservationHeader_PSN == budgetReservationHeader.RecId
                        && budgetReservationLine.RecId == _generalReservationBudgetRecId;

            if (budgetReservationHeader)
            {
                str budgetReservationDocumentNumber = this.getConcatenationStringWithColon("@GeneralLedger:TrialBalanceDetailGBRPrefix", budgetReservationHeader.DocumentNumber);
                descriptionComment = this.concatenateTwoStringWithSeparator(descriptionComment, budgetReservationDocumentNumber, ' | ');
            }
        }

        return descriptionComment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDetailRecordInsertList</Name>
				<Source><![CDATA[
    private RecordInsertList initializeDetailRecordInsertList(LedgerTransactionsDetailTmp _tempRecord)
    {
        RecordInsertList recordInsertList = new RecordInsertList(
            tableNum(LedgerTransactionsDetailTmp), // table id
            false, // skip insert
            false, // skip database log
            false, // skip events
            false, // skip aos validation
            false, // skip RLS validation
            _tempRecord);

        return recordInsertList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeSummaryRecordInsertList</Name>
				<Source><![CDATA[
    private RecordInsertList initializeSummaryRecordInsertList(LedgerTrialBalanceDetailTmp _tempRecord)
    {
        RecordInsertList recordInsertList = new RecordInsertList(
            tableNum(LedgerTrialBalanceDetailTmp),
            false, // skip insert
            false, // skip database log
            false, // skip events
            false, // skip aos validation
            false, // skip RLS validation
            _tempRecord);

        return recordInsertList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOpenCloseSummaryRecordList</Name>
				<Source><![CDATA[
    private void createOpenCloseSummaryRecordList(RecordInsertList _tempDetailSummaryRecordList,
        DimensionDisplayValue _displayValue,
        Description1000 _description,
        LedgerDimensionAccount _ledgerDimension,
        AmountMSTLong _openingAmount,
        AmountMSTLong _closingAmount,
        Qty _openingQuantity,
        Qty _closingQuantity)
    {
        trialBalanceDetailTable.clear();
        trialBalanceDetailTable.AccountingDate = reportParameters.parmFromDate();
        trialBalanceDetailTable.Document = "@SYS53035";
        trialBalanceDetailTable.TransactionType = FiscalPeriodType::Opening;
        trialBalanceDetailTable.TransactionTypeInt = enum2int(FiscalPeriodType::Opening);
        trialBalanceDetailTable.EndingBalance = _openingAmount;
        trialBalanceDetailTable.OpeningBalance = _openingAmount;
        trialBalanceDetailTable.PrimaryFocus = _displayValue;
        trialBalanceDetailTable.PrimaryFocusDescription = _description;
        trialBalanceDetailTable.Quantity = _openingQuantity;

        trialBalanceDetailTable.LedgerDimension = _ledgerDimension;

        _tempDetailSummaryRecordList.add(trialBalanceDetailTable);

        // Inserting closing amount
        trialBalanceDetailTable.clear();
        trialBalanceDetailTable.AccountingDate = reportParameters.parmToDate();
        trialBalanceDetailTable.Document = "@SYS50986";
        trialBalanceDetailTable.TransactionType = FiscalPeriodType::Closing;
        trialBalanceDetailTable.TransactionTypeInt = enum2int(FiscalPeriodType::Closing);
        trialBalanceDetailTable.EndingBalance = _closingAmount;
        trialBalanceDetailTable.ClosingBalance = _closingAmount;
        trialBalanceDetailTable.PrimaryFocus = _displayValue;
        trialBalanceDetailTable.PrimaryFocusDescription = _description;
        trialBalanceDetailTable.LedgerDimension = _ledgerDimension;
        trialBalanceDetailTable.Quantity = _closingQuantity;

        _tempDetailSummaryRecordList.add(trialBalanceDetailTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>concatenateWithSpace</Name>
				<Source><![CDATA[
    private Description1000 concatenateWithSpace(Description255 _string1, Description255 _string2, Description255 _string3)
    {
        return strFmt('%1    %2    %3', _string1, _string2, _string3);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateBudgetData</Name>
				<Source><![CDATA[
    private void populateBudgetData(BudgetTransactionHeader _budgetTransactionHeader, BudgetTransactionLine _budgetTransactionLine)
    {
        transactionDetailTable.Voucher = NoVoucher;
        transactionDetailTable.GeneralJournalEntry = _budgetTransactionLine.GeneralJournalEntry;

        if (_budgetTransactionHeader.TransactionStatus == BudgetTransactionStatus::Completed)
        {
            GeneralJournalEntry generalJournalEntry;

            select firstonly SubledgerVoucher from generalJournalEntry
                where generalJournalEntry.RecId == _budgetTransactionLine.GeneralJournalEntry;

            if (generalJournalEntry)
            {
                transactionDetailTable.Voucher = generalJournalEntry.SubledgerVoucher;
            }
        }

        this.setDocumentLineAndDescriptionForBudgetRegisterEntry(_budgetTransactionHeader, _budgetTransactionLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>concatenateTwoStringWithSeparator</Name>
				<Source><![CDATA[
    private str concatenateTwoStringWithSeparator(str _stringFirst, str _stringSecond, str _separator = ' - ')
    {
        return (_stringFirst != '' && _stringSecond != '') ?
            strFmt('%1%2%3', _stringFirst, _separator, _stringSecond) : strFmt('%1%2', _stringFirst, _stringSecond);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConcatenationStringWithColon</Name>
				<Source><![CDATA[
    private str getConcatenationStringWithColon(str _stringFirst, str _stringSecond)
    {
        return strFmt('%1: %2', _stringFirst, _stringSecond);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedAdvancedLedgerEntry</Name>
				<Source><![CDATA[
    private void populateUnpostedAdvancedLedgerEntry(TransDate _periodStartDate)
    {
        AdvancedLedgerEntryHeader advancedLedgerEntryHeader;
        AdvancedLedgerEntryLine advancedLedgerEntryLine;
        FiscalCalendarPeriod fiscalCalendarPeriod;

        while select TransactionNumber, AccountingDate, TransactionText
            from advancedLedgerEntryHeader
                where advancedLedgerEntryHeader.TransactionStatus == AdvancedLedgerEntryTransactionStatus::Draft
                    && advancedLedgerEntryHeader.AccountingDate >= _periodStartDate
                    && advancedLedgerEntryHeader.AccountingDate <= reportParameters.parmToDate()
            join Type from fiscalCalendarPeriod
                where advancedLedgerEntryHeader.FiscalCalendarPeriod == fiscalCalendarPeriod.RecId
            join LedgerDimension, TransactionText, AmountCurDebit, AmountCurCredit, TransactionCurrency from advancedLedgerEntryLine
                where advancedLedgerEntryLine.AdvancedLedgerEntryHeader == advancedLedgerEntryHeader.RecId
        {
            if (!reportParameters.parmIncludeClosing()
                && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
            {
                continue;
            }

            this.initialDetailDataByTransactionDate(advancedLedgerEntryHeader.AccountingDate);

            if (advancedLedgerEntryHeader.AccountingDate >= reportParameters.parmFromDate())
            {
                transactionDetailTable.TransDate = advancedLedgerEntryHeader.AccountingDate;
                transactionDetailTable.TransactionType = fiscalCalendarPeriod.Type;
            }

            transactionDetailTable.LedgerDimension = advancedLedgerEntryLine.LedgerDimension;

            this.setAccountingAmountsFromLineTransactionAmounts(
                advancedLedgerEntryLine.AmountCurCredit,
                advancedLedgerEntryLine.AmountCurDebit,
                advancedLedgerEntryLine.TransactionCurrency,
                advancedLedgerEntryHeader.AccountingDate);

            this.setDocumentLineAndDescriptionForAdvancedLedgerEntry(advancedLedgerEntryHeader, advancedLedgerEntryLine);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedBudgetRegisterEntry</Name>
				<Source><![CDATA[
    private void populateUnpostedBudgetRegisterEntry(TransDate _periodStartDate)
    {
        BudgetTransactionHeader budgetTransactionHeader;
        BudgetTransactionLine budgetTransactionLine;

        while select budgetTransactionHeader
                where budgetTransactionHeader.Date >= _periodStartDate
                    && budgetTransactionHeader.Date <= reportParameters.parmToDate()
                    && budgetTransactionHeader.TransactionStatus == BudgetTransactionStatus::Draft
            join LedgerDimension, Comment, AccountingCurrencyAmount, TransactionCurrency from budgetTransactionLine
                where budgetTransactionLine.BudgetTransactionHeader == budgetTransactionHeader.RecId
        {
            this.addJournalizationDataForBudgetRegisterEntry(budgetTransactionHeader, budgetTransactionLine);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addJournalizationDataForBudgetRegisterEntry</Name>
				<Source><![CDATA[
    private void addJournalizationDataForBudgetRegisterEntry(BudgetTransactionHeader _budgetTransactionHeader, BudgetTransactionLine _budgetTransactionLine)
    {
        JournalizingDefinition journalizingDefinition;
        JournalizingDefinitionMatch journalizingDefinitionMatch;
        JournalizingDefinitionMatchDetail journalizingDefinitionMatchDetail;
        JournalizingDefinitionVersion journalizingDefinitionVersion;

        JournalizingDefinitionCode currentjournalizingDefinitionCode = this.getJournalizingDefinitionCode(_budgetTransactionHeader.RecId);
        DimensionAttributeValueCombination dimensionAttributeValueCombination = DimensionAttributeValueCombination::find(_budgetTransactionLine.LedgerDimension);

        while select RecId from journalizingDefinition
                where journalizingDefinition.JournalizingDefinitionCode == currentjournalizingDefinitionCode
            join RecId from journalizingDefinitionVersion
                where journalizingDefinitionVersion.JournalizingDefinition == journalizingDefinition.RecId
            join Recid from journalizingDefinitionMatch
                where journalizingDefinitionMatch.JournalizingDefinitionVersion == journalizingDefinitionVersion.RecId
                && journalizingDefinitionMatch.DimensionHierarchy == dimensionAttributeValueCombination.AccountStructure
            join JournalizingDefinitionSign, LedgerDimension from journalizingDefinitionMatchDetail
                where journalizingDefinitionMatchDetail.JournalizingDefinitionMatch == journalizingDefinitionMatch.RecId
        {
            this.initialDetailDataByTransactionDate(_budgetTransactionHeader.Date);

            transactionDetailTable.LedgerDimension = journalizingDefinitionMatchDetail.LedgerDimension;

            this.setDocumentLineAndDescriptionForBudgetRegisterEntry(_budgetTransactionHeader, _budgetTransactionLine);

            if (this.checkDebitCredit(_budgetTransactionLine.LedgerDimension) == DebitCredit::Debit)
            {
                if (journalizingDefinitionMatchDetail.JournalizingDefinitionSign == JournalizingDefinitionSignId::SameSign)
                {
                    transactionDetailTable.AmountDebit = _budgetTransactionLine.AccountingCurrencyAmount;
                }
                else
                {
                    transactionDetailTable.AmountCredit = _budgetTransactionLine.AccountingCurrencyAmount;
                }
            }
            else
            {
                if (journalizingDefinitionMatchDetail.JournalizingDefinitionSign == JournalizingDefinitionSignId::Balancing)
                {
                    transactionDetailTable.AmountDebit = _budgetTransactionLine.AccountingCurrencyAmount;
                }
                else
                {
                    transactionDetailTable.AmountCredit = _budgetTransactionLine.AccountingCurrencyAmount;
                }
            }

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedFreeTextInvoice</Name>
				<Source><![CDATA[
    private void populateUnpostedFreeTextInvoice(TransDate _periodStartDate)
    {
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        AccountingDistribution accountingDistribution;

        while select InvoiceTxt, BillingCode from custInvoiceLine
            join InvoiceAccount, InvoiceId, InvoiceDate from custInvoiceTable
                where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
                    && custInvoiceTable.InvoiceDate >= _periodStartDate
                    && custInvoiceTable.InvoiceDate <= reportParameters.parmToDate()
                    && custInvoiceTable.Posted == NoYes::No
            join LedgerDimension, TransactionCurrencyAmount, AccountingDate, TransactionCurrency from accountingDistribution
                where accountingDistribution.SourceDocumentLine == custInvoiceLine.SourceDocumentLine
        {
            this.initialDetailDataByTransactionDate(custInvoiceTable.InvoiceDate);

            this.setDocumentLineAndDescriptionForFreeTextInvoice(custInvoiceTable, custInvoiceLine);
            this.setDetailFromAccountingDistribution(accountingDistribution);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedPurchaseOrder</Name>
				<Source><![CDATA[
    private void populateUnpostedPurchaseOrder(TransDate _periodStartDate)
    {
        AccountingDistribution accountingDistribution;
        PurchTable purchTable;
        PurchLine purchLine;

        while select AccountingDate, DocumentState, PurchId from purchTable
            join purchLine
                where purchTable.PurchId == purchLine.PurchId
                    && (purchTable.DocumentState == VersioningDocumentState::Draft
                        || purchTable.DocumentState == VersioningDocumentState::Approved)
                    && purchTable.AccountingDate >= _periodStartDate
                    && purchTable.AccountingDate <= reportParameters.parmToDate()
            join LedgerDimension, TransactionCurrencyAmount, AccountingDate, TransactionCurrency from accountingDistribution
                where purchLine.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        {
            this.initialDetailDataByTransactionDate(purchTable.AccountingDate);
            this.setDocumentLineAndDescriptionForPurchaseOrder(purchTable, purchLine);
            this.setDetailFromAccountingDistribution(accountingDistribution);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDetailFromAccountingDistribution</Name>
				<Source><![CDATA[
    private void setDetailFromAccountingDistribution(AccountingDistribution _accountingDistribution)
    {
        transactionDetailTable.LedgerDimension = _accountingDistribution.LedgerDimension;

        AmountMST accountingAmount = this.getAccountingAmountFromTransactionCurrencyAmount(
            _accountingDistribution.TransactionCurrencyAmount,
            _accountingDistribution.TransactionCurrency,
            _accountingDistribution.AccountingDate);

        this.setDebitOrCreditAmount(
            accountingAmount,
            this.checkDebitCredit(_accountingDistribution.LedgerDimension) == DebitCredit::Debit,
            false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedProjectInvoice</Name>
				<Source><![CDATA[
    private void populateUnpostedProjectInvoice(TransDate _periodStartDate)
    {
        ProjProposalJour projProposalJour;

        while select InvoiceDate, DefaultDimension, ProposalId, InvoiceAccount, InvoiceAmount, CurrencyId from projProposalJour
            where projProposalJour.InvoiceDate >= _periodStartDate
                && projProposalJour.InvoiceDate <= reportParameters.parmToDate()
                && projProposalJour.LineProperty == ProjLinePropertyCode::Open
        {
            this.initialDetailDataByTransactionDate(projProposalJour.InvoiceDate);

            transactionDetailTable.Description = DimensionAttributeValueCombination::find(projProposalJour.DefaultDimension).DisplayValue;

            transactionDetailTable.LedgerDimension = projProposalJour.DefaultDimension;

            this.setDocumentLineAndDescriptionForProjectInvoice(projProposalJour);

            AmountMST accountingAmount = this.getAccountingAmountFromTransactionCurrencyAmount(
                projProposalJour.InvoiceAmount,
                projProposalJour.CurrencyId,
                projProposalJour.InvoiceDate);

            this.setDebitOrCreditAmount(
                accountingAmount,
                this.checkDebitCredit(projProposalJour.DefaultDimension) == DebitCredit::Debit,
                false);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedPurchaseRequisition</Name>
				<Source><![CDATA[
    private void populateUnpostedPurchaseRequisition(TransDate _periodStartDate)
    {
        AccountingDistribution accountingDistribution;
        PurchReqTable purchReqTable;
        PurchReqLine purchReqLine;

        while select TransDate, PurchReqId, PurchReqName from purchReqTable
            join ItemIdNonCatalog, ItemId, BuyingLegalEntity, InventDimId, ItemIdDataArea, LineNum from purchReqLine
                where purchReqLine.PurchReqTable == purchReqTable.RecId
                    && (purchReqTable.RequisitionStatus == PurchReqRequisitionStatus::Draft
                        || purchReqTable.RequisitionStatus == PurchReqRequisitionStatus::InReview)
                    && purchReqTable.TransDate >= _periodStartDate
                    && purchReqTable.TransDate <= reportParameters.parmToDate()
            join LedgerDimension, TransactionCurrencyAmount, AccountingDate, TransactionCurrency from accountingDistribution
                where purchReqLine.SourceDocumentLine == accountingDistribution.SourceDocumentLine
        {
            this.initialDetailDataByTransactionDate(purchReqTable.TransDate);

            this.setDocumentLineAndDescriptionForPurchaseRequisition(purchReqTable, purchReqLine);
            this.setDetailFromAccountingDistribution(accountingDistribution);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForPurchaseRequisition</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForPurchaseRequisition(PurchReqTable _purchReqTable, PurchReqLine _purchReqLine)
    {
        if (_purchReqTable && _purchReqLine)
        {
            transactionDetailTable.Document = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailPRPrefix",
                _purchReqTable.PurchReqId);

            transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailPRLinePrefix",
                int2str(real2int(_purchReqLine.LineNum)));

            transactionDetailTable.Description = _purchReqTable.PurchReqName;
            transactionDetailTable.DescriptionSupplement = _purchReqLine.itemName();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForPurchaseOrder</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForPurchaseOrder(PurchTable _purchTable, PurchLine _purchLine)
    {
        if (_purchTable && _purchLine)
        {
            transactionDetailTable.Document = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailPOPrefix",
                _purchTable.PurchId);

            transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailPOLinePrefix",
                int642str(_purchLine.LineNumber));

            transactionDetailTable.Description = _purchLine.Name;
            transactionDetailTable.DescriptionSupplement = EcoResCategory::find(_purchLine.ProcurementCategory).Name;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForFreeTextInvoice</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForFreeTextInvoice(CustInvoiceTable _custInvoiceTable, CustInvoiceLine _custInvoiceLine)
    {
        if (_custInvoiceLine)
        {
            CustTable custTable = CustTable::find(_custInvoiceTable.InvoiceAccount);

            transactionDetailTable.Description = custTable.name();
            transactionDetailTable.AccountNum = custTable.AccountNum;

            transactionDetailTable.DescriptionSupplement = _custInvoiceLine.InvoiceTxt;
            transactionDetailTable.Document = this.concatenateTwoStringWithSeparator(
                "@GeneralLedger:TrialBalanceDetailFTIPrefix",
                _custInvoiceTable.InvoiceId);

            if (_custInvoiceLine.BillingCode)
            {
                transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                    "@GeneralLedger:TrialBalanceDetailBillingCodePrefix",
                    _custInvoiceLine.BillingCode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForVendorInvoice</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForVendorInvoice(VendInvoiceInfoTable _vendInvoiceInfoTable, VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        if (_vendInvoiceInfoTable && _vendInvoiceInfoLine)
        {
            ItemFreeTxt vendorInvoiceLineName = _vendInvoiceInfoLine.VendDocumentLineMap::name();

            if (_vendInvoiceInfoLine.Description)
            {
                vendorInvoiceLineName = _vendInvoiceInfoLine.Description;
            }

            this.setAPInvoiceDescription(
                _vendInvoiceInfoTable.Num,
                _vendInvoiceInfoTable.PurchAgreementHeader_PSN,
                _vendInvoiceInfoTable.InvoiceAccount,
                _vendInvoiceInfoTable.DocumentDate,
                vendorInvoiceLineName,
                _vendInvoiceInfoTable.PurchId,
                _vendInvoiceInfoLine.BudgetReservationLine_PSN);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForAdvancedLedgerEntry</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForAdvancedLedgerEntry(AdvancedLedgerEntryHeader _advancedLedgerEntryHeader, AdvancedLedgerEntryLine _advancedLedgerEntryLine)
    {
        if (_advancedLedgerEntryLine && _advancedLedgerEntryHeader)
        {
            transactionDetailTable.Document = this.getConcatenationStringWithColon(
                "@GeneralLedger:TrialBalanceDetailALEPrefix",
                _advancedLedgerEntryHeader.TransactionNumber);
            transactionDetailTable.Description = _advancedLedgerEntryLine.TransactionText;
            transactionDetailTable.DescriptionSupplement = _advancedLedgerEntryHeader.TransactionText;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedVendorInvoice</Name>
				<Source><![CDATA[
    private void populateUnpostedVendorInvoice(TransDate _periodStartDate)
    {
        VendInvoiceInfoTable vendInvoiceInfoTable;
        VendInvoiceInfoLine vendInvoiceInfoLine;
        VendInvoiceJour vendInvoiceJour;
        AccountingDistribution accountingDistribution;
        SourceDocumentLine sourceDocumentLine;

        while select InvoiceAccount, TransDate, Num, DocumentDate, PurchAgreementHeader_PSN, PurchId
            from vendInvoiceInfoTable
                where vendInvoiceInfoTable.TransDate >= _periodStartDate
                    && vendInvoiceInfoTable.TransDate <= reportParameters.parmToDate()
            join * from vendInvoiceInfoLine
                where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId
                    && vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
            join LedgerDimension, TransactionCurrencyAmount, AccountingDate, TransactionCurrency from accountingDistribution
                exists join sourceDocumentLine
                    where sourceDocumentLine.RecId == accountingDistribution.SourceDocumentLine
                        && (sourceDocumentLine.ParentSourceDocumentLine == vendInvoiceInfoLine.SourceDocumentLine
                            || sourceDocumentLine.RecId == vendInvoiceInfoLine.SourceDocumentLine)
            notexists join vendInvoiceJour
                where vendInvoiceInfoTable.Num == vendInvoiceJour.InvoiceId
        {
            this.initialDetailDataByTransactionDate(vendInvoiceInfoTable.TransDate);

            this.setDocumentLineAndDescriptionForVendorInvoice(vendInvoiceInfoTable, vendInvoiceInfoLine);

            this.setDetailFromAccountingDistribution(accountingDistribution);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalizingDefinitionCode</Name>
				<Source><![CDATA[
    private JournalizingDefinitionCode getJournalizingDefinitionCode(RefRecId _budgetTransactionHeaderRecId)
    {
        JournalizingDefinitionCode journalizingDefinitionCode;
        JournalizingDefinitionManagerBudget journalizingDefinitionManagerBudget;
        BudgetTransactionHeader localBudgetTransactionHeader = BudgetTransactionHeader::find(_budgetTransactionHeaderRecId);

        if (localBudgetTransactionHeader.TransactionStatus != BudgetTransactionStatus::Completed)
        {
            journalizingDefinitionManagerBudget = JournalizingDefinitionManager::newJournalizingDefinitionManagerBudget(
                localBudgetTransactionHeader.BudgetTransactionCode,
                LedgerPostingType::Budget,
                DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

            journalizingDefinitionCode = JournalizingDefinition::findByRecId(journalizingDefinitionManagerBudget.getDefaultJournalizingDefinition()).JournalizingDefinitionCode;
        }

        return journalizingDefinitionCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDebitCredit</Name>
				<Source><![CDATA[
    private DebitCredit checkDebitCredit(LedgerDimensionAccount _ledgerDimension)
    {
        MainAccount mainAccount = MainAccount::findByLedgerDimension(_ledgerDimension);

        return mainAccount.Type == DimensionLedgerAccountType::Expense ?
            DebitCredit::Debit : DebitCredit::Credit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentLineAndDescriptionForProjectInvoice</Name>
				<Source><![CDATA[
    private void setDocumentLineAndDescriptionForProjectInvoice(ProjProposalJour _projProposalJour)
    {
        transactionDetailTable.AccountNum = _projProposalJour.InvoiceAccount;
        transactionDetailTable.Document = this.getConcatenationStringWithColon(
            "@GeneralLedger:TrialBalanceDetailProjectInvoicePrefix",
            _projProposalJour.ProjInvoiceId);

        PSAProjProposalProj pSAProjProposalProj;
        ProjFundingSource projFundingSource;
        ProjTable projTable;
        CustTable custTable;

        select firstonly FundingSource, ProjId
            from pSAProjProposalProj
                where pSAProjProposalProj.ProjProposalId == _projProposalJour.ProposalId
            outer join FundingSourceId from projFundingSource
                where projFundingSource.RecId == pSAProjProposalProj.FundingSource
            outer join Name from projTable
                where projTable.ProjId == pSAProjProposalProj.ProjId
            outer join Party, AccountNum from custTable
                where custTable.AccountNum == _projProposalJour.InvoiceAccount;

        if (pSAProjProposalProj)
        {
            if (projFundingSource)
            {
                transactionDetailTable.DocumentSubtitle = this.getConcatenationStringWithColon(
                    "@GeneralLedger:TrialBalanceDetailFundingSourcePrefix",
                    projFundingSource.FundingSourceId);
            }

            if (projTable)
            {
                transactionDetailTable.DescriptionSupplement = this.concatenateTwoStringWithSeparator(pSAProjProposalProj.ProjId, projTable.Name);
            }
        }

        if (custTable)
        {
            transactionDetailTable.AccountNum = custTable.AccountNum;
            transactionDetailTable.Description = this.concatenateTwoStringWithSeparator(_projProposalJour.InvoiceAccount, custTable.name());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDescriptionForCustomerOrVendor</Name>
				<Source><![CDATA[
    protected void setDescriptionForCustomerOrVendor(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.CustTransId)
        {
            this.setCustomerAccountNumber(_ledgerJournalTrans.CustTransId);
        }
        else if (_ledgerJournalTrans.VendTransId)
        {
            this.setVendorAccountNumber(_ledgerJournalTrans.VendTransId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildSegmentedAccountName</Name>
				<Source><![CDATA[
    private DimensionDisplayValue buildSegmentedAccountName(LedgerDimensionAccount _ledgerDimension)
    {
        DimensionDisplayValue accountName;

        if (_ledgerDimension)
        {
            str delimiter = DimensionParameters::getDimensionSegmentDelimiter();
            Set seenAttributes = new Set(Types::Int64);

            DimensionAttributeValue dimensionAttributeValue;
            DimensionAttributeLevelValue dimensionAttributeLevelValue;
            DimensionAttributeValueGroupCombination dimensionAttributeValueGroupCombination;

            while select dimensionAttributeValue
                    order by dimensionAttributeValueGroupCombination.Ordinal, dimensionAttributeLevelValue.Ordinal
                join Ordinal from dimensionAttributeLevelValue
                    where dimensionAttributeLevelValue.DimensionAttributeValue == dimensionAttributeValue.RecId
                join Ordinal from dimensionAttributeValueGroupCombination
                    where dimensionAttributeValueGroupCombination.DimensionAttributeValueGroup == dimensionAttributeLevelValue.DimensionAttributeValueGroup
                        && dimensionAttributeValueGroupCombination.DimensionAttributeValueCombination == _ledgerDimension
            {
                if (seenAttributes.add(dimensionAttributeValue.DimensionAttribute))
                {
                    accountName += (accountName == '') ? dimensionAttributeValue.getName() : delimiter + dimensionAttributeValue.getName();
                }
            }
        }

        return accountName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFiscalPeriodTypeByDate</Name>
				<Source><![CDATA[
    private FiscalPeriodType getFiscalPeriodTypeByDate(TransDate _transactionDate)
    {
        return _transactionDate < reportParameters.parmFromDate() ? FiscalPeriodType::Opening : FiscalPeriodType::Operating;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionTypeForOpeningData</Name>
				<Source><![CDATA[
    private void updateTransactionTypeForOpeningData()
    {
        date periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), reportParameters.parmFromDate());

        if (reportParameters.parmIncludeOpening()
            && periodStartDate == reportParameters.parmFromDate())
        {
            update_recordSet transactionDetailTable
                setting TransactionType = FiscalPeriodType::Operating
                where transactionDetailTable.TransactionType == FiscalPeriodType::Opening
                    && transactionDetailTable.TransDate == reportParameters.parmFromDate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpeningRowDataByFocusAccount</Name>
				<Source><![CDATA[
    private LedgerTrialBalanceDetailReportSummaryDataParameters getOpeningRowDataByFocusAccount(DimensionDisplayValueLTR _focusAccount, ledgerTrialBalanceTmp _ledgerTrialBalanceTmp)
    {
        LedgerTrialBalanceDetailReportSummaryDataParameters ledgerTrialBalanceDetailOpeningRow = LedgerTrialBalanceDetailReportSummaryDataParameters::construct();

        select firstonly _ledgerTrialBalanceTmp
            where _ledgerTrialBalanceTmp.PrimaryFocus == _focusAccount;

        if (_ledgerTrialBalanceTmp && (_ledgerTrialBalanceTmp.OpeningBalance || _ledgerTrialBalanceTmp.OpeningQuantityBalance))
        {
            ledgerTrialBalanceDetailOpeningRow.parmHasData(true);
            ledgerTrialBalanceDetailOpeningRow.parmRunningBalance(_ledgerTrialBalanceTmp.OpeningBalance);
            ledgerTrialBalanceDetailOpeningRow.parmDisplayValue(_ledgerTrialBalanceTmp.PrimaryFocus);
            ledgerTrialBalanceDetailOpeningRow.parmLedgerDescription(_ledgerTrialBalanceTmp.PrimaryFocusDescription);
            ledgerTrialBalanceDetailOpeningRow.parmRunningQuantityBalance(_ledgerTrialBalanceTmp.OpeningQuantityBalance);
        }

        select sum(AmountDebit), sum(AmountCredit), sum(Quantity), LedgerAccount, PrimaryFocusDescription
            from transactionDetailTable
                group by transactionDetailTable.LedgerAccount, transactionDetailTable.PrimaryFocusDescription
                where transactionDetailTable.LedgerAccount == _focusAccount
                    && transactionDetailTable.TransactionType == FiscalPeriodType::Opening;

        if (transactionDetailTable.AmountCredit || transactionDetailTable.AmountDebit || transactionDetailTable.Quantity)
        {
            AmountMST openingAmount = ledgerTrialBalanceDetailOpeningRow.parmRunningBalance() + transactionDetailTable.AmountDebit - transactionDetailTable.AmountCredit;
            Qty openingQuantity = ledgerTrialBalanceDetailOpeningRow.parmRunningQuantityBalance() + transactionDetailTable.Quantity;
            
            ledgerTrialBalanceDetailOpeningRow.parmHasData(true);
            ledgerTrialBalanceDetailOpeningRow.parmRunningBalance(openingAmount);
            ledgerTrialBalanceDetailOpeningRow.parmDisplayValue(transactionDetailTable.LedgerAccount);
            ledgerTrialBalanceDetailOpeningRow.parmLedgerDescription(transactionDetailTable.PrimaryFocusDescription);
            ledgerTrialBalanceDetailOpeningRow.parmRunningQuantityBalance(openingQuantity);
        }

        return ledgerTrialBalanceDetailOpeningRow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateSummaryRecordListByFocusAccount</Name>
				<Source><![CDATA[
    private LedgerTrialBalanceDetailReportSummaryDataParameters generateSummaryRecordListByFocusAccount(RecordInsertList _transactionsDetailTmpRecordInsertList, DimensionDisplayValueLTR _ledgerAccount, AmountMSTLong _openingAmount, Qty _openingQuantity)
    {
        LedgerTrialBalanceDetailReportSummaryDataParameters ledgerTrialBalanceDetailOperationRow = LedgerTrialBalanceDetailReportSummaryDataParameters::construct();
        AmountMSTLong balanceAmount = _openingAmount;
        Qty balanceQuantity = _openingQuantity;

        while select * from transactionDetailTable
            order by transactionDetailTable.TransDate, transactionDetailTable.Voucher
            join distinctAccount
            where transactionDetailTable.LedgerAccount == _ledgerAccount
                && transactionDetailTable.TransactionType == FiscalPeriodType::Operating
                && transactionDetailTable.LedgerDimension == distinctAccount.LedgerDimension
        {
            if (!ledgerTrialBalanceDetailOperationRow.parmHasData())
            {
                ledgerTrialBalanceDetailOperationRow.parmHasData(true);
                ledgerTrialBalanceDetailOperationRow.parmDisplayValue(transactionDetailTable.PrimaryFocus);
                ledgerTrialBalanceDetailOperationRow.parmLedgerDescription(transactionDetailTable.PrimaryFocusDescription);
                ledgerTrialBalanceDetailOperationRow.parmLedgerDimension(transactionDetailTable.LedgerDimension);
            }

            trialBalanceDetailTable.clear();
            trialBalanceDetailTable.Voucher = transactionDetailTable.Voucher;
            trialBalanceDetailTable.PostingLayer = transactionDetailTable.PostingLayer;
            trialBalanceDetailTable.AccountingDate = transactionDetailTable.TransDate;
            trialBalanceDetailTable.Document = this.concatenateWithSpace(transactionDetailTable.Document, transactionDetailTable.DocumentSubtitle, transactionDetailTable.DocumentComment);
            trialBalanceDetailTable.Description = this.concatenateWithSpace(transactionDetailTable.Description, transactionDetailTable.DescriptionSupplement, transactionDetailTable.DescriptionComment);
            trialBalanceDetailTable.CustomerVendorAccountId = transactionDetailTable.AccountNum;
            trialBalanceDetailTable.TransactionTypeInt = enum2int(transactionDetailTable.TransactionType);
            trialBalanceDetailTable.TransactionType = transactionDetailTable.TransactionType;
            trialBalanceDetailTable.LedgerDimension = transactionDetailTable.LedgerDimension;
            trialBalanceDetailTable.PrimaryFocus = transactionDetailTable.PrimaryFocus;
            trialBalanceDetailTable.PrimaryFocusDescription = transactionDetailTable.PrimaryFocusDescription;
            trialBalanceDetailTable.AccountName = transactionDetailTable.LedgerDescription;
            trialBalanceDetailTable.AmountCredit = transactionDetailTable.AmountCredit;
            trialBalanceDetailTable.AmountDebit = transactionDetailTable.AmountDebit;
            trialBalanceDetailTable.Quantity = transactionDetailTable.Quantity;

            balanceAmount += transactionDetailTable.AmountDebit - transactionDetailTable.AmountCredit;
            balanceQuantity += transactionDetailTable.Quantity;

            trialBalanceDetailTable.ClosingBalance = balanceAmount;
            trialBalanceDetailTable.Accumulated = (transactionDetailTable.TransactionType == FiscalPeriodType::Operating) ? trialBalanceDetailTable.ClosingBalance : 0;

            trialBalanceDetailTable.LedgerDimensionName = distinctAccount.FullAccountName;
            trialBalanceDetailTable.LedgerDimensionValue = distinctAccount.FocusAccountName;

            _transactionsDetailTmpRecordInsertList.add(trialBalanceDetailTable);
        }

        ledgerTrialBalanceDetailOperationRow.parmRunningBalance(balanceAmount);
        ledgerTrialBalanceDetailOperationRow.parmRunningQuantityBalance(balanceQuantity);

        return ledgerTrialBalanceDetailOperationRow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedLedgerJournalData</Name>
				<Source><![CDATA[
    private void populateUnpostedLedgerJournalData(TransDate _periodStartDate)
    {
        this.populateUnpostedLedgerJournalOpeningData(_periodStartDate);

        this.populateUnpostedLedgerJournalTransactionData(_periodStartDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedLedgerJournalOpeningData</Name>
				<Source><![CDATA[
    private void populateUnpostedLedgerJournalOpeningData(TransDate _periodStartDate)
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;

        while select JournalNum, Name
            from ledgerJournalTable
                where ledgerJournalTable.Posted == NoYes::No
            join TransDate, LedgerDimension, Txt, AmountCurDebit, AmountCurCredit, OffsetLedgerDimension, CurrencyCode, Voucher,
                RecId, AccountType, DefaultDimension, Company, PostingProfile, OffsetDefaultDimension, OffsetAccountType, OffsetCompany
            from ledgerJournalTrans
                where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
                    && ledgerJournalTrans.TransDate >= _periodStartDate
                    && ledgerJournalTrans.TransDate < reportParameters.parmFromDate()
                    && (ledgerJournalTrans.TransactionType == LedgerTransType::GeneralJournal
                        || ledgerJournalTrans.TransactionType == LedgerTransType::None)
        {
            this.initialDetailDataByTransactionDate(ledgerJournalTrans.TransDate);

            this.setDetailDataByLedgerJournalTransaction(ledgerJournalTrans);

            this.setDetailDataByLedgerJournalTable(ledgerJournalTable);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);

            this.addOffsetAccountTransaction(ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateUnpostedLedgerJournalTransactionData</Name>
				<Source><![CDATA[
    private void populateUnpostedLedgerJournalTransactionData(TransDate _periodStartDate)
    {
        if (FeatureStateProvider::isFeatureEnabled(LedgerTransactionReportAvoidDupUnpostedTransFlight::instance()))
        {
            TransDate toDate = reportParameters.parmFromDate();

            if (LedgerTransactionReportCorrectDateSetInUnpostedFlight::instance().isEnabled())
            {
                // Correct toDate as a prior date of FromDate in parameter in order to avoid a duplicate date in running queries. 
                toDate = toDate - 1;
            }

            // populate unposted transactions of which type are not general journal nor none from fiscal calendar start date.
            this.addUnpostedLedgerJournalTransactionData(_periodStartDate, toDate, true);

            // populate unposted transactions for all types for a period of parameter.
            this.addUnpostedLedgerJournalTransactionData(reportParameters.parmFromDate(), reportParameters.parmToDate(), false);
        }
        else
        {
            LedgerJournalTable ledgerJournalTable;
            LedgerJournalTrans ledgerJournalTrans;
            LedgerJournalTrans interCompanyLedgerJournalTrans;

            while select TransDate, LedgerDimension, Txt, AmountCurDebit, AmountCurCredit, PaymReference, CustTransId, VendTransId, CurrencyCode, Voucher,
                RecId, AccountType, DefaultDimension, Company, PostingProfile, OffsetDefaultDimension, OffsetLedgerDimension, OffsetAccountType, OffsetCompany
            from ledgerJournalTrans
            join JournalNum, Name from ledgerJournalTable
                where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
                    && ledgerJournalTable.Posted == NoYes::No
                    && ledgerJournalTrans.TransDate >= _periodStartDate
                    && ledgerJournalTrans.TransDate <= reportParameters.parmToDate()
                    && ((reportParameters.parmIncludePendingCustPay() && ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
                            || (reportParameters.parmIncludePendingPayment() && ledgerJournalTable.JournalType == LedgerJournalType::Payment)
                            || (reportParameters.parmIncludePendingDaily() && ledgerJournalTable.JournalType == LedgerJournalType::Daily)
                            || (reportParameters.parmIncludePendingAllocation() && ledgerJournalTable.JournalType == LedgerJournalType::Allocation)
                            || (reportParameters.parmIncludePendingBudget() && ledgerJournalTable.JournalType == LedgerJournalType::Budget)
                            || (reportParameters.parmIncludePendingVendorInvoice() && ledgerJournalTable.JournalType == LedgerJournalType::VendInvoice)
                            // parmIncludePendingVendorInvoiceJournal and parmIncludePendingVendorInvoiceRegister method name is based on the label of ledger journal type,
                            // Label of LedgerJournalType::VendInvoiceRegister: Vendor invoice recording
                            // Label of LedgerJournalType::PurchaseLedger: Invoice register
                            || (reportParameters.parmIncludePendingVendorInvoiceJournal() && ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister)
                            || (reportParameters.parmIncludePendingVendorInvoiceRegister() && ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger))
            notexists join interCompanyLedgerJournalTrans
                where ledgerJournalTrans.Voucher == interCompanyLedgerJournalTrans.Voucher
                    && (interCompanyLedgerJournalTrans.Company != curExt() || interCompanyLedgerJournalTrans.OffsetCompany != curExt())
                    && interCompanyLedgerJournalTrans.Company != interCompanyLedgerJournalTrans.OffsetCompany
            {
                this.initialDetailDataByTransactionDate(ledgerJournalTrans.TransDate);

                this.setDetailDataByLedgerJournalTransaction(ledgerJournalTrans);

                this.setDetailDataByLedgerJournalTable(ledgerJournalTable);

                transactionsDetailTmpRecordInsertList.add(transactionDetailTable);

                this.addOffsetAccountTransaction(ledgerJournalTrans);
            }
        }

        transactionsDetailTmpRecordInsertList.insertDatabase();

        this.updateLedgerDetailForLedgerJournalTransaction();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addUnpostedLedgerJournalTransactionData</Name>
				<Source><![CDATA[
    private void addUnpostedLedgerJournalTransactionData(TransDate _fromDate, TransDate _toDate, boolean _isCheckTransType)
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTrans interCompanyLedgerJournalTrans;

        while select TransDate, LedgerDimension, Txt, AmountCurDebit, AmountCurCredit, PaymReference, CustTransId, VendTransId, CurrencyCode, Voucher,
                RecId, AccountType, DefaultDimension, Company, PostingProfile, OffsetDefaultDimension, OffsetLedgerDimension, OffsetAccountType, OffsetCompany
            from ledgerJournalTrans
            join JournalNum, Name from ledgerJournalTable
                where ledgerJournalTable.JournalNum == ledgerJournalTrans.JournalNum
                    && ledgerJournalTable.Posted == NoYes::No
                    && ledgerJournalTrans.TransDate >= _fromDate
                    && ledgerJournalTrans.TransDate <= _toDate
                    // Checking TransactionType, used in populateUnpostedLedgerJournalOpeningData(), in order to avoid duplicate insertion.
                    && (!_isCheckTransType || (ledgerJournalTrans.TransactionType != LedgerTransType::GeneralJournal && ledgerJournalTrans.TransactionType != LedgerTransType::None))
                    && ((reportParameters.parmIncludePendingCustPay() && ledgerJournalTable.JournalType == LedgerJournalType::CustPayment)
                            || (reportParameters.parmIncludePendingPayment() && ledgerJournalTable.JournalType == LedgerJournalType::Payment)
                            || (reportParameters.parmIncludePendingDaily() && ledgerJournalTable.JournalType == LedgerJournalType::Daily)
                            || (reportParameters.parmIncludePendingAllocation() && ledgerJournalTable.JournalType == LedgerJournalType::Allocation)
                            || (reportParameters.parmIncludePendingBudget() && ledgerJournalTable.JournalType == LedgerJournalType::Budget)
                            || (reportParameters.parmIncludePendingVendorInvoice() && ledgerJournalTable.JournalType == LedgerJournalType::VendInvoice)
                            // parmIncludePendingVendorInvoiceJournal and parmIncludePendingVendorInvoiceRegister method name is based on the label of ledger journal type,
                            // Label of LedgerJournalType::VendInvoiceRegister: Vendor invoice recording
                            // Label of LedgerJournalType::PurchaseLedger: Invoice register
                            || (reportParameters.parmIncludePendingVendorInvoiceJournal() && ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister)
                            || (reportParameters.parmIncludePendingVendorInvoiceRegister() && ledgerJournalTable.JournalType == LedgerJournalType::PurchaseLedger))
            notexists join interCompanyLedgerJournalTrans
                where ledgerJournalTrans.Voucher == interCompanyLedgerJournalTrans.Voucher
                    && (interCompanyLedgerJournalTrans.Company != curExt() || interCompanyLedgerJournalTrans.OffsetCompany != curExt())
                    && interCompanyLedgerJournalTrans.Company != interCompanyLedgerJournalTrans.OffsetCompany
        {
            this.initialDetailDataByTransactionDate(ledgerJournalTrans.TransDate);

            this.setDetailDataByLedgerJournalTransaction(ledgerJournalTrans);

            this.setDetailDataByLedgerJournalTable(ledgerJournalTable);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);

            this.addOffsetAccountTransaction(ledgerJournalTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountingAmountsFromLineTransactionAmounts</Name>
				<Source><![CDATA[
    private void setAccountingAmountsFromLineTransactionAmounts(
        AmountCur _creditAmountCur,
        AmountCur _debitAmountCur,
        CurrencyCode _currency,
        TransDate _transactionDate)
    {
        transactionDetailTable.AmountCredit = this.getAccountingAmountFromTransactionCurrencyAmount(
            _creditAmountCur,
            _currency,
            _transactionDate);

        transactionDetailTable.AmountDebit = this.getAccountingAmountFromTransactionCurrencyAmount(
            _debitAmountCur,
            _currency,
            _transactionDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateDetailSummaryBalanceRecords</Name>
				<Source><![CDATA[
    private void generateDetailSummaryBalanceRecords(str _mainAccountFilterValues = '')
    {
        RecordInsertList tempDetailSummaryRecordList = this.initializeSummaryRecordInsertList(trialBalanceDetailTable);
        LedgerTrialBalanceTmp ledgerTrialBalanceTmp = this.generateTrialBalanceAccumulatedAmountData(_mainAccountFilterValues);
        LedgerTransactionsDetailTmp tmpDistinctAccountLocal;

        tmpDistinctAccountLocal.linkPhysicalTableInstance(transactionDetailTable);

        while select LedgerAccount from tmpDistinctAccountLocal
            group by tmpDistinctAccountLocal.LedgerAccount
        {
            LedgerTrialBalanceDetailReportSummaryDataParameters ledgerTrialBalanceDetailOpeningRow = this.getOpeningRowDataByFocusAccount(
                tmpDistinctAccountLocal.LedgerAccount,
                ledgerTrialBalanceTmp);

            LedgerTrialBalanceDetailReportSummaryDataParameters ledgerTrialBalanceDetailOperationRow = this.generateSummaryRecordListByFocusAccount(
                tempDetailSummaryRecordList,
                tmpDistinctAccountLocal.LedgerAccount,
                ledgerTrialBalanceDetailOpeningRow.parmRunningBalance(),
                ledgerTrialBalanceDetailOpeningRow.parmRunningQuantityBalance());

            DimensionDisplayValue displayValue = ledgerTrialBalanceDetailOpeningRow.parmDisplayValue();
            Description1000 ledgerDescription = ledgerTrialBalanceDetailOpeningRow.parmLedgerDescription();
            LedgerDimensionAccount ledgerDimension;

            if (ledgerTrialBalanceDetailOperationRow.parmHasData())
            {
                displayValue = ledgerTrialBalanceDetailOperationRow.parmDisplayValue();
                ledgerDescription = ledgerTrialBalanceDetailOperationRow.parmLedgerDescription();
                ledgerDimension = ledgerTrialBalanceDetailOperationRow.parmLedgerDimension();
            }

            // insert open and close record row
            if (this.showOpeningGroupRowTransaction(ledgerTrialBalanceDetailOpeningRow.parmHasData(), ledgerTrialBalanceDetailOperationRow.parmHasData()))
            {
                this.createOpenCloseSummaryRecordList(
                    tempDetailSummaryRecordList,
                    displayValue,
                    ledgerDescription,
                    ledgerDimension,
                    ledgerTrialBalanceDetailOpeningRow.parmRunningBalance(),
                    ledgerTrialBalanceDetailOperationRow.parmRunningBalance(),
                    ledgerTrialBalanceDetailOpeningRow.parmRunningQuantityBalance(),
                    ledgerTrialBalanceDetailOperationRow.parmRunningQuantityBalance());
            }
        }

        tempDetailSummaryRecordList.insertdatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTrialBalanceAccumulatedAmountData</Name>
				<Source><![CDATA[
    private ledgerTrialBalanceTmp generateTrialBalanceAccumulatedAmountData(str _mainAccountFilterValues = '')
    {
        LedgerTrialBalanceTmp ledgerTrialBalanceTmp;

        if (reportParameters.parmShowTransactions() == LedgerTrialBalanceShowTransactionStates::All
            || reportParameters.parmShowTransactions() == LedgerTrialBalanceShowTransactionStates::Posted)
        {
            List postingLayers = con2List([reportParameters.parmPostingLayer()]);

            LedgerTrialBalanceTmp::calculateBalances_V2(
                ledgerTrialBalanceTmp,
                reportParameters.parmPrimaryDimensionFocus(),
                reportParameters.parmFromDate(),
                reportParameters.parmToDate(),
                reportParameters.parmIncludeOpening(),
                reportParameters.parmIncludeOpening(),
                reportParameters.parmIncludeClosing(),
                postingLayers,
                true,
                false,
                Ledger::current());
        }

        this.copyAccumulatedOpeningAccounts(ledgerTrialBalanceTmp, _mainAccountFilterValues);

        return ledgerTrialBalanceTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showOpeningGroupRowTransaction</Name>
				<Source><![CDATA[
    private boolean showOpeningGroupRowTransaction(boolean _hasOpeningTransaction, boolean _hasOperationTransaction)
    {
        boolean showOpeningGroupRow;

        if (reportParameters.parmShowTransactions() == LedgerTrialBalanceShowTransactionStates::Unposted)
        {
            showOpeningGroupRow = _hasOperationTransaction;
        }
        else
        {
            showOpeningGroupRow = _hasOpeningTransaction || _hasOperationTransaction;
        }

        return showOpeningGroupRow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyAccumulatedOpeningAccounts</Name>
				<Source><![CDATA[
    private void copyAccumulatedOpeningAccounts(LedgerTrialBalanceTmp _ledgerTrialBalanceTmp, str _mainAccountFilterValues = '')
    {
        if (_mainAccountFilterValues)
        {
            if (FeatureStateProvider::isFeatureEnabled(GeneralLedgerBalanceFeature::instance()))
            {
                DimensionHierarchy dimHierarchy = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, reportParameters.parmPrimaryDimensionFocus());
                Level level = GeneralLedgerBalanceReportingDimensionDataSource::getLevelFromDimensionHierarchyLevel(dimHierarchy, DimensionAttributeType::MainAccount);

                if (level > 0)
                {
                    this.insertLedgerAccountIntoTransactionDetailByLevel(_ledgerTrialBalanceTmp, _mainAccountFilterValues, level);
                }
            }
            else
            {
                this.insertLedgerAccountIntoTransactionDetail(_ledgerTrialBalanceTmp, _mainAccountFilterValues);
            }
        }
        else
        {
            insert_recordset transactionDetailTable(LedgerAccount)
                select
                    PrimaryFocus
                from _ledgerTrialBalanceTmp
                group by _ledgerTrialBalanceTmp.PrimaryFocus;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerAccountIntoTransactionDetailByLevel</Name>
				<Source><![CDATA[
    private void insertLedgerAccountIntoTransactionDetailByLevel(
        LedgerTrialBalanceTmp _ledgerTrialBalanceTmp, str _mainAccountFilterValues, Level _level)
    {
        MainAccount mainAccount;
        ListEnumerator listOfMainAccountIds = strSplit(_mainAccountFilterValues, ',').getEnumerator();

        while (listOfMainAccountIds.moveNext())
        {
            select firstonly PrimaryFocus from _ledgerTrialBalanceTmp
                where _ledgerTrialBalanceTmp.DimensionValues[_level] ==  listOfMainAccountIds.current()
                exists join mainAccount
                    where mainAccount.MainAccountId == _ledgerTrialBalanceTmp.DimensionValues[_level]
                        && mainAccount.LedgerChartOfAccounts == LedgerChartOfAccounts::current();

            this.insertTransactionDetailTable(_ledgerTrialBalanceTmp.PrimaryFocus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertLedgerAccountIntoTransactionDetail</Name>
				<Source><![CDATA[
    private void insertLedgerAccountIntoTransactionDetail(LedgerTrialBalanceTmp _ledgerTrialBalanceTmp, str _mainAccountFilterValues)
    {
        MainAccount mainAccount;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        ListEnumerator listOfMainAccountIds = strSplit(_mainAccountFilterValues, ',').getEnumerator();

        while (listOfMainAccountIds.moveNext())
        {
            select firstonly _ledgerTrialBalanceTmp
                exists join dimensionAttributeValueCombination
                    where dimensionAttributeValueCombination.RecId == _ledgerTrialBalanceTmp.LedgerDimension
                exists join mainAccount
                    where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount
                        && MainAccount.MainAccountId == listOfMainAccountIds.current();

            this.insertTransactionDetailTable(_ledgerTrialBalanceTmp.PrimaryFocus);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTransactionDetailTable</Name>
				<Source><![CDATA[
    private void insertTransactionDetailTable(DimensionDisplayValueLTR _ledgerAccount)
    {
        transactionDetailTable.LedgerAccount = _ledgerAccount;
        transactionDetailTable.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingAmountFromTransactionCurrencyAmount</Name>
				<Source><![CDATA[
    private AmountMST getAccountingAmountFromTransactionCurrencyAmount(
        AmountCur _amountCur,
        CurrencyCode _currency,
        TransDate _transactionDate)
    {
        AmountMST accountingAmount;

        if (_currency == Ledger::accountingCurrency() || !_amountCur)
        {
            accountingAmount = _amountCur;
        }
        else
        {
            if (currencyExchangeHelper == null)
            {
                currencyExchangeHelper = CurrencyExchangeHelper::newLedger(Ledger::current());
            }

            currencyExchangeHelper.parmExchangeDate(_transactionDate);

            accountingAmount = currencyExchangeHelper.calculateTransactionToAccounting(
                _currency,
                _amountCur,
                true);
        }

        return accountingAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateLedgerAccountNameAndPrimaryFocusName</Name>
				<Source><![CDATA[
    private void generateLedgerAccountNameAndPrimaryFocusName()
    {
        delete_from distinctAccount;

        insert_recordset distinctAccount (LedgerDimension)
            select LedgerDimension from transactionDetailTable
                group by transactionDetailTable.LedgerDimension;

        this.updateDistinctLedgerAccountFullAccountNames();

        this.updatePrimaryFocusNameAndDescription();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDistinctLedgerAccountFullAccountNames</Name>
				<Source><![CDATA[
    private void updateDistinctLedgerAccountFullAccountNames()
    {
        DimensionAttributeValue dimensionAttributeValue;
        DimensionAttributeLevelValue dimensionAttributeLevelValue;
        DimensionAttributeValueGroupCombination dimensionAttributeValueGroupCombination;
        RefRecId currentLedgerAccount;
        DimensionDisplayValue accountName;
        str delimiter = DimensionParameters::getDimensionSegmentDelimiter();

        while select distinctAccount
            join dimensionAttributeValue
                order by distinctAccount.LedgerDimension, dimensionAttributeValueGroupCombination.Ordinal, dimensionAttributeLevelValue.Ordinal
            join Ordinal from dimensionAttributeLevelValue
                where dimensionAttributeLevelValue.DimensionAttributeValue == dimensionAttributeValue.RecId
            join Ordinal from dimensionAttributeValueGroupCombination
                where dimensionAttributeValueGroupCombination.DimensionAttributeValueGroup == dimensionAttributeLevelValue.DimensionAttributeValueGroup
                    && dimensionAttributeValueGroupCombination.DimensionAttributeValueCombination == distinctAccount.ledgerDimension
        {
            if (currentLedgerAccount != distinctAccount.LedgerDimension)
            {
                this.updateFullAccountNameByLedgerAccountAndName(currentLedgerAccount, accountName);

                currentLedgerAccount = distinctAccount.LedgerDimension;
                accountName = dimensionAttributeValue.getName();
            }
            else
            {
                accountName += (accountName == '') ? dimensionAttributeValue.getName() : delimiter + dimensionAttributeValue.getName();
            }
        }

        this.updateFullAccountNameByLedgerAccountAndName(currentLedgerAccount, accountName);

        DimensionAttributeValueCombination dimensionAttributeValueCombination;

        update_recordset distinctAccount
            setting FocusAccountName = dimensionAttributeValueCombination.DisplayValue
            join DisplayValue from dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == distinctAccount.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFullAccountNameByLedgerAccountAndName</Name>
				<Source><![CDATA[
    private void updateFullAccountNameByLedgerAccountAndName(RefRecId _ledgerAccount, DimensionDisplayValue _fullAccountName)
    {
        if (_ledgerAccount && _fullAccountName)
        {
            LedgerDistinctAccountTmp distinctAccountLocal;
            distinctAccountLocal.linkPhysicalTableInstance(distinctAccount);

            update_recordset distinctAccountLocal
                setting FullAccountName = _fullAccountName
                where distinctAccountLocal.LedgerDimension == _ledgerAccount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionFocusNameTmp</Name>
				<Source><![CDATA[
    private DimensionFocusNameTmp getDimensionFocusNameTmp(Connection _userConnection)
    {
        LedgerDistinctAccountTmp querySource;
        querySource.linkPhysicalTableInstance(distinctAccount);

        DimensionFocusNameTmp dimensionNameTmp;
        dimensionNameTmp.setConnection(_userConnection);
        querySource.setConnection(_userConnection);

        Query focusNameQuery = new Query();
        SysQuery::findOrCreateDataSource(focusNameQuery, tableNum(LedgerDistinctAccountTmp));

        // Add a link to DimensionAttributeValueCombination, which is required to populate the dimension values
        QueryBuildDataSource dimensionAttributeValueCombinationDataSource = SysQuery::findOrCreateDataSource(focusNameQuery, tableNum(DimensionAttributeValueCombination), tableNum(LedgerDistinctAccountTmp));
        dimensionAttributeValueCombinationDataSource.addLink(fieldNum(LedgerDistinctAccountTmp, LedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));

        QueryRun focusNameQueryRun = new QueryRun(focusNameQuery);
        focusNameQueryRun.setRecord(querySource);
        focusNameQuery = focusNameQueryRun.query();

        DimensionFocusNameTmp::generateFocusNames(
            dimensionNameTmp,
            focusNameQuery,
            reportParameters.parmPrimaryDimensionFocus(),
            _userConnection);

        return dimensionNameTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrimaryFocusNameAndDescription</Name>
				<Source><![CDATA[
    private void updatePrimaryFocusNameAndDescription()
    {
        Connection userConnection = new Connection();
        boolean isReportDataFlightEnabled = FeatureStateProvider::isFeatureEnabled(LedgerTrialBalanceDetailReportBufferOverflowFlight::instance());

        // PrimaryFocus
        DimensionFocusNameTmp dimensionFocusNameTmp = this.getDimensionFocusNameTmp(userConnection);

        if (isReportDataFlightEnabled)
        {
            transactionDetailTable.skipDataMethods(true);
            transactionDetailTable.skipEvents(true);
        }

        update_recordset transactionDetailTable
            setting PrimaryFocus = dimensionFocusNameTmp.FocusValue,
                LedgerAccount = dimensionFocusNameTmp.FocusValue
            join dimensionFocusNameTmp
                where transactionDetailTable.LedgerDimension == dimensionFocusNameTmp.LedgerDimension;

        // PrimaryFocusDescription
        if (isReportDataFlightEnabled)
        {
            // Reusing dimensionFocusNameTmp in DimensionFocusNameTmp::generateFocusDescriptions with large data volume might cause buffer overflow
            // Hence, declare new DimensionFocusNameTmp variable for DimensionFocusNameTmp::generateFocusDescriptions
            DimensionFocusNameTmp dimensionFocusNameTmpDescription;
            LedgerTransactionsDetailTmp ledgerTransDetailTmp;

            dimensionFocusNameTmpDescription.setConnection(userConnection);

            insert_recordset dimensionFocusNameTmpDescription (LedgerDimension)
            select LedgerDimension from ledgerTransDetailTmp
                group by ledgerTransDetailTmp.LedgerDimension;

            DimensionFocusNameTmp::generateFocusDescriptions(
                dimensionFocusNameTmpDescription,
                reportParameters.parmPrimaryDimensionFocus(),
                userConnection);

            update_recordset transactionDetailTable
                setting PrimaryFocusDescription = dimensionFocusNameTmpDescription.FocusValue
                join dimensionFocusNameTmpDescription
                    where transactionDetailTable.LedgerDimension == dimensionFocusNameTmpDescription.LedgerDimension;

            transactionDetailTable.skipDataMethods(false);
            transactionDetailTable.skipEvents(false);
        }
        else
        {
            DimensionFocusNameTmp::generateFocusDescriptions(
                dimensionFocusNameTmp,
                reportParameters.parmPrimaryDimensionFocus(),
                userConnection);

            update_recordset transactionDetailTable
                setting PrimaryFocusDescription = dimensionFocusNameTmp.FocusValue
                join dimensionFocusNameTmp
                    where transactionDetailTable.LedgerDimension == dimensionFocusNameTmp.LedgerDimension;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerDetailForLedgerJournalTransaction</Name>
				<Source><![CDATA[
    private void updateLedgerDetailForLedgerJournalTransaction()
    {
        this.updateAccountNum();
        this.updateCustomerAccountCurrentCompany();
        this.updateVendorAccountCurrentCompany();
        this.updateBankAccountCurrentCompany();
        this.updateProjectAccounts();
        this.updateFixedAssetsAccounts();
        this.updateLedgerDimensionFromPostingProfile();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccountNum</Name>
				<Source><![CDATA[
    private void updateAccountNum()
    {
        DimensionAttributeValueCombination dimensionAttributeValueCombination;
        MainAccount mainAccount;

        update_recordSet transactionDetailTable
            setting AccountNum = dimensionAttributeValueCombination.DisplayValue,
                Description = mainAccount.Name
            join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == transactionDetailTable.LedgerDimension
                    && transactionDetailTable.Voucher == NoVoucher
            join mainAccount
                where mainAccount.RecId == dimensionAttributeValueCombination.MainAccount;

        LanguageId currentLanguage = DimensionCache::currentDimensionValueLanguageId();

        if (currentLanguage != '')
        {
            MainAccountTranslation mainAccountTranslation;

            update_recordSet transactionDetailTable
                setting Description = mainAccountTranslation.Name
                join dimensionAttributeValueCombination
                    where dimensionAttributeValueCombination.RecId == transactionDetailTable.LedgerDimension
                join mainAccountTranslation
                    where dimensionAttributeValueCombination.MainAccount == mainAccountTranslation.MainAccount
                        && mainAccountTranslation.LanguageId == currentLanguage;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDetailDataByLedgerJournalTable</Name>
				<Source><![CDATA[
    private void setDetailDataByLedgerJournalTable(LedgerJournalTable _ledgerJournalTable)
    {
        transactionDetailTable.Document = _ledgerJournalTable.JournalNum;
        transactionDetailTable.DescriptionSupplement = _ledgerJournalTable.Name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addOffsetAccountTransaction</Name>
				<Source><![CDATA[
    private void addOffsetAccountTransaction(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (_ledgerJournalTrans.OffsetLedgerDimension)
        {
            transactionDetailTable.LedgerDimension = _ledgerJournalTrans.OffsetLedgerDimension;
            transactionDetailTable.AccountOffsetaccount = AccountOffsetaccount::OffsetAccount;
            transactionDetailTable.AccountType = _ledgerJournalTrans.OffsetAccountType;
            transactionDetailTable.Company = _ledgerJournalTrans.OffsetCompany ? _ledgerJournalTrans.OffsetCompany : _ledgerJournalTrans.Company;

            this.setAccountingAmountsFromLineTransactionAmounts(
                _ledgerJournalTrans.AmountCurDebit,
                _ledgerJournalTrans.AmountCurCredit,
                _ledgerJournalTrans.CurrencyCode,
                _ledgerJournalTrans.TransDate);

            transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDetailDataByLedgerJournalTransaction</Name>
				<Source><![CDATA[
    private void setDetailDataByLedgerJournalTransaction(LedgerJournalTrans _ledgerJournalTrans)
    {
        transactionDetailTable.LedgerJournalTransactionRecId = _ledgerJournalTrans.RecId;
        transactionDetailTable.AccountType = _ledgerJournalTrans.AccountType;
        transactionDetailTable.Company = _ledgerJournalTrans.Company;
        transactionDetailTable.PostingProfile = _ledgerJournalTrans.PostingProfile;
        transactionDetailTable.DefaultDimension = _ledgerJournalTrans.DefaultDimension;
        transactionDetailTable.AccountOffsetaccount = AccountOffsetaccount::Account;

        transactionDetailTable.LedgerDimension = _ledgerJournalTrans.LedgerDimension;
        transactionDetailTable.DocumentSubtitle = _ledgerJournalTrans.PaymReference;
        transactionDetailTable.Description = this.concatenateTwoStringWithSeparator(_ledgerJournalTrans.Voucher, _ledgerJournalTrans.Txt);

        this.setAccountingAmountsFromLineTransactionAmounts(
            _ledgerJournalTrans.AmountCurCredit,
            _ledgerJournalTrans.AmountCurDebit,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.TransDate);

        this.setDescriptionForCustomerOrVendor(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialDetailDataByTransactionDate</Name>
				<Source><![CDATA[
    private void initialDetailDataByTransactionDate(TransDate _transactionDate)
    {
        transactionDetailTable.clear();
        transactionDetailTable.Voucher = NoVoucher;
        transactionDetailTable.TransDate = _transactionDate;
        transactionDetailTable.TransactionType = this.getFiscalPeriodTypeByDate(_transactionDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomerAccountNumber</Name>
				<Source><![CDATA[
    private void setCustomerAccountNumber(CustTransRefRecId _custTransRefRecId)
    {
        CustTable custTable;
        CustTrans custTrans;

        select firstonly AccountNum, Party from custTable
            exists join custTrans
                where custTrans.RecId == _custTransRefRecId
                    && custTrans.AccountNum == custTable.AccountNum;

        transactionDetailTable.Description = custTable.name();
        transactionDetailTable.AccountNum = custTable.AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVendorAccountNumber</Name>
				<Source><![CDATA[
    private void setVendorAccountNumber(VendTransRefRecId _vendTransRefRecId)
    {
        VendTable vendTable;
        VendTrans vendTrans;

        select firstonly AccountNum, Party from vendTable
            exists join vendTrans
                where vendTrans.RecId == _vendTransRefRecId
                    && vendTrans.AccountNum == vendTable.AccountNum;

        transactionDetailTable.Description = vendTable.name();
        transactionDetailTable.AccountNum = vendTable.AccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAccountNumAndDocumentForMultiple</Name>
				<Source><![CDATA[
    private void setAccountNumAndDocumentForMultiple(LedgerJournalACType _journalType)
    {
        transactionDetailTable.AccountNum = MultipleDocumentSymbol;
        transactionDetailTable.Document = this.getConcatenationStringWithColon(enum2Str(_journalType), MultipleDocumentSymbol);
        transactionDetailTable.Description = transactionDetailTable.Document;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionAmountForSourceLineAndLedgerAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the distribution total amount of a source document line for a specific ledger account.
    /// </summary>
    /// <param name = "_sourceDocumentLineRecId">
    /// The identifier for the <c>SourceDocumentLine</c> to get the distribution totals for.
    /// </param>
    /// <param name = "_ledgerDimension">
    /// The ledger account to get the distribution totals for.
    /// </param>
    /// <returns>
    /// The total transaction amount.
    /// </returns>
    private AmountCur getTransactionAmountForSourceLineAndLedgerAccount(
        SourceDocumentLineRecId _sourceDocumentLineRecId,
        LedgerDimensionAccount _ledgerDimension)
    {
        AccountingDistribution accountingDistribution;
        select sum(TransactionCurrencyAmount) from accountingDistribution
            where accountingDistribution.LedgerDimension == _ledgerDimension
                && accountingDistribution.SourceDocumentLine == _sourceDocumentLineRecId;

        return accountingDistribution.TransactionCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerDimensionFromPostingProfile</Name>
				<Source><![CDATA[
    private void updateLedgerDimensionFromPostingProfile()
    {
        LedgerJournalTable ledgerJournalTable;
        LedgerJournalTrans ledgerJournalTrans;

        ttsbegin;

        while select forUpdate LedgerDimension, AccountOffsetaccount
            from transactionDetailTable
            join * from ledgerJournalTrans
                where ledgerJournalTrans.RecId == transactionDetailTable.LedgerJournalTransactionRecId
                    && ledgerJournalTrans.AccountType != LedgerJournalACType::Ledger
            join JournalType, JournalNum from ledgerJournalTable
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum
        {
            boolean isInterCompany = ledgerJournalTrans.isCompanyIntercompany();

            if (transactionDetailTable.AccountOffsetaccount == AccountOffsetaccount::OffsetAccount)
            {
                ledgerJournalTrans.LedgerDimension = ledgerJournalTrans.OffsetLedgerDimension;
                ledgerJournalTrans.AccountType = ledgerJournalTrans.OffsetAccountType;
                ledgerJournalTrans.Company = ledgerJournalTrans.OffsetCompany;

                ledgerJournalTrans.DefaultDimension = isInterCompany ? ledgerJournalTrans.DefaultDimension : ledgerJournalTrans.OffsetDefaultDimension;
            }

            if (isInterCompany && transactionDetailTable.AccountOffsetaccount == AccountOffsetaccount::Account)
            {
                ledgerJournalTrans.DefaultDimension = (ledgerJournalTrans.Company == curext()) ?
                    ledgerJournalTrans.DefaultDimension : ledgerJournalTrans.OffsetDefaultDimension;
            }

            boolean isOffset = transactionDetailTable.AccountOffsetaccount == AccountOffsetaccount::OffsetAccount;

            transactionDetailTable.LedgerDimension = ledgerJournalTrans.getLedgerDimensionForJournalAccount(ledgerJournalTable, isOffset);

            transactionDetailTable.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomerAccountCurrentCompany</Name>
				<Source><![CDATA[
    private void updateCustomerAccountCurrentCompany()
    {
        CustTable CustTable;
        DirPartyTable dirPartyTable;
        DimensionAttributeLevelValueView dimensionAttributeLevelValueView;

        update_recordset transactionDetailTable
            setting AccountNum = custTable.AccountNum, Description = dirPartyTable.Name
                where transactionDetailTable.AccountType == LedgerJournalACType::Cust
                    && transactionDetailTable.Company == curExt()
            join dimensionAttributeLevelValueView
                where dimensionAttributeLevelValueView.ValueCombinationRecId == transactionDetailTable.LedgerDimension
            join custTable
                where custTable.RecId == dimensionAttributeLevelValueView.EntityInstance
            join dirPartyTable
                where dirPartyTable.RecId == custTable.Party;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendorAccountCurrentCompany</Name>
				<Source><![CDATA[
    private void updateVendorAccountCurrentCompany()
    {
        VendTable vendTable;
        DirPartyTable dirPartyTable;
        DimensionAttributeLevelValueView dimensionAttributeLevelValueView;

        update_recordset transactionDetailTable
            setting AccountNum = vendTable.AccountNum, Description = dirPartyTable.Name
                where transactionDetailTable.AccountType == LedgerJournalACType::Vend
                    && transactionDetailTable.Company == curExt()
            join dimensionAttributeLevelValueView
                where dimensionAttributeLevelValueView.ValueCombinationRecId == transactionDetailTable.LedgerDimension
            join vendTable
                where vendTable.RecId == dimensionAttributeLevelValueView.EntityInstance
            join dirPartyTable
                where dirPartyTable.RecId == vendTable.Party;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankAccountCurrentCompany</Name>
				<Source><![CDATA[
    private void updateBankAccountCurrentCompany()
    {
        BankAccountTable bankAccountTable;
        DirPartyTable dirPartyTable;
        DimensionAttributeLevelValueView dimensionAttributeLevelValueView;

        update_recordset transactionDetailTable
            setting AccountNum = bankAccountTable.AccountID, Description = bankAccountTable.Name
                where transactionDetailTable.AccountType == LedgerJournalACType::Bank
                    && transactionDetailTable.Company == curExt()
            join dimensionAttributeLevelValueView
                where dimensionAttributeLevelValueView.ValueCombinationRecId == transactionDetailTable.LedgerDimension
            join bankAccountTable
                where bankAccountTable.RecId == dimensionAttributeLevelValueView.EntityInstance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectAccounts</Name>
				<Source><![CDATA[
    private void updateProjectAccounts()
    {
        ProjTable projTable;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;

        update_recordSet transactionDetailTable
            setting AccountNum = dimensionAttributeValueCombination.DisplayValue, Description = projTable.Name
                where transactionDetailTable.AccountType == LedgerJournalACType::Project
            join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.RecId == transactionDetailTable.LedgerDimension
            join projTable
                where projTable.ProjId == dimensionAttributeValueCombination.DisplayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFixedAssetsAccounts</Name>
				<Source><![CDATA[
    private void updateFixedAssetsAccounts()
    {
        AssetTable assetTable;
        DimensionAttributeLevelValueView dimensionAttributeLevelValueView;

        update_recordset transactionDetailTable
            setting AccountNum = assetTable.AssetId, Description = assetTable.Name
                where transactionDetailTable.AccountType == LedgerJournalACType::FixedAssets
            join dimensionAttributeLevelValueView
                where dimensionAttributeLevelValueView.ValueCombinationRecId == transactionDetailTable.LedgerDimension
            join assetTable
                where assetTable.RecId == dimensionAttributeLevelValueView.EntityInstance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactionsDetailTmpRecordInsertList</Name>
				<Source><![CDATA[
    private void updateTransactionsDetailTmpRecordInsertList(GeneralJournalEntry _generalJournalEntry, GeneralJournalAccountEntry _generalJournalAccountEntry, SubledgerJournalAccountEntry _subledgerJournalAccountEntry, AccountingDistribution _accountingDistribution)
    {
        this.getDetailDataByGeneralJournal(_generalJournalEntry, _generalJournalAccountEntry, _subledgerJournalAccountEntry, _accountingDistribution);

        if (transactionDetailTable.TransactionType == FiscalPeriodType::Operating)
        {
            this.populateTransactionDetails(_subledgerJournalAccountEntry, _generalJournalEntry, _generalJournalAccountEntry, _accountingDistribution);
        }

        transactionsDetailTmpRecordInsertList.add(transactionDetailTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialBySide</Name>
				<Source><![CDATA[
    private boolean initialBySide(AccountingDistribution _accountingDistribution, SubledgerJournalAccountEntry _subledgerJournalAccountEntry)
    {
        return (_accountingDistribution && _subledgerJournalAccountEntry.Side == DebitCredit::Debit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setQuantity</Name>
				<Source><![CDATA[
    private void setQuantity(Qty _quantitiy)
    {
        transactionDetailTable.Quantity = _quantitiy;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>