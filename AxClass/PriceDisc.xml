<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PriceDisc</Name>
	<SourceCode>
		<Declaration><![CDATA[
class  PriceDisc
{
    PriceDiscParameters     priceDiscParameters;

    SalesParameters         salesParameters;
    PriceParameters         priceParameters;
    PriceDiscTable          actualPriceTable;
    PriceDiscTable          actualDiscTable;
    
    TradeModuleType         tradeModuleType;

    CurrencyCode            genericCurrency;

    PriceCur                price;
    PriceUnit               priceUnit;
    PriceMarkup             markup;
    // <GEERU>
    PriceSecCur_RU          priceSecCur;
    PriceSecCur_RU          markupSecCur;
    // </GEERU>
    Days                    deliveryDays;
    CalendarDays            calendarDays;
    // <GEERU>
    InventBaileeFreeDays_RU inventBaileeFreeDays;
    // </GEERU>

    DiscAmount              lineDiscAmount;
    DiscPct                 lineDiscPct;

    NoYes                   searchAgain;
    DiscAmount              discAmount;
    DiscAmount              roughEndDiscAmount;
    DiscPct                 percent1;
    DiscPct                 percent2;
    NoYes                   discAgreementExist;

    PriceGroupId            usedPriceGroupId;

    // <GIN>
    PriceCur                maxRetailPrice;
    // </GIN>
    #define.cacheScope_FindDisc('PriceDisc:FindDisc')
    CurrencyExchangeHelper  curExch;

    PDSCalculationId        pdsCalculationId;

    boolean                 cacheMode;

    // <GEERU>
    #ISOCountryRegionCodes
    boolean countryRegion_RU;
    // </GEERU>

    AmountQty                   quantityAmount;

    SysRecordSortedList         recordSortedListPriceDiscTable;
    boolean                     mcrPriceHistoryPotentialCalc;
    boolean                     mcrPriceHistoryEnabled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountRelation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the account relation for a given <c>PriceDiscPartyCodeType</c> during calculating either the price or discount.
    /// </summary>
    /// <param name = "_accountCode">The party code type to return the account number for.</param>
    /// <param name = "_groupId">The price group Id.</param>
    /// <returns>Returns the account relation to calculate the price and discount for.</returns>
    [Wrappable(true)]
    protected internal CustVendAC accountRelation(
        PriceDiscPartyCodeType  _accountCode,
        PriceGroupId            _groupId)
    {
        switch (_accountCode)
        {
            case PriceDiscPartyCodeType::Table:
                return priceDiscParameters.parmAccountNum();
            case PriceDiscPartyCodeType::GroupId:
                return _groupId;
            default:
                return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCur2CurPriceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts an amount from a trade agreement currency to a trade line currency.
    /// </summary>
    /// <param name="_amount">
    ///    An amount in a trade agreement currency.
    /// </param>
    /// <param name="_priceDiscTable">
    ///    A record buffer of the <c>PriceDiscTable</c> table.
    /// </param>
    /// <returns>
    ///    An amount in a trade line currency.
    /// </returns>
    public AmountCur calcCur2CurPriceAmount(
        Amount                 _amount,
        PriceDiscTable         _priceDiscTable)
    {
        return this.calcCurrency2Currency(_amount, CurrencyRoundingRuleType::Amount, _priceDiscTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCurrencyUnitAmount2CurrencyUnitAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a unit amount from a trade agreement currency to a trade line currency.
    /// </summary>
    /// <param name="_unitAmount">
    /// A unit amount in a trade agreement currency.
    /// </param>
    /// <param name="_priceDiscTable">
    /// A record buffer of the <c>PriceDiscTable</c> table.
    /// </param>
    /// <returns>
    /// A unit amount in a trade line currency.
    /// </returns>
    public UnitAmountCur calcCurrencyUnitAmount2CurrencyUnitAmount(
        UnitAmountCur          _unitAmount,
        PriceDiscTable         _priceDiscTable)
    {
        return this.calcCurrency2Currency(_unitAmount, CurrencyRoundingRuleType::Price, _priceDiscTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCurrency2Currency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts an amount from a trade agreement currency to a trade line currency.
    /// </summary>
    /// <param name="_amount">
    /// An amount in a trade agreement currency.
    /// </param>
    /// <param name="_roundingRuleType">
    /// A <c>CurrencyRoundingRuleType</c> amount type to use for rounding off the amount.
    /// </param>
    /// <param name="_priceDiscTable">
    /// A <c>PriceDiscTable</c> record.
    /// </param>
    /// <returns>
    /// The amount in trade line currency.
    /// </returns>
    final protected AmountCur calcCurrency2Currency(
        AmountCur                   _amount,
        CurrencyRoundingRuleType    _roundingRuleType,
        PriceDiscTable              _priceDiscTable)
    {
        if (_priceDiscTable.GenericCurrency
         && _priceDiscTable.Currency != priceDiscParameters.parmCurrencyCode())
        {
            if (!curExch)
            {
                curExch = CurrencyExchangeHelper::construct();
                curExch.parmExchangeRateTypeRecId(ExchangeRateType::find(SalesParameters::find().ExchangeRateType).RecId);
            }
            curExch.parmExchangeDate(priceDiscParameters.parmPriceDiscDate());
            
            curExch.parmRoundingRuleType(_roundingRuleType);

            return curExch.calculateCurrencyToCurrency(_priceDiscTable.Currency, priceDiscParameters.parmCurrencyCode(), _amount, true);
        }
        else
        {
            return _amount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePriceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amount based on the general rounding settings of the provided currency.
    /// </summary>
    /// <param name = "_absQty">The amount in transaction currency.</param>
    /// <returns>The calculated amount.</returns>
    final protected internal AmountCur calculatePriceAmount(Qty  _absQty)
    {
        AmountCur localPrice = _absQty ? _absQty * this.price() : this.price();
        return CurrencyExchangeHelper::amount(localPrice / this.priceUnit() + abs(this.markup()), priceDiscParameters.parmCurrencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calendarDays</Name>
				<Source><![CDATA[
    public CalendarDays  calendarDays()
    {
        return calendarDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deliveryDays</Name>
				<Source><![CDATA[
    public Days  deliveryDays()
    {
        return deliveryDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discTable</Name>
				<Source><![CDATA[
    public PriceDiscTable  discTable()
    {
        return actualDiscTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDiscEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the <c>findDisc</c> method should be executed.
    /// </summary>
    /// <param name = "_inventDimId">
    ///     The inventory dimension id to find a price disc for.
    /// </param>
    /// <returns>
    ///     true if the <c>findDisc</c> method should be executed; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected internal boolean findDiscEnabled(InventDimId _inventDimId)
    {
        if (_inventDimId)
        {
            return true;
        }
  
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrievePriceDiscountEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the prices and discounts from the <c>PriceDiscTable</c> based on the <c>PriceType</c>.
    /// </summary>
    /// <param name = "_priceDiscTable">A <c>PriceDiscTable</c> record.</param>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <returns>true if the price and discount was retreived; otherwise, false.</returns>
    protected boolean retrievePriceDiscountEndDisc(PriceDiscTable _priceDiscTable)
    {
        // for end discounts, the QuantiyAmountField field contains order total amounts, not quantities
        if (this.calcCur2CurPriceAmount(_priceDiscTable.QuantityAmountFrom, _priceDiscTable) <= priceDiscParameters.parmQty()
            &&  ((priceDiscParameters.parmQty() < this.calcCur2CurPriceAmount(_priceDiscTable.QuantityAmountTo, _priceDiscTable))
                    || !_priceDiscTable.QuantityAmountTo))
        {
            if (cacheMode)
            {
                _priceDiscTable = PriceDiscTable::findRecId(_priceDiscTable.RecId);
            }

            this.updateDiscountFromPriceDiscTable(_priceDiscTable);

            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiatePriceDiscCacheKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the price discount cache key.
    /// </summary>
    /// <returns>The price discount cache key.</returns>
    internal PriceDiscCacheKey instantiatePriceDiscCacheKey()
    {
        return PriceDiscCacheKey::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateCacheKey</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the price discount cache key.
    /// </summary>
    /// <returns>A price discount cache key.</returns>
    protected PriceDiscCacheKey instantiateCacheKey()
    {
        return PriceDiscCacheKey::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrievePriceDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the prices and discounts from the <c>PriceDiscTable</c> based on the <c>PriceType</c>.
    /// </summary>
    /// <param name = "_priceDiscTable">A <c>PriceDiscTable</c> record.</param>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <returns>true if the price and discount was retreived; otherwise, false.</returns>
    protected boolean retrievePriceDiscount(PriceDiscTable _priceDiscTable, PriceType _relation)
    {
        if ((priceDiscParameters.parmPriceDiscDate() >= _priceDiscTable.FromDate  || !_priceDiscTable.FromDate)
                && (priceDiscParameters.parmPriceDiscDate() <= _priceDiscTable.ToDate || !_priceDiscTable.ToDate))
        {
            switch(_relation)
            {
                case PriceType::EndDiscPurch:
                case PriceType::EndDiscSales:
                    return this.retrievePriceDiscountEndDisc(_priceDiscTable);
                case PriceType::LineDiscPurch:
                case PriceType::LineDiscSales:
                case PriceType::MCRPostageDisc:
                case PriceType::MultiLineDiscPurch:
                case PriceType::MultiLineDiscSales:
                case PriceType::PricePurch:
                case PriceType::PriceSales:
                    if ( _priceDiscTable.QuantityAmountFrom <= priceDiscParameters.parmQty()
                        && (priceDiscParameters.parmQty() < _priceDiscTable.QuantityAmountTo || !_priceDiscTable.QuantityAmountTo))
                    {
                        if (cacheMode)
                        {
                            _priceDiscTable = PriceDiscTable::findRecId(_priceDiscTable.RecId);
                        }

                        this.updateDiscountFromPriceDiscTable(_priceDiscTable);

                        this.mcrPriceDiscTableFound(_priceDiscTable);

                        return true;
                    }
                    else
                    {
                        // If quantity does not qualify, but calculation potential then add as found
                        if (this.parmMCRPriceHistoryPotentialCalc())
                        {
                            if (cacheMode)
                            {
                                _priceDiscTable = PriceDiscTable::findRecId(_priceDiscTable.RecId);
                            }

                            this.mcrPriceDiscTableFound(_priceDiscTable);
                        }
                    }
                    break;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDiscountFromPriceDiscTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the discount fields from the <c>PriceDiscTable</c>.
    /// </summary>
    /// <param name = "_priceDiscTable">
    /// The price disc table record to update the discount fields from.
    /// </param>
    public void updateDiscountFromPriceDiscTable(PriceDiscTable _priceDiscTable)
    {
        discAmount             += this.calcCurrency2Currency(_priceDiscTable.Amount, PriceDisc::priceTypeRoundingRuleType(_priceDiscTable.relation), _priceDiscTable)/ this.priceUnit();
        percent1               += _priceDiscTable.Percent1;
        percent2               += _priceDiscTable.Percent2;
        actualDiscTable         = _priceDiscTable.data();
        quantityAmount         += _priceDiscTable.QuantityAmountFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiatePriceDiscDiscountSearchParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the parameters object for the price agreement search.
    /// </summary>
    /// <param name = "_relation">
    /// A <c>PriceType</c> value.
    /// </param>
    /// <param name = "_inventDimId">
    /// An <c>InventDimId</c> value.
    /// </param>
    /// <param name = "_itemCode">
    /// A <c>PriceDiscProductCodeType</c> value.
    /// </param>
    /// <param name = "_itemRelation">
    /// An <c>ItemId</c> value.
    /// </param>
    /// <param name = "_accountCode">
    /// <c>PriceDiscPartyCodeType</c> value.
    /// </param>
    /// <param name = "_accountRelation">
    /// A <c>CustVendAC</c> value.
    /// </param>
    /// <param name = "_unitID">
    /// An <c>UnitOfMeasureSymbol</c> value.
    /// </param>
    /// <param name = "_quantityAmount">
    /// A <c>Qty</c> value.
    /// </param>
    /// <returns>An instance of the  parameters for the price agreement search.</returns>
    protected PriceDiscDiscountSearchParameters instantiatePriceDiscDiscountSearchParameters(
        PriceType                 _relation,
        InventDimId               _inventDimId,
        PriceDiscProductCodeType  _itemCode        =  PriceDiscProductCodeType::Table,
        ItemId                    _itemRelation    = '',
        PriceDiscPartyCodeType    _accountCode     =  PriceDiscPartyCodeType::Table,
        CustVendAC                _accountRelation = '',
        UnitOfMeasureSymbol       _unitID          = '',
        Qty                       _quantityAmount  =  0)
    {
        PriceDiscDiscountSearchParameters priceDiscDiscountSearchParameters = new PriceDiscDiscountSearchParameters();

        priceDiscDiscountSearchParameters.parmRelation(_relation);
        priceDiscDiscountSearchParameters.parmInventDimId(_inventDimId);
        priceDiscDiscountSearchParameters.parmItemCode(_itemCode);
        priceDiscDiscountSearchParameters.parmItemRelation(_itemRelation);
        priceDiscDiscountSearchParameters.parmAccountCode(_accountCode);
        priceDiscDiscountSearchParameters.parmAccountRelation(_accountRelation);
        priceDiscDiscountSearchParameters.parmUnitID(_unitID);
        priceDiscDiscountSearchParameters.parmQuantityAmount(_quantityAmount);

        return priceDiscDiscountSearchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the price discount agreement for the <c>PriceDiscDiscountSearchParameters</c> instance.
    /// </summary>
    /// <param name = "_priceDiscDiscountSearchParameters">A <c>PriceDiscDiscountSearchParameters</c> instance.</param>
    /// <returns>true if a price agreement was found; otherwise, false.</returns>
    protected boolean findDisc(PriceDiscDiscountSearchParameters _priceDiscDiscountSearchParameters)
    {
        PriceDiscDiscountSearch priceDiscDiscountSearch = PriceDiscDiscountSearch::construct(this, priceDiscParameters, searchAgain);
        boolean result = priceDiscDiscountSearch.findDisc(_priceDiscDiscountSearchParameters);

        searchAgain = priceDiscDiscountSearch.parmSearchAgain();

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPriceDiscFindDiscQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for finding discounts based on the parameters.
    /// </summary>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <param name = "_inventDimId">An <c>InventDimId</c> value.</param>
    /// <param name = "_itemCode">An item code.</param>
    /// <param name = "_itemRelation">An <c>ItemId</c>.</param>
    /// <param name = "_accountCode">An account code.</param>
    /// <param name = "_accountRelation">A customer or vendor account number.</param>
    /// <param name = "_unitID">A <c>UnitOfMeasureSymbol</c> value.</param>
    /// <returns>A <c>Query</c> object.</returns>
    internal Query buildPriceDiscFindDiscQuery(
                              PriceType                 _relation,
                              InventDimId               _inventDimId,
                              PriceDiscProductCodeType  _itemCode,
                              ItemId                    _itemRelation,
                              PriceDiscPartyCodeType    _accountCode,
                              CustVendAC                _accountRelation,
                              UnitOfMeasureSymbol       _unitID)
    {
        return this.buildFindDiscQuery(_relation, _inventDimId, _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPriceDiscFindPriceQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for finding prices based on the parameters.
    /// </summary>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <param name = "_inventDimId">An <c>InventDimId</c> value.</param>
    /// <param name = "_itemCode">An item code.</param>
    /// <param name = "_itemRelation">An <c>ItemId</c>.</param>
    /// <param name = "_accountCode">An account code.</param>
    /// <param name = "_accountRelation">A customer or vendor account number.</param>
    /// <param name = "_unitID">A <c>UnitOfMeasureSymbol</c> value.</param>
    /// <returns>A <c>Query</c> object.</returns>
    internal Query buildPriceDiscFindPriceQuery(
                              PriceType                 _relation,
                              InventDimId               _inventDimId,
                              PriceDiscProductCodeType  _itemCode,
                              ItemId                    _itemRelation,
                              PriceDiscPartyCodeType    _accountCode,
                              CustVendAC                _accountRelation,
                              UnitOfMeasureSymbol       _unitID)
    {
        return this.buildFindPriceQuery(_relation, _inventDimId, _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFindPriceQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for finding prices based on the parameters.
    /// </summary>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <param name = "_inventDimId">An <c>InventDimId</c> value.</param>
    /// <param name = "_itemCode">An item code.</param>
    /// <param name = "_itemRelation">An <c>ItemId</c>.</param>
    /// <param name = "_accountCode">An account code.</param>
    /// <param name = "_accountRelation">A customer or vendor account number.</param>
    /// <param name = "_unitID">A <c>UnitOfMeasureSymbol</c> value.</param>
    /// <returns>A <c>Query</c> object.</returns>
    protected Query buildFindPriceQuery(
                              PriceType                 _relation,
                              InventDimId               _inventDimId,
                              PriceDiscProductCodeType  _itemCode,
                              ItemId                    _itemRelation,
                              PriceDiscPartyCodeType    _accountCode,
                              CustVendAC                _accountRelation,
                              UnitOfMeasureSymbol       _unitID)
    {
        return this.buildFindPriceDiscountQuery(_relation, _inventDimId, _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFindPriceDiscountQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for finding prices and discounts based on the parameters.
    /// </summary>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <param name = "_inventDimId">An <c>InventDimId</c> value.</param>
    /// <param name = "_itemCode">An item code.</param>
    /// <param name = "_itemRelation">An <c>ItemId</c>.</param>
    /// <param name = "_accountCode">An account code.</param>
    /// <param name = "_accountRelation">A customer or vendor account number.</param>
    /// <param name = "_unitID">A <c>UnitOfMeasureSymbol</c> value.</param>
    /// <returns>A <c>Query</c> object.</returns>
    [Wrappable(true)]
    protected internal Query buildFindPriceDiscountQuery(PriceType    _relation,
                              InventDimId           _inventDimId,
                              PriceDiscProductCodeType _itemCode,
                              ItemId                _itemRelation,
                              PriceDiscPartyCodeType _accountCode,
                              CustVendAC            _accountRelation,
                              UnitOfMeasureSymbol   _unitID)
    {
        Query query = new Query();
        QueryBuildDataSource priceDiscTableSource = query.addDataSource(tableNum(PriceDiscTable));

        this.addSortingForFindPriceDiscOnPriceDiscTable(priceDiscTableSource);

        priceDiscTableSource.addRange(fieldNum(PriceDiscTable, Relation)).value(queryValue(_relation));
        priceDiscTableSource.addRange(fieldNum(PriceDiscTable, ItemCode)).value(queryValue(_itemCode));
        priceDiscTableSource.addRange(fieldNum(PriceDiscTable, ItemRelation)).value(queryValue(_itemRelation));
        priceDiscTableSource.addRange(fieldNum(PriceDiscTable, AccountCode)).value(queryValue(_accountCode));
        priceDiscTableSource.addRange(fieldNum(PriceDiscTable, AccountRelation)).value(queryValue(_accountRelation));
        priceDiscTableSource.addRange(fieldNum(PriceDiscTable, UnitId)).value(queryValue(_unitID));

        if (countryRegion_RU)
        {
            priceDiscTableSource.addRange(fieldNum(PriceDiscTable, AgreementHeaderExt_RU)).value(queryvalue(priceDiscParameters.parmAgreementHeaderExt_RU()));
        }

        if (!this.parmMCRPriceHistoryPotentialCalc())
        {
            priceDiscTableSource.addRange(fieldNum(PriceDiscTable, InventDimId)).value(queryvalue(_inventDimId));
        }

        priceDiscTableSource.clearRange(fieldNum(PriceDiscTable, Currency));
        if (genericCurrency)
        {
            priceDiscTableSource.addRange(fieldNum(PriceDiscTable, Currency)).value(strFmt('((%1 == "%2") || ((%3 == %4) && (%1 == "%5")))',
                fieldStr(PriceDiscTable, Currency),
                queryvalue(priceDiscParameters.parmCurrencyCode()),
                fieldStr(PriceDiscTable, GenericCurrency),
                int2str(enum2int(NoYes::Yes)),
                queryValue(genericCurrency)));
        }
        else
        {
            priceDiscTableSource.addRange(fieldNum(PriceDiscTable, Currency)).value(queryvalue(priceDiscParameters.parmCurrencyCode()));
        }
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addSortingForFindPriceDiscOnPriceDiscTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds sorting on the <c>PriceDiscTable</c> datasource in the price and discount query.
    /// </summary>
    /// <param name = "_priceDiscTableSource">A <c>QueryBuildDataSource</c> for the <c>PriceDiscTable</c>.</param>
    protected void addSortingForFindPriceDiscOnPriceDiscTable(QueryBuildDataSource _priceDiscTableSource)
    {
        _priceDiscTableSource.addOrderByField(fieldNum(PriceDiscTable, QuantityAmountFrom));
        _priceDiscTableSource.addOrderByField(fieldNum(PriceDiscTable, FromDate));
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFindDiscQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for finding discount based on the parameters.
    /// </summary>
    /// <param name = "_relation">A <c>PriceType</c> value.</param>
    /// <param name = "_inventDimId">An <c>InventDimId</c> value.</param>
    /// <param name = "_itemCode">An item code.</param>
    /// <param name = "_itemRelation">An <c>ItemId</c>.</param>
    /// <param name = "_accountCode">An account code.</param>
    /// <param name = "_accountRelation">A customer or vendor account number.</param>
    /// <param name = "_unitID">A <c>UnitOfMeasureSymbol</c> value.</param>
    /// <returns>A <c>Query</c> object.</returns>
    protected Query buildFindDiscQuery(PriceType        _relation,
                              InventDimId               _inventDimId,
                              PriceDiscProductCodeType  _itemCode,
                              ItemId                    _itemRelation,
                              PriceDiscPartyCodeType    _accountCode,
                              CustVendAC                _accountRelation,
                              UnitOfMeasureSymbol       _unitID)
    {
        return this.buildFindPriceDiscountQuery(_relation, _inventDimId, _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findItemDiscAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds discount agreement.
    /// </summary>
    /// <param name = "_relation">
    /// A <c>PriceType</c> value.
    /// </param>
    /// <param name = "_itemCode">
    /// A <c>PriceDiscProductCodeType</c> value.
    /// </param>
    /// <param name = "_accountCode">
    /// A <c>PriceDiscPartyCodeType</c> value.
    /// </param>
    /// <param name = "_itemRelation">
    /// An <c>ItemRelation</c> value.
    /// </param>
    /// <param name = "_accountRelation">
    /// A <c>CustVendRel</c> value.
    /// </param>
    /// <param name = "_unitID">
    /// A <c>UnitOfMeasureSymbol</c> value.
    /// </param>
    /// <param name = "_inventDimIdAllActivated">
    /// An <c>InventDimId</c> value.
    /// </param>
    /// <param name = "_inventDimIdItemDim">
    /// An <c>InventDimId</c> value.
    /// </param>
    protected void findItemDiscAgreement(PriceType                   _relation,
                                         PriceDiscProductCodeType    _itemCode,
                                         PriceDiscPartyCodeType      _accountCode,
                                         ItemRelation                _itemRelation,
                                         CustVendRel                 _accountRelation,
                                         UnitOfMeasureSymbol         _unitID,
                                         InventDimId                 _inventDimIdAllActivated,
                                         InventDimId                 _inventDimIdItemDim)
    {
        if (PriceDiscTable::isPartyCodeProductCodeActivated(_relation, _accountCode, _itemCode, priceParameters))
        {
            if (PriceDisc::validatePartyRelation(_accountCode, _accountRelation)  &&
                        PriceDisc::validateProductRelation(_itemCode, _itemRelation))
            {
                if (_itemCode == PriceDiscProductCodeType::Table)
                {
                    // Retail pricing doesn't support dimensions for trade agreements.
                    if (this.parmPriceDiscParameters().parmUseRetailPricing())
                    {
                        discAgreementExist = this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(_relation, InventDim::inventDimIdBlank(), _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID, priceDiscParameters.parmQty()));
                    }
                    else
                    {
                        if (this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(_relation,_inventDimIdAllActivated, _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID, priceDiscParameters.parmQty())))
                        discAgreementExist = true;
                        else if (this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(_relation, _inventDimIdItemDim, _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID, priceDiscParameters.parmQty())))
                       discAgreementExist = true;
                        else if (this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(_relation, InventDim::inventDimIdBlank(), _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID, priceDiscParameters.parmQty())))
                       discAgreementExist = true;
                    }
                }
                else
                {
                    if (this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(_relation, InventDim::inventDimIdBlank(), _itemCode, _itemRelation, _accountCode, _accountRelation, _unitID, priceDiscParameters.parmQty())))
                        discAgreementExist = true;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findDiscAgreement</Name>
				<Source><![CDATA[
    NoYes  findDiscAgreement(PriceType              _relation,
                             DiscCode               _itemDisc,
                             DiscCode               _accountDisc,
                             UnitOfMeasureSymbol    _unitID,
                             InventDimId            _inventDimIdAllActivated,
                             InventDimId            _inventDimIdItemDim
                             )
    {
        if (this.mustSearchDiscAgreements(_relation,_itemDisc, _accountDisc, _unitID, _inventDimIdAllActivated, _inventDimIdItemDim))
        {
            this.searchDiscAgreements(_relation,_itemDisc, _accountDisc, _unitID, _inventDimIdAllActivated, _inventDimIdItemDim);
        }

        if (countryRegion_RU)
        {
            priceDiscParameters.parmAgreementExists_RU(priceDiscParameters.parmAgreementHeaderExt_RU() && discAgreementExist);
        }

        return discAgreementExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSearchDiscAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether to search for discount agreements.
    /// </summary>
    /// <param name = "_relation">
    ///     Price or discount type.
    /// </param>
    /// <param name = "_itemDisc">
    ///     Discount code for item.
    /// </param>
    /// <param name = "_accountDisc">
    ///     Discount code for customer.
    /// </param>
    /// <param name = "_unitID">
    ///     Indicates the unit.
    /// </param>
    /// <param name = "_inventDimIdAllActivated">
    ///     All activated dimension number.
    /// </param>
    /// <param name = "_inventDimIdItemDim">
    ///     Item dim dimension number.
    /// </param>
    /// <returns>
    ///     true if required to search the discount agreements; otherwise, false.
    /// </returns>
    protected boolean mustSearchDiscAgreements(PriceType              _relation,
                                               DiscCode               _itemDisc,
                                               DiscCode               _accountDisc,
                                               UnitOfMeasureSymbol    _unitID,
                                               InventDimId            _inventDimIdAllActivated,
                                               InventDimId            _inventDimIdItemDim)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchDiscAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Searches for discount agreement.
    /// </summary>
    /// <param name = "_relation">
    ///     Price or discount type.
    /// </param>
    /// <param name = "_itemDisc">
    ///     Discount code for item.
    /// </param>
    /// <param name = "_accountDisc">
    ///     Discount code for customer.
    /// </param>
    /// <param name = "_unitID">
    ///     Indicates the unit.
    /// </param>
    /// <param name = "_inventDimIdAllActivated">
    ///     All activated dimension number.
    /// </param>
    /// <param name = "_inventDimIdItemDim">
    ///     Item dim dimension number.
    /// </param>
    protected void searchDiscAgreements(PriceType              _relation,
                                           DiscCode               _itemDisc,
                                           DiscCode               _accountDisc,
                                           UnitOfMeasureSymbol    _unitID,
                                           InventDimId            _inventDimIdAllActivated,
                                           InventDimId            _inventDimIdItemDim)
    {
        PriceDiscProductCodeType    itemCode;
        PriceDiscPartyCodeType      accountCode;
        ItemRelation                itemRelation;
        CustVendRel                 accountRelation;

        PriceDiscPartyCodeTypeOrderedList   priceDiscPartyCodeTypeOrderedList   = PriceDiscPartyCodeTypeOrderedList::newFromOrder(SortOrder::Ascending);
        PriceDiscProductCodeTypeOrderedList priceDiscProductCodeTypeOrderedList = PriceDiscProductCodeTypeOrderedList::newFromOrder(SortOrder::Ascending);

        ListEnumerator priceDiscPartyCodeTypeEnumerator     = priceDiscPartyCodeTypeOrderedList.getEnumerator();
        ListEnumerator priceDiscProductCodeTypeEnumerator   = priceDiscProductCodeTypeOrderedList.getEnumerator();
        boolean continueSearch = true;

        while (priceDiscPartyCodeTypeEnumerator.moveNext() && continueSearch)
        {
            accountCode = priceDiscPartyCodeTypeEnumerator.current();
            while (priceDiscProductCodeTypeEnumerator.moveNext() && continueSearch)
            {
                itemCode = priceDiscProductCodeTypeEnumerator.current();
                itemRelation    = this.itemRelation(itemCode, _itemDisc);
                accountRelation = this.accountRelation(accountCode, _accountDisc);

                this.findItemDiscAgreement(_relation, itemCode, accountCode, itemRelation, accountRelation, _unitID, _inventDimIdAllActivated, _inventDimIdItemDim);

                if (!searchAgain && !this.parmMCRPriceHistoryPotentialCalc())
                {
                    continueSearch = false;
                }
            }
            priceDiscProductCodeTypeEnumerator.reset();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findEndDisc</Name>
				<Source><![CDATA[
    public NoYes  findEndDisc(EndDiscCode        _endDisc,
                              AmountCur          _balanceEndDisc,
                              AmountCur          _totalSalesBalance = 0
                              )
    {
        PriceType relation = tradeModuleType.priceDiscType(PriceGroupType::EndDiscGroup);

        PriceDiscPartyCodeType  accountCode;
        CustVendRel             accountRelation;
        AmountCur               newBalanceEndDisc;

        this.resetDisc();

        PriceDiscPartyCodeTypeOrderedList  priceDiscPartyCodeTypeOrderedList = PriceDiscPartyCodeTypeOrderedList::newFromOrder(SortOrder::Ascending);
        ListEnumerator priceDiscPartyCodeTypeEnumerator = priceDiscPartyCodeTypeOrderedList.getEnumerator();
        while (priceDiscPartyCodeTypeEnumerator.moveNext())
        {
            accountCode = priceDiscPartyCodeTypeEnumerator.current();

            accountRelation = this.accountRelation(accountCode, _endDisc);

            if (PriceDiscTable::isPartyCodeProductCodeActivated(relation, accountCode, PriceDiscProductCodeType::All, priceParameters))
            {
                if (PriceDisc::validatePartyRelation(accountCode, accountRelation))
                {
                    if (_totalSalesBalance != 0)
                    {
                        newBalanceEndDisc = _totalSalesBalance;
                    }
                    else
                    {
                        newBalanceEndDisc = _balanceEndDisc;
                    }

                    if (this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(relation,
                                    InventDim::inventDimIdBlank(),
                                    PriceDiscProductCodeType::All,
                                    '',           // no item relation
                                    accountCode,
                                    accountRelation,
                                    '',           // no unit
                                    newBalanceEndDisc)))
                    {
                        discAgreementExist = true;
                    }
                }
            }

            if (!searchAgain)
            {
                break;
            }
        }

        // Store all vallues of agreements Amount fields participated into calculation of end discount
        // (this value is used by Total Discount List service when Total Discount List is produced.
        roughEndDiscAmount = discAmount;

        // Update discAmount
        discAmount += _balanceEndDisc * (1- (1 - percent1 / 100) * (1 - percent2 / 100));

        return discAgreementExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePriceConvertFactory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>PriceConvertFactory</c> object.
    /// </summary>
    /// <param name = "_inventTableModule">
    /// An <c>InventTableModule</c> record buffer.
    /// </param>
    /// <param name = "_priceDiscDim">
    /// An <c>InventDim</c> record buffer.
    /// </param>
    /// <returns>
    /// The <c>PriceConvertFactory</c> object.
    /// </returns>
    protected PriceConvertFactory initializePriceConvertFactory(InventTableModule _inventTableModule, InventDim _priceDiscDim)
    {
        PriceConvertFactory     priceConvertFactory;

        priceConvertFactory = PriceConvertFactory::newItemPrice(priceDiscParameters.parmItemId(),
                                                                _inventTableModule.UnitId,
                                                                _inventTableModule.price(),
                                                                _inventTableModule.priceUnit(),
                                                                _inventTableModule.markup(),
                                                                _inventTableModule.priceQty(),
                                                                '',
                                                                countryRegion_RU ? _inventTableModule.priceSecCur_RU() : 0,
                                                                countryRegion_RU ? _inventTableModule.markupSecCur_RU() : 0);

        priceConvertFactory.parmNewCurrencyCode(priceDiscParameters.parmCurrencyCode());
        priceConvertFactory.parmTransDate(priceDiscParameters.parmPriceDiscDate());
        priceConvertFactory.parmNewUnitId(priceDiscParameters.parmUnitId());

        priceConvertFactory.parmInventDimId(_priceDiscDim.inventDimId);
        
        return priceConvertFactory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts the item price to the priceDiscParameters currency and unit.
    /// </summary>
    /// <param name = "_inventTableModule">
    /// An <c>InventTableModule</c> record buffer.
    /// </param>
    /// <param name = "_priceDiscDim">
    /// The <c>PriceConvertFactory</c> object.
    /// </param>
    protected void convertPrice(InventTableModule _inventTableModule, InventDim _priceDiscDim)
    {
        PriceConvertFactory     priceConvertFactory = this.initializePriceConvertFactory(_inventTableModule, _priceDiscDim);
        PriceConvert            priceConvert = priceConvertFactory.priceConvert();

        price       = priceConvert.parmPrice();
        priceUnit   = priceConvert.parmPriceUnit();
        markup      = priceConvert.parmMarkup();

        if (countryRegion_RU)
        {
            priceSecCur  = priceConvert.parmPriceSecCur_RU();
            markupSecCur = priceConvert.parmMarkupSecCur_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findItemPrice</Name>
				<Source><![CDATA[
    public boolean  findItemPrice()
    {
        boolean                 taxesMarked = TaxParameters::checkTaxParameters_IN();
        boolean                 countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        InventItemOrderSetupMap inventItemOrderSetupMap = InventItemOrderSetupMap::find(priceDiscParameters.parmItemId(), InventItemOrderSetupMap::module2SetupType(priceDiscParameters.parmModuleType()), priceDiscParameters.parmInventDim().InventDimId);
        
        InventTableModule inventTableModule = InventTableModule::find(priceDiscParameters.parmItemId(), priceDiscParameters.parmModuleType());

        if (countryRegion_IN
            && taxesMarked)
        {
            maxRetailPrice = inventTableModule.maxRetailPrice_IN();
        }

        this.updateLeadTime(inventItemOrderSetupMap);

        InventDim   priceDiscDim = InventDim::findOrCreate(priceDiscParameters.parmInventDim());

        if (countryRegion_IN
            && taxesMarked)
        {
            maxRetailPrice = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(priceDiscParameters.parmItemId(),
                                                                                                   priceDiscDim.inventDimId,
                                                                                                   maxRetailPrice,
                                                                                                   priceDiscParameters.parmUnitID(),
                                                                                                   inventTableModule.UnitId,
                                                                                                   NoYes::Yes);
        }

        this.convertPrice(inventTableModule, priceDiscDim);

        if (countryRegion_IN
            && taxesMarked
            && priceDiscParameters.parmCurrencyCode())
        {
            maxRetailPrice = ExchangeRateHelper::curPrice(maxRetailPrice, priceDiscParameters.parmCurrencyCode(), priceDiscParameters.parmPriceDiscDate());
        }

        return (price != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLineDisc</Name>
				<Source><![CDATA[
    public NoYes  findLineDisc(LineDiscCode    _itemLineDisc,
                               LineDiscCode    _accountLineDisc)
    {
        this.mcrRemovePriceDiscTableList(MCRPriceHistoryType::LineDisc);

        this.resetDisc();

        InventDim inventDimAllActivated;
        InventDim inventDimProductDimActivated;
        InventDim inventDimNoneActivated;
        
        if (priceDiscParameters.parmItemId())
        {
            inventDimAllActivated.initFromInventDim(priceDiscParameters.parmInventDim(), tradeModuleType.activePriceFields(priceDiscParameters.parmItemId()));

            EcoResProductDimGroupSetup::copyProductDimensionsForItem(priceDiscParameters.parmItemId(), inventDimAllActivated, inventDimProductDimActivated);

            boolean findAll         = !InventDim::isInventDimEqual(inventDimAllActivated, inventDimProductDimActivated);
            boolean findProductDim  = !InventDim::isInventDimEqual(inventDimProductDimActivated, inventDimNoneActivated);

            inventDimAllActivated           = findAll           ? InventDim::findDim(inventDimAllActivated)         : inventDimAllActivated;
            inventDimProductDimActivated    = findProductDim    ? InventDim::findDim(inventDimProductDimActivated)  : inventDimProductDimActivated;
        }

        PriceType relation = tradeModuleType.priceDiscType(PriceGroupType::LineDiscGroup);

        if (countryRegion_RU)
        {
            boolean discFound = false;
            if (this.searchbyAgreement_RU())
            {
                discFound = this.findDiscAgreement(relation, _itemLineDisc, _accountLineDisc, priceDiscParameters.parmUnitId(), inventDimAllActivated.InventDimId, inventDimProductDimActivated.InventDimId);
            }
            
            if (!discFound)
            {
                AgreementHeaderExtRecId_RU recId = priceDiscParameters.parmAgreementHeaderExt_RU();
                CustVendAC custVendAc = priceDiscParameters.parmAgreementPartnerCode_RU();

                priceDiscParameters.parmAgreementHeaderExt_RU(0);
                priceDiscParameters.parmAgreementPartnerCode_RU('');
            
                discFound = this.findDiscAgreement(relation, _itemLineDisc, _accountLineDisc, priceDiscParameters.parmUnitId(), inventDimAllActivated.InventDimId, inventDimProductDimActivated.InventDimId);

                priceDiscParameters.parmAgreementHeaderExt_RU(recId);
                priceDiscParameters.parmAgreementPartnerCode_RU(custVendAc);
            }

            if (discFound)
            {
                lineDiscPct         = this.getDiscPercent();
                lineDiscAmount      = this.getDiscAmount();
            }
        }
        else
        {
            if (this.findDiscAgreement(relation, _itemLineDisc, _accountLineDisc, priceDiscParameters.parmUnitId(), inventDimAllActivated.InventDimId, inventDimProductDimActivated.InventDimId))
            {
                lineDiscPct         = this.getDiscPercent();
                lineDiscAmount      = this.getDiscAmount();
            }
        }

        return discAgreementExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findMultiLineDisc</Name>
				<Source><![CDATA[
    public NoYes findMultiLineDisc(MultiLnDiscCode          _itemMultiLnDisc,
                                   MultiLnDiscCode          _accountMultiLnDisc,
                                   Qty                      _multiLnQty,
                                   MCRPriceHistoryUpdate    _mcrPriceHistoryUpdate = null)
    {
        PriceType relation = tradeModuleType.priceDiscType(PriceGroupType::MultiLineDiscGroup);
        boolean discFound = false;

        this.resetDisc();

        if (countryRegion_RU)
        {
            if (this.searchbyAgreement_RU())
            {
                discFound = this.findDiscAgreement(relation, _itemMultiLnDisc, _accountMultiLnDisc, '', '', '');
            }

            if (!discFound)
            {
                AgreementHeaderExtRecId_RU recId = priceDiscParameters.parmAgreementHeaderExt_RU();
                CustVendAC custVendAc = priceDiscParameters.parmAgreementPartnerCode_RU();

                priceDiscParameters.parmAgreementHeaderExt_RU(0);
                priceDiscParameters.parmAgreementPartnerCode_RU('');
            
                discFound = this.findDiscAgreement(relation, _itemMultiLnDisc, _accountMultiLnDisc, '', '', '');
                priceDiscParameters.parmAgreementHeaderExt_RU(recId);
                priceDiscParameters.parmAgreementPartnerCode_RU(custVendAc);
            }
        }
        else
        {
            discFound = this.findDiscAgreement(relation, _itemMultiLnDisc, _accountMultiLnDisc, '', '', '');
        }

        if (_mcrPriceHistoryUpdate
                && MCRPriceHistoryUpdate::isPriceHistoryUpdateEnabled(priceDiscParameters.parmModuleType()))
        {
            _mcrPriceHistoryUpdate.updateMultiline(this);
        }

        return discFound;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPriceAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs trade agreement search.
    /// </summary>
    /// <param name = "_findAll">
    /// A Boolean value that indicates whether to search price with all activated dimensions.
    /// </param>
    /// <param name = "_findProductDim">
    /// A Boolean value that indicates whether to search price with activated product dimensions.
    /// </param>
    /// <param name = "_useItemPrice">
    /// A Boolean value that indicates whether to search item price.
    /// </param>
    /// <param name = "_priceGroupId">
    /// A <c>PriceGroupId</c> value.
    /// </param>
    /// <param name = "_inventDimAllActivated">
    /// A <c>InventDim</c> record buffer.
    /// </param>
    /// <param name = "_inventDimProductDimActivated">
    /// A <c>InventDim</c> record buffer.
    /// </param>
    /// <param name = "_findBlank">
    /// A Boolean value that indicates whether to search price with blank dimensions.
    /// </param>
    /// <returns>
    /// true if the search was successful; otherwise, false.
    /// </returns>
    protected boolean findPriceAgreements(boolean _findAll, boolean _findProductDim, boolean _useItemPrice, PriceGroupId _priceGroupId, InventDim _inventDimAllActivated, InventDim _inventDimProductDimActivated, boolean _findBlank = true)
    {
        return ((_findAll        && _inventDimAllActivated.RecId         && this.findPriceAgreement(_priceGroupId, _inventDimAllActivated.InventDimId)) ||
                (_findProductDim && _inventDimProductDimActivated.RecId  && this.findPriceAgreement(_priceGroupId, _inventDimProductDimActivated.InventDimId)) ||
                (_findBlank      && this.findPriceAgreement(_priceGroupId, InventDim::inventDimIdBlank())) ||
                (_useItemPrice   && this.findItemPrice()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPrice</Name>
				<Source><![CDATA[
    public boolean   findPrice(PriceGroupId _priceGroupId,
                              boolean      _useItemPrice = true)
    {
        boolean     findAll;
        boolean     findProductDim;

        InventDim   inventDimAllActivated;
        InventDim   inventDimProductDimActivated;
        InventDim   inventDimNoneActivated;

        boolean     checkAgreement;

        usedPriceGroupId = _priceGroupId;

        // Remove previously found price agreements
        this.mcrRemovePriceDiscTableList(MCRPriceHistoryType::TradePrice);

        if (priceDiscParameters.parmItemId())
        {
            inventDimAllActivated.initFromInventDim(priceDiscParameters.parmInventDim(), tradeModuleType.activePriceFields(priceDiscParameters.parmItemId()));
            EcoResProductDimGroupSetup::copyProductDimensionsForItem(priceDiscParameters.parmItemId(), inventDimAllActivated, inventDimProductDimActivated);

            checkAgreement = tradeModuleType.isPriceDiscPerAgreementApplicable();

            findAll         = !InventDim::isInventDimEqual(inventDimAllActivated, inventDimProductDimActivated);
            findProductDim  = !InventDim::isInventDimEqual(inventDimProductDimActivated,inventDimNoneActivated);

            inventDimAllActivated           = findAll           ? InventDim::findDim(inventDimAllActivated)         : inventDimAllActivated;
            inventDimProductDimActivated    = findProductDim    ? InventDim::findDim(inventDimProductDimActivated)  : inventDimProductDimActivated;
        }
        boolean ret;

        if (countryRegion_RU)
        {
            ret = (!checkAgreement || this.searchbyAgreement_RU())
                &&
                    (findAll
                        && inventDimAllActivated.RecId
                        && this.findPriceAgreement(_priceGroupId, inventDimAllActivated.InventDimId))
                ||
                    (findProductDim
                        && inventDimProductDimActivated.RecId
                        && this.findPriceAgreement(_priceGroupId, inventDimProductDimActivated.InventDimId))
                ||
                    this.findPriceAgreement(_priceGroupId, InventDim::inventDimIdBlank());
            if (ret)
            {
                return ret;
            }
        }

        AgreementHeaderExtRecId_RU recId;
        CustVendAC custVendAc;

        if (countryRegion_RU)
        {
            recId = priceDiscParameters.parmAgreementHeaderExt_RU();
            custVendAc = priceDiscParameters.parmAgreementPartnerCode_RU();

            priceDiscParameters.parmAgreementHeaderExt_RU(0);
            priceDiscParameters.parmAgreementPartnerCode_RU('');
        }
        
        ret = this.findPriceAgreements(findAll, findProductDim, _useItemPrice, _priceGroupId, inventDimAllActivated, inventDimProductDimActivated, true);

        if (countryRegion_RU)
        {
            priceDiscParameters.parmAgreementHeaderExt_RU(recId);
            priceDiscParameters.parmAgreementPartnerCode_RU(custVendAc);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePriceFromPriceAgreement</Name>
				<Source><![CDATA[
    private void initializePriceFromPriceAgreement(PriceDiscTable _priceDiscTable, PriceType _priceType)
    {
        price     = this.calcCurrencyUnitAmount2CurrencyUnitAmount(_priceDiscTable.price(),  _priceDiscTable);

        if (salesParameters.ApplySmartRoundingAfterConversion
            && _priceType == PriceType::PriceSales
            && _priceDiscTable.Currency != priceDiscParameters.parmCurrencyCode())
        {
            price = PriceDiscSmartRounding::smartRound(price,Currency::find(priceDiscParameters.parmCurrencyCode()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeDeliveryDaysFromPriceAgreement</Name>
				<Source><![CDATA[
    private void initializeDeliveryDaysFromPriceAgreement(PriceDiscTable _priceDiscTable)
    {
        if (_priceDiscTable.DisregardLeadTime)
        {
            this.updateLeadTime(InventItemOrderSetupMap::find(priceDiscParameters.parmItemId(), InventItemOrderSetupMap::module2SetupType(priceDiscParameters.parmModuleType()), priceDiscParameters.parmInventDim().InventDimId));
        }
        else
        {
            deliveryDays        = _priceDiscTable.DeliveryTime;
            calendarDays        = _priceDiscTable.CalendarDays;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculatePriceAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the price from the agreement.
    /// </summary>
    /// <param name = "_priceDiscTable">The <c>PriceDiscTable</c> record to initialize the price related variables from.</param>
    /// <param name = "_priceType">The price type.</param>
    public void calculatePriceAgreement(PriceDiscTable _priceDiscTable, PriceType _priceType)
    {
        priceUnit = _priceDiscTable.priceUnit();
        
        this.initializePriceFromPriceAgreement(_priceDiscTable, _priceType);

        markup                  = this.calcCur2CurPriceAmount(_priceDiscTable.markup(),  _priceDiscTable);

        pdsCalculationId        = _priceDiscTable.pdsCalculationId;

        this.initializeDeliveryDaysFromPriceAgreement(_priceDiscTable);

        // <GEERU>
        inventBaileeFreeDays    = _priceDiscTable.InventBaileeFreeDays_RU;
        // </GEERU>
        actualPriceTable        = _priceDiscTable.data();
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiatePriceDiscPriceAgreementSearchParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates the parameters object for the price agreement search.
    /// </summary>
    /// <returns>An instance of the  parameters for the price agreement search.</returns>
    protected PriceDiscPriceAgreementSearchParameters instantiatePriceDiscPriceAgreementSearchParameters()
    {
        PriceDiscPriceAgreementSearchParameters priceDiscPriceAgreementSearchParameters = PriceDiscPriceAgreementSearchParameters::construct();

        return priceDiscPriceAgreementSearchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPriceAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the price agreements for the given price group and inventory dimension.
    /// </summary>
    /// <param name = "_priceGroupId">A price group value.</param>
    /// <param name = "_inventDimId">An inventory dimension.</param>
    /// <returns>true if a price agreement was found; otherwise, false.</returns>
    public boolean  findPriceAgreement(PriceGroupId        _priceGroupId,
                                       InventDimId         _inventDimId)
    {
        PriceDiscPriceAgreementSearchParameters priceDiscPriceAgreementSearchParameters = this.instantiatePriceDiscPriceAgreementSearchParameters();
        priceDiscPriceAgreementSearchParameters.parmPriceGroupId(_priceGroupId);
        priceDiscPriceAgreementSearchParameters.parmInventDimId(_inventDimId);
        priceDiscPriceAgreementSearchParameters.parmPriceDisc(this);

        PriceDiscPriceAgreementSearch priceDiscPriceAgreementSearch = PriceDiscPriceAgreementSearch::newFromParameters(priceDiscPriceAgreementSearchParameters);
        boolean priceExists = priceDiscPriceAgreementSearch.search();
        
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            priceDiscParameters.parmAgreementExists_RU(priceDiscParameters.parmAgreementHeaderExt_RU() && priceExists);
        }
        
        return priceExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscAmount</Name>
				<Source><![CDATA[
    public DiscAmount  getDiscAmount()
    {
        return discAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscPercent</Name>
				<Source><![CDATA[
    public DiscPct  getDiscPercent()
    {
        return (100 * (1 - (1 - this.getDiscPercent1() / 100) * (1 - this.getDiscPercent2() / 100)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscPercent1</Name>
				<Source><![CDATA[
    public DiscPct  getDiscPercent1()
    {
        return percent1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDiscPercent2</Name>
				<Source><![CDATA[
    public DiscPct  getDiscPercent2()
    {
        return percent2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRoughEndDiscAmount</Name>
				<Source><![CDATA[
    public DiscAmount getRoughEndDiscAmount()
    {
        return roughEndDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventBaileeFreeDays_RU</Name>
				<Source><![CDATA[
    public InventBaileeFreeDays_RU inventBaileeFreeDays_RU()
    {
        return inventBaileeFreeDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isEqual</Name>
				<Source><![CDATA[
    public boolean isEqual(PriceDisc _priceDisc)
    {
        return (_priceDisc.parmPriceDiscParameters().parmModuleType() == priceDiscParameters.parmModuleType()
            && _priceDisc.parmPriceDiscParameters().parmItemId()     == priceDiscParameters.parmItemId()
            && _priceDisc.parmPriceDiscParameters().parmUnitID()     == priceDiscParameters.parmUnitID()
            && _priceDisc.parmPriceDiscParameters().parmPriceDiscDate()  == priceDiscParameters.parmPriceDiscDate()
            && _priceDisc.parmPriceDiscParameters().parmQty()        == priceDiscParameters.parmQty()
            && _priceDisc.parmPriceDiscParameters().parmAccountNum()  == priceDiscParameters.parmAccountNum()
            && _priceDisc.parmPriceDiscParameters().parmCurrencyCode()   == priceDiscParameters.parmCurrencyCode()
            && InventDim::isInventDimEqual(_priceDisc.parmPriceDiscParameters().parmInventDim(), priceDiscParameters.parmInventDim()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemRelation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies the item relation for a given <c>PriceDiscProductCodeType</c> during finding the discount.
    /// </summary>
    /// <param name = "_itemCode">The product code type to return the item id for.</param>
    /// <param name = "_groupId">The price group Id.</param>
    /// <returns>Returns item relation to find the discount for.</returns>
    protected ItemId itemRelation(PriceDiscProductCodeType   _itemCode,
                                  PriceGroupId               _groupId)
    {
        switch (_itemCode)
        {
            case PriceDiscProductCodeType::Table:
                return priceDiscParameters.parmItemId();
            case PriceDiscProductCodeType::GroupId:
                return _groupId;
            default:
                return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemRelationForPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies the item relation for a given <c>PriceDiscProductCodeType</c> during finding the price.
    /// </summary>
    /// <param name = "_itemCode">The product code type to specify the item relation for.</param>
    /// <returns>Returns item relation to find the price for.</returns>
    [Wrappable(true)]
    protected internal ItemId itemRelationForPrice(PriceDiscProductCodeType _itemCode)
    {
        switch (_itemCode)
        {
            case PriceDiscProductCodeType::Table:
                return priceDiscParameters.parmItemId();
            default:
                return '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDiscAmount</Name>
				<Source><![CDATA[
    public DiscAmount  lineDiscAmount()
    {
        return CurrencyExchangeHelper::price(lineDiscAmount * this.priceUnit(), priceDiscParameters.parmCurrencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDiscPct</Name>
				<Source><![CDATA[
    public DiscPct  lineDiscPct()
    {
        return lineDiscPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markup</Name>
				<Source><![CDATA[
    public PriceMarkup  markup()
    {
        return CurrencyExchangeHelper::price(markup, priceDiscParameters.parmCurrencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupSecCur_RU</Name>
				<Source><![CDATA[
    public PriceMarkup  markupSecCur_RU()
    {
        return CurrencyExchangeHelper::price(markupSecCur, CompanyInfoHelper::secondaryCurrency_RU());
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxRetailPrice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets max retail price amount.
    /// </summary>
    /// <returns>
    /// The instance of the <c>PriceCur</c> class.
    /// </returns>
    public PriceCur maxRetailPrice_IN()
    {
        return CurrencyExchangeHelper::price(maxRetailPrice, priceDiscParameters.parmCurrencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMaxRetailPrice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the max retail price for India localization.
    /// </summary>
    /// <param name = "_priceDiscTable">A price discount agreement.</param>
    [Hookable(false)]
    final internal void setMaxRetailPrice_IN(PriceDiscTable _priceDiscTable)
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            // Firstly, retrieve the MRP from the trade agreement. If there is no MRP defined in
            // the trade agreement, the MRP should be retrieved from the item master.
            maxRetailPrice = this.calcCur2CurPriceAmount(
                    _priceDiscTable.MaximumRetailPrice_IN ?
                        _priceDiscTable.MaximumRetailPrice_IN :
                        InventTableModule::find(priceDiscParameters.parmItemId(), priceDiscParameters.parmModuleType()).maxRetailPrice_IN(),
                    _priceDiscTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCalcPostageDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the postage discount.
    /// </summary>
    /// <param name="_acctGroup">
    /// The account group on the that must be verified before the postage
    /// can be calculated.
    /// </param>
    /// <returns>
    /// A <c>Container</c> containing the postage discount amount and the
    /// postage discount percent.
    /// </returns>
    protected internal container mcrCalcPostageDisc(SysGroup _acctGroup)
    {
        CustVendRel accountRelation;

        this.resetDisc();

        PriceDiscPartyCodeTypeOrderedList priceDiscPartyCodeTypeOrderedList = PriceDiscPartyCodeTypeOrderedList::newFromOrder(SortOrder::Ascending);
        ListEnumerator priceDiscPartyCodeTypeEnumerator = priceDiscPartyCodeTypeOrderedList.getEnumerator();
        while (priceDiscPartyCodeTypeEnumerator.moveNext())
        {
            PriceDiscPartyCodeType  accountCode = priceDiscPartyCodeTypeEnumerator.current();
            accountRelation = this.accountRelation(accountCode, _acctGroup);

            if (PriceDiscTable::isPartyCodeProductCodeActivated(PriceType::MCRPostageDisc, accountCode, PriceDiscProductCodeType::All, priceParameters))
            {
                if (PriceDisc::validatePartyRelation(accountCode, accountRelation))
                {
                    this.findDisc(this.instantiatePriceDiscDiscountSearchParameters(PriceType::MCRPostageDisc,
                        InventDim::inventDimIdBlank(),
                        PriceDiscProductCodeType::All, '', // no item relation
                        accountCode, accountRelation, '', // no unit
                        priceDiscParameters.parmQty()));
                }
            }

            if (searchAgain)
            {
                accountCode += 1;
            }
            else
            {
                accountCode = 3;
            }
        }

        return [this.getDiscAmount(), this.getDiscPercent()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPriceDiscTableFound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a trade agreement to the list.
    /// </summary>
    /// <param name="_priceDiscTable">
    /// The <c>PriceDiscTableRecord</c> to add to the list.
    /// </param>
    public void mcrPriceDiscTableFound(PriceDiscTable _priceDiscTable)
    {
        RecordSortedList recordSortedList;

        if (mcrPriceHistoryEnabled)
        {
            recordSortedList = this.parmMCRPriceDiscTableList();
            recordSortedList.ins(_priceDiscTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrRemovePriceDiscTableList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes <c>PriceDiscTable</c> records that are of the same type as the passed <c>MCRriceHistoryType</c>.
    /// </summary>
    /// <param name="_priceHistoryType">
    /// The <c>MCRriceHistoryType</c> value to check for in the <c>PriceDiscTable</c> records.
    /// </param>
    private void mcrRemovePriceDiscTableList(MCRPriceHistoryType _priceHistoryType)
    {
        PriceDiscTable      priceDiscTableLocal;
        RecordSortedList    recordSortedList;
        MCRPriceHistoryType priceHistoryType;
        boolean             loop;

        if (mcrPriceHistoryEnabled)
        {
            recordSortedList = this.parmMCRPriceDiscTableList();

            if (recordSortedList.len() != 0)
            {
                loop = recordSortedList.first(priceDiscTableLocal);

                while (loop)
                {
                    priceHistoryType = MCRPriceHistory::priceType2MCRPriceHistoryType(priceDiscTableLocal.Relation);
                    if (priceHistoryType == _priceHistoryType)
                    {
                        recordSortedList.del(priceDiscTableLocal);
                    }
                    loop = recordSortedList.next(priceDiscTableLocal);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [SysObsolete('This method will be made protected. Please use newFromPriceDiscParameters instead.', true, 30\11\2017)]
    void  new(ModuleInventPurchSales    _moduleType,
              ItemId                    _itemId,
              InventDim                 _inventDim,
              UnitOfMeasureSymbol       _unitID,
              TransDate                 _discDate,
              Qty                       _qty,
              CustVendAC                _accountId,
              CurrencyCode              _currency = CompanyInfoHelper::standardCurrency(),
              AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0,
              CustVendAC                 _agreementPartnerCode    = '',
              PriceDiscParameters        _priceDiscParameters = PriceDiscParameters::construct()
              )
    {
        _priceDiscParameters.parmModuleType(_moduleType);
        _priceDiscParameters.parmItemId(_itemId);
        _priceDiscParameters.parmInventDim(_inventDim);
        _priceDiscParameters.parmUnitID(_unitId);
        _priceDiscParameters.parmPriceDiscDate(_discDate);
        _priceDiscParameters.parmQty(_qty);
        _priceDiscParameters.parmAccountNum(_accountId);
        _priceDiscParameters.parmCurrencyCode(_currency);
        _priceDiscParameters.parmAgreementHeaderExt_RU(_agreementHeaderExtRecId);
        _priceDiscParameters.parmAgreementPartnerCode_RU(_agreementPartnerCode);

        this.parmPriceDiscParameters(_priceDiscParameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initialize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PriceDisc</c> instance.
    /// </summary>
    protected void initialize()
    {
        tradeModuleType     = TradeModuleType::newFromModule(priceDiscParameters.parmModuleType());

        salesParameters     = SalesParameters::find();
        priceParameters     = PriceParameters::find();
        genericCurrency     = salesParameters.GenericCurrency;

        countryRegion_RU    = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        mcrPriceHistoryEnabled = tradeModuleType.isMCRPriceHistoryUpdateEnabled();

        RecordSortedList recordSortedList = new SysRecordSortedList(tableNum(PriceDiscTable));
        recordSortedList.sortOrder(fieldNum(PriceDiscTable, RecId));
        this.parmMCRPriceDiscTableList(recordSortedList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRPriceDiscTableList</Name>
				<Source><![CDATA[
    public SysRecordSortedList parmMCRPriceDiscTableList(
        SysRecordSortedList _recordSortedList = recordSortedListPriceDiscTable)
    {
        recordSortedListPriceDiscTable = _recordSortedList;
        return recordSortedListPriceDiscTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRPriceHistoryPotentialCalc</Name>
				<Source><![CDATA[
    public boolean parmMCRPriceHistoryPotentialCalc(boolean _mcrPriceHistoryPotentialCalc = mcrPriceHistoryPotentialCalc)
    {
        mcrPriceHistoryPotentialCalc = _mcrPriceHistoryPotentialCalc;

        return mcrPriceHistoryPotentialCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrice</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public PriceCur parmPrice(PriceCur _price = price)
    {
        price = _price;

        return price;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPriceDiscParameters</Name>
				<Source><![CDATA[
    public PriceDiscParameters parmPriceDiscParameters(PriceDiscParameters _priceDiscParameters = priceDiscParameters)
    {
        priceDiscParameters = _priceDiscParameters;

        return priceDiscParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPDSCalculationId</Name>
				<Source><![CDATA[
    public PDSCalculationId parmPDSCalculationId(PDSCalculationId _pdsCalculationId = pdsCalculationId)
    {
        pdsCalculationId = _pdsCalculationId;

        return pdsCalculationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTradeModuleType</Name>
				<Source><![CDATA[
    [Hookable(false)]
    final public TradeModuleType parmTradeModuleType()
    {
        return tradeModuleType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percent1</Name>
				<Source><![CDATA[
    public DiscPct percent1()
    {
        return percent1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>percent2</Name>
				<Source><![CDATA[
    public DiscPct percent2()
    {
        return percent2;
    }

]]></Source>
			</Method>
			<Method>
				<Name>price</Name>
				<Source><![CDATA[
    public PriceCur  price()
    {
        return CurrencyExchangeHelper::price(price, priceDiscParameters.parmCurrencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceSecCur_RU</Name>
				<Source><![CDATA[
    public PriceSecCur_RU priceSecCur_RU()
    {
        return CurrencyExchangeHelper::price(priceSecCur, CompanyInfoHelper::secondaryCurrency_RU());
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceTable</Name>
				<Source><![CDATA[
    public PriceDiscTable  priceTable()
    {
        return actualPriceTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceUnit</Name>
				<Source><![CDATA[
    public PriceUnit  priceUnit()
    {
        return priceUnit ? priceUnit : 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetDisc</Name>
				<Source><![CDATA[
    private void  resetDisc()
    {
        lineDiscAmount          = 0;
        lineDiscPct             = 0;
        searchAgain             = NoYes::Yes;
        discAgreementExist      = NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the price.
    /// </summary>
    protected internal void resetPrice()
    {
        price               = 0;
        priceUnit           = 1;
        markup              = 0;
        deliveryDays        = 0;
        calendarDays        = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchbyAgreement_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether an agreement exists for an account combination.
    /// </summary>
    /// <returns>
    ///    A true if agreement exists; otherwise, false.
    /// </returns>
    public boolean searchbyAgreement_RU()
    {
        return priceDiscParameters.parmAgreementHeaderExt_RU() != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLeadTime</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates both delivery days and calendar days from the values set up in the item form.
    /// </summary>
    /// <param name="_inventItemOrderSetupMap">
    ///     The corresponding <c>InventItemOrderSetupMap</c> of the given <c>ItemId</c>, <c>ModuleInventPurchSales</c> and <c>IventDimId</c>.
    /// </param>
    protected void updateLeadTime(InventItemOrderSetupMap _inventItemOrderSetupMap = InventItemOrderSetupMap::find(priceDiscParameters.parmItemId(), InventItemOrderSetupMap::module2SetupType(priceDiscParameters.parmModuleType()), priceDiscParameters.parmInventDim().InventDimId))
    {
        ReqItemTable reqItemTable;

        deliveryDays = _inventItemOrderSetupMap.leadTime();
        calendarDays = _inventItemOrderSetupMap.calendarDays();

        if ( priceDiscParameters.parmModuleType() == ModuleInventPurchSales::Purch )
        {
            reqItemTable = ReqItemTable::find(priceDiscParameters.parmItemId(), InventDim::dimId2ReqCovDimId(priceDiscParameters.parmInventDim().InventDimId, InventDimGroupSetup::newItemId(priceDiscParameters.parmItemId())));
            if ( reqItemTable.RecId && reqItemTable.LeadTimePurchaseActive )
            {
                deliveryDays = reqItemTable.LeadTimePurchase;
                calendarDays = reqItemTable.CalendarDaysPurchase;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>usedPriceGroupId</Name>
				<Source><![CDATA[
    public PriceGroupId usedPriceGroupId()
    {
        return usedPriceGroupId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>actualSalesPriceDisc</Name>
				<Source><![CDATA[
    public static container  actualSalesPriceDisc(CustTable    _custTable,
                                                  InventTable  _inventTable,
                                                  Qty          _qty         = realMin(),
                                                  TransDate    _searchDate  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
                                                  InventDim    _inventDimCriteria = null)
    {
        PriceDisc  priceDisc;

        if (_qty == realMin())
        {
            _qty = _inventTable.salesStandardQty(_inventDimCriteria.inventDimId);
        }

        PriceDiscParameters parameters = PriceDiscParameters::construct();
        parameters.parmModuleType(ModuleInventPurchSales::Sales);
        parameters.parmItemId(_inventTable.ItemId);
        parameters.parmInventDim(_inventDimCriteria);
        parameters.parmUnitID( _inventTable.salesUnitId());
        parameters.parmPriceDiscDate(_searchDate);
        parameters.parmQty(_qty);
        parameters.parmAccountNum(_custTable.AccountNum);
        parameters.parmCurrencyCode(_custTable.Currency);

        priceDisc = PriceDisc::newFromPriceDiscParameters(parameters);

        priceDisc.findPrice(_custTable.PriceGroup);

        priceDisc.findLineDisc(_inventTable.salesLineDisc(), _custTable.LineDisc);

        return [priceDisc.price(),
                priceDisc.markup(),
                priceDisc.priceUnit(),
                priceDisc.lineDiscAmount(),
                priceDisc.lineDiscPct(),
                priceDisc.percent1(),
                priceDisc.percent2(),
                priceDisc.priceTable(),
                priceDisc.discTable()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>amount2Price</Name>
				<Source><![CDATA[
    public static PriceCur  amount2Price(Amount        _amount,
                                                       DiscPct       _discPercent,
                                                       MarkupAmount  _markup,
                                                       Qty           _qty,
                                                       DiscAmount    _discAmount,
                                                       PriceUnit     _priceUnit,
                                                       CurrencyCode  _currencyCode,
                                                       Price         _price)
    {
        Price  returnPrice;

        if (! _priceUnit)
        {
            _priceUnit = 1;
        }

        if (_discPercent     != 100 &&
            _qty             != 0  )
        {
            returnPrice = ( (100 * _amount/ (100 - _discPercent) - (_qty   >= 0 ? _markup : -_markup) + _qty   * _discAmount / _priceUnit) * _priceUnit) / _qty;

            returnPrice = CurrencyExchangeHelper::price(returnPrice, _currencyCode);
        }
        else
        {
            returnPrice = _price;
        }

        return returnPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcGrossAmount</Name>
				<Source><![CDATA[
    public static AmountCur calcGrossAmount(PriceCur       _price,
                                            PriceUnit      _priceUnit,
                                            Qty            _calcQty,
                                            Qty            _totalQty,
                                            MarkupAmount   _markup,
                                            CurrencyCode   _currencyCode,
                                            AmountCur      _lineAmount)
    {
        AmountCur grossAmount = 0;
        if (_calcQty)
        {
            grossAmount = PriceDisc::price2Amount(_price,
                                                  _priceUnit,
                                                  0.0,
                                                  _calcQty,  // sales deliver now
                                                  _totalQty,
                                                  _markup,
                                                  0.0,
                                                  _currencyCode,
                                                  _lineAmount);
        }

        return grossAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discAmount</Name>
				<Source><![CDATA[
    public static DiscAmount discAmount(LineMultiLn  _lineMultiLn,
                                                      DiscAmount   _lineDisc,
                                                      DiscAmount   _multiLnDisc)
    {
        DiscAmount discAmount;

        switch (_lineMultiLn)
        {
            case LineMultiLn::Linie             :   discAmount = _lineDisc;
                break;

            case LineMultiLn::MultiLn           :   discAmount = _multiLnDisc;
                break;

            case LineMultiLn::MaxLineMultiLine  :   discAmount = max(_lineDisc, _multiLnDisc);
                break;

            case LineMultiLn::MinLineMultiLine  :   discAmount = min(_lineDisc, _multiLnDisc);
                break;

            case LineMultiLn::LinePlusMultiLn   :   discAmount = _lineDisc + _multiLnDisc;
                break;

            case LineMultiLn::LineTimesMultiLn  :   discAmount = _lineDisc + _multiLnDisc;
                break;

            default                             :   throw error(strFmt("@SYS19306",funcName()));
        }

        return discAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>discPercent</Name>
				<Source><![CDATA[
    public static DiscPct discPercent(LineMultiLn  _lineMultiLn,
                                                    DiscPct      _linePercent,
                                                    DiscPct      _multiLnPercent)
    {
        DiscPct discPct;

        switch (_lineMultiLn)
        {
            case LineMultiLn::Linie             :   discPct = _linePercent;
                break;

            case LineMultiLn::MultiLn           :   discPct = _multiLnPercent;
                break;

            case LineMultiLn::MaxLineMultiLine  :   discPct = max(_linePercent , _multiLnPercent);
                break;

            case LineMultiLn::MinLineMultiLine  :   discPct = min(_linePercent , _multiLnPercent);
                break;

            case LineMultiLn::LinePlusMultiLn   :   discPct = _linePercent + _multiLnPercent;
                break;

            case LineMultiLn::LineTimesMultiLn  :   discPct = (((1- (100 - _linePercent) / 100 * (100 - _multiLnPercent) / 100)) * 100);
                break;

            default                             :   throw error(strFmt("@SYS19306",funcName()));
        }

        return discPct;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findItemPriceAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the price agreement for a given item.
    /// </summary>
    /// <param name="_moduleType">
    /// The inventory/purchase/sales module for the price agreement.
    /// </param>
    /// <param name="_itemId">
    /// The item ID to locate an agreement for.
    /// </param>
    /// <param name="_inventDim">
    /// The set of inventory dimensions to match.
    /// </param>
    /// <param name="_unitID">
    /// The quantity unit to match.
    /// </param>
    /// <param name="_priceDate">
    /// The date to use to for the effectivity of the price agreement.
    /// </param>
    /// <param name="_qty">
    /// The quantity to match.
    /// </param>
    /// <param name="_accountId">
    /// The currency account ID to match.
    /// </param>
    /// <param name="_currency">
    /// The current ID to match.
    /// </param>
    /// <param name="_priceGroupId">
    /// The price group to match.
    /// </param>
    /// <param name="_agreementHeaderExtRecId">
    /// The ID of the related agreement header record.
    /// </param>
    /// <param name="_agreementPartnerCode">
    /// The ID of the related agreement partner code.
    /// </param>
    /// <returns>
    /// A container with the following: price, markup, price unit, delivery days, calendar days.
    /// PDS feature adds one additional value - the advanced pricing calculation ID.
    /// </returns>
    [SysObsolete('Use the instance method PriceDisc.findPrice instead.', true, 30\11\2017)]
    public static container findItemPriceAgreement(ModuleInventPurchSales  _moduleType,
                                                   ItemId                  _itemId,
                                                   InventDim               _inventDim,
                                                   UnitOfMeasureSymbol     _unitID,
                                                   TransDate               _priceDate,
                                                   Qty                     _qty,
                                                   CustVendAC              _accountId,
                                                   CurrencyCode            _currency,
                                                   PriceGroupId            _priceGroupId,
                                                   AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = 0,
                                                   CustVendAC                 _agreementPartnerCode = ''
                                                   )
    {
        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePriceDiscCache</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal static void removePriceDiscCache(PriceDiscTable _priceDiscTable)
    {
        if (PriceDiscOnlyClearSelectedCacheFlight::instance().isEnabled() && _priceDiscTable.GenericCurrency == NoYes::No)
        {
            PriceDisc::flushSelectedPriceDiscCache(_priceDiscTable);
        }
        else
        {
            PriceDisc::flushPriceDiscCache();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushSelectedPriceDiscCache</Name>
				<Source><![CDATA[
    private static void flushSelectedPriceDiscCache(PriceDiscTable _priceDiscTable)
    {
        PriceDiscParameters priceDiscParameters = PriceDiscParameters::construct();;
        priceDiscParameters.parmUnitID(_priceDiscTable.UnitId);
        priceDiscParameters.parmCurrencyCode(_priceDiscTable.Currency);
        priceDiscParameters.parmAgreementHeaderExt_RU(_priceDiscTable.AgreementHeaderExt_RU);

        PriceDiscCacheKey cacheKey = PriceDiscCacheKey::construct();
        cacheKey.initialize(_priceDiscTable.relation, _priceDiscTable.ItemCode, _priceDiscTable.ItemRelation, _priceDiscTable.AccountCode,
                            _priceDiscTable.AccountRelation, _priceDiscTable.InventDimId, priceDiscParameters);

        PriceDisc::removePriceDiscGlobalObjectCache(cacheKey);

        SalesPurchLineInterface::flushPriceDiscCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePriceDiscGlobalObjectCache</Name>
				<Source><![CDATA[
    private static void removePriceDiscGlobalObjectCache(PriceDiscCacheKey _cacheKey)
    {
        container key = _cacheKey.pack();

        SysGlobalObjectCache sysGlobalObjectCache = new SysGlobalObjectCache();

        if (sysGlobalObjectCache.find(#cacheScope_FindDisc, key) != conNull())
        {
            sysGlobalObjectCache.remove(#cacheScope_FindDisc, key);
        }

        if (sysGlobalObjectCache.find(PriceDiscPriceAgreementSearch::retrieveCacheScope(), key) != conNull())
        {
            sysGlobalObjectCache.remove(PriceDiscPriceAgreementSearch::retrieveCacheScope(), key);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushPriceDiscCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Flushes the server and client-side of the cached prices and discounts.
    /// </summary>
    public static void flushPriceDiscCache()
    {
        PriceDisc::flushPriceDiscCacheServer();
        SalesPurchLineInterface::flushPriceDiscCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushPriceDiscCacheServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Flushes the server side of the cached prices and discounts.
    /// </summary>
    public static void flushPriceDiscCacheServer()
    {
        SysGlobalObjectCache sysGlobalObjectCache = new SysGlobalObjectCache();
        sysGlobalObjectCache.clear(#cacheScope_FindDisc);
        sysGlobalObjectCache.clear(PriceDiscPriceAgreementSearch::retrieveCacheScope());
    }

]]></Source>
			</Method>
			<Method>
				<Name>flushPriceDiscCacheOnTTSCommit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the flush price disc cache event to the tts commited event.
    /// </summary>
    [Hookable(false)]
    public static void flushPriceDiscCacheOnTTSCommit()
    {
        SysTransactionScope transactionScope = appl.transactionScope();
        transactionScope.ttsCommitted += eventhandler(PriceDisc::flushPriceDiscCache);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPriceDiscCacheValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an object from the <c>SysGlobalObjectCache</c> object.
    /// </summary>
    /// <param name="_scope">
    ///    A string type that specifies the scope or the owner of the cached object.
    /// </param>
    /// <param name="_key">
    ///    A container type that specifies the key to the cached object.
    /// </param>
    /// <returns>
    ///    A container type that specifies the retrieved object.
    /// </returns>
    public static container getPriceDiscCacheValue(str _scope, container _key)
    {
        SysGlobalObjectCache sysGlobalObjectCache = new SysGlobalObjectCache();
        return sysGlobalObjectCache.find(_scope, _key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertPriceDiscCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts an object to the <c>SysGlobalObjectCache</c> object.
    /// </summary>
    /// <param name="_scope">
    ///    A string type that specifies the scope or the owner of the cached object.
    /// </param>
    /// <param name="_key">
    ///    A container type that specifies the key to the cached object.
    /// </param>
    /// <param name="_value">
    ///    A container type that has the object to cache.
    /// </param>
    public static void insertPriceDiscCache(str _scope, container _key, container _value)
    {
        SysGlobalObjectCache sysGlobalObjectCache = new SysGlobalObjectCache();
        sysGlobalObjectCache.insert(_scope, _key, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrFindPostageDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds and calculates the amount and percent to discount postage.
    /// </summary>
    /// <param name="_salesTable">
    /// The sales order buffer in which discounting postage.
    /// </param>
    /// <param name="_postageAmount">
    /// The current postage amount.
    /// </param>
    /// <returns>
    /// A container that holds the amount to discount postage and the percentage to discount postage.
    /// </returns>
    public static container mcrFindPostageDisc(SalesTable _salesTable,
                                                AmountCur _postageAmount)
    {
        InventDim inventDim;
        PriceDiscParameters parameters = PriceDiscParameters::construct();
        parameters.parmModuleType(ModuleInventPurchSales::Sales);
        parameters.parmInventDim(inventDim);
        parameters.parmPriceDiscDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        parameters.parmQty(_postageAmount);
        parameters.parmAccountNum(_salesTable.CustAccount);
        parameters.parmCurrencyCode(_salesTable.CurrencyCode);

        PriceDisc priceDisc = PriceDisc::newFromPriceDiscParameters(parameters);

        return priceDisc.mcrCalcPostageDisc(_salesTable.mcrSalesTable().PostageGroupID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPriceDiscTableRecordListDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs the containers for the <c>PriceDiscTable</c> record.
    /// </summary>
    /// <returns>
    /// A container made up of the record ID and table ID of the <c>PriceDiscTable</c> record.
    /// </returns>
    public static container mcrPriceDiscTableRecordListDefinition()
    {
        container sortOrder;
        container result;
        sortOrder = [fieldNum(PriceDiscTable, RecId)];
        result = [tableNum(PriceDiscTable)] + sortOrder;
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromPriceDiscParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>PriceDisc</c> class.
    /// </summary>
    /// <param name = "_parameters">A <c>PriceDiscParameters</c> object.</param>
    /// <returns>An instance of <c>PriceDisc</c>.</returns>
    public static PriceDisc newFromPriceDiscParameters(PriceDiscParameters _parameters)
    {
        if (!_parameters)
        {
            _parameters = PriceDiscParameters::construct();
        }

        PriceDisc priceDisc = new PriceDisc(_parameters.parmModuleType(), _parameters.parmItemId(), _parameters.parmInventDim(), _parameters.parmUnitID(), _parameters.parmPriceDiscDate(),
            _parameters.parmQty(), _parameters.parmAccountNum(), _parameters.parmCurrencyCode(), _parameters.parmAgreementHeaderExt_RU(), _parameters.parmAgreementPartnerCode_RU(), _parameters);

        priceDisc.initialize();

        return priceDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromSalesPurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs a new <c>PriceDisc</c> object for specified line object.
    /// </summary>
    /// <param name="_salesPurchLine">
    ///    The line for which to construct the <c>PriceDisc</c> object.
    /// </param>
    /// <param name="_inventDim">
    ///    The inventory dimension for which to construct the <c>PriceDisc</c> object.
    /// </param>
    /// <param name="_discDate">
    ///    The date for which to construct the <c>PriceDisc</c> object.
    /// </param>
    /// <returns>
    ///    The <c>PriceDisc</c> object constructed for specified parameters.
    /// </returns>
    public static PriceDisc newFromSalesPurchLine(SalesPurchLine  _salesPurchLine,
                                                  InventDim       _inventDim = _salesPurchLine.salesPurchLineInterface().inventDim(),
                                                  TransDate       _priceDiscDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        SalesPurchLineInterface salesPurchLineInterface = _salesPurchLine.salesPurchLineInterface();

        PriceDiscParameters parameters = PriceDiscParameters::construct();
        parameters.initFromSalesPurchLineInterface(salesPurchLineInterface, _inventDim, _priceDiscDate);

        PriceDisc priceDisc = PriceDisc::newFromPriceDiscParameters(parameters);

        return priceDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>price2Amount</Name>
				<Source><![CDATA[
    public static AmountCur  price2Amount(PriceCur         _price,
                                                        PriceUnit        _priceUnit,
                                                        DiscAmount       _discAmount,
                                                        Qty              _qtyNow,
                                                        Qty              _qty,
                                                        MarkupAmount     _markup,
                                                        DiscPct          _discPercent,
                                                        CurrencyCode     _currencyCode,
                                                        Amount           _amount,
                                                        boolean          _forceAmountCalculation = false)
    {
        Amount returnAmount;
        // <GEEPL>
        #ISOCountryRegionCodes
        // </GEEPL>

        if (!_price && !_discAmount && !_discPercent && !_markup && !_forceAmountCalculation)
        {
            if (_qtyNow == _qty)
            {
                return _amount;
            }
            else
            {
                _price = PriceDisc::amount2Price(_amount,
                                                 _discPercent,
                                                 _markup,
                                                 _qty,
                                                 _discAmount,
                                                 _priceUnit,
                                                 _currencyCode,
                                                 _price);
            }
        }

        if (_price  || _discAmount || _discPercent || _markup || _forceAmountCalculation)
        {
            if (!_priceUnit)
            {
                _priceUnit = 1;
            }
            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]) &&
                SalesParameters::find().LineDiscCalculation_PL == PlLineDiscCalcType::PcsPrice &&
                (_discAmount || _markup || _discPercent))
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferencePL00009, funcName());
                if (PriceDisc::isIntercompanyPLFlightEnabled())
                {
                    returnAmount = (_qtyNow / _priceUnit) * CurrencyExchangeHelper::amount((_price - _discAmount + _markup) * (100 - _discPercent) / 100, _currencyCode);
                }
                else 
                {
                    returnAmount = (_qtyNow / _priceUnit) * (_price - _discAmount + _markup) * (100 - _discPercent) / 100;
                }
            }
            else
            {
                // </GEEPL>
                if (PriceDisc::isPriseDiscPriceToAmountRoundingFlightEnabled())
                {
                    returnAmount = (_qtyNow * (_price - _discAmount) / _priceUnit + (_qtyNow >= 0 ? _markup : -_markup) ) * (100 - _discPercent) / 100;
                }
                else
                {
                    returnAmount = (_qtyNow * ((_price - _discAmount) / _priceUnit) + (_qtyNow >= 0 ? _markup : -_markup) ) * (100 - _discPercent) / 100;
                }
                // <GEEPL>
            }

            // </GEEPL>
            returnAmount = CurrencyExchangeHelper::amount(returnAmount, _currencyCode);
        }
        else
        {
            returnAmount = _amount;
        }

        return returnAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyInvolvingPolPrice2Amount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculate intercompany order amount and have option to use Poland calc method or non-Poland calc method
    ///    Poland calc method: Use none intermediate rounding price discount calculation
    /// </summary>
    /// <returns>
    ///    Amount with cash discount.
    /// </returns>
    public static AmountCur intercompanyInvolvingPolPrice2Amount(PriceCur     _price,
                                                        PriceUnit              _priceUnit,
                                                        DiscAmount             _discAmount,
                                                        Qty                    _qtyNow,
                                                        Qty                    _qty,
                                                        MarkupAmount           _markup,
                                                        DiscPct                _discPercent,
                                                        CurrencyCode           _currencyCode,
                                                        Amount                 _amount,
                                                        boolean                _forceAmountCalculation,
                                                        boolean                _shouldUsePolandCalc)
    {
        Amount returnAmount;

        if (!_price && !_discAmount && !_discPercent && !_markup && !_forceAmountCalculation)
        {
            if (_qtyNow == _qty)
            {
                return _amount;
            }
            else
            {
                _price = PriceDisc::amount2Price(_amount,
                                                 _discPercent,
                                                 _markup,
                                                 _qty,
                                                 _discAmount,
                                                 _priceUnit,
                                                 _currencyCode,
                                                 _price);
            }
        }

        if (_price  || _discAmount || _discPercent || _markup || _forceAmountCalculation)
        {
            if (!_priceUnit)
            {
                _priceUnit = 1;
            }
            // <GEEPL>
            if (_shouldUsePolandCalc &&
                (_discAmount || _markup || _discPercent))
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferencePL00009, funcName());
                returnAmount = (_qtyNow / _priceUnit) * CurrencyExchangeHelper::amount((_price - _discAmount + _markup) * (100 - _discPercent) / 100, _currencyCode);
            }
            else
            {
                // </GEEPL>
                if (PriceDisc::isPriseDiscPriceToAmountRoundingFlightEnabled())
                {
                    returnAmount = (_qtyNow * (_price - _discAmount) / _priceUnit + (_qtyNow >= 0 ? _markup : -_markup) ) * (100 - _discPercent) / 100;
                }
                else
                {
                    returnAmount = (_qtyNow * ((_price - _discAmount) / _priceUnit) + (_qtyNow >= 0 ? _markup : -_markup) ) * (100 - _discPercent) / 100;
                }
                // <GEEPL>
            }

            // </GEEPL>
            returnAmount = CurrencyExchangeHelper::amount(returnAmount, _currencyCode);
        }
        else
        {
            returnAmount = _amount;
        }

        return returnAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProductRelation</Name>
				<Source><![CDATA[
    public static boolean  validateProductRelation(PriceDiscProductCodeType _code, str _relation)
    {
        boolean  ok = true;

        if ( _relation  &&  _code == PriceDiscProductCodeType::All)
        {
            ok = false;
        }

        if (!_relation  &&  _code != PriceDiscProductCodeType::All)
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePartyRelation</Name>
				<Source><![CDATA[
    public static boolean  validatePartyRelation(PriceDiscPartyCodeType _code, str _relation)
    {
        boolean  ok = true;

        if ( _relation  &&  _code == PriceDiscPartyCodeType::All)
        {
            ok = false;
        }

        if (!_relation  &&  _code != PriceDiscPartyCodeType::All)
        {
            ok = false;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPriceTypeHandlingUnitAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the price type handles unit amount.
    /// </summary>
    /// <param name = "_priceType">
    /// A <c>PriceType</c> value.
    /// </param>
    /// <returns>
    /// true if the price type handles unit amounts; otherwise, false.
    /// </returns>
    public static boolean isPriceTypeHandlingUnitAmount(PriceType _priceType)
    {
        switch (_priceType)
        {
            case PriceType::EndDiscPurch:
            case PriceType::EndDiscSales:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceTypeRoundingRuleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currency rounding rule type for a price type.
    /// </summary>
    /// <param name = "_priceType">
    /// A <c>PriceType</c> value to retrieve the round rule for.
    /// </param>
    /// <returns>
    /// The currency rounding rule type.
    /// </returns>
    [Hookable(false)]
    public static CurrencyRoundingRuleType priceTypeRoundingRuleType(PriceType _priceType)
    {
        return PriceDisc::isPriceTypeHandlingUnitAmount(_priceType) ? CurrencyRoundingRuleType::Price : CurrencyRoundingRuleType::Amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountId</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public CustVendAC parmAccountId(CustVendAC _accountId = priceDiscParameters.parmAccountNum())
    {
        priceDiscParameters.parmAccountNum(_accountId);
        return priceDiscParameters.parmAccountNum();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgreementHeaderExt_RU</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public AgreementHeaderExtRecId_RU parmAgreementHeaderExt_RU(AgreementHeaderExtRecId_RU _agreementHeaderExtRecId = priceDiscParameters.parmAgreementHeaderExt_RU())
    {
        priceDiscParameters.parmAgreementHeaderExt_RU(_agreementHeaderExtRecId);
        return priceDiscParameters.parmAgreementHeaderExt_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAgreementPartnerCode_RU</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public CustVendAC parmAgreementPartnerCode_RU(CustVendAC _agreementPartnerCode = priceDiscParameters.parmAgreementPartnerCode_RU())
    {
        priceDiscParameters.parmAgreementPartnerCode_RU(_agreementPartnerCode);
        return priceDiscParameters.parmAgreementPartnerCode_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrency</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public CurrencyCode parmCurrency(CurrencyCode _currency = priceDiscParameters.parmCurrencyCode())
    {
        priceDiscParameters.parmCurrencyCode(_currency);
        return priceDiscParameters.parmCurrencyCode();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDiscDate</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public TransDate parmDiscDate(TransDate _discDate = priceDiscParameters.parmPriceDiscDate())
    {
        priceDiscParameters.parmPriceDiscDate(_discDate);
        return priceDiscParameters.parmPriceDiscDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public InventDim parmInventDim(InventDim _inventDim = priceDiscParameters.parmInventDim())
    {
        priceDiscParameters.parmInventDim(_inventDim);
        return priceDiscParameters.parmInventDim();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    [SysObsolete('Use parmPriceDiscParameters instead.', false, 30\11\2017)]
    public ItemId parmItemId(ItemId _itemId = priceDiscParameters.parmItemId())
    {
        priceDiscParameters.parmItemId(_itemId);
        return priceDiscParameters.parmItemId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompanyPLFlightEnabled</Name>
				<Source><![CDATA[
    public static boolean isIntercompanyPLFlightEnabled()
    {
        return IntercompanyOrderUseRootSalesOrderCalcMethod_PL_Flight::instance().isEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPriseDiscPriceToAmountRoundingFlightEnabled</Name>
				<Source><![CDATA[
    public static boolean isPriseDiscPriceToAmountRoundingFlightEnabled()
    {
        return PriseDiscPriceToAmountRoundingFlight::instance().isEnabled();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>