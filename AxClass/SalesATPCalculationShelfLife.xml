<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesATPCalculationShelfLife</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>SalesATPCalculationShelfLife</c> class is a specialized version of the <c>SalesATPCalculation</c> class
/// responsible for available to promise calculation and that takes batch shelf life and disposition status into account.
/// </summary>
public class SalesATPCalculationShelfLife extends SalesATPCalculation
{
    CustAccount custAccount;
    DataAreaId  custAccountDataAreaId;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkBatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a batch disposition code and expiry date.
    /// </summary>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_inventBatchId">
    /// A batch ID.
    /// </param>
    /// <param name="_atpEndDate">
    /// The last date of the ATP calculation.
    /// </param>
    /// <returns>
    /// true if the batch has valid disposition code and it will not expire prior to the last date of the ATP calculation; otherwise, false.
    /// </returns>
    protected boolean checkBatch(
        ItemId          _itemId,
        InventBatchId   _inventBatchId,
        date            _atpEndDate)
    {
        boolean                 validationResult = true;

        // No batch should be considered as a valid entry
        if (!_inventBatchId)
        {
            return validationResult;
        }

        InventBatch inventBatch = InventBatch::find(_inventBatchId, _itemId);
        if (inventBatch.PdsDispositionCode)
        {
            PdsDispositionMaster pdsDispositionMaster = PdsDispositionMaster::find(inventBatch.PdsDispositionCode);

            // Check disposition status
            if (   pdsDispositionMaster.reqPlanRestrictStatus()    == NoYes::No
                || pdsDispositionMaster.salesRestrictStatus()      == NoYes::Yes)
            {
                validationResult = false;
            }
        }

        // Check expiry date
        if (validationResult && !InventBatch::pdsCheckExpiryDate(
            _inventBatchId,
            _itemId,
            _atpEndDate + this.getCustomerSellableDays(_itemId, inventDimId),
            false,
            '',
            false,
            InventDim::find(inventDimId)))
        {
            validationResult = false;
        }

        return validationResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentOnHand</Name>
				<Source><![CDATA[
    protected InventQtyPhysicalOnhand currentOnHand(
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm,
        date            _atpEndDate)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().currentOnHand())
        {
            InventModelGroup        inventModelGroup = InventModelGroupItem::modelGroupByItemIdLegalEntity(_itemId);
            PdsSellableDays         sellableDays = this.getCustomerSellableDays(_itemId);
            InventQty               expiredBatchIssues = this.calculateExpiredBatchIssues(_itemId, _inventDimCriteria, _inventDimParm, _atpEndDate, sellableDays, inventModelGroup);

            return this.currentOnHandWithDipositionNotSet(
                        _itemId,
                        _inventDimCriteria,
                        _inventDimParm,
                        _atpEndDate,
                        sellableDays,
                        inventModelGroup)
                +  this.currentOnHandWithDipositionSetAvailable(
                        _itemId,
                        _inventDimCriteria,
                        _inventDimParm,
                        _atpEndDate,
                        sellableDays,
                        inventModelGroup)
                + expiredBatchIssues;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentOnHandWithDipositionNotSet</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the current on hand without batch disposition code.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The <c>InventDim</c> criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// The <c>InventDimParm</c>.
    /// </param>
    /// <param name="_atpEndDate">
    /// The ATP end date.
    /// </param>
    /// <param name="_sellableDays">
    /// The sellable days.
    /// </param>
    /// <param name="_inventModelGroup">
    /// The inventory model group.
    /// </param>
    /// <returns>
    /// The current on hand without batch disposition code.
    /// </returns>
    protected InventQtyPhysicalOnhand currentOnHandWithDipositionNotSet(
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm,
        date            _atpEndDate,
        PdsSellableDays _sellableDays,
        InventModelGroup _inventModelGroup)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().currentOnHandWithDipositionNotSet())
        {
            InventSum               inventSum;
            InventDim               inventDim;
            InventBatch             inventBatch;

            var validDate = this.getValidDate(_atpEndDate, _sellableDays);
            inventSum.selectLocked(false);

            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                select sum(PostedQty), sum(Received), sum(Deducted), sum(Registered), sum(Picked)
                    from inventSum
                    where   inventSum.ItemId    == _itemId
                        &&  inventSum.ClosedQty == NoYes::No
                        &&  #InventDimFieldsFilter(inventSum, _inventDimCriteria, _inventDimParm)
                exists join inventBatch
                        where   inventBatch.InventBatchId   == inventSum.InventBatchId
                            &&  inventBatch.ItemId          == _itemId
                            &&  InventBatch.PdsDispositionCode == ''
                            && (inventBatch.ExpDate         == dateNull()
                            || ((_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::BestBeforeDate
                            &&   inventBatch.PdsBestBeforeDate      >= validDate)
                            ||  (_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::ExpiryDate
                            &&   inventBatch.ExpDate                >= validDate)));
            }
            else
            {
                select sum(PostedQty), sum(Received), sum(Deducted), sum(Registered), sum(Picked)
                    from inventSum
                    where   inventSum.ItemId    == _itemId
                        &&  inventSum.ClosedQty == NoYes::No
                    #inventDimExistsJoin(inventSum.InventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                exists join inventBatch
                        where   inventBatch.InventBatchId   == inventDim.InventBatchId
                            &&  inventBatch.ItemId          == _itemId
                            &&  InventBatch.PdsDispositionCode == ''
                            && (inventBatch.ExpDate         == dateNull()
                            || ((_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::BestBeforeDate
                            &&   inventBatch.PdsBestBeforeDate      >= validDate)
                            ||  (_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::ExpiryDate
                            &&   inventBatch.ExpDate                >= validDate)));
            }

            return inventSum.physicalInventCalculated();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateExpiredBatchIssues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds issues that are satisfied by expired batches within the demand but before the requested shipping date.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventory dimension parameters that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_atpEndDate">
    /// The ATP end date.
    /// </param>
    /// <param name="_sellableDays">
    /// The customer's sellable days.
    /// </param>
    /// <param name="_inventModelGroup">
    /// The inventory model group.
    /// </param>
    /// <returns>
    /// The positive sum of issues satisfied by expired batches.
    /// </returns>
    private InventQty calculateExpiredBatchIssues(
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm,
        date            _atpEndDate,
        PdsSellableDays _sellableDays,
        InventModelGroup _inventModelGroup)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calculateExpiredBatchIssues())
        {
            date demandStart = this.getDemandStartDate(_atpEndDate);
            date validDate = this.getValidDate(_atpEndDate, _sellableDays);

            if (!this.parmShippingDateRequested())
            {
                return 0;
            }

            Map expiredOnHandMap = this.getExpiredBatchOnHand(_itemId, _inventDimCriteria, _inventDimParm, _inventModelGroup, demandStart, validDate);
            if (expiredOnHandMap.empty())
            {
                return 0;
            }

            return this.getExpiredBatchIssues(_itemId, _inventDimCriteria, _inventDimParm, demandStart, validDate, expiredOnHandMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpiredBatchIssues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts issues that are expected between the demandStart and valid date.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventory dimension parameters that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_demandStart">
    /// The start date of the ATP demand period.
    /// </param>
    /// <param name="_validDate">
    /// The last date before which issues are counted
    /// </param>
    /// <param name="_expiredOnHandMap">
    /// A map linking batch expiration date to expired quantity
    /// </param>
    /// <returns>
    /// The positive sum of issues found in the given period.
    /// </returns>
    private InventQty getExpiredBatchIssues(
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm,
        date            _demandStart,
        date            _validDate,
        Map             _expiredOnHandMap)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().getExpiredBatchIssues())
        {
            SalesATPIssueInventTrans    atpIssueInventTrans;
            InventDim                   inventDim;
            InventDim                   inventDimTransfer;
            InventTransOriginTransfer   inventTransOriginTransfer;
            InventTrans                 inventTransTransfer;
            InventBatch                 inventBatch;
            MapEnumerator enumerator = _expiredOnHandMap.getEnumerator();
            InventQty expiredBatchIssueQuantity = 0;

            while select DateExpected, sum(Qty)
                    from atpIssueInventTrans
                group by DateExpected
                order by DateExpected
                   where atpIssueInventTrans.ItemId == _itemId
                      && atpIssueInventTrans.DateExpected < _validDate
                      && atpIssueInventTrans.DateExpected >= _demandStart
                      && atpIssueInventTrans.InventTransId != this.parmReplacedSalesLineInventTransId()
              outer join inventTransOriginTransfer
                   where inventTransOriginTransfer.IssueInventTransOrigin == atpIssueInventTrans.InventTransOrigin
          notexists join inventTransTransfer
                   where inventTransTransfer.ItemId == itemId
                      && inventTransTransfer.StatusIssue == StatusIssue::None
                      && (inventTransTransfer.StatusReceipt == StatusReceipt::Arrived
                          || inventTransTransfer.StatusReceipt == StatusReceipt::Ordered)
                      && (inventTransTransfer.InventTransOrigin == atpIssueInventTrans.InventTransOrigin
                          || inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.ReceiptInventTransOrigin)
                #inventDimExistsJoin(inventTransTransfer.inventDimId, inventDimTransfer, _inventDimCriteria, _inventDimParm)
            {
                InventQty issueQuantity = atpIssueInventTrans.Qty * -1;
                DateExpected dateExpected = atpIssueInventTrans.DateExpected;
                InventQty quantity = this.calculateExpiredBatchIssueQuantity(_expiredOnHandMap, enumerator, issueQuantity, dateExpected);
                expiredBatchIssueQuantity += quantity;
            }

            return expiredBatchIssueQuantity;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateExpiredBatchIssueQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates how much of the issue's quantity can be covered by expired on-hand batches. 
    /// </summary>
    /// <param name="_expiredOnHandMap">
    /// A map linking batch expiration date to expired quantity.
    /// </param>
    /// <param name="_enumerator">
    /// The map's enumerator instance.
    /// </param>
    /// <param name="_issueQuantity">
    /// The issue's quantity.
    /// </param>
    /// <param name="_dateExpected">
    /// The date the issue is expected.
    /// </param>
    /// <returns>
    /// The positive quantity of the issue that can be covered by expired on-hand.
    /// </returns>
    private InventQty calculateExpiredBatchIssueQuantity(Map _expiredOnHandMap, MapEnumerator _enumerator, InventQty _issueQuantity, DateExpected _dateExpected)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().calculateExpiredBatchIssueQuantity())
        {
            InventQty expiredBatchIssueQuantity = 0;
            _enumerator.reset();
            while(_issueQuantity && _enumerator.moveNext())
            {
                InventBatchExpDate onHandExpirationDate = _enumerator.currentKey();
                InventQtyPhysicalOnhand onHandQuantity = _enumerator.currentValue();
                if (_dateExpected < onHandExpirationDate)
                {
                    InventQty quantity = min(_issueQuantity, onHandQuantity);
                    onHandQuantity -= quantity;
                    _issueQuantity -= quantity;
                    expiredBatchIssueQuantity += quantity;
                    _expiredOnHandMap.insert(onHandExpirationDate, onHandQuantity);
                }
                else
                {
                    break;
                }
            }
            return expiredBatchIssueQuantity;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExpiredBatchOnHand</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates a map of expiration date to the on-hand of batches that expire within the demand start and valid date.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_inventDimParm">
    /// The inventory dimension parameters that are used to calculate demand and supply quantities.
    /// </param>
    /// <param name="_inventModelGroup">
    /// The inventory model group.
    /// </param>
    /// <param name="_demandStart">
    /// The start date of the ATP demand period.
    /// </param>
    /// <param name="_validDate">
    /// The last date before which issues are counted.
    /// </param>
    /// <returns>
    /// A map grouping the batch quantity to its expiration date.
    /// </returns>
    private Map getExpiredBatchOnHand(
        ItemId              _itemId,
        InventDim           _inventDimCriteria,
        InventDimParm       _inventDimParm,
        InventModelGroup    _inventModelGroup,
        date                _demandStart,
        date                _validDate)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().getExpiredBatchOnHand())
        {
            InventSum            inventSum;
            InventBatch          inventBatch;
            InventDim            inventDim;
            PdsDispositionMaster pdsDispositionMaster;
            Map inventMap = new Map(Types::Date, Types::Integer);

            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                while select sum(PostedQty), sum(Received), sum(Deducted), sum(Registered), sum(Picked)
                        from inventSum
                       group by inventBatch.ExpDate
                       order by inventBatch.ExpDate
                       where inventSum.ItemId    == _itemId
                          && inventSum.ClosedQty == NoYes::No
                          && (inventBatch.PdsDispositionCode == '' || pdsDispositionMaster.DispositionCode != '')
                          && #InventDimFieldsFilter(inventSum, _inventDimCriteria, _inventDimParm)
                join ExpDate from inventBatch
                       where   inventBatch.InventBatchId   == inventSum.InventBatchId
                          &&   inventBatch.ItemId          == _itemId
                          && ((_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::BestBeforeDate
                          &&   inventBatch.PdsBestBeforeDate < _validDate
                          &&   inventBatch.PdsBestBeforeDate >= _demandStart)
                          ||  (_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::ExpiryDate
                          &&   inventBatch.ExpDate < _validDate
                          &&   inventBatch.ExpDate >= _demandStart))
                  outer join pdsDispositionMaster
                       where (inventBatch.PdsDispositionCode == pdsDispositionMaster.DispositionCode
                          &&  pdsDispositionMaster.PdsNettable            == NoYes::Yes
                          &&  pdsDispositionMaster.PdsSalesBlockReserve   == NoYes::No
                          &&  pdsDispositionMaster.PdsSalesBlockPick      == NoYes::No
                          &&  pdsDispositionMaster.PdsSalesBlockShip      == NoYes::No)
                {
                    inventMap.insert(inventBatch.expDate, inventSum.physicalInventCalculated());
                }
            }
            else
            {
                while select sum(PostedQty), sum(Received), sum(Deducted), sum(Registered), sum(Picked)
                        from inventSum
                       group by inventBatch.ExpDate
                       order by inventBatch.ExpDate
                       where inventSum.ItemId    == _itemId
                          && inventSum.ClosedQty == NoYes::No
                          && (inventBatch.PdsDispositionCode == '' || pdsDispositionMaster.DispositionCode != '')
                    #inventDimJoin(inventSum.inventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                join ExpDate from inventBatch
                       where   inventBatch.InventBatchId   == inventDim.InventBatchId
                          &&   inventBatch.ItemId          == _itemId
                          && ((_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::BestBeforeDate
                          &&   inventBatch.PdsBestBeforeDate < _validDate
                          &&   inventBatch.PdsBestBeforeDate >= _demandStart)
                          ||  (_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::ExpiryDate
                          &&   inventBatch.ExpDate < _validDate
                          &&   inventBatch.ExpDate >= _demandStart))
                  outer join pdsDispositionMaster
                       where (inventBatch.PdsDispositionCode == pdsDispositionMaster.DispositionCode
                          &&  pdsDispositionMaster.PdsNettable            == NoYes::Yes
                          &&  pdsDispositionMaster.PdsSalesBlockReserve   == NoYes::No
                          &&  pdsDispositionMaster.PdsSalesBlockPick      == NoYes::No
                          &&  pdsDispositionMaster.PdsSalesBlockShip      == NoYes::No)
                {
                    inventMap.insert(inventBatch.expDate, inventSum.physicalInventCalculated());
                }
            }
            
            activityContext
                .addCustomProperty('MapElements', int2Str(inventMap.elements()));

            return inventMap;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentOnHandWithDipositionSetAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the current on hand with batch disposition code available.
    /// </summary>
    /// <param name="_itemId">
    /// The item id.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The <c>InventDim</c> criteria.
    /// </param>
    /// <param name="_inventDimParm">
    /// The <c>InventDimParm</c>.
    /// </param>
    /// <param name="_atpEndDate">
    /// The ATP end date.
    /// </param>
    /// <param name="_sellableDays">
    /// The sellable days.
    /// </param>
    /// <param name="_inventModelGroup">
    /// The inventory model group.
    /// </param>
    /// <returns>
    /// The current on hand with batch disposition code available.
    /// </returns>
    protected InventQtyPhysicalOnhand currentOnHandWithDipositionSetAvailable(
        ItemId          _itemId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm,
        date            _atpEndDate,
        PdsSellableDays _sellableDays,
        InventModelGroup _inventModelGroup)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().currentOnHandWithDipositionSetAvailable())
        {
            InventSum               inventSum;
            InventSum               inventSumEmptyBatch;
            InventDim               inventDim;
            InventDimParm           inventDimParmEmptyBatch;
            InventBatch             inventBatch;
            PdsDispositionMaster    pdsDispositionMaster;

            var validDate = this.getValidDate(_atpEndDate, _sellableDays);
            inventSum.selectLocked(false);

            if (InventUseDimOfInventSumForPublicQueryToggle::instance().isEnabled())
            {
                select sum(PostedQty), sum(Received), sum(Deducted), sum(Registered), sum(Picked)
                    from inventSum
                    where   inventSum.ItemId    == _itemId
                        &&  inventSum.ClosedQty == NoYes::No
                        &&  #InventDimFieldsFilter(inventSum, _inventDimCriteria, _inventDimParm)
                exists join inventBatch
                        where   inventBatch.InventBatchId   == inventSum.InventBatchId
                            &&  inventBatch.ItemId          == _itemId
                            &&  inventBatch.PdsDispositionCode != ''
                            && (inventBatch.ExpDate         == dateNull()
                            || ((_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::BestBeforeDate
                            && inventBatch.PdsBestBeforeDate      >= validDate)
                            ||  (_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::ExpiryDate
                            && inventBatch.ExpDate >= validDate)))
                    exists join pdsDispositionMaster
                            where   inventBatch.PdsDispositionCode              == pdsDispositionMaster.DispositionCode
                                &&  pdsDispositionMaster.PdsNettable            == NoYes::Yes
                                &&  pdsDispositionMaster.PdsSalesBlockReserve   == NoYes::No
                                &&  pdsDispositionMaster.PdsSalesBlockPick      == NoYes::No
                                &&  pdsDispositionMaster.PdsSalesBlockShip      == NoYes::No;
            }
            else
            {
                select sum(PostedQty), sum(Received), sum(Deducted), sum(Registered), sum(Picked)
                    from inventSum
                    where   inventSum.ItemId    == _itemId
                        &&  inventSum.ClosedQty == NoYes::No
                    #inventDimExistsJoin(inventSum.InventDimId, inventDim, _inventDimCriteria, _inventDimParm)
                exists join inventBatch
                        where   inventBatch.InventBatchId   == inventDim.InventBatchId
                            &&  inventBatch.ItemId          == _itemId
                            &&  inventBatch.PdsDispositionCode != ''
                            && (inventBatch.ExpDate         == dateNull()
                            || ((_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::BestBeforeDate
                            && inventBatch.PdsBestBeforeDate      >= validDate)
                            ||  (_inventModelGroup.PdsPickCriteria  == PdsPickCriteria::ExpiryDate
                            && inventBatch.ExpDate >= validDate)))
                    exists join pdsDispositionMaster
                            where   inventBatch.PdsDispositionCode              == pdsDispositionMaster.DispositionCode
                                &&  pdsDispositionMaster.PdsNettable            == NoYes::Yes
                                &&  pdsDispositionMaster.PdsSalesBlockReserve   == NoYes::No
                                &&  pdsDispositionMaster.PdsSalesBlockPick      == NoYes::No
                                &&  pdsDispositionMaster.PdsSalesBlockShip      == NoYes::No;
            }

            // fetch the available for the batch-less InventSum Records
            if (!_inventDimCriteria.inventBatchId)
            {
                inventDimParmEmptyBatch.initFromInventDimParm(_inventDimParm);
                inventDimParmEmptyBatch.InventBatchIdFlag = NoYes::Yes;
                inventSumEmptyBatch = InventSum::findSum(_itemId, _inventDimCriteria, inventDimParmEmptyBatch);
            }

            return inventSum.physicalInventCalculated() + inventSumEmptyBatch.physicalInventCalculated();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValidDate</Name>
				<Source><![CDATA[
    private date getValidDate(
        date            _atpEndDate,
        PdsSellableDays _sellableDays)
    {
        return (this.parmShippingDateRequested() ? min(_atpEndDate, this.parmShippingDateRequested()) : _atpEndDate) + _sellableDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustAccount</Name>
				<Source><![CDATA[
    public CustAccount parmCustAccount(CustAccount _custAccount = custAccount)
    {
        custAccount = _custAccount;

        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustAccountCompany</Name>
				<Source><![CDATA[
    public CustAccount parmCustAccountCompany(DataAreaId _custAccountDataAreaId = custAccountDataAreaId)
    {
        custAccountDataAreaId = _custAccountDataAreaId;

        return custAccountDataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIssues</Name>
				<Source><![CDATA[
    protected void processIssues(
        SalesTmpATP     _salesTmpATP,
        ItemId          _itemId,
        date            _atpEndDate,
        date            _demandStartDate,
        date            _atpDateForPastDemand,
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processIssues())
        {
            SalesATPIssueInventTrans    atpIssueInventTrans;
            InventTransOriginTransfer   inventTransOriginTransfer;
            InventTrans                 inventTransTransfer;
            InventDim                   inventDimTransfer;
            InventDim                   inventDim;
            InventBatch                 inventBatch;

            // Calculate issues - don't include transfers if a corresponding counterpart receipt transaction exist with same grouping inventory dimensions.
            // Notice quarantine orders and wms orders are not linked together by the table inventTransOriginTransfer - instead the receipt and issue inventTrans have same inventTransOrigin.

            while select forceplaceholders DateExpected, sum (Qty) from atpIssueInventTrans
                group by DateExpected
                where atpIssueInventTrans.ItemId == _itemId
                    && atpIssueInventTrans.DateExpected <= _atpEndDate
                    && atpIssueInventTrans.DateExpected >= _demandStartDate
                    && atpIssueInventTrans.InventTransId != _inventTransId
                    && atpIssueInventTrans.InventTransId != this.parmReplacedSalesLineInventTransId()
                #inventDimJoin(atpIssueInventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParm)
            outer join InventBatchId from inventBatch
                    group by InventBatchId
                    where inventBatch.InventBatchId == inventDim.InventBatchId
                        && inventBatch.ItemId == _itemId
                outer join TableId from inventTransOriginTransfer
                    where inventTransOriginTransfer.IssueInventTransOrigin == atpIssueInventTrans.InventTransOrigin
                notexists join inventTransTransfer
                    where inventTransTransfer.ItemId == itemId
                        && inventTransTransfer.StatusIssue == StatusIssue::None
                        && inventTransTransfer.StatusReceipt >= StatusReceipt::Arrived
                        && inventTransTransfer.StatusReceipt <= StatusReceipt::Ordered
                        && (inventTransTransfer.InventTransOrigin == atpIssueInventTrans.InventTransOrigin
                            || inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.ReceiptInventTransOrigin)
                #inventDimExistsJoin(inventTransTransfer.inventDimId,inventDimTransfer,_inventDimCriteria,_inventDimParm)
            {
                if (this.checkBatch(_itemId, inventBatch.InventBatchId, _atpEndDate))
                {
                    this.updateSalesTmpATPWithIssue(
                        _salesTmpATP,
                        atpIssueInventTrans.Qty,
                        atpIssueInventTrans.DateExpected,
                        _atpDateForPastDemand);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPlannedDemand</Name>
				<Source><![CDATA[
    protected void processPlannedDemand(
        SalesTmpATP             _salesTmpATP,
        ItemId                  _itemId,
        ReqPlanVersionRefRecId  _reqPlanVersionRefRecId,
        date                    _atpEndDate,
        date                    _plannedDemandStartDate,
        date                    _atpDateForPastDemand,
        InventTransOriginId     _inventTransOriginId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processPlannedDemand())
        {
            ReqTrans    reqTrans;
            InventDim   inventDim;
            InventBatch inventBatch;

            while select ReqDate, sum (Qty) from reqTrans
                group by ReqDate
                where reqTrans.ItemId                   == _itemId
                   && reqTrans.PlanVersion              == _reqPlanVersionRefRecId
                   && reqTrans.ReqDate                  >= _plannedDemandStartDate
                   && reqTrans.ReqDate                  <= _atpEndDate
                   && reqTrans.IsForecastPurch          == NoYes::No
                   && (reqTrans.InventTransOrigin       != _inventTransOriginId || !_inventTransOriginId)
                   && reqTrans.Qty                      < 0
                   && (reqTrans.RefType == ReqRefType::BOMPlannedOrder
                    || reqTrans.RefType == ReqRefType::PmfFormulaLine
                    || reqTrans.RefType == ReqRefType::PmfPlannedProdBatch
                    || reqTrans.RefType == ReqRefType::ItemPlannedOrder
                    || reqTrans.RefType == ReqRefType::TransferPlannedOrder
                    || reqTrans.RefType == ReqRefType::TransferDemand
                    || reqTrans.RefType == ReqRefType::BOMLine
                    || reqTrans.RefType == ReqRefType::PlannedKanban
                    || reqTrans.RefType == ReqRefType::PlannedKanbanLine)
                #inventDimJoin(reqTrans.CovInventDimId, inventDim, _inventDimCriteria, _inventDimParm)
            outer join InventBatchId from inventBatch
                    group by InventBatchId
                    where   inventBatch.InventBatchId   == inventDim.InventBatchId
                        &&  inventBatch.ItemId          == _itemId
            {
                if (this.checkBatch(_itemId, inventBatch.InventBatchId, _atpEndDate))
                {
                    this.updateSalesTmpATPWithPlannedDemand(
                        _salesTmpATP,
                        reqTrans,
                        _atpDateForPastDemand);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPlannedSupply</Name>
				<Source><![CDATA[
    protected void processPlannedSupply(
        SalesTmpATP             _salesTmpATP,
        ItemId                  _itemId,
        ReqPlanVersionRefRecId  _reqPlanVersionRefRecId,
        date                    _atpEndDate,
        date                    _plannedSupplyStartDate,
        date                    _atpDateForPastSupply,
        InventTransOriginId     _inventTransOriginId,
        InventDim               _inventDimCriteria,
        InventDimParm           _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processPlannedSupply())
        {
            ReqTrans    reqTrans;
            InventDim   inventDim;
            InventBatch inventBatch;

            while select ReqDate, sum (Qty) from reqTrans
                group by ReqDate
                where reqTrans.ItemId                   == _itemId
                   && reqTrans.PlanVersion              == _reqPlanVersionRefRecId
                   && reqTrans.ReqDate                  >= _plannedSupplyStartDate
                   && reqTrans.ReqDate                  <= _atpEndDate
                   && (useSupplyForcastInATPCheckIsEnabled  || reqTrans.IsForecastPurch == NoYes::No)
                   && (reqTrans.InventTransOrigin       != _inventTransOriginId || !_inventTransOriginId)
                   && reqTrans.Qty                      > 0
                   && (reqTrans.RefType == ReqRefType::BOMPlannedOrder
                    || reqTrans.RefType == ReqRefType::PmfFormulaLine
                    || reqTrans.RefType == ReqRefType::PmfPlannedProdBatch
                    || reqTrans.RefType == ReqRefType::ItemPlannedOrder
                    || reqTrans.RefType == ReqRefType::TransferPlannedOrder
                    || reqTrans.RefType == ReqRefType::TransferDemand
                    || reqTrans.RefType == ReqRefType::BOMLine
                    || reqTrans.RefType == ReqRefType::PlannedKanban
                    || reqTrans.RefType == ReqRefType::PlannedKanbanLine)
                #inventDimJoin(reqTrans.CovInventDimId, inventDim, _inventDimCriteria, _inventDimParm)
            outer join InventBatchId from inventBatch
                    group by InventBatchId
                    where   inventBatch.InventBatchId   == inventDim.InventBatchId
                        &&  inventBatch.ItemId          == _itemId
            {
                if (this.checkBatch(_itemId, inventBatch.InventBatchId, _atpEndDate))
                {
                    this.updateSalesTmpATPWithPlannedSupply(
                        _salesTmpATP,
                        reqTrans,
                        _atpDateForPastSupply);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReceipts</Name>
				<Source><![CDATA[
    protected void processReceipts(
        SalesTmpATP     _salesTmpATP,
        ItemId          _itemId,
        date            _atpEndDate,
        date            _supplyStartDate,
        date            _atpDateForPastSupply,
        InventTransId   _inventTransId,
        InventDim       _inventDimCriteria,
        InventDimParm   _inventDimParm)
    {
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().processReceipts())
        {
            SalesATPReceiptInventTrans  atpReceiptInventTrans;
            InventTransOriginTransfer   inventTransOriginTransfer;
            InventTrans                 inventTransTransfer;
            InventDim                   inventDimTransfer;
            InventDim                   inventDim;
            InventBatch                 inventBatch;

            // Calculate receipts - don't include transfers if a corresponding counterpart issue transaction exist with same grouping inventory dimensions.
            // Notice quarantine orders and wms orders are not linked together by the table inventTransOriginTransfer - instead the receipt and issue inventTrans have same inventTransOrigin.

            while select forceplaceholders DateExpected, sum (Qty) from atpReceiptInventTrans
                group by DateExpected
                where atpReceiptInventTrans.ItemId == _itemId
                    && atpReceiptInventTrans.DateExpected <= _atpEndDate
                    && atpReceiptInventTrans.DateExpected >= _supplyStartDate
                    && atpReceiptInventTrans.InventTransId != _inventTransId
                    && atpReceiptInventTrans.InventTransId != this.parmDerivedPurchLineInventTransId()
                #inventDimJoin(atpReceiptInventTrans.inventDimId, inventDim, _inventDimCriteria, _inventDimParm)
            outer join InventBatchId from inventBatch
                    group by InventBatchId
                    where inventBatch.InventBatchId == inventDim.InventBatchId
                        && inventBatch.ItemId == _itemId
                outer join TableId from inventTransOriginTransfer
                    where inventTransOriginTransfer.ReceiptInventTransOrigin == atpReceiptInventTrans.InventTransOrigin
                notexists join inventTransTransfer
                    where inventTransTransfer.ItemId == _itemId
                        && inventTransTransfer.StatusReceipt == StatusReceipt::None
                        && inventTransTransfer.StatusIssue >= StatusIssue::ReservPhysical
                        && inventTransTransfer.StatusIssue <= StatusIssue::OnOrder
                        && (inventTransTransfer.InventTransOrigin == atpReceiptInventTrans.InventTransOrigin
                            || inventTransTransfer.InventTransOrigin == inventTransOriginTransfer.IssueInventTransOrigin)
                #inventDimExistsJoin(inventTransTransfer.inventDimId, inventDimTransfer,_inventDimCriteria,_inventDimParm)
            {
                if (this.checkBatch(_itemId, inventBatch.InventBatchId, _atpEndDate))
                {
                    this.updateSalesTmpATPWithReceipt(
                        _salesTmpATP,
                        atpReceiptInventTrans.Qty,
                        atpReceiptInventTrans.DateExpected,
                        _atpDateForPastSupply);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerSellableDays</Name>
				<Source><![CDATA[
    protected PdsSellableDays getCustomerSellableDays(ItemId _itemId, InventDimId _inventDimId = InventDim::inventDimIdBlank())
    {
        PdsSellableDays sellableDays = 0;
        
        using (SysInstrumentationActivityContext activityContext = this.instrumentationLogger().salesATPCalculationActivities().getCustomerSellableDays())
        {
            if (custAccount)
            {
                InventDim inventDim = InventDim::find(_inventDimId);

                if (custAccountDataAreaId && custAccountDataAreaId != curExt())
                {
                    InventTable item = InventTable::find(_itemId);

                    changecompany(custAccountDataAreaId)
                    {
                        InventDim inventDimInCustomerCompany = InventDim::findOrCreate(inventDim);
                        ItemId    itemIdInCustomerCompany = InventTable::findByProduct(item.Product).ItemId;

                        sellableDays = PdsCustSellableDays::findValidRec(itemIdInCustomerCompany, custAccount, inventDimInCustomerCompany).SellableDays;
                    }
                }
                else
                {
                    sellableDays = PdsCustSellableDays::findValidRec(_itemId, custAccount, inventDim).SellableDays;
                }
            }
        }

        return sellableDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static SalesATPCalculationShelfLife construct()
    {
        return new SalesATPCalculationShelfLife();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>