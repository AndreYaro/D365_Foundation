<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalEngine_Server</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LedgerJournalEngine_Server</c> class supports <c>LedgerJournalEngine</c> objects that have
///    database centered operations, such as tax calculation, cash discount calculation, miscellaneous
///    caches and calculation of journal and voucher totals.
/// </summary>
/// <remarks>
///    This class is the server part of <c>LedgerJournalEngine</c>.
/// </remarks>
public class LedgerJournalEngine_Server implements SysPackable
{
    container           voucherDateCorrect;

    AmountMST           journalTotalCredit;
    AmountMST           journalTotalDebit;
    AmountMST           journalTotalOffset;

    AmountMSTSecondary  journalTotalCreditReportingCurrency;
    AmountMSTSecondary  journalTotalDebitReportingCurrency;

    container           initAccountsCache;
    TmpLedgerTable      tmpLedgerTable;

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
        voucherDateCorrect,
        journalTotalCredit,
        journalTotalDebit,
        journalTotalOffset,
        initAccountsCache,
        tmpLedgerTable
    ENDMACRO

    #ISOCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcTotalTaxAmount</Name>
				<Source><![CDATA[
    public container calcTotalTaxAmount(LedgerJournalTrans       _ledgerJournalTrans,
                                        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                        boolean                  _update,
                                        boolean                  _delete,
                                        container                _amountContainer = conNull())
    {
        AmountMST           amountMST;
        AmountCur           amountCur;
        LedgerJournalTrans  ledgerJournalTrans;
        container           c;

        if (!_update)
        {
            while select JournalNum, Voucher, Invoice from ledgerJournalTrans
            group by ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice
            where ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum   &&
                  ledgerJournalTrans.Voucher    == _ledgerJournalTrans.Voucher      &&
                  ledgerJournalTrans.TransDate  == _ledgerJournalTrans.TransDate    &&
                  ledgerJournalTrans.PurchLedgerPosting == ArrivalPostingType::None
            {
                c = LedgerJournalEngine_Server::calcTaxLedgerJournalTrans(ledgerJournalTrans, _ledgerJournalTrans_Asset, 1, _update);
                amountMST += conPeek(c,1);
                amountCur += conPeek(c,2);
            }
        }
        else
        {
            AmountMST           updatedAmountMST;
            AmountCur           updatedAmountCur;

            if (_delete)
            {
                [amountMST, amountCur] = LedgerJournalEngine_Server::calcTaxLedgerJournalTrans(_ledgerJournalTrans, _ledgerJournalTrans_Asset, -1);

                if (_amountContainer)
                {
                    updatedAmountMST = amountMST + conPeek(_amountContainer, 1);
                    updatedAmountCur = amountCur + conPeek(_amountContainer, 2);

                    [amountMST, amountCur] = conPoke([amountMST, amountCur], 1, updatedAmountMST, updatedAmountCur);
                }

                return [amountMST, amountCur];
            }

            [amountMST, amountCur] = LedgerJournalEngine_Server::calcTaxLedgerJournalTrans(_ledgerJournalTrans.orig().data(), _ledgerJournalTrans_Asset, -1); //calculate tax that should be reversed
            c = LedgerJournalEngine_Server::calcTaxLedgerJournalTrans(_ledgerJournalTrans, _ledgerJournalTrans_Asset); //calculate new tax amounts

            updatedAmountMST = amountMST + conPeek(c, 1);
            updatedAmountCur = amountCur + conPeek(c, 2);

            [amountMST, amountCur] = conPoke([amountMST, amountCur], 1, updatedAmountMST, updatedAmountCur); //find difference

            if (_amountContainer)
            {
                updatedAmountMST = amountMST + conPeek(_amountContainer, 1);
                updatedAmountCur = amountCur + conPeek(_amountContainer, 2);

                [amountMST, amountCur] = conPoke([amountMST, amountCur], 1, updatedAmountMST, updatedAmountCur); //apply diff. on existing tax amount.
            }
        }

        return [amountMST, amountCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBalances</Name>
				<Source><![CDATA[
    public container initBalances(LedgerJournalId _ledgerJournalId, boolean _calc)
    {
        LedgerJournalTable  ledgerJournalTable;
        boolean             addtax;

        voucherDateCorrect  = ['@@',NoYes::No];
        ledgerJournalTable  = LedgerJournalTable::find(_ledgerJournalId);

        if (_calc)
        {
            addtax = this.approvalJournalAmountsIncludeSalesTax(ledgerJournalTable);

            [journalTotalDebit,
             journalTotalCredit,
             journalTotalOffset,
             journalTotalDebitReportingCurrency,
             journalTotalCreditReportingCurrency] = LedgerJournalTable::journalBalanceMST(_ledgerJournalId, addtax, ledgerJournalTable.LedgerJournalInclTax);
        }

        // There is a value that is coming from the journalBalanceMST method but it is invalid.
        // Unfortunately, it appears to be used for some of the Journal totals calculations so I
        // left this code alone and just made a change below to overwrite the value with what is
        // calculated from the createJournalOffsetBalance method as it is correct.
        if (ledgerJournalTable.FixedOffsetAccount && ledgerJournalTable.parmOffsetLedgerDimension())
        {
            journalTotalOffset = LedgerJournalEngine_Server::createJournalOffsetBalance(ledgerJournalTable);
        }

        return [journalTotalDebit, journalTotalCredit, journalTotalOffset, journalTotalDebitReportingCurrency, journalTotalCreditReportingCurrency];
    }

]]></Source>
			</Method>
			<Method>
				<Name>approvalJournalAmountsIncludeSalesTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the invoice approval journal in the given <c>LedgerJournalTable</c> has amounts that include sales tax.
    /// </summary>
    /// <param name = "ledgerJournalTable">The <c>LedgerJournalTable</c> containing the defaulting and state information of the journal.</param>
    /// <returns>True if the journal is of type approval and the amounts in the journal includes sales tax; otherwise, false.</returns>
    private boolean approvalJournalAmountsIncludeSalesTax(LedgerJournalTable ledgerJournalTable)
    {
        boolean isSalesTaxIncluded;

        if (ledgerJournalTable.LedgerJournalInclTax == NoYes::Yes && ledgerJournalTable.JournalType == LedgerJournalType::Approval)
        {
            isSalesTaxIncluded = true;
        }

        return isSalesTaxIncluded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        int version = conPeek(_packedClass, 1);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = _packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Transfers vouchers from the invoice pool into an approval journal.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///    A <c>LedgerJournalTable</c> record buffer for the approval journal.
    /// </param>
    /// <param name="_ledgerJournalTransPool">
    ///    A <c>LedgerJournalTrans</c> record buffer for the voucher to transfer.
    /// </param>
    public static void addVoucher(LedgerJournalTable _ledgerJournalTable, LedgerJournalTrans _ledgerJournalTransPool)
    {
        LedgerJournalId                 vendInvoicePoolJournalId = LedgerJournalTable::findVendorInvoicePool().JournalNum;
        LedgerJournalTrans              ledgerJournalTrans;
        VendTrans                       vendTransPool;
        TransDate                       originalTransDate;
        TransDate                       newTransdate;
        LineNum                         lineNum;
        Voucher                         curVoucher;
        Voucher                         newVoucher;
        boolean                         isVoucherNumberUpdated;

        // <GEEU>
        VatDueDate_W                    poolVATDueDate_W;
        boolean                         isVATDueDate_WInContext;
        // </GEEU>

        if (!_ledgerJournalTransPool || !_ledgerJournalTable)
        {
            throw Exception::Error;
        }

        curVoucher = _ledgerJournalTransPool.Voucher;

        // <GEEU>
        isVATDueDate_WInContext = TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled();
        if (isVATDueDate_WInContext)
        {
            poolVATDueDate_W = _ledgerJournalTransPool.VatDueDate_W;
        }
        // </GEEU>

        ttsbegin;

        select firstonly forupdate vendTransPool
            where vendTransPool.AccountNum == _ledgerJournalTransPool.parmAccount()
               && vendTransPool.Voucher    == _ledgerJournalTransPool.Voucher
               && vendTransPool.TransDate  == _ledgerJournalTransPool.TransDate
               && vendTransPool.Invoice    == _ledgerJournalTransPool.Invoice
               && vendTransPool.Arrival    == NoYes::Yes;

        if (!vendTransPool.RecId)
        {
            throw Exception::Error;
        }

        if (vendInvoicePoolJournalId != vendTransPool.JournalNum)
        {
            throw error(strFmt("@SYS58811", vendTransPool.JournalNum));
        }

        vendTransPool.JournalNum = _ledgerJournalTable.JournalNum;
        vendTransPool.update();

        lineNum = ledgerJournalTrans::lastLineNum(_ledgerJournalTable.JournalNum) + 1;

        while select _ledgerJournalTransPool
            order by LineNum
            where _ledgerJournalTransPool.JournalNum   == vendInvoicePoolJournalId    &&
                  _ledgerJournalTransPool.Voucher      == curVoucher                  &&
                  _ledgerJournalTransPool.AccountType  != LedgerJournalACType::Vend   &&
                  _ledgerJournalTransPool.Invoice      == vendTransPool.Invoice
        {
            originalTransDate = _ledgerJournalTransPool.TransDate;

            newTransdate = LedgerJournalEngine_Server::findNewTransactionDate(_ledgerJournalTable, _ledgerJournalTransPool);

            // <GIT>
            boolean useOriginalVoucher = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]) && VendInvoiceApprovalUseOriginVoucher_ITFlight::instance().isEnabled();
            // </GIT>

            if (originalTransDate != newTransdate && !isVoucherNumberUpdated && !useOriginalVoucher)
            {
                newVoucher = LedgerJournalEngine_Server::getNewVoucher(_ledgerJournalTable, _ledgerJournalTransPool);

                if (!newVoucher)
                {
                    throw error("@SYS26396");
                }
                isVoucherNumberUpdated = true;
            }

            ledgerJournalTrans.data(_ledgerJournalTransPool);
            // <GTH>
            ledgerJournalTrans.SysExtensionSerializerMap::copyExtensionTableData(_ledgerJournalTransPool);
            // </GTH>

            // For invoice approval, offset amount includes tax if 'Apply sales tax taxation rules' is true and it is use tax.
            if (ledgerJournalTrans.PurchLedgerPosting == ArrivalPostingType::Offset && TaxParameters::find().PurchTaxOnOperations)
            {
                // Use original Voucher, Invoice, TransDate, TransactionType
                // to find the <c>LedgerJournalTrans</c> that JournalNum was not transferred,
                // because it can relate <c>TaxTrans</c>.
                LedgerJournalTrans ledgerJournalTransNotTransferred;
                select firstonly ledgerJournalTransNotTransferred
                    where ledgerJournalTransNotTransferred.Voucher == ledgerJournalTrans.Voucher
                        && ledgerJournalTransNotTransferred.Invoice == ledgerJournalTrans.Invoice
                        && ledgerJournalTransNotTransferred.TransDate == ledgerJournalTrans.TransDate
                        && ledgerJournalTransNotTransferred.TransactionType == ledgerJournalTrans.TransactionType
                        && ledgerJournalTransNotTransferred.Transferred == NoYes::No;

                if (Tax::isUseTax(ledgerJournalTransNotTransferred))
                {
                    ledgerJournalTrans.AmountCurCredit -= Tax::taxAmountToSubtract(
                        ledgerJournalTransNotTransferred.Voucher,
                        ledgerJournalTransNotTransferred.TransDate,
                        ledgerJournalTransNotTransferred.RecId);
                }
            }

            ledgerJournalTrans.RecId        = 0;
            ledgerJournalTrans.parmLedgerDimension(_ledgerJournalTransPool.parmLedgerDimension());
            ledgerJournalTrans.LineNum      = lineNum;
            lineNum++;

            if (isVoucherNumberUpdated)
            {
                ledgerJournalTrans.Voucher  = newVoucher;
            }

            ledgerJournalTrans.JournalNum   = _ledgerJournalTable.JournalNum;
            ledgerJournalTrans.PoolRecId    = _ledgerJournalTransPool.RecId;
            ledgerJournalTrans.TransDate    = newTransdate;
            ledgerJournalTrans.Cancel       = NoYes::No;
            ledgerJournalTrans.Approved     = NoYes::Yes;
            ledgerJournalTrans.NoEdit       = NoYes::Yes;
            ledgerJournalTrans.parmOffsetLedgerDimension(0);
            ledgerJournalTrans.TaxGroup     = '';

            if (isVATDueDate_WInContext)
            {
                ledgerJournalTrans.VatDueDate_W = poolVATDueDate_W;
            }

            ledgerJournalTrans.insert();

            // <GIN>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
            {
                LedgerJournalTransTaxExtensionIN    ledgerJournalTransTaxExtensionIN;
                LedgerJournalTrans                  ledgerJournalTransLoc;

                ledgerJournalTransLoc = LedgerJournalTrans::findJournalForVoucher(_ledgerJournalTransPool.Voucher, _ledgerJournalTransPool.TransDate);
                TransTaxInformationHelper::copyTransTaxInformation(ledgerJournalTransLoc, ledgerJournalTrans);

                ledgerJournalTransTaxExtensionIN.LedgerJournalTrans = ledgerJournalTrans.RecId;
                ledgerJournalTransTaxExtensionIN.insert();
            }
            // </GIN>

            LedgerJournalTransTaxExtension::copyLedgerJournalTransTaxExtensionForInvoiceApproval(_ledgerJournalTransPool, ledgerJournalTrans);
        }

        if (!isVoucherNumberUpdated)
        {
            newVoucher = curVoucher;
        }

        if (ledgerJournalTrans != null)
        {
            // At least one approval journal line has been created from the invoice pool for the voucher number.
            // Check budget for the new approval journal lines.
            BudgetControlAccountingJournalProcessor::submitLedgerJournalVoucherToCheckBudget(
                _ledgerJournalTable.JournalType,
                _ledgerJournalTable.JournalNum,
                _ledgerJournalTable.company(),
                newVoucher);
        }

        LedgerJournalVoucherChanged::modifyChangedVoucherDate(_ledgerJournalTable.JournalNum,
                                                              curVoucher,
                                                              originalTransDate,
                                                              newVoucher,
                                                              newTransdate);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNewVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a new journal voucher number.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// A <c>LedgerJournalTable</c> record buffer for the approval journal.
    /// </param>
    /// <param name = "_ledgerJournalTransPool">
    /// A <c>LedgerJournalTrans</c> record buffer for the voucher to transfer.
    /// </param>
    /// <returns>
    /// A string that is a journal voucher number.
    /// </returns>
    protected static Voucher getNewVoucher(LedgerJournalTable _ledgerJournalTable, LedgerJournalTrans _ledgerJournalTransPool)
    {
        Voucher newVoucher = new JournalVoucherNum(JournalTableData::newTable(_ledgerJournalTable)).getNew(false);
        return newVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNewTransactionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the new transaction date for the journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// A <c>LedgerJournalTable</c> record buffer for the approval journal.
    /// </param>
    /// <param name = "_ledgerJournalTransPool">
    /// A <c>LedgerJournalTrans</c> record buffer for the voucher to transfer.
    /// </param>
    /// <returns>
    /// The new transaction date for the journal.
    /// </returns>
    protected static TransDate findNewTransactionDate(LedgerJournalTable _ledgerJournalTable, LedgerJournalTrans _ledgerJournalTransPool)
    {
        TransDate newTransdate;

        if (_ledgerJournalTable.JournalType == LedgerJournalType::Approval)
        {
            newTransdate = LedgerJournalEngine_Server::findNewTransactionDateForApprovalJournal(_ledgerJournalTable, _ledgerJournalTransPool);
        }
        else
        {
            newTransdate = LedgerJournalEngine_Server::findNewTransactionDateForJournal(_ledgerJournalTable, _ledgerJournalTransPool);
        }

        return newTransdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNewTransactionDateForApprovalJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the new transaction date for the approval journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// A <c>LedgerJournalTable</c> record buffer for the approval journal.
    /// </param>
    /// <param name = "_ledgerJournalTransPool">
    /// A <c>LedgerJournalTrans</c> record buffer for the voucher to transfer.
    /// </param>
    /// <returns>
    /// The new transaction date for the approval journal.
    /// </returns>
    protected static TransDate findNewTransactionDateForApprovalJournal(LedgerJournalTable _ledgerJournalTable, LedgerJournalTrans _ledgerJournalTransPool)
    {
        RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();

        SysModule sysModule = _ledgerJournalTable.ledgerJournalName().getSysModuleForJournal();
        if (!LedgerFiscalCalendar::checkLedgerPeriodDateModule(calendarRecId, _ledgerJournalTransPool.TransDate, sysModule, false))
        {
            return LedgerFiscalCalendar::findFirstOpenStartDateModule(calendarRecId, _ledgerJournalTransPool.TransDate, sysModule);
        }

        return LedgerFiscalCalendar::findFirstOpenStartDateInAnyYear(calendarRecId, _ledgerJournalTransPool.TransDate);
     }

]]></Source>
			</Method>
			<Method>
				<Name>findNewTransactionDateForJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the new transaction date for the journal.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// A <c>LedgerJournalTable</c> record buffer for the approval journal.
    /// </param>
    /// <param name = "_ledgerJournalTransPool">
    /// A <c>LedgerJournalTrans</c> record buffer for the voucher to transfer.
    /// </param>
    /// <returns>
    /// The new transaction date for the journal.
    /// </returns>
    protected static TransDate findNewTransactionDateForJournal(LedgerJournalTable _ledgerJournalTable, LedgerJournalTrans _ledgerJournalTransPool)
    {
        RecId calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
        return LedgerFiscalCalendar::findFirstOpenStartDateInYear(calendarRecId, _ledgerJournalTransPool.TransDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustDate</Name>
				<Source><![CDATA[
    public static boolean adjustDate(LedgerJournalTrans _ledgerJournalTrans, LedgerJournalEngine _ledgerJournalEngine = null)
    {
        LedgerJournalTrans  ledgerJournalTransLocal;
        boolean             dateCorrected;
        LedgerJournalTable  ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        // <GCN>
        boolean             isChineseVoucher_CN = LedgerParameters::isChineseVoucher_CN();
        // </GCN>

        ttsbegin;

        while   select  forupdate ledgerJournalTransLocal
                where   ledgerJournalTransLocal.JournalNum == _ledgerJournalTrans.JournalNum &&
                        ledgerJournalTransLocal.Voucher    == _ledgerJournalTrans.Voucher &&
                        ledgerJournalTransLocal.TransDate  != _ledgerJournalTrans.TransDate &&
                        ledgerJournalTransLocal.RecId      != _ledgerJournalTrans.RecId
        {
            ledgerJournalTransLocal.TransDate = _ledgerJournalTrans.TransDate;
            ledgerJournalTransLocal.AcknowledgementDate = _ledgerJournalTrans.AcknowledgementDate;
            ledgerJournalTransLocal.ExchRate = _ledgerJournalTrans.ExchRate;

            // Updating project voucher date when related ledger voucher date is changed.
            if (ledgerJournalTransLocal.AccountType == LedgerJournalACType::Project ||
                ledgerJournalTransLocal.OffsetAccountType == LedgerJournalACType::Project)
            {
                LedgerJournalTrans_Project ledgerJournalTrans_Project;

                select firstonly ledgerJournalTrans_Project
                        where ledgerJournalTrans_Project.RefRecId == ledgerJournalTransLocal.RecId;

                if (ledgerJournalTrans_Project && ledgerJournalTrans_Project.ProjTransDate != ledgerJournalTransLocal.TransDate)
                {
                    ttsbegin;
                    ledgerJournalTrans_Project.selectForUpdate(true);
                    ledgerJournalTrans_Project.ProjTransDate = ledgerJournalTransLocal.TransDate;
                    ledgerJournalTrans_Project.update();
                    ttscommit;
                }
            }

            // <GCN>
            if (isChineseVoucher_CN)
            {
                ledgerJournalTransLocal.Voucher_CN = _ledgerJournalTrans.Voucher_CN;
            }
            // </GCN>

            if (_ledgerJournalEngine)
            {
                _ledgerJournalEngine.currencyModified(ledgerJournalTransLocal);
            }

            ledgerJournalTransLocal.doUpdate();
            dateCorrected = true;

            if (ledgerJournalTransLocal.TaxWithholdGroup)
            {
                new TaxWithhold(ledgerJournalTransLocal).updateAllTaxWithholdTransJournal();
            }
        }

        if (dateCorrected)
        {
            TaxUncommitted::deleteForVoucher(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher);

            // don't calculate taxes if this is marked as posted.  Also, records in the invoice pool don't
            // get Taxes calculated since they have already been posted to TaxTrans.
            // documents in the invoice pool are already posted and should not have taxes calculated.
            if (!ledgerJournalTable.Posted && !(ledgerJournalTable.JournalType == LedgerJournalType::VendInvoicePool))
            {
                LedgerJournalTrans::getTaxInstance(
                    _ledgerJournalTrans.JournalNum,
                    _ledgerJournalTrans.Voucher,
                    _ledgerJournalTrans.Invoice,
                    true,
                    null,
                    false,
                    _ledgerJournalTrans.TransDate);
            }
        }

        ttscommit;

        return dateCorrected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustReleaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>ReleaseDate</c> field values in the <c>LedgerJournalTrans</c> table for records with
    /// the specified journal number and voucher.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table record to use as a basis for the update.
    /// </param>
    /// <remarks>
    /// This method updates all <c>LedgerJournalTrans</c> table records that have the same journal number
    /// and voucher as the supplied <c>LedgerJournalTrans</c> table record. It also sets the value of the
    /// <c>ReleaseDate</c> field to the value from the specified <c>LedgerJournalTrans</c> table record.
    /// </remarks>
    public static void adjustReleaseDate(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans  ledgerJournalTransLocal;
        ledgerJournalTransLocal.skipAosValidation(true);
        ledgerJournalTransLocal.skipDatabaseLog(true);
        ledgerJournalTransLocal.skipDataMethods(true);
        ledgerJournalTransLocal.skipEvents(true);

        update_recordset ledgerJournalTransLocal
            setting  ReleaseDate = _ledgerJournalTrans.ReleaseDate
            where ledgerJournalTransLocal.JournalNum == _ledgerJournalTrans.JournalNum &&
                  ledgerJournalTransLocal.Voucher == _ledgerJournalTrans.Voucher &&
                  ledgerJournalTransLocal.RecId != _ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustRevDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the values of the <c>ReverseEntry</c> and <c>ReverseDate</c> fields of records in the
    /// <c>LedgerJournalTrans</c> table with the specified journal number and voucher.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The record in the <c>LedgerJournalTrans</c> table to use as a basis for the update.
    /// </param>
    /// <remarks>
    /// Updates all records in the <c>LedgerJournalTrans</c> table that have the same journal number and
    /// voucher as on the specified record in the <c>LedgerJournalTrans</c> table; sets the
    /// <c>ReverseEntry</c> and <c>ReverseDate</c> field to the values on the specified record in the
    /// <c>LedgerJournalTrans</c> table.
    /// </remarks>
    public static void adjustRevDate(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans  ledgerJournalTransLocal;
        ledgerJournalTransLocal.skipAosValidation(true);
        ledgerJournalTransLocal.skipDatabaseLog(true);
        ledgerJournalTransLocal.skipDataMethods(true);
        ledgerJournalTransLocal.skipEvents(true);

        update_recordset ledgerJournalTransLocal
            setting  ReverseEntry = _ledgerJournalTrans.ReverseEntry,
                     ReverseDate = _ledgerJournalTrans.ReverseDate
            where ledgerJournalTransLocal.JournalNum == _ledgerJournalTrans.JournalNum &&
                  ledgerJournalTransLocal.Voucher == _ledgerJournalTrans.Voucher &&
                  ledgerJournalTransLocal.RecId != _ledgerJournalTrans.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCashDisc</Name>
				<Source><![CDATA[
    public static void calcCashDisc(LedgerJournalTrans    _ledgerJournalTrans,
                                           TaxAmountJournal      _taxAmountJournal,
                                           boolean               _updateDetail)
    {
        TransDate                       transDate;
        TransDate                       cashDiscBaseDate;
        LedgerJournalCashDiscService    ledgerJournalCashDiscService;
        CustTransCashDisc               custTransCashDisc;
        VendTransCashDisc               vendTransCashDisc;
        boolean                         manual;
        LedgerJournalEngine             ledgerJournalEngine;

        if (TaxParameters::find().CashDiscOnInvoice)
        {
            LedgerJournalEngine_Server::calcCashDiscOnInvoice(_ledgerJournalTrans, _updateDetail);
        }
        else
        {
            ledgerJournalEngine = new LedgerJournalEngine();
            transDate = ledgerJournalEngine.getDueDateBaseDate(_ledgerJournalTrans);

            if (!ledgerJournalCashDiscService)
            {
                ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                                _ledgerJournalTrans.Voucher,
                                                                                _ledgerJournalTrans,
                                                                                _updateDetail);
            }

            manual = _updateDetail;

            if (_ledgerJournalTrans.RecId        &&
                _ledgerJournalTrans.CashDiscCode &&
                _ledgerJournalTrans.amount())
            {
                ttsbegin;

                ledgerJournalCashDiscService.setCashDiscParameters(
                    _ledgerJournalTrans.Company,
                    _ledgerJournalTrans.CashDiscCode,
                    _ledgerJournalTrans.Invoice,
                    _ledgerJournalTrans.AccountType);

                ledgerJournalCashDiscService.setCashDiscPercent(
                    CashDisc::findByCompany(ledgerJournalCashDiscService.getCompany(), ledgerJournalCashDiscService.cashDiscCode()).Percent,
                    _ledgerJournalTrans.AccountType);

                switch (_ledgerJournalTrans.AccountType)
                {
                    case LedgerJournalACType::Cust:
                        cashDiscBaseDate = _ledgerJournalTrans.CashDiscBaseDate ? _ledgerJournalTrans.CashDiscBaseDate : transDate;
                        if (!LedgerJournalCashDiscService::manualCashDiscExist(_ledgerJournalTrans))
                        {
                            custTransCashDisc = custTransCashDisc.calcCashDisc(
                                _ledgerJournalTrans.Company,
                                _ledgerJournalTrans.CurrencyCode,
                                ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans),
                                _ledgerJournalTrans.Due,
                                cashDiscBaseDate,
                                ledgerJournalCashDiscService.cashDiscCode(),
                                _ledgerJournalTrans.TableId,
                                _ledgerJournalTrans.RecId,
                                _updateDetail,
                                _ledgerJournalTrans.CashDiscAmount,
                                _ledgerJournalTrans.DateCashDisc,
                                _ledgerJournalTrans.CashDiscPercent);

                            if (_ledgerJournalTrans.CashDiscCode    == _ledgerJournalTrans.orig().CashDiscCode &&
                                _ledgerJournalTrans.CashDiscAmount  == custTransCashDisc.CashDiscAmount        &&
                                _ledgerJournalTrans.TaxGroup        == _ledgerJournalTrans.orig().TaxGroup)
                            {
                                _updateDetail = true;
                            }
                            _ledgerJournalTrans.CashDiscAmount  = custTransCashDisc.CashDiscAmount;
                            _ledgerJournalTrans.DateCashDisc    = custTransCashDisc.CashDiscdate;
                        }
                        break;

                    case LedgerJournalACType::Vend:
                        if (!LedgerJournalCashDiscService::manualCashDiscExist(_ledgerJournalTrans))
                        {
                            vendTransCashDisc = vendTransCashDisc.calcCashDisc(
                                _ledgerJournalTrans.Company,
                                _ledgerJournalTrans.CurrencyCode,
                                ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans),
                                _ledgerJournalTrans.Due,
                                transDate,
                                ledgerJournalCashDiscService.cashDiscCode(),
                                _ledgerJournalTrans.TableId,
                                _ledgerJournalTrans.RecId,
                                _updateDetail,
                                _ledgerJournalTrans.CashDiscAmount,
                                _ledgerJournalTrans.DateCashDisc,
                                _ledgerJournalTrans.CashDiscPercent);

                            if (_ledgerJournalTrans.CashDiscCode    == _ledgerJournalTrans.orig().CashDiscCode &&
                                _ledgerJournalTrans.CashDiscAmount  == vendTransCashDisc.CashDiscAmount        &&
                                _ledgerJournalTrans.TaxGroup        == _ledgerJournalTrans.orig().TaxGroup)
                            {
                                _updateDetail = true;
                            }
                            _ledgerJournalTrans.CashDiscAmount  = vendTransCashDisc.CashDiscAmount;
                            _ledgerJournalTrans.DateCashDisc    = vendTransCashDisc.CashDiscdate;
                        }
                        break;

                    case LedgerJournalACType::Ledger,
                         LedgerJournalACType::Project,
                         LedgerJournalACType::FixedAssets :
                        _ledgerJournalTrans.CashDiscAmount = ledgerJournalCashDiscService.calcCashDiscAmount(_ledgerJournalTrans);
                        if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval && TaxParameters::find().TaxLessCashDisc)
                        {
                            if (!LedgerJournalCashDiscService::manualCashDiscExist(_ledgerJournalTrans))
                            {
                                vendTransCashDisc = vendTransCashDisc.calcCashDisc(
                                    _ledgerJournalTrans.Company,
                                    _ledgerJournalTrans.CurrencyCode,
                                    ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans),
                                    _ledgerJournalTrans.Due,
                                    transDate,
                                    ledgerJournalCashDiscService.cashDiscCode(),
                                    _ledgerJournalTrans.TableId,
                                    _ledgerJournalTrans.RecId,
                                    _updateDetail,
                                    _ledgerJournalTrans.CashDiscAmount,
                                    _ledgerJournalTrans.DateCashDisc);

                                if (_ledgerJournalTrans.CashDiscCode    == _ledgerJournalTrans.orig().CashDiscCode &&
                                    _ledgerJournalTrans.CashDiscAmount  == vendTransCashDisc.CashDiscAmount        &&
                                    _ledgerJournalTrans.TaxGroup        == _ledgerJournalTrans.orig().TaxGroup)
                                {
                                    _updateDetail = true;
                                }
                                _ledgerJournalTrans.CashDiscAmount  = vendTransCashDisc.CashDiscAmount;
                                _ledgerJournalTrans.DateCashDisc    = vendTransCashDisc.CashDiscdate;
                            }
                        }
                        else
                        {
                            _ledgerJournalTrans.CashDiscAmount = ledgerJournalCashDiscService.calcCashDiscAmount(_ledgerJournalTrans);
                        }
                        break;
                }
                LedgerJournalEngine_Server::updateCashDiscDetail(_ledgerJournalTrans, manual);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcCashDiscOnInvoice</Name>
				<Source><![CDATA[
    private static void calcCashDiscOnInvoice(LedgerJournalTrans _ledgerJournalTrans,
                                                     boolean            _updateDetail)
    {
        TransDate                       transDate                    = _ledgerJournalTrans.DocumentDate ?
                                                                       _ledgerJournalTrans.DocumentDate :
                                                                       _ledgerJournalTrans.TransDate;

        LedgerJournalTrans              ledgerJournalTransOrig       = _ledgerJournalTrans.data();
        LedgerJournalCashDiscService    ledgerJournalCashDiscService;
        CustTransCashDisc               custTransCashDisc;
        VendTransCashDisc               vendTransCashDisc;
        boolean                         manual;
        ;

        // <GTH>
        ledgerJournalTransOrig.SysExtensionSerializerMap::copyExtensionTableData(_ledgerJournalTrans);
        // </GTH>

        if (!ledgerJournalCashDiscService)
        {
            ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                            _ledgerJournalTrans.Voucher,
                                                                            _ledgerJournalTrans,
                                                                            _updateDetail);
        }
        manual = _updateDetail;
        if (_ledgerJournalTrans.RecId &&
            _ledgerJournalTrans.amount())
        {
            ttsbegin;
            if (_ledgerJournalTrans.CashDiscPercent)
            {
                ledgerJournalCashDiscService.setCashDiscPercent(_ledgerJournalTrans.CashDiscPercent,
                                                                _ledgerJournalTrans.AccountType);
            }
            else
            {
                ledgerJournalCashDiscService.setCashDiscPercent(CashDisc::find(ledgerJournalCashDiscService.cashDiscCode()).Percent,
                                                                _ledgerJournalTrans.AccountType);
            }
            ledgerJournalCashDiscService.setCashDiscParameters(
                _ledgerJournalTrans.Company,
                _ledgerJournalTrans.CashDiscCode,
                _ledgerJournalTrans.Invoice,
                _ledgerJournalTrans.AccountType);

            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust:
                    if ( (!LedgerJournalCashDiscService::manualCashDiscExist(_ledgerJournalTrans)
                          && !TaxParameters::find().CashDiscOnInvoice )
                         ||  (TaxParameters::find().CashDiscOnInvoice) )
                    {
                        custTransCashDisc = custTransCashDisc.calcCashDisc(
                            _ledgerJournalTrans.Company,
                            _ledgerJournalTrans.CurrencyCode,
                            ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans),
                            _ledgerJournalTrans.Due,
                            transDate,
                            ledgerJournalCashDiscService.cashDiscCode(),
                            _ledgerJournalTrans.TableId,
                            _ledgerJournalTrans.RecId,
                            _updateDetail,
                            _ledgerJournalTrans.CashDiscAmount,
                            _ledgerJournalTrans.DateCashDisc,
                            _ledgerJournalTrans.CashDiscPercent);

                        if (_ledgerJournalTrans.CashDiscCode    == _ledgerJournalTrans.orig().CashDiscCode &&
                            _ledgerJournalTrans.CashDiscAmount  == custTransCashDisc.CashDiscAmount        &&
                            _ledgerJournalTrans.TaxGroup        == _ledgerJournalTrans.orig().TaxGroup)
                        {
                            _updateDetail = true;
                        }
                        _ledgerJournalTrans.CashDiscAmount  = custTransCashDisc.CashDiscAmount;
                        _ledgerJournalTrans.DateCashDisc    = custTransCashDisc.CashDiscdate;
                        _ledgerJournalTrans.CashDiscPercent = custTransCashDisc.CashDiscPercent;
                    }
                    break;

                case LedgerJournalACType::Vend:
                    if ((!LedgerJournalCashDiscService::manualCashDiscExist(_ledgerJournalTrans)
                        && !TaxParameters::find().CashDiscOnInvoice )
                        ||  (TaxParameters::find().CashDiscOnInvoice) )
                    {
                        vendTransCashDisc = vendTransCashDisc.calcCashDisc(
                            _ledgerJournalTrans.Company,
                            _ledgerJournalTrans.CurrencyCode,
                            ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans),
                            _ledgerJournalTrans.Due,
                            transDate,
                            ledgerJournalCashDiscService.cashDiscCode(),
                            _ledgerJournalTrans.TableId,
                            _ledgerJournalTrans.RecId,
                            _updateDetail,
                            _ledgerJournalTrans.CashDiscAmount,
                            _ledgerJournalTrans.DateCashDisc,
                            _ledgerJournalTrans.CashDiscPercent);

                        if (_ledgerJournalTrans.CashDiscCode    == _ledgerJournalTrans.orig().CashDiscCode &&
                            _ledgerJournalTrans.CashDiscAmount  == vendTransCashDisc.CashDiscAmount        &&
                            _ledgerJournalTrans.TaxGroup        == _ledgerJournalTrans.orig().TaxGroup)
                        {
                            _updateDetail = true;
                        }
                        _ledgerJournalTrans.CashDiscAmount  = vendTransCashDisc.CashDiscAmount;
                        _ledgerJournalTrans.DateCashDisc    = vendTransCashDisc.CashDiscdate;
                        _ledgerJournalTrans.CashDiscPercent = vendTransCashDisc.CashDiscPercent;
                    }
                    break;

                case LedgerJournalACType::Ledger,
                     LedgerJournalACType::Project,
                     LedgerJournalACType::FixedAssets :

                    _ledgerJournalTrans.CashDiscAmount = ledgerJournalCashDiscService.calcCashDiscAmount(_ledgerJournalTrans);
                    _ledgerJournalTrans.CashDiscPercent = CashDisc::find(_ledgerJournalTrans.CashDiscCode).Percent;
                    break;
            }

            LedgerJournalEngine_Server::updateCashDiscDetail(_ledgerJournalTrans, manual);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTaxLedgerJournalTrans</Name>
				<Source><![CDATA[
    private static container calcTaxLedgerJournalTrans(LedgerJournalTrans       _ledgerJournalTrans,
                                                              LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = null,
                                                              Sign                     _sign = 1,
                                                              boolean                  _update = true)
    {
        AmountMST           amountMST;
        AmountCur           amountCur;
        TaxCalculation      taxCalculation;

        if (!_update)
        {
            taxCalculation = LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, true);
        }
        else
        {
            taxCalculation = LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, true, _ledgerJournalTrans);
        }
        amountMST = taxCalculation.totalTaxAmountMST() * _sign;
        amountCur = taxCalculation.totalTaxAmount() * _sign;

        return [amountMST, amountCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcTotalTaxAmount_Packed</Name>
				<Source><![CDATA[
    private static container calcTotalTaxAmount_Packed(container                _packedClass,
                                                              LedgerJournalTrans       _ledgerJournalTrans,
                                                              LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                                              boolean                  _update,
                                                              boolean                  _delete/* = false*/,
                                                              container                _amountContainer = conNull())
    {
        LedgerJournalEngine_Server ljeServer = LedgerJournalEngine_Server::create(_packedClass);
        container                  result = ljeServer.calcTotalTaxAmount(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _update, _delete, _amountContainer);

        return [ljeServer.pack(), result];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForCompleteJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates tax totals for the whole journal.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// A ledger journal ID of the journal for which to calculate tax totals.
    /// </param>
    /// <returns>
    /// A container that contains the definition of the tax totals record sorted list, the data of the
    /// sorted list, and a map with tax amount for each journal line.
    /// </returns>
    /// <remarks>
    /// This method is called by the client side of the <c>LedgerJournalEngine</c> class.
    /// </remarks>
    public static container calculateTaxForCompleteJournal(LedgerJournalId    _ledgerJournalId)
    {
        SysRecordSortedList taxTotals       = new SysRecordSortedList(tableNum(TmpTaxTotals));
        container           taxTotalsSortOrder;
        container           returnValue;
        Map                 taxDisplayCache = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Real);
        LedgerJournalTrans  ledgerJournalTrans;
        TaxAmountCur        taxAmountCur;
        Voucher             lastVoucher;
        InvoiceId           lastInvoiceId;
        TaxCalculation      taxCalculation;
        LedgerJournalTable  ledgerJournalTable = LedgerJournalTable::find(_ledgerJournalId);

        if ((TaxParameters::find().TaxLessCashDisc
                || ledgerJournalTable.isTaxIntegrationEnabled())
            && !TaxUncommitted::existByDocumentId(ledgerJournalTable.TableId, ledgerJournalTable.RecId))
        {
            // Need to recalculate taxes and update cash discounts
            returnValue = LedgerJournalEngine_Server::calculateTaxForJournalLessCashDi(_ledgerJournalId);
        }
        else
        {
            taxTotalsSortOrder = [fieldNum(TmpTaxTotals, TaxCode),
                                  fieldNum(TmpTaxTotals, TaxDirection),
                                  fieldNum(TmpTaxTotals, CurrencyCode)];

            taxTotals.sortOrderFromContainer(taxTotalsSortOrder);

            while select ledgerJournalTrans
                order by Voucher, Invoice
                where ledgerJournalTrans.JournalNum == _ledgerJournalId
            {
                taxAmountCur = 0;

                if (ledgerJournalTrans.isTaxable())
                {
                    if (ledgerJournalTrans.ledgerJournalTable().Posted)
                    {
                        taxAmountCur = Tax::taxTotalsPosted(ledgerJournalTrans.Voucher,
                                                            ledgerJournalTrans.TransDate,
                                                            ledgerJournalTrans.RecId,
                                                            taxTotals);
                    }
                    else
                    {
                        if (lastVoucher != ledgerJournalTrans.Voucher || lastInvoiceId != ledgerJournalTrans.Invoice)
                        {
                            taxCalculation = LedgerJournalTrans::getTaxInstance(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, true);
                            taxCalculation.taxTotals(taxTotals, false);
                        }
                        taxAmountCur = taxCalculation.totalTaxAmountSingleLine(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);

                        lastVoucher = ledgerJournalTrans.Voucher;
                        lastInvoiceId = ledgerJournalTrans.Invoice;
                    }
                }
                taxDisplayCache.insert(ledgerJournalTrans.RecId, taxAmountCur);
            }

            returnValue =  [[tableNum(TmpTaxTotals)] + taxTotalsSortOrder, taxTotals.pack(), taxDisplayCache.pack()];
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTaxForJournalLessCashDi</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the tax totals for the whole journal when the cash discount is affected by tax
    /// calculations.
    /// </summary>
    /// <param name="_ledgerJournalId">
    /// A ledger journal ID of the journal for which to calculate tax totals.
    /// </param>
    /// <returns>
    /// A container that contains the definition of the tax totals record sorted list, the data of the
    /// sorted list, and a map with tax amount for each journal line.
    /// </returns>
    /// <remarks>
    /// This method is called by the client side of the <c>LedgerJournalEngine</c> class. The tax amounts
    /// may get modified by this operation. Therefore, the cash discount will get updated.
    /// </remarks>
    private static container calculateTaxForJournalLessCashDi(LedgerJournalId    _ledgerJournalId)
    {
        SysRecordSortedList taxTotals       = new SysRecordSortedList(tableNum(TmpTaxTotals));
        container           taxTotalsSortOrder;
        Map                 taxDisplayCache = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Real);
        LedgerJournalTrans  ledgerJournalTrans;
        TaxAmountCur        taxAmountCur;
        Voucher             lastVoucher;
        InvoiceId           lastInvoiceId;
        TaxCalculation      taxCalculation;

        Debug::assert(TaxParameters::find().TaxLessCashDisc == true
            || LedgerJournalTable::find(_ledgerJournalId).isTaxIntegrationEnabled());

        taxTotalsSortOrder = [fieldNum(TmpTaxTotals, TaxCode),
                              fieldNum(TmpTaxTotals, TaxDirection),
                              fieldNum(TmpTaxTotals, CurrencyCode)];

        taxTotals.sortOrderFromContainer(taxTotalsSortOrder);

        // need to clear cash discount amount since cash discount calculations depend upon
        // the tax amount and the code below may change the tax amount.
        update_recordset ledgerJournalTrans
        setting CashDiscAmount = 0
        where ledgerJournalTrans.JournalNum == _ledgerJournalId;

        while select forupdate ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalId
        {
            taxAmountCur = 0;

            if (ledgerJournalTrans.isTaxable())
            {
                if (ledgerJournalTrans.ledgerJournalTable().Posted)
                {
                    taxAmountCur = Tax::taxTotalsPosted(ledgerJournalTrans.Voucher,
                                                        ledgerJournalTrans.TransDate,
                                                        ledgerJournalTrans.RecId,
                                                        taxTotals);
                }
                else
                {
                    if (lastVoucher != ledgerJournalTrans.Voucher || lastInvoiceId != ledgerJournalTrans.Invoice)
                    {
                        if (ledgerJournalTrans.isTaxIntegrationEnabled())
                        {
                            taxCalculation = LedgerJournalTrans::getTaxInstance(
                                ledgerJournalTrans.JournalNum,
                                ledgerJournalTrans.Voucher,
                                ledgerJournalTrans.Invoice,
                                true,
                                // pass ledgerJournalTrans as "unsaved" in tax integration to avoid update conflict,
                                // since an update is called lines below.
                                ledgerJournalTrans);
                        }
                        else
                        {
                            taxCalculation = LedgerJournalTrans::getTaxInstance(ledgerJournalTrans.JournalNum, ledgerJournalTrans.Voucher, ledgerJournalTrans.Invoice, true);
                        }
                    }

                    taxCalculation.taxTotals(taxTotals, false);

                    taxAmountCur = taxCalculation.totalTaxAmountSingleLine(ledgerJournalTrans.TableId, ledgerJournalTrans.RecId);

                    // We have a new tax amount so update the cash discount.
                    LedgerJournalEngine_Server::calcCashDisc(ledgerJournalTrans, taxAmountCur, false);
                    ledgerJournalTrans.update();
                }

                lastVoucher = ledgerJournalTrans.Voucher;
                lastInvoiceId = ledgerJournalTrans.Invoice;
            }

            taxDisplayCache.insert(ledgerJournalTrans.RecId, taxAmountCur);
        }

        return [[tableNum(TmpTaxTotals)] + taxTotalsSortOrder, taxTotals.pack(), taxDisplayCache.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualCashDisc</Name>
				<Source><![CDATA[
    public static container calcVirtualCashDisc(LedgerJournalTrans       _ledgerJournalTrans,
                                                       LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                                       TaxAmountJournal         _taxAmountJournal,
                                                       TaxAmountCur             _correctedTaxAmount)
    {
        CashDisc                     cashDisc;
        VendTransCashDisc            vendTransCashDiscLocal;
        CustTransCashDisc            custTransCashDiscLocal;
        TransDate                    cashDiscDate;
        VendCashDiscAmount           cashDiscAmount;
        TransDate                    transDate;
        LedgerJournalTrans           ledgerJournalTransMain;
        LedgerJournalCashDiscService ledgerJournalCashDiscService;

        ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                                                    _ledgerJournalTrans.Voucher,
                                                                                                    _ledgerJournalTrans);
        transDate = _ledgerJournalTrans.DocumentDate ? _ledgerJournalTrans.DocumentDate : _ledgerJournalTrans.TransDate;
        ledgerJournalCashDiscService.setCashDiscParameters(
            _ledgerJournalTrans.Company,
            _ledgerJournalTrans.CashDiscCode,
            _ledgerJournalTrans.Invoice,
            _ledgerJournalTrans.AccountType);

        if (ledgerJournalCashDiscService.cashDiscCode())
        {
            cashDisc = CashDisc::findByCompany(ledgerJournalCashDiscService.getCompany(), ledgerJournalCashDiscService.cashDiscCode());

            ledgerJournalCashDiscService.setCashDiscPercent(
                cashDisc.Percent,
                _ledgerJournalTrans.AccountType);

            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Vend :
                    vendTransCashDiscLocal = VendTransCashDisc::findRef(_ledgerJournalTrans.TableId,
                                                                        _ledgerJournalTrans.RecId);

                    if (vendTransCashDiscLocal.RecId)
                    {
                        cashDiscDate    = vendTransCashDiscLocal.CashDiscdate;
                        cashDiscAmount  = vendTransCashDiscLocal.CashDiscAmount;
                    }
                    else
                    {
                        cashDiscDate    = cashDisc.discDate(transDate);
                        cashDiscAmount  = cashDisc.discAmount(_ledgerJournalTrans.CurrencyCode,
                                                              ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _correctedTaxAmount));
                    }
                    break;

                case LedgerJournalACType::Cust :
                    custTransCashDiscLocal = CustTransCashDisc::findRef(_ledgerJournalTrans.TableId,
                                                                        _ledgerJournalTrans.RecId);

                    if (custTransCashDiscLocal.RecId)
                    {
                        cashDiscDate    = custTransCashDiscLocal.CashDiscdate;
                        cashDiscAmount  = custTransCashDiscLocal.CashDiscAmount;
                    }
                    else
                    {
                        if (_ledgerJournalTrans.CashDiscBaseDate)
                        {
                            transDate = _ledgerJournalTrans.CashDiscBaseDate;
                        }
                        cashDiscDate    = cashDisc.discDate(transDate);
                        cashDiscAmount  = cashDisc.discAmount(_ledgerJournalTrans.CurrencyCode,
                                                              ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _correctedTaxAmount));
                    }

                    break;

                case LedgerJournalACType::Ledger,
                    LedgerJournalACType::Project,
                    LedgerJournalACType::FixedAssets :
                    cashDiscAmount = ledgerJournalCashDiscService.calcCashDiscAmount(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                    if (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Approval && TaxParameters::find().TaxLessCashDisc)
                    {
                        select firstonly ledgerJournalTransMain
                            where ledgerJournalTransMain.JournalNum == _ledgerJournalTrans.JournalNum &&
                                ledgerJournalTransMain.Voucher    == _ledgerJournalTrans.Voucher    &&
                                ledgerJournalTransMain.TransDate  == _ledgerJournalTrans.TransDate  &&
                                ledgerJournalTransMain.PurchLedgerPosting == ArrivalPostingType::Vendor;

                        cashDiscDate = ledgerJournalTransMain ? ledgerJournalTransMain.DateCashDisc : cashDisc.discDate(transDate);
                        cashDiscAmount   = cashDisc.discAmount(_ledgerJournalTrans.CurrencyCode,
                            ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, _ledgerJournalTrans_Asset, _correctedTaxAmount));
                    }
                    else
                    {
                        cashDiscDate = _ledgerJournalTrans.DateCashDisc ?  _ledgerJournalTrans.DateCashDisc : cashDisc.discDate(transDate);
                        cashDiscAmount = ledgerJournalCashDiscService.calcCashDiscAmount(_ledgerJournalTrans, _ledgerJournalTrans_Asset);
                    }
                    break;
            }
        }
        return [cashDiscDate, cashDiscAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcVirtualCashDiscOnInvoice</Name>
				<Source><![CDATA[
    public static container calcVirtualCashDiscOnInvoice(LedgerJournalTrans _ledgerJournalTrans,
                                                                TaxAmountCur       _correctedTaxAmount)
    {
        CashDisc                     cashDisc;
        VendTransCashDisc            vendTransCashDiscLocal;
        CustTransCashDisc            custTransCashDiscLocal;
        TransDate                    cashDiscDate;
        VendCashDiscAmount           cashDiscAmount;
        DiscPct                      cashDiscPercent;
        TransDate                    transDate;
        LedgerJournalCashDiscService ledgerJournalCashDiscService;

        ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                                                    _ledgerJournalTrans.Voucher,
                                                                                                    _ledgerJournalTrans);
        transDate = _ledgerJournalTrans.DocumentDate ? _ledgerJournalTrans.DocumentDate : _ledgerJournalTrans.TransDate;
        ledgerJournalCashDiscService.setCashDiscParameters(_ledgerJournalTrans.Company, _ledgerJournalTrans.CashDiscCode,
                                                           _ledgerJournalTrans.Invoice,
                                                           _ledgerJournalTrans.AccountType);
        if (ledgerJournalCashDiscService.cashDiscCode() || _ledgerJournalTrans.CashDiscPercent )
        {
            cashDisc = CashDisc::findByCompany(ledgerJournalCashDiscService.getCompany(), ledgerJournalCashDiscService.cashDiscCode());

            if (_ledgerJournalTrans.CashDiscPercent)
            {
                ledgerJournalCashDiscService.setCashDiscPercent(_ledgerJournalTrans.CashDiscPercent,
                                                               _ledgerJournalTrans.AccountType);
            }
            else
            {
                ledgerJournalCashDiscService.setCashDiscPercent(cashDisc.Percent, _ledgerJournalTrans.AccountType);
            }

            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Vend:
                    vendTransCashDiscLocal = VendTransCashDisc::findRef(_ledgerJournalTrans.TableId,
                                                                        _ledgerJournalTrans.RecId);

                    if (vendTransCashDiscLocal.RecId)
                    {
                        cashDiscDate       = vendTransCashDiscLocal.CashDiscdate;
                        cashDiscAmount     = vendTransCashDiscLocal.CashDiscAmount;
                        cashDiscPercent    = vendTransCashDiscLocal.CashDiscPercent;
                    }
                    else
                    {
                        cashDiscDate     = cashDisc.discDate(transDate);

                        if (TaxParameters::find().CashDiscOnInvoice)
                        {
                            cashDiscPercent  = _ledgerJournalTrans.CashDiscPercent;
                            cashDiscAmount   = cashDisc.discAmountOnInvoice(_ledgerJournalTrans.CurrencyCode,
                                                                  ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, null, _correctedTaxAmount),
                                                                  cashDiscPercent);
                        }
                        else
                        {
                            cashDiscAmount   = cashDisc.discAmount(_ledgerJournalTrans.CurrencyCode,
                                                                  ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, null, _correctedTaxAmount));
                            cashDiscPercent  = cashDisc.Percent;
                        }
                    }
                    break;

                case LedgerJournalACType::Cust:
                    custTransCashDiscLocal = CustTransCashDisc::findRef(_ledgerJournalTrans.TableId,
                                                                        _ledgerJournalTrans.RecId);

                    if (custTransCashDiscLocal.RecId)
                    {
                        cashDiscDate       = custTransCashDiscLocal.CashDiscdate;
                        cashDiscAmount     = custTransCashDiscLocal.CashDiscAmount;
                        cashDiscPercent    = custTransCashDiscLocal.CashDiscPercent;
                    }
                    else
                    {
                        cashDiscDate     = cashDisc.discDate(transDate);
                        if (TaxParameters::find().CashDiscOnInvoice)
                        {
                            cashDiscPercent  = _ledgerJournalTrans.CashDiscPercent;

                            cashDiscAmount   = cashDisc.discAmountOnInvoice(_ledgerJournalTrans.CurrencyCode,
                                                                            ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, null, _correctedTaxAmount),
                                                                            cashDiscPercent);
                        }
                        else
                        {
                            cashDiscAmount   = cashDisc.discAmount(_ledgerJournalTrans.CurrencyCode,
                                                                   ledgerJournalCashDiscService.cashDiscBaseAmount(_ledgerJournalTrans, null, _correctedTaxAmount));
                            cashDiscPercent  = cashDisc.Percent;
                        }
                    }
                    break;

                case LedgerJournalACType::Ledger,
                     LedgerJournalACType::Project,
                     LedgerJournalACType::FixedAssets :
                    cashDiscAmount = ledgerJournalCashDiscService.calcCashDiscAmount(_ledgerJournalTrans);
                    break;
            }
        }

        return [cashDiscDate, cashDiscAmount, cashDiscPercent];
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerJournalEngine_Server</c> object.
    /// </summary>
    /// <returns>A new instance of the <c>LedgerJournalEngine_Server</c> object.</returns>
    public static LedgerJournalEngine_Server construct()
    {
        return new LedgerJournalEngine_Server();
    }

]]></Source>
			</Method>
			<Method>
				<Name>correctTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Records a tax regulation.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <param name="_taxAmountCur">
    ///    The tax amount.
    /// </param>
    public static void correctTaxAmount(LedgerJournalTrans _ledgerJournalTrans,
                                               TaxAmountCur       _taxAmountCur)
    {
        TaxRegulation taxRegulation    = new TaxRegulation();
        LedgerJournalTable ledgerJournalTable;

        ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();

        TaxUncommitted::deleteForInvoice(ledgerJournalTable.TableId, ledgerJournalTable.RecId, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
        taxRegulation.setTax(LedgerJournalTrans::getTaxInstance(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice, true, _ledgerJournalTrans));
        taxRegulation.setLedgerJournalTrans(_ledgerJournalTrans);
        taxRegulation.createSumsFromTmp();
        taxRegulation.allocateAmount(_taxAmountCur);
        taxRegulation.saveTaxRegulation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    public static LedgerJournalEngine_Server create(container _packedClass)
    {
        LedgerJournalEngine_Server instance = new LedgerJournalEngine_Server();
        instance.unpack(_packedClass);
        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalOffsetBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the balance of this account for the current journal when the journal has a fixed offset
    /// account.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    /// A <c>LedgerJournalTable</c> record buffer.
    /// </param>
    /// <returns>
    /// The balance amount in transaction currency.
    /// </returns>
    /// <remarks>
    /// The balance is the total balance for the account when the account is used both as an account or
    /// offset account.
    /// </remarks>
    public static AmountCur createJournalOffsetBalance(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans                  ledgerJournalTrans;
        CurrencyCode                        currencyCode;
        AmountCur                           amountCur;
        MainAccountRecId                    mainAccount;

        #define.IncludeOnlyOffset(true)

        if (_ledgerJournalTable.FixedOffsetAccount && _ledgerJournalTable.parmOffsetLedgerDimension())
        {
            if (_ledgerJournalTable.OffsetAccountType == LedgerJournalACType::Bank &&
                BankAccountTable::isSingleCurrency(_ledgerJournalTable.parmOffsetAccount(), _ledgerJournalTable.JournalNum))
            {
                currencyCode = BankAccountTable::findByLedgerDimension(_ledgerJournalTable.parmOffsetLedgerDimension()).CurrencyCode;

                select sum(AmountCurDebit), sum(AmountCurCredit) from ledgerJournalTrans
                    where ledgerJournalTrans.JournalNum        == _ledgerJournalTable.JournalNum &&
                          ledgerJournalTrans.OffsetAccountType == _ledgerJournalTable.OffsetAccountType &&
                          ledgerJournalTrans.OffsetLedgerDimension == _ledgerJournalTable.OffsetLedgerDimension  &&
                          ledgerJournalTrans.CurrencyCode      == currencyCode;

                amountCur -= (ledgerJournalTrans.AmountCurDebit - ledgerJournalTrans.AmountCurCredit);
            }
            else if (_ledgerJournalTable.OffsetAccountType == LedgerJournalACType::Ledger)
            {
                mainAccount = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_ledgerJournalTable.OffsetLedgerDimension);
                amountCur = -_ledgerJournalTable.getOffsetBalanceForMainAccount(mainAccount);
            }
            else
            {
                amountCur = _ledgerJournalTable.journalBalanceOnAccount(_ledgerJournalTable.OffsetAccountType, _ledgerJournalTable.OffsetLedgerDimension, #IncludeOnlyOffset);
            }
        }

        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucherBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the balances for a single voucher.
    /// </summary>
    /// <param name="_voucher">
    /// A voucher number.
    /// </param>
    /// <param name="_ledgerJournalId">
    /// A ledger journal ID.
    /// </param>
    /// <returns>
    /// A <c>TmpVoucherSum</c> table record buffer that contains the totals.
    /// </returns>
    public static TmpVoucherSum createVoucherBalance(Voucher         _voucher,
                                                            LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans  ledgerJournalTransLocal;
        TmpVoucherSum       tmpVoucherSum;
        Amount              debitAmount;
        Amount              creditAmount;
        Amount              debitAmountReportingCurrency;
        Amount              creditAmountReportingCurrency;
        CurrencyCode        reportingCurrency = Ledger::reportingCurrency();

        ledgerJournalTransLocal.selectLocked(false);

        // If all transactions match the accounting currency then there
        // is no reason to do currency conversion on each transaction
        select firstonly RecId from ledgerJournalTransLocal where
            ledgerJournalTransLocal.Voucher == _voucher &&
            ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
            ledgerJournalTransLocal.CurrencyCode != Ledger::accountingCurrency();

        ledgerJournalTable = LedgerJournalTable::find(_ledgerJournalId);

        // If the Journal type is reporting currency adjustment the currency conversion will not execute.
        if (ledgerJournalTransLocal && ledgerJournalTable.JournalType != LedgerJournalType::ReportingCurrencyAdjustment)
        {

            // Not everything matches the accounting currency so
            // currency conversion is necessary for those lines
            while select TransDate,
                         CurrencyCode,
                         Triangulation,
                         ExchRate,
                         ExchRateSecond,
                         ReportingCurrencyExchRate,
                         ReportingCurrencyExchRateSecondary,
                         OffsetLedgerDimension,
                         AmountCurCredit,
                         AmountCurDebit,
                         JournalNum,
                         // <GEEU>
                         DocumentDate, // Used in exchange rate date calculation for GEEU
                         VatDueDate_W, // Used in exchange rate date calculation for GEEU
                         TaxGroup,     // Used in exchange rate date calculation for GEEU
                         // </GEEU>
                         Company from    ledgerJournalTransLocal
                index hint NumVoucherIdx
                where ledgerJournalTransLocal.Voucher    == _voucher &&
                      ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                      ledgerJournalTransLocal.CurrencyCode != Ledger::accountingCurrency()
            {
                if (ledgerJournalTransLocal.AmountCurDebit)
                {
                    debitAmount = ledgerJournalTransLocal.calcDebitMST(true, ledgerJournalTable);
                }
                else
                {
                    debitAmount = 0;
                }

                if (ledgerJournalTransLocal.AmountCurCredit)
                {
                    creditAmount = ledgerJournalTransLocal.calcCreditMST(true, ledgerJournalTable);
                }
                else
                {
                    creditAmount = 0;
                }

                tmpVoucherSum.Debit += debitAmount;
                tmpVoucherSum.Credit += creditAmount;

                // Credit and debit are reversed since this is an offset account
                if (ledgerJournalTransLocal.OffsetLedgerDimension != 0)
                {
                    tmpVoucherSum.Debit += creditAmount;
                    tmpVoucherSum.Credit += debitAmount;
                }

                tmpVoucherSum.SumCur += ledgerJournalTransLocal.AmountCurDebit - ledgerJournalTransLocal.AmountCurCredit;
            }

            // For everything that matches the accounting currency, just sum up the amounts

            // Process lines with and without an offset separately because they affect the
            // balance differently and because a single query to do it was more complex and slower

            while select sum(AmountCurCredit),
                         sum(AmountCurDebit)
            from         ledgerJournalTransLocal
            where        ledgerJournalTransLocal.Voucher == _voucher &&
                         ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                         ledgerJournalTransLocal.CurrencyCode == Ledger::accountingCurrency() &&
                         ledgerJournalTransLocal.OffsetLedgerDimension == 0
            {
                tmpVoucherSum.Debit += ledgerJournalTransLocal.AmountCurDebit;
                tmpVoucherSum.Credit += ledgerJournalTransLocal.AmountCurCredit;

                tmpVoucherSum.SumCur += ledgerJournalTransLocal.AmountCurDebit - ledgerJournalTransLocal.AmountCurCredit;
            }

            while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransLocal
                where ledgerJournalTransLocal.JournalNum == _ledgerJournalId
                    && ledgerJournalTransLocal.Voucher == _voucher
                    && ledgerJournalTransLocal.CurrencyCode == Ledger::accountingCurrency()
                    && ledgerJournalTransLocal.OffsetLedgerDimension != 0
            {
                tmpVoucherSum.Debit += ledgerJournalTransLocal.AmountCurDebit;
                tmpVoucherSum.Credit += ledgerJournalTransLocal.AmountCurCredit;

                // Credit and debit are reversed since this is an offset account
                tmpVoucherSum.Debit += ledgerJournalTransLocal.AmountCurCredit;
                tmpVoucherSum.Credit += ledgerJournalTransLocal.AmountCurDebit;

                tmpVoucherSum.SumCur += ledgerJournalTransLocal.AmountCurDebit - ledgerJournalTransLocal.AmountCurCredit;
            }
        }
        else
        {
            // For everything that matches the accounting currency, just sum up the amounts

            // Process lines with and without an offset separately because they affect the
            // balance differently and because a single query to do it was more complex and slower

            while select sum(AmountCurCredit),
                         sum(AmountCurDebit)
            from         ledgerJournalTransLocal
            where        ledgerJournalTransLocal.Voucher == _voucher &&
                         ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                         ledgerJournalTransLocal.OffsetLedgerDimension == 0
            {
                tmpVoucherSum.Debit += ledgerJournalTransLocal.AmountCurDebit;
                tmpVoucherSum.Credit += ledgerJournalTransLocal.AmountCurCredit;

                tmpVoucherSum.SumCur += ledgerJournalTransLocal.AmountCurDebit - ledgerJournalTransLocal.AmountCurCredit;
            }

            while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransLocal
                where ledgerJournalTransLocal.JournalNum == _ledgerJournalId
                    && ledgerJournalTransLocal.Voucher == _voucher
                    && ledgerJournalTransLocal.OffsetLedgerDimension != 0
            {
                tmpVoucherSum.Debit += ledgerJournalTransLocal.AmountCurDebit;
                tmpVoucherSum.Credit += ledgerJournalTransLocal.AmountCurCredit;

                // Credit and debit are reversed since this is an offset account
                tmpVoucherSum.Debit += ledgerJournalTransLocal.AmountCurCredit;
                tmpVoucherSum.Credit += ledgerJournalTransLocal.AmountCurDebit;

                tmpVoucherSum.SumCur += ledgerJournalTransLocal.AmountCurDebit - ledgerJournalTransLocal.AmountCurCredit;
            }
        }

        if (reportingCurrency != '')
        {
            // If reporting currency matches with the accounting currency then there is no reason to calculate the
            // reporting currency balance, because amount value will be same for reporting and accounting currency.
            if (reportingCurrency == Ledger::accountingCurrency())
            {
                //Setting up the reporting currency value to the accounting currency value
                //because the currencies are set to the same currency.
                tmpVoucherSum.DebitReportingCurrency  = tmpVoucherSum.Debit;
                tmpVoucherSum.CreditReportingCurrency = tmpVoucherSum.Credit;
            }
            else
            {
                // If all transactions match the reporting currency then there
                // is no reason to do currency conversion on each transaction
                select firstonly RecId from ledgerJournalTransLocal where
                    ledgerJournalTransLocal.Voucher == _voucher &&
                    ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                    ledgerJournalTransLocal.CurrencyCode != reportingCurrency;

                // If the Journal type is reporting currency adjustment the currency conversion will not execute.
                if (ledgerJournalTransLocal && ledgerJournalTable.JournalType != LedgerJournalType::ReportingCurrencyAdjustment)
                {

                    // Not everything matches the reporting currency so
                    // currency conversion is necessary for those lines
                    while select AccountType,
                                 TransDate,
                                 CurrencyCode,
                                 Triangulation,
                                 ExchRate,
                                 ExchRateSecond,
                                 ReportingCurrencyExchRate,
                                 ReportingCurrencyExchRateSecondary,
                                 OffsetLedgerDimension,
                                 AmountCurCredit,
                                 AmountCurDebit,
                                 JournalNum,
                                 // <GEEU>
                                 DocumentDate, // Used in exchange rate date calculation for GEEU
                                 VatDueDate_W, // Used in exchange rate date calculation for GEEU
                                 TaxGroup,     // Used in exchange rate date calculation for GEEU
                                // </GEEU>
                                Company from    ledgerJournalTransLocal
                        index hint NumVoucherIdx
                        where ledgerJournalTransLocal.Voucher    == _voucher &&
                              ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                              ledgerJournalTransLocal.CurrencyCode != reportingCurrency
                    {
                        if (ledgerJournalTransLocal.AmountCurDebit)
                        {
                            debitAmountReportingCurrency = ledgerJournalTransLocal.calcDebitReportingCurrency(true, ledgerJournalTable);
                        }
                        else
                        {
                            debitAmountReportingCurrency = 0;
                        }

                        if (ledgerJournalTransLocal.AmountCurCredit)
                        {
                            creditAmountReportingCurrency = ledgerJournalTransLocal.calcCreditReportingCurrency(true, ledgerJournalTable);
                        }
                        else
                        {
                            creditAmountReportingCurrency = 0;
                        }

                        tmpVoucherSum.DebitReportingCurrency   += debitAmountReportingCurrency;
                        tmpVoucherSum.CreditReportingCurrency  += creditAmountReportingCurrency;

                        // Credit and debit are reversed since this is an offset account
                        if (ledgerJournalTransLocal.OffsetLedgerDimension != 0)
                        {
                            tmpVoucherSum.DebitReportingCurrency   += creditAmountReportingCurrency;
                            tmpVoucherSum.CreditReportingCurrency  += debitAmountReportingCurrency;
                        }
                    }

                    // For everything that matches the reporting currency, just sum up the amounts

                    // Process lines with and without an offset separately because they affect the
                    // balance differently and because a single query to do it was more complex and slower

                    while select sum(AmountCurCredit),
                                 sum(AmountCurDebit)
                    from         ledgerJournalTransLocal
                    where        ledgerJournalTransLocal.Voucher == _voucher &&
                                 ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                                 ledgerJournalTransLocal.CurrencyCode == reportingCurrency &&
                                 ledgerJournalTransLocal.OffsetLedgerDimension == 0
                    {
                        tmpVoucherSum.DebitReportingCurrency   += ledgerJournalTransLocal.AmountCurDebit;
                        tmpVoucherSum.CreditReportingCurrency  += ledgerJournalTransLocal.AmountCurCredit;
                    }

                    while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransLocal
                        where ledgerJournalTransLocal.JournalNum == _ledgerJournalId
                            && ledgerJournalTransLocal.Voucher == _voucher
                            && ledgerJournalTransLocal.CurrencyCode == reportingCurrency
                            && ledgerJournalTransLocal.OffsetLedgerDimension != 0
                    {
                        tmpVoucherSum.DebitReportingCurrency   += ledgerJournalTransLocal.AmountCurDebit;
                        tmpVoucherSum.CreditReportingCurrency  += ledgerJournalTransLocal.AmountCurCredit;

                        // Credit and debit are reversed since this is an offset account
                        tmpVoucherSum.DebitReportingCurrency   += ledgerJournalTransLocal.AmountCurCredit;
                        tmpVoucherSum.CreditReportingCurrency  += ledgerJournalTransLocal.AmountCurDebit;
                    }
                }
                else
                {
                    // For everything that matches the reporting currency, just sum up the amounts

                    // Process lines with and without an offset separately because they affect the
                    // balance differently and because a single query to do it was more complex and slower

                    while select sum(AmountCurCredit),
                                 sum(AmountCurDebit)
                    from         ledgerJournalTransLocal
                    where        ledgerJournalTransLocal.Voucher == _voucher &&
                                 ledgerJournalTransLocal.JournalNum == _ledgerJournalId &&
                                 ledgerJournalTransLocal.OffsetLedgerDimension == 0
                    {
                        tmpVoucherSum.DebitReportingCurrency += ledgerJournalTransLocal.AmountCurDebit;
                        tmpVoucherSum.CreditReportingCurrency += ledgerJournalTransLocal.AmountCurCredit;
                    }

                    while select sum(AmountCurCredit), sum(AmountCurDebit) from ledgerJournalTransLocal
                        where ledgerJournalTransLocal.JournalNum == _ledgerJournalId
                            && ledgerJournalTransLocal.Voucher == _voucher
                            && ledgerJournalTransLocal.OffsetLedgerDimension != 0
                    {
                        tmpVoucherSum.DebitReportingCurrency  += ledgerJournalTransLocal.AmountCurDebit;
                        tmpVoucherSum.CreditReportingCurrency  += ledgerJournalTransLocal.AmountCurCredit;

                        // Credit and debit are reversed since this is an offset account
                        tmpVoucherSum.DebitReportingCurrency  += ledgerJournalTransLocal.AmountCurCredit;
                        tmpVoucherSum.CreditReportingCurrency  += ledgerJournalTransLocal.AmountCurDebit;
                    }
                }
            }
        }

        tmpVoucherSum.Voucher = _voucher;

        return tmpVoucherSum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyModified</Name>
				<Source><![CDATA[
    public static container currencyModified(LedgerJournalTrans _ledgerJournalTrans,
                                                    boolean            _selectTriangulation = true)
    {
        UnknownNoYes      triangulation;
        ExchRate          exchRate;
        ExchRate          exchRateSecond;
        ExchRateSecondTxt exchRateSecondTxt;
        // <GEEU>
        TransDate         exchRateDate;
        // </GEEU>

        if (_ledgerJournalTrans.CurrencyCode)
        {
            try
            {
                // <GEEU>
                exchRateDate = _ledgerJournalTrans.exchRateDate_W();
                // </GEEU>
                if (_selectTriangulation)
                {
                    triangulation = Currency::noYes2UnknownNoYes(Currency::triangulation(_ledgerJournalTrans.CurrencyCode,
                                                                 // <GEEU>
                                                                 exchRateDate));
                                                                 // </GEEU>
                }
                else
                {
                    triangulation = Currency::noYes2UnknownNoYes(_ledgerJournalTrans.Triangulation);
                }
                if (triangulation == UnknownNoYes::Yes && !Currency::findEuroCurrencyCode())
                {
                    throw error("@SYS70752");
                }

                exchRate = ExchangeRateHelper::exchRate(_ledgerJournalTrans.CurrencyCode, exchRateDate, triangulation);

                exchRateSecond = ExchangeRateHelper::exchRateSecond(_ledgerJournalTrans.CurrencyCode, exchRateDate, triangulation);

                exchRateSecondTxt = _ledgerJournalTrans.exchRateTxt();
            }
            catch
            {
                exchRate = 0.0;
                exchRateSecond = 0.0;
                triangulation = UnknownNoYes::No;
                exchRateSecondTxt = '';
            }
        }

        return [triangulation,exchRate, exchRateSecond, exchRateSecondTxt];
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defaults the reporting currency exchange rate values when CurrencyCode field is modified on the table <c>LedgerJournalTrans</c>.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// Returns a container with reporting currency exchange rates and exchange rate text.
    /// </returns>
    public static container reportingCurrencyModified(LedgerJournalTrans _ledgerJournalTrans)
    {
        ExchRate          reportingExchRate;
        ExchRate          reportingExchRateSecond;
        ExchRateSecondTxt reportingExchRateSecondTxt;

        if (_ledgerJournalTrans.CurrencyCode && Ledger::reportingCurrency())
        {
            try
            {
                TransDate exchRateDate = _ledgerJournalTrans.exchRateDate_W();

                ExchangeRateCalculation exchangeRateCalculation= ExchangeRateCalculation::newExchangeDate(Ledger::reportingCurrencyExchangeRateType(),
                                                                                                _ledgerJournalTrans.CurrencyCode,
                                                                                                Ledger::reportingCurrency(),
                                                                                                exchRateDate);

                reportingExchRate = exchangeRateCalculation.getExchangeRate1();

                reportingExchRateSecond = exchangeRateCalculation.getExchangeRate2();

                reportingExchRateSecondTxt = _ledgerJournalTrans.exchRateTxtForReportingCurrency();
            }
            catch
            {
                reportingExchRate = 0.0;
                reportingExchRateSecond = 0.0;
                reportingExchRateSecondTxt = '';
            }
        }

        return [reportingExchRate, reportingExchRateSecond, reportingExchRateSecondTxt];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWithholdTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get Withholding tax amount based on the passed criteria.
    /// </summary>
    /// <param name="_vendTransId">
    /// VendTransId used to find the record from <c>VendTrans</c> table.
    /// </param>
    /// <param name="_withholdTaxGroupTDS">
    /// TDS group used to find the record.
    /// </param>
    /// <param name="_withholdTaxGroupTCS">
    /// TCS group used to find the record.
    /// </param>
    /// <returns>
    /// Return Withholding tax Amount from <c>VendTrans</c> buffer.
    /// </returns>
    public static AmountCur getWithholdTaxAmount_IN(VendTransRefRecId  _vendTransId,
                                             TaxWithholdGroup   _withholdTaxGroupTDS,
                                             TaxWithholdGroup   _withholdTaxGroupTCS)
    {
        VendTrans_W   vendTransLoc_W;

        if (_withholdTaxGroupTDS)
        {
            select firstonly tdsAmount_IN from vendTransLoc_W
                where vendTransLoc_W.VendTrans == _vendTransId;
            if (vendTransLoc_W)
            {
                return vendTransLoc_W.tdsAmount_IN;
            }
        }
        else if (_withholdTaxGroupTCS)
        {
            select firstonly tcsAmount_IN from vendTransLoc_W
                where vendTransLoc_W.VendTrans == _vendTransId;
            if (vendTransLoc_W)
            {
                return vendTransLoc_W.tcsAmount_IN;
            }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBalances_Packed</Name>
				<Source><![CDATA[
    private static container initBalances_Packed(container _packedClass, LedgerJournalId _ledgerJournalId, boolean _calc)
    {
        LedgerJournalEngine_Server ljeServer = LedgerJournalEngine_Server::create(_packedClass);
        container                  result = ljeServer.initBalances(_ledgerJournalId, _calc);

        return [ljeServer.pack(), result];
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes an invoice from the approval journal and transfers it back to the invoice pool.
    /// </summary>
    /// <param name="_vendTrans">
    /// A <c>VendTrans</c> record buffer for the invoice to remove.
    /// </param>
    /// <param name="_ledgerJournalTable">
    /// A <c>LedgerJournalTable</c> record buffer of the journal holding the invoice.
    /// </param>
    /// <param name="_voucher">
    /// The <c>Voucher</c> number of the invoice transaction.
    /// </param>
    /// <returns>
    /// true if the journal number, Voucher, and Invoice are valid; otherwise, false.
    /// </returns>
    /* Removes a voucher from the approval journal, and transfers it back to the invoice pool */
    public static boolean removeVoucher(VendTrans            _vendTrans,
                                               LedgerJournalTable   _ledgerJournalTable,
                                               Voucher              _voucher)
    {
        VendTrans           vendTransPool;
        VendTransOpen       vendTransOpen;
        LedgerJournalId     vendInvoicePoolJournalId = LedgerJournalTable::findVendorInvoicePool().JournalNum;
        LedgerJournalTrans  ledgerJournalTrans;
        boolean             isJournalVoucherRemoved;
        SpecTransManager    specTransManager;

        ttsbegin;

        while select forupdate ledgerJournalTrans
            where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum &&
                  ledgerJournalTrans.Voucher    == _voucher &&
                  ledgerJournalTrans.Invoice    == _vendTrans.Invoice
        {
            isJournalVoucherRemoved = true;

            if (TaxIntegrationUtils::isTransitDocumentEnabled())
            {
                ledgerJournalTrans.TransitDocumentTransactionMap_IN::deleteTransitDocuments();
            }

            specTransManager = SpecTransManager::newFromSpec(ledgerJournalTrans, false);
            specTransManager.deleteAll();

            ledgerJournalTrans.doDelete();
        }

        if (isJournalVoucherRemoved)
        {
            // Voucher has been removed.  Remove budget for the voucher.
            BudgetControlAccountingJournalProcessor::submitLedgerJournalVoucherToRemoveBudget(
                _ledgerJournalTable.JournalNum,
                _ledgerJournalTable.company(),
                _voucher);
        }

        LedgerJournalVoucherChanged::deleteChange(_ledgerJournalTable.JournalNum, _vendTrans.Voucher);

        select firstonly forupdate vendTransPool
            where vendTransPool.AccountNum  == _vendTrans.AccountNum            &&
                  vendTransPool.Voucher     == _vendTrans.Voucher               &&
                  vendTransPool.JournalNum  == _ledgerJournalTable.JournalNum   &&
                  vendTransPool.TransDate   == _vendTrans.TransDate             &&
                  vendTransPool.Invoice     == _vendTrans.Invoice;

        vendTransPool.JournalNum = vendInvoicePoolJournalId;
        vendTransPool.update();

        select firstonly forupdate vendTransOpen
            where vendTransOpen.RefRecId == _vendTrans.RecId;

        vendTransOpen.UseCashDisc = UseCashDisc::Normal;
        vendTransOpen.update();

        ttscommit;

        return isJournalVoucherRemoved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDisc</Name>
				<Source><![CDATA[
    public static container updateCashDisc(LedgerJournalTrans _ledgerJournalTrans,
                                                  boolean            _updateCashDisc = false)
    {
        LedgerJournalCashDiscService    ledgerJournalCashDiscService;
        ;

        ledgerJournalCashDiscService = new LedgerJournalCashDiscService(_ledgerJournalTrans.JournalNum,
                                                                        _ledgerJournalTrans.Voucher,
                                                                        _ledgerJournalTrans,
                                                                        _updateCashDisc);

        return ledgerJournalCashDiscService.updateVoucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCashDiscDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>CustTransCashDisc</c> table and <c>VendTransCashDisc</c> tables with cash discount
    /// information from the journal line.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> table record buffer.
    /// </param>
    /// <param name="_manual">
    /// A Boolean value that indicates whether the cash discount should be recorded to the
    /// Cust-/VendTransCashDisc tables as a manual entry; optional.
    /// </param>
    /// <remarks>
    /// This method must be called when the <c>CashDiscAmount</c>, <c>CashDiscCode</c>, and
    /// <c>DateCashDisc</c> fields of the journal line are changed.
    /// </remarks>
    public static void updateCashDiscDetail(LedgerJournalTrans _ledgerJournalTrans,
                                                   boolean            _manual = false)
    {
        VendTransCashDisc   vendTransCashDisc;
        CustTransCashDisc   custTransCashDisc;

        ttsbegin;

        switch (_ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust :
                select firstonly forupdate custTransCashDisc
                    index RecIdDateIdx
                    where custTransCashDisc.RefTableId   == _ledgerJournalTrans.TableId &&
                          custTransCashDisc.RefRecId     == _ledgerJournalTrans.RecId   &&
                          custTransCashDisc.CashDiscDue  ==  CashDiscDue::CashDisc;

                if (custTransCashDisc.RecId)
                {
                    custTransCashDisc.CashDiscAmount = _ledgerJournalTrans.CashDiscAmount;
                    custTransCashDisc.CashDiscdate   = _ledgerJournalTrans.DateCashDisc;
                    custTransCashDisc.CashDiscPercent= _ledgerJournalTrans.CashDiscPercent;
                    custTransCashDisc.Manual         = _manual;
                    custTransCashDisc.update();
                }
                break;

            case LedgerJournalACType::Vend :
                select firstonly forupdate vendTransCashDisc
                    index RecIdDateIdx
                    where vendTransCashDisc.RefTableId   == _ledgerJournalTrans.TableId &&
                          vendTransCashDisc.RefRecId     == _ledgerJournalTrans.RecId   &&
                          vendTransCashDisc.CashDiscDue  ==  CashDiscDue::CashDisc;

                if (vendTransCashDisc.RecId)
                {
                    vendTransCashDisc.CashDiscAmount = _ledgerJournalTrans.CashDiscAmount;
                    vendTransCashDisc.CashDiscdate   = _ledgerJournalTrans.DateCashDisc;
                    vendTransCashDisc.CashDiscPercent= _ledgerJournalTrans.CashDiscPercent;
                    vendTransCashDisc.Manual         = _manual;
                    vendTransCashDisc.update();
                }
            default :
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>TaxGroup</c> field of the other lines with the same voucher number as the voucher
    /// number of the line that is passed as a parameter.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> record buffer.
    /// </param>
    /// <returns>
    /// true if the method has updated any lines; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is only applicable when a voucher is covered by more than one journal line.
    /// </remarks>
    public static boolean updateTaxGroup(LedgerJournalTrans  _ledgerJournalTrans)
    {
        boolean             updatedLinesDB;
        LedgerJournalTrans  ledgerJournalTransLocal;

        ttsbegin;
        changecompany(_ledgerJournalTrans.company())
        {
            if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Cust ||
                _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                (_ledgerJournalTrans.parmOffsetLedgerDimension()                                &&
                 (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust ||
                  _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)))
            {
                while select forupdate ledgerJournalTransLocal
                    where
                          ledgerJournalTransLocal.JournalNum == _ledgerJournalTrans.JournalNum &&
                          ledgerJournalTransLocal.Voucher     == _ledgerJournalTrans.Voucher    &&
                          ledgerJournalTransLocal.TransDate   == _ledgerJournalTrans.TransDate  &&
                          ledgerJournalTransLocal.RecId       != _ledgerJournalTrans.RecId      &&
                          ledgerJournalTransLocal.TaxGroup    != _ledgerJournalTrans.TaxGroup   &&
                          ledgerJournalTransLocal.AccountType != LedgerJournalACType::Cust      &&
                          ledgerJournalTransLocal.AccountType != LedgerJournalACType::Vend      &&
                          ledgerJournalTransLocal.AccountType != LedgerJournalACType::Project   &&
                          ((ledgerJournalTransLocal.OffsetLedgerDimension == 0)                    ||
                           (ledgerJournalTransLocal.OffsetLedgerDimension != 0                     &&
                            ledgerJournalTransLocal.OffsetAccountType != LedgerJournalACType::Cust &&
                            ledgerJournalTransLocal.OffsetAccountType != LedgerJournalACType::Vend &&
                            ledgerJournalTransLocal.OffsetAccountType != LedgerJournalACType::Project))
                {
                    // Verify that a tax code is derived for the given Tax Group and Tax Item Group.
                    if (_ledgerJournalTrans.TaxGroup && ledgerJournalTransLocal.TaxItemGroup)
                    {
                        if (CheckTaxGroups::Error == Tax::isValidTaxGroupIntersectionV2(
                                                        _ledgerJournalTrans.TaxGroup,
                                                        ledgerJournalTransLocal.TaxItemGroup,
                                                        _ledgerJournalTrans.isTaxIntegrationEnabled()))
                        {
                            // In this scenario there are no derived tax codes and the user has asked that we flag this condition as an error.
                            // Due to how the journal forms display taxes through display methods it is best to not allow this field to be set to a Tax Item Group
                            // with no over lapping Tax Codes.  The error message will let the user know what Tax Item Group was trying to default.
                            error (strFmt("@SYS4009766",_ledgerJournalTrans.TaxGroup, ledgerJournalTransLocal.TaxItemGroup));
                        }
                        else
                        {
                            if (ledgerJournalTransLocal.TaxGroup == '')
                            {
                                ledgerJournalTransLocal.TaxGroup = _ledgerJournalTrans.TaxGroup;
                                ledgerJournalTransLocal.update();
                                updatedLinesDB = true;
                            }
                        }
                    }
                    else if (ledgerJournalTransLocal.TaxItemGroup == '')
                    {
                        ledgerJournalTransLocal.TaxGroup = _ledgerJournalTrans.TaxGroup;
                        ledgerJournalTransLocal.update();
                        updatedLinesDB = true;
                    }
                }
            }
            else
            {
                select firstonly Invoice, TaxGroup from ledgerJournalTransLocal
                    index hint NumVoucherIdx
                    where ledgerJournalTransLocal.JournalNum  == _ledgerJournalTrans.JournalNum  &&
                          ledgerJournalTransLocal.Voucher     == _ledgerJournalTrans.Voucher     &&
                          ledgerJournalTransLocal.TransDate   == _ledgerJournalTrans.TransDate   &&
                         (ledgerJournalTransLocal.AccountType == LedgerJournalACType::Cust       ||
                          ledgerJournalTransLocal.AccountType == LedgerJournalACType::Vend       ||
                         (ledgerJournalTransLocal.OffsetLedgerDimension != 0                     &&
                         (ledgerJournalTransLocal.OffsetAccountType == LedgerJournalACType::Cust ||
                          ledgerJournalTransLocal.OffsetAccountType == LedgerJournalACType::Vend)));

                if (ledgerJournalTransLocal)
                {
                    if (ledgerJournalTransLocal.Invoice == '' &&
                        (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::CustPayment ||
                         _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Payment))
                    {
                        _ledgerJournalTrans.TaxGroup = '';
                    }
                    else
                    {
                        // Verify that a tax code is derived for the given Tax Group and Tax Item Group.
                        if (ledgerJournalTransLocal.TaxGroup && _ledgerJournalTrans.TaxItemGroup)
                        {
                            if (CheckTaxGroups::Error == Tax::isValidTaxGroupIntersectionV2(
                                                            ledgerJournalTransLocal.TaxGroup,
                                                            _ledgerJournalTrans.TaxItemGroup,
                                                            _ledgerJournalTrans.isTaxIntegrationEnabled()))
                            {
                                // In this scenario there are no derived tax codes and the user has asked that we flag this condition as an error.
                                // Due to how the journal forms display taxes through display methods it is best to not allow this field to be set to a Tax Item Group
                                // with no over lapping Tax Codes.  The error message will let the user know what Tax Item Group was trying to default.
                                error (strFmt("@SYS4009766", ledgerJournalTransLocal.TaxGroup, _ledgerJournalTrans.TaxItemGroup));
                            }
                            else
                            {
                                _ledgerJournalTrans.TaxGroup = ledgerJournalTransLocal.TaxGroup;
                            }
                        }
                        else if (_ledgerJournalTrans.TaxItemGroup == '')
                        {
                            _ledgerJournalTrans.TaxGroup = ledgerJournalTransLocal.TaxGroup;
                        }
                    }

                    if (_ledgerJournalTrans.TaxGroup == '' && ledgerJournalTransLocal.AccountType == LedgerJournalACType::Ledger)
                    {
                        RefRecId mainAccount = _ledgerJournalTrans.findMainAccount().RecId;
                        RefRecId legalEntity = CompanyInfo::current();
                        MainAccountLegalEntity mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(mainAccount, legalEntity);
                        if (mainAccountLegalEntity.TaxGroup != '')
                        {
                            _ledgerJournalTrans.TaxGroup = mainAccountLegalEntity.TaxGroup;
                        }
                    }
                }
            }
        }
        ttscommit;

        return updatedLinesDB;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>