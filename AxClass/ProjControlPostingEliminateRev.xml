<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjControlPostingEliminateRev</Name>
	<SourceCode>
		<Declaration><![CDATA[
class   ProjControlPostingEliminateRev extends ProjControlPosting implements BatchRetryable
{
    boolean isMultipleContractLineFeatureEnable = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkCreateRevenueTrans</Name>
				<Source><![CDATA[
    public boolean checkCreateRevenueTrans()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAccByMatchingPrincip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements checking of matching principle for <c>ProjControlPostingEliminateRev::checkPostOnAcc</c>.
    /// </summary>
    /// <param name = "_matchingPrincip">Value of matching principle.</param>
    /// <returns>true if the check succceeds; otherwise false.</returns>
	[Replaceable]
	protected boolean checkPostOnAccByMatchingPrincip(ProjMatchingPrincip _matchingPrincip)
    {
        return _matchingPrincip == ProjMatchingPrincip::SalesValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAccByCompletePrincip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Implements checking of complete principle for <c>ProjControlPostingEliminateRev::checkPostOnAcc</c>.
    /// </summary>
    /// <param name = "_completePrincip">Value of complete principle.</param>
    /// <returns>true if the check succeeds; otherwise, false.</returns>
	[Replaceable]
	protected boolean checkPostOnAccByCompletePrincip(ProjCompletePrincip _completePrincip)
    {
        return _completePrincip == ProjCompletePrincip::CompletedPercentage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostOnAcc</Name>
				<Source><![CDATA[
    public boolean checkPostOnAcc()
    {
        ProjTable projTableLoc = ProjTable::find(projId);
        ProjCompletePrincip completePrinciple;
        ProjMatchingPrincip matchingPrinciple;
        ProjLedgerStatusOnAcc onAccLedgerStatus;

        if (isMultipleContractLineFeatureEnable || (isContractLineUsed && contractLineBasedRevRecFeature))
        {
            if (!projRevProfile)
            {
                if(isContractLineUsed && contractLineBasedRevRecFeature)
                {
                    projRevProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(ProjWIPTable::find(this.parmProjId()));
                }
                else
                {
                    projRevProfile = ProjRevRecHelper::getRevProfile(projTableLoc, ProjContractBillingMethod::FixedPrice);
                }
            }
            completePrinciple = projRevProfile.CompletePrinciple;
            matchingPrinciple = projRevProfile.MatchingPrinciple;
            onAccLedgerStatus = projRevProfile.OnAccLedgerStatus;
        }
        else
        {
            completePrinciple = projGroup.CompletePrincip;
            matchingPrinciple = projGroup.MatchingPrincip;
            onAccLedgerStatus = projGroup.InvoicePosting;
        }

        if (onAccLedgerStatus == ProjLedgerStatusOnAcc::Operations &&
            this.checkPostOnAccByMatchingPrincip(matchingPrinciple) &&
            this.checkPostOnAccByCompletePrincip(completePrinciple))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostRevenueReverse</Name>
				<Source><![CDATA[
    public boolean checkPostRevenueReverse()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog can be either built by using the <c>Dialog</c> class or by using a class that is created
    /// in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase   dialogRunbase;

        this.parmTransDate(this.parmTransDate() ? this.parmTransDate() : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        dialogRunbase = super();

        dialogRunbase.caption("@SYS6098");

        dialogRunbase.addGroup("@SYS14475");
        fieldTransDate = dialogRunbase.addFieldValue(extendedTypeStr(TransDate), this.parmTransDate(), "@SYS14475", "@SYS53214");

        return dialogRunbase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doAction</Name>
				<Source><![CDATA[
    public boolean doAction(ProjControlPeriodTable _projControlPeriodTable)
    {
        return (select firstonly projWIPTable
                    where   projWIPTable.ProjId         == _projControlPeriodTable.ProjId
                    &&      projWIPTable.wipEliminated  == NoYes::Yes).RecId ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>elimination</Name>
				<Source><![CDATA[
    public boolean elimination()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>investmentEliminationAmount</Name>
				<Source><![CDATA[
    public AmountMST investmentEliminationAmount(ProjControlPeriodTable  _projControlPeriod)
    {
        ProjControlPeriodTableColumn    projControlPeriodTableColumnEstimate    =
                                        ProjControlPeriodTableColumn::find(_projControlPeriod.ProjId,
                                                                           _projControlPeriod.ControlId,
                                                                           _projControlPeriod.PeriodFrom,
                                                                           _projControlPeriod.Version,
                                                                           ProjEstimateColumn::Estimate);

        ProjControlPeriodTable  projControlPeriodTableLast = ProjControlPeriodTable::findLastPosted(
            _projControlPeriod.ProjId,_projControlPeriod.ControlId);

        return (projControlPeriodTableColumnEstimate.wipCostpriceTotal+projControlPeriodTableLast.totalTotalEstimateAccCost());
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerStatusCostTo</Name>
				<Source><![CDATA[
    protected ProjLedgerStatus ledgerStatusCostTo(ProjTrans _projTrans)
    {
        ProjLedgerStatus ret;

        if (_projTrans.transType() == ProjTransType::Cost &&
            _projTrans.ledgerStatusCost() == ProjLedgerStatus::None)
        {
            ret = _projTrans.ledgerStatusCost();
        }
        else if (_projTrans.ledgerStatusCost() == ProjLedgerStatus::Never)   // Handle Never Ledger (Hour or Item)
        {
            ret = ProjLedgerStatus::Never;
        }
        else
        {
            ProjTable projTable = ProjTable::find(_projTrans.projId());

            // Estimate was posted prior to elimination
            if (_projTrans.wipPeriod())
            {
                if (((isContractLineUsed && contractLineBasedRevRecFeature)
                    && ProjRevRecHelper::getCompletePrincipleContractLine(ProjWIPTable::find(this.parmProjId())) == ProjCompletePrincip::CompletedContract)
                    || (projTable.isInvestmentProject())
                    || (ProjRevRecHelper::getCompletePrincipleForProjTable(projTable) == ProjCompletePrincip::CompletedContract))
                {
                    if (_projTrans.canBeCapitalize())
                    {
                        ret = ProjLedgerStatus::BalanceSheet;
                    }
                    else
                    {
                        ret = ProjLedgerStatus::Operations;
                    }
                }
                else
                {
                    ret = ProjLedgerStatus::Operations;
                }
            }
            else
            {
                switch (_projTrans.transType())
                {
                    case ProjTransType::Hour :
                        if(isContractLineUsed && contractLineBasedRevRecFeature)
                        {
                            ret = ProjRevRecHelper::getProfileForRevRecProjectContractLine(ProjWIPTable::find(this.parmProjId())).EmplLedgerStatus;
                        }
                        else
                        {
                            ret = ProjRevRecHelper::getEmplLedgerStatus(projTable);
                        }
                        break;

                    case ProjTransType::Cost :
                        if(isContractLineUsed && contractLineBasedRevRecFeature)
                        {
                            ret = ProjRevRecHelper::cost2LedgerStatus(ProjRevRecHelper::getProfileForRevRecProjectContractLine(ProjWIPTable::find(this.parmProjId())).CostLedgerStatus);
                        }
                        else
                        {
                            ret = ProjRevRecHelper::getCostLedgerStatus(projTable);
                        }
                        break;

                    case ProjTransType::Item :
                        if(isContractLineUsed && contractLineBasedRevRecFeature)
                        {
                            ret = ProjRevRecHelper::item2LedgerStatus(ProjRevRecHelper::getProfileForRevRecProjectContractLine(ProjWIPTable::find(this.parmProjId())).ItemLedgerStatus);
                        }
                        else
                        {
                            ret = ProjRevRecHelper::getItemLedgerStatus(projTable);
                        }
                        break;
                }
                if (ret == ProjLedgerStatus::BalanceSheet && !_projTrans.canBeCapitalize())
                {
                    ret = ProjLedgerStatus::Operations;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projControlPeriodStatusNew</Name>
				<Source><![CDATA[
    protected ProjControlPeriodStatus projControlPeriodStatusNew()
    {
        return ProjControlPeriodStatus::Reversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReversal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the posting is a reversal posting.
    /// </summary>
    /// <returns>true if the posting is reversal; otherwise, false.</returns>
    protected boolean isReversal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    public TransTxt transactionLogTxt()
    {
        return "@SYS92316";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    public TransactionLogType transactionLogType()
    {
        return TransactionLogType::ProjEstimate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccruedCost</Name>
				<Source><![CDATA[
    public void updateAccruedCost(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
        ProjCostTrans       projCostTrans;
        ProjCostTransCost   projCostTransCost;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select forupdate projCostTrans
                where projCostTrans.TransactionOrigin == ProjOrigin::EstimateAccruedLoss
            join projRevRecContractLine
            where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId &&
                    projRevRecContractLine.ContractLineNum == projCostTrans.PSAContractLineNum
            join forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId &&
                    projCostTransCost.TransStatus == ProjTransStatus::Eliminated
            {
                this.postAccruedCost(projCostTrans,projCostTransCost,_ledgerVoucher);
            }
        }
        else
        {

            while select forupdate projCostTrans
            join projTable
            where projTable.WIPProject == _projControlPeriod.ProjId
                && projCostTrans.ProjId == projTable.ProjId
                && projCostTrans.TransactionOrigin == ProjOrigin::EstimateAccruedLoss
            join forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId &&
                    projCostTransCost.TransStatus == ProjTransStatus::Eliminated
            {
                this.postAccruedCost(projCostTrans,projCostTransCost,_ledgerVoucher);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccruedOnAcc</Name>
				<Source><![CDATA[
    // change
    public void updateAccruedOnAcc(
        ProjId        _projId,
        LedgerVoucher _ledgerVoucher)
    {
        ProjOnAccTrans      projOnAccTrans;
        ProjOnAccTrans      projOnAccTransUpdate;
        ProjOnAccTransSale  projOnAccTransSale;
        ProjOnAccTransSale  projOnAccTransSaleUpdate;
        ProjTable           projTable;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projId
            join TransId from projOnAccTrans
            where projOnAccTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                join projOnAccTransSale
                    where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                        projOnAccTransSale.TransStatus == ProjTransStatus::Eliminated &&
                        projOnAccTransSale.wipPeriod
            {
                projOnAccTransUpdate = ProjOnAccTrans::find(projOnAccTrans.TransId,true);
                projOnAccTransSaleUpdate = ProjOnAccTransSale::find(projOnAccTransSale.RecId,true);
                ProjPost::newEnterOnAccEstimate(projOnAccTransUpdate,
                                            projOnAccTransSaleUpdate,
                                            _ledgerVoucher,
                                            this.parmPeriodTo(),
                                            this.checkPostOnAcc(),
                                            this.isReversal(),
                                            NoYes::Yes).postTrans();

                projOnAccTransSaleUpdate.TransStatus   = ProjTransStatus::Estimated;
                projOnAccTransSaleUpdate.update();
            }
        }
        else
        {
        while select RecId from projTable
            where projTable.wipProject == _projId
            join TransId from projOnAccTrans
            where projOnAccTrans.ProjID == projTable.ProjId
                join projOnAccTransSale
                    where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                        projOnAccTransSale.TransStatus == ProjTransStatus::Eliminated &&
                        projOnAccTransSale.wipPeriod
        {
            projOnAccTransUpdate = ProjOnAccTrans::find(projOnAccTrans.TransId,true);
            projOnAccTransSaleUpdate = ProjOnAccTransSale::find(projOnAccTransSale.RecId,true);
            ProjPost::newEnterOnAccEstimate(projOnAccTransUpdate,
                                            projOnAccTransSaleUpdate,
                                            _ledgerVoucher,
                                            this.parmPeriodTo(),
                                            this.checkPostOnAcc(),
                                            this.isReversal(),
                                            NoYes::Yes).postTrans();

            projOnAccTransSaleUpdate.TransStatus   = ProjTransStatus::Estimated;
            projOnAccTransSaleUpdate.update();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProjControlPeriodTableFields</Name>
				<Source><![CDATA[
	protected void setProjControlPeriodTableFields(ProjControlPeriodTable _projControlPeriodTable, LedgerVoucher _ledgerVoucher)
	{
		_projControlPeriodTable.PeriodStatus = this.projControlPeriodStatusNew();
		_projControlPeriodTable.VoucherReverse = _ledgerVoucher.lastVoucher();
		_projControlPeriodTable.VoucherDateReverse = _ledgerVoucher.lastTransDate();
		if (this.elimination() && this.isReversal())
		{
			_projControlPeriodTable.Elimination = NoYes::No;
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>updatePeriod</Name>
				<Source><![CDATA[
    protected void updatePeriod(LedgerVoucher _ledgerVoucher)
    {
        ProjControlPeriodTable  projControlPeriodTable  = ProjControlPeriodTable::find(this.parmProjId(),
                                                                                        controlId,
                                                                                        periodFrom,
                                                                                        projControlVersion,
                                                                                        true);

        if (projControlPeriodTable.RecId)
        {
            this.setProjControlPeriodTableFields(projControlPeriodTable, _ledgerVoucher);
            projControlPeriodTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTable</Name>
				<Source><![CDATA[
    protected void updateProjTable()
    {
        ProjWIPTable       projWIPTable  = ProjWIPTable::find(this.parmProjId(), true);

        projWIPTable.wipEliminated = NoYes::No;
        projWIPTable.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTrans</Name>
				<Source><![CDATA[
    protected void updateProjTrans()
    {
        ProjTable           projTable;
        ProjEmplTrans       projEmplTrans;
        ProjEmplTransCost   projEmplTransCost;
        ProjCostTrans   projCostTrans;
        ProjCostTransCost   projCostTransCost;
        ProjItemTrans       projItemTrans;
        ProjItemTransCost   projItemTransCost;
        ProjRevRecContractLine projRevRecContractLine;

        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine where projRevRecContractLine.RevenueRecognitionId == this.parmProjId()
            {
                update_recordset projEmplTransCost
                setting TransStatus = ProjTransStatus::Estimated
                where projEmplTransCost.TransStatus == ProjTransStatus::Eliminated
                    join projEmplTrans
                        where projEmplTrans.TransId == projEmplTransCost.TransId &&
                            projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum;

                update_recordset projCostTransCost
                setting TransStatus = ProjTransStatus::Estimated
                where projCostTransCost.TransStatus == ProjTransStatus::Eliminated
                    join projCostTrans
                        where projCostTrans.TransId == projCostTransCost.TransId &&
                            projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum;

                update_recordset projItemTransCost
                setting TransStatus = ProjTransStatus::Estimated
                where projItemTransCost.TransStatus == ProjTransStatus::Eliminated
                    join projItemTrans
                        where projItemTrans.InventTransId == projItemTransCost.InventTransId &&
                            projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId &&
                            projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum;
            }
        }
        else
        {

        while select ProjId from projTable where projTable.wipProject == this.parmProjId()
        {
            update_recordset projEmplTransCost
                setting TransStatus = ProjTransStatus::Estimated
                where projEmplTransCost.TransStatus == ProjTransStatus::Eliminated
                    join projEmplTrans
                        where projEmplTrans.TransId == projEmplTransCost.TransId &&
                            projEmplTrans.ProjId == projTable.ProjId;

            update_recordset projCostTransCost
                setting TransStatus = ProjTransStatus::Estimated
                where projCostTransCost.TransStatus == ProjTransStatus::Eliminated
                    join projCostTrans
                        where projCostTrans.TransId == projCostTransCost.TransId &&
                            projCostTrans.ProjId == projTable.ProjId;

            update_recordset projItemTransCost
                setting TransStatus = ProjTransStatus::Estimated
                where projItemTransCost.TransStatus == ProjTransStatus::Eliminated
                    join projItemTrans
                        where projItemTrans.InventTransId == projItemTransCost.InventTransId &&
                            projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId &&
                            projItemTrans.ProjId == projTable.ProjId;
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRevenue</Name>
				<Source><![CDATA[
    public void updateRevenue(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher)
    {
        ProjRevenueTrans        projRevenueTrans;
        ProjRevenueTransSale    projRevenueTransSale;
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransSale       projEmplTransSale;
        ProjCostTrans           projCostTrans;
        ProjCostTransSale       projCostTransSale;
        ProjItemTrans           projItemTrans;
        ProjItemTransSale       projItemTransSale;
        ProjTable projTable;
        ProjRevRecContractLine projRevRecContractLine;

    #localMacro.process
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            if(%1.tableId == tableNum(ProjRevenueTrans))
            {
                while select pessimisticlock %1
                join pessimisticlock %2
                    where %2.%3 == %1.%3 &&
                      %2.TransStatus == ProjTransStatus::Eliminated      &&
                     !%2.LedgerSalesPosted &&
                      %2.wipPeriod  &&
                      %2.%4 == _projControlPeriod.ProjId
                {
                    ProjPost::newEnterRevenueEstimate(%1,
                                                %2,
                                                _ledgerVoucher,
                                                this.isReversal(),
                                                true,
                                                true).postTrans();
                }
            }
            else
            {
                while select pessimisticlock %1
                join pessimisticlock %2
                    where %2.%3 == %1.%3 &&
                      %2.TransStatus == ProjTransStatus::Eliminated      &&
                     !%2.LedgerSalesPosted &&
                      %2.wipPeriod
                exists join projRevRecContractLine
                    where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId &&
                       projRevRecContractLine.ContractLineNum == %1.PSAContractLineNum
                {
                    ProjPost::newEnterRevenueEstimate(%1,
                                                %2,
                                                _ledgerVoucher,
                                                this.isReversal(),
                                                true,
                                                true).postTrans();
                }
            }
            
        }
        else
        {
        while select forupdate %1
            join projTable
            where projTable.WIPProject == _projControlPeriod.ProjId
                && %1.ProjId == projTable.ProjId
                join forupdate %2
                    where %2.%3 == %1.%3 &&
                      %2.TransStatus == ProjTransStatus::Eliminated      &&
                     !%2.LedgerSalesPosted &&
                      %2.wipPeriod
        {
            ProjPost::newEnterRevenueEstimate(%1,
                                                %2,
                                                _ledgerVoucher,
                                                this.isReversal(),
                                                true,
                                                true).postTrans();
        }
        }
    #endMacro

        if (this.getSalesPriceMatchingPrinciple() == ProjSalesPriceMatchingPrincip::None)
        {
            #process(projRevenueTrans, projRevenueTransSale, TransId, WIPProjId)
        }
        else
        {
            #process(projEmplTrans, projEmplTransSale, TransId, TransId)
            #process(projCostTrans, projCostTransSale, TransId, TransId)
            #process(projItemTrans, projItemTransSale, ProjTransId, ProjTransId)
            #process(projRevenueTrans, projRevenueTransSale, TransId, WIPProjId)
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostCost</Name>
				<Source><![CDATA[
    protected void wipPostCost(
        ProjControlPeriodTable  _projControlPeriod,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId)
    {
        ProjCostTrans           projCostTrans;
        ProjCostTransCost       projCostTransCost;
        ProjTrans               projTrans;
        LedgerVoucher           ledgerVoucherSpecialTrx;
        LedgerVoucherObject     ledgerVoucherObjectSpecial;
        TransactionTxt          transSpecialTxt;
        Voucher                 voucherSpecial;
        ProjLedgerStatus        projLedgerStatusTo;
        NumberSeq               numberSeqSpecial;
        TransDate               voucherDate;
        DetailSummary           detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;
        ProjRevRecContractLine projRevRecContractLine;

        //
        // Handle tranactions posted after the elimination
        // This must be done prior to those transactions which have been eliminated
        // because transactions could be moved to posted status if they have not been
        // included in the estimate.
        //
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
            join forupdate projCostTrans
                where projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
            join forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Posted
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                //Create new journal and use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::ReverseElimination, false).postTrans();

                /*if (projGroup.ProjType  == ProjType::Investment)
                {
                    this.eliminateInvestment(_projControlPeriod, ledgerVoucherSpecialTrx, NoYes::Yes, -projCostTransCost.LineAmount);
                }*/

                ledgerVoucherSpecialTrx.end();

                projCostTransCost.update();
            }
            }
        }
        else
        {
        while select forupdate projCostTrans
            where projCostTrans.ProjId == _projId
                join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                        && projCostTransCost.TransStatus == ProjTransStatus::Posted
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                //Create new journal and use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::ReverseElimination, false).postTrans();

                /*if (projGroup.ProjType  == ProjType::Investment)
                {
                    this.eliminateInvestment(_projControlPeriod, ledgerVoucherSpecialTrx, NoYes::Yes, -projCostTransCost.LineAmount);
                }*/

                ledgerVoucherSpecialTrx.end();

                projCostTransCost.update();
            }
           }
        }

        // Handle transactions post prior to elimination (Before or After estimate)
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
             while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriod.ProjId
            join forupdate projCostTrans
                where projCostTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                    && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
            join forupdate projCostTransCost
                where projCostTransCost.TransId == projCostTrans.TransId
                    && projCostTransCost.TransStatus == ProjTransStatus::Eliminated
            {
                projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
                projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
                if (projTrans.wipPeriod())
                {
                    projCostTransCost.TransStatus   = ProjTransStatus::Estimated;
                }
                else
                {
                    projCostTransCost.TransStatus   = ProjTransStatus::Posted;
                }

                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    if (projTrans.wipPeriod())
                    {
                        ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();
                    }
                    else
                    {
                        //Create new journal and use larger of two dates (trx posted or Acknowledgment)
                        numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                        voucherSpecial = numberSeqSpecial.voucher();

                        transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                        transSpecialTxt.setDate(this.parmTransDate());
                        transSpecialTxt.setVoucher(voucherSpecial);

                        ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                        if (projTrans.transDate() >= this.parmTransDate())
                        {
                            voucherDate = projTrans.transDate();
                        }
                        else
                        {
                            voucherDate = this.parmTransDate();
                        }

                        ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                            voucherSpecial,
                            voucherDate,
                            SysModule::Project,
                            LedgerTransType::Project);

                        ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                        ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                        ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                        ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();

                        if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                        {
                            this.eliminateInvestment(_projControlPeriod, ledgerVoucherSpecialTrx, NoYes::Yes, -projCostTransCost.LineAmount);
                        }

                        ledgerVoucherSpecialTrx.end();
                    }
                }
                projCostTransCost.update();
            }
        }
        else
        {
        while select forupdate projCostTrans
            where projCostTrans.ProjId == _projId
                && projCostTrans.TransactionOrigin != ProjOrigin::EstimateAccruedLoss
                join forupdate projCostTransCost
                    where projCostTransCost.TransId == projCostTrans.TransId
                        && projCostTransCost.TransStatus == ProjTransStatus::Eliminated
        {
            projTrans   = ProjTrans::newProjCostTransCost(projCostTrans, projCostTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
            if (projTrans.wipPeriod())
            {
                projCostTransCost.TransStatus   = ProjTransStatus::Estimated;
            }
            else
            {
                projCostTransCost.TransStatus   = ProjTransStatus::Posted;
            }

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                if (projTrans.wipPeriod())
                {
                    ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();
                }
                else
                {
                    //Create new journal and use larger of two dates (trx posted or Acknowledgment)
                    numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                    voucherSpecial = numberSeqSpecial.voucher();

                    transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                    transSpecialTxt.setDate(this.parmTransDate());
                    transSpecialTxt.setVoucher(voucherSpecial);

                    ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                    if (projTrans.transDate() >= this.parmTransDate())
                    {
                        voucherDate = projTrans.transDate();
                    }
                    else
                    {
                        voucherDate = this.parmTransDate();
                    }

                    ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                        voucherSpecial,
                        voucherDate,
                        SysModule::Project,
                        LedgerTransType::Project);

                    ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                    ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                    ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                    ProjPost::newEnterCost_TrxDetail(projCostTrans, projCostTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();

                    if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                    {
                        this.eliminateInvestment(_projControlPeriod, ledgerVoucherSpecialTrx, NoYes::Yes, -projCostTransCost.LineAmount);
                    }

                    ledgerVoucherSpecialTrx.end();
                }
            }
            projCostTransCost.update();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostEmpl</Name>
				<Source><![CDATA[
    protected void wipPostEmpl(
        ProjControlPeriodTable  _projControlPeriodTable,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId)
    {
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransCost       projEmplTransCost;
        ProjTrans               projTrans;
        ProjLedgerStatus        projLedgerStatusTo;
        LedgerVoucher           ledgerVoucherSpecialTrx;
        LedgerVoucherObject     ledgerVoucherObjectSpecial;
        TransactionTxt          transSpecialTxt;
        Voucher                 voucherSpecial;
        NumberSeq               numberSeqSpecial;
        TransDate               voucherDate;
        DetailSummary           detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;
        PSAIndirectComponentTrans   psaIndirectComponentTrans;
        ProjRevRecContractLine projRevRecContractLine;

        // Handle the transactions posted after the elimination
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
            join forupdate projEmplTrans
                where projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                        && projEmplTransCost.TransStatus == ProjTransStatus::Posted
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                {
                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, false, false, psaIndirectComponentTrans).postTrans();
                }

                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, false).postTrans();

                /*if (projGroup.ProjType  == ProjType::Investment)
                {
                    this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projEmplTransCost.LineAmount);
                }*/

                ledgerVoucherSpecialTrx.end();

                projEmplTransCost.update();
            }
        }
        }
        else
        {
        while select forupdate projEmplTrans
            where projEmplTrans.ProjId == _projId
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                        && projEmplTransCost.TransStatus == ProjTransStatus::Posted
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                // Use larger of two dates (trx posted or Acknowledgment)
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                while select psaIndirectComponentTrans
                    where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                        psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                        psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                {
                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, false, false, psaIndirectComponentTrans).postTrans();
                }

                ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, false).postTrans();

                /*if (projGroup.ProjType  == ProjType::Investment)
                {
                    this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projEmplTransCost.LineAmount);
                }*/

                ledgerVoucherSpecialTrx.end();

                projEmplTransCost.update();
            }
        }
        }

        // Handle transactions posted before the elimination (with or without estimate)
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
            join forupdate projEmplTrans
            where projEmplTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                        && projEmplTransCost.TransStatus == ProjTransStatus::Eliminated
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
            if (projTrans.wipPeriod())
            {
                projEmplTransCost.TransStatus = ProjTransStatus::Estimated;
            }
            else
            {
                projEmplTransCost.TransStatus = ProjTransStatus::Posted;
            }

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                if (projTrans.wipPeriod())
                {
                    while select psaIndirectComponentTrans
                        where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                            psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                            psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true, false, psaIndirectComponentTrans).postTrans();
                    }

                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();
                }
                else
                {
                    numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                    voucherSpecial = numberSeqSpecial.voucher();

                    transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                    transSpecialTxt.setDate(this.parmTransDate());
                    transSpecialTxt.setVoucher(voucherSpecial);

                    ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                    // Use larger of two dates (trx posted or Acknowledgment)
                    if (projTrans.transDate() >= this.parmTransDate())
                    {
                        voucherDate = projTrans.transDate();
                    }
                    else
                    {
                        voucherDate = this.parmTransDate();
                    }

                    ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                        voucherSpecial,
                        voucherDate,
                        SysModule::Project,
                        LedgerTransType::Project);

                    ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                    ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                    ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                    while select psaIndirectComponentTrans
                        where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                            psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                            psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::ReverseElimination,true, false, psaIndirectComponentTrans).postTrans();

                        if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                        {
                            this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -psaIndirectComponentTrans.Amount);
                        }
                    }

                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::ReverseElimination,true).postTrans();

                    if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                    {
                        this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projEmplTransCost.LineAmount);
                    }

                    ledgerVoucherSpecialTrx.end();
                }
            }
            projEmplTransCost.update();
        }
        }
        else
        {
        while select forupdate projEmplTrans
            where projEmplTrans.ProjId == _projId
                join forupdate projEmplTransCost
                    where projEmplTransCost.TransId == projEmplTrans.TransId
                        && projEmplTransCost.TransStatus == ProjTransStatus::Eliminated
        {
            projTrans   = ProjTrans::newProjEmplTransCost(projEmplTrans, projEmplTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
            if (projTrans.wipPeriod())
            {
                projEmplTransCost.TransStatus = ProjTransStatus::Estimated;
            }
            else
            {
                projEmplTransCost.TransStatus = ProjTransStatus::Posted;
            }

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                if (projTrans.wipPeriod())
                {
                    while select psaIndirectComponentTrans
                        where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                            psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                            psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true, false, psaIndirectComponentTrans).postTrans();
                    }

                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();
                }
                else
                {
                    numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                    voucherSpecial = numberSeqSpecial.voucher();

                    transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                    transSpecialTxt.setDate(this.parmTransDate());
                    transSpecialTxt.setVoucher(voucherSpecial);

                    ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                    // Use larger of two dates (trx posted or Acknowledgment)
                    if (projTrans.transDate() >= this.parmTransDate())
                    {
                        voucherDate = projTrans.transDate();
                    }
                    else
                    {
                        voucherDate = this.parmTransDate();
                    }

                    ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                        voucherSpecial,
                        voucherDate,
                        SysModule::Project,
                        LedgerTransType::Project);

                    ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                    ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                    ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                    while select psaIndirectComponentTrans
                        where psaIndirectComponentTrans.TransId == projEmplTransCost.TransId &&
                            psaIndirectComponentTrans.ProjFundingSource == projEmplTransCost.FundingSource &&
                            psaIndirectComponentTrans.IndirectComponentType == PSAIndirectComponentType::Cost
                    {
                        ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::ReverseElimination,true, false, psaIndirectComponentTrans).postTrans();

                        if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                        {
                            this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -psaIndirectComponentTrans.Amount);
                        }
                    }

                    ProjPost::newEnterCost_TrxDetail(projEmplTrans, projEmplTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo, ProjOrigin::ReverseElimination,true).postTrans();

                    if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                    {
                        this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projEmplTransCost.LineAmount);
                    }

                    ledgerVoucherSpecialTrx.end();
                }
            }
            projEmplTransCost.update();
        }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>wipPostItem</Name>
				<Source><![CDATA[
    protected void wipPostItem(
        ProjControlPeriodTable  _projControlPeriodTable,
        LedgerVoucher           _ledgerVoucher,
        ProjId                  _projId)
    {
        ProjItemTrans           projItemTrans;
        ProjItemTransCost       projItemTransCost;
        ProjTrans               projTrans;
        LedgerVoucher           ledgerVoucherSpecialTrx;
        LedgerVoucherObject     ledgerVoucherObjectSpecial;
        TransactionTxt          transSpecialTxt;
        Voucher                 voucherSpecial;
        ProjLedgerStatus        projLedgerStatusTo;
        NumberSeq               numberSeqSpecial;
        TransDate               voucherDate;
        DetailSummary           detailSummary = ProjParameters::find().LineTotalEstimate == ProjLineTotal::Line ? DetailSummary::Detail : DetailSummary::Summary ;
        ProjRevRecContractLine projRevRecContractLine;

        // Handle transactions posted after elimination
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
            join forupdate projItemTrans
                    where projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                    join forupdate projItemTransCost
                        where projItemTransCost.InventTransId == projItemTrans.InventTransId
                            && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                            && projItemTransCost.TransStatus == ProjTransStatus::Posted
            {
                projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
                projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                    voucherSpecial = numberSeqSpecial.voucher();

                    transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                    transSpecialTxt.setDate(this.parmTransDate());
                    transSpecialTxt.setVoucher(voucherSpecial);

                    ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                    if (projTrans.transDate() >= this.parmTransDate())
                    {
                        voucherDate = projTrans.transDate();
                    }
                    else
                    {
                        voucherDate = this.parmTransDate();
                    }

                    ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                        voucherSpecial,
                        voucherDate,
                        SysModule::Project,
                        LedgerTransType::Project);

                    ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                    ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                    ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                    ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, false).postTrans();

                    /*if (projGroup.ProjType  == ProjType::Investment)
                    {
                        this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projItemTransCost.AmountMST);
                    }*/

                    ledgerVoucherSpecialTrx.end();
                }
            }
        }
        else
        {
        while select forupdate projItemTrans
                where projItemTrans.ProjId == _projId
                join forupdate projItemTransCost
                    where projItemTransCost.InventTransId == projItemTrans.InventTransId
                        && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                        && projItemTransCost.TransStatus == ProjTransStatus::Posted
        {
            projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);
            projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);

            if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
            {
                numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                voucherSpecial = numberSeqSpecial.voucher();

                transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                transSpecialTxt.setDate(this.parmTransDate());
                transSpecialTxt.setVoucher(voucherSpecial);

                ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                if (projTrans.transDate() >= this.parmTransDate())
                {
                    voucherDate = projTrans.transDate();
                }
                else
                {
                    voucherDate = this.parmTransDate();
                }

                ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                    voucherSpecial,
                    voucherDate,
                    SysModule::Project,
                    LedgerTransType::Project);

                ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, false).postTrans();

                /*if (projGroup.ProjType  == ProjType::Investment)
                {
                    this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projItemTransCost.AmountMST);
                }*/

                ledgerVoucherSpecialTrx.end();
            }
        }
        }

        // Handle transactions posted prior to eliminated (With or Without estimate)
        if(isContractLineUsed && contractLineBasedRevRecFeature)
        {
            while select projRevRecContractLine
                where projRevRecContractLine.RevenueRecognitionId == _projControlPeriodTable.ProjId
            join forupdate projItemTrans
                where projItemTrans.PSAContractLineNum == projRevRecContractLine.ContractLineNum
                join forupdate projItemTransCost
                    where projItemTransCost.InventTransId == projItemTrans.InventTransId
                        && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                        && projItemTransCost.TransStatus == ProjTransStatus::Eliminated
            {
                projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);

                projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
                if (projTrans.wipPeriod())
                {
                    projItemTransCost.TransStatus = ProjTransStatus::Estimated;
                }
                else
                {
                    projItemTransCost.TransStatus = ProjTransStatus::Posted;
                }

                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    if (projTrans.wipPeriod())
                    {
                        ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();
                    }
                    else
                    {
                        numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                        voucherSpecial = numberSeqSpecial.voucher();

                        transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                        transSpecialTxt.setDate(this.parmTransDate());
                        transSpecialTxt.setVoucher(voucherSpecial);

                        ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                        if (projTrans.transDate() >= this.parmTransDate())
                        {
                            voucherDate = projTrans.transDate();
                        }
                        else
                        {
                            voucherDate = this.parmTransDate();
                        }

                        ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                            voucherSpecial,
                            voucherDate,
                            SysModule::Project,
                            LedgerTransType::Project);

                        ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                        ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                        ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                        ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();

                        if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                        {
                            this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projItemTransCost.AmountMST);
                        }

                        ledgerVoucherSpecialTrx.end();
                    }
                }
                projItemTransCost.update();
            }
        }
        else
        {
            while select forupdate projItemTrans
                    where projItemTrans.ProjId == _projId
                    join forupdate projItemTransCost
                        where projItemTransCost.InventTransId == projItemTrans.InventTransId
                            && projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId
                            && projItemTransCost.TransStatus == ProjTransStatus::Eliminated
            {
                projTrans   = ProjTrans::newProjItemTransCost(projItemTransCost);

                projLedgerStatusTo = this.ledgerStatusCostTo(projTrans);
                if (projTrans.wipPeriod())
                {
                    projItemTransCost.TransStatus = ProjTransStatus::Estimated;
                }
                else
                {
                    projItemTransCost.TransStatus = ProjTransStatus::Posted;
                }

                if (projTrans.ledgerStatusCost() != projLedgerStatusTo)
                {
                    if (projTrans.wipPeriod())
                    {
                       ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, _ledgerVoucher, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();
                    }
                    else
                    {
                        numberSeqSpecial =  NumberSeq::newGetVoucher(ProjParameters::numRefProjPeriodVoucher());
                        voucherSpecial = numberSeqSpecial.voucher();

                        transSpecialTxt  = TransactionTxt::construct(LedgerTransTxt::ProjectPostingLedger);
                        transSpecialTxt.setDate(this.parmTransDate());
                        transSpecialTxt.setVoucher(voucherSpecial);

                        ledgerVoucherSpecialTrx     = LedgerVoucher::newLedgerPost(detailSummary, SysModule::Project, numberSeqSpecial.parmVoucherSequenceCode(), this.transactionLogType(), this.transactionLogTxt());
                        if (projTrans.transDate() >= this.parmTransDate())
                        {
                            voucherDate = projTrans.transDate();
                        }
                        else
                        {
                            voucherDate = this.parmTransDate();
                        }

                        ledgerVoucherObjectSpecial = LedgerVoucherObject::newVoucher(
                            voucherSpecial,
                            voucherDate,
                            SysModule::Project,
                            LedgerTransType::Project);

                        ledgerVoucherObjectSpecial.parmAcknowledgementDate(this.parmTransDate());
                        ledgerVoucherObjectSpecial.lastTransTxt(transSpecialTxt.txt());

                        ledgerVoucherSpecialTrx.addVoucher(ledgerVoucherObjectSpecial);

                        ProjPost::newEnterCost_TrxDetail(projItemTrans, projItemTransCost, ledgerVoucherSpecialTrx, projLedgerStatusTo,ProjOrigin::ReverseElimination, true).postTrans();

                        if (projGroup.isInvestmentProjGroup(isMultipleContractLineFeatureEnable))
                        {
                            this.eliminateInvestment(_projControlPeriodTable, ledgerVoucherSpecialTrx, NoYes::Yes, -projItemTransCost.AmountMST);
                        }

                        ledgerVoucherSpecialTrx.end();
                    }
                }
                projItemTransCost.update();
            }
          }
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    protected static ClassDescription description()
    {
        return "@SYS55483";
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>