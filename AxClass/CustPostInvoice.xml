<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustPostInvoice</Name>
	<SourceCode>
		<Declaration><![CDATA[
class CustPostInvoice
{
    CustInvoiceTable custInvoiceTable;
    CustInvoiceLine custInvoiceLine;

    CustFreeInvoiceCalcTotals custFreeInvoiceCalcTotals;
    Tax tax;

    TypeOfCreditmaxCheck typeOfCreditmaxCheck;

    boolean update;
    boolean creditError;
    boolean isPostingOK;
    NoYes   sendByEmail;
    private boolean documentIsCreditNote;

    boolean areDistributionsNeeded;
    RefRecId accountingEventId;
    TransferPolicy transferPolicy;
    PaymTerm paymTerm;

    boolean isUnrealizedVATEnabled;
    // Indicates whether realized or unrealized VAT exists in current posting invoice.
    // Value is set when method isSingleTaxType_TH is called.
    boolean isRealizedVAT;
    // MX
    boolean isElectronicInvoiceCFDIEnabled;

    PrintInMST_RU printInMST;
    Storno_RU storno_RU;
    container custInvoiceLineRec;
    container custInvoiceTransRec;
    TaxWithholdCalcFreeInvoice_IN taxWithholdCalcFreeInvoice;
    #ISOCountryRegionCodes

    //Bill of lading info which will be posted
    WMSCarrierName carrierName;
    WMSFreightChargeTerms freightChargeTerms;
    DlvNoOfCarrier_BR dlvNoOfCarrier;
    DlvStateRegistered_BR dlvStateRegistered;
    DlvTransportBrand_BR dlvTransportBrand;
    VolumeType_BR volumeType;
    VolumeQty_BR volumeQty;
    ItemNetWeight netWeight;
    GrossWeight grossWeight;
    boolean custInterestAdjustmentAction;
    boolean isInterestNoteReversal;
    boolean isLedgerVoucherPosted;
    boolean isInvoiceForInterestAdjustment;

    PlFiscalDocType fiscalDocType;

    AdvanceInvoiceSettlement_FreeText_W advanceInvoiceSettlement;
    RefRecId cashRegisterTerminalRecId_W;

    UseOriginalDocumentAsFacture_RU useOriginalDocumentAsFacture;

    #EECountryRegionCodes

    SettlementType settlementType;
    RefNum refNum;
    #define.UnknownEnumValue(255)

    protected LogisticsAddressCountryRegionISOCode countryRegion;

    private LedgerBondClient_RU ledgerBondClient;
    private ReasonRefRecId reasonRefRecId;
    private Set rAssetTransReversedSet = new Set(Types::Container);

    private RefRecId invoiceNumberNumSeqRefRecId;
    private RefRecId invoiceVoucherNumSeqRefRecId;
    private boolean isNumSeqPreallocated;
    private boolean allowSameAs;
    private boolean isInBatch;
    private Counter numberOfLines;
    private CustPostInvoiceInstrumentationLogger custPostInvoiceLogger;

    boolean isFinTagConfigurationSetForCurrent = FinTagConfiguration::isFinTagConfigurationSet(curExt());

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmLedgerBondClient</Name>
				<Source><![CDATA[
    protected LedgerBondClient_RU parmLedgerBondClient (LedgerBondClient_RU _ledgerBondClient = ledgerBondClient)
    {
        ledgerBondClient = _ledgerBondClient;
        return ledgerBondClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecId</Name>
				<Source><![CDATA[
    protected ReasonRefRecId parmReasonRefRecId(ReasonRefRecId _reasonRefRecId = reasonRefRecId)
    {
        reasonRefRecId = _reasonRefRecId;
        return reasonRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRefNum</Name>
				<Source><![CDATA[
    public RefNum parmRefNum(RefNum _refNum = refNum)
    {
        refNum = _refNum;
        return refNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseOriginalDocumentAsFacture_RU</Name>
				<Source><![CDATA[
    public UseOriginalDocumentAsFacture_RU parmUseOriginalDocumentAsFacture_RU(UseOriginalDocumentAsFacture_RU _useOriginalDocumentAsFacture = useOriginalDocumentAsFacture)
    {
        useOriginalDocumentAsFacture = _useOriginalDocumentAsFacture;

        return useOriginalDocumentAsFacture;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateNumAndVoucher</Name>
				<Source><![CDATA[
    NumberSeq allocateNumAndVoucher(boolean _creditNote = false)
    {
        RefRecId invoiceNumberId;
        RefRecId invoiceVoucherId;

        CustBillingClassification custBillingClassification;
        NumberSequenceTable numberSequenceTable;

        boolean voucherEqualsNumber;

        CustInvoiceLine tmpCustInvoiceLine;
        NumberSeq tmpNumberSeq;
        NumberSequenceDatatype numberDatatype;
        NumberSequenceDatatype voucherDatatype;
        RefRecId scopeId = NumberSeqScopeFactory::createDefaultScope().getId();

        #ISOCountryRegionCodes

        boolean countryRegion_RU = this.countryRegion == #isoRU;

        if (CustParameters::find().EnableChronologicalInvoiceNumbering_W)
        {
            tmpNumberSeq = ChronologicalNumberingSetup_W::getTmpNumberSeq(
                scopeId,
                _creditNote,
                custInvoiceTable.InvoiceDate,
                custInvoiceTable.NumberSequenceGroup,
                CustParameters::numRefCustInvoiceId(),
                CustParameters::numRefCustInvoiceVoucher(),
                CustParameters::numRefCustCreditNoteId(),
                CustParameters::numRefCustCreditNoteVoucher());
        }
        else
        if (custInvoiceTable.NumberSequenceGroup)
        {
            if (_creditNote)
            {
                numberDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustCreditNoteId().NumberSequenceDatatype);
                voucherDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustCreditNoteVoucher().NumberSequenceDatatype);

                if (countryRegion_RU)
                {
                    invoiceNumberId = NumberSequenceGroupRef::findNaturalKey(custInvoiceTable.Correct_RU ?
                                                                             CustParameters::numRefCustCorrectCreditNoteId_RU().NumberSequenceDatatype :
                                                                             CustParameters::numRefCustCreditNoteId().NumberSequenceDatatype,
                                                                             scopeId,
                                                                             custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                }
                else
                {
                    invoiceNumberId = NumberSequenceGroupRef::findNaturalKey(numberDatatype.RecId, scopeId, custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                }

                if (!invoiceNumberId)
                {
                    if (countryRegion_RU)
                    {
                        invoiceNumberId = NumberSequenceReference::findNaturalKey(custInvoiceTable.Correct_RU ?
                                                                                   CustParameters::numRefCustCorrectCreditNoteId_RU().NumberSequenceDatatype :
                                                                                   CustParameters::numRefCustCreditNoteId().NumberSequenceDatatype,
                                                                                   scopeId).NumberSequenceId;
                    }
                    else
                    {
                        invoiceNumberId = NumberSequenceReference::findNaturalKey(numberDatatype.RecId, scopeId).NumberSequenceId;
                    }
                }

                if (countryRegion_RU
                        && custInvoiceTable.Correct_RU ?
                    CustParameters::numRefCustCorrectCreditNoteVoucher_RU().AllowSameAs :
                    CustParameters::numRefCustCreditNoteVoucher().AllowSameAs)
                {
                    voucherEqualsNumber = true;
                    invoiceVoucherId = invoiceNumberId;
                }
                else
                {
                    if (countryRegion_RU)
                    {
                        invoiceVoucherId = NumberSequenceGroupRef::findNaturalKey(custInvoiceTable.Correct_RU ?
                                                                                  CustParameters::numRefCustCorrectCreditNoteVoucher_RU().NumberSequenceDatatype :
                                                                                  CustParameters::numRefCustCreditNoteVoucher().NumberSequenceDatatype,
                                                                                  scopeId,
                                                                                  custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                    }
                    else
                    {
                        invoiceVoucherId = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                    }

                    if (!invoiceVoucherId)
                    {
                        invoiceVoucherId = countryRegion_RU
                                            && custInvoiceTable.Correct_RU ?
                                           CustParameters::numRefCustCorrectCreditNoteVoucher_RU().NumberSequenceId :
                                           CustParameters::numRefCustCreditNoteVoucher().NumberSequenceId;
                    }
                }
            }
            else
            {
                if (isUnrealizedVATEnabled
                    && this.isDebitNote())
                {
                    // Debit note sequence will be generated.
                    numberDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustDebitNoteId().NumberSequenceDatatype);
                    voucherDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustDebitNoteVoucher().NumberSequenceDatatype);
                }
                else
                {
                    if (isUnrealizedVATEnabled
                        && this.isNoneFormatWithRealizedVAT())
                    {
                        // Free text tax invoice sequence will be generated.
                        numberDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustTaxInvoiceId().NumberSequenceDatatype);
                        voucherDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustTaxInvoiceVoucher().NumberSequenceDatatype);
                    }
                    else
                    {
                        numberDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustInvoiceId().NumberSequenceDatatype);
                        voucherDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustInvoiceVoucher().NumberSequenceDatatype);
                    }
                }

                // If current sales invoice is debit note format for MalaySia.
                // <GMY><GIN>
                if ((this.countryRegion == #isoMY || this.countryRegion == #isoIN) && !_creditNote && custInvoiceTable.hasLinesWithRefrence_MY())
                {
                    // Debit note sequence will be generated.
                    numberDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustDebitNoteId_MY().NumberSequenceDatatype);
                    voucherDatatype = NumberSequenceDatatype::find(CustParameters::numRefCustDebitNoteVoucher_MY().NumberSequenceDatatype);
                }
                // </GMY></GIN>

                if (countryRegion_RU)
                {
                    invoiceNumberId = NumberSequenceGroupRef::findNaturalKey(custInvoiceTable.Correct_RU ?
                                                                             CustParameters::numRefCustCorrectInvoiceId_RU().NumberSequenceDatatype :
                                                                             CustParameters::numRefCustInvoiceId().NumberSequenceDatatype,
                                                                             scopeId,
                                                                             custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                }
                else
                {
                    invoiceNumberId = NumberSequenceGroupRef::findNaturalKey(numberDatatype.RecId, scopeId, custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                }

                if (!invoiceNumberId)
                {
                    if (countryRegion_RU)
                    {
                        invoiceNumberId = NumberSequenceReference::findNaturalKey(custInvoiceTable.Correct_RU ?
                                                                                  CustParameters::numRefCustCorrectInvoiceId_RU().NumberSequenceDatatype :
                                                                                  CustParameters::numRefCustInvoiceId().NumberSequenceDatatype,
                                                                                  scopeId).NumberSequenceId;
                    }
                    else
                    {
                        invoiceNumberId = NumberSequenceReference::findNaturalKey(numberDatatype.RecId, scopeId).NumberSequenceId;
                    }
                }

                if (countryRegion_RU
                        && custInvoiceTable.Correct_RU ?
                    CustParameters::numRefCustCorrectInvoiceVoucher_RU().AllowSameAs :
                    CustParameters::numRefCustInvoiceVoucher().AllowSameAs)
                {
                    voucherEqualsNumber = true;
                    invoiceVoucherId = invoiceNumberId;
                }
                else
                {
                    if (countryRegion_RU)
                    {
                        invoiceVoucherId = NumberSequenceGroupRef::findNaturalKey(custInvoiceTable.Correct_RU ?
                                                                                  CustParameters::numRefCustCorrectInvoiceVoucher_RU().NumberSequenceDatatype :
                                                                                  CustParameters::numRefCustInvoiceVoucher().NumberSequenceDatatype,
                                                                                  scopeId,
                                                                                  custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                    }
                    else
                    {
                        invoiceVoucherId = NumberSequenceGroupRef::findNaturalKey(voucherDatatype.RecId, scopeId, custInvoiceTable.NumberSequenceGroup).NumberSequenceId;
                    }

                    if (!invoiceVoucherId)
                    {
                        invoiceVoucherId = countryRegion_RU && custInvoiceTable.Correct_RU ?
                                            CustParameters::numRefCustCorrectInvoiceVoucher_RU().NumberSequenceId :
                                            CustParameters::numRefCustInvoiceVoucher().NumberSequenceId;
                    }
                }
            }

            tmpNumberSeq = NumberSeq::newGetNumAndVoucherFromId(invoiceNumberId, invoiceVoucherId, voucherEqualsNumber);
        }
        else
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custInvoiceTable.CustBillingClassification)
            {
                custBillingClassification = CustBillingClassification::find(custInvoiceTable.CustBillingClassification);
            }

            if (_creditNote)
            {
                if (countryRegion_RU
                    && custInvoiceTable.Correct_RU)
                {
                    tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustCorrectCreditNoteId_RU(),
                                                                    CustParameters::numRefCustCorrectCreditNoteVoucher_RU());
                }
                else
                {
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custInvoiceTable.CustBillingClassification)
                    {
                        if (custBillingClassification.CreditNoteNumberSeq)
                        {
                            if (!NumberSeqReference::findNumberSeqReference(custBillingClassification.CreditNoteNumberSeq))
                            {
                                numberSequenceTable = NumberSequenceTable::find(CustParameters::numRefCustCreditNoteVoucher().NumberSequenceId);
                                tmpNumberSeq = NumberSeq::newGetNumAndVoucherFromCode(custBillingClassification.CreditNoteNumberSeq, numberSequenceTable.NumberSequence);
                            }
                            else
                            {
                                tmpNumberSeq = NumberSeq::newGetNumAndVoucher(NumberSeqReference::findNumberSeqReference(custBillingClassification.CreditNoteNumberSeq),
                                                    CustParameters::numRefCustCreditNoteVoucher());
                            }
                        }
                        else
                        {
                            tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustCreditNoteId(),
                                                                  CustParameters::numRefCustCreditNoteVoucher());
                        }
                    }
                    else
                    {
                        tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustCreditNoteId(),
                                                                CustParameters::numRefCustCreditNoteVoucher());
                    }
                }
            }
            else
            {
                if (countryRegion_RU
                    && custInvoiceTable.Correct_RU)
                {
                    tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustCorrectInvoiceId_RU(),
                                                                    CustParameters::numRefCustCorrectInvoiceVoucher_RU());
                }
                else
                {
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custInvoiceTable.CustBillingClassification)
                    {
                        if (custBillingClassification.InvoiceNumberSeq)
                        {
                            if (! NumberSeqReference::findNumberSeqReference(custBillingClassification.InvoiceNumberSeq))
                            {
                                numberSequenceTable = NumberSequenceTable::find(CustParameters::numRefCustInvoiceVoucher().NumberSequenceId);
                                tmpNumberSeq = NumberSeq::newGetNumAndVoucherFromCode(custBillingClassification.InvoiceNumberSeq, numberSequenceTable.NumberSequence);
                            }
                            else
                            {
                                tmpNumberSeq = NumberSeq::newGetNumAndVoucher(NumberSeqReference::findNumberSeqReference(
                                                    custBillingClassification.InvoiceNumberSeq), CustParameters::numRefCustInvoiceVoucher());
                            }
                        }
                        else
                        {
                            tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustInvoiceId(),
                                            CustParameters::numRefCustInvoiceVoucher());
                        }
                    }
                    else
                    {
                        if (isUnrealizedVATEnabled
                            && this.isDebitNote())
                        {
                            // Debit note sequence will be generated.
                            tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustDebitNoteId(),
                                CustParameters::numRefCustDebitNoteVoucher());
                        }
                        else
                        {
                            if (isUnrealizedVATEnabled
                                && this.isNoneFormatWithRealizedVAT())
                            {
                                // Free text tax invoice sequence will be generated.
                                tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustTaxInvoiceId(),
                                    CustParameters::numRefCustTaxInvoiceVoucher());
                            }
                            else
                            {
                                tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustInvoiceId(),
                                    CustParameters::numRefCustInvoiceVoucher());
                            }
                        }

                        // If current sales invoice is debit note format for MalaySia.
                        // We are in the !_creditNote code branch already.
                        // <GMY><GIN>
                        if ((this.countryRegion == #isoMY || this.countryRegion == #isoIN) && custInvoiceTable.hasLinesWithRefrence_MY())
                        {
                            // Debit note sequence will be generated.
                            tmpNumberSeq = NumberSeq::newGetNumAndVoucher(CustParameters::numRefCustDebitNoteId_MY(),
                                CustParameters::numRefCustDebitNoteVoucher_MY());
                        }
                        // </GMY></GIN>
                    }
                }
            }
        }

        // Italian functionality of VAT books and VAT book sections
        if (MultipleTaxIdReportingHelper::isLegalEntityOrTaxInCountryRegion(
            this.tax(), [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIT00028, funcName());

            if (! TaxBookSection::checkTaxBookSection(
                    tmpNumberSeq.parmVoucherSequenceId(),
                    custInvoiceTable.InvoiceDate))
            {
                throw error("@SYS21533");
            }
        }

        if (this.countryRegion == #isoIT && !TaxIntegrationUtils::isMultipleTaxIdEnabled())
        {
            while select * from tmpCustInvoiceLine
            index hint ParentRecIdIdx
            where tmpCustInvoiceLine.ParentRecId == custInvoiceTable.RecId
            {
                if ((CustInterestAdjustSkipTaxValidationOnFreeTextInvoiceFlight::instance().isEnabled() && !isInvoiceForInterestAdjustment && !TaxGroupData::checkTaxGroups(tmpCustInvoiceLine.TaxGroup, tmpCustInvoiceLine.TaxItemGroup))
                    || (!CustInterestAdjustSkipTaxValidationOnFreeTextInvoiceFlight::instance().isEnabled() && !TaxGroupData::checkTaxGroups(tmpCustInvoiceLine.TaxGroup, tmpCustInvoiceLine.TaxItemGroup)))
                {
                    throw error("@SYS21533");
                }
            }
        }

        if (BrazilParameters::isEnabled() && !this.parmIsCustInterestAdjustment_BR())
        {
            return this.postAllocateNumAndVoucherBR(tmpNumberSeq);
        }

        return tmpNumberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesBook_RU</Name>
				<Source><![CDATA[
    private boolean checkSalesBook_RU()
    {
        TmpTaxWorkTrans tmpTaxWorkTrans;

        boolean exportJour;
        boolean ret = true;

        if (this.tax())
        {
            tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
            while select tmpTaxWorkTrans
                group by TaxCode
            {
                if (TaxTable::find(tmpTaxWorkTrans.TaxCode).isExportVAT_RU())
                {
                    exportJour = true;
                    break;
                }
            }
        }

        if (CustParameters::taxation_RU(custInvoiceTable.InvoiceDate) == CustTaxation_RU::OnDelivery &&
            ! custInvoiceTable.vatOnPayment_RU &&
            ! exportJour)
        {
            ret = SalesBookTable_RU::canProcessDate(custInvoiceTable.InvoiceDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createExportDocument_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates export document.
    /// </summary>
    /// <param name="_custInvoiceTableRecId">
    /// The record id of free text invoice.
    /// </param>
    /// <param name="_custInvoiceJourRecId">
    /// The record id of customer invoice.
    /// </param>
    protected void createExportDocument_CN(
        RefRecId _custInvoiceTableRecId,
        RefRecId _custInvoiceJourRecId)
    {
        TaxIntgrExportDocumentGenerator_CN::generate(
            _custInvoiceJourRecId,
            tableNum(CustInvoiceJour),
            _custInvoiceTableRecId,
            tableNum(CustInvoiceTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fiscalDocType2State_PL</Name>
				<Source><![CDATA[
    private PlFiscalDocState fiscalDocType2State_PL(PlFiscalDocType _docType)
    {
        return _docType == PlFiscalDocType::FiscalDocument?PlFiscalDocState::FiscalDocument:PlFiscalDocState::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInclTaxAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and updates the field with required value.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The buffer is used to find the record.
    /// </param>
    public void getInclTaxAmount_IN(CustInvoiceJour _custInvoiceJour)
    {
        TaxAmountCur inclTaxAmount;
        TmpTaxWorkTrans tmpTaxWorkTrans;
        CustInvoiceLine custInvoicelineloc;
        FormulaDesigner_IN formulaDesigner;
        TaxableBasis_IN taxBasis;
        TmpTaxCalc_IN tmpTaxCalc;

        while select RecId, TableId, TaxItemGroup from custInvoicelineloc
            index hint ParentRecIdIdx
            where custInvoicelineloc.ParentRecId == custInvoiceTable.RecId
        {
            if (FormulaDesigner_IN::isPriceInclTaxLine(custInvoicelineloc.TaxItemGroup))
            {
                tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
                tmpTaxCalc = this.tax().tmpTaxCalc_IN();
                while select tmpTaxWorkTrans
                    where tmpTaxWorkTrans.SourceRecId == custInvoicelineloc.RecId &&
                          tmpTaxWorkTrans.SourceTableId == custInvoicelineloc.TableId &&
                          tmpTaxWorkTrans.TaxDirection != TaxDirection::UseTax &&
                          tmpTaxWorkTrans.TaxOrigin != TaxOrigin::TaxReversed
                {
                    formulaDesigner = FormulaDesigner_IN::findByTaxCode(tmpTaxWorkTrans.TaxItemGroup, tmpTaxWorkTrans.TaxCode);
                    if (formulaDesigner.PriceInclTax)
                    {
                        select tmpTaxCalc
                            where tmpTaxCalc.TaxCode == tmpTaxWorkTrans.TaxCode &&
                                   tmpTaxCalc.SourceTableID == custInvoicelineloc.TableId &&
                                   tmpTaxCalc.SourceRecID == custInvoicelineloc.RecId;

                        taxBasis = formulaDesigner.TaxableBasis;
                        if (taxBasis == TaxableBasis_IN::ExclAmount)
                        {
                            taxBasis = Tax::getTaxableBasis_IN(formulaDesigner);
                        }
                        if (TaxTable::find(tmpTaxWorkTrans.TaxCode).TaxType_IN != TaxType_IN::None
                            && (taxBasis == TaxableBasis_IN::LineAmount
                                || taxBasis == TaxableBasis_IN::Assessable))
                        {
                            if (!tmpTaxWorkTrans.SourceRegulateAmountCur)
                            {
                                inclTaxAmount += tmpTaxWorkTrans.SourceTaxAmountCur;
                            }
                            else
                            {
                                inclTaxAmount += tmpTaxWorkTrans.SourceRegulateAmountCur;
                            }
                            if (inclTaxAmount < 0)
                            {
                                inclTaxAmount += tmpTaxCalc.TaxOnCharges;
                            }
                            else
                            {
                                inclTaxAmount -= tmpTaxCalc.TaxOnCharges;
                            }
                        }
                    }
                }
            }
        }
        if (inclTaxAmount)
        {
            _custInvoiceJour.InvoiceAmount = CurrencyExchangeHelper::amount(_custInvoiceJour.InvoiceAmount - abs(inclTaxAmount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumAndVoucher_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     This method is used to get invoice number and voucher. This can be from the general number sequence or user defined auto numbering or it can be manual.
    /// </summary>
    /// <param name="_numberSeq">
    ///     The NumberSeq object from which invoice number and voucher can be obtained.
    /// </param>
    /// <returns>
    ///     The method always returns the voucher from the _numberSeq object, but gets the invoice id depending on the ManualInvoiceID_W or ManualNumbering_W field.
    /// </returns>
    private container getNumAndVoucher_W(NumberSeq _numberSeq)
    {
        container ret;

        if (custInvoiceTable.ManualInvoiceID_W != '')
        {
            _numberSeq.parmNumberSequenceCode('');
            _numberSeq.parmNumberSequenceId(0);

            ret = [custInvoiceTable.ManualInvoiceID_W, _numberSeq.voucher()];
        }
        else
        {
            if (custInvoiceTable.ManualNumbering_W)
            {
                if (!LtInvoiceAutoNumberingTable::checkLastDate(custInvoiceTable.DocNumberingCode_LT, custInvoiceTable.InvoiceDate, true))
                {
                    throw error("@SYS25904");
                }

                _numberSeq.parmNumberSequenceCode('');
                _numberSeq.parmNumberSequenceId(0);
                ret = [NumberSeq::newGetNumFromCode(LtInvoiceAutoNumberingTable::find(custInvoiceTable.DocNumberingCode_LT).NumberSequenceCode).num(),
                       _numberSeq.voucher()];

                LtInvoiceAutoNumberingTable::updateLastDate(custInvoiceTable.DocNumberingCode_LT, custInvoiceTable.InvoiceDate);
            }
            else
            {
                ret = _numberSeq.numAndVoucher();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBillOfLadingParameters_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the parameters used for bill of lading in free text invoice. They will be propagated until
    ///    post in fiscalDocJour.
    /// </summary>
    /// <param name="_carrierName">Carrier name</param>
    /// <param name="_freightChargeTerms">Freight Terms</param>
    /// <param name="_dlvNoOfCarrier">Vehicle license plate number</param>
    /// <param name="_dlvStateRegistered">Vehicle license plate state</param>
    /// <param name="_dlvTransportBrand">Packing brand</param>
    /// <param name="_volumeType">Packing type</param>
    /// <param name="_volumeQty">Packing quantity</param>
    /// <param name="_netWeight">Packing net weight</param>
    /// <param name="_grossWeight">Packing gross weight</param>
    public void initBillOfLadingParameters_BR(WMSCarrierName _carrierName = '',
                                              WMSFreightChargeTerms _freightChargeTerms = WMSFreightChargeTerms::Nofreight,
                                              DlvNoOfCarrier_BR _dlvNoOfCarrier = '',
                                              DlvStateRegistered_BR _dlvStateRegistered = '',
                                              DlvTransportBrand_BR _dlvTransportBrand = '',
                                              VolumeType_BR _volumeType = '',
                                              VolumeQty_BR _volumeQty = 0,
                                              ItemNetWeight _netWeight = 0,
                                              GrossWeight _grossWeight = 0)
    {
        carrierName = _carrierName;
        freightChargeTerms = _freightChargeTerms;
        dlvNoOfCarrier = _dlvNoOfCarrier;
        dlvStateRegistered = _dlvStateRegistered;
        dlvTransportBrand = _dlvTransportBrand;
        volumeType = _volumeType;
        volumeQty = _volumeQty;
        netWeight = _netWeight;
        grossWeight = _grossWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustCreditInvoicingJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>custVendCreditInvoicingJour</c> records.
    /// </summary>
    /// <param name="_custInvoiceTable">
    ///    The invoice record to link to an invoice journal record.
    /// </param>
    /// <param name="_custInvoiceJour">
    ///    The invoice journal record to link to an invoice table record.
    /// </param>
    protected void insertCustCreditInvoicingJour(CustInvoiceTable _custInvoiceTable, CustInvoiceJour _custInvoiceJour)
    {
        CustVendCreditInvoicingJour custVendCreditInvoicingJour;

        if (CustVendCreditInvoicingTable::useCreditInvoicingReporting())
        {
            if (_custInvoiceTable)
            {
                CustVendCreditInvoicingTable custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(_custInvoiceTable.TableId,
                    _custInvoiceTable.RecId);
                if (custVendCreditInvoicingTable)
                {
                    custVendCreditInvoicingJour.insertFromCustVendCreditInvoicingTable(custVendCreditInvoicingTable, _custInvoiceJour);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustCreditInvoicingTrans</Name>
				<Source><![CDATA[
    protected void insertCustCreditInvoicingTrans(CustInvoiceLine _custInvoiceLine,
                                                  CustInvoiceTrans _custInvoiceTrans)
    {
        CustVendCreditInvoicingLine custVendCreditInvoicingLine;
        CustVendCreditInvoicingTrans custVendCreditInvoicingTrans;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL]))
        {
            if (_custInvoiceLine)
            {
                custVendCreditInvoicingLine = CustVendCreditInvoicingLine::findRefId(_custInvoiceLine.TableId,
                                                                                     _custInvoiceLine.RecId);
                if (custVendCreditInvoicingLine)
                {
                    custVendCreditInvoicingTrans.insertFromCustVendCreditInvoicingLine(custVendCreditInvoicingLine,
                                                                                       _custInvoiceTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustInvoiceJourExtensionCN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>custVendCreditInvoicingJour</c> records.
    /// </summary>
    /// <param name="_custInvoiceTableRecId">
    ///    The invoice record to link to an invoice journal record.
    /// </param>
    /// <param name="_custInvoiceJourRecId">
    ///    The invoice journal record to link to an invoice table record.
    /// </param>
    protected void insertCustInvoiceJourExtensionCN(RecId _custInvoiceTableRecId,
                                                    RecId _custInvoiceJourRecId)
    {
        CustInvoiceJourExtension_CN custInvoiceJourExtensionCN;

        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            if (_custInvoiceTableRecId)
            {
                custInvoiceJourExtensionCN.insertFromCustInvoiceTable(_custInvoiceTableRecId,
                                                                      _custInvoiceJourRecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCustInvoiceTrasAsset</Name>
				<Source><![CDATA[
    private void insertCustInvoiceTrasAsset(RefRecId _custInvoiceTransRecid)
    {
        CustInvoiceTransAsset custInvoiceTransAsset;
        CustInvoiceLineAsset custInvoiceLineAsset;

        custInvoiceLineAsset = CustInvoiceLineAsset::findByCustInvoiceLineId(custInvoiceLine.RecId);
        if (custInvoiceLineAsset)
        {
            custInvoiceTransAsset.clear();
            custInvoiceTransAsset.AssetSaleFactor = custInvoiceLineAsset.AssetSaleFactor;
            custInvoiceTransAsset.CustInvoiceTrans = _custInvoiceTransRecid;
            custInvoiceTransAsset.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertElectronicInvoice_MX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the electronic invoice information.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The document source to create the electronic invoice information.
    /// </param>
    /// <param name="_numberSequenceTable">
    /// The record ID of a <c>numberSequenceTable</c> table that is used to get the invoice ID.
    /// </param>
    protected void insertElectronicInvoice_MX(
        CustInvoiceJour _custInvoiceJour,
        RefRecId _numberSequenceTable)
    {
        EInvoicePost_MX eInvoicePost;

        eInvoicePost = EInvoicePost_MX::construct(_custInvoiceJour, _numberSequenceTable, custInvoiceTable);

        eInvoicePost.createElectronicInvoiceJour();

        if (this.parmSendByEmail_MX())
        {
            eInvoicePost.createXMLFileAndPopulateSysMailTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDebitNote</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current free text invoice is debit note format.
    /// </summary>
    /// <returns>
    ///     Returns true if free text invoice is debit note format. Otherwise, returns false.
    /// </returns>
    private boolean isDebitNote()
    {
        CustInvoiceTableExtensionTH custInvoiceTableExtensionTH = custInvoiceTable.custinvoiceTableExtensionTH();
        return (custInvoiceTableExtensionTH.NoteFormat == TaxUnrealizedSalesNoteFormat::DebitNoteQuantity
            || custInvoiceTableExtensionTH.NoteFormat == TaxUnrealizedSalesNoteFormat::DebitNoteValue);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNoneFormatWithRealizedVAT</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether current free text invoice is NONE format and with realized VAT.
    /// </summary>
    /// <returns>
    ///     Returns true if free text invoice is NONE format and with realized VAT. Otherwise, returns false.
    /// </returns>
    private boolean isNoneFormatWithRealizedVAT()
    {
        return (custInvoiceTable.custInvoiceTableExtensionTH().NoteFormat == TaxUnrealizedSalesNoteFormat::None
            && isRealizedVAT);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPostingOK</Name>
				<Source><![CDATA[
    boolean isPostingOK()
    {
        return isPostingOK;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSingleTaxType</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Indicates whether only either realized VAT or unrealized VAT exists in current posting invoice.
    /// </summary>
    /// <returns>
    ///     Returns false if both realized and unrealized VAT exist. Otherwise, returns true.
    /// </returns>
    private boolean isSingleTaxType()
    {
        TaxTable taxTableRealized;
        TaxTable taxTableUnrealized;
        TaxGroupData taxGroupData;
        TaxOnItem taxOnItem;
        CustInvoiceLine custInvoiceLineLocal;
        boolean ret = true;

        // Tries to find realized tax.
        select firstonly TaxCode from taxTableRealized
            where (taxTableRealized.TaxType_TH == TaxType_TH::Normal
                    && taxTableRealized.PaymentTaxCode == '')
                || taxTableRealized.TaxType_TH == TaxType_TH::AverageRealized
            exists join taxGroupData
                where taxTableRealized.TaxCode == taxGroupData.TaxCode
            exists join taxOnItem
                where taxTableRealized.TaxCode == taxOnItem.TaxCode
            exists join custInvoiceLineLocal
                where taxGroupData.TaxGroup == custInvoiceLineLocal.TaxGroup
                    && taxOnItem.TaxItemGroup == custInvoiceLineLocal.TaxItemGroup
                    && custInvoiceLineLocal.ParentRecId == custInvoiceTable.RecId;
        if (taxTableRealized)
        {
            isRealizedVAT = true;
        }

        select firstonly TaxCode from taxTableUnrealized
            where (taxTableUnrealized.TaxType_TH == TaxType_TH::Normal
                    && taxTableUnrealized.PaymentTaxCode != '')
                || taxTableUnrealized.TaxType_TH == TaxType_TH::AverageUnrealized
            exists join taxGroupData
                where taxTableUnrealized.TaxCode == taxGroupData.TaxCode
            exists join taxOnItem
                where taxTableUnrealized.TaxCode == taxOnItem.TaxCode
            exists join custInvoiceLineLocal
                where taxGroupData.TaxGroup == custInvoiceLineLocal.TaxGroup
                    && taxOnItem.TaxItemGroup == custInvoiceLineLocal.TaxItemGroup
                    && custInvoiceLineLocal.ParentRecId == custInvoiceTable.RecId;

        if (taxTableRealized && taxTableUnrealized)
        {
            // Both realized VAT and unrealized VAT exist in current posting invoice.
            ret = checkFailed("@SYS4082809");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrChangePostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the posting profile on the payments , if the payments are prepay - then check
    /// the posting profile on the customer parameters. If that is different than the
    /// posting profile on the <c>CustInvoiceJour</c>, assign the posting profile found in the
    /// cust parameters.
    /// </summary>
    /// <returns>
    /// A record in the <c>PostingProfile</c> table.
    /// </returns>
    PostingProfile mcrChangePostingProfile()
    {
        int paymcount;
        boolean allPrepay = false;

        MCRCustPaymTable mcrCustPaymTable;
        CustParameters custParameters;
        PostingProfile postingProfileUsed;
        postingProfileUsed = custInvoiceTable.PostingProfile;

        paymCount =MCRCustPaymTable::count(custInvoiceTable.TableId, custInvoiceTable.RecId);

        select firstonly mcrCustPaymTable
            where mcrCustPaymTable.RefRecId ==custInvoiceTable.RecId
            && mcrCustPaymTable.RefTableId == custInvoiceTable.TableId
            && mcrCustPaymTable.Amount > 0
            && mcrCustPaymTable.IsPrepay == NoYes::No;
        if (mcrCustPaymTable)
        {
            allPrepay= false;
        }

        if ((paymCount == 1)
            || (paymCount > 1 && allPrepay == true))
        {
            //Once in this loop means that all payments be it single or multiple are prepays.
            mcrCustPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(custInvoiceTable.RecId, custInvoiceTable.TableId);
            if (mcrCustPaymTable.IsPrepay == NoYes::Yes)
            {
                custParameters = CustParameters::find();
                if (custParameters.PostingProfile != custParameters.PrepaymentPostingProfile)
                {
                    if (custInvoiceTable.PostingProfile != custParameters.PrepaymentPostingProfile)
                    {
                        postingProfileUsed = custParameters.PrepaymentPostingProfile;
                    }
                }
            }
        }
        return postingProfileUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(CustInvoiceTable _custInvoiceTable,
             TypeOfCreditmaxCheck _typeOfCreditmaxCheck = CustParameters::find().CreditMaxCheck,
             NoYes _creditError = NoYes::No,
             SettlementType _settlementType = #UnknownEnumValue)
    {
        update = true;
        custInvoiceTable = _custInvoiceTable;
        typeOfCreditmaxCheck = _typeOfCreditmaxCheck;
        creditError = _creditError;
        settlementType = _settlementType;

        countryRegion = SysCountryRegionCode::countryInfo(curext());

        isElectronicInvoiceCFDIEnabled = EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled();
        isUnrealizedVATEnabled = TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled();

        custPostInvoiceLogger = CustPostInvoiceInstrumentationLogger::createLogger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a new instance of the <c>CustPostInvoice</c> class.
    /// </summary>
    /// <param name = "_custInvoiceTable">
    /// The buffer of <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name = "_typeOfCreditmaxCheck">
    /// The type of credit max check.
    /// </param>
    /// <param name = "_creditError">
    /// A boolean indicating whether or not there is a credit error.
    /// </param>
    /// <param name = "_settlementType">
    /// The settlement type.
    /// </param>
    /// <returns>
    /// A new instance of the <c>CustPostInvoice</c> class.
    /// </returns>
    public static CustPostInvoice construct(
        CustInvoiceTable _custInvoiceTable,
        TypeOfCreditmaxCheck _typeOfCreditmaxCheck = CustParameters::find().CreditMaxCheck,
        NoYes _creditError = NoYes::No,
        SettlementType _settlementType = #UnknownEnumValue)
    {
        return new CustPostInvoice(_custInvoiceTable, _typeOfCreditmaxCheck, _creditError, _settlementType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransactionTxt_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes new <c>TransactionTxt</c> object
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// <c>CustInvoiceJour</c> record which is source of data for <c>TransactionTxt</c> object
    /// </param>
    /// <param name="_creditNote">
    /// Boolean value which indicates if current invoice is a credit note.
    /// </param>
    /// <returns>
    /// New <c>TransactionTxt</c> object
    /// </returns>
    /// <remarks>
    /// Copied from \Classes\CustInvoiceTableSourceDocument\getTransactoionTxt
    /// </remarks>
    protected TransactionTxt newTransactionTxt_RU(CustInvoiceJour _custInvoiceJour, boolean _creditNote)
    {
        TransactionTxt ret = TransactionTxt::construct();
        ret.setType(_creditNote ? LedgerTransTxt::CustCreditNoteLedger : LedgerTransTxt::CustInvoiceLedger);
        ret.setLanguage(_custInvoiceJour.LanguageId);
        ret.setVoucher(_custInvoiceJour.LedgerVoucher);
        ret.setFormLetter(_custInvoiceJour.InvoiceId);
        ret.setKey1(_custInvoiceJour.InvoiceAccount);
        ret.setKey2(CustTable::groupId(_custInvoiceJour.InvoiceAccount));
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingEvent</Name>
				<Source><![CDATA[
    public RefRecId parmAccountingEvent(RefRecId _accountingEventId = accountingEventId)
    {
        accountingEventId = _accountingEventId;
        return accountingEventId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvanceInvoiceSettlement_W</Name>
				<Source><![CDATA[
    public AdvanceInvoiceSettlement_FreeText_W parmAdvanceInvoiceSettlement_W(
        AdvanceInvoiceSettlement_FreeText_W _advanceInvoiceSettlement = advanceInvoiceSettlement)
    {
        advanceInvoiceSettlement = _advanceInvoiceSettlement;
        return advanceInvoiceSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAreDistributionsNeeded</Name>
				<Source><![CDATA[
    public boolean parmAreDistributionsNeeded(boolean _areDistributionsNeeded = areDistributionsNeeded)
    {
        areDistributionsNeeded = _areDistributionsNeeded;
        return areDistributionsNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashRegisterTerminalRecId</Name>
				<Source><![CDATA[
    public RefRecId parmCashRegisterTerminalRecId(RefRecId _cashRegisterTerminalRecId_W = cashRegisterTerminalRecId_W)
    {
        cashRegisterTerminalRecId_W = _cashRegisterTerminalRecId_W;
        return cashRegisterTerminalRecId_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceTable</Name>
				<Source><![CDATA[
    CustInvoiceTable parmCustInvoiceTable(CustInvoiceTable _custInvoiceTable = custInvoiceTable)
    {
        custInvoiceTable = _custInvoiceTable;
        return custInvoiceTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalDocType_PL</Name>
				<Source><![CDATA[
    public PlFiscalDocType parmFiscalDocType_PL(PlFiscalDocType _fiscalDocType = fiscalDocType)
    {
        fiscalDocType = _fiscalDocType;
        return fiscalDocType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintFacture_RU</Name>
				<Source><![CDATA[
    public NoYes parmPrintFacture_RU(NoYes _printFacture = false)
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintInMST_RU</Name>
				<Source><![CDATA[
    public PrintInMST_RU parmPrintInMST_RU(PrintInMST_RU _printInMST = printInMST)
    {
        printInMST = _printInMST;

        return printInMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSendByEmail_MX</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <paramref name="sendByEmail" /> parameter.
    /// </summary>
    /// <param name="_sendByEmail">
    ///     The value to set; optional.
    /// </param>
    /// <returns>
    ///     The value of the <paramref name="sendByEmail" /> parameter.
    /// </returns>
    public NoYes parmSendByEmail_MX(NoYes _sendByEmail = sendByEmail)
    {
        sendByEmail = _sendByEmail;

        return sendByEmail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmStorno_RU</Name>
				<Source><![CDATA[
    public Storno_RU parmStorno_RU(Storno_RU _storno_RU = storno_RU)
    {
        storno_RU = _storno_RU;

        return storno_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCustInterestAdjustment_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine whether the cust interest note adjustment action is performed or not.
    /// </summary>
    /// <param name="_custInterestAdjustmentAction">
    /// parm _custInterestAdjustmentAction holds the interest note action.
    /// </param>
    /// <returns>
    /// If interest note adjustment action performed then it returns TRUE, otherwise returns FALSE
    /// </returns>
    public boolean parmIsCustInterestAdjustment_BR(boolean _custInterestAdjustmentAction = custInterestAdjustmentAction)
    {
        custInterestAdjustmentAction = _custInterestAdjustmentAction;

        return custInterestAdjustmentAction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInterestNoteReversal</Name>
				<Source><![CDATA[
    public boolean parmIsInterestNoteReversal(boolean _isInterestNoteReversal = isInterestNoteReversal)
    {
        isInterestNoteReversal = _isInterestNoteReversal;

        return isInterestNoteReversal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInvoiceForInterestAdjustment</Name>
				<Source><![CDATA[
    internal boolean parmIsInvoiceForInterestAdjustment(boolean _isInvoiceForInterestAdjustment = isInvoiceForInterestAdjustment)
    {
        isInvoiceForInterestAdjustment = _isInvoiceForInterestAdjustment;

        return isInvoiceForInterestAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceNumberNumSeqRefRecId</Name>
				<Source><![CDATA[
    internal RefRecId parmInvoiceNumberNumSeqRefRecId(RefRecId _invoiceNumberNumSeqRefRecId = invoiceNumberNumSeqRefRecId)
    {
        invoiceNumberNumSeqRefRecId = _invoiceNumberNumSeqRefRecId;
        return invoiceNumberNumSeqRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceVoucherNumSeqRefRecId</Name>
				<Source><![CDATA[
    internal RefRecId parmInvoiceVoucherNumSeqRefRecId(RefRecId _invoiceVoucherNumSeqRefRecId = invoiceVoucherNumSeqRefRecId)
    {
        invoiceVoucherNumSeqRefRecId = _invoiceVoucherNumSeqRefRecId;
        return invoiceVoucherNumSeqRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsNumSeqPreallocated</Name>
				<Source><![CDATA[
    internal boolean parmIsNumSeqPreallocated(boolean _isNumSeqPreallocated = isNumSeqPreallocated)
    {
        isNumSeqPreallocated = _isNumSeqPreallocated;
        return isNumSeqPreallocated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowSameAs</Name>
				<Source><![CDATA[
    internal boolean parmAllowSameAs(boolean _allowSameAs = allowSameAs)
    {
        allowSameAs = _allowSameAs;
        return allowSameAs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInBatch</Name>
				<Source><![CDATA[
    internal boolean parmIsInBatch(boolean _isInBatch = isInBatch)
    {
        isInBatch = _isInBatch;
        return isInBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAllocateNumAndVoucherBR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates Brazilian specific journal and voucher number from the corresponding number sequences after
    /// the <c>CustPostInvoice.allocateNumAndVoucher</c> method.
    /// </summary>
    /// <param name="_returnValue">
    /// The return value of the <c>CustPostInvoice.allocateNumAndVoucher</c> method; optional.
    /// </param>
    /// <returns>
    /// A <c>NumberSeq</c> object.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// The fiscal document type is not specified.
    /// </exception>
    public NumberSeq postAllocateNumAndVoucherBR(NumberSeq _returnValue = null)
    {
        NumberSeq tmpNumberSeq = _returnValue;
        NumberSequenceTable numberSequenceTableNum;

        if (CustRelatedInvoice::findByCustInvoice(custInvoiceTable.RecId).InvoiceAssociationType == InvoiceAssociationType::AdjustingInvoice
            || custInvoiceTable.MCRGiftCard == NoYes::Yes)
        {
            return _returnValue;
        }

        if (!custInvoiceTable.FiscalDocumentType_BR)
        {
            throw error("@GLS62");
        }

        numberSequenceTableNum = FiscalDocumentType_BR::getFiscalDocumentNumberSequence(custInvoiceTable.FiscalDocumentType_BR);

        tmpNumberSeq.parmNumberSequenceId(numberSequenceTableNum.RecId);
        tmpNumberSeq.parmNumberSequenceCode(numberSequenceTableNum.NumberSequence);
        tmpNumberSeq.parmNumTableNum(numberSequenceTableNum);

        return tmpNumberSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFacture_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates facture by given <c>CustInvoiceJour</c> record
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// <c>CustInvoiceJour</c> record facture based upon
    /// </param>
    public void postFacture_RU(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFiscalDocument_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the Brazilian fiscal document.
    /// </summary>
    /// <param name="_custFreeInvoiceCalcTotals">
    /// The <c>CustFreeInvoiceCalcTotals</c> class instance to construct the <c>FiscalDocumentPost_BR</c> class instance.
    /// </param>
    /// <param name="_custInvoiceTable">
    /// The <c>CustInvoiceTable</c> table record to construct the <c>FiscalDocumentPost_BR</c> class instance.
    /// </param>
    /// <remarks>
    /// If the invoice amount is negative, this method cancels a fiscal document.
    /// </remarks>
    protected void postFiscalDocument_BR(CustFreeInvoiceCalcTotals _custFreeInvoiceCalcTotals, CustInvoiceTable _custInvoiceTable)
    {
        CustInvoiceJour custInvoiceJour = _custInvoiceTable.custInvoiceJour();
        FiscalDocumentPost_BR fiscalDocumentPost;

        if (_custInvoiceTable.MCRGiftCard == NoYes::Yes)
        {
            return;
        }

        if (custInvoiceJour.InvoiceAmount >= 0)
        {
            fiscalDocumentPost = new FiscalDocumentPost_BR(
                    FiscalDocumentParmDataCreator_BR::fromFreeTextInvoice(_custFreeInvoiceCalcTotals,
                                                                   _custInvoiceTable,
                                                                   carrierName,
                                                                   freightChargeTerms,
                                                                   dlvNoOfCarrier,
                                                                   dlvStateRegistered,
                                                                   dlvTransportBrand,
                                                                   volumeType,
                                                                   volumeQty,
                                                                   netWeight,
                                                                   grossWeight));

            fiscalDocumentPost.run();
        }
        else
        {
            FiscalDocumentPost_BR::cancelFiscalDocument(
                CustRelatedInvoice::findParentInvoiceForChild(custInvoiceTable.RecId).custInvoiceJour().fiscalDocument_BR(),
                custInvoiceJour.LedgerVoucher,
                custInvoiceJour.InvoiceDate,
                '',
                ReasonTableRef::find(custInvoiceJour.ReasonTableRef).ReasonComment);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax</Name>
				<Source><![CDATA[
    Tax tax(Tax _tax = tax)
    {
        tax = _tax;
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalcFreeInvoice_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets tax withhold calculation of free invoice.
    /// </summary>
    /// <param name="_taxWithholdCalcFreeInvoice">
    /// The instance of the <c>TaxWithholdCalcFreeInvoice_IN</c> class.
    /// </param>
    /// <returns>
    /// The instance of the <c>TaxWithholdCalcFreeInvoice_IN</c> class.
    /// </returns>
    TaxWithholdCalcFreeInvoice_IN taxWithholdCalcFreeInvoice_IN(TaxWithholdCalcFreeInvoice_IN _taxWithholdCalcFreeInvoice = taxWithholdCalcFreeInvoice)
    {
        taxWithholdCalcFreeInvoice = _taxWithholdCalcFreeInvoice;
        return taxWithholdCalcFreeInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpTaxWorkTrans_W</Name>
				<Source><![CDATA[
    private TmpTaxWorkTrans tmpTaxWorkTrans_W(TmpTaxWorkTrans _taxWorkTrans,
                                              CustInvoiceJour _custInvoiceJour,
                                              CustInvoiceLine _custInvoiceLine)
    {
        CurrencyCode companyCurrency= CompanyInfoHelper::standardCurrency();

        ttsbegin;

        while select forupdate _taxWorkTrans
            where ! _taxWorkTrans.TaxAutogenerated &&
                    _taxWorkTrans.SourceTableId == _custInvoiceLine.TableId &&
                    _taxWorkTrans.SourceRecId == _custInvoiceLine.RecId
        {
            if (_taxWorkTrans.SourceCurrencyCode == companyCurrency)
            {
                _taxWorkTrans.TaxAmount = _taxWorkTrans.transactionCurrencyTaxAmount();
            }
            else
            {
                _taxWorkTrans.TaxAmount = CurrencyExchangeHelper::mstAmount(_taxWorkTrans.transactionCurrencyTaxAmount(), _taxWorkTrans.SourceCurrencyCode, _taxWorkTrans.TransDate, _taxWorkTrans.euroTriangulation ? UnknownNoYes::Unknown : UnknownNoYes::No, _custInvoiceJour.ExchRate, _custInvoiceJour.ExchRateSecondary);
            }

            _taxWorkTrans.doUpdate();
        }

        ttscommit;

        return _taxWorkTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAsset_RU</Name>
				<Source><![CDATA[
    private void updateAsset_RU(LedgerVoucher _assetLedgerVoucherBase,
                                CustInvoiceTrans _custInvoiceTrans,
                                CustInvoiceJour _custInvoiceJour,
                                TransactionTxt _transTxt,
                                RAssetStandards _assetStandardsDefault)
    {
        CustInvoiceTrans_RU custInvoiceTrans_RU;
        LedgerVoucher assetLedgerVoucherOthers;
        LedgerVoucherObject assetLedgerVoucherObjectOthers;
        Voucher assetVoucher;
        RAssetStandards rassetStandards;
        RefRecId numberRefRecId;
        RAssetPost rAssetPost;
        RAssetOperationType rAssetOperationType;
        RAssetTrans rassetTrans;
        
        if (_assetLedgerVoucherBase)
        {
            rAssetPost = RAssetPost::construct(_custInvoiceTrans, _assetLedgerVoucherBase, _assetStandardsDefault.AssetStandardId);
            rAssetPost.run();

            custInvoiceTrans_RU = _custInvoiceTrans.custInvoiceTrans_RU();

            while select AssetStandardId from rassetStandards
                where rassetStandards.AssetId == custInvoiceTrans_RU.AssetId_RU &&
                      rassetStandards.AssetStandardId != _assetStandardsDefault.AssetStandardId &&
                      rassetStandards.Depreciation
            exists join rassetTrans
                where rassetTrans.AccountNum == rassetStandards.AssetId &&
                      rassetTrans.AssetStandardId == rassetStandards.AssetStandardId &&
                      rassetTrans.AssetTransType == RAssetTransType::Acquisition &&
                      !rassetTrans.StornoRecId
            {
                rAssetOperationType = RAssetOperationType::construct(RAssetTransType::DisposalSale,
                                                                     custInvoiceLine,
                                                                     _custInvoiceJour.InvoiceDate,
                                                                     rassetStandards.AssetStandardId);

                if (!rAssetOperationType.check())
                {
                    throw error("@SYS25904");
                }

                numberRefRecId = (select firstonly NumberSequenceTable from ledgerJournalName
                                      where ledgerJournalName.JournalType == LedgerJournalType::Assets_RU).NumberSequenceTable;

                assetVoucher = NumberSeq::newGetVoucherFromId(numberRefRecId, true).voucher();

                assetLedgerVoucherOthers = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                        SysModule::FixedAssets_RU,
                                                                        NumberSequenceTable::find(numberRefRecId).NumberSequence);

                assetLedgerVoucherObjectOthers = LedgerVoucherObject::newVoucher(assetVoucher,
                                                                                 _custInvoiceJour.InvoiceDate,
                                                                                 SysModule::FixedAssets_RU,
                                                                                 LedgerTransType::FixedAssets_RU,
                                                                                 NoYes::No);

                assetLedgerVoucherObjectOthers.lastTransTxt(_transTxt.txt());
                assetLedgerVoucherOthers.addVoucher(assetLedgerVoucherObjectOthers);

                if (assetLedgerVoucherOthers)
                {
                    rAssetPost = RAssetPost::construct(_custInvoiceTrans, assetLedgerVoucherOthers, rassetStandards.AssetStandardId);
                    rAssetPost.run();

                    assetLedgerVoucherOthers.end();
                    assetLedgerVoucherOthers.finalize();
                }
            }
            RAssetTable::updateCustInfo(custInvoiceTrans_RU.AssetId_RU, _custInvoiceJour.InvoiceAccount, '', _custInvoiceJour.InvoiceId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetReverse_RU</Name>
				<Source><![CDATA[
    private void updateAssetReverse_RU()
    {
        RAssetStandards rassetStandards;
        while select AssetStandardId from rassetStandards
            where rassetStandards.AssetId == custInvoiceLine.AssetId_RU &&
                  rassetStandards.Depreciation
        {
            RAssetTrans rAssetTrans = RAssetTrans::findLastType(custInvoiceLine.AssetId_RU,
                                                       rassetStandards.AssetStandardId,
                                                       RAssetTransType::DisposalSale,
                                                       false,
                                                       maxDate(),
                                                       true);
            RAssetTransactionReversal rAssetTransactionReversal = RAssetTransactionReversal::construct(rAssetTrans);
            rAssetTransactionReversal.initValue(rAssetTrans);
            rAssetTransactionReversal.parmReversalDate(custInvoiceTable.InvoiceDate);
            rAssetTransactionReversal.parmAssetTransReversedSet(rAssetTransReversedSet);
            rAssetTransactionReversal.runOperation();

            rAssetTransReversedSet.add([rAssetTrans.Voucher, rAssetTrans.DataAreaId, rAssetTrans.getAccountingDate()]);
        }
        RAssetTable::updateCustInfo(custInvoiceLine.AssetId_RU, '', '');
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if invoice is valid before posting.
    /// </summary>
    /// <param name = "_invoiceAmount">Invoice total in transaction currency.</param>
    /// <param name = "_creditNote">The boolean value indicating if invoice is a credit note.</param>
    /// <returns>The boolean value indicating if the invoice is valid.</returns>
    /// <remarks>Callers of this method external to <c>CustPostInvoice</c> should pass the value of _creditNote parameter explicitly if there is a need</remarks>
    boolean validate(AmountCur _invoiceAmount, boolean _creditNote = false)
    {
        boolean ok = true;
        numberOfLines = 0;
        CustTable custTable;

        #ISOCountryRegionCodes
        boolean countryRegion_RU = this.countryRegion == #isoRU;
        boolean countryRegion_PL = this.countryRegion == #isoPL;

        boolean firstPKWiUNotFound;
        CustPKWiUErrorLevel pkwiuErrorLevel;

        utcdatetime localDT;
        TaxParameters taxParameters;
        MainAccount mainAccount;
        TransDate lastValidDate;

        if (countryRegion_PL)
        {
            firstPKWiUNotFound = true;
            pkwiuErrorLevel = CustParameters::find().pkWiUCodeRequirement;
        }

        if (!custInvoiceTable)
        {
            throw error("@SYS26860");
        }
        if (custInvoiceTable.Posted)
        {
            ok = checkFailed("@SYS23025");
        }
        if (custInvoiceTable.ReleaseDate != utcDateTimeNull() && custInvoiceTable.ReleaseDate > DateTimeUtil::utcNow())
        {
            localDT = DateTimeUtil::applyTimeZoneOffset(custInvoiceTable.ReleaseDate, DateTimeUtil::getUserPreferredTimeZone());
            ok = checkFailed(strFmt("@SYS114593", datetime2str(localDT, DateFlags::FormatAll)));
        }

        if (countryRegion_RU
            && ! CustInvoiceLine::checkLines_RU(custInvoiceTable.RecId))
        {
            ok = checkFailed("@GLS102161");
        }

        if (!CustTable::exist(custInvoiceTable.OrderAccount))
        {
            ok = checkFailed(strFmt(CustTable::txtNotExist(), custInvoiceTable.OrderAccount));
        }
        custTable = custInvoiceTable.custTable_InvoiceAccount();

        if (! custTable)
        {
            ok = checkFailed(strFmt(CustTable::txtNotExist(), custInvoiceTable.InvoiceAccount));
        }
        if (ok)
        {
            if (!custTable.checkAccountBlocked(_invoiceAmount))
            {
                ok = false;
            }
            if (!this.validateCreditLimit(_invoiceAmount))
            {
                ok = false;
            }
        }

        if (ok)
        {
            // Validate the accounting distributions are valid and required dimensions were provided for each line.
            if (!SourceDocumentProvider::areSourceDocAccDistAccountValid(SourceDocumentHeader::find(custInvoiceTable.SourceDocumentHeader)))
            {
                ok = checkfailed(strFmt("@AccountsReceivable:DistributionsInvalidForInvoice", custInvoiceTable.InvoiceAccount));
            }
        }

        taxParameters = TaxParameters::find();
        while select custInvoiceLine
            where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
        {
            // Check if the account exists.
            mainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(custInvoiceLine.LedgerDimension);
            ok = (ok && this.checkMainAccount(mainAccount));

            //checkTax to check if no tax is allowed.
            if (ok && taxParameters.ValidateTaxCode)
            {
                MarkupTrans markupTrans;
                boolean isMarkupTrans;
                while select  markupTrans
                    where markupTrans.transRecid == custInvoiceTable.Recid
                    && markupTrans.transTableId == custInvoiceTable.TableId
                {
                    isMarkupTrans = true;
                    ok = Tax::checkNoTax(mainAccount,
                                markupTrans.TaxGroup,
                                markupTrans.TaxItemGroup);
                    if (!Ok)
                    {
                        break;
                    }
                }
                
                if (!isMarkupTrans)
                {
                    ok = Tax::checkNoTax(mainAccount,
                                custInvoiceLine.TaxGroup,
                                custInvoiceLine.TaxItemGroup);
                }

            }

            if (ok)
            {
                boolean validateIsBlockedForManualEntry =
                    !isInterestNoteReversal && !custInvoiceLine.shouldDefaultLedgerDimensionFromProject();

                // if ledger dimension was defaulted from project then skip validation if main account is blocked for manual entry
                ok = MainAccount::checkAllowPosting(mainAccount.MainAccountId,
                                                    LedgerPostingType::LedgerJournal,
                                                    false,
                                                    validateIsBlockedForManualEntry);
            }

            if (pkwiuErrorLevel != CustPKWiUErrorLevel::None
                && countryRegion_PL
                && !custInvoiceLine.pkWiUCode_PL)
            {
                if (firstPKWiUNotFound)
                {
                    switch (pkwiuErrorLevel)
                    {
                        case CustPKWiUErrorLevel::Warning :
                            warning("@GLS220259");
                            break;
                        case CustPKWiUErrorLevel::Error :
                            ok = false;
                            error("@GLS220259");
                            break;
                    }

                    firstPKWiUNotFound = false;
                }

                info(strFmt("@GLS220277", mainAccount.MainAccountId, custInvoiceLine.Description));
            }

            if (ok && custInvoiceTable.InclTax && (this.countryRegion == #isoLT || this.countryRegion == #isoHU))
            {
                ok = custInvoiceLine.validateExcludeTaxFromInvoice(custInvoiceTable.InclTax);
            }

            numberOfLines++;
        }

        if (!numberOfLines)
        {
            ok = checkFailed("@SYS69823");
        }

        if (TaxVATNumTable::isVATNumMandatory(CustParameters::find().MandatoryInvoiceVATNum, custInvoiceTable))
        {
            ok = checkFailed("@SYS55694");
        }

        if (countryRegion_RU
            && ! this.checkSalesBook_RU())
        {
            warning(strFmt("@GLS101326",
                           custInvoiceTable.InvoiceId,
                           custInvoiceTable.InvoiceDate));
            ok = checkFailed("@GLS101992");
        }

        if (countryRegion_RU && RestoredVATLogTable_RU::checkApproved(custInvoiceTable.InvoiceDate))
        {
            ok = checkFailed(RestoredVATLogTable_RU::txtApprovedMsg(custInvoiceTable.InvoiceDate));
        }

        if (ok && TradeBLWIParameters::isBLWIFeatureEnabled())
        {
            ok = TradeBLWIParameters::checkBLWI(custInvoiceTable.RecId, TradeBLWITypeOfForm::CustFreeInvoice, custInvoiceTable.custTable_InvoiceAccount());
        }

        ok = ok && this.validateEInvoiceFields();

        ok = ok && PaymMoneyTransferSlip::checkPaymentSlip_DK(custInvoiceTable.GiroType, custInvoiceTable.CurrencyCode);

        if (isUnrealizedVATEnabled)
        {
            ok = ok && this.isSingleTaxType();
        }

        if (custInvoiceTable.Payment && this.countryRegion == #isoES)
        {
            paymTerm = PaymTerm::find(custInvoiceTable.Payment);
            if (!custInvoiceTable.DeliveryDate_ES && paymTerm.UseDeliveryDateForDueDate_ES)
            {
                ok = checkFailed("@SYS4001053");
            }
            else
            {
                lastValidDate = PaymDueDateLimit_ES::getCurrentValues(paymTerm.DueDateLimitGroupId_ES).getLastValidDate(
                    paymTerm.UseDeliveryDateForDueDate_ES ? custInvoiceTable.DeliveryDate_ES : custInvoiceTable.InvoiceDate);
                if (custInvoiceTable.DueDate > lastValidDate)
                {
                    ok = checkFailed("@SYS4001058");
                }
            }
        }

        if (fiscalDocType == PlFiscalDocType::FiscalDocument &&
            ! custInvoiceTable.InclTax)
        {
            ok = checkFailed("@GLS109942");
        }

        if (this.countryRegion == #IsoHU)
        {
            ok = SalesInvoiceJournalCreate::checkDocumentDate_W(custInvoiceTable.PostalAddress,
                                                                custInvoiceTable.DocumentDate,
                                                                custInvoiceTable.InvoiceDate,
                                                                _creditNote,
                                                                fieldPName(CustInvoiceTable, DocumentDate),
                                                                fieldPName(CustInvoiceTable, InvoiceDate)) && ok;
        }

        if (this.countryRegion == #IsoMY)
        {
            CustRelatedInvoice custRelatedInvoice = CustRelatedInvoice::findByCustInvoice(custInvoiceTable.RecId);

            if (!custFreeInvoiceCalcTotals)
            {
                this.calculateTotals();
            }

            if ((custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount() < 0 && custRelatedInvoice && custRelatedInvoice.InvoiceAssociationType != InvoiceAssociationType::AdjustingInvoice)
            || (custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount() >= 0 && custInvoiceTable.hasLinesWithRefrence_MY()))
            {
                if (!custInvoiceTable.CorrectionReasonCode)
                {
                    ok = checkFailed("@SYP4860740");
                }
            }
        }

        if ((SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]) && CustParameters::find().EnableChronologicalInvoiceNumbering_W)
            || MultipleTaxIdReportingHelper::isLegalEntityOrTaxInCountryRegion(
               this.tax(), [#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            using (TaxBookContext context = TaxBookContext::construct())
            {
                context.parmIsLegalEntityOrTaxInIT(
                    MultipleTaxIdReportingHelper::isLegalEntityOrTaxInCountryRegion(
                        this.tax(), [#isoIT], MultipleTaxIdScope::VATDeclaration));
                ok = CustInvoiceJour::validateChronologicalDates_FR(custInvoiceTable) && ok;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether or not the specified main account record exists in the <c>MainAccount</c> table.
    /// </summary>
    /// <param name = "_mainAccount">
    ///     The <c>MainAccount</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the specified main account record exists; otherwise, false.
    /// </returns>
    protected boolean checkMainAccount(MainAccount _mainAccount)
    {
        boolean ok = true;
        if (!this.verifyMainAccountExists(_mainAccount.RecId))
        {
            ok = checkFailed(strFmt("@SYS9779", _mainAccount.MainAccountId));
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyMainAccountExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Verifies whether or not the specified main account record exists in the <c>MainAccount</c> table.
    /// </summary>
    /// <param name = "_mainAccountRecId">
    ///     The record ID of the <c>MainAccount</c> record.
    /// </param>
    /// <returns>
    ///     true if the specified record exists; otherwise, false.
    /// </returns>
    protected boolean verifyMainAccountExists(RecId _mainAccountRecId)
    {
        return MainAccount::checkExist(_mainAccountRecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreditLimit</Name>
				<Source><![CDATA[
    [Replaceable]
    protected boolean validateCreditLimit(AmountCur _invoiceAmount)
    {
        boolean ok = true;

        if(CustParameters::find().CreditLimitCheckFreeInvoice)
        {
            if (!CustTable::checkCreditLimit(custInvoiceTable.InvoiceAccount,
                                            typeOfCreditmaxCheck,
                                            custInvoiceTable.amountMST(_invoiceAmount),
                                            CustParameters::find().CreditLineError == CreditLineErrorType::Warning,
                                            custInvoiceTable.AgreementHeaderExt_RU,
                                            custInvoiceTable.TableId,
                                            custInvoiceTable.RecId
                                            ))
            {
                ok = false;
            }

        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEInvoiceFields</Name>
				<Source><![CDATA[
    private boolean validateEInvoiceFields()
    {
        LogisticsPostalAddress postalAddress;
        AmountMST lineAmount;
        boolean descriptionExists = true;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && CustTable::isCustDKPublic(custInvoiceTable.InvoiceAccount) == NoYes::Yes)
        {
            if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
                && !custInvoiceTable.contactPersonName())
            {
                warning(strFmt("@SYS26332", "@SYS100792"));
            }

            postalAddress = LogisticsPostalAddress::findRecId(custInvoiceTable.PostalAddress);
            if (!postalAddress.Street)
            {
                warning(strFmt("@SYS26332", "@SYS23438"));
            }

            if (!postalAddress.ZipCode)
            {
                warning(strFmt("@SYS26332", "@SYS12463"));
            }

            if (!postalAddress.City)
            {
                warning(strFmt("@SYS26332", "@SYS22249"));
            }

            if (!postalAddress.CountryRegionId)
            {
                warning(strFmt("@SYS26332", "@SYS7437"));
            }

            if (!CompanyInfo::find().CoRegNum)
            {
                warning(strFmt("@SYS26332", "@SYS969"));
            }

            if (LogisticsAddressCountryRegion::find(postalAddress.CountryRegionId).isOcode)
            {
                if (strLen(LogisticsAddressCountryRegion::find(postalAddress.CountryRegionId).isOcode) != 2)
                {
                    warning(strFmt("@SYS101033", postalAddress.CountryRegionId));
                }
            }
            else
            {
                warning(strFmt("@SYS101034", postalAddress.CountryRegionId));
            }

            if (Currency::find(custInvoiceTable.CurrencyCode).CurrencyCodeISO)
            {
                if (strLen(Currency::find(custInvoiceTable.CurrencyCode).CurrencyCodeISO) != 3)
                {
                    warning(strFmt("@SYS101035", custInvoiceTable.CurrencyCode));
                }
            }
            else
            {
                warning(strFmt("@SYS101036", custInvoiceTable.CurrencyCode));
            }

            while select custInvoiceLine
                where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
            {
                if (custInvoiceLine.Description == '')
                {
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
                    {
                        error("@SYS344734");
                        descriptionExists = false;
                        break;
                    }
                    else
                    {
                        warning("@SYS344734");
                        break;
                    }
                }

                lineAmount += custInvoiceLine.AmountCur;
            }
        }
        return descriptionExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateEInvoiceParameters_MX</Name>
				<Source><![CDATA[
    private boolean validateEInvoiceParameters_MX()
    {
        boolean ok = true;

        if (isElectronicInvoiceCFDIEnabled)
        {
            if (!CertificateHelper_MX::isCurrentCFDIPACPrivateKeyReadable() || !CertificateHelper_MX::isCurrentCFDIPrivateKeyReadable())
            {
                ok = checkFailed("@SYS341994");
            }

            if (!EInvoiceCFDIParameters_MX::schemaFileExists())
            {
                ok = checkFailed(strFmt("@SYS109820", EInvoiceCFDIParameters_MX::find().cfdiXsdFile));
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>vatRegData_W</Name>
				<Source><![CDATA[
    public container vatRegData_W(InvoiceId _invoiceId = "")
    {
        VATNum                  vatNum;
        Addressing              addressing;
        PlCustVendName          custVendName;
        PlTaxPeriodPaymentCode  taxPeriodPaymentCode;
        DocumentDate            documentDate;
        CzPostponeVAT           postponeVAT;
        VatDueDate_W            vatDate = custInvoiceTable.VatDueDate_W;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
        {
            documentDate = custInvoiceTable.DocumentDate;
            postponeVAT = custInvoiceTable.PostponeVAT && custInvoiceTable.creditNote_W();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            taxPeriodPaymentCode = custInvoiceTable.TaxPeriodPaymentCode_PL;
            CustTable custTable = CustTable::find(custInvoiceTable.InvoiceAccount);
            custVendName = custTable.name();
            addressing = custTable.address();
            vatNum = custTable.getPrimaryRegistrationNumber(TaxRegistrationTypesList::TAXID, custInvoiceTable.InvoiceDate);
        }

        return [ vatDate,
                 documentDate,
                 custVendName,
                 vatNum,
                 addressing,
                 taxPeriodPaymentCode,
                 postponeVAT,
                 NoYes::No ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides an entry point for the <c>CustPostInvoice</c> when it is called from a menu item.
    /// </summary>
    /// <param name = "args">An _args instance with the <c>CustInvoiceTable</c> record to be processed.</param>
    static void main(Args args)
    {
        CustInvoiceTable custInvoiceTable = args.record() as CustInvoiceTable;
        SettlementType   settlementType = #UnknownEnumValue;

        if (args.parmEnumType() == enumNum(SettlementType))
        {
            settlementType = args.parmEnum();
        }

        CustPostInvoice custPostInvoice = CustPostInvoice::construct(custInvoiceTable,
                                                                    CustParameters::find().CreditMaxCheck,
                                                                    NoYes::No,
                                                                    settlementType);
        custPostInvoice.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCorrection</Name>
				<Source><![CDATA[
    protected boolean isCorrection()
    {
        if ((countryRegion == #isoRU) && storno_RU)
        {
            creditError = true;
        }

        // any invoice can be a correction not just negative invoices
        return creditError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    protected boolean isCreditNote(AmountCur _invoiceAmount)
    {
        boolean creditNote;
        CustInvoiceTableExtensionTH custInvoiceTableExtensionTH;

        if (_invoiceAmount == 0 && custFreeInvoiceCalcTotals.custFreeInvoiceQty() < 0)
        {
            creditNote = NoYes::Yes;
        }
        else if (_invoiceAmount < 0 || custInvoiceTable.creditNote_W())
        {
            creditNote = NoYes::Yes;
        }
        else
        {
            if (this.countryRegion == #isoTH)
            {
                custInvoiceTableExtensionTH = custInvoiceTable.custInvoiceTableExtensionTH();
                if (isUnrealizedVATEnabled
                        && (custInvoiceTableExtensionTH.NoteFormat == TaxUnrealizedSalesNoteFormat::CreditNoteQuantity
                        || custInvoiceTableExtensionTH.NoteFormat == TaxUnrealizedSalesNoteFormat::CreditNoteValue))
                {
                    creditNote = NoYes::Yes;
                }
                else
                {
                    creditNote = NoYes::No;
                }
            }
            else
            {
                creditNote = NoYes::No;
            }
        }

        documentIsCreditNote = creditNote;

        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustoms_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check if any lines has Customs tax.
    /// </summary>
    /// <returns>
    ///     Returns true if at least one of the lines has Customs tax. Otherwise, returns false.
    /// </returns>
    protected boolean isCustoms_IN()
    {
        TaxTable taxTable;
        CustInvoiceLine custInvoiceLineLoc;

        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            TmpTaxWorkTrans tmpTaxWorkTransLoc = this.tax().tmpTaxWorkTrans();

            select firstonly RecId from custInvoiceLineLoc
                where custInvoiceLineLoc.ParentRecId == custInvoiceTable.RecId
                    exists join TaxCode from tmpTaxWorkTransLoc
                        where tmpTaxWorkTransLoc.SourceTableId == custInvoiceLineLoc.TableId
                            && tmpTaxWorkTransLoc.SourceRecId == custInvoiceLineLoc.RecId
                                exists join TaxType_IN from taxTable
                                    where taxTable.TaxCode == tmpTaxWorkTransLoc.TaxCode
                                        && taxTable.TaxType_IN == TaxType_IN::Customs;
        }

        return custInvoiceLineLoc.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceIdAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the invoice ID and a voucher number to use.
    /// </summary>
    /// <param name = "_custInvoiceTable"><c>CustInvoiceTable</c> record.</param>
    /// <param name = "_numberSeq">The number sequence to use for generating the invoice ID and voucher number.</param>
    /// <returns>A container holding an invoice ID and a voucher number.</returns>
    protected container getInvoiceIdAndVoucher(CustInvoiceTable _custInvoiceTable, NumberSeq _numberSeq)
    {
        boolean                          countryRegion_LTLV = (this.countryRegion == #isoLT || this.countryRegion == #isoLV);
        InvoiceId                        invoiceId;
        Voucher                          voucher;

        if (countryRegion_LTLV)
        {
            [invoiceId, voucher] = this.getNumAndVoucher_W(_numberSeq);
            if (! CustInvoiceJour::checkDuplicateNum_W(invoiceId, '', custInvoiceTable.InvoiceDate))
            {
                throw error("@SYS25904");
            }
        }
        else
        {
            [invoiceId, voucher] = _numberSeq.numAndVoucher();
        }

        if (custInvoiceTable.InvoiceId
            && RetailMCRChannelTable::findForCurrentUser().mcrEnableOrderCompletion)
        {
            invoiceId = custInvoiceTable.InvoiceId;
            voucher = custInvoiceTable.mcrLedgerVoucher;
        }

        if (!voucher)
        {
            throw error("@SYS71652");
        }

        return [invoiceId, voucher];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInitializeMoneyTransferSlip</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether to initialize <c>PaymMoneyTransferSlip</c> object.
    /// </summary>
    /// <returns>
    ///     true if initialization can be performed for <c>PaymMoneyTransferSlip</c> object; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldInitializeMoneyTransferSlip()
    {
        return SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO, #isoDK]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the journal header.
    /// </summary>
    /// <param name = "_numberSeq">The number sequence to use.</param>
    /// <param name = "_creditNote">Indicates whether this is a credit note or not.</param>
    /// <returns>The created <c>CustInvoiceJour</c></returns>
    protected CustInvoiceJour createJournalHeader(NumberSeq _numberSeq, NoYes _creditNote)
    {
        using (var createJournalActivityContext = custPostInvoiceLogger.activityContextWithCustomProperties(CustPostInvoiceInstrumentationConstants::CustPostInvoiceCreateJournal))
        {
            CustInvoiceJour                  custInvoiceJour;
            boolean                          countryRegion_RU = this.countryRegion == #isoRU;
            OfficialsServ_RU                 officialsServ;
            CustInvoiceJour_Officials        custInvoiceJour_Officials;
            CustInvoiceJour_PL               custInvoiceJour_PL;
            boolean                          countryRegion_PL = this.countryRegion == #isoPL;
            CustInvoiceJour_RU               custInvoiceJour_RU;
            InvoiceId                        invoiceId;
            Voucher                          voucher;
            boolean                          mcrCallCenterComplete = custInvoiceTable.InvoiceId && RetailMCRChannelTable::findForCurrentUser().mcrEnableOrderCompletion;
            CustInvoiceJourCorrectionType_RU custInvoiceJourCorrType;
            CustInvoiceJourSymbol            custInvoiceJourSymbol;
        
            custInvoiceTable.checkCreditNoteReason();

            if (this.isFTIValidToUsePreallocNumSeq(_creditNote))
            {
                [invoiceId, voucher] = this.getInvoiceIdAndVoucherFromPreallocation(custInvoiceTable, _numberSeq, _creditNote);
            }
            else
            {
                [invoiceId, voucher] = this.getInvoiceIdAndVoucher(custInvoiceTable, _numberSeq);
            }

            custInvoiceJour.clear();
            custInvoiceJour.initValue();

            this.initCustInvoiceJourFromCustInvoiceTable(custInvoiceJour, custInvoiceTable, _creditNote);

            custInvoiceJour.initFromCustFreeInvoiceCalcTotals(custFreeInvoiceCalcTotals);

            // Use the method MCRChangePostingProfile to determine what the posting
            // profile should be. If the payments are all prepays then the custinvoicejour
            // should have the prepayment posting profile specified on the custparameters.
            if (mcrCallCenterComplete)
            {
                custInvoiceJour.PostingProfile=this.mcrChangePostingProfile();
            }

            custInvoiceJour.InvoiceId = invoiceId;
            custInvoiceJour.LedgerVoucher = voucher;
            custInvoiceJour.Updated = NoYes::Yes;

            // check if there is duplicated invoice id and voucher in CustInvoiceJour
            if (!this.validateNoDuplicates(custInvoiceJour))
            {
                throw error("@SYS21533");
            }

            custInvoiceJour.calcDue();
            custInvoiceJour.calcCashDiscDate();
            custInvoiceJour.IsCorrection = this.isCorrection();

            if (CustConfigurablePaymentIdFeature_CH::isEnabled() || (this.shouldInitializeMoneyTransferSlip() && _numberSeq))
            {
                custInvoiceJour.setPaymId(_numberSeq);
            }

            if (isElectronicInvoiceCFDIEnabled)
            {
                EInvoicePost_MX::validateInvoiceDateForCFDI_MX(custInvoiceJour.InvoiceDate);
            }

            if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
            {
                officialsServ = new OfficialsServ_RU();
                officialsServ.initTableCustInvoice(custInvoiceJour);

                custInvoiceJour_Officials = custInvoiceJour.custInvoiceJour_Officials();
                custInvoiceJour_Officials.OffSessionId = officialsServ.newId();
                custInvoiceJour.packCustInvoiceJour_Officials(custInvoiceJour_Officials);
            }
            if (countryRegion_RU)
            {
                custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();
                custInvoiceJour_RU.PrintStandardCurrency_RU = this.parmPrintInMST_RU();
                custInvoiceJour.packCustInvoiceJour_RU(custInvoiceJour_RU);
            }

            if (countryRegion_PL)
            {
                custInvoiceJour_PL = custInvoiceJour.custInvoiceJour_PL();
                custInvoiceJour_PL.FiscalDocState_PL = this.fiscalDocType2State_PL(fiscalDocType);
                custInvoiceJour.packCustInvoiceJour_PL(custInvoiceJour_PL);
            }

            if (_numberSeq && MultipleTaxIdReportingHelper::isLegalEntityOrTaxInCountryRegion(
                this.tax(), [#isoIT], MultipleTaxIdScope::VATDeclaration))
            {
                CustInvoiceJour_W custInvoiceJour_W = custInvoiceJour.custInvoiceJour_W();
                custInvoiceJour_W.NumberSequenceId_IT = _numberSeq.parmNumberSequenceId();
                custInvoiceJour.SysExtensionSerializerMap::packExtensionTable(custInvoiceJour_W);
            }

            if (this.countryRegion == #isoTH && _numberSeq)
            {
                // saving the number sequence id to use it later for generating substitution invoice id
                CustInvoiceJourExtensionTH custInvoiceJourExtensionTH = custInvoiceJour.custInvoiceJourExtensionTH();
                custInvoiceJourExtensionTH.NumberSequenceId = _numberSeq.parmNumberSequenceId();
                custInvoiceJour.SysExtensionSerializerMap::packExtensionTable(custInvoiceJourExtensionTH);
            }

            // <GFR>
            if (this.countryRegion == #isoFR && _numberSeq)
            {
                CustInvoiceJour_FR custInvoiceJour_FR = custInvoiceJour.custInvoiceJour_FR();
                custInvoiceJour_FR.NumberSequenceId = _numberSeq.parmNumberSequenceId();
                custInvoiceJour.packCustInvoiceJour_FR(custInvoiceJour_FR);
            }
            // </GFR>

            this.createJournalHeaderPreInsert(custInvoiceJour);

            this.setInvoiceType_IT(custInvoiceJour);

            custInvoiceJour.insert();

            EInvoice_IT::newCustInvoice(custInvoiceJour);

            this.createJournalHeaderDelegate(custInvoiceJour);

            if (TaxSpecificExchangeRateHelper::isTaxSpecificExchRateEnabledByTable(custInvoiceTable.TableId, custInvoiceTable.RecId))
            {
                TaxSpecificExchangeRateHelper::transferTaxSpecificExchangeRateType(
                    custInvoiceTable.TableId,
                    custInvoiceTable.RecId,
                    custInvoiceJour.TableId,
                    custInvoiceJour.RecId);
            }
            else if (TaxParameters::isBankExchRateEnabled_W())
            {
                SalesTaxExchangeRateHelper::changeSourceRecord(custInvoiceTable.TableId, custInvoiceTable.RecId, custInvoiceJour.TableId, custInvoiceJour.RecId);
            }

            if (CustParameters::isTaxIntegrationSystem_CN())
            {
                this.insertCustInvoiceJourExtensionCN(custInvoiceTable.RecId, custInvoiceJour.RecId);
            }

            this.insertCustCreditInvoicingJour(custInvoiceTable, custInvoiceJour);

            if (countryRegion_RU)
            {
                CustInvoiceSalesLink::newFromInvoiceJour_RU(custInvoiceJour);

                custInvoiceJourCorrType.CustInvoiceJour = custInvoiceJour.RecId;
                custInvoiceJourCorrType.CorrectionType = custInvoiceTable.CorrectionType_RU;
                custInvoiceJourCorrType.insert();
            }

            Docu::copy(custInvoiceTable, custInvoiceJour);

            custInvoiceTable.Posted = NoYes::Yes;
            custInvoiceTable.InvoiceId = custInvoiceJour.InvoiceId;
            this.canExcludeFromDelayJournalization(createJournalActivityContext);
            createJournalActivityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalization,
                (custInvoiceTable.ExcludeFromDecoupledPostingProcess == NoYes::Yes) ? 'Yes': 'No');
            custInvoiceTable.update();

            if (this.countryRegion == #isoCZ)
            {
                custInvoiceJourSymbol.initFromCustInvoiceJourCust(custInvoiceJour);
                if (custInvoiceJourSymbol.CustInvoiceJour)
                {
                    custInvoiceJourSymbol.insert();
                }
            }

            if (countryRegion_RU)
            {
                RestoredVATLogTable_RU::setRecalcAll(custInvoiceTable.InvoiceDate);
            }

            return custInvoiceJour;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceType_IT</Name>
				<Source><![CDATA[
    private void setInvoiceType_IT(CustInvoiceJour _custInvoiceJour)
    {
        if (EXILFeatures_IT::isFeatureEnabled(EXILFeature::Exil2131))
        {
            CustInvoiceJour_W custInvoiceJour_W = _custInvoiceJour.custInvoiceJour_W();
            custInvoiceJour_W.InvoiceType_IT = this.isCreditNote(custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount()) ? InvoiceType_IT::CreditNote : InvoiceType_IT::Invoice;
            _custInvoiceJour.packCustInvoiceJour_W(custInvoiceJour_W);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInvoiceJourFromCustInvoiceTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CustInvoiceJour</c> record based on <c>CustInvoiceTable</c> and whether it is a credit note.
    /// </summary>
    /// <param name = "_custInvoiceJour">The <c>CustInvoiceJour</c> record to initialize.</param>
    /// <param name = "_custInvoiceTable">The <c>CustInvoiceTable</c> record.</param>
    /// <param name = "_creditNote">Whether this is a credit note or not.</param>
    protected void initCustInvoiceJourFromCustInvoiceTable(CustInvoiceJour _custInvoiceJour, CustInvoiceTable _custInvoiceTable, NoYes _creditNote)
    {
        if (_creditNote && refNum == RefNum::Interest)
        {
            _custInvoiceJour.initFromCustInvoiceTable(_custInvoiceTable, refNum);
        }
        else
        {
            _custInvoiceJour.initFromCustInvoiceTable(_custInvoiceTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInitLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Post initializes the <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The <c>LedgerVoucherObject</c> class object.
    /// </param>
    /// <param name = "_custInvoiceJour">
    ///     A <c>CustInvoiceJour</c> table buffer.
    /// </param>
    [Wrappable(true)]
    final protected void postInitLedgerVoucher(LedgerVoucherObject _ledgerVoucherObject, CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucher</c> class.
    /// </summary>
    /// <param name = "_correct">
    ///     The boolean value for correction.
    /// </param>
    /// <param name = "_numberSeq">
    ///     The number sequence for voucher code.
    /// </param>
    /// <param name = "_custInvoiceJour">
    ///     A <c>CustInvoiceJour</c> table buffer.
    /// </param>
    /// <param name = "_creditNote">
    ///     Whether this is a credit note or not.
    /// </param>
    /// <returns>
    ///     The <c>LedgerVoucher</c> class object.
    /// </returns>
    protected LedgerVoucher initLedgerVoucher(boolean _correct, NumberSeq _numberSeq, CustInvoiceJour _custInvoiceJour, NoYes _creditNote)
    {
        LedgerVoucher ledgerVoucher;
        LedgerVoucherObject ledgerVoucherObject;

        //If the payment term option to post offsetting a/r entries is selected
        //then make sure this transaction posts in detail so records are present
        //in the general journal even if the offsetting entries cancel out.
        //This is an Italian legal requirement for their fiscal journal (GFR 11110)
        paymTerm = PaymTerm::find(_custInvoiceJour.Payment, false);

        if (paymTerm.PostOffsettingAR == NoYes::Yes)
        {
            ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                                     SysModule::Cust,
                                                                     _numberSeq.parmVoucherSequenceCode());
            transferPolicy = TransferPolicy::TransferIndividual;
        }
        else
        {
            if (TaxParameters::isCustomsEnable_IN() && this.isCustoms_IN())
            {
                ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                                        SysModule::Cust,
                                                                        _numberSeq.parmVoucherSequenceCode());
            }
            else
            {
                ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                                        SysModule::Cust,
                                                                        _numberSeq.parmVoucherSequenceCode());
            }
            transferPolicy = TransferPolicy::Summarize;
        }

        if (_creditNote && refNum == RefNum::Interest)
        {
            ledgerVoucherObject = LedgerVoucherObject::newVoucher(_custInvoiceJour.LedgerVoucher,
                                                                  _custInvoiceJour.InvoiceDate,
                                                                  SysModule::Cust,
                                                                  LedgerTransType::Interest,
                                                                  _correct);
        }
        else
        {
            ledgerVoucherObject = LedgerVoucherObject::newVoucher(_custInvoiceJour.LedgerVoucher,
                                                                  _custInvoiceJour.InvoiceDate,
                                                                  SysModule::Cust,
                                                                  LedgerTransType::Cust,
                                                                  _correct);
        }

        ledgerVoucherObject.parmDocumentNumber(_custInvoiceJour.InvoiceId);
        ledgerVoucherObject.parmDocumentDate(_custInvoiceJour.DocumentDate);

        if (FeatureStateProvider::isFeatureEnabled(PostingZeroInvoicesInGeneralLedgerFeature::instance()))
        {
            ledgerVoucherObject.setIsZeroInvoice_IT(_custInvoiceJour.InvoiceAmount == 0);
        }

        this.postInitLedgerVoucher(ledgerVoucherObject, _custInvoiceJour);
        ledgerVoucher.addVoucher(ledgerVoucherObject);

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLines</Name>
				<Source><![CDATA[
    protected void createJournalLines(CustInvoiceJour _custInvoiceJour, LedgerVoucher _ledgerVoucher, boolean _creditNote)
    {
        CustInvoiceTrans custInvoiceTrans;
        CustInvoiceTransTaxExtensionIN custInvoiceTransTaxExtensionIN;
        LedgerVoucher assetLedgerVoucherBase;
        RAssetStandards assetStandardsDefault;
        boolean taxParametersChecked = TaxParameters::checkTaxParameters_IN();
        boolean countryRegion_RU = (this.countryRegion == #isoRU);
        boolean countryRegion_IN = (this.countryRegion == #isoIN);
        #EECountryRegionCodes
        boolean countryRegion_EE = (this.countryRegion == #isoCZ ||
                                                        this.countryRegion == #isoEE ||
                                                        this.countryRegion == #isoHU ||
                                                        this.countryRegion == #isoLT ||
                                                        this.countryRegion == #isoLV ||
                                                        this.countryRegion == #isoPL);

        Map lineAmountTaxMap = new Map(Types::Int64, Types::Real);
        TaxAmount localTaxAmount;
        LineAmountTax lineAmountTax;
        boolean taxSpecifyLine = countryRegion_RU && TaxParameters::find().TaxSpecifyLine;
        boolean isCreditNote_EELT;
        
        while select custInvoiceLine order by RecId
            where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
        {
            if (countryRegion_RU && custInvoiceLine.AssetId_RU)
            {
                assetStandardsDefault = RAssetStandards::find(custInvoiceLine.AssetId_RU, RAssetParameters::find().StandardIdDefault);
                if (assetStandardsDefault && assetStandardsDefault.Depreciation)
                {
                    assetLedgerVoucherBase = _ledgerVoucher;
                }
            }

            if (countryRegion_IN
                    && taxParametersChecked)
            {
                lineAmountTax = 0;
                if (FormulaDesigner_IN::isPriceInclTaxLine(custInvoiceLine.TaxItemGroup))
                {
                    lineAmountTax = Tax::getpriceInclTaxAmount_IN(tableNum(CustInvoiceLine), custInvoiceLine.RecId, custInvoiceLine.TaxItemGroup, this.tax().tmpTaxWorkTrans(), this.tax().tmpTaxCalc_IN());
                    lineAmountTaxMap.insert(custInvoiceLine.RecId, lineAmountTax);
                }
            }

            custInvoiceTrans.clear();
            custInvoiceTrans.initFromCustInvoiceJour(_custInvoiceJour);

            if (countryRegion_RU)
            {
                custInvoiceTrans.initFromTaxWorkTrans_RU(this.tmpTaxWorkTrans_W(this.tax().tmpTaxWorkTrans(),
                                                                _custInvoiceJour,
                                                                custInvoiceLine),
                                                                custInvoiceLine.TableId,
                                                                custInvoiceLine.RecId);
                localTaxAmount = custInvoiceTrans.TaxAmount;
            }

            custInvoiceTrans.initFromCustInvoiceLine(custInvoiceLine, this.tax());
            if (countryRegion_RU && taxSpecifyLine)
            {
                custInvoiceTrans.TaxAmount = localTaxAmount;
            }
            if (custInvoiceTable.InclTax || TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                custInvoiceTrans.LineAmountTax = custInvoiceLine.AmountCur - custInvoiceTrans.LineAmount;
            }

            custInvoiceTrans.LineAmountMST = _custInvoiceJour.amountMST(custInvoiceTrans.LineAmount);
            custInvoiceTrans.LineAmountTaxMST = _custInvoiceJour.amountMST(custInvoiceTrans.LineAmountTax);

            if (isFinTagConfigurationSetForCurrent
                && AccountsReceivableFinTagFlight::instance().isEnabled())
            {
                custInvoiceTrans.FinTag = custInvoiceLine.FinTag;
            }

            custInvoiceTrans.insert();

            if (countryRegion_IN)
            {
                custInvoiceTransTaxExtensionIN.TaxModelDocLineExtensionIN::initFromBaseTable(custInvoiceTrans);
                custInvoiceTransTaxExtensionIN.insert();
            }

            if (this.countryRegion == #isoPL)
            {
                TaxServiceTariff::insertTaxServiceTariffForNewParent(custInvoiceLine.TableId, custInvoiceLine.RecId, custInvoiceTrans.TableId, custInvoiceTrans.RecId);
                this.insertCustInvoiceTrasAsset(custInvoiceTrans.RecId);
            }

            this.insertCustCreditInvoicingTrans(custInvoiceLine, custInvoiceTrans);

            if (countryRegion_RU)
            {
                if (custInvoiceTrans.custInvoiceTrans_RU().AssetId_RU)
                {
                    if (custInvoiceTrans.LineAmount < 0)
                    {
                        this.updateAssetReverse_RU();
                    }
                    else
                    {
                        this.updateAsset_RU(assetLedgerVoucherBase,
                                            custInvoiceTrans,
                                            _custInvoiceJour,
                                            this.newTransactionTxt_RU(_custInvoiceJour, _creditNote),
                                            assetStandardsDefault);
                    }
                }
                if (custInvoiceLine.existsCorrLink_RU())
                {
                    CustInvoiceTransCorrLink_RU::createLink(
                            custInvoiceTrans.RecId,
                            custInvoiceLine.custInvoiceLineCorrLink_RU().CorrTransRecId);
                }
            }

            Docu::copy(custInvoiceLine, custInvoiceTrans);

            // If the transaction line is for a fixed asset make sure the selected asset passes validation
            // prior to posting the asset transaction. This will prevent the sale of any assets which do
            // not have a status that allows it to be sold.
            if (custInvoiceTrans.AssetId
                    && (!BrazilParameters::isEnabled() || custInvoiceTable.createCustTrans_BR()))
            {
                AssetPost assetPost = AssetPost::newCustInvoiceTrans(_ledgerVoucher, custInvoiceTrans);

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#IsoEE, #IsoLT])
                        && custInvoiceLine.RefReturnInvoiceTrans_W)
                {
                    isCreditNote_EELT = true;
                    assetPost.parmIsCreditNote(true);
                    assetPost.post(false);
                }
                else
                {
                    if (assetPost.check(false, false))
                    {
                        assetPost.parmIsCreditNote(_creditNote);
                        assetPost.post(false);
                    }
                    else
                    {
                        throw error("@SYS25904");
                    }
                }
            }

            //Store the first reason code on a line for use on the header
            if (!this.parmReasonRefRecId() && custInvoiceLine.ReasonRefRecId)
            {
                this.parmReasonRefRecId(custInvoiceLine.ReasonRefRecId);
            }
        }
        if (isCreditNote_EELT)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceEEU00004, funcName());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransLink_RU</Name>
				<Source><![CDATA[
    private void createTransLink_RU(CustInvoiceJour _custInvoiceJour)
    {
        LedgerTransLink_RU ledgerTransLink;
        CustInvoiceJour correctedInvoiceJour;
        CustInvoiceJour custInvoiceJour = _custInvoiceJour;
        CustInvoiceJour_RU custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

        if (! custInvoiceJour_RU.CorrectedInvoiceId_RU)
        {
            return;
        }

        correctedInvoiceJour = CustInvoiceJour::findFromCustTrans(custInvoiceJour_RU.CorrectedInvoiceId_RU,
                                                                  custInvoiceJour_RU.CorrectedInvoiceDate_RU,
                                                                  custInvoiceJour.InvoiceAccount);

        ledgerTransLink = LedgerTransLink_RU::newTrans(custInvoiceJour, correctedInvoiceJour);
        ledgerTransLink.parmReportingDate(custInvoiceJour_RU.CorrectedInvoiceDate_RU);
        ledgerTransLink.parmVoucherField(fieldnum(CustInvoiceJour, LedgerVoucher));
        ledgerTransLink.parmAccountingDateField(fieldnum(CustInvoiceJour, InvoiceDate));
        ledgerTransLink.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndValidatePaymentSchedule</Name>
				<Source><![CDATA[
    protected void createAndValidatePaymentSchedule(CustInvoiceJour _custInvoiceJour)
    {
        if (custInvoiceTable.PaymentSched && !CustPaymSched::exist(custInvoiceTable.TableId, custInvoiceTable.RecId))
        {
            custInvoiceTable.createPaymentSched();
        }
        else if (CFMParameters::isModuleEnabled())
        {
            CFMPlannedPaymentCalc cfmPlannedPaymentCalc = CFMPlannedPaymentCalc::construct(custInvoiceTable);

            if (cfmPlannedPaymentCalc)
            {
                cfmPlannedPaymentCalc.calc();
            }
        }

        if (CustPaymSched::exist(custInvoiceTable.TableId, custInvoiceTable.RecId))
        {
            custInvoiceTable.copyPaymentSched(_custInvoiceJour);
        }

        if (!_custInvoiceJour.validatePaymentSched())
        {
            throw error("@SYS25904");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processMarkup</Name>
				<Source><![CDATA[
    protected void processMarkup(CustInvoiceJour _custInvoiceJour, LedgerVoucher _ledgerVoucher)
    {
        using (var processMarkupActivityContext = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoiceProcessMarkup))
        {
            CustInvoiceTrans custInvoiceTrans;
            boolean countryRegion_RU = this.countryRegion == #isoRU;

            // <GTE>
            boolean countryRegion_IN = this.countryRegion == #isoIN;
            boolean isGTEEnabled = TaxSolutionScopeIntegrationUtil::isCompanyEnabled();
            // </GTE>

            Markup markup = new Markup(_custInvoiceJour.CurrencyCode);

            // Markups in cust invoices
            if (countryRegion_RU)
            {
                markup.setTax(this.tax());

                this.parmLedgerBondClient(_ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU());
                if (this.parmLedgerBondClient())
                {
                    this.parmLedgerBondClient().addNewLogObject();
                }
            }

            markup.parmExchRate(_custInvoiceJour.ExchRate,
                                    _custInvoiceJour.ExchRateSecondary,
                                    Currency::noYes2UnknownNoYes(_custInvoiceJour.Triangulation));

            if (countryRegion_RU && TaxParameters::find().TaxSpecPosting_RU)
            {
                markup.parmCustInvoiceAccount_RU(custInvoiceTable.InvoiceAccount);
            }
            markup.postInvoice(1,
                                   _custInvoiceJour.SalesBalance,
                                   custInvoiceTable,
                                   _ledgerVoucher,
                                   custInvoiceTable.DefaultDimension,
                                   _custInvoiceJour,
                                   0,
                                   '',
                                   true);

            // Process Charges on FTI line level
            if (SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
            {
                while select custInvoiceTrans
                        where custInvoiceTrans.SalesId == _custInvoiceJour.SalesId
                        && custInvoiceTrans.InvoiceId == _custInvoiceJour.InvoiceId
                        && custInvoiceTrans.InvoiceDate == _custInvoiceJour.InvoiceDate
                        && custInvoiceTrans.NumberSequenceGroup == _custInvoiceJour.NumberSequenceGroup
                        join custInvoiceLine
                            where custInvoiceLine.SourceDocumentLine == custInvoiceTrans.SourceDocumentLine
                {
                    markup.postInvoice(custInvoiceTrans.Qty,
                                       custInvoiceTrans.LineAmount,
                                       custInvoiceLine,
                                       _ledgerVoucher,
                                       custInvoiceTrans.DefaultDimension,
                                       custInvoiceTrans,
                                       0,
                                       '',
                                       true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTax</Name>
				<Source><![CDATA[
    protected CustInvoiceCalcTax postTax(CustInvoiceJour _custInvoiceJour, LedgerVoucher _ledgerVoucher)
    {
        using (var postTaxActivityContext = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoicePostTax))
        {
            CustInvoiceCalcTax custInvoiceCalcTax = CustInvoiceCalcTax::construct(_custInvoiceJour);

            if (this.countryRegion == #isoRU)
            {
                AmountAdjustEngineCustInvoice_W::adjustInvoiceJour(_custInvoiceJour);
            }

            if (TaxWithholdParameters_IN::checkTaxParameters() && custInvoiceTable.custTable_InvoiceAccount().TaxWithholdCalculate_IN)
            {
                custInvoiceCalcTax.taxWithholdCalcFreeInvoice_IN(taxWithholdCalcFreeInvoice);
            }
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) || BrazilParameters::isEnabled() || TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
            {
                custInvoiceCalcTax.tax(this.tax());
            }

            custInvoiceCalcTax.post(LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                            NoYes::Yes);

            if (TaxIntegrationUtils::isISVApiActivated(TaxServiceISVApiTypes::PostTax))
            {
                TaxIntegrationBusinessProcess businessProcess = TaxIntegrationUtils::getBusinessProcessForCustInvoiceTable(custInvoiceTable);
                if (TaxIntegrationUtils::getTaxSolutionProviderTypeByBusinessProcess(businessProcess) == TaxSolutionProviderType::ISV)
                {
                    this.transferPackedTaxCalculationInput(_custInvoiceJour);
                    TaxModuleType taxModuleTypeLocal = (businessProcess == TaxIntegrationBusinessProcess::Project) ? TaxModuleType::Project : TaxModuleType::FreeTxtInvoice;
                    TaxIntegrationFacade::postTaxToISV(_custInvoiceJour.TableId, _custInvoiceJour.RecId, taxModuleTypeLocal);
                }
            }

            return custInvoiceCalcTax;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferPackedTaxCalculationInput</Name>
				<Source><![CDATA[
    private void transferPackedTaxCalculationInput(CustInvoiceJour _custInvoiceJour)
    {
        TaxIntegrationCalculationInputPersisted packedTaxCalculationInput;

        if (isConfigurationkeyEnabled(configurationKeyNum(FreeTextInvoiceCorrection))
            && CustRelatedInvoice::doesInvoiceExistForType(custInvoiceTable.RecId, InvoiceAssociationType::AdjustingInvoice))
        {
            // If the posting invoice is an adjusting invoice, copy the packed tax calculation input from the original invoice.
            CustInvoiceTable originalInvoiceTable = CustRelatedInvoice::findParentInvoiceForChild(custInvoiceTable.RecId);

            TaxIntegrationCalculationInputPersisted packedCalculationInputOfOriginalInvoice
                = TaxIntegrationCalculationInputPersisted::findByHeadingTable(originalInvoiceTable.TableId, originalInvoiceTable.RecId, TaxModuleType::FreeTxtInvoice);
            
            packedTaxCalculationInput.HeadingTableId = custInvoiceTable.TableId;
            packedTaxCalculationInput.HeadingRecId = custInvoiceTable.RecId;
            packedTaxCalculationInput.JournalTableId = _custInvoiceJour.TableId;
            packedTaxCalculationInput.JournalRecId = _custInvoiceJour.RecId;
            packedTaxCalculationInput.PackedTaxCalculationInput = packedCalculationInputOfOriginalInvoice.PackedTaxCalculationInput;
            packedTaxCalculationInput.Status = TaxIntegrationPersistedTaxCalculationInputStatus::Original;
            packedTaxCalculationInput.Source = TaxModuleType::FreeTxtInvoice;
            packedTaxCalculationInput.insert();
        }
        else
        {
            update_recordset packedTaxCalculationInput
                setting
                    JournalTableId = _custInvoiceJour.TableId,
                    JournalRecId = _custInvoiceJour.RecId
                where packedTaxCalculationInput.HeadingTableId == custInvoiceTable.TableId
                    && packedTaxCalculationInput.HeadingRecId == custInvoiceTable.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSettlementTypeForDelayedJournalization</Name>
				<Source><![CDATA[
    protected void setSettlementTypeForDelayedJournalization(CustVoucher _custVoucher)
    {
        //Set the settlement to None when split is turned on to make sure we do not run the settlement logic
        if (EnableEnhancedDelaySDAFJournalizerForSourceDocuments::isEnabled() &&
            custInvoiceTable.ExcludeFromDecoupledPostingProcess == NoYes::No &&
            CustParameters::find().AutoSettle == NoYes::Yes && !SourceDocumentDetermineDistributionFactorsForSettlementFlight::instance().isEnabled())
        {
            _custVoucher.parmSettlementType(SettlementType::None);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVoucher</Name>
				<Source><![CDATA[
    protected CustVoucher initCustVoucher(CustInvoiceJour _custInvoiceJour, boolean _creditNote)
    {
        CustInvoiceLine custInvoiceLineLoc;
        CustInvoiceTrans custInvoiceTrans;
        LedgerTransTxt ledgerTransTxt = _creditNote ? LedgerTransTxt::CustCreditNoteCust : LedgerTransTxt::CustInvoiceCust;
        CustVoucher custVoucher = CustVoucher::newCustVoucherFreeInvoice(
                ledgerTransTxt,
                _custInvoiceJour,
                custInvoiceTable);

        // Set settlement type if variable is set to a valid value
        if (settlementType != #UnknownEnumValue)
        {
            custVoucher.parmSettlementType(settlementType);
        }

        this.setSettlementTypeForDelayedJournalization(custVoucher);

        custVoucher.parmTypeOfCreditmaxCheck(typeOfCreditmaxCheck);

        custVoucher.parmReasonRefRecID(this.parmReasonRefRecId());

        if (custInvoiceTrans.AssetId)
        {
            custVoucher.parmExchangeRateDate(AssetBook::find(custInvoiceTrans.AssetId, custInvoiceTrans.AssetBookId).exchangeRateDate());
        }

        // set taxWithholdAmount, TDSGroup, TCSGroup on the CustVoucher object.
        // This are used for population of CustTrans and CustOpenTrans tables.
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            CustInvoiceLineTaxExtensionIN custInvoiceLineTaxExtensionIN;
            select firstonly RecId from custInvoiceLineLoc
                join TDSGroup, TCSGroup from custInvoiceLineTaxExtensionIN
                        where custInvoiceLineTaxExtensionIN.CustInvoiceLine == custInvoiceLineLoc.RecId
                            && (custInvoiceLineTaxExtensionIN.tdsGroup != '' || custInvoiceLineTaxExtensionIN.tcsGroup != '')
                            && custInvoiceLineLoc.ParentRecId == custInvoiceTable.RecId;

            if (custFreeInvoiceCalcTotals)
            {
                custVoucher.parmTaxWithholdAmount_IN(custFreeInvoiceCalcTotals.custFreeInvoiceTaxWithholdTotal_IN());
                custVoucher.parmTaxWithholdAmountOriginCur_IN(custFreeInvoiceCalcTotals.taxWithholdCalcFreeInvoice_IN().totalTaxAmountOriginCur());
                custVoucher.parmIsTDSApplicable_IN(custInvoiceLineTaxExtensionIN.tdsGroup != '');
                custVoucher.parmIsTCSApplicable_IN(custInvoiceLineTaxExtensionIN.tcsGroup != '');
            }
        }

        if (_creditNote)
        {
            custVoucher.parmTransRefType(CustTransRefType::CreditNote);
        }
        else
        {
            custVoucher.parmTransRefType(CustTransRefType::Invoice);
        }

        custVoucher.parmTransRefId(custInvoiceTable.InvoiceId);

        custVoucher.parmExchRate(_custInvoiceJour.ExchRate);

        custVoucher.parmExchRateSecondary(_custInvoiceJour.ExchRateSecondary);

        custVoucher.parmReportingCurrencyExchRate(_custInvoiceJour.ReportingCurrencyExchangeRate);

        custVoucher.parmCashRegisterTerminalRecId(cashRegisterTerminalRecId_W);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVoucher</Name>
				<Source><![CDATA[
    protected void postCustVoucher(CustVoucher _custVoucher, CustInvoiceJour _custInvoiceJour, RecId _accountingEventRecId, LedgerVoucher _ledgerVoucher)
    {
        using (var postCustVoucher = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoicePostCustVoucher))
        {
            CustTrans custTrans;

            if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
            {
                // The paymorderID was getting lost when calling the post
                // on the cust voucher.
                custTrans.mcrPaymOrderID=_custInvoiceJour.InvoiceId;
            }

            _custVoucher.parmAccountingEventReference(_accountingEventRecId);

            if (BrazilParameters::isEnabled())
            {
                _custVoucher.parmAmountCur(custFreeInvoiceCalcTotals.custTransAmount_BR());
            }

            if (!BrazilParameters::isEnabled() || custInvoiceTable.createCustTrans_BR())
            {
                _custVoucher.post(_ledgerVoucher, custTrans, NoYes::No, Currency::noYes2UnknownNoYes(_custInvoiceJour.Triangulation), false, true);
            }

            if (this.parmAdvanceInvoiceSettlement_W())
            {
                this.parmAdvanceInvoiceSettlement_W().reverseSettlement(_custInvoiceJour);
                this.parmAdvanceInvoiceSettlement_W().settleNow(_custInvoiceJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSourceDocument</Name>
				<Source><![CDATA[
    protected AccountingEventRecId processSourceDocument(LedgerVoucher _ledgerVoucher, CustInvoiceCalcTax _custInvoiceCalcTax)
    {
        using (var processSourceDocActivityContext = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoiceProcessSourceDocument))
        {
            //do distribution before calling to journalize the document
            
            SourceDocument sourceDocument = SourceDocument::newFromSourceDocumentImplementation(custInvoiceTable);            
            const SourceDocumentProcessorCaller NullCaller = null;
            const boolean doAsynchronousLineTransition = false;

            if (SourceDocumentDistributeDocumentToAllowSetBasedTransitionFlight::instance().isEnabled())
            {
                SourceDocumentProcessorFacade::submitSourceDocumentLinesForHeader(
                    custInvoiceTable,
                    SourceDocumentLineAccountingStatus::FullyDistributed,
                    NullCaller,
                    curUserId(),
                    doAsynchronousLineTransition);
            }

            //Take the new path when the feature to delay jouralization is enabled 
            if (EnableEnhancedDelaySDAFJournalizerForSourceDocuments::isEnabled() && 
                custInvoiceTable.ExcludeFromDecoupledPostingProcess == NoYes::No)
            {
                //Only call distribute again if we have the flight above disabled otherwise the document should be distributed
                if (!SourceDocumentDistributeDocumentToAllowSetBasedTransitionFlight::instance().isEnabled())
                {
                    SourceDocumentProcessorFacade::submitSourceDocumentLinesForHeader(
                    custInvoiceTable,
                    SourceDocumentLineAccountingStatus::FullyDistributed,
                    NullCaller,
                    curUserId(),
                    doAsynchronousLineTransition);
                }                

                AccountingEventRecId accountingEventRecid = SourceDocumentAccountingEventForDelayedJournalizationProcessor::createAccountingEventForDelayedJournalizationOfSourceDocument
                (
                    custInvoiceTable,
                    AccountingEventType::Original,
                    custInvoiceTable.DataAreaId
                );

                if (accountingEventRecid != 0)
                {
                    return accountingEventRecid;
                }
            }
            else
            {
                TaxUncommitted taxUncommitted;
                List taxUncommittedHUList;
                SourceDocumentLine sourceDocumentLine;
                boolean isContinuousHU;

                const boolean UpdateImplementationFalse = false;
                const boolean DoTransitionToCompletedStateAccountFullyQualifiedValidationTrue = true;
                const SourceDocumentLineImplementationList NullSourceDocumentLineImplementationList = null;
        
                SourceDocumentProcessorFacade::submitSourceDocumentImplementation(
                    custInvoiceTable,
                    UpdateImplementationFalse,
                    SourceDocumentAccountingStatus::Completed,
                    NullCaller,
                    curUserId(),
                    DoTransitionToCompletedStateAccountFullyQualifiedValidationTrue,
                    NullSourceDocumentLineImplementationList,
                    doAsynchronousLineTransition);

                if (this.countryRegion == #isoHU)
                {
                    taxUncommittedHUList = new List(Types::Int64);

                    ttsbegin;
                    select firstonly RecId from taxUncommitted
                        exists join sourceDocumentLine
                        where sourceDocumentLine.RecId == taxUncommitted.SourceDocumentLine
                            && sourceDocumentLine.SourceDocumentHeader == custInvoiceTable.SourceDocumentHeader;

                    if (!taxUncommitted.RecId)
                    {
                        TaxTrans taxTrans;
                        while select forupdate taxTrans
                            // The tax transaction for bank exchange rate is created during tax posting, which should be filtered out when processing deferred tax.
                            where taxTrans.ExchRateDiffOrigRecId == 0
                            join sourceDocumentLine
                            where sourceDocumentLine.RecId == taxTrans.SourceDocumentLine
                                && sourceDocumentLine.SourceDocumentHeader == custInvoiceTable.SourceDocumentHeader
                        {
                            if (TaxContinuousHUHelper::isTransactionContinuousHU(taxTrans.TaxItemGroup))
                            {
                                TaxUncommitted_HU::insertTaxUncommittedHU(sourceDocumentLine.RecId);
                                taxUncommittedHUList.addEnd(sourceDocumentLine.RecId);
                                // For hungarian deferred taxes, the tax has to be posted to a deferred tax account until the vat due date
                                // when it is reversed out of the deferred tax account and posted to the sales tax account
                                // The source document tax lines for which Hungarian Subscription is enabled is submitted to the Source Document
                                // Processor Facade for fully distributed state processing. The change in state from Completed to FullyDistributed
                                // causes the reversal on the VAT due date to occur
                                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(taxTrans, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                                isContinuousHU = true;
                            }
                        }
                    }
                    else
                    {
                        while select forupdate taxUncommitted
                            join sourceDocumentLine
                            where sourceDocumentLine.RecId == taxUncommitted.SourceDocumentLine &&
                                  sourceDocumentLine.SourceDocumentHeader == custInvoiceTable.SourceDocumentHeader
                        {
                            if (TaxContinuousHUHelper::isTransactionContinuousHU(taxUncommitted.TaxItemGroup))
                            {
                                TaxUncommitted_HU::insertTaxUncommittedHU(sourceDocumentLine.RecId);
                                taxUncommittedHUList.addEnd(sourceDocumentLine.RecId);
                                isContinuousHU = true;
                                // For hungarian deferred taxes, the tax has to be posted to a deferred tax account until the vat due date
                                // when it is reversed out of the deferred tax account and posted to the sales tax account
                                // The source document tax lines for which Hungarian Subscription is enabled is submitted to the Source Document
                                // Processor Facade for fully distributed state processing. The change in state from Completed to FullyDistributed
                                // causes the reversal on the VAT due date to occur
                                SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(taxUncommitted, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                            }
                        }
                    }
                    if (isContinuousHU)
                    {
                        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceHU00008, funcName());

                        SourceDocumentProcessorFacade::submitSourceDocumentImplementation(custInvoiceTable, false, SourceDocumentAccountingStatus::Completed);
                        TaxContinuousHUHelper::deleteTaxUncommittedHURecords(taxUncommittedHUList);
                    }

                    ttscommit;
                }

                //need to get the new updated state of the SDH for validation
                sourceDocument = SourceDocument::newFromSourceDocumentImplementation(custInvoiceTable);
                
                if (sourceDocument.parmSourceDocumentHeader().AccountingStatus != SourceDocumentAccountingStatus::Completed)
                {
                    throw error("@SYS25904");
                }

                SourceDocumentIPostingJournalSeqProv custInvoiceSourceDoc = sourceDocument as SourceDocumentIPostingJournalSeqProv;
                if (custInvoiceSourceDoc)
                {
                    SubledgerJournalTransferCommand::initJournalVoucherSeries(
                    custInvoiceSourceDoc,
                    curExt(),
                    custInvoiceTable.InvoiceDate,
                    _ledgerVoucher.lastVoucher());
                }
            }

            return AccountingEvent::getLastEvent(custInvoiceTable.SourceDocumentHeader).RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLedgerVoucher</Name>
				<Source><![CDATA[
    protected void postLedgerVoucher(LedgerVoucher _ledgerVoucher)
    {
        using (var postLedgerVoucherActivityContext = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoicePostLedgerVoucher))
        {
            if (this.countryRegion == #isoRU && this.parmLedgerBondClient())
            {
                if (this.parmLedgerBondClient().findVRefByPostingType(LedgerPostingType::CustBalance))
                {
                    this.parmLedgerBondClient().bondVRef2Log(this.parmLedgerBondClient().findVRefByPostingType(LedgerPostingType::CustBalance));
                }
            }

            isLedgerVoucherPosted = _ledgerVoucher.end();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateTotals</Name>
				<Source><![CDATA[
    protected void calculateTotals()
    {
        using (var calcTotalsActivityContext = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoiceCalculateTotals))
        {
            if (CustInvoiceTableCalcTotalsFeature::isEnabled())
            {
                custFreeInvoiceCalcTotals = CustFreeInvoiceCalcTotals::newForSaveWhenPostingInvoice(custInvoiceTable);
            }
            else
            {
                custFreeInvoiceCalcTotals = new CustFreeInvoiceCalcTotals(custInvoiceTable);
            }

            custFreeInvoiceCalcTotals.calc();
            this.tax(custFreeInvoiceCalcTotals.tax());

            if (TaxWithholdParameters_IN::checkTaxParameters() && custInvoiceTable.custTable_InvoiceAccount().TaxWithholdCalculate_IN)
            {
                this.taxWithholdCalcFreeInvoice_IN(custFreeInvoiceCalcTotals.taxWithholdCalcFreeInvoice_IN());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePostCustInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Executes the pre posting logic for the Free text invoice.
    /// </summary>
    protected void prePostCustInvoice()
    {
       
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the posting logic for the Free text invoice.
    /// </summary>
    public void run()
    {
        #OCCRetryCount
        System.Exception exception;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadlockException;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictException;
        int backOffWait = RandomGenerate::construct().randomInt(50, 1000);
        CustInvoiceJour custInvoiceJour;

        NumberSeq numberSeq;
        LedgerVoucher ledgerVoucher;

        boolean creditNote;

        isPostingOK = false;

        if (!this.validateEInvoiceParameters_MX())
        {
            Box::stop("@SYS25904");
        }

        try
        {
            using (var runActivityContext = custPostInvoiceLogger.activityContextWithCustomProperties(CustPostInvoiceInstrumentationConstants::CustPostInvoiceRun))
            {
                // calculate totals in seperate transaction scope so that taxUncommitted records
                // are visible to asynch tasks.
                ttsbegin;
                this.prePostCustInvoice();
                // Calculates the totals for the invoice.
                // This will create TaxUncommitted records for the invoice lines and markups.
                this.calculateTotals();
                ttscommit;

                ttsbegin;
                custInvoiceTable = CustInvoiceTable::findRecId(custInvoiceTable.RecId,update);

                creditNote = this.isCreditNote(custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount());

                if (!this.validate(custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount(), creditNote))
                {
                    Message::Add(MessageSeverity::Error, "@SYS25904");
                    throw Exception::Error;
                }

                numberSeq = this.allocateNumAndVoucher(creditNote);

                custInvoiceJour = this.createJournalHeader(numberSeq, creditNote);

                ledgerVoucher = this.initLedgerVoucher(custInvoiceJour.IsCorrection, numberSeq, custInvoiceJour, creditNote);
            
                this.postCustInvoice(custInvoiceJour, ledgerVoucher, creditNote, numberSeq);

                ttscommit;

                isPostingOK = true;

                runActivityContext.addCustomProperty(
                    CustPostInvoiceInstrumentationConstants::LineCountMagnitude, 
                    ApplicationCommonInstrumentationMagnitude::log10magnitude(numberOfLines));

                runActivityContext.addCustomProperty(
                    CustPostInvoiceInstrumentationConstants::IsRunningInBatch, 
                    custPostInvoiceLogger.bool2str(this.parmIsInBatch()));
            }
        }

        catch (deadlockException)
        {
            int currentRetryCount = xSession::currentRetryCount();
            if (currentRetryCount >= #RetryNum)
            {
                custPostInvoiceLogger.logException(deadlockException, strFmt('Maximum retry on deadlock exception. retry count:%1, isInBatch: %2, recid:%3',
                    currentRetryCount, custPostInvoiceLogger.bool2str(this.parmIsInBatch()), custInvoiceTable.RecId));
                throw deadlockException;
            }
            else 
            {
                custPostInvoiceLogger.logException(deadlockException, strFmt('Deadlock. retry count:%1, isInBatch: %2, recid:%3',
                    currentRetryCount, custPostInvoiceLogger.bool2str(this.parmIsInBatch()), custInvoiceTable.RecId));

                sleep(currentRetryCount * backOffWait);
                retry;
            }
            
            retry;
        }

        catch (updateConflictException)
        {
            if (appl.ttsLevel() == 0)
            {
                int currentRetryCount = xSession::currentRetryCount();
                if (currentRetryCount >= #RetryNum)
                {
                    custPostInvoiceLogger.logException(updateConflictException, strFmt('Maximum retry on update conflict exception. retry count:%1, isInBatch:%2, recid:%3',
                        currentRetryCount, custPostInvoiceLogger.bool2str(this.parmIsInBatch()), custInvoiceTable.RecId));
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    custPostInvoiceLogger.logException(updateConflictException, strFmt('Update conflict. retry count:%1, isInBatch:%2, recid:%3',
                        currentRetryCount, custPostInvoiceLogger.bool2str(this.parmIsInBatch()), custInvoiceTable.RecId));

                    sleep(currentRetryCount * backOffWait);
                    retry;
                }
            }
            else
            {
                custPostInvoiceLogger.logException(updateConflictException, strFmt('Update conflict. ttsLevel:%1, isInBatch:%2, recid:%3',
                    appl.ttsLevel(), custPostInvoiceLogger.bool2str(this.parmIsInBatch()), custInvoiceTable.RecId));
                throw updateConflictException;
            }
        }

        catch
        {
            // Chain the exception forward so that the batch process updates the success status.
            custPostInvoiceLogger.logError(strFmt('Unhandled exception. ttsLevel:%1, isInBatch:%2, recid:%3',
                appl.ttsLevel(), custPostInvoiceLogger.bool2str(this.parmIsInBatch()), custInvoiceTable.RecId));
            throw Exception::Error;
        }

        if (isPostingOK)
        {
            // <GTE>
            if (this.canPostTaxDocument(ledgerVoucher))
            {
                TaxBusinessService::postTaxDocument(
                    TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(custInvoiceJour)),
                    ledgerVoucher);
            }
            // </GTE>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if can post tax document.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// A LedgerVoucher used for posting.
    /// </param>
    /// <returns>true if can post tax document.</returns>
    protected boolean canPostTaxDocument(LedgerVoucher _ledgerVoucher)
    {
        boolean canPostTaxDocument;
        canPostTaxDocument = TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
            && _ledgerVoucher
            && (isLedgerVoucherPosted || _ledgerVoucher.check());
        return canPostTaxDocument;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the posting logic for the Free text invoice.
    /// </summary>
    /// <param name = "_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> table buffer.
    /// </param>
    /// <param name = "_ledgerVoucher">
    /// A LedgerVoucher used for posting.
    /// </param>
    /// <param name = "_creditNote">
    /// A boolean indicating whether or not it is a credit note.
    /// </param>
    /// <param name = "_numberSeq">
    /// A <c>NumberSeq</c> instance used to get the invoice ID.
    /// </param>
    protected void postCustInvoice(CustInvoiceJour _custInvoiceJour, LedgerVoucher _ledgerVoucher, boolean _creditNote, NumberSeq _numberSeq)
    {
        using (var postInvoiceActivityContext = custPostInvoiceLogger.activityContext(CustPostInvoiceInstrumentationConstants::CustPostInvoicePostInvoice))
        {
            // Parameter creditNote is used for fixed asset posting transaction text inside this method.
            this.createJournalLines(_custInvoiceJour, _ledgerVoucher, _creditNote);

            //MarkupTrans records are created for the custinvoicejour and later used for tax calculation.
            this.processMarkup(_custInvoiceJour, _ledgerVoucher);

            this.createAndValidatePaymentSchedule(_custInvoiceJour);

            CustInvoiceCalcTax custInvoiceCalcTax = this.postTax(_custInvoiceJour, _ledgerVoucher);

            if (TaxIntegrationUtils::isTransitDocumentEnabled())
            {
                this.transitDocument(_custInvoiceJour);
            }

            RecId accountingEventRecId = this.processSourceDocument(_ledgerVoucher, custInvoiceCalcTax);
 
            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                TaxBusinessService::postTax(
                        _ledgerVoucher,
                        TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_custInvoiceJour)));
            }

            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                this.transferTaxDocument(_custInvoiceJour);
            }
            // </GTE>

            CustVoucher custVoucher = this.initCustVoucher(_custInvoiceJour, _creditNote);
            // The CustVoucher.post() call subsequently invokes settlement functionality if the document being posted was marked for settlement.
            // Settlement depends upon the existance of the source document data produced by the "journalize" step, thus invocation of CustVoucher.post()
            // must come after the call to SourceDocumentHeaderType::journalize().
            this.postCustVoucher(custVoucher, _custInvoiceJour, accountingEventRecId, _ledgerVoucher);

            this.postLedgerVoucher(_ledgerVoucher);

            if (CustInvoiceCalculateTaxFieldsForFreeTextInvoiceFlight::instance().isEnabled())
            {
                // Updating the tax fields in CustInvoiceJour and CustInvoiceTrans tables
                this.updateTaxFields(_custInvoiceJour);
            }

            if (isElectronicInvoiceCFDIEnabled)
            {
                this.insertElectronicInvoice_MX(_custInvoiceJour, _numberSeq.parmNumberSequenceId());
            }

            if (BrazilParameters::isEnabled() && !this.parmIsCustInterestAdjustment_BR())
            {
                this.postFiscalDocument_BR(custFreeInvoiceCalcTotals, custInvoiceTable);
            }

            if (this.countryRegion == #isoRU)
            {
                this.createTransLink_RU(_custInvoiceJour);
            }

            TransactionLog::create(TransactionLogType::CustFreeInvoice,"@SYS60858");

            this.postFacture_RU(_custInvoiceJour);

            if (CustParameters::isTaxIntegrationSystem_CN())
            {
                this.createExportDocument_CN(custInvoiceTable.RecId, _custInvoiceJour.RecId);
            }

            if (ProjIntercompanyVendorInvoiceCreator::isProjIntercompany(custInvoiceTable))
            {
                ProjIntercompanyVendorInvoiceCreator::construct(custInvoiceTable).createVendorInvoice();
            }

            if (!RecurrenceInvoice::existsByCustInvoiceTable(custInvoiceTable.RecId))
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(FreeTextInvoiceCorrection)))
                {
                    if (CustRelatedInvoice::doesInvoiceExistForType(custInvoiceTable.RecId, InvoiceAssociationType::AdjustingInvoice))
                    {
                        info(strFmt("@SYS308704", _custInvoiceJour.InvoiceId));
                    }
                    else if (custInvoiceTable.isCorrectedInvoice())
                    {
                        InvoiceId parentInvoiceID = CustRelatedInvoice::findParentInvoiceForChild(custInvoiceTable.RecId).InvoiceId;
                        info(strFmt("@SYS311111", _custInvoiceJour.InvoiceId, parentInvoiceID));
                    }
                    else
                    {
                        info(strFmt("@SYS25683", _custInvoiceJour.InvoiceId));
                    }
                }
                else
                {
                    info(strFmt("@SYS25683", _custInvoiceJour.InvoiceId));
                }
            }
            TradeBLWIJournalPurposeCodes::createRecordFromJournal(
                custInvoiceTable.RecId,
                TradeBLWITypeOfForm::CustFreeInvoice,
                _custInvoiceJour.RecId,
                TradeBLWITypeOfForm::CustInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Transfer tax document from original transaction to the target transaction.
    /// </summary>
    /// <param name = "_custInvoiceJour">The buffer of table CustInvoiceJour</param>
    // <GTE>
    private void transferTaxDocument(CustInvoiceJour _custInvoiceJour)
    {
        ITaxableDocument            taxableDocument;
        taxableDocument = TaxableDocumentObject::construct(
            TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(this.parmCustInvoiceTable()));

        TaxBusinessService::transferTaxDocument(custInvoiceTable, _custInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitDocument</Name>
				<Source><![CDATA[
    // </GTE>

    private void transitDocument(CustInvoiceJour _custInvoiceJour)
    {
        CustInvoiceTrans            custInvoiceTransLoc;
        CustInvoiceLine             custInvoiceLineLoc;
        TransitDocumentManager_IN   transitManager = TransitDocumentManager_IN::newManager();

        transitManager = TransitDocumentManager_IN::newManager();
        transitManager.transit(_custInvoiceJour.custInvoiceTable(), _custInvoiceJour);

        while select custInvoiceTransLoc
        where custInvoiceTransLoc.SalesId               == _custInvoiceJour.SalesId
            && custInvoiceTransLoc.InvoiceId            == _custInvoiceJour.InvoiceId
            && custInvoiceTransLoc.InvoiceDate          == _custInvoiceJour.InvoiceDate
            && custInvoiceTransLoc.numberSequenceGroup  == _custInvoiceJour.numberSequenceGroup
        join custInvoiceLineLoc
            where custInvoiceLineLoc.sourceDocumentLine == custInvoiceTransLoc.SourceDocumentLine
        {
            transitManager.transit(custInvoiceLineLoc, custInvoiceTransLoc, _custInvoiceJour);
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalHeaderDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// A delegate that is called in the <c>createJournalHeader</c>.
    /// </summary>
    /// <param name = "_custInvoiceJour">The <c>CustInvoiceJour</c> record.</param>
    delegate void createJournalHeaderDelegate(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalHeaderPreInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the journal record before actual insertion.
    /// </summary>
    /// <param name = "_custInvoiceJour">The buffer of the table <c>CustInvoiceJour</c>.</param>
    protected void createJournalHeaderPreInsert(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFTIValidToUsePreallocNumSeq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if this free text invoice can use preallocated number sequence
    /// Exclude the scenario that preallocation cannot be used.
    /// </summary>
    /// <param name = "_isCreditNote">if this is creditNote</param>
    private boolean isFTIValidToUsePreallocNumSeq(boolean _isCreditNote)
    {
        return CustPostInvoiceJobPreallocatedNumberSequenceFlight::instance().isEnabled() &&
            this.parmIsNumSeqPreallocated() &&
            this.parmIsInBatch() &&
            !_isCreditNote &&
            !custInvoiceTable.InvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPreallocatedNumSeqMatchedWithOriginal</Name>
				<Source><![CDATA[
    private boolean isPreallocatedNumSeqMatchedWithOriginal(NumberSeq _originalNumSeq)
    {
        return _originalNumSeq.parmNumberSequenceId() == this.parmInvoiceNumberNumSeqRefRecId() &&
            ((this.parmAllowSameAs() && _originalNumSeq.parmVoucherSequenceId() == this.parmInvoiceNumberNumSeqRefRecId()) ||
                (!this.parmAllowSameAs() && _originalNumSeq.parmVoucherSequenceId() == this.parmInvoiceVoucherNumSeqRefRecId()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceIdAndVoucherFromPreallocation</Name>
				<Source><![CDATA[
    private container getInvoiceIdAndVoucherFromPreallocation(CustInvoiceTable _custInvoiceTable, NumberSeq _numberSeq, NoYes _creditNote)
    {
        InvoiceId invoiceId;
        Voucher voucher;
        SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(classStr(CustPostInvoice));

        if (this.isPreallocatedNumSeqMatchedWithOriginal(_numberSeq))
        {
            [invoiceId, voucher] = CustPostInvoiceJobPreallocatedNumberSequence::useNumbers(custInvoiceTable.RecId,
                this.parmInvoiceNumberNumSeqRefRecId(), this.parmInvoiceVoucherNumSeqRefRecId(), this.parmAllowSameAs());
            if (!invoiceId || !voucher)
            {
                logger.logInformation('Cannot get preallocated number for invoice or voucher');
            }
        }
        else
        {
            logger.logInformation('Preallocated number sequence id is not matched with original');
        }
        
        if (!invoiceId && !voucher)
        {
            // no number get from preallocation
            // rollback to old way
            [invoiceId, voucher] = this.getInvoiceIdAndVoucher(_custInvoiceTable, _numberSeq);
        }
        else
        {
            // get missing number in old way
            if (!invoiceId)
            {
                invoiceId = _numberSeq.num();
            }

            if (!voucher)
            {
                voucher = _numberSeq.voucher();
            }
        }

        if (!voucher)
        {
            throw error("@SYS71652");
        }

        return [invoiceId, voucher];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canExcludeFromDelayJournalization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine if the FTI can exclude from delay journalization - decoupled posting process
    /// If the 'EnableEnhancedDelaySDAFJournalizerForSourceDocuments' feature is disabled
    /// or the field has been set to YES,
    /// then 'ExcludeFromDecoupledPostingProcess' field is not changed in this function.
    /// Otherwise set 'ExcludeFromDecoupledPostingProcess' to Yes if meets the specified condition in function.
    /// </summary>
    private void canExcludeFromDelayJournalization(SysInstrumentationActivityContext _activityContext)
    {
        if (!EnableEnhancedDelaySDAFJournalizerForSourceDocuments::isEnabled() ||
            custInvoiceTable.ExcludeFromDecoupledPostingProcess == NoYes::Yes)
        {
            // do nothing if feature is disabled or the field has been set to YES.
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'FeatureDisabledOrFieldWasSet');
            return;
        }

        if (this.countryRegion == #isoHU)
        {
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'CountryRegionSpecific');
            custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
        else if (!this.parmIsInBatch())
        {
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'NotInBatch');
            custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
        else if (CustParameters::find().AutoSettle == NoYes::Yes)
        {
            this.determineInvoiceQualifyForAutoSettlementCriteria(custInvoiceTable);

            if (custInvoiceTable.ExcludeFromDecoupledPostingProcess == NoYes::Yes)
            {
                _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'AutoSettle');
            }
        }
        else if (custInvoiceTable.PaymMode && CustPaymModeTable::find(custInvoiceTable.PaymMode).PaymOnInvoice)
        {
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'PaymentWithInvoice');
            custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
        else if (custInvoiceTable.SalesId && SalesTable::find(custInvoiceTable.SalesId).mcrIsCallCenter())
        {
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'RetailCallCenter');
            // MCR Retail will need to process payment and settlement, but those are not supported.
            custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
        else if (SpecTrans::findBySpec(custInvoiceTable.company(), custInvoiceTable.TableId, custInvoiceTable.RecId))
        {
            // There is marked transaction for settlement, but settlement is not supported.
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'MarkedTransactionForSettle');
            custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
        else if (custInvoiceTable.isCorrectedInvoice())
        {
            // Corrected invoice need to do settlement and settlement is not supported.
            _activityContext.addCustomProperty(CustPostInvoiceInstrumentationConstants::ExcludeFromDelayJournalizationReason, 'CorrectedInvoice');
            custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateNoDuplicates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate there is no duplicated voucher in CustInvoiceJour table
    /// </summary>
    /// <param name = "custInvoiceJour">CustInvoiceJour to be validated</param>
    /// <returns>True if the <c>CustInvoiceJour</c> values are valid; otherwise false.</returns>
    private boolean validateNoDuplicates(CustInvoiceJour _custInvoiceJour)
    {
        boolean isValid = true;

        isValid = CustInvoiceJour::validateVoucher(_custInvoiceJour.LedgerVoucher, _custInvoiceJour.InvoiceDate);

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineInvoiceQualifyForAutoSettlementCriteria</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is for extension and customization that can be done to override the default exclusion behavior of the Free text invoice
    /// when auto settlement is turned on for the invoice company
    /// </summary>
    /// <param name = "_custInvoiceTable">The free text invoice header record that is getting posted</param>
    protected void determineInvoiceQualifyForAutoSettlementCriteria(CustInvoiceTable _custInvoiceTable)
    {
        if (!SourceDocumentDetermineDistributionFactorsForSettlementFlight::instance().isEnabled())
        {
            _custInvoiceTable.ExcludeFromDecoupledPostingProcess = NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTaxFields</Name>
				<Source><![CDATA[
    /// <summary>
    ///  This method will update the tax fields for FTI
    /// </summary>
    /// <param name = "_custInvoiceJour"> The <c>CustInvoiceJour</c> table buffer.</param>
    private void updateTaxFields(CustInvoiceJour _custInvoiceJour)
    {
        TaxSourceLineSummaryTmp taxSourceLineSummaryTmp =
            TaxSummaryUtils::getLineTaxAmountPosted(_custInvoiceJour.LedgerVoucher, _custInvoiceJour.InvoiceDate);

        CustInvoiceTrans custInvoiceTrans;
        custInvoiceTrans.skipDataMethods(true);
        custInvoiceTrans.skipEvents(true);

        // line amount 
        update_recordset custInvoiceTrans
            setting
                TotalTax = taxSourceLineSummaryTmp.ActualTransactionTaxAmount * -1
            join taxSourceLineSummaryTmp
                where taxSourceLineSummaryTmp.SourceRecId == custInvoiceTrans.RecId &&
                    taxSourceLineSummaryTmp.SourceTableId == tableNum(CustInvoiceTrans);

        // Process Charges on FTI line level
        if (isConfigurationkeyEnabled(configurationKeyNum(Markup)) && 
            SysCountryRegionCode::isLegalEntityInConsolidatedCountryRegion())
        {
            MarkupTransLineTotalChargeAmountView markupTransLineTotalChargeAmountView;
            MarkupTransLineTotalChargeTaxAmountView markupTransLineTotalChargeTaxAmountView;

            update_recordset custInvoiceTrans
                setting
                    TotalTax = custInvoiceTrans.TotalTax + (markupTransLineTotalChargeTaxAmountView.LineChargesTaxAmount * -1),
                    TotalCharge = markupTransLineTotalChargeAmountView.ChargeAmount
                join markupTransLineTotalChargeAmountView
                    where markupTransLineTotalChargeAmountView.CustInvoiceTransRecId == custInvoiceTrans.RecId
                join markupTransLineTotalChargeTaxAmountView
                     where markupTransLineTotalChargeTaxAmountView.CustInvoiceTransRecId == custInvoiceTrans.RecId &&
                        custInvoiceTrans.ParentRecId == _custInvoiceJour.RecId;
        }

        select sum(TotalTax) from custInvoiceTrans
            where custInvoiceTrans.ParentRecId == _custInvoiceJour.RecId;

        if (_custInvoiceJour.SumTax != custInvoiceTrans.TotalTax)
        {
            // Header Tax = Total Tax - Total line tax
            _custInvoiceJour.HeaderTax = _custInvoiceJour.SumTax - custInvoiceTrans.TotalTax;
            _custInvoiceJour.doUpdate();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>