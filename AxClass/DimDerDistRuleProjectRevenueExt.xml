<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>DimDerDistRuleProjectRevenueExt</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>DimDerDistRuleProjectRevenueExt</c> class is the dimension derivation distribution rule
///    extension for recognizing project revenue.
/// </summary>
[SourceDocumentClassExtensionAttribute(classStr(AccDistRuleProjectRevenueExtendedPrice))]
class DimDerDistRuleProjectRevenueExt extends DimensionDerivationRuleExtension
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getAccrualDimensionForIntercompany</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default dimensions that the accrual entries should use for an intercompany customer.
    /// </summary>
    /// <param name="_transactionDataAreaId">
    /// The data area ID of the company posting the transaction.
    /// </param>
    /// <param name="_contractingCompany">
    /// The data area ID of the company that has the contract with the final customer.
    /// </param>
    /// <returns>
    /// The default dimension that should be used on the accrual entries.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown if the intercompany setup does not exist or is incomplete.
    /// </exception>
    private DimensionDefault getAccrualDimensionForIntercompany(DataAreaId _transactionDataAreaId, DataAreaId _contractingCompany)
    {
        CustTable                   custTable;
        InterCompanyTradingPartner  tradingPartner;

        tradingPartner = InterCompanyTradingPartner::findTradingCustomer(_transactionDataAreaId, _contractingCompany);
        if (tradingPartner)
        {
            custTable = CustTable::findByPartyRecId(tradingPartner.CustomerParty);
        }

        if (!custTable)
        {
            throw error(strFmt("@SYS4005055", _contractingCompany));
        }

        return custTable.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDimAllocList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the allocation list by using the project setup.
    /// </summary>
    /// <param name="_ledgerDimensionAllocationList">
    ///    The allocation list for which to populate.
    /// </param>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public void populateDimAllocList(LedgerDimensionAllocationList _ledgerDimensionAllocationList)
    {
        Common                          sourceDocumentLineImplementation;
        ProjectRevenueLine              projectRevenueLine;
        ProjectRevenueHeader            projectRevenueHeader;
        DebitCredit                     side;

        sourceDocumentLineImplementation = dimensionDerivationRule.parmAccountingRule().parmSourceDocumentLineItem().parmSourceDocumentLine().getSourceDocumentLineImplementation();
        if (sourceDocumentLineImplementation.TableId != tableNum(ProjectRevenueLine))
        {
            throw error("@SYS6144");
        }

        projectRevenueLine = sourceDocumentLineImplementation;
        projectRevenueHeader = projectRevenueLine.getProjectRevenueHeader();

        side = dimensionDerivationRule.parmAccountingRule().parmSide();

        if (projectRevenueHeader.IsIntercompany == false)
        {
            this.processRegularTransactions(projectRevenueHeader, projectRevenueLine, side, _ledgerDimensionAllocationList);
        }
        else
        {
            this.processIntercompanyTransTimesheet(projectRevenueHeader, projectRevenueLine, side, _ledgerDimensionAllocationList);
            // Check for the number of elements to avoid unnecessary queries. Only one of the process calls will fill the list,
            // the one from the source document having its revenue accrued. We try the most frequent documents first.
            if (_ledgerDimensionAllocationList.elements() == 0)
            {
                this.processIntercompanyTransCustInvoice(projectRevenueHeader, projectRevenueLine, side, _ledgerDimensionAllocationList);
            }
            if (_ledgerDimensionAllocationList.elements() == 0)
            {
                this.processIntercompanyTransExpense(projectRevenueHeader, projectRevenueLine, side, _ledgerDimensionAllocationList);
            }
            if (_ledgerDimensionAllocationList.elements() == 0)
            {
                this.processIntercompanyTransVendorInv(projectRevenueHeader, projectRevenueLine, side, _ledgerDimensionAllocationList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimensionForTransCustInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a ledger dimension for the specified combination for customer transactions.
    /// </summary>
    /// <param name = "_custInvoiceTable">
    ///     A <c>CustInvoiceTable</c> table buffer.
    /// </param>
    /// <param name = "_custInvoiceLine">
    ///     A <c>CustInvoiceLine</c> table buffer.
    /// </param>
    /// <param name = "_categoryId">
    ///     The category ID.
    /// </param>
    /// <returns>
    ///     The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    [Replaceable(true)]
    protected LedgerDimensionAccount createLedgerDimensionForTransCustInvoice(CustInvoiceTable _custInvoiceTable, CustInvoiceLine _custInvoiceLine, ProjCategoryId _categoryId)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension = ProjPosting::getLedgerDimension(ProjAccountType::SalesValue, '', _categoryId, 0);

        CustTable customer = CustTable::find(_custInvoiceTable.OrderAccount);

        // need to merge the default account with the default dimensions
        LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, _custInvoiceLine.DefaultDimension, customer.DefaultDimension);

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForTransCustInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Builds the query for customer invoice transactions.
    /// </summary>
    /// <param name = "_revenueHeader">
    ///     A <c>ProjectRevenueHeader</c> table buffer.
    /// </param>
    /// <returns>
    ///     A query used for customer invoice transactions.
    /// </returns>
    [Wrappable(true)]
    protected final Query buildQueryForTransCustInvoice(ProjectRevenueHeader _revenueHeader)
    {
        Query query = new Query();
        
        QueryBuildDataSource qbdsCustInvoiceTable = query.addDataSource(tableNum(CustInvoiceTable));
        qbdsCustInvoiceTable.addSelectionField(fieldNum(CustInvoiceTable, RecId));
        qbdsCustInvoiceTable.addSelectionField(fieldNum(CustInvoiceTable, OrderAccount));
        qbdsCustInvoiceTable.addSelectionField(fieldNum(CustInvoiceTable, InvoiceDate));
        qbdsCustInvoiceTable.addRange(fieldNum(CustInvoiceTable, SourceDocumentHeader)).value(queryValue(_revenueHeader.ReferenceSourceDocumentHeader));

        QueryBuildDataSource qbdsCustInvoiceLine = qbdsCustInvoiceTable.addDataSource(tableNum(CustInvoiceLine));
        qbdsCustInvoiceLine.joinMode(JoinMode::InnerJoin);
        qbdsCustInvoiceLine.fetchMode(QueryFetchMode::One2One);
        qbdsCustInvoiceLine.addSelectionField(fieldNum(CustInvoiceLine, Quantity));
        qbdsCustInvoiceLine.addSelectionField(fieldNum(CustInvoiceLine, DefaultDimension));
        qbdsCustInvoiceLine.addSelectionField(fieldNum(CustInvoiceLine, RecId));
        qbdsCustInvoiceLine.addLink(fieldNum(CustInvoiceTable, RecId), fieldNum(CustInvoiceLine, ParentRecId));

        QueryBuildDataSource qbdsInterProjLine = qbdsCustInvoiceLine.addDataSource(tableNum(CustInvoiceLineInterProj));
        qbdsInterProjLine.joinMode(JoinMode::InnerJoin);
        qbdsInterProjLine.fetchMode(QueryFetchMode::One2One);
        qbdsInterProjLine.addSelectionField(fieldNum(CustInvoiceLineInterProj, ProjCategoryId));
        qbdsInterProjLine.addSelectionField(fieldNum(CustInvoiceLineInterProj, SalesPrice));
        qbdsInterProjLine.addSelectionField(fieldNum(CustInvoiceLineInterProj, SalesPriceCurrency));
        qbdsInterProjLine.addSelectionField(fieldNum(CustInvoiceLineInterProj, ProjDataArea));
        qbdsInterProjLine.addSelectionField(fieldNum(CustInvoiceLineInterProj, TransType));
        qbdsInterProjLine.addSelectionField(fieldNum(CustInvoiceLineInterProj, IndirectComponentAmount));
        qbdsInterProjLine.addLink(fieldNum(CustInvoiceLine, RecId), fieldNum(CustInvoiceLineInterProj, CustInvoiceLine));

        QueryBuildDataSource qbdsOrigTransAccountingDistribution = qbdsInterProjLine.addDataSource(tableNum(AccountingDistribution));
        qbdsOrigTransAccountingDistribution.joinMode(JoinMode::InnerJoin);
        qbdsOrigTransAccountingDistribution.fetchMode(QueryFetchMode::One2One);
        qbdsOrigTransAccountingDistribution.addSelectionField(fieldNum(AccountingDistribution, LedgerDimension));
        qbdsOrigTransAccountingDistribution.addSelectionField(fieldNum(AccountingDistribution, AllocationFactor));
        qbdsOrigTransAccountingDistribution.addLink(fieldNum(CustInvoiceLineInterProj, OrigTransSourceDocumentLine), fieldNum(AccountingDistribution, SourceDocumentLine));

        QueryBuildDataSource qbdsIntercompanyParams = qbdsInterProjLine.addDataSource(tableNum(ProjIntercompanyParameters));
        qbdsIntercompanyParams.joinMode(JoinMode::ExistsJoin);
        qbdsIntercompanyParams.fetchMode(QueryFetchMode::One2One);
        qbdsIntercompanyParams.addLink(fieldNum(ProjIntercompanyParameters, BorrowingLegalEntity), fieldNum(CustInvoiceLineInterProj, ProjDataArea));
        qbdsIntercompanyParams.addRange(fieldNum(ProjIntercompanyParameters, WIPRevenue)).value(queryValue(NoYes::Yes));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIntercompanyTransCustInvoice</Name>
				<Source><![CDATA[
    private void processIntercompanyTransCustInvoice(ProjectRevenueHeader            _revenueHeader,
                                                     ProjectRevenueLine              _revenueLine,
                                                     DebitCredit                     _side,
                                                     LedgerDimensionAllocationList   _ledgerDimensionAllocationList)
    {
        AccountingDistribution origTransAccountingDistribution;
        LedgerDimensionAccount mergedLedgerDimension;
        LedgerDimensionAllocation ledgerDimensionAllocation;
        AllocationFactor allocationFactor;
        ProjIntercompanyParameters intercompanyParams;
        ProjCategoryId categoryId;
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        CustInvoiceLineInterProj interProjLine;
        Qty lineQty;

        QueryRun queryRun = new QueryRun(this.buildQueryForTransCustInvoice(_revenueHeader));
        // Revenue lines are generated by summing all the amounts to be accrued grouped by currency.
        // Here we want to create allocations for WIP per each distribution of the original (cost) line.
        while (queryRun.next())
        {
            custInvoiceTable = queryRun.get(tableNum(CustInvoiceTable));
            custInvoiceLine = queryRun.get(tableNum(CustInvoiceLine));
            interProjLine = queryRun.get(tableNum(CustInvoiceLineInterProj));
            origTransAccountingDistribution = queryRun.get(tableNum(AccountingDistribution));

            categoryId = ProjIntercompanyParameters::getValidCategory(interProjLine.ProjCategoryId,
                                                                      interProjLine.ProjDataArea,
                                                                      interProjLine.TransType);

            mergedLedgerDimension = this.createLedgerDimensionForTransCustInvoice(custInvoiceTable, custInvoiceLine, categoryId);

            // The revenue line is the sum of all the revenue amounts for the invoice. So we need the revenue amount of the original transaction to calculate
            // its contribution to total revenue.
            lineQty = custinvoiceline.Quantity == 0 ? 1 : custinvoiceline.Quantity;
            // To calculate the allocation factor we first calculate the participation of the original transaction in the total
            // amount of accrued revenue
            if (_revenueLine.TransactionCurrencyAmount != 0)
            {
                AmountCur transactionCurrencyAmount = _revenueLine.TransactionCurrencyAmount;
                CurrencyCode revenueCurrencyCode = Currency::findRecId(_revenueLine.Currency).CurrencyCode;

                if (interProjLine.SalesPriceCurrency != revenueCurrencyCode && ProjIntercompanyAdvanceJournalAccruedRevenueFlight::instance().isEnabled())
                {
                    transactionCurrencyAmount = CurrencyExchangeHelper::curAmount2CurAmount(transactionCurrencyAmount,
                                                        revenueCurrencyCode,
                                                        interProjLine.SalesPriceCurrency,
                                                        custInvoiceTable.InvoiceDate);
                }

                if (transactionCurrencyAmount != 0)
                {
                    allocationFactor = (interProjLine.SalesPrice * lineQty + interProjLine.IndirectComponentAmount) / -transactionCurrencyAmount;
                }
                else
                {
                    allocationFactor = 1;
                }

                // and then consider the participation of this particular distribution that we're using the dimension from to this amount
                allocationFactor = allocationFactor * origTransAccountingDistribution.AllocationFactor;
            }
            else
            {
                allocationFactor = origTransAccountingDistribution.AllocationFactor;
            }

            ledgerDimensionAllocation = LedgerDimensionAllocation::newFromParameters(mergedLedgerDimension,
                                                                                     allocationFactor,
                                                                                     _side,
                                                                                     false,
                                                                                     origTransAccountingDistribution.RecId,
                                                                                     0,
                                                                                     0,
                                                                                     0,
                                                                                     interProjLine.SalesPrice * lineQty);

            _ledgerDimensionAllocationList.addEnd(ledgerDimensionAllocation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimensionForTransExpense</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a ledger dimension for the specified combination for expense transactions.
    /// </summary>
    /// <param name = "_trvExpTrans">
    ///     A <c>TrvExpTrans</c> table buffer.
    /// </param>
    /// <param name = "_expense">
    ///     An instance of <c>ProjIntercompanyInvoiceOrigExpense</c> class.
    /// </param>
    /// <param name = "_categoryId">
    ///     The category ID.
    /// </param>
    /// <returns>
    ///     The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    [Replaceable(true)]
    protected LedgerDimensionAccount createLedgerDimensionForTransExpense(TrvExpTrans _trvExpTrans, ProjIntercompanyInvoiceOrigExpense _expense, ProjCategoryId _categoryId)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension = ProjPosting::getLedgerDimension(ProjAccountType::SalesValue, '', _categoryId, 0);

        DimensionDefault intercompanyCustomerDimensions = this.getAccrualDimensionForIntercompany(_expense.getDataAreaId(), _expense.getProjectDataAreaId());

        // need to merge the default account with the default dimensions
        LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, _trvExpTrans.DefaultDimension, intercompanyCustomerDimensions);

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIntercompanyTransExpense</Name>
				<Source><![CDATA[
    private void processIntercompanyTransExpense(ProjectRevenueHeader            _revenueHeader,
                                                 ProjectRevenueLine              _revenueLine,
                                                 DebitCredit                     _side,
                                                 LedgerDimensionAllocationList   _ledgerDimensionAllocationList)
    {
        AccountingDistribution              referenceAccountingDistribution;
        LedgerDimensionAccount              mergedLedgerDimension;
        LedgerDimensionAllocation           ledgerDimensionAllocation;
        AllocationFactor                    allocationFactor;
        ProjIntercompanyParameters          intercompanyParams;
        ProjCategoryId                      categoryId;
        TrvExpTrans                         trvExpTrans;
        ProjIntercompanyInvoiceOrigExpense  expense;
        CurrencyCode                        revenueLineCurrency = Currency::findRecId(_revenueLine.Currency).CurrencyCode;

        // Revenue lines are generated by summing all the amounts to be accrued grouped by currency.
        // Here we want to create allocations for WIP per each distribution of the original (cost) line.
        while select AllocationFactor, RecId from referenceAccountingDistribution
            where referenceAccountingDistribution.SourceDocumentHeader == _revenueHeader.ReferenceSourceDocumentHeader
            join trvExpTrans
            where trvExpTrans.SourceDocumentLine == referenceAccountingDistribution.SourceDocumentLine &&
                  trvExpTrans.InterCompanyLE != trvExpTrans.ReferenceDataAreaId &&
                  (trvExpTrans.ExchangeCode == referenceAccountingDistribution.TransactionCurrency
                   || trvExpTrans.CreditCardTransactionCurrency == referenceAccountingDistribution.TransactionCurrency) &&
                  trvExpTrans.ProjId != ''
            exists join intercompanyParams
            where intercompanyParams.BorrowingLegalEntity == trvExpTrans.InterCompanyLE &&
                  intercompanyParams.WIPRevenue == true
        {
            expense = ProjIntercompanyInvoiceOrigExpense::construct(trvExpTrans);
            if (expense.getCurrencyCode() != revenueLineCurrency)
            {
                continue;
            }
            categoryId = ProjIntercompanyParameters::getValidCategory(trvExpTrans.InterCompanyCategory, trvExpTrans.InterCompanyLE, ProjTransType::Cost);

            mergedLedgerDimension = this.createLedgerDimensionForTransExpense(trvExpTrans, expense, categoryId);

            // The revenue line the sum of all the revenue amounts. So we need to revenue amount of the original transaction to calculate
            // its contribution to total revenue.
            allocationFactor =  _revenueLine.TransactionCurrencyAmount ? (expense.getAmountCur() / _revenueLine.TransactionCurrencyAmount) * referenceAccountingDistribution.AllocationFactor
                                                                       : referenceAccountingDistribution.AllocationFactor;

            ledgerDimensionAllocation = LedgerDimensionAllocation::newFromParameters(mergedLedgerDimension,
                                                                                     allocationFactor,
                                                                                     _side,
                                                                                     false,
                                                                                     referenceAccountingDistribution.RecId);
            _ledgerDimensionAllocationList.addEnd(ledgerDimensionAllocation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimensionForTransTimesheet</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a ledger dimension for the specified combination for timesheet transactions.
    /// </summary>
    /// <param name = "_tsTimesheetLine">
    ///     A <c>TSTimesheetLine</c> table buffer.
    /// </param>
    /// <param name = "_timesheet">
    ///      An instance of <c>ProjIntercompanyInvoiceOrigTimesheet</c> class.
    /// </param>
    /// <returns>
    ///     The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    [Replaceable(true)]
    protected LedgerDimensionAccount createLedgerDimensionForTransTimesheet(TSTimesheetLine _tsTimesheetLine, ProjIntercompanyInvoiceOrigTimesheet _timesheet)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension = ProjPosting::getLedgerDimension(ProjAccountType::SalesValue, '', _tsTimesheetLine.categoryId, 0);

        DimensionDefault intercompanyCustomerDimensions = this.getAccrualDimensionForIntercompany(_timesheet.getDataAreaId(), _timesheet.getProjectDataAreaId());

        // need to merge the default account with the default dimensions
        LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, _tsTimesheetLine.DefaultDimension, intercompanyCustomerDimensions);

        return mergedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIntercompanyTransTimesheet</Name>
				<Source><![CDATA[
    private void processIntercompanyTransTimesheet(ProjectRevenueHeader            _revenueHeader,
                                                   ProjectRevenueLine              _revenueLine,
                                                   DebitCredit                     _side,
                                                   LedgerDimensionAllocationList   _ledgerDimensionAllocationList)
    {
        AccountingDistribution                  referenceAccountingDistribution;
        LedgerDimensionAccount                  mergedLedgerDimension;
        LedgerDimensionAllocation               ledgerDimensionAllocation;
        AllocationFactor                        allocationFactor;
        TSTimesheetTrans                        tsTimesheetTrans;
        TSTimesheetLineWeek                     tsTimesheetLineWeek;
        TSTimesheetLine                         tsTimesheetLine;
        ProjIntercompanyParameters              intercompanyParams;
        Currency                                tsCurrency;
        ProjIntercompanyInvoiceOrigTimesheet    timesheet;

        // Revenue lines are generated by summing all the amounts to be accrued grouped by currency.
        // Here we want to create allocations for WIP per each distribution of the original (cost) line.
        while select AllocationFactor, RecId from referenceAccountingDistribution
            where referenceAccountingDistribution.SourceDocumentHeader == _revenueHeader.ReferenceSourceDocumentHeader
            join tsTimesheetTrans
            where tsTimesheetTrans.SourceDocumentLine == referenceAccountingDistribution.SourceDocumentLine &&
                  tsTimesheetTrans.TableId            == _revenueLine.RefTableId &&
                  tsTimesheetTrans.RecId              == _revenueLine.RefRecId  
            join tsTimesheetLineWeek
            where tsTimesheetLineWeek.RecId == tsTimesheetTrans.TSTimesheetLineWeek
            join tsTimesheetLine
            where tsTimesheetLine.RecId             == tsTimesheetLineWeek.TSTimesheetLine &&
                  tsTimesheetLine.ProjectDataAreaId != tsTimesheetLine.dataAreaId
            join RecId from tsCurrency
            where tsCurrency.CurrencyCode ==  tsTimesheetLine.CurrencyCode &&
                  tsCurrency.RecId        == _revenueLine.Currency
            exists join intercompanyParams
            where intercompanyParams.BorrowingLegalEntity == tsTimesheetLine.ProjectDataAreaId &&
                  intercompanyParams.WIPRevenue           == true
        {
            timesheet = ProjIntercompanyInvoiceOrigTimesheet::construct(tsTimesheetTrans, tsTimesheetLineWeek, tsTimesheetLine);

            mergedLedgerDimension = this.createLedgerDimensionForTransTimesheet(tsTimesheetLine, timesheet);

            // The single project revenue line contains sum of revenue amounts for this transaction. 
            // Allocation factor is calculated as ratio of the reference accounting distribution amount to the total revenue amount for the given project revenue line.

            allocationFactor =  _revenueLine.TransactionCurrencyAmount ? (timesheet.getAmountCur() / _revenueLine.TransactionCurrencyAmount) * referenceAccountingDistribution.AllocationFactor
                                                                       : referenceAccountingDistribution.AllocationFactor;

            ledgerDimensionAllocation = LedgerDimensionAllocation::newFromParameters(mergedLedgerDimension,
                                                                                     allocationFactor,
                                                                                     _side,
                                                                                     false,
                                                                                     referenceAccountingDistribution.RecId);
            _ledgerDimensionAllocationList.addEnd(ledgerDimensionAllocation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processIntercompanyTransVendorInv</Name>
				<Source><![CDATA[
    private void processIntercompanyTransVendorInv(ProjectRevenueHeader            _revenueHeader,
                                                   ProjectRevenueLine              _revenueLine,
                                                   DebitCredit                     _side,
                                                   LedgerDimensionAllocationList   _ledgerDimensionAllocationList)
    {
        AccountingDistribution              referenceAccountingDistribution;
        LedgerDimensionDefaultAccount       defaultLedgerDimension;
        LedgerDimensionAccount              mergedLedgerDimension;
        LedgerDimensionAllocation           ledgerDimensionAllocation;
        AllocationFactor                    allocationFactor;
        ProjIntercompanyParameters          intercompanyParams;
        ProjCategoryId                      categoryId;
        VendInvoiceInfoLine_Project         projLine;
        VendInvoiceInfoLine                 infoLine;
        CurrencyCode                        revenueLineCurrency = Currency::findRecId(_revenueLine.Currency).CurrencyCode;

        // Revenue lines are generated by summing all the amounts to be accrued grouped by currency.
        // Here we want to create allocations for WIP per each distribution of the original (cost) line.
        while select LedgerDimension, AllocationFactor, RecId from referenceAccountingDistribution
            where referenceAccountingDistribution.SourceDocumentHeader == _revenueHeader.ReferenceSourceDocumentHeader
            join RecId, ReceiveNow from infoLine
            where infoLine.SourceDocumentLine == referenceAccountingDistribution.SourceDocumentLine &&
                  infoLine.TableId == _revenueLine.RefTableId &&
                  infoLine.RecId == _revenueLine.RefRecId
            join ProjCategoryId, ProjDataAreaId, TransferCurrency,  TransferPrice from projLine
            where projLine.VendInvoiceInfoLineRefRecId == infoLine.recid &&
                  projLine.TransferPrice != 0
            exists join intercompanyParams
            where intercompanyParams.BorrowingLegalEntity == projLine.ProjDataAreaId &&
                  intercompanyParams.WIPRevenue           == true
        {
            categoryId = ProjIntercompanyParameters::getValidCategory(projLine.ProjCategoryId,
                                                                      projLine.ProjDataAreaId,
                                                                      ProjIntercompanyInvoiceOrigVendInvoice::getProjTransType(projLine));

            if (projLine.TransferCurrency != revenueLineCurrency)
            {
                continue;
            }
            defaultLedgerDimension = ProjPosting::getLedgerDimension(ProjAccountType::SalesValue,
                                                                     '',
                                                                     categoryId,
                                                                     0);

            // need to merge the default account with the default dimensions
            mergedLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                                                                    defaultLedgerDimension,
                                                                    referenceAccountingDistribution.LedgerDimension);

            // The revenue line the sum of all the revenue amounts. So we need to revenue amount of the original transaction to calculate
            // its contribution to total revenue.
            allocationFactor =  _revenueLine.TransactionCurrencyAmount ? ((projLine.TransferPrice * infoLine.ReceiveNow)/ _revenueLine.TransactionCurrencyAmount) * referenceAccountingDistribution.AllocationFactor
                                                                       : referenceAccountingDistribution.AllocationFactor;

            ledgerDimensionAllocation = LedgerDimensionAllocation::newFromParameters(mergedLedgerDimension,
                                                                                     allocationFactor,
                                                                                     _side,
                                                                                     false,
                                                                                     referenceAccountingDistribution.RecId);
            _ledgerDimensionAllocationList.addEnd(ledgerDimensionAllocation);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRegularTransactions</Name>
				<Source><![CDATA[
    private void processRegularTransactions(ProjectRevenueHeader            _revenueHeader,
                                            ProjectRevenueLine              _revenueLine,
                                            DebitCredit                     _side,
                                            LedgerDimensionAllocationList   _ledgerDimensionAllocationList)
    {
        Query                           query;
        QueryRun                        queryRun;
        AccountingDistribution          referenceAccountingDistribution;
        ProjectAccountingDistribution   referenceProjectAccountingDistribution;
        ProjTable                       projTable;
        ProjCategory                    projCategory;
        ProjLineProperty                projLineProperty;
        ProjFundingSource               projFundingSource;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        LedgerDimensionAccount          mergedLedgerDimension;
        LedgerDimensionAllocation       ledgerDimensionAllocation;
        AllocationFactor                allocationFactor;
        SourceDocumentLineItem          sourceDocumentLineItem;
        DimensionDefault                dimensionDefault;
        
        SourceDocumentHeader _sourceDocumentHeader = SourceDocumentHeader::find(_revenueHeader.ReferenceSourceDocumentHeader);

        boolean useAccountingEvenTmpTable = this.useAccountingEventTmp(_sourceDocumentHeader.TypeEnumName);

        if (useAccountingEvenTmpTable)
        {
            queryRun = SubledgerJournalizerProjectExtension::distributionsForAccrualQueryRun(_sourceDocumentHeader,
                                                                              _revenueLine.Currency,
                                                                              _revenueLine.AccountingLegalEntity,
                                                                              _revenueLine.AccountingDate,
                                                                              real2int(sign(_revenueLine.TransactionCurrencyAmount)));
        }
        else
        {
            query = SubledgerJournalizerProjectExtension::distributionsForAccrual(_sourceDocumentHeader,
                                                                              _revenueLine.Currency,
                                                                              _revenueLine.AccountingLegalEntity,
                                                                              _revenueLine.AccountingDate,
                                                                              real2int(sign(_revenueLine.TransactionCurrencyAmount)));
            queryRun = new QueryRun(query);
        }

        while (queryRun.next())
        {
            referenceAccountingDistribution = queryRun.get(tableNum(AccountingDistribution));
            referenceProjectAccountingDistribution = queryRun.get(tableNum(ProjectAccountingDistribution));

            changecompany (CompanyInfo::findRecId(referenceAccountingDistribution.AccountingLegalEntity).DataArea)
            {
                projTable = ProjTable::findRecId(referenceProjectAccountingDistribution.ProjTable);
                projCategory = ProjCategory::findRecId(referenceProjectAccountingDistribution.ProjCategory);
                projLineProperty = ProjLineProperty::findRecId(referenceProjectAccountingDistribution.ProjLineProperty);
                sourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(referenceAccountingDistribution.SourceDocumentLine));
                AmountCur transactionCurrencySalesAmount = ProjectAccountingDistribution::transactionCurrencySalesAmount(referenceAccountingDistribution, referenceProjectAccountingDistribution);

                // Add only project revenue lines to <c>ledgerDimensionAllocationList</c>
                if (this.checkToAddProjRevenueLineToLedgerDimAllocationList(
                                                                        projTable, 
                                                                        projCategory, 
                                                                        projLineProperty, 
                                                                        sourceDocumentLineItem, 
                                                                        transactionCurrencySalesAmount, 
                                                                        referenceProjectAccountingDistribution))
                {
                    projFundingSource = ProjFundingSource::find(referenceProjectAccountingDistribution.ProjFundingSource);

                    ProjTaxGroup taxGroup = ProjectSourceDocumentLineItemHelper::getSalesTaxGroup(sourceDocumentLineItem);
                    using (ProjTaxGroupParameters insertParameters = ProjTaxGroupParameters::parmProjTaxGroup(taxGroup))
                    {
                        defaultLedgerDimension = ProjectPosting::accruedRevenueLedgerDimension(
                                                    projTable,
                                                    projCategory,
                                                    projFundingSource);
                    }

                    dimensionDefault = this.getDimensionDefault(sourceDocumentLineItem, referenceAccountingDistribution);

                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, dimensionDefault);
                    
                    allocationFactor = _revenueLine.TransactionCurrencyAmount ? transactionCurrencySalesAmount / _revenueLine.TransactionCurrencyAmount : referenceAccountingDistribution.AllocationFactor;

                    ledgerDimensionAllocation = LedgerDimensionAllocation::newFromParameters(mergedLedgerDimension,
                                                    allocationFactor,
                                                    _side,
                                                    false,
                                                    referenceAccountingDistribution.RecId,
                                                    AccountingDistributionReferenceRole::None,
                                                    0,
                                                    0,
                                                    transactionCurrencySalesAmount);
                    
                    _ledgerDimensionAllocationList.addEnd(ledgerDimensionAllocation);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>subscribe</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Subscribe to the events of the dimension derivation rule extension.
    /// </summary>
    protected void subscribe()
    {
        dimensionDerivationRule.populatingDimAllocListEventHandler += eventhandler(this.populateDimAllocList);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the dimension from <c>SourceDocumentLineItem</c> object or <c>AccountingDistribution</c> table buffer.
    /// </summary>
    /// <param name = "_sourceDocumentLineItem">
    ///     An instance of <c>SourceDocumentLineItem</c> object.
    /// </param>
    /// <param name = "_referenceAccountingDistribution">
    ///     A record of the <c>AccountingDistribution</c> table.
    /// </param>
    /// <returns>
    ///     The dimension from <c>SourceDocumentLineItem</c> object or <c>AccountingDistribution</c> table buffer.
    /// </returns>
    [Wrappable(true)]
    protected final DimensionDefault getDimensionDefault(SourceDocumentLineItem _sourceDocumentLineItem, AccountingDistribution _referenceAccountingDistribution)
    {
        return _sourceDocumentLineItem ? _sourceDocumentLineItem.parmDefaultDimension() : _referenceAccountingDistribution.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useAccountingEventTmp</Name>
				<Source><![CDATA[
    private boolean useAccountingEventTmp(EnumName _enumName)
    {
        return SubledgerJournalizerProjectExtension::canUseAccountingEventTmp(_enumName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkToAddProjRevenueLineToLedgerDimAllocationList</Name>
				<Source><![CDATA[
    private boolean checkToAddProjRevenueLineToLedgerDimAllocationList(ProjTable projTable, 
                                                                       ProjCategory projCategory, 
                                                                       ProjLineProperty projLineProperty, 
                                                                       SourceDocumentLineItem sourceDocumentLineItem, 
                                                                       AmountCur transactionCurrencySalesAmount, 
                                                                       ProjectAccountingDistribution referenceProjectAccountingDistribution)
    {
        boolean canBookActuals = SubledgerJournalizerProjectExtension::parmCanBookActuals(sourceDocumentLineItem);

        boolean isTaxDocLine = sourceDocumentLineItem is TaxSourceDocSublineItem;

        ProjAdvancedJournalLine projAdvJournalLine;

        if (!isTaxDocLine &&
            sourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
        {
            ProjAdvancedJournalSourceDocumentLineItem projAdvancedJournalSDLItem = sourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
            projAdvJournalLine = projAdvancedJournalSDLItem.parmProjAdvancedJournalLine();
        }

        boolean canAccrueRev = false;

        using (ProjectPostingParameters insertParameters = ProjectPostingParameters::parmProjContractLineNum(projAdvJournalLine.ContractLineId))
        {
            canAccrueRev = ProjectPosting::canAccrueRevenue(
                                projTable,
                                projCategory,
                                projLineProperty,
                                transactionCurrencySalesAmount,
                                referenceProjectAccountingDistribution.ProjFundingSource);
        }

        return AddingTaxLineITemToLedgerDimAllocationFlight::instance().isEnabled() ?
                                        (canBookActuals || isTaxDocLine) && canAccrueRev  : 
                                        canBookActuals && canAccrueRev;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>