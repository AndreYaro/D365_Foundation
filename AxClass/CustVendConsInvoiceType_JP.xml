<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendConsInvoiceType_JP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The class <c>CustVendConsInvoiceType_JP</c> is the based type class for consolidation invoice.
/// </summary>
public abstract class CustVendConsInvoiceType_JP extends object
{
    CustVendConsInvoice_JP  consInvoice;
    CustVendConsRefRecId_JP consRecId;
    CustVendConsInvoiceHistory_JP consHistory;
    SysInstrumentationLogger logger = SysInstrumentationLoggerFactory::CreateLogger(classStr(CustVendConsInvoiceType_JP));

    #OCCRetryCount
    #define.Zero(0)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildConstructQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for Consolidated Invoice Construction.
    /// </summary>
    /// <returns>
    /// The constructed query.
    /// </returns>
    public abstract Query buildConstructQuery()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildUpdateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the query for Consolidated Invoice updating.
    /// </summary>
    /// <returns>
    /// The constructed query.
    /// </returns>
    public abstract Query buildUpdateQuery()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Confirms this consolidated invoice.
    /// </summary>
    public void confirm()
    {
        boolean isRetry = false;

        try
        {
            ttsbegin;

            if (isRetry)
            {
                this.reLoadConsInvoice(true);
            }

            if (consInvoice.Status == CustVendConsInvoiceStatus_JP::Unconfirmed)
            {
                // Ensures that no related invoice journal has been paid.
                if (this.hasNoPaymTrans(consInvoice))
                {
                    consInvoice.Status        = CustVendConsInvoiceStatus_JP::Confirmed;
                    consInvoice.CustVendConsInvoice_JP::setInvoiceAmount();

                    // Recalculate consolidation date and due date.
                    consInvoice.PaymTerm      = consInvoice.CustVendConsInvoice_JP::getCustVendInvoiceJourWithSmallestId().Payment;

                    consInvoice.update();

                    // Recalculate due date for related invoice journal and transaction.
                    this.updateDue(consInvoice);

                    CustVendConsInvoiceType_JP::updateConsRefRecId_Confirm(consInvoice);
                }
            }
            else
            {
                // Only unconfirmed consolidated invoice can be confirmed.
                throw error("@GLS63323");
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    isRetry = true;
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNextConfirmedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a confirmed consolidated invoice with later date exists.
    /// </summary>
    /// <returns>
    /// true when such invoice exists; otherwise, false.
    /// </returns>
    private boolean hasNextConfirmedInvoice()
    {
        CustVendConsInvoice_JP  custVendConsInvoice_JP = consInvoice.data();
        boolean                 ret;

        if (consInvoice)
        {
            select firstonly RecId from custVendConsInvoice_JP
                where custVendConsInvoice_JP.ConsInvoice_JP  == consInvoice.RecId
                    && custVendConsInvoice_JP.Status         != CustVendConsInvoiceStatus_JP::Unconfirmed;
            ret = (custVendConsInvoice_JP.RecId != 0);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasNoPaymTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether posted payment journal for this consolidated invoice exists.
    /// </summary>
    /// <param name="_consInvoice">
    /// The given <c>CustVendConsInvoice_JP</c> record.
    /// </param>
    /// <returns>
    /// Returns false when such payment journal exists. Otherwise, returns true.
    /// </returns>
    private boolean hasNoPaymTrans(CustVendConsInvoice_JP _consInvoice)
    {
        CustTrans           custTrans;
        CustTrans_W         custTrans_W;
        CustTrans           offsetCustTrans;
        VendTrans           vendTrans;
        VendTrans_W         vendTrans_W;
        VendTrans           offsetVendTrans;
        boolean             ret = true;

        switch (_consInvoice.TableId)
        {
            case tablenum(CustConsInvoice_JP)   :
                while select Invoice, AccountNum, TransDate from custTrans
                        where custTrans.TransType == LedgerTransType::Sales
                    join SettleAmountMST, RecId from offsetCustTrans
                        where offsetCustTrans.OffsetRecid == custTrans.RecId
                            && offsetCustTrans.TransType  == LedgerTransType::Payment
                            && offsetCustTrans.LastSettleVoucher
                    exists join custTrans_W
                        where custTrans_W.CustTrans == custTrans.RecId
                           && custTrans_W.CustConsInvoice_JP == _consInvoice.RecId
                {
                    if (offsetCustTrans.SettleAmountMST == 0)
                    {
                        // Consolidated invoice %1 can be only confirmed after the invoice %2 that applied a reversed settlement is unmarked.
                        ret = checkFailed(strfmt("@GLS63371", _consInvoice.ConsId, custTrans.Invoice));
                    }
                    else
                    {
                        // Consolidated invoice %1 cannot be confirmed for related invoice %2 has been paid.
                        ret = checkFailed(strfmt("@GLS63329", _consInvoice.ConsId, custTrans.Invoice));
                    }
                }
                break;

            case tablenum(VendConsInvoice_JP)   :
                while select Voucher, AccountNum, TransDate from vendTrans
                        where vendTrans.TransType == LedgerTransType::Purch
                    exists join vendTrans_W
                        where vendTrans.RecId == vendTrans_W.VendTrans
                           && vendTrans_W.VendConsInvoice_JP == _consInvoice.RecId
                    exists join offsetVendTrans
                        where offsetVendTrans.OffsetRecid == vendTrans.RecId
                            && offsetVendTrans.TransType  == LedgerTransType::Payment
                            && offsetVendTrans.LastSettleVoucher
                {
                    // Consolidated invoice %1 cannot be confirmed for related voucher %2 has been paid.
                    ret = checkFailed(strfmt("@GLS63330", _consInvoice.ConsId, vendTrans.Voucher));
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDataLoaded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the Consoldiation Invoice record buffer is loaded.
    /// </summary>
    /// <returns>
    /// True if it is loaded; otherwise, false.
    /// </returns>
    public boolean isDataLoaded()
    {
        return consInvoice
            && consInvoice.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendConsInvoice_JP</Name>
				<Source><![CDATA[
    public CustVendConsInvoice_JP parmCustVendConsInvoice_JP(CustVendConsInvoice_JP _consInvoice = consInvoice)
    {
        this.parmCustVendConsRefRecId_JP(consInvoice.RecId);
        consInvoice = _consInvoice;
        return consInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendConsRefRecId_JP</Name>
				<Source><![CDATA[
    public CustVendConsRefRecId_JP parmCustVendConsRefRecId_JP(CustVendConsRefRecId_JP _consRecId = consRecId)
    {
        if (consRecId != _consRecId)
        {
            consInvoice = null;
        }
        consRecId = _consRecId;
        return consRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reLoadConsInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reloads the <c>CustVendConsInvoice_JP</c> record.
    /// </summary>
    /// <param name="_forUpdate">
    /// A Boolean value that indicates whether to read the record for update; optional.
    /// </param>
    protected void reLoadConsInvoice(boolean _forUpdate  = false)
    {
        CustVendConsInvoice_JP  consInvoiceLocal;

        consInvoiceLocal = this.parmCustVendConsInvoice_JP();

        if (this.isDataLoaded())
        {
            consInvoiceLocal.reread();
            consInvoiceLocal.selectForUpdate(_forUpdate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unconfirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unconfirms this consolidated invoice.
    /// </summary>
    public void unconfirm()
    {
        boolean isRetry = false;

        try
        {
            ttsbegin;

            if (isRetry)
            {
                this.reLoadConsInvoice(true);
            }

            if (consInvoice.Status == CustVendConsInvoiceStatus_JP::Confirmed)
            {
                if (TaxConsInvoice_JP::isTaxDifferencePostingOnConsInvoiceEnabled(false))
                {
                    if(consInvoice.Posted == NoYes::Yes)
                    {
                        if (consInvoice.JournalNum)
                        {
                            // You cannot reopen a posted invoice
                            throw error("@AccountsReceivable:CannotReopenPostedInvoiceError");
                        }
                        else
                        {
                            consInvoice.Posted = NoYes::No;
                        }
                    }
                }

                if (this.hasNextConfirmedInvoice())
                {
                    // To unconfirm this consolidated invoice, first unconfirm all consolidated invoices for this customer/vendor with a later date.
                    throw error("@GLS63324");
                }
                else
                {
                    consInvoice.Status = CustVendConsInvoiceStatus_JP::Unconfirmed;
                    consInvoice.CustVendConsInvoice_JP::setInvoiceAmount();
                    consInvoice.update();

                    CustVendConsInvoiceType_JP::updateConsRefRecId_Unconfirm(consInvoice);
                }
            }
            else
            {
                // Only confirmed consolidated invoice can be unconfirmed.
                throw error("@GLS63325");
            }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    isRetry = true;
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates due date of invoice journal when confirming consolidated invoice.
    /// </summary>
    /// <param name="_consInvoice">
    /// The given record of <c>CustConsInvoice_JP</c> or <c>VendConsInvoice_JP</c>.
    /// </param>
    private void updateDue(CustVendConsInvoice_JP _consInvoice)
    {
        CustInvoiceJour CustInvoiceJour;
        VendInvoiceJour vendInvoiceJour;
        CustInvoiceJour_W custInvoiceJourW;

        ttsbegin;

        if (_consInvoice.TableId == tableNum(CustConsInvoice_JP))
        {
            while select forupdate * from custInvoiceJour
                join forupdate * from custInvoiceJourW
                    where custInvoiceJourW.CustInvoiceJour == custInvoiceJour.RecId
                        && custInvoiceJourW.CustConsInvoice_JP == _consInvoice.RecId
            {
                custInvoiceJour.CustVendInvoiceJour::updateDue_JP();
                custInvoiceJour.update();
            }
        }
        else if (_consInvoice.TableId == tableNum(VendConsInvoice_JP))
        {
            while select forupdate vendInvoiceJour
                where vendInvoiceJour.VendConsInvoice_JP == _consInvoice.RecId
            {
                vendInvoiceJour.CustVendInvoiceJour::updateDue_JP();
                vendInvoiceJour.update();
            }
        }
        else
        {
            Debug::assert(false);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPaymSlipPrintQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a query for payment slip report.
    /// </summary>
    /// <param name="_recId">
    /// The record Id.
    /// </param>
    /// <returns>
    /// Query for payment slip report.
    /// </returns>
    public static Query buildPaymSlipPrintQuery(CustVendConsRefRecId_JP _recId)
    {
        Query                   query = new Query();
        QueryBuildDataSource    qbCustConsInvoice;
        QueryBuildDataSource    qbCustTransW;
        QueryBuildDataSource    qbCustTrans;
        QueryBuildRange         qbrTransType;
        QueryBuildRange         qbrConsRefRecId;

        qbCustConsInvoice = query.addDataSource(tablenum(CustConsInvoice_JP));
        qbrConsRefRecId = qbCustConsInvoice.addRange(fieldnum(CustConsInvoice_JP, RecId));
        qbrConsRefRecId.value(queryValue(_recId));

        qbCustTransW = qbCustConsInvoice.addDataSource(tableNum(CustTrans_W));
        qbCustTransW.relations(true);

        qbCustTrans = qbCustTransW.addDataSource(tablenum(CustTrans));
        qbCustTrans.joinMode(JoinMode::InnerJoin);
        qbCustTrans.relations(true);

        qbrTransType    = qbCustTrans.addRange(fieldnum(CustTrans, TransType));
        qbrTransType.value(queryValue(LedgerTransType::Payment));

        qbrTransType    = qbCustTrans.addRange(fieldnum(CustTrans, TransType));
        qbrTransType.value(queryValue(LedgerTransType::None));

        qbCustTrans.addSortField(fieldnum(CustTrans, TransDate));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPrintQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a query for report.
    /// </summary>
    /// <param name="_custVendConsInvoice">
    /// The table Id for <c>CustConsInvoice</c> or <c>VendConsInvoice</c>.
    /// </param>
    /// <param name="_custVendInvoiceJour">
    /// The table Id for <c>CustInvoiceJour</c> or <c>VendInvoiceJour</c>.
    /// </param>
    /// <param name="_custVendInvoiceTrans">
    /// The table Id for <c>CustInvoiceTrans</c> or <c>VendInvoiceTrans</c>.
    /// </param>
    /// <param name="_recId">
    /// The record Id.
    /// </param>
    /// <returns>
    /// Query for report.
    /// </returns>
    public static Query buildPrintQuery(
        tableId                 _custVendConsInvoice,
        tableId                 _custVendInvoiceJour,
        tableId                 _custVendInvoiceTrans,
        CustVendConsRefRecId_JP _recId)
    {
        Query                   query = new Query();
        QueryBuildDataSource    qbCustVendConsInvoice;
        QueryBuildDataSource    qbCustConsInvoice;
        QueryBuildDataSource    qbCustVendInvoiceJour;
        QueryBuildDataSource    qbCustVendInvoiceTrans;
        QueryBuildRange         qbrConsRefRecId;

        fieldId                 fidRecId;
        fieldId                 fidOrigId;
        fieldId                 fidLineNum;

        qbCustVendConsInvoice = query.addDataSource(_custVendConsInvoice);
        if (_custVendConsInvoice == tableNum(CustConsInvoice_JP))
        {
            qbCustConsInvoice = qbCustVendConsInvoice.addDataSource(tableNum(CustInvoiceJour_W));
            qbCustConsInvoice.relations(true);
            qbCustVendInvoiceJour = qbCustConsInvoice.addDataSource(_custVendInvoiceJour);
            qbCustVendInvoiceJour.relations(true);
        }
        else
        {
            qbCustVendInvoiceJour = qbCustVendConsInvoice.addDataSource(_custVendInvoiceJour);
            qbCustVendInvoiceJour.relations(true);
        }
        qbCustVendInvoiceTrans = qbCustVendInvoiceJour.addDataSource(_custVendInvoiceTrans);
        qbCustVendInvoiceTrans.relations(true);

        if (_custVendConsInvoice == tablenum(CustConsInvoice_JP))
        {
            fidRecId    = fieldnum(CustConsInvoice_JP, RecId);
            fidOrigId   = fieldnum(CustInvoiceTrans, OrigSalesId);
            fidLineNum  = fieldnum(CustInvoiceTrans, LineNum);
        }
        else
        {
            fidRecId    = fieldnum(VendConsInvoice_JP, RecId);
            fidOrigId   = fieldnum(VendInvoiceTrans, OrigPurchId);
            fidLineNum  = fieldnum(VendInvoiceTrans, LineNum);
        }

        qbrConsRefRecId = qbCustVendConsInvoice.addRange(fidRecId);
        qbrConsRefRecId.value(queryValue(_recId));

        qbCustVendInvoiceTrans.addSortField(fidOrigId);
        qbCustVendInvoiceTrans.addSortField(fidLineNum);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructByConsInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>CustVendConsInvoiceType_JP</c> class based on a given
    /// <c>CustVendConsInvoice_JP</c> record.
    /// </summary>
    /// <param name="_consInvoice">
    /// The given <c>CustVendConsInvoice_JP</c> class
    /// </param>
    /// <returns>
    /// The constructed <c>CustVendConsInvoiceType_JP</c> instance.
    /// </returns>
    public static CustVendConsInvoiceType_JP constructByConsInvoice(CustVendConsInvoice_JP _consInvoice)
    {
        CustVendConsInvoiceType_JP  consInvoiceType;

        if (_consInvoice)
        {
            switch (_consInvoice.TableId)
            {
                case tablenum(custConsInvoice_JP)   :
                    consInvoiceType = CustConsInvoiceType_JP::construct(_consInvoice);
                    break;

                case tablenum(VendConsInvoice_JP)   :
                    consInvoiceType = VendConsInvoiceType_JP::construct(_consInvoice);
                    break;
            }
        }

        return consInvoiceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentConsPeriodEndDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets end date of current consolidated period.
    /// </summary>
    /// <param name="_accountNum">
    /// The customer or vendor account.
    /// </param>
    /// <param name="_accountType">
    /// The account type, Cust or Vend.
    /// </param>
    /// <param name="_currentDate">
    /// The current date, default value is current session date.
    /// </param>
    /// <returns>
    /// The current consolidated period end date.
    /// </returns>
    public static TransDate getCurrentConsPeriodEndDate(
        CustVendAC      _accountNum,
        CustVendACType  _accountType,
        Date            _currentDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        CustVendConsDay_JP  custVendConsDay;
        TransDate           currentConsPeriodEndDate;

        if (_accountType == CustVendACType::Cust)
        {
            custVendConsDay = CustTable::find(_accountNum).ConsDay_JP;
        }
        else
        {
            custVendConsDay = VendTable::find(_accountNum).ConsDay_JP;
        }

        if (custVendConsDay == #Zero)
        {
            // consolidation day = 0, it means consolidated invoice is disabled for this vendor / customer.
            // So no consolidated invoice will be created for this customer / vendor.
            currentConsPeriodEndDate = dateNull();
        }
        else if (custVendConsDay > dayOfMth(_currentDate))
        {
            // year(prevMth(currentDate)) equals previous year when current month is January, otherwise it equals current year.
            currentConsPeriodEndDate = mkDate(custVendConsDay, mthOfYr(prevMth(_currentDate)), year(prevMth(_currentDate)));
        }
        else
        {
            currentConsPeriodEndDate = mkDate(custVendConsDay, mthOfYr(_currentDate), year(_currentDate));
        }

        return currentConsPeriodEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceJourPaid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the specified invoice journal has been paid, even partial paid.
    /// </summary>
    /// <param name="_invoiceJour">
    /// The given <c>CustInvoiceJour</c> or <c>VendInvoiceJour</c> record.
    /// </param>
    /// <returns>
    /// Returns true if it has been paid. otherwise, returns false.
    /// </returns>
    public static boolean isInvoiceJourPaid(CustVendInvoiceJour _invoiceJour)
    {
        CustTrans       custTrans;
        VendTrans       vendTrans;
        recId           transRecId;

        switch (_invoiceJour.TableId)
        {
            case tablenum(CustInvoiceJour)  :
                select firstonly RecId from custTrans
                    where custTrans.Invoice      == _invoiceJour.InvoiceId
                        && custTrans.Voucher     == _invoiceJour.LedgerVoucher
                        && custTrans.AccountNum  == _invoiceJour.InvoiceAccount
                        && custTrans.TransDate   == _invoiceJour.InvoiceDate
                        && custTrans.OffsetRecid != 0
                        && custTrans.LastSettleVoucher;
                transRecId = custTrans.RecId;
                break;

            case tablenum(VendInvoiceJour)  :
                select firstonly RecId from vendTrans
                    where vendTrans.Voucher      == _invoiceJour.LedgerVoucher
                        && vendTrans.AccountNum  == _invoiceJour.InvoiceAccount
                        && vendTrans.TransDate   == _invoiceJour.InvoiceDate
                        && vendTrans.OffsetRecid != 0
                        && vendTrans.LastSettleVoucher;
                transRecId = vendTrans.RecId;
                break;

            default                         :
                break;
        }

        return (transRecId != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove invoice journal from the consolidated invoice.
    /// </summary>
    /// <param name = "_tableSource">from custInvoiceJour or vendInvoiceJour</param>
    /// <param name = "_invoiceJourToRemove">list of custInvoiceJour RecID to remove</param>
    public static void removeInvoiceJour(int _tableSource, List _invoiceJourToRemove)
    {
        CustVendConsRefRecId_JP refRecId = #Zero;
        refRecId invoiceJourToRemoveRecId;

        CustInvoiceJour custInvoiceJour;
        CustInvoiceJour_W custInvoiceJourW;
        VendInvoiceJour vendInvoiceJour;

        ListEnumerator listEnum = _invoiceJourToRemove.getEnumerator();

        ttsbegin;

        switch (_tableSource)
        {
            case tablenum(CustInvoiceJour):
                while (listEnum.moveNext())
                {
                    invoiceJourToRemoveRecId = listEnum.current();
                    custInvoiceJour = custInvoiceJour::findRecId(invoiceJourToRemoveRecId, true);
                    custInvoiceJourW = custInvoiceJour.custInvoiceJour_W();
                    custInvoiceJourW.CustConsInvoice_JP = refRecId;
                    custInvoiceJour.packCustInvoiceJour_W(custInvoiceJourW);

                    custInvoiceJour.CustVendInvoiceJour::updateDue_JP();
                    custInvoiceJour.update();

                    CustVendConsInvoiceType_JP::updateTransByMarkJour(custInvoiceJour, false);
                }
                break;

            case tablenum(VendInvoiceJour):
                while (listEnum.moveNext())
                {
                    invoiceJourToRemoveRecId = listEnum.current();
                    vendInvoiceJour = VendInvoiceJour::findRecId(invoiceJourToRemoveRecId, true);

                    vendInvoiceJour.VendConsInvoice_JP = refRecId;
                    vendInvoiceJour.CustVendInvoiceJour::updateDue_JP();
                    vendInvoiceJour.update();

                    CustVendConsInvoiceType_JP::updateTransByMarkJour(vendInvoiceJour, false);
                }
                break;

            default:
                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateConsRefRecId_Confirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates references when confirming a consolidated invoice.
    /// </summary>
    /// <param name="_consInvoice">
    /// The given <c>CustVendConsInvoice_JP</c> record.
    /// </param>
    private static void updateConsRefRecId_Confirm(CustVendConsInvoice_JP _consInvoice)
    {
        CustConsInvoice_JP  custConsInvoice;
        VendConsInvoice_JP  vendConsInvoice;

        ttsbegin;
        switch (_consInvoice.TableId)
        {
            case tablenum(CustConsInvoice_JP)   :
                update_recordset custConsInvoice
                    setting CustConsInvoice_JP = _consInvoice.RecId
                    where custConsInvoice.CustTable == _consInvoice.AccountNum
                        && custConsInvoice.Status   == CustVendConsInvoiceStatus_JP::Unconfirmed;
                break;

            case tablenum(VendConsInvoice_JP)   :
                update_recordset vendConsInvoice
                    setting VendConsInvoice_JP = _consInvoice.RecId
                    where vendConsInvoice.VendTable == _consInvoice.AccountNum
                        && vendConsInvoice.Status   == CustVendConsInvoiceStatus_JP::Unconfirmed;
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateConsRefRecId_Unconfirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates references when un-confirming a consolidated invoice.
    /// </summary>
    /// <param name="_consInvoice">
    /// The given <c>CustVendConsInvoice_JP</c> record.
    /// </param>
    private static void updateConsRefRecId_Unconfirm(CustVendConsInvoice_JP _consInvoice)
    {
        CustConsInvoice_JP  custConsInvoice;
        VendConsInvoice_JP  vendConsInvoice;

        ttsbegin;
        switch (_consInvoice.TableId)
        {
            case tablenum(CustConsInvoice_JP)   :
                update_recordset custConsInvoice
                    setting CustConsInvoice_JP = _consInvoice.ConsInvoice_JP
                    where custConsInvoice.CustTable           == _consInvoice.AccountNum
                        && custConsInvoice.CustConsInvoice_JP == _consInvoice.RecId;
                break;

            case tablenum(VendConsInvoice_JP)   :
                update_recordset vendConsInvoice
                    setting VendConsInvoice_JP = _consInvoice.ConsInvoice_JP
                    where vendConsInvoice.VendTable           == _consInvoice.AccountNum
                        && vendConsInvoice.VendConsInvoice_JP == _consInvoice.RecId;
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransByMarkJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates reference of related transactions when marking or unmarking specified invoice journal.
    /// </summary>
    /// <param name="_invoiceJour">
    /// The given <c>CustVendInvoiceJour</c> record.
    /// </param>
    /// <param name="_mark">
    /// Indicates whether marking or unmarking a invoice journal.
    /// </param>
    /// <remarks>
    /// This method is called when marking or unmarking a invoice journal.
    /// This method is also called when creating or updating a consolidated invoice while the invoice journal will be marked.
    /// </remarks>
    public static void updateTransByMarkJour(
        CustVendInvoiceJour _invoiceJour,
        boolean             _mark)
    {
        CustInvoiceJour         custInvoiceJour;
        VendInvoiceJour         vendInvoiceJour;
        CustTrans               custTrans;
        CustTrans_W             custTrans_W;
        VendTrans               vendTrans;
        VendTrans_W             vendTrans_W;
        CustVendConsRefRecId_JP refRecId;
        CustInvoiceJour         custInvoiceJourLocal;
        VendInvoiceJour         vendInvoiceJourLocal;

        ttsbegin;

        refRecId = #Zero;

        switch (_invoiceJour.TableId)
        {
            case tablenum(CustInvoiceJour):
                custInvoiceJour = _invoiceJour;

                if (_mark)
                {
                    refRecId = CustConsInvoice_JP::find(custInvoiceJour.custInvoiceJour_W().CustConsInvoice_JP).RecId;
                }

                update_recordset custTrans_W
                        setting CustConsInvoice_JP = refRecId
                    exists join custTrans
                        where custTrans.RecId == custTrans_W.CustTrans
                    exists join custInvoiceJourLocal
                        where custInvoiceJourLocal.RecId             == _invoiceJour.RecId
                           && custInvoiceJourLocal.InvoiceId         == custTrans.Invoice
                           && custInvoiceJourLocal.InvoiceAccount    == custTrans.AccountNum
                           && custInvoiceJourLocal.InvoiceDate       == custTrans.TransDate;
                break;

            case tablenum(VendInvoiceJour)   :
                vendInvoiceJour = _invoiceJour;

                if (_mark)
                {
                    refRecId = VendConsInvoice_JP::find(vendInvoiceJour.VendConsInvoice_JP).RecId;
                }

                update_recordset vendTrans_W
                        setting VendConsInvoice_JP = refRecId
                    exists join vendTrans
                        where vendTrans.RecId == vendTrans_W.VendTrans
                    exists join vendInvoiceJourLocal
                        where vendInvoiceJourLocal.RecId             == _invoiceJour.RecId
                           && vendInvoiceJourLocal.LedgerVoucher     == vendTrans.Voucher
                           && vendInvoiceJourLocal.InvoiceAccount    == vendTrans.AccountNum
                           && vendInvoiceJourLocal.InvoiceDate       == vendTrans.TransDate;
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCode</Name>
				<Source><![CDATA[
    internal protected CurrencyCode getCurrencyCode()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalName</Name>
				<Source><![CDATA[
    internal protected LedgerJournalNameId getJournalName()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJournalACType</Name>
				<Source><![CDATA[
    internal protected LedgerJournalACType getJournalACType()
    {
        return LedgerJournalACType::Ledger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasHistoryInProgress</Name>
				<Source><![CDATA[
    internal protected boolean hasHistoryInProgress()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalHeader</Name>
				<Source><![CDATA[
    private LedgerJournalTable createJournalHeader(LedgerJournalNameId _ledgerJournalName, CurrencyCode _currency, LedgerDefaultDimensionValueSet _defaultDimension = 0)
    {
        LedgerJournalTable ledgerJournalTable;

        ledgerJournalTable.initValue();
        ledgerJournalTable.JournalName = _ledgerJournalName;
        ledgerJournalTable.defaultRow();
        ledgerJournalTable.CurrencyCode = _currency;
        ledgerJournalTable.DefaultDimension = _defaultDimension;

        ledgerJournalTable.insert();

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournal</Name>
				<Source><![CDATA[
    internal protected LedgerJournalTable createJournal(TmpTaxWorkTrans _tmpTaxWorkTrans, CurrencyCode _currency, LedgerDefaultDimensionValueSet _defaultDimension = 0)
    {
        LedgerJournalNameId ledgerJournalName = this.getJournalName();
        LedgerJournalTable ledgerJournalTable = this.createJournalHeader(ledgerJournalName, _currency, _defaultDimension);
        NumberSequenceTable numSequenceVoucher = NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable);
        Voucher voucher = NumberSeq::newGetVoucherFromCode(numSequenceVoucher.NumberSequence).voucher();

        //LedgerJournalTrans line variables
        AmountCur totalTaxDifferenceAmount = 0;

        //Dimension information 
        LedgerDimensionAccount ledgerDimension;
        TaxLedgerAccountGroup taxLedgerAccountGroup;
        LedgerDimensionDefaultAccount defaultAccount;
       
        boolean isLedgerCorrectionParameterEnabled = LedgerParameters::find().TransactionReversalCorrection;

        while select _tmpTaxWorkTrans
        {
            if (_tmpTaxWorkTrans.TaxCode)
            {
                if(!_tmpTaxWorkTrans.SourceRegulateAmountCur
                   && !_tmpTaxWorkTrans.TaxInCostPriceRegulated)
                {
                    continue;
                }

                taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::findAccountGroup(_tmpTaxWorkTrans.TaxCode));

                defaultAccount = taxLedgerAccountGroup.taxLedgerDimension(_tmpTaxWorkTrans.TaxDirection);

                if (defaultAccount != 0)
                {
                    ledgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, _defaultDimension);
                }

                AmountCur amountCredit;
                AmountCur amountDebit;

                AmountCur nonDeductibleTaxDifferenceAmount = _tmpTaxWorkTrans.TaxInCostPriceRegulated;
                if (nonDeductibleTaxDifferenceAmount)
                {
                    LedgerDimensionAccount nonDeductibleTaxDiffLedgerDimension = TaxConsInvoice_JP::getNondeductibleTaxLedgerDimension(_tmpTaxWorkTrans.TaxCode);
                    if (!nonDeductibleTaxDiffLedgerDimension)
                    {
                        throw error(strFmt("@Tax:NotHaveAccountErrorMsg", taxLedgerAccountGroup.TaxAccountGroup, "@Tax:NondeductibleTaxExpense"));
                    }
                }

                AmountCur taxDifferenceAmount = _tmpTaxWorkTrans.SourceRegulateAmountCur;
                totalTaxDifferenceAmount += taxDifferenceAmount;
                amountCredit = (taxDifferenceAmount < 0) ? -taxDifferenceAmount: 0;
                amountDebit = (taxDifferenceAmount > 0) ? taxDifferenceAmount: 0;

                // considering Ledger Parameter for Correction when tax diff amount < 0
                if (isLedgerCorrectionParameterEnabled && this.isTaxDifferenceAmountNegative(_tmpTaxWorkTrans))
                {
                    switch (consInvoice.TableId)
                    {
                        case tablenum(CustConsInvoice_JP):
                            amountCredit = -amountDebit;
                            amountDebit = 0;

                            break;

                        case tablenum(VendConsInvoice_JP):
                            amountDebit = -amountCredit;
                            amountCredit = 0;

                            break;
                    }

                }

                this.createJournalLine(
                        ledgerJournalTable,
                        consInvoice.ConsDate,
                        voucher,
                        LedgerJournalACType::Ledger,
                        ledgerDimension,
                        amountDebit,
                        amountCredit,
                        _tmpTaxWorkTrans.TaxCode,
                        LedgerJournalACType::Ledger,
                        0,
                        nonDeductibleTaxDifferenceAmount,
                        _defaultDimension);

            }
        }

        if (totalTaxDifferenceAmount)
        {
            AmountCur custVendBalance = totalTaxDifferenceAmount;
            AmountCur totalTaxDifferenceDebit = (totalTaxDifferenceAmount < 0) ? -totalTaxDifferenceAmount: 0;
            AmountCur totalTaxDifferenceCredit = (totalTaxDifferenceAmount > 0) ? totalTaxDifferenceAmount: 0;

            // considering Ledger Parameter for Correction when tax diff amount < 0
            if (isLedgerCorrectionParameterEnabled && this.isTaxDifferenceAmountNegative(_tmpTaxWorkTrans, custVendBalance))
            {
                switch (consInvoice.TableId)
                {
                    case tablenum(CustConsInvoice_JP):
                        totalTaxDifferenceDebit = -totalTaxDifferenceCredit;
                        totalTaxDifferenceCredit = 0;

                        break;

                    case tablenum(VendConsInvoice_JP):
                        totalTaxDifferenceCredit = -totalTaxDifferenceDebit;
                        totalTaxDifferenceDebit = 0;

                        break;

                }

            }

            this.createJournalLine(
                ledgerJournalTable,
                consInvoice.ConsDate,
                voucher,
                this.getJournalACType(),
                LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(consInvoice.AccountNum, this.getJournalACType()),
                totalTaxDifferenceDebit,
                totalTaxDifferenceCredit,
                _tmpTaxWorkTrans.TaxCode,
                LedgerJournalACType::Ledger,
                0,
                0,
                _defaultDimension);
        }

        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJournalLine</Name>
				<Source><![CDATA[
    private void createJournalLine(
        LedgerJournalTable _ledgerJournalTable,
        TransDate _transDate,
        Voucher _voucher,
        LedgerJournalACType _accountType,
        DimensionDynamicAccount _ledgerDimension,
        AmountMST _amountDebit,
        AmountMST _amountCredit,
        TaxCode _taxCode,
        LedgerJournalACType _offsetAccountType = LedgerJournalACType::Ledger,
        DimensionDynamicAccount _offsetLedgerDimension = 0,
        AmountMST _nonDeductibleTaxDifferenceAmount = 0,
        LedgerDefaultDimensionValueSet _defaultDimension = 0)
    {
        if (_amountDebit && _amountCredit)
        {
            throw error("@AccountsReceivable:BothCreditDebitAmountsPresentError");
        }

        if (_ledgerDimension == 0)
        {
            throw error("@AccountsReceivable:LedgerDimensionMissingError");
        }

        LedgerJournalTrans ledgerJournalTrans;
        LedgerJournalTransTaxExtension taxExtension;

        ledgerJournalTrans.initValue();

        ledgerJournalTrans.JournalNum = _ledgerJournalTable.JournalNum;
        ledgerJournalTrans.TransDate = _transDate;
        ledgerJournalTrans.Voucher = _voucher;
        ledgerJournalTrans.AccountType = _accountType;
        ledgerJournalTrans.LedgerDimension = _ledgerDimension;
        ledgerJournalTrans.DefaultDimension = _defaultDimension;
        ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, LedgerDimension));

        if (_amountDebit)
        {
            ledgerJournalTrans.AmountCurDebit = _amountDebit;
            ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, AmountCurDebit));
        }

        if (_amountCredit)
        {
            ledgerJournalTrans.AmountCurCredit = _amountCredit;
            ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, AmountCurCredit));
        }

        ledgerJournalTrans.OffsetAccountType = _offsetAccountType;

        if (_offsetLedgerDimension != 0)
        {
            ledgerJournalTrans.OffsetLedgerDimension = _offsetLedgerDimension;
            ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, OffsetLedgerDimension));
        }

        ledgerJournalTrans.CurrencyCode = _ledgerJournalTable.CurrencyCode;

        if (_ledgerJournalTable.CurrencyCode != Ledger::accountingCurrency())
        {
            ledgerJournalTrans.modifiedField(fieldNum(LedgerJournalTrans, CurrencyCode));
        }

        ledgerJournalTrans.TransactionType = LedgerTransType::GeneralJournal;
        ledgerJournalTrans.TaxCode = _taxCode;
        ledgerJournalTrans.Approved = NoYes::Yes;
        ledgerJournalTrans.Approver = HcmWorker::userId2Worker(curUserId());

        ledgerJournalTrans.write();

        if (_nonDeductibleTaxDifferenceAmount)
        {
            taxExtension = ledgerJournalTrans.ledgerJournalTransTaxExtension();
            taxExtension.TaxInCostPrice = _nonDeductibleTaxDifferenceAmount;
            taxExtension.save(ledgerJournalTrans, true);
            ledgerJournalTrans.calcBaseAmountMSTIncTaxInCostPrice();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceHistoryEntryStatus</Name>
				<Source><![CDATA[
    internal protected void updateInvoiceHistoryEntryStatus()
    {
        ttsbegin;
        consHistory.reread();

        if (consHistory.RecId && consHistory.Status == CustVendConsInvoiceHistoryStatus_JP::InProgress)
        {
            logger.logInformation(strFmt('Posting failed for consolidated invoice: %1', consInvoice.ConsId));
            consHistory.delete();
        }
        else
        {
            logger.logInformation(strFmt('Posting completed for consolidated invoice: %1', consInvoice.ConsId));
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts this consolidated invoice.
    /// </summary>
    internal void post()
    {
        boolean isRetry = false;
        TaxConsInvoice_JP taxConsInvoice_JP = TaxConsInvoice_JP::newForSourceTable(consInvoice);
        CurrencyCode currencyCode = this.getCurrencyCode();

        using (SysInstrumentationActivityContext activityContext = logger.activityContext("ConsolidatedInvoiceOperation", "Posting"))
        {
            taxConsInvoice_JP.validateSalesTaxTransactionProperties();
            if (this.hasHistoryInProgress())
            {
                logger.logError(strFmt('Another operation detected on consolidated invoice: %1', consInvoice.ConsId));
                throw Error(strFmt('@AccountsReceivable:ParallelCustVendConsInvoicePostingError', consInvoice.ConsId));
            }

            try
            {
                if (isRetry)
                {
                    this.reLoadConsInvoice(true);
                }

                consInvoice.CustVendConsInvoice_JP::setPosted();

                if (consInvoice.Status != CustVendConsInvoiceStatus_JP::Unconfirmed
                && consInvoice.Posted == NoYes::No)
                {
                    consHistory = CustVendConsInvoiceHistory_JP::create(consInvoice);

                    ttsbegin;

                    TmpTaxWorkTrans tmpTaxWorkTrans = taxConsInvoice_JP.calculateTax();

                    select tmpTaxWorkTrans
                    where tmpTaxWorkTrans.TaxCode
                        && (tmpTaxWorkTrans.SourceRegulateAmountCur || tmpTaxWorkTrans.TaxInCostPriceRegulated);

                    if (tmpTaxWorkTrans)
                    {
                        LedgerDefaultDimensionValueSet defaultDimension;

                        switch (consInvoice.TableId)
                        {
                            case tablenum(CustConsInvoice_JP):
                                CustTable custAccount = CustTable::find(consInvoice.AccountNum);
                                defaultDimension = custAccount.DefaultDimension;

                                break;

                            case tablenum(VendConsInvoice_JP):
                                VendTable vendAccount = VendTable::find(consInvoice.AccountNum);
                                defaultDimension = vendAccount.DefaultDimension;

                                break;
                        }

                        LedgerJournalTable ledgerJournalTable = this.createJournal(tmpTaxWorkTrans, currencyCode, defaultDimension);
                        consHistory.JournalNum = LedgerJournalTable.JournalNum;
                        consHistory.update();

                        logger.logInformation(strFmt('Posting consolidated invoice: %1', consInvoice.ConsId));
                        LedgerJournalPost::postJournal(ledgerJournalTable, NoYes::No);
                    }
                    else
                    {
                        consInvoice.Posted = NoYes::Yes;
                        consInvoice.update();
                        logger.logInformation(strFmt('Posting completed with no tax difference posted for consolidated invoice: %1', consInvoice.ConsId));
                        info('@AccountsReceivable:OperationCompleted');
                    }

                    ttscommit;
                }

                else
                {
                    // Unconfirmed consolidated invoices cannot be posted.
                    throw error("@AccountsReceivable:UnconfirmedConsolidatedInvoicePostingError");
                }

            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    isRetry = true;
                    retry;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() >= #RetryNum)
                    {
                        throw Exception::UpdateConflictNotRecovered;
                    }
                    else
                    {
                        isRetry = true;
                        retry;
                    }
                }
                else
                {
                    throw Exception::UpdateConflict;
                }
            }
            catch (Exception::Error)
            {
                throw;
            }
            finally
            {
                /*
             * In case of any posting failures, we need to remove
             * the created history entry if the status of history
             * entry is not changed from InProgress to Completed.
             */
             this.updateInvoiceHistoryEntryStatus();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTaxDifferenceAmountNegative</Name>
				<Source><![CDATA[
    private boolean isTaxDifferenceAmountNegative(TmpTaxWorkTrans _tmpTaxWorkTrans, AmountCur custVendBalance = 0)
    {
        boolean isTaxDiffIsNegative = false;

        if (!custVendBalance)
        {
            isTaxDiffIsNegative = (abs(_tmpTaxWorkTrans.ConsolidateSourceTaxAmountCur_JP) < abs(_tmpTaxWorkTrans.ConsolidateSourceTaxAmountCurPosted_JP));
        }
        else
        {
            switch (consInvoice.TableId)
            {
                case tablenum(CustConsInvoice_JP):

                    isTaxDiffIsNegative = (custVendBalance > 0) ? true : false;

                    break;

                case tablenum(VendConsInvoice_JP):

                    isTaxDiffIsNegative = (custVendBalance < 0) ? true : false;

                    break;
            }
        }

        return isTaxDiffIsNegative;
    
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>