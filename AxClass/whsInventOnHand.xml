<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>whsInventOnHand</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>whsInventOnHand</c> class is used to query onhand and available
/// for reservation quantity of items in specific reservation hierarchies.
/// </summary>
class whsInventOnHand
{
    #WHSReservationHierarchy

    #define.ConPosPhysical(1)
    #define.ConPosOrdered(2)

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getAvailPhysicalHandlingQuantityForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total physically available quantity in the handling unit for reservation for a specified hierarchy level
    /// based on the inventory dimension criteria provided.
    /// </summary>
    /// <param name = "_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name = "_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name = "_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name = "_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// The quantity in the handling unit that is available for reservation at the specified hierarchy level.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest level that can be deducted from inventDim criteria.
    /// </remarks>
    [Hookable(false)]
    internal static InventHandlingQty getAvailPhysicalHandlingQuantityForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWAvailPhysicalForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
        }

        return whsInventOnHand::getAvailPhysicalForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailPhysicalForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total physically available quantity for reservation for a specified hierarchy level based on the inventory dimension criteria provided.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// The quantity that is available for reservation at the specified hierarchy level.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest level that can be deducted from inventDim criteria.
    /// </remarks>
    public static InventQty getAvailPhysicalForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta = true)
    {
        return conPeek(whsInventOnHand::getAvailQuantityForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta), #ConPosPhysical);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWAvailPhysicalForLevel</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWAvailPhysicalForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        WHSInventReserveQuantities quanties = whsInventOnHand::getAvailQuantitiesForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);

        return quanties.CWAvailPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailOrderedHandlingQuantityForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity available for reservation in the handling unit for a specified hierarchy level
    /// based on the inventory dimension criteria provided.
    /// </summary>
    /// <param name = "_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name = "_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name = "_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name = "_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// The quantity in the handling unit that is available for reservation at the specified hierarchy level.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest level that can be deducted from inventDim criteria.
    /// </remarks>
    [Hookable(false)]
    internal static InventHandlingQty getAvailOrderedHandlingQuantityForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWAvailOrderedForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
        }

        return whsInventOnHand::getAvailOrderedForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailOrderedForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total quantity available for reservation for a specified hierarchy level based on the dim criteria provided.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// The quantity that is available for reservation at the specified hierarchy level.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest level that can be deducted from inventDim criteria.
    /// </remarks>
    public static InventQty getAvailOrderedForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta = true)
    {
        return conPeek(whsInventOnHand::getAvailQuantityForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta), #ConPosOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWAvailOrderedForLevel</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWAvailOrderedForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        WHSInventReserveQuantities quanties = whsInventOnHand::getAvailQuantitiesForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);

        return quanties.CWAvailOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailHandlingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the available onhand quantity in the handling unit of an item with a dimension criteria.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    /// The upper most hierarchy level to be considered for calculating the onhand; optional, by default the calculation includes all levels up the hierarchy.
    /// </param>
    /// <returns>
    /// A <c>WHSInventReserveQuantities</c> instance containing the maximum physically available quantities and maximum reservable quantities.
    /// </returns>
    [Hookable(false)]
    internal static WHSInventReserveQuantities getAvailHandlingQuantities(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        boolean                         _mustIncludeDelta,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getAllAvailQuantities(_itemId, _inventDimCriteria, _mustIncludeDelta, _upperLevelOfMinimumCalculation);
        }
        
        InventQty   maxPhysicalAvail;
        InventQty   maxOrderedAvail;
        [maxPhysicalAvail, maxOrderedAvail] = whsInventOnHand::getAvailQty(_itemId, _inventDimCriteria, _mustIncludeDelta, _upperLevelOfMinimumCalculation);

        return WHSInventReserveQuantities::newAvailQuantities(maxPhysicalAvail, maxOrderedAvail, 0, 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the available onhand quantity of an item with a dimension criteria.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    /// The upper most hierarchy level to be considered for calculating the onhand; optional, by default the calculation includes all levels up the hierarchy.
    /// </param>
    /// <returns>
    /// A container containing the maximum physically available quantity and maximum reservable quantity.
    /// </returns>
    public static container getAvailQty(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        boolean                         _mustIncludeDelta = true,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        InventQty               maxPhysicalAvail;
        InventQty               maxOrderedAvail;
        CreatedTransactionId    ttsId;
        boolean                 isWork = false;

        ttsbegin;

        if (_mustIncludeDelta)
        {
            ttsId = InventUpdateOnhandGlobal::instance().inventUpdateOnhand().ttsId();

            // Perform an initial check to make absolutely sure a delta
            // record actually exists for this item.  Much more expensive operation if a
            // delta record exists
            if (WHSInventReserveDelta::existTtsIdItemId(ttsId, _itemId))
            {
                [maxPhysicalAvail, maxOrderedAvail] = whsInventOnHand::getReserveAvailQtyIncludeDelta(_itemId,
                                                                                                _inventDimCriteria,
                                                                                                ttsId,
                                                                                                isWork,
                                                                                                true,
                                                                                                false,
                                                                                                null,
                                                                                                _upperLevelOfMinimumCalculation);
            }
            else
            {
                [maxPhysicalAvail, maxOrderedAvail] = whsInventOnHand::getReserveAvailQty(_itemId, _inventDimCriteria, isWork, _upperLevelOfMinimumCalculation);
            }
        }
        else
        {
            [maxPhysicalAvail, maxOrderedAvail] = whsInventOnHand::getReserveAvailQty(_itemId, _inventDimCriteria, isWork, _upperLevelOfMinimumCalculation);
        }

        ttscommit;

        return [maxPhysicalAvail, maxOrderedAvail];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllAvailQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the available onhand quantity of an item with a dimension criteria.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    /// The upper most hierarchy level to be considered for calculating the onhand; optional, by default the calculation includes all levels up the hierarchy.
    /// </param>
    /// <returns>
    /// An <c>WHSInventReserveQuantities</c> instance containing the available quantities.
    /// </returns>
    [Hookable(false)]
    internal static WHSInventReserveQuantities getAllAvailQuantities(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        boolean                         _mustIncludeDelta = true,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        boolean isWork = false;
        boolean doIncludeDelta = false;
        CreatedTransactionId ttsId;
        
        ttsbegin;
    
        if (_mustIncludeDelta)
        {
            ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

            // Perform an initial check to make absolutely sure a delta
            // record actually exists for this item.  Much more expensive operation if a delta record exists
            doIncludeDelta = WHSInventReserveDelta::existTtsIdItemId(ttsId, _itemId);            
        }
        
        WHSInventReserveQuantities quantities;

        if (doIncludeDelta)
        {
            quantities = whsInventOnHand::getReserveAvailQuantitiesIncludeDelta(_itemId, _inventDimCriteria, ttsId, isWork, true, _upperLevelOfMinimumCalculation);
        }
        else
        {
            quantities = whsInventOnHand::getAllReserveAvailQuantities(_itemId, _inventDimCriteria, isWork, _upperLevelOfMinimumCalculation);
        }        

        ttscommit;

        return quantities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailHandlingQuantityForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total avail physical and avail ordered qty in the handling unit for a specified hierarchy level based on the dim criteria provided.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// A container containing the quantity in the handling unit that is available physical and avail ordered for reservation at the specified hierarchy level respectively.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest can be deducted from the inventDim criteria.
    /// </remarks>
    [Hookable(false)]
    internal static container getAvailHandlingQuantityForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWAvailQuantityForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
        }

        return whsInventOnHand::getAvailQuantityForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailQuantityForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total avail physical and avail ordered qty for a specified hierarchy level based on the dim criteria provided.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// A container containing the quantity that is available physical and avail ordered for reservation at the specified hierarchy level respectively.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest can be deducted from the inventDim criteria.
    /// </remarks>
    public static container getAvailQuantityForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        WHSInventReserveQuantities quanties = whsInventOnHand::getAvailQuantitiesForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
        
        return [quanties.AvailPhysical, quanties.AvailOrdered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWAvailQuantityForLevel</Name>
				<Source><![CDATA[
    private static container getCWAvailQuantityForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        WHSInventReserveQuantities quanties = whsInventOnHand::getAvailQuantitiesForLevel(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);
        
        return [quanties.CWAvailPhysical, quanties.CWAvailOrdered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailQuantitiesForLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the total available quantities for a specified hierarchy level based on the dimension criteria provided.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_hierarchyLevel">
    /// The hierarchy level that availability is being calculated for.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines if delta records must be used in the calculation.
    /// </param>
    /// <returns>
    /// A <c>WHSInventReserveQuantities</c> instance containing the quantities that are available for reservation at the specified hierarchy level respectively.
    /// </returns>
    /// <remarks>
    /// This hierarchy level should be for a level that is as specific or more specific than the deepest can be deducted from the inventDim criteria.
    /// </remarks>
    [Hookable(false)]
    public static WHSInventReserveQuantities getAvailQuantitiesForLevel(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        WHSReservationHierarchyLevel    _hierarchyLevel,
        boolean                         _mustIncludeDelta)
    {
        WHSInstrumentationLogger logger = WHSInstrumentationLogger::createLogger(classStr(WHSInventOnHand));

        using (var activityContext = logger.whsOnHandCalculations().calculateQuantitiesForLevel())
        {
            WHSInventOnHandForLevelCalculator onHandForLevelCalculator = WHSInventOnHandForLevelCalculator::constructFromParameters(_itemId, _inventDimCriteria, _hierarchyLevel, _mustIncludeDelta);

            onHandForLevelCalculator.parmFetchOnlyAvailFields(true);
            onHandForLevelCalculator.parmUseDeltaView(true);

            WHSInventReserve whsInventReserve = onHandForLevelCalculator.calculateQuantities();

            return WHSInventReserveQuantities::newAvailQuantities(whsInventReserve.AvailPhysical,
                                                        whsInventReserve.AvailOrdered,
                                                        whsInventReserve.CWAvailPhysical,
                                                        whsInventReserve.CWAvailOrdered);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderedAvailHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable ordered quantity in the handling unit of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The reservable ordered quantity in the handling unit of the item.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getOrderedAvailHandlingQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _mustIncludeDelta,
        boolean      _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWOrderedAvailQty(_itemId, _inventDimCriteria, _mustIncludeDelta, _isWork);
        }

        return whsInventOnHand::getOrderedAvailQty(_itemId, _inventDimCriteria, _mustIncludeDelta, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderedAvailQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable ordered quantity of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The reservable ordered quantity of the item.
    /// </returns>
    public static InventQty getOrderedAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _mustIncludeDelta = true,
        boolean      _isWork = false)
    {
        InventQty               maxOrderedAvail;
        CreatedTransactionId    ttsId;
        if (_isWork && !_inventDimCriteria.wmsLocationId)
        {
            // If this on hand check was passed a check for WHS work
            // that doesn't have a location, no check is performed
            maxOrderedAvail = realMax();
        }
        else
        {
            ttsbegin;

            if (_mustIncludeDelta)
            {
                ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

                // Perform an initial check to make absolutely sure a delta
                // record actually exists for this item.  Much more expensive operation if a
                // delta record exists
                if (WHSInventReserveDelta::existTtsIdItemId(ttsId, _itemId))
                {
                    maxOrderedAvail = whsInventOnHand::getReserveOrderedAvailQtyWithDelta(_itemId,
                                                                                          _inventDimCriteria,
                                                                                          ttsId,
                                                                                          _isWork);
                }
                else
                {
                    maxOrderedAvail = whsInventOnHand::getReserveOrderedAvailQty(_itemId, _inventDimCriteria, _isWork);
                }
            }
            else
            {
                maxOrderedAvail = whsInventOnHand::getReserveOrderedAvailQty(_itemId, _inventDimCriteria, _isWork);
            }

            ttscommit;
        }

        return maxOrderedAvail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWOrderedAvailQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWOrderedAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _mustIncludeDelta,
        boolean      _isWork)
    {
        InventQty               maxOrderedAvail;
        if (_isWork && !_inventDimCriteria.wmsLocationId)
        {
            // If this on hand check was passed a check for WHS work
            // that doesn't have a location, no check is performed
            maxOrderedAvail = realMax();
        }
        else
        {
            ttsbegin;            
        
            boolean doIncludeDelta = false;
            CreatedTransactionId ttsId;

            if (_mustIncludeDelta)
            {
                ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

                // Perform an initial check to make absolutely sure a delta
                // record actually exists for this item.  Much more expensive operation if a delta record exists
                doIncludeDelta = WHSInventReserveDelta::existTtsIdItemId(ttsId, _itemId);                
            }
            
            if (doIncludeDelta)
            {
                maxOrderedAvail = whsInventOnHand::getCWReserveOrderedAvailQtyWithDelta(_itemId, _inventDimCriteria, ttsId, _isWork);
            }                                                                                                                                                          
            else
            {
                maxOrderedAvail = whsInventOnHand::getCWReserveOrderedAvailQty(_itemId, _inventDimCriteria, _isWork);
            }            

            ttscommit;
        }

        return maxOrderedAvail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalAvailHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available onhand quantity in the handling unit of the an item with certain dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The physically available onhand quantity in the handling unit of the item.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getPhysicalAvailHandlingQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _mustIncludeDelta,
        boolean      _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWPhysicalAvailQty(_itemId, _inventDimCriteria, _mustIncludeDelta, _isWork);
        }

        return whsInventOnHand::getPhysicalAvailQty(_itemId, _inventDimCriteria, _mustIncludeDelta, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalAvailQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available onhand quantity of the an item with certain dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included or not.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The physically available onhand quantity of the item.
    /// </returns>
    public static InventQty getPhysicalAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _mustIncludeDelta = true,
        boolean      _isWork = false)
    {
        InventQty               maxPhysicalAvail;
        CreatedTransactionId    ttsId;

        if (_isWork && !_inventDimCriteria.wmsLocationId)
        {
            // If this on hand check was passed a check for WHS work
            // that doesn't have a location, no check is performed
            maxPhysicalAvail = realMax();
        }
        else
        {
            ttsbegin;

            if (_mustIncludeDelta)
            {
                ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

                // Perform an initial check to make absolutely sure a delta
                // record actually exists for this item.  Much more expensive operation if a
                // delta record exists
                if (WHSInventReserveDelta::existTtsIdItemId(ttsId, _itemId))
                {
                    maxPhysicalAvail = whsInventOnHand::getReservePhysicalAvailQtyWithDelta(_itemId,
                                                                                            _inventDimCriteria,
                                                                                            ttsId,
                                                                                            _isWork);
                }
                else
                {
                    maxPhysicalAvail = whsInventOnHand::getReservePhysicalAvailQty(_itemId, _inventDimCriteria, _isWork);
                }
            }
            else
            {
                maxPhysicalAvail = whsInventOnHand::getReservePhysicalAvailQty(_itemId, _inventDimCriteria, _isWork);
            }

            ttscommit;
        }

        return maxPhysicalAvail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWPhysicalAvailQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWPhysicalAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _mustIncludeDelta,
        boolean      _isWork)
    {
        PdsCWInventQty maxPhysicalAvail;
        
        if (_isWork && !_inventDimCriteria.wmsLocationId)
        {
            // If this on hand check was passed a check for WHS work
            // that doesn't have a location, no check is performed
            maxPhysicalAvail = realMax();
        }
        else
        {
            ttsbegin;

            boolean doIncludeDelta = false;
            CreatedTransactionId ttsId;
            if (_mustIncludeDelta)
            {
                ttsId = InventUpdateOnhandGlobal::Instance().inventUpdateOnhand().ttsId();

                // Perform an initial check to make absolutely sure a delta
                // record actually exists for this item.  Much more expensive operation if a
                // delta record exists
                doIncludeDelta = WHSInventReserveDelta::existTtsIdItemId(ttsId, _itemId);
            }

            if (doIncludeDelta)
            {
                maxPhysicalAvail = whsInventOnHand::getCWReservePhysicalAvailQtyWithDelta(_itemId, _inventDimCriteria, ttsId, _isWork);
            }                                                                                            
            else
            {
                maxPhysicalAvail = whsInventOnHand::getCWReservePhysicalAvailQty(_itemId, _inventDimCriteria, _isWork, #ITEMHIERARCHYLEVEL);
            }

            ttscommit;
        }

        return maxPhysicalAvail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveAvailQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical available quantity and ordered available quantity of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    /// The upper most hierarchy level to be considered for calculating the onhand; optional, by default the calculation includes all levels up the hierarchy.
    /// </param>
    /// <returns>
    /// Container containing physical available quantity and ordered available quantity of the item.
    /// </returns>
    public static container getReserveAvailQty(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        boolean                         _isWork,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        
        var result = whsInventOnHand::getAllReserveAvailQuantities(_itemId, _inventDimCriteria, _isWork, _upperLevelOfMinimumCalculation);

        return [result.AvailPhysical, result.AvailOrdered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWReservePhysicalAvailQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWReservePhysicalAvailQty(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        boolean                         _isWork,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation)
    {
        
        var result = whsInventOnHand::getAllReserveAvailQuantities(_itemId, _inventDimCriteria, _isWork, _upperLevelOfMinimumCalculation);

        return result.CWAvailPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWReserveOrderedAvailQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWReserveOrderedAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _isWork)
    {
        var result = whsInventOnHand::getAllReserveAvailQuantities(_itemId, _inventDimCriteria, _isWork, #ITEMHIERARCHYLEVEL);

        return result.CWAvailOrdered;    
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllReserveAvailQuantities</Name>
				<Source><![CDATA[
    private static WHSInventReserveQuantities getAllReserveAvailQuantities(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        boolean                         _isWork,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation)
    {
        InventTable inventTable;

        InventTable getInventTable()
        {
            if (!inventTable)
            {
                inventTable = InventTable::find(_itemId);
            }

            return inventTable;
        }

        ttsbegin;

        WHSReservationHierarchyLevel upperHierarchyLevel = _upperLevelOfMinimumCalculation;
        if (_isWork)
        {
            upperHierarchyLevel = max(WHSReservationHierarchyProvider::construct().getLocationHierarchyLevel(getInventTable()), upperHierarchyLevel);
        }

        InventDimId inventDimIdSearch = _inventDimCriteria.inventDimId;
        if (!inventDimIdSearch)
        {
            inventDimIdSearch = InventDim::findDim(_inventDimCriteria).InventDimId;
        }

        WHSInventReserve inventReserve;

        boolean                    reserveAvailQuantitiesStoredProceduresFlightEnabled = WHSReserveAvailQuantitiesStoredProceduresV2Flight::instance().isEnabled();
        WHSOnHandSPHelper          onHandSPHelper;
        WHSInventReserveQuantities quantities;

        if (reserveAvailQuantitiesStoredProceduresFlightEnabled)
        {
            onHandSPHelper = WHSOnHandSPHelper::construct();

            quantities = onHandSPHelper.calculateInventReserveMinValuesForDimId(
                _itemId,
                upperHierarchyLevel,
                inventDimIdSearch,
                true,
                false,
                0);

            if (quantities)
            {
                ttscommit;

                return quantities;
            }
            // otherwise, the inventReserve should be empty because the record was not found
        }
        else
        {
            inventReserve = WHSInventReserve::find(_itemId, inventDimIdSearch);
        }

        InventQty availPhysical = inventReserve.AvailPhysical;
        InventQty availOrdered = inventReserve.AvailOrdered;
        PdsCWInventQty cwAvailPhysical = inventReserve.CWAvailPhysical;
        PdsCWInventQty cwAvailOrdered = inventReserve.CWAvailOrdered;

        if (!inventReserve.RecId)
        {
            // Traverse the reservation hierarchy up until find the first inventory dimension present in WHSInventReserve.
            WHSReservationHierarchyInventDimEnumerator hierarchyInventDimEnumerator = new WHSReservationHierarchyInventDimEnumerator(getInventTable(), _inventDimCriteria, upperHierarchyLevel);
            while (hierarchyInventDimEnumerator.moveNext())
            {
                inventDimIdSearch = hierarchyInventDimEnumerator.current().InventDimId;
                inventReserve = WHSInventReserve::find(_itemId, inventDimIdSearch);

                if (inventReserve.RecId)
                {
                    availPhysical = min(availPhysical, inventReserve.AvailPhysical);
                    availOrdered = min(availOrdered, inventReserve.AvailOrdered);
                    cwAvailPhysical = min(cwAvailPhysical, inventReserve.CWAvailPhysical);
                    cwAvailOrdered = min(cwAvailOrdered, inventReserve.CWAvailOrdered);
                    break;
                }
            }
        }

        if (inventReserve.RecId && inventReserve.ParentInventDimId)
        {
            if (reserveAvailQuantitiesStoredProceduresFlightEnabled)
            {
                quantities = onHandSPHelper.calculateInventReserveMinValuesForDimId(
                    _itemId,
                    upperHierarchyLevel,
                    inventReserve.ParentInventDimId,
                    false,
                    false,
                    0);

                if (quantities)
                {
                    quantities.AvailPhysical   = min(quantities.AvailPhysical,   availPhysical);
                    quantities.AvailOrdered    = min(quantities.AvailOrdered,    availOrdered);
                    quantities.CWAvailPhysical = min(quantities.CWAvailPhysical, cwAvailPhysical);
                    quantities.CWAvailOrdered  = min(quantities.CWAvailOrdered,  cwAvailOrdered);
                }
            }
            else
            {
                // We have found a specific WHSInventReserve record. Now we can traverse WHSInventReserve hierarchy.
                do
                {
                    inventReserve = WHSInventReserve::find(_itemId, inventReserve.ParentInventDimId);

                    if (inventReserve.HierarchyLevel < upperHierarchyLevel)
                    {
                        break;
                    }

                    if (inventReserve.RecId)
                    {
                        availPhysical = min(availPhysical, inventReserve.AvailPhysical);
                        availOrdered = min(availOrdered, inventReserve.AvailOrdered);
                        cwAvailPhysical = min(cwAvailPhysical, inventReserve.CWAvailPhysical);
                        cwAvailOrdered = min(cwAvailOrdered, inventReserve.CWAvailOrdered);
                    }
                }
                while (inventReserve.ParentInventDimId);
            }
        }

        ttscommit;

        if (quantities)
        {
            return quantities;
        }

        return WHSInventReserveQuantities::newAvailQuantities(availPhysical, availOrdered, cwAvailPhysical, cwAvailOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveAvailHandlingQtyIncludeDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container with the quantity in the handling unit that is physical available and the total quantity that is available for reservation. The quantities include the contribution from <c>WHSInventReserveDelta</c> records.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_ttsId">
    /// The transaction id which is used to search for <c>WHSInventReserveDelta</c> records.
    /// </param>
    /// <param name="_isWork">
    /// A boolean flag determining if the calculation should be done for work.
    /// </param>
    /// <param name="_checkReservationHierarchyHoles">
    /// A boolean flag indicating whether a check for reservation hierarchy holes should be performed.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    /// The upper most hierarchy level to be considered for calculating the onhand; optional, by default the calculation includes all levels up the hierarchy.
    /// </param>
    /// <returns>
    /// A container with the quantity in the handling unit that is physical available and the total quantity that is available for reservation.
    /// </returns>
    [Hookable(false)]
    internal static container getReserveAvailHandlingQtyIncludeDelta(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        CreatedTransactionId            _ttsId,
        boolean                         _isWork,
        boolean                         _checkReservationHierarchyHoles,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation = #ITEMHIERARCHYLEVEL)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWReserveAvailQtyIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, _checkReservationHierarchyHoles, _upperLevelOfMinimumCalculation);    
        }

        return whsInventOnHand::getReserveAvailQtyIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, _checkReservationHierarchyHoles, false, null, _upperLevelOfMinimumCalculation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveAvailQtyIncludeDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a container with the quantity that is physical available and the total quantity that is available for reservation. The quantities include the contribution from <c>WHSInventReserveDelta</c> records.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID to determine availability for.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimensions to determine availability for.
    /// </param>
    /// <param name="_ttsId">
    /// The transaction id which is used to search for <c>WHSInventReserveDelta</c> records.
    /// </param>
    /// <param name="_isWork">
    /// A boolean flag determining if the calculation should be done for work.
    /// </param>
    /// <param name="_checkReservationHierarchyHoles">
    /// A boolean flag indicating whether a check for reservation hierarchy holes should be performed.
    /// </param>
    /// <param name="_useInventDimParmLocationAndAbove">
    /// A boolean flag determining if the <param name="_inventDimParmLocationAndAbove"/> buffer should be used. This parameter is optional.
    /// This parameter is not used anymore and will be removed in future releases.
    /// </param>
    /// <param name="_inventDimParmLocationAndAbove">
    /// An <c>InventDimParm</c> buffer with the dimensions of location and above set based on the item. This parameter can be passed for performance optimizations. This parameter is optional.
    /// This parameter is not used anymore and will be removed in future releases.
    /// </param>
    /// <param name="_upperLevelOfMinimumCalculation">
    /// The upper most hierarchy level to be considered for calculating the onhand; optional, by default the calculation includes all levels up the hierarchy.
    /// </param>
    /// <returns>
    /// A container with the quantity that is physical available and the total quantity that is available for reservation.
    /// </returns>
    public static container getReserveAvailQtyIncludeDelta(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        CreatedTransactionId            _ttsId,
        boolean                         _isWork,
        boolean                         _checkReservationHierarchyHoles,
        boolean                         _useInventDimParmLocationAndAbove  = false, // not used anymore.
        InventDimParm                   _inventDimParmLocationAndAbove     = null,  // not used anymore.
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation    = #ITEMHIERARCHYLEVEL)
    {
        WHSInventReserveQuantities quantities = whsInventOnHand::getReserveAvailQuantitiesIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, _checkReservationHierarchyHoles, _upperLevelOfMinimumCalculation);
        
        return [quantities.AvailPhysical, quantities.AvailOrdered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWReserveAvailQtyIncludeDelta</Name>
				<Source><![CDATA[
    private static container getCWReserveAvailQtyIncludeDelta(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        CreatedTransactionId            _ttsId,
        boolean                         _isWork,
        boolean                         _checkReservationHierarchyHoles,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation    = #ITEMHIERARCHYLEVEL)
    {
        WHSInventReserveQuantities quantities = whsInventOnHand::getReserveAvailQuantitiesIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, _checkReservationHierarchyHoles, _upperLevelOfMinimumCalculation);
        
        return [quantities.CWAvailPhysical, quantities.CWAvailOrdered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveAvailQuantitiesIncludeDelta</Name>
				<Source><![CDATA[
    private static WHSInventReserveQuantities getReserveAvailQuantitiesIncludeDelta(
        ItemId                          _itemId,
        InventDim                       _inventDimCriteria,
        CreatedTransactionId            _ttsId,
        boolean                         _isWork,
        boolean                         _checkReservationHierarchyHoles,
        WHSReservationHierarchyLevel    _upperLevelOfMinimumCalculation)
    {
        InventTable inventTable;

        InventTable getInventTable()
        {
            if (!inventTable)
            {
                inventTable = InventTable::find(_itemId);
            }

            return inventTable;
        }

        InventDimId getParentInventDimId(WHSInventReserve _inventReserve, WHSInventReserveDelta _inventReserveDelta)
        {
            if (_inventReserve)
            {
                return _inventReserve.ParentInventDimId;
            }

            if (_inventReserveDelta)
            {
                return _inventReserveDelta.ParentInventDimId;
            }

            return '';
        }

        // Calculate upper level of reservation hierarchy to look at. When call this method for work, upper level is Location by default.
        WHSReservationHierarchyLevel upperHierarchyLevel = _upperLevelOfMinimumCalculation;
        if (_isWork)
        {
            upperHierarchyLevel = max(WHSReservationHierarchyProvider::construct().getLocationHierarchyLevel(getInventTable()), upperHierarchyLevel);
        }

        InventDimId inventDimIdSearch = _inventDimCriteria.inventDimId ? _inventDimCriteria.inventDimId : InventDim::findDim(_inventDimCriteria).InventDimId;
        WHSInventReserve inventReserve;
        WHSInventReserveDelta inventReserveDelta;
        
        boolean reserveAvailQuantitiesStoredProceduresFlightEnabled = WHSReserveAvailQuantitiesStoredProceduresV2Flight::instance().isEnabled();
        WHSOnHandSPHelper onHandSPHelper;

        if (reserveAvailQuantitiesStoredProceduresFlightEnabled)
        {
            onHandSPHelper = WHSOnHandSPHelper::construct();

            WHSInventReserveQuantities quantities = onHandSPHelper.calculateInventReserveMinValuesForDimId(
                _itemId,
                upperHierarchyLevel,
                inventDimIdSearch,
                true,
                true,
                _ttsId);

            if (quantities)
            {
                return quantities;
            }
        }
        else
        {
            inventReserve = WHSInventReserve::find(_itemId, inventDimIdSearch);
            inventReserveDelta = WHSInventReserveDelta::sumReserveDeltaByDimId(_itemId, inventDimIdSearch);
        }

        WHSInventOnHandRollingMinimum availPhysicalRollingMinimum = new WHSInventOnHandRollingMinimum();
        WHSInventOnHandRollingMinimum availOrderedRollingMinimum = new WHSInventOnHandRollingMinimum();

        WHSInventOnHandRollingMinimum cwAvailPhysicalRollingMinimum = new WHSInventOnHandRollingMinimum();
        WHSInventOnHandRollingMinimum cwAvailOrderedRollingMinimum = new WHSInventOnHandRollingMinimum();

        if (inventReserve || inventReserveDelta)
        {
            availPhysicalRollingMinimum.addValue(inventReserve.AvailPhysical + inventReserveDelta.AvailPhysical);
            availOrderedRollingMinimum.addValue(inventReserve.AvailOrdered + inventReserveDelta.AvailOrdered);
            cwAvailPhysicalRollingMinimum.addValue(inventReserve.CWAvailPhysical + inventReserveDelta.CWAvailPhysical);
            cwAvailOrderedRollingMinimum.addValue(inventReserve.CWAvailOrdered + inventReserveDelta.CWAvailOrdered);
        }
        else
        {
            if (_checkReservationHierarchyHoles)
            {
                // We did not find WHSInventReserve and WHSInventReserveDelta. If we check for reservation hierarchy holes, we need to count that as 0.
                availPhysicalRollingMinimum.addValue(0);
                availOrderedRollingMinimum.addValue(0);
                cwAvailPhysicalRollingMinimum.addValue(0);
                cwAvailOrderedRollingMinimum.addValue(0);
            }

            // Traverse the reservation hierarchy up until find the first inventory dimension present in WHSInventReserve.
            WHSReservationHierarchyInventDimEnumerator hierarchyInventDimEnumerator = new WHSReservationHierarchyInventDimEnumerator(getInventTable(), _inventDimCriteria, upperHierarchyLevel);
            while (hierarchyInventDimEnumerator.moveNext())
            {
                inventDimIdSearch = hierarchyInventDimEnumerator.current().InventDimId;

                inventReserve = WHSInventReserve::find(_itemId, inventDimIdSearch);
                inventReserveDelta = WHSInventReserveDelta::sumReserveDeltaByDimId(_itemId, inventDimIdSearch);

                if (inventReserve || inventReserveDelta)
                {
                    // can safely sum here - even if only one record has data, that level should be taken into account.
                    availPhysicalRollingMinimum.addValue(inventReserve.AvailPhysical + inventReserveDelta.AvailPhysical);
                    availOrderedRollingMinimum.addValue(inventReserve.AvailOrdered + inventReserveDelta.AvailOrdered);
                    cwAvailPhysicalRollingMinimum.addValue(inventReserve.CWAvailPhysical + inventReserveDelta.CWAvailPhysical);
                    cwAvailOrderedRollingMinimum.addValue(inventReserve.CWAvailOrdered + inventReserveDelta.CWAvailOrdered);

                    break;
                }
            }
        }

        InventDimId parentInventDimId = getParentInventDimId(inventReserve, inventReserveDelta);

        if (reserveAvailQuantitiesStoredProceduresFlightEnabled)
        {
            if (parentInventDimId)
            {
                WHSInventReserveQuantities quantities = onHandSPHelper.calculateInventReserveMinValuesForDimId(
                    _itemId,
                    upperHierarchyLevel,
                    parentInventDimId,
                    false,
                    true,
                    _ttsId);

                if (quantities)
                {
                    quantities.AvailPhysical   = min(quantities.AvailPhysical, availPhysicalRollingMinimum.minValue());
                    quantities.AvailOrdered    = min(quantities.AvailOrdered, availOrderedRollingMinimum.minValue());
                    quantities.CWAvailPhysical = min(quantities.CWAvailPhysical, cwAvailPhysicalRollingMinimum.minValue());
                    quantities.CWAvailOrdered  = min(quantities.CWAvailOrdered, cwAvailOrderedRollingMinimum.minValue());

                    return quantities;
                }
            }
        }
        else
        {
            while (parentInventDimId)
            {
                // We have found a specific WHSInventReserve or WHSInventReserveDelta record. Now we can traverse reservation hierarchy by using ParentInventDimId value.
                inventReserve = WHSInventReserve::find(_itemId, parentInventDimId);
                if (inventReserve && inventReserve.HierarchyLevel < upperHierarchyLevel)
                {
                    break;
                }

                inventReserveDelta = WHSInventReserveDelta::sumReserveDeltaByDimId(_itemId, parentInventDimId);
                if (inventReserveDelta && inventReserveDelta.HierarchyLevel < upperHierarchyLevel)
                {
                    break;
                }

                if (inventReserve || inventReserveDelta)
                {
                    availPhysicalRollingMinimum.addValue(inventReserve.AvailPhysical + inventReserveDelta.AvailPhysical);
                    availOrderedRollingMinimum.addValue(inventReserve.AvailOrdered + inventReserveDelta.AvailOrdered);
                    cwAvailPhysicalRollingMinimum.addValue(inventReserve.CWAvailPhysical + inventReserveDelta.CWAvailPhysical);
                    cwAvailOrderedRollingMinimum.addValue(inventReserve.CWAvailOrdered + inventReserveDelta.CWAvailOrdered);
                }
            
                parentInventDimId = getParentInventDimId(inventReserve, inventReserveDelta);
            }
        }

        return WHSInventReserveQuantities::newAvailQuantities(availPhysicalRollingMinimum.minValue(), availOrderedRollingMinimum.minValue(), cwAvailPhysicalRollingMinimum.minValue(), cwAvailOrderedRollingMinimum.minValue());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveOrderedAvailHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable ordered quantity in the handling unit of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The reservable ordered quantity in the handling unit of the item.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getReserveOrderedAvailHandlingQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWReserveOrderedAvailQty(_itemId, _inventDimCriteria, _isWork);
        }

        return whsInventOnHand::getReserveOrderedAvailQty(_itemId, _inventDimCriteria, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveOrderedAvailQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable ordered quantity of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The reservable ordered quantity of the item.
    /// </returns>
    public static InventQty getReserveOrderedAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _isWork)
    {
        return conPeek(whsInventOnHand::getReserveAvailQty(_itemId, _inventDimCriteria, _isWork), #ConPosOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveOrderedAvailHandlingQtyWithDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable ordered quantity in the handling unit of an item with given dimensions. The quantity includes the contribution from <c>WHSInventReserveDelta</c> records.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_ttsId">
    /// Created transaction id.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The reservable ordered quantity in the handling unit of the item including the contribution from delta records.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getReserveOrderedAvailHandlingQtyWithDelta(
        ItemId                  _itemId,
        InventDim               _inventDimCriteria,
        CreatedTransactionId    _ttsId,
        boolean                 _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWReserveOrderedAvailQtyWithDelta(_itemId, _inventDimCriteria, _ttsId, _isWork);
        }

        return whsInventOnHand::getReserveOrderedAvailQtyWithDelta(_itemId, _inventDimCriteria, _ttsId, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveOrderedAvailQtyWithDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable ordered quantity of an item with given dimensions. The quantity includes the contribution from <c>WHSInventReserveDelta</c> records.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_ttsId">
    /// Created transaction id.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The reservable ordered quantity of the item including the contribution from delta records.
    /// </returns>
    public static InventQty getReserveOrderedAvailQtyWithDelta(
        ItemId               _itemId,
        InventDim            _inventDimCriteria,
        CreatedTransactionId _ttsId,
        boolean              _isWork)
    {
        return conPeek(whsInventOnHand::getReserveAvailQtyIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, true), #ConPosOrdered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWReserveOrderedAvailQtyWithDelta</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWReserveOrderedAvailQtyWithDelta(
        ItemId               _itemId,
        InventDim            _inventDimCriteria,
        CreatedTransactionId _ttsId,
        boolean              _isWork)
    {
        WHSInventReserveQuantities quantities = whsInventOnHand::getReserveAvailQuantitiesIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, true, #ITEMHIERARCHYLEVEL);

        return quantities.CWAvailOrdered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReservePhysicalAvailHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity in the handling unit of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The physically available quantity in the handling unit of the item.
    /// </returns>
    [Hookable(false)]
    internal static InventQty getReservePhysicalAvailHandlingQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWReservePhysicalAvailQty(_itemId, _inventDimCriteria, _isWork, #ITEMHIERARCHYLEVEL);
        }

        return whsInventOnHand::getReservePhysicalAvailQty(_itemId, _inventDimCriteria, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReservePhysicalAvailQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity of an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The physically available quantity of the item.
    /// </returns>
    public static InventQty getReservePhysicalAvailQty(
        ItemId       _itemId,
        InventDim    _inventDimCriteria,
        boolean      _isWork)
    {
        return conPeek(whsInventOnHand::getReserveAvailQty(_itemId, _inventDimCriteria, _isWork), #ConPosPhysical);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReservePhysicalAvailHandlingQtyWithDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity in the handling unit of an item with given dimensions.
    /// The quantity includes the contribution from <c>WHSInventReserveDelta</c> records.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_ttsId">
    /// Created transaction id.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The physically available quantity in the handling unit of the item including the contribution from delta records.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getReservePhysicalAvailHandlingQtyWithDelta(
        ItemId               _itemId,
        InventDim            _inventDimCriteria,
        CreatedTransactionId _ttsId,
        boolean              _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWReservePhysicalAvailQtyWithDelta(_itemId, _inventDimCriteria, _ttsId, _isWork);
        }

        return whsInventOnHand::getReservePhysicalAvailQtyWithDelta(_itemId, _inventDimCriteria, _ttsId, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReservePhysicalAvailQtyWithDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity of an item with given dimensions. The quantity includes the contribution from <c>WHSInventReserveDelta</c> records.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the query.
    /// </param>
    /// <param name="_ttsId">
    /// Created transaction id.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is for WHS work or not.
    /// </param>
    /// <returns>
    /// The physically available quantity of the item including the contribution from delta records.
    /// </returns>
    public static InventQty getReservePhysicalAvailQtyWithDelta(
        ItemId               _itemId,
        InventDim            _inventDimCriteria,
        CreatedTransactionId _ttsId,
        boolean              _isWork)
    {
        return conPeek(whsInventOnHand::getReserveAvailQtyIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, true), #ConPosPhysical);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWReservePhysicalAvailQtyWithDelta</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWReservePhysicalAvailQtyWithDelta(
        ItemId               _itemId,
        InventDim            _inventDimCriteria,
        CreatedTransactionId _ttsId,
        boolean              _isWork)
    {
        WHSInventReserveQuantities quantities = whsInventOnHand::getReserveAvailQuantitiesIncludeDelta(_itemId, _inventDimCriteria, _ttsId, _isWork, true, #ITEMHIERARCHYLEVEL);
        
        return quantities.CWAvailPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable quantity for an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_reserveOnOrdered">
    /// Determines whether the reservation is done on ordered quantities or physically available quantities.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is from WHS work.
    /// </param>
    /// <returns>
    /// The reservable quantity for an item.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getReserveHandlingQty(
        ItemId         _itemId,
        InventDim      _inventDimCriteria,
        boolean        _reserveOnOrdered,
        boolean        _mustIncludeDelta,
        boolean        _isWork)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWReserveQty(_itemId, _inventDimCriteria, _reserveOnOrdered, _mustIncludeDelta, _isWork);
        }

        return whsInventOnHand::getReserveQty(_itemId, _inventDimCriteria, _reserveOnOrdered, _mustIncludeDelta, _isWork);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReserveQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the reservable quantity for an item with given dimensions.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// Dimension criteria for the onhand query.
    /// </param>
    /// <param name="_reserveOnOrdered">
    /// Determines whether the reservation is done on ordered quantities or physically available quantities.
    /// </param>
    /// <param name="_mustIncludeDelta">
    /// Determines whether delta records must be included.
    /// </param>
    /// <param name="_isWork">
    /// Determines whether the onhand inquiry is from WHS work.
    /// </param>
    /// <returns>
    /// The reservable quantity for an item.
    /// </returns>
    public static InventQty getReserveQty(
        ItemId         _itemId,
        InventDim      _inventDimCriteria,
        boolean        _reserveOnOrdered,
        boolean        _mustIncludeDelta = true,
        boolean        _isWork = false)
    {
        InventQty           qty;

        if (_reserveOnOrdered)
        {
            qty = whsInventOnHand::getOrderedAvailHandlingQty(_itemId,
															  _inventDimCriteria,
															  _mustIncludeDelta,
															  _isWork);
        }
        else
        {
            qty = whsInventOnHand::getPhysicalAvailQty(_itemId,
                                                       _inventDimCriteria,
                                                       _mustIncludeDelta,
                                                       _isWork);
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWReserveQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWReserveQty(
        ItemId         _itemId,
        InventDim      _inventDimCriteria,
        boolean        _reserveOnOrdered,
        boolean        _mustIncludeDelta,
        boolean        _isWork)
    {
        InventQty           qty;

        if (_reserveOnOrdered)
        {
            qty = whsInventOnHand::getCWOrderedAvailQty(_itemId,
                                                      _inventDimCriteria,
                                                      _mustIncludeDelta,
                                                      _isWork);
        }
        else
        {
            qty = whsInventOnHand::getCWPhysicalAvailQty(_itemId,
                                                       _inventDimCriteria,
                                                       _mustIncludeDelta,
                                                       _isWork);
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalAvailHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity in the handling unit for an item with given dimensions. This inquiry is for WHS work.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimId">
    /// Id of the dimension for onhand query.
    /// </param>
    /// <param name="_useRealMax">
    /// Determines whether to use real max value or not.
    /// </param>
    /// <returns>
    /// The physically available quantity in the handling unit for the item.
    /// </returns>
    /// <remarks>
    /// It returns real max value if it is allowed to have negative quantity on the item.
    /// </remarks>
    [Hookable(false)]
    internal static InventHandlingQty getWorkPhysicalAvailHandlingQty(
        ItemId      _itemId,
        InventDimId _inventDimId,
        boolean     _useRealMax)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWWorkPhysicalAvail(_itemId, _inventDimId, _useRealMax);
        }

        return whsInventOnHand::getWorkPhysicalAvail(_itemId, _inventDimId, _useRealMax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalAvail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity of an item with given dimensions. This inquiry is for WHS work.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimId">
    /// Id of the dimension for onhand query.
    /// </param>
    /// <param name="_useRealMax">
    /// Determines whether to use real max value or not.
    /// </param>
    /// <returns>
    /// The physically available quantity for the item.
    /// </returns>
    /// <remarks>
    /// It returns real max value if it is allowed to have negative quantity on the item.
    /// </remarks>
    public static InventQty getWorkPhysicalAvail(
        ItemId      _itemId,
        InventDimId _inventDimId,
        boolean     _useRealMax = true)
    {
        return whsInventOnHand::getWorkPhysicalAvailByInventDim(_itemId, InventDim::find(_inventDimId), _useRealMax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWWorkPhysicalAvail</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWWorkPhysicalAvail(
        ItemId      _itemId,
        InventDimId _inventDimId,
        boolean     _useRealMax = true)
    {
        return whsInventONHand::getCWWorkPhysicalAvailQtyByInventDim(_itemId, InventDim::find(_inventDimId), _useRealMax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalAvailHandlingQtyByInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity in the handling unit for an item with given dimensions. This inquiry is for WHS work.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDim">
    /// The dimension for onhand query.
    /// </param>
    /// <param name="_useRealMax">
    /// Determines whether to use real max value or not.
    /// </param>
    /// <returns>
    /// The physically available quantity in the handling unit for the item.
    /// </returns>
    /// <remarks>
    /// It returns real max value if it is allowed to have negative quantity on the item.
    /// If _inventDim.InventDimId is blank, the dimension record will be created if required.
    /// </remarks>
    [Hookable(false)]
    public static InventHandlingQty getWorkPhysicalAvailHandlingQtyByInventDim(
        ItemId      _itemId,
        InventDim   _inventDim,
        boolean     _useRealMax)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWWorkPhysicalAvailQtyByInventDim(_itemId, _inventDim, _useRealMax);
        }

        return whsInventOnHand::getWorkPhysicalAvailByInventDim(_itemId, _inventDim, _useRealMax);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalAvailByInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physically available quantity of an item with given dimensions. This inquiry is for WHS work.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDim">
    /// The dimension for onhand query.
    /// </param>
    /// <param name="_useRealMax">
    /// Determines whether to use real max value or not.
    /// </param>
    /// <returns>
    /// The physically available quantity for the item.
    /// </returns>
    /// <remarks>
    /// It returns real max value if it is allowed to have negative quantity on the item.
    /// If _inventDim.InventDimId is blank, the dimension record will be created if required.
    /// </remarks>
    public static InventQty getWorkPhysicalAvailByInventDim(
        ItemId      _itemId,
        InventDim   _inventDim,
        boolean     _useRealMax = true)
    {
        return whsInventOnhand::getWorkPhysicalQtyByInventDim(_itemId, _inventDim, _useRealMax, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWWorkPhysicalAvailQtyByInventDim</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWWorkPhysicalAvailQtyByInventDim(
        ItemId      _itemId,
        InventDim   _inventDim,
        boolean     _useRealMax)
    {
        return whsInventOnhand::getWorkPhysicalQtyByInventDim(_itemId, _inventDim, _useRealMax, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalQtyByInventDim</Name>
				<Source><![CDATA[
    private static InventHandlingQty getWorkPhysicalQtyByInventDim(
        ItemId      _itemId,
        InventDim   _inventDim,
        boolean     _useRealMax,
        boolean     _returnCWQty)
    {
        real ret;        

        if (_useRealMax && InventTable::find(_itemId).modelGroup().NegativePhysical)
        {
            ret = realMax();
        }
        else 
        {
            boolean includeDeltaRecords = WHSInventOnHandMustAddInventSumDeltaOnhandFlight::instance().isEnabled() ? InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_itemId) : true;

            if (_returnCWQty)
            {
                ret = whsInventOnhand::getCWPhysicalAvailQty(_itemId, _inventDim, includeDeltaRecords, true);
            }
            else
            {
                ret = whsInventOnHand::getPhysicalAvailQty(_itemId, _inventDim, includeDeltaRecords, true);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalInventHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory quantity in the handling unit for an item using <c>physicalInvent</c> or <c>pdsCWPhysicalInvent</c>
    /// methods of <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimId">
    /// Id of the inventory dimensions.
    /// </param>
    /// <returns>
    /// The physical inventory quantity in the handling unit for the item.
    /// </returns>
    public static InventHandlingQty getWorkPhysicalInventHandlingQty(
        ItemId         _itemId,
        InventDimId    _inventDimId)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::getCWWorkPhysicalInventQty(_itemId, _inventDimId);
        }

        return whsInventOnHand::getWorkPhysicalInvent(_itemId, _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalInvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory quantity for an item using <c>physicalInvent</c> method of <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimId">
    /// Id of the inventory dimensions.
    /// </param>
    /// <returns>
    /// The physical inventory quantity of the item.
    /// </returns>
    public static InventQty getWorkPhysicalInvent(
        ItemId         _itemId,
        InventDimId    _inventDimId)
    {
        return whsInventOnHand::getWorkPhysicalInventByInventDim(_itemId, InventDim::find(_inventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWWorkPhysicalInventQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWWorkPhysicalInventQty(
        ItemId         _itemId,
        InventDimId    _inventDimId)
    {
        return whsInventOnHand::getCWWorkPhysicalInventQtyByInventDim(_itemId, InventDim::find(_inventDimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalInventHandlingQtyByInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory quantity in the handling unit for an item using <c>physicalInvent</c> or <c>pdsCWPhysicalInvent</c>
    /// methods of <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions. InventDimID can be blank.
    /// </param>
    /// <returns>
    /// The physical inventory quantity in the handling unit for the item.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty getWorkPhysicalInventHandlingQtyByInventDim(
        ItemId         _itemId,
        InventDim      _inventDim)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnhand::getCWWorkPhysicalInventQtyByInventDim(_itemId, _inventDim);
        }

        return whsInventOnHand::getWorkPhysicalInventByInventDim(_itemId, _inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalInventByInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory quantity for an item using <c>physicalInvent</c> method of <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions. InventDimID can be blank.
    /// </param>
    /// <returns>
    /// The physical inventory quantity of the item.
    /// </returns>
    public static InventQty getWorkPhysicalInventByInventDim(
        ItemId         _itemId,
        InventDim      _inventDim)
    {
        return whsInventOnhand::getWorkPhysicalQuantityByInventDim(_itemId, _inventDim).parmInventQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCWWorkPhysicalInventQtyByInventDim</Name>
				<Source><![CDATA[
    private static PdsCWInventQty getCWWorkPhysicalInventQtyByInventDim(
        ItemId         _itemId,
        InventDim      _inventDim)
    {
        return whsInventOnhand::getWorkPhysicalQuantityByInventDim(_itemId, _inventDim).parmCwQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWorkPhysicalQuantityByInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory and catch weight quantity for an item using <c>physicalInvent</c> or <c>pdsCWPhysicalInvent</c> methods of the <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions. InventDimID can be blank.
    /// </param>
    /// <returns>
    /// An instance of a <c>PmfQtyDataCarrier</c> containing the physical inventory quantity and physical catch weight quantity for an item. The catch weight quantity
    /// will be zero for a non-catch weight item.
    /// </returns>
    [Hookable(false)]
    internal static PmfQtyDataCarrier getWorkPhysicalQuantityByInventDim(
        ItemId      _itemId,
        InventDim   _inventDim)
    {
        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(_inventDim);

        //If product dimensions are enabled by configuration key and the inventDim has all the product dimensions for the item filled then we are searching for an exact match on product dimensions.
        //By setting all the product dimension field flags we allow SQL to use the ProductDimIdx index which for many scenarios will be covering and lead to effective query plans
        List productDimList     = InventDimMetaDataCache::dimProductDimFieldList();
        InventDim inventDim     = _inventDim;

        if (!productDimList.empty())
        {
            InventDimGroupSetup inventDimGroupSetupProductDim = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId);
            InventDimParm       inventDimParmActiveProductDim;

            inventDimGroupSetupProductDim.inventDimParmActiveProductDimension(inventDimParmActiveProductDim);

            //we just compare using the full product dim list since we already have that list and it is faster iterating a few more times than getting the list of the enabled product dimensions for the item
            if (inventDim.allInventDimParmFieldsHaveValues(inventDimParmActiveProductDim, productDimList))
            {
                inventDimParm.setAllProductDimensions();
            }
        }

        InventOnhandQty inventOnHand = InventOnhandQty::newParameters(_itemId, inventDim, inventDimParm);
             
        //since we are looking for physical invent only we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
        inventOnhand.parmDelayAvailabilityCalculation(true);

        return PmfQtyDataCarrier::newStandard(inventOnHand.physicalInvent(), inventOnHand.pdsCWPhysicalInvent());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReserveDelta</Name>
				<Source><![CDATA[
    private static boolean insertReserveDelta(
        ItemId                      _itemId,
        WHSInventReserveQuantities  _quantities,
        InventDimId                 _inventDimId,
        CreatedTransactionId        _ttsId,
        boolean                     _onlyLocationAndBelow)
    {
        InventDim inventDim = InventDim::find(_inventDimId);

        boolean addedWarehouseInventoryTransactionToOnHand = false;

        if (inventDim.wmsLocationId || !_onlyLocationAndBelow)
        {
            RecordInsertList recordInsertList;

            WHSInventReserveDelta inventReserveDelta;
            inventReserveDelta.ItemId               = _itemId;
            inventReserveDelta.InventDimId          = _inventDimId;
            inventReserveDelta.addFromWHSInventReserveQuantities(_quantities);
            inventReserveDelta.IsItemCatchWeightEnabled = PdsGlobal::pdsIsCWItem(_itemId);
            inventReserveDelta.ttsId                = _ttsId;
                                    
            var levelsEnumerator = WHSInventReserveDeltaLevelsEnumerator::newFromDelta(inventReserveDelta, _onlyLocationAndBelow);
            
            List parentInventDimIds = whsInventOnHand::buildListOfParentInventDimIds(inventReserveDelta);
            ListEnumerator parentInventDimIdsEnumerator = parentInventDimIds.getEnumerator();


            while (levelsEnumerator.moveNext() && parentInventDimIdsEnumerator.moveNext())
            {
                inventDim = levelsEnumerator.currentInventDim();
                inventReserveDelta.InventDimId = inventDim.InventDimId;
                inventReserveDelta.HierarchyLevel = levelsEnumerator.currentHierarchyLevel();
                
                inventReserveDelta.ParentInventDimId = parentInventDimIdsEnumerator.current();
                inventReserveDelta.setInventDimFieldsFromInventDim(inventDim);
                
                if (WHSInventoryTranscationOnHandStackContext::current())
                {
                    WHSInventoryTranscationOnHandStackContext::current().addWHSInventReserveDelta(inventReserveDelta);
                    addedWarehouseInventoryTransactionToOnHand = true;
                }
                else
                {
                    const boolean skipDataMethods = true;
                    recordInsertList = recordInsertList ? recordInsertList : new RecordInsertList(tableNum(WHSInventReserveDelta), skipDataMethods, skipDataMethods, skipDataMethods);
                    recordInsertList.add(inventReserveDelta);
                }
                
                [inventReserveDelta.AvailPhysical, inventReserveDelta.AvailOrdered, inventReserveDelta.CWAvailPhysical, inventReserveDelta.CWAvailOrdered] = WhsInventOnHand::getUpperLevelDeltaAvailQuantities(inventReserveDelta, inventDim, levelsEnumerator.currentDimFieldId());
            }
            
            Debug::assert(levelsEnumerator.moveNext() == false);

            if (recordInsertList)
            {
                recordInsertList.insertDatabase();
                return true;
            }
        }

        return addedWarehouseInventoryTransactionToOnHand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildListOfParentInventDimIds</Name>
				<Source><![CDATA[
    private static List buildListOfParentInventDimIds(WHSInventReserveDelta _inventReserveDelta)
    {
        List parentInventDimIds = new List(Types::String);

        var levelsEnumerator = WHSInventReserveDeltaLevelsEnumerator::newFromDelta(_inventReserveDelta, false);
            
        // skip the first level
        levelsEnumerator.moveNext();
        while (levelsEnumerator.moveNext())
        {
            parentInventDimIds.addEnd(levelsEnumerator.currentInventDimId());
        }

        // parent of last level is empty
        parentInventDimIds.addEnd('');

        return parentInventDimIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWHSInventReserveDeltaFromAggrSum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the <c>WHSInventReserveDelta</c> table based on the parameters.
    /// </summary>
    /// <param name="_inventSumDelta">
    /// An <c>InventSumDelta</c> buffer which can be an aggregation of multiple sums for the item.
    /// </param>
    /// <param name="_transTypeOnlyAffectsLocationAndBelow">
    /// A Boolean that determines if the insert affects all levels of the hierarchy or only the location level and below.
    /// </param>
    /// <returns>
    /// true if records were inserted; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method assumes that the caller have verified before calling that on-hand has to be updated.
    /// </remarks>
    public static boolean insertWHSInventReserveDeltaFromAggrSum(
        InventSumDelta  _inventSumDelta,
        boolean         _transTypeOnlyAffectsLocationAndBelow)
    {
        boolean         insertedAnyRecords = false;
        
        WHSInventReserveQuantities quantities = whsInventOnHand::calcAllInventReserveQuantitiesFromInventSumDelta(_inventSumDelta);

        if (whsInventOnHand::shouldInsertIntoWHSInventReserveDelta(quantities))
        {
            insertedAnyRecords = whsInventOnHand::insertReserveDelta(_inventSumDelta.ItemId,
                                                     quantities,
                                                    _inventSumDelta.InventDimId,
                                                     InventUpdateOnhandGlobal::instance().inventUpdateOnhand().ttsId(),
                                                    _transTypeOnlyAffectsLocationAndBelow);
        }

        return insertedAnyRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWHSInventReserveDeltaFromSumDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the <c>WHSInventReserveDelta</c> table based on the parameters.
    /// </summary>
    /// <param name="_inventSumDelta">
    /// An <c>InventSumDelta</c> buffer.
    /// </param>
    /// <param name="_inventTrans">
    /// An <c>InventTrans</c> record.
    /// </param>
    /// <returns>
    /// true if records were inserted; otherwise, false.
    /// </returns>
    public static boolean insertWHSInventReserveDeltaFromSumDelta(
        InventSumDelta  _inventSumDelta,
        InventTrans     _inventTrans)
    {
        boolean         insertedAnyRecords = false;
        
        WHSInventReserveQuantities quantities = whsInventOnHand::calcAllInventReserveQuantitiesFromInventSumDelta(_inventSumDelta); 
            
        if (whsInventOnHand::shouldInsertIntoWHSInventReserveDelta(quantities))
        {
            boolean mustUpdateWHSInventReserve = true;
            boolean transTypeOnlyAffectsLocationAndBelow = true;

            if (!WHSInventoryTranscationOnHandStackContext::current())
            {
                var transType = InventTransOrigin::find(_inventTrans.InventTransOrigin).ReferenceCategory;

                mustUpdateWHSInventReserve = WhsInvent::mustUpdateWHSInventReserve(transType);
                transTypeOnlyAffectsLocationAndBelow = WhsInvent::transTypeOnlyAffectsLocationAndBelow(transType);
            }

            if (mustUpdateWHSInventReserve)
            {
                insertedAnyRecords = whsInventOnHand::insertReserveDelta(_inventSumDelta.ItemId,
                                                    quantities,
                                                    _inventSumDelta.InventDimId,
                                                    InventUpdateOnhandGlobal::instance().inventUpdateOnhand().ttsId(),
                                                    transTypeOnlyAffectsLocationAndBelow);
            }
        }

        return insertedAnyRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onHandHandlingQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory quantity in the handling unit for an item using <c>physicalInvent</c> or <c>pdsCWPhysicalInvent</c>
    /// methods of <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimId">
    /// Id of the inventory dimensions.
    /// </param>
    /// <returns>
    /// The physical inventory quantity in the handling unit for the item.
    /// </returns>
    [Hookable(false)]
    internal static InventHandlingQty onHandHandlingQty(ItemId _itemId, InventDimId _inventDimId)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return whsInventOnHand::cwOnHandQty(_itemId, _inventDimId);
        }

        return whsInventOnHand::onHandQty(_itemId, _inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>cwOnHandQty</Name>
				<Source><![CDATA[
    private static PdsCWInventQty cwOnHandQty(ItemId _itemId, InventDimId _inventDimId)
    {
        return whsInventOnHand::getPhysicalInventoryOnHandQty(_itemId, _inventDimId, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onHandQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the physical inventory quantity for an item using <c>physicalInvent</c> method of <c>InventOnhand</c> class.
    /// </summary>
    /// <param name="_itemId">
    /// Id of the inventory item.
    /// </param>
    /// <param name="_inventDimId">
    /// Id of the inventory dimensions.
    /// </param>
    /// <returns>
    /// The physical inventory quantity of the item.
    /// </returns>
    public static Qty onHandQty(ItemId _itemId, InventDimId _inventDimId)
    {
        return whsInventOnHand::getPhysicalInventoryOnHandQty(_itemId, _inventDimId, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalInventoryOnHandQty</Name>
				<Source><![CDATA[
    private static InventHandlingQty getPhysicalInventoryOnHandQty(
        ItemId          _itemId,
        InventDimId     _inventDimId,
        boolean         _returnCWQty)
    {
        InventDim inventDim = InventDim::find(_inventDimId);

        InventDimParm inventDimParm;
        inventDimParm.initFromInventDim(inventDim);

        InventOnhand inventOnhand = InventOnhand::newParameters(_itemId,
                                                                inventDim,
                                                                inventDimParm);
        // Since we are looking for physical invent only we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
        inventOnhand.parmDelayAvailabilityCalculation(true);

        return (_returnCWQty) ? inventOnhand.pdsCWPhysicalInvent() : inventOnhand.physicalInvent();
    }

]]></Source>
			</Method>
			<Method>
				<Name>topDownNoOnHandCreationDimLevel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the level, when going from top and down, where the on-hand will be created until but not included for.
    /// </summary>
    /// <param name="_itemId">
    /// The item ID that on-hand is being updated for.
    /// </param>
    /// <param name="_inventDim">
    /// The <c>InventDim</c> ID that is on-hand is being updated for.
    /// </param>
    /// <returns>
    /// The first level, going from top and down that on-hand will be not be created for.
    /// </returns>
    /// <remarks>
    /// If all levels should be filled then 0 is returned.
    /// </remarks>
    public static WHSReservationHierarchyLevel topDownNoOnHandCreationDimLevel(
        ItemId      _itemId,
        InventDim   _inventDim)
    {
        return WHSReservationHierarchyInventDimUtil::getLevelOfFirstBlankDim(_itemId, _inventDim, WHSReservationHierarchySortOrder::TopDown, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcInventReserveQtyFromInventSumDelta</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates quantities of the lowest level <c>WHSInventReserveDelta</c> record
    /// based on the quantities of the the <c>InventSumDelta</c> record.
    /// </summary>
    /// <param name="_inventSumDelta">
    /// The <c>InventSumDelta</c> record.
    /// </param>
    /// <returns>
    /// A container containing available physically, available ordered, reserved physically and reserved ordered quantities.
    /// </returns>
    public static container calcInventReserveQtyFromInventSumDelta(
        InventSumDelta  _inventSumDelta)
    {
        return [
            _inventSumDelta.AvailPhysical,
            _inventSumDelta.AvailOrdered +_inventSumDelta.OnOrder,
            _inventSumDelta.ReservPhysical,
            _inventSumDelta.ReservOrdered
        ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAllInventReserveQuantitiesFromInventSumDelta</Name>
				<Source><![CDATA[
    private static WHSInventReserveQuantities calcAllInventReserveQuantitiesFromInventSumDelta(InventSumDelta  _inventSumDelta)
    {
        WHSInventReserveQuantities quantities = WHSInventReserveQuantities::newDefault();

        [quantities.AvailPhysical, quantities.AvailOrdered, quantities.ReservPhysical, quantities.ReservOrdered] = whsInventOnHand::calcInventReserveQtyFromInventSumDelta(_inventSumDelta);
        
        quantities.CWAvailPhysical  = _inventSumDelta.PdsCWAvailPhysical;
        quantities.CWAvailOrdered   = _inventSumDelta.PdsCWAvailOrdered + _inventSumDelta.PdsCWOnOrder;
        quantities.CWReservPhysical = _inventSumDelta.PdsCWReservPhysical;
        quantities.CWReservOrdered  = _inventSumDelta.PdsCWReservOrdered;

        return quantities;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpperLevelDeltaAvailQuantities</Name>
				<Source><![CDATA[
    private static container getUpperLevelDeltaAvailQuantities(
        WHSInventReserveDelta   _inventReserveDelta,
        InventDim               _inventDim,
        FieldId                 _hierarchyLevelInventDimFieldId)
    {
        WHSNegativeOnHandTrackerCacheValue trackers;
        WHSInventReserve inventReserve;

        InventQty adjustedAvailPhysical = _inventReserveDelta.AvailPhysical;
        InventQty adjustedAvailOrdered = _inventReserveDelta.AvailOrdered;
        PdsCWInventQty cwAdjustedAvailPhysical = _inventReserveDelta.CWAvailPhysical;
        PdsCWInventQty cwAdjustedAvailOrdered = _inventReserveDelta.CWAvailOrdered;

        if (_hierarchyLevelInventDimFieldId == fieldNum(InventDim, InventLocationId)
            && whsInventOnHand::isNegativeWarehouseAdjustmentRequired(_inventReserveDelta.ItemId, _inventDim))
        {
            trackers = WHSNegativeOnHandTrackerCache::getOnHandTrackers(_inventReserveDelta.ItemId, _inventReserveDelta.InventDimId);

            if (!trackers)
            {
                inventReserve = WHSInventReserve::find(_inventReserveDelta.ItemId, _inventReserveDelta.InventDimId);

                if (!inventReserve)
                {
                    inventReserve.ItemId = _inventReserveDelta.ItemId;
                    inventReserve.InventDimId = _inventReserveDelta.InventDimId;
                    inventReserve.IsItemCatchWeightEnabled = _inventReserveDelta.IsItemCatchWeightEnabled;
                }

                trackers = WHSNegativeOnHandTrackerCacheValue::newFromInventReserve(inventReserve);

                WHSNegativeOnHandTrackerCache::set(trackers);
            }

            adjustedAvailPhysical = trackers.availPhysicalTracker().getUpperLevelDeltaQty(_inventReserveDelta.AvailPhysical);
            adjustedAvailOrdered = trackers.availOrderedTracker().getUpperLevelDeltaQty(_inventReserveDelta.AvailOrdered);
            trackers.availPhysicalTracker().registerDeltaQty(_inventReserveDelta.AvailPhysical);
            trackers.availOrderedTracker().registerDeltaQty(_inventReserveDelta.AvailOrdered);
            
            if (_inventReserveDelta.IsItemCatchWeightEnabled)
            {
                cwAdjustedAvailPhysical = trackers.availCWPhysicalTracker().getUpperLevelDeltaQty(_inventReserveDelta.CWAvailPhysical);
                cwAdjustedAvailOrdered = trackers.availCWOrderedTracker().getUpperLevelDeltaQty(_inventReserveDelta.CWAvailOrdered);
                trackers.availCWPhysicalTracker().registerDeltaQty(_inventReserveDelta.CWAvailPhysical);
                trackers.availCWOrderedTracker().registerDeltaQty(_inventReserveDelta.CWAvailOrdered);
            }
        }

        return [adjustedAvailPhysical, adjustedAvailOrdered, cwAdjustedAvailPhysical, cwAdjustedAvailOrdered];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPhysicalHandlingQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the physical invent in the handling unit and the weight of the inventory from the <c>InventOnHand</c> class.
    /// </summary>
    /// <param name = "_itemId">ID of the inventory item.</param>
    /// <param name = "_inventDimId">ID of the inventory dimensions.</param>
    /// <returns>A container that contains the weight and physical invent in the handling unit.</returns>
    [Hookable(false)]
    internal static container getPhysicalHandlingQuantities(
        ItemId      _itemId,
        InventDimId _inventDimId)
    {
        InventDimParm   inventDimParm;
        InventDim       inventDim = InventDim::find(_inventDimId);

        inventDimParm.initFromInventDim(inventDim);

        // If product dimensions are enabled by configuration key and the inventDim has all the product dimensions for the item filled then we are searching for an exact match on product dimensions.
        // By setting all the product dimension field flags we allow SQL to use the WHSDimIdx index which for many scenarios will be covering and lead to effective query plans
        List productDimList = InventDimMetaDataCache::dimProductDimFieldList();

        if (!productDimList.empty())
        {
            InventDimGroupSetup inventDimGroupSetupProductDim = InventDimGroupSetup::newItemIdProductDimensionsOnly(_itemId);

            InventDimParm   inventDimParmActiveProductDim;
            inventDimGroupSetupProductDim.inventDimParmActiveProductDimension(inventDimParmActiveProductDim);

            // We just compare using the full product dim list since we already have that list and it is faster iterating a few more times than getting the list of the enabled product dimensions for the item
            if (inventDim.allInventDimParmFieldsHaveValues(inventDimParmActiveProductDim, productDimList))
            {
                inventDimParm.setAllProductDimensions();
            }
        }

        InventOnhand inventOnhand = InventOnhand::newParameters(_itemId,
                                                   inventDim,
                                                   inventDimParm);

        // Since we are looking for physical invent only we do not need to go to the WHSInventReserve tables so for performance reasons we set the delay flag
        inventOnhand.parmDelayAvailabilityCalculation(true);

        boolean useCWAsHandlingUnit = PdsGlobal::pdsIsCWItem(_itemId);

        // If the item is a CW item then the handling quantity should be CW
        InventHandlingQty   handlingQty;
        WHSTransWeight      transWeight;

        if (useCWAsHandlingUnit)
        {
            handlingQty = inventOnhand.pdsCWPhysicalInvent();
            transWeight = inventOnhand.physicalInvent();
        }
        else
        {
            handlingQty = inventOnhand.physicalInvent();
        }

        return  [handlingQty, transWeight];
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReserveDeltaNegativeWarehouseAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>WHSInventReserveDelta</c> records to account for the changes
    /// to the available quantities that were committed from concurrent database transactions
    /// for warehouses that allow negative physical on hand.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item.
    /// </param>
    /// <param name="_warehouseLevelInventDimId">
    /// The ID of the inventory dimension values set for the warehouse level of the reservation hierarchy.
    /// </param>
    /// <param name="_ttsId">
    /// The ID of the transaction scope.
    /// </param>
    /// <param name="_quantities">
    /// The change in quantities that needs to be applied on the upper levels of the hierarchy.
    /// </param>    
    public static void insertReserveDeltaNegativeWarehouseAdjustment(
        ItemId                     _itemId,
        InventDimId                _warehouseLevelInventDimId,        
        CreatedTransactionId       _ttsId,
        WHSInventReserveQuantities _quantities
        )
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            whsInventOnHand::insertReserveDeltaNegWarehouseAdjustmentFromQuantities(_itemId, _warehouseLevelInventDimId, _ttsId, _quantities);
        }
        else
        {
            whsInventOnHand::insertReserveDeltaNegWarehouseAdjustment(_itemId, _warehouseLevelInventDimId, _quantities.AvailPhysical, _quantities.AvailOrdered, _ttsId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReserveDeltaNegWarehouseAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>WHSInventReserveDelta</c> records to account for the changes
    /// to the available quantities that were committed from concurrent database transactions
    /// for warehouses that allow negative physical on hand.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item.
    /// </param>
    /// <param name="_warehouseLevelInventDimId">
    /// The ID of the inventory dimension values set for the warehouse level of the reservation hierarchy.
    /// </param>
    /// <param name="_availPhysicalAdjustment">
    /// The change in the physically available quantity that needs to be applied on the upper levels of the hierarchy.
    /// </param>
    /// <param name="_availOrderedAdjustment">
    /// The change in the ordered available quantity that needs to be applied on the upper levels of the hierarchy.
    /// </param>
    /// <param name="_ttsId">
    /// The ID of the transaction scope.
    /// </param>
    public static void insertReserveDeltaNegWarehouseAdjustment(
        ItemId                     _itemId,
        InventDimId                _warehouseLevelInventDimId,
        InventQtyAvailPhysical     _availPhysicalAdjustment,
        InventQtyAvailOrdered      _availOrderedAdjustment,
        CreatedTransactionId       _ttsId)
    {
        if (PdsGlobal::pdsIsCWItem(_itemId))
        {
            throw error("@WAX:Error_WHSCWOnHandNotSupported");
        }

        WHSInventReserveDeltaLevelsEnumerator deltaLevelsEnumerator = WHSInventReserveDeltaLevelsEnumerator::newForNegativeWarehouseAdjustment(
                                                                        _itemId,
                                                                        _warehouseLevelInventDimId,
                                                                        _availPhysicalAdjustment,
                                                                        _availOrderedAdjustment);

        WHSInventReserveQuantities quantities = WHSInventReserveQuantities::newAvailQuantities(_availPhysicalAdjustment, _availOrderedAdjustment, 0, 0);
        
        whsInventOnHand::insertWHSInventReserveDeltaNegWarehouseAdjustmentFromParam(deltaLevelsEnumerator, _itemId, _ttsId, NoYes::No, quantities);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReserveDeltaNegWarehouseAdjustmentFromQuantities</Name>
				<Source><![CDATA[
    private static void insertReserveDeltaNegWarehouseAdjustmentFromQuantities(
        ItemId                     _itemId,
        InventDimId                _warehouseLevelInventDimId,        
        CreatedTransactionId       _ttsId,
        WHSInventReserveQuantities _quantities)
    {
        WHSInventReserveDeltaLevelsEnumerator deltaLevelsEnumerator = WHSInventReserveDeltaLevelsEnumerator::newForNegativeWarehouseAdjustmentFromQuantities(
                                                                        _itemId,
                                                                        _warehouseLevelInventDimId,
                                                                        _quantities);
        
        whsInventOnHand::insertWHSInventReserveDeltaNegWarehouseAdjustmentFromParam(deltaLevelsEnumerator, _itemId, _ttsId, PdsGlobal::pdsIsCWItem(_itemId), _quantities);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertWHSInventReserveDeltaNegWarehouseAdjustmentFromParam</Name>
				<Source><![CDATA[
    private static void insertWHSInventReserveDeltaNegWarehouseAdjustmentFromParam(
        WHSInventReserveDeltaLevelsEnumerator   _deltaLevelsEnumerator,
        ItemId                                  _itemId,
        CreatedTransactionId                    _ttsId,
        WHSIsItemCatchWeightEnabled             _isItemCatchWeightEnabled,
        WHSInventReserveQuantities              _quantities)
    {
        
        while (_deltaLevelsEnumerator.moveNext())
        {
            WHSInventReserveDelta inventReserveDelta;

            inventReserveDelta.TTSId = _ttsId;
            inventReserveDelta.ItemId = _itemId;
            inventReserveDelta.IsItemCatchWeightEnabled = _isItemCatchWeightEnabled;
            inventReserveDelta.InventDimId = _deltaLevelsEnumerator.currentInventDimId();
            inventReserveDelta.HierarchyLevel = _deltaLevelsEnumerator.currentHierarchyLevel(); 
            inventReserveDelta.addFromWHSInventReserveQuantities(_quantities);
            inventReserveDelta.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNegativeWarehouseAdjustmentRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether on hand adjustments on the upper levels of the reservation hierarchy
    /// are required for negative on hand changes.
    /// </summary>
    /// <param name="_itemId">
    /// The ID of the item for which the on hand changes are done.
    /// </param>
    /// <param name="_warehouseLevelInventDim">
    /// The inventory dimensions value set for the warehouse level of the reservation hierarchy.
    /// </param>
    /// <returns>
    /// true if on hand adjustments are required; otherwise, false.
    /// </returns>
    public static boolean isNegativeWarehouseAdjustmentRequired(
        ItemId                  _itemId,
        InventDim               _warehouseLevelInventDim)
    {
        return _warehouseLevelInventDim.inventLocation().RetailInventNegPhysical
            && !InventTable::modelGroupByItemId(_itemId).NegativePhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInsertIntoWHSInventReserveDelta</Name>
				<Source><![CDATA[
    private static boolean shouldInsertIntoWHSInventReserveDelta(WHSInventReserveQuantities _quantities)
    {
        return _quantities.anyFieldHasValue();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>