<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanProductionFlowTraverser</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LeanProductionFlowTraverser</c> class implements an algorithm that is used to scan a
///    production flow graph and finds all <c>KanbanFlow</c> objects between the specified first and last
///    activity.
/// </summary>
public class LeanProductionFlowTraverser
{
    Map                                 mapProdFlow;
    StackBase                           stackRemainingNodes;

    KanbanFlowsTree                     kanbanFlowsTree;
    KanbanFlowStateMachine              kanbanFlowValidator;

    LeanActivityRelationshipWrapper     actRelationshipWrapperListHead;

    PlanPlanActivity                    firstPlanPlanActivity;
    PlanPlanActivity                    lastPlanPlanActivity;
    PlanActivity                        firstPlanActivity;
    PlanActivity                        lastPlanActivity;

    LeanKanbanType                      kanbanType;

    boolean                             inCrossPlanReferenceMode;
    boolean                             inCheckConnectivityMode;
    boolean                             inFindFirstMode;
    boolean                             inUseKanbanFlowsFromDatabaseMode;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addAdjacentElementsToList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds all adjacent relations of the one passed as argument to the list of stacked nodes.
    /// </summary>
    /// <param name="_currLeanActivityRelationshipWrapper">
    ///    The relation whose adjacent ones are added to the list.
    /// </param>
    protected void addAdjacentElementsToList(LeanActivityRelationshipWrapper _currLeanActivityRelationshipWrapper)
    {
        RefRecId                        planActivityRecId;

        if (!_currLeanActivityRelationshipWrapper)
        {
            planActivityRecId = firstPlanActivity.RecId;
        }
        else
        {
            planActivityRecId = _currLeanActivityRelationshipWrapper.parmDependentActivityRecId();
        }

        // if there are no further exit links from this element, we stop at this point
        if (!mapProdFlow.exists(planActivityRecId))
        {
            return;
        }

        // get the next elements
        List elementsList = mapProdFlow.lookup(planActivityRecId);
        ListEnumerator listEnumerator = elementsList.getEnumerator();

        // iterate and eventually add the next links
        while (listEnumerator.moveNext())
        {
            LeanActivityRelationshipWrapper nextLeanActivityRelationshipWrapper = listEnumerator.current();

            // we add a relation to the next relations stack only if:
            //  - if we're only interested in connectivity OR
            //  - if the validation FSM is in valid state
            //  - if the relation can be used (see this.isRelationAllowed() for more details)
            if (inCheckConnectivityMode
                || (kanbanFlowValidator.inValidState()
                    && this.isRelationAllowed(nextLeanActivityRelationshipWrapper)))
            {
                this.addElementToStack(nextLeanActivityRelationshipWrapper, _currLeanActivityRelationshipWrapper);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addElementToStack</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a <c>LeanActivityRelationshipWrapper</c> element to the non-visited nodes list.
    /// </summary>
    /// <param name="_leanActivityRelationshipWrapper">
    ///    The element to add to the nodes list.
    /// </param>
    /// <param name="_prevLeanActivityRelationshipWrapper">
    ///    The previous element that is used to maintain the consistency of the currently built kanban flow
    ///    list.
    /// </param>
    protected void addElementToStack(
        LeanActivityRelationshipWrapper _leanActivityRelationshipWrapper,
        LeanActivityRelationshipWrapper _prevLeanActivityRelationshipWrapper)
    {
        // first we set the current state to the object
        _leanActivityRelationshipWrapper.parmAlreadyInContainer(true);

        // set the backward reference to the tail so that when this element
        // is current, we can easily restore the kanban flow links list
        // with 2 assignments instead of multiple deletion of elements
        _leanActivityRelationshipWrapper.parmPrevWrapper(_prevLeanActivityRelationshipWrapper);

        // we then push it to the stack to get depth-first search behavior
        stackRemainingNodes.push(_leanActivityRelationshipWrapper);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateAllFlows</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates all flows that exist between the specified first and last activities.
    /// </summary>
    /// <returns>
    ///    A collection object that has all kanban flows that have been found between the specified first and
    ///    last <c>PlanPlanActivity</c> records.
    /// </returns>
    public KanbanFlowsCollection generateAllFlows()
    {
        LeanActivityRelationshipWrapper currentLeanActivityRelationshipWrapper, prevLeanActivityRelationshipWrapper;
        KanbanFlowsCollection kanbanFlowsCollection = KanbanFlowsCollection::construct();

        firstPlanActivity = firstPlanPlanActivity.planActivity();
        lastPlanActivity = lastPlanPlanActivity.planActivity();

        // check whether the search targets are defined
        if (   !firstPlanActivity.RecId
            || !lastPlanActivity.RecId)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        // Initialize tree to remember all kanban flows in database
        if (this.parmInUseKanbanFlowsFromDatabaseMode())
        {
            kanbanFlowsTree = KanbanFlowsTree::construct();
            kanbanFlowsTree.init(KanbanFlow::findAllFlows(firstPlanPlanActivity.RecId, lastPlanPlanActivity.RecId));
        }

        // initialize the flow-validating state machine
        this.initKanbanFlowValidator();

        // 1. fill in the initial search list in the stack (all links that exit from the source)
        this.addAdjacentElementsToList(null);

        // 2. loop until we finish with all elements in the stack and
        //    if we're in findFirst mode - until we haven't found any route
        while (   stackRemainingNodes.count() > 0
               && (!inFindFirstMode
               ||  kanbanFlowsCollection.kanbanFlowsCount() == 0))
        {
            // 2.1. get an element from the list
            currentLeanActivityRelationshipWrapper = stackRemainingNodes.pop();

            // 2.1.1 set the state machine's current state
            kanbanFlowValidator.parmCurrentState(currentLeanActivityRelationshipWrapper.parmCurrentFSMState());

            // 2.2 if we're starting a new flow, update the head of the list
            if (this.isFirstActivity(currentLeanActivityRelationshipWrapper))
            {
                actRelationshipWrapperListHead = currentLeanActivityRelationshipWrapper;
            }

            // 2.3. mark it as not in the stack
            currentLeanActivityRelationshipWrapper.parmAlreadyInContainer(false);

            // 2.4. update the element's previos'es next element to be the element
            //      (this way we get the up-to-date kanban flow without any deletion or maintenance)
            prevLeanActivityRelationshipWrapper = currentLeanActivityRelationshipWrapper.parmPrevWrapper();

            if (prevLeanActivityRelationshipWrapper)
            {
                prevLeanActivityRelationshipWrapper.parmNextWrapper(currentLeanActivityRelationshipWrapper);
            }

            // 2.5. if it's destination -> create a kanbanflowwrapper and add to collection
            if (this.isLastActivity(currentLeanActivityRelationshipWrapper))
            {
                if (inCheckConnectivityMode
                    || (kanbanFlowValidator.inValidState()
                        && kanbanFlowValidator.inFinalState()))
                {
                    // create a kanbanflowwrapper
                    kanbanFlowsCollection.addKanbanFlowWrapper(this.generateKanbanFlowWrapper());
                }
            }
            else
            {
                // 2.6. if this is not a loop element -> explode the current element and
                // add each of the elements to the list
                if (currentLeanActivityRelationshipWrapper.parmIndependentActivityRecId() !=
                    currentLeanActivityRelationshipWrapper.parmDependentActivityRecId())
                {
                    this.addAdjacentElementsToList(currentLeanActivityRelationshipWrapper);
                }
            }
        }

        return kanbanFlowsCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateKanbanFlowWrapper</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Generates a new instance of the <c>KanbanFlowWrapper</c> class that is specified by the current
    ///    linked list of <c>LeanActivityRelationshipWrapper</c> elements.
    /// </summary>
    /// <returns>
    ///    An instance of the <c>KanbanFlowWrapper</c> class.
    /// </returns>
    protected KanbanFlowWrapper generateKanbanFlowWrapper()
    {
        KanbanFlowsTree                 actTree           = kanbanFlowsTree;
        KanbanFlowWrapper               kanbanFlowWrapper = KanbanFlowWrapper::newStandard();

        // check input state
        if (!actRelationshipWrapperListHead)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        // initialize the iterator
        LeanActivityRelationshipWrapper iterator = actRelationshipWrapperListHead;

        // duplicate the current linked list and add it to the flow
        while (iterator)
        {
            LeanActivityRelationshipWrapper leanActivityRelationshipWrapper = iterator.clone();
            int i = kanbanFlowWrapper.addRelation(leanActivityRelationshipWrapper);

            // iterate through the tree to check if flow exists in database
            if (this.parmInUseKanbanFlowsFromDatabaseMode() && actTree)
            {
                actTree = actTree.getChild(leanActivityRelationshipWrapper.parmDependentActivityRecId(), false);
            }

            iterator = iterator.parmNextWrapper();
        }

        // if found return kanban flow from database
        if (actTree && actTree.parmKanbanFlowWrapper())
        {
            return actTree.parmKanbanFlowWrapper();
        }

        // initialize the KanbanFlow header record
        kanbanFlowWrapper.parmKanbanFlow(this.initKanbanFlow(inCrossPlanReferenceMode));

        return kanbanFlowWrapper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initKanbanFlow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes and retrieves a <c>KanbanFlow</c> record that holds the information relevant to the
    ///    current production flow scan.
    /// </summary>
    /// <param name="_feeder">
    ///    A Boolean value that indicates whether the flow is cross production flow reference.
    /// </param>
    /// <returns>
    ///    A <c>KanbanFlow</c> buffer that holds the information relevant to the current production flow scan.
    /// </returns>
    protected KanbanFlow initKanbanFlow(boolean _feeder = false)
    {
        KanbanFlow kanbanFlow;

        kanbanFlow.initFromFirstPlanPlanActivity(firstPlanPlanActivity.RecId);
        kanbanFlow.initFromLastPlanPlanActivity(lastPlanPlanActivity.RecId);
        kanbanFlow.IsBridge = _feeder;

        return kanbanFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initKanbanFlowValidator</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the state machine for validating kanban flows.
    /// </summary>
    /// <remarks>
    ///    This method only supports multiple activity and cross production flows.The
    ///    <c>LeanProductionFlowTraverser</c> class is not meant that must be used for single activity kanban
    ///    flows.
    /// </remarks>
    protected void initKanbanFlowValidator()
    {
        container                   initialTransition;
        LeanProductionFlowActivity  leanProductionFlowActivity = LeanProductionFlowActivity::findPlanActivity(firstPlanActivity.RecId);

        if (inCrossPlanReferenceMode)
        {
            kanbanFlowValidator = KanbanFlowStateMachine::newCrossPFKanbanFlow();
            initialTransition = KanbanFlowStateMachine::createConditionCrossPF(kanbanType,
                                                                                firstPlanActivity.PlanActivityType,
                                                                                leanProductionFlowActivity.PickUpSemiFinished,
                                                                                leanProductionFlowActivity.ReceiveSemiFinished,
                                                                                leanProductionFlowActivity.FeederBridge == NoYes::Yes);
        }
        else
        {
            kanbanFlowValidator = KanbanFlowStateMachine::newMultiActivityKanbanFlow();
            initialTransition = KanbanFlowStateMachine::createCondition(kanbanType,
                                                                                firstPlanActivity.PlanActivityType,
                                                                                leanProductionFlowActivity.PickUpSemiFinished,
                                                                                leanProductionFlowActivity.ReceiveSemiFinished);
        }

        // do the first transition
        kanbanFlowValidator.changeState(initialTransition);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the state of the object.
    /// </summary>
    protected void initState()
    {
        mapProdFlow                     = new Map(Types::Int64, Types::Class);
        stackRemainingNodes             = new StackBase(Types::Class);
        inCrossPlanReferenceMode        = false;
        actRelationshipWrapperListHead  = null;

        firstPlanActivity.clear();
        lastPlanActivity.clear();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFirstActivity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the passed wrapper holds the first activity of the kanban flow.
    /// </summary>
    /// <param name="_leanActivityRelationshipWrapper">
    ///    The wrapper to check.
    /// </param>
    /// <returns>
    ///    true if the element is the first activity of the kanban flow; otherwise, false.
    /// </returns>
    private boolean isFirstActivity(LeanActivityRelationshipWrapper _leanActivityRelationshipWrapper)
    {
        return _leanActivityRelationshipWrapper.parmIndependentActivityRecId() == firstPlanActivity.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastActivity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the passed wrapper holds the last activity of the kanban flow.
    /// </summary>
    /// <param name="_leanActivityRelationshipWrapper">
    ///    The wrapper to check.
    /// </param>
    /// <returns>
    ///    true if the element is the last activity of the kanban flow; otherwise, false.
    /// </returns>
    private boolean isLastActivity(LeanActivityRelationshipWrapper _leanActivityRelationshipWrapper)
    {
        return _leanActivityRelationshipWrapper.parmDependentActivityRecId() == lastPlanActivity.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRelationAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the scanning state of the current flow allows the use of a relation.
    /// </summary>
    /// <param name="_nextLeanActivityRelationshipWrapper">
    ///    The production flow next relation to use.
    /// </param>
    /// <returns>
    ///    true if the relation can be used; otherwise, false.
    /// </returns>
    protected boolean isRelationAllowed(LeanActivityRelationshipWrapper _nextLeanActivityRelationshipWrapper)
    {
        KanbanFlowStateMachineStates    nextState = kanbanFlowValidator.nextState(this.transitionCondition(_nextLeanActivityRelationshipWrapper));

        boolean result = nextState != KanbanFlowStateMachineStates::Invalid;

        // in case of valid state we preserve it in the relation checked so next time we can
        // restore the FSM at that state directly
        if (result)
        {
            _nextLeanActivityRelationshipWrapper.parmCurrentFSMState(nextState);
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
        protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFirstPlanPlanActivity</Name>
				<Source><![CDATA[
        protected PlanPlanActivity parmFirstPlanPlanActivity(PlanPlanActivity _firstPlanPlanActivity = firstPlanPlanActivity)
    {
        firstPlanPlanActivity = _firstPlanPlanActivity;

        return firstPlanPlanActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInCheckConnectivityMode</Name>
				<Source><![CDATA[
        protected boolean parmInCheckConnectivityMode(boolean _inCheckConnectivityMode = inCheckConnectivityMode)
    {
        inCheckConnectivityMode = _inCheckConnectivityMode;

        return inCheckConnectivityMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInCrossPlanReferenceMode</Name>
				<Source><![CDATA[
        protected boolean parmInCrossPlanReferenceMode(boolean _inCrossPlanReferenceMode = inCrossPlanReferenceMode)
    {
        inCrossPlanReferenceMode = _inCrossPlanReferenceMode;

        return inCrossPlanReferenceMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInFindFirstMode</Name>
				<Source><![CDATA[
        protected boolean parmInFindFirstMode(boolean _inFindFirstMode = inFindFirstMode)
    {
        inFindFirstMode = _inFindFirstMode;

        return inFindFirstMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInUseKanbanFlowsFromDatabaseMode</Name>
				<Source><![CDATA[
        protected boolean parmInUseKanbanFlowsFromDatabaseMode(boolean _inUseKanbanFlowsFromDatabaseMode = inUseKanbanFlowsFromDatabaseMode)
    {
        inUseKanbanFlowsFromDatabaseMode = _inUseKanbanFlowsFromDatabaseMode;

        return inUseKanbanFlowsFromDatabaseMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKanbanType</Name>
				<Source><![CDATA[
        public LeanKanbanType parmKanbanType(LeanKanbanType _kanbanType = kanbanType)
    {
        kanbanType = _kanbanType;

        return kanbanType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastPlanPlanActivity</Name>
				<Source><![CDATA[
        protected PlanPlanActivity parmLastPlanPlanActivity(PlanPlanActivity _lastPlanPlanActivity = lastPlanPlanActivity)
    {
        lastPlanPlanActivity = _lastPlanPlanActivity;

        return lastPlanPlanActivity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMapProdFlow</Name>
				<Source><![CDATA[
        protected Map parmMapProdFlow(Map _mapProdFlow = mapProdFlow)
    {
        mapProdFlow = _mapProdFlow;

        return mapProdFlow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transitionCondition</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates transition conditions for the kanban flow state machine.
    /// </summary>
    /// <param name="_leanActivityRelationshipWrapper">
    ///    An object that contains the source data for the transition conditions.
    /// </param>
    /// <returns>
    ///    A container that holds the needed parameters.
    /// </returns>
    private container transitionCondition(LeanActivityRelationshipWrapper _leanActivityRelationshipWrapper)
    {
        return inCrossPlanReferenceMode ?
                KanbanFlowStateMachine::createConditionCrossPF(kanbanType,
                                                                _leanActivityRelationshipWrapper.parmDependentActivityType(),
                                                                _leanActivityRelationshipWrapper.parmDependentActInputSemiFinished(),
                                                                _leanActivityRelationshipWrapper.parmDependentActOutputSemiFinished(),
                                                                _leanActivityRelationshipWrapper.parmDependentActivityFeederBridge())
                :
                KanbanFlowStateMachine::createCondition(kanbanType,
                                                                _leanActivityRelationshipWrapper.parmDependentActivityType(),
                                                                _leanActivityRelationshipWrapper.parmDependentActInputSemiFinished(),
                                                                _leanActivityRelationshipWrapper.parmDependentActOutputSemiFinished());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProductionFlowLoops</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks for loops in the production flow relations.
    /// </summary>
    /// <param name="_leanProductionFlow">
    ///    The production flow to check.
    /// </param>
    /// <returns>
    ///    true if loops exist; otherwise, false.
    /// </returns>
    private static boolean checkProductionFlowLoops(LeanProductionFlow _leanProductionFlow)
    {
        PlanActivityRelationship    planActivityRelationship, loopedRelationship;
        LeanProdFlowPlanActivityRelation leanProdFlowPlanActivityRelation, loopedLeanProdFlowPlanActivityRelation;

        // tries to pick relations that look like a->b and b->a that belong to the same PF
        select firstonly RecId
            from planActivityRelationship
        exists join loopedRelationship
            where planActivityRelationship.IndependentPlanActivity                  == loopedRelationship.DependentPlanActivity &&
                  planActivityRelationship.DependentPlanActivity                    == loopedRelationship.IndependentPlanActivity
        exists join leanProdFlowPlanActivityRelation
            where leanProdFlowPlanActivityRelation.PlanActivityRelationship         == planActivityRelationship.RecId
        exists join loopedLeanProdFlowPlanActivityRelation
            where loopedLeanProdFlowPlanActivityRelation.PlanActivityRelationship   == loopedRelationship.RecId
                  && leanProdFlowPlanActivityRelation.ProductionFlow                == loopedLeanProdFlowPlanActivityRelation.ProductionFlow;

        return planActivityRelationship.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
        private static LeanProductionFlowTraverser construct()
    {
        return new LeanProductionFlowTraverser();
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadCrossProductionFlow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads all production flow relations from the database.
    /// </summary>
    /// <param name="_feederLeanProductionFlow">
    ///    The feeding <c>LeanProductionFlow</c> record.
    /// </param>
    /// <param name="_fedLeanProductionFlow">
    ///    The fed <c>LeanProductionFlow</c> record.
    /// </param>
    /// <returns>
    ///    A map object that contains all existing relations that connect the two flows.
    /// </returns>
    private static Map loadCrossProductionFlow(
        LeanProductionFlow _feederLeanProductionFlow,
        LeanProductionFlow _fedLeanProductionFlow)
    {
        Map                                 productionFlowRelations = new Map(Types::Int64, Types::Class);
        List                                list;

        LeanProdFlowPlanActivityRelation    leanProdFlowPlanActivityRelation;
        PlanActivityRelationship            planActivityRelationship;
        PlanActivity                        independentPlanActivity;
        PlanActivity                        dependentPlanActivity;
        PlanConstraint                      planConstraint;
        PlanSequenceConstraintValue         planSequenceConstraintValue;

        RefRecId                            fedPlanReference = _fedLeanProductionFlow.plan().PlanReference;
        RefRecId                            feederPlanReference = _feederLeanProductionFlow.plan().PlanReference;

        // validate input params
        if (fedPlanReference == feederPlanReference)
        {
            throw error("@SYS134776");
        }

        // we only load the data for relations that:
        //  - the cross-plan reference relation belong to the fed production flow
        //  - dependent activity should belong to the same plan reference as the _fedLeanProductionFlow
        //  - dependent activity should be of type Transfer
        //  - independent activity should belong to the same plan reference as the _feederLeanProductionFlow
        while select RecId, CycleTimeRatio from leanProdFlowPlanActivityRelation
                where leanProdFlowPlanActivityRelation.ProductionFlow   == _fedLeanProductionFlow.RecId
            join planActivityRelationship
                order by planActivityRelationship.IndependentPlanActivity
                where planActivityRelationship.RecId                    == leanProdFlowPlanActivityRelation.PlanActivityRelationship
            join RecId, Name, PlanActivityType from independentPlanActivity
                where independentPlanActivity.RecId                     == planActivityRelationship.IndependentPlanActivity
                      && independentPlanActivity.PlanReference          == feederPlanReference
                      && ( independentPlanActivity.PlanActivityType     == PlanActivityType::Process
                           || independentPlanActivity.PlanActivityType  == PlanActivityType::Transfer )
            join RecId, Name, PlanActivityType from dependentPlanActivity
                where dependentPlanActivity.RecId                       == planActivityRelationship.DependentPlanActivity
                      && dependentPlanActivity.PlanReference            == fedPlanReference
                      && dependentPlanActivity.PlanActivityType         == PlanActivityType::Transfer
            outer join RecId from planConstraint
                where planConstraint.RecId                              == planActivityRelationship.Constraint
            outer join PlanConstraint, ConstraintValueRole, Value, UnitOfMeasure from planSequenceConstraintValue
                where planSequenceConstraintValue.PlanConstraint        == planConstraint.RecId
                      && planSequenceConstraintValue.ConstraintValueRole== ConstraintRoleTypes::Minimum
        {
            // create a link wrapper object
            LeanActivityRelationshipWrapper leanActivityRelationshipWrapper = LeanActivityRelationshipWrapper::newBuffers(leanProdFlowPlanActivityRelation,
                                                                                                                            planActivityRelationship,
                                                                                                                            independentPlanActivity,
                                                                                                                            dependentPlanActivity,
                                                                                                                            planConstraint,
                                                                                                                            planSequenceConstraintValue);

            if (!productionFlowRelations.exists(independentPlanActivity.RecId))
            {
                // if the element doesn't exist -> create the list and add it
                list = new List(Types::Class);
                list.addEnd(leanActivityRelationshipWrapper);

                productionFlowRelations.insert(independentPlanActivity.RecId, list);
            }
            else
            {
                // if the element exists we should just append the new relation wrapper
                list = productionFlowRelations.lookup(independentPlanActivity.RecId);
                list.addEnd(leanActivityRelationshipWrapper);
            }
        }

        return productionFlowRelations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadFromKanbanFlowWrapper</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads all production flow relations from the database that are part of the <c>KanbanFlowWrapper</c>
    ///    record.
    /// </summary>
    /// <param name="_kanbanFlowWrapper">
    ///    The <c>KanbanFlowWrapper</c> record that holds all relations to load.
    /// </param>
    /// <returns>
    ///    A map object that contains all relations that belong to the production flow.
    /// </returns>
    private static Map loadFromKanbanFlowWrapper(KanbanFlowWrapper _kanbanFlowWrapper)
    {
        Map                                 productionFlowRelations = new Map(Types::Int64, Types::Class);
        List                                list;

        // get an enumerator to the links
        ListEnumerator listEnumerator = _kanbanFlowWrapper.relationsList().getEnumerator();

        // iterate the collection and populate the map
        while (listEnumerator.moveNext())
        {
            LeanActivityRelationshipWrapper leanActivityRelationshipWrapper = listEnumerator.current();
            recId independentActivityRecId = leanActivityRelationshipWrapper.parmIndependentActivityRecId();

            if (!productionFlowRelations.exists(independentActivityRecId))
            {
                // if the element doesn't exist -> create the list and add it
                list = new List(Types::Class);
                list.addEnd(leanActivityRelationshipWrapper);

                productionFlowRelations.insert(independentActivityRecId, list);
            }
            else
            {
                // if the element exists we should just append the new relation wrapper
                list = productionFlowRelations.lookup(independentActivityRecId);
                list.addEnd(leanActivityRelationshipWrapper);
            }
        }

        return productionFlowRelations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>loadProductionFlow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Loads all production flow relations from the database.
    /// </summary>
    /// <param name="_leanProductionFlow">
    ///    The <c>LeanProductionFlow</c> record that indicates the relations to load.
    /// </param>
    /// <returns>
    ///    A map object that contains all relations that belong to the production flow.
    /// </returns>
    private static Map loadProductionFlow(LeanProductionFlow _leanProductionFlow)
    {
        Map                                 productionFlowRelations = new Map(Types::Int64, Types::Class);
        List list;

        LeanProdFlowPlanActivityRelation    leanProdFlowPlanActivityRelation;
        PlanActivityRelationship            planActivityRelationship;
        PlanActivity                        independentPlanActivity;
        PlanActivity                        dependentPlanActivity;
        PlanConstraint                      planConstraint;
        PlanSequenceConstraintValue         planSequenceConstraintValue;

        if (LeanProductionFlowTraverser::checkProductionFlowLoops(_leanProductionFlow))
        {
            throw error("@SYS184180");
        }

        // we only load the data for relations connecting high-level activities (of type Process or Transfer)
        while select RecId, CycleTimeRatio from leanProdFlowPlanActivityRelation
                where leanProdFlowPlanActivityRelation.ProductionFlow   == _leanProductionFlow.RecId
            join RecId from planActivityRelationship
                order by planActivityRelationship.IndependentPlanActivity, planActivityRelationship.DependentPlanActivity
                where planActivityRelationship.RecId                    == leanProdFlowPlanActivityRelation.PlanActivityRelationship
            join RecId, Name, PlanActivityType from independentPlanActivity
                where independentPlanActivity.RecId                     == planActivityRelationship.IndependentPlanActivity
                      && ( independentPlanActivity.PlanActivityType     == PlanActivityType::Process
                           || independentPlanActivity.PlanActivityType  == PlanActivityType::Transfer )
            join RecId, Name, PlanActivityType from dependentPlanActivity
                where dependentPlanActivity.RecId                       == planActivityRelationship.DependentPlanActivity
                      && ( dependentPlanActivity.PlanActivityType       == PlanActivityType::Process
                           || dependentPlanActivity.PlanActivityType    == PlanActivityType::Transfer )
            outer join RecId from planConstraint
                where planConstraint.RecId == planActivityRelationship.Constraint
            outer join PlanConstraint, ConstraintValueRole, Value, UnitOfMeasure from planSequenceConstraintValue
                where planSequenceConstraintValue.PlanConstraint        == planConstraint.RecId
                      && planSequenceConstraintValue.ConstraintValueRole== ConstraintRoleTypes::Minimum
        {
            // create a link wrapper object
            LeanActivityRelationshipWrapper leanActivityRelationshipWrapper = LeanActivityRelationshipWrapper::newBuffers(leanProdFlowPlanActivityRelation,
                                                                                                                            planActivityRelationship,
                                                                                                                            independentPlanActivity,
                                                                                                                            dependentPlanActivity,
                                                                                                                            planConstraint,
                                                                                                                            planSequenceConstraintValue);

            if (!productionFlowRelations.exists(independentPlanActivity.RecId))
            {
                // if the element doesn't exist -> create the list and add it
                list = new List(Types::Class);
                list.addEnd(leanActivityRelationshipWrapper);

                productionFlowRelations.insert(independentPlanActivity.RecId, list);
            }
            else
            {
                // if the element exists we should just append the new relation wrapper
                list = productionFlowRelations.lookup(independentPlanActivity.RecId);
                list.addEnd(leanActivityRelationshipWrapper);
            }
        }

        return productionFlowRelations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newKanbanFlowWrapper</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates and retrieves an instance of the <c>LeanProductionFlowTraverser</c> class that is used to
    ///    validate the particular flow.
    /// </summary>
    /// <param name="_kanbanFlowWrapper">
    ///    The <c>KanbanFlowWrapper</c> object that holds the memory copy of the flow.
    /// </param>
    /// <param name="_kanbanType">
    ///    The type of kanban for which to create the traverser.
    /// </param>
    /// <returns>
    ///    An instance of the <c>LeanProductionFlowTraverser</c> class.
    /// </returns>
    protected static LeanProductionFlowTraverser newKanbanFlowWrapper(
        KanbanFlowWrapper _kanbanFlowWrapper,
        LeanKanbanType    _kanbanType)
    {
        LeanProductionFlowTraverser leanProductionFlowTraverser = LeanProductionFlowTraverser::construct();
        Map                         productionFlowRelations = new Map(Types::Int64, Types::Class);

        // validate input parameters
        if (!_kanbanFlowWrapper)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        if (_kanbanType == LeanKanbanType::Manufacturing)
        {
            // load the map holding the relations
            productionFlowRelations = LeanProductionFlowTraverser::loadFromKanbanFlowWrapper(_kanbanFlowWrapper);
        }

        // set the data the traverser operates on
        leanProductionFlowTraverser.initState();
        leanProductionFlowTraverser.parmMapProdFlow(productionFlowRelations);
        leanProductionFlowTraverser.parmKanbanType(_kanbanType);
        leanProductionFlowTraverser.parmInCrossPlanReferenceMode(_kanbanFlowWrapper.parmKanbanFlow().IsBridge == NoYes::Yes);

        return leanProductionFlowTraverser;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPlanPlanActivity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and returns an instance of <c>leanProductionFlowTraverser</c> that
    /// is used to find all paths between the first and last <c>PlanPlanActivity</c> records.
    /// </summary>
    /// <param name="_firstPlanPlanActivity">
    /// The first <c>PlanPlanActivity</c> record.
    /// </param>
    /// <param name="_lastPlanPlanActivity">
    /// The last <c>PlanPlanActivity</c> record.
    /// </param>
    /// <param name="_kanbanType">
    /// The type of kanban for which we are creating this traverser.
    /// </param>
    /// <param name="_onlyCheckConnectivity">
    /// The flag indicates whether the traverser ignores all kanban flow rules, i.e. it only
    /// checks for valid paths between source and destination in the production flow.
    /// </param>
    /// <param name="_useKanbanFlowsFromDatabase">
    /// The flag indicates whether the traverser uses kanban flows from database when possible
    /// during generating all flows
    /// </param>
    /// <returns>
    /// An instance of <c>leanProductionFlowTraverser</c>.
    /// </returns>
    public static LeanProductionFlowTraverser newPlanPlanActivity(
        PlanPlanActivity _firstPlanPlanActivity,
        PlanPlanActivity _lastPlanPlanActivity,
        LeanKanbanType   _kanbanType,
        boolean          _onlyCheckConnectivity      = false,
        boolean          _useKanbanFlowsFromDatabase = false)
    {
        LeanProductionFlowTraverser leanProductionFlowTraverser = LeanProductionFlowTraverser::construct();
        Map                         productionFlowRelations = new Map(Types::Int64, Types::Class);
        boolean                     crossPF = false;

        // validate input parameters
        if (!_firstPlanPlanActivity.RecId   ||
            !_lastPlanPlanActivity.RecId)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        // load the map holding the relations
        if (_firstPlanPlanActivity.plan().RecId == _lastPlanPlanActivity.plan().RecId)
        {
            if (_firstPlanPlanActivity.RecId != _lastPlanPlanActivity.RecId &&
                (_kanbanType != LeanKanbanType::Withdrawal ||
                 _onlyCheckConnectivity))
            {
                productionFlowRelations = LeanProductionFlowTraverser::loadProductionFlow(_firstPlanPlanActivity.productionFlow());
            }
        }
        else
        {
            productionFlowRelations = LeanProductionFlowTraverser::loadCrossProductionFlow(_firstPlanPlanActivity.productionFlow(), _lastPlanPlanActivity.productionFlow());
            crossPF = true;
        }

        // set the data the traverser operates on
        leanProductionFlowTraverser.initState();
        leanProductionFlowTraverser.parmMapProdFlow(productionFlowRelations);
        leanProductionFlowTraverser.parmKanbanType(_kanbanType);
        leanProductionFlowTraverser.parmInCrossPlanReferenceMode(crossPF);
        leanProductionFlowTraverser.parmInCheckConnectivityMode(_onlyCheckConnectivity);
        leanProductionFlowTraverser.parmInUseKanbanFlowsFromDatabaseMode(_useKanbanFlowsFromDatabase);

        // default the search to the constructor parameters
        leanProductionFlowTraverser.parmFirstPlanPlanActivity(_firstPlanPlanActivity);
        leanProductionFlowTraverser.parmLastPlanPlanActivity(_lastPlanPlanActivity);

        return leanProductionFlowTraverser;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pathExists</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether there is an existing path in the production flow between those two elements.
    /// </summary>
    /// <param name="_firstPlanPlanActivity">
    ///    The first <c>PlanPlanActivity</c> record.
    /// </param>
    /// <param name="_lastPlanPlanActivity">
    ///    The last <c>PlanPlanActivity</c> record.
    /// </param>
    /// <returns>
    ///    A collection object that has all kanban flows that have been found between the specified first and
    ///    last <c>PlanPlanActivity</c> records.
    /// </returns>
    public static boolean pathExists(
        PlanPlanActivity _firstPlanPlanActivity,
        PlanPlanActivity _lastPlanPlanActivity)
    {
        LeanProductionFlowTraverser leanProductionFlowTraverser  = LeanProductionFlowTraverser::newPlanPlanActivity(_firstPlanPlanActivity,
                                                                                                                    _lastPlanPlanActivity,
                                                                                                                    LeanKanbanType::Manufacturing, true);
        leanProductionFlowTraverser.parmInFindFirstMode(true);

        return leanProductionFlowTraverser.generateAllFlows().kanbanFlowsCount() > 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateKanbanFlow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the particular kanban flow.
    /// </summary>
    /// <param name="_kanbanFlowWrapper">
    ///    The <c>KanbanFlowWrapper</c> object that holds the memory copy of the flow.
    /// </param>
    /// <param name="_kanbanType">
    ///    The type of kanban for which to create the traverser.
    /// </param>
    /// <returns>
    ///    true if the flow is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Reuses the same logic and rules for the validation as for when all flows are generated.
    /// </remarks>
    public static boolean validateKanbanFlow(
        KanbanFlowWrapper _kanbanFlowWrapper,
        LeanKanbanType    _kanbanType)
    {
        boolean                     result = false;

        if (!_kanbanFlowWrapper)
        {
            throw error(Error::wrongUseOfFunction(funcname()));
        }

        KanbanFlow kanbanFlow = _kanbanFlowWrapper.parmKanbanFlow();

        if (   kanbanFlow.FirstPlanPlanActivity != 0
            && kanbanFlow.LastPlanPlanActivity  != 0)
        {
            // single activity flows are always valid, independent on the type
            // withdraw activities
            result =    kanbanFlow.isSingleActivityFlow()
                     && kanbanFlow.IsBridge == NoYes::No
                     && _kanbanFlowWrapper.relationsCount() == 0;

            if (result)
            {
                PlanActivity planActivity = kanbanFlow.firstPlanActivity();

                 result =    result
                          && (_kanbanType                    == LeanKanbanType::Manufacturing
                          &&  planActivity.PlanActivityType  == PlanActivityType::Process)
                          || (_kanbanType                    == LeanKanbanType::Withdrawal
                          &&  planActivity.PlanActivityType  == PlanActivityType::Transfer);
            }
            else
            {
                // get a traverser object
                LeanProductionFlowTraverser leanProductionFlowTraverser = LeanProductionFlowTraverser::newKanbanFlowWrapper(_kanbanFlowWrapper, _kanbanType);

                // set search context
                leanProductionFlowTraverser.parmFirstPlanPlanActivity(PlanPlanActivity::find(kanbanFlow.FirstPlanPlanActivity));
                leanProductionFlowTraverser.parmLastPlanPlanActivity(PlanPlanActivity::find(kanbanFlow.LastPlanPlanActivity));

                // scan all paths
                KanbanFlowsCollection kanbanFlowsCollection = leanProductionFlowTraverser.generateAllFlows();

                // if the flow was found, then it's valid
                result =    kanbanFlowsCollection != null
                         && kanbanFlowsCollection.kanbanFlowsCount() == 1;
            }
        }
        return result;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>
