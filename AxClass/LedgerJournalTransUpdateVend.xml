<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransUpdateVend</Name>
	<SourceCode>
		<Declaration><![CDATA[
class LedgerJournalTransUpdateVend extends LedgerJournalTransUpdate
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the vendor invoicing details.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The table record that holds the invoicing details.
    /// </param>
    /// <param name="_checkNoSettlement">
    ///    The Boolean value that is used to check the chance of the invoice settlement;optional.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The object that holds the ledger voucher details ;optional.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true if validations successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The method <c>checkAccountBlocked</c>(checkBlockAmount,invoiceTransDate) call is modified by adding
    ///    an optional parameter <c>invoiceTransDate</c> that represents the invoice transaction date.
    /// </remarks>
    boolean check(LedgerJournalTrans _ledgerJournalTrans,
                  boolean _checkNoSettlement = true,
                  LedgerVoucher _ledgerVoucher = null,
                  LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        VendTable vendTable;
        boolean ok;
        LedgerJournalType ledgerJournalType;
        AmountCur checkBlockAmount;
        InvoiceReleaseDate invoiceTransDate;

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;
        vendTable = VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension);
        invoiceTransDate = DateTimeUtil::newDateTime(_ledgerJournalTrans.TransDate,0);

        if (! vendTable)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS11817", _ledgerJournalTrans.parmAccount()));
            }
            else
            {
                ok = checkFailed(strFmt("@SYS11817", _ledgerJournalTrans.parmAccount()));
            }
        }
        else
        {
            ok = this.checkVoucher(_ledgerJournalTrans, _ledgerVoucher, _ledgerPostingMessageCollection);

            if (ok)
            {
                ok = this.checkDocumentDate(_ledgerJournalTrans);
            }

            ok = this.checkVendorBlocked(vendTable, _ledgerJournalTrans, invoiceTransDate, ledgerJournaltype) && ok;

            if (_ledgerJournalTrans.amount() < 0)
            {
                switch (ledgerJournalType)
                {
                    case LedgerJournalType::VendPromissoryNoteDraw,
                         LedgerJournalType::VendPromissoryNoteRedraw,
                         LedgerJournalType::VendPaymRemittance,
                         LedgerJournalType::VendPromissoryNoteSettle :
                        break;
                    default :
                        //
                        // For the credit check the _ledgerJournalTrans.AmountCurDebit or
                        // _ledgerJournalTrans.AmountCurCredit must be converted into a
                        //  "MST" amount before it can be used by the VendTable::checkCreditLimit() method.
                        //
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            ok = VendTable::checkCreditLimit(vendTable.AccountNum, VendParameters::find().CreditMaxCheck,
                                                             -_ledgerJournalTrans.calcAmountMST(),
                                                             '',
                                                             AgreementHeaderExt_RU::findByAgreementId(_ledgerJournalTrans.AccountAgreementId_RU).RecId,
                                                             _ledgerJournalTrans.TableId,
                                                             _ledgerJournalTrans.RecId) && ok;
                        }
                        else
                        {
                        // </GEERU>
                            ok = VendTable::checkCreditLimit(vendTable.AccountNum, VendParameters::find().CreditMaxCheck, -_ledgerJournalTrans.calcAmountMST()) && ok;
                        // <GEERU>
                        }
                        // </GEERU>
                }
            }
        }

        if (ok)
        {
            ok = this.checkSettleVoucher(_ledgerJournalTrans, _checkNoSettlement, _ledgerPostingMessageCollection);
            ok = this.checkCashDiscCodeAmount(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            ok = this.checkInvoice(_ledgerJournalTrans) && ok;
            ok = this.checkPrepayment(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            // <GEERU>
            ok = this.checkCurrencyDealAccounts_RU(_ledgerJournalTrans) && ok;
            // </GEERU>
            ok = super(_ledgerJournalTrans, _checkNoSettlement, _ledgerVoucher, _ledgerPostingMessageCollection) && ok;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            ok = this.checkPrepayments_W(_ledgerJournalTrans, VendParameters::find().TaxOnPrepayment) && ok;

            ok = CustVendInvoiceJour::checkCorrectionParameters_RU(_ledgerJournalTrans.CorrectedInvoiceId_RU,
                                                                   _ledgerJournalTrans.CorrectedInvoiceDate_RU,
                                                                   _ledgerJournalTrans.Correct_RU) && ok;
        }
        // </GEERU>

        if (TradeBLWIParameters::isBLWIFeatureEnabled())
        {
            ok = this.checkCentralBankPurposeCode_BE(ledgerJournalType, _ledgerJournalTrans, vendTable) && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVendorBlocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check vendor blocked.
    /// </summary>
    /// <param name = "_vendTable">The vendor.</param>
    /// <param name = "_ledgerJournalTrans">The journal line.</param>
    /// <param name = "_invoiceTransDate">The invoice transaction date.</param>
    /// <param name = "_ledgerJournalType">The ledger journal type.</param>
    /// <param name = "_custVendPaymStatus">The payment status.</param>
    /// <returns>true when the vendor is not blocked; otherwise false.</returns>
    [Replaceable]
    protected boolean checkVendorBlocked(
        VendTable _vendTable, 
        LedgerJournalTrans _ledgerJournalTrans, 
        InvoiceReleaseDate _invoiceTransDate, 
        LedgerJournalType _ledgerJournalType,
        CustVendPaymStatus _custVendPaymStatus = CustVendPaymStatus::None)
    {
        boolean ok;

        if (_ledgerJournalTrans.amount() < 0 &&
                LedgerJournalName::isNegotiableInstrumentJournal(_ledgerJournalType))
        {
            AmountCur checkBlockAmount = 0;
            ok = _vendTable.checkAccountBlocked(checkBlockAmount, _invoiceTransDate, _ledgerJournalType, _custVendPaymStatus);
        }
        else
        {
            ok = _vendTable.checkAccountBlocked(_ledgerJournalTrans.amount(), _invoiceTransDate, _ledgerJournalType, _custVendPaymStatus);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCustomsNumber_IT</Name>
				<Source><![CDATA[
    private boolean checkCustomsNumber_IT(LedgerJournalTrans _ledgerJournalTrans)
    {
        VendInvoiceJour vendInvoiceJour;
        TransDate       foundDate;
        Amount          invoiceAmount;
        Amount          sumTax;

        if (!_ledgerJournalTrans.Invoice)
        {
            return true;
        }

        if (VendParameters::find().CheckInvoice == ReuseVoucher::NoDuplicate)
        {
            while select firstonly InvoiceDate, InvoiceAmount, SumTax from vendInvoiceJour
            where vendInvoiceJour.InvoiceAccount    == _ledgerJournalTrans.parmAccount()
                &&  vendInvoiceJour.InvoiceId         == _ledgerJournalTrans.Invoice
                && (vendInvoiceJour.InvoiceAmount     != 0
                ||  vendInvoiceJour.SumTax            != 0)
            {
                invoiceAmount   += vendInvoiceJour.InvoiceAmount;
                sumTax          += vendInvoiceJour.SumTax;
                if (!foundDate)
                {
                    foundDate = vendInvoiceJour.InvoiceDate;
                }
            }
        
            if (invoiceAmount || sumTax)
            {
                return checkFailed(strfmt("@SYS50887", _ledgerJournalTrans.Invoice, foundDate));
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCentralBankPurposeCode_BE</Name>
				<Source><![CDATA[
    private boolean checkCentralBankPurposeCode_BE(LedgerJournalType _ledgerJournalType, LedgerJournalTrans _ledgerJournalTrans, VendTable _vendTable)
    {
        boolean ret = true;

        if (_ledgerJournalType == LedgerJournalType::Daily ||
        _ledgerJournalType == LedgerJournalType::VendInvoiceRegister ||
        _ledgerJournalType == LedgerJournalType::PurchaseLedger)
        {
            ret = TradeBLWIParameters::checkBLWI(_ledgerJournalTrans.RecId, TradeBLWITypeOfForm::LedgerJournalTrans, _vendTable);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentStatusNotEqualToSent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the payment status for the given <c>LedgerJournalTrans</c> record is not equal to Sent.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record.</param>
    /// <returns>true if the payment status value is not equal to Sent; otherwise, false.</returns>
    protected boolean isPaymentStatusNotEqualToSent(LedgerJournalTrans _ledgerJournalTrans)
    {
        return _ledgerJournalTrans.PaymentStatus != CustVendPaymStatus::Sent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCurrencyDealAccounts_RU</Name>
				<Source><![CDATA[
    protected boolean checkCurrencyDealAccounts_RU(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        BankGroup bankGroup;
        BankCurrencyTransferLog_RU currencyTransferLog;

        boolean ret = true;
        BankTransType bankTransType;
        CurrencyCode transferCurrency, standardCurrency = CompanyInfoHelper::standardCurrency();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            _ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Payment &&
            _ledgerJournalTrans.BankTransType &&
            _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank)
        {
            bankTransType = BankTransType::find(_ledgerJournalTrans.BankTransType);
            transferCurrency = _ledgerJournalTrans.TransferCurrency_RU;

            if (_ledgerJournalTrans.BankCurrencyTransferLog_RU)
            {
                currencyTransferLog = BankCurrencyTransferLog_RU::find(_ledgerJournalTrans.BankCurrencyTransferLog_RU);
                transferCurrency = currencyTransferLog.TransferCurrency ? currencyTransferLog.TransferCurrency :
                                                                            _ledgerJournalTrans.TransferCurrency_RU;
            }

            if (bankTransType.BankAdvancedTransType_RU == BankAdvancedTransType_RU::CurrSell ||
                bankTransType.BankAdvancedTransType_RU == BankAdvancedTransType_RU::CurrBuy)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceRU00034, funcName());

                if (_ledgerJournalTrans.amount() > 0)
                {
                    if (this.isPaymentStatusNotEqualToSent(_ledgerJournalTrans))
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS114410", "@SYS8205"));
                        }
                        else
                        {
                            ret = checkFailed(strFmt("@GLS114410", "@SYS8205"));
                        }
                    }

                    if (! _ledgerJournalTrans.BankCurrencyTransferLog_RU)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS107196", fieldId2pname(tableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, BankCurrencyTransferLog_RU))));
                        }
                        else
                        {
                            ret = checkFailed(strFmt("@GLS107196", fieldId2pname(tableNum(LedgerJournalTrans), fieldNum(LedgerJournalTrans, BankCurrencyTransferLog_RU))));
                        }
                    }

                    bankGroup = BankGroup::find(BankAccountTable::find(_ledgerJournalTrans.parmOffsetAccount()).BankGroupId);

                    if (_ledgerJournalTrans.parmAccount() != bankGroup.VendAccountNum_RU)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ret = _ledgerPostingMessageCollection.logCheckFailed("@GLS114411");
                        }
                        else
                        {
                            ret = checkFailed("@GLS114411");
                        }
                    }
                }

                if (_ledgerJournalTrans.amount() < 0 && ! _ledgerJournalTrans.BankCurrencyTransferLog_RU)
                {
                    if (bankTransType.BankAdvancedTransType_RU == BankAdvancedTransType_RU::CurrSell)
                    {
                        if (_ledgerJournalTrans.CurrencyCode != standardCurrency)
                        {
                            if (_ledgerPostingMessageCollection)
                            {
                                ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS114412", standardCurrency));
                            }
                            else
                            {
                                ret = checkFailed(strFmt("@GLS114412", standardCurrency));
                            }
                        }

                        if (transferCurrency ==standardCurrency)
                        {
                            if (_ledgerPostingMessageCollection)
                            {
                                ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS114413", standardCurrency));
                            }
                            else
                            {
                                ret = checkFailed(strFmt("@GLS114413", standardCurrency));
                            }
                        }
                    }
                    else
                    {
                        if (_ledgerJournalTrans.CurrencyCode == standardCurrency)
                        {
                            if (_ledgerPostingMessageCollection)
                            {
                                ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS114414", standardCurrency));
                            }
                            else
                            {
                                ret = checkFailed(strFmt("@GLS114414", standardCurrency));
                            }
                        }

                        if (transferCurrency != standardCurrency)
                        {
                            if (_ledgerPostingMessageCollection)
                            {
                                ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS114415", standardCurrency));
                            }
                            else
                            {
                                ret = checkFailed(strFmt("@GLS114415", standardCurrency));
                            }
                        }
                    }

                    if (! _ledgerJournalTrans.BankCurrencyDealCourse_RU)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ret = _ledgerPostingMessageCollection.logCheckFailed("@GLS114416");
                        }
                        else
                        {
                            ret = checkFailed("@GLS114416");
                        }
                    }

                    if (!transferCurrency)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ret = _ledgerPostingMessageCollection.logCheckFailed("@GLS114417");
                        }
                        else
                        {
                            ret = checkFailed("@GLS114417");
                        }
                    }
                }
            }
            else if (bankTransType.BankAdvancedTransType_RU == BankAdvancedTransType_RU::CurrTransfer)
            {
                if (_ledgerJournalTrans.CurrencyCode != transferCurrency)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ret = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@GLS114415", _ledgerJournalTrans.CurrencyCode));
                    }
                    else
                    {
                        ret = checkFailed(strFmt("@GLS114415", _ledgerJournalTrans.CurrencyCode));
                    }
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDocumentDate</Name>
				<Source><![CDATA[
    boolean checkDocumentDate(LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ok = true;

        if ((_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::VendInvoiceRegister) ||
            (_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::PurchaseLedger) ||
            ((_ledgerJournalTrans.ledgerJournalTable().JournalType == LedgerJournalType::Daily && _ledgerJournalTrans.Invoice)))
        {
            ok = VendParameters::checkDocumentDate(_ledgerJournalTrans.TransDate, _ledgerJournalTrans.DocumentDate);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoice</Name>
				<Source><![CDATA[
    boolean checkInvoice(LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GTH>
        boolean ret;
        VendTable vendTable;
        // </GTH>

        switch (_ledgerJournalTrans.ledgerJournalTable().JournalType)
        {
            case LedgerJournalType::Approval:
            case LedgerJournalType::VendPaymRemittance:
            case LedgerJournalType::VendPromissoryNoteSettle:
                return true;
            case LedgerJournalType::CustomsDeclaration_IT:
                return this.checkCustomsNumber_IT(_ledgerJournalTrans);
        }

        vendTable = VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN().TaxWithholdCode != '')
        {
            ret = true;
        }
        else
        {
            ret = vendTable.checkInvoice(_ledgerJournalTrans.Invoice, _ledgerJournalTrans.TransDate);
        }

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled())
        {
            ret = vendTable.checkTaxInvoice(_ledgerJournalTrans.DocumentNum, _ledgerJournalTrans.DocumentDate)
                && ret;
        }
        // <GTH>

        if (ret && !FeatureStateProvider::isFeatureEnabled(VendInvoiceExtendInvoiceIdFeature::instance()) && strLen(_ledgerJournalTrans.Invoice) > 20)
        {
            ret = checkFailed(strFmt("@AccountsPayable:VendInvoiceWithLongNumFail", _ledgerJournalTrans.Invoice));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkJournalsTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the ledger journal transactions for one voucher number and several transaction dates.
    /// </summary>
    /// <param name="_ledgerJournalType">
    ///    The type of a journal in the <c>LedgerJournalTable</c> table.
    /// </param>
    /// <param name="_ledgerJournalName">
    ///    The name of a journal in the <c>LedgerJournalTable</c> table.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher of a <c>ledgerJournalTrans</c> record.
    /// </param>
    /// <param name="_tranDate">
    ///    The transaction date of a <c>ledgerJournalTrans</c> record.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true if validation passes; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This method is specific to the validation of ledger journal transactions. It is only used when the
    ///    parameter validations on promissory notes journals are marked in the vendor parameters form.
    /// </remarks>
    public boolean checkJournalsTransDate(
        LedgerJournalType _ledgerJournalType,
        LedgerJournalNameId _ledgerJournalName,
        Voucher _voucher,
        TransDate _transDate,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        LedgerJournalTrans ledgerJournalTrans;

        if (VendParameters::find().NotesJournalsValidations
            && LedgerJournalName::find(_ledgerJournalName).NewVoucher == NewVoucher::OneVoucher
            && (_ledgerJournalType == LedgerJournalType::VendPromissoryNoteDraw
            || _ledgerJournalType == LedgerJournalType::VendPromissoryNoteRedraw
            || _ledgerJournalType == LedgerJournalType::VendPaymRemittance
            || _ledgerJournalType == LedgerJournalType::Payment))
        {
            select firstonly RecId from ledgerJournalTrans
                where ledgerJournalTrans.Voucher == _voucher
                   && ledgerJournalTrans.TransDate != _transDate;

            if (ledgerJournalTrans)
            {
                if (_ledgerPostingMessageCollection)
                {
                    _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS116346", _voucher));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS116346", _voucher));
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymStatus</Name>
				<Source><![CDATA[
    public boolean checkPaymStatus(LedgerJournalType _ledgerJournalType,
                                    LedgerJournalTrans _ledgerJournalTrans,
                                    LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;
        CustVendPaymStatus paymStatus;
        SelectableDataArea journalTransCompany = _ledgerJournalTrans.company();

        if ((_ledgerJournalType == LedgerJournalType::Payment ||
             _ledgerJournalType == LedgerJournalType::VendPromissoryNoteDraw ||
             _ledgerJournalType == LedgerJournalType::VendPaymRemittance ||
             _ledgerJournalType == LedgerJournalType::PayrollDisbursement) &&
             _ledgerJournalTrans.PaymMode)
        {
            changecompany (journalTransCompany)
            {
                paymStatus = CustVendPaymModeTable::findCommon(_ledgerJournalTrans).PaymStatus;
            }

            if (_ledgerJournalType == LedgerJournalType::VendPaymRemittance && this.isPaymentStatusOfNone(_ledgerJournalTrans, paymStatus))
            {
                ok = false;

                if (_ledgerPostingMessageCollection)
                {
                    _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                        _ledgerJournalTrans.PaymentStatus,
                        CustVendPaymStatus::Sent));
                }
                else
                {
                    checkFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                        _ledgerJournalTrans.PaymentStatus,
                        CustVendPaymStatus::Sent));
                }
            }
            else
            {
                changecompany (journalTransCompany)
                {
                    ok = CustVendPaym::checkPaymStatus(ModuleCustVend::Vend, _ledgerJournalTrans.PaymMode, _ledgerJournalTrans.PaymentStatus);
                }

                if (!ok)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                            _ledgerJournalTrans.PaymentStatus,
                            paymStatus));
                    }
                    else
                    {
                        checkFailed(strFmt("@SYS66070", LedgerJournalTrans::findTmpVoucher(_ledgerJournalTrans.Voucher, tmpVoucherMap),
                            _ledgerJournalTrans.PaymentStatus,
                            paymStatus));
                    }
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrepayment</Name>
				<Source><![CDATA[
    boolean checkPrepayment(LedgerJournalTrans _ledgerJournalTrans, LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        boolean ok = true;

        if (_ledgerJournalTrans.Prepayment &&
         // <GEERU>
            VendParameters::find().TaxOnPrepayment
            && ! VendTable::find(_ledgerJournalTrans.parmAccount()).vatTaxAgent_RU)
         // </GEERU>
        {
            if (!_ledgerJournalTrans.ledgerJournalTable().LedgerJournalInclTax)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS98399");
                }
                else
                {
                    ok = checkFailed("@SYS98399");
                }
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettleVoucher</Name>
				<Source><![CDATA[
    public boolean checkSettleVoucher(
        LedgerJournalTrans _ledgerJournalTrans,
        boolean _checkNoSettlement = true,
        LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        SpecTransManager specTransManager;
        VendTable journalTransVendor;
        SpecTrans specTrans;
        VendTrans vendTrans;
        VendTransOpen vendTransOpen;
        VendTable vendTransVendor;
        AmountCur totalMarkedAmount;
        LedgerJournalType ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;
        ExchangeRateHelper exchangeRateHelper;

        // Initialize the SpecTransManager for the journal transaction
        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        if (_ledgerJournalTrans.SettleVoucher == SettlementType::None && _checkNoSettlement)
        {
            // Journal transaction is designated as having no marked transactions
            if (specTransManager.getSpecTransCount() > 0)
            {
                // There is a mismatch between the transactions marked and journal transaction setting
                if (_ledgerPostingMessageCollection)
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS55515", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
                else
                {
                    return checkFailed(strFmt("@SYS55515", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
            }
        }
        else if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
        {
            // Journal transaction is designated as having marked transactions
            if (specTransManager.getSpecTransCount() <= 0)
            {
                // There is a mismatch between the transactions marked and journal transaction setting
                if (_ledgerPostingMessageCollection)
                {
                    return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS55512", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
                else
                {
                    return checkFailed(strFmt("@SYS55512", _ledgerJournalTrans.parmAccount(), _ledgerJournalTrans.Voucher));
                }
            }
        }

        if (_ledgerJournalTrans.SettleVoucher != SettlementType::None &&
            (ledgerJournalType != LedgerJournalType::VendPromissoryNoteRedraw &&
             ledgerJournalType != LedgerJournalType::BankChequeReversal))
        {
            // Get the vendor from the journal transaction to compare with the customer from the marked transaction
            changecompany(_ledgerJournalTrans.Company)
            {
                journalTransVendor = VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension);
            }

            // Validate the individual marked transactions
            while select crossCompany RecId from specTrans
                where specTrans.SpecCompany == _ledgerJournalTrans.company() &&
                    specTrans.SpecTableId == _ledgerJournalTrans.TableId &&
                    specTrans.SpecRecId == _ledgerJournalTrans.RecId
                join RecId from vendTransOpen
                    where specTrans.RefCompany == vendTransOpen.DataAreaId &&
                        specTrans.RefTableId == vendTransOpen.TableId &&
                        specTrans.RefRecId == vendTransOpen.RecId
                join RecId, AccountNum, Voucher, Approved, Closed from vendTrans
                    where vendTransOpen.RefRecId == vendTrans.RecId
                join Party from vendTransVendor
                    where vendTrans.AccountNum == vendTransVendor.AccountNum
            {
                if (vendTrans.RecId == 0)
                {
                    // If no VendTrans was found for the SpecTrans
                    if (_ledgerPostingMessageCollection)
                    {
                        return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                    }
                    else
                    {
                        return checkFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                    }
                }
                else
                {
                    if (vendTrans.AccountNum != _ledgerJournalTrans.parmAccount() &&
                        !isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvInterCompanyAccounting)))
                    {
                        // The account numbers for the VendTrans and LedgerJournalTrans don't match & intercompany accounting is not enabled
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS19285", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                        }
                    }

                    if (journalTransVendor.Party != vendTransVendor.Party)
                    {
                        // The vendors do no share the same PartyId
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS115976",
                                _ledgerJournalTrans.parmAccount(),
                                _ledgerJournalTrans.Company,
                                vendTrans.AccountNum,
                                vendTrans.company()));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS115976",
                                _ledgerJournalTrans.parmAccount(),
                                _ledgerJournalTrans.Company,
                                vendTrans.AccountNum,
                                vendTrans.company()));
                        }
                    }

                    if (!vendTrans.Approved)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed (strFmt("@SYS18654", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                        }
                        else
                        {
                            return checkFailed (strFmt("@SYS18654", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                        }
                    }

                    if (vendTrans.Closed)
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS18655", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                        }
                        else
                        {
                            return checkFailed(strFmt("@SYS18655", _ledgerJournalTrans.parmAccount(), vendTrans.Voucher));
                        }
                    }
                }
            }

            // Validate the marked transactions overall
            if (ledgerJournalType == LedgerJournalType::VendPaymRemittance && specTransManager.getSpecTransCount() > 0)
            {
                exchangeRateHelper = ExchangeRateHelper::newCurrency(Ledger::primaryLedger(CompanyInfo::findDataArea(_ledgerJournalTrans.Company).RecId), _ledgerJournalTrans.CurrencyCode);

                // Get the total amount of the transactions marked for this journal transaction
                totalMarkedAmount = SpecTransManager::getTotalSettleAmountForSpecReference(
                                        _ledgerJournalTrans.company(),
                                        _ledgerJournalTrans.TableId,
                                        _ledgerJournalTrans.RecId,
                                        _ledgerJournalTrans.CurrencyCode,
                                        _ledgerJournalTrans.Company,
                                        _ledgerJournalTrans.TransDate,
                                        exchangeRateHelper.prepareExchangeRateForStorage(_ledgerJournalTrans.crossrate()));

                if ( _ledgerJournalTrans.amount() != -totalMarkedAmount)
                {
                    // The journal transaction must fully settle all the marked transactions
                    if (_ledgerPostingMessageCollection)
                    {
                        return _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS73854", ledgerJournalType));
                    }
                    else
                    {
                        return checkFailed(strFmt("@SYS73854", ledgerJournalType));
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVoucher</Name>
				<Source><![CDATA[
    boolean checkVoucher(LedgerJournalTrans _ledgerJournalTrans,
                         LedgerVoucher _ledgerVoucher = null,
                         LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        #EECountryRegionCodes

        LedgerJournalType ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;

        boolean ok = true;
        boolean allok = true;
        boolean checkApprover = ledgerJournalType == LedgerJournalType::Cost ||
                                ledgerJournalType == LedgerJournalType::VendInvoiceRegister ||
                                (ledgerJournalType == LedgerJournalType::PurchaseLedger
                                && !FeatureStateProvider::isFeatureEnabled(VendorInvoiceRegisterApprovedFeature::instance()))
                                || (ledgerJournalType == LedgerJournalType::PurchaseLedger
                                && VendParameters::find().VendorInvoiceRegisterApproved == VendorInvoiceRegisterApproved::RequiredApprover);

        if (checkApprover)
        {
            if (!_ledgerJournalTrans.Approver)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed ("@SYS74484");
                }
                else
                {
                    ok = checkFailed ("@SYS74484");
                }

                allok = false;
            }
        }

        if (ledgerJournalType == LedgerJournalType::Cost ||
            this.isLedgerJournalTypeAnInvoiceType(ledgerJournalType))
        {
            if (!_ledgerJournalTrans.Invoice)
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed ("@SYS24539");
                }
                else
                {
                    ok = checkFailed ("@SYS24539");
                }

                allok = false;
            }
        }

        if (this.isLedgerJournalTypeAnInvoiceType(ledgerJournalType))
        {
            if (!LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).summaryLedgerDimension(_ledgerJournalTrans.PostingProfile)))
            {
                if (_ledgerPostingMessageCollection)
                {
                    ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS17167",
                        LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).summaryLedgerDimension(_ledgerJournalTrans.PostingProfile)).MainAccountId));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS17167",
                        LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).summaryLedgerDimension(_ledgerJournalTrans.PostingProfile)).MainAccountId));
                }

                allok = false;
            }
            if (ledgerJournalType != LedgerJournalType::VendInvoiceRegister)
            {
                if (!LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).purchLedgerDimension(_ledgerJournalTrans.PostingProfile)).MainAccountId)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS17167", LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).purchLedgerDimension(_ledgerJournalTrans.PostingProfile)).MainAccountId));
                    }
                    else
                    {
                        ok = checkFailed(strFmt("@SYS17167", LedgerDimensionFacade::getMainAccountFromLedgerDimension(VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).purchLedgerDimension(_ledgerJournalTrans.PostingProfile)).MainAccountId));
                    }

                    allok = false;
                }
            }

            if (_ledgerJournalTrans.Payment && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
            {
                PaymTerm paymTerm = PaymTerm::find(_ledgerJournalTrans.Payment);
                if (paymTerm.UseDeliveryDateForDueDate_ES && !_ledgerJournalTrans.LedgerJournalDlvDate_ES)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed(strfmt("@SYS4000479", paymTerm.PaymTermId));
                    }
                    else
                    {
                        ok = checkFailed(strfmt("@SYS4000479", paymTerm.PaymTermId));
                    }

                    allok = false;
                }
                else
                {
                    TransDate deliveryDate = paymTerm.UseDeliveryDateForDueDate_ES ? _ledgerJournalTrans.LedgerJournalDlvDate_ES : _ledgerJournalTrans.TransDate;
                    if (_ledgerJournalTrans.Due > PaymDueDateLimit_ES::getCurrentValues(paymTerm.DueDateLimitGroupId_ES).getLastValidDate(deliveryDate))
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS4001058");
                        }
                        else
                        {
                            ok = checkFailed("@SYS4001058");
                        }

                        allok = false;
                    }
                }
            }
        }

        //
        //  The following rule should only be applied when the invoice number field contains a value.
        //  When "Vendor" type is used on any Ledger Journal Transaction it can only
        //  exist once per "Voucher" series.
        //
        //  Since a "Vendor" type can be applied to either the primary or offset side
        //  of a transaction. This is both a qualifying factor and additional data to be
        //  validated. Although this only applies to "Daily" (GL) based journals it
        //  should not affect this validation.
        //
        //  The exclusion of the "Fee" type transaction allows for an
        //  LedgerTransType::Fee transaction for a vendor to be posted inside
        //  the same voucher grouping.
        //

        if (LedgerParameters::find().AllowMultipleTransactionsWithinOneVoucher == NoYes::Yes &&
            _ledgerJournalTrans.Invoice
            // <GEEU>
            // SAD document may require multiple vendor postings in same voucher
            && !PlSADFinanceLedgerJournalRef::existsJournal(_ledgerJournalTrans.RecId)
            // </GEEU>
            )
        {
            // Company context for this validation must the journal's company ID.
            changecompany(_ledgerJournalTrans.company())
            {
                LedgerJournalTrans ledgerJournalTrans;
                ledgerJournalTrans.selectLocked(false);
                select
                    count(RecId)
                from
                    ledgerJournalTrans
                where
                    ledgerJournalTrans.Voucher == _ledgerJournalTrans.Voucher &&
                    ledgerJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum &&
                    ledgerJournalTrans.TransactionType != LedgerTransType::Fee &&
                    (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend ||
                    (ledgerJournalTrans.OffsetLedgerDimension != 0 &&
                     ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend));

                if (ledgerJournalTrans.RecId > 1)
                {
                    if (_ledgerPostingMessageCollection)
                    {
                        ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS29116");
                    }
                    else
                    {
                        ok = checkFailed("@SYS29116");
                    }

                    allok = false;
                }
            }
        }

        if (ledgerJournalType == LedgerJournalType::CustomsDeclaration_IT)
        {
            if (!_ledgerJournalTrans.Invoice)
            {
                ok = checkFailed("@CustomsDocumentsIT:CD_JournalError_LedgerJournalTrans_InvoiceIsEmpty");
                allok = false;
            }

            LedgerJournalTable_Customs_IT customsTable = _ledgerJournalTrans.ledgerJournalTable().ledgerJournalTable_Customs_IT();
            VendAccount vendAccount = customsTable.CustomsDebt == CustomsDebt_IT::Customs ? customsTable.CustomsId : customsTable.ShipperId;

            if (_ledgerJournalTrans.parmAccount() != vendAccount)
            {
                ok = checkFailed(strFmt("@CustomsDocumentsIT:CD_JournalError_LedgerJournalTrans_ParmAccountWrongAccount", vendAccount));
                allok = false;
            }
        }

        if (!ok)
        {
            allok = false;
        }

        if (_ledgerJournalTrans.amount() < 0)
        {
            if (_ledgerJournalTrans.CashDiscAmount > 0)
            {
                if (_ledgerPostingMessageCollection)
                {
                    allok = _ledgerPostingMessageCollection.logCheckFailed("@SYS28756");
                }
                else
                {
                    allok = checkFailed("@SYS28756");
                }
            }
        }
        if (_ledgerJournalTrans.amount() > 0)
        {
            if (_ledgerJournalTrans.CashDiscAmount < 0)
            {
                if (_ledgerPostingMessageCollection)
                {
                    allok = _ledgerPostingMessageCollection.logCheckFailed("@SYS28756");
                }
                else
                {
                    allok = checkFailed("@SYS28756");
                }
            }
        }

        return allok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLedgerJournalTypeAnInvoiceType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>LedgerJournalType</c> enumeration value is a type of a vendor invoice.
    /// </summary>
    /// <param name = "_ledgerJournalType">
    /// The Ledger journal type.
    /// </param>
    /// <returns>
    /// Returns true if the <c>LedgerJournalType</c> enumeration value is a type of a vendor invoice; otherwise, false.
    /// </returns>
    protected boolean isLedgerJournalTypeAnInvoiceType(LedgerJournalType _ledgerJournalType)
    {
        return (_ledgerJournalType == LedgerJournalType::PurchaseLedger ||
                _ledgerJournalType == LedgerJournalType::VendInvoiceRegister);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWhenPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the vendor invoice before posting to Journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The table record holds the invoicing details.
    /// </param>
    /// <param name="_originalLedgerJournalTrans">
    ///    The unmodified table record holds the invoicing details.
    /// </param>
    /// <param name="_checkNoSettlement">
    ///    The boolean value that is used for checking chance of the invoice settlement;optional.
    /// </param>
    /// <param name="_ledgerPostingMessageCollection">
    ///    The posting messages collection; optional.
    /// </param>
    /// <returns>
    ///    true if validations successful; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The call to checkAccountBlocked(_ledgerJournalTrans.amount(),invoiceTransDate) also incorporates
    ///    the invoice transaction date to check the vendor on hold by comparing with release date
    /// </remarks>
    boolean checkWhenPost(LedgerJournalTrans _ledgerJournalTrans,
                          LedgerJournalTrans _originalLedgerJournalTrans,
                          boolean _checkNoSettlement = true,
                          LedgerPostingMessageLog _ledgerPostingMessageCollection = null)
    {
        VendTable vendTableFieldList;
        boolean ok;
        LedgerJournalTable ledgerJournalTable;
        boolean checkNoSettlement = _checkNoSettlement;
        AmountCur checkBlockAmount;
        InvoiceReleaseDate invoiceTransDate;

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        invoiceTransDate = DateTimeUtil::newDateTime(_ledgerJournalTrans.TransDate,0);

        select firstonly AccountNum, Blocked from vendTableFieldList
            where vendTableFieldList.AccountNum == _ledgerJournalTrans.parmAccount();

        if (! vendTableFieldList)
        {
            if (_ledgerPostingMessageCollection)
            {
                ok = _ledgerPostingMessageCollection.logCheckFailed(strFmt("@SYS11817", _ledgerJournalTrans.parmAccount()));
            }
            else
            {
                ok = checkFailed(strFmt("@SYS11817", _ledgerJournalTrans.parmAccount()));
            }
        }
        else
        {
            ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
            ok = this.checkVoucher(_ledgerJournalTrans, null, _ledgerPostingMessageCollection);

            if (ok)
            {
                ok = this.checkDocumentDate(_ledgerJournalTrans);
            }

            ok = this.checkVendorBlocked(vendTableFieldList, _ledgerJournalTrans, invoiceTransDate, ledgerJournalTable.JournalType, _ledgerJournalTrans.PaymentStatus) && ok;

            if (_ledgerJournalTrans.amount() < 0)
            {
                switch (ledgerJournalTable.JournalType)
                {
                    case LedgerJournalType::VendPromissoryNoteDraw,
                         LedgerJournalType::VendPromissoryNoteRedraw,
                         LedgerJournalType::VendPaymRemittance,
                         LedgerJournalType::VendPromissoryNoteSettle :
                        break;

                    default :
                        //
                        // For the credit check the _ledgerJournalTrans.AmountCurDebit or
                        // _ledgerJournalTrans.AmountCurCredit must be converted into a
                        //  "MST" amount before it can be used by the VendTable::checkCreditLimit() method.
                        //
                        // <GEERU>
                        if (countryRegion_RU)
                        {
                            ok = VendTable::checkCreditLimit(vendTableFieldList.AccountNum, VendParameters::find().CreditMaxCheck, -_ledgerJournalTrans.calcAmountMST(),'',
                                                             AgreementHeaderExt_RU::findByAgreementId(_ledgerJournalTrans.AccountAgreementId_RU).RecId,
                                                             _ledgerJournalTrans.TableId,_ledgerJournalTrans.RecId) && ok;
                        }
                        else
                        {
                        // </GEERU>
                            ok = VendTable::checkCreditLimit(vendTableFieldList.AccountNum, VendParameters::find().CreditMaxCheck, -_ledgerJournalTrans.calcAmountMST()) && ok;
                        // <GEERU>
                        }
                        // </GEERU>
                }
            }
        }

        ok = this.checkPaymStatus(ledgerJournalTable.JournalType, _ledgerJournalTrans) && ok;

        if (ok)
        {
            if (ledgerJournalTable.JournalType == LedgerJournalType::VendPromissoryNoteRedraw &&
                ledgerJournalTable.ProtestSettledBill == NoYes::Yes)
            {
                checkNoSettlement = false;
            }

            ok = this.checkSettleVoucher(_ledgerJournalTrans, checkNoSettlement, _ledgerPostingMessageCollection);
            ok = this.checkCashDiscCodeAmount(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            ok = this.checkPaymStatus(ledgerJournalTable.JournalType, _ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            ok = this.checkInvoice(_ledgerJournalTrans) && ok;
            ok = this.checkTaxGroupsCompleteness(ledgerJournalTable.JournalType, _ledgerJournalTrans) && ok;

            // <GEERU>
            ok = this.checkCurrencyDealAccounts_RU(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
            // </GEERU>
            // We only need to check for the existence of the pool invoice in the company the ledger originated in.
            // This can be either the _ledgerJournalTrans.Company or OffsetCompany value so we cannot rely
            // on their setting. If the OriginalCompany value is not set then this is the ledger entry for the
            // company the ledger originated in. We want to test then using the dataAreaId which is the company
            // the pool transaction would have originated in.
            // We do not need to check for the ledger being posted to the other company since that would be redundant.
            if (!ledgerJournalTable.OriginalCompany)
            {
                changecompany(_ledgerJournalTrans.DataAreaId ? _ledgerJournalTrans.company() : curext())
                {
                    if (_ledgerJournalTrans.PoolRecId != 0 &&
                        !LedgerJournalTrans::findRecId(_ledgerJournalTrans.PoolRecId, false))
                    {
                        if (_ledgerPostingMessageCollection)
                        {
                            ok = _ledgerPostingMessageCollection.logCheckFailed("@SYS58988") && ok;
                        }
                        else
                        {
                            ok = checkFailed("@SYS58988") && ok;
                        }
                    }
                }
            }
            ok = super(_ledgerJournalTrans, _originalLedgerJournalTrans, checkNoSettlement, _ledgerPostingMessageCollection) && ok;
        }

        ok = ok && this.checkJournalsTransDate(ledgerJournalTable.JournalType, _ledgerJournalTrans.ledgerJournalTable().JournalName, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate, _ledgerPostingMessageCollection);

        // <GEERU>
        if (countryRegion_RU)
        {
            ok = this.checkPrepayments_W(_ledgerJournalTrans, VendParameters::find().TaxOnPrepayment) && ok;
        }
        // </GEERU>

        if (TradeBLWIParameters::isBLWIFeatureEnabled())
        {
            ok = this.checkCentralBankPurposeCode_BE(ledgerJournalTable.JournalType, _ledgerJournalTrans, VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension)) && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxGroupsCompleteness</Name>
				<Source><![CDATA[
    protected boolean checkTaxGroupsCompleteness(LedgerJournalType _ledgerJournalType, LedgerJournalTrans _ledgerJournalTrans)
    {
        boolean ret = true;

        if (_ledgerJournalType == LedgerJournalType::VendInvoiceRegister && VendParameters::find().ValidateTaxGroupCompleteness)
        {
            ret = TaxGroupData::validateTaxGroupsCompleteness(_ledgerJournalTrans.TaxGroup, _ledgerJournalTrans.TaxItemGroup);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chequeReversalUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the steps that are required to reverse a check for a vendor.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is used during the reversal.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for which to reverse transactions.
    /// </param>
    protected void chequeReversalUpdate(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher)
    {
        VendTrans vendTransLocal;
        // <GIN>
        TaxWithholdReversePost_IN taxWithholdReversePost;
        LedgerJournalTable ledgerJournalTableloc;
        LedgerJournalTrans ledgerJournalTransOrig;
        TaxAmountCur taxWithholdAmountCurInterCompany;
        // </GIN>

        select firstonly forupdate vendTransLocal
            where vendTransLocal.RecId == _ledgerJournalTrans.BankChequeDepositTransRefRecID;

        Debug::assert(vendTransLocal.RecId != 0);

        vendTransLocal.ReasonRefRecId = ReasonTableRef::checkCreateInCompany( _ledgerJournalTrans.ReasonRefRecID, vendTransLocal.DataAreaId);
        vendTransLocal.update();

        LedgerJournalTrans::revertBankChequeNum(vendTransLocal.TransDate, vendTransLocal.Voucher, _ledgerJournalTrans.BankChequeNum, _ledgerJournalTrans.JournalNum);
        this.reverseTaxWithhold(vendTransLocal, _ledgerVoucher, _ledgerJournalTrans.TransDate);

        this.reverseSettlement(_ledgerJournalTrans, _ledgerVoucher);
        this.setupClosingSettlement(_ledgerJournalTrans, vendTransLocal);

        // <GIN>
        // Execute only for cross company transaction.
        if (TaxWithholdParameters_IN::checkTaxParameters() && BankParameters::checkParameters_IN()
            && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
        {
            ledgerJournalTableloc = _ledgerJournalTrans.ledgerJournalTable();
            taxWithholdReversePost = new TaxWithholdReversePost_IN(_ledgerJournalTrans.Voucher,
                                                                    _ledgerJournalTrans.DocumentDate,
                                                                    _ledgerJournalTrans.Txt,
                                                                    ledgerJournalTableloc.TableId,
                                                                    ledgerJournalTableloc.RecId);

            taxWithholdReversePost.setReverseTableId(_ledgerJournalTrans.TableId);
            taxWithholdReversePost.setReverseRecId(_ledgerJournalTrans.RecId);
            taxWithholdReversePost.setSource(TaxModuleType::Voucher);

            select firstOnly ledgerJournalTransOrig
                where ledgerJournalTransOrig.Voucher == vendTransLocal.Voucher
                   && ledgerJournalTransOrig.TransDate == vendTransLocal.TransDate;

            taxWithholdAmountCurInterCompany = taxWithholdReversePost.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher),
                                                    vendTransLocal.Voucher,
                                                    _ledgerJournalTrans.DocumentDate);

            if (ledgerJournalTransOrig.ledgerJournalTransTaxExtensionIN().TDSGroup)
            {
                _ledgerVoucher.parmAdvancePaymentWHT_IN(taxWithholdAmountCurInterCompany);
            }
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherForTaxAgent_RU</Name>
				<Source><![CDATA[
    private void createLedgerVoucherForTaxAgent_RU(LedgerJournalTrans _ledgerJournalTrans,
                                                   LedgerVoucher _ledgerVoucher)
    {
        TaxLedgerAccountGroup taxLedgerAccountGroup;

        void createVouchers(LedgerDimensionDefaultAccount _defaultAccount,
                            LedgerDimensionDefaultAccount _offsetDefaultAccount,
                            AmountCur _amountCur)
        {
            LedgerBondClient_RU ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
            LedgerVoucherTransObject ledgerVoucherTransObject;
            CurrencyExchangeHelper currencyExchHelper;

            if (ledgerBondClient)
            {
                ledgerBondClient.addNewLogObject();
            }
            currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _ledgerJournalTrans.TransDate);
            currencyExchHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
            currencyExchHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
            currencyExchHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
            currencyExchHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                _ledgerVoucher.findLedgerVoucherObject(),
                LedgerPostingType::Tax,
                this.mergeLedgerDimensionAndDefaultDimension(_defaultAccount, _ledgerJournalTrans.DefaultDimension),
                _ledgerJournalTrans.CurrencyCode,
                _amountCur,
                currencyExchHelper);

            ledgerVoucherTransObject.parmUseTaxParentTaxUncommitted(taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Source);
            ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
            ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                 _ledgerVoucher.findLedgerVoucherObject(),
                 LedgerPostingType::Tax,
                 this.mergeLedgerDimensionAndDefaultDimension(_offsetDefaultAccount, _ledgerJournalTrans.DefaultDimension),
                 _ledgerJournalTrans.CurrencyCode,
                 - _amountCur,
                 currencyExchHelper);

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(_ledgerJournalTrans.RecId);
            ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
                ledgerBondClient.removeCurrentLogObject();
            }
        }

        taxLedgerAccountGroup = TaxLedgerAccountGroup::find(TaxTable::find(_ledgerJournalTrans.TaxCode).TaxAccountGroup);

        createVouchers(taxLedgerAccountGroup.TaxOutgoingLedgerDimension,
                       taxLedgerAccountGroup.TaxIncomingLedgerDimension,
                       _ledgerJournalTrans.amount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxEntryInPaymentCompany_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates voucher entries in payment company
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    _ledgerJournalTrans buffer created either by settlement or through advance payment
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    _ledgerVoucher object to which transactions are added.
    /// </param>
    /// <returns>
    ///    The total withholding tax amount for entire transaction.
    /// </returns>
    protected AmountCur createTaxEntryInPaymentCompany_IN(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucher _ledgerVoucher)
    {
        AmountCur totalWHT;
        AmountCur backWardAmount;
        LedgerInterCompany interCompany;
        CurrencyExchangeHelper currencyExchHelper;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerJournalTrans ledgerJournalTransLoc;

        ledgerJournalTransLoc = LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, false);

        totalWHT = taxVoucherService.taxWithholdAmountForVendType_IN(ledgerJournalTransLoc, true);
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = ledgerJournalTransLoc.ledgerJournalTransTaxExtensionIN();

        if (ledgerJournalTransLoc.SettleVoucher != SettlementType::SelectedTransact
            && (ledgerJournalTransTaxExtensionIN.TCSGroup
                || (ledgerJournalTransTaxExtensionIN.TDSGroup
                    && ledgerJournalTransLoc.AmountCurCredit
                    && ledgerJournalTransLoc.AccountType == LedgerJournalACType::Vend
                    && ledgerJournalTransLoc.OffsetAccountType == LedgerJournalACType::Ledger)))
        {
            backWardAmount = -totalWHT;
        }

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        currencyExchHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            ledgerVoucherObject.parmAccountingDate());

        interCompany = TaxWithholdCalculation_IN::findLedgerInterCompany(ledgerJournalTransLoc.OffsetCompany, ledgerJournalTransLoc.Company);
        if (totalWHT)
        {
            LedgerDimensionAccount ledgerDimensionId = LedgerDimensionFacade::serviceMergeLedgerDimensions(interCompany.OriginatingDebitLedgerDimension, _ledgerJournalTrans.LedgerDimension);
                
            _ledgerVoucher.addTrans(LedgerVoucherTransObject::newTransactionAmountDefault(
                ledgerVoucherObject,
                LedgerPostingType::InterCompany,
                ledgerDimensionId,
                _ledgerJournalTrans.CurrencyCode,
                totalWHT,
                currencyExchHelper));
        }

        _ledgerVoucher.parmBackWardAmountWHT_IN(backWardAmount);

        return backWardAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyAttachements</Name>
				<Source><![CDATA[
    private void copyAttachements(LedgerJournalTrans _ledgerJournalTrans, vendTrans _vendTrans)
    {
        Docu::copy(_ledgerJournalTrans, _vendTrans);

        VendInvoiceJour vendInvoiceJour = VendInvoiceJour::findFromVendTrans(_vendTrans.Invoice, _vendTrans.TransDate, _vendTrans.AccountNum, false, _vendTrans.Voucher);
        if (vendInvoiceJour)
        {
            Docu::copy(_ledgerJournalTrans, vendInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount ledgerDimension(LedgerJournalTrans _journalTrans)
    {
        return VendLedgerAccounts::summaryLedgerDimension(_journalTrans.parmAccount(), _journalTrans.PostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNewVendorVoucherPostVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the vendor voucher, using provided parameters.
    /// </summary>
    /// <param name = "_vendVoucher">The vendor voucher to post.</param>
    /// <param name = "_ledgerVoucher">The ledger voucher being posted.</param>
    /// <param name = "_vendTrans">The vendor transaction being posted.</param>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record that is being posted.</param>
    protected void postNewVendorVoucherPostVoucher(VendVoucher _vendVoucher, LedgerVoucher _ledgerVoucher, VendTrans _vendTrans, LedgerJournalTrans _ledgerJournalTrans)
    {
        _vendVoucher.post(_ledgerVoucher, _vendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNewVendorVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new vendor voucher based on a <c>LedgerJournalTrans</c> record, validates, and posts it.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is being posted.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher being posted.
    /// </param>
    /// <param name="_originalJournalType">
    ///    The journal type of the original journal transaction.
    /// </param>
    /// <param name="_taxAgentVATAmount">
    ///    Amount to be added for taxAgentVAT transaction
    /// </param>
    /// <returns>
    ///    A newly created vendor transaction record.
    /// </returns>
    protected VendTrans postNewVendorVoucher(LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucher _ledgerVoucher,
        LedgerJournalType _originalJournalType,
        AmountCur _taxAgentVATAmount = 0)

    {
        VendVoucher vendVoucher;
        VendTrans vendTrans;
        LedgerJournalType ledgerJournalType = _ledgerJournalTrans.ledgerJournalTable().JournalType;
        VendSettlement vendSettlement;

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

        BankCurrencyTransferLog_RU bankCurrencyTransferLog;
        BankAdvancedTransType_RU bankAdvancedTransType;
        LedgerJournalTrans localLedgerJournalTrans;
        LedgerJournalTrans ledgerJournalTransOrig;
        // </GEERU>

        // <GIN>
        boolean checkBankStatus;
        TaxWithholdJournal_IN taxWithholdJournal;
        LedgerJournalTaxDocument ledgerJournalTaxDocument;
        TaxTrans taxTransLoc;
        LedgerTransVoucherLink LedgerTransVoucherLinkLoc;
        LedgerTransVoucherLink ledgerTransVoucherLinkLoc1;
        TaxItemGroupHeading taxItemGroupHeading;
        VendTrans_W vendTransServiceTaxExtensionLoc;
        TaxTable taxTableLoc;
        // </GIN>

        TaxWithhold::postTaxWithhold(_ledgerVoucher, _ledgerJournalTrans);

        // <GEERU>
        if (countryRegion_RU)
        {
            vendVoucher = VendVoucher::newVendVoucherJournal(
                _ledgerJournalTrans,
                0,
                LedgerTransTxt::None,
                _taxAgentVATAmount);
        }
        else
        {
        // </GEERU>
            vendVoucher = VendVoucher::newVendVoucherJournal(_ledgerJournalTrans, 0);
        // <GEERU>
        }
        // </GEERU>

        if (vendVoucher.validate())
        {
            if (_ledgerJournalTrans.TransactionType != LedgerTransType::Payment && VendTable::findByLedgerDimension(_ledgerJournalTrans.LedgerDimension).Tax1099Reports)
            {
                vendTrans.Tax1099Fields = _ledgerJournalTrans.Tax1099Fields;
                if (vendTrans.Tax1099Fields)
                {
                    if (_ledgerJournalTrans.Tax1099Amount != 0)
                    {
                        vendTrans.Tax1099Amount = _ledgerJournalTrans.Tax1099Amount;

                        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                        {
                            vendTrans.Tax1099RecId = _ledgerJournalTrans.Tax1099RecId;
                        }
                    }
                    else
                    {
                        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                        {
                            //Leave 1099 Amount as zero when S-2 and S-4 is checked (state amount always defaults)
                            if (_ledgerJournalTrans.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099S::grossProceeds()) && Tax1099BoxDetail::findRecId(_ledgerJournalTrans.Tax1099RecId).Tax1099PropertyOrServices == NoYes::Yes)
                            {
                                vendTrans.Tax1099Amount = 0;
                            }
                            else
                            {
                                vendTrans.Tax1099Amount = _ledgerJournalTrans.amount();
                                vendTrans.Tax1099RecId = _ledgerJournalTrans.Tax1099RecId;
                            }
                        }
                        else
                        {
							vendTrans.Tax1099Amount = _ledgerJournalTrans.amount();
                        }
                    }
                    vendTrans.Tax1099State = _ledgerJournalTrans.Tax1099State;
                    if (vendTrans.Tax1099State)
                    {
                        vendTrans.Tax1099StateAmount = _ledgerJournalTrans.Tax1099StateAmount;
                    }
                }
            }

            if (!_ledgerJournalTrans.ReverseEntry)
            {
                ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(_ledgerJournalTrans.RecId);
            }

            if (ledgerJournalTransOrig != null && ledgerJournalTransOrig.ReverseEntry)
            {
                vendVoucher.parmExchRate(ledgerJournalTransOrig.ExchRate);
                vendVoucher.parmExchRateSecondary(ledgerJournalTransOrig.ExchRateSecond);
                vendVoucher.parmExchangeRateDate(ledgerJournalTransOrig.TransDate);
            }
            else
            {
                vendVoucher.parmExchRate(_ledgerJournalTrans.ExchRate);
                vendVoucher.parmExchRateSecondary(_ledgerJournalTrans.ExchRateSecond);
            }

            // For check reversals there is always something to settle.
            if (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
                _originalJournalType == LedgerJournalType::BankChequeReversal)
            {
                vendVoucher.parmSettlementType(SettlementType::SelectedTransact);
            }

            //propagate the invoice release date and release date comment to vend trans
            vendTrans.InvoiceReleaseDate = _ledgerJournalTrans.InvoiceReleaseDate;
            vendTrans.ReleaseDateComment = _ledgerJournalTrans.ReleaseDateComment;

            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters())
            {
                if (TaxWithholdJournal_IN::validateBankAccount(_ledgerJournalTrans))
                {
                    if (TaxWithholdJournal_IN::checkBankAccount(_ledgerJournalTrans))
                    {
                        vendVoucher.parmTaxWithholdAmount_IN(taxVoucherService.taxWithholdAmountForVendType_IN(_ledgerJournalTrans));
                    }
                    else
                    {
                        vendVoucher.parmTaxWithholdBank_IN(taxVoucherService.taxWithholdAmountForVendType_IN(_ledgerJournalTrans));
                    }
                }

                else if (_ledgerJournalTrans.SettleVoucher == SettlementType::SelectedTransact)
                {
                    ledgerJournalTaxDocument = LedgerJournalTaxDocument::construct(_ledgerJournalTrans.JournalNum, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.Invoice);
                    taxWithholdJournal = new TaxWithholdJournal_IN(ledgerJournalTaxDocument, false, false, false);

                    checkBankStatus = taxWithholdJournal.checkBankStatus(_ledgerJournalTrans);
                    if (checkBankStatus)
                    {
                        vendVoucher.parmTaxWithholdAmount_IN(taxVoucherService.taxWithholdAmountForVendType_IN(_ledgerJournalTrans));
                    }
                    else
                    {
                        vendVoucher.parmTaxWithholdAmount_IN(0);
                    }
                    vendVoucher.parmCheckBank_IN(checkBankStatus);
                    _ledgerVoucher.parmCheckBank_IN(checkBankStatus);
                }
                else
                {
                    vendVoucher.parmTaxWithholdAmount_IN(taxVoucherService.taxWithholdAmountForVendType_IN(_ledgerJournalTrans));
                }

                vendVoucher.parmTaxWithholdAmountOriginCur_IN(TaxWithholdJournal_IN::grossAmountCurForJournalLine(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId));

                // Execute only for cross company transactions.
                if (_ledgerJournalTrans.BankChequeDepositTransRefRecID != 0
                    && _ledgerJournalTrans.Company != _ledgerJournalTrans.OffsetCompany)
                {
                    vendVoucher.parmTaxWithholdAmount_IN(-TaxWithholdTrans_IN::taxWithholdAmountCur(TaxWithholdCodeType_IN::TCS, _ledgerJournalTrans.Voucher, _ledgerJournalTrans.TransDate));
                    vendVoucher.parmTaxWithholdAmountOriginCur_IN(TaxWithholdJournal_IN::grossAmountCurForPostedTrans(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId));
                }
            }
            // </GIN>
            // <GEERU>
            if (countryRegion_RU)
            {
                bankAdvancedTransType = BankTransType::find(_ledgerJournalTrans.BankTransType).BankAdvancedTransType_RU;

                if (bankAdvancedTransType != BankAdvancedTransType_RU::None)
                {
                    if (_ledgerJournalTrans.AmountCurCredit && ! _ledgerJournalTrans.BankCurrencyTransferLog_RU)
                    {
                        select firstonly forupdate localLedgerJournalTrans
                            where localLedgerJournalTrans.RecId == _ledgerJournalTrans.RecId;

                        bankCurrencyTransferLog = BankCurrencyTransferLog_RU::initFromLedgerJournalTrans(_ledgerJournalTrans, false);
                        localLedgerJournalTrans.BankCurrencyTransferLog_RU = bankCurrencyTransferLog.RecId;
                        localLedgerJournalTrans.doUpdate();
                    }
                    else if ((bankAdvancedTransType == BankAdvancedTransType_RU::CurrTransfer ||
                              bankAdvancedTransType == BankAdvancedTransType_RU::CashCollection) &&
                             _ledgerJournalTrans.AmountCurDebit)
                    {
                        select firstonly forupdate localLedgerJournalTrans
                            where localLedgerJournalTrans.RecId == _ledgerJournalTrans.RecId;

                        bankCurrencyTransferLog = BankCurrencyTransferLog_RU::initFromLedgerJournalTrans(_ledgerJournalTrans, true);
                        localLedgerJournalTrans.BankCurrencyTransferLog_RU = bankCurrencyTransferLog.RecId;
                        localLedgerJournalTrans.doUpdate();
                    }
                    else
                    {
                        bankCurrencyTransferLog = BankCurrencyTransferLog_RU::find(_ledgerJournalTrans.BankCurrencyTransferLog_RU);
                    }
                    vendVoucher.parmBankCurrencyTransferId_RU(bankCurrencyTransferLog.BankCurrencyTransferId);
                }
            }
            // </GEERU>
            if (CFMParameters::isPaymentRequestsEnabled())
            {
                container paymentRequestsCon = this.getPaymentRequestsContainer(_ledgerJournalTrans);

                vendVoucher.post(_ledgerVoucher, vendTrans);

                if (ledgerJournalTransIntercompanyMap && ledgerJournalTransIntercompanyMap.exists(_ledgerJournalTrans.recId))
                {
                    LedgerJournalTrans prOrigJournalTrans;

                    RecId origTransRecId = ledgerJournalTransIntercompanyMap.lookup(_ledgerJournalTrans.recId);

                    select firstonly crossCompany prOrigJournalTrans
                        where prOrigJournalTrans.RecId == origTransRecId;

                    CFMPaymentRequestPaymentLink::updatePaymentRequestJournalTransPosting(prOrigJournalTrans);
                    CFMPaymentRequestPaymentLink::createReference(CFMPaymentRequestPaymentLink::findPaymentRequestByPaymentSource(prOrigJournalTrans).PaymentRequest, vendTrans);
                }
                else
                {
                    CFMPaymentRequestPaymentLink::updatePaymentRequestJournalTransPosting(_ledgerJournalTrans);
                    CFMPaymentRequestPaymentLink::createReference(CFMPaymentRequestPaymentLink::findPaymentRequestByPaymentSource(_ledgerJournalTrans).PaymentRequest, vendTrans);
                }

                this.createPrepaymentSpecTrans(paymentRequestsCon, vendTrans);
            }
            else
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                || _ledgerJournalTrans.orig().AccountType == LedgerJournalACType::FixedAssets)
                {
                    LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
                    if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
                    {
                        vendVoucher.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());
                    }
                }
                this.postNewVendorVoucherPostVoucher(vendVoucher, _ledgerVoucher, vendTrans, _ledgerJournalTrans);
            }
            
            // <GIN>
            if (TaxParameters::isServiceTaxEnable_IN())
            {
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Vend || _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
                {
                    select firstOnly taxTransLoc
                        where taxTransLoc.Voucher == vendTrans.Voucher
                            && taxTransLoc.TransDate == vendTrans.TransDate
                        join TaxCode from taxTableLoc
                            where taxTableLoc.TaxCode == taxTransLoc.TaxCode
                               && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax
                            join RecId, ServiceTaxBasis_IN from taxItemGroupHeading
                                where taxItemGroupHeading.TaxItemGroup == taxTransLoc.TaxItemGroup
                                   && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis;

                    if (!taxTransLoc.RecId)
                    {
                        select firstOnly ledgerTransVoucherLinkLoc1
                            where ledgerTransVoucherLinkLoc1.Voucher == vendTrans.Voucher
                                && ledgerTransVoucherLinkLoc1.TransDate == vendTrans.TransDate;

                        select firstOnly RecId, TaxCode, TaxItemGroup, Voucher, TransDate from taxTransLoc
                            join TaxCode from taxTableLoc
                                where taxTableLoc.TaxCode == taxTransLoc.TaxCode
                                join RecId, ServiceTaxBasis_IN from taxItemGroupHeading
                                    where taxItemGroupHeading.TaxItemGroup == taxTransLoc.TaxItemGroup
                                       && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                                    exists join ledgerTransVoucherLinkLoc
                                        where ledgerTransVoucherLinkLoc.Voucher == taxTransLoc.Voucher
                                            && ledgerTransVoucherLinkLoc.TransDate == taxTransLoc.TransDate
                                            && ledgerTransVoucherLinkLoc.VoucherGroupId == ledgerTransVoucherLinkLoc1.VoucherGroupId;
                    }

                    if (taxTransLoc.RecId)
                    {
                        vendTransServiceTaxExtensionLoc = VendTrans_W::findByVendTrans(vendTrans.RecId, true);
                        vendTransServiceTaxExtensionLoc.ServiceTaxPOTStatus_IN = ServiceTaxPOTStatus_IN::Original;
                        vendTransServiceTaxExtensionLoc.VendTrans = vendTrans.RecId;
                        vendTransServiceTaxExtensionLoc.update();
                    }
                }
            }
            // </GIN>

            // <GJP>
            this.updatePaymFee_JP(_ledgerJournalTrans, vendTrans);
            // </GJP>

            if (DocuRef::exist(_ledgerJournalTrans.company(), _ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId))
            {
                this.copyAttachements(_ledgerJournalTrans, vendTrans);
            }

            VendInvoiceInfo::copy(_ledgerJournalTrans, vendTrans);

            // If a Bank reversal journal type, update the settlement records so they are not reversable.
            if (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
                _originalJournalType == LedgerJournalType::BankChequeReversal)
            {
                update_recordset vendSettlement
                    setting CanBeReversed = NoYes::No
                    where vendSettlement.CanBeReversed == NoYes::Yes &&
                          (vendSettlement.TransRecId == vendTrans.RecId ||
                          (vendSettlement.OffsetRecid == vendTrans.RecId &&
                           vendSettlement.OffsetCompany == vendTrans.company()));
            }

            if (_ledgerJournalTrans.Invoice)
            {
                TradeBLWIJournalPurposeCodes::createRecordFromJournal(_ledgerJournalTrans.recId,
                TradeBLWITypeOfForm::LedgerJournalTrans,
                vendVoucher.parmCustVendInvoiceJour().RecId,
                TradeBLWITypeOfForm::VendInvoiceJour);
            }
            else
            {
                TradeBLWIJournalPurposeCodes::createRecordFromJournal(_ledgerJournalTrans.recId,
                TradeBLWITypeOfForm::LedgerJournalTrans,
                vendTrans.RecId,
                TradeBLWITypeOfForm::VendTrans);
            }
        }

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxDocumentLedgerVoucherMap = vendVoucher.getTaxDocumentLedgerVoucherMap();
        }
        // </GTE>
        return vendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVATTransForTaxAgent_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>CustVendTransPostingLog_RU</c> record for VAT tax agent transaction
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///   <c>LedgerVoucher</c> object which holds posting data
    /// </param>
    /// <param name="_vendTransPayment">
    ///   <c>VendTrans</c> transaction which is payment for Tax agent
    /// </param>
    /// <param name="_offsetDefaultAccount">
    ///   Account for posting offset
    /// </param>
    private void postVATTransForTaxAgent_RU(LedgerVoucher _ledgerVoucher,
                                            VendTrans _vendTransPayment,
                                            LedgerDimensionDefaultAccount _offsetDefaultAccount)
    {
        CustVendTransPostingLog_RU postingLog;
        TaxTrans taxTrans;
        TaxTrans_RU taxTrans_RU;
        FactureJour_RU factureJour;

        LedgerDimensionAccount getLedgerDimensionForTaxTrans(RefRecId _taxTrans)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject;
            LedgerVoucherTransList ledgerVoucherTransList;
            boolean haveVoucherTrans;
            LedgerPostingOneToManyCollection taxLinks;

            ledgerVoucherTransList = _ledgerVoucher.findLedgerVoucherObject().getInternalCollection();
            haveVoucherTrans = ledgerVoucherTransList.first();

            while (haveVoucherTrans)
            {
                ledgerVoucherTransObject = ledgerVoucherTransList.item();

                taxLinks = ledgerVoucherTransObject.parmTaxLinks();

                if (taxLinks.find(_taxTrans))
                {
                    return ledgerVoucherTransObject.parmLedgerDimensionId();
                }

                haveVoucherTrans = ledgerVoucherTransList.next();
            }
            return 0;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            while select forupdate taxTrans
                where taxTrans.Voucher == _vendTransPayment.Voucher &&
                      taxTrans.TransDate == _vendTransPayment.TransDate
                join forupdate taxTrans_RU
                    where taxTrans_RU.TaxTrans == taxTrans.RecId
                      && taxTrans_RU.vatTaxAgentVendAccount_RU == _vendTransPayment.AccountNum
            {
                postingLog.clear();

                taxTrans_RU = taxTrans.taxTrans_RU();

                postingLog.Voucher = _ledgerVoucher.lastVoucher();
                postingLog.TransDate = _vendTransPayment.TransDate;
                postingLog.Posting = LedgerPostingType::Tax;

                postingLog.LedgerDimension = getLedgerDimensionForTaxTrans(taxTrans.RecId);
                postingLog.OffsetLedgerDimension = this.mergeLedgerDimensionAndDefaultDimension(_offsetDefaultAccount, 0);
                postingLog.CurrencyCode = taxTrans.SourceCurrencyCode;

                postingLog.AmountCur = taxTrans.SourceTaxAmountCur;
                postingLog.AmountMST = taxTrans.TaxAmount;
                postingLog.AmountMSTSecond = CurrencyExchangeHelper::amountMST2MSTSecond_RU(postingLog.AmountMST, taxTrans.TransDate);

                postingLog.TaxBaseAmountMST = taxTrans.TaxBaseAmount;
                postingLog.TaxBaseAmountCur = taxTrans.SourceBaseAmountCur;
                postingLog.TaxBaseAmountReporting = CurrencyExchangeHelper::amountMST2MSTSecond_RU(postingLog.TaxBaseAmountMST, taxTrans.TransDate);

                postingLog.TaxCode = taxTrans.TaxCode;
                postingLog.PostingLogType = CustVendTransPostingLogType_RU::VATTaxAgent;
                postingLog.OffSetRecId = _vendTransPayment.RecId;
                postingLog.RefTableId = _vendTransPayment.TableId;
                postingLog.vatOperationCode_RU = taxTrans_RU.vatOperationCode_RU;
                postingLog.CannotBeReversed = NoYes::Yes;

                postingLog.insert();

                taxTrans.SourceTableId = postingLog.TableId;
                taxTrans.SourceRecId = postingLog.RecId;
                taxTrans.TaxDirection = TaxDirection::VATTaxAgentCharged_RU;
                taxTrans_RU.CustVendTransPostingLog_RU = postingLog.RecId;
                taxTrans.packTaxTrans_RU(taxTrans_RU);
                taxTrans.update();

                factureJour = FactureJourCreate_RU::newVATPaymentFactureSettlement(postingLog,
                                                                     _vendTransPayment);
                factureJour.OperationTypeCodes = FactureJour_RU::getInitialTypeCodes(factureJour);
                factureJour.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds a <c>SpecTransManager</c>.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is used during the reversal.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for which to reverse transactions.
    /// </param>
    /// <remarks>
    ///    If there is a <c>SpecTransCount</c> larger than zero, the <c>ReverseTransact</c> method of the
    ///    <c>VendTrans</c> table is called.
    /// </remarks>
    protected void reverseSettlement(LedgerJournalTrans _ledgerJournalTrans, LedgerVoucher _ledgerVoucher)
    {
        SpecTransManager specTransManager;
        CompanyId originalVoucherCompany;

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        if (specTransManager.getSpecTransCount() > 0)
        {
            originalVoucherCompany = _ledgerVoucher.parmCompanyId();

            // Set the company because reverseTransact requires LedgerVoucher to have the current company context.
            _ledgerVoucher.parmCompanyId(curext());
            // <GEERU>
            if (countryRegion_RU)
            {
                VendTrans::reverseTransact(_ledgerJournalTrans,
                                           _ledgerVoucher,
                                           SettleDatePrinc::SelectDate,
                                           _ledgerJournalTrans.TransDate,
                                           false);
            }
            else
            {
            // </GEERU>
                VendTrans::reverseTransact(_ledgerJournalTrans,
                                           _ledgerVoucher,
                                           SettleDatePrinc::SelectDate,
                                           _ledgerJournalTrans.TransDate);
            // <GEERU>
            }
            // </GEERU>
            // Restore the original company so that the rest of the posting process is not affected.
            _ledgerVoucher.parmCompanyId(originalVoucherCompany);

            specTransManager.deleteAll();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reverses withholding taxes for a vendor transaction.
    /// </summary>
    /// <param name="_vendTrans">
    ///    The vendor transaction that is being reversed.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger voucher for which to reverse withholding taxes.
    /// </param>
    /// <param name="_transDate">
    ///    The date for the reversal transaction.
    /// </param>
    /// <remarks>
    ///    A similar method is found on the <c>BankChequeCancel</c> class.
    /// </remarks>
    protected void reverseTaxWithhold(VendTrans _vendTrans, LedgerVoucher _ledgerVoucher, TransDate _transDate)
    {
        VendTrans vendTrans;
        VendTable vendTable;
        VendSettlement reverseVendSettlement;
        SpecTransManager specTransManager;
        TaxWithholdTrans taxWithholdTrans;
        CompanyId originalVoucherCompany;
        CompanyId currentCompany;

        currentCompany = curext();

        // Find the TaxWithholdingTrans record based on the payment voucher since
        // the Tax Withholding voucher in the VendTrans table does not have to match
        // the payment voucher. The crosscompany statement is unbounded because it
        // is not possible to predetermine exactly where the TaxWithholdTrans records
        // will exist. The where restrictions will retrieve the appropriate records
        // across all companies where they exist.

        LedgerTransVoucherLink  ledgerTransVoucherLinkPayment, ledgerTransVoucherLinkSettlement;

        while select crosscompany taxWithholdTrans
            where taxWithholdTrans.Voucher == _vendTrans.Voucher
                && taxWithholdTrans.TransDate == _vendTrans.TransDate
                && taxWithholdTrans.PaymCompany == _vendTrans.company()
        {
            // Get the Tax Withholding VendTrans record based upon the SettlementVoucher
            // which is set at settlement time. The only way to create withholding records
            // is during settlements so we know it will always be set correctly.

            // The vendTrans table must be reset since it is not part of a cross company
            // query. This ensures the appropriate company will be used.
            vendTrans = null;
            reverseVendSettlement = null;

            // When current payment voucher is a related voucher of the settlement voucher 
            // which generates current TaxWithholdTrans, the settlement has been marked in 
            // previous steps. It should not be reversed again here.
            select RecId from ledgerTransVoucherLinkPayment
                where ledgerTransVoucherLinkPayment.Voucher == _vendTrans.Voucher
                    && ledgerTransVoucherLinkPayment.TransDate == _vendTrans.TransDate
                exists join ledgerTransVoucherLinkSettlement
                    where ledgerTransVoucherLinkSettlement.Voucher == taxWithholdTrans.SettlementVoucher
                        && ledgerTransVoucherLinkSettlement.TransDate == _vendTrans.TransDate
                        && ledgerTransVoucherLinkSettlement.VoucherGroupId == ledgerTransVoucherLinkPayment.VoucherGroupId;

            if (ledgerTransVoucherLinkPayment.RecId)
            {
                break;
            }

            changecompany(taxWithholdTrans.company())
            {
                // Find all the vendTrans records for the tax withholding settlement
                while select vendTrans
                    where vendTrans.Voucher == taxWithholdTrans.SettlementVoucher
                        && vendTrans.TransDate == taxWithholdTrans.TransDate
                        && vendTrans.RecId != _vendTrans.RecId
                {
                    // Use the settlement reversal code to reverse the tax withholding settlement
                    // To do this, mark the tax withhold settlement records and then call the reversal code
                    vendTable = VendTable::find(vendTrans.AccountNum);
                    Debug::assert(vendTable.RecId != 0);

                    specTransManager = SpecTransManager::newFromSpec(vendTable);
                    while select reverseVendSettlement
                        where reverseVendSettlement.TransCompany == vendTrans.DataAreaId
                           && reverseVendSettlement.TransRecId == vendTrans.RecId
                           && reverseVendSettlement.CanBeReversed == NoYes::Yes
                    {
                        reverseVendSettlement.CustVendSettlement::markThisAndRelatedOffsets(specTransManager, vendTrans.CurrencyCode);
                    }
                    
                    if (specTransManager.getSpecTransCount() > 0)
                    {
                        originalVoucherCompany = _ledgerVoucher.parmCompanyId();

                        // Set the company because reverseTransact requires LedgerVoucher to have the current company context.
                        _ledgerVoucher.parmCompanyId(currentCompany);

                        // Reverse tax withholding settlements
                        VendTrans::reverseTransact(vendTable,
                            _ledgerVoucher,
                            SettleDatePrinc::SelectDate,
                            _transDate);

                        // Restore the original company so that the rest of the posting process is not affected.
                        _ledgerVoucher.parmCompanyId(originalVoucherCompany);

                        // Clean up SpecTrans records for reversal
                        specTransManager.deleteAll();
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupClosingSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds records from the <c>VendTransOpen</c> table that correspond to the passed in <c>VendTrans</c>
    ///    record and for each record inserts reversal settlement records.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record for the reversal.
    /// </param>
    /// <param name="_vendTrans">
    ///    The vendor transaction for which to find <c>VendTransOpen</c> records.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    No records from <c>VendTransOpen</c> were found to reverse.
    /// </exception>
    protected void setupClosingSettlement(LedgerJournalTrans _ledgerJournalTrans, VendTrans _vendTrans)
    {
        VendTransOpen vendTransOpen;
        SpecTransManager specTransManager;
        boolean foundVendTransOpen = false;

        specTransManager = SpecTransManager::newFromSpec(_ledgerJournalTrans);

        while select TableId, RecId, AmountCur from vendTransOpen
            where vendTransOpen.RefRecId == _vendTrans.RecId
        {
            specTransManager.insert(vendTransOpen.DataAreaId, vendTransOpen.TableId, vendTransOpen.RecId, vendTransOpen.AmountCur, _vendTrans.CurrencyCode);
            foundVendTransOpen = true;
        }

        if (foundVendTransOpen == false)
        {
            throw error(strFmt("@SYS18598", funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankPromissoryNoteStatus</Name>
				<Source><![CDATA[
    protected void updateBankPromissoryNoteStatus(LedgerJournalTrans _ledgerJournalTrans)
    {
        BankPromissoryNoteTable bankPromissoryNoteTable;

        if (_ledgerJournalTrans.BankAccountId && _ledgerJournalTrans.BankPromissoryNoteNum)
        {
            bankPromissoryNoteTable = BankPromissoryNoteTable::find(_ledgerJournalTrans.BankAccountId,
                                                                    _ledgerJournalTrans.BankPromissoryNoteNum,
                                                                    true);

            bankPromissoryNoteTable.DocumentStatus = BankPromissoryNoteStatus::Posted;
            bankPromissoryNoteTable.VendPromissoryNoteID = VendTrans::findVoucherDate(_ledgerJournalTrans.Voucher,_ledgerJournalTrans.TransDate).PromissoryNoteID;
            bankPromissoryNoteTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get tax amount calculated by GTE
    /// </summary>
    /// <param name = "_ledgerJournalTrans">the journal line for which tax is calculated</param>
    /// <returns>tax amount calculated by GTE</returns>    
    protected TaxAmount getTaxAmountGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        TaxAmount           taxAmount;
        ITaxableDocument    taxableDocument;
        ITaxDocument        taxDocumentObject;
        ITaxDocumentLine    taxDocumentLineObject;
        TaxAmountCur        inclTaxAmountTotal;
          
        taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans));

        taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
        if (taxDocumentObject)
        {
            if (_ledgerJournalTrans.LedgerDimension == 0 || _ledgerJournalTrans.OffsetLedgerDimension == 0)
            {
                taxAmount           = taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                taxAmount           -= taxDocumentObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                inclTaxAmountTotal  = taxDocumentObject.getInclTax().amountTransactionCurrency();
            }
            else
            {
                taxDocumentLineObject   = taxDocumentObject.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);
                if (taxDocumentLineObject)
                {
                    taxAmount               = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                    taxAmount               -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Party, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                    inclTaxAmountTotal      = taxDocumentLineObject.getInclTax().amountTransactionCurrency();
                }
            }

            if (LedgerJournalTrans::isVendorPayment(_ledgerJournalTrans))
            {
                inclTaxAmountTotal = -inclTaxAmountTotal;
            }

            if (inclTaxAmountTotal)
            {
                if (_ledgerJournalTrans.AmountCurCredit)
                {
                    _ledgerJournalTrans.AmountCurCredit -= inclTaxAmountTotal;
                }
                else if (_ledgerJournalTrans.AmountCurDebit)
                {
                    _ledgerJournalTrans.AmountCurDebit += inclTaxAmountTotal;
                }
            }
        }

        return taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPrepaymentLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucherTransObject</c> when posting type is VendPayment.
    /// </summary>
    /// <param name = "_defaultLedgerPostingReference">
    ///     The <c>LedgerVoucherObject</c> class instance.
    /// </param>
    /// <param name = "_postingType">
    ///     The posting type.
    /// </param>
    /// <param name = "_ledgerDimensionId">
    ///     The merged Ledger Dimension.
    /// </param>
    /// <param name = "_transactionCurrencyCode">
    ///     The currency code.
    /// </param>
    /// <param name = "_transactionCurrencyAmount">
    ///     The transaction amount in currency to be used.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The <c>CurrencyExchangeHelper</c> class instance.
    /// </param>
    /// <returns>
    ///     The initialized <c>LedgerVoucherTransObject</c> class instance.
    /// </returns>
    protected LedgerVoucherTransObject initPrepaymentLedgerVoucherTransObject(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        return LedgerVoucherTransObject::newTransactionAmountDefault(
                         _defaultLedgerPostingReference,
                         _postingType,
                         _ledgerDimensionId,
                         _transactionCurrencyCode,
                         _transactionCurrencyAmount,
                         _exchangeRateHelper);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    void updateNow(LedgerVoucher _ledgerVoucher,
                   LedgerPostingType _posting,
                   LedgerJournalTrans _ledgerJournalTrans,
                   LedgerJournalTrans _originalLedgerJournalTrans,
                   boolean _interCompany = false,
                   boolean _reversalsMayExist = true,
                   boolean _isDueToDueFromAccount = false
                   )
    {
        CustVendNegInstPost custVendNegInstPost;
        BankRemittanceFilesVend bankRemittanceFilesVend;
        TaxAmount taxAmount;
        AmountCur originalAmountCur;
        LedgerJournalTable ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
        LedgerJournalType ledgerJournalType = ledgerJournalTable.JournalType;
        LedgerJournalTrans localLedgerJournalTrans;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        VendTransOpen tmpVendTransOpen;
        VendTrans vendTrans;
        LedgerJournalType originalJournalType = ledgerJournalTable.findOriginalJournalType();
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerVoucherObject ledgerVoucherObject;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerDimensionDefaultAccount prepaymentLedgerDimension;
        LedgerDimensionAccount mergedLedgerDimension;
        // <GEERU>
        LedgerBondClient_RU ledgerBondClient = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        FactureJour_RU factureJour;
        #isoCountryRegionCodes
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GIN>
        AmountCur backWardAmount;
        boolean isIndiaPrimaryCountry;
        boolean isIndiaTaxMarked;
        LedgerJournalTrans ledgerJournalTransLoc;
        TaxGroupData taxGroupData;
        TaxItemGroup taxItemGroup;
        TaxGroup taxGroup;
        TaxOnItem taxOnItem;
        TaxAmountCur serviceTaxCur;
        TaxItemGroupHeading taxItemGroupHeadingRev = TaxItemGroupHeading::find(LedgerJournalTrans::findRecId(_ledgerJournalTrans.RecId, false).TaxItemGroup);
        TaxAmountCur withholdTaxCur;
        vendTrans offsetVendTrans;
        LedgerDimensionAccount dueFromLedgerDimension;
        LedgerDimensionAccount ledgerDimensionMerged;
        int sign = -1;
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt;
        #ISOCountryRegionCodes
        // </GIN>
        
        taxAmount = 0;

        // If asset journal line is not initialized from _ledgerJournalTrans for offset type, this will initialize from original journal line buffer.
        if (!ledgerJournalTrans_Asset && isOffset)
        {
            ledgerJournalTrans_Asset = _ledgerJournalTrans.orig().findLedgerJournalTransAssetSibling();
        }

        // <GIN>
        isIndiaPrimaryCountry = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

        if (isIndiaPrimaryCountry)
        {
            ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();
        }

        if (isIndiaPrimaryCountry)
        {
            // to check multiline journal posting
            select firstonly TaxItemGroup, TaxGroup from ledgerJournalTransLoc
                where ledgerJournalTransLoc.Voucher == _originalLedgerJournalTrans.Voucher &&
                    ledgerJournalTransLoc.RecId != _originalLedgerJournalTrans.RecId &&
                    ((ledgerJournalTransLoc.AmountCurDebit && _originalLedgerJournalTrans.AmountCurCredit) ||
                    (ledgerJournalTransLoc.AmountCurCredit && _originalLedgerJournalTrans.AmountCurDebit));

            if (_originalLedgerJournalTrans.TaxItemGroup && _originalLedgerJournalTrans.TaxGroup)
            {
                taxGroup = _originalLedgerJournalTrans.TaxGroup;
                taxItemGroup = _originalLedgerJournalTrans.TaxItemGroup;
            }
            else if (ledgerJournalTransLoc.TaxItemGroup && ledgerJournalTransLoc.TaxGroup)
            {
                taxGroup = ledgerJournalTransLoc.TaxGroup;
                taxItemGroup = ledgerJournalTransLoc.TaxItemGroup;
            }
            if (taxGroup && taxItemGroup)
            {
                select firstonly TaxGroup, TaxCode from taxGroupData
                    where taxGroupData.TaxGroup == taxGroup
                        join TaxItemGroup, TaxCode from taxOnItem
                            where taxOnItem.TaxItemGroup == taxItemGroup
                            && taxOnItem.TaxCode == taxGroupData.TaxCode;
                if (taxGroupData.TaxCode)
                {
                    isIndiaTaxMarked = TaxParameters::checkParameter_IN(TaxTable::find(taxGroupData.TaxCode).TaxType_IN);
                }
            }
        }
        // </GIN>
        if (!_ledgerJournalTrans.Cancel && taxVoucherService)
        {            
            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                if (!TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans).skipTaxDocument())
                {
                    taxAmount = this.getTaxAmountGTE(_ledgerJournalTrans);
                }
                else
                {
                    taxAmount = 0;
                }
            }
            else
            {
            // </GTE>
                taxAmount = taxVoucherService.taxAmountForVendCustType(_ledgerJournalTrans, _interCompany, _posting, _isDueToDueFromAccount);
            // <GTE>
            }
            // </GTE>
            
            // <GIN>
            if (isIndiaPrimaryCountry)
            {
                if (TaxParameters::find().ServiceTax_IN)
                {
                    if (_ledgerJournalTrans.OffsetLedgerDimension)
                    {
                    serviceTaxCur = TaxUncommitted::getSpecificTaxAmount_IN(_ledgerJournalTrans.TableId,
                                                                            _ledgerJournalTrans.RecId,
                                                                            TaxType_IN::ServiceTax);
                    }
                    else
                    {
                        serviceTaxCur = TaxUncommitted::getSpecificTaxAmountForVoucher_IN(ledgerJournalTable.TableId,
                                                                            ledgerJournalTable.RecId,
                                                                            _ledgerJournalTrans.Voucher,
                                                                            false,
                                                                            TaxType_IN::ServiceTax,
                                                                            _ledgerJournalTrans.Company());
                    }

                    if (serviceTaxCur)
                    {// Case GTA vendor.
                        if (_ledgerJournalTrans.isGTAVendorAccount_IN() || _ledgerJournalTrans.isForeignVendorAccount_IN()
                                                            ||//[OR]
                            (!taxVoucherService.parmIsInterCompanyTrans_IN()
                                && (!_ledgerJournalTrans.isGTAVendorAccount_IN())
                                && !_ledgerJournalTrans.isForeignVendorAccount_IN()
                                && _ledgerJournalTrans.ForeignCompany != ''
                            )
                           )//End if
                        {
                            taxAmount = (taxAmount - serviceTaxCur);// Total tax minus service tax.
                        }
                        else if (taxItemGroupHeadingRev.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                            && taxItemGroupHeadingRev.ReverseChargePercentage_IN)
                        {
                            taxAmount = taxAmount - serviceTaxCur + _ledgerJournalTrans.serviceTaxAmountForReverseCharge_IN();
                        }
                        if (_ledgerJournalTrans.orig().AccountType == LedgerJournalACType::Bank
                            || _ledgerJournalTrans.orig().OffsetAccountType == LedgerJournalACType::Bank)
                        {
                            taxAmount = 0;// Service tax shud not hit vendor account for Bank. Applicable to GTA also.
                        }
                    }
                }
                // Included Tax is deducted from Line amount here.
                if (FormulaDesigner_IN::isPriceInclTaxOnLineAmount(_ledgerJournalTrans.TaxItemGroup))
                {
                    if (taxAmount)
                    {
                        if (_ledgerJournalTrans.AmountCurCredit)
                        {
                            _ledgerJournalTrans.AmountCurCredit -= taxVoucherService.priceInclTaxAmount_IN(_ledgerJournalTrans);
                        }
                        else if (_ledgerJournalTrans.AmountCurDebit)
                        {
                            _ledgerJournalTrans.AmountCurDebit += taxVoucherService.priceInclTaxAmount_IN(_ledgerJournalTrans);
                        }
                    }
                }
            }
            // </GIN>

            // <GEERU>
            if (_ledgerJournalTrans.isNonTaxablePrepayment_RU())
            {
                taxAmount = 0;
            }
            // </GEERU>


            if (_ledgerJournalTrans.AmountCurCredit)
            {
                originalAmountCur = _ledgerJournalTrans.AmountCurCredit;
                _ledgerJournalTrans.AmountCurCredit += taxAmount;
            }
            if (_ledgerJournalTrans.AmountCurDebit)
            {
                originalAmountCur = _ledgerJournalTrans.AmountCurDebit;
                _ledgerJournalTrans.AmountCurDebit -= taxAmount;
            }
        }
        this.reverseTax(_ledgerVoucher,
                        _ledgerJournalTrans);

        if (_ledgerJournalTrans.Tax1099Fields)
        {
            if (_ledgerJournalTrans.AmountCurCredit != 0)
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    //Leave 1099 Amount as zero when S-2 and S-4 is checked (state amount always defaults)
                    if (_ledgerJournalTrans.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099S::grossProceeds()) && Tax1099BoxDetail::findRecId(_ledgerJournalTrans.Tax1099RecId).Tax1099PropertyOrServices == NoYes::Yes)
                    {
                        _ledgerJournalTrans.Tax1099Amount = 0;
                    }
                    else
                    {
                        _ledgerJournalTrans.Tax1099Amount = _ledgerJournalTrans.Tax1099Amount == 0 ? -_ledgerJournalTrans.AmountCurCredit : _ledgerJournalTrans.Tax1099Amount;
                    }
                }
                else
                {
                _ledgerJournalTrans.Tax1099Amount = _ledgerJournalTrans.Tax1099Amount == 0 ? -_ledgerJournalTrans.AmountCurCredit : _ledgerJournalTrans.Tax1099Amount;
                }
            }
            else
            {
                _ledgerJournalTrans.Tax1099Amount = _ledgerJournalTrans.Tax1099Amount == 0 ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.Tax1099Amount;
            }

            if ((_ledgerJournalTrans.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099MISC::stateTaxWithheld())
                || _ledgerJournalTrans.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099DIV::stateTaxWithheld())
                || _ledgerJournalTrans.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099INT::stateTaxWithheld())
                || _ledgerJournalTrans.Tax1099Fields == Tax1099Base::findTax1099FieldsRecId(Tax1099OID::stateTaxWithheld()))
                && _ledgerJournalTrans.Tax1099Amount != 0)
            {
                _ledgerJournalTrans.Tax1099Amount = 0;
            }
        }

        if (_ledgerJournalTrans.Tax1099State)
        {
            if (_ledgerJournalTrans.AmountCurCredit != 0)
            {
                _ledgerJournalTrans.Tax1099StateAmount = _ledgerJournalTrans.Tax1099StateAmount == 0 ? -_ledgerJournalTrans.AmountCurCredit : _ledgerJournalTrans.Tax1099StateAmount;
            }
            else
            {
                 _ledgerJournalTrans.Tax1099StateAmount = _ledgerJournalTrans.Tax1099StateAmount == 0 ? _ledgerJournalTrans.AmountCurDebit : _ledgerJournalTrans.Tax1099StateAmount;
            }
            if ((_ledgerJournalTrans.Tax1099State == Tax1099MISC::federalIncomeTaxWithheld().tax1099Box || _ledgerJournalTrans.Tax1099State == Tax1099INT::federalIncomeTaxWithheld().tax1099Box || _ledgerJournalTrans.Tax1099State == Tax1099DIV::federalIncomeTaxWithheld().tax1099Box) && _ledgerJournalTrans.Tax1099StateAmount != 0)
            {
                _ledgerJournalTrans.Tax1099StateAmount = 0;
            }
        }

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

        // <GEERU><GIN>
        if ((_ledgerJournalTrans.Prepayment || _ledgerJournalTrans.isVatTaxAgentAuthorityPayment_RU())
            && !_ledgerJournalTrans.isTaxTypeApplicable_IN())
        // </GIN></GEERU>
        {
            // <GEERU>
            if (_originalLedgerJournalTrans.TaxGroup
                && (VendParameters::find().TaxOnPrepayment == NoYes::Yes
                || (countryRegion_RU
                && (_ledgerJournalTrans.isVatTaxAgentPrepayment_RU()
                || _ledgerJournalTrans.isVatTaxAgentAuthorityPayment_RU()))))
            // </GEERU>
            {
                // <GEERU>
                if (countryRegion_RU && _ledgerJournalTrans.isVatTaxAgentPrepayment_RU())
                {
                    prepaymentLedgerDimension = TaxLedgerAccountGroup::find(TaxTable::find(TaxTable::vatCode_RU(_ledgerJournalTrans.TaxGroup,
                                            _ledgerJournalTrans.TaxItemGroup)).TaxAccountGroup).TaxOutgoingLedgerDimension;
                }
                else if (countryRegion_RU && _ledgerJournalTrans.isVatTaxAgentAuthorityPayment_RU())
                {
                    prepaymentLedgerDimension = TaxLedgerAccountGroup::find(TaxTable::find(_ledgerJournalTrans.TaxCode).TaxAccountGroup).TaxIncomingLedgerDimension;
                }
                else
                {
                // </GEERU>
                    prepaymentLedgerDimension = VendLedgerAccounts::vatPrepaymentsLedgerDimension(_ledgerJournalTrans.parmAccount(),
                                                    _ledgerJournalTrans.PostingProfile);
                // <GEERU>
                }
                // </GEERU>

                if (originalAmountCur && ! ledgerJournalTable.LedgerJournalInclTax)
                {
                    if (_ledgerJournalTrans.AmountCurCredit)
                    {
                        _ledgerJournalTrans.AmountCurCredit = originalAmountCur;
                    }
                    if (_ledgerJournalTrans.AmountCurDebit)
                    {
                        _ledgerJournalTrans.AmountCurDebit = originalAmountCur;
                }
                }

                if (! ledgerJournalTable.LedgerJournalInclTax)
                {
                    taxAmount = taxVoucherService.getTransactionalTaxAmountForPrepayment(_ledgerJournalTrans, true);
                }
                else
                {
                    taxAmount = taxVoucherService.getTransactionalTaxAmountForLine(_originalLedgerJournalTrans);
                }

                // <GEERU>
                if (_ledgerJournalTrans.isVatTaxAgentPrepayment_RU())
                {
                    taxAmount = _ledgerJournalTrans.totalTaxAmountSingleLine(true, false, true);
                }


                if (_ledgerJournalTrans.isNonTaxablePrepayment_RU())
                {
                    taxAmount = 0;
                }
                // </GEERU>

                mergedLedgerDimension = this.mergeLedgerDimensionAndDefaultDimension(prepaymentLedgerDimension, _ledgerJournalTrans.DefaultDimension);

                ledgerVoucherTransObject = this.initPrepaymentLedgerVoucherTransObject(
                    ledgerVoucherObject,
                    LedgerPostingType::VendPayment,
                    mergedLedgerDimension,
                    _ledgerJournalTrans.CurrencyCode,
                    -taxAmount,
                    exchangeRateHelper);

                if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
                {
                    ledgerVoucherTransObject.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());
                }
                ledgerVoucherTransObject.parmSourceTableId(_ledgerJournalTrans.TableId);
                ledgerVoucherTransObject.parmSourceRecId(_ledgerJournalTrans.RecId);
                ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);

                _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                // <GEERU>
                if (ledgerBondClient && ledgerBondClient.currentLogLength() >= 2)
                {
                    ledgerBondClient.bondLastVRef2CurrentLog();
                }
                // </GEERU>
            }
        }

        if (_posting == LedgerPostingType::InterCompany)
        {
            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters() && TaxWithholdParameters_IN::find().CrossCompanyPayment && (ledgerJournalTransTaxExt.tdsGroup || ledgerJournalTransTaxExt.tcsGroup))
            {
                backWardAmount = this.createTaxEntryInPaymentCompany_IN(_ledgerJournalTrans, _ledgerVoucher);
            }
            // </GIN>
            // Assume that this is always on account type of ledger
            Debug::assert(_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger);

            ledgerVoucherTransObject = this.initIntercompanyLedgerVoucherTransObject(
                ledgerVoucherObject,
                _posting,
                _ledgerJournalTrans,
                backWardAmount,
                exchangeRateHelper);

            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        else
        {
            // A Bank reversal during cross company posting may not have a journal type of BankChequeReversal.
            //  Check to see if the Bank reversal process must still be performed.
            if (ledgerJournalType == LedgerJournalType::BankChequeReversal ||
                originalJournalType == LedgerJournalType::BankChequeReversal)
            {
                this.chequeReversalUpdate(_ledgerJournalTrans, _ledgerVoucher);
            }

            switch (ledgerJournalType)
            {
                case LedgerJournalType::VendPromissoryNoteRedraw,
                     LedgerJournalType::VendPaymRemittance,
                     LedgerJournalType::VendPromissoryNoteSettle,
                     LedgerJournalType::VendPromissoryNoteDraw :

                    custVendNegInstPost = CustVendNegInstPost::construct(_ledgerJournalTrans, _ledgerVoucher);
                    custVendNegInstPost.post();

                    if (_ledgerJournalTrans.LedgerDimension == _ledgerJournalTrans.OffsetLedgerDimension)
                    {
                        _ledgerJournalTrans.OffsetLedgerDimension = 0;
                    }

                    if (originalJournalType == LedgerJournalType::BankChequeReversal)
                    {
                        vendTrans = this.postNewVendorVoucher(_ledgerJournalTrans, _ledgerVoucher, originalJournalType);
                    }

                    break;

                default :
                    // <GEERU>
                    vendTrans = this.postNewVendorVoucher(_ledgerJournalTrans,
                                                          _ledgerVoucher,
                                                          originalJournalType,
                                                          _ledgerJournalTrans.isVATTaxAgentPaymentFromVendorFunds_RU() ? taxAmount : 0);
                    // </GEERU>
            }

            // <GIN>
            if (TaxWithholdParameters_IN::checkTaxParameters()
                && TaxWithholdParameters_IN::find().CrossCompanyPayment
                && (ledgerJournalTransTaxExt.tdsGroup
                    || ledgerJournalTransTaxExt.tcsGroup))
            {
                while select crossCompany offsetVendTrans
                    group by DataAreaId
                    where offsetVendTrans.OffsetRecid == vendTrans.Recid
                {
                    if (vendTrans.company() != offsetVendTrans.company())
                    {
                        withholdTaxCur = _ledgerVoucher.getWHTInvoiceCompanyFromCache_IN(offsetVendTrans.company(), _ledgerVoucher.lastVoucher());

                        if (ledgerJournalTransTaxExt.TCSGroup)
                        {
                            sign = 1;
                        }

                        dueFromLedgerDimension = LedgerInterCompany::getOriginatingCompanyLedgerDimensionWithAmount(
                            (sign * withholdTaxCur),
                            curExt(),
                            offsetVendTrans.company());

                        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(dueFromLedgerDimension);

                        ledgerVoucherTransObject = this.initIntercompanyLedgerVoucherTransObject_IN(
                            ledgerVoucherObject,
                            _posting,
                            ledgerDimensionMerged,
                            _ledgerJournalTrans,
                            withholdTaxCur,
                            exchangeRateHelper);

                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    }
                }
            }
            // </GIN>
        }

        if (originalAmountCur)
        {
            if (_ledgerJournalTrans.AmountCurCredit)
            {
                _ledgerJournalTrans.AmountCurCredit = originalAmountCur;
            }
            if (_ledgerJournalTrans.AmountCurDebit)
            {
                _ledgerJournalTrans.AmountCurDebit = originalAmountCur;
        }
        }

        if (_posting != LedgerPostingType::InterCompany &&
            ledgerJournalType != LedgerJournalType::VendPromissoryNoteRedraw &&
            ledgerJournalType != LedgerJournalType::VendPaymRemittance &&
            ledgerJournalType != LedgerJournalType::VendPromissoryNoteSettle)
        {
            // Only set if it is not already set. Handles the case of a vendor to vendor transaction
            if (!_ledgerJournalTrans.VendTransId)
            {
                _ledgerJournalTrans.VendTransId = vendTrans.RecId;
            }

            select firstonly forupdate localLedgerJournalTrans
                where localLedgerJournalTrans.RecId == _ledgerJournalTrans.RecId;

            if (localLedgerJournalTrans)
            {
                // Only set if it is not already set. Handles the case of a vendor to vendor transaction
                if (!localLedgerJournalTrans.VendTransId)
                {
                    localLedgerJournalTrans.VendTransId = vendTrans.RecId;
                }

                localLedgerJournalTrans.Tax1099Amount = _ledgerJournalTrans.Tax1099Amount;
                localLedgerJournalTrans.Tax1099StateAmount = _ledgerJournalTrans.Tax1099StateAmount;

                localLedgerJournalTrans.doUpdate();

                select firstonly forupdate tmpVendTransOpen
                    where tmpVendTransOpen.RefRecId == vendTrans.RecId;

                if (tmpVendTransOpen)
                {
                    tmpVendTransOpen.Tax1099Amount = vendTrans.Tax1099Amount;
                    tmpVendTransOpen.Tax1099StateAmount = vendTrans.Tax1099StateAmount;
                    tmpVendTransOpen.update();
                }
            }
        }

        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            AssetBook::updateVendInfo(_ledgerJournalTrans.parmOffsetAccount(),
                                      ledgerJournalTrans_Asset.BookId,
                                      vendTrans.AccountNum,
                                      '',
                                      vendTrans.Invoice,
                                      CurrencyExchangeHelper::amountCur2MST(-_ledgerJournalTrans.amount(), _ledgerJournalTrans.CurrencyCode, 0, _ledgerJournalTrans.TransDate));
        }

        bankRemittanceFilesVend = BankRemittanceFilesVend::find(_ledgerJournalTrans.BankRemittanceFileId, true);
        if (bankRemittanceFilesVend.RecId)
        {
            bankRemittanceFilesVend.Posted = NoYes::Yes;
            bankRemittanceFilesVend.update();
        }

        this.updateBankPromissoryNoteStatus(_ledgerJournalTrans);

        // <GEERU>
        if (countryRegion_RU)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(RAsset)))
            {
                RAssetPurchTrans::post(_ledgerJournalTrans.orig(), vendTrans);
            }
            if (_ledgerJournalTrans.isVatTaxAgentAuthorityPayment_RU())
            {
                this.createLedgerVoucherForTaxAgent_RU(_ledgerJournalTrans,
                                                        _ledgerVoucher);

                if (TaxTable::find(_ledgerJournalTrans.TaxCode).TaxType_W != TaxType_W::Excise)
                {
                factureJour = FactureJourCreate_RU::newVATPaymentFactureLedgerJournalTrans(_ledgerJournalTrans);
                factureJour.OperationTypeCodes = FactureJour_RU::getInitialTypeCodes(factureJour);
                factureJour.doUpdate();
            }
            }
            if (_ledgerJournalTrans.isVatTaxAgentPrepayment_RU())
            {
                this.postVATTransForTaxAgent_RU(_ledgerVoucher, vendTrans, prepaymentLedgerDimension);
            }
        }
        // </GEERU>

        // <GEEPL>
        PlSADFinanceLedgerJournalRef::clearReference(_ledgerJournalTrans.RecId);
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntercompanyLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> when posting type is InterCompany.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> class instance.
    /// </param>
    /// <param name = "_posting">
    /// The posting type.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table buffer for transaction data.
    /// </param>
    /// <param name = "_backWardAmount">
    /// Total Withholding tax amount.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    /// The <c>CurrencyExchangeHelper</c> class instance.
    /// </param>
    /// <returns>
    /// The initialized <c>LedgerVoucherTransObject</c> class instance.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerVoucherTransObject initIntercompanyLedgerVoucherTransObject(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _posting,
        LedgerJournalTrans _ledgerJournalTrans,
        AmountCur _backWardAmount,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _ledgerVoucherObject,
            _posting,
            _ledgerJournalTrans.LedgerDimension,
            _ledgerJournalTrans.CurrencyCode,
            _ledgerJournalTrans.amount() + _backWardAmount,
            _exchangeRateHelper);

        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);
        ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIntercompanyLedgerVoucherTransObject_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> when posting type is other than InterCompany.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> class instance.
    /// </param>
    /// <param name = "_posting">
    /// The posting type.
    /// </param>
    /// <param name = "_ledgerDimensionMerged">
    /// The merged Ledger Dimension.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table buffer for transaction data.
    /// </param>
    /// <param name = "_withholdTaxCur">
    /// Total Withholding tax amount.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    /// The <c>CurrencyExchangeHelper</c> class instance.
    /// </param>
    /// <returns>
    /// The initialized <c>LedgerVoucherTransObject</c> class instance.
    /// </returns>
    [Wrappable(true)]
    protected final ledgerVoucherTransObject initIntercompanyLedgerVoucherTransObject_IN(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerPostingType _posting,
        LedgerDimensionAccount _ledgerDimensionMerged,
        LedgerJournalTrans _ledgerJournalTrans,
        TaxAmountCur _withholdTaxCur,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        ledgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _ledgerVoucherObject,
            _posting,
            _ledgerDimensionMerged,
            _ledgerJournalTrans.CurrencyCode,
            _withholdTaxCur,
            _exchangeRateHelper);
        ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);

        ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePaymFee_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the payment fee.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The payment line.
    /// </param>
    /// <param name="_vendTrans">
    /// The posted vendor transaction.
    /// </param>
    protected void updatePaymFee_JP(LedgerJournalTrans _ledgerJournalTrans, VendTrans _vendTrans)
    {
        #ISOCountryRegionCodes
        VendTrans_W vendTransPaymFee;
        RefRecId paymentLineRecid;
        DataAreaId paymentCompany;
        AmountCur paymFeeAmountCur;

        //Follow the standard logic that bank account is at the offset side
        if (VendPaymFeeUtil_JP::isVendorPaymFeeEnabled()
            && _ledgerJournalTrans.AccountType == LedgerJournalACType::Vend
            && _ledgerJournalTrans.OffsetCompany
            && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
            && _ledgerJournalTrans.PaymMode)
        {
            //For inter company payment
            if (_ledgerJournalTrans.ForeignCompany)
            {
                //switch into payment company
                changeCompany (_ledgerJournalTrans.ForeignCompany)
                {
                    //currently only voucher link is available
                    //asumption here is the payment is with same voucher, same date, to same vendor, same payment method
                    if (ledgerJournalTransIntercompanyMap
                        && ledgerJournalTransIntercompanyMap.exists(_ledgerJournalTrans.RecId))
                    {
                        paymentLineRecid = ledgerJournalTransIntercompanyMap.lookup(_ledgerJournalTrans.RecId);
                    }
                    paymentCompany = _ledgerJournalTrans.ForeignCompany;
                }
            }
            else
            {
                paymentLineRecid = _ledgerJournalTrans.RecId;
                paymentCompany = curext();
            }

            //Get the fee amount
            changeCompany (paymentCompany)
            {
                if (CustVendPaymJournalFee::existVendorCoveredFee_JP(paymentLineRecid))
                {
                    paymFeeAmountCur = CustVendPaymJournalFee::getPaymFeeTotalInTransactionCurrency_JP(paymentLineRecid, true);
                }
            }

            //back to vendor transaction company
            if (paymFeeAmountCur)
            {
                vendTransPaymFee = VendTrans_W::findByVendTrans(_vendTrans.RecId, true);
                if (!vendTransPaymFee.VendTrans)
                {
                    vendTransPaymFee.VendTrans = _vendTrans.RecId;
                }
                vendTransPaymFee.PaymFeeTransactionCurrencyAmount_JP = paymFeeAmountCur;

                //avoid negative payment
                if (_vendTrans.AmountCur < vendTransPaymFee.PaymFeeTransactionCurrencyAmount_JP)
                {
                    throw error(strFmt("@SYS4003231", _vendTrans.Voucher));
                }
                vendTransPaymFee.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPrepaymentSpecTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates <c>SpecTrans</c> line for marking open transaction in Purchase order, based on payment requests
    /// </summary>
    /// <param name="_paymentRequestsCon">
    /// Container of payment requests
    /// </param>
    /// <param name="_vendTrans">
    /// Vendor transaction for creation <c>SpecTrans</c>
    /// </param>
    private void createPrepaymentSpecTrans(Container _paymentRequestsCon, VendTrans _vendTrans)
    {
        VendTransOpen vendTransOpen = vendTransOpen::findRefId(_vendTrans.RecId);

        for (Counter counter = conLen(_paymentRequestsCon); counter > 0; counter--)
        {
            CFMPaymentRequestTable paymentRequest = CFMPaymentRequestTable::findRecID(conPeek(_paymentRequestsCon, counter));
            PurchTable purchTable = PurchTable::findRecId(paymentRequest.HeaderRefRecId);

            SpecTransManager specTransManager = SpecTransManager::newFromSpec(purchTable);

            specTransManager.insert(vendTransOpen.DataAreaId,
                vendTransOpen.TableId,
                vendTransOpen.RecId,
                vendTransOpen.AmountCur,
                _vendTrans.CurrencyCode,
                NoYes::Yes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentRequestsContainer</Name>
				<Source><![CDATA[
    private container getPaymentRequestsContainer(LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans specTrans;
        CFMPaymentRequestTable paymentRequestTable;
        container paymentRequestsCon;

        while select RefRecId from specTrans
            where specTrans.SpecTableId == tableNum(LedgerJournalTrans)
               && specTrans.SpecRecId == _ledgerJournalTrans.RecId
               && specTrans.RefTableId == tableNum(CFMPaymentRequestTable)
                exists join paymentRequestTable
                where paymentRequestTable.RecId == specTrans.RefRecId
                   && paymentRequestTable.SourceType == CFMPaymentRequestSourceType::PlannedPayment
        {
            paymentRequestsCon += specTrans.RefRecId;
        }

        return paymentRequestsCon;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>