<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustPostInvoiceJob</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustPostInvoiceJob extends RunBaseBatch implements BatchRetryable
{
    // The following fields can be directly persisted to a container as they are primitive data types.
    container printerSettingsFreeText;
    container printerSettingsFreeTextCopy;
    
    container subsetRecIdContainer;
    boolean isSubsetJob;

    Counter             numberOfRecords;
    Counter             progressCounter; // Obsolete.  No longer used.
    Printout            printOutWhen;
    NoYes               proforma;
    CustCreditMaxCheck  custCreditMaxCheck;
    NoYes               printOut;
    NoYes               creditError;
    NoYes               usePrintManagement;
    NoYes               areDistributionsNeeded;
    //<GMX>
    Amount              invoiceTotal;
    //</GMX>
    //<GTH>
    TaxUnrealizedDocuId docuSetCode;
    //</GTH>
    // <GEERU>
    PrintInMST_RU       printInMST;
    NoYes               printFacture;
    NoYes               printAcceptanceReport;
    NoYes               printCODCashReceipt_W;
    #ISOCountryRegionCodes
    // </GEERU>

    str                   billingClassification;
    boolean               isBillingClassificationEnabled;
    // <GBR>
    WMSCarrierName        carrierName;
    WMSFreightChargeTerms freightChargeTerms;
    DlvNoOfCarrier_BR     dlvNoOfCarrier;
    DlvStateRegistered_BR dlvStateRegistered;
    DlvTransportBrand_BR  dlvTransportBrand;
    VolumeType_BR         volumeType;
    VolumeQty_BR          volumeQty;
    ItemNetWeight         netWeight;
    GrossWeight           grossWeight;
    // </GBR>

    // <GEEPL>
    PlFiscalDocType fiscalDocType;
    // </GEEPL>

    // <GEEPL>
    IntrastatFulfillmentDate_HU fulfillmentDate;
    // </GEEPL>

    // <GEEU>
    AdvanceInvoiceSettlement_FreeText_W advanceInvoiceSettlement;
    // </GEEU>
    CustInvoiceTableRefRecId custInvoiceTableRecId;

    UseOriginalDocumentAsFacture_RU useOriginalDocumentAsFacture;

    private RefRecId invoiceNumberId;
    private RefRecId invoiceVoucherId;
    private boolean allowSameAs;
    private boolean isFTIValidToUsePreallocNumSeq = true;
    private boolean isNumSeqPreallocated;

    private boolean isTopPickInvoicePosting;
    private guid topPickInvoicePostingProcessId;
    private int countSubsetJobsCreated;
    private int numOfInvoicesToPostThroughTopPicking;

    private const int DefaultTopPickBatchTasks = 8;

    private CustPostInvoiceJobInstrumentationLogger custPostInvoiceJobLogger;

    // The following fields cannot be directly persisted to a container as they are object type.
    QueryRun queryRun; // This field is packed explicitly in the pack method.
    // <GCN>
    container custInvoicecon;
    // </GCN>
    RefRecId  cashRegisterTerminalRecId_W;
    container printReceiptData;

    // This value defines which version of field-list will be persisted and restored via the system's
    // SysLastValue functionality.
    private const Version sysLastValuesCurrentVersion = 102;

    // This list defines which fields will be persisted and restored via the system's
    // SysLastValue functionality (old vesions).
    #DEFINE.SysLastValuesVersion101(101)
    #LOCALMACRO.SysLastValuesListV101
        printOut,
        printOutWhen,
        creditError,
        proforma,
        usePrintManagement,
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
    //<GMX>
        sendByMail,
    //</GMX>
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture,
        // </GEERU>
        // <GBR>
        carrierName,
        freightChargeTerms,
        dlvNoOfCarrier,
        dlvStateRegistered,
        dlvTransportBrand,
        volumeType,
        volumeQty,
        netWeight,
        grossWeight,
        // </GBR>
        // <GTH>
        docuSetCode
        // </GTH>
    #ENDMACRO

    #DEFINE.SysLastValuesForkedFromVersion(7) // Defines what version of CurrentList that SysLastValuesList forked from.

    // This list defines how the object is serialized and unserialized as it is sent across the wire. This
    // list should contain all non-object types defined on this class declaration.
    #DEFINE.CurrentVersion(15)
    #DEFINE.Version15(15)
    #LOCALMACRO.CurrentList
        subsetRecIdContainer,
        isSubsetJob,
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        areDistributionsNeeded,
        invoiceTotal,
    //<GMX>
        sendByMail,
    //</GMX>
    // <GTH>
        docuSetCode,
    // </GTH>
        billingClassification,
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture,
        // </GEERU>
        // <GBR>
        carrierName,
        freightChargeTerms,
        dlvNoOfCarrier,
        dlvStateRegistered,
        dlvTransportBrand,
        volumeType,
        volumeQty,
        netWeight,
        grossWeight,
        // </GBR>
        // <GEEPL>
        fiscalDocType,
        // </GEEPL>
        printCODCashReceipt_W, 
        cashRegisterTerminalRecId_W, 
        printReceiptData,
        useOriginalDocumentAsFacture
    #ENDMACRO

    #DEFINE.Version14(14)
    #LOCALMACRO.CurrentListV14
        subsetRecIdContainer,
        isSubsetJob,
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        areDistributionsNeeded,
        invoiceTotal,
    //<GMX>
        sendByMail,
    //</GMX>
    // <GTH>
        docuSetCode,
    // </GTH>
        billingClassification,
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture,
        // </GEERU>
        // <GBR>
        carrierName,
        freightChargeTerms,
        dlvNoOfCarrier,
        dlvStateRegistered,
        dlvTransportBrand,
        volumeType,
        volumeQty,
        netWeight,
        grossWeight,
        // </GBR>
        // <GEEPL>
        fiscalDocType,
        // </GEEPL>
        printCODCashReceipt_W,
        cashRegisterTerminalRecId_W,
        printReceiptData
    #ENDMACRO

    // This list defines how the object is serialized and unserialized as it is sent across the wire. This
    // list should contain all non-object types defined on this class declaration (old versions).
    #DEFINE.Version13(13)
    #LOCALMACRO.CurrentListV13
        subsetRecIdContainer,
        isSubsetJob,
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        areDistributionsNeeded,
        invoiceTotal,
    //<GMX>
        sendByMail,
    //</GMX>
    // <GTH>
        docuSetCode,
    // </GTH>
        billingClassification,
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture,
        // </GEERU>
        // <GBR>
        carrierName,
        freightChargeTerms,
        dlvNoOfCarrier,
        dlvStateRegistered,
        dlvTransportBrand,
        volumeType,
        volumeQty,
        netWeight,
        grossWeight,
        // </GBR>
        // <GEEPL>
        fiscalDocType
        // </GEEPL>
    #ENDMACRO



    #DEFINE.Version12(12)
    #LOCALMACRO.CurrentListV12
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        areDistributionsNeeded,
        invoiceTotal,
    //<GMX>
        sendByMail,
    //</GMX>
    // <GTH>
        docuSetCode,
    // </GTH>
        billingClassification,
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture,
        // </GEERU>
        // <GBR>
        carrierName,
        freightChargeTerms,
        dlvNoOfCarrier,
        dlvStateRegistered,
        dlvTransportBrand,
        volumeType,
        volumeQty,
        netWeight,
        grossWeight,
        // </GBR>
        // <GEEPL>
        fiscalDocType
        // </GEEPL>
    #ENDMACRO

    #DEFINE.Version11(11)
    #LOCALMACRO.CurrentListV11
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        areDistributionsNeeded,
        invoiceTotal,
    //<GMX>
        sendByMail,
    //</GMX>
        billingClassification,
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture,
        // </GEERU>
        // <GBR>
        carrierName,
        freightChargeTerms,
        dlvNoOfCarrier,
        dlvStateRegistered,
        dlvTransportBrand,
        volumeType,
        volumeQty,
        netWeight,
        grossWeight,
        // </GBR>
        // <GEEPL>
        fiscalDocType
        // </GEEPL>
    #ENDMACRO

    #DEFINE.Version10(10)
    #LOCALMACRO.CurrentListV10
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        areDistributionsNeeded,
        invoiceTotal,
    //<GMX>
        sendByMail
    //</GMX>
    #ENDMACRO

    // <GEERU>
    #DEFINE.Version7(7)
    #LOCALMACRO.CurrentListV8V7
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement,
        printInMST,
        printAcceptanceReport,
        printFacture
    #ENDMACRO
    // </GEERU>
    #DEFINE.Version7(7)
    #LOCALMACRO.CurrentListV7
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        numberOfRecords,
        printOutWhen,
        proforma,
        custCreditMaxCheck,
        printOut,
        creditError,
        usePrintManagement
    #ENDMACRO

    #DEFINE.Version6(6)
    #LOCALMACRO.CurrentListV6
        printOut,
        printOutWhen,
        creditError,
        proforma,
        usePrintManagement,
        printerSettingsFreeText,
        printerSettingsFreeTextCopy,
        // <GEERU>
        printInMST,
        printAcceptanceReport,
        printFacture
        // </GEERU>
    #ENDMACRO

    #DEFINE.Version5(5)
    #LOCALMACRO.CurrentListV5
        printOut,
        printOutWhen,
        creditError
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEditCODCashReceipt_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Chechs allowance for editing information related to Cash Transaction.
    /// </summary>
    /// <returns>True - changes are allowed, false - otherwise.</returns>
    public boolean allowEditCODCashReceipt_W()
    {
        QueryRun queryRunLoc = new queryRun(this.queryRun().pack());
        Query query = queryRunLoc.query();
        QueryBuildDataSource qbdsCustInvoiceTable = query.dataSourceTable(tableNum(CustInvoiceTable));
        qbdsCustInvoiceTable.firstOnly(true);

        QueryBuildDataSource qbdsPaymTerm = qbdsCustInvoiceTable.addDataSource(tableNum(PaymTerm));
        qbdsPaymTerm.joinMode(joinMode::ExistsJoin);
        qbdsPaymTerm.relations(true);
        qbdsPaymTerm.addRange(fieldNum(PaymTerm, CashLedgerDimension)).value(SysQuery::valueNot(0));

        QueryBuildDataSource qbdsCashRegisterPaymMode = qbdsCustInvoiceTable.addDataSource(tableNum(CashRegisterPaymMode_W));
        qbdsCashRegisterPaymMode.joinMode(joinMode::ExistsJoin);
        qbdsCashRegisterPaymMode.addLink(fieldNum(CustInvoiceTable, PaymMode), fieldNum(CashRegisterPaymMode_W, PaymMode));

        return queryRunLoc.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns false.
    /// </summary>
    /// <returns>
    ///    Always returns false.
    /// </returns>
    /// <remarks>
    ///    This method must be in this class because it is called from the <c>DialogRunbase</c> class.
    /// </remarks>
    public boolean canGoBatch()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    /// true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A class that can be used in a batch journal is a class where the same parameters can be used
    /// repeatedly. The dialog box can be shown and the parameters can be changed but parameters of some
    /// classes might build on data that is only valid for a short time. Running a class two times with the
    /// same parameters is not always possible. If the <see cref="M:RunBaseBatch.canGoBatch" /> method
    /// returns false, this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdvancePayments_W</Name>
				<Source><![CDATA[
    private boolean checkAdvancePayments_W(boolean _showBox = false)
    {
        boolean ret = true;
        str errorStr = "",
                         errorStr2 = "";

        Set custSet = new Set(Types::Container);
        SetIterator custIterator;

        QueryRun localQR = new QueryRun(queryRun.query());
        CustInvoiceTable localInvoiceTable;

        Set invoiceSet = new Set(Types::Int64);
        boolean advanceAdjustment = LedgerParameters::find().AdvanceAdjustment_W || EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled();

        if (! CzCustAdvanceInvoiceTable::featureEnabled() && ! advanceAdjustment)
        {
            return true;
        }

        while (localQR.next())
        {
            localInvoiceTable = localQR.get(tableNum(CustInvoiceTable));

            if (invoiceSet.in(localInvoiceTable.RecId))
                continue;
            invoiceSet.add(localInvoiceTable.RecId);
            custSet.add([localInvoiceTable.company(), localInvoiceTable.InvoiceAccount]);

            if ((advanceAdjustment &&
                CustVendExchAdjustment_W::existsPrepayments(ModuleCustVend::Cust,
                                                            localInvoiceTable.InvoiceAccount,
                                                            localInvoiceTable.InvoiceDate)) ||
                (CzCustAdvanceInvoiceLink::existsPaymentForFreeText(localInvoiceTable.company(), localInvoiceTable.RecId) &&
                ! SpecTrans::findBySpec(localInvoiceTable.DataAreaId, tableNum(CustInvoiceTable), localInvoiceTable.RecId)))
            {
                if (_showBox)
                {
                    errorStr = (errorStr ?
                                strFmt("@SYS26868", errorStr, '<' + strFmt("@GLS111171",
                                                                           localInvoiceTable.InvoiceAccount,
                                                                           localInvoiceTable.InvoiceDate,
                                                                           localInvoiceTable.RecId) + '>') :
                                '<' + strFmt("@GLS111171",
                                             localInvoiceTable.InvoiceAccount,
                                             localInvoiceTable.InvoiceDate,
                                             localInvoiceTable.RecId) + '>');
                }
                else
                {
                    warning(strFmt("@GLS111760", '<' + strFmt("@GLS111171",
                                                             localInvoiceTable.InvoiceAccount,
                                                             localInvoiceTable.InvoiceDate,
                                                             localInvoiceTable.RecId) + '>'));
                }
            }

            if (this.parmAdvanceInvoiceSettlement_W())
            {
                errorStr2 = this.parmAdvanceInvoiceSettlement_W().checkSettlement(localInvoiceTable);
            }
        }

        if (_showBox)
        {
            if (errorStr)
            {
                ret = Box::okCancel(strFmt("@GLS111761", errorStr),
                                    DialogButton::Cancel) == DialogButton::Ok;
            }

            if (errorStr2 && ret)
            {
                ret = Box::okCancel(errorStr2, DialogButton::Cancel) == DialogButton::Ok;
            }
        }
        else if (! advanceAdjustment)
        {
            custIterator = new SetIterator(custSet);
            while (custIterator.more())
            {
                if (CzCustAdvanceInvoiceLink::existsNonLinkedPayment(conPeek(custIterator.value(), 1),
                                                                     CustTable::find(conPeek(custIterator.value(), 2)).Party))
                {
                    info(strFmt("@GLS111758", conPeek(custIterator.value(), 2)));
                }

                if (CzCustAdvanceInvoiceLink::existsPaymentLinkedToManual(conPeek(custIterator.value(), 1),
                                                                          conPeek(custIterator.value(), 2)))
                {
                    info(strFmt("@GLS111759", conPeek(custIterator.value(), 2)));
                }

                custIterator.next();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFundingLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the invoice for limit errors
    /// </summary>
    /// <returns>
    /// <c>False</c> if there is a funding limit error, otherwise <c>true</c>.
    /// </returns>
    protected boolean checkFundingLimit()
    {
        CustInvoiceTable custInvoice;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            select firstonly SourceDocumentHeader from custInvoice where custInvoice.RecId == custInvoiceTableRecId;
            if (ProjFundingLimitTrackingManager::hasLimitErrorSourceDocument(custInvoice.SourceDocumentHeader))
            {
                return checkFailed("@SYS4110061");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkIntrastatFulfillmentDate_HU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates Intrastat fulfillment date.
    /// </summary>
    /// <param name="_custInvoiceTable">
    /// The <c>CustInvoiceTable</c> record that needs to be reported for Intrastat.
    /// </param>
    /// <returns>
    /// true if Intrastat fulfillment date is valid; otherwise, false.
    /// </returns>
    public boolean checkIntrastatFulfillmentDate_HU(CustInvoiceTable _custInvoiceTable)
    {
        LogisticsPostalAddress countryPostalAddress = LogisticsPostalAddress::findRecId(_custInvoiceTable.PostalAddress);

        if (!countryPostalAddress.CountryRegionId)
        {
            return checkFailed("@GLS107637");
        }

        if (!IntrastatCountryRegionParameters::isCountryRegionStateInEU(countryPostalAddress))
        {
            return true;
        }

        IntrastatParameters intrastatParameters = IntrastatParameters::find();
        if (intrastatParameters.IntrastatFulfillmentDateEmptyWarning_HU && ! _custInvoiceTable.IntrastatFulfillmentDate_HU)
        {
            setPrefix(strFmt("@SYS26938",
                                 _custInvoiceTable.InvoiceAccount,
                                 _custInvoiceTable.InvoiceDate));

            return checkFailed(strFmt("@SYS26332", fieldPName(SalesTable, IntrastatFulfillmentDate_HU)));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustPostInvoice_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates an instance of the <c>CustPostInvoice</c> class.
    /// </summary>
    /// <param name="_custInvoiceTable">
    ///     The record of the <c>CustInvoiceTable</c> table.
    /// </param>
    /// <param name="_typeOfCreditmaxCheck">
    ///     The credit limit type; optional.
    /// </param>
    /// <param name="_creditError">
    ///     Yes if any invoice can be a correction not just negative invoices; optional.
    /// </param>
    /// <returns>
    ///     The instance of the <c>CustPostInvoice</c> class.
    /// </returns>
    protected CustPostInvoice createCustPostInvoice_RU( CustInvoiceTable _custInvoiceTable,
                                                        TypeOfCreditmaxCheck _typeOfCreditmaxCheck = CustParameters::find().CreditMaxCheck,
                                                        NoYes _creditError = NoYes::No)
    {
        return CustPostInvoice::construct(_custInvoiceTable,
                                          _typeOfCreditmaxCheck,
                                          _creditError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPostInvoiceProformaTopPick</Name>
				<Source><![CDATA[
    public void custPostInvoiceProformaTopPick()
    {
        CustInvoiceTable custInvoiceTable;
        RecordSortedList recordSortedList = new RecordSortedList(tableNum(CustInvoiceTable));
        recordSortedList.sortOrder(fieldNum(CustInvoiceJour, RecId));

        CustPostInvoiceJobProcessingQueue custPostInvoiceJobProcessingQueue;

        // Allow read past when posting in batch
        custPostInvoiceJobProcessingQueue.readPast(this.isSubsetJob);

        System.Exception systemException;
        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockException;
        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        CustPrintOutInvoice custPrintOutInvoice = this.initializeCustPrintOutInvoiceProforma();

        using (var custPostInvoiceProformaActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCustPostInvoiceProforma))
        {
            do
            {
                ttsbegin;

                select firstonly pessimisticlock * from custPostInvoiceJobProcessingQueue
                    where custPostInvoiceJobProcessingQueue.ProcessId == this.topPickInvoicePostingProcessId;

                custInvoiceTable = CustInvoiceTable::findRecId(custPostInvoiceJobProcessingQueue.CustInvoiceTable);

                boolean canPrintInvoice = custPostInvoiceJobProcessingQueue
                    && custPostInvoiceJobProcessingQueue.CustInvoiceTable
                    && custInvoiceTable;

                if (canPrintInvoice)
                {
                    custPostInvoiceJobProcessingQueue.delete();
                }

                ttscommit;

                if (canPrintInvoice)
                {
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU])
                        && !this.checkIntrastatFulfillmentDate_HU(custInvoiceTable))
                    {
                        checkFailed("@SYS18738");
                        continue;
                    }

                    if (!custInvoiceTable.Posted)
                    {
                        proforma = NoYes::Yes;
                    }

                    setPrefix(#PreFixField( CustInvoiceTable, InvoiceAccount));

                    recordSortedList.ins(custInvoiceTable);
                }
            }

            while (custPostInvoiceJobProcessingQueue);

            custPrintOutInvoice.printOut(proforma,
                                        recordSortedList,
                                        NoYes::Yes,
                                        printOutWhen,
                                        usePrintManagement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPostInvoiceProforma</Name>
				<Source><![CDATA[
    public void custPostInvoiceProforma()
    {
        CustPrintOutInvoice custPrintOutInvoice;
        CustInvoiceTable custInvoiceTable;
        Counter progressTotal;

        RecordSortedList recordSortedList = new RecordSortedList(tableNum(CustInvoiceTable));

        recordSortedList.sortOrder(fieldNum(CustInvoiceJour,RecId));
        progressTotal = QueryRun::getQueryRowCount(queryRun.query(), intMax());

        using (var custPostInvoiceProformaActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCustPostInvoiceProforma))
        {
            if (progressTotal)
            {
                custPrintOutInvoice = this.initializeCustPrintOutInvoiceProforma();

                queryRun.query().dataSourceTable(tableNum(CustInvoiceTable)).update(true);
                queryRun.query().dataSourceTable(tableNum(CustInvoiceTable)).concurrencyModel(ConcurrencyModel::Optimistic);

                if (this.isInBatch())
                {
                    var recIdRange = SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(CustInvoiceTable)), fieldNum(CustInvoiceTable, RecId));
                    recIdRange.value(con2Str(this.parmSubsetRecIdContainer()));
                }

                while (queryRun.next())
                {
                    custInvoiceTable = queryRun.get(tableNum(CustInvoiceTable));

                    // <GEEHU>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU])
                        && ! this.checkIntrastatFulfillmentDate_HU(custInvoiceTable))
                    {
                        checkFailed("@SYS18738");
                        continue;
                    }
                    // </GEEHU>

                    ttsbegin;

                    if (!custInvoiceTable.Posted)
                    {
                        proforma = NoYes::Yes;
                    }

                    setPrefix(#PreFixField( CustInvoiceTable, InvoiceAccount));

                    recordSortedList.ins(custInvoiceTable);

                    ttscommit;
                }

                custPrintOutInvoice.printOut(proforma,
                                             recordSortedList,
                                             NoYes::Yes,
                                             printOutWhen,
                                             usePrintManagement);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustPostProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>CustPostInvoice</c> instance.
    /// </summary>
    /// <returns>A newly initialized <c>CustPostInvoice</c> instance.</returns>
    protected CustPostInvoice initializeCustPostProcess()
    {
        CustPostInvoice custPostInvoice;
        CustInvoiceTable custInvoiceTable;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            custPostInvoice = this.createCustPostInvoice_RU(custInvoiceTable, custCreditMaxCheck, creditError);
        }
        // </GEERU>
        else
        {
            custPostInvoice = CustPostInvoice::construct(custInvoiceTable, custCreditMaxCheck, creditError);
        }

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            custPostInvoice.parmFiscalDocType_PL(fiscalDocType);
        }
        // </GEEPL>

        custPostInvoice.parmCashRegisterTerminalRecId(cashRegisterTerminalRecId_W);
        custPostInvoice.parmUseOriginalDocumentAsFacture_RU(useOriginalDocumentAsFacture);

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            custPostInvoice.parmPrintInMST_RU(printInMST);
        }
        // </GEERU>

        return custPostInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustPrintOutInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>CustPrintOutInvoice</c> instance.
    /// </summary>
    /// <returns>A newly initialized <c>CustPrintOutInvoice</c> instance.</returns>
    protected CustPrintOutInvoice initializeCustPrintOutInvoice()
    {
        CustPrintOutInvoice custPrintOutInvoice;

        if (printOut == NoYes::Yes
            // <GEERU>
        || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && (printAcceptanceReport == NoYes::Yes || printFacture))
            )
            // </GEERU>
        {
            custPrintOutInvoice = CustPrintOutInvoice::newPrintOriginalCopy(printerSettingsFreeText, printerSettingsFreeTextCopy, this.isInBatch());

            custPrintOutInvoice.parmShowWarningMessageSendToXML(false);

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                custPrintOutInvoice.parmPrintFormLetter_RU(printOut);
                custPrintOutInvoice.parmPrintAcceptanceReport_RU(printAcceptanceReport);
                custPrintOutInvoice.parmPrintFacture_RU(printFacture);
                custPrintOutInvoice.parmPrintInMST_RU(printInMST);
            }
            // </GEERU>
        }

        return custPrintOutInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWorkFlowStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if workflow approval status is 'Approved' or blank for posting invoice.
    /// </summary>
    /// <param name = "_custInvoiceTable">
    ///     A <c>CustInvoiceTable</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if invoice should be posted; otherwise, false.
    /// </returns>
    protected boolean validateWorkFlowStatus(CustInvoiceTable _custInvoiceTable)
    {
        return _custInvoiceTable.WorkflowApprovalStatus == CustFreeInvoiceWFApprovalStatus::Approved ||
            _custInvoiceTable.WorkflowApprovalStatus == CustFreeInvoiceWFApprovalStatus::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustPostInvoiceUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the processing of individual customer invoices as a part of the CustPostInvoiceUpdate process.
    /// </summary>
    /// <param name = "_custInvoiceTable">The customer invoice.</param>
    /// <param name = "_custPostInvoice">A <c>CustPostInvoice</c> instance to use for processing.</param>
    /// <param name = "_recordSortedList">A <c>RecordSortedList</c> used to store processed invoice documents.</param>
    /// <param name = "_custPrintOutInvoice">A <c>CustPrintOutInvoice</c> instance to use for processing.</param>
    protected void processCustPostInvoiceUpdate(
        CustInvoiceTable _custInvoiceTable, 
        CustPostInvoice _custPostInvoice, 
        CustPrintOutInvoice _custPrintOutInvoice,
        RecordSortedList _recordSortedList)
    {
        SourceDocumentHeader sourceDocumentHeader = SourceDocumentHeader::find(_custInvoiceTable.SourceDocumentHeader);
        // <GCN>
        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            custInvoicecon += _custInvoiceTable.RecId;
        }
        // </GCN>
        _custPostInvoice.parmAreDistributionsNeeded(true);

        numberOfRecords++;

        // <GEEHU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU])
                && ! this.checkIntrastatFulfillmentDate_HU(_custInvoiceTable))
        {
            checkFailed("@SYS18738");
            return;
        }
        // </GEEHU>

        setprefix(#PreFixField(_custInvoiceTable, invoiceAccount));

        _custPostInvoice.parmCustInvoiceTable(_custInvoiceTable);
        _custPostInvoice.parmIsInBatch(this.isInBatch());
        if (CustPostInvoiceJobPreallocatedNumberSequenceFlight::instance().isEnabled() && this.parmIsNumSeqPreallocated())
        {
            _custPostInvoice.parmInvoiceNumberNumSeqRefRecId(this.parmInvoiceNumberId());
            _custPostInvoice.parmInvoiceVoucherNumSeqRefRecId(this.parmInvoiceVoucherId());
            _custPostInvoice.parmAllowSameAs(this.parmAllowSameAs());
            _custPostInvoice.parmIsNumSeqPreallocated(true);
        }

        // <GEEU>
        _custPostInvoice.parmAdvanceInvoiceSettlement_W(this.parmAdvanceInvoiceSettlement_W());
        // </GEEU>

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled()
                && printOut == NoYes::Yes)
        {
            _custPrintoutInvoice.parmDocuSetCode(this.parmDocuSetCode());
        }
        // </GTH>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            _custPostInvoice.initBillOfLadingParameters_BR(carrierName,
                                                              freightChargeTerms,
                                                              dlvNoOfCarrier,
                                                              dlvStateRegistered,
                                                              dlvTransportBrand,
                                                              volumeType,
                                                              volumeQty,
                                                              netWeight,
                                                              grossWeight);
        }
        // </GBR>

        // Before posting a corrected invoice run additional validation and make changes to the parent invoice.
        if (_custInvoiceTable.isCorrectedInvoice())
        {
            try
            {
                ttsbegin;

                CustFreeInvoiceCorrectionPost custFreeInvoiceCorrectionPost = CustFreeInvoiceCorrectionPost::newCorrectedInvoice(_custInvoiceTable);

                custFreeInvoiceCorrectionPost.post();

                // post corrected invoice.
                _custPostInvoice.run();

                if (_custPostInvoice.isPostingOK())
                {
                    custFreeInvoiceCorrectionPost.settleCorrectedInvoice();
                }
                else
                {
                    throw Exception::Error;
                }

                ttscommit;
            }
            catch
            {
                ttsabort;
                return;
            }
        }

        // Execute posting process only if FTI workflow approval status is 'Approved' or blank
        else if (this.validateWorkFlowStatus(_custInvoiceTable))
        {
            SalesTable salesTable = SalesTable::find(_custInvoiceTable.SalesId);
            if (salesTable.mcrIsCallCenter())
            {
                try
                {
                    MCRCustPaymTotals mcrCustPaymTotals;
                    MCRCustPaymTable mcrCustPaymTable = MCRCustPaymTable::findByRefRecIDRefTableID(_custInvoiceTable.RecId,_custInvoiceTable.TableId);

                    // Authorize the payments if MCR processing is on
                    if (mcrCustPaymTable)
                    {
                        mcrCustPaymTotals =
                                MCRCustPaymTotals::construct(_custInvoiceTable.TableId,
                                                        _custInvoiceTable.RecId);
                        mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostOnlyPrepays,true);
                    }

                    // check to ensure all payments are approved before posting
                    if (mcrCustPaymTotals
                                && mcrCustPaymTotals.allPaymentsApproved())
                    {
                        _custPostInvoice.run();
                        // If the invoiced is posted then settle payments (capture any credit cards).
                        if (_custPostInvoice.isPostingOK())
                        {
                            mcrCustPaymTotals.processPayments(MCRProcessPaymAction::PostAll,true);
                            mcrCustPaymTotals.settlePayments(true);
                        }
                    }
                    else
                    {
                        throw error("@MCR10966");
                    }
                }
                catch
                {
                    return;
                }
            }
            else
            {
                try
                {
                    _custPostInvoice.run();
                }
                catch
                {
                    return;
                }
            }
        }
        else
        {
            info("@SYS311635");
            error("@SYS25904");
        }

        if (_custPostInvoice.isPostingOK())
        {
            CashRegisterProcessingBase::sendFromCustInvoiceJournal(_custPostInvoice.parmCustInvoiceTable().custInvoiceJour());
        }

        this.constructCustVendPaymInvoice(_custPostInvoice, _custInvoiceTable);

        _custInvoiceTable.reread();

        _recordSortedList.ins(_custInvoiceTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>printOutInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the printing of the posted invoices.
    /// </summary>
    /// <param name = "_recordSortedList">A <c>RecordSortedList</c> used to store processed invoice documents.</param>
    /// <param name = "_custPostInvoice"><c>CustPostInvoice</c>.</param>
    /// <param name = "_custPrintOutInvoice">A <c>CustPrintOutInvoice</c> instance to use for post-processing.</param>
    protected void printOutInvoice(RecordSortedList _recordSortedList, CustPostInvoice _custPostInvoice, CustPrintOutInvoice _custPrintOutInvoice)
    {
        using (var printOutInvoiceActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobPrintOutInvoice))
        {
            if (_custPostInvoice.isPostingOK() && (printOut == NoYes::Yes || printAcceptanceReport == NoYes::Yes || printFacture))
            {
                if (printOutWhen == Printout::After && _recordSortedList.len())
                {
                    this.printInvoice(_custPrintoutInvoice, _recordSortedList, false);
                }
            }

            if (_custPostInvoice.isPostingOK() && printCODCashReceipt_W)
            {
                printReceiptData = CashReceiptPrinting_W::prepareForPrintingReceipt(_custPostInvoice, _recordSortedList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printOutInvoiceCurrent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the printing of the current posted invoice.
    /// </summary>
    /// <param name = "_recordSortedList">A <c>RecordSortedList</c> used to store processed invoice documents.</param>
    /// <param name = "_custPostInvoice"><c>CustPostInvoice</c>.</param>
    /// <param name = "_custInvoiceTable">A <c>CustInvoiceTable</c> used for processing.</param>
    /// <param name = "_custPrintOutInvoice">A <c>CustPrintOutInvoice</c> instance to use for post-processing.</param>
    private void printOutInvoiceCurrent(RecordSortedList _recordSortedList, CustPostInvoice _custPostInvoice, CustInvoiceTable _custInvoiceTable, CustPrintOutInvoice _custPrintOutInvoice)
    {
        using (var printOutInvoiceCurrentActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobPrintOutInvoiceCurrent))
        {
            if (_custPostInvoice.isPostingOK() && (printOut == NoYes::Yes || printAcceptanceReport == NoYes::Yes || printFacture))
            {
                try
                {
                    this.printInvoice(_custPrintoutInvoice, _recordSortedList, true);
                }
                finally
                {
                    _recordSortedList.del(_custInvoiceTable);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printInvoice</Name>
				<Source><![CDATA[
    private void printInvoice(CustPrintoutInvoice _custPrintoutInvoice, RecordSortedList _recordSortedList, boolean _sendInvoiceToGER)
    {
        _custPrintoutInvoice.printOut(
            NoYes::No,
            _recordSortedList,
            NoYes::No,
            printOutWhen,
            usePrintManagement,
            TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled() ? PrintCopyOriginal::Original :PrintCopyOriginal::OriginalPrint,
            _sendInvoiceToGER);
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPostInvoiceUpdateTopPick</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes customer invoices for posting from the CustPostInvoiceJobProcessingQueue.
    /// </summary>
    public void custPostInvoiceUpdateTopPick()
    {
        CustInvoiceTable custInvoiceTable;
        
        RecordSortedList recordSortedList = new RecordSortedList(tablenum(CustInvoiceTable));
        recordSortedList.sortOrder(fieldnum(CustInvoiceTable,RecId));

        CustPostInvoice custPostInvoice = this.initializeCustPostProcess();
        CustPrintOutInvoice custPrintOutInvoice = this.initializeCustPrintOutInvoice();

        setPrefix("@AccountsReceivable:FreeTextInvoicePostingProcessComplete");

        CustPostInvoiceJobProcessingQueue custPostInvoiceJobProcessingQueue;

        // Allow read past when posting in batch
        custPostInvoiceJobProcessingQueue.readPast(this.isSubsetJob);

        System.Exception systemException;
        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        using (var custPostInvoiceUpdateTopPickActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCustPostInvoiceUpdateTopPick))
        {
            do
            {
                try
                {
                    ttsbegin;

                    select firstonly pessimisticlock * from custPostInvoiceJobProcessingQueue
                        where custPostInvoiceJobProcessingQueue.ProcessId == this.topPickInvoicePostingProcessId;

                    custInvoiceTable = CustInvoiceTable::findRecId(custPostInvoiceJobProcessingQueue.CustInvoiceTable);

                    boolean canPostInvoice = custPostInvoiceJobProcessingQueue
                        && custPostInvoiceJobProcessingQueue.CustInvoiceTable
                        && custInvoiceTable;

                    if (canPostInvoice)
                    {
                        custPostInvoiceJobProcessingQueue.delete();
                    }

                    ttscommit;

                    if (canPostInvoice)
                    {
                        this.processCustPostInvoiceUpdateTopPick(
                            custInvoiceTable,
                            custPostInvoice,
                            custPrintOutInvoice,
                            recordSortedList);
                    }
                }
                catch (transientSqlConnectionError)
                {
                    if (appl.ttsLevel() == 0)
                    {
                        if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
                        {
                            retry;
                        }
                        else
                        {
                            custPostInvoiceJobLogger.logException(
                                transientSqlConnectionError,
                                strFmt('Transient SQL connection error. ttsLevel:%1, isInBatch:%2',
                                    appl.ttsLevel(),
                                    custPostInvoiceJobLogger.bool2str(this.isInBatch())));

                            throw transientSqlConnectionError;
                        }
                    }
                    else
                    {
                        throw transientSqlConnectionError;
                    }
                }
                catch (systemException)
                {
                    custPostInvoiceJobLogger.logError(
                        strFmt('System exception. inBatch:%1, Record:%2',
                            custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                            int642Str(custPostInvoice.parmCustInvoiceTable().RecId)));

                    this.postProcessCustPostInvoiceUpdateError(custPostInvoice);
                }
            }
            while (custPostInvoiceJobProcessingQueue);

            this.printOutInvoice(recordSortedList, custPostInvoice, custPrintOutInvoice);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processCustPostInvoiceUpdateTopPick</Name>
				<Source><![CDATA[
    private void processCustPostInvoiceUpdateTopPick(
        CustInvoiceTable _custInvoiceTable,
        CustPostInvoice _custPostInvoice,
        CustPrintOutInvoice _custPrintOutInvoice,
        RecordSortedList _recordSortedList)

    {
        #OCCRetryCount
        int backOffWait;

        Microsoft.Dynamics.Ax.Xpp.DeadlockException deadLockException;
        Microsoft.Dynamics.Ax.Xpp.UpdateConflictException updateConflictException;
        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        using (var processCustPostInvoiceUpdateTopPickActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobProcessCustPostInvoiceUpdateTopPick))
        {
            try
            {
                backOffWait = RandomGenerate::construct().randomInt(100, 5000);

                ttsbegin;
                    
                this.processCustPostInvoiceUpdate(_custInvoiceTable, _custPostInvoice, _custPrintOutInvoice, _recordSortedList);

                ttscommit;

                if (printOutWhen == Printout::Current)
                {
                    this.printOutInvoiceCurrent(_recordSortedList, _custPostInvoice, _custInvoiceTable, _custPrintOutInvoice);
                }

                this.postProcessCustPostInvoiceUpdate(_custPostInvoice);
            }
            catch (deadLockException)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() <= #RetryNum)
                    {
                        sleep(xSession::currentRetryCount() * backOffWait);
                        retry;
                    }
                    else
                    {
                        custPostInvoiceJobLogger.logException(
                            deadlockException, 
                            strFmt('Maximum retry on deadlock exception. retry count:%1, isInBatch:%2, recid:%3',
                                    xSession::currentRetryCount(),
                                    custPostInvoiceJobLogger.bool2str(this.isInBatch()), 
                                    _custInvoiceTable.RecId));

                        throw deadLockException;
                    }
                }
                else
                {
                    custPostInvoiceJobLogger.logException(
                        deadlockException, 
                        strFmt('Deadlock. retry count:%1, isInBatch:%2, recid:%3',
                            xSession::currentRetryCount(),
                            custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                            _custInvoiceTable.RecId));

                    throw deadLockException;
                }
                retry;
            }

            catch (updateConflictException)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (xSession::currentRetryCount() <= #RetryNum)
                    {
                        sleep(xSession::currentRetryCount() * backOffWait);
                        retry;
                    }
                    else
                    {
                        custPostInvoiceJobLogger.logException(
                            updateConflictException, 
                            strFmt('Maximum retry on update conflict exception. retry count:%1, isInBatch:%2, recid:%3',
                                xSession::currentRetryCount(),
                                custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                                _custInvoiceTable.RecId));

                        throw Exception::UpdateConflictNotRecovered;
                    }
                }
                else
                {
                    custPostInvoiceJobLogger.logException(
                        updateConflictException, 
                        strFmt('Update conflict. ttsLevel:%1, isInBatch:%2, recid:%3',
                            appl.ttsLevel(), 
                            custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                            _custInvoiceTable.RecId));

                    throw updateConflictException;
                }
            }
            catch (transientSqlConnectionError)
            {
                if (appl.ttsLevel() == 0)
                {
                    if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
                    {
                        retry;
                    }
                    else
                    {
                        custPostInvoiceJobLogger.logException(
                            transientSqlConnectionError,
                            strFmt('Maximum retry on Transient SQL connection error. retry count:%1, isInBatch:%2, recid:%3',
                                xSession::currentRetryCount(),
                                custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                                _custInvoiceTable.RecId));

                        throw transientSqlConnectionError;
                    }
                }
                else
                {
                    custPostInvoiceJobLogger.logException(
                        transientSqlConnectionError,
                        strFmt('Transient SQL connection error. ttsLevel:%1, isInBatch:%2, recid:%3',
                            appl.ttsLevel(),
                            custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                            _custInvoiceTable.RecId));

                    throw transientSqlConnectionError;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>custPostInvoiceUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes customer invoices for posting.
    /// </summary>
    public void custPostInvoiceUpdate()
    {
        // Second connection requires that this method owns its transaction scope
        boolean isUsingSecondConnection = appl.ttsLevel() == 0;
            
        UserConnection secondConnection;

        RecordSortedList recordSortedList;
        SourceDocumentHeader sourceDocumentHeader;

        recordSortedList = new RecordSortedList(tablenum(CustInvoiceTable));
        recordSortedList.sortOrder(fieldnum(CustInvoiceTable,RecId));

        CustPostInvoice custPostInvoice = this.initializeCustPostProcess();
        CustPrintOutInvoice custPrintOutInvoice = this.initializeCustPrintOutInvoice();

        this.queryBuildUpdate();
        this.updateCustPostInvoiceJobQueue();

        setPrefix("@AccountsReceivable:FreeTextInvoicePostingProcessComplete");

        CustPostInvoiceJobQueue custPostInvoiceJobQueue;
        custPostInvoiceJobQueue.readPast(true);

        boolean stopInvoicePostingOnFirstError = CustParameters::find().FreeTextInvoiceStopInvoicePostingOnFirstError == NoYes::Yes;

        boolean canPostInvoice;

        using (var custPostInvoiceUpdateActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCustPostInvoiceUpdate))
        {
            while (queryRun.next())
            {
                System.Exception exception;

                try
                {
                    ttsbegin;

                    var custInvoiceTable = queryRun.get(tablenum(CustInvoiceTable));

                    if (isUsingSecondConnection)
                    {
                        secondConnection = new UserConnection();

                        custPostInvoiceJobQueue.setConnection(secondConnection);

                        secondConnection.ttsbegin();

                        select firstonly pessimisticlock CustInvoiceTableRecId from custPostInvoiceJobQueue
                            where custPostInvoiceJobQueue.CustInvoiceTableRecId == custInvoiceTable.RecId;

                        canPostInvoice = custPostInvoiceJobQueue.CustInvoiceTableRecId != 0;

                        if (canPostInvoice)
                        {
                            //
                            // Remove the custPostInvoiceJobQueue record regardless of posting success
                            // to prevent another process from picking up the same record after the pessimistic
                            // lock is released.
                            //
                            custPostInvoiceJobQueue.delete();
                        }

                        secondConnection.ttscommit();
                    }
                    else
                    {
                        select firstonly pessimisticlock CustInvoiceTableRecId from custPostInvoiceJobQueue
                            where custPostInvoiceJobQueue.CustInvoiceTableRecId == custInvoiceTable.RecId;

                        canPostInvoice = custPostInvoiceJobQueue.CustInvoiceTableRecId != 0;
                    }

                    if (canPostInvoice)
                    {
                        this.processCustPostInvoiceUpdate(custInvoiceTable, custPostInvoice, custPrintOutInvoice, recordSortedList);
                    }

                    ttscommit;

                    if (printOutWhen == Printout::Current)
                    {
                        this.printOutInvoiceCurrent(recordSortedList, custPostInvoice, custInvoiceTable, custPrintOutInvoice);
                    }

                    this.postProcessCustPostInvoiceUpdate(custPostInvoice);
                }
                catch (exception)
                {
                    custPostInvoiceJobLogger.logError(
                        strFmt('System exception. inBatch:%1, Record:%2, StopPostingOnFirstError:%3, isUsingSecondConnection: %4',
                            custPostInvoiceJobLogger.bool2str(this.isInBatch()),
                            int642Str(custPostInvoice.parmCustInvoiceTable().RecId),
                            custPostInvoiceJobLogger.bool2str(stopInvoicePostingOnFirstError),
                            custPostInvoiceJobLogger.bool2str(isUsingSecondConnection)));

                    if (stopInvoicePostingOnFirstError)
                    {
                        this.throwPostProcessCustPostInvoiceUpdateError(custPostInvoice, exception);
                    }
                    else
                    {
                        this.postProcessCustPostInvoiceUpdateError(custPostInvoice);
                    }
                }
                finally
                {
                    if (isUsingSecondConnection
                        && secondConnection)
                    {
                        // Must dispose of the second user connection
                        secondConnection.finalize();
                    }
                }
            }

            this.printOutInvoice(recordSortedList, custPostInvoice, custPrintOutInvoice);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProcessCustPostInvoiceUpdateError</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the error after processing customer invoices for posting.
    /// </summary>
    /// <param name = "_custPostInvoice">
    ///     A <c>CustPostInvoice</c> instance to use for processing.
    /// </param>
    [SysObsolete('This method is obsolete. Please use the throwPostProcessCustPostInvoiceUpdateError method.', false, 18\8\2020)]
    protected void postProcessCustPostInvoiceUpdateError(CustPostInvoice _custPostInvoice)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwPostProcessCustPostInvoiceUpdateError</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Handles the error after processing customer invoices for posting.
    /// </summary>
    /// <param name = "_custPostInvoice">
    ///     A <c>CustPostInvoice</c> instance to use for processing.
    /// </param>
    /// <param name = "_exception">
    ///     A <c>System.Exception</c> instance.
    /// </param>
    protected void throwPostProcessCustPostInvoiceUpdateError(CustPostInvoice _custPostInvoice, System.Exception _exception)
    {
        this.postProcessCustPostInvoiceUpdateError(_custPostInvoice);

        throw _exception;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProcessCustPostInvoiceUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Empty placeholder to handles the post processing of individual customer invoices as a part of the CustPostInvoiceUpdate process.
    /// </summary>
    /// <param name = "_custInvoiceTable">
    ///     A <c>CustPostInvoice</c> instance to use for processing.
    /// </param>
    protected void postProcessCustPostInvoiceUpdate(CustPostInvoice _custPostInvoice)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        DialogRunbase dialog = Dialog::newFormnameRunbase(formStr(CustPostInvoiceJob),this);

        dialog.caption("@SYS25765");
        dialog = this.dialogInternal(dialog);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogUpdateQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a query in the dialog box.
    /// </summary>
    /// <param name="dialog">
    /// The dialog box in which to update the query.
    /// </param>
    /// <remarks>
    /// This method should not ordinarily be called. The update is performed by standard .
    /// </remarks>
    public void dialogUpdateQuery(Dialog dialog)
    {
        super(dialog);

        this.checkAdvancePayments_W();
        this.dialogUpdateQueryDelegate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the <c>SysLastValue</c> record for this user and object.
    /// </summary>
    /// <remarks>
    ///    This is a customization of the standard <c>SysLastValues</c> functionality and is required to
    ///    support the split implementation of serializing (by using <c>pack</c> and <c>unpack</c>) and
    ///    persisting user input (<c>SysLastValue</c>).
    /// </remarks>
    public void getLast()
    {
        container packedValues;

        // Don't make the call to super as the #CurrentList and #SysLastValues lists are different,
        // requiring that we have specialized logic for the SysLastValues implementation.
        // super();

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        getLastCalled = true;
        inGetSaveLast = true;

        // Restore the pertinent values from the SysLastValue table.
        packedValues = xSysLastValue::getValue(this.lastValueDataAreaId(),
                                               this.lastValueUserId(),
                                               this.lastValueType(),
                                               this.lastValueElementName(),
                                               this.lastValueDesignName());

        this.unpackSysLastValues(packedValues);

        // This is a RunBaseBatch class. Manually restore the user's settings on the batch tab since
        // super() is not being called.
        xSysLastValue::getLast(this.batchInfo());

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdateFreeTxt_RU</Name>
				<Source><![CDATA[
    public boolean getUpdateFreeTxt_RU()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasFixedAsset_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if at least one of the invoices selected to be posted is related to a fixed asset.
    /// </summary>
    /// <returns>
    /// True if verification is successful; otherwise, false.
    /// </returns>
    public boolean hasFixedAsset_BR()
    {
        //We'll build a query based on the class query, which is the CustInvoiceTable entries selected
        //to be posted.
        Query query = new Query(this.queryRun().query());
        QueryBuildDataSource qbds;
        QueryRun qr;
        //Retrieve the lines from the invoices head at the current query
        qbds = query.dataSourceTable(tableNum(CustInvoiceTable)).addDataSource(tableNum(CustInvoiceLine));
        qbds.joinMode(JoinMode::ExistsJoin);
        qbds.addLink(fieldNum(CustInvoiceTable, RecId), fieldNum(CustInvoiceLine, ParentRecId));

        //Filter rows that have AssetId and AssetBookId fields filled
        qbds.addRange(fieldNum(CustInvoiceLine, ServiceInvoice_BR)).value('0');

        //Check whether we have at least one row after the filters
        qr = new QueryRun(query);
        return qr.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBillOfLadingParameters_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the parameters used for bill of lading in free text invoice. They will be propagated until
    ///    post in fiscalDocJour.
    /// </summary>
    /// <param name="_carrierName">Carrier name</param>
    /// <param name="_freightChargeTerms">Freight Terms</param>
    /// <param name="_dlvNoOfCarrier">Vehicle license plate number</param>
    /// <param name="_dlvStateRegistered">Vehicle license plate state</param>
    /// <param name="_dlvTransportBrand">Packing brand</param>
    /// <param name="_volumeType">Packing type</param>
    /// <param name="_volumeQty">Packing quantity</param>
    /// <param name="_netWeight">Packing net weight</param>
    /// <param name="_grossWeight">Packing gross weight</param>
    public void initBillOfLadingParameters_BR(WMSCarrierName _carrierName = '',
                                              WMSFreightChargeTerms _freightChargeTerms = WMSFreightChargeTerms::Nofreight,
                                              DlvNoOfCarrier_BR _dlvNoOfCarrier = '',
                                              DlvStateRegistered_BR _dlvStateRegistered = '',
                                              DlvTransportBrand_BR _dlvTransportBrand = '',
                                              VolumeType_BR _volumeType = '',
                                              VolumeQty_BR _volumeQty = 0,
                                              ItemNetWeight _netWeight = 0,
                                              GrossWeight _grossWeight = 0)
    {
        carrierName = _carrierName;
        freightChargeTerms = _freightChargeTerms;
        dlvNoOfCarrier = _dlvNoOfCarrier;
        dlvStateRegistered = _dlvStateRegistered;
        dlvTransportBrand = _dlvTransportBrand;
        volumeType = _volumeType;
        volumeQty = _volumeQty;
        netWeight = _netWeight;
        grossWeight = _grossWeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParameters</Name>
				<Source><![CDATA[
    public void initParameters(Printout _printOutWhen = Printout::Current,
                               NoYes _proforma = NoYes::Yes,
                               CustCreditMaxCheck _custCreditCheckMax = TypeOfCreditmaxCheck::None,
                               NoYes _printOut = NoYes::Yes,
                               NoYes _creditError = NoYes::No,
                               NoYes _usePrintmanagement = NoYes::No
                               , str _billingClassification = ""
                               ,NoYes _printFacture = NoYes::No,
                               NoYes _printAcceptanceReport = NoYes::No,
                               NoYes _printInMST = NoYes::No
                               ,PlFiscalDocType _fiscalDocType = PlFiscalDocType::Invoice
                               )
    {
        this.parmPrintOutWhen(_printOutWhen);
        this.parmProforma(_proforma);
        this.parmCustCreditMaxCheck(_custCreditCheckMax);
        this.parmPrintOut(_printOut);
        this.parmCreditError(_creditError);
        this.parmUsePrintManagement(_usePrintmanagement);

        if (isBillingClassificationEnabled)
        {
            this.parmBillingClassification(_billingClassification);
            this.updateQueryBuildBillingClassification(_billingClassification);
        }
        // <GEERU>
        this.parmPrintFacture_RU(_printFacture);
        this.parmPrintAcceptanceReport_RU(_printAcceptanceReport);
        this.parmPrintInMST_RU(_printInMST);
        // </GEERU>
        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            this.parmFiscalDocType_PL(_fiscalDocType);
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new()
    {
        super();

        queryRun = new QueryRun(queryStr(CustInvoice));
        custCreditMaxCheck = CustParameters::find().CreditMaxCheck;
        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        custPostInvoiceJobLogger = CustPostInvoiceJobInstrumentationLogger::createLogger();
    }

]]></Source>
			</Method>
			<Method>
				<Name>numberOfRecords</Name>
				<Source><![CDATA[
    public Counter numberOfRecords()
    {
        return numberOfRecords;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        // <GMX>
        NoYes sendByMail;
        // </GMX>

        // Pack all class fields.
        // <GEEU>
        container packed =  [#CurrentVersion,
            [#CurrentList, advanceInvoiceSettlement ? advanceInvoiceSettlement.pack() : conNull(), queryRun.pack() ] ];
        packed = this.appendVariableToPack(packed, varStr(invoiceNumberId), invoiceNumberId);
        packed = this.appendVariableToPack(packed, varStr(invoiceVoucherId), invoiceVoucherId);
        packed = this.appendVariableToPack(packed, varStr(allowSameAs), allowSameAs);
        packed = this.appendVariableToPack(packed, varStr(isNumSeqPreallocated), isNumSeqPreallocated);
        packed = this.appendVariableToPack(packed, varStr(isTopPickInvoicePosting), isTopPickInvoicePosting);
        packed = this.appendVariableToPack(packed, varStr(topPickInvoicePostingProcessId), topPickInvoicePostingProcessId);
        return packed;
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(CustPostInvoiceJob) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>packSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Packs the object for the <c>SysLastValue</c> framework to support persisting user input.
    /// </summary>
    /// <returns>
    ///    A container storing the list of values specified by the <c>SysLastValuesList</c> macro.
    /// </returns>
    /// <remarks>
    ///    Brings support for inheritance to the <c>SysLastValue</c> implementation on this class. Derivative
    ///    classes should override this method and provide their own implementation with a pack list like
    ///    <c>[#SysLastValuesList, super()]</c>.
    /// </remarks>
    public container packSysLastValues()
    {
        // <GMX>
        NoYes sendByMail;
        // </GMX>

        return [sysLastValuesCurrentVersion, printOut, printOutWhen, creditError, proforma, usePrintManagement, 
            printerSettingsFreeText, printerSettingsFreeTextCopy, sendByMail, printInMST, printAcceptanceReport, 
            printFacture, carrierName, freightChargeTerms, dlvNoOfCarrier, dlvStateRegistered, dlvTransportBrand, 
            volumeType, volumeQty, netWeight, grossWeight, docuSetCode, printCODCashReceipt_W, cashRegisterTerminalRecId_W,
            printReceiptData];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvanceInvoiceSettlement_W</Name>
				<Source><![CDATA[
    public AdvanceInvoiceSettlement_FreeText_W parmAdvanceInvoiceSettlement_W(
        AdvanceInvoiceSettlement_FreeText_W _advanceInvoiceSettlement = advanceInvoiceSettlement)
    {
        advanceInvoiceSettlement = _advanceInvoiceSettlement;
        return advanceInvoiceSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAreDistributionsNeeded</Name>
				<Source><![CDATA[
    public NoYes parmAreDistributionsNeeded(NoYes _areDistributionsNeeded = areDistributionsNeeded)
    {
        areDistributionsNeeded = _areDistributionsNeeded;

        return areDistributionsNeeded;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBillingClassification</Name>
				<Source><![CDATA[
    public str parmBillingClassification(str _billingClassification = billingClassification)
    {
        billingClassification = _billingClassification;
        return billingClassification;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCashRegisterTerminalRecId</Name>
				<Source><![CDATA[
    public RefRecId parmCashRegisterTerminalRecId(RefRecId _cashRegisterTerminalRecId_W = cashRegisterTerminalRecId_W)
    {
        cashRegisterTerminalRecId_W = _cashRegisterTerminalRecId_W;
        return cashRegisterTerminalRecId_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditError</Name>
				<Source><![CDATA[
    public NoYes parmCreditError(NoYes _creditError = creditError)
    {
        creditError = _creditError;

        return creditError;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustCreditMaxCheck</Name>
				<Source><![CDATA[
    public CustCreditMaxCheck parmCustCreditMaxCheck(CustCreditMaxCheck _custCreditMaxCheck = custCreditMaxCheck)
    {
        custCreditMaxCheck = _custCreditMaxCheck;

        return custCreditMaxCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmcustInvoicecon</Name>
				<Source><![CDATA[
    public container parmcustInvoicecon(container _custInvoicecon = custInvoicecon)
    {
        custInvoicecon = _custInvoicecon;

        return custInvoicecon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocuSetCode</Name>
				<Source><![CDATA[
    public TaxUnrealizedDocuId parmDocuSetCode(TaxUnrealizedDocuId _docuSetCode = docuSetCode)
    {
        docuSetCode = _docuSetCode;
        return docuSetCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalDocType_PL</Name>
				<Source><![CDATA[
    public PlFiscalDocType parmFiscalDocType_PL(PlFiscalDocType _fiscalDocType = fiscalDocType)
    {
        fiscalDocType = _fiscalDocType;
        return fiscalDocType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceTotal</Name>
				<Source><![CDATA[
    public Amount parmInvoiceTotal(Amount _invoiceTotal = invoiceTotal)
    {
        invoiceTotal = _invoiceTotal;

        return invoiceTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintAcceptanceReport_RU</Name>
				<Source><![CDATA[
    public NoYes parmPrintAcceptanceReport_RU(NoYes _printAcceptanceReport = printAcceptanceReport)
    {
        printAcceptanceReport = _printAcceptanceReport;
        return printAcceptanceReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintCODCashReceipt</Name>
				<Source><![CDATA[
    public NoYes parmPrintCODCashReceipt(NoYes _printCODCashReceipt_W = printCODCashReceipt_W)
    {
        printCODCashReceipt_W = _printCODCashReceipt_W;
        return printCODCashReceipt_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintReceiptData</Name>
				<Source><![CDATA[
    public container parmPrintReceiptData(container _printReceiptData = printReceiptData)
    {
        printReceiptData = _printReceiptData;
        return printReceiptData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintFacture_RU</Name>
				<Source><![CDATA[
    public NoYes parmPrintFacture_RU(NoYes _printFacture = printFacture)
    {
        printFacture = _printFacture;
        return printFacture;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintInMST_RU</Name>
				<Source><![CDATA[
    public PrintInMST_RU parmPrintInMST_RU(PrintInMST_RU _printInMST = printInMST)
    {
        printInMST = _printInMST;
        return printInMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintOut</Name>
				<Source><![CDATA[
    public NoYes parmPrintOut(NoYes _printOut = printOut)
    {
        printOut = _printOut;

        return printOut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintOutWhen</Name>
				<Source><![CDATA[
    public Printout parmPrintOutWhen(Printout _printOutWhen = printOutWhen)
    {
        printOutWhen = _printOutWhen;

        return printOutWhen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProforma</Name>
				<Source><![CDATA[
    public NoYes parmProforma(NoYes _proforma = proforma)
    {
        proforma = _proforma;

        return proforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsePrintManagement</Name>
				<Source><![CDATA[
    public NoYes parmUsePrintManagement(NoYes _usePrintManagement = usePrintManagement)
    {
        usePrintManagement = _usePrintManagement;

        return usePrintManagement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCountSubsetJobsCreated</Name>
				<Source><![CDATA[
    public int parmCountSubsetJobsCreated(int _countSubsetJobsCreated = countSubsetJobsCreated)
    {
        countSubsetJobsCreated = _countSubsetJobsCreated;

        return countSubsetJobsCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumOfInvoicesToPostThroughTopPicking</Name>
				<Source><![CDATA[
    public int parmNumOfInvoicesToPostThroughTopPicking(int _numOfInvoicesToPostThroughTopPicking = numOfInvoicesToPostThroughTopPicking)
    {
        numOfInvoicesToPostThroughTopPicking = _numOfInvoicesToPostThroughTopPicking;

        return numOfInvoicesToPostThroughTopPicking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printerSettingsFreeText</Name>
				<Source><![CDATA[
    public container printerSettingsFreeText(PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        if (_originalCopy == PrintSetupOriginalCopy::Copy)
        {
            return printerSettingsFreeTextCopy;
        }
        else
        {
            return printerSettingsFreeText;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubsetJob</Name>
				<Source><![CDATA[
    public boolean parmSubsetJob(boolean _isSubsetJob = isSubsetJob)
    {
        isSubsetJob = _isSubsetJob;
        return isSubsetJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceNumberId</Name>
				<Source><![CDATA[
    private RefRecId parmInvoiceNumberId(RefRecId _invoiceNumberId = invoiceNumberId)
    {
        invoiceNumberId = _invoiceNumberId;
        return invoiceNumberId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceVoucherId</Name>
				<Source><![CDATA[
    private RefRecId parmInvoiceVoucherId(RefRecId _invoiceVoucherId = invoiceVoucherId)
    {
        invoiceVoucherId = _invoiceVoucherId;
        return invoiceVoucherId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowSameAs</Name>
				<Source><![CDATA[
    private boolean parmAllowSameAs(boolean _allowSameAs = allowSameAs)
    {
        allowSameAs = _allowSameAs;
        return allowSameAs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFTIValidToUsePreallocNumSeq</Name>
				<Source><![CDATA[
    private boolean parmIsFTIValidToUsePreallocNumSeq(boolean _isFTIValidToUsePreallocNumSeq = isFTIValidToUsePreallocNumSeq)
    {
        isFTIValidToUsePreallocNumSeq = _isFTIValidToUsePreallocNumSeq;
        return isFTIValidToUsePreallocNumSeq;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsNumSeqPreallocated</Name>
				<Source><![CDATA[
    private boolean parmIsNumSeqPreallocated(boolean _isNumSeqPreallocated = isNumSeqPreallocated)
    {
        isNumSeqPreallocated = _isNumSeqPreallocated;
        return isNumSeqPreallocated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prompt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Displays a dialog box from the class dialog and waits for user input.
    /// </summary>
    /// <returns>
    /// true if the user clicks the OK button in the dialog box; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the <c> RunBase.canSwapBetweenCS </c> and <c> RunBase.canSwapBetweenCSPrim </c> methods
    /// return true, the class is packed, sent to the client, unpacked, and the prompt is executed there.
    /// </remarks>
    public boolean prompt()
    {
        boolean ret;

        if (this.checkFundingLimit())
        {
            this.checkAdvancePayments_W();
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuildUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the query that executes the posting of the invoices.
    /// </summary>
    protected void queryBuildUpdate()
    {
        // Don't allow posting of free text invoice that generates through recurring invoice generation process.
        queryRun.query().dataSourceTable(tableNum(CustInvoiceTable)).addDataSource(tableNum(RecurrenceInvoice));
        queryRun.query().dataSourceTable(tableNum(RecurrenceInvoice)).addLink(fieldNum(CustInvoiceTable, RecId), fieldNum(RecurrenceInvoice, CustInvoiceTable));
        queryRun.query().dataSourceTable(tableNum(RecurrenceInvoice)).joinMode(JoinMode::NoExistsJoin);

        if (this.isInBatch()
            && !isTopPickInvoicePosting)
        {
            var recIdRange = SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(CustInvoiceTable)), fieldNum(CustInvoiceTable, RecId));
            container recIdContainer = this.parmSubsetRecIdContainer();
            int recIdContainerLength = conLen(recIdContainer);

            if (recIdContainerLength == 1)
            {
                recIdRange.value(con2Str(recIdContainer));
            }
            else if (recIdContainerLength > 1)
            {
                // Create a range based on the first and last RecId in the container. The container is pre-sorted. The rest of the criteria on the query
                // will keep the processing from posting unintended invoices. We are assured of this based on the original query being packed and included
                // on the subjob, which we are creating here.
                recIdRange.value(strFmt('%1..%2', conPeek(recIdContainer, 1), conPeek(recIdContainer, recIdContainerLength)));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustPostInvoiceJobQueue</Name>
				<Source><![CDATA[
    private void updateCustPostInvoiceJobQueue()
    {
        #OCCRetryCount

        Query query = queryRun.query();
        QueryBuildDataSource qbds = query.dataSourceTable(tableNum(CustInvoiceTable));
        QueryBuildDataSource qbdsJobQueue = qbds.addDataSource(tableNum(CustPostInvoiceJobQueue));
        qbdsJobQueue.addLink(fieldNum(CustInvoiceTable, RecId), fieldNum(CustPostInvoiceJobQueue, CustInvoiceTableRecId), qbds.name());
        qbdsJobQueue.joinMode(JoinMode::NoExistsJoin);

        query.clearAllFields();
        qbds.addSelectionField(fieldNum(CustInvoiceTable, RecId));

        int qbdsUniqueId = qbds.uniqueId();
        Map insertRecordsetMap = new Map(Types::String,Types::Container);
        
        insertRecordsetMap.insert(fieldStr(CustPostInvoiceJobQueue, CustInvoiceTableRecId), [qbdsUniqueId, fieldStr(CustInvoiceTable, RecId)]);
        
        CustPostInvoiceJobQueue custPostInvoiceJobQueue;
        try
        {
            Query::insert_recordset(custPostInvoiceJobQueue, insertRecordsetMap, query);
        }
        catch (Exception::DuplicateKeyException)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::UpdateConflictNotRecovered;
            }
            else
            {
                retry;
            }
        }

        // Disable data source to ensure invoices during posting are picked from the queue.
        query.dataSourceTable(tableNum(CustPostInvoiceJobQueue)).enabled(false);

        // Clear the selection fields so that the buffer repopulates.
        query.clearAllFields();
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    /// The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    /// This method is used if a query prompt is the dialog, and if a Select command is added to a dialog
    /// box. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it in
    /// the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTaskProcessing</Name>
				<Source><![CDATA[
    private void prepareTaskProcessing(BatchHeader _batchHeader)
    {
        using (var prepareTaskProcessingActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobPrepareTaskProcessing))
        {
            QueryRun localQuery = new QueryRun(this.queryRun().query());

            CustInvoiceTable custInvoiceTable;

            // Sort by RecId in order to assure that the container used to store the RecIds can be properly used for grabbing the first and last invoice
            // for efficient SQL query creation.
            localQuery.query().dataSourceTable(tableNum(CustInvoiceTable)).addSortField(fieldNum(CustInvoiceTable, RecId));

            container subsetRecIdCont;
            int invoiceBundleSize = SalesParameters::find().OrderBatchTaskSize;
            int invoiceBundleSizeCounter;
            this.parmIsFTIValidToUsePreallocNumSeq(true);

            while (localQuery.next())
            {
                custInvoiceTable = localQuery.get(tableNum(CustInvoiceTable));
                subsetRecIdCont += custInvoiceTable.RecId;
                this.shouldFTIUsePreallocNumSeq(custInvoiceTable);
                invoiceBundleSizeCounter++;

                if (invoiceBundleSizeCounter == invoiceBundleSize)
                {
                    this.createSubsetJob(_batchHeader, subsetRecIdCont);
                    subsetRecIdCont = conNull();
                    invoiceBundleSizeCounter = 0;

                    this.parmIsFTIValidToUsePreallocNumSeq(true);

                    countSubsetJobsCreated++;
                }
            }

            //The last job created contains less invoices than invoiceBundleSize
            if (invoiceBundleSizeCounter > 0)
            {
                this.createSubsetJob(_batchHeader, subsetRecIdCont);
                this.parmIsFTIValidToUsePreallocNumSeq(true);

                countSubsetJobsCreated++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubsetRecIdContainer</Name>
				<Source><![CDATA[
    public container parmSubsetRecIdContainer(container _subsetRecIdContainer = subsetRecIdContainer)
    {
        subsetRecIdContainer = _subsetRecIdContainer;
        return subsetRecIdContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubsetJob</Name>
				<Source><![CDATA[
    private void createSubsetJob(BatchHeader _batchHeader, container _container)
    {
        using (var createSubsetJobActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCreateSubSetJob))
        {
            var subsetJob = CustPostInvoiceJob::construct();

            subsetJob.unpack(this.pack());

            subsetJob.parmSubsetRecIdContainer(_container);
            subsetJob.parmSubsetJob(true);
            subsetJob.preallocateNumSeq(_container);

            subsetJob.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
            subsetJob.batchInfo().parmCaption(CustPostInvoiceJob::description());
            _batchHeader.addRuntimeTask(subsetJob, this.parmCurrentBatch().RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTopPickProcessing</Name>
				<Source><![CDATA[
    private void prepareTopPickProcessing()
    {
        #OCCRetryCount
        CustPostInvoiceJobTmpProcessingQueue tmpProcessingQueue;

        Microsoft.Dynamics.Ax.Xpp.TransientSqlConnectionError transientSqlConnectionError;

        if (appl.ttsLevel() > 0)
        {
            // Top pick processing must own its transaction scope.
            throw Error("@AccountsReceivable:CustPostInvoiceJobTTSLevelError");
        }

        this.isTopPickInvoicePosting = true;
        this.topPickInvoicePostingProcessId = newGuid();

        using (var prepareTopPickProcessingActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobPrepareTopPickProcessing))
        {
            try
            {
                ttsbegin;

                this.cleanupTopPickTmpProcessingQueue();

                if (this.canPrepareTopPickProcessing())
                {
                    tmpProcessingQueue.linkPhysicalTableInstance(this.prepareTopPickTmpProcessingQueue());

                    this.prepareTopPickProcessingQueue(tmpProcessingQueue);
                }

                select count(CustInvoiceTable) from tmpProcessingQueue;

                numOfInvoicesToPostThroughTopPicking = tmpProcessingQueue.CustInvoiceTable;

                ttscommit;
            }
            catch (transientSqlConnectionError)
            {
                if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
                {
                    retry;
                }
                else
                {
                    custPostInvoiceJobLogger.logException(
                        transientSqlConnectionError,
                        strFmt('Transient SQL connection error. ttsLevel:%1, isInBatch:%2',
                            appl.ttsLevel(), 
                            custPostInvoiceJobLogger.bool2str(this.isInBatch())));

                    throw transientSqlConnectionError;
                }
            }
            catch
            {
                custPostInvoiceJobLogger.logError(
                    strFmt('Unhandled exception. ttsLevel:%1, isInBatch:%2',
                        appl.ttsLevel(),
                        custPostInvoiceJobLogger.bool2str(this.isInBatch())));

                throw Exception::Error;
            }
            finally
            {
                tmpProcessingQueue.dispose();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPrepareTopPickProcessing</Name>
				<Source><![CDATA[
    private boolean canPrepareTopPickProcessing()
    {
        boolean canPrepareTopPickProcessing = true;

        if (this.parmProforma()
            && !this.isPrintOutProforma())
        {
            // Do not create processing data when proforma but not printing
            canPrepareTopPickProcessing = false;
        }

        return canPrepareTopPickProcessing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupTopPickTmpProcessingQueue</Name>
				<Source><![CDATA[
    private void cleanupTopPickTmpProcessingQueue()
    {
        using (var cleanupTopPickProcessingQueueActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCleanupTopPickProcessingQueue))
        {
            CustPostInvoiceJobProcessingQueue::cleanUpProcessingQueue();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTopPickTmpProcessingQueue</Name>
				<Source><![CDATA[
    private CustPostInvoiceJobTmpProcessingQueue prepareTopPickTmpProcessingQueue()
    {
        using (var prepareTopPickTmpProcessingQueueActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobPrepareTopPickTmpProcessingQueue))
        {
            this.queryBuildUpdate();
            return CustPostInvoiceJobTmpProcessingQueue::createTmpProcessingQueueFromQuery(queryRun.query());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>prepareTopPickProcessingQueue</Name>
				<Source><![CDATA[
    private void prepareTopPickProcessingQueue(CustPostInvoiceJobTmpProcessingQueue _tmpProcessingQueue)
    {
        using (var prepareTopPickProcessingQueueActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobPrepareTopPickProcessingQueue))
        {
            CustPostInvoiceJobProcessingQueue::createProcessingQueueForProcessId(this.topPickInvoicePostingProcessId, _tmpProcessingQueue);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTopPickPostingTasks</Name>
				<Source><![CDATA[
    private void createTopPickPostingTasks(BatchHeader _batchHeader)
    {
        int maxTasks = this.getMaxNumberTopPickBatchTasks();

        // don't create additional tasks if there is nothing to post.
        if (CustPostInvoiceTopPickingMaxNumTasksFlight::instance().isEnabled()
            && numOfInvoicesToPostThroughTopPicking < maxTasks)
        {
            maxTasks = numOfInvoicesToPostThroughTopPicking;
        }

        using (var createTopPickPostingTasksActivityContext = custPostInvoiceJobLogger.activityContext(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobCreateTopPickPostingTasks))
        {
            for (int i = 1; i <= maxTasks; i++)
            {
                CustPostInvoiceJob topPickInvoicePostingTask = CustPostInvoiceJob::construct();

                topPickInvoicePostingTask.unpack(this.pack());
                topPickInvoicePostingTask.isSubsetJob = true;

                topPickInvoicePostingTask.batchInfo().parmGroupId(this.parmCurrentBatch().GroupId);
                topPickInvoicePostingTask.batchInfo().parmCaption(CustPostInvoiceJob::description());

                _batchHeader.addRuntimeTask(topPickInvoicePostingTask, this.parmCurrentBatch().RecId);

                countSubsetJobsCreated++;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMaxNumberTopPickBatchTasks</Name>
				<Source><![CDATA[
    protected internal int getMaxNumberTopPickBatchTasks()
    {
        CustParameters custParameters = CustParameters::find();

        if (custParameters.DefaultFreeTextInvoicePostingTopPickBatchTasks == 0)
        {
            custParameters.selectForUpdate(true);
            custParameters.DefaultFreeTextInvoicePostingTopPickBatchTasks = DefaultTopPickBatchTasks;

            ttsbegin;
            custParameters.update();
            ttscommit;
        }

        return custParameters.DefaultFreeTextInvoicePostingTopPickBatchTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateBatchHeader</Name>
				<Source><![CDATA[
    private BatchHeader getOrCreateBatchHeader()
    {
        Batchheader batchHeader = BatchHeader::getCurrentBatchHeader();

        if (batchHeader == null)
        {
            batchHeader = BatchHeader::construct();
        }

        return batchHeader;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        using (var runActivityContext = custPostInvoiceJobLogger.activityContextWithCustomProperties(CustPostInvoiceJobInstrumentationConstants::CustPostInvoiceJobRun))
        {
            boolean isTTSLevelZero = appl.ttsLevel() == 0 ? true : false;

            if (this.isInBatch())
            {
                if (!isSubsetJob)
                {
                    var batchHeader = this.getOrCreateBatchHeader();

                    if (CustPostInvoiceJobTopPickFeature::isEnabled())
                    {
                        numOfInvoicesToPostThroughTopPicking = 0;
                        this.prepareTopPickProcessing();
                        this.createTopPickPostingTasks(batchHeader);
                    }
                    else
                    {
                        this.prepareTaskProcessing(batchHeader);
                    }

                    batchHeader.save();
                }
                else
                {
                    this.executeCustPostInvoiceJob();
                }
            }
            else
            {
                if (CustPostInvoiceJobTopPickFeature::isEnabled())
                {
                    this.prepareTopPickProcessing();
                }

                this.executeCustPostInvoiceJob();
            }

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsTTSLevelZero,
                custPostInvoiceJobLogger.bool2str(isTTSLevelZero));

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsInBatch,
                custPostInvoiceJobLogger.bool2str(this.isInBatch()));

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsSubsetJob,
                custPostInvoiceJobLogger.bool2str(isSubsetJob));

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsProforma,
                enum2Str(this.parmProforma()));

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsPrintOutProforma,
                enum2Str(this.isPrintOutProforma()));

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsCustPostInvoiceJobTopPickFeatureInUse,
                custPostInvoiceJobLogger.bool2str(CustPostInvoiceJobTopPickFeature::isEnabled()));

            runActivityContext.addCustomProperty(
                CustPostInvoiceJobInstrumentationConstants::IsTopPickInvoicePosting,
                custPostInvoiceJobLogger.bool2str(this.isTopPickInvoicePosting));

            if (!isSubsetJob)
            {
                runActivityContext.addCustomProperty(
                    CustPostInvoiceJobInstrumentationConstants::InvoiceCountMagnitude,
                    ApplicationCommonInstrumentationMagnitude::log10magnitude(SysQuery::countLoops(queryRun)));

                runActivityContext.addCustomProperty(
                    CustPostInvoiceJobInstrumentationConstants::CountSubsetJobCreated,
                    int2Str(this.countSubsetJobsCreated));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeCustPostInvoiceJob</Name>
				<Source><![CDATA[
    private void executeCustPostInvoiceJob()
    {
        if (this.parmProforma())
        {
            if (this.isPrintOutProforma())
            {
                if (this.isTopPickInvoicePosting)
                {
                    this.custPostInvoiceProformaTopPick();
                }
                else
                {
                    this.custPostInvoiceProforma();
                }
            }
        }
        else
        {
            if (this.isTopPickInvoicePosting)
            {
                this.custPostInvoiceUpdateTopPick();
            }
            else
            {
                this.custPostInvoiceUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrintOutProforma</Name>
				<Source><![CDATA[
    private boolean isPrintOutProforma()
    {
        boolean isPrintOutProforma =
            this.parmPrintOut()
            // <GEERU>
            || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) 
                && (this.parmPrintAcceptanceReport_RU() 
                    || this.parmPrintFacture_RU()));
            // </GEERU>

        return isPrintOutProforma;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend the <c>RunBaseBatch</c> class must override the <c>runsImpersonated</c>
    ///    method and return false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the <c>SysLastValue</c> record for this user and object.
    /// </summary>
    /// <remarks>
    ///    This is a customization of the standard <c>SysLastValues</c> functionality and is required to
    ///    support the split implementation of serializing (by using <c>pack</c> and <c>unpack</c>) and
    ///    persisting user input (<c>SysLastValue</c>).
    /// </remarks>
    public void saveLast()
    {
        // Don't make the call to super as the #CurrentList and #SysLastValues lists are different,
        // requiring that we have specialized logic for the SysLastValues implementation.
        //super();

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        inGetSaveLast = true;

        // Persist the pertinent values to the SysLastValue table.
        xSysLastValue::putValue(this.packSysLastValues(),
                                this.lastValueDataAreaId(),
                                this.lastValueUserId(),
                                this.lastValueType(),
                                this.lastValueElementName(),
                                this.lastValueDesignName());

        // This is a RunBaseBatch derivative class. Manually save the user's settings on the batch tab since
        // super() is not being called.
        xSysLastValue::saveLast(this.batchInfo());

        // The following fields must be maintained to mimic the functionality of the overriden
        // method.
        inGetSaveLast = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseOriginalDocumentAsFacture_RU</Name>
				<Source><![CDATA[
    public UseOriginalDocumentAsFacture_RU parmUseOriginalDocumentAsFacture_RU(UseOriginalDocumentAsFacture_RU _useOriginalDocumentAsFacture = useOriginalDocumentAsFacture)
    {
        useOriginalDocumentAsFacture = _useOriginalDocumentAsFacture;

        return useOriginalDocumentAsFacture;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showCODCashReceipt_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks avaliability of printing cash receipt.
    /// </summary>
    /// <returns>True if printing of cash reciept is avaliable, false - otherwise.</returns>
    public boolean showCODCashReceipt_W()
    {
        return CashRegisterProcessingBase::isEnabledForCurrentUser();
    }

]]></Source>
			</Method>
			<Method>
				<Name>showFacture_RU</Name>
				<Source><![CDATA[
    public boolean showFacture_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a Select button to the dialog box.
    /// </summary>
    /// <returns>
    /// true when a Record ID has not been selected, otherwise, false.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> object.If you change the return value to false, the button will no
    /// longer be added.
    /// </remarks>
    boolean showQueryValues()
    {
        QueryBuildRange qbrRecId = queryRun.query().dataSourceTable(tablenum(CustInvoiceTable)).findRange(fieldnum(CustInvoiceTable, RecId));
        return !(qbrRecId && qbrRecId.value());
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container packedClass)
    {
        Version version = RunBase::getVersion(packedClass);
        container packedSuper;
        container packedQueryRun;
        container packedValues;
        // <GEEU>
        container packedMap;

        advanceInvoiceSettlement = null;
        // </GEEU>
        // <GMX>
        NoYes sendByMail;
        // </GMX>

        switch (version)
        {
            case #CurrentVersion:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                // <GEEU>
                [#CurrentList, packedMap, packedQueryRun] = packedValues;
                advanceInvoiceSettlement = AdvanceInvoiceSettlement_W::newUnpack(tableNum(CustInvoiceTable), packedMap);
                invoiceNumberId = this.extractPackedVariable(packedClass, varStr(invoiceNumberId));
                invoiceVoucherId = this.extractPackedVariable(packedClass, varStr(invoiceVoucherId));
                allowSameAs = this.extractPackedVariable(packedClass, varStr(allowSameAs));
                isNumSeqPreallocated = this.extractPackedVariable(packedClass, varStr(isNumSeqPreallocated));
                // </GEEU>

                isTopPickInvoicePosting = this.extractPackedVariable(packedClass, varStr(isTopPickInvoicePosting));
                topPickInvoicePostingProcessId = this.extractPackedVariable(packedClass, varStr(topPickInvoicePostingProcessId));

                break;

            case #Version14:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                // <GEEU>
                [#CurrentListV14, packedMap, packedQueryRun] = packedValues;
                advanceInvoiceSettlement = AdvanceInvoiceSettlement_W::newUnpack(tableNum(CustInvoiceTable), packedMap);
                // </GEEU>

                break;
            case #Version13:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                // <GEEU>
                [#CurrentListV13, packedMap, packedQueryRun] = packedValues;
                advanceInvoiceSettlement = AdvanceInvoiceSettlement_W::newUnpack(tableNum(CustInvoiceTable), packedMap);
                // </GEEU>

                break;

            case #Version12:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                // <GEEU>
                [#CurrentListV12, packedMap, packedQueryRun] = packedValues;
                advanceInvoiceSettlement = AdvanceInvoiceSettlement_W::newUnpack(tableNum(CustInvoiceTable), packedMap);
                // </GEEU>

                break;

            case #Version11:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                [#CurrentListV11, packedQueryRun] = packedValues;

                break;
            case #Version10:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                [#CurrentListV10, packedQueryRun] = packedValues;

                break;
            case #Version7:
                // Extract the version and values from the packed class.
                [version, packedValues] = packedClass;

                // Extract the values from the values container.
                [#CurrentListV8V7, packedQueryRun] = packedValues;

                break;
            case #Version6:
                // This older version used a different means of packing its values.
                [version, #CurrentListV6, packedQueryRun] = packedClass;

                break;
            case #Version5:
                // This older version used a different means of packing its values.
                [version, #CurrentListV5, packedSuper, packedQueryRun] = packedClass;

                // Default to "Posting" which is proform = No.
                this.parmProforma(NoYes::No);

                //Default to "No".
                this.parmUsePrintManagement(NoYes::No);

                break;
            default:
                return false;
        }

        // <GEEU>
        if (!advanceInvoiceSettlement)
        {
            advanceInvoiceSettlement = AdvanceInvoiceSettlement_W::newFromParent(tableNum(CustInvoiceTable));
        }
        // </GEEU>

        if (packedQueryRun)
        {
            //Re-initialize the queryRun object from the packed queryRun.
            queryRun = new QueryRun(packedQueryRun);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpackSysLastValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Unpacks the object for <c>SysLastValue</c> framework to support persisting user input.
    /// </summary>
    /// <param name="_packedValues">
    ///    A packed instance of <c>LedgerJournalSave</c>.
    /// </param>
    /// <remarks>
    ///    Brings support for inheritance to the <c>SysLastValue</c> implementation on this class. Derivative
    ///    classes should override this method and provide their own implementation with an unpack list like:
    ///    <c>[#SysLastValuesList, baseClassPackedValues] = _packedValues; super(baseClassPackedValues);</c>
    /// </remarks>
    public void unpackSysLastValues(container _packedValues)
    {
        Version version = RunBase::getVersion(_packedValues);
        // <GMX>
        NoYes sendByMail;
        // </GMX>

        switch (version)
        {
            case sysLastValuesCurrentVersion:
                [version, printOut, printOutWhen, creditError, proforma, usePrintManagement, printerSettingsFreeText,
                    printerSettingsFreeTextCopy, sendByMail, printInMST, printAcceptanceReport, printFacture,
                    carrierName, freightChargeTerms, dlvNoOfCarrier, dlvStateRegistered, dlvTransportBrand, volumeType,
                    volumeQty, netWeight, grossWeight, docuSetCode, printCODCashReceipt_W, cashRegisterTerminalRecId_W,
                    printReceiptData] = _packedValues;

                break;
            case #SysLastValuesVersion101:
                [version, #SysLastValuesListV101] = _packedValues;

                break;
            case #SysLastValuesForkedFromVersion:
                // This pack list came from the forked version of the
                // CurrentList list.
                [version, #CurrentListV6] = _packedValues;

                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePrinterSettingsFreeText</Name>
				<Source><![CDATA[
    public void updatePrinterSettingsFreeText(container _printerSettings,
                                              PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        if (_originalCopy == PrintSetupOriginalCopy::Copy)
        {
            printerSettingsFreeTextCopy = _printerSettings;
        }
        else
        {
            printerSettingsFreeText = _printerSettings;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuild</Name>
				<Source><![CDATA[
    void updateQueryBuild(CustInvoiceTable _custInvoiceTable)
    {
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;
        anytype startDate = DateTimeUtil::newDateTime(_custInvoiceTable.InvoiceDate, 0);
        anytype endDate = DateTimeUtil::addDays(startDate, 1);

        queryBuildDataSource = queryRun.query().dataSourceTable(tableNum(CustInvoiceTable));

        queryBuildRange = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(CustInvoiceTable,InvoiceAccount));
        queryBuildRange.value(queryValue(_custInvoiceTable.InvoiceAccount));

        queryBuildRange = queryBuildDataSource.addRange(fieldNum(CustInvoiceTable, InvoiceDate));
        queryBuildRange.value(strFmt('((%1.%2 >= %3) && (%1.%2 < %4))',
            queryBuildDataSource.name(),
            fieldStr(CustInvoiceTable, InvoiceDate),
            date2StrXpp(startDate),
            date2StrXpp(endDate)));

        queryBuildRange = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(CustInvoiceTable,RecId));
        queryBuildRange.value(queryValue(_custInvoiceTable.RecId));
        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV]))
        {
            queryBuildDataSource.addSortField(fieldNum(CustInvoiceTable,InvoiceDate));
        }
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuildBillingClassification</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query object to filter the query by using the selected billing classifications.
    /// </summary>
    /// <param name="_billingClassification">
    /// The billing classifications that are selected on the free text invoice posting form.
    /// </param>
    void updateQueryBuildBillingClassification(str _billingClassification)
    {
        QueryBuildDataSource queryBuildDataSource;
        QueryBuildRange queryBuildRange;

        queryBuildDataSource = queryRun.query().dataSourceTable(tableNum(CustInvoiceTable));

        queryBuildRange = SysQuery::findOrCreateRange(queryBuildDataSource, fieldNum(CustInvoiceTable, CustBillingClassification));

        queryBuildRange.value(_billingClassification);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object calledFrom = null)
    {
        boolean ret = true;

        // <GEERU><GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL, #isoRU, #isoMX])
            && !this.checkAdvancePayments_W(true))
        {
            return checkFailed("@SYS18738");
        }
        // </GEEU></GEERU>

        if (isBillingClassificationEnabled && !this.parmBillingClassification())
        {
            ret = checkFailed("@SPS671");
        }

        ret = ret & this.checkFundingLimit();

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ret = ret & this.validateCreditCorrection();
        }
        // </GEERU>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            ret = ret & this.validate_BR();
        }
        // </GBR>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the Free Text Invoice is valid for Brazilian localization.
    /// </summary>
    /// <returns>
    /// True if it is valid; otherwise, false.
    /// </returns>
    public boolean validate_BR()
    {
        CustInvoiceTable custInvoiceTable;
        CustInvoiceLine custInvoiceLine;
        MarkupTrans markupTrans;

        queryRun = this.queryRun();
        queryRun.reset();

        while (queryRun.next())
        {
            custInvoiceTable = queryRun.get(tableNum(CustInvoiceTable));

            while select custInvoiceLine where custInvoiceLine.ParentRecId == custInvoiceTable.RecId
            {
                select count(RecId) from markupTrans where
                    markupTrans.TransTableId == tableNum(CustInvoiceLine) &&
                    markupTrans.TransRecId == custInvoiceLine.RecId;

                if (markupTrans.RecId && !custInvoiceLine.AssetId)
                {
                    return checkFailed("@GLS223778");
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCreditCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that credit correction is valid.
    /// </summary>
    /// <returns>
    ///  Result of validation as boolean.
    /// </returns>
    /// <remarks>
    /// Validates that credit correction is valid and shows message box to user in case when correction is not valid.
    /// </remarks>
    protected boolean validateCreditCorrection()
    {
        return ! creditError || this.parmInvoiceTotal() < 0 ||
               Box::confirm("@GLS221792");
    }

]]></Source>
			</Method>
			<Method>
				<Name>callPrinterSettingsFreeText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables the user to modify the printer settings by using the SSRS print settings dialog box.
    /// </summary>
    /// <param name="_custPostInvoiceJob">
    /// The <c>CustPostInvoiceJob</c> class where the printer settings are modified.
    /// </param>
    /// <param name="_originalCopy">
    /// A Boolean value that indicates whether the original or copy is being modified; optional.
    /// </param>
    /// <returns>
    /// true if the settings were modified; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The <c>callPrinterSettingsFreeText</c> method is static; therefore the user can select AOS
    /// printers.Selecting AOS printers requires that the <c>SysPrintForm</c> form is called from the
    /// server.
    /// </remarks>
    static boolean callPrinterSettingsFreeText(CustPostInvoiceJob _custPostInvoiceJob,
                                                      PrintSetupOriginalCopy _originalCopy = PrintSetupOriginalCopy::Original)
    {
        #PrintMgmtSetup
        SRSPrintDestinationSettings printSettings =
                new SRSPrintDestinationSettings(_custPostInvoiceJob.printerSettingsFreeText(_originalCopy));
        boolean ok = SrsReportRunUtil::showSettingsDialog(printSettings, #SRSPrintDestinationTokenPrintMgmt, enum2Symbol(enumNum(PrintMgmtDocumentType), enum2int(PrintMgmtDocumentType::SalesFreeTextInvoice)));

        _custPostInvoiceJob.updatePrinterSettingsFreeText(printSettings.pack(), _originalCopy);

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>CustPostInvoiceJob</c> class.
    /// </summary>
    /// <returns>
    ///    A new instance of the <c>CustPostInvoiceJob</c> class.
    /// </returns>
    /// <remarks>
    ///    Use the following procedure to customize or extend the
    ///    <c>
    ///       CustPostInvoiceJob
    ///    </c>
    ///     class.
    ///    <list type="number">
    ///       <item>
    ///          <description>
    ///             Create a new class that derives from <c>CustPostInvoiceJob</c>.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Overlayer the <c>construct</c> method on <c>CustPostInvoiceJob</c> so that it returns an instance
    ///             of the derived class.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             Override the methods from the <c>CustPostInvoiceJob</c> class that you want to customize or extend
    ///             in your derived class.
    ///          </description>
    ///       </item>
    ///    </list>
    ///     This procedure helps make sure that your customizations are maintained if the base version of the
    ///    <c>
    ///       CustPostInvoiceJob
    ///    </c>
    ///     class is changed, minimizing code conflicts during an upgrade. For more information, see <see cref="Best Practices for Static Construct Methods" />
    ///    .
    /// </remarks>
    static CustPostInvoiceJob construct()
    {
        return new CustPostInvoiceJob();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS25765";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        CustPostInvoiceJob custPostInvoiceJob;
        CustInvoiceTable custInvoiceTableFormDataSource;
        CustInvoiceTable custInvoiceTableForProcessing;
        QueryBuildRange qbrPosted;

        if (args && args.caller())
        {
            // Keep the form data source separate from the processing logic since all of the fields
            // may not be selected. It is only necessary for form refresh logic.
            custInvoiceTableFormDataSource = args.record();

            // Ensure all fields are selected prior to processing since many of the forms calling
            // this method set the OnlyFetchActive flag on the datasource. This could result in
            // incorrect results.
            select custInvoiceTableForProcessing where
                custInvoiceTableForProcessing.RecId == custInvoiceTableFormDataSource.RecId;

            // <GEEU>
            custInvoiceTableForProcessing.checkCreditNoteReason();
            // </GEEU>
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            custPostInvoiceJob = CustPostInvoiceJob::newFromEnum_RU(args.parmEnum()); // Factures
        }
        else
        {
        // </GEERU>
            custPostInvoiceJob = CustPostInvoiceJob::construct();
        // <GEERU>
        }
        // </GEERU>

        custPostInvoiceJob.getLast();

        if (custInvoiceTableForProcessing)
        {
            custPostInvoiceJob.initCustPostInvoiceJobFromInvoiceTable(custInvoiceTableForProcessing);
        }

        //don't allow posting of allready posted invoices
        qbrPosted = SysQuery::findOrCreateRange(SysQuery::findOrCreateDataSource(custPostInvoiceJob.queryRun().query(), tablenum(CustInvoiceTable)), fieldnum(CustInvoiceTable, Posted));

        // <GEERU>
        // Factures: allow posted FTIs, but try not to mix with non-posted
        qbrPosted.value(args.parmEnum() ? queryValue(custInvoiceTableForProcessing.Posted) : queryValue(NoYes::No));
        // </GEERU>
        qbrPosted.status(RangeStatus::Locked);

        if (custPostInvoiceJob.checkInvoiceDate(custInvoiceTableForProcessing) && custPostInvoiceJob.prompt())
        {
            using (SysErrorMessageHelpScope scope = SysErrorMessageHelpScope::newErrorContext(args))
            {
                custPostInvoiceJob.runOperation();
            }
        }

        CustPostInvoiceJob::refreshFormData(custInvoiceTableFormDataSource, custPostInvoiceJob.numberOfRecords());

        if (custPostInvoiceJob.parmPrintCODCashReceipt())
        {
            CashReceiptPrinting_W::printReadyReceipts(CustPostInvoiceJob.parmPrintReceiptData());
        }

        // Remove any posted invoices from the queue after completion.
        CustPostInvoiceJobQueue::removePostedInvoicesFromJobQueue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustPostInvoiceJobFromInvoiceTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the current <c>CustPostInvoiceJob</c> class instance from the given <c>CustInvoiceTable</c> table buffer.
    /// </summary>
    /// <param name = "_custInvoiceTableForProcessing">
    ///     Customer free text invoice table buffer.
    /// </param>
    protected void initCustPostInvoiceJobFromInvoiceTable(CustInvoiceTable _custInvoiceTableForProcessing)
    {
        this.updateQueryBuild(_custInvoiceTableForProcessing);
        this.parmInvoiceTotal(_custInvoiceTableForProcessing.calcInvoiceBalance());
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && _custInvoiceTableForProcessing.CustBillingClassification)
        {
            this.parmBillingClassification(int642Str(_custInvoiceTableForProcessing.CustBillingClassification));
        }
        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            this.parmFiscalDocType_PL(_custInvoiceTableForProcessing.FiscalDocType_PL);
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromEnum_RU</Name>
				<Source><![CDATA[
    private static CustPostInvoiceJob newFromEnum_RU(NoYes _facture)
    {
        CustPostInvoiceJob postInvoiceJob;

        switch (_facture)
        {
            case NoYes::No :
                postInvoiceJob = CustPostInvoiceJob::construct();
                break;

            case NoYes::Yes :
                postInvoiceJob = new CustPostFactureFreeTxtJob_RU();
                break;
        }

        return postInvoiceJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshFormData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refreshes the data sources of the caller form.
    /// </summary>
    /// <param name="_custInvoiceTable">
    /// The pointer that points to the <c>CustInvoiceTable</c> record currently selected on the form.
    /// </param>
    /// <param name="_numberOfEffectedRecords">
    /// The number of invoices posted by the job.
    /// </param>
    protected static void refreshFormData(CustInvoiceTable _custInvoiceTable, int _numberOfEffectedRecords)
    {
        Object custInvoicetable_ds = FormDataUtil::isFormDataSource(_custInvoiceTable) ? FormDataUtil::getFormDataSource(_custInvoiceTable) : null;

        // This code was moved from the main method to its current location to reduce RPC
        // calls to the client. The original code made calls out to the form datasource
        // from the server, which caused approximately five unecessary RPC calls.

        if (_custInvoiceTable && custInvoicetable_ds)
        {
            if (_numberOfEffectedRecords > 1)
            {
                custInvoicetable_ds.executeQuery();
            }
            else
            {
                custInvoicetable_ds.reRead();
                custInvoicetable_ds.reFresh();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return !(printOut || printAcceptanceReport || printFacture);
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructCustVendPaymInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the Auto generation of payment - setup on Accounts receivable methods of payment
    /// </summary>
    /// <param name = "_custPostInvoice">The customer post invoice.</param>
    /// <param name = "_custInvoiceTable">The customer invoice.</param>
    protected void constructCustVendPaymInvoice(CustPostInvoice _custPostInvoice, CustInvoiceTable _custInvoiceTable)
    {
        if (_custPostInvoice.isPostingOK())
        {
            if (CustPaymModeTable::find(_custInvoiceTable.PaymMode).PaymOnInvoice)
            {
                CustVendPaymInvoiceWithJournal::construct(_custPostInvoice.parmCustInvoiceTable().custInvoiceJour()).run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoiceDate</Name>
				<Source><![CDATA[
    private boolean checkInvoiceDate(CustInvoiceTable _custInvoiceTable)
    {
        boolean ret = true;
        if (EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled() == NoYes::Yes && _custInvoiceTable)
        {
            try
            {
                setprefix(#PreFixField(_custInvoiceTable, InvoiceAccount));
                EInvoicePost_MX::validateInvoiceDateForCFDI_MX(_custInvoiceTable.InvoiceDate);
            }
            catch
            {
                ret = false;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPreallocateNumberSeq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether to do preallocation of number sequence,
    /// exclude those not supported scenarios.
    /// </summary>
    /// <returns>
    /// If true is returned, it can use number sequence preallocation, otherwise false
    /// </returns>
    private boolean shouldPreallocateNumberSeq()
    {
        return CustPostInvoiceJobPreallocatedNumberSequenceFlight::instance().isEnabled() &&
            this.parmIsFTIValidToUsePreallocNumSeq() &&
            !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU, #isoMY, #isoCN, #isoCH, #isoIN, #isoBR, #isoTH, #isoFR, #isoIT, #isoLT, #isoLV]) &&
            !TaxThaiGovCertificationFeatureChecker::isUnrealizedVATEnabled() && // isUnrealizedVATEnabled in CustPostInvoice
            !CustParameters::find().EnableChronologicalInvoiceNumbering_W;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preallocateNumSeq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Preallocate the number sequence for a set of free text invoices, only for continuously number sequence configuration.
    /// </summary>
    private void preallocateNumSeq(container _recIds)
    {
        // performance gain is minimum if only 1 or 0 invoice in batch job
        if (conLen(_recIds) <= 1 ||
            !this.shouldPreallocateNumberSeq())
        {
            return;
        }

        RefRecId invoiceNumSeqId = CustParameters::numRefCustInvoiceId().NumberSequenceId;
        RefRecId voucherNumSeqId = CustParameters::numRefCustInvoiceVoucher().NumberSequenceId;
        boolean reuseNumber = CustParameters::numRefCustInvoiceVoucher().AllowSameAs;

        // performance improvement only work on continuous number sequence
        NumberSequenceTable invoiceNumberSequenceTable = NumberSequenceTable::find(invoiceNumSeqId);
        NumberSequenceTable voucherNumberSequenceTable = NumberSequenceTable::find(voucherNumSeqId);

        if (!invoiceNumberSequenceTable || !voucherNumberSequenceTable)
        {
            return;
        }

        if (!invoiceNumberSequenceTable.Continuous ||
            (!reuseNumber && !voucherNumberSequenceTable.Continuous))
        {
            return;
        }

        // do not do preallocation if it is global number sequence
        NumberSequenceScope invoiceNumSeqScope = NumberSequenceScope::find(invoiceNumberSequenceTable.NumberSequenceScope);
        NumberSequenceScope voucherNumSeqScope = NumberSequenceScope::find(voucherNumberSequenceTable.NumberSequenceScope);

        if (invoiceNumSeqScope.DataArea == '' || voucherNumSeqScope.DataArea == '')
        {
            return;
        }

        this.parmInvoiceNumberId(invoiceNumSeqId);
        this.parmInvoiceVoucherId(voucherNumSeqId);
        this.parmAllowSameAs(reuseNumber);

        CustPostInvoiceJobPreallocatedNumberSequence::allocateNumbers(_recIds, this.parmInvoiceNumberId(), this.parmInvoiceVoucherId(), this.parmAllowSameAs());
        this.parmIsNumSeqPreallocated(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldFTIUsePreallocNumSeq</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether free text invoice can use preallocation of number sequence,
    /// exclude those not supported scenarios.
    /// </summary>
    private void shouldFTIUsePreallocNumSeq(CustInvoiceTable _custInvoiceTable)
    {
        if (!CustPostInvoiceJobPreallocatedNumberSequenceFlight::instance().isEnabled() ||
            !this.parmIsFTIValidToUsePreallocNumSeq())
        {
            return;
        }

        if (_custInvoiceTable.InvoiceId)
        {
            this.parmIsFTIValidToUsePreallocNumSeq(false);
            return;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && _custInvoiceTable.CustBillingClassification)
        {
            if(CustBillingClassification::find(_custInvoiceTable.CustBillingClassification).InvoiceNumberSeq)
            {
                this.parmIsFTIValidToUsePreallocNumSeq(false);
                return;
            }
        }

        if (MultipleTaxIdReportingHelper::existsAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration))
        {
            CustFreeInvoiceCalcTotals custFreeInvoiceCalcTotals = new CustFreeInvoiceCalcTotals(_custInvoiceTable);
            custFreeInvoiceCalcTotals.calc();

            if (MultipleTaxIdReportingHelper::isTaxInCountryRegion(
                custFreeInvoiceCalcTotals.tax(), [#isoIT], MultipleTaxIdScope::VATDeclaration))
            {
                this.parmIsFTIValidToUsePreallocNumSeq(false);
                return;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeCustPrintOutInvoiceProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>CustPrintOutInvoice</c> instance to print proforma.
    /// </summary>
    /// <returns>A newly initialized <c>CustPrintOutInvoice</c> instance.</returns>
    protected CustPrintOutInvoice initializeCustPrintOutInvoiceProforma()
    {
        CustPrintOutInvoice custPrintOutInvoice = CustPrintOutInvoice::newPrintOriginalCopy(
            printerSettingsFreeText,
            printerSettingsFreeTextCopy,
            this.isInBatch());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            custPrintOutInvoice.parmPrintFormLetter_RU(printOut);
            custPrintOutInvoice.parmPrintAcceptanceReport_RU(printAcceptanceReport);
            custPrintOutInvoice.parmPrintFacture_RU(this.parmPrintFacture_RU());
            custPrintOutInvoice.parmPrintInMST_RU(printInMST);
        }

        return custPrintOutInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogUpdateQueryDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate rised after query updated by user in dialog.
    /// </summary>
    delegate void dialogUpdateQueryDelegate()
    {
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>