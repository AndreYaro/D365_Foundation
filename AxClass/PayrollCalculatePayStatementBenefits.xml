<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PayrollCalculatePayStatementBenefits</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Performs the logic for calculating and creating the applicable <c>PayrollPayStatementBenefitLine</c> records for a Pay Statment.
/// </summary>
/// <remarks>
/// This class is consumed by the <c>PayrollPayStatementGenerationTask</c> to calculate the benefits portion of the Pay Statement.
/// </remarks>
public class PayrollCalculatePayStatementBenefits
{
    #PayrollConstants
    PayrollPayStatement payStatement;
    EndDateTime companyPayPeriodEndDateTime;
    EndDate companyPayPeriodEndDate;
    StartDateTime effectiveRangeStart;
    EndDateTime effectiveRangeEnd;
    TransDate paymentTransDate;
    PeriodStart payPeriodYearStartDate;
    PeriodEnd payPeriodYearEndDate;
    HcmWorkerEnrolledBenefit workerEnrolledBenefit;
    PayrollWorkerEnrolledBenefitDetail workerEnrolledBenefitDetail;
    PayrollWorkerEnrolledBenefitLimit workerEnrolledBenefitLimit;
    HcmBenefit benefit;
    PayrollBenefitDetail benefitDetail;
    PayrollBenefitPlanDetail benefitPlanDetail;
    HcmBenefitPlan benefitPlan;
    PayrollRetirementBenefitPlanDetail_US retirementBenefitPlanDetail_US;
    HcmBenefitType benefitType;
    PayrollStatementAccountingCurrencyAmount totalDeductionAmount;
    PayrollStatementAccountingCurrencyAmount baseDeductionAmount;
    PayrollStatementAccountingCurrencyAmount deductionAmount;
    PayrollStatementAccountingCurrencyAmount contributionAmount;
    PayrollStatementAccountingCurrencyAmount baseContributionAmount;
    PayrollStatementAccountingCurrencyAmount deductionEarningBasis;
    PayrollStatementAccountingCurrencyAmount contributionEarningBasis;
    PayrollStatementAccountingCurrencyAmount regularPortionEarningBasisPositiveAmount;
    PayrollStatementAccountingCurrencyAmount regularPortionEarningBasisNegativeAmount;
    PayrollStatementAccountingCurrencyAmount baseEarningPositiveAmount;
    PayrollStatementAccountingCurrencyAmount baseEarningNegativeAmount;
    PayrollEarningQuantity baseEarningPositiveHours;
    PayrollEarningQuantity baseEarningNegativeHours;
    PayrollEarningQuantity regularPortionEarningBasisPositiveHours;
    PayrollEarningQuantity regularPortionEarningBasisNegativeHours;
    PayrollStatementAccountingCurrencyAmount regularPortionEarningBasisPremiumPositiveAmount;
    PayrollStatementAccountingCurrencyAmount regularPortionEarningBasisPremiumNegativeAmount;
    PayrollEarningQuantity regularPortionEarningBasisPremiumPositiveHours;
    PayrollEarningQuantity regularPortionEarningBasisPremiumNegativeHours;
    System.Int16 zeroInt16;
    AccountingDistributionTemplateRecId distributionTemplatePositiveRecId;
    AccountingDistributionTemplateRecId distributionTemplateNegativeRecId;
    PayrollCalculationFrequency deductionCalculationFrequency;
    PayrollCalculationFrequency contributionCalculationFrequency;
    PayrollCalculationFrequencyPayPeriod deductionCalculationFrequencyPayPeriod;
    PayrollCalculationFrequencyPayPeriod contributionCalculationFrequencyPayPeriod;
    Query earningBasisQuery,
        earningBasisInitialQuery;
    PayrollPayPeriod payPeriod;
    Amount baseRetirementDeductionLimit401_403;
    Amount retirementDeductionlimit401_403;
    Amount retirementDeductionlimit401_403_Catchup;
    Amount retirementContributionLimit401_403;
    Amount baseRetirementDeductionLimit457;
    Amount retirementDeductionlimit457;
    Amount retirementDeductionlimit457_Catchup;
    Amount retirementContributionLimit457;
    Map templatePositiveRecIdMap;
    Map templateNegativeRecIdMap;
    Amount currentYtdDeductionAmount401_403;
    Amount currentYtdDeductionAmount457;
    Amount currentYtdContributionAmount;
    Amount benefitAnnualTotal401_403;
    Amount benefitAnnualTotal457;
    Amount baseAnnualTotalLimit401_403;
    Amount annualTotalLimit401_403;
    Amount baseAnnualTotalLimit457;
    Amount annualTotalLimit457;
    Amount contributionBenefitRate;

    PayrollParameters payrollParameters;
    boolean wageLimitReached401_403Benefits;
    boolean wageLimitReached457Benefits;
    boolean isTaxEngineBenefitLimitsLoaded;
    boolean isRetirementBenefitWithCascadingTier;
    PeriodEnd payPeriodEndDate;

    PayrollTmpGarnishmentDeduction workerGarnishmentDeduction;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>assignExpandedValidTimeStateRange</Name>
				<Source><![CDATA[
    private void assignExpandedValidTimeStateRange()
    {
        //
        // Due to a validTimeState issue when a single query has both date-based and utcdatetime-based tables,
        // we need to expand the validTimeState range of the HcmWorkerEnrolledBenefit table to ensure that the
        // validTimeState() does not select the wrong date-based records in PayrollWorkerEnrolledBenefitDetail and
        // PayrollBenefitDetail.  Instead of relying on validTimeState() to retrieve the correct records, we instead
        // add our own where clauses to do this manually for each table so that the proper value can be used to
        // range by.  One day before and after the specified utcdatetime will ensure timezone offsets will not cause
        // the correct date-based records to be excluded.
        //
        
		if (companyPayPeriodEndDateTime != DateTimeUtil::minValue())
        {
			effectiveRangeStart = DateTimeUtil::addDays(companyPayPeriodEndDateTime, -1);
        }

        if (companyPayPeriodEndDateTime != DateTimeUtil::maxValue())
        {
			effectiveRangeEnd = DateTimeUtil::addDays(companyPayPeriodEndDateTime, 1);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyContributionLimits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies the contribution limits.
    /// </summary>
    protected void applyContributionLimits()
    {
        Amount fixedBasisContributionAmount, employeeLimitContributionAmount;
        Amount totalAmountLeft;
        Amount limitAmountLeft;

        if (benefitType.PayrollCategory ==  PayrollCategory::Standard
            || benefitType.PayrollCategory == PayrollCategory::WorkerCompensation
            || benefitType.PayrollCategory == PayrollCategory::GeneralLiabilityInsurance)
        {
            if (workerEnrolledBenefitLimit.ContributionLimitAmountCur == 0)
            {
                contributionAmount = baseContributionAmount;
            }
            else
            {
                // this needs to be processed now as we need to know what the limit period remaining should be
                limitAmountLeft = workerEnrolledBenefitLimit.processContributionLimitPeriod(payPeriod);

                contributionAmount = min (limitAmountLeft, baseContributionAmount);
            }
        }
        else if (benefitType.PayrollCategory == PayrollCategory::Retirement)
        {
            switch (retirementBenefitPlanDetail_US.ContributionLimitMethod)
            {
                case PayrollContributionLimitMethod::None:

                    // There is no employer limit
                    contributionAmount = baseContributionAmount;
                    break;

                case PayrollContributionLimitMethod::Fixed:

                    contributionAmount = this.applyContributionLimitsFixed(baseContributionAmount, benefitPlanDetail.DefaultContributionLimitAmountCur);
                    break;

                case PayrollContributionLimitMethod::EmployeeLimit:

                    contributionAmount = this.applyContributionLimitsEmployeeLimit(baseContributionAmount, baseDeductionAmount, deductionAmount);
                    break;

                case PayrollContributionLimitMethod::Combination:

                    fixedBasisContributionAmount = this.applyContributionLimitsFixed(baseContributionAmount, benefitPlanDetail.DefaultContributionLimitAmountCur);
                    employeeLimitContributionAmount = this.applyContributionLimitsEmployeeLimit(baseContributionAmount, baseDeductionAmount, deductionAmount);

                    // Since Combination, take the lesser of the two calculated contribution amounts
                    contributionAmount = min(fixedBasisContributionAmount, employeeLimitContributionAmount);
                    break;
            }

            Amount deductionsBelowCatchUpLimit = 0.0;

            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
                || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                // If catch-up is implemented, any deductions below the catch-up limit should not affect contributions
                if (workerEnrolledBenefitDetail.IsRetirementCatchUp == NoYes::Yes)
                {
                    deductionsBelowCatchUpLimit = min(currentYtdDeductionAmount401_403, retirementDeductionlimit401_403_Catchup);
                }

                // this will apply the total annual limit for the 401/403 retirement benefit group, retrieved from the tax engine
                totalAmountLeft = retirementContributionLimit401_403 - (benefitAnnualTotal401_403 - deductionsBelowCatchUpLimit);
                contributionAmount = max(0, min(contributionAmount, totalAmountLeft));
                benefitAnnualTotal401_403 += contributionAmount;
            }
            else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
            {
                // If catch-up is implemented, any deductions below the catch-up limit should not affect contributions
                if (workerEnrolledBenefitDetail.IsRetirementCatchUp == NoYes::Yes)
                {
                    deductionsBelowCatchUpLimit = min(currentYtdDeductionAmount457, retirementDeductionlimit457_Catchup);
                }

                // this will apply the total annual limit for the 457 retirement benefit group, retrieved from the tax engine
                totalAmountLeft = retirementContributionLimit457 - (benefitAnnualTotal457 - deductionsBelowCatchUpLimit);
                contributionAmount = max(0, min(contributionAmount, totalAmountLeft));
                benefitAnnualTotal457 += contributionAmount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyContributionLimitsEmployeeLimit</Name>
				<Source><![CDATA[
    private Amount applyContributionLimitsEmployeeLimit(Amount _baseContributionAmount, Amount _baseDeductionAmount, Amount _deductionAmount)
    {
        Amount employeeLimitContributionAmount = 0;

        //
        //  If the employee's deduction limit was met we then throw away the base contribution calculation
        //  and proportionally recalculate it against the employee's deduction.
        //
        if (_deductionAmount < _baseDeductionAmount)
        {
            if (_baseDeductionAmount != 0)
            {
                employeeLimitContributionAmount = (_deductionAmount / _baseDeductionAmount) * _baseContributionAmount;
            }
        }
        else
        {
            //
            //  An employee deduction was made without being limited so no limiting needs to
            //  occur.  Use the calculated contribution amount.
            //
            employeeLimitContributionAmount = _baseContributionAmount;
        }

        return employeeLimitContributionAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyContributionLimitsFixed</Name>
				<Source><![CDATA[
    private Amount applyContributionLimitsFixed(Amount _baseContributionAmount, Amount _defaultContributionLimitAmountCur)
    {
        this.setYtdContributionAmountForBenefit();

        // Detemine the amount left on the employer 401k limit, apply the limit, and return the correct contribution amount
        return  max(0, (min(_baseContributionAmount, _defaultContributionLimitAmountCur - currentYtdContributionAmount)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyDeductionLimits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies deduction limits.
    /// </summary>
    protected void applyDeductionLimits()
    {
        Amount totalAmountLeft = 0;
        Amount limitAmountLeft = 0;
        Amount newYtdDeductionAmount = 0;
        Amount retirementLimit = 0;

        if (benefitType.PayrollCategory == PayrollCategory::Standard
            || benefitType.PayrollCategory == PayrollCategory::WorkerCompensation
            || benefitType.PayrollCategory == PayrollCategory::GeneralLiabilityInsurance)
        {
            if (workerEnrolledBenefitLimit.DeductionLimitAmountCur == 0)
            {
                deductionAmount = baseDeductionAmount;
            }
            else
            {
                // this needs to be processed now as we need to know what the limit period remaining should be
                limitAmountLeft = workerEnrolledBenefitLimit.processDeductionLimitPeriod(payPeriod);
                deductionAmount = CurrencyExchange::round(min(limitAmountLeft, baseDeductionAmount), PayrollSetup::currencyCode());
            }
        }
        else if (benefitType.PayrollCategory == PayrollCategory::Retirement)
        {
            // determines the current limit amount
            retirementLimit = this.getRetirementLimitForBenefit();

            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
                || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                newYtdDeductionAmount = currentYtdDeductionAmount401_403 + baseDeductionAmount;
                if (newYtdDeductionAmount > retirementLimit)
                {
                    deductionAmount = baseDeductionAmount - (newYtdDeductionAmount - retirementLimit);
                }
                else
                {
                    deductionAmount = baseDeductionAmount;
                }
                // this will apply the total annual limit for the 401/403 retirement benefit group, retrieved from the tax engine
                totalAmountLeft = annualTotalLimit401_403 - benefitAnnualTotal401_403;
                deductionAmount = CurrencyExchange::round(max(0, min(deductionAmount, totalAmountLeft)), PayrollSetup::currencyCode());
                benefitAnnualTotal401_403 += deductionAmount;
                currentYtdDeductionAmount401_403 += deductionAmount;
            }
            else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
            {
                newYtdDeductionAmount = currentYtdDeductionAmount457 + baseDeductionAmount;
                if (newYtdDeductionAmount > retirementLimit)
                {
                    deductionAmount = baseDeductionAmount - (newYtdDeductionAmount - retirementLimit);
                }
                else
                {
                    deductionAmount = baseDeductionAmount;
                }
                // this will apply the total annual limit for the 457 retirement benefit group, retrieved from the tax engine
                totalAmountLeft = annualTotalLimit457 - benefitAnnualTotal457;
                deductionAmount = CurrencyExchange::round(max(0, min(deductionAmount, totalAmountLeft)), PayrollSetup::currencyCode());
                benefitAnnualTotal457 += deductionAmount;
                currentYtdDeductionAmount457 += deductionAmount;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBaseContributionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the base contribution amount of the benefit.
    /// </summary>
    /// <param name="_earningBasis">
    /// The earning basis amount to base the contribution amount calculation.
    /// </param>
    protected void calculateBaseContributionAmount(Amount _earningBasis)
    {
        if (workerEnrolledBenefitDetail.ContributionBasis == PayrollContributionBasis::FixedAmount)
        {
            baseContributionAmount = workerEnrolledBenefitDetail.ContributionAmountCur;
        }
        else
        {
            // Load the contribution rate information
            this.retrieveContributionBenefitRates();

            if (isRetirementBenefitWithCascadingTier)
            {
                this.calculateBaseContributionAmountCascading(_earningBasis);

                //reset flag for new benefit
                isRetirementBenefitWithCascadingTier = false;
            }
            else
            {
                baseContributionAmount = contributionBenefitRate * _earningBasis;
            }
        }
        baseContributionAmount = CurrencyExchange::round(baseContributionAmount, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBaseContributionAmountCascading</Name>
				<Source><![CDATA[
    protected void calculateBaseContributionAmountCascading(Amount _earningBasis)
    {
        PayrollBenefitDetail                        benefitDetailLocal;
        PayrollBenefitCalculationRateDetail         benefitCalculationRateDetail;
        PayrollBenefitCalculationRateVersion        benefitCalculationRateVersion;

        //
        // Start at the highest tier and sum the contribution amount as we loop down through the tiers.
        //
        PayrollStatementAccountingCurrencyAmount    previousTierMinimum = workerEnrolledBenefitDetail.DeductionAmountCur;
        baseContributionAmount = 0;

       while select validtimestate(companyPayPeriodEndDate) RecId from benefitDetailLocal
            order by benefitCalculationRateDetail.Minimum desc
            where benefitDetailLocal.Benefit == benefit.RecId
            join RecId from benefitCalculationRateVersion
                where benefitCalculationRateVersion.BenefitCalculationRate == benefitDetailLocal.ContributionCalculationRate
                join @Rate, Minimum, ContributionMethod from benefitCalculationRateDetail
                    where (benefitCalculationRateDetail.BenefitCalculationRateVersion == benefitCalculationRateVersion.RecId)
                    && (benefitCalculationRateDetail.Minimum <= workerEnrolledBenefitDetail.DeductionAmountCur)
        {
            if (retirementBenefitPlanDetail_US.RecId && benefitCalculationRateDetail.ContributionMethod == PayrollContributionMethod::PercentOfEmployee)
            {
                baseContributionAmount += (previousTierMinimum - benefitCalculationRateDetail.Minimum) * benefitCalculationRateDetail.Rate * _earningBasis;
            }
            else
            {
                baseContributionAmount += benefitCalculationRateDetail.Rate * _earningBasis;
            }
            previousTierMinimum = benefitCalculationRateDetail.Minimum;
        }
        baseContributionAmount = CurrencyExchange::round(baseContributionAmount, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBaseDeductionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the base deduction amount for all payroll categories.
    /// </summary>
    /// <param name="_earningBasis">
    /// The earning basis amount for which to base the deduction amount calculation.
    /// </param>
    protected void calculateBaseDeductionAmount(Amount _earningBasis)
    {
        if (workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::FixedAmount)
        {
            baseDeductionAmount = workerEnrolledBenefitDetail.DeductionAmountCur;
        }
        else if ((workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::PercentOfEarnings)
            || (benefitType.PayrollCategory != PayrollCategory::Retirement))
        {
            baseDeductionAmount = workerEnrolledBenefitDetail.DeductionAmountCur * _earningBasis;
        }
        baseDeductionAmount = CurrencyExchange::round(baseDeductionAmount, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateBenefits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the main processing loop for calculating and creating <c>PayrollPayStatementBenefitLine</c> records.
    /// </summary>
    /// <returns>
    /// The total amount of deductions created for the pay statement.
    /// </returns>
    public PayrollStatementAccountingCurrencyAmount calculateBenefits()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateEarningBasis</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the earning basis amount for contributions or deductions.
    /// </summary>
    /// <param name="_payrollType">
    /// The <c>PayrollType</c> value that determines whether we are calculating for deductions or contributions.
    /// </param>
    /// <returns>
    /// the earning basis amount.
    /// </returns>
    protected Amount calculateEarningBasis(PayrollType _payrollType)
    {
        QueryRun queryRun;
        PayrollPayStatementEarningLine payStatementEarningLine;
        PayrollEarningCode earningCode;
        Amount earningBasis;
        Amount currentEarningBasis;

        baseEarningPositiveAmount = 0;
        baseEarningNegativeAmount = 0;
        baseEarningPositiveHours = 0;
        baseEarningNegativeHours = 0;
        regularPortionEarningBasisPositiveAmount = 0;
        regularPortionEarningBasisNegativeAmount = 0;
        regularPortionEarningBasisPositiveHours = 0;
        regularPortionEarningBasisNegativeHours = 0;
        regularPortionEarningBasisPremiumPositiveAmount = 0;
        regularPortionEarningBasisPremiumNegativeAmount = 0;
        regularPortionEarningBasisPremiumPositiveHours = 0;
        regularPortionEarningBasisPremiumNegativeHours = 0;

        this.setupEarningsBasisInitialQuery();

        earningBasisQuery = new Query(earningBasisInitialQuery);

        if (_payrollType == PayrollType::Deduction)
        {
            this.setupDeductionEarningBasisQuery();
        }
        else
        {
            this.setupContributionEarningBasisQuery();
        }

        queryRun = new QueryRun(earningBasisQuery);

        if ((_payrollType == PayrollType::Deduction
            && workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::RegularPortionOfAllPay)
            || (_payrollType == PayrollType::Contribution
            && workerEnrolledBenefitDetail.ContributionBasis == PayrollContributionBasis::RegularPortionOfAllPay))
        {
            while (queryRun.next())
            {
                payStatementEarningLine = queryRun.get(tableNum(PayrollPayStatementEarningLine));
                earningCode = queryRun.get(tableNum(PayrollEarningCode));

                if (earningCode.BaseDefinition == PayrollBaseDefinition::BaseTime)
                {
                    earningBasis += payStatementEarningLine.AccountingCurrencyAmount;

                    if (payStatementEarningLine.AccountingCurrencyAmount > 0)
                    {
                        regularPortionEarningBasisPositiveAmount += payStatementEarningLine.AccountingCurrencyAmount;

                        if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                        {
                            // Hours are summed based on the sign of the amount and not the sign of the hours
                            regularPortionEarningBasisPositiveHours += payStatementEarningLine.Quantity;
                        }
                    }
                    else
                    {
                        regularPortionEarningBasisNegativeAmount += payStatementEarningLine.AccountingCurrencyAmount;

                        if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                        {
                            // Hours are summed based on the sign of the amount and not the sign of the hours
                            regularPortionEarningBasisNegativeHours += payStatementEarningLine.Quantity;
                        }
                    }
                }
                else if (earningCode.BaseDefinition == PayrollBaseDefinition::TimeAndHalf)
                {
                    currentEarningBasis = payStatementEarningLine.AccountingCurrencyAmount * (2/3);
                    earningBasis += currentEarningBasis;

                    if (currentEarningBasis > 0)
                    {
                        regularPortionEarningBasisPremiumPositiveAmount += currentEarningBasis;

                        if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                        {
                            // Hours are summed based on the sign of the amount and not the sign of the hours
                            regularPortionEarningBasisPremiumPositiveHours += payStatementEarningLine.Quantity;
                        }
                    }
                    else
                    {
                        regularPortionEarningBasisPremiumNegativeAmount += currentEarningBasis;

                        if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                        {
                            // Hours are summed based on the sign of the amount and not the sign of the hours
                            regularPortionEarningBasisPremiumNegativeHours += payStatementEarningLine.Quantity;
                        }
                    }
                }
                else if (earningCode.BaseDefinition == PayrollBaseDefinition::DoubleTime)
                {
                    currentEarningBasis = payStatementEarningLine.AccountingCurrencyAmount * (1/2);
                    earningBasis += currentEarningBasis;

                    if (currentEarningBasis > 0)
                    {
                        regularPortionEarningBasisPremiumPositiveAmount += currentEarningBasis;

                        if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                        {
                            // Hours are summed based on the sign of the amount and not the sign of the hours
                            regularPortionEarningBasisPremiumPositiveHours += payStatementEarningLine.Quantity;
                        }
                    }
                    else
                    {
                        regularPortionEarningBasisPremiumNegativeAmount += currentEarningBasis;

                        if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                        {
                            // Hours are summed based on the sign of the amount and not the sign of the hours
                            regularPortionEarningBasisPremiumNegativeHours += payStatementEarningLine.Quantity;
                        }
                    }
                }
            }
        }
        else
        {
            while (queryRun.next())
            {
                payStatementEarningLine = queryRun.get(tableNum(PayrollPayStatementEarningLine));
                earningCode = queryRun.get(tableNum(PayrollEarningCode));

                if ((_payrollType == PayrollType::Deduction
                    && PayrollCalculatePayStatementBenefits::isDeductionBasisAmountBased(workerEnrolledBenefitDetail.DeductionBasis))
                    || (_payrollType == PayrollType::Contribution
                    && PayrollCalculatePayStatementBenefits::isContributionBasisAmountBased(workerEnrolledBenefitDetail.ContributionBasis)))
                {
                    earningBasis += payStatementEarningLine.AccountingCurrencyAmount;
                }
                else
                {
                    earningBasis += payStatementEarningLine.Quantity;
                }

                if (payStatementEarningLine.AccountingCurrencyAmount > 0)
                {
                    baseEarningPositiveAmount += payStatementEarningLine.AccountingCurrencyAmount;

                    if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                    {
                        // Hours are summed based on the sign of the amount and not the sign of the hours
                        baseEarningPositiveHours += payStatementEarningLine.Quantity;
                    }
                }
                else
                {
                    baseEarningNegativeAmount += payStatementEarningLine.AccountingCurrencyAmount;

                    if (earningCode.QuantityUnit == PayrollQuantityUnit::Hours)
                    {
                        // Hours are summed based on the sign of the amount and not the sign of the hours
                        baseEarningNegativeHours += payStatementEarningLine.Quantity;
                    }
                }
            }
        }

        return earningBasis;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBenefitLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create the benefit line.
    /// </summary>
    /// <param name="_payrollType">
    /// The <c>PayrollType</c> value that determines whether we are create a deduction or contribution line.
    /// </param>
    public void createBenefitLine(PayrollType _payrollType)
    {
        PayrollPayStatementBenefitLine benefitLine;
        HcmPosition position = HcmPosition::find(workerEnrolledBenefitDetail.Position);
        Amount benefitLineAmount;
        Amount earningBasisPositiveAmount;
        Amount earningBasisNegativeAmount;
        Amount earningBasisPositiveHours;
        Amount earningBasisNegativeHours;
        real positiveApportionPercent;
        PayrollStatementAccountingCurrencyAmount negativeBenefitLineAmount;

        boolean isBenefitBasisFixedAmount;

        if (!PayrollPayStatementBenefitLine::canCreate(benefit.RecId, payStatement.RecId, (_payrollType == PayrollType::Contribution)))
        {
            return;
        }

        if (_payrollType == PayrollType::Deduction)
        {
            benefitLineAmount = deductionAmount;
            totalDeductionAmount += deductionAmount;

            if (workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::FixedAmount)
            {
                isBenefitBasisFixedAmount = true;
            }
        }
        else
        {
            benefitLineAmount = contributionAmount;

            if (workerEnrolledBenefitDetail.ContributionBasis == PayrollContributionBasis::FixedAmount)
            {
                isBenefitBasisFixedAmount = true;
            }
        }

        if (workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::RegularPortionOfAllPay
            || workerEnrolledBenefitDetail.ContributionBasis == PayrollContributionBasis::RegularPortionOfAllPay)
        {
            earningBasisPositiveAmount = regularPortionEarningBasisPositiveAmount;
            earningBasisNegativeAmount = regularPortionEarningBasisNegativeAmount;
            earningBasisPositiveHours = regularPortionEarningBasisPositiveHours;
            earningBasisNegativeHours = regularPortionEarningBasisNegativeHours;
        }
        else
        {
            earningBasisPositiveAmount = baseEarningPositiveAmount;
            earningBasisNegativeAmount = baseEarningNegativeAmount;
            earningBasisPositiveHours = baseEarningPositiveHours;
            earningBasisNegativeHours = baseEarningNegativeHours;
        }

        PayrollStatementAccountingCurrencyAmount earningBasisNetAmount = earningBasisPositiveAmount + earningBasisNegativeAmount;

        if (earningBasisNetAmount == 0)
        {
            positiveApportionPercent = 0;
        }
        else
        {
            positiveApportionPercent = earningBasisPositiveAmount / earningBasisNetAmount;
        }

        // Create the positive line
        if (earningBasisPositiveAmount > 0)
        {
            benefitLine = PayrollPayStatementBenefitLine::create(payStatement,
                        paymentTransDate,
                        benefit,
                        distributionTemplatePositiveRecId,
                        (benefitLineAmount * positiveApportionPercent),
                        _payrollType,
                        position.RecId,
                        PayrollPayStatementLineSource::WorkerEnrolledBenefit,
                        NoYes::No,
                        earningBasisPositiveAmount,
                        earningBasisPositiveHours,
                        regularPortionEarningBasisPremiumPositiveAmount,
                        regularPortionEarningBasisPremiumPositiveHours
                        );

            if (templatePositiveRecIdMap && benefitLine.IsEmployer)
            {
                // The insert call updates the record so we need to grab the latest to ensure the source document line field is populated
                benefitLine.reread();
                benefitLine.createProjectAccountingDistribution(templatePositiveRecIdMap);
            }
        }

        // Create the negative line
        if (earningBasisNegativeAmount < 0)
        {
            negativeBenefitLineAmount = benefitLineAmount - benefitLine.AccountingCurrencyAmount;
            benefitLine = PayrollPayStatementBenefitLine::create(payStatement,
                        paymentTransDate,
                        benefit,
                        distributionTemplateNegativeRecId,
                        negativeBenefitLineAmount,
                        _payrollType,
                        position.RecId,
                        PayrollPayStatementLineSource::WorkerEnrolledBenefit,
                        NoYes::No,
                        earningBasisNegativeAmount,
                        earningBasisNegativeHours,
                        regularPortionEarningBasisPremiumNegativeAmount,
                        regularPortionEarningBasisPremiumNegativeHours
                        );

            if (templateNegativeRecIdMap && benefitLine.IsEmployer)
            {
                // The insert call updates the record so we need to grab the latest to ensure the source document line field is populated
                benefitLine.reread();
                benefitLine.createProjectAccountingDistribution(templateNegativeRecIdMap);
            }
        }

        // In the event of zero net earnings, ensure that fixed amount benefit lines are still generated because
        // these benefits lines are used when generating arrears to counter any fixed benefit deductions.
        // Without these arrears fixed benefit deductions will result in a negative net pay on the pay statement.
        if (earningBasisPositiveAmount == 0
            && earningBasisNegativeAmount == 0
            && isBenefitBasisFixedAmount)
        {
            // Create a single, non-apportioned line for the fixed benefit amount
            benefitLine = PayrollPayStatementBenefitLine::create(payStatement,
                    paymentTransDate,
                    benefit,
                    distributionTemplatePositiveRecId,
                    benefitLineAmount,
                    _payrollType,
                    position.RecId,
                    PayrollPayStatementLineSource::WorkerEnrolledBenefit,
                    NoYes::No,
                    (earningBasisPositiveAmount + earningBasisNegativeAmount),
                    (earningBasisPositiveHours + earningBasisNegativeHours),
                    (regularPortionEarningBasisPremiumPositiveAmount + regularPortionEarningBasisPremiumNegativeAmount),
                    (regularPortionEarningBasisPremiumPositiveHours + regularPortionEarningBasisPremiumNegativeHours)
                    );

            if (templatePositiveRecIdMap && benefitLine.IsEmployer)
            {
                // The insert call updates the record so we need to grab the latest to ensure the source document line field is populated
                benefitLine.reread();
                benefitLine.createProjectAccountingDistribution(templatePositiveRecIdMap);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetirementLimitForBenefit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the annual limit amount for the current benefit being processed.
    /// </summary>
    /// <returns>
    /// The annual limit amount for the current benefit being processed.
    /// </returns>
    protected Amount getRetirementLimitForBenefit()
    {
        Amount retirementLimit = 0;

        if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
            || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
        {
            retirementLimit = retirementDeductionlimit401_403;
        }
        else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
        {
            retirementLimit = retirementDeductionlimit457;
        }

        return retirementLimit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBenefitCalculations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the variables specific to each benefit being processed.
    /// </summary>
    private void initializeBenefitCalculations()
    {
        baseDeductionAmount = 0;
        deductionAmount = 0;
        baseContributionAmount = 0;
        contributionAmount = 0;
        deductionEarningBasis = 0;
        contributionEarningBasis = 0;

        retirementDeductionlimit401_403 = baseRetirementDeductionLimit401_403;
        annualTotalLimit401_403 = baseAnnualTotalLimit401_403;

        retirementDeductionlimit457 = baseRetirementDeductionLimit457;
        annualTotalLimit457 = baseAnnualTotalLimit457;

        //
        // Contribution limits do not take catch-up into account.
        // This ensures that, if eligible for catch-up, the worker can deduct a larger amount but the employer cannot contribute a larger amount.
        //
        retirementContributionLimit401_403 = baseAnnualTotalLimit401_403;
        retirementContributionLimit457 = baseAnnualTotalLimit457;

        this.adjustRetirementLimits();
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustRetirementLimits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts deduction and total limits depending on catch-up and overrides
    /// </summary>
    private void adjustRetirementLimits()
    {
        // If worker is eligible for catch-up, add catch-up amount to deduction and combined limits
        if (workerEnrolledBenefitDetail.IsRetirementCatchUp == NoYes::Yes)
        {
            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
                    || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                retirementDeductionlimit401_403 = baseRetirementDeductionLimit401_403 + retirementDeductionlimit401_403_Catchup;
                annualTotalLimit401_403 = baseAnnualTotalLimit401_403 + retirementDeductionlimit401_403_Catchup;
            }
            else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
            {
                retirementDeductionlimit457 = baseRetirementDeductionLimit457 + retirementDeductionlimit457_Catchup;
                annualTotalLimit457 = baseAnnualTotalLimit457 + retirementDeductionlimit457_Catchup;
            }
        }
        
        if (workerEnrolledBenefitDetail.OverrideLimit == NoYes::Yes)
        {
            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                retirementDeductionlimit401_403 = workerEnrolledBenefitLimit.DeductionLimitAmountCur;
            }
            else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
            {
                retirementDeductionlimit457 = workerEnrolledBenefitLimit.DeductionLimitAmountCur;
                annualTotalLimit457 = workerEnrolledBenefitLimit.DeductionLimitAmountCur;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeForPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class in preparation for processing the benefits related to the <c>PayrollPayStatement</c> table record.
    /// </summary>
    /// <param name="_payStatement">
    /// The pay statement for which to calculate benefits.
    /// </param>
    /// <param name="_companyPayPeriodEndDate">
    /// The pay period end date in the company's timezone be used by the process to retrieve data.
    /// </param>
    /// <param name="_distributionTemplatePositiveRecId">
    /// The distribution for positive lines with which to base the accounting distribution.
    /// </param>
    /// <param name="_distributionTemplateNegativeRecId">
    /// The distribution for negative lines with which to base the accounting distribution.
    /// </param>
    /// <param name="_templatePositiveRecIdMap">
    /// The project distribution information for positive lines to use for creating the project acccountnig distribution.
    /// </param>
    /// <param name="_templateNegativeRecIdMap">
    /// The project distribution information for negative lines to use for creating the project acccountnig distribution.
    /// </param>
    /// <remarks>
    /// This method is called every iteration through the main processing loop in the calculateBenenefits method.
    /// </remarks>
    public void initializeForPayment(PayrollPayStatement _payStatement,
        utcdatetime _companyPayPeriodEndDate,
        AccountingDistributionTemplateRecId _distributionTemplatePositiveRecId,
        AccountingDistributionTemplateRecId _distributionTemplateNegativeRecId,
        Map                                 _templatePositiveRecIdMap,
        Map                                 _templateNegativeRecIdMap
    )
    {
        paymentTransDate = PayrollPayPeriod::find(_payStatement.PayPeriod).PeriodEndDate;
        companyPayPeriodEndDateTime = _companyPayPeriodEndDate;
        companyPayPeriodEndDate = paymentTransDate;
        payStatement = _payStatement;
        PreferredLocale locale = new Session().preferredLocale();
        payPeriodYearStartDate = DateTimeUtil::getStartOfYearDate(locale, paymentTransDate);
        payPeriodYearEndDate = DateTimeUtil::getEndOfYearDate(locale, paymentTransDate);
        distributionTemplatePositiveRecId = _distributionTemplatePositiveRecId;
        distributionTemplateNegativeRecId = _distributionTemplateNegativeRecId;
        workerEnrolledBenefitDetail.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
        zeroInt16 = #ZEROAMOUNT;
        totalDeductionAmount = 0;
        currentYtdDeductionAmount401_403 = 0;
        currentYtdDeductionAmount457 = 0;
        currentYtdDeductionAmount401_403 = 0;
        currentYtdDeductionAmount457 = 0;
        currentYtdContributionAmount = 0;
        retirementDeductionlimit401_403 = 0;
        retirementDeductionlimit401_403_Catchup = 0;
        retirementDeductionlimit457 = 0;
        templatePositiveRecIdMap = _templatePositiveRecIdMap;
        templateNegativeRecIdMap = _templateNegativeRecIdMap;

        this.retrieveSymmetryBenefitLimits();
        this.setAnnualWageLimits();
        this.setTotalLimitsForRetirementBenefits();
        this.setYtdDeductionAmountForRetirementTypes();
        this.setCalendarYearRetirementDeductionLimits();

        select PeriodEndDate from payPeriod
            where payPeriod.RecId == payStatement.PayPeriod;

        payPeriodEndDate = payPeriod.PeriodEndDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>Construct</Name>
				<Source><![CDATA[
    public static PayrollCalculatePayStatementBenefits Construct()
    {
        return new PayrollCalculatePayStatementBenefits();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        zeroInt16 = #ZEROAMOUNT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processGarnishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// determine the amount of deduction for enrolled garnishment and tax levy benefits of selected worker, and
    /// create pay statement benefit line for the deductions.
    /// </summary>
    /// <param name="_payrollCategory">
    /// an attribute used by benefit to categorize its contribution and deduction.
    /// </param>
    /// <param name="_payrollPaymentType">
    /// type of payroll run
    /// </param>
    /// <returns>
    /// total garnishment and tax levy deductions for selected worker
    /// </returns>
    /// <remarks>
    /// parameter _payrollCategory is obsolete now
    /// 1. for each garnishment tax levy type, call calcGarnishmentDeductions() to determine the deduction for
    ///    enrolled benefits of such type.
    /// 2. make dedction adjustment based on overall deduction limit for garnishment tax levy.
    /// 3. create payroll pay statement benefit line for garnishment tax levy deductions.
    /// </remarks>
    public PayrollStatementAccountingCurrencyAmount processGarnishment(PayrollCategory _payrollCategory, PayrollPaymentType _payrollPaymentType = PayrollPaymentType::Manual)
    {
        PayrollWorkerGarnishmentRule workerGarnishmentRule;
        PayrollStatementAccountingCurrencyAmount limitForAllGarnishments;

        while select workerGarnishmentRule
            order by workerGarnishmentRule.GarnishmentTaxLevyType, workerGarnishmentRule.StateId, workerGarnishmentRule.CountryRegionId
            where workerGarnishmentRule.Worker == payStatement.Worker &&
                  workerGarnishmentRule.GarnishmentTaxLevyType != PayrollGarnishmentTaxLevyType::CombinedGarnishments
        {
            this.calcGarnishmentDeductions(_payrollPaymentType, workerGarnishmentRule);
        }

        // Adjust all garnishment deductions based on combined garnishment rules
        select firstonly workerGarnishmentRule
            where workerGarnishmentRule.GarnishmentTaxLevyType == PayrollGarnishmentTaxLevyType::CombinedGarnishments
            && workerGarnishmentRule.Worker == payStatement.Worker;
        limitForAllGarnishments = this.garnishmentDeductionLimit(payStatement, PayrollGarnishmentTaxLevyType::CombinedGarnishments, workerGarnishmentRule);
        this.applyLimitForAllGarnishments(limitForAllGarnishments);

        // create pay statement benefit line
        totalDeductionAmount = 0.0; // this is critial to arrear process. only the amount written to benefit line should be tallied.
        while select workerGarnishmentDeduction where workerGarnishmentDeduction.DeductionAmount > 0
        {
            deductionAmount = workerGarnishmentDeduction.DeductionAmount;
            benefit = HcmBenefit::find(workerGarnishmentDeduction.Benefit);
            workerEnrolledBenefitDetail = PayrollWorkerEnrolledBenefitDetail::find(workerGarnishmentDeduction.WorkerEnrolledBenefitDetail);
            this.createBenefitLine(PayrollType::Deduction);
        }

        return totalDeductionAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reachedAnnualRetirementDeductionLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the benefit retirement group for the retirement benefit has already reached the annual deduction limit determined by the Symmetry Tax Engine.
    /// </summary>
    /// <returns>
    /// true if the annual deduction limit has been reached; otherwise, false.
    /// </returns>
    protected boolean reachedAnnualRetirementDeductionLimit()
    {
        boolean annualDeductionLimitReached = false;
        Amount retirementLimit = this.getRetirementLimitForBenefit();

        if (benefitType.PayrollCategory == PayrollCategory::Retirement)
        {
            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
                || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                annualDeductionLimitReached = currentYtdDeductionAmount401_403 >= retirementLimit;
            }
            else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
            {
                annualDeductionLimitReached = currentYtdDeductionAmount457 >= retirementLimit;
            }
        }

        return annualDeductionLimitReached;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reachedAnnualWageLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the benefit retirement group for the retirement benefit has already reached the annual wage limit determined by the Symmetry Tax Engine.
    /// </summary>
    /// <returns>
    /// true if the annual wage limit has been reached; otherwise, false.
    /// </returns>
    protected boolean reachedAnnualWageLimit()
    {
        boolean wageLimitReached = false;

        if (benefitType.PayrollCategory == PayrollCategory::Retirement)
        {
            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
                || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                wageLimitReached = wageLimitReached401_403Benefits;
            }
        }

        return wageLimitReached;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reachedTotalRetirementLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the benefit retirement group for the retirement benefit has already reached the total limit determined by the Symmetry Tax Engine.
    /// </summary>
    /// <returns>
    /// true if the total limit has been reached; otherwise, false.
    /// </returns>
    protected boolean reachedTotalRetirementLimit()
    {
        boolean annualLimitReached = false;

        if (benefitType.PayrollCategory == PayrollCategory::Retirement)
        {
            if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT401kRoth401k
                || retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                annualLimitReached = benefitAnnualTotal401_403 >= annualTotalLimit401_403;
            }
            else if (retirementBenefitPlanDetail_US.RetirementType == PayrollRetirementType::PRT457Roth457)
            {
                annualLimitReached = benefitAnnualTotal457 >= annualTotalLimit457;
            }
        }

        return annualLimitReached;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveContributionBenefitRates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the benefit rate to be used when calculating the contribution amount.
    /// </summary>
    protected void retrieveContributionBenefitRates()
    {
        PayrollBenefitDetail benefitDetailLocal;
        PayrollBenefitCalculationRate benefitCalculationRate;
        PayrollBenefitCalculationRateDetail benefitCalculationRateDetail;
        PayrollBenefitCalculationRateVersion benefitCalculationRateVersion;

        switch (benefitType.PayrollCategory)
        {
            case PayrollCategory::Retirement :

                // Retrieve the matching rate for the benefit.
                select firstonly validtimestate(companyPayPeriodEndDate) RecId from benefitDetailLocal
                    order by benefitCalculationRateDetail.Minimum desc
                    where benefitDetailLocal.Benefit == benefit.RecId
                    join RecId, TierType from benefitCalculationRate
                        where benefitCalculationRate.RecId == benefitDetailLocal.ContributionCalculationRate
                    join RecId from benefitCalculationRateVersion
                        where benefitCalculationRateVersion.BenefitCalculationRate == benefitDetailLocal.ContributionCalculationRate
                        join @Rate, ContributionMethod from benefitCalculationRateDetail
                            where (benefitCalculationRateDetail.BenefitCalculationRateVersion == benefitCalculationRateVersion.RecId)
                            && (benefitCalculationRateDetail.Minimum <= workerEnrolledBenefitDetail.DeductionAmountCur);

                if (benefitDetailLocal.RecId)
                {
                    // Cascading tiers do not have a single contribution benefit rate
                    if (benefitCalculationRate.RecId && benefitCalculationRate.TierType == PayrollTierType::CascadingTier)
                    {
                        isRetirementBenefitWithCascadingTier = true;
                        break;
                    }

                    if (retirementBenefitPlanDetail_US.RecId && benefitCalculationRateDetail.ContributionMethod == PayrollContributionMethod::PercentOfEmployee)
                    {
                        contributionBenefitRate = benefitCalculationRateDetail.Rate * workerEnrolledBenefitDetail.DeductionAmountCur;
                    }
                    else
                    {
                        contributionBenefitRate = benefitCalculationRateDetail.Rate;
                    }
                }
                else
                {
                    contributionBenefitRate = workerEnrolledBenefitDetail.DeductionAmountCur;
                }
                break;
            case PayrollCategory::Standard :
            case PayrollCategory::WorkerCompensation :
            case PayrollCategory::GeneralLiabilityInsurance :
                contributionBenefitRate = workerEnrolledBenefitDetail.ContributionAmountCur;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveSymmetryBenefitLimits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the applicable limit types from the tax engine that is used by the process when checking the limits of benefits.
    /// </summary>
    protected void retrieveSymmetryBenefitLimits()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAllHoursQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the all hours earning method.
    /// </summary>
    protected void setAllHoursQuery()
    {
        QueryBuildDataSource earningCodeDataSource,
            benefitEarningBasis;

        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, QuantityUnit)).value(queryValue(PayrollQuantityUnit::Hours));

        benefitEarningBasis = earningCodeDataSource.addDataSource(tableNum(PayrollBenefitEarningBasis));
        benefitEarningBasis.addLink(fieldNum(PayrollEarningCode, RecId), fieldNum(PayrollBenefitEarningBasis, EarningCode));
        benefitEarningBasis.fetchMode(QueryFetchMode::One2One);
        benefitEarningBasis.joinMode(JoinMode::ExistsJoin);
        benefitEarningBasis.addRange(fieldNum(PayrollBenefitEarningBasis, Benefit)).value(queryValue(benefit.RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAnnualWageLimits</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines the annual wage limits.
    /// </summary>
    protected void setAnnualWageLimits()
    {
        Query earningLineQuery;
        QueryRun queryRun;
        Amount earningLineTotal = 0;
        PayrollPayStatementEarningLine payStatementEarningLine;
        QueryBuildDataSource earningCodeDataSource, earningLineDataSource;
        Amount annualWageLimit401_403;

        wageLimitReached401_403Benefits = false;

        if (!payrollParameters.RecId)
        {
            select ApplyRetirementAnnualWageLimit, RecId from payrollParameters;
        }

        if (payrollParameters.ApplyRetirementAnnualWageLimit == NoYes::No)
        {
            return;
        }

        earningLineQuery = PayrollCalculatePayStatementEarnings::getEarningTotalQueryByDateRange(payPeriodYearStartDate, payPeriodYearEndDate, payStatement.Worker);
        earningLineDataSource = earningLineQuery.dataSourceTable(tableNum(PayrollPayStatementEarningLine));
        earningCodeDataSource = earningLineDataSource.addDataSource(tableNum(PayrollEarningCode));
        earningCodeDataSource.addLink(fieldNum(PayrollPayStatementEarningLine, EarningCode), fieldNum(PayrollEarningCode, RecId));
        earningCodeDataSource.fetchMode(QueryFetchMode::One2One);
        earningCodeDataSource.joinMode(JoinMode::ExistsJoin);
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, TaxMethod)).value(SysQuery::valueNot(PayrollTaxMethod::Exempt));

        queryRun = new QueryRun(earningLineQuery);
        if (queryRun.next())
        {
            payStatementEarningLine = queryRun.get(tableNum(PayrollPayStatementEarningLine));
            earningLineTotal = payStatementEarningLine.AccountingCurrencyAmount;
        }

        if (earningLineTotal >= annualWageLimit401_403)
        {
            wageLimitReached401_403Benefits = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCalendarYearRetirementDeductionLimits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the deduction limit amount for the 2 different retirement benefit groupings.
    /// </summary>
    protected void setCalendarYearRetirementDeductionLimits()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPercentOfEarningsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the percent of earnings earning method.
    /// </summary>
    protected void setPercentOfEarningsQuery()
    {
        QueryBuildDataSource earningCodeDataSource,
            benefitEarningBasis;

        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));
        benefitEarningBasis = earningCodeDataSource.addDataSource(tableNum(PayrollBenefitEarningBasis));
        benefitEarningBasis.addLink(fieldNum(PayrollEarningCode, RecId), fieldNum(PayrollBenefitEarningBasis, EarningCode));
        benefitEarningBasis.fetchMode(QueryFetchMode::One2One);
        benefitEarningBasis.joinMode(JoinMode::ExistsJoin);
        benefitEarningBasis.addRange(fieldNum(PayrollBenefitEarningBasis, Benefit)).value(queryValue(benefit.RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setProductiveHoursQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the productive hours earning method.
    /// </summary>
    protected void setProductiveHoursQuery()
    {
        QueryBuildDataSource earningCodeDataSource;

        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, IsProductive)).value(queryValue(NoYes::Yes));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, QuantityUnit)).value(queryValue(PayrollQuantityUnit::Hours));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRegularEarningsQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the regular earnings earning method.
    /// </summary>
    protected void setRegularEarningsQuery()
    {
        QueryBuildDataSource payStatementEarningLineDataSource,
            earningCodeDataSource,
            benefitEarningBasis;

        payStatementEarningLineDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollPayStatementEarningLine));
        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, BaseDefinition)).value(queryValue(PayrollBaseDefinition::BaseTime));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, QuantityUnit)).value(queryValue(PayrollQuantityUnit::Hours));

        benefitEarningBasis = earningCodeDataSource.addDataSource(tableNum(PayrollBenefitEarningBasis));
        benefitEarningBasis.addLink(fieldNum(PayrollEarningCode, RecId), fieldNum(PayrollBenefitEarningBasis, EarningCode));
        benefitEarningBasis.fetchMode(QueryFetchMode::One2One);
        benefitEarningBasis.joinMode(JoinMode::ExistsJoin);
        benefitEarningBasis.addRange(fieldNum(PayrollBenefitEarningBasis, Benefit)).value(queryValue(benefit.RecId));

        if (benefitType.PayrollCategory == PayrollCategory::GeneralLiabilityInsurance)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerGeneralLiabilityInsuranceBenefit)).value(queryValue(benefit.RecId));
        }
        else if (benefitType.PayrollCategory == PayrollCategory::WorkerCompensation)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerCompensationBenefit)).value(queryValue(benefit.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRegularHoursQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the regular hours earning method.
    /// </summary>
    protected void setRegularHoursQuery()
    {
        QueryBuildDataSource payStatementEarningLineDataSource,
            earningCodeDataSource,
            benefitEarningBasis;

        payStatementEarningLineDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollPayStatementEarningLine));
        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, BaseDefinition)).value(queryValue(PayrollBaseDefinition::BaseTime));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, QuantityUnit)).value(queryValue(PayrollQuantityUnit::Hours));

        benefitEarningBasis = earningCodeDataSource.addDataSource(tableNum(PayrollBenefitEarningBasis));
        benefitEarningBasis.addLink(fieldNum(PayrollEarningCode, RecId), fieldNum(PayrollBenefitEarningBasis, EarningCode));
        benefitEarningBasis.fetchMode(QueryFetchMode::One2One);
        benefitEarningBasis.joinMode(JoinMode::ExistsJoin);
        benefitEarningBasis.addRange(fieldNum(PayrollBenefitEarningBasis, Benefit)).value(queryValue(benefit.RecId));

        if (benefitType.PayrollCategory == PayrollCategory::GeneralLiabilityInsurance)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerGeneralLiabilityInsuranceBenefit)).value(queryValue(benefit.RecId));
        }
        else if (benefitType.PayrollCategory == PayrollCategory::WorkerCompensation)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerCompensationBenefit)).value(queryValue(benefit.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRegularPortionOfAllPayQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the regular portion of all pay earning method.
    /// </summary>
    protected void setRegularPortionOfAllPayQuery()
    {
        QueryBuildDataSource payStatementEarningLineDataSource,
            earningCodeDataSource,
            benefitEarningBasis;

        payStatementEarningLineDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollPayStatementEarningLine));
        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));

        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, TaxMethod)).value(SysQuery::valueNot(PayrollTaxMethod::Exempt));

        benefitEarningBasis = earningCodeDataSource.addDataSource(tableNum(PayrollBenefitEarningBasis));
        benefitEarningBasis.addLink(fieldNum(PayrollEarningCode, RecId), fieldNum(PayrollBenefitEarningBasis, EarningCode));
        benefitEarningBasis.fetchMode(QueryFetchMode::One2One);
        benefitEarningBasis.joinMode(JoinMode::ExistsJoin);
        benefitEarningBasis.addRange(fieldNum(PayrollBenefitEarningBasis, Benefit)).value(queryValue(benefit.RecId));
        if (benefitType.PayrollCategory == PayrollCategory::GeneralLiabilityInsurance)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerGeneralLiabilityInsuranceBenefit)).value(queryValue(benefit.RecId));
        }
        else if (benefitType.PayrollCategory == PayrollCategory::WorkerCompensation)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerCompensationBenefit)).value(queryValue(benefit.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTotalHoursQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the logic for calculating the earning basis for the total hours earning method.
    /// </summary>
    protected void setTotalHoursQuery()
    {
        QueryBuildDataSource payStatementEarningLineDataSource,
            earningCodeDataSource,
            benefitEarningBasis;

        payStatementEarningLineDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollPayStatementEarningLine));

        earningCodeDataSource = earningBasisQuery.dataSourceTable(tableNum(PayrollEarningCode));
        earningCodeDataSource.addRange(fieldNum(PayrollEarningCode, QuantityUnit)).value(queryValue(PayrollQuantityUnit::Hours));

        benefitEarningBasis = earningCodeDataSource.addDataSource(tableNum(PayrollBenefitEarningBasis));
        benefitEarningBasis.addLink(fieldNum(PayrollEarningCode, RecId), fieldNum(PayrollBenefitEarningBasis, EarningCode));
        benefitEarningBasis.fetchMode(QueryFetchMode::One2One);
        benefitEarningBasis.joinMode(JoinMode::ExistsJoin);
        benefitEarningBasis.addRange(fieldNum(PayrollBenefitEarningBasis, Benefit)).value(queryValue(benefit.RecId));

        if (benefitType.PayrollCategory == PayrollCategory::GeneralLiabilityInsurance)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerGeneralLiabilityInsuranceBenefit)).value(queryValue(benefit.RecId));
        }
        else if (benefitType.PayrollCategory == PayrollCategory::WorkerCompensation)
        {
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, WorkerCompensationBenefit)).value(queryValue(benefit.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTotalLimitsForRetirementBenefits</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total limit amounts and current totals for the 2 different retirement benefit groupings, 401K/403 and 457.
    /// </summary>
    protected void setTotalLimitsForRetirementBenefits()
    {
        QueryRun queryRun;
        Query benefitAnnualTotalQuery;
        QueryBuildDataSource retirementBenefitPlanDetail_USDataSource;
        QueryBuildRange retirementTypeRange;

        PayrollPayStatementBenefitLine payStatementBenefitLine;
        // retrieves the current sum of all deductions and contributions for the benefit grouping of 401/403
        benefitAnnualTotalQuery = PayrollCalculatePayStatementBenefits::getBenefitTotalQueryByDateRange(payPeriodYearStartDate,
            payPeriodYearEndDate,
            0,
            0,
            false,
            PayrollType::Contribution,
            true,
            PayrollRetirementType::PRT457Roth457,
            payStatement.Worker);

        queryRun = new QueryRun(benefitAnnualTotalQuery);

        // retrieves the current sum of all deductions and contributions for the benefit grouping of 401/403
        if (queryRun.next())
        {
            payStatementBenefitLine = queryRun.get(tableNum(PayrollPayStatementBenefitLine));
            benefitAnnualTotal457 = payStatementBenefitLine.AccountingCurrencyAmount;
        }
        // retrieves the total limit for the 457 retirement grouping
        baseAnnualTotalLimit457 = PayrollTaxEngineUtil::money2Real();

        retirementBenefitPlanDetail_USDataSource = benefitAnnualTotalQuery.dataSourceTable(tableNum(PayrollRetirementBenefitPlanDetail_US));

        retirementTypeRange = retirementBenefitPlanDetail_USDataSource.findRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType));
        retirementTypeRange.value(queryValue(PayrollRetirementType::PRT401kRoth401k));
        retirementTypeRange = retirementBenefitPlanDetail_USDataSource.addRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType));
        retirementTypeRange.value(queryValue(PayrollRetirementType::PRT403bRoth403b));

        queryRun = new QueryRun(benefitAnnualTotalQuery);

        if (queryRun.next())
        {
            payStatementBenefitLine = queryRun.get(tableNum(PayrollPayStatementBenefitLine));
            benefitAnnualTotal401_403 = payStatementBenefitLine.AccountingCurrencyAmount;
        }
        // retrieves the total limit for the 401K/403 retirement grouping
        baseAnnualTotalLimit401_403 = PayrollTaxEngineUtil::money2Real();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupContributionEarningBasisQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the contribution earning basis query to determine the earning basis amount based on the contribution basis of the benefit.
    /// </summary>
    protected void setupContributionEarningBasisQuery()
    {
        switch (benefitType.PayrollCategory)
        {
            case PayrollCategory::Retirement :
                if (workerEnrolledBenefitDetail.ContributionBasis == PayrollContributionBasis::PercentOfEarnings)
                {
                    this.setPercentOfEarningsQuery();
                }
                break;
            case PayrollCategory::Standard :
            case PayrollCategory::WorkerCompensation :
            case PayrollCategory::GeneralLiabilityInsurance :
                switch (workerEnrolledBenefitDetail.ContributionBasis)
                {
                    case PayrollContributionBasis::RegularPortionOfAllPay :
                        this.setRegularPortionOfAllPayQuery();
                        break;

                    case PayrollContributionBasis::PercentOfEarnings :
                        this.setPercentOfEarningsQuery();
                        break;
                    case PayrollContributionBasis::RegularEarnings :
                        this.setRegularEarningsQuery();
                        break;
                    case PayrollContributionBasis::AllHours :
                        this.setAllHoursQuery();
                        break;
                    case PayrollContributionBasis::ProductiveHours :
                        this.setProductiveHoursQuery();
                        break;
                    case PayrollContributionBasis::RegularHours :
                        this.setRegularHoursQuery();
                        break;
                    case PayrollContributionBasis::TotalHours :
                        this.setTotalHoursQuery();
                        break;
                }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupDeductionEarningBasisQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the main logic for calculating the deduction earning basis amount.
    /// </summary>
    protected void setupDeductionEarningBasisQuery()
    {
        switch (benefitType.PayrollCategory)
        {
            case PayrollCategory::Retirement :
                if (workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::PercentOfEarnings)
                {
                    this.setPercentOfEarningsQuery();
                }
                break;
            case PayrollCategory::Standard :
            case PayrollCategory::WorkerCompensation :
            case PayrollCategory::GeneralLiabilityInsurance :
                switch (workerEnrolledBenefitDetail.DeductionBasis)
                {
                    case PayrollDeductionBasis::RegularPortionOfAllPay :
                        this.setRegularPortionOfAllPayQuery();
                        break;
                    case PayrollDeductionBasis::PercentOfEarnings :
                        this.setPercentOfEarningsQuery();
                        break;
                    case PayrollDeductionBasis::RegularEarnings :
                        this.setRegularEarningsQuery();
                        break;
                    case PayrollDeductionBasis::AllHours :
                        this.setAllHoursQuery();
                        break;
                    case PayrollDeductionBasis::ProductiveHours :
                        this.setProductiveHoursQuery();
                        break;
                    case PayrollDeductionBasis::RegularHours :
                        this.setRegularHoursQuery();
                        break;
                    case PayrollDeductionBasis::TotalHours :
                        this.setTotalHoursQuery();
                        break;
                }
            case PayrollCategory::Garnishment :
            case PayrollCategory::TaxLevy :
                if (workerEnrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::PercentOfEarnings)
                {
                    this.setPercentOfEarningsQuery();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupEarningsBasisInitialQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the base query used for calculating the earning basis amount.
    /// </summary>
    protected void setupEarningsBasisInitialQuery()
    {
        QueryBuildDataSource payStatementEarningLineDataSource,
            earningCodeDataSource;

        if (!earningBasisInitialQuery)
        {
            earningBasisInitialQuery = new Query();
            earningBasisInitialQuery.validTimeStateAsOfDate(paymentTransDate);
            earningBasisInitialQuery.validTimeStateAsOfDateTime(companyPayPeriodEndDateTime);
            payStatementEarningLineDataSource = earningBasisInitialQuery.addDataSource(tableNum(PayrollPayStatementEarningLine), tableId2name(tableNum(PayrollPayStatementEarningLine)));
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, IsMarkedForRemoval)).value(queryValue(NoYes::No));
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, PayStatement)).value(queryValue(payStatement.RecId));
            payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, Source)).value(SysQuery::valueNot(PayrollPayStatementLineSource::FringeBenefitRecover));

            if (workerEnrolledBenefitDetail.Position > 0)
            {
                payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, Position)).value(queryValue(workerEnrolledBenefitDetail.Position));
            }

            earningCodeDataSource = payStatementEarningLineDataSource.addDataSource(tableNum(PayrollEarningCode));
            earningCodeDataSource.addLink(fieldNum(PayrollPayStatementEarningLine, EarningCode), fieldNum(PayrollEarningCode, RecId));
            earningCodeDataSource.fetchMode(QueryFetchMode::One2One);
            earningCodeDataSource.joinMode(JoinMode::InnerJoin);
        }
        else
        {
            payStatementEarningLineDataSource = earningBasisInitialQuery.dataSourceTable(tableNum(PayrollPayStatementEarningLine));
            payStatementEarningLineDataSource.clearRange(fieldNum(PayrollPayStatementEarningLine, Position));

            if (workerEnrolledBenefitDetail.Position > 0)
            {
                payStatementEarningLineDataSource.addRange(fieldNum(PayrollPayStatementEarningLine, Position)).value(queryValue(workerEnrolledBenefitDetail.Position));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setYtdContributionAmountForBenefit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the logic for calculating and applying the limits related to the retirement
    /// </summary>
    protected void setYtdContributionAmountForBenefit()
    {
        QueryRun queryRun;
        Query ytdContributionQuery;
        PayrollPayStatementBenefitLine payStatementBenefitLine;

        ytdContributionQuery = PayrollCalculatePayStatementBenefits::getBenefitTotalQueryByDateRange(payPeriodYearStartDate,
            payPeriodYearEndDate,
            0,
            benefit.RecId,
            true,
            PayrollType::Contribution,
            false,
            0,
            payStatement.Worker);

        queryRun = new QueryRun(ytdContributionQuery);
        if (queryRun.next())
        {
            payStatementBenefitLine = queryRun.get(tableNum(PayrollPayStatementBenefitLine));

            // The year-to-date contribution amount excludes the current pay statement and is for the entire year
            currentYtdContributionAmount = payStatementBenefitLine.AccountingCurrencyAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setYtdDeductionAmountForRetirementTypes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the currentYtdDeductionAmount variable based on the sum of the benefits for all retirement types.
    /// </summary>
    protected void setYtdDeductionAmountForRetirementTypes()
    {
        PayrollPayStatementBenefitLine payStatementBenefitLine;
        QueryRun queryRun;
        Query ytdQuery;
        QueryBuildRange retirementTypeRange;
        QueryBuildDataSource retirementPlanDetail;

        ytdQuery = PayrollCalculatePayStatementBenefits::getBenefitTotalQueryByDateRange(payPeriodYearStartDate,
                    payPeriodYearEndDate,
                    0,
                    0,
                    true,
                    PayrollType::Deduction,
                    true,
                    PayrollRetirementType::PRT457Roth457,
                    payStatement.Worker);
        queryRun = new QueryRun(ytdQuery);

        if (queryRun.next())
        {
            payStatementBenefitLine = queryRun.get(tableNum(PayrollPayStatementBenefitLine));
            currentYtdDeductionAmount457 = payStatementBenefitLine.AccountingCurrencyAmount;
        }

        retirementPlanDetail = ytdQuery.dataSourceTable(tableNum(PayrollRetirementBenefitPlanDetail_US));

        retirementTypeRange = retirementPlanDetail.findRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType));
        retirementTypeRange.value(queryValue(PayrollRetirementType::PRT401kRoth401k));
        retirementTypeRange = retirementPlanDetail.addRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType));
        retirementTypeRange.value(queryValue(PayrollRetirementType::PRT403bRoth403b));

        queryRun = new QueryRun(ytdQuery);

        if (queryRun.next())
        {
            payStatementBenefitLine = queryRun.get(tableNum(PayrollPayStatementBenefitLine));
            currentYtdDeductionAmount401_403 = payStatementBenefitLine.AccountingCurrencyAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBenefitTotalQueryByDateRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the base deduction amount for all payroll categories.
    /// </summary>
    /// <param name="_startDate">
    /// The start date value of the date range.
    /// </param>
    /// <param name="_endDate">
    /// The end date value of the date range.
    /// </param>
    /// <param name="_payStatementRecId">
    /// The <c>PayrolLPayStatement</c> record ID value to filter on.
    /// </param>
    /// <param name="_benefitRecId">
    /// The <c>HcmBenefit</c> record ID value to filter on.
    /// </param>
    /// <param name="_byPayrollType">
    /// The boolean value that determines whether to include both deductions and contributions in the total query.
    /// </param>
    /// <param name="_payrollType">
    /// The <c>PayrollType</c> value to filter on if we are calculating either deductions or contributions.
    /// </param>
    /// <param name="_byRetirementType">
    /// The boolean value that determines whether to include both retirement grouping in the total query.
    /// </param>
    /// <param name="_retirementType">
    /// The <c>PayrollRetirementType</c> value to filter on if we are calculating a single retirement type.
    /// </param>
    /// <param name="_workerRecId">
    /// The <c>HcmWorker</c> record ID value to filter on.
    /// </param>
    /// <returns>
    /// A <c>Query</c> object that will select and sum benefit lines based on the input parameters.
    /// </returns>
    public static Query getBenefitTotalQueryByDateRange(TransDate _startDate,
        TransDate _endDate,
        PayrollPayStatementRecId _payStatementRecId = 0,
        HcmBenefitRecId _benefitRecId = 0,
        boolean _byPayrollType = false,
        PayrollType _payrollType = PayrollType::Contribution,
        boolean _byRetirementType = false,
        PayrollRetirementType _retirementType = PayrollRetirementType::PRT457Roth457,
        HcmWorkerRecId _workerRecId = 0
        )
    {
        Query benefitTotalQuery = new Query();
        utcdatetime startDate = DateTimeUtil::newDateTime(_startDate, 0);
        utcdatetime endDate = DateTimeUtil::newDateTime(_endDate, timeMax());

        QueryBuildDataSource payStatementBenefitLineDataSource,
            payStatementDataSource,
            benefitDataSource,
            retirementBenefitPlanDetail_USDataSource;

        benefitTotalQuery.validTimeStateDateTimeRange(startDate, endDate);
        payStatementBenefitLineDataSource = benefitTotalQuery.addDataSource(tableNum(PayrollPayStatementBenefitLine));
        payStatementBenefitLineDataSource.addSelectionField(fieldNum(PayrollPayStatementBenefitLine, AccountingCurrencyAmount), SelectionField::Sum);
        payStatementBenefitLineDataSource.addRange(fieldNum(PayrollPayStatementBenefitLine, IsMarkedForRemoval)).value(queryValue(NoYes::No));
        if (_benefitRecId)
        {
            payStatementBenefitLineDataSource.addRange(fieldNum(PayrollPayStatementBenefitLine, Benefit)).value(queryValue(_benefitRecId));
        }

        if (_byPayrollType)
        {
            if (_payrollType == PayrollType::Contribution)
            {
                payStatementBenefitLineDataSource.addRange(fieldNum(PayrollPayStatementBenefitLine, IsEmployer)).value(queryValue(NoYes::Yes));
            }
            else
            {
                payStatementBenefitLineDataSource.addRange(fieldNum(PayrollPayStatementBenefitLine, IsEmployer)).value(queryValue(NoYes::No));
            }
        }

        payStatementDataSource = payStatementBenefitLineDataSource.addDataSource(tableNum(PayrollPayStatement));
        payStatementDataSource.fetchMode(QueryFetchMode::One2One);
        payStatementDataSource.joinMode(JoinMode::ExistsJoin);
        payStatementDataSource.addLink(fieldNum(PayrollPayStatementBenefitLine, PayStatement), fieldNum(PayrollPayStatement, RecId));
        payStatementDataSource.addRange(fieldNum(PayrollPayStatement, PaymentDate)).value(SysQuery::range(startDate, endDate));
        if (_payStatementRecId)
        {
            payStatementDataSource.addRange(fieldNum(PayrollPayStatement, RecId)).value(queryValue(_payStatementRecId));
        }

        if (_workerRecId)
        {
            payStatementDataSource.addRange(fieldNum(PayrollPayStatement, Worker)).value(queryValue(_workerRecId));
        }

        if (_byRetirementType)
        {
            benefitDataSource = payStatementBenefitLineDataSource.addDataSource(tableNum(HcmBenefit));
            benefitDataSource.fetchMode(QueryFetchMode::One2One);
            benefitDataSource.joinMode(JoinMode::InnerJoin);
            benefitDataSource.addLink(fieldNum(PayrollPayStatementBenefitLine, Benefit), fieldNum(HcmBenefit, RecId));

            retirementBenefitPlanDetail_USDataSource = benefitDataSource.addDataSource(tableNum(PayrollRetirementBenefitPlanDetail_US));
            retirementBenefitPlanDetail_USDataSource.fetchMode(QueryFetchMode::One2One);
            retirementBenefitPlanDetail_USDataSource.joinMode(JoinMode::InnerJoin);
            retirementBenefitPlanDetail_USDataSource.addLink(fieldNum(HcmBenefit, BenefitPlan), fieldNum(PayrollRetirementBenefitPlanDetail_US, BenefitPlan));
            if (_retirementType == PayrollRetirementType::PRT457Roth457)
            {
                retirementBenefitPlanDetail_USDataSource.addRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType)).value(queryValue(_retirementType));
            }
            else if (_retirementType == PayrollRetirementType::PRT401kRoth401k
                || _retirementType == PayrollRetirementType::PRT403bRoth403b)
            {
                retirementBenefitPlanDetail_USDataSource.addRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType)).value(queryValue(PayrollRetirementType::PRT401kRoth401k));
                retirementBenefitPlanDetail_USDataSource.addRange(fieldNum(PayrollRetirementBenefitPlanDetail_US, RetirementType)).value(queryValue(PayrollRetirementType::PRT403bRoth403b));
            }
        }
        return benefitTotalQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isContributionBasisAmountBased</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>PayrollContributionBasis</c> enum value is amount based or quantity based.
    /// </summary>
    /// <param name="_contributionBasis">
    /// The <c>PayrollContributionBasis</c> value that is checked to see if it is amount based.
    /// </param>
    /// <returns>
    /// true if contribution basis is amount based; otherwise, false.
    /// </returns>
    protected static boolean isContributionBasisAmountBased(PayrollContributionBasis _contributionBasis)
    {
        switch (_contributionBasis)
        {
            case PayrollContributionBasis::FixedAmount :
            case PayrollContributionBasis::PercentOfEarnings :
            case PayrollContributionBasis::RegularEarnings :
            case PayrollContributionBasis::RegularPortionOfAllPay :
                return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeductionBasisAmountBased</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the <c>PayrollDeductionBasis</c> enum value is amount based or quantity based.
    /// </summary>
    /// <param name="_deductionBasis">
    /// The <c>PayrollDeductionBasis</c> value that is checked to see if it is amount based.
    /// </param>
    /// <returns>
    /// true if deduction basis is amount based; otherwise, false.
    /// </returns>
    protected static boolean isDeductionBasisAmountBased(PayrollDeductionBasis _deductionBasis)
    {
        switch (_deductionBasis)
        {
            case PayrollDeductionBasis::FixedAmount :
            case PayrollDeductionBasis::PercentOfEarnings :
            case PayrollDeductionBasis::RegularEarnings :
            case PayrollDeductionBasis::RegularPortionOfAllPay :
                return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyLimitForAllGarnishments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Make adjustment for garnishment tax levy deductions based on overall deduction limit
    /// </summary>
    /// <param name="_limit">
    /// The overall limit for all garnishment tax levy deductions
    /// </param>
    /// <remarks>
    /// Bankruptcy order and federal or state or local tax levy deductions are subject to adjustment.
    /// </remarks>
    protected void applyLimitForAllGarnishments(PayrollStatementAccountingCurrencyAmount _limit)
    {
        PayrollStatementAccountingCurrencyAmount remainingLimit = _limit;

        ttsBegin;
        while select forUpdate workerGarnishmentDeduction
            order by workerGarnishmentDeduction.DeductionPriority, workerGarnishmentDeduction.ValidFrom asc
            where workerGarnishmentDeduction.GarnishmentTaxLevyType != PayrollGarnishmentTaxLevyType::BankruptcyOrder &&
                  workerGarnishmentDeduction.GarnishmentTaxLevyType != PayrollGarnishmentTaxLevyType::FederalTaxLevy &&
                  workerGarnishmentDeduction.GarnishmentTaxLevyType != PayrollGarnishmentTaxLevyType::StateTaxLevy &&
                  workerGarnishmentDeduction.GarnishmentTaxLevyType != PayrollGarnishmentTaxLevyType::LocalTaxLevy
        {
            if (workerGarnishmentDeduction.AllowReduction)
            {
                // if deduction is subject to adjustment
                if (workerGarnishmentDeduction.DeductionAmount > remainingLimit)
                {
                    // if reaching the overal deduction limit, actual deduction amount will be adjusted accordingly.
                    workerGarnishmentDeduction.DeductionAmount = remainingLimit;
                    workerGarnishmentDeduction.update();
                }
            }

            // adjust the remaining limit
            if (workerGarnishmentDeduction.DeductionAmount > remainingLimit)
            {
                remainingLimit = 0;
            }
            else
            {
                remainingLimit -= workerGarnishmentDeduction.DeductionAmount;
            }
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyLimitForMultipleGarnishments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust the requested deduction amount based on limit for a given type of garnishment tax levy type.
    /// </summary>
    /// <param name="_limit">
    /// The limit for a given garnishment tax levy
    /// </param>
    /// <param name="_multipleMethod">
    /// The method of adjustment
    /// </param>
    /// <param name="_type">
    /// The garnishment tax levy type
    /// </param>
    /// <param name="_stateId">
    /// String type identification of the state with which a garnishment tax levy benefit is associated
    /// </param>
    /// <param name="_countryRegionId">
    /// String type identification of the country to which the state belongs
    /// </param>
    /// <remarks>
    /// Garnishment tax levy type, state id, and country region id together defined the scope of deductions
    /// that are subject to deduction limit and possible adjustment.
    /// Adjustment will be made only when the overall deduction (deduction and administration fee) is over the limit.
    /// There are three adjustment methods:
    /// <list type="number">
    /// <item>
    /// <description>Pro-Rata, deduction amount is a percent of the deduction limit based on its requested amount.</description>
    /// </item>
    /// <item>
    /// <description>Equal, deduction amount is the equal share of a remaining limit during each iteration.</description>
    /// </item>
    /// <item>
    /// <description>First-In, requested deduction amount is granted on the order of starting date of the enrolled benefit, until the deduction limit is reached.</description>
    /// </item>
    /// <item>
    /// <description>None, requested deduction amount is adjusted against the limit individually.</description>
    /// </item>
    /// </list>
    /// Then administrative fee will be subtracted.
    /// </remarks>
    protected void applyLimitForMultipleGarnishments(
        PayrollStatementAccountingCurrencyAmount _limit,
        PayrollMultipleGarnishmentMethod _multipleMethod,
        PayrollGarnishmentTaxLevyType _type,
        LogisticsAddressStateId _stateId,
        LogisticsAddressCountryRegionId _countryRegionId)
    {
        PayrollStatementAccountingCurrencyAmount deductionTotal = 0;
        PayrollStatementAccountingCurrencyAmount proposedDeductionAmt = 0;

        PayrollStatementAccountingCurrencyAmount remainingLimit = 0;
        int64 numberOfDeductions = 0;
        int64 remainingNum = 0;

        select count(RecId) from workerGarnishmentDeduction
            where workerGarnishmentDeduction.GarnishmentTaxLevyType == _type &&
                  workerGarnishmentDeduction.StateId == _stateId &&
                  workerGarnishmentDeduction.CountryRegionId == _countryRegionId;

        numberOfDeductions = workerGarnishmentDeduction.RecId;

        if (numberOfDeductions == 0)
        {
            // no deductions, no need for adjustment
            return;
        }

        select sum(DeductionAmount) from workerGarnishmentDeduction
            where workerGarnishmentDeduction.GarnishmentTaxLevyType == _type &&
                  workerGarnishmentDeduction.StateId == _stateId &&
                  workerGarnishmentDeduction.CountryRegionId == _countryRegionId;

        deductionTotal = workerGarnishmentDeduction.DeductionAmount;

        ttsBegin;
        if (deductionTotal > _limit)
        {
            // if exceeds the deduction limit, adjust the deduction amount
            switch (_multipleMethod)
            {
                case PayrollMultipleGarnishmentMethod::ProRata :
                    // adjust deduction use a weight based on requested deduction amount
                    remainingLimit = _limit;

                    while select forUpdate workerGarnishmentDeduction
                        where workerGarnishmentDeduction.GarnishmentTaxLevyType == _type &&
                                workerGarnishmentDeduction.StateId == _stateId &&
                                workerGarnishmentDeduction.CountryRegionId == _countryRegionId
                    {
                        proposedDeductionAmt = remainingLimit * workerGarnishmentDeduction.DeductionAmount / deductionTotal;
                        this.updateGarnishmentDeduction(proposedDeductionAmt, remainingLimit, workerGarnishmentDeduction);
                        workerGarnishmentDeduction.update();
                    }

                    break;

                case PayrollMultipleGarnishmentMethod::Equal :
                    // adjust deduction from lowest amount to highest amount
                    remainingLimit = _limit;
                    remainingNum = numberOfDeductions;

                    while select forUpdate workerGarnishmentDeduction order by workerGarnishmentDeduction.DeductionAmount asc
                        where workerGarnishmentDeduction.GarnishmentTaxLevyType == _type &&
                              workerGarnishmentDeduction.StateId == _stateId &&
                              workerGarnishmentDeduction.CountryRegionId == _countryRegionId
                    {
                        proposedDeductionAmt = remainingLimit / remainingNum;
                        remainingLimit = this.updateGarnishmentDeduction(proposedDeductionAmt, remainingLimit, workerGarnishmentDeduction);
                        workerGarnishmentDeduction.update();
                        remainingNum--;
                    }

                    break;

                case PayrollMultipleGarnishmentMethod::FirstIn :
                    // adjust deduction from earliest enrolled benefit to the latest
                    remainingLimit = _limit;

                    while select forUpdate workerGarnishmentDeduction order by workerGarnishmentDeduction.ValidFrom
                        where workerGarnishmentDeduction.GarnishmentTaxLevyType == _type &&
                              workerGarnishmentDeduction.StateId == _stateId &&
                              workerGarnishmentDeduction.CountryRegionId == _countryRegionId
                    {
                        proposedDeductionAmt = remainingLimit;
                        remainingLimit = this.updateGarnishmentDeduction(proposedDeductionAmt, remainingLimit, workerGarnishmentDeduction);
                        workerGarnishmentDeduction.update();
                    }

                    break;

                case PayrollMultipleGarnishmentMethod::None :
                    // each deduction is adjusted individually against the limit
                    remainingLimit = _limit;
                    proposedDeductionAmt = _limit;

                    while select forUpdate workerGarnishmentDeduction
                        where workerGarnishmentDeduction.GarnishmentTaxLevyType  == _type &&
                              workerGarnishmentDeduction.StateId == _stateId &&
                              workerGarnishmentDeduction.CountryRegionId == _countryRegionId
                    {
                        this.updateGarnishmentDeduction(proposedDeductionAmt, remainingLimit, workerGarnishmentDeduction);
                        workerGarnishmentDeduction.update();
                    }
            }
        }
        else
        {
            // no adjustment needed, just need to remove the added admin fee from deduction amount initially
            while select forupdate workerGarnishmentDeduction order by workerGarnishmentDeduction.ValidFrom
                where workerGarnishmentDeduction.GarnishmentTaxLevyType == _type &&
                      workerGarnishmentDeduction.StateId == _stateId &&
                      workerGarnishmentDeduction.CountryRegionId == _countryRegionId
            {
                workerGarnishmentDeduction.DeductionAmount -= workerGarnishmentDeduction.AdminFee;
                workerGarnishmentDeduction.update();
            }
        }
        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcGarnishmentDeductions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the deduction for each enrolled benefit of selected garnishment tax levy type.
    /// </summary>
    /// <param name="_paymentType">
    /// Type of payroll run
    /// </param>
    /// <param name="_rule">
    /// Definition of how to determine the limit and make adjustment for enrolled benefit of selected garnishment tax levy type
    /// </param>
    /// <remarks>
    /// 1. Setup query for all enrolled benefits of selected garnishment tax levy type, selected worker, and payment type.
    /// 2. For each enrolled benefits, determine the limit for individual deduction limit and , requested deduction amount.
    /// 3. Make deduction adjustment if over the limit for selected garnishment tax levy type.
    /// </remarks>
    protected void  calcGarnishmentDeductions(PayrollPaymentType _paymentType, PayrollWorkerGarnishmentRule _rule)
    {
        RefRecId legalEntity = CompanyInfo::current();
        PayrollStatementAccountingCurrencyAmount deductionLimit;
        PayrollStatementAccountingCurrencyAmount requestedDeductionAmount;
        QueryRun queryRunWorkerEnrolledBenefit;
        PayrollWorkerGarnishmentDetail workerGarnishmentDetail;
        boolean firstRec;
        PayrollGarnishmentTaxLevyType processType;
        PayrollPayPeriod period = PayrollPayPeriod::find(payStatement.PayPeriod);
        PayrollTimePeriod payCycleTimePeriod = PayrollPayCycle::find(period.PayCycle).TimePeriod;

        //
        // for state/local tax levy, determine how to calculate the deduction limit:
        // if ExemptEarningAmount is greater than zero, use federal tax levy's approach.
        // if ExemptEarningAmount is zero, use creditor's approach.
        //
        processType = _rule.GarnishmentTaxLevyType;

        if (_rule.GarnishmentTaxLevyType == PayrollGarnishmentTaxLevyType::StateTaxLevy || _rule.GarnishmentTaxLevyType == PayrollGarnishmentTaxLevyType::LocalTaxLevy)
        {
            processType = PayrollGarnishmentTaxLevyType::Creditor;
            if (_rule.ExemptEarningAmount > 0)
            {
                processType = PayrollGarnishmentTaxLevyType::FederalTaxLevy;
            }
        }

        // set up query for enrolled benefit of selected garnishment tax levy type, and create QueryRun object
        queryRunWorkerEnrolledBenefit = new QueryRun(this.setupQueryForEnrolledGarnishment(legalEntity,
                                                                                       companyPayPeriodEndDateTime,
                                                                                       payStatement,
                                                                                       _paymentType,
                                                                                       _rule.GarnishmentTaxLevyType,
                                                                                       _rule.StateId,
                                                                                       _rule.CountryRegionId));

        firstRec = true;

        while (queryRunWorkerEnrolledBenefit.next())
        {
            // for each enrolled benefit, determine requested deduction amount and the individual limit
            workerEnrolledBenefit = queryRunWorkerEnrolledBenefit.get(tableNum(HcmWorkerEnrolledBenefit));
            benefit = queryRunWorkerEnrolledBenefit.get(tableNum(HcmBenefit));
            benefitType = queryRunWorkerEnrolledBenefit.get(tableNum(HcmBenefitType));
            workerEnrolledBenefitDetail = queryRunWorkerEnrolledBenefit.get(tableNum(PayrollWorkerEnrolledBenefitDetail));
            workerGarnishmentDetail = queryRunWorkerEnrolledBenefit.get(tableNum(PayrollWorkerGarnishmentDetail));

            if (!PayrollPayStatementBenefitLine::canCreate(benefit.RecId, payStatement.RecId, NoYes::No))
            {
                // Overridden garnishment deductions can't be changed so we don't need to calculate it.
                continue;
            }

            if (firstRec)
            {
                // determine the deduction limit
                deductionLimit = this.garnishmentDeductionLimit(payStatement, processType, _rule, payCycleTimePeriod, workerEnrolledBenefitDetail.CalculationPriorityNumber);
                firstRec = false;
            }

            // save requested deduction amount in temp table
            workerGarnishmentDeduction.clear();
            workerGarnishmentDeduction.Benefit = benefit.RecId;
            workerGarnishmentDeduction.AllowReduction = _rule.AllowReduction;
            workerGarnishmentDeduction.CalculationPriority = workerEnrolledBenefitDetail.CalculationPriorityNumber;
            workerGarnishmentDeduction.DeductionPriority = workerEnrolledBenefitDetail.DeductionPriorityNumber;
            workerGarnishmentDeduction.ValidFrom = workerEnrolledBenefit.ValidFrom;
            workerGarnishmentDeduction.GarnishmentTaxLevyType = workerGarnishmentDetail.GarnishmentTaxLevyType;
            workerGarnishmentDeduction.StateId = workerGarnishmentDetail.StateId;
            workerGarnishmentDeduction.CountryRegionId = workerGarnishmentDetail.CountryRegionId;

            // determine the requested deduction amount for each garnishment tax levy
            requestedDeductionAmount = this.requestedGarnishmentDeductionAmount(_rule.GarnishmentTaxLevyType, deductionLimit, workerEnrolledBenefitDetail, payPeriod);

            if (_rule.GarnishmentTaxLevyType == PayrollGarnishmentTaxLevyType::SupportOrder)
            {
                workerGarnishmentDeduction.DeductionAmount = requestedDeductionAmount + CurrencyExchange::round(workerGarnishmentDetail.AdministrativeFeeAmount, PayrollSetup::currencyCode());
                workerGarnishmentDeduction.AdminFee = CurrencyExchange::round(workerGarnishmentDetail.AdministrativeFeeAmount, PayrollSetup::currencyCode());
            }
            else
            {
                workerGarnishmentDeduction.DeductionAmount = requestedDeductionAmount;
            }

            workerGarnishmentDeduction.write();
        }

        if (_rule.GarnishmentTaxLevyType != PayrollGarnishmentTaxLevyType::BankruptcyOrder)
        {
            // adjust multiple garnishment deductions of same type (and state), except for bankruptcy order
            this.applyLimitForMultipleGarnishments(deductionLimit, _rule.MultipleMethod, _rule.GarnishmentTaxLevyType, _rule.StateId, _rule.CountryRegionId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposableIncomeForGarnishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate worker's disposable income for processing enrolled garnishment benefits.
    /// </summary>
    /// <param name="_paystatement">
    /// A record of table <c>PayrollPayStatement</c>
    /// </param>
    /// <param name="_disposableIncome">
    /// Unique identifier of table <c>PayrollDisposableIncome</c> record
    /// </param>
    /// <param name="_earningExemption">
    /// Allowed earning exemption when calculate disposable income
    /// </param>
    /// <param name="_disposableIncomeExemption">
    /// Allowed amount of disposable income exemption
    /// </param>
    /// <param name="_benefitCalcPriority">
    /// The calculation priority number of enrolled garnishment benefit
    /// </param>
    /// <returns>
    /// Disposable income
    /// </returns>
    /// <remarks>
    /// Disposable income = total earning - allowed earning exemption
    ///                                   - total taxes
    ///                                   - allowed earning reduction
    ///                                   - allowed benefit reduction
    ///                                   - allowed worker garnishment reduction
    ///                                   - allowed disposable income exemption
    /// The calculation of allowed earning and benefit reduction is based on record of
    /// <c>PayrollDisposableIncome</c> table.
    ///
    /// A _benefitCalcPriority value less than zero will be used to opt-out of using
    /// the _benefitCalcPriority as a criteria for determining the allowed benefit reduction
    /// and allowed worker garnishment reduction amounts
    ///
    /// A _benefitCalcPriority value greater than zero will only include allowed benefit reduction
    /// and allowed worker garnishment reduction amounts for benefits with a lower calculation priority.
    /// </remarks>
    protected PayrollStatementAccountingCurrencyAmount disposableIncomeForGarnishment(
        PayrollPayStatement _paystatement,
        PayrollDisposableIncomeRecId _disposableIncome = 0,
        PayrollAmountCurPositive _earningExemption = 0,
        PayrollAmountCurPositive _disposableIncomeExemption = 0,
        PayrollPriority _benefitCalcPriority = -1)
    {
        PayrollStatementAccountingCurrencyAmount totalWage;
        PayrollStatementAccountingCurrencyAmount totalTax;
        PayrollStatementAccountingCurrencyAmount allowedEarningReduction = 0;
        PayrollStatementAccountingCurrencyAmount allowedBenefitReduction = 0;
        PayrollStatementAccountingCurrencyAmount allowedWorkerGarnishmentReduction = 0;
        PayrollStatementAccountingCurrencyAmount earningExemption = _earningExemption;
        PayrollStatementAccountingCurrencyAmount disposableIncomeExemption = _disposableIncomeExemption;
        PayrollStatementAccountingCurrencyAmount disposableIncome;

        PayrollPayStatementTaxLine taxLine;
        PayrollPayStatementEarningLine earningLine;
        PayrollPayStatementBenefitLine benefitLine;
        PayrollDisposableIncomeEarning earningReduction;
        PayrollDisposableIncomeBenefit benefitReduction;
        PayrollDisposableIncomeBenefit workerGarnishmentReduction;

        HcmWorkerEnrolledBenefit enrolledBenefit;
        PayrollWorkerEnrolledBenefitDetail enrolledBenefitDetail;

        // Total wage
        select sum(AccountingCurrencyAmount) from earningLine
            where earningLine.PayStatement == _PayStatement.RecId &&
                  earningLine.IsMarkedForRemoval == NoYes::No &&
                  earningLine.Source != PayrollPayStatementLineSource::FringeBenefitRecover &&
                  earningLine.Source != PayrollPayStatementLineSource::GrossUpEarning;

        totalWage = earningLine.AccountingCurrencyAmount;

        // Total taxes
        select sum(AccountingcurrencyAmount) from taxLine
            where taxLine.PayStatement == _payStatement.RecId &&
                  taxLine.IsEmployer == NoYes::No &&
                  taxLine.IsMarkedForRemoval == NoYes::No;

        totalTax = taxLine.AccountingCurrencyAmount;

        if (_disposableIncome)
        {
            // Allowed earning reductions
            select sum(AccountingCurrencyAmount) from earningLine
                exists join earningReduction
                    where earningLine.PayStatement == _paystatement.RecId
                     &&   earningLine.EarningCode == earningReduction.EarningCode
                     &&   earningReduction.DisposableIncome == _disposableIncome;

            allowedEarningReduction = earningLine.AccountingCurrencyAmount;

            if (_benefitCalcPriority < 0)
            {
                // Allowed benefit deductions from all existing benefit lines.
                select sum(AccountingCurrencyAmount) from benefitLine
                    exists join benefit, DisposableIncome from benefitReduction
                        where benefitLine.PayStatement == _paystatement.RecId
                        &&    benefitLine.IsEmployer == NoYes::No
                        &&    benefitLine.IsMarkedForRemoval == NoYes::No
                        &&    benefitLine.Benefit == benefitReduction.Benefit
                        &&    benefitReduction.DisposableIncome == _disposableIncome;

                allowedBenefitReduction = benefitLine.AccountingCurrencyAmount;

                // Allowed benefit deductions from all existing worker garnishment deduction lines.
                select sum(DeductionAmount) from workerGarnishmentDeduction
                    exists join Benefit, DisposableIncome from workerGarnishmentReduction
                        where workerGarnishmentDeduction.Benefit == workerGarnishmentReduction.Benefit
                        &&    workerGarnishmentReduction.DisposableIncome == _disposableIncome;

                allowedWorkerGarnishmentReduction = workerGarnishmentDeduction.DeductionAmount;
            }
            else
            {
                // Ensure that effectiveRangeStart and effectiveRangeEnd are initialized properly
                this.assignExpandedValidTimeStateRange();

                // Allowed benefit deductions from the existing benefit lines with a lower calculation priority.
                select validTimeState(effectiveRangeStart, effectiveRangeEnd) sum(AccountingCurrencyAmount) from benefitLine
                    exists join Benefit, DisposableIncome from benefitReduction
                    exists join Benefit, worker from enrolledBenefit
                    exists join WorkerEnrolledBenefit, CalculationPriorityNumber from enrolledBenefitDetail
                        where benefitLine.PayStatement == _paystatement.RecId
                        &&    benefitLine.IsEmployer == NoYes::No
                        &&    benefitLine.IsMarkedForRemoval == NoYes::No
                        &&    benefitLine.Benefit == benefitReduction.Benefit
                        &&    benefitReduction.DisposableIncome == _disposableIncome
                        &&    enrolledBenefit.Benefit == benefitReduction.Benefit
                        &&    enrolledBenefit.Worker == _payStatement.Worker
                        &&    enrolledbenefitdetail.workerenrolledbenefit == enrolledbenefit.recid
                        &&    enrolledBenefit.ValidFrom <= companyPayPeriodEndDateTime
						&&    enrolledBenefit.ValidTo >= companyPayPeriodEndDateTime
						&&    enrolledBenefitDetail.WorkerEnrolledBenefit == enrolledBenefit.RecId
						&&    enrolledBenefitDetail.CalculationPriorityNumber < _benefitCalcPriority
						&&    enrolledBenefitDetail.ValidFrom <= companyPayPeriodEndDate
						&&    enrolledBenefitDetail.ValidTo >= companyPayPeriodEndDate;

                allowedBenefitReduction = benefitLine.AccountingCurrencyAmount;

                // Allowed benefit deductions from the worker garnishment deduction lines with a lower calculation priority.
                select sum(DeductionAmount) from workerGarnishmentDeduction
                    exists join Benefit, DisposableIncome from workerGarnishmentReduction
                        where workerGarnishmentDeduction.CalculationPriority < _benefitCalcPriority
                        &&    workerGarnishmentDeduction.Benefit == workerGarnishmentReduction.Benefit
                        &&    workerGarnishmentReduction.DisposableIncome == _disposableIncome;

                allowedWorkerGarnishmentReduction = workerGarnishmentDeduction.DeductionAmount;
           }
        }

        disposableIncome = totalWage - earningExemption - totalTax - allowedEarningReduction - allowedBenefitReduction - allowedWorkerGarnishmentReduction - disposableIncomeExemption;

        if (disposableIncome < 0)
        {
            disposableIncome = 0.0;
        }

        return disposableIncome;
    }

]]></Source>
			</Method>
			<Method>
				<Name>disposableIncomeForTaxLevy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate worker's disposable income for processing enrolled tax levy benefits.
    /// </summary>
    /// <param name="_payStatement">
    /// A record of table <c>PayrollPayStatement</c>
    /// </param>
    /// <param name="_earningExemption">
    /// Allowed earning exemption when calculate disposable income
    /// </param>
    /// <param name="_benefitCalcPriority">
    /// The calculation priority number of enrolled tax levy benefit
    /// </param>
    /// <param name="_disposableIncome">
    /// Unique identifier of table <c>PayrollDisposableIncome</c> record
    /// </param>
    /// <returns>
    /// Disposable income
    /// </returns>
    /// <remarks>
    /// Disposable income = total earning - allowed earning exemption
    ///                                   - total taxes
    ///                                   - allowed benefit reduction which has lower calculation priority
    ///                                   - allowed worker garnishment reduction which has lower calculation priority
    ///
    /// A _disposableIncome value will be used to constrain the allowed benefit reduction
    /// and allowed worker garnishment reduction to benefits within the specified disposable income
    /// collection.
    ///
    /// Otherwise all benefits will be be considered.
    /// </remarks>
    protected PayrollStatementAccountingCurrencyAmount disposableIncomeForTaxLevy(
        PayrollPayStatement _payStatement,
        PayrollAmountCurPositive _earningExemption = 0,
        PayrollPriority _benefitCalcPriority = 0,
        PayrollDisposableIncomeRecId _disposableIncome = 0)
    {
        PayrollStatementAccountingCurrencyAmount totalWage;
        PayrollStatementAccountingCurrencyAmount totalTax;
        PayrollStatementAccountingCurrencyAmount allowedEarningReduction = 0;
        PayrollStatementAccountingCurrencyAmount allowedBenefitReduction = 0;
        PayrollStatementAccountingCurrencyAmount allowedWorkerGarnishmentReduction = 0;
        PayrollStatementAccountingCurrencyAmount earningExemption = _earningExemption;
        PayrollStatementAccountingCurrencyAmount disposableIncome;

        PayrollPayStatementTaxLine taxLine;
        PayrollPayStatementEarningLine earningLine;
        PayrollPayStatementBenefitLine benefitLine;
        PayrollDisposableIncomeEarning earningReduction;
        PayrollDisposableIncomeBenefit benefitReduction;
        PayrollDisposableIncomeBenefit workerGarnishmentReduction;

        HcmWorkerEnrolledBenefit enrolledBenefit;
        PayrollWorkerEnrolledBenefitDetail enrolledBenefitDetail;

        // Total wage
        select sum(AccountingCurrencyAmount) from earningLine
            where earningLine.PayStatement == _payStatement.RecId &&
                  earningLine.IsMarkedForRemoval == NoYes::No &&
                  earningLine.Source != PayrollPayStatementLineSource::FringeBenefitRecover &&
                  earningLine.Source != PayrollPayStatementLineSource::GrossUpEarning;

        totalWage = earningLine.AccountingCurrencyAmount;

        // Total taxes
        select sum(AccountingcurrencyAmount) from taxLine
            where taxLine.PayStatement == _payStatement.RecId &&
                  taxLine.IsEmployer == NoYes::No &&
                  taxLine.IsMarkedForRemoval == NoYes::No;

        totalTax = taxLine.AccountingCurrencyAmount;

        // Ensure that effectiveRangeStart and effectiveRangeEnd are initialized properly
        this.assignExpandedValidTimeStateRange();

        if (_disposableIncome)
        {
            // Allowed earning reductions
            select sum(AccountingCurrencyAmount) from earningLine
                exists join earningReduction
                    where earningLine.PayStatement == _paystatement.RecId
                    &&   earningLine.EarningCode == earningReduction.EarningCode
                    &&   earningReduction.DisposableIncome == _disposableIncome;

            allowedEarningReduction = earningLine.AccountingCurrencyAmount;

            // Allowed benefit deductions from the existing benefit lines for a disposable income reference with a lower calculation priority.
            select validTimeState(effectiveRangeStart, effectiveRangeEnd) sum(AccountingCurrencyAmount) from benefitLine
                exists join Benefit, DisposableIncome from benefitReduction
                exists join Benefit, worker from enrolledBenefit
                exists join WorkerEnrolledBenefit, CalculationPriorityNumber from enrolledBenefitDetail
                    where benefitLine.PayStatement == _paystatement.RecId
                    &&    benefitLine.IsEmployer == NoYes::No
                    &&    benefitLine.IsMarkedForRemoval == NoYes::No
                    &&    benefitLine.Benefit == benefitReduction.Benefit
                    &&    benefitReduction.DisposableIncome == _disposableIncome
                    &&    enrolledBenefit.Benefit == benefitReduction.Benefit
                    &&    enrolledBenefit.Worker == _payStatement.Worker
                    &&    enrolledBenefitDetail.WorkerEnrolledBenefit == enrolledBenefit.RecId
                    &&    enrolledBenefit.ValidFrom <= companyPayPeriodEndDateTime
					&&    enrolledBenefit.ValidTo >= companyPayPeriodEndDateTime
					&&    enrolledBenefitDetail.WorkerEnrolledBenefit == enrolledBenefit.RecId
					&&    enrolledBenefitDetail.CalculationPriorityNumber < _benefitCalcPriority
					&&    enrolledBenefitDetail.ValidFrom <= companyPayPeriodEndDate
					&&    enrolledBenefitDetail.ValidTo >= companyPayPeriodEndDate;

            allowedBenefitReduction = benefitLine.AccountingCurrencyAmount;

            // Allowed benefit deductions from the worker garnishment deduction lines for a disposable income reference with a lower calculation priority.
            select sum(DeductionAmount) from workerGarnishmentDeduction
                exists join Benefit, DisposableIncome from workerGarnishmentReduction
                    where workerGarnishmentDeduction.CalculationPriority < _benefitCalcPriority
                    &&    workerGarnishmentDeduction.Benefit == workerGarnishmentReduction.Benefit
                    &&    workerGarnishmentReduction.DisposableIncome == _disposableIncome;

            allowedWorkerGarnishmentReduction = workerGarnishmentDeduction.DeductionAmount;
        }
        else
        {
            // Allowed benefit deductions from the existing benefit lines with a lower calculation priority.
            select validTimeState(effectiveRangeStart, effectiveRangeEnd) sum(AccountingCurrencyAmount) from benefitLine
                exists join Benefit, worker from enrolledBenefit
                exists join WorkerEnrolledBenefit, CalculationPriorityNumber from enrolledBenefitDetail
                    where benefitLine.PayStatement == _paystatement.RecId
                    &&    benefitLine.IsEmployer == NoYes::No
                    &&    benefitLine.IsMarkedForRemoval == NoYes::No
                    &&    enrolledBenefit.Benefit == benefitLine.Benefit
                    &&    enrolledBenefit.Worker == _payStatement.Worker
                    &&    enrolledBenefitDetail.WorkerEnrolledBenefit == enrolledBenefit.RecId
                    &&    enrolledBenefit.ValidFrom <= companyPayPeriodEndDateTime
					&&    enrolledBenefit.ValidTo >= companyPayPeriodEndDateTime
					&&    enrolledBenefitDetail.WorkerEnrolledBenefit == enrolledBenefit.RecId
					&&    enrolledBenefitDetail.CalculationPriorityNumber < _benefitCalcPriority
					&&    enrolledBenefitDetail.ValidFrom <= companyPayPeriodEndDate
					&&    enrolledBenefitDetail.ValidTo >= companyPayPeriodEndDate;

            allowedBenefitReduction = benefitLine.AccountingCurrencyAmount;

            // Allowed benefit deductions from the worker garnishment deduction lines with a lower calculation priority.
            select sum(DeductionAmount) from workerGarnishmentDeduction
                    where workerGarnishmentDeduction.CalculationPriority < _benefitCalcPriority;

            allowedWorkerGarnishmentReduction = workerGarnishmentDeduction.DeductionAmount;
        }

        disposableIncome = totalWage - earningExemption - totalTax - allowedEarningReduction - allowedBenefitReduction - allowedWorkerGarnishmentReduction;

        if (disposableIncome < 0)
        {
            disposableIncome = 0.0;
        }

        return disposableIncome;
    }

]]></Source>
			</Method>
			<Method>
				<Name>garnishmentDeductionLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the deduction limit for a given type of enrolled garnishment tax levy benefit.
    /// </summary>
    /// <param name="_payStatement">
    /// Record of table <c>PayrollPayStatement</c>
    /// </param>
    /// <param name="_type">
    /// The garnishment tax levy type
    /// </param>
    /// <param name="_rule">
    /// A Record of table <c>PayrollWorkerGarnishmentRule</c>
    /// </param>
    /// <param name="_payCycleTimePeriod">
    /// Pay cycle frequency
    /// </param>
    /// <param name="_calculationPriority">
    /// Calculation priority of the enrolled benefit
    /// </param>
    /// <returns>
    /// The deduction limit
    /// </returns>
    /// <remarks>
    /// In general, the deduction limit is determined by choice of limit method:
    /// 1. Fixed amount, if use alternate limit is the user selection.
    /// 2. Calculated amount, if calculate disposable income is the selection,
    ///    and either a percentage or a portion of disposable income is the deduction limit.
    /// The calculation of deduction limit is based on record of table <c>PayrollWorkerGarnishmentRule</c>
    /// </remarks>
    protected PayrollStatementAccountingCurrencyAmount garnishmentDeductionLimit(
        PayrollPayStatement _payStatement,
        PayrollGarnishmentTaxLevyType _type,
        PayrollWorkerGarnishmentRule _rule,
        PayrollTimePeriod _payCycleTimePeriod = PayrollTimePeriod::Weekly,
        PayrollPriority _calculationPriority = -1)
    {
        PayrollStatementAccountingCurrencyAmount limit;
        PayrollStatementAccountingCurrencyAmount workerDisposableIncome;

        switch (_type)
        {
            case PayrollGarnishmentTaxLevyType::SupportOrder :
                if (_rule.LimitMethod == PayrollLimitMethod::UseAlternativeLimit)
                {
                    limit = _rule.AlternateLimit;
                }
                else if (_rule.LimitMethod == PayrollLimitMethod::CalculateDisposableIncome)
                {
                    workerDisposableIncome = this.disposableIncomeForGarnishment(_payStatement,
                                                                                 _rule.DisposableIncome,
                                                                                 _rule.ExemptEarningAmount,
                                                                                 _rule.DisposableIncomeExemption,
                                                                                 _calculationPriority);

                    limit = workerDisposableIncome * _rule.DisposableEarningsPercent;
                }
                break;

            case PayrollGarnishmentTaxLevyType::StudentLoan :
            case PayrollGarnishmentTaxLevyType::FederalAdministrative :
            case PayrollGarnishmentTaxLevyType::Creditor :
                if (_rule.LimitMethod == PayrollLimitMethod::UseAlternativeLimit)
                {
                    limit = _rule.AlternateLimit;
                }
                else if (_rule.LimitMethod == PayrollLimitMethod::CalculateDisposableIncome)
                {
                    workerDisposableIncome = this.disposableIncomeForGarnishment(_payStatement,
                                                                                 _rule.DisposableIncome,
                                                                                 _rule.ExemptEarningAmount,
                                                                                 _rule.DisposableIncomeExemption,
                                                                                 _calculationPriority);

                    limit = min((workerDisposableIncome * _rule.DisposableEarningsPercent),
                                (workerDisposableIncome - this.minimumWageLimit(_rule.MinimumWage, _rule.MinimumWageMultiplier, _payCycleTimePeriod)));
                }
                break;

            case PayrollGarnishmentTaxLevyType::FederalTaxLevy :
                if (_rule.LimitMethod == PayrollLimitMethod::UseAlternativeLimit)
                {
                    limit = _rule.AlternateLimit;
                }
                else if (_rule.LimitMethod == PayrollLimitMethod::CalculateDisposableIncome)
                {
                    limit = this.disposableIncomeForTaxLevy(_payStatement, _rule.ExemptEarningAmount, _calculationPriority, _rule.DisposableIncome);
                }
                break;

            case PayrollGarnishmentTaxLevyType::CombinedGarnishments :
                limit = this.disposableIncomeForGarnishment(_payStatement,
                                                            _rule.DisposableIncome,
                                                            _rule.ExemptEarningAmount,
                                                            _rule.DisposableIncomeExemption,
                                                            _calculationPriority);
                if (_rule.RecId)
                {
                    limit = limit * _rule.DisposableEarningsPercent;
                }
                else
                {
                    limit = limit * 0.25;
                }
                break;

            case PayrollGarnishmentTaxLevyType::BankruptcyOrder :
                // Bankruptcy Order doesn't have limit, and does not subject to multiple garnishment adjustment.
                limit = 0.0;
                break;

            default :
                throw error(strFmt("@Payroll:UnexpectedPayrolllgarnishmenttaxlevytypeEnumValue1NoPayState", _type, HcmWorker::find(_payStatement.Worker).PersonnelNumber));
        }

        return CurrencyExchange::round(limit, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>minimumWageLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculate the allowed reduction when minimum wage is involved in garnishment tax levy processing.
    /// </summary>
    /// <param name="_minimumWage">
    /// The minimum wage
    /// </param>
    /// <param name="_minimumWageMultiplier">
    /// A multiplier used in calculation of allowed reduction.
    /// </param>
    /// <param name="_payCycleTimePeriod">
    /// The payroll pay cycle frequency
    /// </param>
    /// <returns>
    /// The allowed reduction
    /// </returns>
    /// <remarks>
    /// When minimum wage is considered in calculation of the deduction limit,
    /// this is how the allowed reduction is calculated: minimum wage * multiplier / pay cycle divisor
    /// The pay cycle divisor is a number based on the payroll pay cycle frequency.
    /// This allowed reduction will be subtracted from disposable income when determine the deduction limit.
    /// If _payCycleTimePeriod does not match with any of defined type, throw an error.
    /// </remarks>
    protected PayrollStatementAccountingCurrencyAmount minimumWageLimit(
        PayrollAmountCurPositive _minimumWage,
        PayrollAmountCurPositive _minimumWageMultiplier,
        PayrollTimePeriod _payCycleTimePeriod)
    {
        real payCycleDivisor;

        switch (_payCycleTimePeriod)
        {
            case PayrollTimePeriod::Daily :
                payCycleDivisor = 365.0;
                break;
            case PayrollTimePeriod::Weekly :
                payCycleDivisor = 52.0;
                break;
            case PayrollTimePeriod::Biweekly :
                payCycleDivisor = 26.0;
                break;
            case PayrollTimePeriod::Semimonthly :
                payCycleDivisor = 24.0;
                break;
            case PayrollTimePeriod::Monthly :
                payCycleDivisor = 12.0;
                break;
            case PayrollTimePeriod::Quarterly :
                payCycleDivisor = 4.0;
                break;
            case PayrollTimePeriod::Semiannually :
                payCycleDivisor = 2.0;
                break;
            case PayrollTimePeriod::Annually :
                payCycleDivisor = 1.0;
                break;
            default :
                throw error(strFmt("@Payroll:UnexpectedPayrollpaycycletimeperiodEnumValue1NoPayStatementW", _payCycleTimePeriod));
        }

        return (_minimumWage * _minimumWageMultiplier * 52 / payCycleDivisor);
    }

]]></Source>
			</Method>
			<Method>
				<Name>requestedGarnishmentDeductionAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determine the requested deduction amount for each enrolled garnishment tax levy benefit.
    /// </summary>
    /// <param name="_type">
    /// The garnishment tax levy type
    /// </param>
    /// <param name="_limit">
    /// The individual deduction limit for a given garnishment tax levy type
    /// </param>
    /// <param name="_enrolledBenefitDetail">
    /// A record of <c>PayrollWorkerEnrolledBenefitDetail</c>
    /// </param>
    /// <param name="_payPeriod">
    /// The pay period for the pay statement
    /// </param>
    /// <returns>
    /// The requested deduction
    /// </returns>
    /// <remarks>
    /// The requested deduction for each enrolled garnishment tax levy benefit is determine in the following way:
    /// 1. A fixed amount, if user set deduction basis as fixed amount.
    /// 2. A percent of base earning, if user elect the deduction basis as percent of earning.
    /// 3. The deduction limit is the requested deduction amount in the case of federal tax levy.
    /// Then the deduction amount will be adjusted if it is over the remaining limit of the current pay period.
    /// </remarks>
    protected PayrollStatementAccountingCurrencyAmount requestedGarnishmentDeductionAmount(
        PayrollGarnishmentTaxLevyType _type,
        PayrollStatementAccountingCurrencyAmount _limit,
        PayrollWorkerEnrolledBenefitDetail _enrolledBenefitDetail,
        PayrollPayPeriod _payPeriod)
    {
        PayrollStatementAccountingCurrencyAmount deductionAmt;
        PayrollWorkerEnrolledBenefitLimit   benefitLimit;
        HcmWorkerEnrolledBenefit enrolledGarnishmentBenefit = HcmWorkerEnrolledBenefit::find(_enrolledBenefitDetail.WorkerEnrolledBenefit);

        switch (_type)
        {
            case PayrollGarnishmentTaxLevyType::SupportOrder :
            case PayrollGarnishmentTaxLevyType::StudentLoan :
            case PayrollGarnishmentTaxLevyType::FederalAdministrative :
            case PayrollGarnishmentTaxLevyType::Creditor :
            case PayrollGarnishmentTaxLevyType::BankruptcyOrder :
                if (_enrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::FixedAmount)
                {
                    deductionAmt = _enrolledBenefitDetail.DeductionAmountCur;
                }
                else if (_enrolledBenefitDetail.DeductionBasis == PayrollDeductionBasis::PercentOfEarnings)
                {
                    deductionAmt = this.calculateEarningBasis(PayrollType::Deduction) * _enrolledBenefitDetail.DeductionAmountCur;
                }
                break;

            case PayrollGarnishmentTaxLevyType::FederalTaxLevy :
            case PayrollGarnishmentTaxLevyType::StateTaxLevy :
            case PayrollGarnishmentTaxLevyType::LocalTaxLevy :
                deductionAmt = _limit;
                break;

            default :
                throw error(strFmt("@Payroll:UnexpectedPayrolllgarnishmenttaxlevytypeEnumValue1NoPayState", _type, HcmWorker::find(enrolledGarnishmentBenefit.Worker).PersonnelNumber));
        }

        // check against the remaining limit of the pay period
        benefitLimit = PayrollWorkerEnrolledBenefitLimit::findByWorkerEnrolledBenefit(_enrolledBenefitDetail.WorkerEnrolledBenefit, true);
        if (benefitLimit.RecId)
        {
            benefitLimit.processDeductionLimitPeriod(_payPeriod, true);
            deductionAmt = min(deductionAmt, benefitLimit.DeductionLimitPeriodRemaining);
        }

        return CurrencyExchange::round(deductionAmt, PayrollSetup::currencyCode());
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupQueryForEnrolledGarnishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create query for enrolled garnishment benefit of selected worker, garnishment tax levy type,
    /// and payroll run type.
    /// </summary>
    /// <param name="_legalEntity">
    /// Company with which the current payroll run is associated
    /// </param>
    /// <param name="_companyPayPeriodEndDate">
    /// End date and time of the pay period
    /// </param>
    /// <param name="_payStatement">
    /// A record of table <c>PayrollPayStatement</c>
    /// </param>
    /// <param name="_paymentType">
    /// Payroll run type
    /// </param>
    /// <param name="_garnishmentTaxLevyType">
    /// Garnishment tax levy type of the enrolled benefits
    /// </param>
    /// <param name="_stateId">
    /// String type idendification of a state
    /// </param>
    /// <param name="_countryRegionId">
    /// String type identification of a country to which the state belongs
    /// </param>
    /// <returns>
    /// A query object
    /// </returns>
    /// <remarks>
    /// 1. Create query object based on modeled query <c>PayrollWorkerEnrolledBenefitCalc</c>.
    /// 2. Make query date-effective.
    /// 3. Set up query range for selected worker.
    /// 4. Set up query range for legal entity.
    /// 5. Sort query result by benefit calculation priority.
    /// 6. Set up query range for pay period of the pay statement.
    /// 7. Set up query range for garnishment tax levy type, state and country region.
    /// 8. Set up query range for selected payroll run type.
    /// </remarks>
    protected Query setupQueryForEnrolledGarnishment(
        CompanyInfoRecId _legalEntity,
        utcDatetime _companyPayPeriodEndDate,
        PayrollPayStatement _payStatement,
        PayrollPaymentType _paymentType,
        PayrollGarnishmentTaxLevyType _garnishmentTaxLevyType,
        LogisticsAddressStateId _stateId,
        LogisticsAddressCountryRegionId _countryRegionId)
    {
        Query queryEnrolledGarnishment = new Query(queryStr(PayrollWorkerEnrolledBenefitCalc));
        QueryBuildDataSource qbdsWorkerEnrolledBenefit;
        QueryBuildDataSource qbdsWorkerEnrolledBenefitDetail;
        QueryBuildDataSource qbdsCalcFreqPayPeriod;

        QueryBuildDataSource qbdsWorkerGarnishmentDetail;
        QueryBuildRange qbrGarnishmentTaxLevyType;
        QueryBuildRange qbrState;
        QueryBuildRange qbrCountryRegion;

        QueryBuildDataSource qbdsPayrollBenefitPlanDetail;
        QueryBuildRange qbrPaymentTypePrimary;
        QueryBuildRange qbrPaymentTypeGrossUp;
        QueryBuildRange qbrPaymentTypeAdditional;

        // Setup query : Date Effective
        queryEnrolledGarnishment.validTimeStateAsOfDateTime(_companyPayPeriodEndDate);

        // Setup query: query range for worker
        qbdsWorkerEnrolledBenefit = queryEnrolledGarnishment.dataSourceTable(tableNum(HcmWorkerEnrolledBenefit));
        qbdsWorkerEnrolledBenefit.findRange(fieldNum(HcmWorkerEnrolledBenefit, Worker)).value(queryValue(_payStatement.Worker));

        // Setup query: query range for Legal Entity and sort by calculation priority
        qbdsWorkerEnrolledBenefitDetail = queryEnrolledGarnishment.dataSourceTable(tableNum(PayrollWorkerEnrolledBenefitDetail));
        qbdsWorkerEnrolledBenefitDetail.findRange(fieldNum(PayrollWorkerEnrolledBenefitDetail, LegalEntity)).value(queryValue(_legalEntity));
        qbdsWorkerEnrolledBenefitDetail.addSortField(fieldNum(PayrollWorkerEnrolledBenefitDetail, CalculationPriorityNumber), SortOrder::Ascending);

        // Setup query: query range for PayPeriod
        qbdsCalcFreqPayPeriod = queryEnrolledGarnishment.dataSourceTable(tableNum(PayrollCalculationFrequencyPayPeriod));
        qbdsCalcFreqPayPeriod.findRange(fieldNum(PayrollCalculationFrequencyPayPeriod, PayPeriod)).value(queryValue(_payStatement.PayPeriod));

        // setup query: query range for garnishment tax levy type, stateId + countryRegionId
        qbdsWorkerGarnishmentDetail = queryEnrolledGarnishment.dataSourceTable(tableNum(PayrollWorkerGarnishmentDetail));

        qbrGarnishmentTaxLevyType = qbdsWorkerGarnishmentDetail.findRange(fieldNum(PayrollWorkerGarnishmentDetail, GarnishmentTaxLevyType));
        qbrGarnishmentTaxLevyType.value(queryValue(_garnishmentTaxLevyType));

        qbrState= qbdsWorkerGarnishmentDetail.findRange(fieldNum(PayrollWorkerGarnishmentDetail, StateId));
        qbrState.value(queryValue(_stateId));

        qbrCountryRegion = qbdsWorkerGarnishmentDetail.findRange(fieldNum(PayrollWorkerGarnishmentDetail, CountryREgionId));
        qbrCountryRegion.value(queryValue(_countryRegionId));

        // setup query range to match with paymnet type
        qbdsPayrollBenefitPlanDetail = queryEnrolledGarnishment.dataSourceTable(tableNum(PayrollBenefitPlanDetail));
        qbrPaymentTypePrimary = qbdsPayrollBenefitPlanDetail.findRange(fieldNum(PayrollBenefitPlanDetail, IsPrimary));
        qbrPaymentTypeGrossUp = qbdsPayrollBenefitPlanDetail.findRange(fieldNum(PayrollBenefitPlanDetail, IsGrossUp));
        qbrPaymentTypeAdditional = qbdsPayrollBenefitPlanDetail.findRange(fieldNum(PayrollBenefitPlanDetail, IsAdditional));

        switch (_paymentType)
        {
            case PayrollPaymentType::Primary :
                qbrPaymentTypePrimary.value(queryValue(NoYes::Yes));
                qbrPaymentTypeGrossUp.enabled(false);
                qbrPaymentTypeAdditional.enabled(false);
                break;
            case PayrollPaymentType::GrossUp :
                qbrPaymentTypePrimary.enabled(false);
                qbrPaymentTypeGrossUp.value(queryValue(NoYes::Yes));
                qbrPaymentTypeAdditional.enabled(false);
                break;
            case PayrollPaymentType::Additional :
                qbrPaymentTypePrimary.enabled(false);
                qbrPaymentTypeGrossUp.enabled(false);
                qbrPaymentTypeAdditional.value(queryValue(NoYes::Yes));
                break;
        }

        return queryEnrolledGarnishment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateGarnishmentDeduction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update garnishment deduction amount in the temp table, and update the remaining limit.
    /// </summary>
    /// <param name="_proposedDeduction">
    /// The proposed deduction amount
    /// </param>
    /// <param name="_currentLimit">
    /// The current remaining limit
    /// </param>
    /// <param name="_garnishmentDeduction">
    /// Temporary table buffer
    /// </param>
    /// <returns>
    /// The updated remaining limit
    /// </returns>
    /// <remarks>
    /// Set the garnishment deduction based on requested deduction amount, proposed deduction amount, and administrative fee.
    /// After the deduction amount is set, update the remaining limit for multiple garnishment deduction adjustment.
    /// </remarks>
    protected PayrollStatementAccountingCurrencyAmount updateGarnishmentDeduction(
        PayrollStatementAccountingCurrencyAmount _proposedDeduction,
        PayrollStatementAccountingCurrencyAmount _currentLimit,
        PayrollTmpGarnishmentDeduction _garnishmentDeduction)
    {
        PayrollStatementAccountingCurrencyAmount newLimit;

        if (_garnishmentDeduction.DeductionAmount > _proposedDeduction)
        {
            if (_proposedDeduction > _garnishmentDeduction.AdminFee)
            {
                _garnishmentDeduction.DeductionAmount = CurrencyExchange::round(_proposedDeduction, PayrollSetup::currencyCode()) - _garnishmentDeduction.AdminFee;
            }
            else
            {
                _garnishmentDeduction.DeductionAmount = 0.0;
                _garnishmentDeduction.AdminFee = 0.0;
            }
        }
        else
        {
            _garnishmentDeduction.DeductionAmount -= _garnishmentDeduction.AdminFee;
        }

        newLimit = _currentLimit - _garnishmentDeduction.DeductionAmount - _garnishmentDeduction.AdminFee;

        return newLimit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>