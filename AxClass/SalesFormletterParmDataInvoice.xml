<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesFormletterParmDataInvoice</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::Invoice)]
[DocumentStatusFactoryAttribute(DocumentStatus::FreeTextInvoice)]
class SalesFormletterParmDataInvoice
extends SalesFormletterParmData
{
    RecordInsertList recordInsertParmLinePricingCalculation;
    RecordInsertList recordInsertParmSubLine;
    SalesQty newPostingSalesQty;
    InventQty newPostingInventQty;
    PdsCWInventQty newPostingCWQty;
    boolean allowTaxRegulation;
    int taxAdjustmentDocumentCount;

    PaymentStub giroType;
    Map salesParmSubTableMap;
    NoYes allowLineLevelTaxAdjustments;

    IntercompanySalesAtCostPriceFormLetterHandler intercompanySalesAtCostPriceHandler;

    // <GEERU>
    OfficialsServ_RU offSrv;
    // </GEERU>

    // <GBR>
    Map packingSlipParmRefIdMap_BR;
    // </GBR>

    // <GEEU>
    AdvanceInvoiceSettlement_SalesOrder_W advanceInvoiceSettlement;
    #ISOCountryRegionCodes
    #EECountryRegionCodes
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowCreateParmLineIfFromLoad_BR</Name>
				<Source><![CDATA[
    protected boolean allowCreateParmLineIfFromLoad_BR(SalesLine _salesLine)
    {
        if (this.isPostFromLoad_BR())
        {
            if (_salesLine.SalesStatus == SalesStatus::Invoiced)
            {
                return false;
            }

            return _salesLine.whsIsInLoadAndNotInvoiced_BR(this.parmWHSLoadId(), tableNum(CustInvoiceJour));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAdvancePayments_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs check of current update for advance payments exist
    /// </summary>
    /// <param name="_showBox">
    /// If box should be shown to user to prompt for proceeding
    /// </param>
    /// <returns>
    /// True if no prepayments exist or user selected to proceed
    /// </returns>
    public boolean checkAdvancePayments_W(boolean _showBox = false)
    {
        boolean ret = true;

        SalesParmTable localSalesParmTable;
        SalesParmLine localSalesParmLine;
        SalesTable localSalesTable;

        Set salesSet = new Set(Types::String);

        Set custSet = new Set(Types::Container);

        str errorStr = '';
        boolean advanceAdjustment = LedgerParameters::find().AdvanceAdjustment_W || EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled();

        if (!CzCustAdvanceInvoiceTable::featureEnabled() && !advanceAdjustment)
        {
            return true;
        }

        while select SalesId, InvoiceAccount, RecId from localSalesTable
            join Transdate from localSalesParmTable
                where localSalesParmTable.ParmId == salesParmUpdate.ParmId
            exists join localSalesParmLine
                where localSalesParmLine.OrigSalesId == localSalesTable.SalesId &&
                      localSalesParmLine.ParmId == salesParmUpdate.ParmId &&
                      localSalesParmTable.TableRefId == localSalesParmLine.TableRefId
        {
            if (salesSet.in(localSalesTable.SalesId))
                continue;

            if ((advanceAdjustment &&
                CustVendExchAdjustment_W::existsPrepayments(ModuleCustVend::Cust,
                                                            localSalesTable.InvoiceAccount,
                                                            localSalesParmTable.Transdate)) ||
                (CzCustAdvanceInvoiceLink::existsPaymentForOrder(localSalesTable.company(), localSalesTable.SalesId) &&
                ! SpecTrans::findBySpec(localSalesTable.company(), tableNum(SalesTable), localSalesTable.RecId)))
            {
                if (!_showBox)
                {
                    warning(strFmt("@GLS111760", localSalesTable.SalesId));
                }

                salesSet.add(localSalesTable.SalesId);
            }

            if (this.parmAdvanceInvoiceSettlement_W() && _showBox)
            {
                errorStr = this.parmAdvanceInvoiceSettlement_W().checkSettlement(localSalesTable);
            }

            custSet.add([ localSalesTable.company(), localSalesTable.InvoiceAccount ]);
        }

        if (_showBox)
        {
            if (salesSet.elements())
            {
                ret = Box::okCancel(strFmt("@GLS111761", strRem(salesSet.toString(), '{}')),
                                    DialogButton::Cancel) == DialogButton::Ok;
            }

            if (errorStr && ret)
            {
                ret = Box::okCancel(errorStr, DialogButton::Cancel) == DialogButton::Ok;
            }
        }
        else if (! advanceAdjustment)
        {
            SetIterator custIterator = new SetIterator(custSet);
            while (custIterator.more())
            {
                if (CzCustAdvanceInvoiceLink::existsNonLinkedPayment(conPeek(custIterator.value(), 1),
                                                                     CustTable::find(conPeek(custIterator.value(), 2)).Party))
                {
                    info(strFmt("@GLS111758", conPeek(custIterator.value(), 2)));
                }

                if (CzCustAdvanceInvoiceLink::existsPaymentLinkedToManual(conPeek(custIterator.value(), 1),
                                                                          conPeek(custIterator.value(), 2)))
                {
                    info(strFmt("@GLS111759", conPeek(custIterator.value(), 2)));
                }

                custIterator.next();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxWorkRegulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if there are any issues with adjusted taxes on the current documents.
    /// </summary>
    /// <returns>
    /// true if there are no issues with adjusted taxes; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This is an error check during the arrange process.
    /// </remarks>
    protected boolean checkTaxWorkRegulation()
    {
        if (allowTaxRegulation || salesParmUpdate.numberOfSubTables() <= 1 ||
            taxAdjustmentDocumentCount == salesParmUpdate.numberOfTables())
        {
            // If there is only one subtable, arrange will have no effect. Allow adjusted taxes in that case.
            return true;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesFromWMSShipment</Name>
				<Source><![CDATA[
    private void chooseLinesFromWMSShipment()
    {
        WMSShipment wmsShipment;
        WMSOrderTrans wmsOrderTrans;
        SalesLine localSalesLine;

        TradeLineRefId tableRefId;
        // <GEERU>
        CustPostingProfile previousPostingProfile,
                                postingProfile;
        InventProfileType_RU previousInventProfileType,
                                inventProfileType;
        InventOwnerId_RU previousInventOwnerId;
        InventDim inventDim;
        // </GEERU>

        ttsbegin;
        this.initRecordLists();
        salesParmUpdate = SalesParmUpdate::find(salesParmUpdate.ParmId, true);
        salesParmUpdate.SpecQty = SalesUpdate::DeliverNow;
        salesParmUpdate.SumBy = AccountOrder::Account;

        List list = List::create(this.parmLineList());
        ListEnumerator listEnumerator = list.getEnumerator();

        while (listEnumerator.moveNext())
        {
            wmsShipment = listEnumerator.current();
            if (wmsShipment.PackingType == WMSPackingType::Order)
            {
                salesParmUpdate.SumBy = AccountOrder::None;
                break;
            }
        }

        salesParmUpdate.update();

        listEnumerator.reset();
        while (listEnumerator.moveNext())
        {
            wmsShipment = listEnumerator.current();
            SalesId previousSalesId = '';

            // <GEERU>
            if (countryRegion_RU)
            {
                while select InventTransId, sum(Qty) from wmsOrderTrans
                        group by InventTransRefId, InventTransId
                        where wmsOrderTrans.ShipmentId == wmsShipment.ShipmentId
                           && wmsOrderTrans.InventTransType == InventTransType::Sales
                           && wmsOrderTrans.ExpeditionStatus == WMSExpeditionStatus::Complete
                join inventDim
                    group by InventOwnerId_RU
                    where inventDim.InventDimId == wmsOrderTrans.InventDimId
                {
                    localSalesLine = SalesLine::findInventTransId(wmsOrderTrans.InventTransId);

                    if (!localSalesLine.Blocked)
                    {
                        postingProfile = this.postingProfile_RU(localSalesLine.PostingProfile_RU, localSalesLine.salesTable().PostingProfile);
                        inventProfileType = this.inventProfileType_RU(localSalesLine);

                        if (previousSalesId != localSalesLine.SalesId ||
                            previousPostingProfile != postingProfile ||
                            previousInventProfileType != inventProfileType ||
                            previousInventOwnerId != inventDim.InventOwnerId_RU)
                        {
                            tableRefId = this.getTableRefId(localSalesLine, false);
                        }

                        if (this.createParmLineFromWMSOrderTrans(localSalesLine, wmsOrderTrans.Qty, tableRefId, inventDim.InventOwnerId_RU))
                        {
                            if (previousSalesId != localSalesLine.SalesId ||
                                previousPostingProfile != postingProfile ||
                                previousInventProfileType != inventProfileType ||
                                previousInventOwnerId != inventDim.InventOwnerId_RU)
                            {
                                previousSalesId = localSalesLine.SalesId;
                                previousPostingProfile = postingProfile;
                                previousInventProfileType = inventProfileType;
                                previousInventOwnerId = inventDim.InventOwnerId_RU;

                                this.createParmTable(SalesTable::find(localSalesLine.SalesId),
                                    localSalesLine,
                                    tableRefId,
                                    false,
                                    previousPostingProfile,
                                    previousInventProfileType,
                                    previousInventOwnerId);
                            }
                        }
                    }
                }
            }
            else
            {
                // </GEERU>
                while select InventTransId, sum(Qty) from wmsOrderTrans
                        group by InventTransRefId, InventTransId // ensure order by InventTransRefId and group by inventTransId
                        where wmsOrderTrans.ShipmentId == wmsShipment.ShipmentId
                           && wmsOrderTrans.InventTransType == InventTransType::Sales
                           && wmsOrderTrans.ExpeditionStatus == WMSExpeditionStatus::Complete
                {
                    localSalesLine = SalesLine::findInventTransId(wmsOrderTrans.InventTransId);

                    if (! localSalesLine.Blocked)
                    {
                        if (previousSalesId != localSalesLine.SalesId)
                        {
                            tableRefId = this.getTableRefId(localSalesLine, false);
                        }

                        if (this.createParmLineFromWMSOrderTrans(localSalesLine, wmsOrderTrans.Qty, tableRefId))
                        {
                            if (previousSalesId != localSalesLine.SalesId)
                            {
                                previousSalesId = localSalesLine.SalesId;
                                this.createParmTable(SalesTable::find(localSalesLine.SalesId), localSalesLine, tableRefId);
                            }
                        }
                    }
                }
                // <GEERU>
            }
            // </GEERU>
        }
        this.insertRecordLists();
        this.reArrange();
        this.updateAllSalesShippingStat();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesNext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls next on the <c>ChooseLines</c> query.
    /// </summary>
    /// <returns>
    /// true if a record was selected; otherwise, false.
    /// </returns>
    protected boolean chooseLinesNext()
    {
        boolean ret = super();

        // <GEERU>
        if (countryRegion_RU && this.splitInventOwnerId_RU())
        {
            chooseLineInventTrans = chooseLines.get(tableNum(InventTrans));
        }
        // </GEERU>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>chooseLinesPackingSlip</Name>
				<Source><![CDATA[
    protected void chooseLinesPackingSlip(boolean _append = true)
    {
        CustPackingSlipTrans custPackingSlipTrans;
        CustPackingSlipJour custPackingSlipJour;

        SalesLine localSalesLine;
        SalesTable localSalesTable;

        SalesParmTable localSalesParmTable;
        SalesParmLine localSalesParmLine;

        boolean mayJournalBePosted = false;
        List list = new List(Types::Record);

        Map packingSlipJourLines = new Map(Types::Int64, Types::Container);
        Map packingSlipLineSalesLine = new Map(Types::Int64, Types::Record);
        // <GEERU>
        Map emptyHeaders;
        // </GEERU>
        Map headers = new Map(Types::String, Types::String);
        // <GIN>
        Map emptyLines = new Map(Types::String, Types::Record);
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>

        // <GEEU>
        #EECountryRegionCodes
        // </GEEU>

        // <GEERU>
        InventOwnerId_RU inventOwnerId;
        List inventOwnerIdList;
        ListEnumerator inventOwnerIdEnumerator;

        void createEmptyHeaders_RU()
        {
            inventOwnerIdList = this.getSplitInventOwnerIdList_RU(localSalesLine);
            inventOwnerIdEnumerator = inventOwnerIdList.getEnumerator();
            while (inventOwnerIdEnumerator.moveNext())
            {
                inventOwnerId = inventOwnerIdEnumerator.current();
                if (! headers.exists(this.parmTableMapKey(localSalesLine, inventOwnerId)))
                {
                    emptyHeaders.insert(this.parmTableMapKey(localSalesLine, inventOwnerId), [localSalesTable, inventOwnerId]);
                }
            }
        }

        if (countryRegion_RU)
        {
            parmLineMap = new Map(Types::String, Types::Record);
            emptyHeaders = new Map(Types::String, Types::Container);
        }
        else
        {
            emptyHeaders = new Map(Types::String, Types::Record);
        }
        // </GEERU>

        if (_append)
        {
            while select localSalesParmTable
                where localSalesParmTable.ParmId == salesParmUpdate.ParmId
                join localSalesTable
                    where localSalesTable.SalesId == localSalesParmTable.SalesId
                notexists join localSalesParmLine
                    where localSalesParmLine.TableRefId == localSalesParmTable.TableRefId
                        && localSalesParmLine.ParmId == localSalesParmTable.ParmId
            {
                // <GEERU>
                if (countryRegion_RU)
                {
                    emptyHeaders.insert(this.parmTableMapKey(localSalesParmTable), [localSalesTable, '']);
                }
                else
                {
                    // </GEERU>
                    emptyHeaders.insert(this.parmTableMapKey(localSalesParmTable), localSalesTable);
                    // <GEERU>
                }
                // </GEERU>
            }
        }

        ttsbegin;
        this.allowCreateParmTable(this.parmAllowEmptyParmTable());
        chooseLines.reset(); // if the select button is used from saleseditlines
        RecId prevPackingSlipJourRecId = 0;

        while (chooseLines.next())
        {
            // <GEERU>
            if (countryRegion_RU && this.splitInventOwnerId_RU())
            {
                chooseLineInventTrans = chooseLines.get(tableNum(InventTrans));
            }
            // </GEERU>

            if (chooseLines.changed(tablenum(SalesTable)))
            {
                localSalesTable = chooseLines.get(tablenum(SalesTable));
                mayJournalBePosted = this.mayJournalBePosted(localSalesTable);
            }

            if (! mayJournalBePosted)
            {
                continue;
            }

            if (chooseLines.changed(tablenum(SalesLine)))
            {
                localSalesLine = chooseLines.get(tablenum(SalesLine));
            }

            this.updateTaxIdDuringCreatingParmLinesAndTable();

            // <GEERU>
            if (countryRegion_RU && this.splitInventOwnerId_RU())
            {
                inventOwnerId = this.inventOwnerId_RU(localSalesLine);

                if (skipLineCreate)
                {
                    continue;
                }
                else
                {
                    parmLineMap.insert(this.parmLineMapKeyPackingSlip(localSalesLine, inventOwnerId, chooseLineInventTrans.PackingSlipId), null);
                }

                select firstonly custPackingSlipTrans
                    where custPackingSlipTrans.InventTransId == localSalesLine.InventTransId
                       && custPackingSlipTrans.PackingSlipId == chooseLineInventTrans.PackingSlipId;
            }
            else
            {
                // </GEERU>
                custPackingSlipTrans = chooseLines.get(tableNum(CustPackingSlipTrans));
                // <GEERU>
            }
            // </GEERU>

            if (this.canInsertPackingSlipSalesLine(custPackingSlipTrans, localSalesLine))
            {
                if (custPackingSlipJour.PackingSlipId != custPackingSlipTrans.PackingSlipId
                    || custPackingSlipJour.SalesId != custPackingSlipTrans.SalesId
                    || custPackingSlipJour.DeliveryDate != custPackingSlipTrans.DeliveryDate)
                {
                    // select PackingSlipJour only if necessary
                    select firstonly RecId, PackingSlipId, SalesId, DeliveryDate from custPackingSlipJour
                        where custPackingSlipTrans.PackingSlipId == custPackingSlipJour.PackingSlipId
                           && custPackingSlipTrans.SalesId == custPackingSlipJour.SalesId
                           && custPackingSlipTrans.DeliveryDate == custPackingSlipJour.DeliveryDate;
                }

                if (prevPackingSlipJourRecId == custPackingSlipJour.RecId)
                {
                    packingSlipLineSalesLine.insert(custPackingSlipTrans.RecId, localSalesLine);
                }
                else
                {
                    if (prevPackingSlipJourRecId != 0)
                    {
                        packingSlipJourLines.insert(prevPackingSlipJourRecId, packingSlipLineSalesLine.pack());
                    }

                    if (packingSlipJourLines.exists(custPackingSlipJour.RecId))
                    {
                        packingSlipLineSalesLine = Map::create(packingSlipJourLines.lookup(custPackingSlipJour.RecId));
                    }
                    else
                    {
                        packingSlipLineSalesLine = new Map(Types::Int64, Types::Record);
                    }

                    packingSlipLineSalesLine.insert(custPackingSlipTrans.RecId, localSalesLine);
                    prevPackingSlipJourRecId = custPackingSlipJour.RecId;
                }

                if (emptyHeaders.exists(this.parmTableMapKey(localSalesLine)))
                {
                    emptyHeaders.remove(this.parmTableMapKey(localSalesLine));
                }
                headers.insert(this.parmTableMapKey(localSalesLine),'');
                // <GEERU>
                if (countryRegion_RU)
                {
                    createEmptyHeaders_RU();
                }
                // </GEERU>
            }
            else if (!this.checkHeaderExist(headers, localSalesLine))
            {
                this.updateTableSplit(localSalesTable, localSalesLine);
                // <GEERU>
                if (countryRegion_RU)
                {
                    emptyHeaders.insert(this.parmTableMapKey(localSalesLine), [localSalesTable, inventOwnerId]);
                    createEmptyHeaders_RU();
                }
                else
                {
                    // </GEERU>
                    emptyHeaders.insert(this.parmTableMapKey(localSalesLine), localSalesTable);
                    // <GEERU>
                }
                // </GEERU>
                // <GIN>
                if (taxesMarked)
                {
                    emptyLines.insert(this.parmTableMapKey(localSalesLine), localSalesLine);
                }
                // </GIN>
            }
        }

        packingSlipJourLines.insert(prevPackingSlipJourRecId,packingSlipLineSalesLine.pack());

        // <GIN>
        if (countryRegion_IN
             && taxesMarked)
        {
            this.createBasedOnPackingSlip(packingSlipJourLines, emptyHeaders, emptyLines);
        }
        else
        {
            // </GIN>
            this.createBasedOnPackingSlip(packingSlipJourLines, emptyHeaders);
            // <GIN>
        }
        // </GIN>

        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            this.initDates_W(null);
        }
        // </GEEU>

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHeaderExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the sales order line exists in the map.
    /// </summary>
    /// <param name = "_headers">
    /// The map instance.
    /// </param>
    /// <param name = "_salesLine">
    /// A table buffer that contains the <c>SalesLine</c> record.
    /// </param>
    /// <returns>
    /// true if the sales order line exists in the map; otherwise, false.
    /// </returns>
    protected boolean checkHeaderExist(Map _headers, SalesLine _salesLine)
    {
        return _headers.exists(this.parmTableMapKey(_salesLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInsertPackingSlipSalesLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>CustPackingSlipTrans</c> record can be inserted.
    /// </summary>
    /// <param name = "_custPackingSlipTrans">An instance of the <c>CustPackingSlipTrans</c> record.</param>
    /// <param name = "_salesLine">An instance of the <c>SalesLine</c> record.</param>
    /// <returns>true if the packing slip line can be inserted; otherwise, false.</returns>
    protected boolean canInsertPackingSlipSalesLine(CustPackingSlipTrans _custPackingSlipTrans, SalesLine _salesLine)
    {
        return _custPackingSlipTrans && (!_salesLine || this.mayJournalTransBePosted(_salesLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createBasedOnPackingSlip</Name>
				<Source><![CDATA[
    protected void createBasedOnPackingSlip(Map _packingSlipJourLines,
                                            Map _emptyHeaders = null
                                            , Map _emptyLines = null
                                            )
    {
        CustPackingSlipTrans prevCustPackingSlipTrans;
        CustPackingSlipJour custPackingSlipJour;
        int64 custPackingSlipTransRecid, custPackingSlipJourRecid;

        TradeLineRefId tableRefId;

        SalesTable prevSalesTable;
        Set set = new Set(Types::Record);
        SalesParmSubId subId;

        MapEnumerator me, me_lines;
        // <GIN>
        MapEnumerator me_loc;
        SalesLine prevSalesLine;
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>
        SalesParmSubTable localSalesParmSubTable;

        SalesId prevsalesId;
        SalesParmTable localSalesParmTable;

        // <GEERU>
        InventOwnerId_RU prevInventOwnerId;
        // </GEERU>
                
        SalesFormletterParmDataCreateSalesParmTableArgs salesFormletterParmDataCreateSalesParmTableArgs = 
            SalesFormletterParmDataCreateSalesParmTableArgs::construct();        
        this.intercompanySalesAtCostPriceHandler().onSalesLinesSelectionStarted();

        this.initRecordLists();

        tableRefId = this.getTableRefId(null, false);

        subId = newguid();
        me = _packingSlipJourLines.getEnumerator();
        while (me.moveNext())
        {
            me_lines = Map::create(me.currentValue()).getEnumerator();
            custPackingSlipJourRecid = me.currentKey();
            custPackingSlipJour = CustPackingSlipJour::findRecId(custPackingSlipJourRecid);

            while (me_lines.moveNext())
            {
                custPackingSlipTransRecid = me_lines.currentKey();
                CustPackingSlipTrans custPackingSlipTrans = CustPackingSlipTrans::findRecId(custPackingSlipTransRecid);
                // <GEERU>
                if (countryRegion_RU && this.splitInventOwnerId_RU())
                {
                    List inventOwnerIdList = this.getSplitInventOwnerIdList_RU(me_lines.currentValue());
                    ListEnumerator inventOwnerIdEnumerator = inventOwnerIdList.getEnumerator();
                    while (inventOwnerIdEnumerator.moveNext())
                    {
                        prevInventOwnerId = inventOwnerIdEnumerator.current();

                        if (prevsalesId != custPackingSlipTrans.OrigSalesId)
                        {
                            if (prevsalesId) // skip first line
                            {
                                prevSalesTable = SalesTable::find(prevsalesId);
                                this.updateTableSplit(prevSalesTable, prevCustPackingSlipTrans);
                                this.runCreateSalesParmTableArgs(salesFormletterParmDataCreateSalesParmTableArgs, localSalesParmTable,
                                    localSalesParmSubTable, tableRefId, prevSalesTable, prevSalesLine, subId, prevInventOwnerId, custPackingSlipJour);
                                tableRefId = this.createSalesParmTable(salesFormletterParmDataCreateSalesParmTableArgs);
                                subId = newGuid();
                            }
                            prevsalesId = custPackingSlipTrans.OrigSalesId;
                        }
                        set = new Set(Types::Record);
                        set.add(custPackingSlipTrans);
                        this.createParmLineAndSubLines(me_lines.currentValue(), set.pack(), tableRefId, subId, prevInventOwnerId);
                    }
                    continue;
                }
                // </GEERU>

                if (prevsalesId != custPackingSlipTrans.OrigSalesId)
                {
                    if (prevsalesId)
                    {
                        prevSalesTable = SalesTable::find(prevsalesId);
                        this.updateTableSplit(prevSalesTable, prevCustPackingSlipTrans);
                        this.runCreateSalesParmTableArgs(salesFormletterParmDataCreateSalesParmTableArgs, localSalesParmTable,
                            localSalesParmSubTable, tableRefId, prevSalesTable, prevSalesLine, subId, prevInventOwnerId, custPackingSlipJour);
                        tableRefId = this.createSalesParmTable(salesFormletterParmDataCreateSalesParmTableArgs);
                    }
                    prevsalesId = custPackingSlipTrans.OrigSalesId;
                }
                set = new Set(Types::Record);
                set.add(custPackingSlipTrans);
                this.createParmLineAndSubLines(me_lines.currentValue(), set.pack(), tableRefId, subId);
                prevCustPackingSlipTrans = custPackingSlipTrans.data();
            }
            prevSalesTable = SalesTable::find(prevsalesId);
            this.updateTableSplit(prevSalesTable, prevCustPackingSlipTrans);
            this.runCreateSalesParmTableArgs(salesFormletterParmDataCreateSalesParmTableArgs, localSalesParmTable,
                    localSalesParmSubTable, tableRefId, prevSalesTable, prevSalesLine, subId, prevInventOwnerId, custPackingSlipJour);
            tableRefId = this.createSalesParmTable(salesFormletterParmDataCreateSalesParmTableArgs);
            subId = newguid();
            prevsalesId = '';
        }

        this.intercompanySalesAtCostPriceHandler().onSalesLinesSelectionFinished();
        this.insertRecordLists();

        AccountOrder accountOrder = salesParmUpdate.SumBy;
        salesParmUpdate.SumBy = AccountOrder::None;

        if (!(this.parmIsInBatch() && this.parmUsePackedMapInChooseLinesQuery() && this.useLateSelectionQuery()))
        {
            allowTaxRegulation = true;

            this.reArrange();

            allowTaxRegulation = false;
        }

        salesParmUpdate.SumBy = accountOrder;

        if (_emptyHeaders)
        {
            tableRefId = this.getTableRefId(null, false);
            localSalesParmTable = null;
            this.initRecordLists();

            custPackingSlipJour = null;
            me = _emptyHeaders.getEnumerator();
            // <GIN>
            if (countryRegion_IN
                 && taxesMarked)
            {
                me_loc = _emptyLines.getEnumerator();
            }
            // </GIN>
            while (me.moveNext())
            {
                // <GEERU>
                if (countryRegion_RU)
                {
                    [prevSalesTable, prevInventOwnerId] = me.currentValue();
                }
                else
                {
                    // </GEERU>
                    prevSalesTable = me.currentValue();
                    // <GEERU>
                }
                // </GEERU>
                // <GIN>
                if (countryRegion_IN
                     && taxesMarked)
                {
                    me_loc.moveNext();
                    prevSalesLine = me_loc.currentValue();
                }
                // </GIN>
                this.runCreateSalesParmTableArgs(salesFormletterParmDataCreateSalesParmTableArgs, localSalesParmTable, 
                    localSalesParmSubTable, tableRefId, prevSalesTable, prevSalesLine, subId, prevInventOwnerId, custPackingSlipJour);
                tableRefId = this.createSalesParmTable(salesFormletterParmDataCreateSalesParmTableArgs);
            }
            this.insertRecordLists();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runCreateSalesParmTableArgs</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Pass parameters to parm methods of <c>SalesFormletterParmDataCreateSalesParmTableArgs</c> class.
    /// </summary>
    /// <param name = "_salesFormletterParmDataCreateSalesParmTableArgs">
    ///     An instance of the <c>SalesFormletterParmDataCreateSalesParmTableArgs</c> class.
    /// </param>
    /// <param name = "_localSalesParmTable">
    ///     Sales table header posting buffer.
    /// </param>
    /// <param name = "_localSalesParmSubTable">
    ///     Sales order header update table buffer.
    /// </param>
    /// <param name = "_tableRefId">
    ///     Table line reference id.
    /// </param>
    /// <param name = "_prevSalesTable">
    ///     Sales table buffer.
    /// </param>
    /// <param name = "_prevSalesLine">
    ///     Sales line buffer.
    /// </param>
    /// <param name = "_subId">
    ///     A GUID.
    /// </param>
    /// <param name = "_prevInventOwnerId">
    ///     Previous owner id.
    /// </param>
    /// <param name = "_custPackingSlipJour">
    ///     Packing slip header table buffer.
    /// </param>

    private void runCreateSalesParmTableArgs(
        SalesFormletterParmDataCreateSalesParmTableArgs salesFormletterParmDataCreateSalesParmTableArgs,
        SalesParmTable _localSalesParmTable,
        SalesParmSubTable _localSalesParmSubTable,
        TradeLineRefId _tableRefId,
        SalesTable _prevSalesTable,
        SalesLine _prevSalesLine,
        SalesParmSubId _subId,
        InventOwnerId_RU _prevInventOwnerId,
        CustPackingSlipJour _custPackingSlipJour)
    {
        salesFormletterParmDataCreateSalesParmTableArgs.parmSalesParmTable(_localSalesParmTable);
        salesFormletterParmDataCreateSalesParmTableArgs.parmSalesParmSubTable(_localSalesParmSubTable);
        salesFormletterParmDataCreateSalesParmTableArgs.parmTradeLineRefId(_tableRefId);
        salesFormletterParmDataCreateSalesParmTableArgs.parmSalesTable(_prevSalesTable);
        salesFormletterParmDataCreateSalesParmTableArgs.parmSalesLine(_prevSalesLine);
        salesFormletterParmDataCreateSalesParmTableArgs.parmSalesParmSubId(_subId);
        salesFormletterParmDataCreateSalesParmTableArgs.parmInventOwnerId_RU(_prevInventOwnerId);
        salesFormletterParmDataCreateSalesParmTableArgs.parmCustPackingSlipJour(_custPackingSlipJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesParmTable</Name>
				<Source><![CDATA[
/// <summary>
///     To create sales table records.
/// </summary>
/// <param name = "_salesFormletterParmDataCreateSalesParmTableArgs">
///     An instance of the <c>SalesFormletterParmDataCreateSalesParmTableArgs</c> class.
/// </param>
/// <returns>
///     Table line reference id.
/// </returns>
    [Wrappable(true)]
    protected final TradeLineRefId createSalesParmTable(SalesFormletterParmDataCreateSalesParmTableArgs _salesFormletterParmDataCreateSalesParmTableArgs)
    {      
        TradeLineRefId tableRefId = _salesFormletterParmDataCreateSalesParmTableArgs.parmTradeLineRefId();        
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        if (this.allowCreateParmTable())
        {
            SalesParmTable localSalesParmTable = _salesFormletterParmDataCreateSalesParmTableArgs.parmSalesParmTable();
            SalesParmSubTable localSalesParmSubTable = _salesFormletterParmDataCreateSalesParmTableArgs.parmSalesParmSubTable();
            SalesTable prevSalesTable = _salesFormletterParmDataCreateSalesParmTableArgs.parmSalesTable();
            SalesLine prevSalesLine = _salesFormletterParmDataCreateSalesParmTableArgs.parmSalesLine();
            SalesParmSubId subId = _salesFormletterParmDataCreateSalesParmTableArgs.parmSalesParmSubId();
            InventOwnerId_RU prevInventOwnerId = _salesFormletterParmDataCreateSalesParmTableArgs.parmInventOwnerId_RU();
            CustPackingSlipJour custPackingSlipJour = _salesFormletterParmDataCreateSalesParmTableArgs.parmCustPackingSlipJour();

            if (localSalesParmTable.TableRefId != tableRefId)
            {
                // <GEERU>
                if (countryRegion_RU)
                {
                    localSalesParmTable = this.createParmTable(prevSalesTable,
                            null,
                            tableRefId,
                            true,
                            prevSalesTable.PostingProfile,
                            prevSalesTable.salesTable_RU().InventProfileType_RU,
                            prevInventOwnerId);
                }
                else
                    // </GEERU>
                    // <GIN>
                    if (countryRegion_IN
                         && prevSalesLine)
                {
                    localSalesParmTable = this.createParmTable(prevSalesTable, prevSalesLine, tableRefId, true);
                }
                else
                {
                    // </GIN>
                    localSalesParmTable = this.createParmTable(prevSalesTable, null, tableRefId, true);
                    // <GIN>
                }
                // </GIN>

                localSalesParmSubTable = SalesParmSubTable::createFromSalesParmTable(localSalesParmTable,false);

                if (custPackingSlipJour.RecId)
                {
                    localSalesParmSubTable.initFromCustPackingSlipJour(custPackingSlipJour);
                    localSalesParmSubTable.SubId = subId;
                }
                this.insertParmSubTable(localSalesParmSubTable);
            }
            else
            {
                if (custPackingSlipJour.RecId)
                {
                    select firstonly forupdate localSalesParmSubTable
                            where localSalesParmSubTable.ParmId == localSalesParmTable.ParmId
                               && localSalesParmSubTable.TableRefId == localSalesParmTable.TableRefId;

                    localSalesParmSubTable.initFromCustPackingSlipJour(custPackingSlipJour);
                    localSalesParmSubTable.SubId = subId;
                    localSalesParmSubTable.update();
                }
            }

            this.allowCreateParmTable(this.parmAllowEmptyParmTable());

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                packingSlipParmRefIdMap_BR.insert(custPackingSlipJour.RecId, subId);
            }
            // </GBR>

            tableRefId = this.getTableRefId(null, false);
        }
        return tableRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the data for the posting to be based on.
    /// </summary>
    /// <param name="_append">
    /// A Boolean value that indicates whether to append records or delete existing records first; optional.
    /// </param>
    public void createData(boolean _append = false)
    {
        if (this.parmDeleteGiro())
        {
            this.deleteGiro();
        }

        super(_append);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFromHistoryParmLines</Name>
				<Source><![CDATA[
    protected void createFromHistoryParmLines(Common _parmTable)
    {
        //don't call super as salesParmLines are handled in this method.
        SalesParmTable parmTable = _parmTable as SalesParmTable;
        SalesParmLine salesParmLine;
        SalesParmLine salesParmLineNew;
        SalesParmSubLine salesParmSubLine;
        RecId prevRecId;

        while select salesParmLine
            where salesParmLine.ParmId == parmTable.ParmId
               && salesParmLine.TableRefId == parmTable.TableRefId
                  outer join salesParmSubLine
                    where salesParmSubLine.LineRefRecId == salesParmLine.RecId
        {
            if (prevRecId != salesParmLine.RecId)
            {
                prevRecId = salesParmLine.RecId;
                salesParmLineNew = salesParmLine.data();
                salesParmLineNew.ParmId = this.parmId();
                this.insertParmLine(salesParmLineNew);
            }
            if (salesParmSubLine.RecId)
            {
                SalesParmSubLine salesParmSubLineNew = salesParmSubLine.data();
                salesParmSubLineNew.initFromSalesParmLine(salesParmLineNew);
                this.insertParmSubLine(salesParmSubLineNew);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLineAndSubLines</Name>
				<Source><![CDATA[
    protected void createParmLineAndSubLines(SalesLine _salesLine,
                                             container _packedSubLinesList,
                                             TradeLineRefId _tableRefId,
                                             SalesParmSubId _subId
                                             , InventOwnerId_RU _inventOwnerId = ''
                                             )
    {
        SalesParmLine salesParmLine;
        CustPackingSlipTrans custPackingSlipTrans;
        SalesQty salesQty;
        InventQty inventQty;
        PdsCWInventQty cwQty;
        Set subLineSet = new Set(Types::Record);
        // <GEERU>
        InventDim inventDim;
        InventDimParm inventDimParm;
        // </GEERU>

        newPostingSalesQty = 0;
        newPostingInventQty = 0;
        newPostingCWQty = 0;
        // <GEERU>
        if (countryRegion_RU)
        {
            if (SalesFormLetter::useInventOwnerIdRange_RU(this.splitInventOwnerId_RU(),
                                                          this.parmDocumentStatus(),
                                                          _salesLine))
            {
                inventDim.InventOwnerId_RU = _inventOwnerId;
                inventDimParm.InventOwnerIdFlag_RU = NoYes::Yes;
            }
        }
        // </GEERU>

        if (_salesLine.RecId)
        {
            SetEnumerator se = Set::create(_packedSubLinesList).getEnumerator();

            while (se.moveNext())
            {
                custPackingSlipTrans = se.current();
                // <GEERU>
                if (countryRegion_RU)
                {
                    custPackingSlipTrans.Qty = custPackingSlipTrans.remainSalesFinancial_RU(inventDim, inventDimParm);
                    custPackingSlipTrans.InventQty = custPackingSlipTrans.remainInventFinancial_RU(inventDim, inventDimParm);
                }
                else
                {
                    // </GEERU>
                    custPackingSlipTrans.Qty = custPackingSlipTrans.remainSalesFinancial();
                    custPackingSlipTrans.InventQty = custPackingSlipTrans.remainInventFinancial();
                    // <GEERU>
                }
                // </GEERU>
                subLineSet.add(custPackingSlipTrans);

                inventQty += custPackingSlipTrans.InventQty;
                salesQty += custPackingSlipTrans.Qty;
                cwQty += custPackingSlipTrans.PdsCWQty;
            }

            newPostingSalesQty = salesQty;
            newPostingInventQty = inventQty;
            newPostingCWQty = cwQty;

            // <GEERU>
            if (countryRegion_RU)
            {
                if (this.createParmLine(_salesLine, _tableRefId, _inventOwnerId))
                {
                    if (parmLineMap.exists(this.parmLineMapKey(_salesLine, _inventOwnerId)))
                    {
                        salesParmLine = parmLineMap.lookup(this.parmLineMapKey(_salesLine, _inventOwnerId));

                        se = subLineSet.getEnumerator();
                        while (se.moveNext())
                        {
                            custPackingSlipTrans = se.current();
                            this.createParmSubLine(salesParmLine, custPackingSlipTrans, _subId);
                        }
                    }
                }
            }
            else
            {
                // </GEERU>
                if (this.createParmLine(_salesLine, _tableRefId))
                {
                    if (parmLineMap.exists(this.parmLineMapKey(_salesLine)))
                    {
                        salesParmLine = parmLineMap.lookup(this.parmLineMapKey(_salesLine));

                        se = subLineSet.getEnumerator();
                        while (se.moveNext())
                        {
                            custPackingSlipTrans = se.current();
                            this.createParmSubLine(salesParmLine, custPackingSlipTrans, _subId);
                        }
                    }
                }
                // <GEERU>
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLineFromWMSOrderTrans</Name>
				<Source><![CDATA[
    protected boolean createParmLineFromWMSOrderTrans(SalesLine _salesLine,
                                                      InventQty _qty2Invoice,
                                                      TradeLineRefId _tableRef
                                                      , InventOwnerId_RU _inventOwnerId = ''
    )
    {
        boolean ret = false;
        SalesParmLine localSalesParmLine;
        InventQty qtyDelivered = _salesLine.RemainInventFinancial;
        // <GEERU>
        InventDimParm inventDimParm;
        InventDim inventDimCriteria;
        // </GEERU>

        // <GEERU>
        if (countryRegion_RU)
        {
            if (SalesFormLetter::useInventOwnerIdRange_RU(this.splitInventOwnerId_RU(),
                                                          this.parmDocumentStatus(),
                                                          _salesLine))
            {
                inventDimCriteria.InventOwnerId_RU = _inventOwnerId;
                inventDimParm.InventOwnerIdFlag_RU = NoYes::Yes;
            }
            salesQuantity.parmInventDimCriteria_RU(inventDimCriteria);
            salesQuantity.parmInventDimParm_RU(inventDimParm);
            qtyDelivered = _salesLine.remainInventFinancial_RU(inventDimCriteria, inventDimParm);
            localSalesParmLine.InventOwnerId_RU = _inventOwnerId;
        }
        // </GEERU>
        if (qtyDelivered > _qty2Invoice)
        {
            qtyDelivered = _qty2Invoice;
        }

        if (qtyDelivered == 0)
        {
            return false;
        }

        _salesLine.InventDeliverNow = qtyDelivered;
        _salesLine.SalesDeliverNow = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_salesLine.ItemId,
                                                                                                           _salesLine.InventDimId,
                                                                                                           _salesLine.InventDeliverNow,
                                                                                                           _salesLine.inventTable().inventUnitId(),
                                                                                                           _salesLine.SalesUnit,
                                                                                                           NoYes::Yes);
        if (_salesLine.RecId)
        {
            this.interCompanyUpdateSalesPrice(_salesLine);

            localSalesParmLine.clear();
            localSalesParmLine.TableRefId = _tableRef;

            [localSalesParmLine.DeliverNow, localSalesParmLine.RemainBefore , localSalesParmLine.RemainAfter ] = this.qtySales (_salesLine, naReal());
            [localSalesParmLine.InventNow, localSalesParmLine.RemainBeforeInvent, localSalesParmLine.RemainAfterInvent] = this.qtyInvent(_salesLine, naReal());

            if (localSalesParmLine.DeliverNow || (localSalesParmLine.RemainBefore))
            {
                localSalesParmLine.ParmId = salesParmUpdate.ParmId;
                localSalesParmLine.initFromSalesLine(_salesLine);

                localSalesParmLine.setQty(DocumentStatus::Invoice, salesParmUpdate.CreditRemaining);
                localSalesParmLine.setInventDeliverNow();
                localSalesParmLine.setLineAmount(_salesLine);
                localSalesParmLine.calcPackingUnitQty();
                this.insertParmLine(localSalesParmLine);
                this.allowCreateParmTable(true);
                ret = true;
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmSubLine</Name>
				<Source><![CDATA[
    protected void createParmSubLine(SalesParmLine _salesParmLine,
                                     CustPackingSlipTrans _custPackingSlipTrans,
                                     SalesParmSubId _subId)
    {
        SalesParmSubLine localSalesParmSubLine;

        localSalesParmSubLine.clear();
        localSalesParmSubLine.initFromSalesParmLine(_salesParmLine);
        localSalesParmSubLine.initFromCustPackingSlipTrans(_custPackingSlipTrans);
        localSalesParmSubLine.SubId = _subId;
        this.insertParmSubLine(localSalesParmSubLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmTable</Name>
				<Source><![CDATA[
    protected Common createParmTable(Common _salesTable,
                                     Common _salesLine,
                                     TradeLineRefId _tableRefId,
                                     boolean _skipParmSubTable = false,
                                     CustPostingProfile _postingProfile = '',
                                     InventProfileType_RU _inventProfileType = InventProfileType_RU::General,
                                     InventOwnerId_RU _inventOwnerId = '',

                                     MCRPackingBoxName _mcrPackingBoxName = '')
    {
        SalesTable localSalesTable = _salesTable as SalesTable;
        // <GEERU>
        SalesLine localSalesLine = _salesLine as SalesLine;
        // </GEERU>

        // <GEEU>
        SalesParmTable salesParmTable;
        // </GEEU>

        if (localSalesTable.GiroType != giroType)
        {
            this.parmGiroAllSame(false);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            salesParmTable = super(_salesTable,
                         _salesLine,
                         _tableRefId,
                         _skipParmSubTable,
                         prmisDefault(_postingProfile) ?
                         this.postingProfile_RU(localSalesLine.PostingProfile_RU, localSalesTable.PostingProfile) :
                         _postingProfile,
                         prmisDefault(_inventProfileType) ?
                         this.inventProfileType_RU(localSalesLine) :
                         _inventProfileType,
                         prmisDefault(_inventOwnerId) ?
                         this.inventOwnerId_RU(localSalesLine) :
                         _inventOwnerId);
        }
        else
        {
            salesParmTable = super(_salesTable, _salesLine, _tableRefId, _skipParmSubTable);
        }
        // </GEERU>

        this.setAddressForInvoice(salesParmTable);

        // <GEEU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            if (!salesParmTable.FixedDueDate)
            {
                salesParmTable.FixedDueDate = salesParmTable.DocumentDate ? salesParmTable.DocumentDate : salesParmTable.Transdate;
                salesParmTable.FixedDueDate = PaymTerm::find(localSalesTable.Payment).due(salesParmTable.FixedDueDate, _salesTable.paymDayId());
            }

            if (localSalesTable.TaxPeriodPaymentCode_PL &&
                PlTaxDueTable::find(salesTable.TaxPeriodPaymentCode_PL).VatDateIsPaymentDate)
            {
                salesParmTable.VatDueDate_W = salesParmTable.FixedDueDate;
            }
        }
        // </GEEU>

        // <GEEU>
        return salesParmTable;
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the order posting parameter table.
    /// </summary>
    /// <returns>
    /// The inserted record.
    /// </returns>
    protected Common createParmUpdate()
    {
        if (this.parmDefaultGiroType())
        {
            salesParmUpdate.GiroType = PaymentStubInclAll::All;
        }
        else
        {
            salesParmUpdate.GiroType = this.getPaymentStubInclAllValue(salesTable.GiroType);
        }
       
        giroType = this.getPaymentStubValue(salesParmUpdate.GiroType);
        this.parmDefaultGiroType(salesParmUpdate.GiroType == PaymentStubInclAll::All);

        // <GBR>
        if (this.isPostFromLoad_BR())
        {
            salesParmUpdate = super();

            this.updateParmUpdateFromLoad_BR(salesParmUpdate);

            return salesParmUpdate;
        }
        // </GBR>

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentStubInclAllValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets enum value of <c>PaymentStubInclAll</c>.
    /// </summary>
    /// <param name = "_paymentStub">
    ///     Element value of <c>PaymentStub</c>.
    /// </param>
    /// <returns>
    ///     The enum value of <c>PaymentStubInclAll</c>.
    /// </returns>
    protected PaymentStubInclAll getPaymentStubInclAllValue(PaymentStub _paymentStub)
    {
        PaymentStubInclAll paymentStubInclAll;
        switch(_paymentStub)
        {
            Case PaymentStub::None:
                paymentStubInclAll = PaymentStubInclAll::None;
                break;

            Case PaymentStub::FIK:
                paymentStubInclAll = PaymentStubInclAll::FIK;
                break;

            Case PaymentStub::BBS:
                paymentStubInclAll = PaymentStubInclAll::BBS;
                break;

            Case PaymentStub::ESR_blue_PTT:
                paymentStubInclAll = PaymentStubInclAll::ESR_blue_PTT;
                break;

            Case PaymentStub::ESR_red_bank:
                paymentStubInclAll = PaymentStubInclAll::ESR_red_bank;
                break;

            Case PaymentStub::FIK762:
                paymentStubInclAll = PaymentStubInclAll::FIK762;
                break;

            Case PaymentStub::ESR_orange:
                paymentStubInclAll = PaymentStubInclAll::ESR_orange;
                break;

            Case PaymentStub::BelSMS101:
                paymentStubInclAll = PaymentStubInclAll::BelSMS101;
                break;

            Case PaymentStub::BelSMS102:
                paymentStubInclAll = PaymentStubInclAll::BelSMS102;
                break;

            Case PaymentStub::Finnish:
                paymentStubInclAll = PaymentStubInclAll::Finnish;
                break;

            Case PaymentStub::FIK751:
                paymentStubInclAll = PaymentStubInclAll::FIK751;
                break;

            Case PaymentStub::FIK752:
                paymentStubInclAll = PaymentStubInclAll::FIK752;
                break;
        }

        return paymentStubInclAll;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymentStubValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets enum value of <c>PaymentStub</c>.
    /// </summary>
    /// <param name = "_paymentStubInclAll">
    ///     Element value of <c>PaymentStubInclAll</c>.
    /// </param>
    /// <returns>
    ///     The enum value of <c>PaymentStub</c>.
    /// </returns>
    protected PaymentStub getPaymentStubValue(PaymentStubInclAll _paymentStubInclAll)
    {
        PaymentStub paymentStub;
        switch(_paymentStubInclAll)
        {
            Case PaymentStubInclAll::None:
                paymentStub = PaymentStub::None;
                break;

            Case PaymentStubInclAll::FIK:
                paymentStub = PaymentStub::FIK;
                break;

            Case PaymentStubInclAll::BBS:
                paymentStub = PaymentStub::BBS;
                break;

            Case PaymentStubInclAll::ESR_blue_PTT:
                paymentStub = PaymentStub::ESR_blue_PTT;
                break;

            Case PaymentStubInclAll::ESR_red_bank:
                paymentStub = PaymentStub::ESR_red_bank;
                break;

            Case PaymentStubInclAll::FIK762:
                paymentStub = PaymentStub::FIK762;
                break;

            Case PaymentStubInclAll::ESR_orange:
                paymentStub = PaymentStub::ESR_orange;
                break;

            Case PaymentStubInclAll::BelSMS101:
                paymentStub = PaymentStub::BelSMS101;
                break;

            Case PaymentStubInclAll::BelSMS102:
                paymentStub = PaymentStub::BelSMS102;
                break;

            Case PaymentStubInclAll::Finnish:
                paymentStub = PaymentStub::Finnish;
                break;

            Case PaymentStubInclAll::FIK751:
                paymentStub = PaymentStub::FIK751;
                break;

            Case PaymentStubInclAll::FIK752:
                paymentStub = PaymentStub::FIK752;
                break;
        }

        return paymentStub;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custBankAccountId</Name>
				<Source><![CDATA[
    protected CustBankAccountId custBankAccountId(SalesTable _salesTable)
    {
        if (_salesTable.DirectDebitMandate)
        {
            return CustDirectDebitMandate::find(_salesTable.DirectDebitMandate).BankAccount;
        }
        else
        {
            return _salesTable.custTable_InvoiceAccount().BankAccount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteGiro</Name>
				<Source><![CDATA[
    protected void deleteGiro()
    {
        SalesParmTable localSalesParmTable;

        ttsbegin;

        while select forupdate localSalesParmTable
            where localSalesParmTable.ParmId == salesParmUpdate.ParmId
        {
            if (localSalesParmTable.salesTable().GiroType != this.getPaymentStubValue(salesParmUpdate.GiroType) && (!this.parmDefaultGiroType()))
            {
                SalesParmLine::deleteFromSalesParmTable(localSalesParmTable);

                if (this.useShippingStat())
                {
                    SalesShippingStat::deleteFromSalesParmTable(localSalesParmTable);
                }
                localSalesParmTable.delete();
            }
        }

        ttscommit;

        this.updateQueryBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endParmLinePackingslipUpdate</Name>
				<Source><![CDATA[
    protected void endParmLinePackingslipUpdate()
    {
        SalesParmTable salesParmTable;
        SalesParmSubTable salesParmSubTable;
        SalesParmSubLine localSalesParmSubLine;
        SalesParmLine localSalesParmLine;
        // <GEERU>
        Map counter;
        InventOwnerId_RU prevInventOwnerId;
        // </GEERU>
        SalesParmLine sumParmLine;
        SalesLineRefRecId prevSalesLineRecId;
        SalesParmLineRefRecId prevLineRefRecId;
        // <GIN>
        // </GIN>

        // <GEERU>
        if (countryRegion_RU)
        {
            counter = new Map(Types::Container,Types::Record);

            if (!salesParmTableReArrange && salesParmSubTableMap)
            {
                MapEnumerator me = salesParmSubTableMap.getEnumerator();
                if (me.moveNext())
                {
                    SalesParmSubTable localSalesParmSubTable = me.currentValue();
                    salesParmTableReArrange = localSalesParmSubTable.salesParmTable();
                }
            }
        }
        else
        {
            counter = new Map(typeName2Type(extendedTypeStr(RecId)),Types::Record);
        }
        // </GEERU>
        if (salesParmUpdate.SumBy != AccountOrder::Journal)
        {
            while select count(RecId), sum(PdsCWDeliverNow), sum(DeliverNow), sum(InventNow) from localSalesParmLine
                   join salesParmTableRearrange
                    group by localSalesParmLine.SalesLineRecId
                    // <GEERU>
                    , InventOwnerId_RU
                    // </GEERU>
                    where localSalesParmLine.ParmId == salesParmUpdate.ParmId
                        && salesParmTableRearrange.ParmId == localSalesParmLine.ParmId
                        && salesParmTableRearrange.TableRefId == localSalesParmLine.TableRefId
                        && salesParmTableRearrange.ParmJobStatus == ParmJobStatus::Waiting
            {
                if (localSalesParmLine.RecId > 1)
                // <GEERU>
                {
                    if (countryRegion_RU)
                    {
                        counter.insert([localSalesParmLine.SalesLineRecId, localSalesParmLine.InventOwnerId_RU], localSalesParmLine);
                    }
                    else
                    {
                        // </GEERU>
                        counter.insert(localSalesParmLine.SalesLineRecId, localSalesParmLine);
                        // <GEERU>
                    }
                }
                // </GEERU>
            }

            if (counter.elements() > 0)
            {
                ttsbegin;
                while select forupdate localSalesParmSubLine
                    order by SalesLineRecId
                    // <GEERU>
                    , InventOwnerId_RU
                    // </GEERU>
                    where localSalesParmSubLine.ParmId == salesParmUpdate.ParmId
                    outer join forupdate localSalesParmLine
                    where localSalesParmSubLine.LineRefRecId == localSalesParmLine.RecId
                          join salesParmTableRearrange
                    where salesParmTableReArrange.ParmId == localSalesParmLine.ParmId
                        && salesParmTableReArrange.TableRefId == localSalesParmLine.TableRefId
                        && salesParmTableRearrange.ParmJobStatus == ParmJobStatus::Waiting
                {
                    // <GEERU>
                    if ( (countryRegion_RU && counter.exists([localSalesParmSubLine.SalesLineRecId, localSalesParmSubLine.InventOwnerId_RU])
                        || (!countryRegion_RU && counter.exists(localSalesParmSubLine.SalesLineRecId))))
                    // </GEERU>
                    {
                        if (prevSalesLineRecId == localSalesParmSubLine.SalesLineRecId
                            // <GEERU>
                            && ((countryRegion_RU && prevInventOwnerId == localSalesParmSubLine.InventOwnerId_RU) || !countryRegion_RU)
                            // </GEERU>
                            )
                        {
                            localSalesParmSubLine.LineRefRecId = prevLineRefRecId;
                            if (!SalesParmSubLine::exist(localSalesParmSubLine.LineRefRecId,localSalesParmSubLine.JournalRefTableId,localSalesParmSubLine.JournalRefRecId))
                            {
                                localSalesParmSubLine.doUpdate();
                            }
                            localSalesParmLine.doDelete();
                        }
                        else
                        {
                            if (localSalesParmLine)
                            {
                                // <GEERU>
                                if (countryRegion_RU)
                                {
                                    sumParmLine = counter.lookup([localSalesParmSubLine.SalesLineRecId,localSalesParmSubLine.InventOwnerId_RU]);
                                }
                                else
                                {
                                    // </GEERU>
                                    sumParmLine = counter.lookup(localSalesParmSubLine.SalesLineRecId);
                                    // <GEERU>
                                }
                                // </GEERU>
                                localSalesParmLine.PdsCWDeliverNow = sumParmLine.PdsCWDeliverNow;
                                localSalesParmLine.DeliverNow = sumParmLine.DeliverNow;
                                localSalesParmLine.InventNow = sumParmLine.InventNow;
                                localSalesParmLine.setLineAmount();
                                localSalesParmLine.calcPackingUnitQty();
                                // <GIN>
                                if (TaxParameters::checkTaxParameters_IN())
                                {
                                    this.updateAssessableValue_IN(localSalesParmLine, localSalesParmSubLine);
                                }
                                // </GIN>
                                localSalesParmLine.doUpdate();
                                // <GEEPL>
                                PlInventPackageParm::updateFromSalesParmLine(localSalesParmLine, DocumentStatus::Invoice);
                                // </GEEPL>
                                prevLineRefRecId = localSalesParmLine.RecId;
                                prevSalesLineRecId = localSalesParmSubLine.SalesLineRecId;
                                // <GEERU>
                                if (countryRegion_RU)
                                {
                                    prevInventOwnerId = localSalesParmSubLine.InventOwnerId_RU;
                                }
                                // </GEERU>
                            }
                        }
                    }
                }
                ttscommit;
            }
        }

        if (salesParmUpdate.SumBy != AccountOrder::Order)
        {
            update_recordset salesParmTable setting SalesId = salesParmSubTable.OrigSalesId
                where salesParmTable.ParmId == salesParmUpdate.ParmId
                 join salesParmSubTable
                    where salesParmSubTable.ParmId == salesParmTable.ParmId
                        && salesParmSubTable.TableRefId == salesParmTable.TableRefId
                 notexists join localSalesParmLine
                    where localSalesParmLine.ParmId == salesParmTable.ParmId
                        && localSalesParmLine.TableRefId == salesParmTable.TableRefId
                        && localSalesParmLine.OrigSalesId == salesParmTable.SalesId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findParmLine</Name>
				<Source><![CDATA[
    protected VendDocumentLineMap findParmLine(ParmId _parmId, InventTransId _inventTransId)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        Debug::assert(this.parmDocumentStatus() == DocumentStatus::Invoice);

        // If any vendInvoiceInfoLine for the given ParmId & InventTransId is closed, return that line.

        select firstonly * from vendInvoiceInfoLine where vendInvoiceInfoLine.ParmId == _parmId &&
                                                    vendInvoiceInfoLine.InventTransId == _inventTransId &&
                                                    vendInvoiceInfoLine.Closed == NoYes::Yes;
        return vendInvoiceInfoLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesQtyInventQtyFromLoad_BR</Name>
				<Source><![CDATA[
    protected container getSalesQtyInventQtyFromLoad_BR(SalesLine _salesLine)
    {
        return super(_salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventOwnerId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if an invoice should be separated for each inventory owner.
    /// </summary>
    /// <returns>
    ///    <c>NoYes::Yes</c> if a invoice should be separated for each inventory owner; otherwise, <c>NoYes::No</c>.
    /// </returns>
    protected NoYes getSplitInventOwnerId_RU()
    {
        return countryRegion_RU &&
               SalesParameters::find().SplitInventOwnerIdInvoice_RU &&
               (this.parmDocumentStatus() == DocumentStatus::Invoice ||
                this.parmDocumentStatus() == DocumentStatus::Facture_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventOwnerIdList_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the list of the inventory owners which separates the invoice.
    /// </summary>
    /// <param name="_salesLine">
    ///     A table buffer that contains the <c>SalesLine</c> record.
    /// </param>
    /// <returns>
    ///     The list of the inventory owners values.
    /// </returns>
    protected List getSplitInventOwnerIdList_RU(SalesLine _salesLine)
    {
        InventTransOrigin inventTransOrigin;
        InventTrans localInventTrans;
        InventDim inventDim;
        List inventOwnerList = new List(Types::String);
        boolean blankAdded;

        if (this.splitInventOwnerId_RU())
        {
            while select inventDim
                group by InventProfileId_RU, InventOwnerId_RU
            exists join localInventTrans
                where localInventTrans.InventDimId == inventDim.InventDimId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == localInventTrans.InventTransOrigin
                   && inventTransOrigin.InventTransId == _salesLine.InventTransId
            {
                if (inventDim.inventProfile_RU().splitDocumentByInventOwnerId(this.parmDocumentStatus()))
                {
                    inventOwnerList.addEnd(inventDim.InventOwnerId_RU);
                }
                else
                {
                    if (! blankAdded)
                    {
                        inventOwnerList.addEnd('');
                        blankAdded = true;
                    }
                }
            }

            return inventOwnerList;
        }
        else
        {
            inventOwnerList.addEnd('');
        }

        return inventOwnerList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitInventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if an invoice should be separated for each kind of activity.
    /// </summary>
    /// <returns>
    ///    <c>NoYes::Yes</c> in RU country context; otherwise, <c>NoYes::No</c>.
    /// </returns>
    protected NoYes getSplitInventProfileType_RU()
    {
        return countryRegion_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitPostingProfile_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if an invoice should be separated for each posting profile.
    /// </summary>
    /// <returns>
    ///    <c>NoYes::Yes</c> in RU country context; otherwise, <c>NoYes::No</c>.
    /// </returns>
    protected NoYes getSplitPostingProfile_RU()
    {
        return countryRegion_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init()
    {
        super();

        if (this.parmSalesFormLetterContract() is SalesFormLetterInvoiceContract)
        {
            SalesFormLetterInvoiceContract invoiceContract = salesFormLetterContract as SalesFormLetterInvoiceContract;
            this.parmAllowLineLevelTaxAdjustments(invoiceContract.parmAllowLineLevelTaxAdjustments());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmTable</Name>
				<Source><![CDATA[
    protected SalesParmTable initParmTable(SalesTable _salesTable, Common _salesLine, TradeLineRefId _tableRefId, CustPostingProfile _postingProfile, InventProfileType_RU _inventProfileType, InventOwnerId_RU _inventOwnerId, MCRPackingBoxName _mcrPackingBoxName)
    {
        SalesParmTable ret;

        ret = super(_salesTable, _salesLine, _tableRefId, _postingProfile, _inventProfileType, _inventOwnerId, _mcrPackingBoxName);

        ret.AllowLineLevelTaxAdjustments = allowLineLevelTaxAdjustments;

        if (FeatureStateProvider::isFeatureEnabled(CompanyTaxRegistrationFeature::instance()))
        {
            ret.TaxId = _salesTable.TaxId;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initChooseLines</Name>
				<Source><![CDATA[
    protected void initChooseLines()
    {
        super();

        // <GBR>
        if (this.isPostFromLoad_BR())
        {
            this.parmAllowEmptyParmTable(false);
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDates_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes dates for given <c>SalesParmTable</c> or whole update
    /// </summary>
    /// <param name="_salesParmTable">
    /// <c>SalesParmTable</c> to initialized dates for
    /// </param>
    public void initDates_W(SalesParmTable _salesParmTable)
    {
        SalesParmTable localSalesParmTable;

        if (_salesParmTable) // Editing parmTable
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(TradeDates_W)) &&
                !_salesParmTable.DocumentDate &&
                !_salesParmTable.orig().DocumentDate &&
                SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
            {
                _salesParmTable.DocumentDate = _salesParmTable.Transdate;
            }

            this.updateDates_W(_salesParmTable);
        }
        else // Creating parmTables
        {
            ttsbegin;
            while select forupdate localSalesParmTable
                where localSalesParmTable.ParmId == salesParmUpdate.ParmId &&
                      (localSalesParmTable.Ordering == DocumentStatus::Invoice ||
                      localSalesParmTable.Ordering == DocumentStatus::Facture_RU ||
                      localSalesParmTable.Ordering == DocumentStatus::FreeTextInvoice ||
                      localSalesParmTable.Ordering == DocumentStatus::ProjectInvoice)
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(TradeDates_W)) &&
                    !localSalesParmTable.DocumentDate &&
                    SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAll))
                {
                    localSalesParmTable.DocumentDate = localSalesParmTable.Transdate;
                }

                this.updateDates_W(localSalesParmTable);
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficials_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes officials for given <c>SalesParmTable</c>
    /// </summary>
    /// <param name="_salesParmTable">
    /// <c>SalesParmTable</c> to create officials for
    /// </param>
    public void initOfficials_RU(Common _salesParmTable = null)
    {
        SalesParmTable localSalesParmTable = _salesParmTable as SalesParmTable;

        if (! OfficialsServ_RU::isFeatureEnabled())
            return;

        if (! offSrv)
        {
            offSrv = new OfficialsServ_RU();
        }

        if (_salesParmTable) // Editing parmTable
        {
            this.initOffSalesParmTable_RU(localSalesParmTable, this.initOfficialsFacture_RU());
        }
        else // Creating parmTables
        {
            ttsbegin;
            while select forupdate localSalesParmTable
                where localSalesParmTable.ParmId == salesParmUpdate.ParmId &&
                      localSalesParmTable.Ordering == this.parmDocumentStatus() &&
                    ! localSalesParmTable.OffSessionId_RU
            {
                this.initOffSalesParmTable_RU(localSalesParmTable, this.initOfficialsFacture_RU());
            }
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOfficialsFacture_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether officials should be initialized for facture document.
    /// </summary>
    /// <returns>
    ///     Always returns false.
    /// </returns>
    protected boolean initOfficialsFacture_RU()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffSalesParmTable_RU</Name>
				<Source><![CDATA[
    private void initOffSalesParmTable_RU(
        SalesParmTable _localSalesParmTable,
        boolean _includeFacture)
    {
        boolean newId = true;

        if (_localSalesParmTable.OffSessionId_RU)
        {
            newId = false;
            offSrv.newId(_localSalesParmTable.OffSessionId_RU);
            _localSalesParmTable.OffSessionId_RU = "";
        }
        _localSalesParmTable.OffReportType_RU =
            offSrv.initTableSales(_localSalesParmTable,
                                  salesParmUpdate,
                                  newId,
                                  _includeFacture,
                                  invoicePrintoutType);
        if (! _localSalesParmTable.OffSessionId_RU)
        {
            _localSalesParmTable.OffSessionId_RU = offSrv.newId();
        }
        if (_localSalesParmTable.RecId && _localSalesParmTable.selectForUpdate())
        {
            _localSalesParmTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefaultCreditRemaining</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets a default value for the <c>CreditRemaining</c> field.
    /// </summary>
    protected void initParmDefaultCreditRemaining()
    {
        // <GEERU>
        //When posting goods in route order its status should be "Cancelled" at the end and remaining fields should be zero
        if (!countryRegion_RU || !goodsInRouteId)
        {
            // </GEERU>
            this.parmCreditRemaining(NoYes::Yes);
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the record list and map variables.
    /// </summary>
    protected void initRecordLists()
    {
        super();
        recordInsertParmSubLine = new RecordInsertList(tableNum(SalesParmSubLine), true, true, true);
        recordInsertParmLinePricingCalculation = new RecordInsertList(tableNum(PDSSalesParmLinePricingCalculation), true, true, true);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.postInitRecordLists_BR();
        }
        // </GBR>
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Inserts a record in the order line posting parameter table.
    /// </summary>
    /// <param name="_parmLine">
    ///    The record to insert.
    /// </param>
    protected void insertParmLine(Common _parmLine)
    {
        SalesParmLine salesParmLine = _parmLine as SalesParmLine;
        TransDate localTransDate;
        // <GIN>
        // </GIN>

        PDSSalesParmLinePricingCalculation salesParmPricingCalc;

        if (countryRegion_RU)
        {
            SalesParmTable parmTable = salesParmLine.salesParmTable();

            if (parmTable)
            {
                localTransDate = parmTable.DocumentDate ? parmTable.DocumentDate : parmTable.Transdate;
            }
            else
            {
                localTransDate = this.parmTransDate();
            }

            salesParmLine.setAlcoholLicenseSeriesNum_RU(localTransDate);
        }

        super(_parmLine);

        if (#PDSPotencyEnabled)
        {
            PDSSalesLinePricingCalculation salesPricingCalc = PDSSalesLinePricingCalculation::findBySalesLine(salesParmLine.SalesLineRecId);

            if (salesPricingCalc.PriceCalculation)
            {
                salesParmPricingCalc.SalesParmLine = salesParmLine.RecId;
                salesParmPricingCalc.PriceCalculation = salesPricingCalc.PriceCalculation;

                // Although SalesParmLine has a record ID, it is not yet saved to the database. Therefore, the method displayCalculatedLineAmount cannot be used. Set the base buffer and call the
                // price establisher directly.
                PDSPriceEstablisher priceEstablisher = PDSPriceEstablisher::construct(salesParmPricingCalc);
                priceEstablisher.parmBaseBuffer(salesParmLine);
                salesParmPricingCalc.CalculatedUnitPrice = priceEstablisher.averageAdjustedUnitPrice();

                recordInsertParmLinePricingCalculation.add(salesParmPricingCalc);
            }
        }
        // <GIN>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])  && _parmLine.TableId == tableNum(SalesParmLine))
        {
            SalesParmLine_IN salesParmLineIN = salesParmLine.salesParmLine_IN();
            salesParmLineIN.SysExtensionSerializerExtensionMap::insertAfterBaseTable(_parmLine);
            salesParmLine.packSalesParmLine_IN(salesParmLineIN);
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertParmSubLine</Name>
				<Source><![CDATA[
    protected void insertParmSubLine(SalesParmSubLine _salesParmSubLine)
    {
        recordInsertParmSubLine.add(_salesParmSubLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records in the record lists into the database.
    /// </summary>
    protected void insertRecordLists()
    {
        super();

        recordInsertParmSubLine.insertDatabase();
        recordInsertParmLinePricingCalculation.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the posting parameter line for an intercompany line.
    /// </summary>
    /// <param name="_common">
    /// A <c>SalesLine</c> record.
    /// </param>
    /// <returns>
    /// A record in the <c>VendInvoiceInfoLine</c> table.
    /// </returns>
    protected Common interCompanyParmLine(Common _common)
    {
        SalesLine localSalesLine = _common;
        SalesTable localSalesTable = localSalesLine.salesTable();
        VendInvoiceInfoLine vendInvoiceInfoLine;

        if (interCompanyCompanyId)
        {
            changecompany(interCompanyCompanyId)
            {
                select firstonly vendInvoiceInfoLine
                       where vendInvoiceInfoLine.ParmId == interCompanyParmId
                       && vendInvoiceInfoLine.OrigPurchId == localSalesTable.InterCompanyPurchId
                       && vendInvoiceInfoLine.InventTransId == localSalesLine.InterCompanyInventTransId;
            }
        }
        else
        {
            select firstonly vendInvoiceInfoLine
                   where vendInvoiceInfoLine.ParmId == interCompanyParmId
                   && vendInvoiceInfoLine.OrigPurchId == localSalesLine.InventRefId
                   && vendInvoiceInfoLine.InventTransId == localSalesLine.InventRefTransId;
        }

        return vendInvoiceInfoLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyParmLineQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the quantity for an intercompany line.
    /// </summary>
    /// <param name="_common">
    /// A <c>SalesLine</c> record.
    /// </param>
    /// <param name="_isInventQty">
    /// A <c>Boolean</c> value that indicates whether the quantity is an inventory quantity.
    /// </param>
    /// <returns>
    /// A quantity.
    /// </returns>
    protected Qty interCompanyParmLineQty(Common _common, boolean _isInventQty = false)
    {
        SalesLine salesLineLocal = _common;
        VendInvoiceTrans vendInvoiceTransLocal;
        VendInvoiceJour vendInvoiceJourLocal;

        if (interCompanyCompanyId)
        {
            changecompany(interCompanyCompanyId)
            {
                select forceplaceholders InventQty, Qty, PurchUnit from vendInvoiceTransLocal
                       where vendInvoiceTransLocal.InventTransId == salesLineLocal.InterCompanyInventTransId
                exists join vendInvoiceJourLocal
                       where vendInvoiceJourLocal.InvoiceId == vendInvoiceTransLocal.InvoiceId
                       && vendInvoiceJourLocal.InvoiceDate == vendInvoiceTransLocal.InvoiceDate
                       && vendInvoiceJourLocal.PurchId == vendInvoiceTransLocal.PurchID
                       && vendInvoiceJourLocal.InternalInvoiceId == vendInvoiceTransLocal.InternalInvoiceId
                       && vendInvoiceJourLocal.ParmId == interCompanyParmId;
            }
        }
        else
        {
            select forceplaceholders InventQty, Qty, PurchUnit from vendInvoiceTransLocal
                   where vendInvoiceTransLocal.InventTransId == salesLineLocal.InventRefTransId
            exists join vendInvoiceJourLocal
                   where vendInvoiceJourLocal.InvoiceId == vendInvoiceTransLocal.InvoiceId
                   && vendInvoiceJourLocal.InvoiceDate == vendInvoiceTransLocal.InvoiceDate
                   && vendInvoiceJourLocal.PurchId == vendInvoiceTransLocal.PurchID
                   && vendInvoiceJourLocal.InternalInvoiceId == vendInvoiceTransLocal.InternalInvoiceId
                   && vendInvoiceJourLocal.ParmId == interCompanyParmId;
        }
        return _isInventQty ? vendInvoiceTransLocal.InventQty : this.getQty(salesLineLocal, vendInvoiceTransLocal);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQty</Name>
				<Source><![CDATA[
    private Qty getQty(SalesLine _salesLineLocal, VendInvoiceTrans _vendInvoiceTransLocal)
    {
        if (SalesFormLetterInterCompanyParmLineQtyFlight::instance().isEnabled() && _salesLineLocal.SalesUnit != _vendInvoiceTransLocal.PurchUnit)
        {
            return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_salesLineLocal.ItemId,
                                                                                        _salesLineLocal.InventDimId,
                                                                                        _vendInvoiceTransLocal.Qty,
                                                                                        _vendInvoiceTransLocal.PurchUnit,
                                                                                        _salesLineLocal.SalesUnit,
                                                                                        NoYes::Yes);
        }
        else
        {
            return _vendInvoiceTransLocal.Qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyUpdateSalesPrice</Name>
				<Source><![CDATA[
    protected void interCompanyUpdateSalesPrice(SalesLine _salesLine)
    {
        this.intercompanySalesAtCostPriceHandler().onSalesLineSelected(_salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventOwnerId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the inventory owner value.
    /// </summary>
    /// <param name="_salesLine">
    ///     A table buffer that contains the <c>SalesLine</c> record.
    /// </param>
    /// <returns>
    ///     The inventory owner value.
    /// </returns>
    protected InventOwnerId_RU inventOwnerId_RU(Common _salesLine)
    {
        SalesLine salesLine = _salesLine as SalesLine;
        InventOwnerId_RU inventOwnerId = super(salesLine);

        if (this.splitInventOwnerId_RU())
        {
            if (chooseLineInventTrans.RecId)
            {
                InventDim inventDim = chooseLineInventTrans.inventDim();
                if (inventDim.inventProfile_RU().splitDocumentByInventOwnerId(this.parmDocumentStatus()))
                {
                    inventOwnerId = inventDim.InventOwnerId_RU;
                }
            }

            if (this.parmSpecQty() == SalesUpdate::PackingSlip)
            {
                skipLineCreate = parmLineMap.exists(this.parmLineMapKeyPackingSlip(salesLine, inventOwnerId, chooseLineInventTrans.PackingSlipId));
            }
            else
            {
                skipLineCreate = parmLineMap.exists(this.parmLineMapKey(salesLine, inventOwnerId));
            }
        }

        return inventOwnerId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalBePosted</Name>
				<Source><![CDATA[
    protected boolean mayJournalBePosted(Common _salesTable)
    {
        SalesTable localSalesTable = _salesTable as SalesTable;
        boolean ok = super(_salesTable);

        if (ok && !localSalesTable.canCustomerBeUpdated(documentStatus))
        {
            ok = checkFailed(strFmt("@SYS7987", localSalesTable.CustAccount));
        }

        return ok && localSalesTable.mayInvoiceBeUpdated();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayJournalTransBePosted</Name>
				<Source><![CDATA[
    protected boolean mayJournalTransBePosted(Common _salesLine)
    {
        SalesLine salesLine = _salesLine as SalesLine;

        if (salesLine.isInterCompanyOrder() && salesLine.isCategoryBased())
        {
            return false;
        }

        boolean ok = super(_salesLine);

        if (ok)
        {
            ok = salesLine.mayInvoiceBeUpdated(salesTableOrig);
        }

        if (ok)
        {
            if (!interCompanyParmId
            && salesLine.InventRefType == InventRefType::Purch
            && salesLine.InventRefId
            && salesTableOrig.InterCompanyDirectDelivery)
            {
                PurchTable purchTable = PurchTable::find(salesLine.InventRefId);
                if (purchTable.InterCompanyOrder
                && purchTable.interCompanyEndpointActionPolicy().PostSalesInvoice
                && !salesParmUpdate.Proforma)
                {
                    ok = checkFailed(strFmt("@SYS101046", salesLine.ItemId));
                }
            }

            if (salesLine.SalesType == SalesType::ReturnItem)
            {
                ok = ok && salesLine.ReturnStatus == ReturnStatusLine::Registered || salesLine.ReturnStatus == ReturnStatusLine::Received;
                ok = ok && !salesLine.isReturnReservationLine();
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrAllowCreateParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the specified sales line should be allowed to be
    ///     invoiced.
    /// </summary>
    /// <param name="_salesLine">
    ///     The <c>SalesLine</c> record for which this method checks invoicing
    ///     viability.
    /// </param>
    /// <param name="_salesTable">
    ///     The <c>SalesTable</c> record for which this method cheks invoicing
    ///     viability.
    /// </param>
    /// <returns>
    ///     true if the sales order should be allowed to be invoiced; otherwise,
    ///     false.
    /// </returns>
    /// <remarks>
    ///     Do not process continuity item lines.
    ///     Do not process continuity child orders that are not in the delivery window.
    ///     Do not process continuity childorders that have payment issues.
    /// </remarks>
    protected boolean mcrAllowCreateParmLine(SalesLine _salesLine, SalesTable _salesTable)
    {
        boolean allowCreateParmLine = true;

        allowCreateParmLine = super(_salesLine, _salesTable);

        if (MCROrderParameters::isCallCenterEnabledAndInUse())
        {
            if (allowCreateParmLine
                && !this.mcrAllowCreateCheck(_salesLine, _salesTable))
            {
                allowCreateParmLine = false;
            }
        }

        return allowCreateParmLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdvanceInvoiceSettlement_W</Name>
				<Source><![CDATA[
    public AdvanceInvoiceSettlement_SalesOrder_W parmAdvanceInvoiceSettlement_W(
        AdvanceInvoiceSettlement_SalesOrder_W _advanceInvoiceSettlement = advanceInvoiceSettlement)
    {
        advanceInvoiceSettlement = _advanceInvoiceSettlement;
        return advanceInvoiceSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoicePrintoutType_RU</Name>
				<Source><![CDATA[
    final public CustInvoicePrintoutType_RU parmCustInvoicePrintoutType_RU(CustInvoicePrintoutType_RU _printout = invoicePrintoutType)
    {
        invoicePrintoutType = countryRegion_RU ?
                              _printout :
                              CustInvoicePrintoutType_RU::TORG_12; // Default value

        return invoicePrintoutType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLineMapKeyPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// ADd a key.
    /// </summary>
    /// <param name="_line">
    /// Source record.
    /// </param>
    /// <param name="_inventOwnerId">
    /// The inventory owner.
    /// </param>
    /// <param name="_packingSlipId">
    /// The Identification of the packing slip.
    /// </param>
    /// <returns>
    /// A <c>String</c> with the modified key.
    /// </returns>
    protected str parmLineMapKeyPackingSlip(Common _line, InventOwnerId_RU _inventOwnerId = '', PackingSlipId _packingSlipId = '')
    {
        str key = this.parmLineMapKey(_line, _inventOwnerId);

        key = this.addToKey(key, _packingSlipId);

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmUpdate</Name>
				<Source><![CDATA[
    public Common parmParmUpdate(Common _salesParmUpdate = salesParmUpdate)
    {
        giroType = this.getPaymentStubValue(salesParmUpdate.GiroType);
        return super(_salesParmUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTableMapKey</Name>
				<Source><![CDATA[
    protected str parmTableMapKey(Common _source
                                  , InventOwnerId_RU _inventOwnerId = ''
    )
    {
        str key = super(_source
                    // <GEERU>
                    , _inventOwnerId
                    // </GEERU>
                    );

        if (salesParmUpdate.SumBy == AccountOrder::Journal)
        {
            switch (_source.TableId)
            {
                case tableNum(SalesParmTable) :
                    SalesParmTable salesParmTable = _source;
                    key = this.addToKey(key, salesParmTable.packingSlipId(salesParmTable));
                    break;
                case tableNum(SalesParmLine) :
                    SalesParmLine salesParmLine = _source;
                    key = this.addToKey(key, salesParmLine.documentId(salesParmLine));
                    break;
            }
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            return this.postParmTableMapKey_BR(_source, key);
        }
        // </GBR>

        return key;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWInterCompanyParmLineQty</Name>
				<Source><![CDATA[
    protected PdsCWInventQty pdsCWInterCompanyParmLineQty(Common _common)
    {
        SalesLine salesLineLocal = _common;
        VendInvoiceTrans vendInvoiceTransLocal;
        VendInvoiceJour vendInvoiceJourLocal;

        if (interCompanyCompanyId)
        {
            changecompany(interCompanyCompanyId)
            {
                select forceplaceholders PdsCWQty from vendInvoiceTransLocal
                    where vendInvoiceTransLocal.InventTransId == salesLineLocal.InterCompanyInventTransId
                exists join vendInvoiceJourLocal
                    where vendInvoiceJourLocal.InvoiceId == vendInvoiceTransLocal.InvoiceId
                        && vendInvoiceJourLocal.InvoiceDate == vendInvoiceTransLocal.InvoiceDate
                        && vendInvoiceJourLocal.PurchId == vendInvoiceTransLocal.PurchID
                        && vendInvoiceJourLocal.InternalInvoiceId == vendInvoiceTransLocal.InternalInvoiceId
                        && vendInvoiceJourLocal.ParmId == interCompanyParmId;
            }
        }
        else
        {
            select forceplaceholders PdsCWQty from vendInvoiceTransLocal
                where vendInvoiceTransLocal.InventTransId == salesLineLocal.InventRefTransId
            exists join vendInvoiceJourLocal
                where vendInvoiceJourLocal.InvoiceId == vendInvoiceTransLocal.InvoiceId
                    && vendInvoiceJourLocal.InvoiceDate == vendInvoiceTransLocal.InvoiceDate
                    && vendInvoiceJourLocal.PurchId == vendInvoiceTransLocal.PurchID
                    && vendInvoiceJourLocal.InternalInvoiceId == vendInvoiceTransLocal.InternalInvoiceId
                    && vendInvoiceJourLocal.ParmId == interCompanyParmId;
        }

        return vendInvoiceTransLocal.PdsCWQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInitRecordLists_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Brazilian specific map variables.
    /// </summary>
    protected void postInitRecordLists_BR()
    {
        if (!packingSlipParmRefIdMap_BR)
        {
            packingSlipParmRefIdMap_BR = new Map(Types::Int64, Types::Guid);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReArrangeCustPaymSched</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves <c>CustPaymSched</c> table records associated with one table record to another.
    /// </summary>
    public void postReArrangeCustPaymSched()
    {
        SalesParmTable  oldSalesParmTable, localSalesParmTable;
        select firstOnly oldSalesParmTable
            order by RecId asc
                where oldSalesParmTable.ParmId == salesParmUpdate.ParmId;

        select firstOnly localSalesParmTable
            order by RecId desc
                where localSalesParmTable.ParmId == salesParmUpdate.ParmId;

        if (localSalesParmTable != oldSalesParmTable)
        {
            // Move payment schedule from current journal to the new journal
            CustPaymSchedule::move(oldSalesParmTable, localSalesParmTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReArrangeEnd_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the re-arrange of data has completed.
    /// </summary>
    protected void postReArrangeEnd_BR()
    {
        MapEnumerator enumerator = packingSlipParmRefIdMap_BR.getEnumerator();
        SalesParmSubTable localSalesParmSubTable;
        SalesParmTable localSalesParmTable;
        FiscalReferenceParm_BR fiscalReferenceParm_BR;

        if (enumerator)
        {
            while (enumerator.moveNext())
            {
                select localSalesParmSubTable
                    where localSalesParmSubTable.SubId == enumerator.currentValue();

                if (localSalesParmSubTable)
                {
                    CustPackingSlipJour custPackingSlipJour = CustPackingSlipJour::findRecId(enumerator.currentKey());

                    select localSalesParmTable
                        where localSalesParmTable.ParmId == this.parmId()
                            && localSalesParmTable.TableRefId == localSalesParmSubTable.TableRefId;

                    select fiscalReferenceParm_BR
                        where fiscalReferenceParm_BR.SourceTableId == localSalesParmTable.TableId
                            && fiscalReferenceParm_BR.SourceRecId == localSalesParmTable.RecId;

                    if (!fiscalReferenceParm_BR)
                    {
                        FiscalReferenceParmCreator_BR fiscalReferenceParmCreator_BR = new FiscalReferenceParmCreator_BR(localSalesParmTable);
                        
                        FiscalDocument_BR fiscalDocumentBeingReturned = FiscalDocument_BR::findByRef(custPackingSlipJour.TableId, custPackingSlipJour.RecId);

                        if (fiscalDocumentBeingReturned)
                        {
                            fiscalReferenceParmCreator_BR.addReference(fiscalDocumentBeingReturned);
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postReArrangeEndPackages</Name>
				<Source><![CDATA[
    private void postReArrangeEndPackages()
    {
        SalesParmTable localSalesParmTable;
        SalesParmLine localSalesParmLine;

        ttsbegin;

        while select localSalesParmTable
            where localSalesParmTable.ParmId == salesParmUpdate.ParmId
        {
            PlInventPackageParm::updateFromSalesParmTable(localSalesParmTable);
        }

        while select localSalesParmLine
            where localSalesParmLine.ParmId == salesParmUpdate.ParmId
        {
            PlInventPackageParm::updateFromSalesParmLine(localSalesParmLine, DocumentStatus::Invoice);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyInvent</Name>
				<Source><![CDATA[
    public container qtyInvent(Common _common,
                               InventQty _qty = 0,
                               real _shipmentQuantity = -1)
    {
        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip)
        {
            _qty = newPostingInventQty;
        }
        return super(_common, _qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtySales</Name>
				<Source><![CDATA[
    public container qtySales(Common _common,
                              SalesQty _qty = 0,
                              real _shipmentQuantity = -1)
    {
        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip)
        {
            _qty = newPostingSalesQty;
        }
        return super(_common, _qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the name of the query that is used to create data.
    /// </summary>
    /// <returns>
    /// A string with the name of the used query.
    /// </returns>
    protected str queryName()
    {
        str name = super();

        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip)
        {
            // <GEERU>
            if (countryRegion_RU && salesParmUpdate.SplitInventOwnerId_RU)
            {
                return queryStr(SalesUpdateInventTrans_RU);
            }
            else
            {
                // </GEERU>
                name = queryStr(SalesUpdatePackingSlip);
                // <GEERU>
            }
            // </GEERU>
        }

        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeCreateParmTable</Name>
				<Source><![CDATA[
    protected void reArrangeCreateParmTable(QueryRun _queryRun, SalesParmTable _oldSalesParmTable, TradeLineRefId _newTableRefId, boolean _skipParmSubTable)
    {
        super(_queryRun, _oldSalesParmTable, _newTableRefId, _skipParmSubTable);

        if (_oldSalesParmTable.RecId)
        {
            // Move tax adjustments from current invoice to the new invoice
            TaxWorkRegulation::move(_oldSalesParmTable, salesParmTableReArrange);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gives an update when the re-arrange of data is completed.
    /// </summary>
    protected void reArrangeEnd()
    {
        using (var activityContextInvoice = this.instrumentationLogger().formLetterParmDataActivities().reArrangeEndInvoice())
        {
            // <GEEU>
            SalesParmTable localSalesParmTable;
            // </GEEU>

            this.endParmLinePackingslipUpdate();
            this.postReArrangeCustPaymSched();

            super();

            // <GEEU>
            if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
            {
                while select forupdate localSalesParmTable
                    where localSalesParmTable.ParmId == salesParmUpdate.ParmId
                {
                    this.initDates_W(localSalesParmTable);
                }
            }
            // </GEEU>

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                this.postReArrangeEnd_BR();
            }
            // </GBR>

            // <GEEPL>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoPL ]))
            {
                this.postReArrangeEndPackages();
            }
            // </GEEPL>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reArrangeInit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the re-arrange process.
    /// </summary>
    protected void reArrangeInit()
    {
        SalesParmLine localSalesParmLine, salesParmLineNew;
        SalesParmSubLine localSalesParmSubLine;
        Set counter = new Set(typeName2Type(extendedTypeStr(RecId)));

        taxAdjustmentDocumentCount = salesParmUpdate.numberOfTables();

        super();

        if (salesParmUpdate.SumBy == AccountOrder::Journal)
        {
            while select count(RecId) from localSalesParmSubLine
                group by LineRefRecId
                where localSalesParmSubLine.ParmId == salesParmUpdate.ParmId
            {
                if (localSalesParmSubLine.RecId > 1)
                    counter.add(localSalesParmSubLine.LineRefRecId);
            }

            if (counter.elements() > 0)
            {
                ttsbegin;
                while select forupdate localSalesParmSubLine
                    order by LineRefRecId
                    where localSalesParmSubLine.ParmId == salesParmUpdate.ParmId
                {
                    if (counter.in(localSalesParmSubLine.LineRefRecId))
                    {
                        if (localSalesParmLine.RecId == localSalesParmSubLine.LineRefRecId)
                        {
                            salesParmLineNew = localSalesParmLine.data();
                            salesParmLineNew.DeliverNow = localSalesParmSubLine.DeliverNow;
                            salesParmLineNew.InventNow = localSalesParmSubLine.InventNow;
                            salesParmLineNew.setLineAmount();
                            salesParmLineNew.calcPackingUnitQty();
                            salesParmLineNew.doInsert();
                            localSalesParmSubLine.LineRefRecId = salesParmLineNew.RecId;
                            localSalesParmSubLine.doUpdate();
                        }
                        else
                        {
                            localSalesParmLine = SalesParmLine::findRecId(localSalesParmSubLine.LineRefRecId, true);
                            localSalesParmLine.InventNow = localSalesParmSubLine.InventNow;
                            localSalesParmLine.DeliverNow = localSalesParmSubLine.DeliverNow;
                            localSalesParmLine.setLineAmount();
                            localSalesParmLine.calcPackingUnitQty();
                            localSalesParmLine.doUpdate();
                        }
                    }
                }
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Called when the re-selection of data has completed.
    /// </summary>
    protected void reSelectEnd()
    {
        MapEnumerator me;
        // <GEEU>
        // </GEEU>

        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip)
        {
            this.initRecordLists();
            me = salesParmSubTableMap.getEnumerator();
            while (me.moveNext())
            {
                SalesParmSubTable newSalesParmSubTable = me.currentValue();
                this.insertParmSubTable(newSalesParmSubTable);
            }
            this.insertRecordLists(); //Records must be inserted before calling reArrangeEnd
            this.endParmLinePackingslipUpdate();
        }

        // <GEEU>
        if (TaxParameters::isEasternEuropeOrVatDueDateFeatureEnabled())
        {
            me = parmTableMap.getEnumerator();
            while (me.moveNext())
            {
                SalesParmTable parmTable = me.currentValue();
                this.initDates_W(parmTable);
            }
        }
        // </GEEU>

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.postReArrangeEnd_BR();
            FiscalReferenceParmCreator_BR::runForReturnCustInvoice(parmId);
        }
        // </GBR>

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoPL ]))
        {
            this.postReArrangeEndPackages();
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldInitializeReselectProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the re-select process should be initialized.
    /// </summary>
    /// <returns>
    /// true if the re-select process should be initialized; otherwise, false.
    /// </returns>
    protected boolean shouldInitializeReselectProcess()
    {
        return (salesParmUpdate.SpecQty != SalesUpdate::PackingSlip);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectInit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the re-select process.
    /// </summary>
    protected void reSelectInit()
    {
        SalesId prevSalesId;
        InventSiteId prevInventSiteId;
        TaxRegistrationRecId prevTaxId;
        // <GEERU>
        CustPostingProfile prevPostingProfile;
        InventProfileType_RU prevProfileType;
        InventOwnerId_RU prevInventOwner;
        // </GEERU>
        SalesParmSubTable localSalesParmSubTable;
        SalesParmTable localSalesParmTable;

        salesParmSubTableMap = new Map(Types::String, Types::Record);

        if (this.shouldInitializeReselectProcess())
        {
            //remove sub table records created by specQty = PackingSlip
            ttsbegin;
            while select forupdate localSalesParmSubTable
                order by OrigSalesId
                where localSalesParmSubTable.ParmId == salesParmUpdate.ParmId
                   && localSalesParmSubTable.JournalRefTableId != 0
                      join localSalesParmTable
            // <GEERU>
            order by InventSiteId, InventProfileType_RU, PostingProfile_RU, InventOwnerId_RU, TaxId
            // </GEERU>
            where localSalesParmTable.ParmId == localSalesParmSubTable.ParmId
                           && localSalesParmTable.TableRefId == localSalesParmSubTable.TableRefId

            {
                if (prevSalesId == localSalesParmSubTable.OrigSalesId
                // <GEERU>
                    && prevInventSiteId == localSalesParmTable.InventSiteId
                    && (!countryRegion_RU
                        || (prevProfileType == localSalesParmTable.InventProfileType_RU
                            && prevPostingProfile == localSalesParmTable.PostingProfile_RU
                            && prevInventOwner == localSalesParmTable.InventOwnerId_RU))
                // </GEERU>
                    && (!TaxIntegrationUtils::isMultipleTaxIdAllowedWithinOneSalesOrder()
                        || prevTaxId == localSalesParmTable.TaxId))
                {
                    localSalesParmSubTable.doDelete();
                }
                else
                {
                    prevSalesId = localSalesParmSubTable.OrigSalesId;
                    prevTaxId = localSalesParmTable.TaxId;
                    prevInventSiteId = localSalesParmTable.InventSiteId;
                    // <GEERU>
                    prevProfileType = localSalesParmTable.InventProfileType_RU;
                    prevPostingProfile = localSalesParmTable.PostingProfile_RU;
                    prevInventOwner = localSalesParmTable.InventOwnerId_RU;
                    // </GEERU>
                    this.removeSalesParmSubTableReferences(localSalesParmSubTable, localSalesParmTable);
                    localSalesParmSubTable.update();
                }
            }
            ttscommit;
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeSalesParmSubTableReferences</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the reference fields on the <c>SalesParmSubTable</c> to zero or empty.
    /// </summary>
    /// <param name = "_salesParmSubTable">The table buffer to zero.</param>
    /// <param name = "_salesParmTable">An additional argument to be used in zeroing the <c>SalesParmSubTable</c>.</param>
    protected void removeSalesParmSubTableReferences(SalesParmSubTable _salesParmSubTable, SalesParmTable _salesParmTable)
    {
        guid emptySubId;

        _salesParmSubTable.JournalRefRecId = 0;
        _salesParmSubTable.JournalRefTableId = 0;
        _salesParmSubTable.SubId = emptySubId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Re-selects the record in the line posting parameter table.
    /// </summary>
    /// <param name="_origOrderId">
    /// An order ID.
    /// </param>
    protected void reSelectLines(SalesId _origOrderId)
    {
        this.intercompanySalesAtCostPriceHandler().onSalesLinesSelectionStarted();

        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip)
        {
            this.reSelectLinesPackingSlip(_origOrderId);
        }
        else
        {
            super(_origOrderId);
        }

        this.intercompanySalesAtCostPriceHandler().onSalesLinesSelectionFinished();
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildReSelectLinesQuery</Name>
				<Source><![CDATA[
    protected Query buildReSelectLinesQuery(SalesId _origOrderId)
    {
        Query query = super(_origOrderId);
        
        if (InventInventoryDataServiceSoftReservationHelper::isSoftReserveEnabled())
        {
            InventInventoryDataServiceSoftReservationHelper::addSoftReserveFilter(query);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reSelectLinesPackingSlip</Name>
				<Source><![CDATA[
    protected void reSelectLinesPackingSlip(SalesId _origOrderId)
    {
        SalesParmSubTable localSalesParmSubTable;

        SalesLine localSalesLine;
        CustPackingSlipJour custPackingSlipJour;
        CustPackingSlipTrans custPackingSlipTrans;

        SalesParmSubTable newSalesParmSubTable;

        Set set = new Set(Types::Record);
        TradeLineRefId tableRefId;
        boolean subTableUpdated;
        guid subId, emptySubId;
        Set packingSlips = new Set(Types::String);

        SalesLine prevSalesLine;
        CustPackingSlipTrans prevPackingSlipTrans;

        // <GEERU>
        InventTransOrigin inventTransOrigin;
        InventTrans inventTrans;
        InventTrans previousInventTrans;
        boolean splitInventOwnerId_RU = countryRegion_RU && this.splitInventOwnerId_RU();
        // </GEERU>

        void updateSalesParmSubTable()
        {
            custPackingSlipJour = CustPackingSlipJour::findFromCustPackingSlipTrans(prevPackingSlipTrans.SalesId,
                prevPackingSlipTrans.PackingSlipId,
                prevPackingSlipTrans.DeliveryDate);

            if (!packingSlips.in(custPackingSlipJour.PackingSlipId))
                subId = newGuid();

            // <GEERU>
            if (splitInventOwnerId_RU)
            {
                this.createParmLineAndSubLines(prevSalesLine, set.pack(), tableRefId, subId, this.inventOwnerId_RU(prevSalesLine));
            }
            else
            {
                // </GEERU>
                this.createParmLineAndSubLines(prevSalesLine, set.pack(), tableRefId, subId);
                // <GEERU>
            }
            // </GEERU>

            if (!packingSlips.in(custPackingSlipJour.PackingSlipId))
            {
                if (subTableUpdated)
                {
                    newSalesParmSubTable = localSalesParmSubTable.data();
                    newSalesParmSubTable.SubId = subId;
                    newSalesParmSubTable.JournalRefRecId = custPackingSlipJour.RecId;
                    newSalesParmSubTable.JournalRefTableId = custPackingSlipJour.TableId;
                    salesParmSubTableMap.insert(newSalesParmSubTable.OrigSalesId + #KeyDelimitor + int642str(newSalesParmSubTable.JournalRefRecId), newSalesParmSubTable);
                }
                else
                {
                    localSalesParmSubTable = SalesParmSubTable::find(this.parmId(), tableRefId, _origOrderId, emptySubId, true);

                    if (localSalesParmSubTable)
                    {
                        localSalesParmSubTable.JournalRefRecId = custPackingSlipJour.RecId;
                        localSalesParmSubTable.JournalRefTableId = custPackingSlipJour.TableId;
                        localSalesParmSubTable.SubId = subId;
                        localSalesParmSubTable.doUpdate();
                    }
                    subTableUpdated = true;
                }
                packingSlips.add(custPackingSlipJour.PackingSlipId);
            }

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                packingSlipParmRefIdMap_BR.insert(custPackingSlipJour.RecId, localSalesParmSubTable.subId);
            }
            // </GBR>

            set = new Set(Types::Record);
        }

        // <GEERU>
        if (splitInventOwnerId_RU)
        {
            select nofetch localSalesLine
                where localSalesLine.SalesId == _origOrderId
                   && localSalesLine.Blocked == NoYes::No
                    join custPackingSlipTrans
                        order by localSalesLine.RecId, custPackingSlipTrans.PackingSlipId
                        where custPackingSlipTrans.InventTransId == localSalesLine.InventTransId
                           && custPackingSlipTrans.FullyMatched == NoYes::No
                            join inventTransOrigin
                                where inventTransOrigin.InventTransId == custPackingSlipTrans.InventTransId
                                    join inventTrans
                                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId;
        }
        else
        {
            select nofetch localSalesLine
                // </GEERU>
                where localSalesLine.SalesId == _origOrderId
                       && localSalesLine.Blocked == NoYes::No
                        join custPackingSlipTrans
                                order by localSalesLine.RecId, custPackingSlipTrans.PackingSlipId
                            where custPackingSlipTrans.InventTransId == localSalesLine.InventTransId
                               && custPackingSlipTrans.FullyMatched == NoYes::No
                               && (custPackingSlipTrans.Qty != 0 
                                   || custPackingSlipTrans.inventQty != 0)
                // <GEERU>
                ;
        }
        next localSalesLine;
        while (localSalesLine)
        // </GEERU>
        {
            if (prevPackingSlipTrans.PackingSlipId != custPackingSlipTrans.PackingSlipId
            // <GEERU>
            || (splitInventOwnerId_RU && inventTrans.inventDim().InventOwnerId_RU != previousInventTrans.inventDim().InventOwnerId_RU)
            // </GEERU>
            || prevPackingSlipTrans.InventTransId != custPackingSlipTrans.InventTransId)
            {
                if (prevPackingSlipTrans.PackingSlipId)
                {
                    // <GEERU>
                    if (splitInventOwnerId_RU)
                    {
                        chooseLineInventTrans = previousInventTrans.data();
                    }
                    // </GEERU>
                    tableRefId = this.getTableRefId(prevSalesLine);
                }

                prevPackingSlipTrans = custPackingSlipTrans.data();
                // <GEERU>
                previousInventTrans = inventTrans.data();
                // </GEERU>
            }

            if (this.canReSelectLinesPackingSlip(custPackingSlipTrans, localSalesLine))
            {
                if (prevSalesLine.RecId != 0 && (prevSalesLine.RecId != localSalesLine.RecId))
                {
                    // new SalesLine, write out the SalesParmLine and SalesParmSubLines.
                    updateSalesParmSubTable();
                }

                set.add(custPackingSlipTrans);
            }

            prevSalesLine = localSalesLine.data();

            next localSalesLine;
        }

        if (prevPackingSlipTrans.PackingSlipId)
        {
            // <GEERU>
            if (splitInventOwnerId_RU)
            {
                chooseLineInventTrans = previousInventTrans.data();
            }
            // </GEERU>
            tableRefId = this.getTableRefId(prevSalesLine);
            updateSalesParmSubTable();
            prevSalesLine = null;
            prevPackingSlipTrans = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReSelectLinesPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether can reselect lines packing slip.
    /// </summary>
    /// <param name = "_custPackingSlipTrans"><c>CustPackingSlipTrans</c> record.</param>
    /// <param name = "_salesLine"><c>SalesLine</c> record.</param>
    /// <returns>
    ///  Always true.
    /// </returns>
    protected boolean canReSelectLinesPackingSlip(CustPackingSlipTrans _custPackingSlipTrans, SalesLine _salesLine)
    {
        return _custPackingSlipTrans && (!_salesLine || this.mayJournalTransBePosted(_salesLine));
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesStatusRange</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the sales status range that selects the sales orders to be invoice updated.
    /// </summary>
    /// <returns>
    ///    The sales status range that selects the sales orders to be invoice updated.
    /// </returns>
    protected str salesStatusRange()
    {
        return queryRange(SalesStatus::Backorder,SalesStatus::Delivered);
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectChooseLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Selects which ChooseLines method to execute.
    /// </summary>
    /// <param name="_append">
    /// A Boolean value that indicates whether to append or delete existing data first.
    /// </param>
    protected void selectChooseLines(boolean _append = false)
    {
        this.intercompanySalesAtCostPriceHandler().onSalesLinesSelectionStarted();

        if (this.lineListTableId() == tableNum(WMSShipment))
        {
            this.chooseLinesFromWMSShipment();
        }
        else if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip &&
            !this.parmCreateFromLines())
        {
            this.chooseLinesPackingSlip();
        }
        else
        {
            super(_append);
            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                FiscalReferenceParmCreator_BR::runForReturnCustInvoice(this.parmParmId());
            }
            // </GBR>
        }

        this.intercompanySalesAtCostPriceHandler().onSalesLinesSelectionFinished();
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournal</Name>
				<Source><![CDATA[
    public void selectFromJournal(container _packedTmpFrmVirtualList)
    {
        #OCCRetryCount

        List tmpFrmVirtualList = List::create(_packedTmpFrmVirtualList);
        ListEnumerator enumerator = tmpFrmVirtualList.getEnumerator();

        CustPackingSlipJour custPackingSlipJour;
        CustPackingSlipTrans custPackingSlipTrans;
        TmpFrmVirtual tmpFrmVirtual;

        SalesLine localSalesLine;

        Map allowPostingMap = new Map(Types::String, Types::Enum);
        Map packingSlipJourLines = new Map(Types::Int64, Types::Container);
        Map lastPackingSlipLineSalesLine;
        RecId lastPackingSlipJourRecId;

        try
        {
            ttsbegin;
            if (!this.parmParmUpdate().RecId)
            {
                SalesParmUpdate localSalesParmUpdate = this.createParmUpdate();
                this.insertParmUpdate(localSalesParmUpdate);
            }

            SalesParmTable::deleteWithoutUpdate(salesParmUpdate.ParmId);

            while (enumerator.moveNext())
            {
                tmpFrmVirtual.data(enumerator.current());
                tmpFrmVirtual.insert();
            }

            while select RecId from tmpFrmVirtual
                order by Id
                join RecId from custPackingSlipJour
                    where tmpFrmVirtual.RecordNo == custPackingSlipJour.RecId
                       && tmpFrmVirtual.TableNum == custPackingSlipJour.TableId
                    join RecId, OrigSalesId from custPackingSlipTrans
                        order by OrigSalesId
                        where custPackingSlipJour.SalesId == custPackingSlipTrans.SalesId
                           && custPackingSlipJour.PackingSlipId == custPackingSlipTrans.PackingSlipId
                           && custPackingSlipJour.DeliveryDate == custPackingSlipTrans.DeliveryDate
                           && custPackingSlipTrans.FullyMatched == NoYes::No
                        join localSalesLine
                            where localSalesLine.InventTransId == custPackingSlipTrans.InventTransId
            {
                if (!allowPostingMap.exists(custPackingSlipTrans.OrigSalesId))
                {
                    SalesTable localSalesTable = SalesTable::find(custPackingSlipTrans.OrigSalesId);
                    allowPostingMap.insert(custPackingSlipTrans.OrigSalesId, this.mayJournalBePosted(localSalesTable));
                }
                if (!allowPostingMap.lookup(custPackingSlipTrans.OrigSalesId))
                    continue;

                if (custPackingSlipJour.RecId != lastPackingSlipJourRecId)
                {
                    if (lastPackingSlipLineSalesLine)
                    {
                        packingSlipJourLines.insert(lastPackingSlipJourRecId, lastPackingSlipLineSalesLine.pack());
                    }

                    if (packingSlipJourLines.exists(custPackingSlipJour.RecId))
                    {
                        lastPackingSlipLineSalesLine = Map::create(packingSlipJourLines.lookup(custPackingSlipJour.RecId));
                    }
                    else
                    {
                        lastPackingSlipLineSalesLine = new Map(Types::Int64, Types::Record);
                    }
                }

                lastPackingSlipLineSalesLine.insert(custPackingSlipTrans.RecId, localSalesLine);

                lastPackingSlipJourRecId = custPackingSlipJour.RecId;
            }

            if (lastPackingSlipLineSalesLine)
            {
                packingSlipJourLines.insert(lastPackingSlipJourRecId, lastPackingSlipLineSalesLine.pack());
            }

            this.createBasedOnPackingSlip(packingSlipJourLines);

            ttscommit;
        }
        catch (Exception::TransientSqlConnectionError)
        {
            if (SysTransientSqlConnectionErrorHandler::retryTransientSqlConnectionError())
            {
                retry;
            }
            else
            {
                throw Exception::TransientSqlConnectionError;
            }
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch
        {
            this.catchAll();
        }

        AccountOrder accountOrder = salesParmUpdate.SumBy;
        salesParmUpdate.SumBy = AccountOrder::None;
        this.reArrange();
        salesParmUpdate.SumBy = accountOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAddressForInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the address for invoice.
    /// </summary>
    /// <param name="salesParmTable">
    /// A sales order update table.
    /// </param>
    protected void setAddressForInvoice(SalesParmTable salesParmTable)
    {
        //need to change the address to the one with invoice role
        CustTable custTable = CustTable::find(salesParmTable.CustAccount) as CustTable;

        LogisticsLocation location = LogisticsLocationDefault::findSimpleDefault(custTable, LogisticsLocationRole::findBytype(
            LogisticsLocationRoleType::Invoice));
        if (location.RecId)
        {
            LogisticsLocationEntity locationEntity = LogisticsLocationEntity::constructFromLocationRecId(location.RecId);
            salesParmTable.DeliveryPostalAddress = locationEntity.getPostalAddress().RecId;
            salesParmTable.DeliveryName = location.Description;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitByServiceCode_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the invoice should be split for each service code.
    /// </summary>
    /// <returns>
    /// true if invoice should be split; otherwise, false.
    /// </returns>
    protected boolean splitByServiceCode_BR()
    {
        return SalesParameters::find().SplitInvoiceByServiceCode_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDates_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates dates for given <c>SalesParmTable</c>
    /// </summary>
    /// <param name="_localSalesParmTable">
    /// <c>SalesParmTable</c> to update dates for
    /// </param>
    final public void updateDates_W(SalesParmTable _localSalesParmTable)
    {
        _localSalesParmTable.modifiedVATDueDate_W(true);
        _localSalesParmTable.modifiedSalesDate_W(true);

        if (_localSalesParmTable.RecId && _localSalesParmTable.selectForUpdate())
        {
            _localSalesParmTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmUpdateFromLoad_BR</Name>
				<Source><![CDATA[
    private void updateParmUpdateFromLoad_BR(SalesParmUpdate _salesParmUpdate)
    {
        _salesParmUpdate.setFieldsFromWHSLoad(this.parmWHSLoadId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryBuild</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the query that was used during data creation.
    /// </summary>
    public void updateQueryBuild()
    {
        super();

        if (InventInventoryDataServiceSoftReservationHelper::isSoftReserveEnabled())
        {
            InventInventoryDataServiceSoftReservationHelper::addSoftReserveFilter(chooseLines.query());
        }

        if (chooseLines.query().dataSourceTable(tableNum(SalesTable)).findRange(fieldNum(SalesTable, GiroType)))
        {
            chooseLines.query().dataSourceTable(tableNum(SalesTable)).clearRange(fieldNum(SalesTable, GiroType));
        }
        if (!this.parmDefaultGiroType() &&
            !interCompanyParmId &&
            // When late selection is enabled we can't predict parmDefaultGiroType() because
            // records are retrieved one by one, so checking salesParmUpdate table directly
            !(salesParmUpdate.lateSelection && salesParmUpdate.GiroType == PaymentStubInclAll::All))
        {
            chooseLines.query().dataSourceTable(tableNum(SalesTable)).addRange(fieldNum(SalesTable, GiroType));
            chooseLines.query().dataSourceTable(tableNum(SalesTable)).rangeField(fieldNum(SalesTable, GiroType)).value(queryValue(giroType));
            chooseLines.query().dataSourceTable(tableNum(SalesTable)).rangeField(fieldNum(SalesTable, GiroType)).status(RangeStatus::Locked);
        }

        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip
        // <GEERU>
        && ((countryRegion_RU && !salesParmUpdate.SplitInventOwnerId_RU) || !countryRegion_RU)
        // </GEERU>
        )
        {
            QueryBuildDataSource qbds = chooseLines.query().dataSourceTable(tableNum(CustPackingSlipTrans));
            if (qbds)
            {
                QueryBuildRange qbr = SysQuery::findOrCreateRange(qbds, fieldNum(CustPackingSlipTrans, FullyMatched));
                qbr.value(queryValue(NoYes::No));
                qbr.status(RangeStatus::Hidden);
            }
            }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryDocumentRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds ranges on order ID to the query that is used when data is created.
    /// </summary>
    /// <param name="_datasourceRecordsPackedMap">
    /// A container with a packed version of a map with order IDs.
    /// </param>
    /// <param name="_abortOnError">
    /// A Boolean value that indicates whether to stop the update of the query if an error occurs.
    /// </param>
    /// <returns>
    /// The number of order ID ranges that are added to the query.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// An error occurred during the update.
    /// </exception>
    protected int updateQueryDocumentRanges(container _datasourceRecordsPackedMap, boolean _abortOnError = false)
    {
        // <GBR>
        if (this.isPostFromLoad_BR())
        {
            return this.updateQueryForLoadInvoice_BR(_abortOnError);
        }
        // </GBR>

        return super(_datasourceRecordsPackedMap, _abortOnError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQueryForLoadInvoice_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Load the query with sales tables related to the Load that is being posted.
    /// </summary>
    /// <param name="_abortOnError">
    /// A Boolean value that indicates whether to stop the update of the query if an error occurs.
    /// </param>
    /// <returns>
    /// The number of order ID ranges that are added to the query.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    /// An error occurred during the update.
    /// </exception>
    private int updateQueryForLoadInvoice_BR(boolean _abortOnError = false)
    {
        return this.updateQueryFromLoad_BR(_abortOnError);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssessableValue_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update assessable value of current salesParmLine.
    /// </summary>
    /// <param name = "_salesParmLine">
    /// The record of current salesParmLine.
    /// </param>
    /// <param name = "_salesParmSubLine">
    /// The salesParmSubLine record related to current salesParmline.
    /// </param>
    private void updateAssessableValue_IN(SalesParmLine _salesParmLine, SalesParmSubLine _salesParmSubLine)
    {
        SalesParmLine_IN salesParmLineIN = _salesParmLine.salesParmLine_IN();

        // <GTE>
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            // </GTE>
            ttsbegin;
            RealBase factor = _salesParmLine.orig().salesParmLine_IN().AssessableValueTransactionCurrency / _salesParmLine.orig().DeliverNow;
            salesParmLineIN.selectForUpdate(true);
            salesParmLineIN.AssessableValueTransactionCurrency = factor * _salesParmLine.DeliverNow;
            if (_salesParmLine.ParmId && salesParmLineIN.RecId)
            {
                salesParmLineIN.doUpdate();
            }
            ttscommit;
            // <GTE>
        }
        else
        {
            ttsbegin;
            salesParmLineIN.selectForUpdate(true);
            SalesLine salesLine = SalesLine::findRecId(_salesParmSubLine.SalesLineRecId);
            salesParmLineIN.AssessableValueTransactionCurrency = _salesParmLine.getMiscChargesAmount_IN(salesLine.TableId, salesLine.RecId, this.parmDocumentStatus());
            salesParmLineIN.doUpdate();
            ttscommit;
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    [SysObsolete('Use SalesFormletterParmData::construct() instead.', false, 30\6\2020)]
    static SalesFormletterParmDataInvoice construct()
    {
        return SalesFormletterParmData::construct(DocumentStatus::Invoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQty</Name>
				<Source><![CDATA[
    public container pdsCWQty(Common _common, PdsCWInventQty _qty = naReal())
    {
        if (salesParmUpdate.SpecQty == SalesUpdate::PackingSlip)
        {
            _qty = newPostingCWQty;
        }

        return super(_common, _qty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanySalesAtCostPriceHandler</Name>
				<Source><![CDATA[
    private IntercompanySalesAtCostPriceFormLetterHandler intercompanySalesAtCostPriceHandler()
    {
        intercompanySalesAtCostPriceHandler = intercompanySalesAtCostPriceHandler ? intercompanySalesAtCostPriceHandler : IntercompanySalesAtCostPriceFormLetterHandler::construct();
        return intercompanySalesAtCostPriceHandler;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowLineLevelTaxAdjustments</Name>
				<Source><![CDATA[
    public NoYes parmAllowLineLevelTaxAdjustments(NoYes _allowLineLevelTaxAdjustments = allowLineLevelTaxAdjustments)
    {
        allowLineLevelTaxAdjustments = _allowLineLevelTaxAdjustments;
        return allowLineLevelTaxAdjustments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createParmLinesAndTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void createParmLinesAndTable()
    {
        super();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>