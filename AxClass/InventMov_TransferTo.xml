<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventMov_TransferTo</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>InventMov_TransferTo</c> class is used together with inventory transfer orders.
/// </summary>
/// <remarks>
///  When you work with a transfer order or inventory movement, the following four movements are created
///  for each transfer order, an
///  <c>
///  InventTransferLine
///  </c>
///   record:
///  <list type="bullet">
///   <item>
///    <description>
///    <c>InventMov_TransferFrom</c> : Issue transaction from warehouse.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferTransitTo</c> : Receipt transaction to transit warehouse.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferTransitFrom</c> : Issue transaction from transit warehouse.
///    </description>
///   </item>
///   <item>
///    <description>
///    <c>InventMov_TransferTo</c> : Receipt transaction to warehouse.
///    </description>
///   </item>
///  </list>
/// </remarks>
[InventMovementFactoryAttribute(tableStr(InventTransferLine),InventMovSubType::TransferOrderTo)]
class InventMov_TransferTo extends InventMov_Transfer
{
    private boolean useFromMovementAsIssueMovement;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmUseFromMovementAsIssueMovement</Name>
				<Source><![CDATA[
    internal boolean parmUseFromMovementAsIssueMovement(boolean _useFromMovementAsIssueMovement = useFromMovementAsIssueMovement)
    {   
        useFromMovementAsIssueMovement = _useFromMovementAsIssueMovement;
        return useFromMovementAsIssueMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the <c>InventQty</c> that is passed as argument to the <c>qtyRemainReceive</c> of the <see
    ///    cref="T:InventTransferLine" /> that is related to this movement.
    /// </summary>
    /// <param name="_inventQty">
    ///    The quantity to be added.
    /// </param>
    public void addRemainPhysical(InventQty  _inventQty)
    {
        inventTransferLine.QtyRemainReceive += _inventQty * this.transSign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustTransactionInventDimEstimated</Name>
				<Source><![CDATA[
    public InventDim adjustTransactionInventDimEstimated()
    {
        return WHSInvent::fillLicensePlateForTransferReceipt(this.inventdim(), this.inventTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInventLocationId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the <c>InventLocationId</c> value of the <c>InventDim</c> record of this movement is
    ///    the same as the <c>InventLocationId</c> value of the <c>Transferto</c> location of the <see
    ///    cref="T:InventTransferTable" /> that is related to this movement.
    /// </summary>
    /// <returns>
    ///    true if the two <c>InventLocationId</c> values are the same; otherwise, false.
    /// </returns>
    protected boolean checkInventLocationId()
    {
        if (this.inventdim().InventLocationId != InventTransferTable::find(inventTransferLine.TransferId).InventLocationIdTo)
        {
            return checkFailed(strFmt("@SYS78513", InventTransferTable::find(inventTransferLine.TransferId).InventLocationIdTo));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateArrived</Name>
				<Source><![CDATA[
    public boolean checkUpdateArrived(InventUpd_Arrived _updateNow)
    {
        boolean ret = super(_updateNow);

        InventDim arrInventDimCriteria = _updateNow.parmInventDimCriteria();
        InventLocationId toLocation = inventTransferLine.inventTransferTable().InventLocationIdTo;

        if (arrInventDimCriteria.InventLocationId != toLocation)
        {
            ret = ret && checkFailed(strFmt("@SYS54084",toLocation));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateRegistered</Name>
				<Source><![CDATA[
    public boolean checkUpdateRegistered(InventUpd_Registered _updateNow)
    {
        boolean ret = super(_updateNow);

        InventDim regInventDimCriteria = _updateNow.parmRegInventDimCriteria();
        InventLocationId toLocation = inventTransferLine.inventTransferTable().InventLocationIdTo;

        if (regInventDimCriteria.InventLocationId != toLocation)
        {
            ret = ret && checkFailed(strFmt("@SYS54084",toLocation));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    public void createOriginOwnerRelationship()
    {
        InventTransOriginId originId = this.inventTransOriginId();

        if (originId && inventTransferLine.RecId)
        {
            InventTransOriginTransferReceive::writeOriginOwnerRelationship(inventTransferLine.DataAreaId, inventTransferLine.TransferId, inventTransferLine.LineNum, originId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will return the DefaultDimension based up on the InventTransId
    /// </summary>
    /// <returns>
    /// Default dimension
    /// </returns>
    public DimensionDefault defaultDimension()
    {
        if (InventTransferLine::enableDefaultDimensionControl())
        {
            return inventTransferLine.DimensionDefaultShipTo;
        }

        // <GIN>
        if (this.useParmLineDefaultDimension_IN())
        {
            return (select firstOnly InventTransferParmLine where InventTransferParmLine.ParmId == this.parmInventParmID_IN()
                                                                && InventTransferParmLine.InventTransId == inventTransferLine.InventTransIdReceive).DefaultDimension_IN;
        }
        // </GIN>

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteOriginOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the relationship between the inventory transactions originator and the owner that
    ///    corresponds.
    /// </summary>
    public void deleteOriginOwnerRelationship()
    {
        if (inventTransferLine.RecId)
        {
            InventTransOriginTransferReceive::deleteOwnerRelationship(inventTransferLine.DataAreaId, inventTransferLine.TransferId, inventTransferLine.LineNum);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimParmRelatedUpdate</Name>
				<Source><![CDATA[
    public InventDimParm dimParmRelatedUpdate(InventDim _inventDim = null)
    {
        InventDimParm inventDimParm;

        inventDimParm.initDimTransferReceipt(_inventDim);
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimFrom</Name>
				<Source><![CDATA[
    protected InventDim inventDimFrom()
    {
        return inventTransferLine.inventDimTransitFrom(inventTransferTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimId</Name>
				<Source><![CDATA[
    public InventDimId inventDimId()
    {
        if (! inventDim.InventDimId)
        {
            inventDim = inventTransferLine.inventDimReceive(inventTransferTable);
        }

        return inventDim.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimMerged</Name>
				<Source><![CDATA[
    public InventDim inventDimMerged(InventDim _inventDim)
    {
        return inventTransferLine.inventDimMergeWarehouse(inventTransferTable.InventLocationIdTo,inventTransferTable,_inventDim);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimParmMatchTransferTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an <c>InventDimParm</c> table buffer to use to find the related <c>InventTrans</c>
    ///    records.
    /// </summary>
    /// <returns>
    ///    An <c>InventDimParm</c> table buffer.
    /// </returns>
    /// <remarks>
    ///    This method is used for movements that represent transfers.
    /// </remarks>
    public InventDimParm inventDimParmMatchTransferTrans()
    {
        InventDimParm inventDimParmMatchTransferTrans;
         // we want to search for an exact match on dimensions that are being transferred, which also means match on blank dimensions.
        inventDimParmMatchTransferTrans.setAllInventDim();
        //clear non transferable dimensions since we do not need to look for these when we look for related transactions
        inventDimParmMatchTransferTrans.clearNonTransferReceiptMergeable();

        return inventDimParmMatchTransferTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimTo</Name>
				<Source><![CDATA[
    protected InventDim inventDimTo()
    {
        return inventTransferLine.inventDimReceive(inventTransferTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventRefTransId</Name>
				<Source><![CDATA[
    InventRefTransId inventRefTransId()
    {
        return this.parmInventRefTransId_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the ID of the inventory transaction originator that corresponds to the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The new value of the ID of the inventory transaction originator.
    /// </param>
    /// <returns>
    ///    The ID of the inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId inventTransOriginId(InventTransOriginId _inventTransOriginId = inventTransOriginId)
    {
        if (_inventTransOriginId != inventTransOriginId)
        {
            inventTransOriginId = _inventTransOriginId;
        }
        else
        {
            if (!inventTransOriginId)
            {
                inventTransOriginId = InventTransOriginTransferReceive::findInventTransOriginId(inventTransferLine.DataAreaId, inventTransferLine.TransferId, inventTransferLine.LineNum);
            }
        }

        return inventTransOriginId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrimaryMovement</Name>
				<Source><![CDATA[
    public boolean isPrimaryMovement()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStorageDimensionOnlyTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Check if movement operates only with the storage dimensions during transfers.
    /// </summary>
    /// <returns>
    ///    true if the movement operates only with the storage dimensions during transfers; otherwise, false.
    /// </returns>
    public boolean isStorageDimensionOnlyTransfer()
    {
        // Because internal transfer shipment pair serial number validation was already done, thus serial number control validation can be skipped
        // for internal transfer receive when arrival is processing inventTrans that comes from internal transfer.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markingRefInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the ID of the marked transaction origin.
    /// </summary>
    /// <returns>
    /// <c>0</c> if the whole movement is not marked; otherwise, the ID of the transaction origin marked
    /// with.
    /// </returns>
    public InventTransOriginId markingRefInventTransOrigin()
    {
        return this.parmMarkingRefInventTransOrigin_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeTransDimTransferReceipt</Name>
				<Source><![CDATA[
    public InventDim mergeTransDimTransferReceipt(
        InventDim       _toInventDim,
        InventDim       _fromInventDim          = this.inventdim(),
        InventDim       _origFromDim            = _fromInventDim)
    {
        // The method is called in a way that makes issueDim _toInventDim and receiptDim - _fromInventDim
        InventDim issueDim   = _toInventDim;
        InventDim receiptDim;

        receiptDim.data(_fromInventDim);
        receiptDim.mergeTransferIssueIntoFinalReceipt(this.inventDimGroupSetup(), issueDim);

        receiptDim.clearLicensePlateIfInvalid();

        return receiptDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBeAutoReserved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if the <c>inventMovement</c> must be autoreserved.
    /// </summary>
    /// <returns>
    ///    true, because this movement is always autoreserved.
    /// </returns>
    /// <remarks>
    ///    The method is often called together with the <c>canBeReserved</c> method, which returns a default
    ///    Boolean from the <c>inventType</c> class hierarchy.
    /// </remarks>
    public boolean  mustBeAutoReserved()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateRelatedTrans</Name>
				<Source><![CDATA[
    public boolean mustUpdateRelatedTrans()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_Orig</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new <see cref="T:InventMov_TransferTo" /> that is created based on the original <see
    ///    cref="T:InventTransferLine" />.
    /// </summary>
    /// <returns>
    ///    A new instance of <c>InventMov_TransferTo</c>.
    /// </returns>
    public InventMovement newMovement_Orig()
    {
        if (!inventTransferLine.RecId)
        {
            return null;
        }

        return InventMov_TransferTo::newFromInventTransferLine(inventTransferLine.orig(),inventType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_TransferIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new <c>InventMovement</c> that is constructed based on this movement's <see
    ///    cref="T:InventTransferLine" /> and an <c>InventMovSubType</c> of <c>TransferOrderTransitFrom</c>.
    /// </summary>
    /// <returns>
    ///    A new <c>InventMovement</c> that is constructed based on an <c>InventMovSubType</c> of
    ///    <c>TransferOrderTransitFrom</c>.
    /// </returns>
    public InventMovement  newMovement_TransferIssue()
    {
        InventTransferLine  movementInventTransferLine = this.buffer();

        if (this.parmUseFromMovementAsIssueMovement())
        {
            return InventMov_TransferFrom::newFromInventTransferLine(movementInventTransferLine);
        }

        return InventMovement::construct(movementInventTransferLine, InventMovSubType::TransferOrderTransitFrom, this.childBuffer());
    }

]]></Source>
			</Method>
			<Method>
				<Name>newMovement_TransferReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns this instance of the invent movement.
    /// </summary>
    /// <returns>
    ///    Returns this <c>InventMovement</c>.
    /// </returns>
    public InventMovement  newMovement_TransferReceipt()
    {
        return this;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWAddRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds catch weight remain physical.
    /// </summary>
    /// <param name="_qty">
    /// The catch weight quantity to add to remain physical.
    /// </param>
    public void pdsCWAddRemainPhysical(PdsCWInventQty _qty)
    {
        inventTransferLine.PdsCWQtyRemainReceive +=  _qty * this.transSign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the catch weight remain physical value.
    /// </summary>
    /// <returns>
    /// The catch weight remain physical quantity.
    /// </returns>
    public PdsCWInventQty pdsCWRemainPhysical()
    {
        return this.transSign() * inventTransferLine.PdsCWQtyRemainReceive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWSetRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the catch weight remain physical quantity.
    /// </summary>
    /// <param name="_qty">
    /// The catch weight quantity to set remain physical.
    /// </param>
    public void pdsCWSetRemainPhysical(PdsCWInventQty _qty)
    {
        inventTransferLine.PdsCWQtyRemainReceive = _qty * this.transSign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>relatedMovement</Name>
				<Source><![CDATA[
    public InventMovement relatedMovement()
    {
        return this.newMovement_TransferIssue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the quantity that remains to be received.
    /// </summary>
    /// <returns>
    ///    The quantity that remains to be received, as an <c>InventQty</c>.
    /// </returns>
    public InventQty remainPhysical()
    {
        // <GIN>
        if (inventTransferLine.checkForUnitID_IN())
        {
            return this.transSign() * inventTransferLine.converUnit_IN(inventTransferLine.QtyRemainReceive);
        }
        else
        {
        // </GIN>
            return this.transSign() * inventTransferLine.QtyRemainReceive;
        // <GIN>
        }
        // </GIN>
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>InventDimId</c> of this movement to a merge between the <c>InventDim</c> related to the
    ///    <c>InventDimId</c> passed as argument, and the <c>InventLoactionTo</c> of the <see
    ///    cref="T:InventTransferTable" /> that is related to this movement's <see cref="T:InventTransferLine"
    ///    />.
    /// </summary>
    /// <param name="_dimId">
    ///    The <c>InventDimId</c> that the <c>InventDim</c> to be merged is found from.
    /// </param>
    public void setInventDimId(InventDimId _dimId)
    {
        inventDim = inventTransferLine.inventDimMergeWarehouse(inventTransferTable.InventLocationIdTo,inventTransferTable,InventDim::find(_dimId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRemainPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the quantity that remains to be received.
    /// </summary>
    /// <param name="_inventQty">
    ///    The <c>InventQty</c> that should be assigned.
    /// </param>
    public void setRemainPhysical(InventQty  _inventQty)
    {
        inventTransferLine.QtyRemainReceive = _inventQty * this.transSign();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the receive date of the <see cref="T:InventTransferLine" /> of this movement.
    /// </summary>
    /// <returns>
    ///    The receive date of the <c>InventTransferline</c> of this movement.
    /// </returns>
    public TransDate transDate()
    {
        return inventTransferLine.ReceiveDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferDirection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the direction of the transfer movements.
    /// </summary>
    /// <returns>
    ///    The direction of the transfer movements.
    /// </returns>
    public InventDirection transferDirection()
    {
        return InventDirection::Receipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferInventTransOriginId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves an ID of transfer counterpart inventory transaction originator that corresponds to the
    ///    movement.
    /// </summary>
    /// <returns>
    ///    The ID of a transfer counterpart inventory transaction originator that corresponds to the movement.
    /// </returns>
    public InventTransOriginId transferInventTransOriginId()
    {
        return InventTransOrigin::findByInventTransId(inventTransferLine.InventTransIdTransitFrom).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferIssueCostPriceInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    For a transfer issue the inventory dimension are returned.
    /// </summary>
    /// <returns>
    ///    The inventory dimension where the transfer was issued.
    /// </returns>
    /// <remarks>
    ///    Only the inventory dimension of the originating buffer are returned.
    /// </remarks>
    public InventDim transferIssueCostPriceInventDim()
    {
        return this.inventDimFrom();
    }

]]></Source>
			</Method>
			<Method>
				<Name>transId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>InventTransIdReceive</c> of the <see cref="T:InventTransferLine" /> of this movement.
    /// </summary>
    /// <returns>
    ///    The <c>InventTransIdReceive</c> of the <c>InventTransferLine</c> of this movement.
    /// </returns>
    public InventTransId transId()
    {
        return inventTransferLine.InventTransIdReceive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSign</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>transSign</c> representing the direction of this transaction.
    /// </summary>
    /// <returns>
    ///    Returns 1.
    /// </returns>
    public Integer transSign()
    {
        return 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>InventTransType</c> of this movement.
    /// </summary>
    /// <returns>
    ///    <c>InventTransType::TransferOrderReceive</c>.
    /// </returns>
    public InventTransType transType()
    {
        return InventTransType::TransferOrderReceive;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromInventTransferLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>InventMov_TransferTo</c> class based on the specified record.
    /// </summary>
    /// <param name="_inventTransferLine">
    ///    The record in the <c>InventTransferLine</c> table for which the class is instantiated.
    /// </param>
    /// <param name="_inventType">
    ///    The associated <c>InventType</c> class.
    /// </param>
    /// <returns>
    ///    An instance of the <c>InventMov_TransferTo</c> class.
    /// </returns>
    public static InventMov_TransferTo newFromInventTransferLine(
        InventTransferLine      _inventTransferLine,
        InventType              _inventType         = new InventType(_inventTransferLine))
    {
        InventMov_TransferTo    movement = new InventMov_TransferTo(_inventTransferLine, _inventType);
        movement.inventMovSubType(InventMovSubType::TransferReceipt);
        return movement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventTableCostPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the movement can update the cost price on the related <c>InventTable</c> table.
    /// </summary>
    /// <returns>
    ///    Returns true if the site dimensions are different; otherwise, returns false.
    /// </returns>
    public boolean mustUpdateInventTableCostPrice()
    {
        if (inventTransferLine.inventDimShip().InventSiteId != inventTransferLine.inventDimReceive().InventSiteId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncEstimatedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronize dimensions on the expected receipts to match the issue dimensions.
    /// </summary>
    /// <param name="_inventTransIdIssue">
    /// transfer issue LOT Id
    /// </param>
    /// <param name="_inventTransIdReceipt">
    /// transfer receipt LOT Id
    /// </param>
    /// <param name="_transferReceiptSubType">
    /// transfer order receipt or transfer journal receipt sub type
    /// </param>
    /// <param name="_transferLineBuffer">
    /// transfer order or transfer journal line
    /// </param>
    public static void syncEstimatedTransactions(
		InventTransId      _inventTransIdIssue,
        InventTransId      _inventTransIdReceipt,
        InventMovSubType   _transferReceiptSubType,
        Common             _transferLineBuffer)
    {
        Map                     expectedIssues                  = new Map(Types::String, Types::Container);  // Map of InventDimId and positive quantity
        Map                     expectedReceipts                = new Map(Types::String, Types::Container);  // Map of InventDimId and positive quantity
        InventMovement          transferReceiptMovement;        

        if (!(_transferReceiptSubType == InventMovSubType::TransferReceipt || _transferReceiptSubType == InventMovSubType::TransferOrderTo))
        {
            return;
        }

        transferReceiptMovement = InventMovement::construct(_transferLineBuffer, _transferReceiptSubType);

        Map inventDimIdToInventDimIdWithoutLicensePlateId = new Map(Types::String, Types::String); // Map of InventDimId and its InventDimId whose license plate id is cleaned up
        
        InventMov_TransferTo::buildExpectedMaps(_inventTransIdIssue, _inventTransIdReceipt, expectedIssues, expectedReceipts, inventDimIdToInventDimIdWithoutLicensePlateId);
        InventMov_TransferTo::removeMatches(expectedIssues, expectedReceipts, inventDimIdToInventDimIdWithoutLicensePlateId);
        InventMov_TransferTo::syncDimensions(expectedIssues, expectedReceipts, transferReceiptMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the Map.
    /// </summary>
    /// <param name = "_map">The Map.</param>
    /// <param name = "_inventDimId">The InventDimId.</param>
    /// <param name = "_qty">The invent qty.</param>
    /// <param name = "_cwQty">The catch weight qty.</param>
    private static void updateMap(
        Map         _map,
        InventDimId _inventDimId,
        InventQty   _qty,
        PdsCWQty    _cwQty)
    {
        InventQty   qty = 0;
        PdsCWQty    cwQty = 0;

        if (_map.exists(_inventDimId))
        {
            [qty, cwQty] = _map.lookup(_inventDimId);
        }
        qty += _qty;

        if (InventTransferSyncDimensionsConsiderCatchWeightQtyToggle::instance().isEnabled())
        {
            cwQty += _cwQty;
        }

        if (qty != 0)
        {
            _map.insert(_inventDimId, [qty, cwQty]);
        }
        else
        {
            if (qty != _qty)
            {
                // entry previously exist in map, but is now to be deleted
                _map.remove(_inventDimId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferedDimensions</Name>
				<Source><![CDATA[
    private static InventDimId transferedDimensions(InventDim _inventDim)
    {
        _inventDim.InventSiteId         = '';
        _inventDim.InventLocationId     = '';
        _inventDim.wmsLocationId        = '';
        // <GEERU>
        _inventDim.InventProfileId_RU   = '';
        // </GEERU>

        return InventDim::findOrCreate(_inventDim).InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferedDimensionsByCleanLP</Name>
				<Source><![CDATA[
    private static InventDimId transferedDimensionsByCleanLP(InventDim _inventDim)
    {
        _inventDim.InventSiteId         = '';
        _inventDim.InventLocationId     = '';
        _inventDim.wmsLocationId        = '';
        _inventDim.LicensePlateId       = '';
        // <GEERU>
        _inventDim.InventProfileId_RU   = '';
        // </GEERU>

        return InventDim::findOrCreate(_inventDim).InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExpectedIssues</Name>
				<Source><![CDATA[
    private static void addExpectedIssues(InventTransOriginId _origin, Map _expectedIssues, Map _inventDimIdToInventDimIdWithoutLicensePlateId)
    {
        InventTrans             inventTrans;
        InventDim               inventDims;

        if (_origin)
        {
             while select Qty, PdsCWQty, InventDimId from inventTrans
                order by StatusIssue desc
                where inventTrans.InventTransOrigin == _origin
                  &&  inventTrans.StatusReceipt     == StatusReceipt::None
                join inventDims
                    where inventDims.InventDimId == inventTrans.InventDimId
            {
                InventDimId inventDimIdByCleanLP;
                if (inventDims.LicensePlateId && _inventDimIdToInventDimIdWithoutLicensePlateId)
                {
                    inventDimIdByCleanLP = InventMov_TransferTo::transferedDimensionsByCleanLP(inventDims.data());
                }

                InventDimId inventDimIdOrigin = InventMov_TransferTo::transferedDimensions(inventDims);
                InventMov_TransferTo::updateMap(_expectedIssues, inventDimIdOrigin, -inventTrans.Qty, -inventTrans.PdsCWQty);
                if (inventDimIdByCleanLp)
                {
                    _inventDimIdToInventDimIdWithoutLicensePlateId.insert(inventDimIdOrigin, inventDimIdByCleanLP);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addExpectedRecipts</Name>
				<Source><![CDATA[
    private static void addExpectedRecipts(InventTransOriginId _origin, Map _expectedReceipts, Map _inventDimIdToInventDimIdWithoutLicensePlateId)
    {
        InventTrans             inventTrans;
        InventDim               inventDims;

        if (_origin)
        {
            boolean isRecvWMSLocationNotLPControlled;
            Set inventDimIdWithoutLP = new Set(Types::String);
            while select Qty, PdsCWQty, InventDimId from inventTrans
                where inventTrans.InventTransOrigin == _origin
                  &&  inventTrans.StatusIssue       == StatusIssue::None
                  &&  inventTrans.StatusReceipt     >= StatusReceipt::Ordered
                join inventDims
                    where inventDims.InventDimId == inventTrans.InventDimId
            {
                if (_inventDimIdToInventDimIdWithoutLicensePlateId &&
                    !_inventDimIdToInventDimIdWithoutLicensePlateId.empty())
                {
                    // Check license plate controll of location
                    WMSLocation wmsLocation = inventDims.WMSLocation();
                    if (!wmsLocation.LocProfileId || !wmsLocation.whsLocationIsLPControlled())
                    {
                        isRecvWMSLocationNotLPControlled = true;
                    }
                }

                InventDimId inventDimId = InventMov_TransferTo::transferedDimensions(inventDims);
                if (isRecvWMSLocationNotLPControlled && inventDims.LicensePlateId == '')
                {
                    inventDimIdWithoutLP.add(inventDimId);
                }

                InventMov_TransferTo::updateMap(_expectedReceipts, inventDimId, inventTrans.Qty, inventTrans.PdsCWQty);
            }

            // Remove value from map when its value does not contain receipt inventDim whose license plate Id is empty
            InventMov_TransferTo::removeUnMatchedInventDimId(_inventDimIdToInventDimIdWithoutLicensePlateId, inventDimIdWithoutLP);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeUnMatchedInventDimId</Name>
				<Source><![CDATA[
    private static void removeUnMatchedInventDimId(Map _inventDimIdToInventDimIdWithoutLicensePlateId, Set _inventDimIdWithoutLP)
    {       
        if (_inventDimIdToInventDimIdWithoutLicensePlateId && !_inventDimIdToInventDimIdWithoutLicensePlateId.empty())
        {
            Set mapkeySetDelete = new Set(Types::String);
            MapEnumerator enumerator = _inventDimIdToInventDimIdWithoutLicensePlateId.getEnumerator();
            while (enumerator.moveNext())
            {
                if (!_inventDimIdWithoutLP || !_inventDimIdWithoutLP.in(enumerator.currentValue()))
                {
                    mapkeySetDelete.add(enumerator.currentKey());
                }
            }
 
            SetEnumerator setEnumerator = mapkeySetDelete.getEnumerator();
            while (setEnumerator.moveNext())
            {
                _inventDimIdToInventDimIdWithoutLicensePlateId.remove(setEnumerator.current());
            } 
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeMatches</Name>
				<Source><![CDATA[
    private static void removeMatches(Map _expectedIssues, Map _expectedReceipts, Map _inventDimIdToInventDimIdWithoutLicensePlateId)
    {
        // Remove entries already matching
        boolean         removedAny;
        MapEnumerator   mapEnumeratorIssue;
        InventQty       expectedIssueQty;
        PdsCWQty        expectedIssueCWQty;
        InventQty       expectedReceiptQty;
        PdsCWQty        expectedReceiptCWQty;
        InventQty       matchedQty;
        PdsCWQty        matchedCWQty;
        InventDimId     inventDimId;
        InventDimId     inventDimIdWithoutLP;
        InventDimId     inventDimIdReceipt;

        do
        {
            removedAny = false;
            if (_expectedIssues.elements())
            {
                mapEnumeratorIssue = _expectedIssues.getEnumerator();
                while (mapEnumeratorIssue.moveNext())
                {
                    inventDimId = mapEnumeratorIssue.currentKey();
                    [expectedIssueQty, expectedIssueCWQty] = mapEnumeratorIssue.currentValue();

                    if (!_expectedReceipts.exists(inventDimId) &&
                        _inventDimIdToInventDimIdWithoutLicensePlateId &&
                        _inventDimIdToInventDimIdWithoutLicensePlateId.exists(inventDimId))
                    {
                        inventDimIdWithoutLP = _inventDimIdToInventDimIdWithoutLicensePlateId.lookup(inventDimId);
                    }

                    if (_expectedReceipts.exists(inventDimId) || (inventDimIdWithoutLP && _expectedReceipts.exists(inventDimIdWithoutLP)))
                    {
                        if (_expectedReceipts.exists(inventDimId))
                        {
                            [expectedReceiptQty, expectedReceiptCWQty] = _expectedReceipts.lookup(inventDimId);
                            inventDimIdReceipt = inventDimId;
                        }
                        else
                        {
                            // Try with the inventory dimension without license plate Id
                            [expectedReceiptQty, expectedReceiptCWQty] = _expectedReceipts.lookup(inventDimIdWithoutLP);
                            inventDimIdReceipt = inventDimIdWithoutLP;
                        }

                        matchedQty = min(expectedIssueQty, expectedReceiptQty);
                        if (InventTransferSyncDimensionsConsiderCatchWeightQtyToggle::instance().isEnabled())
                        {
                            matchedCWQty = min(expectedIssueCWQty, expectedReceiptCWQty);
                        }
                        removedAny = true; // Need to restart iterating as enumerator probably has been invalidated by updateMap
                        mapEnumeratorIssue = null;
                        InventMov_TransferTo::updateMap(_expectedIssues, inventDimId, -matchedQty, -matchedCWQty);
                        InventMov_TransferTo::updateMap(_expectedReceipts, inventDimIdReceipt, -matchedQty, -matchedCWQty);
                        break;
                    }
                }
            }
        }
        while (removedAny);
    }

]]></Source>
			</Method>
			<Method>
				<Name>changeReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Changed the reservation with dimensions.
    /// </summary>
    /// <param name = "_fromDimensions">The from dimensions.</param>
    /// <param name = "_toDimensions">The to dimensions.</param>
    /// <param name = "_qty">The qty.</param>
    /// <param name = "_transferReceiptMovement">The Invent movement</param>
    /// <param name = "_cwQty">The catch weight qty.</param>
    private static void changeReservation(
        InventDimId    _fromDimensions,
        InventDimId    _toDimensions,
        InventQty      _qty,
        InventMovement _transferReceiptMovement,
        PdsCWQty       _cwQty = 0)
    { 
        InventDim                   inventDimFrom   = InventDim::find(_fromDimensions);
        InventDim                   inventDimTo     = InventDim::find(_toDimensions);
        InventDimParm               inventDimParmFrom;
        InventUpd_ChangeDimension   inventUpd_ChangeDimension;

        inventDimParmFrom.setAllInventDim();
        inventDimParmFrom.InventSiteIdFlag      = NoYes::No;
        inventDimParmFrom.InventLocationIdFlag  = NoYes::No;
        inventDimParmFrom.wmsLocationIdFlag     = NoYes::No;
        // <GEERU>
        inventDimParmFrom.InventProfileIdFlag_RU = NoYes::No;
        // </GEERU>

        inventDimTo = _transferReceiptMovement.inventDimMerged(inventDimTo);
        inventUpd_ChangeDimension = InventUpd_ChangeDimension::newParameters(_transferReceiptMovement, inventDimFrom, inventDimParmFrom, inventDimTo, _qty, _cwQty);
        inventUpd_ChangeDimension.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>firstMapElement</Name>
				<Source><![CDATA[
    private static container firstMapElement(Map _map)
    {
        MapEnumerator   mapEnumerator;
        InventDimId     dimId;
        InventQty       qty;
        PdsCWQty        cwQty;

        mapEnumerator = _map.getEnumerator();
        if (!mapEnumerator.moveNext())
        {
            return ['', 0, 0];
        }
        dimId = mapEnumerator.currentKey();
        [qty, cwQty] = mapEnumerator.currentValue();
        mapEnumerator = null; // Release all references as they might become invalid if element is removed
        return [dimId, qty, cwQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Synchronize dimensions.
    /// </summary>
    /// <param name = "_expectedIssues">Map of InventDimId and positive quantity.</param>
    /// <param name = "_expectedReceipts">Map of InventDimId and positive quantity.</param>
    /// <param name = "_transferReceiptMovement">Invent movement journal.</param>
    private static void syncDimensions(
        Map            _expectedIssues,
        Map            _expectedReceipts,
        InventMovement _transferReceiptMovement)
    {
        // Update dimensions
        boolean         syncedAny;
        InventQty       matchedQty;
        PdsCWQty        matchedCWQty;
        InventQty       expectedIssueQty;
        PdsCWQty        expectedIssueCWQty;
        InventQty       expectedReceiptQty;
        PdsCWQty        expectedReceiptCWQty;
        InventDimId     inventDimId;
        InventDimId     inventDimIdReceipt;

        do
        {
            syncedAny = false;
            if (_expectedIssues.elements() && _expectedReceipts.elements())
            {
                [inventDimId, expectedIssueQty, expectedIssueCWQty] = InventMov_TransferTo::firstMapElement(_expectedIssues);
                [inventDimIdReceipt, expectedReceiptQty, expectedReceiptCWQty] = InventMov_TransferTo::firstMapElement(_expectedReceipts);
                matchedQty = min(expectedIssueQty, expectedReceiptQty);
                matchedCWQty = 0;
                if (InventTransferSyncDimensionsConsiderCatchWeightQtyToggle::instance().isEnabled())
                {
                    matchedCWQty = min(expectedIssueCWQty, expectedReceiptCWQty);
                }

                InventMov_TransferTo::changeReservation(inventDimIdReceipt, inventDimId, matchedQty, _transferReceiptMovement, matchedCWQty);
                InventMov_TransferTo::updateMap(_expectedIssues, inventDimId, -matchedQty, -matchedCWQty);
                InventMov_TransferTo::updateMap(_expectedReceipts, inventDimIdReceipt, -matchedQty, -matchedCWQty);
                syncedAny = true;
            }
        }
        while (syncedAny);
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildExpectedMaps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Build the expected Maps.
    /// </summary>
    /// <param name = "_inventTransIdIssue">transfer issue LOT Id.</param>
    /// <param name = "_inventTransIdReceipt">transfer receipt LOT Id.</param>
    /// <param name = "_expectedIssues">
    /// An <c>InventTransId</c> value of the inventory transaction originator.
    /// </param>
    /// <param name = "_expectedReceipts">
    /// An <c>InventTransId</c> value of the inventory transaction originator.
    /// </param>
    /// <param name = "_inventDimIdToInventDimIdWithoutLicensePlateId">
    /// An <c>Map</c> value of InventDimId to its related InventDimId whose license plate id is cleaned.
    /// </param>
    private static void buildExpectedMaps(
        InventTransId      _inventTransIdIssue,
        InventTransId      _inventTransIdReceipt,
        Map                _expectedIssues,
        Map                _expectedReceipts,
        Map                _inventDimIdToInventDimIdWithoutLicensePlateId)
    {
        InventTransOrigin       inventTransOriginIssue          = InventTransOrigin::findByInventTransId(_inventTransIdIssue);
        InventTransOrigin       inventTransOriginReceipt        = InventTransOrigin::findByInventTransId(_inventTransIdReceipt);

        InventMov_TransferTo::addExpectedIssues(inventTransOriginIssue.RecId, _expectedIssues, _inventDimIdToInventDimIdWithoutLicensePlateId);
        InventMov_TransferTo::addExpectedRecipts(inventTransOriginReceipt.RecId, _expectedReceipts, _inventDimIdToInventDimIdWithoutLicensePlateId);       // Not received yet
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>