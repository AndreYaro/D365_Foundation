<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjectPosting</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjectPosting
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accruedRevenueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project the accrue revenue ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record of the <c>_projFundingSource</c> table.
    /// </param>
    /// <returns>
    /// The project accrue revenue ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount accruedRevenueLedgerDimension(ProjTable _projTable, ProjCategory _projCategory, ProjFundingSource _projFundingSource)
    {
        LedgerDimensionDefaultAccount   debitAccountSalesAccruedLedgerDimension;
        ProjTrans_Virtual               projTrans_Virtual;

        projTrans_Virtual = ProjTrans_Virtual::construct();

        projTrans_Virtual.setProjId(_projTable.ProjId);
        projTrans_Virtual.setCategoryId(_projCategory.CategoryId);

        ProjTaxGroupParameters insertParameters = ProjTaxGroupParameters::current();
        if (insertParameters)
        {
            projTrans_Virtual.setTaxGroup(insertParameters.projTaxGroup());
        }

        changecompany (
                       _projTable.company()
                       )
        {
            debitAccountSalesAccruedLedgerDimension = projTrans_Virtual.salesValueAccountLedgerDimension(_projFundingSource.RecId);
        }

        return debitAccountSalesAccruedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedRevenueOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project accrue revenue offset ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record of the <c>_projFundingSource</c> table.
    /// </param>
    /// <returns>
    /// The project accrue revenue offset ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount accruedRevenueOffsetLedgerDimension(ProjTable _projTable, ProjCategory _projCategory, ProjFundingSource _projFundingSource)
    {
        LedgerDimensionDefaultAccount   creditAccountSalesAccruedLedgerDimension;
        ProjTrans_Virtual               projTrans_Virtual;

        projTrans_Virtual = ProjTrans_Virtual::construct();

        projTrans_Virtual.setProjId(_projTable.ProjId);
        projTrans_Virtual.setCategoryId(_projCategory.CategoryId);

        ProjTaxGroupParameters insertParameters = ProjTaxGroupParameters::current();
        if (insertParameters)
        {
            projTrans_Virtual.setTaxGroup(insertParameters.projTaxGroup());
        }

        changecompany (
                       _projTable.company()
                       )
        {
            creditAccountSalesAccruedLedgerDimension = projTrans_Virtual.salesOffsetAccountLedgerDimension(_projFundingSource.RecId);
        }

        return creditAccountSalesAccruedLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedRevenueOffsetPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project accrue revenue offset posting type.
    /// </summary>
    /// <returns>
    /// The project accrue revenue offset posting type
    /// </returns>
    public static LedgerPostingType accruedRevenueOffsetPostingType()
    {
        //WIP Sales Value
        LedgerPostingType postingTypeOffsetTurnoverAccrued = LedgerPostingType::ProjSalesvalueOffset;

        return postingTypeOffsetTurnoverAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accruedRevenuePostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project accrue revenue posting type.
    /// </summary>
    /// <returns>
    /// The project accrue revenue posting type
    /// </returns>
    public static LedgerPostingType accruedRevenuePostingType()
    {
        //Accrued Revenue Sales Value
        LedgerPostingType   postingTypeTurnoverAccrued = LedgerPostingType::ProjSalesvalue;

        return postingTypeTurnoverAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAccrueRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the project revenue can be accrued.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_transactionCurrencySalesAmount">
    /// The transaction currency sales amount value.
    /// </param>
    /// <param name="_fundingSource">
    /// The funding source id of the current transaction. Optional.
    /// </param>
    /// <returns>
    /// true if the project revenue can be accrued; otherwise false
    /// </returns>
    [SysObsolete('This method will be deprecated. Please use ProjectPosting::canAccrueRevenueV2 instead.', false, 27\06\2024)]
    public static boolean canAccrueRevenue( ProjTable               _projTable,
                                            ProjCategory            _projCategory,
                                            ProjLineProperty        _projLineProperty,
                                            AmountCur               _transactionCurrencySalesAmount,
                                            ProjFundingSourceRefId  _fundingSource = 0)
    {
        NoYes               parmEnterSalesAccrued;
        boolean             canBeAccrued;
        boolean             checkEnterSalesAccrued;
        ProjFundingSource   projFundingSource;
        
        changecompany (_projTable.company())
        {
            projFundingSource = ProjFundingSource::find(_fundingSource);
        }
        
        boolean isProjWIPPostingFlightEnabled = ProjWIPPostingAndReversalFlight::instance().isEnabled();
    
        // If flight enabled and contractlineNum is present then call canAccrueRevenueV2
        if (isProjWIPPostingFlightEnabled)
        {
            ProjectPostingParameters projPostingParameters = ProjectPostingParameters::current();
            PSAContractLineNum contractLineNum = '';

            if (projPostingParameters)
            {
                contractLineNum = projPostingParameters.ProjContractLineNum();
            }

            // If WIP Posting is enabled, look for contract line based on transaction type.
            // If canAccruedRevenueV2 is not called and the flight is enabled, that means,
            //      contractlineId is not passed as parameter, so at this point, contractLineNum = ''
            // Hence, if the flight is enabled, system will make one last try to get contractLineNum based on Transaction Type.     
            if (!contractLineNum)
            {
                ProjTransType projTransType = _projCategory.getProjectTransType();
                contractLineNum = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(
                            _projTable.ProjId,
                            _projTable.ProjInvoiceProjId,
                            projTransType).ContractLineNum;
            }

            return ProjectPosting::canAccrueRevenueV2(_projTable,
                    _projCategory,
                    _projLineProperty,
                    _transactionCurrencySalesAmount,
                    contractLineNum,
                    projFundingSource);
        }

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Cost:
                if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                {
                    parmEnterSalesAccrued = NoYes::No;
                }
                else
                {
                    parmEnterSalesAccrued = ProjRevRecHelper::postWIPCostForProject(_projTable);
                }
                break;
            case ProjCategoryType::Item:
                if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                {
                    parmEnterSalesAccrued = NoYes::No;
                }
                else
                {
                    parmEnterSalesAccrued = ProjRevRecHelper::postWIPItemForProject(_projTable);
                }
                break;
            case ProjCategoryType::Revenue:
                if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                {
                    parmEnterSalesAccrued = NoYes::No;
                }
                else
                {
                    parmEnterSalesAccrued = ProjRevRecHelper::postWIPFeeForProject(_projTable);
                }
                break;
            case ProjCategoryType::Hour:
                // If this condition fails, the SYS logic needs to fall to default so this should be the last case before default
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    || isConfigurationkeyEnabled(configurationKeyNum(Project))
                    || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration)))
                {
                    if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        parmEnterSalesAccrued = NoYes::No;
                    }
                    else
                    {
                        parmEnterSalesAccrued = ProjRevRecHelper::postWIPEmplForProject(_projTable);
                    }
                    break;
                }
            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        canBeAccrued = (_projLineProperty.ToBeAccrued ? true : false);

        if (canBeAccrued)
        {         
            canBeAccrued = ProjInvoiceTable::isBillingRuleInvoiceable(_projTable.ProjId, _projCategory.CategoryId, '');
        }

        checkEnterSalesAccrued = parmEnterSalesAccrued &&
            canBeAccrued &&
            _transactionCurrencySalesAmount;

        if (checkEnterSalesAccrued)
        {
            if ((projFundingSource.FundingType == ProjFundingType::Organization) ||
                (projFundingSource.FundingType == ProjFundingType::OnHoldFundingSource))
            {
                checkEnterSalesAccrued =  false;
            }
        }

        return checkEnterSalesAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProjTrans_Virtual</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the instance variables for ProjTrans_Virtual.
    /// </summary>
    /// <param name="_projTable">
    ///     A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    ///     A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    ///     Whether the ledger dimension is for an intercompany transaction; optional.
    /// </param>
    /// <returns>
    ///     The instance of ProjTrans_Virtual.
    /// </returns>
    public static ProjTrans_Virtual initProjTrans_Virtual(ProjTable     _projTable,
                                                          ProjCategory  _projCategory,
                                                          boolean       _isIntercompany = false)
    {
        
        ProjTrans_Virtual projTrans_Virtual = ProjTrans_Virtual::construct();
        projTrans_Virtual.setProjId(_projTable.ProjId);
        projTrans_Virtual.setCategoryId(_projCategory.CategoryId);
        projTrans_Virtual.setIntercompany(_isIntercompany);

        // Get the lending legal entity from the cache.
        SysGlobalCache cache = appl.globalCache();
        str cacheKey = _projTable.ProjId + ':' + _projCategory.CategoryId + ':' + _projTable.DataAreaId;

        if (_isIntercompany && cache.isSet(classStr(ProjIntercompanyVendorInvoiceCreator), cacheKey))
        {
            DataAreaId  lendingLegalEntity = cache.get(classStr(ProjIntercompanyVendorInvoiceCreator), cacheKey);
            projTrans_Virtual.setLendingLegalEntity(lendingLegalEntity);
        }
        else if (_isIntercompany && cache.isSet(classStr(AccDistProcessorProjectExtension), cacheKey))
        {
            DataAreaId lendingLegalEntity = cache.get(classStr(AccDistProcessorProjectExtension), cacheKey);
            projTrans_Virtual.setLendingLegalEntity(lendingLegalEntity);
        }
        else
        {
            projTrans_Virtual.setLendingLegalEntity(curExt());
        }
        return projTrans_Virtual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costLedgerDimensionFromContractLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record in the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_contractLineItems">
    /// A record of the <c>PSAContractLineItems</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the ledger dimension is for an intercompany transaction; optional.
    /// </param>
    /// <returns>
    /// The project cost ledger dimension.
    /// </returns>
    private static LedgerDimensionDefaultAccount costLedgerDimensionFromContractLines(ProjTable           _projTable,
                                                                    ProjCategory        _projCategory,
                                                                    ProjFundingSource   _projFundingSource,
                                                                    ProjLineProperty    _projLineProperty,
                                                                    PSAContractLineItems _contractLineItems,
                                                                    boolean             _isIntercompany = false)
    {
        ProjLedgerStatus costLedgerStatus = ProjectPosting::costLedgerStatusFromPSAContractLineItems(_projTable, _projCategory, _projLineProperty, _contractLineItems);

        return ProjectPosting::getDefaultDebitAccountValue(_projTable, _projCategory, _projFundingSource, costLedgerStatus, _isIntercompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultDebitAccountValue</Name>
				<Source><![CDATA[
    public static LedgerDimensionDefaultAccount getDefaultDebitAccountValue(ProjTable _projTable, ProjCategory _projCategory, ProjFundingSource   _projFundingSource, ProjLedgerStatus _costLedgerStatus, boolean _isIntercompany)
    {
       
        LedgerDimensionDefaultAccount   debitAccountCostValueLedgerDimension;
        ProjTrans_Virtual               projTrans_Virtual = ProjectPosting::initProjTrans_Virtual(_projTable, _projCategory, _isIntercompany);

        changecompany (_projTable.company())
        {
            switch (_projCategory.CategoryType)
            {
                case ProjCategoryType::Cost:
                    switch (_costLedgerStatus)
                    {
                        case ProjLedgerStatus::BalanceSheet:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.statusAccountLedgerDimension(_projFundingSource.RecId);
                            break;
                        case ProjLedgerStatus::Operations:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.costAccountLedgerDimension(_projFundingSource.RecId);
                            break;
                        case ProjLedgerStatus::Never:
                        case ProjLedgerStatus::None:
                            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                            {
                                debitAccountCostValueLedgerDimension = projTrans_Virtual.costAccountLedgerDimension(_projFundingSource.RecId);
                            }
                            else
                            {
                                throw error(strFmt("@SYS22828",funcName()));
                            }
                            break;
                        default:
                            if (ProjectPosting::shouldThrowInvalidCostLedgerStatusErrorForCosts(_costLedgerStatus))
                            {
                                throw error(strFmt("@SYS22828",funcName()));
                            }
                    }
                    break;
                case ProjCategoryType::Hour:
                    switch (_costLedgerStatus)
                    {
                        case ProjLedgerStatus::BalanceSheet:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.statusAccountLedgerDimension(_projFundingSource.RecId);
                            break;
                        case ProjLedgerStatus::Operations:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.costAccountLedgerDimension(_projFundingSource.RecId);
                            break;
                        case ProjLedgerStatus::Never:
                        case ProjLedgerStatus::None:
                            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                            {
                                debitAccountCostValueLedgerDimension = projTrans_Virtual.costAccountLedgerDimension(_projFundingSource.RecId);
                            }
                            else
                            {
                                throw error(strFmt("@SYS22828",funcName()));
                            }
                            break;
                        default:
                            if (ProjectPosting::shouldThrowInvalidCostLedgerStatusErrorForHours(_costLedgerStatus))
                            {
                                throw error(strFmt("@SYS22828",funcName()));
                            }
                    }
                    break;
                case ProjCategoryType::Item:
                    switch (_costLedgerStatus)
                    {
                        case ProjLedgerStatus::BalanceSheet:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.statusAccountItemLedgerDimension(_projFundingSource.RecId);
                            break;
                        case ProjLedgerStatus::Operations:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.costAccountLedgerDimension(_projFundingSource.RecId);
                            break;
                        case ProjLedgerStatus::Never:
                            if (FeatureStateProvider::isFeatureEnabled(ProjEnableSubcontractActualsPostingFeature::instance()))
                            {
                                debitAccountCostValueLedgerDimension = projTrans_Virtual.costAccountLedgerDimension(_projFundingSource.RecId);
                            }
                            else
                            {
                                throw error(strFmt("@SYS22828",funcName()));
                            }
                            break;
                        default:
                            if (ProjectPosting::shouldThrowInvalidCostLedgerStatusErrorForItems(_costLedgerStatus))
                            {
                                throw error(strFmt("@SYS22828",funcName()));
                            }
                    }
                    break;
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
        }

        return debitAccountCostValueLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record in the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the ledger dimension is for an intercompany transaction; optional.
    /// </param>
    /// <returns>
    /// The project cost ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount costLedgerDimension(ProjTable           _projTable,
                                                                    ProjCategory        _projCategory,
                                                                    ProjFundingSource   _projFundingSource,
                                                                    ProjLineProperty    _projLineProperty,
                                                                    boolean             _isIntercompany = false)
    {
        ProjLedgerStatus costLedgerStatus = ProjectPosting::costLedgerStatus(_projTable, _projCategory, _projLineProperty);
        return ProjectPosting::getDefaultDebitAccountValue(_projTable, _projCategory, _projFundingSource, costLedgerStatus, _isIntercompany);

    }

]]></Source>
			</Method>
			<Method>
				<Name>costLedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the project cost ledger status.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <returns>
    /// A project cost ledger status.
    /// </returns>
    public static ProjLedgerStatus costLedgerStatus(ProjTable _projTable, ProjCategory _projCategory, ProjLineProperty _projLineProperty)
    {
        ProjLedgerStatus parmLedgerStatusCost;
        ProjTransType transType;

        changecompany (_projTable.company())
        {
            switch (_projCategory.CategoryType)
            {
                case ProjCategoryType::Cost:
                    transType = ProjTransType::Cost;

                    if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        // Internal project, post cost to P/L accounts.
                        parmLedgerStatusCost = ProjLedgerStatus::Operations;
                    }
                    else
                    {
                        parmLedgerStatusCost = ProjRevRecHelper::getCostLedgerStatus(_projTable);
                    }
                    break;
                case ProjCategoryType::Item:
                    transType = ProjTransType::Item;
                    
                    if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                    {
                        // Internal project, post cost to P/L accounts.
                        parmLedgerStatusCost = ProjLedgerStatus::Operations;
                    }
                    else
                    {
                        parmLedgerStatusCost = ProjRevRecHelper::getItemLedgerStatus(_projTable);
                    }
                    break;
                case ProjCategoryType::Hour:
                    transType = ProjTransType::Hour;

                    // If this condition fails, the SYS logic needs to fall to default so this should be the last case before default
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                        || isConfigurationkeyEnabled(configurationKeyNum(Project))
                        || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration)))
                    {
                        if (!_projTable.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                        {
                            // Internal project, post cost to P/L accounts.
                            parmLedgerStatusCost = ProjLedgerStatus::Operations;
                        }
                        else
                        {
                            parmLedgerStatusCost = ProjRevRecHelper::getEmplLedgerStatus(_projTable);
                        }
                        break;
                    }
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }

            if (parmLedgerStatusCost == ProjLedgerStatus::BalanceSheet)
            {
                if (_projLineProperty.ToBeCapitalize)
                {
                    if (ProjTable::isPLPostingRequiredForTransType(_projTable.ProjId, transType))
                    {
                        parmLedgerStatusCost = ProjLedgerStatus::Operations;
                    }
                }
                else
                {
                    parmLedgerStatusCost = ProjLedgerStatus::Operations;
                }
            }
        }

        return parmLedgerStatusCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost posting type.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the posting type is for an intercompany transaction.
    /// </param>
    /// <returns>
    /// The project cost posting type.
    /// </returns>
    public static LedgerPostingType costPostingType(ProjTable           _projTable,
                                                    ProjCategory        _projCategory,
                                                    ProjLineProperty    _projLineProperty,
                                                    boolean             _isIntercompany = false)
    {
        ProjLedgerStatus    costLedgerStatus;
        LedgerPostingType   postingTypeCost;

        costLedgerStatus = ProjectPosting::costLedgerStatus(_projTable, _projCategory, _projLineProperty);
        return ProjectPosting::costPostingTypeFromLedgerStatus(costLedgerStatus, _projCategory, _isIntercompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getContractLineItems</Name>
				<Source><![CDATA[
    protected static PSAContractLineItems getContractLineItems(ProjTable _projTable, ProjAdvancedJournalSourceDocumentLineItem _projOpsAdvancedJournalSourceDocumentLineItem)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectLedgerDimensionFromContractLinesProjOps</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record in the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_projOpsAdvancedJournalSourceDocumentLineItem">
    ///  Subledger journal line of a <c>ProjAdvancedJournalLine</c> table record.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the ledger dimension is for an intercompany transaction; optional.
    /// </param>
    /// <returns>
    /// The project ledger dimension.
    /// </returns>
    private static LedgerDimensionDefaultAccount getProjectLedgerDimensionFromContractLinesProjOps(ProjTable _projTable,
                                                                          ProjCategory      _projCategory,
                                                                          ProjFundingSource _projFundingSource,
                                                                          ProjLineProperty  _projLineProperty,
                                                                          ProjAdvancedJournalSourceDocumentLineItem _projOpsAdvancedJournalSourceDocumentLineItem,
                                                                          boolean           _isIntercompany = false)
    {
        LedgerDimensionDefaultAccount defaultLedgerDimension;
        PSAContractLineItems contractLineItems = ProjectPosting::getContractLineItems(_projTable, _projOpsAdvancedJournalSourceDocumentLineItem);

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Cost:
            case ProjCategoryType::Item:
            case ProjCategoryType::Hour:
                if ((isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                        || isConfigurationkeyEnabled(configurationKeyNum(Project))
                        || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                        && _projCategory.CategoryType == ProjCategoryType::Hour)
                        || _projCategory.CategoryType == ProjCategoryType::Cost
                        || _projCategory.CategoryType == ProjCategoryType::Item)
                {
                    defaultLedgerDimension = ProjectPosting::costLedgerDimensionFromContractLines(
                                                    _projTable,
                                                    _projCategory,
                                                    _projFundingSource,
                                                    _projLineProperty,
                                                    contractLineItems,
                                                    _isIntercompany);
                }
                else
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
                break;
            case ProjCategoryType::Revenue:
                defaultLedgerDimension = ProjectPosting::invoicedRevenueLedgerDimension(
                                                _projTable,
                                                _projCategory,
                                                _projFundingSource);
                break;
            default:
                throw error(strFmt("@SYS22828", funcName()));
        }

        return defaultLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectLedgerDimensionWhenProjOpsIntegrationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project ledger dimension for scenario when project operations integration is enabled.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record in the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_topSourceDocumentLineItem">
    ///  The source document line.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the ledger dimension is for an intercompany transaction; optional.
    /// </param>
    /// <returns>
    /// The project ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount getProjectLedgerDimensionWhenProjOpsIntegrationEnabled(ProjTable _projTable,
                                                                                                ProjCategory _projCategory,
                                                                                                ProjFundingSource _projFundingSource,
                                                                                                ProjLineProperty _projLineProperty,
                                                                                                SourceDocumentLineItem _topSourceDocumentLineItem,
                                                                                                boolean _isIntercompany = false)
    {
        if (_topSourceDocumentLineItem is ProjAdvancedJournalSourceDocumentLineItem)
        {
            ProjAdvancedJournalSourceDocumentLineItem projAdvJournalSourceDocumentLineItem = _topSourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem;
            ProjAdvancedJournalLine projAdvJournalLine = projAdvJournalSourceDocumentLineItem.parmProjAdvancedJournalLine();

            if (projAdvJournalLine.shouldProcessSubcontractLineAsNeverLedger())
            {
                return ProjectPosting::getDefaultDebitAccountValue(_projTable, _projCategory, _projFundingSource, ProjLedgerStatus::Never, _isIntercompany);
            }
            else
            {
                return ProjectPosting::getProjectLedgerDimensionFromContractLinesProjOps(_projTable,
                                                                                _projCategory,
                                                                                _projFundingSource,
                                                                                _projLineProperty,
                                                                                projAdvJournalSourceDocumentLineItem,
                                                                                _isIntercompany);
            }
        }
        else
        {
            return ProjectPosting::getProjectLedgerDimensionFromContractLinesProjOps(_projTable,
                                                                                _projCategory,
                                                                                _projFundingSource,
                                                                                _projLineProperty,
                                                                                _topSourceDocumentLineItem as ProjAdvancedJournalSourceDocumentLineItem,
                                                                                _isIntercompany);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record in the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the ledger dimension is for an intercompany transaction; optional.
    /// </param>
    /// <returns>
    /// The project ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount getProjectLedgerDimension(ProjTable         _projTable,
                                                                          ProjCategory      _projCategory,
                                                                          ProjFundingSource _projFundingSource,
                                                                          ProjLineProperty  _projLineProperty,
                                                                          boolean           _isIntercompany = false)
    {
        LedgerDimensionDefaultAccount   defaultLedgerDimension;

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Cost:
            case ProjCategoryType::Item:
            case ProjCategoryType::Hour:
                if ((isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                        || isConfigurationkeyEnabled(configurationKeyNum(Project))
                        || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                        && _projCategory.CategoryType == ProjCategoryType::Hour)
                        || _projCategory.CategoryType == ProjCategoryType::Cost
                        || _projCategory.CategoryType == ProjCategoryType::Item)
                {
                    defaultLedgerDimension = ProjectPosting::costLedgerDimension(
                                                    _projTable,
                                                    _projCategory,
                                                    _projFundingSource,
                                                    _projLineProperty,
                                                    _isIntercompany);
                }
                else
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
                break;
            case ProjCategoryType::Revenue:
                defaultLedgerDimension = ProjectPosting::invoicedRevenueLedgerDimension(
                                                _projTable,
                                                _projCategory,
                                                _projFundingSource);
                break;
            default:
                throw error(strFmt("@SYS22828", funcName()));
        }

        return defaultLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project posting type.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the posting type is for an intercompany transaction.
    /// </param>
    /// <returns>
    /// The project posting type
    /// </returns>
    public static LedgerPostingType getProjectPostingType(ProjTable         _projTable,
                                                          ProjCategory      _projCategory,
                                                          ProjLineProperty  _projLineProperty,
                                                          boolean           _isIntercompany = false)
    {
        LedgerPostingType postingType;

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Cost:
            case ProjCategoryType::Item:
            case ProjCategoryType::Hour:
                if ((isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    || isConfigurationkeyEnabled(configurationKeyNum(Project))
                    || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                && _projCategory.CategoryType == ProjCategoryType::Hour)
                    || _projCategory.CategoryType == ProjCategoryType::Cost
                    || _projCategory.CategoryType == ProjCategoryType::Item)
                {
                    postingType = ProjectPosting::costPostingType(
                                    _projTable,
                                    _projCategory,
                                    _projLineProperty,
                                    _isIntercompany);
                }
                else
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
                break;
            case ProjCategoryType::Revenue:
                postingType = ProjectPosting::invoicedRevenuePostingType();
                break;
            default:
                throw error(strFmt("@SYS22828", funcName()));
        }

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAccrueRevenueWhenProjOpsIntegrationEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the project revenue can be accrued.
    /// </summary>
    /// <param name="_projTable">
    /// A record in the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record in the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record in the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_projAdvancedJournalLine">
    /// A record in the <c>ProjAdvancedJournalLine</c> table.
    /// </param>
    /// <param name="_transactionCurrencySalesAmount">
    /// The transaction currency sales amount value.
    /// </param>
    /// <param name="_fundingSource">
    /// The funding source id of the current transaction. Optional.
    /// </param>
    /// <returns>
    /// true if the project revenue can be accrued; otherwise false
    /// </returns>
    public static boolean canAccrueRevenueWhenProjOpsIntegrationEnabled(ProjTable _projTable,
                                                                        ProjCategory            _projCategory,
                                                                        ProjLineProperty        _projLineProperty,
                                                                        ProjAdvancedJournalLine _projAdvancedJournalLine,
                                                                        AmountCur               _transactionCurrencySalesAmount,
                                                                        ProjFundingSourceRefId  _fundingSource = 0
                                                                      )

    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjectPostingTypeFromPSAContractLineItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the project posting type when integration flag is enabled.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <param name="_projOpsAdvancedJournalSourceDocumentLineItem">
    /// A record of the <c>ProjAdvancedJournalSourceDocumentLineItem</c> table.
    /// </param>
    /// <param name="_isIntercompany">
    /// Whether the posting type is for an intercompany transaction; optional
    /// </param>
    /// <returns>
    /// The project posting type.
    /// </returns>
    public static LedgerPostingType getProjectPostingTypeFromPSAContractLineItems(ProjTable         _projTable,
                                                                                  ProjCategory      _projCategory,
                                                                                  ProjLineProperty  _projLineProperty,
                                                                                  ProjAdvancedJournalSourceDocumentLineItem _projOpsAdvancedJournalSourceDocumentLineItem,
                                                                                  boolean           _isIntercompany = false)
    {
        LedgerPostingType postingType;
        PSAContractLineItems contractLineItems = ProjectPosting::getContractLineItems(_projTable, _projOpsAdvancedJournalSourceDocumentLineItem);

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Cost:
            case ProjCategoryType::Item:
            case ProjCategoryType::Hour:
                    if ((isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                        || isConfigurationkeyEnabled(configurationKeyNum(Project))
                        || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration))
                    && _projCategory.CategoryType == ProjCategoryType::Hour)
                        || _projCategory.CategoryType == ProjCategoryType::Cost
                        || _projCategory.CategoryType == ProjCategoryType::Item)
                {
                    postingType = ProjectPosting::costPostingTypeFromPSAContractLineItems(_projTable,
                                    _projCategory,
                                    _projLineProperty,
                                    contractLineItems,
                                    _isIntercompany);
                }
                else
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
                break;
            case ProjCategoryType::Revenue:
                postingType = ProjectPosting::invoicedRevenuePostingType();
                break;
            default:
                throw error(strFmt("@SYS22828", funcName()));
        }
        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPostingTypeFromPSAContractLineItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project ledger posting type when intergration flag is enabled.
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c></param>
    /// <param name = "_projCategory"><c>ProjCategory</c></param>
    /// <param name = "_projLineProperty"><c>ProjLineProperty</c></param>
    /// <param name = "_psaContractLineItems"><c>PSAContractLineItems</c></param>
    /// <param name = "_isIntercompany">Whether the posting type is for an intercompany; optional</param>
    /// <returns>The project cost ledger status.</returns>
    public static LedgerPostingType costPostingTypeFromPSAContractLineItems(ProjTable         _projTable,
                                                                               ProjCategory      _projCategory,
                                                                               ProjLineProperty  _projLineProperty,
                                                                               PSAContractLineItems _psaContractLineItems,
                                                                               boolean           _isIntercompany = false)
    {
       

        ProjLedgerStatus costLedgerStatus = ProjectPosting::costLedgerStatusFromPSAContractLineItems(_projTable,
                                                                                                     _projCategory,
                                                                                                     _projLineProperty,
                                                                                                     _psaContractLineItems);

        return ProjectPosting::costPostingTypeFromLedgerStatus(costLedgerStatus, _projCategory, _isIntercompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>costPostingTypeFromLedgerStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost posting type.
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <param name = "_projCategory"><c>ProjCategory</c></param>
    /// <param name = "_isIntercompany">Whether the posting type is for an intercompany; optional</param>
    /// <returns>The project cost posting type.</returns>
    private static LedgerPostingType costPostingTypeFromLedgerStatus(ProjLedgerStatus _ledgerStatus, ProjCategory _projCategory, boolean _isIntercompany = false)
    {
        LedgerPostingType postingTypeCost;

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Cost:
                postingTypeCost = ProjectPosting::getCostPostingTypeForCosts(_ledgerStatus, _isIntercompany);
                break;
            case ProjCategoryType::Hour:
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    || isConfigurationkeyEnabled(configurationKeyNum(Project))
                    || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration)))
                {
                    postingTypeCost = ProjectPosting::getCostPostingTypeForHours(_ledgerStatus, _isIntercompany);
                }
                else
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
                break;
            case ProjCategoryType::Item:
                postingTypeCost = ProjectPosting::getCostPostingTypeForItems(_ledgerStatus, _isIntercompany);
                break;
            default:
                if (ProjectPosting::shouldThrowInvalidCatgoryTypeError(_projCategory.CategoryType))
                {
                    throw error(strFmt("@SYS22828",funcName()));
                }
        }

        return postingTypeCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowInvalidCatgoryTypeError</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether throwing CatgoryTypeError or not
    /// </summary>
    /// <param name = "_categoryType"><c>ProjCategoryType</c></param>
    /// <returns>true to show error, otherwise false</returns>
    protected static boolean shouldThrowInvalidCatgoryTypeError(ProjCategoryType _categoryType)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowInvalidCostLedgerStatusErrorForHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether to throw CostLedgerStatusError for hour
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <returns>true to throw error, otherwise false</returns>
    protected static boolean shouldThrowInvalidCostLedgerStatusErrorForHours(ProjLedgerStatus _ledgerStatus)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowInvalidCostLedgerStatusErrorForCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether to throw CostLedgerStatusError for cost
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <returns>true to throw error, otherwise false</returns>
    protected static boolean shouldThrowInvalidCostLedgerStatusErrorForCosts(ProjLedgerStatus _ledgerStatus)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldThrowInvalidCostLedgerStatusErrorForItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether to throw CostLedgerStatusError for item
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <returns>true to throw error, otherwise false</returns>
    protected static boolean shouldThrowInvalidCostLedgerStatusErrorForItems(ProjLedgerStatus _ledgerStatus)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostPostingTypeForHours</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost posting type for hours
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <param name = "_isIntercompany">Whether the posting type is for an intercompany; optional</param>
    /// <returns>The project cost posting type for hours.</returns>
    protected static LedgerPostingType getCostPostingTypeForHours(ProjLedgerStatus _ledgerStatus, boolean _isIntercompany)
    {
        LedgerPostingType ret;

        switch (_ledgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                ret = LedgerPostingType::ProjWIPCostvalue;
                break;
            case ProjLedgerStatus::Operations:
                if (_isIntercompany)
                {
                    ret = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ret = LedgerPostingType::ProjCost;
                }
                break;
            case ProjLedgerStatus::Never:
                if (_isIntercompany)
                {
                    ret = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ret = LedgerPostingType::ProjNeverLedger;
                }
                break;
            case ProjLedgerStatus::None:
                if (_isIntercompany)
                {
                    ret = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ret = LedgerPostingType::ProjNoLedger;
                }
                break;
            default:
                if (ProjectPosting::shouldThrowInvalidCostLedgerStatusErrorForHours(_ledgerStatus))
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostPostingTypeForCosts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost posting type for costs
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <param name = "_isIntercompany">Whether the posting type is for an intercompany; optional</param>
    /// <returns>The project cost posting type for costs.</returns>
    protected static LedgerPostingType getCostPostingTypeForCosts(ProjLedgerStatus _ledgerStatus, boolean _isIntercompany)
    {
        LedgerPostingType ret;

        switch (_ledgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                ret = LedgerPostingType::ProjWIPCostvalue;
                break;
            case ProjLedgerStatus::Operations:
                if (_isIntercompany)
                {
                    ret = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ret = LedgerPostingType::ProjCost;
                }
                break;
            case ProjLedgerStatus::Never:
                if (_isIntercompany)
                {
                    ret = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ret = LedgerPostingType::ProjNeverLedger;
                }
                break;
            case ProjLedgerStatus::None:
                if (_isIntercompany)
                {
                    ret = LedgerPostingType::IntercompanyCost;
                }
                else
                {
                    ret = LedgerPostingType::ProjNoLedger;
                }
                break;
            default:
                if (ProjectPosting::shouldThrowInvalidCostLedgerStatusErrorForCosts(_ledgerStatus))
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCostPostingTypeForItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost posting type for hours
    /// </summary>
    /// <param name = "_ledgerStatus"><c>ProjLedgerStatus</c></param>
    /// <param name = "_isIntercompany">Whether the posting type is for an intercompany; optional</param>
    /// <returns>The project cost posting type for items.</returns>
    protected static LedgerPostingType getCostPostingTypeForItems(ProjLedgerStatus _ledgerStatus, boolean _isIntercompany)
    {
        LedgerPostingType ret;

        switch (_ledgerStatus)
        {
            case ProjLedgerStatus::BalanceSheet:
                ret = LedgerPostingType::ProjStatusAccountItem;
                break;
            case ProjLedgerStatus::Operations:
                ret = LedgerPostingType::ProjCost;
                break;
            default:
                if (ProjectPosting::shouldThrowInvalidCostLedgerStatusErrorForItems(_ledgerStatus))
                {
                    throw error(strFmt("@SYS22828", funcName()));
                }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costLedgerStatusFromPSAContractLineItems</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project cost ledger status when intergration flag is enabled..
    /// </summary>
    /// <param name = "_projTable"><c>ProjTable</c></param>
    /// <param name = "_projCategory"><c>ProjCategory</c></param>
    /// <param name = "_projLineProperty"><c>ProjLineProperty</c></param>
    /// <param name = "_psaContractLineItems"><c>PSAContractLineItems</c></param>
    /// <returns>The project cost ledger status.</returns>
    private static ProjLedgerStatus costLedgerStatusFromPSAContractLineItems(ProjTable         _projTable,
                                                                            ProjCategory      _projCategory,
                                                                            ProjLineProperty  _projLineProperty,
                                                                            PSAContractLineItems _psaContractLineItems)
    {
        ProjLedgerStatus projLedgerStatus;
        ProjTransType transType;

        changecompany (_projTable.company())
        {
            switch (_projCategory.CategoryType)
            {
                case ProjCategoryType::Cost:
                    transType = ProjTransType::Cost;

                    if (!_projTable.ProjInvoiceProjId || !_psaContractLineItems)
                    {
                        // Internal project, post cost to P/L accounts.
                        projLedgerStatus = ProjLedgerStatus::Operations;
                    }
                    else
                    {
                        projLedgerStatus = ProjRevRecHelper::cost2LedgerStatus(ProjRevRecHelper::getRevProfileV2(_projTable, _psaContractLineItems).CostLedgerStatus);
                    }
                    break;
                case ProjCategoryType::Item:
                    transType = ProjTransType::Item;
                    
                    if (!_projTable.ProjInvoiceProjId || !_psaContractLineItems)
                    {
                        // Internal project, post cost to P/L accounts.
                        projLedgerStatus = ProjLedgerStatus::Operations;
                    }
                    else
                    {
                       
                        projLedgerStatus = ProjRevRecHelper::item2LedgerStatus(ProjRevRecHelper::getRevProfileV2(_projTable, _psaContractLineItems).ItemLedgerStatus);
                    }
                  
                    break;
                case ProjCategoryType::Hour:
                    transType = ProjTransType::Hour;

                    // If this condition fails, the SYS logic needs to fall to default so this should be the last case before default
                    if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                        || isConfigurationkeyEnabled(configurationKeyNum(Project))
                        || isConfigurationkeyEnabled(configurationKeyNum(PayrollAdministration)))
                    {
                        if (!_projTable.ProjInvoiceProjId || !_psaContractLineItems)
                        {
                            // Internal project, post cost to P/L accounts.
                            projLedgerStatus = ProjLedgerStatus::Operations;
                        }
                        else
                        {
                           
                            projLedgerStatus = ProjRevRecHelper::getRevProfileV2(_projTable, _psaContractLineItems).EmplLedgerStatus;
                        }
                
                        break;
                    }
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }

            if (projLedgerStatus == ProjLedgerStatus::BalanceSheet)
            {
                if (_projLineProperty.ToBeCapitalize)
                {
                    if (_psaContractLineItems && _psaContractLineItems.BillingMethod == ProjContractBillingMethod::FixedPrice && ProjectPosting::fixedPriceEligibleForOnlyPLPosting(_projTable))
                    {
                        projLedgerStatus = ProjLedgerStatus::Operations;
                    }
                }
                else
                {
                    projLedgerStatus = ProjLedgerStatus::Operations;
                }
            }
        }

        return projLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedPriceEligibleForOnlyPLPosting</Name>
				<Source><![CDATA[
    private static boolean fixedPriceEligibleForOnlyPLPosting(ProjTable _projTable)
    {
        return !_projTable.wipProject
                || (_projTable.wipProject && (ProjControlPeriodTable::eliminated(_projTable.wipProject, ProjWIPTable::find(_projTable.wipProject).ControlId)
                    || ProjWIPTable::find(_projTable.wipProject).wipEliminated));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project inventory cost ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record of the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <returns>
    /// The project inventory cost ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount inventCostLedgerDimension(ProjTable _projTable, ProjCategory _projCategory, ProjFundingSource _projFundingSource, ProjLineProperty _projLineProperty)
    {
        ProjLedgerStatus                costLedgerStatus;
        LedgerDimensionDefaultAccount   debitAccountCostValueLedgerDimension;
        ProjTrans_Virtual               projTrans_Virtual;

        costLedgerStatus = ProjectPosting::costLedgerStatus(_projTable, _projCategory, _projLineProperty);

        projTrans_Virtual = ProjTrans_Virtual::construct();
        projTrans_Virtual.setProjId(_projTable.ProjId);
        projTrans_Virtual.setCategoryId(_projCategory.CategoryId);

        changecompany (
                       _projTable.company()
                       )
        {
            switch (_projCategory.CategoryType)
            {
                case ProjCategoryType::Item:
                    switch (costLedgerStatus)
                    {
                        case ProjLedgerStatus::BalanceSheet:
                            debitAccountCostValueLedgerDimension = projTrans_Virtual.statusAccountItemLedgerDimension(_projFundingSource.RecId);
                            break;
                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                    break;
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
        }

        return debitAccountCostValueLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project inventory cost offset ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record of the <c>ProjFundingSource</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <returns>
    /// The project inventory cost offset ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount inventCostOffsetLedgerDimension(ProjTable _projTable, ProjCategory _projCategory, ProjFundingSource _projFundingSource, ProjLineProperty _projLineProperty)
    {
        ProjLedgerStatus                costLedgerStatus;
        LedgerDimensionDefaultAccount   creditAccountCostValueLedgerDimension;
        ProjTrans_Virtual               projTrans_Virtual;

        costLedgerStatus = ProjectPosting::costLedgerStatus(_projTable, _projCategory, _projLineProperty);

        projTrans_Virtual = ProjTrans_Virtual::construct();
        projTrans_Virtual.setProjId(_projTable.ProjId);
        projTrans_Virtual.setCategoryId(_projCategory.CategoryId);

        changecompany (
                       _projTable.company()
                       )
        {
            switch (_projCategory.CategoryType)
            {
                case ProjCategoryType::Item:
                    switch (costLedgerStatus)
                    {
                        case ProjLedgerStatus::BalanceSheet:
                            creditAccountCostValueLedgerDimension = projTrans_Virtual.offsetAccountItemLedgerDimension(_projFundingSource.RecId);
                            break;
                        default:
                            throw error(strFmt("@SYS22828",funcName()));
                    }
                    break;
                default:
                    throw error(strFmt("@SYS22828",funcName()));
            }
        }

        return creditAccountCostValueLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostOffsetPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project inventory cost offset posting type.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <returns>
    /// The project inventory cost offset posting type.
    /// </returns>
    public static LedgerPostingType inventCostOffsetPostingType(ProjTable _projTable, ProjCategory _projCategory, ProjLineProperty _projLineProperty)
    {
        ProjLedgerStatus    costLedgerStatus;
        LedgerPostingType   postingTypeOffsetCost;

        costLedgerStatus = ProjectPosting::costLedgerStatus(_projTable, _projCategory, _projLineProperty);

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Item:
                switch (costLedgerStatus)
                {
                    case ProjLedgerStatus::BalanceSheet :
                        postingTypeOffsetCost = LedgerPostingType::ProjOffsetAccountItem;
                        break;
                    default:
                        throw error(strFmt("@SYS22828",funcName()));
                }
                break;
            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return postingTypeOffsetCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventCostPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project inventory cost posting type.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projLineProperty">
    /// A record of the <c>ProjLineProperty</c> table.
    /// </param>
    /// <returns>
    /// The project inventory cost posting type.
    /// </returns>
    public static LedgerPostingType inventCostPostingType(ProjTable _projTable, ProjCategory _projCategory, ProjLineProperty _projLineProperty)
    {
        ProjLedgerStatus    costLedgerStatus;
        LedgerPostingType   postingTypeCost;

        costLedgerStatus = ProjectPosting::costLedgerStatus(_projTable, _projCategory, _projLineProperty);

        switch (_projCategory.CategoryType)
        {
            case ProjCategoryType::Item:
                switch (costLedgerStatus)
                {
                    case ProjLedgerStatus::BalanceSheet:
                        postingTypeCost = LedgerPostingType::ProjStatusAccountItem;
                        break;
                    default:
                        throw error(strFmt("@SYS22828",funcName()));
                }
                break;
            default:
                throw error(strFmt("@SYS22828",funcName()));
        }

        return postingTypeCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedRevenueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project invoiced revenue ledger dimension.
    /// </summary>
    /// <param name="_projTable">
    /// A record of the <c>ProjTable</c> table.
    /// </param>
    /// <param name="_projCategory">
    /// A record of the <c>ProjCategory</c> table.
    /// </param>
    /// <param name="_projFundingSource">
    /// A record of the <c>ProjFundingSource</c> table.
    /// </param>
    /// <returns>
    /// The project invoiced revenue ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount invoicedRevenueLedgerDimension(ProjTable _projTable, ProjCategory _projCategory, ProjFundingSource _projFundingSource)
    {
        LedgerDimensionDefaultAccount   creditAccountTurnoverLedgerDimension;
        ProjTrans_Virtual               projTrans_Virtual;

        projTrans_Virtual = ProjTrans_Virtual::construct();

        projTrans_Virtual.setProjId(_projTable.ProjId);
        projTrans_Virtual.setCategoryId(_projCategory.CategoryId);

        changecompany (
                       _projTable.company()
                       )
        {
            creditAccountTurnoverLedgerDimension = projTrans_Virtual.revenueAccountLedgerDimension(_projFundingSource.RecId);
        }

        return creditAccountTurnoverLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicedRevenuePostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the project invoiced revenue posting type.
    /// </summary>
    /// <returns>
    /// The project invoiced revenue posting type.
    /// </returns>
    public static LedgerPostingType invoicedRevenuePostingType()
    {
        //Invoiced Revenue
        LedgerPostingType   postingTypeTurnover = LedgerPostingType::ProjTurnover;

        return postingTypeTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAccrueRevenueV2</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether revenue can be accrued.
    /// </summary>
    /// <param name = "_projTable">An instance of the <t>ProjectTable</t></param>
    /// <param name = "_projCategoryId">Project category identifier</param>
    /// <param name = "_transactionCurrencySalesAmount">Sales amount for the transaction</param>
    /// <param name = "_contractLineId">Contract line number for the transaction.</param>
    /// <param name = "_fundingSource">Funding source for the transaction.</param>
    /// <param name = "_projLinePropertyToBeAccrued"></param>
    /// <returns>True, if revenue can be accrued; otherwise, false.</returns>
    public static boolean canAccrueRevenueV2(ProjTable _projTable,
        ProjCategory _projCategory,
        ProjLineProperty _projLineProperty,
        AmountCur _transactionCurrencySalesAmount,
        PSAContractLineNum _contractLineId,
        ProjFundingSource _fundingSource)
    {

        boolean isMultipleContractLineEnabled = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
        boolean checkEnterSalesAccrued;

        boolean canBeAccrued = _transactionCurrencySalesAmount &&
            _projLineProperty.ToBeAccrued;

        if (!canBeAccrued)
        {
            return canBeAccrued;
        }
        
        canBeAccrued = _fundingSource.RecId != 0 ? ProjFundingSource::isInvoiceable(_fundingSource) : canBeAccrued;

        if (canBeAccrued)
        {
            ProjTransType projTransType = _projCategory.getProjectTransType();
            
            PSAContractLineItems psaContractLineItems;

            if (_contractLineId)
            {
                psaContractLineItems = PSAContractLineItems::find(_contractLineId);
            }
            else
            {
                psaContractLineItems = ProjMultipleContractLinesForProjectFeatureHelper::getProjContractLineByContractIdTransType(
                        _projTable.ProjId,
                        _projTable.ProjInvoiceProjId,
                        projTransType);
            }
            
            if (!_projTable.ProjInvoiceProjId && 
                isMultipleContractLineEnabled)
            {
                canBeAccrued = false;
            }
            else if (isMultipleContractLineEnabled)
            {
                ProjRevenueProfile projProfile = ProjRevRecHelper::getRevProfileV2(_projTable, psaContractLineItems);
                canBeAccrued = projProfile.canPostWIPForTransType(projTransType);
            }
            else
            {
                canBeAccrued = _projCategory.canPostWIPForProjGroup(_projTable.projGroup());
            }
            
            canBeAccrued = canBeAccrued && ProjInvoiceTable::isBillingRuleInvoiceable(_projTable.ProjId,
                        _projCategory.CategoryId,
                        _contractLineId,
                        projTransType);
        }

        return canBeAccrued;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>