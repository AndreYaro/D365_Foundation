<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CatDisplayHelper</Name>
	<SourceCode>
		<Declaration><![CDATA[
class CatDisplayHelper
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addFreeTextPredicatesForAttributeFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds free-text predicates, by using the or command to combine them, to the given instance of the
    ///    <c>CatProductAttributeFilter</c> query for free-text search.
    /// </summary>
    /// <param name="_queryCatProductAttributeFilter">
    ///    An instance of the <c>CatProductAttributeFilter</c> query to which to add free-text predicates.
    /// </param>
    /// <param name="_token">
    ///    The value to use the free-text to search.
    /// </param>
    public static void addFreeTextPredicatesForAttributeFilter(Query _queryCatProductAttributeFilter, str _token)
    {
        container               pairsOfTableIdFieldId;

        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(EcoResTextValue           ), fieldNum(EcoResTextValue           , TextValue)]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(EcoResTextValueTranslation), fieldNum(EcoResTextValueTranslation, TextValue)]);

        CatDisplayHelper::addFreeTextPredicatesWithOr(
            _queryCatProductAttributeFilter,
            pairsOfTableIdFieldId,
            tableNum(EcoResTextValue),
            fieldNum(EcoResTextValue, TextValue),
            _token
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFreeTextPredicatesForCatProductFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds free-text predicates, by using the or command to combine them, to the specified instance of
    ///    <c>CatProductFilter</c> query for free-text search.
    /// </summary>
    /// <param name="_queryCatProductFilter">
    ///    An instance of the <c>CatProductFilter</c> query to which to add free-text predicates.
    /// </param>
    /// <param name="_token">
    ///    The value to free-text search for.
    /// </param>
    public static void addFreeTextPredicatesForCatProductFilter(Query _queryCatProductFilter, str _token)
    {
        container               pairsOfTableIdFieldId;

        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(EcoResProductTranslation), fieldNum(EcoResProductTranslation, Name       )]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(EcoResProductTranslation), fieldNum(EcoResProductTranslation, Description)]);

        CatDisplayHelper::addFreeTextPredicatesWithOr(
            _queryCatProductFilter,
            pairsOfTableIdFieldId,
            tableNum(EcoResProductTranslation),
            fieldNum(EcoResProductTranslation, Name),
            _token
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFreeTextPredicatesForCatVendorFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds free-text predicates, by using or to combine them, to the given instance of
    ///    <c>CatVendorFilter</c> query for free-text search.
    /// </summary>
    /// <param name="_queryCatVendorFilter">
    ///    An instance of the <c>CatVendorFilter</c> query to add free-text predicates to.
    /// </param>
    /// <param name="_token">
    ///    The value to free-text search for.
    /// </param>
    public static void addFreeTextPredicatesForCatVendorFilter(Query _queryCatVendorFilter, str _token)
    {
        container               pairsOfTableIdFieldId;

        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(VendTable    ), fieldNum(VendTable    , AccountNum)]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(DirPartyTable), fieldNum(DirPartyTable, Name      )]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(DirPartyTable), fieldNum(DirPartyTable, NameAlias )]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(DirPartyTable), fieldNum(DirPartyTable, KnownAs   )]);

        CatDisplayHelper::addFreeTextPredicatesWithOr(
            _queryCatVendorFilter,
            pairsOfTableIdFieldId,
            tableNum(DirPartyTable),
            fieldNum(DirPartyTable, Name),
            _token
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFreeTextPredicatesForExternalFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds free-text predicates, by using Or to combine them, to the specified instance of the
    ///    <c>CatExternalCatalogFilter</c> query for free-text search.
    /// </summary>
    /// <param name="_queryCatExternalCatalogFilter">
    ///    An instance of the <c>CatExternalCatalogFilter</c> query to add free-text predicates to.
    /// </param>
    /// <param name="_token">
    ///    The value to free-text search for.
    /// </param>
    public static void addFreeTextPredicatesForExternalFilter(Query _queryCatExternalCatalogFilter, str _token)
    {
        container               pairsOfTableIdFieldId;

        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(CatExternalCatalog           ), fieldNum(CatExternalCatalog           , Name        )]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(CatExternalCatalogTranslation), fieldNum(CatExternalCatalogTranslation, FriendlyName)]);
        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(CatExternalCatalogTranslation), fieldNum(CatExternalCatalogTranslation, Description )]);

        CatDisplayHelper::addFreeTextPredicatesWithOr(
            _queryCatExternalCatalogFilter,
            pairsOfTableIdFieldId,
            tableNum(CatExternalCatalog),
            fieldNum(CatExternalCatalog, Name),
            _token
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFreeTextPredicatesForKeywordFilter</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds free-text predicates, by using Or to combine them, to the given instance of the
    ///    <c>CatExternalCatalogKeywordFilter</c> query for free-text search.
    /// </summary>
    /// <param name="_queryCatExternalCatalogKeywordFilter">
    ///    An instance of <c>CatExternalCatalogKeywordFilter</c> query to add free-text predicates to.
    /// </param>
    /// <param name="_token">
    ///    The value to free-text search for.
    /// </param>
    public static void addFreeTextPredicatesForKeywordFilter(Query _queryCatExternalCatalogKeywordFilter, str _token)
    {
        container               pairsOfTableIdFieldId;

        pairsOfTableIdFieldId = conIns(pairsOfTableIdFieldId, conLen(pairsOfTableIdFieldId)+1, [tableNum(CatExternalCatalogCategories ), fieldNum(CatExternalCatalogCategories , Keywords    )]);

        CatDisplayHelper::addFreeTextPredicatesWithOr(
            _queryCatExternalCatalogKeywordFilter,
            pairsOfTableIdFieldId,
            tableNum(CatExternalCatalogCategories),
            fieldNum(CatExternalCatalogCategories, Keywords),
            _token
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addFreeTextPredicatesWithOr</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds free-text predicates, by using Or to combine them, to the given query for free-text search.
    /// </summary>
    /// <param name="_query">
    /// The query to add free-text predicates to.
    /// </param>
    /// <param name="_pairsOfTableIdFieldId">
    /// A container of containers each is a pair:
    /// </param>
    /// <param name="_tid">
    /// The ID of the table to add free-text predicates to.
    /// </param>
    /// <param name="_fid">
    /// The ID of the field on the specified <paramref name="_tid" /> table to add free-text predicates to.
    /// </param>
    /// <param name="_token">
    /// The value to free-text search for.
    /// </param>
    /// <remarks>
    /// NOTE: The predicates are always added to the data source from the container with the highest data
    /// source number in the given query.Example: given a query with <c>TableX</c> data source and
    /// <c>TableY</c> data source, the <paramref name="_pairsOfTableIdFieldId" /> parameter value has 2
    /// pairs: (TableX, FieldX) and (TableY, FieldY). The <paramref name="_token" /> parameter value is
    /// abc. Then, the result query may resemble this, with other, existing predicates not shown here:
    /// select * from TableX where join TableY where (TableX.FieldX freetext "abc" || TableY.FieldY
    /// freetext "abc")
    /// </remarks>
    public static void addFreeTextPredicatesWithOr(Query _query, container _pairsOfTableIdFieldId, TableId _tid, FieldId _fid, str _token)
    {
        str                     orPredicates; // predicuates ORed together
        container               pair;
        TableId                 tid;
        FieldId                 fid, freetextFidOfDataSourceWithLargestDsNo;
        int                     i, largestDataSourceNo = 0;
        int                     nPairs = conLen(_pairsOfTableIdFieldId);
        Map                     tid_dsNo = new Map(Types::Integer, Types::Integer);

        // We always get the last (ie, with largest datasourceNo) datasource, of all in the given container, from the query.
        // This is important:
        //   if the query has #1 thats TableX and #2 that's TableY,
        //   predicuates are for TableX.FieldX and TableY.FieldY,
        //   then if we had used #1 (TableX), we'd get this X++ query, which is wrong since it references TableY before "JOIN TableY":
        //     select *
        //     from TableX
        //       where (TableX.FieldX freetext "abc" || TableY.FieldY freetext "abc")
        //     join TableY
        //       where ...
        //
        // The algorithm to get that datasource:
        //   build tid_dsNo, a Map, of all datasources on the query
        //   of all tables in the container, find the one, using above Map, with the largest dsNo.

        QueryBuildDataSource    qbDataSource;
        QueryBuildRange         qbRange     ;

        // populate tid_dsNo
        for (i=1; i<=_query.dataSourceCount(); i++)
        {
            tid = _query.dataSourceNo(i).table();
            // keep the largest ds number for the table
            if (tid_dsNo.exists(tid))
            {
                tid_dsNo.remove(tid);
            }

            tid_dsNo.insert(tid, i);
        }

        for (i=1; i<=nPairs; i++)
        {
            pair = conPeek(_pairsOfTableIdFieldId, i);
            [tid, fid] = pair;

            if (i > 1)
            {
                orPredicates+= ' || ';
            }
            orPredicates += strFmt('(%1)', CatDisplayHelper::constructFreeTextPredicate(_query, tid, fid, _token));

            // of all the tables that we're doing free-text search on, get the one with the largest datasource#:
            if (largestDataSourceNo < tid_dsNo.lookup(tid))
            {
                largestDataSourceNo = tid_dsNo.lookup(tid);
                freetextFidOfDataSourceWithLargestDsNo = fid;
            }
        }

        // NOTE: we cannot simply use the ubiquitous RecId column of the last datasource of all from the query to avoid calling passing in tid/fid
        // - must use a freetext-enabled (AOT\Table\FreetextIndex) column, or runtime error.
        qbDataSource    = _query.dataSourceTable(_tid);
        qbRange         = qbDataSource.addRange(_fid);
        qbRange.rangeType(QueryRangeType::FullText);
        qbRange.value(orPredicates);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addHiddenFilter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a hidden filter to the given query object.
    /// </summary>
    /// <param name="_query">
    /// The query to which to add a hidden filter.
    /// </param>
    /// <param name="_queryBuildDataSource">
    /// The data source on which to add a hidden filter.
    /// </param>
    /// <param name="_fieldName">
    /// The name of the field on which the hidden filter is added.
    /// </param>
    /// <returns>
    /// The filter that is added.
    /// </returns>
    public static QueryFilter addHiddenFilter(
        Query                   _query,
        QueryBuildDataSource    _queryBuildDataSource,
        FieldName               _fieldName
    )
    {
        QueryFilter filter = _query.addQueryFilter(_queryBuildDataSource, _fieldName);
        filter.status(RangeStatus::Hidden);
        return filter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addHiddenRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a hidden range to the given data source.
    /// </summary>
    /// <param name="_queryBuildDataSource">
    /// The data source to which to add a hidden range.
    /// </param>
    /// <param name="_fieldId">
    /// The field on which the hidden range is added.
    /// </param>
    /// <returns>
    /// The range that is added.
    /// </returns>
    public static QueryBuildRange addHiddenRange(QueryBuildDataSource _queryBuildDataSource, FieldId _fieldId)
    {
        QueryBuildRange range = _queryBuildDataSource.addRange(_fieldId);
        range.status(RangeStatus::Hidden);
        return range;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFreeTextPredicate</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Contructs a X++ query predicate for free-text search.
    /// </summary>
    /// <param name="_query">
    ///    The query to construct free-text predicate for.
    /// </param>
    /// <param name="_tid">
    ///    The ID of the table to free-text search in.
    /// </param>
    /// <param name="_fid">
    ///    The ID of the field to free-text search on.
    /// </param>
    /// <param name="_token">
    ///    The value to free-text search for.
    /// </param>
    /// <returns>
    ///   A string like this one (except, without the single quotes), with double quotes added around given <paramref>_token</paramref>, if given token is abc:
    ///     'tableX.FieldY freetext "abc"'
    /// </returns>
    public static str constructFreeTextPredicate(Query _query, TableId _tid, FieldId _fid, str _token)
    {
        // tableNameInQuery:    The name of the datasource (table or view) to free-text search in.
        // fieldName:           The name of the field to free-text search on.
        QueryBuildDataSource    qbds                = _query.dataSourceTable(_tid);
        str                     tableNameInQuery    = qbds.name();
        str                     fieldName           = fieldId2name(_tid, _fid);
        // MUST use tableNameInQuery instead of tableid2name.
        // For example, in a <c>Query</c> object, if <c>CustTable</c> table is a datasource with
        // name "Customer", then
        // - tableNameInQuery is "Customer",
        // - tableid2name is "CustTable".
        return strFmt('%1.%2 freetext "%3"', tableNameInQuery, fieldName, queryValue(_token));
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPurchaseTradeAgreements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds all trade agreements data for the specified item.
    /// </summary>
    /// <param name="_inventTableItemId">
    /// The item ID of the <c>InventTable</c> record for which to find trade agreements data.
    /// </param>
    /// <param name="_inventTableCompanyId">
    /// The company in which to find released variants.
    /// </param>
    /// <returns>
    /// A container of containers as shown below.
    /// </returns>
    /// <remarks>
    /// First container's elements are purchase setup data. Second container's elements are each a
    /// container of TradeAgreement data. [ [setupLQ,setupHQ,setupDQ,setupMQ], [ [a1,b1,c1,d1,e1,...],
    /// [a2,b2,c2,d2,e2,...], ] ] Note: the second container may have multiple entries for the same vendor.
    /// Note: the TradeAgreement container may have null vendor and/or null TradeAgreement data but it will
    /// have non-null Product RecId data.
    /// </remarks>
    public static container findPurchaseTradeAgreements(
        ItemId _inventTableItemId,
        CompanyId _inventTableCompanyId)
    {
        InventItemPurchSetup                inventItemPurchSetup;
        CurrencySymbol                      currencySymbol;
        EcoResProduct                       masterOrDistinctProduct; // masterOrDistinctProduct:  either EcoResProductMaster   or EcoResDistinctProduct
        EcoResDistinctProductVariant        distinctProductVariant;
        InventDimCombination                inventDimCom;
        InventDim                           dimForDistinctProduct;
        CatProcurementCache                 procurementCache = CatProcurementCache::getCache();

        CurrencyCode                        currencyCode = Ledger::accountingCurrency();
        InventTable                         inventTable;
        InventTableModule                   inventTableModule;
        RecId                               vendorRecId;

        TransDate                   now                     = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()) ;
        TransDate                   nullDate;

        container                   taContainer; // trade agreement container
        container                   purchSetupContainer;
        PriceCur                    taPricePerUnit;
        PriceUnit                   setupMultiQty;
        PriceUnit                   setupDefaultQty;
        PriceUnit                   setupLowestQty;
        PriceUnit                   setupHighestQty;

        int64                       lengthOfTheContainer;
        int                         ntAadded;
        VendName                    primaryVendor;
        boolean                     priceIsFound = false;

        // converts 0.0 to 1.0; otherwise just return the input.
        PriceUnit zeroToOne(PriceUnit _input)
        {
            return (_input==0.0 ? 1.0 : _input);
        }

        /// Gets the setup quantity by using the input as the original value,
        /// then check CatProcurementCache.Ignore*QuantitySetup field.
        Qty getSetupQuantityAfterIgnore(Qty _input, FieldId _procureCacheIgnoreXQuantitySetup)
        {
            Qty output = _input;
            if (procurementCache.RecId && procurementCache.(_procureCacheIgnoreXQuantitySetup))
            {
                output = 0.0;
            }
            return output;
        }

        // _inventDimIdForDistinctProductVariant would and must  be non-null iff _distinctOrVariantProductRecId is Variant
        // returns: number of TradeAgreement's added to taContainer.
        int processDistinctOrVariantProduct(RefRecId _distinctOrVariantProductRecId, InventDimId _inventDimIdForDistinctProductVariant = '')
        {
            EcoResDistinctProduct       iDistinctOrVariantProduct = EcoResProduct::find(_distinctOrVariantProductRecId);
            PriceDiscTable              iPriceDiscTable;
            VendTable                   iVendTable;
            VendName                    iSelectedVendor;
            VendAccount                 iVendorAccountNum;
            UnitOfMeasureSymbol         iUnitId;
            PriceUnit                   iTaMinQuantity;
            PriceUnit                   iTaMaxQuantity;
            InventDim                   iDimForDinstinctProduct; // for EcoResDistinctProduct or EcoResDistinctProductVariant
            InventDim                   iDimForPriceDisc;        // for PriceDiscTable
            RecId                       iVendorRecId;
            int                         itAadded = 0;

            //Check if the product is a distinct product variant
            if (_inventDimIdForDistinctProductVariant)
            {
                iDimForDinstinctProduct = InventDim::find(_inventDimIdForDistinctProductVariant);
            }
            else
            {
                //If it is not a distinct product variant it will be a distinct product.
                //The item needs to be in the correct LE
                iDimForDinstinctProduct = InventDim::findDim(iDimForDinstinctProduct);
            }

            //Join the PriceDiscTable with distinct products, vendors, invent dim and invent dim combination table
            //to get all the vendors and all possible configurations being available for each of the purchase setup.

            // for EcoResDistinctProductVariant:
            //   instead of finding the InventDim by joining it to PriceDiscTable on InventDimId,
            //   we should use use the given _inventDimIdForDistinctProductVariant, which should have come from the InventDimCombination which was found via its DistinctProductVariant.
            // so here is the whole picture:
            //   InventTable
            //     EcoResProductMaster (IT.Product==PM.RecId)
            //       EcoResDistinctProductVariant (DPV.ProductMaster==PM.RecId)
            //         InventDimCombination (Com.DistinctProductVariant==DPV.RecId)
            //           InventDim (Dim.InventDimId==Com.InventDimId)
            while select RecId, AccountRelation, Currency, Amount, PriceUnit, UnitId, QuantityAmountFrom, QuantityAmountTo
            from iPriceDiscTable
                order by
                    iPriceDiscTable.AccountRelation,
                    iPriceDiscTable.InventDimId,
                    iPriceDiscTable.QuantityAmountFrom,
                    iPriceDiscTable.QuantityAmountTo
                where  iPriceDiscTable.ItemRelation == inventTable.ItemId
                    // restrict only to those for Purchase
                    && iPriceDiscTable.Module == ModuleInventCustVend::Vend
                    // restrict only to those still effective
                    && (
                        //restrict by from date
                        (
                            iPriceDiscTable.FromDate <= now  ||
                            iPriceDiscTable.FromDate == nullDate
                        )
                        &&
                        //and restrict also by to date
                        (
                            iPriceDiscTable.ToDate > now ||
                            iPriceDiscTable.ToDate == nullDate
                        )
                    )
                    //consider only valid account relation
                    && iPriceDiscTable.AccountRelation != ''
                    //consider only valid account code
                    && iPriceDiscTable.AccountCode == PriceDiscPartyCodeType::Table
            outer join iDimForPriceDisc
                where iDimForPriceDisc.InventDimId == iPriceDiscTable.InventDimId
            outer join * from iVendTable
                where iVendTable.AccountNum == iPriceDiscTable.AccountRelation
            {
                // either _inventDimIdForDistinctProductVariant is null,
                // or     _inventDimIdForDistinctProductVariant's info must match that of the PriceDiscTable's InventDim
                //          - we only care about product dimensions since that's all EP enduser cares about.
                if (!_inventDimIdForDistinctProductVariant || InventDim::getModifiedProductDimensionFields(iDimForPriceDisc, iDimForDinstinctProduct).elements() == 0)
                {
                    //if no vendors is associated in price discount table, it means that the vendor is the default vendor associated with intent table.
                    if (iVendTable)
                    {
                        iSelectedVendor = iVendTable.name();
                        iVendorAccountNum = iVendTable.AccountNum;
                    }
                    else
                    {
                        iSelectedVendor = primaryVendor;
                        iVendorAccountNum = inventTable.PrimaryVendorId;
                    }

                    //Get unitid
                    if ( iPriceDiscTable )
                    {
                        iUnitId         = iPriceDiscTable.UnitId;
                        currencyCode    = iPriceDiscTable.Currency;
                        iTaMinQuantity  = (iPriceDiscTable.QuantityAmountFrom);
                        iTaMaxQuantity  = (iPriceDiscTable.QuantityAmountTo  );

                        // // Let's show the TradeAgreement anyhow even though user should not be able to make purchase:
                        // // if TradeAgreement [iTaMinQuantity, iTaMaxQuantity] does not overlap InventItemPurchSetup [getLowestQty(), getHighestQty()],
                        // // then it's not possible to use the TradeAgreement
                        // // - let's not bother returning it to caller.
                        // if (     ((setupHighestQty  < iTaMinQuantity ) && (setupHighestQty != 0))
                        //     ||  ((iTaMaxQuantity   < setupLowestQty ) && (iTaMaxQuantity  != 0))
                        // )
                        // {
                        //     continue;
                        // }
                    }
                    else
                    {
                        iUnitId      = inventTableModule.UnitId;
                        iTaMinQuantity = setupLowestQty ;
                        iTaMaxQuantity = setupHighestQty;
                    }

                    //Call Trade Agreement API and pull the TA price
                    [priceIsFound, taPricePerUnit] = CatDisplayHelper::getPurchasePrice(
                        _inventTableItemId,
                        (iDimForPriceDisc ? iDimForPriceDisc : iDimForDinstinctProduct), //must still use iDimForDinstinctProduct for the case of NO TradeAgreement
                        iPriceDiscTable.UnitId,
                        // Do NOT use setupLowestQty
                        // - if there are two TA (1-50, $10; 51-200: $9), and setupLowestQty=1
                        // - using setupLowestQty then we'd get $10 for both.
                        // Even using iTaMinQuantity is still problematic when multiple TAs have overlapping quantity ranges
                        // - because DiscPrice API uses first-wins approach.
                        zeroToOne(iTaMinQuantity),
                        iVendorAccountNum,
                        CatDisplayHelper::priceGroupId(),
                        currencyCode
                    );

                    if (priceIsFound)
                    {
                        iVendorRecId = VendTable::findByCompany(_inventTableCompanyId, iVendorAccountNum).RecId;
                        currencySymbol = Currency::find(currencyCode).symbol();
                        // for the same combination of (iVendorAccountNum,iDimForDinstinctProduct.InventDimId),
                        // we could contain multiple entries.
                        lengthOfTheContainer++;
                        itAadded++;

                        container tradeAgreementCon = 
                        [
                            lengthOfTheContainer                        ,
                            iVendorAccountNum                           ,
                            iSelectedVendor                             ,
                            iVendorRecId                                ,
                            currencyCode                                ,
                            currencySymbol                              ,
                            taPricePerUnit                              ,
                            iUnitId                                     ,
                            iDimForPriceDisc.InventDimId                ,
                            _distinctOrVariantProductRecId              ,
                            iTaMinQuantity                              ,
                            iTaMaxQuantity
                        ];

                        InventDimensionEnumerator productDims = InventProductDimension::getEnumeratorForEnabledDimensions();
                        while (productDims.moveNext())
                        {
                            tradeAgreementCon += iDimForPriceDisc.(productDims.currentInventDimFieldId());
                        }

                        taContainer = conIns(taContainer, (1+conLen(taContainer)), tradeAgreementCon);
                    }
                }
            }
            return itAadded;
        }

        //Get currency symbol for the LE currency
        currencySymbol = Currency::find(currencyCode).symbol();

        changecompany(_inventTableCompanyId)
        {
            inventTable = InventTable::find(_inventTableItemId);
            primaryVendor = CatAttributeProductCollection::getPrimaryVendorName(inventTable, getCompany(tableNum(VendTable), _inventTableCompanyId));

            // Even if Primary vendor is not set, we still want to allow purchase

            //Get the item setup details
            inventItemPurchSetup = inventTable.inventItemPurchSetup();

            if (inventItemPurchSetup && inventItemPurchSetup.Stopped == false)
            {
                // StandardQty is like the "default quantity"
                // MultipleQty is like the "mininum quantity" (from InventItemPurchSetup - not to be confused with "mininum quantity" from TradeAgreement)
                setupLowestQty  = (inventItemPurchSetup.getLowestQty ());
                setupHighestQty = (inventItemPurchSetup.getHighestQty());
                setupDefaultQty = (inventItemPurchSetup.StandardQty);
                setupMultiQty   = (inventItemPurchSetup.MultipleQty);

                purchSetupContainer =
                    [
                    getSetupQuantityAfterIgnore(setupLowestQty  ,fieldNum(CatProcurementCache, IgnoreMinimumOrderQuantitySetup)),
                    getSetupQuantityAfterIgnore(setupHighestQty ,fieldNum(CatProcurementCache, IgnoreMaximumOrderQuantitySetup)),
                    setupDefaultQty         ,
                    getSetupQuantityAfterIgnore(setupMultiQty   ,fieldNum(CatProcurementCache, IgnoreMultipleOrderQuantitySetup))
                    ];

                while select RecId from masterOrDistinctProduct
                    where masterOrDistinctProduct.RecId == inventTable.Product
                    join Price, PriceUnit, UnitId, ItemId, ModuleType from inventTableModule
                        where  inventTableModule.ItemId     == inventTable.ItemId
                            && inventTableModule.ModuleType == ModuleInventPurchSales::Purch
                {
                    switch (masterOrDistinctProduct.getInstanceRelationType())
                    {
                        case tableStr(EcoResProductMaster):
                            while select RecId from distinctProductVariant
                                where distinctProductVariant.ProductMaster == masterOrDistinctProduct.RecId
                                join inventDimCom
                                    where inventDimCom.DistinctProductVariant == distinctProductVariant.RecId
                            {
                                ntAadded = processDistinctOrVariantProduct(distinctProductVariant.RecId, inventDimCom.InventDimId);
                            }
                            break;
                        case tableStr(EcoResDistinctProduct):
                            ntAadded = processDistinctOrVariantProduct(masterOrDistinctProduct.RecId);
                            break;
                        default:
                            throw error(
                            strFmt(
                            "@SYS330032", masterOrDistinctProduct.getInstanceRelationType()
                            )
                            );
                    }

                    // no TA found? add an entry to ensure the _distinctOrVariantProductRecId is in taContainer
                    if (ntAadded <= 0)
                    {
                        if (inventTable.PrimaryVendorId)
                        {
                            vendorRecId = VendTable::findByCompany(_inventTableCompanyId, inventTable.PrimaryVendorId).RecId;
                        }
                        switch (EcoResProduct::find(inventTable.Product).getInstanceRelationType())
                        {
                            case tableStr(EcoResProductMaster):
                                while select RecId from distinctProductVariant
                                    where distinctProductVariant.ProductMaster == inventTable.Product
                                    join RecId from inventDimCom
                                        where inventDimCom.DistinctProductVariant == distinctProductVariant.RecId
                                    join dimForDistinctProduct
                                        where inventDimCom.InventDimId == dimForDistinctProduct.InventDimId
                                {
                                    lengthOfTheContainer++;
                                    container tradeAgreementCon = 
                                    [
                                        lengthOfTheContainer                        ,
                                        inventTable.PrimaryVendorId                 ,
                                        primaryVendor                               ,
                                        vendorRecId                                 ,
                                        currencyCode                                ,
                                        currencySymbol                              ,
                                        inventTableModule.Price                     ,
                                        inventTableModule.UnitId                    ,
                                        dimForDistinctProduct.InventDimId           ,
                                        distinctProductVariant.RecId                ,
                                        1.0                                         ,
                                        0.0
                                    ];

                                    InventDimensionEnumerator productDims = InventProductDimension::getEnumeratorForEnabledDimensions();
                                    while (productDims.moveNext())
                                    {
                                        tradeAgreementCon += dimForDistinctProduct.(productDims.currentInventDimFieldId());
                                    }

                                    taContainer = conIns(taContainer, (1+conLen(taContainer)), tradeAgreementCon);
                                }
                                break;
                            case tableStr(EcoResDistinctProduct):
                                lengthOfTheContainer++;
                                container tradeAgreementCon = 
                                [
                                    lengthOfTheContainer                        ,
                                    inventTable.PrimaryVendorId                 ,
                                    primaryVendor                               ,
                                    vendorRecId                                 ,
                                    currencyCode                                ,
                                    currencySymbol                              ,
                                    inventTableModule.Price                     ,
                                    inventTableModule.UnitId                    ,
                                    ''                                          ,
                                    inventTable.Product                         ,
                                    1.0                                         ,
                                    0.0
                                ];

                                Enumerator productDims = InventProductDimension::getEnumeratorForEnabledDimensions();
                                while (productDims.moveNext())
                                {
                                    tradeAgreementCon += '';
                                }

                                taContainer = conIns(taContainer, (1+conLen(taContainer)), tradeAgreementCon);
                                break;
                            default:
                                throw error(strFmt("@SYS330032", masterOrDistinctProduct.getInstanceRelationType()));
                        }
                    }
                }
            }
        }
        return [purchSetupContainer , taContainer];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExternalImages</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds all the data for the external images of the specified product, depending on its type.
    /// </summary>
    /// <param name="_productRecId">
    /// The record ID of the <c>EcoResProduct</c> record for which to find related image data.
    /// </param>
    /// <param name="_maxCount">
    /// The maximum number of product images to retrieve.
    /// </param>
    /// <returns>
    /// A container of containers that each contain detailed data about an image.
    /// </returns>
    /// <remarks>
    ///  The product that is selected by the user in the shopping site might belong to anyone of these 3
    ///  tables:
    ///  <list type="bullet">
    ///   <item>
    ///    <description>
    ///    The <c>EcoResDistinctProduct</c> table.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    The <c>EcoResProductMaster</c> table.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    The<c>EcoResDistinctProductVariant</c> table.
    ///    </description>
    ///   </item>
    ///  </list>
    /// </remarks>
    public static container getExternalImages(
                                RefRecId    _productRecId,
                                int         _maxCount = 4)
    {
        EcoResProduct                   product;
        container                       result;

        select firstonly product where product.RecId == _productRecId;
        //In Product information management feature, image can be associated with product from several places
        //-    AllProducts and ProductMaster, then ProductImage
        //-    AllProducts and ProductMaster, then ProductVariant, then ProductImage
        //-    Products, then ProductImage
        //-    ProductMaster, then ProductImage
        //-    ProductMaster, then ProductVariant, then ProductImage
        //So, when user clicks on the product to know its details from EP, we need to know what is the type of the record.
        //This switch statement helps us to get the appropriate product id i.e. either from
        //product master or product or product variant
        switch (product.getInstanceRelationType())
        {
            case tableStr(EcoResDistinctProduct):
                result = CatDisplayHelper::getImagesFromProductImage(_productRecId, result, _maxCount);
                break;
            case tableStr(EcoResProductMaster):
                result = CatDisplayHelper::getExternalImagesFromProductMaster(_productRecId, _maxCount);
                break;
            case tableStr(EcoResDistinctProductVariant):
                result = CatDisplayHelper::getExternalImagesFromProductVariant(_productRecId, _maxCount);
                break;
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExternalImagesFromProductMaster</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds all data for the external images of the specified product master.
    /// </summary>
    /// <param name="_productRecId">
    /// The record ID of the <c>EcoResProductMaster</c> record for which to find related image data.
    /// </param>
    /// <param name="_maxCount">
    /// The maximum number of product images to retrieve.
    /// </param>
    /// <returns>
    /// A container of containers that each contain detailed data about an image.
    /// </returns>
    private static container getExternalImagesFromProductMaster(
                                RefRecId    _productRecId,
                                int         _maxCount)
    {
        container                       result;
        EcoResDistinctProductVariant    ecoResDistinctProductVariant;

        //If the product recid for which we need to show image belongs to ProductMaster then we need to initially get the
        //images associated with product master.if the count of images is <4 then we need to look into
        //images that are associated with product variants too.
        result = CatDisplayHelper::getImagesFromProductImage(_productRecId, result, _maxCount);

        //if the count of images associated with product master is <4 then we need to look into images that are
        //associated with product variants too.
        if (conLen(result) < _maxCount)
        {
            //This inner loop is to search for the images associated with product variants
            //At any point of time, if the image count is 4, we will exit the loop
            while select RecId from ecoResDistinctProductVariant where ecoResDistinctProductVariant.ProductMaster == _productRecId
            {
                if (conLen(result) < _maxCount)
                {
                    result = CatDisplayHelper::getImagesFromProductImage(ecoResDistinctProductVariant.RecId, result, _maxCount);
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExternalImagesFromProductVariant</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds all data for the external images of the specified product variant.
    /// </summary>
    /// <param name="_productRecId">
    /// The record ID of the <c>EcoResDistinctProductVariant</c> record for which to find related image
    /// data.
    /// </param>
    /// <param name="_maxCount">
    /// The maximum number of product images to retrieve.
    /// </param>
    /// <returns>
    /// A container of containers that each contain detailed data about an image.
    /// </returns>
    private static container getExternalImagesFromProductVariant(
                               RefRecId    _productRecId,
                               int         _maxCount)
    {
        container                       result;
        EcoResDistinctProductVariant    ecoResDistinctProductVariant;
        EcoResProduct                   productMaster;

        //If the product recid for which we need to associate image, belongs to ecoResDistinctProductVariant then get the productMaster recId first
        select RecId from productMaster
            join RecId from ecoResDistinctProductVariant
                where productMaster.RecId == ecoResDistinctProductVariant.ProductMaster
                    && ecoResDistinctProductVariant.RecId == _productRecId;

        //We need to initially get the images associated with product master and then the product variants. Calling the below method
        //will satisfy our use as that method internally search the product variant images
        result = CatDisplayHelper::getExternalImagesFromProductMaster(productMaster.RecId, _maxCount);

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImagesFromProductImage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds all data for the external images of the specified product.
    /// </summary>
    /// <param name="_productRecId">
    ///    The record ID of the <c>EcoResProduct</c> record for which to find related image data.
    /// </param>
    /// <param name="_result">
    ///    A container to hold image parameters associated with product.
    /// </param>
    /// <param name="_maxCount">
    ///    The maximum number of product images to retrieve.
    /// </param>
    /// <returns>
    ///    A container of containers, each with detailed data about an image.
    /// </returns>
    private static container getImagesFromProductImage(
                                RefRecId    _productRecId,
                                container   _result,
                                int         _maxCount)
    {
        EcoResProductImage              ecoResProductImage;
        DocuRef                         docuRef;
        DocuValue                       docuValue;
        str th, ms, os;
        InventTable                     inventTable = InventTable::findByProduct(_productRecId);
        InventDimCombination            inventDimCombination = InventDimCombination::findByDistinctProductVariant(_productRecId);

        //Get the required values from EcoResProductImage table
        while select * from ecoResProductImage
                where (ecoResProductImage.RefRecord == InventDimCombination.RecId
                        || ecoResProductImage.RefRecord == inventTable.RecId
                        || ecoResProductImage.RefRecord == _productRecId)
                    && ecoResProductImage.Usage == EcoResProductImageUsage::External
            join RecId from docuRef
                where docuRef.RecId == ecoResProductImage.RefRecId
                    && docuRef.RefRecId == ecoResProductImage.RefRecord
            join RecId from docuValue
                where docuRef.ValueRecId == docuValue.RecId
        {
            th = CatDisplayHelper::getPublishedImageFileName(ecoResProductImage, fieldNum(EcoResProductImage, ThumbnailSize));
            ms = CatDisplayHelper::getPublishedImageFileName(ecoResProductImage, fieldNum(EcoResProductImage, MediumSize));
            os = CatDisplayHelper::getPublishedImageFileName(docuRef, 0, ecoResProductImage.ImageFormat);
            _result = conIns(_result, (1+conLen(_result)),
            [
                    th
                ,   ms
                ,   os
                ,   ecoResProductImage.DefaultImage
            ]);

            //Maximum images we show up in the shopping site is 4. If the container results count exceeds 4 then we need to break the loop
            if (conLen(_result) >= _maxCount)
            {
                break;
            }
        }

        return _result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInventItemPurchSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the <c>InventItemPurchSetup</c> record for the given item in the given company.
    /// </summary>
    /// <param name="_companyRecId">
    /// The record ID of the <c>CompanyInfo</c> record in which to find the <c>InventItemPurchSetup</c>
    /// record.
    /// </param>
    /// <param name="_itemId">
    /// The item ID for which to find the <c>InventItemPurchSetup</c> record.
    /// </param>
    /// <param name="_includeStopped">
    /// A Boolean value that indicates whether the stopped record should be returned.
    /// </param>
    /// <returns>
    /// The <c>InventItemPurchSetup</c> record for the given item in the given company.
    /// </returns>
    public static InventItemPurchSetup getInventItemPurchSetup(
        RecId       _companyRecId,
        ItemId      _itemId,
        boolean     _includeStopped = true
    )
    {
        CompanyInfo             company;
        InventTable             inventTable;
        InventItemPurchSetup    inventItemPurchSetup;

        if (_companyRecId && _itemId)
        {
            company = CompanyInfo::findRecId(_companyRecId);
            if (company.DataArea)
            {
                changecompany(company.DataArea)
                {
                    inventTable = InventTable::find(_itemId);
                    inventItemPurchSetup = inventTable.inventItemPurchSetup();
                    if (     inventItemPurchSetup
                        && (!_includeStopped)
                        && (inventItemPurchSetup.Stopped == NoYes::Yes)
                    )
                    {
                        return null;
                    }
                }
            }
        }

        return inventItemPurchSetup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPublishedDefaultThumbNailFileName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the file name of the published default thumbnail image for the specified product.
    /// </summary>
    /// <param name="_product">
    ///    The product for which to obtain image data.
    /// </param>
    /// <returns>
    ///    The full file name of the published default thumbnail image that includes the file name extension.
    /// </returns>
    public static Filename getPublishedDefaultThumbNailFileName(EcoResProduct _product)
    {
        EcoResProductImage              tblProductImage;
        str                             result = '';
        InventTable                     inventTable = InventTable::findByProduct(_product.recId);
        InventDimCombination            inventDimCombination = InventDimCombination::findByDistinctProductVariant(_product.recId);

        select firstonly * from tblProductImage
            where (tblProductImage.RefRecord == _product.RecId
                    || tblProductImage.RefRecord == inventTable.RecId
                    || tblProductImage.RefRecord == InventDimCombination.RecId)
                && tblProductImage.DefaultImage == NoYes::Yes
        ;
        if (tblProductImage.RecId)
        {
            result = tblProductImage.getPublishedThumbNailFileName();
        }
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPublishedImageFileName</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the file name of the published image by using the specified field of the record.
    /// </summary>
    /// <param name="_record">
    ///    A record buffer with image raw data in the specified field.
    /// </param>
    /// <param name="_fid">
    ///    The field of the record buffer that stores the image raw data.
    /// </param>
    /// <param name="_imageFileExt">
    ///    The file name extension of the original image file that is used to construct the published image
    ///    file name.
    /// </param>
    /// <returns>
    ///    The full file name of the published image that includes the file name extension.
    /// </returns>
    /// <remarks>
    ///    If the specified record does not have an <c>ImageFormat</c> column that stores the file name
    ///    extension and the image file name extension is not .gif, the caller must supply a value for the
    ///    <paramref name="_imageFileExt" /> parameter in order to get the correct result.
    /// </remarks>
    static Filename getPublishedImageFileName(Common _record, FieldId _fid, str _imageFileExt = '')
    {
        // see EPWebSiteParameters::companyImageFileName
        // see EPWebSiteParameters::ecpPresentationImageFileName

        str imageFileName = CatDisplayHelper::imageName(_record, fieldName2id(_record.TableId, fieldId2name(_record.TableId, _fid)));
        if (!_imageFileExt)
        {
            _imageFileExt = CatDisplayHelper::imageType(_record);
        }
        return (imageFileName + '.' + _imageFileExt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchasePrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an instance of the <c>PriceCur</c> extended data type.
    /// </summary>
    /// <param name="_itemId">
    ///    An instance of the <c>ItemId</c> type that represents the item ID.
    /// </param>
    /// <param name="_inventDim">
    ///    An instance of the <c>InventDim</c> record that represents inventory dimensions.
    /// </param>
    /// <param name="_unitSymbol">
    ///    An instance of the <c>UnitOfMeasureSymbol</c> record that represents the unit of measure.
    /// </param>
    /// <param name="_quantity">
    ///    An instance of the <c>Qty</c> type that represents the quantity for which to find trade agreement
    ///    price.
    /// </param>
    /// <param name="_vendorAccountNumber">
    ///    An instance of the <c>CustVendAC</c> type that represents the vendor account.
    /// </param>
    /// <param name="_priceGroupId">
    ///    An instance of the <c>PriceGroupId</c> extended data type that represents the price group ID.
    /// </param>
    /// <param name="_currency">
    ///    An instance of the <c>CurrencyCode</c> type that represents the LE currency.
    /// </param>
    /// <returns>
    ///    A container that contains a Boolean value and an instance of the <c>PriceCur</c> extended data type.
    /// </returns>
    /// <remarks>
    ///    A container of two elements: the first is a Boolean value that indicates whether the price has been
    ///    found.The second is an instance of the <c>PriceCur</c> extended data type that represents the trade
    ///    agreement price for the given input. Note that the price returned would be wrong and should not be
    ///    used unless the Boolean has value of true. Note that the price is per-unit, not for the given
    ///    <paramref name="!Malformed!" /> _quantity.
    /// </remarks>
    public static container getPurchasePrice(
        ItemId              _itemId,
        InventDim           _inventDim,
        UnitOfMeasureSymbol _unitSymbol,
        Qty                 _quantity,
        CustVendAC          _vendorAccountNumber,
        PriceGroupId        _priceGroupId,
        CurrencyCode        _currency
    )
    {
        PriceCur  priceCur;
        boolean   priceIsFound = false;

        PriceDiscParameters parameters = CatDisplayHelper::createAndInitPriceDiscParameters(
            _itemId,
            _inventDim,
            _unitSymbol,
            _quantity,
            _vendorAccountNumber,
            _currency);

        PriceDisc priceDisc = CatDisplayHelper::createPriceDiscInstance(parameters);

        // IMPORTANT: do not use priceDisc.findPrice(_priceGroupId) which does not use the right InventDimId!
        priceIsFound = priceDisc.findPriceAgreement(_priceGroupId, _inventDim.InventDimId);
        if (priceIsFound)
        {
            priceCur =  priceDisc.price();
        }

        return [priceIsFound, priceCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscInstance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDisc</c> class.
    /// </summary>
    /// <param name = "_parameters">An instance of the <c>PriceDiscParameters</c> class.</param>
    /// <returns>An instance of the <c>PriceDisc</c> class.</returns>
    protected static PriceDisc createPriceDiscInstance(PriceDiscParameters _parameters)
    {
        return PriceDisc::newFromPriceDiscParameters(_parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPriceDiscParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <returns>An instance of the <c>PriceDiscParameters</c> class.</returns>
    protected static PriceDiscParameters createPriceDiscParameters()
    {
        return PriceDiscParameters::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndInitPriceDiscParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of the <c>PriceDiscParameters</c> class.
    /// </summary>
    /// <param name = "_itemId">An <c>ItemId</c> value.</param>
    /// <param name = "_inventDim">An <c>InventDim</c> object.</param>
    /// <param name = "_unit">A <c>UnitOfMeasureSymbol</c> value.</param>
    /// <param name = "_quantity">A <c>Qty</c> value.</param>
    /// <param name = "_vendorAccountNumber">A <c>CustVendAC</c> value.</param>
    /// <param name = "_currency">A <c>CurrencyCode</c> value.</param>
    /// <returns></returns>
    protected static PriceDiscParameters createAndInitPriceDiscParameters(
        ItemId              _itemId,
        InventDim           _inventDim,
        UnitOfMeasureSymbol _unit,
        Qty                 _quantity,
        CustVendAC          _vendorAccountNumber,
        CurrencyCode        _currency)
    {
        PriceDiscParameters parameters = CatDisplayHelper::createPriceDiscParameters();

        parameters.parmModuleType(ModuleInventPurchSales::Purch);
        parameters.parmItemId(_itemId);
        parameters.parmInventDim(_inventDim);
        parameters.parmUnitID(_unit);
        parameters.parmPriceDiscDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        parameters.parmQty(_quantity);
        parameters.parmAccountNum(_vendorAccountNumber);
        parameters.parmCurrencyCode(_currency);

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRelatedProductsForProcurement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds all products related to the specified item and visible on the procurement site in the catalog.
    /// </summary>
    /// <param name="_inventTableRecId">
    ///    The record ID of the <c>InventTable</c> record for which to find related products.
    /// </param>
    /// <param name="_inventTableCompanyId">
    ///    The company in which to find released products.
    /// </param>
    /// <param name="_catDisplayCategoryTableRecId">
    ///    The ID of the <c>CatDisplayCategoryTableRecId</c> record that has the catalog for which to find
    ///    related products.
    /// </param>
    /// <param name="_maxCount">
    ///    The max number of related products to retrieve.
    /// </param>
    /// <returns>
    ///    A container of containers, each with detailed data about a related product.
    /// </returns>
    /// <remarks>
    ///    Only related products meeting all these criteria will be retrieved:
    ///    <list type="bullet">
    ///       <item>
    ///          <description>The product is released in the same legal entity as the specified item.</description>
    ///       </item>
    ///       <item>
    ///          <description>The relation type is not hidden in the catalog.</description>
    ///       </item>
    ///    </list>
    ///
    ///    Only products eligible for procurement will be returned.
    /// </remarks>
    public static container getRelatedProductsForProcurement(
        RefRecId    _inventTableRecId,
        CompanyId   _inventTableCompanyId,
        RefRecId    _catDisplayCategoryTableRecId,
        int         _maxCount = 5
        )
    {
        CatDisplayCategoryTable                 catDisplayCategoryTable;
        EcoResProduct                           ecoResProduct2;
        EcoResProductTranslation                ecoResProductTranslationPrimaryLanguage2;
        InventTable                             inventTable1;
        InventTable                             inventTable2;
        InventTableModule                       inventTableModule2;
        EcoResProductRelationTable              ecoResProductRelationTable;
        EcoResProductRelationType               ecoResProductRelationType;
        EcoResProductRelationTypeTranslation    ecoResProductRelationTypeTranslation;
        CatCatalogProductRelationType           catCatalogProductRelationType;
        CatUserReviewComputedProductRating      catUserReviewComputedProductRating;
        EcoResProductImage                      ecoResProductImage2;
        CompanyInfo                             companyInfo2;
        Ledger                                  ledger;
        Currency                                currency2;
        str                                     publishedThumbNailFileName;
        EcoResProductName                       productName;
        Name                                    productRelationTypeName;
        CatDisplayProductSiteAllActive          displayProductSiteAllActive;
        EcoResProductCategory                   ecoResProductCategory2;
        EcoResCategory                          ecoResCategory2;
        EcoResCategoryHierarchyRole             ecoResCategoryHierarchyRole2;

        container                               result;

        changecompany(_inventTableCompanyId)
        {
            while select RecId from ecoResProductRelationTable
                order by catCatalogProductRelationType.DisplayOrder
                join RecId from inventTable1
                    where  inventTable1.Product    == ecoResProductRelationTable.Product1
                        && inventTable1.RecId      == _inventTableRecId
                join Name from ecoResProductRelationType
                    where ecoResProductRelationType.RecId == ecoResProductRelationTable.ProductRelationType
                outer join FriendlyName from ecoResProductRelationTypeTranslation
                    where  ecoResProductRelationTypeTranslation.ProductRelationType == ecoResProductRelationType.RecId
                        && ecoResProductRelationTypeTranslation.Language == SysTranslationHelper::getPrimaryLanguage()
                join RecId from ecoResProduct2
                    where ecoResProduct2.RecId == ecoResProductRelationTable.Product2
                outer join Name from ecoResProductTranslationPrimaryLanguage2
                    where  ecoResProductTranslationPrimaryLanguage2.Product == ecoResProduct2.RecId
                        && ecoResProductTranslationPrimaryLanguage2.LanguageId == SysTranslationHelper::getPrimaryLanguage()
                // to get Rating
                outer join AverageRating , NumRatings from catUserReviewComputedProductRating
                    where catUserReviewComputedProductRating.Product == ecoResProduct2.RecId
                // make sure it's also released, in the same LE
                // - this conveniently also ensures that ecoResProduct2 is
                // -- either a distinct product (no variant/no generic)
                // -- or     a generic  product (w/ variant)
                // -- not the variant (which, when released, has a record in InventDimCombination, but not in InventTable)
                join RecId from inventTable2
                    where inventTable2.Product == ecoResProductRelationTable.Product2
                // to get price
                join RecId from inventTableModule2
                    where  inventTableModule2.ItemId == inventTable2.ItemId
                        // This code is only for Purchasing:
                        && inventTableModule2.ModuleType == ModuleInventPurchSales::Purch
                // to get currency
                join RecId from companyInfo2
                    where companyInfo2.DataArea == _inventTableCompanyId
                join RecId from ledger
                    where ledger.PrimaryForLegalEntity == companyInfo2.RecId
                join RecId from currency2
                    where ledger.AccountingCurrency == currency2.CurrencyCode
                // to exclude the related products whose relation type shouldn't be visible in the catalog
                join DisplayOrder from catCatalogProductRelationType
                    where catCatalogProductRelationType.ProductRelationType == ecoResProductRelationType.RecId
                join RecId from catDisplayCategoryTable
                    where catDisplayCategoryTable.Catalog == catCatalogProductRelationType.Catalog
                        && catDisplayCategoryTable.RecId == _catDisplayCategoryTableRecId
                // to get image info if available
                // use * since, you don't know what fields getPublishedThumbNailFileName needs
                outer join * from ecoResProductImage2
                    where  ecoResProductImage2.RefRecord == ecoResProductRelationTable.Product2
                        && ecoResProductImage2.DefaultImage == NoYes::Yes
                        && ecoResProductImage2.Usage == EcoResProductImageUsage::External
                join Category from ecoResProductCategory2
                    where  ecoResProductCategory2.Product == ecoResProduct2.RecId
                join RecId from ecoResCategory2
                    where  ecoResProductCategory2.Category == ecoResCategory2.RecId
                join RecId from ecoResCategoryHierarchyRole2
                    where  ecoResCategoryHierarchyRole2.CategoryHierarchy == ecoResCategory2.CategoryHierarchy
                        && ecoResCategoryHierarchyRole2.NamedCategoryHierarchyRole == EcoResCategoryNamedHierarchyRole::Procurement
                // cannot use inner-join since multiple records in displayProductSiteAllActive may exist for a single ecoResProduct2:
                exists join RecId from displayProductSiteAllActive
                    where  displayProductSiteAllActive.ProductRecId == ecoResProduct2.RecId
            {
                // NOTE: we use slightly inefficient API call for this check, knowing that a given product normally does not have too many related products.
                // The more efficient way is to expand above query - but then we'd need two copies of the above query, which is already massive, and creates maintenance nightmare:
                // - one copy that's identical to above, for the case when there is no purchasing policy
                // - one copy that's above, plus a join to ProcCategoryAccessPolicyParameter, for the case when there is purchasing policy
                if (ProcCategoryAccessPolicyParameter::procurementCategoryAllowedByPolicy(ecoResProductCategory2.Category))
                {
                    if (ecoResProductImage2.RecId)
                    {
                        publishedThumbNailFileName = ecoResProductImage2.getPublishedThumbNailFileName();
                    }
                    else
                    {
                        publishedThumbNailFileName = '';
                    }

                    if (ecoResProductTranslationPrimaryLanguage2)
                    {
                        productName = ecoResProductTranslationPrimaryLanguage2.Name;
                    }
                    else
                    {
                        productName = '';
                    }

                    if (ecoResProductRelationTypeTranslation)
                    {
                        productRelationTypeName = ecoResProductRelationTypeTranslation.FriendlyName;
                    }
                    else if (ecoResProductRelationType)
                    {
                        productRelationTypeName = ecoResProductRelationType.Name;
                    }
                    else
                    {
                        productRelationTypeName = '';
                    }
                    result = conIns(result, (1+conLen(result)),
                    [
                            catCatalogProductRelationType.DisplayOrder
                        ,   productRelationTypeName
                        ,   inventTable2.RecId
                        ,   productName
                        ,   currency2.Symbol
                        ,   inventTableModule2.Price
                        ,   publishedThumbNailFileName
                        ,   catUserReviewComputedProductRating.AverageRating
                        ,   catUserReviewComputedProductRating.NumRatings
                    ]);
                    if (conLen(result) >= _maxCount)
                    {
                        break;
                    }
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
            <Method>
				<Name>imageName</Name>
				<Source><![CDATA[
    internal static str imageName(Common _record, fieldId _fieldId)
    {
        return 'image_'+int2str(_record.TableId)+'_'+int2str(_fieldId)+'_'+int642str(_record.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageType</Name>
				<Source><![CDATA[
    internal static str imageType(Common _record)
    {
        str type;
        fieldId id = fieldname2id(_record.TableId, 'imageformat');
        if (id)
        {
            type = _record.(id);
        }
        return type ? type : 'gif';
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduloForReal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the remainder of the modulus operation on the given real numbers.
    /// </summary>
    /// <param name="_dividend">
    /// The dividend (in X++ type) of the modulus operation.
    /// </param>
    /// <param name="_divisor">
    /// The divisor (in X++ type) of the modulus operation.
    /// </param>
    /// <returns>
    /// The remainder (in X++ type.).
    /// </returns>
    /// <remarks>
    /// The X++ MOD (modulo) operator only works well on Integer values. The operator loses precision on
    /// real numbers.If the given divisor is 0, the result is a random number and it must not be used.
    /// </remarks>
    public static real moduloForReal(real _dividend, real _divisor)
    {
        // Note: do not use X++ == or != operators on two System.Decimal types
        //  - even when both vars (eg, csD1, csD2) are 0.0, csD1==csD2 would return FALSE.
        // If needed, use System.Decimal::op_Equality instead.
        //  The result is System.Boolean - its implicit cast to X++ boolean is correct.
        System.Decimal dotNetDividend  = CLRInterop::getObjectForAnyType(_dividend);
        System.Decimal dotNetDivisor   = CLRInterop::getObjectForAnyType(_divisor);
        System.Decimal dotNetRemainder;
        real           remainder;

        if (_divisor != 0)
        {
            dotNetRemainder = System.Decimal::op_Modulus(dotNetDividend, dotNetDivisor);
            remainder = CLRInterop::getAnyTypeForObject(dotNetRemainder);
        }

        return remainder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>priceGroupId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the <c>PriceGroupId</c> type for the line.
    /// </summary>
    /// <returns>
    ///    Always returns empty.
    /// </returns>
    public static PriceGroupId priceGroupId()
    {
        // Return blank as cart lines don't have price groups associated
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundDecimalByUnitOfMeasureRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the given decimal quantity using the precision data of the given unit of measure.
    /// </summary>
    /// <param name="_unitOfMeasureRecId">
    /// The record ID of a unit of measure by which to round.
    /// </param>
    /// <param name="_quantity">
    /// The decimal quantity to round.
    /// </param>
    /// <returns>
    /// The rounded quantity.
    /// </returns>
    public static Qty roundDecimalByUnitOfMeasureRecId(
        UnitOfMeasureRecId  _unitOfMeasureRecId,
        Qty                 _quantity
    )
    {
        Qty             result = _quantity;

        if (_unitOfMeasureRecId)
        {
            result = decRound(_quantity, UnitOfMeasure::unitOfMeasureDecimalPrecision(_unitOfMeasureRecId));
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundDecimalByUnitOfMeasureSymbol</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rounds the given decimal quantity using the precision data of a given unit of measure.
    /// </summary>
    /// <param name="_symbol">
    /// The symbol of a unit of measure by which to round.
    /// </param>
    /// <param name="_quantity">
    /// The decimal quantity to round.
    /// </param>
    /// <returns>
    /// The rounded quantity.
    /// </returns>
    public static Qty roundDecimalByUnitOfMeasureSymbol(
        UnitOfMeasureSymbol _symbol, // AKA, UnitId
        Qty                 _quantity
    )
    {
        Qty             result = _quantity;
        UnitOfMeasure   uofm;

        if (_symbol)
        {
            uofm = UnitOfMeasure::findBySymbol(_symbol);
            if (uofm)
            {
                result = CatDisplayHelper::roundDecimalByUnitOfMeasureRecId(uofm.RecId, _quantity);
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryAddToCart</Name>
				<Source><![CDATA[
    /// <summary>
    /// Attempts to automatically add the given item to the shopping cart of the current logon user.
    /// </summary>
    /// <param name="_inventTableRecId">
    /// The record ID of the <c>InventTable</c> to attempt to add to cart.
    /// </param>
    /// <returns>
    /// true if given item was successfully added to the cart; otherwise, false.
    /// </returns>
    public static boolean tryAddToCart(RecId _inventTableRecId)
    {
        #CatConstants
        boolean         result = false;
        CatProcurementCache cache = CatProcurementCache::getCache();
        InventTable     inventTable = InventTable::findRecId(_inventTableRecId);
        CatCartLine     createdLine;
        container       setupContainer, taContainer, atA, itA;
        Qty             setupDefaultQty;
        Qty             setupMultiQty;
        Qty             setupMinQty;
        Qty             setupMaxQty;
        AccountNum      vendorAccountNum;
        CurrencyCode    currencyCode;
        RecId           productRecId;
        InventDimId     inventDimId;
        boolean         singleVariation = true; // if there are multiple TA, are they for the same variation (Product/Vendor/Dim)?
        int             taIndex;

        if (_inventTableRecId && cache && cache.EmployerDataAreaId)
        {
            changecompany(cache.EmployerDataAreaId)
            {
                inventTable = InventTable::findRecId(_inventTableRecId);
            }

            if (inventTable)
            {
                [setupContainer, taContainer] = CatDisplayHelper::findPurchaseTradeAgreements(inventTable.ItemId, inventTable.company());
                if (setupContainer && (conLen(setupContainer) >= #SetupIndexForMaxQuantity))
                {
                    setupMultiQty   = conPeek(setupContainer, #SetupIndexForMultiQuantity);
                    setupDefaultQty = conPeek(setupContainer, #SetupIndexForDefaultQuantity);
                    setupMinQty     = conPeek(setupContainer, #SetupIndexForMinQuantity);
                    setupMaxQty     = conPeek(setupContainer, #SetupIndexForMaxQuantity);

                    if (taContainer && (conLen(taContainer) >= 1))
                    {
                        atA = conPeek(taContainer, 1);
                        // if multiple: ensure they're all for same "variation" (ie vendor/dim/product):
                        if (conLen(taContainer) > 1)
                        {
                            for (taIndex=2; taIndex<=conLen(taContainer); taIndex++)
                            {
                                itA = conPeek(taContainer, taIndex);
                                if ( (conPeek(atA, #TradeAgreementIndexForProductRecId    ) != conPeek(itA, #TradeAgreementIndexForProductRecId    ))
                                ||  (conPeek(atA, #TradeAgreementIndexForInventDimId     ) != conPeek(itA, #TradeAgreementIndexForInventDimId     ))
                                ||  (conPeek(atA, #TradeAgreementIndexForVendorAccountNum) != conPeek(itA, #TradeAgreementIndexForVendorAccountNum))
                                )
                                {
                                    singleVariation = false;
                                }
                            }
                        }

                        if (singleVariation)
                        {
                            vendorAccountNum= conPeek(atA, #TradeAgreementIndexForVendorAccountNum);
                            productRecId    = conPeek(atA, #TradeAgreementIndexForProductRecId);
                            inventDimId     = conPeek(atA, #TradeAgreementIndexForInventDimId);
                            currencyCode    = conPeek(atA, #TradeAgreementIndexForCurrencyCode);

                            // We'll automatically add to cart if all the following are true:
                            // - no dimension to choose, or only one possible combination to use
                            // - default quantity is 1 by setup (and multi-quantity is 1)
                            // - exactly 1 vendor to choose from
                            //   -- if the vendor has multiple TradeAgreement, they must all for the same Dim/Product.
                            if (    (vendorAccountNum != '')
                                && productRecId
                                && ((setupMultiQty  == 0) ||  (CatDisplayHelper::moduloForReal(#SetupMultiQuantityForAutoAddToCart, setupMultiQty) == 0))
                                && ((setupDefaultQty== 0) ||  (#SetupMultiQuantityForAutoAddToCart == setupDefaultQty))
                                && ((setupMinQty    == 0) ||  (#SetupMultiQuantityForAutoAddToCart >= setupMinQty))
                                && ((setupMaxQty    == 0) ||  (#SetupMultiQuantityForAutoAddToCart <= setupMaxQty))
                            )
                            {
                                createdLine = CatCartLine::createDistinctProductLine(
                                    inventTable.company(),
                                    productRecId,
                                    #SetupMultiQuantityForAutoAddToCart,
                                    vendorAccountNum,
                                    0,
                                    inventTable.ItemId,
                                    inventDimId,
                                    currencyCode
                                );
                                result = createdLine.RecId;
                            }
                        }
                    }
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>