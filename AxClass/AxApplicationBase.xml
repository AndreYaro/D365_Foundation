<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AxApplicationBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
class AxApplicationBase extends AxInternalBase
{
    boolean             inventDimIdDirtySaved;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes internal values of the current AxBC class.
    /// </summary>
    protected void init()
    {
        super();
        inventDimIdDirtySaved   = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emptyRecord</Name>
				<Source><![CDATA[
    protected Common emptyRecord()
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>end</Name>
				<Source><![CDATA[
    public void end()
    {
        super();
        if (inventDimIdDirtySaved)
        {
            throw error("@SYS54831");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>axCurrencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to currency code identification by using the map policy that is
    ///    passed to the AxBC table class.
    /// </summary>
    /// <param name="_currencyCode">
    ///    The value of the currency code identification that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axCurrencyCode</c> method is only used internally in the AxBC table classes.The map policy
    ///    is set up in the value mapping form.
    /// </remarks>
    /*This method converts a currency by using the MapPolicy that is given for the internal class*/
    protected str axCurrencyCode(str _currencyCode)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(Currency);
        XMLMapCurrencyCode  xmlMapCurrencyCode;
        CurrencyExtCodeId   currencyExtCodeId;

        xmlMapCurrencyCode = this.mapPolicy().xMLMapCurrencyCode();
        currencyExtCodeId  = this.mapPolicy().currencyExtCodeId();

        if (!_currencyCode || xmlMapCurrencyCode == XMLMapCurrencyCode::NotSpecified)
        {
            return _currencyCode;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapCurrencyCode(xmlMapCurrencyCode,
                                                               tableId,
                                                               _currencyCode,
                                                               currencyExtCodeId,
                                                               '');
            return xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapCurrencyCode(xmlMapCurrencyCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _currencyCode,
                                                               currencyExtCodeId,
                                                               '');
            return xmlCode2AxId.axId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>axLogisticsAddressCountryRegionId</Name>
				<Source><![CDATA[
    /*This method converts a CountryId by using the MapPolicy that is given for the internal class*/
    protected str axLogisticsAddressCountryRegionId(str _logisticsAddressCountryRegionId)
    {
        XMLAxId2Code                    xmlAxId2Code;
        XMLCode2AxId                    xmlCode2AxId;
        tableId                         tableId = tableNum(LogisticsAddressCountryRegion);
        XMLMapExternalCode              xmlMapExternalCode;
        AddressCountryRegionExtCodeId   countryExtCodeId;
        str                             countryRegionId;

        xmlMapExternalCode = this.mapPolicy().xMLMapCountryRegion();
        countryExtCodeId   = this.mapPolicy().countryRegionExtCodeId();

        if (!_logisticsAddressCountryRegionId || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _logisticsAddressCountryRegionId;
        }
        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _logisticsAddressCountryRegionId,
                                                               countryExtCodeId,
                                                               '');
            countryRegionId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _logisticsAddressCountryRegionId,
                                                               countryExtCodeId,
                                                               '');
            countryRegionId = xmlCode2AxId.axId();
        }

        return countryRegionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axLogisticsAddressCountyId</Name>
				<Source><![CDATA[
    /* This method converts a countyId using the MapPolicy that is given for the internal class*/
    protected str axLogisticsAddressCountyId(str _countyId, LogisticsAddressCountryRegionId _logisticsAddressCountryRegionId,LogisticsAddressStateId _logisticsAddressStateId)
    {
        XMLAxId2Code            xmlAxId2Code;
        XMLCode2AxId            xmlCode2AxId;
        tableId                 tableId = tableNum(LogisticsAddressCounty);
        XMLMapExternalCode      xmlMapExternalCode;
        AddressCountyExtCodeId  countyExtCodeId;
        str                     countyId;

        xmlMapExternalCode = this.mapPolicy().xMLMapCounty();
        countyExtCodeId    = this.mapPolicy().countyExtCodeId();

        if (!_countyId || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _countyId;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               [_logisticsAddressCountryRegionId,_logisticsAddressStateId,_countyId],
                                                               countyExtCodeId,
                                                               '');
            countyId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _countyId,
                                                               countyExtCodeId,
                                                               [_logisticsAddressCountryRegionId,_logisticsAddressStateId]);
            countyId = xmlCode2AxId.axId();
        }

        return countyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axLogisticsAddressStateId</Name>
				<Source><![CDATA[
    /* This method converts a stateId using the MapPolicy that is given for the internal class*/
    protected str axLogisticsAddressStateId(str _stateId, LogisticsAddressCountryRegionId _logisticsAddressCountryRegionId)
    {
        XMLAxId2Code            xmlAxId2Code;
        XMLCode2AxId            xmlCode2AxId;
        tableId                 tableId = tableNum(LogisticsAddressState);
        XMLMapExternalCode      xmlMapExternalCode;
        AddressStateExtCodeId   logisticsAddressStateExtCodeId;
        str                     stateId;

        xmlMapExternalCode    = this.mapPolicy().xMLMapState();
        logisticsAddressStateExtCodeId = this.mapPolicy().stateExtCodeId();

        if (!_stateId || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _stateId;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               [_logisticsAddressCountryRegionId,_stateId],
                                                               logisticsAddressStateExtCodeId,
                                                               '');
            stateId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _stateId,
                                                               logisticsAddressStateExtCodeId,
                                                               _logisticsAddressCountryRegionId);
            stateId = xmlCode2AxId.axId();
        }

        return stateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axLogisticsAddressZipCodeId</Name>
				<Source><![CDATA[
    /*This method converts a ZipCode by using the MapPolicy that is given for the internal class*/
    protected str axLogisticsAddressZipCodeId(str _logisticsAddressZipCodeId)
    {
        XMLAxId2Code            xmlAxId2Code;
        XMLCode2AxId            xmlCode2AxId;
        tableId                 tableId = tableNum(LogisticsAddressZipCode);
        XMLMapExternalCode      xmlMapExternalCode;
        AddressZipCodeExtCodeId logisticsAddressZipCodeExtCodeId;
        str                     zipCodeId;

        xmlMapExternalCode      = this.mapPolicy().xMLMapZipCode();
        logisticsAddressZipCodeExtCodeId = this.mapPolicy().zipCodeExtCodeId();

        if (!_logisticsAddressZipCodeId || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _logisticsAddressZipCodeId;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _logisticsAddressZipCodeId,
                                                               logisticsAddressZipCodeExtCodeId,
                                                               '');
            zipCodeId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _logisticsAddressZipCodeId,
                                                               logisticsAddressZipCodeExtCodeId,
                                                               '');
            zipCodeId = xmlCode2AxId.axId();
        }

        return zipCodeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axCustAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to customer accounts by using the map policy that is passed to the
    ///    AxBC table class.
    /// </summary>
    /// <param name="_custAccount">
    ///    The value of the customer account that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axCustAccount</c> method is only used internally in the AxBC table classes.The map policy is
    ///    set up in the value mapping form.
    /// </remarks>
    /*This method converts a CustAccount by using the MapPolicy that is given for the internal class*/
    protected str axCustAccount(str _custAccount)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(CustTable);
        XMLMapExternalCode  xmlMapExternalCode;
        CustExtCodeId       custExtCodeId;
        str                 custAccount;

        xmlMapExternalCode = this.mapPolicy().xMLMapCustAccount();
        custExtCodeId      = this.mapPolicy().custAccountExtCodeId();

        if (!_custAccount || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _custAccount;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _custAccount,
                                                               custExtCodeId,
                                                               '');
            custAccount = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _custAccount,
                                                               custExtCodeId,
                                                               '');
            custAccount = xmlCode2AxId.axId();
        }

        return custAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axVendAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to customer account identification by using the map policy that is
    ///    passed to the AxBC table class.
    /// </summary>
    /// <param name="_vendAccount">
    ///    The value of the customer account identification that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axVendAccount</c> method is only used internally in the AxBC table classes.The map policy is
    ///    set up in the value mapping form.
    /// </remarks>
    /*This method converts a VendAccount by using the MapPolicy that is given for the internal class*/
    protected VendAccount axVendAccount(str _vendAccount)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(VendTable);
        XMLMapExternalCode  xmlMapExternalCode;
        VendExtCodeId       vendExtCodeId;
        str                 vendAccount;

        xmlMapExternalCode = this.mapPolicy().xMLMapVendAccount();
        vendExtCodeId      = this.mapPolicy().vendAccountExtCodeId();

        if (!_vendAccount || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _vendAccount;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _vendAccount,
                                                               vendExtCodeId,
                                                               '');
            vendAccount = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _vendAccount,
                                                               vendExtCodeId,
                                                               '');
            vendAccount = xmlCode2AxId.axId();
        }

        return vendAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axCustMarkupCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to markup codes for customers by using the map policy that is passed
    ///    to the AxBC table class.
    /// </summary>
    /// <param name="_markupCode">
    ///    The value of the markup code that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axCustMarkupCode</c> method is only used internally in the AxBC table classes.The map policy
    ///    is set up in the value mapping form.
    /// </remarks>
    /*This method converts a markup code for a customer using by using
    the MapPolicy that is given for the internal class*/
    protected str axCustMarkupCode(str  _markupCode)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(MarkupTable);
        XMLMapExternalCode  xmlMapExternalCode;
        MarkupExtCodeId     markupExtCodeId;
        str                 markupCode;

        xmlMapExternalCode = this.mapPolicy().xMLMapMarkup();
        markupExtCodeId    = this.mapPolicy().markupExtCodeId();

        if (!_markupCode || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _markupCode;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               [ModuleInventCustVend::Cust,_markupCode],
                                                               markupExtCodeId,
                                                               '');
            markupCode = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::Cust,
                                                               _markupCode,
                                                               markupExtCodeId,
                                                               '');
            switch (typeOf(xmlCode2AxId.axId()))
            {
                case Types::Container:
                markupCode = conPeek(xmlCode2AxId.axId(),2);
                break;

                default:
                markupCode = xmlCode2AxId.axId();
            }
        }

        return markupCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axDlvModeId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to delivery mode identification by using the map policy that is
    ///    passed to the AxBC table class.
    /// </summary>
    /// <param name="_dlvModeId">
    ///    The value of the delivery mode identification that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axDlvModeId</c> method is only used internally in the AxBC table classes.The map policy is
    ///    set up in the value mapping form.
    /// </remarks>
    /*This method converts delivery Modes ID by using the MapPolicy that is given for the internal class*/
    protected str axDlvModeId(str _dlvModeId)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(DlvMode);
        XMLMapExternalCode  xmlMapExternalCode;
        DlvModeExtCodeId    dlvModeExtCodeId;
        str                 dlvModeId;

        xmlMapExternalCode = this.mapPolicy().xMLMapDlvMode();
        dlvModeExtCodeId   = this.mapPolicy().dlvModeExtCodeId();

        if (!_dlvModeId || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _dlvModeId;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _dlvModeId,
                                                               dlvModeExtCodeId,
                                                               '');
            dlvModeId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _dlvModeId,
                                                               dlvModeExtCodeId,
                                                               '');
            dlvModeId = xmlCode2AxId.axId();
        }

        return dlvModeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axDlvTermId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to delivery term identification by using the map policy that is
    ///    passed to the AxBC table class.
    /// </summary>
    /// <param name="_dlvTermId">
    ///    The value of the delivery term identification that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axDlvTermId</c> method is only used internally in the AxBC table classes.The map policy is
    ///    set up in the value mapping form.
    /// </remarks>
    /*This method converts delivery terms ID by using the MapPolicy that is given for the internal class*/
    protected str axDlvTermId(str _dlvTermId)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(DlvTerm);
        XMLMapExternalCode  xmlMapExternalCode;
        DlvTermExtCodeId    dlvTermExtCodeId;
        str                 dlvTermId;

        xmlMapExternalCode = this.mapPolicy().xMLMapDlvTerm();
        dlvTermExtCodeId   = this.mapPolicy().dlvTermExtCodeId();

        if (!_dlvTermId || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _dlvTermId;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _dlvTermId,
                                                               dlvTermExtCodeId,
                                                               '');
            dlvTermId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _dlvTermId,
                                                               dlvTermExtCodeId,
                                                               '');
            dlvTermId = xmlCode2AxId.axId();
        }
        return dlvTermId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts an item ID by using the MapPolicy that is given for the internal class.
    /// </summary>
    /// <param name="_itemId">
    /// An item ID to be converted.
    /// </param>
    /// <returns>
    /// A converted item ID if conversion is defined; otherwise, the value of the <paramref name="_itemId"/> parameter.
    /// </returns>
    protected ItemId axItemId(ItemId _itemId)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(InventTable);
        XMLMapItemId        xmlMapItemId;
        ItemExtCodeId       itemExtCodeId;
        ItemId              itemId;

        xmlMapItemId    = this.mapPolicy().xMLMapItemId();
        itemExtCodeId   = this.mapPolicy().itemExtCodeId();

        if (!_itemId || xmlMapItemId == xmlMapItemId::NotSpecified)
        {
            return _itemId;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapItemId(xmlMapItemId,
                                                               tableId,
                                                               _itemId,
                                                               itemExtCodeId,
                                                               '');
            itemId = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapItemId(xmlMapItemId,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _itemId,
                                                               itemExtCodeId,
                                                               '');
            itemId = xmlCode2AxId.axId();
        }

        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>axPurchItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to item identification by using the map policy that is passed to the
    ///    AxBC table class when a vendor is related.
    /// </summary>
    /// <param name="_vendAccount">
    ///    The value of the vendor account that is used for converting the item if the map policy is set to
    ///    external item number.
    /// </param>
    /// <param name="_itemId">
    ///    The value of the county identification that is to be converted.
    /// </param>
    /// <param name="_inventDim">
    ///    The value of the inventory dimension that is used for converting the item if the map policy is set
    ///    to external item number.
    /// </param>
    /// <returns>
    ///    The converted value for item identification, which is related inventory dimension record.
    /// </returns>
    /// <remarks>
    ///    The <c>axPurchItemId</c> method is only used internally in the AxBC table classes.The map policy is
    ///    set up in the value mapping form.The <c>axPurchItemId</c> method can also be used when there is no
    ///    customer or vendor related to the item by using the <paramref name="_vendAccount" /> parameter.
    /// </remarks>
    /*This method converts a Item for an Vendor by using the MapPolicy that is given for the internal class*/
    protected container axPurchItemId(VendAccount _vendAccount, str _itemId, InventDim _inventDim = null)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId;
        XMLMapItemId        xmlMapItemId;
        ItemExtCodeId       itemExtCodeId;
        InventDim           inventDim;
        anytype             foreignKey;
        str                 axItemId;
        InventDim           axInventDim;

        xmlMapItemId  = this.mapPolicy().xMLMapItemId();
        itemExtCodeId = this.mapPolicy().itemExtCodeId();

        if (!_itemId || xmlMapItemId == XMLMapItemId::NotSpecified)
        {
            return [_itemId,_inventDim];
        }

        switch (xmlMapItemId)
        {
            case XMLMapItemId::ExternalItemId:
                foreignKey  = _vendAccount;
                break;

            case XMLMapItemId::BarCode:
                foreignKey  = this.mapPolicy().barCodeSetupId();
                break;
        }

        tableId = xmlMapItemId == XMLMapItemId::ExternalItemId ? tableNum(VendTable) : tableNum(InventTable);
        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            if (xmlMapItemId == XMLMapItemId::Our && inventDim.InventDimId != InventDim::inventDimIdBlank())
            {
                _inventDim = InventDim::find(InventDim::inventDimIdBlank());
            }

            inventDim.data(_inventDim);
            inventDim.clearNotProductDim(InventDimGroupSetup::newItemId(_itemId));
            inventDim = InventDim::findOrCreate(inventDim);

            xmlAxId2Code = XMLAxId2Code::newXMLMapItemId(xmlMapItemId,
                                                         tableId,
                                                         [_itemId, inventDim],
                                                         itemExtCodeId,
                                                         foreignKey);
            if (xmlMapItemId == XMLMapItemId::Our && inventDim.InventDimId != InventDim::inventDimIdBlank())
            {
                throw error(strFmt("@SYS74300", XMLMapItemId::Our));
            }
            else
            {
                axItemId = xmlAxId2Code.xmlCode();
                axInventDim = InventDim::find(InventDim::inventDimIdBlank());
            }
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapItemId(xmlMapItemId,
                                                        tableId,
                                                        ExtCodeSubModule::None,
                                                        _itemId,
                                                        itemExtCodeId,
                                                        foreignKey);

            switch (typeOf(xmlCode2AxId.axId()))
            {
                case Types::Container:
                axItemId = conPeek(xmlCode2AxId.axId(),1);
                axInventDim = conPeek(xmlCode2AxId.axId(),2);
                break;

                default:
                axItemId = xmlCode2AxId.axId();
                axInventDim = InventDim::find(InventDim::inventDimIdBlank());
            }
        }

        return [axItemId,axInventDim];
    }

]]></Source>
			</Method>
			<Method>
				<Name>axSalesItemId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to item identification by using the map policy that is passed to the
    ///    AxBC table class when a customer is related.
    /// </summary>
    /// <param name="_custAccount">
    ///    The value of the customer account that is used for converting the item if the map policy is set to
    ///    external item number.
    /// </param>
    /// <param name="_itemId">
    ///    The value of the county identification that is to be converted.
    /// </param>
    /// <param name="_inventDim">
    ///    The value of the inventory dimension that is used for converting the item if the map policy is set
    ///    to external item number.
    /// </param>
    /// <returns>
    ///    The converted value for item identification, which is related inventory dimension record.
    /// </returns>
    /// <remarks>
    ///    The <c>axSalesItemId</c> method is only used internally in the AxBC table classes.The map policy is
    ///    set up in the value mapping form.The <c>axSalesItemId</c> method can also be used when there is no
    ///    customer or vendor related to the item by using the <paramref name="_custAccount" /> parameter.
    /// </remarks>
    /*This method converts a Item for an Vendor by using the MapPolicy that is given for the internal class*/
    protected container axSalesItemId(CustAccount _custAccount, str _itemId, InventDim _inventDim = null)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId;
        XMLMapItemId        xmlMapItemId;
        ItemExtCodeId       itemExtCodeId;
        InventDim           inventDim;
        anytype             foreignKey;
        str                 axItemId;
        InventDim           axInventDim;

        xmlMapItemId  = this.mapPolicy().xMLMapItemId();
        itemExtCodeId = this.mapPolicy().itemExtCodeId();

        if (!_itemId || xmlMapItemId == XMLMapItemId::NotSpecified)
        {
            return [_itemId,_inventDim];
        }

        switch (xmlMapItemId)
        {
            case XMLMapItemId::ExternalItemId:
                foreignKey  = _custAccount;
                break;

            case XMLMapItemId::BarCode:
                foreignKey  = this.mapPolicy().barCodeSetupId();
                break;
        }

        tableId = xmlMapItemId == XMLMapItemId::ExternalItemId ? tableNum(CustTable) : tableNum(InventTable);
        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            if (xmlMapItemId == XMLMapItemId::Our && inventDim.InventDimId != InventDim::inventDimIdBlank())
            {
                _inventDim = InventDim::find(InventDim::inventDimIdBlank());
            }

            inventDim.data(_inventDim);
            inventDim.clearNotProductDim(InventDimGroupSetup::newItemId(_itemId));
            inventDim = InventDim::findOrCreate(inventDim);

            xmlAxId2Code = XMLAxId2Code::newXMLMapItemId(xmlMapItemId,
                                                         tableId,
                                                         [_itemId, inventDim],
                                                         itemExtCodeId,
                                                         foreignKey);
            if (xmlMapItemId == XMLMapItemId::Our && inventDim.InventDimId != InventDim::inventDimIdBlank())
            {
                throw error(strFmt("@SYS74300", XMLMapItemId::Our));
            }
            else
            {
                axItemId = xmlAxId2Code.xmlCode();
                axInventDim = InventDim::find(InventDim::inventDimIdBlank());
            }
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapItemId(xmlMapItemId,
                                                        tableId,
                                                        ExtCodeSubModule::None,
                                                        _itemId,
                                                        itemExtCodeId,
                                                        foreignKey);

            switch (typeOf(xmlCode2AxId.axId()))
            {
                case Types::Container:
                axItemId = conPeek(xmlCode2AxId.axId(),1);
                axInventDim = conPeek(xmlCode2AxId.axId(),2);
                break;

                default:
                axItemId = xmlCode2AxId.axId();
                axInventDim = InventDim::find(InventDim::inventDimIdBlank());
            }
        }

        return [axItemId,axInventDim];
    }

]]></Source>
			</Method>
			<Method>
				<Name>axTaxCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    This method converts tax codes by using the map policy that is specified for the class.
    /// </summary>
    /// <param name="_taxCode">
    ///    The internal or external tax code to convert.
    /// </param>
    /// <returns>
    ///    The converted value of the tax code.
    /// </returns>
    protected TaxCode axTaxCode(TaxCode _taxCode)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(TaxTable);
        XMLMapExternalCode  xmlMapExternalCode;
        TaxExtCodeId        taxExtCodeId;
        ;

        xmlMapExternalCode = this.mapPolicy().xMLMapTaxCode();
        taxExtCodeId       = this.mapPolicy().taxExtCodeId();

        if (!_taxCode || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _taxCode;
        }

        switch (this.xmlDocDirection())
        {
            case XMLDocDirection::Outbound:
                xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _taxCode,
                                                               taxExtCodeId,
                                                               '');
                return xmlAxId2Code.xmlCode();

            case XMLDocDirection::Inbound:
            default:
                xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _taxCode,
                                                               taxExtCodeId,
                                                               '');
                return xmlCode2AxId.axId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>axVendMarkupCode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a value that relates to markup codes for vendors by using the map policy that is passed to
    ///    the AxBC table class.
    /// </summary>
    /// <param name="_markupCode">
    ///    The value of the markup code that is to be converted.
    /// </param>
    /// <returns>
    ///    The converted value.
    /// </returns>
    /// <remarks>
    ///    The <c>axVendMarkupCode</c> method is only used internally in the AxBC table classes.The map policy
    ///    is set up in the value mapping form.
    /// </remarks>
    /*This method converts a markup code for a vendor using by using
    the MapPolicy that is given for the internal class*/
    protected str axVendMarkupCode(str  _markupCode)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(MarkupTable);
        XMLMapExternalCode  xmlMapExternalCode;
        MarkupExtCodeId     markupExtCodeId;
        str                 markupCode;

        xmlMapExternalCode = this.mapPolicy().xMLMapMarkup();
        markupExtCodeId    = this.mapPolicy().markupExtCodeId();

        if (!_markupCode || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _markupCode;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               [ModuleInventCustVend::Vend,_markupCode],
                                                               markupExtCodeId,
                                                               '');
            markupCode = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::Vend,
                                                               _markupCode,
                                                               markupExtCodeId,
                                                               '');
            switch (typeOf(xmlCode2AxId.axId()))
            {
                case Types::Container:
                markupCode = conPeek(xmlCode2AxId.axId(),2);
                break;

                default:
                markupCode = xmlCode2AxId.axId();
            }
        }

        return markupCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInboundString</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the string length for an incoming string.
    /// </summary>
    /// <param name="_string">
    ///    The string that the length is to be validated for.
    /// </param>
    /// <param name="_dictField">
    ///    The <c>DictField</c> class for the field that the string relates to.
    /// </param>
    /// <param name="_xmlMapExternalCode">
    ///    The policy for how the string length is validated.
    /// </param>
    /// <remarks>
    ///    The <c>validateInboundString</c> method is used in parm&lt;FieldName&gt; methods that contain code
    ///    for performing value mapping.The <c>validateInboundString</c> method is created because
    ///    parm&lt;FieldName&gt; methods that are using value mapping use "str" as parameter type and
    ///    therefore do not have an extended data type to define the maximum length for the passed parameter.
    /// </remarks>
    //This method validates the string length for an inbound string
    protected void validateInboundString(str _string, DictField _dictField, XMLMapExternalCode _xmlMapExternalCode = XMLMapExternalCode::NotSpecified)
    {
        DictField   dictFieldExtCode;
        boolean     ret;

        super(_string, _dictField, _xmlMapExternalCode);

        if (validateInput)
        {
            if (this.valueMappingInbound())
            {
                if (_xmlMapExternalCode == XMLMapExternalCode::ExternalCode)
                {
                    dictFieldExtCode = new DictField(tableNum(ExtCodeValueTable),fieldNum(ExtCodeValueTable,ExtCodeValue));
                    ret = strLen(_string) > dictFieldExtCode.stringLen();
                }
            }

            if (ret)
            {
                error(strFmt("@SYS88485",_dictField.name()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInboundCurrencyString</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the string length for an incoming currency code string.
    /// </summary>
    /// <param name="_string">
    ///    The string that the length is to be validated for.
    /// </param>
    /// <param name="_dictField">
    ///    The <c>DictField</c> class for the field the string relates to.
    /// </param>
    /// <remarks>
    ///    The <c>validateInboundCurrencyString</c> method is used in parm&lt;FieldName&gt; methods where the
    ///    field relates to currency code.The <c>validateInboundCurrencyString</c> method is created because
    ///    parm&lt;FieldName&gt; methods that are using value mapping use "str" as parameter type and
    ///    therefore do not have an extended data type to define maximum length for the passed parameter.The
    ///    <c>validateInboundCurrencyString</c> method uses the <c>XMLMapCurrency</c> code that is defined in
    ///    the <see cref="M:AxInternalBase.mapPolicy" /> to define the maximum length of the incoming string.
    /// </remarks>
    //This method validates the string length for an inbound string relating to currency
    protected void validateInboundCurrencyString(str _string, DictField _dictField)
    {
        DictField           dictFieldExtCode;
        boolean             ret;
        XMLMapCurrencyCode  xmlMapCurrencyCode;

        if (validateInput)
        {
            if (this.valueMappingInbound())
            {
                xmlMapCurrencyCode = this.mapPolicy().xMLMapCurrencyCode();
                switch (xmlMapCurrencyCode)
                {
                    case XMLMapCurrencyCode::ExternalCode :
                        dictFieldExtCode = new DictField(tableNum(ExtCodeValueTable),fieldNum(ExtCodeValueTable,ExtCodeValue));
                        ret = strLen(_string) > dictFieldExtCode.stringLen();
                        break;

                    case XMLMapCurrencyCode::ISOCode :
                        dictFieldExtCode = new DictField(tableNum(Currency),fieldNum(Currency,CurrencyCodeISO));
                        ret = strLen(_string) > dictFieldExtCode.stringLen();
                        break;

                    default :
                        ret = strLen(_string) > _dictField.stringLen();
                }
            }
            else
            {
                ret = strLen(_string) > _dictField.stringLen();
            }

            if (ret)
            {
                error(strFmt("@SYS88485",_dictField.name()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInboundItemIdString</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the string length for an incoming string that relates to item Id.
    /// </summary>
    /// <param name="_string">
    ///    The string that the length is to be validated for.
    /// </param>
    /// <param name="_dictField">
    ///    The <c>DictField</c> class for the field the string relates to.
    /// </param>
    /// <remarks>
    ///    The <c>validateInboundItemIdString</c> method is used in parm&lt;FieldName&gt; methods where the
    ///    field relates to item Id.The <c>validateInboundItemIdString</c> method is created because
    ///    parm&lt;FieldName&gt; methods that are using value mapping use "str" as parameter type and
    ///    therefore do not have an extended data type to define the maximum length for the passed
    ///    parameter.The <c>validateInboundItemIdString</c> method uses the <c>XMLMapItemId</c> code that is
    ///    defined in the <see cref="M:AxInternalBase.mapPolicy" /> to define the maximum length of the
    ///    incoming string.
    /// </remarks>
    //This method validates the string length for an inbound string relating to ItemId depending of the map policy
    protected void validateInboundItemIdString(str _string, DictField _dictField)
    {
        DictField       dictFieldExtCode;
        boolean         ret;
        XMLMapItemId    xmlMapItemId;

        if (validateInput)
        {
            if (this.valueMappingInbound())
            {
                xmlMapItemId = this.mapPolicy().xMLMapItemId();
                switch (xmlMapItemId)
                {
                    case XMLMapItemId::ExternalCode :
                        dictFieldExtCode = new DictField(tableNum(ExtCodeValueTable),fieldNum(ExtCodeValueTable,ExtCodeValue));
                        ret = strLen(_string) > dictFieldExtCode.stringLen();
                        break;

                    case XMLMapItemId::ExternalItemId :
                        dictFieldExtCode = new DictField(tableNum(CustVendExternalItem),fieldNum(CustVendExternalItem,ExternalItemId));
                        ret = strLen(_string) > dictFieldExtCode.stringLen();
                        break;

                    case XMLMapItemId::BarCode :
                        dictFieldExtCode = new DictField(tableNum(InventItemBarcode),fieldNum(InventItemBarcode,ItemBarCode));
                        ret = strLen(_string) > dictFieldExtCode.stringLen();
                        break;

                    default :
                        ret = strLen(_string) > _dictField.stringLen();
                }
            }
            else
            {
                ret = strLen(_string) > _dictField.stringLen();
            }

            if (ret)
            {
                error(strFmt("@SYS88485",_dictField.name()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>axUnitOfMeasureSymbol</Name>
				<Source><![CDATA[
    /*This method converts a unit of measure symbol by using the MapPolicy that is given for the internal class*/
    protected UnitOfMeasureSymbol axUnitOfMeasureSymbol(UnitOfMeasureSymbol _symbol)
    {
        XMLAxId2Code        xmlAxId2Code;
        XMLCode2AxId        xmlCode2AxId;
        tableId             tableId = tableNum(UnitOfMeasure);
        XMLMapExternalCode  xmlMapExternalCode;
        UnitExtCodeId       unitExtCodeId;
        UnitOfMeasureSymbol symbol;

        xmlMapExternalCode = this.mapPolicy().xmlMapUnitOfMeasureSymbol();
        unitExtCodeId      = this.mapPolicy().unitExtCodeId();

        if (!_symbol || xmlMapExternalCode == XMLMapExternalCode::NotSpecified)
        {
            return _symbol;
        }

        if (this.xmlDocDirection() == XMLDocDirection::Outbound)
        {
            xmlAxId2Code = XMLAxId2Code::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               _symbol,
                                                               unitExtCodeId,
                                                               '');
            symbol = xmlAxId2Code.xmlCode();
        }
        else
        {
            xmlCode2AxId = XMLCode2AxId::newXMLMapExternalCode(xmlMapExternalCode,
                                                               tableId,
                                                               ExtCodeSubModule::None,
                                                               _symbol,
                                                               unitExtCodeId,
                                                               '');
            symbol = xmlCode2AxId.axId();
        }

        return symbol;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>