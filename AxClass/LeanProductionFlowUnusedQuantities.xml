<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LeanProductionFlowUnusedQuantities</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>LeanProductionFlowUnusedQuantities</c> class calculates items and material present in a
///    production flow at a specified date.
/// </summary>
public class LeanProductionFlowUnusedQuantities
{
    #TimeConstants

    TransDateTime                       dateTime;
    TransDateTime                       lastBackflushCostingDateTime;
    RefRecId                            leanProductionFlowReferenceRecId;
    Map                                 mapResult;
    RecordSortedList                    recordSortedListResult;
    int                                 explosionLevel;

    Map                                 mapResultStarted;
    Map                                 mapResultCompleted;
    Map                                 mapResultWIP;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addPlanActivityServiceResult</Name>
				<Source><![CDATA[
    private void addPlanActivityServiceResult(
        Map                     _map,
        ItemId                  _itemId,
        InventDimId             _inventDimId,
        InventQty               _inventQty)
    {
        this.addResult(
            _itemId,
            _inventDimId,
            LeanCostingUnusedQtyType::Service,
            _inventQty,
            _map);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addResult</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds an item, inventory dimension, and quantity to the result.
    /// </summary>
    /// <param name="_itemId">
    ///    The <c>itemId</c> value to add to the result.
    /// </param>
    /// <param name="_inventDimId">
    ///    The <c>InventDimId</c> value to add to the result.
    /// </param>
    /// <param name="_leanCostingUnusedQtyType">
    ///    The <c>LeanCostingUnusedQtyType</c> enum value to add to the result.
    /// </param>
    /// <param name="_inventQty">
    ///    The <c>InventQty</c> value to add to the result.
    /// </param>
    /// <param name="_map">
    ///    The map to store the result.
    /// </param>
    /// <remarks>
    ///    The result is stored in a map. Item and inventory dimension IDs are the key. The quantity is the
    ///    value.
    /// </remarks>
    private void addResult(
        ItemId                   _itemId,
        InventDimId              _inventDimId,
        LeanCostingUnusedQtyType _leanCostingUnusedQtyType,
        InventQty                _inventQty,
        Map                      _map = mapResult)
    {
        //only item and site dimensions are required in the result
        InventDim inventDim = InventDim::find(_inventDimId);
        inventDim.clearNotSiteAndProductDim(InventDimGroupSetup::newItemId(_itemId));
        inventDim = InventDim::findOrCreate(inventDim);

        container containerMapKey = [_itemId,inventDim.InventDimId,_leanCostingUnusedQtyType];

        if (_map.exists(containerMapKey))
        {
            InventQty inventQty = _map.lookup(containerMapKey);
            inventQty += _inventQty;
            if (inventQty)
            {
                _map.insert(containerMapKey,inventQty);
            }
            else
            {
                _map.remove(containerMapKey);
            }
        }
        else
        {
            _map.insert(containerMapKey,_inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addResultOrExplosion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Explodes BOM and adds it to the result or adds the item, inventory dimension, and quantity to the
    /// result.
    /// </summary>
    /// <param name="_itemId">
    /// The <c>itemId</c> value to add to the result.
    /// </param>
    /// <param name="_inventDimId">
    /// The <c>InventDimId</c> value to add to the result.
    /// </param>
    /// <param name="_leanCostingUnusedQtyType">
    /// The <c>LeanCostingUnusedQtyType</c> enumeration value to add to the result.
    /// </param>
    /// <param name="_inventQty">
    /// The <c>InventQty</c> value to add to the result.
    /// </param>
    /// <param name="_kanbanJob">
    /// The <c>KanbanJob</c> record that is the original source of the explosion.
    /// </param>
    /// <param name="_transDate">
    /// The date that is used when finding connected kanban rules.
    /// </param>
    /// <param name="_downStreamPlanActivityRefRecId">
    /// The <c>PlanActivity</c> record ID that is required to be connected to kanban rules found; optional.
    /// </param>
    /// <param name="_findReceiveFinished">
    /// A Boolean value that defines if connected rules must receive finished item; optional.
    /// </param>
    /// <param name="_addResultIfNoExplosion">
    /// A Boolean value that defines if the item itself should be added, if it is not exploded.
    /// </param>
    /// <param name="_dateTimeFrom">
    /// A temporal value that is used when finding connected kanban rules; optional.
    /// </param>
    /// <param name="_dateTimeTo">
    /// A temporal value that is used when finding connected kanban rules; optional.
    /// </param>
    private void addResultOrExplosion(
        ItemId                   _itemId,
        InventDimId              _inventDimId,
        LeanCostingUnusedQtyType _leanCostingUnusedQtyType,
        InventQty                _inventQty,
        KanbanJob                _kanbanJob,
        TransDate                _transDate,
        PlanActivityRefRecId     _downStreamPlanActivityRefRecId,
        boolean                  _findReceiveFinished    = true,
        boolean                  _addResultIfNoExplosion = true,
        TransDateTime            _dateTimeFrom = DateTimeUtil::newDateTime(_transDate,0),
        TransDateTime            _dateTimeTo   = DateTimeUtil::newDateTime(_transDate,#secondsPerDay-1)
        )
    {
        #define.maxExplosionLevel(100)
        InventDimParm                               inventDimParm;
        KanbanRule                                  kanbanRule;
        boolean                                     isAddedToResult;
        boolean                                     done;
        PlanActivityRefRecId                        downStreamPlanActivityRefRecId = _downStreamPlanActivityRefRecId;

        if (explosionLevel <= #maxExplosionLevel)
        {
            // initialize inventDim, inventDimParm
            InventDim inventDim = InventDim::find(_inventDimId);
            inventDim.clearNotSiteAndProductDim(InventDimGroupSetup::newItemId(_itemId));
            inventDim = InventDim::findOrCreate(inventDim);
            inventDimParm.initFromInventDim(inventDim);

            while (!done)
            {
                // find manufacturing rule that receives finished item and does not update on hand anywhere in the flow
                // use that rule as starting point to go through upstream connected rules, so that all
                // picking lines are considered
                KanbanFindRules kanbanFindRules = KanbanFindRules::newFromLeanProductionFlowReference(
                                                                            leanProductionFlowReferenceRecId,
                                                                            _itemId,
                                                                            _dateTimeFrom,
                                                                            _dateTimeTo
                                                                            ,
                                                                            inventDim.InventDimId,
                                                                            inventDimParm,
                                                                            true,
                                                                            true,
                                                                            true
                                                                            ,
                                                                            abs(_inventQty));

                kanbanFindRules.parmIncludeReceiveSemiFinished(
                                                               !_findReceiveFinished
                                                               );
                kanbanFindRules.parmIncludeReceiveFinished(
                                                           _findReceiveFinished
                                                           );
                kanbanFindRules.parmIncludeOnHandUpdateReceipt(false);
                kanbanFindRules.parmIncludeNotOnHandUpdateReceipt(true);
                kanbanFindRules.parmIncludePickupFinished(true);
                kanbanFindRules.parmIncludePickupSemiFinished(
                                                              true
                                                             );

                // always require a direct connection
                kanbanFindRules.parmLastPlanActivityDownstreamRecId(downStreamPlanActivityRefRecId);

                // exclude current rule, if looping
                kanbanFindRules.parmExcludeKanbanRuleRecId(kanbanRule.RecId);

                kanbanRule = kanbanFindRules.first();

                // in most cases the first loop would find the manufacturing rule
                // However, if it is a withdrawal rule, continue search further upstream
                done =    !kanbanRule
                       || kanbanRule.KanbanType != LeanKanbanType::Withdrawal;

                if (!done)
                {
                    // set for next rule search
                    downStreamPlanActivityRefRecId = kanbanRule.kanbanFlow().firstPlanActivity().RecId;
                }
            }

            if (kanbanRule)
            {
                // set flag, so that the item itself will not get added
                isAddedToResult = true;

                // create the picking list in memory
                KanbanJobPickingListCreateAsListCosting kanbanJobPickingListCreateAsListCosting = KanbanJobPickingListCreateAsListCosting::newStandard(
                                                                                                                                                _itemId,
                                                                                                                                                _inventDimId,
                                                                                                                                                abs(_inventQty),
                                                                                                                                                _transDate
                                                                                                                                                ,
                                                                                                                                                kanbanRule,
                                                                                                                                                _kanbanJob);

                explosionLevel++;

                this.addResultOrExplosionKanbanJobPickingList(
                                                        kanbanJobPickingListCreateAsListCosting,
                                                        _itemId,
                                                        _inventDimId,
                                                        _leanCostingUnusedQtyType,
                                                        _inventQty,
                                                        _kanbanJob,
                                                        _transDate,
                                                        kanbanRule,
                                                        _dateTimeFrom,
                                                        _dateTimeTo);

                explosionLevel--;
            }
        }

        if (   !isAddedToResult
            && _addResultIfNoExplosion
           )
        {
            // add the item itself, if no applicable rule is found
            this.addResult(_itemId,
                           _inventDimId,
                           _leanCostingUnusedQtyType,
                           _inventQty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addResultOrExplosionKanbanJobPickingList</Name>
				<Source><![CDATA[
    private void addResultOrExplosionKanbanJobPickingList(
        KanbanJobPickingListCreateAsList _kanbanJobPickingListCreateAsList,
        ItemId                           _itemId,
        InventDimId                      _inventDimId,
        LeanCostingUnusedQtyType         _leanCostingUnusedQtyType,
        InventQty                        _inventQty,
        KanbanJob                        _kanbanJob,
        TransDate                        _transDate,
        KanbanRule                       _kanbanRule,
        TransDateTime                    _dateTimeFrom = DateTimeUtil::newDateTime(_transDate,0),
        TransDateTime                    _dateTimeTo   = DateTimeUtil::newDateTime(_transDate,#secondsPerDay-1))
    {
        KanbanJobPickingList                        kanbanJobPickingList;
        KanbanRule                                  kanbanRule                       = _kanbanRule;
        KanbanJobPickingListCreateAsList            kanbanJobPickingListCreateAsList = _kanbanJobPickingListCreateAsList;

        if (   kanbanJobPickingListCreateAsList
            && kanbanRule)
        {
            // get upstream connected kanban rules of the initial rule
            KanbanRulesConnectedResourceCalc kanbanRulesConnectedResourceCalc = KanbanRulesConnectedResourceCalc::newStandard(
                                                                                                                         _kanbanRule,
                                                                                                                         _itemId,
                                                                                                                         _inventDimId,
                                                                                                                         _dateTimeFrom,
                                                                                                                         _dateTimeTo,
                                                                                                                         abs(_inventQty));

            while (kanbanRule)
            {
                RecordSortedList recordSortedList = kanbanJobPickingListCreateAsList.kanbanJobPickingListAsList();

                boolean done = !recordSortedList.first(kanbanJobPickingList);
                while (!done)
                {
                    int factor = _inventQty < 0 ? -1 : 1;

                    // the activity that the next level of rules is expected to be connected to
                    PlanActivity planActivity = kanbanJobPickingList.pickingPlanActivity();
                    planActivity = planActivity.isAtomic() ? planActivity.prevLevelPlanActivity() : planActivity;

                    // recursively explode the next level
                    this.addResultOrExplosion(
                                    kanbanJobPickingList.ItemId,
                                    kanbanJobPickingList.InventDimId,
                                    _leanCostingUnusedQtyType,
                                    kanbanJobPickingList.Quantity * factor,
                                    _kanbanJob,
                                    _transDate,
                                    planActivity.RecId,
                                    true,
                                    true,
                                    _dateTimeFrom,
                                    _dateTimeTo);

                    done = !recordSortedList.next(kanbanJobPickingList);
                }

                // next rule, if any
                do
                {
                    kanbanRule = kanbanRulesConnectedResourceCalc.moveNext()
                                    ? kanbanRulesConnectedResourceCalc.kanbanRule()
                                    : null;
                }
                // skip withdrawal rules
                while (   kanbanRule
                       && kanbanRule.KanbanType == LeanKanbanType::Withdrawal);

                if (kanbanRule)
                {
                    // create the next picking list
                    kanbanJobPickingListCreateAsList = KanbanJobPickingListCreateAsListCosting::newStandard(
                                                                                                        _itemId,
                                                                                                        _inventDimId,
                                                                                                        abs(_inventQty),
                                                                                                        _transDate,
                                                                                                        kanbanRule,
                                                                                                        _kanbanJob);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPlanActivityService</Name>
				<Source><![CDATA[
    private void calcPlanActivityService(
        Map                 _mapResults,
        KanbanJob           _kanbanJob,
        PlanActivity        _planActivity)
    {
        PlanActivityService planActivityService = PlanActivityService::findKanbanJob(_kanbanJob,true);

        if (planActivityService)
        {
            // get service quantity in service unit
            InventQty inventQty = _kanbanJob.serviceQuantity(planActivityService,_planActivity);

            if (inventQty)
            {
                InventTable inventTable = InventTable::find(planActivityService.ItemId);
                UnitOfMeasure unitOfMeasure = UnitOfMeasure::findBySymbol(inventTable.inventUnitId());

                // convert to inventory unit
                if (planActivityService.ServiceUnitOfMeasure != unitOfMeasure.RecId)
                {
                    inventQty = EcoResProductUnitConverter::convertForReleasedProduct(inventTable.ItemId,
                                                                                      planActivityService.ServiceItemInventDimId,
																					  inventQty,
																					  planActivityService.ServiceUnitOfMeasure,
																					  unitOfMeasure.RecId,
																					  NoYes::Yes);
                }

                if (inventQty)
                {
                    this.addPlanActivityServiceResult(
                        _mapResults,
                        planActivityService.ItemId,
                        planActivityService.mergeInventDim(_kanbanJob.inventDim(),true,false).InventDimId,
                        inventQty);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPlanActivityServiceCompleted</Name>
				<Source><![CDATA[
    private void calcPlanActivityServiceCompleted()
    {
        KanbanRule                          kanbanRule;
        KanbanFlow                          kanbanFlow;
        PlanPlanActivity                    planPlanActivity;
        Plan                                plan;
        LeanProductionFlowReference         leanProductionFlowReference;
        Kanban                              kanban;
        KanbanJob                           kanbanJob;
        PlanActivity                        planActivity;
        LeanProductionFlowActivity          leanProductionFlowActivity;
        PlanActivityService                 planActivityServiceExist;

        while select kanbanJob
            where kanbanJob.Status == LeanKanbanJobStatus::Completed
               && kanbanJob.ActualEndDateTime > lastBackflushCostingDateTime
               && kanbanJob.ActualEndDateTime <= dateTime
            join TableId from leanProductionFlowActivity
                where leanProductionFlowActivity.RecId == kanbanJob.LeanProductionFlowActivity
            join planActivity
                where planActivity.RecId == leanProductionFlowActivity.PlanActivity
            exists join planActivityServiceExist
                where planActivityServiceExist.PlanActivity == planActivity.RecId
            exists join kanban
                where kanban.RecId     == kanbanJob.Kanban
            exists join kanbanRule
                where kanbanRule.RecId == kanban.KanbanRule
            exists join kanbanFlow
                where kanbanFlow.RecId == kanbanRule.KanbanFlow
            exists join planPlanActivity
                where planPlanActivity.RecId == kanbanFlow.LastPlanPlanActivity
            exists join plan
                where plan.RecId == planPlanActivity.Plan
            exists join leanProductionFlowReference
                where leanProductionFlowReference.PlanReference == plan.PlanReference
                   && leanProductionFlowReference.RecId         == leanProductionFlowReferenceRecId
        {
            this.calcPlanActivityService(mapResultCompleted, kanbanJob, planActivity);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPlanActivityServiceStarted</Name>
				<Source><![CDATA[
    private void calcPlanActivityServiceStarted()
    {
        KanbanRule                          kanbanRule;
        KanbanFlow                          kanbanFlow;
        PlanPlanActivity                    planPlanActivity;
        Plan                                plan;
        LeanProductionFlowReference         leanProductionFlowReference;
        Kanban                              kanban;
        KanbanJob                           kanbanJob;
        PlanActivity                        planActivity;
        LeanProductionFlowActivity          leanProductionFlowActivity;
        PlanActivityService                 planActivityServiceExist;

        while select kanbanJob
            where kanbanJob.Status == LeanKanbanJobStatus::InProgress
               && kanbanJob.ActualStartDateTime <= dateTime
               && (kanbanJob.ActualEndDateTime  >= dateTime
               ||  !kanbanJob.ActualEndDateTime)
            join TableId from leanProductionFlowActivity
                where leanProductionFlowActivity.RecId == kanbanJob.LeanProductionFlowActivity
            join planActivity
                where planActivity.RecId == leanProductionFlowActivity.PlanActivity
            exists join planActivityServiceExist
                where planActivityServiceExist.PlanActivity == planActivity.RecId
            exists join kanban
                where kanban.RecId     == kanbanJob.Kanban
            exists join kanbanRule
                where kanbanRule.RecId == kanban.KanbanRule
            exists join kanbanFlow
                where kanbanFlow.RecId == kanbanRule.KanbanFlow
            exists join planPlanActivity
                where planPlanActivity.RecId == kanbanFlow.LastPlanPlanActivity
            exists join plan
                where plan.RecId == planPlanActivity.Plan
            exists join leanProductionFlowReference
                where leanProductionFlowReference.PlanReference == plan.PlanReference
                   && leanProductionFlowReference.RecId         == leanProductionFlowReferenceRecId
        {
            this.calcPlanActivityService(mapResultStarted, kanbanJob, planActivity);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcPlanActivityServiceWIP</Name>
				<Source><![CDATA[
    private void calcPlanActivityServiceWIP()
    {
        ProdCalcTrans               prodCalcTrans;

        TransDate localTransDate = DateTimeUtil::date(DateTimeUtil::applyTimeZoneOffset(dateTime, DateTimeUtil::getCompanyTimeZone()));

        while select Resource, InventDimId, sum(RealConsump) from prodCalcTrans
            group by prodCalcTrans.Resource, prodCalcTrans.InventDimId
            where prodCalcTrans.TransRefType == ProdTransRefType::ProductionFlow
                && prodCalcTrans.IdRefRecId == leanProductionFlowReferenceRecId
                && prodCalcTrans.CalcType == ItemCalcType::Service
                && prodCalcTrans.TransDate <= localTransDate
        {
            this.addPlanActivityServiceResult(
                mapResultWIP,
                prodCalcTrans.Resource,
                prodCalcTrans.InventDimId,
                prodCalcTrans.RealConsump);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnusedQuantitiesKanban</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the unused material of the kanbans.
    /// </summary>
    /// <remarks>
    /// This method covers two cases. The first requirement is to identify all withdrawal kanbans in the
    /// ended status where the kanban does not obtain semi-finished items and only the issue side is
    /// inventory controlled. The second requirement is to identify all kanbans in ended status that are
    /// not inventory controlled and do obtain semi-finished items. In this case the bill of materials is
    /// exploded and items are added to the result if they are flushed with the start principle.
    /// </remarks>
    private void calcUnusedQuantitiesKanban()
    {
        KanbanRule                          kanbanRule;
        KanbanFlow                          kanbanFlow;
        PlanPlanActivity                    planPlanActivity;
        Plan                                plan;
        LeanProductionFlowReference         leanProductionFlowReference;
        Kanban                              kanban;

        while select kanban
            where kanban.Status           >=
                                             LeanKanbanStatus::Assigned
               && (kanban.EmptiedDateTime >= dateTime
               ||  !kanban.EmptiedDateTime)
            join
            kanbanRule
                where kanbanRule.RecId == kanban.KanbanRule
            join TableId from kanbanFlow
                where kanbanFlow.RecId == kanbanRule.KanbanFlow
            join TableId from planPlanActivity
                where planPlanActivity.RecId == kanbanFlow.LastPlanPlanActivity
            join TableId from plan
                where plan.RecId == planPlanActivity.Plan
            join TableId from leanProductionFlowReference
                where leanProductionFlowReference.PlanReference == plan.PlanReference
                   && leanProductionFlowReference.RecId         == leanProductionFlowReferenceRecId
        {
            KanbanJob firstkanbanJob = kanban.firstKanbanJob();
            LeanProductionFlowActivity leanProductionFlowActivity = firstkanbanJob.leanProductionFlowActivity();
            KanbanJob lastKanbanJob = kanban.lastKanbanJob();

            // received before date/time?
            boolean isReceived = lastKanbanJob.Status == LeanKanbanJobStatus::Completed
                         && lastKanbanJob.ActualEndDateTime <= dateTime;

            // assigned before date/time?
            boolean isAssigned = !isReceived
                         && firstkanbanJob.Status >= LeanKanbanJobStatus::Prepared
                         && firstkanbanJob.ActualPreparedDateTime <= dateTime;

            if (isAssigned)
            {
                // in progress kanbans that do pick up semi finished items must be exploded
                if (   leanProductionFlowActivity
                    && leanProductionFlowActivity.PickUpSemiFinished)
                {
                    // manufacturing or withdrawal
                    // picking list lines for in progress kanbans themselves are not included here
                    // just need the upstream material
                    this.addResultOrExplosion(
                                kanban.ItemId,
                                firstkanbanJob.InventDimId,
                                LeanCostingUnusedQtyType::RawMaterial,
                                -kanban.QuantityOrdered,
                                lastKanbanJob,
                                kanban.bomValidDate(),
                                firstkanbanJob.planActivity().RecId,
                                !leanProductionFlowActivity.PickUpSemiFinished,
                                false);
                }
            }

            if (isReceived)
            {
                // handle received, but not emptied kanbans
                KanbanJob kanbanJob = lastKanbanJob;
                PlanActivity planActivity = lastKanbanJob.planActivity();

                if (!planActivity.onHandUpdate(PlanActivityType::Receive))
                {
                    boolean updateOnHandPick = planActivity.onHandUpdate(PlanActivityType::Pick);

                    if (!leanProductionFlowActivity.PickUpSemiFinished)
                    {
                        if (   kanban.Type == LeanKanbanType::Withdrawal
                            && updateOnHandPick)
                        {
                            // add kanban item to result
                            this.addResult(kanban.ItemId,
                                           kanbanJob.InventDimId,
                                           LeanCostingUnusedQtyType::RawMaterial,
                                           -kanban.QuantityReceived);
                        }
                    }

                    if (   !(kanban.Type == LeanKanbanType::Withdrawal
                        &&   updateOnHandPick))
                    {
                        // explode BOM and add components to result
                        if (kanban.type().canHaveBOM())
                        {
                            KanbanJobPickingListCreateAsList kanbanJobPickingListCreateAsList =
                                    KanbanJobPickingListCreateAsList::newStandard(
                                                                                  firstkanbanJob,
                                                                                  kanban
                                                                                  );
                            this.addResultOrExplosionKanbanJobPickingList(
                                                kanbanJobPickingListCreateAsList,
                                                kanban.ItemId,
                                                kanbanJob.InventDimId,
                                                LeanCostingUnusedQtyType::RawMaterial,
                                                -kanban.QuantityReceived,
                                                kanbanJob,
                                                kanban.bomValidDate(),
                                                kanbanRule);
                        }

                        else
                        {
                            if (kanban.Type == LeanKanbanType::Withdrawal)
                            {
                                if (leanProductionFlowActivity.PickUpSemiFinished)
                                {
                                    this.addResultOrExplosion(kanban.ItemId,
                                                              kanbanJob.InventDimId,
                                                              LeanCostingUnusedQtyType::RawMaterial,
                                                              -kanban.QuantityReceived,
                                                              kanbanJob,
                                                              kanban.bomValidDate(),
                                                              kanbanJob.planActivity().RecId,
                                                              !leanProductionFlowActivity.PickUpSemiFinished,
                                                              false);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnusedQuantitiesKanbanJobPickList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the consumed material of unfinished jobs.
    /// </summary>
    /// <remarks>
    /// For all kanban jobs that are started but not ended in the production flow, report all kanban job
    /// consumption with flushing principle start.
    /// </remarks>
    private void calcUnusedQuantitiesKanbanJobPickList()
    {
        KanbanRule                          kanbanRule;
        KanbanFlow                          kanbanFlow;
        PlanPlanActivity                    planPlanActivity;
        Plan                                plan;
        LeanProductionFlowReference         leanProductionFlowReference;
        Kanban                              kanban;
        KanbanJob                           kanbanJob;
        KanbanJobPickingList                kanbanJobPickingList;

        while select kanbanJobPickingList
            where kanbanJobPickingList.FlushingPrinciple
                                                         != FlushingPrincipKanban::Empty
            join kanbanJob
                where kanbanJob.RecId  == kanbanJobPickingList.Job
                   && ((kanbanJob.Status                       >= LeanKanbanJobStatus::Prepared
                   &&   kanbanJobPickingList.FlushingPrinciple == FlushingPrincipKanban::Prepare
                   &&   kanbanJob.ActualPreparedDateTime       <= dateTime)
                   ||  (kanbanJob.Status                       >= LeanKanbanJobStatus::Completed
                   &&   kanbanJobPickingList.FlushingPrinciple == FlushingPrincipKanban::End
                   &&   kanbanJob.ActualEndDateTime            <= dateTime))
            join kanban
                where kanban.RecId     == kanbanJob.Kanban
            exists join kanbanRule
                where kanbanRule.RecId == kanban.KanbanRule
            exists join kanbanFlow
                where kanbanFlow.RecId == kanbanRule.KanbanFlow
            exists join planPlanActivity
                where planPlanActivity.RecId == kanbanFlow.LastPlanPlanActivity
            exists join plan
                where plan.RecId == planPlanActivity.Plan
            exists join leanProductionFlowReference
                where leanProductionFlowReference.PlanReference == plan.PlanReference
                   && leanProductionFlowReference.RecId         == leanProductionFlowReferenceRecId
        {
            KanbanJob lastKanbanJob = kanban.lastKanbanJob();

            if (   lastKanbanJob.ActualEndDateTime >= dateTime
                || !lastKanbanJob.ActualEndDateTime)
            {
                boolean materialNotInWIP = false;

                if (lastKanbanJob.Type == LeanKanbanJobType::Transfer)
                {
                    PlanActivity transferPlanActivity = lastKanbanJob.planActivity();

                    // If the last kanban job of the kanban is a transfer activity that has update onhand on pick = yes and update onhand on receive = yes,
                    // then the material is not in WIP and should NOT be added to unused quantity.
                    materialNotInWIP = transferPlanActivity.onHandUpdate(PlanActivityType::Pick) && transferPlanActivity.onHandUpdate(PlanActivityType::Receive);
                }

                if (!materialNotInWIP)
                {
                    // the activity that the next level of rules is expected to be connected to
                    PlanActivity planActivity = kanbanJobPickingList.pickingPlanActivity();
                    planActivity = planActivity.isAtomic() ? planActivity.prevLevelPlanActivity() : planActivity;

                    this.addResultOrExplosion(kanbanJobPickingList.ItemId,
                                              kanbanJobPickingList.InventDimId,
                                              LeanCostingUnusedQtyType::RawMaterial,
                                              this.getKanbanJobPickingListQuantity(kanbanJobPickingList, planActivity),
                                              kanbanJob,
                                              kanban.bomValidDate(),
                                              planActivity.RecId,
                                              true,
                                              true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnusedQuantitiesPlanActivityService</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the unused service quantities.
    /// </summary>
    /// <remarks>
    /// The logic for computing the unused quantities respects this formula: UU = MIN ( S , MAX(0, WIP -
    /// C)) Where: UU = Unused quantityS = Started kanbans qtyWIP = Current WIP, current received qty by
    /// receiving/invoicing PO lines for subcontracted activitiesC = Completed kanbans qtyWIP is calculated
    /// based on the records in the <c>ProdCalcTrans</c> table that is assumed to be already updated to
    /// reflect the current WIP situation before this method is called.
    /// </remarks>
    private void calcUnusedQuantitiesPlanActivityService()
    {
        ItemId          currentItemId;
        InventDimId     currentInventDimId;
        InventQty       currentQtyStarted, currentQtyCompleted, currentQtyInWIP, currentQtyUnused;

        this.calcPlanActivityServiceStarted();
        this.calcPlanActivityServiceCompleted();
        this.calcPlanActivityServiceWIP();

        MapEnumerator me = mapResultStarted.getEnumerator();
        while (me.moveNext())
        {
            container containerMapKey = me.currentKey();

            [currentItemId, currentInventDimId] = containerMapKey;

            currentQtyStarted = me.currentValue();

            if (mapResultCompleted.exists(containerMapKey))
            {
                currentQtyCompleted = mapResultCompleted.lookup(containerMapKey);
            }
            else
            {
                currentQtyCompleted = 0;
            }

            if (mapResultWIP.exists(containerMapKey))
            {
                currentQtyInWIP = mapResultWIP.lookup(containerMapKey);
            }
            else
            {
                currentQtyInWIP = 0;
            }

            currentQtyUnused = min(currentQtyStarted, max(0, currentQtyInWIP - currentQtyCompleted));

            if (currentQtyUnused)
            {
                this.addResult(currentItemId,
                    currentInventDimId,
                    LeanCostingUnusedQtyType::Service,
                    -currentQtyUnused);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getKanbanJobPickingListQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// It returns the quantity with or without scrap based on the picking activity parameter RegisterScrap
    /// </summary>
    /// <param name="kanbanJobPickingList">
    /// A record of <c>KanbanJobPickingList</c>
    /// </param>
    /// <param name="planActivity">
    /// A record of <c>PlanActivity</c>
    /// </param>
    /// <returns>
    /// The <c>InventQty</c> value
    /// </returns>
    private InventQty getKanbanJobPickingListQuantity(KanbanJobPickingList kanbanJobPickingList, PlanActivity planActivity)
    {
        LeanRegisterScrap                   leanRegisterScrap;

        //By default use the quantity with scrap value
        InventQty quantity = kanbanJobPickingList.Quantity;

        //The quantity excluding scrap can only be used if the flushing principle is Finish
        if (kanbanJobPickingList.bomTable().ProdFlushingPrincip == ProdFlushingPrincipBOM::Finish)
        {
            LeanProductionFlowActivity leanProductionFlowActivity = LeanProductionFlowActivity::findPlanActivity(planActivity.RecId);
            LeanProdFlowActivityPickingLocation leanProdFlowActivityPickingLocation = leanProductionFlowActivity.leanProdFlowActivityPickingLocation(kanbanJobPickingList.ItemId, kanbanJobPickingList.inventDim());
            leanRegisterScrap = leanProdFlowActivityPickingLocation.editRegisterScrap(false, leanRegisterScrap);

            if (leanRegisterScrap == NoYes::No)
            {
                quantity =  kanbanJobPickingList.QuantityExcludingScrap;
            }
        }

        return -quantity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the class variables.
    /// </summary>
    private void init()
    {
        explosionLevel = 0;
        mapResult      = new Map(Types::Container,Types::Real);
        recordSortedListResult = new RecordSortedList(tableNum(LeanProductionFlowCostingUnusedQty));
        recordSortedListResult.sortOrder(fieldNum(LeanProductionFlowCostingUnusedQty, ItemId),
                                         fieldNum(LeanProductionFlowCostingUnusedQty, InventDimId),
                                         fieldNum(LeanProductionFlowCostingUnusedQty, UnusedQtyType));

        mapResultStarted    = new Map(Types::Container,Types::Real);
        mapResultCompleted  = new Map(Types::Container,Types::Real);
        mapResultWIP        = new Map(Types::Container,Types::Real);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDateTime</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TransDateTime parmDateTime(TransDateTime _dateTime = dateTime)
    {
        dateTime = _dateTime;
        return dateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLastBackflushCostingDateTime</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public TransDateTime parmLastBackflushCostingDateTime(TransDateTime _lastBackflushCostingDateTime = lastBackflushCostingDateTime)
    {
        lastBackflushCostingDateTime = _lastBackflushCostingDateTime;

        return lastBackflushCostingDateTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanProductionFlowReferenceRecId</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RefRecId parmLeanProductionFlowReferenceRecId(RefRecId _leanProductionFlowReferenceRecId = leanProductionFlowReferenceRecId)
    {
        leanProductionFlowReferenceRecId = _leanProductionFlowReferenceRecId;
        return leanProductionFlowReferenceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unusedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates the item and material quantities present in the production flow at a specified date.
    /// </summary>
    /// <returns>
    ///    The <c>RecordSortedList</c> object of the <c>ProdCalcTrans</c> records.
    /// </returns>
    /// <remarks>
    ///    The <c>ProdCalcTrans</c> record is sparsely populated.Only the <c>Resource</c>, <c>InventDimId</c>
    ///    and <c>Qty</c> fields will have a value.
    /// </remarks>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public RecordSortedList unusedQuantities()
    {
        LeanProductionFlowCostingUnusedQty  leanProductionFlowCostingUnusedQty;
        LeanCostingUnusedQtyType            leanCostingUnusedQtyType;
        ItemId                              itemId;
        InventDimId                         inventDimId;

        if (!this.validate())
        {
            throw error("@SYS18447");
        }

        if (!recordSortedListResult)
        {
            setPrefix(LeanProductionFlowUnusedQuantities::description());
            setPrefix(strFmt("@SYS313425",LeanProductionFlow::find(leanProductionFlowReferenceRecId).planReference().PlanName));

            this.init();
            this.calcUnusedQuantitiesKanban();
            this.calcUnusedQuantitiesKanbanJobPickList();
            this.calcUnusedQuantitiesPlanActivityService();

            MapEnumerator me = mapResult.getEnumerator();
            while (me.moveNext())
            {
                [itemId,inventDimId,leanCostingUnusedQtyType]    = me.currentKey();

                leanProductionFlowCostingUnusedQty.clear();
                leanProductionFlowCostingUnusedQty.ItemId        = itemId;
                leanProductionFlowCostingUnusedQty.InventDimId   = inventDimId;
                leanProductionFlowCostingUnusedQty.UnusedQtyType = leanCostingUnusedQtyType;
                leanProductionFlowCostingUnusedQty.UnusedQty     = me.currentValue();

                recordSortedListResult.ins(leanProductionFlowCostingUnusedQty);
            }
        }

        return recordSortedListResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the class parameters.
    /// </summary>
    /// <returns>
    ///    true if the specified parameters are valid; otherwise, false.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    protected boolean validate()
    {
        boolean result = true;

        if (LeanProductionFlowReference::find(leanProductionFlowReferenceRecId).legalEntity() != CompanyInfo::current())
        {
            result = checkFailed("@SYS332729");
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LeanProductionFlowUnusedQuantities</c> class.
    /// </summary>
    /// <returns>
    /// A new instance of the <c>LeanProductionFlowUnusedQuantities</c> class.
    /// </returns>
    /// <remarks>
    ///  Use the following procedure to customize or extend the
    ///  <c>
    ///   LeanProductionFlowUnusedQuantities
    ///  </c>
    ///   class.
    ///  <list type="number">
    ///   <item>
    ///    <description>
    ///    Create a new class that derives from the <c>LeanProductionFlowUnusedQuantities</c> class.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    Overlayer the <c>construct</c> method on the <c>LeanProductionFlowUnusedQuantities</c> class so
    ///    that it returns an instance of the derived class.
    ///    </description>
    ///   </item>
    ///   <item>
    ///    <description>
    ///    Override the methods from the <c>LeanProductionFlowUnusedQuantities</c> class that you want to
    ///    customize or extend in your derived class.
    ///    </description>
    ///   </item>
    ///  </list>
    ///
    ///  This procedure helps make sure that your customizations are maintained if the base version of the
    ///  <c>
    ///   LeanProductionFlowUnusedQuantities
    ///  </c>
    ///   class is changed, minimizing code conflicts during an upgrade. For more information, see <see cref="Best Practices for Static Construct Methods" />
    /// </remarks>
    private static LeanProductionFlowUnusedQuantities construct()
    {
        return new LeanProductionFlowUnusedQuantities();
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static Description description()
    {
        return "@SYS339035";
    }

]]></Source>
			</Method>
			<Method>
				<Name>newStandard</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new <c>LeanProductionFlowUnusedQuantities</c> object.
    /// </summary>
    /// <param name="_leanProductionFlowReferenceRecId">
    ///    The <c>RefRecId</c> value that is used to initialize the object.
    /// </param>
    /// <param name="_date">
    ///    The <c>TransDate</c> value that is used to initialize the object.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>LeanProductionFlowUnusedQuantities</c> class.
    /// </returns>
    [Microsoft.Dynamics.BusinessPlatform.SharedTypes.InternalUseOnlyAttribute]
    public static LeanProductionFlowUnusedQuantities newStandard(
        RefRecId  _leanProductionFlowReferenceRecId,
        TransDate _date)
    {
        LeanProductionFlowUnusedQuantities  leanProductionFlowUnusedQuantities = LeanProductionFlowUnusedQuantities::construct();

        leanProductionFlowUnusedQuantities.parmLeanProductionFlowReferenceRecId(_leanProductionFlowReferenceRecId);
        leanProductionFlowUnusedQuantities.parmDateTime(DateTimeUtil::newDateTime(_date,#secondsPerDay-1));
        leanProductionFlowUnusedQuantities.parmLastBackflushCostingDateTime(
            LeanProductionFlowCosting::getEndDateTimeForLastEnded(
                _leanProductionFlowReferenceRecId,
                _date));
        return leanProductionFlowUnusedQuantities;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>