<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TmsxmlApportionment_Dimension</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Apportionment by order line dimension
/// Proceeded by vendor invoice journal creation
/// </summary>
class TmsxmlApportionment_Dimension extends TMSXMLApportionment
{
    boolean                 isFreightBillDetail;
    JournalId               journalId;
    VendAccount             account;
    TMSOffsetAccount        offset;
    str                     transText;
    Common                  source;
    boolean                 creditMemo;
    RecId                   recIdInvoiceLine;
    TMSInternalInvNumber    invoiceNum;
    TMSDirection            direction;
    List                    recMatchList;
    ListEnumerator          listEnumerator;
    Set                     chargeSet;
    Set                     chargeSet2;
    boolean                 autoReconcile;
    Set                     vendInvoiceSet;
    SetEnumerator           vendInvoiceEnum;

    private CurrencyCode markupCurrencyCode;

    #TMSXML
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkMarkupType</Name>
				<Source><![CDATA[
    NoYesId checkMarkupType(MarkupTrans _markupTrans)
    {
        MarkupTable markupTable;

        markupTable = MarkupTable::find(_markupTrans.ModuleType, _markupTrans.MarkupCode);

        return markupTable.CustType == MarkupType::Item ? NoYes::Yes : NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFreightBillMarkup</Name>
				<Source><![CDATA[
    void createFreightBillMarkup(RecId _freightBillRecId, MarkupTrans _markup)
    {
        TMSFreightBillMarkupTrans freightBillMarkupTrans;

        freightBillMarkupTrans.FreightBillDetailTableId  = tableNum(TMSFreightBillDetail);
        freightBillMarkupTrans.FreightBillDetailRecId    = _freightBillRecId;
        freightBillMarkupTrans.MarkupTransTableId        = _markup.TableId;
        freightBillMarkupTrans.MarkupTransRecId          = _markup.RecId;
        freightBillMarkupTrans.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>MarkupTrans</c> record and the related <c>TMSFreightBillMarkupTrans</c> record.
    /// </summary>
    /// <param name = "_common">Table record for which the new <c>MarkupTrans</c> record is created.</param>
    /// <param name = "_markupTrans">Existing <c>MarkupTrans</c> record used for initializing the new one.</param>
    /// <param name = "_amount">New amount value.</param>
    /// <param name = "_isInvoiced">Is invoiced?</param>
    public void createMarkup(
        Common      _common,
        MarkupTrans _markupTrans,
        Amount      _amount,
        boolean     _isInvoiced = false)
    {
        MarkupTrans newMarkup;

        newMarkup.initFromMarkupTrans(_markupTrans);
        newMarkup.TransRecId        = _common.RecId;
        newMarkup.TransTableId      = _common.TableId;
        newMarkup.Value             = _amount;
        newMarkup.LineNum           = this.calculateNewMarkupLineNum(_common);
        newMarkup.ModuleCategory    = HeadingLine::Line;
        newMarkup.CurrencyCode      = this.parmMarkupCurrencyCode() ? this.parmMarkupCurrencyCode() : _markupTrans.CurrencyCode;
        newMarkup.insert();

        TMSFreightBillMarkupTrans fbMarkup;

        select firstonly FreightBillDetailRecId from fbMarkup
            where fbMarkup.MarkupTransRecId == _markupTrans.RecId;

        this.createFreightBillMarkup(fbMarkup.FreightBillDetailRecId, newMarkup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateNewMarkupLineNum</Name>
				<Source><![CDATA[
    private LineNum calculateNewMarkupLineNum(Common _common)
    {
        return MarkupTrans::lastLineNum(_common.TableId, _common.RecId) + 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doInvoiceAdjustment</Name>
				<Source><![CDATA[
    boolean doInvoiceAdjustment(TMSFreightMatchReason _matchReason, TMSInvoiceLineReconcile _invoiceRec)
    {
        TMSFreightBillMarkupTrans   fbMarkup;
        TMSFreightBillDetail        fbDetail;
        TMSFBInvMatch               fbMatch;
        TMSInvoiceLine              invoiceLine;
        MarkupTrans                 markupTrans;
        MarkupTable                 markupTable;

        invoiceLine = TMSInvoiceLine::findByRecId(_invoiceRec.InvoiceLineRecId);

        select firstonly markupTrans
            join MarkupTransRecId from fbMarkup
            where fbMarkup.MarkupTransRecId == markupTrans.RecId
                join RecId from fbDetail
                where fbMarkup.FreightBillDetailRecId == fbDetail.RecId
                    join FreightBillDetailRecId, InvoiceLineRecId from fbMatch
                    where fbDetail.RecId == fbMatch.FreightBillDetailRecId &&
                          fbMatch.InvoiceLineRecId == invoiceLine.RecId
                        join MarkupCode, ModuleType, CustType from markupTable
                        where markupTrans.MarkupCode    == markupTable.MarkupCode   &&
                              markupTrans.ModuleType    == markupTable.ModuleType   &&
                              markupTable.CustType      == MarkupType::Item;

        return markupTrans ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFreightBill</Name>
				<Source><![CDATA[
    /// <summary>
	/// Finds freight bill details id.
	/// </summary>
	/// <param name="_source">
	/// The source transaction record.
	/// </param>
	/// <param name="_invoiceLineRecId">
	/// The invoice line record id.
	/// </param>
	/// <returns>
	/// The freight bill details id.
	/// </returns>
    str findFreightBill(Common _source, RecId _invoiceLineRecId)
    {
        TMSFreightBillDetail        fbDetail;
        TMSFreightBillMarkupTrans   fbMarkup;
        MarkupTrans                 markupTrans;
        TMSFBInvMatch               fbMatch;

        select firstonly FreightBillId from fbDetail order by CreatedDateTime
            join TransTableId, TransRecId, RecId from markupTrans
            where markupTrans.TransTableId  == _source.TableId &&
                  markupTrans.TransRecId    == _source.RecId
                join InvoiceLineRecId, FreightBillDetailRecId from fbMatch
                where fbMatch.InvoiceLineRecId       == _invoiceLineRecId &&
                      fbMatch.FreightBillDetailRecId == fbDetail.RecId
                    join FreightBillDetailRecId, MarkupTransRecId from fbMarkup order by CreatedDateTime asc
                    where fbMarkup.FreightBillDetailRecId == fbDetail.RecId &&
                          fbMarkup.MarkupTransRecId       == markupTrans.RecId;

        return fbDetail.FreightBillId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDirection</Name>
				<Source><![CDATA[
    void getDirection(TableId _tableId)
    {
        switch (_tableId)
        {
            case tableNum(VendInvoiceTrans):
                 direction = TMSDirection::Inbound;
                 break;

            case tableNum(PurchLine):
                 direction = TMSDirection::Inbound;
                 break;

            case tableNum(SalesLine):
                 direction = TMSDirection::Outbound;
                 break;

            case tableNum(CustInvoiceTrans):
                 direction = TMSDirection::Outbound;
                 break;

            case tableNum(InventTransferLine):
                 direction = TMSDirection::Outbound;
                 break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceLineMatchReconcile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loops through amounts to be apportioned by dimension on the vendor invoice journals.
    /// </summary>
    /// <param name="_invoiceLine">
    /// The <c>TMSInvoiceLine</c> record.
    /// </param>
    /// <param name="_xmlNode">
    /// The XML node.
    /// </param>
    void invoiceLineMatchReconcile(TMSInvoiceLine _invoiceLine,  XmlNode _xmlNode)
    {
        XmlNode                     appNode;

        TMSInvoiceLineReconcile invoiceRec;
        TMSFBInvMatch           fbMatch;

        // Reconciliations
        while select invoiceRec
            where invoiceRec.InvoiceLineRecId    == _invoiceLine.RecId   &&
                  invoiceRec.Amount                 != 0                    &&
                  invoiceRec.WorkflowStatus      == TMSWorkflowStatus::Submitted
        {
            appNode     = this.writeXMLNode(_xmlNode, #apportionment);

            this.writeXMLElement(appNode, #amount, TMSXMLApportionment::num2XmlStr(invoiceRec.Amount));

            this.writeAppDetails(appNode, invoiceRec);
        }

        // Matches
        while select forupdate fbMatch
            where fbMatch.InvoiceLineRecId      == _invoiceLine.RecId   &&
                  fbMatch.RateCur                  != 0                    &&
                  fbMatch.WorkflowStatus        == TMSWorkflowStatus::Submitted
        {
            appNode     = this.writeXMLNode(_xmlNode, #apportionment);

            this.writeXMLElement(appNode, #amount, TMSXMLApportionment::num2XmlStr(fbMatch.RateCur));

            this.writeAppDetails(appNode, fbMatch);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoicedCharge</Name>
				<Source><![CDATA[
    NoYes isInvoicedCharge(TableId _tableId)
    {
        NoYes ret;

        if (_tableId == tableNum(VendInvoiceTrans) || _tableId == tableNum(CustInvoiceTrans))
        {
            ret = NoYes::Yes;
        }

        else
        {
            ret = NoYes::No;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAutoReconcile</Name>
				<Source><![CDATA[
    boolean parmAutoReconcile(boolean _autoReconcile = autoReconcile)
    {
        if (_autoReconcile)
        {
            autoReconcile = _autoReconcile;
        }

        return autoReconcile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupCurrencyCode</Name>
				<Source><![CDATA[
    protected CurrencyCode parmMarkupCurrencyCode(CurrencyCode _currencyCode = markupCurrencyCode)
    {
        if (_currencyCode)
        {
            markupCurrencyCode = _currencyCode;
        }
        return markupCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDirection</Name>
				<Source><![CDATA[
    TMSDirection parmDirection(TMSDirection _direction = direction)
    {
        if (_direction)
        {
            direction = _direction;
        }

        return direction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInvoiceNumber</Name>
				<Source><![CDATA[
    TMSInternalInvNumber parmInvoiceNumber(TMSInternalInvNumber _invoiceNum = invoiceNum)
    {
        if (_invoiceNum)
        {
            invoiceNum = _invoiceNum;
        }

        return invoiceNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCreditMemo</Name>
				<Source><![CDATA[
    boolean parmIsCreditMemo(boolean _creditMemo = creditMemo)
    {
        if (_creditMemo)
        {
            creditMemo = _creditMemo;
        }

        return creditMemo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFreightBillDetail</Name>
				<Source><![CDATA[
    boolean parmIsFreightBillDetail(boolean _isFreightBillDetail = isFreightBillDetail)
    {
        if (_isFreightBillDetail)
        {
            isFreightBillDetail = _isFreightBillDetail;
        }

        return isFreightBillDetail;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalId</Name>
				<Source><![CDATA[
    JournalId parmJournalId(JournalId _journalId = journalId)
    {
        if (_journalId)
        {
            journalId = _journalId;
        }

        return journalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSource</Name>
				<Source><![CDATA[
    Common parmSource(Common _source = source)
    {
        if (_source)
        {
            source = _source;
        }

        return source;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransText</Name>
				<Source><![CDATA[
    LedgerJournalTransTxt parmTransText(LedgerJournalTransTxt _transText = transText)
    {
        if (_transText)
        {
            transText = _transText;
        }

        return transText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>readAppEntity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Read the Adhoc Apportionment transaction response record's detail nade.
    /// </summary>
    /// <param name="_xmlNode">
    ///     the Current xml node and subsequent children nodes.
    /// </param>
    public void readAppEntity(XmlNode _xmlNode)
    {
        XmlNodeList                 detailsList;
        XmlNode                     detailsNode;
        XmlNodeList                 appList;
        XmlNode                     appNode;

        PurchLine                   purchLine;
        SalesLine                   salesLine;
        VendInvoiceTrans            vendInvoiceTrans;
        CustInvoiceTrans            custInvoiceTrans;
        MarkupTrans                 markupTrans;
        TMSInvoiceLineReconcile     invoiceRec;
        TMSFBInvMatch               fbMatch;
        TMSInvoiceLine              invoiceLine;
        TMSFreightMatchReason       matchReason;
        TMSFreightBillDetail        fbDetail;
        TMSFBDetailReconcile        fbRec;
        Common                      setRecord;
        Common                      lineSource;

        Amount                      appValue;
        DimensionDynamicAccount     vendAccount;
        DimensionDynamicAccount     offsetAccount;
        LedgerDimensionBase         dimension;
        boolean                     payAmount;
        RecId                       markupRecId;
        boolean                     landedCost;
        boolean                     isInvoiced;
        NoYes                       noYes;
        LedgerJournalAC             invoiceVendor;
        boolean                     isMatch;
        LedgerJournalACType         acType;
        str                         text;
        CurrencyCode                currencyCode;
        LineNum                     lineNum;
        RecId                       invoiceLineRecId;
        TMSInvoiceApproval          invoiceApproval = new TMSInvoiceApproval();
        TMSFreightMatchReason       freightMatchReason;        

        invoiceRec  = this.parmSource();

        detailsList         = _xmlNode.selectNodes(#details);
        detailsNode         = detailsList.nextNode();

        // Loop through the Apportionments for a reconcile or match
        if (detailsNode)
        {
            appList    = detailsNode.selectNodes(#detail);
            appNode    = appList.nextNode();

            using (TMSDiscardFreightNegativeFreightBillContext context = TMSDiscardFreightNegativeFreightBillContext::construct())
            {
                while (appNode)
                {
                    // Grab either freight bill or reconcile
                    // from the specificly ordered set
                    listEnumerator.moveNext();
                    setRecord = listEnumerator.current();
                    matchReason     = null;
                    lineNum         = 0.0;
                    appValue        = 0.0;
                    transText       = '';
                    text            = '';
                    isInvoiced      = NoYes::No;
                    landedCost      = NoYes::No;
                    currencyCode    = '';

                     // Get line fields and add to invoice journal
                    appValue            = str2num(this.returnNamedNode(appNode, #Amount));
                    isInvoiced          = symbol2Enum(enumNum(NoYes), this.returnNamedNode(appNode, #invoiced));
                    landedCost          = symbol2Enum(enumNum(NoYes), this.returnNamedNode(appNode, #landedCost));
                    text                = this.returnNamedNode(appNode, #name);
                    currencyCode        = this.returnNamedNode(appNode, #currencyCode);
                    invoiceLineRecId    = str2int64(this.returnNamedNode(appNode, #invoiceLineRecId));
                    this.parmMarkupCurrencyCode(currencyCode);

                    switch (setRecord.TableId)
                    {
                        case tableNum(TMSInvoiceLineReconcile):
                            invoiceRec  = setRecord;
                            invoiceLine = TMSInvoiceLine::findByRecId(invoiceLineRecId);
                            matchReason = TMSFreightMatchReason::find(invoiceRec.FreightReasonCode);
                            payAmount   = matchReason.PayAmount;
                            lineSource  = invoiceLine;
                            invoiceVendor = invoiceLine.VendInvoiceAccount ? invoiceLine.VendInvoiceAccount : invoiceLine.VendAccount;
                            break;

                        case tableNum(TMSFBInvMatch):
                            fbMatch     = setRecord;
                            invoiceLine = TMSInvoiceLine::findByRecId(invoiceLineRecId);
                            payAmount   = true;
                            lineSource  = fbMatch;
                            invoiceVendor = invoiceLine.VendInvoiceAccount ? invoiceLine.VendInvoiceAccount : invoiceLine.VendAccount;
                            isMatch         = true;
                            break;

                        case tableNum(TMSFBDetailReconcile):
                            fbRec       = setRecord;
                            fbDetail    = TMSFreightBillDetail::find(fbRec.FreightBillDetailRecId);
                            matchReason = TMSFreightMatchReason::find(fbRec.FreightReasonCode);
                            payAmount   = false;
                            lineSource  = fbDetail;
                            invoiceVendor = fbDetail.VendorInvoiceCode;
                            break;
                    }

                    if (str2numOK(this.returnNamedNode(appNode, #sequence)))
                    {
                        lineNum         = str2num(this.returnNamedNode(appNode, #sequence));
                    }

                    context.parmIsNegativeAmount(appValue < 0);

                    if (this.parmIsFreightBillDetail())
                    {
                        appValue = -appValue;
                    }

                    markupRecId = str2int64(this.returnNamedNode(appNode, #chargeCode));

                    select firstonly markupTrans
                        where markupTrans.RecId == markupRecId;

                    this.getDirection(markupTrans.TransTableId);

                    // Based off direction, get the appropriate dimension
                    switch (direction)
                    {
                        case TMSDirection::Inbound:
                            if (isInvoiced)
                            {
                                vendInvoiceTrans = VendInvoiceTrans::findRecId(str2int64(this.returnNamedNode(appNode, #objectId)));
                                dimension = vendInvoiceTrans.DefaultDimension;

                                // Note: Checking if there are any charges of type item
                                // that need an invoice adjustment for landed cost
                                if (landedCost)
                                {
                                    this.createMarkup(vendInvoiceTrans, markupTrans, appValue, isInvoiced);

                                    // Add to PO invoice set for compiled invoice adjustment
                                    if (!vendInvoiceSet.in(vendInvoiceTrans.vendInvoiceJour().RecId))
                                    {
                                        vendInvoiceSet.add(vendInvoiceTrans.vendInvoiceJour().RecId);
                                    }
                                }
                            }
                            else
                            {
                                purchLine = PurchLine::findRecId(str2int64(this.returnNamedNode(appNode, #objectId)));
                                dimension = purchLine.DefaultDimension;

                                // Landed cost
                                if (landedCost)
                                {
                                    this.createMarkup(purchLine, markupTrans, appValue);
                                }
                            }
                            break;

                        default:
                            if (isInvoiced)
                            {
                                custInvoiceTrans = CustInvoiceTrans::findRecId(str2int64(this.returnNamedNode(appNode, #objectId)));
                                dimension = custInvoiceTrans.DefaultDimension;
                            }
                            else
                            {
                                if (markupTrans.TransTableId == tableNum(SalesLine))
                                {
                                    salesLine = SalesLine::findRecId(str2int64(this.returnNamedNode(appNode, #objectId)));
                                    dimension = salesLine.DefaultDimension;
                                }
                                else if (markupTrans.TransTableId == tableNum(CustConfirmTrans))
                                {
                                    dimension = CustConfirmTrans::findRecId(str2int64(this.returnNamedNode(appNode, #objectId))).DefaultDimension;
                                }
                            }
                            break;
                    }

                    // override dimensions
                    if (matchReason.OverrideAccts)
                    {
                        dimension = matchReason.OffAcctLedgerDimension;
                    }

                    if (this.parmIsFreightBillDetail())
                    {
                        appValue = abs(appValue);
                    }

                    acType = payAmount ? LedgerJournalACType::Vend : LedgerJournalACType::Ledger;

                    [vendAccount, offsetAccount] = invoiceApproval.setAccounts(invoiceVendor,
                                                                               direction == TMSDirection::Inbound ? InventTransType::Purch : InventTransType::Sales,
                                                                               matchReason,
                                                                               MarkupTable::find(markupTrans.ModuleType, markupTrans.MarkupCode),
                                                                               isMatch,
                                                                               dimension,
                                                                               acType);

                    if (!markupRecId && invoiceRec)
                    {
                        freightMatchReason  = TMSFreightMatchReason::find(invoiceRec.FreightReasonCode);

                        if (freightMatchReason.PayAmount)
                        {
                            vendAccount = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(invoiceLine.VendInvoiceAccount, LedgerJournalACType::Vend);
                            if (!vendAccount)
                            {
                                vendAccount = LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(invoiceLine.VendAccount, LedgerJournalACType::Vend);
                            }
                        }
                        else
                        {
                            LedgerAccountDimensionResolver ledgerAccountDimensionResolver = LedgerAccountDimensionResolver::newResolver(freightMatchReason.LedgerAccount);
                            ledgerAccountDimensionResolver.parmDimensionFormat(DimensionAttribute::find(DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount)).Name);
                            vendAccount = ledgerAccountDimensionResolver.resolve();
                        }
                        offsetAccount  = freightMatchReason.OffAcctLedgerDimension;
                    }

                    DimensionDynamicAccount creditAccount;
                    DimensionDynamicAccount debitAccount;
                    [creditAccount, debitAccount] = this.retrieveCreditAndDebitAccounts(setRecord, offsetAccount, vendAccount, markupTrans);

                    transText = invoiceApproval.createTransText(lineSource);

                    invoiceApproval.findOrCreateLedgerJournalTrans(this.parmJournalId(),
                                                                   appValue,
                                                                   creditAccount,
                                                                   debitAccount,
                                                                   acType,
                                                                   transText,
                                                                   currencyCode,
                                                                   invoiceLineRecId,
                                                                   TMSInvoiceTable::find(invoiceLine.InternalInvNumber),
                                                                   text,
                                                                   lineNum,
                                                                   recIdInvoiceLine == invoiceLineRecId,
                                                                   markupTrans.TaxGroup,
                                                                   markupTrans.TaxItemGroup,
                                                                   markupTrans);

                    recIdInvoiceLine = invoiceLineRecId;

                    appNode = appList.nextNode();
                }
            
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCreditAndDebitAccounts</Name>
				<Source><![CDATA[
    private container retrieveCreditAndDebitAccounts(
        Common                  _setRecord,
        DimensionDynamicAccount _offsetAccount,
        DimensionDynamicAccount _vendAccount,
        MarkupTrans             _markupTrans)
    {
        DimensionDynamicAccount creditAccount;
        DimensionDynamicAccount debitAccount;

        if (this.shouldReverseCreditAndDebitAccounts(_setRecord, _markupTrans))
        {
            creditAccount = _offsetAccount;
            debitAccount  = _vendAccount;
        }
        else
        {
            creditAccount = _vendAccount;
            debitAccount  = _offsetAccount;
        }

        return [creditAccount, debitAccount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldReverseCreditAndDebitAccounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the credit and debit accounts should be reversed during freight bill or the freight invoice processing.
    /// </summary>
    /// <param name = "_setRecord">Buffer representing the freight bill or the freight invoice being processed.</param>
    /// <param name = "_markupTrans">Charge code buffer.</param>
    /// <returns>true if the accounts should be reversed; otherwise, false.</returns>
    protected boolean shouldReverseCreditAndDebitAccounts(
        Common      _setRecord,
        MarkupTrans _markupTrans)
    {
        // In case of discarding the freight bill, it is necessary to reverse the credit and debit accounts,
        // when the related freight charge has both credit and debit types set to Ledger account.
        // This needs to be done so that the accounts have the correct amounts.
        // For example, the charge code debit account should not have amount that is greater than the freight bill itself,
        // which would happen in case when accounts are not reversed.
        boolean ret = this.parmIsFreightBillDetail()
            && _setRecord.TableId == tableNum(TMSFBDetailReconcile);

        if (ret)
        {
            TMSDiscardFreightNegativeFreightBillContext context = TMSDiscardFreightNegativeFreightBillContext::current();
            if (context.parmIsNegativeAmount())
            {
                return ret;
            }
            MarkupTable markupTable = MarkupTable::find(_markupTrans.ModuleType, _markupTrans.MarkupCode);

            // If the markup table is not found, one of the reasons is that the accounts are overridden on the reconciliation reason code,
            // as can be seen in the writeAppDetailsDiscard method, so the accounts should not be reversed.
            ret = markupTable.RecId != 0;

            if (ret)
            {
                // The reversal should not happen for the inventory type, which is used for transfer orders,
                // because there is no support for invoicing such charges.
                ret = markupTable.ModuleType != MarkupModuleType::Invent
                    && markupTable.CustType == MarkupType::LedgerAccount
                    && markupTable.VendType == MarkupType::LedgerAccount;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>readXML</Name>
				<Source><![CDATA[
    void readXML(XML _xml)
    {
        XmlParseError       xmlError;
        XmlNode             transactionNode;
        XmlNodeList         rateList;
        XmlNode             requestNode;
        XmlNode             apportionNode;
        XmlNodeList         apportionList;

        VendInvoiceJour     vendInvoiceJour;

        responseDoc = XmlDocument::newXml(_xml);
        xmlError = responseDoc.parseError();

        try
        {
            ttsbegin;

            if (xmlError && xmlError.errorCode() != 0)
            {
                xmlError.reason();
            }

            transactionNode     = responseDoc.documentElement();
            communicationType   = symbol2Enum(enumNum(TMSCommunicationType), this.returnNamedNode(transactionNode, #communicationType));

            rateList        = transactionNode.selectNodes(#request);
            requestNode     = rateList.nextNode();

            apportionList   = requestNode.selectNodes(#apportionment);
            apportionNode    = apportionList.nextNode();

            vendInvoiceSet = new Set(Types::Int64);

            while (apportionNode)
            {
                this.readAppEntity(apportionNode);
                apportionNode = apportionList.nextNode();
            }

            // Run invoice adjustment
            if (!vendInvoiceSet.empty())
            {
                vendInvoiceEnum = vendInvoiceSet.getEnumerator();

                while (vendInvoiceEnum.moveNext())
                {
                    vendInvoiceJour = VendInvoiceJour::findRecId(vendInvoiceEnum.current(), true);

                    TMSInvoiceApproval::invoiceAdjustment(vendInvoiceJour);
                }
            }

            ttscommit;
        }
        catch
        {
            throw error("@TRX:ErrorInProcessingRequest");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendTransaction</Name>
				<Source><![CDATA[
    container sendTransaction()
    {
        TMSTransaction  transaction;
        XML             xml;

        xml =  this.createXML();

        transaction.TransactionTypeCode  = Global::enum2Symbol(enumNum(TMSCommunicationType), communicationType);
        transaction.RequestData          = xml;
        transaction.Id                   = #adhoc;
        transaction.OrderNum             = this.parmInvoiceNumber();
        transaction.insert();

        return [transaction.RecId, xml];
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeAppDetails</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Write XML for the details for the Adhoc Apportionment transaction
    /// </summary>
    /// <param name="_xmlNode">
    ///     The parent xml node.
    /// </param>
    /// <param name="_source">
    ///     The associated record to write the XML.
    /// </param>
    public void writeAppDetails(XmlNode _xmlNode, Common _source = null)
    {
        XmlNode                     detailNode;
        XmlNode                     detailsNode;

        TMSFreightBillDetail        fbDetail;
        TMSFreightBillMarkupTrans   fbMarkup;
        TMSInvoiceLineReconcile     invReconcile;
        TMSFBInvMatch               fbMatch;
        TMSInvoiceLine              invoiceLine;
        TMSFreightMatchReason       matchReason;
        MarkupTrans                 markupTrans;
        int                         i;

        // Set to ensure no duplicates are added for apportionment
        Set                         recSet    = new Set(Types::Int64);

        // Determine if the source is either a reconcile, freight bill, or discard
        switch (_source.TableId)
        {
            case tableNum(TMSInvoiceLineReconcile):
                invReconcile    = _source;
                invoiceLine     = TMSInvoiceLine::findByRecId(invReconcile.InvoiceLineRecId);
                matchReason     = TMSFreightMatchReason::find(invReconcile.FreightReasonCode);
                break;

            case tableNum(TMSFBInvMatch):
                fbMatch     = _source;
                invoiceLine = TMSInvoiceLine::findByRecId(fbMatch.InvoiceLineRecId);
                break;
        }

        // Begin example set of apportioned details
        detailsNode = this.writeXMLNode(_xmlNode, #details);

        if (matchReason.OverrideAccts)
        {
            recMatchList.addEnd(_source);

            detailNode = this.writeXMLNode(detailsNode, #detail);
            this.writeXMLElement(detailNode, #objectId, '');
            this.writeXMLElement(detailNode, #unit, TMSXMLApportionment::num2XmlStr(invReconcile.Amount));
            this.writeXMLElement(detailNode, #chargeCode, '');
            this.writeXMLElement(detailNode, #invoiced, enum2Symbol(enumNum(NoYes), NoYes::No));
            this.writeXMLElement(detailNode, #landedCost, enum2Symbol(enumNum(NoYes), NoYes::No));
            this.writeXMLElement(detailNode, #name, invoiceLine.Description);
            this.writeXMLElement(detailNode, #CurrencyCode, invoiceLine.CurrencyCode);
            if (matchReason.PayAmount)
            {
                this.writeXMLElement(detailNode, #invoiceLineRecId, (int642str(invReconcile.InvoiceLineRecId)));
            }
        }

        // Reconciles
        else if (invReconcile)
        {
            while select markupTrans
                    join fbMatch
                    where fbMatch.InvoiceLineRecId == invReconcile.InvoiceLineRecId
                        join RecId from fbDetail
                        where fbMatch.FreightBillDetailRecId == fbDetail.RecId
                            join FreightBillDetailRecId, MarkupTransRecId from fbMarkup order by CreatedDateTime asc
                                where fbMarkup.FreightBillDetailRecId == fbDetail.RecId &&
                                      fbMarkup.MarkupTransRecId       == markupTrans.RecId
            {
                if (!recSet.in(markupTrans.TransRecId))
                {
                    recSet.add(markupTrans.TransRecId);
                    recMatchList.addEnd(_source);
                    chargeSet.add(markupTrans.RecId);

                    detailNode = this.writeXMLNode(detailsNode, #detail);
                    this.writeXMLElement(detailNode, #objectId, (int642str(markupTrans.TransRecId)));
                    this.writeXMLElement(detailNode, #unit, TMSXMLApportionment::num2XmlStr(markupTrans.Value));
                    this.writeXMLElement(detailNode, #chargeCode, (int642str(markupTrans.RecId)));
                    this.writeXMLElement(detailNode, #invoiced, enum2Symbol(enumNum(NoYes), this.isInvoicedCharge(markupTrans.TransTableId)));
                    this.writeXMLElement(detailNode, #landedCost, enum2Symbol(enumNum(NoYes), this.checkMarkupType(markupTrans)));
                    this.writeXMLElement(detailNode, #currencyCode, invoiceLine.CurrencyCode);
                    this.writeXMLElement(detailNode, #sequence, strFmt('%1', invoiceLine.LineNum));
                    this.writeXMLElement(detailNode, #invoiceLineRecId, (int642str(invReconcile.InvoiceLineRecId)));
                    ++i;
                }
            }

            if (i == 0)
            {
                recSet.add(invReconcile.RecId);
                recMatchList.addEnd(_source);

                detailNode = this.writeXMLNode(detailsNode, #detail);
                this.writeXMLElement(detailNode, #objectId, (int642str(invReconcile.RecId)));
                this.writeXMLElement(detailNode, #unit, TMSXMLApportionment::num2XmlStr(invoiceLine.NetAmount));
                this.writeXMLElement(detailNode, #currencyCode, invoiceLine.CurrencyCode);
                this.writeXMLElement(detailNode, #invoiceLineRecId, (int642str(invReconcile.InvoiceLineRecId)));
            }
        }

        // Freight Bill Match
        else
        {
            while select TransRecId, TransTableId, Value, RecId, Txt from markupTrans
                join RecId from fbDetail
                    where fbDetail.RecId == fbMatch.FreightBillDetailRecId
                    join FreightBillDetailRecId, MarkupTransRecId from fbMarkup
                        order by createdDateTime asc
                        where fbMarkup.FreightBillDetailRecId == fbDetail.RecId
                           && fbMarkup.MarkupTransRecId       == markupTrans.RecId
            {
                if (!recSet.in(markupTrans.TransRecId))
                {
                    recSet.add(markupTrans.TransRecId);
                    recMatchList.addEnd(_source);
                    chargeSet2.add(markupTrans.RecId);

                    detailNode = this.writeXMLNode(detailsNode, #detail);
                    this.writeXMLElement(detailNode, #objectId, (int642str(markupTrans.TransRecId)));
                    this.writeXMLElement(detailNode, #unit, TMSXMLApportionment::num2XmlStr(markupTrans.Value));
                    this.writeXMLElement(detailNode, #chargeCode, (int642str(markupTrans.RecId)));
                    this.writeXMLElement(detailNode, #invoiced, enum2Symbol(enumNum(NoYes), this.isInvoicedCharge(markupTrans.TransTableId)));
                    this.writeXMLElement(detailNode, #landedCost, enum2Symbol(enumNum(NoYes), NoYes::No));
                    this.writeXMLElement(detailNode, #name, invoiceLine.Description);
                    this.writeXMLElement(detailNode, #currencyCode, invoiceLine.CurrencyCode);
                    this.writeXMLElement(detailNode, #sequence, strFmt('%1', invoiceLine.LineNum));
                    this.writeXMLElement(detailNode, #invoiceLineRecId, (int642str(invoiceLine.RecId)));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeAppDetailsDiscard</Name>
				<Source><![CDATA[
    /// <summary>
	/// Writes XML for the details to be discarded of Adhoc Apportionment transaction.
	/// </summary>
	/// <param name="_xmlNode">
	/// The XML node.
	/// </param>
	/// <param name="_source">
	/// The associated record to write the XML.
	/// </param>
    void writeAppDetailsDiscard(XmlNode _xmlNode, Common _source)
    {
        XmlNode                     detailNode;
        XmlNode                     detailsNode;

        TMSFreightBillDetail        fbDetail;
        TMSFreightBillMarkupTrans   fbMarkup;
        TMSFBDetailReconcile        fbRec;
        TMSFreightMatchReason       matchReason;

        MarkupTrans                 markupTrans;

        // Set to ensure no duplicates are added for apportionment
        Set                         recSet    = new Set(Types::Int64);

        fbRec       = _source;
        fbDetail    = TMSFreightBillDetail::find(fbRec.FreightBillDetailRecId);
        matchReason = TMSFreightMatchReason::find(fbRec.FreightReasonCode);
        this.parmDirection(fbDetail.Direction);

        // Begin example set of apportioned details
        detailsNode = this.writeXMLNode(_xmlNode, #details);

        if (matchReason.OverrideAccts)
        {
            recMatchList.addEnd(_source);

            detailNode = this.writeXMLNode(detailsNode, #detail);
            this.writeXMLElement(detailNode, #objectId, '');
            this.writeXMLElement(detailNode, #unit, TMSXMLApportionment::num2XmlStr(fbRec.Amount));
            this.writeXMLElement(detailNode, #chargeCode, '');
            this.writeXMLElement(detailNode, #invoiced, enum2Symbol(enumNum(NoYes), NoYes::No));
            this.writeXMLElement(detailNode, #landedCost, enum2Symbol(enumNum(NoYes), NoYes::No));
            this.writeXMLElement(detailNode, #currencyCode, fbDetail.CurrencyCode);
        }

        else
        {
            while select markupTrans
                    join FreightBillDetailRecId, MarkupTransRecId from fbMarkup order by CreatedDateTime asc
                    where fbMarkup.FreightBillDetailRecId == fbRec.FreightBillDetailRecId &&
                          fbMarkup.MarkupTransRecId       == markupTrans.RecId
            {
                if (!recSet.in(markupTrans.TransRecId))
                {
                    recSet.add(markupTrans.TransRecId);
                    recMatchList.addEnd(_source);
                    chargeSet.add(markupTrans.RecId);

                    detailNode = this.writeXMLNode(detailsNode, #detail);
                    this.writeXMLElement(detailNode, #objectId, (int642str(markupTrans.TransRecId)));
                    this.writeXMLElement(detailNode, #unit, TMSXMLApportionment::num2XmlStr(markupTrans.Value));
                    this.writeXMLElement(detailNode, #chargeCode, (int642str(markupTrans.RecId)));
                    this.writeXMLElement(detailNode, #invoiced, enum2Symbol(enumNum(NoYes), this.isInvoicedCharge(markupTrans.TransTableId)));
                    this.writeXMLElement(detailNode, #landedCost, enum2Symbol(enumNum(NoYes), this.checkMarkupType(markupTrans)));
                    this.writeXMLElement(detailNode, #currencyCode, markupTrans.CurrencyCode);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeApportionment</Name>
				<Source><![CDATA[
    public void writeApportionment(XmlNode _xmlNode)
    {
        XmlNode                     appNode;

        TMSFreightBillDetail        fbDetail;
        TMSInvoiceLine              invoiceLine;
        TMSFBDetailReconcile        fbRec;
        TMSFreightMatchReason       matchReason;

        SetEnumerator               se = new SetEnumerator();

        recMatchList    = new List(Types::Record);
        chargeSet       = new Set(Types::Int64);
        chargeSet2      = new Set(Types::Int64);

        if (!this.parmIsFreightBillDetail())
        {
            while select forupdate invoiceLine
                where invoiceLine.InternalInvNumber  == this.parmInvoiceNumber()             &&
                      (invoiceLine.InvoiceLineStatus == TMSInvoiceLineStatus::Submitted      ||
                      invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::Resubmitted    ||
                      invoiceLine.InvoiceLineStatus  == TMSInvoiceLineStatus::Rejected)
            {
                // Ensure invoice line that is rejected is only invoiced once.
                if (invoiceLine.InvoiceLineStatus    == TMSInvoiceLineStatus::Rejected &&
                    invoiceLine.amountApproved()        == invoiceLine.NetAmount)
                {
                    continue;
                }

                else
                {
                    this.invoiceLineMatchReconcile(invoiceLine, _xmlNode);
                }
            }
        }

        else
        {
            while select forupdate fbRec
                join fbDetail order by RouteCode, Direction
                    where fbDetail.RecId == fbRec.FreightBillDetailRecId
                    join matchReason order by PayAmount, OffAcctLedgerDimension
                        where matchReason.FreightReasonCode  == fbRec.FreightReasonCode   &&
                              ((fbRec.CurrentSession         == NoYes::Yes                   && // Session through reconcile form
                              autoReconcile                    == false)                       ||
                              (fbRec.AutoReconciled          == true                         && // Session through batch job
                              autoReconcile                    == true))
            {
                appNode = this.writeXMLNode(_xmlNode, #apportionment);

                this.writeXMLElement(appNode, #amount, TMSXMLApportionment::num2XmlStr(fbRec.Amount));

                this.writeAppDetailsDiscard(appNode, fbRec);
            }
        }

        // Set enumerator later to be used
        // for finding related reconcile/match records
        listEnumerator = recMatchList.getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
	/// Constructs the class instance.
	/// </summary>
	/// <returns>
	/// The class instance.
	/// </returns>
    static TMSXMLApportionment_Dimension construct()
    {
        TMSXMLApportionment_Dimension  processXML;

        processXML = new TMSXMLApportionment_Dimension();

        return processXML;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>