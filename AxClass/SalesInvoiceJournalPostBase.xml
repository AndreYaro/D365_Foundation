<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesInvoiceJournalPostBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>SalesInvoiceJournalPostBase</c> class is the base class used to post sales invoice journals.
/// </summary>
abstract class SalesInvoiceJournalPostBase extends FormletterJournalPost
{
    SalesParmTable salesParmTable;
    SalesParmLine salesParmLine;

    CustInvoiceJour custInvoiceJour;
    CustInvoiceTrans custInvoiceTrans;

    SalesQty updateNow;
    SalesQty invoiceUpdatedOnly;

    PdsCWInventQty cwInvoiceUpdatedOnly;

    SalesCalcTax salesCalcTax;
    TaxParameters taxParameters;
    CustParameters custParameters;
    InventTable inventTable;

    InventSiteId lineInventSiteId;
    AmountCur lineValue;
    AmountCur lineValueInclTax;
    AmountCur totalAmountCashDiscOnInvoice;
    AmountCur cashDiscountAmount;
    AmountCur discValue;
    RecordInsertList recordInsertListCustInvoicePackingSlipMatch;
    List journalLines;

    InventMovement inventMovement;

    AmountCur totalOrderBalanceAbsoluteValue;

    boolean isFinTagConfigurationSetForCurrent = FinTagConfiguration::isFinTagConfigurationSet(curExt());

    // <GBR>
    RecordSortedList journalLines_BR;
    // </GBR>
    // <GEERU>
    // to be set in descendants
    boolean postNegativeMarkupsAsCorrection_RU;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addTaxParentReference</Name>
				<Source><![CDATA[
    protected void addTaxParentReference(LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
        _ledgerVoucherTransObject.parmTaxParentReferenceTableId(custInvoiceTrans.TableId);
        _ledgerVoucherTransObject.parmTaxParentReferenceRecId(custInvoiceTrans.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the <c>InventReportDimHistory</c> records to a record sorted list.
    /// </summary>
    /// <param name="_journalLine">
    ///    The customer invoice transaction for which to create the <c>InventReportDimHistory</c> records.
    /// </param>
    protected void addToInventReportDimHistory(Common _journalLine)
    {
        InventTransOrigin inventTransOrigin;
        InventTrans inventTrans;
        CustInvoiceTrans localCustInvoiceTrans = _journalLine as CustInvoiceTrans;
        InventQty qtyRemain = localCustInvoiceTrans.InventQty;
        InventDim transInventDim;

        boolean isSalesProcessEnabled = this.isSalesProcessEnabled(localCustInvoiceTrans);
        InventTrackingRegisterTransDimIterator trackingDimIterator;

        void createInventReportDimHistory(InventQty _qty, InventDimId _inventDimId)
        {
            qtyRemain = this.createInventReportDimHistory(localCustInvoiceTrans.InventTransId, _inventDimId, localCustInvoiceTrans.InvoiceId, _qty, qtyRemain);
        }

        if (this.isLineStocked())
        {
            if (isSalesProcessEnabled)
            {
                trackingDimIterator = InventTrackingRegisterTransDimIterator::newFromFinancialJournalLine(localCustInvoiceTrans);
            }

            while select TableId from inventTransOrigin
                where inventTransOrigin.InventTransId == localCustInvoiceTrans.InventTransId
                      && inventTransOrigin.ReferenceCategory == InventTransType::Sales
                join InventDimId, Qty from inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                          && inventTrans.InvoiceId == localCustInvoiceTrans.InvoiceId
                          && inventTrans.DateFinancial == localCustInvoiceTrans.InvoiceDate
                          && inventTrans.Voucher == voucher
                join transInventDim
                    where transInventDim.InventDimId == inventTrans.InventDimId
            {
                if (qtyRemain)
                {
                    if (!isSalesProcessEnabled)
                    {
                        createInventReportDimHistory(inventTrans.Qty, inventTrans.InventDimId);
                    }
                    else
                    {
                        InventQty remainingInventTransQty = inventTrans.Qty;

                        // we need to split inventTrans to several lines with qty=-1 to include tracking dimensions
                        while (remainingInventTransQty != 0)
                        {
                            InventDim newInventDim = trackingDimIterator.nextTrackingDim(transInventDim);
                            if (!newInventDim)
                            {
                                break;
                            }
                            InventQty currentQty = trackingDimIterator.currentQty();
                            createInventReportDimHistory(currentQty, newInventDim.InventDimId);
                            remainingInventTransQty -= currentQty;
                        }

                        if (remainingInventTransQty)
                        {
                            createInventReportDimHistory(remainingInventTransQty, inventTrans.InventDimId);
                        }
                    }
                }
                else
                    break;
            }
        }
        else
        {
            this.createInventReportDimHistory(localCustInvoiceTrans.InventTransId,
                                             localCustInvoiceTrans.InventDimId,
                                             localCustInvoiceTrans.InvoiceId,
                                             localCustInvoiceTrans.Qty,
                                             localCustInvoiceTrans.Qty );
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesProcessEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the sales process is enabled on the provided <c>CustInvoiceTrans</c>.
    /// </summary>
    /// <param name = "_custInvoiceTrans">
    /// The <c>CustInvoiceTrans</c> on which to check if the sales process is enabled.
    /// </param>
    /// <returns>
    /// true if the sales process is enabled on the provided <c>CustInvoiceTrans</c>; otherwise, false.
    /// </returns>
    protected boolean isSalesProcessEnabled(CustInvoiceTrans _custInvoiceTrans)
    {
        return _custInvoiceTrans.inventTable().isActiveInSalesProcess();
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTotalDiscountTaxLinkEntries</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create the records in <c>TaxTransGeneralJournalAccountEntry</c> for sales order total discount that affect taxes.
    /// </summary>
    private void addTotalDiscountTaxLinkEntries()
    {
        GeneralJournalEntry                 generalJournalEntry;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        SalesTable                          salesTable;
        TaxTrans                            taxTrans;
        TaxTransGeneralJournalAccountEntry  taxTransGeneralJournalAccountEntry;
        const TaxTransRelationshipType      totalDiscount = TaxTransRelationshipType::TotalDiscount;
        const AllocationFactor              one = 1.0;

        insert_recordset taxTransGeneralJournalAccountEntry
                (TaxTransRelationship, AllocationFactor, TaxTrans, GeneralJournalAccountEntry, LedgerDimension)
            select totalDiscount, one from custInvoiceTrans
                where custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
            join RecId from taxTrans
                where taxTrans.SourceTableId == custInvoiceTrans.TableId
                   && taxTrans.SourceRecId == custInvoiceTrans.RecId
            join generalJournalEntry
                where generalJournalEntry.DocumentNumber == custInvoiceTrans.InvoiceId
                   && generalJournalEntry.Ledger == Ledger::current()
            join RecId, LedgerDimension from generalJournalAccountEntry
                where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                   && generalJournalAccountEntry.PostingType == LedgerPostingType::CustInvoiceDisc;

        update_recordset taxTransGeneralJournalAccountEntry
            setting TransactionCurrencyAmount = custInvoiceTrans.LineAmount * salesTable.DiscPercent / 100,
                AccountingCurrencyAmount = custInvoiceTrans.LineAmountMST * salesTable.DiscPercent / 100,
                TransactionCurrency = generalJournalAccountEntry.TransactionCurrencyCode
            where taxTransGeneralJournalAccountEntry.TaxTransRelationship == totalDiscount
            join salesTable
                where salesTable.SalesId == custInvoiceJour.SalesId
            join custInvoiceTrans
                where custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
            join taxTrans
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans
                   && taxTrans.SourceTableId == custInvoiceTrans.TableId
                   && taxTrans.SourceRecId == custInvoiceTrans.RecId
            join generalJournalEntry
                where generalJournalEntry.DocumentNumber == custInvoiceTrans.InvoiceId
                   && generalJournalEntry.Ledger == Ledger::current()
            join generalJournalAccountEntry
               where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry
                  && generalJournalAccountEntry.LedgerDimension == taxTransGeneralJournalAccountEntry.LedgerDimension
                  && generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                  && generalJournalAccountEntry.PostingType == LedgerPostingType::CustInvoiceDisc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetId_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the Russian asset ID.
    /// </summary>
    /// <returns>
    ///    The Russian asset ID.
    /// </returns>
    abstract protected RAssetIdOpen assetId_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>bypassCustomerCreditCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a customer credit check should be bypassed.
    /// </summary>
    /// <returns>
    /// <c>NoYes::Yes</c> if the customer credit check should be bypassed; otherwise, NoYes::No.
    /// </returns>
    abstract protected NoYes bypassCustomerCreditCheck()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcExcise_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates excise amount per line
    /// </summary>
    /// <returns>
    /// Excise amount per line
    /// </returns>
    protected container calcExcise_PL()
    {
        TaxGroupData taxGroupData;
        TaxOnItem taxOnItem;
        TaxTable taxTable;

        AmountCur exciseValue = 0;
        TaxCode taxCode = "";

        TaxGroup taxGroup;
        TaxItemGroup taxItemGroup;

        if (custInvoiceTrans)
        {
            taxGroup = custInvoiceTrans.TaxGroup;
            taxItemGroup = custInvoiceTrans.TaxItemGroup;
        }
        else
        {
            SalesLine salesLine = salesParmLine.salesLine();
            taxGroup = salesLine.TaxGroup;
            taxItemGroup = salesLine.TaxItemGroup;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoPL ]))
        {
            while select TaxCode from taxGroupData
                where taxGroupData.TaxGroup == taxGroup
            join TableId from taxOnItem
                where taxOnItem.TaxItemGroup == taxItemGroup &&
                      taxOnItem.TaxCode == taxGroupData.TaxCode
            join TableId from taxTable
                where taxTable.TaxCode == taxGroupData.TaxCode &&
                      taxTable.TaxType_W == TaxType_W::Excise
            {
                taxCode = taxGroupData.TaxCode;
                exciseValue += CurrencyExchangeHelper::amount(lineValue * TaxData::find(taxCode, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), lineValue).ExciseDuty_PL / 100, custInvoiceTrans.CurrencyCode);
            }
        }

        return [ exciseValue, taxCode ];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostEndDisc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the end discounts can be posted.
    /// </summary>
    /// <returns>
    /// true if the end discount can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostEndDisc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the ledger postings can occur.
    /// </summary>
    /// <returns>
    /// true if the ledger postings can occur; otherwise, false.
    /// </returns>
    protected boolean canPostLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostRoundOff</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the end rounding can be posted.
    /// </summary>
    /// <returns>
    /// true if the rounding can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostRoundOff()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the tax can be posted.
    /// </summary>
    /// <returns>
    /// true if the tax can be posted; otherwise, false.
    /// </returns>
    protected boolean canPostTax()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a cash discount amount.
    /// </summary>
    /// <returns>
    /// A cash discount amount.
    /// </returns>
    protected AmountCur cashDiscountAmount()
    {
        return cashDiscountAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscPercent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a cash discount percentage.
    /// </summary>
    /// <returns>
    /// A cash discount percentage.
    /// </returns>
    protected DiscPct cashDiscPercent()
    {
        return custInvoiceJour.CashDiscPercent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTrans_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the customer transactions should be created the Brazilian way.
    /// </summary>
    /// <returns>
    /// true if the customer transactions should be created the Brazilian way; otherwise, false.
    /// </returns>
    abstract protected boolean createCustTrans_BR()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAlternativeReturnEnabled_BR</Name>
				<Source><![CDATA[
    protected boolean isAlternativeReturnEnabled_BR()
    {
        return CustParameters::isReturnAlternativePostingProfileEnabled() && salesParmLine.salesLine().SalesType == SalesType::ReturnItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData</Name>
				<Source><![CDATA[
    public boolean createReportData(FormletterJournalPrint _formletterJournalPrint)
    {
        SRSTmpDataStore srsTmpDataStore;

        // <GTE><GIN>
        if (TaxGSTInvoiceHelper_IN::isGSTInvoice(custInvoiceJour)
            && !custInvoiceJour.salesTable().CustomsExportOrder_IN)
        {
            return this.createReportData_IN(_formletterJournalPrint);
        }
        // </GTE></GIN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
         || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoMX])
         || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoTH])
         || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL])
         || BrazilParameters::isEnabled())
        {
            //other reports are printed in this case. they do not support new way of printing proforma yet.
            return false;
        }

        SalesInvoiceContract salesInvoiceContract = this.createSalesInvoiceContract();

        // Set PrintCopyOriginal value
        salesInvoiceContract.parmPrintCopyOriginal(PrintCopyOriginal::OriginalPrint);

        // Set Record Id
        salesInvoiceContract.parmRecordId(formletterJournal.RecId);

        if (_formletterJournalPrint)
        {
            // Pack the class and insert into the temporary store.
            srsTmpDataStore.Value = _formletterJournalPrint.pack();
            srsTmpDataStore.insert();

            // Set the rec id to contract parameter
            salesInvoiceContract.parmFormLetterRecordId(srsTmpDataStore.RecId);
        }

        SalesInvoiceDP salesInvoiceDP = this.createSalesInvoiceDP();
        salesInvoiceDP.parmDataContract(salesInvoiceContract);
        salesInvoiceDP.parmUserConnection(new UserConnection(true));
        salesInvoiceDP.createData();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesInvoiceContract</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>SalesInvoiceContract</c>.
    /// </summary>
    /// <returns>
    /// An instance of the <c>SalesInvoiceContract</c> class.
    /// </returns>
    protected SalesInvoiceContract createSalesInvoiceContract()
    {
        return new SalesInvoiceContract();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSalesInvoiceDP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>SalesInvoiceDP</c>.
    /// </summary>
    /// <returns>
    /// An instance of the <c>SalesInvoiceDP</c> class.
    /// </returns>
    protected SalesInvoiceDP createSalesInvoiceDP()
    {
        return new SalesInvoiceDP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData_IN</Name>
				<Source><![CDATA[
    public boolean createReportData_IN(FormletterJournalPrint _formletterJournalPrint)
    {
        SRSTmpDataStore         srsTmpDataStore;

        GSTInvoiceContract_IN gstInvoiceContract = new GSTInvoiceContract_IN();

        // Set PrintCopyOriginal value
        gstInvoiceContract.parmPrintCopyOriginal(PrintCopyOriginal::OriginalPrint);

        // Set Record Id
        gstInvoiceContract.parmRecordId(formletterJournal.RecId);
        gstInvoiceContract.parmTableId(tableNum(FormletterJournal));

        gstInvoiceContract.parmGSTInvoiceControllerName(classStr(SalesInvoiceController));
        if (_formletterJournalPrint)
        {
            // Pack the class and insert into the temporary store.
            srsTmpDataStore.Value = _formletterJournalPrint.pack();
            srsTmpDataStore.insert();

            // Set the rec id to contract parameter
            gstInvoiceContract.parmFormLetterRecordId(srsTmpDataStore.RecId);
        }

        GSTInvoiceDPBase_IN gstInvoiceDPBase = new GSTInvoiceDPBase_IN();
        gstInvoiceDPBase.parmDataContract(gstInvoiceContract);
        gstInvoiceDPBase.parmUserConnection(new UserConnection(true));
        gstInvoiceDPBase.processReport();

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createScrapOnInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates scrap on inventory.
    /// </summary>
    protected void createScrapOnInventory()
    {
        if (this.mustCreateScrapOnInventory())
        {
            InventUpd_Estimated estimated = InventUpd_Estimated::newInventMovement(InventMovement::construct(this.sourceLine()));
            estimated.parmTransEstimated(-salesParmLine.InventNow);
            estimated.parmEstimated(-salesParmLine.InventNow);
            estimated.parmCWTransEstimated(-salesParmLine.PdsCWDeliverNow);
            estimated.parmPdsCWEstimated(-salesParmLine.PdsCWDeliverNow);
            estimated.updateNow();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether an invoice that is being posted is a credit note.
    /// </summary>
    /// <returns>
    /// true if a credit note is being posted; otherwise, false.
    /// </returns>
    protected NoYes creditNote()
    {
        NoYes creditNote;

        if (taxParameters.CashDiscOnInvoice)
        {
            if (totalAmountCashDiscOnInvoice < 0)
            {
                creditNote = NoYes::Yes;
            }
            else
            {
                creditNote = NoYes::No;
            }
        }
        else
        {
            /* <SCM>
            if (this.totalAmount() < 0)
            </SCM> */
            // <GEERU>
            if (this.totalAmount() < 0 || (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && !this.totalAmount() && this.totalQty_RU() < 0))
            // </GEERU>
            {
                creditNote = NoYes::Yes;
            }
            else
            {
                creditNote = NoYes::No;
            }
        }
        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the currency code for a source line.
    /// </summary>
    /// <returns>
    /// The unit of currency for the source line.
    /// </returns>
    /// <remarks>
    /// This method is used for the ledger posting of the source line.
    /// </remarks>
    abstract protected CustCurrencyCode currencyCode()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>custTransAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the customer transaction amount.
    /// </summary>
    /// <returns>
    ///    The calculated customer transaction amount.
    /// </returns>
    /// <remarks>
    ///    Used for posting customer transaction when the legal entity is Brazilian.
    /// </remarks>
    abstract protected AmountCur custTransAmount_BR()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the default dimension for a record.
    /// </summary>
    /// <returns>
    /// A <c>DimensionDefault</c>.
    /// </returns>
    /// <remarks>
    /// Override this method in the subclass when deriving a default dimension from another entity other than a
    /// <c>CustInvoiceTrans</c> record.
    /// </remarks>
    protected DimensionDefault defaultDimension()
    {
        return custInvoiceTrans.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimensionMarkupOnJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default dimension for a record.
    /// </summary>
    /// <param name="_source">
    /// The <c>Common</c> record for which to find the default dimension.
    /// </param>
    /// <returns>
    /// A <c>DimensionDefault</c> object .
    /// </returns>
    /// <remarks>
    /// This method is used to calculate the miscellaneous charges on the header level.
    /// </remarks>
    abstract protected DimensionDefault defaultDimensionMarkupOnJour(Common _source)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimensionMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the default dimension when miscellaneous charges are posted on the line level.
    /// </summary>
    /// <returns>
    /// A <c>DimensionDefault</c> object .
    /// </returns>
    /// <remarks>
    /// This method is used to post the miscellaneous charges on the line level.
    /// </remarks>
    abstract protected DimensionDefault defaultDimensionMarkupOnTrans()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLedgerTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a default ledger transaction text.
    /// </summary>
    /// <returns>
    /// The transaction text.
    /// </returns>
    protected LedgerTransTxt defaultLedgerTransactionText()
    {
        return (this.creditNote() ? LedgerTransTxt::SalesCreditNoteLedger : LedgerTransTxt::SalesInvoiceLedger);
    }

]]></Source>
			</Method>
			<Method>
				<Name>discAmountExclTaxcInventoryPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the discount amount excluded tax for a quantity that is updated in the inventory.
    /// </summary>
    /// <returns>
    /// The discount amount excluded tax for the quantity that is updated in the inventory.
    /// </returns>
    abstract protected AmountCur discAmountExclTaxcInventoryPosted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Invokes the posting process.
    /// </summary>
    protected void endLedgerVoucher()
    {
        // <GEERU>
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher ? ledgerVoucher.findLedgerVoucherObject() : null;
        LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject ? ledgerVoucherObject.ledgerBondClient_RU() : null;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU])
            && ledgerBondClient
            && ledgerBondClient.findVRefByPostingType(LedgerPostingType::CustBalance) != 0)
        {
            ledgerBondClient.bondVRef2Log(ledgerBondClient.findVRefByPostingType(LedgerPostingType::CustBalance), ledgerBondClient.currentLog(), true);
        }
        // </GEERU>

        super();

        // When calculating the amount for the total discount the method doing the work does not have the reference to the TaxTrans.
        // In addition the existing parmTaxParentReferenceRecId and parmTaxPerentReferenceTableId on the LedgerVoucherTransObject do
        // not work to relate the tax transaction as we are creating the total discount transaction on the header instead of on a line.
        // As such we must wait until after the total discount and tax have been posted as part of endLedgerVoucher and then use
        // insertRecordset to create the total discount tax links from the already posted ledger vouchers.
        if (ledgerVoucher &&
            // <GEERU>
            (
            // </GEERU>
                formletterJournal.EndDisc
            // <GEERU>
                || endDiscAmounts
            )
            // </GEERU>
            )
        {
            this.addTotalDiscountTaxLinkEntries();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the posting of a journal line.
    /// </summary>
    protected void endPostLine()
    {
        this.updateNonPostedParmLines(salesParmLine);

        inventMovement = null; //Ensures that the internal recordViewCache in inventMovement is deactivated again.

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a fixed exchange rate.
    /// </summary>
    /// <returns>
    /// The fixed exchange rate.
    /// </returns>
    public CustExchRate fixedExchRate()
    {
        CustExchRate exchRate = super();

        if (!exchRate && SalesParameters::find().DateOfExchRate_W != DateOfExchRate_W::PostingDate)
        {
            exchRate = custInvoiceJour.ExchRate;
        }

        if (!exchRate && CustInvoiceJourUseReporCurrFromSettleFlight::instance().isEnabled() 
            && this.salesParmTable.salesTable().SettleVoucher == SettlementType::SelectedTransact
            && SalesParameters::find().UseSettleExchRate)
        {
            exchRate = custInvoiceJour.ExchRate;
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedExchRateSecondary</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a fixed secondary exchange rate.
    /// </summary>
    /// <returns>
    /// The fixed secondary exchange rate.
    /// </returns>
    public ExchrateSecondary fixedExchRateSecondary()
    {
        ExchrateSecondary exchRate = super();

        if (!exchRate && SalesParameters::find().DateOfExchRate_W != DateOfExchRate_W::PostingDate)
        {
            exchRate = custInvoiceJour.ExchRateSecondary;
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyFixedExchangeRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets reporting currency fixed exchange rate for a currency exchange date
    /// set in <c>SalesParameters</c>.
    /// </summary>
    /// <returns>Reporting currency fixed exchange rate.</returns>
    internal ExchRate reportingCurrencyFixedExchangeRate()
    {
        ExchRate exchRate = super();

        if (!exchRate
            && SalesParameters::find().DateOfExchRate_W != DateOfExchRate_W::PostingDate
            && EnableReportingCurrencyExchRateInSOInvoice_WFlight::instance().isEnabled())
        {
            exchRate = custInvoiceJour.ReportingCurrencyExchangeRate;
        }

        if (!exchRate && CustInvoiceJourUseReporCurrFromSettleFlight::instance().isEnabled()
            && this.salesParmTable.salesTable().SettleVoucher == SettlementType::SelectedTransact
            && SalesParameters::find().UseSettleExchRate)
        {
            exchRate = custInvoiceJour.ReportingCurrencyExchangeRate;
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>formletterType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a form letter type.
    /// </summary>
    /// <returns>
    /// A <c>FormletterType</c> enumeration value.
    /// </returns>
    protected FormletterType formletterType()
    {
        return FormletterType::Sales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a voucher number.
    /// </summary>
    /// <returns>
    /// The voucher number.
    /// </returns>
    protected Num getVoucher()
    {
        return custInvoiceJour.LedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>includeDiscValueInRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to include the discount value in a calculation of revenue.
    /// </summary>
    /// <returns>
    /// Always returns false.
    /// </returns>
    /// <remarks>
    /// This method is used to post the invoice line.
    /// </remarks>
    protected boolean includeDiscValueInRevenue()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>SalesInvoiceJournalPostBase</c> class.
    /// </summary>
    public void init()
    {
        this.initTotals();
        super();

        taxParameters = TaxParameters::find();
        custParameters = CustParameters::find();
        onlyOneCashDiscOnInvoice = true;

        journalLines = new List(Types::Record);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInvoiceJourFromTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a journal header from the totals.
    /// </summary>
    /// <remarks>
    /// This method is used to update the journal header with the values posted in the inventory.
    /// </remarks>
    abstract protected void initCustInvoiceJourFromTotals()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>CustVoucher</c> object.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    /// The <c>LedgerTransText</c> object that is transferred to the <c>CustVoucher</c> object.
    /// </param>
    /// <returns>
    /// The <c>CustVoucher</c> object.
    /// </returns>
    abstract protected CustVoucher initCustVoucher(LedgerTransTxt _ledgerTransTxt)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a <c>InventMovement</c> object.
    /// </summary>
    /// <returns>
    /// The <c>InventMovement</c> object.
    /// </returns>
    abstract protected InventMovement initInventMovement()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>Markup</c> object.
    /// </summary>
    protected void initMarkup()
    {
        super();

        markup.parmGoodsInRouteId_RU(salesParmTable.GoodsInRouteId_RU);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRecordLists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the record lists.
    /// </summary>
    protected void initRecordLists()
    {
        super();
        recordInsertListCustInvoicePackingSlipMatch = new RecordInsertList(tableNum(CustInvoicePackingSlipQuantityMatch));
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the totals class for posting an invoice.
    /// </summary>
    abstract protected void initTotals()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditInvoicingTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Inserts data into the <c>CustVendCreditInvoicingTrans</c> table.
    /// </summary>
    /// <param name="_sourceLine">
    ///   The source line record.
    /// </param>
    protected void insertCreditInvoicingTrans(Common _sourceLine)
    {
        CustVendCreditInvoicingTrans custVendCreditInvoicingTrans;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL]))
        {
            if (_sourceLine.RecId)
            {
                CustVendCreditInvoicingLine custVendCreditInvoicingLine = CustVendCreditInvoicingLine::findRefId(_sourceLine.TableId, _sourceLine.RecId, true);
                if (custVendCreditInvoicingLine)
                {
                    custVendCreditInvoicingTrans.insertFromCustVendCreditInvoicingLine(custVendCreditInvoicingLine, custInvoiceTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEInvoice_MX</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the electronic invoice information
    /// </summary>
    /// <param name = "_numberSeq">
    /// The <c>NumberSeq</c> record.
    /// </param>
    protected void insertEInvoice_MX(NumberSeq _numberSeq)
    {
        EInvoicePost_MX eInvoicePost = EInvoicePost_MX::construct(custInvoiceJour, _numberSeq.parmNumberSequenceId(), salesParmTable);

        eInvoicePost.createElectronicInvoiceJour();

        if (this.parmSendByMail_MX())
        {
            eInvoicePost.createXMLFileAndPopulateSysMailTable();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRecordList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the records in the record lists into the database.
    /// </summary>
    protected void insertRecordList()
    {
        super();
        recordInsertListCustInvoicePackingSlipMatch.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>intercompanyAmountMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an intercompany miscellaneous charges amount.
    /// </summary>
    /// <returns>
    /// Always returns <c>0</c>.
    /// </returns>
    /// <remarks>
    /// This method is used o calculate the miscellaneous charges on the line level.
    /// </remarks>
    protected AmountCur intercompanyAmountMarkupOnTrans()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventProfileType_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the <c>InventProfileType_RU</c> for the line being posted.
    /// </summary>
    /// <returns>
    ///    The <c>InventProfileType_RU</c> for the line being posted
    /// </returns>
    /// <remarks>
    ///    Russian feature.
    /// </remarks>
    abstract protected InventProfileType_RU inventProfileType_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReportDimHistoryLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an inventory report dimension history type.
    /// </summary>
    /// <returns>
    /// A <c>InventReportDimHistoryLogType</c> enumeration value.
    /// </returns>
    protected InventReportDimHistoryLogType inventReportDimHistoryLogType()
    {
        return InventReportDimHistoryLogType::SalesInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the invoice number to which the inventory transaction would be attached.
    /// </summary>
    /// <returns>
    /// The invoice number to which the inventory transaction would be attached.
    /// </returns>
    protected InvoiceId invoiceNum()
    {
        return custInvoiceJour.InvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJournalLinePartDelivery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a journal line is a part delivery.
    /// </summary>
    /// <returns>
    /// Always returns <c>NoYes::No</c>.
    /// </returns>
    protected NoYes isJournalLinePartDelivery()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLineStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a source line is tracked in the inventory.
    /// </summary>
    /// <returns>
    /// true if the source line is tracked in inventory; otherwise, false.
    /// </returns>
    abstract protected boolean isLineStocked()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets a journal line record.
    /// </summary>
    /// <param name="_journalLine">
    /// A journal line record.
    /// </param>
    /// <returns>
    /// The journal line record.
    /// </returns>
    protected Common journalLine(Common _journalLine = custInvoiceTrans)
    {
        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            this.preJournalLine_BR(_journalLine);
        }
        // </GBR>

        custInvoiceTrans = _journalLine as CustInvoiceTrans;
        if (custInvoiceTrans)
        {
            journalLines.addEnd(custInvoiceTrans);
        }
        return custInvoiceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the table ID for a journal line table.
    /// </summary>
    /// <returns>
    /// The table ID.
    /// </returns>
    protected TableId journalLineTableId()
    {
        return tableNum(CustInvoiceTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the document values from a <c>LedgervoucherObject</c> object.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// A <c>LedgerVoucherObject</c> object.
    /// </param>
    /// <returns>
    /// A container that contains the document values.
    /// </returns>
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        return custInvoiceJour.DocumentDate ? [custInvoiceJour.DocumentDate, custInvoiceJour.InvoiceId] : [custInvoiceJour.InvoiceDate, custInvoiceJour.InvoiceId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountExclTaxInventoryPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the line amount excluded tax for a quantity that is updated in the inventory.
    /// </summary>
    /// <returns>
    /// The line amount excluded tax for the quantity that is updated in the inventory.
    /// </returns>
    abstract protected AmountCur lineAmountExclTaxInventoryPosted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineAmountInventoryPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the line amount for a quantity that is updated in the inventory.
    /// </summary>
    /// <returns>
    /// The line amount for the quantity that is updated in the inventory.
    /// </returns>
    abstract protected AmountCur lineAmountInventoryPosted()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDiscountAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets a line discount amount.
    /// </summary>
    /// <param name="_lineDiscount">
    /// A line discount amount.
    /// </param>
    /// <returns>
    /// The line discount amount.
    /// </returns>
    protected AmountCur lineDiscountAmount(AmountCur _lineDiscount = discValue)
    {
        discValue = _lineDiscount;
        return discValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markupOnJourSourceQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query to find the miscellaneous charges on the header level.
    /// </summary>
    /// <returns>
    /// The built query.
    /// </returns>
    abstract protected Query markupOnJourSourceQuery()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveSpecTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Moves the specification to the different source.
    /// </summary>
    protected void moveSpecTrans_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCreateScrapOnInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to create scrap on inventory.
    /// </summary>
    /// <returns>
    /// true if scrap should be created on inventory; otherwise, false.
    /// </returns>
    abstract protected boolean mustCreateScrapOnInventory()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = custInvoiceJour)
    {
        custInvoiceJour = _journalTable as CustInvoiceJour;

        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = salesParmTable)
    {
        salesParmTable = _parmTable as SalesParmTable;

        return salesParmTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the customer related postings.
    /// </summary>
    protected void postCustVend()
    {
        CustTrans custTrans;
        CustTransRefType refType;
        Num refId;
        LedgerTransTxt ledgerTransTxt;

        // <GEERU>
        CustInvoiceJour_RU custInvoiceJour_RU;

        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // <GBR>
        if (BrazilParameters::isEnabled() && !this.createCustTrans_BR())
        {
            return;
        }
        // </GBR>

        if (this.creditNote())
        {
            ledgerTransTxt = LedgerTransTxt::SalesCreditNoteCust;
        }
        else
        {
            ledgerTransTxt = LedgerTransTxt::SalesInvoiceCust;
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

            if (custInvoiceJour_RU.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute)
            {
                this.moveSpecTrans_RU();
            }
        }

        // </GEERU>
        CustVoucher custVoucher = this.initCustVoucher(ledgerTransTxt);

        custVoucher.parmExchRate(custInvoiceJour.ExchRate);
        custVoucher.parmExchRateSecondary(custInvoiceJour.ExchRateSecondary);

        // <GEERU>
        if (countryRegion_RU)
        {
            custVoucher.parmSalesInvoicePostingType_RU(custInvoiceJour_RU.InvoicePostingType_RU);
        }
        // </GEERU>
        if (custInvoiceJour.creditNote())
        {
            refType = CustTransRefType::CreditNote;
            refId = custInvoiceJour.InvoiceId;
        }
        else
        {
            refType = CustTransRefType::Invoice;
            refId = custInvoiceJour.InvoiceId;
        }

        custVoucher.parmTransRefType(refType);
        custVoucher.parmTransRefId(refId);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            custVoucher.parmAmountCur(this.custTransAmount_BR());
        }
        // </GBR>

        custVoucher.parmBypassCreditCheck(this.bypassCustomerCreditCheck());
        custVoucher.post(ledgerVoucher, custTrans, NoYes::No,Currency::noYes2UnknownNoYes(custInvoiceJour.Triangulation));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndDiscount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the end discount.
    /// </summary>
    protected void postEndDiscount()
    {
        // <GEERU>
        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) || custInvoiceJour.custInvoiceJour_RU().InvoicePostingType_RU != SalesInvoicePostingType_RU::GoodsInRoute)
        {
            // </GEERU>
            super();
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>LedgerPostingType</c> value to use to post an invoice line.
    /// </summary>
    /// <returns>
    /// The <c>LedgerPostingType</c> value.
    /// </returns>
    abstract protected LedgerPostingType postingSales()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts to inventory.
    /// </summary>
    protected void postInventory()
    {
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        this.createScrapOnInventory();
        // <GEERU>
        if (countryRegion_RU && this.assetId_RU())
        {
            InventMov_AssetSale_ru assetInvent = new InventMov_AssetSale_ru(this.sourceLine());
            if (assetInvent.canDisposal())
            {
                InventUpd_Estimated estimated = InventUpd_Estimated::newInventMovement(assetInvent);
                estimated.updateNow();

                InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newPostAsset_RU(assetInvent, ledgerVoucher);
                inventUpd_Financial.parmCurrencyCode(CompanyInfoHelper::standardCurrency());
                inventUpd_Financial.updateNow();
            }
        }
        // </GEERU>
        // <GEERU>
        if (countryRegion_RU)
        {
            inventMovement.parmStorno_RU(this.isLineStorno_RU() && this.parmStorno());
            inventMovement.parmGoodsInRoute_RU(salesParmTable.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute);
            inventMovement.parmInventTransIdTransit_RU(custInvoiceTrans.custInvoiceTrans_RU().InventTransIdTransit_RU);
            inventMovement.parmInventTransIdDelivery_RU(custInvoiceTrans.custInvoiceTrans_RU().InventTransIdDelivery_RU);
            inventMovement.parmStornoPhysical_RU(salesParmTable.salesParmUpdate().StornoPhysical_RU);
        }
        // </GEERU>
        inventMovement = this.initInventMovement();
        if (inventMovement)
        {
            this.updateInventory(inventMovement);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionLineAmount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a ledger dimension for the combination of ledger dimension default account and the account that is used for posting line amount.
    /// </summary>
    /// <returns>
    ///     The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    public LedgerDimensionDefaultAccount getLedgerDimensionLineAmount()
    {
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;

        if (EXILFeatures_IT::isFeatureEnabled(EXILFeature::Exil2131))
        {
            SalesFormletterProvider salesFormletterProvider = this.formletterProvider as SalesFormletterProvider;
            if (salesFormletterProvider)
            {
                ledgerDimensionDefaultAccount = salesFormletterProvider.ledgerDimensionLineAmount_IT(this.creditNote());
            }
        }
        else
        {
            ledgerDimensionDefaultAccount = formletterProvider.ledgerDimensionLineAmount();
        }

        return LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, this.defaultDimension());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherTransList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a transaction list for posting.
    /// </summary>
    /// <param name = "_ledgerVoucherTransObject">
    /// <c>LedgerVoucherTransObject</c> object that holds transaction related information for posting.
    /// </param>
    /// <returns>
    /// A list of transactions for posting.
    /// </returns>
    protected List createLedgerVoucherTransList(LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
        List transactionList = new List(Types::Class);
        transactionList.addEnd(_ledgerVoucherTransObject);

        return transactionList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerVoucherTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates asset journal transactions based on a transaction parameter list.
    /// </summary>
    /// <param name = "_transList">
    /// Transaction list.
    /// </param>
    private void addLedgerVoucherTransactions(List _transList)
    {
        ListEnumerator transListEnumerator =  _transList.getEnumerator();

        while (transListEnumerator.moveNext())
        {
            LedgerVoucherTransObject ledgerVoucherTransObject;
            if (transListEnumerator.current())
            {
                ledgerVoucherTransObject = transListEnumerator.current();
                ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSkipPostLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Can bypass posting of line.
    /// </summary>
    /// <returns>
    ///     true if line posting should be skipped; otherwise, false.
    /// </returns>
    protected boolean canSkipPostLine()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a journal line.
    /// </summary>
    [Hookable]
    protected void postLine()
    {
        if (this.canSkipPostLine())
        {
            return;
        }

        LedgerVoucherTransObject ledgerVoucherTransObject;
        // <GEERU>
        Amount tmpLineValue;
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        InventProfileType_RU inventProfileType;
        // </GEERU>
        // <GEEPL>
        boolean postExcise = SalesParameters::find().PostExciseInLedger_PL;
        AmountCur exciseValue;
        TaxCode exciseTaxCode;
        // </GEEPL>

        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(this.fixedExchRate());
        exchangeRateHelper.parmExchangeRate2(this.fixedExchRateSecondary());

        ExchRate exchRateReporting = this.reportingCurrencyFixedExchangeRate();

        if (exchRateReporting)
        {
            exchangeRateHelper.parmReportingExchangeRate1(exchRateReporting);
        }

        LedgerDimensionAccount ledgerDimensionMerged = this.getLedgerDimensionLineAmount();

        if (!ledgerDimensionMerged)
        {
            if (CustParameters::isReturnAlternativePostingProfileEnabled() && salesParmLine.salesLine().SalesType == SalesType::ReturnItem)
            {
                throw error(strFmt("@SYS24816", "@GLS220586"));
            }
            // <GBR>
            else if (BrazilParameters::isEnabled()
                    && CustParameters::isCancelAlternativePostingProfileEnabled()
                    && salesParmLine.salesLine().isCancellingSalesOrder_BR())
            {
                throw error(strFmt("@SYS24816", "@Brazil:SalesOrderCancelling"));
            }
            // </GBR>
        }

        // <GEERU>
        if (countryRegion_RU && taxParameters.TaxSpecPosting_RU == NoYes::Yes)
        {
            tmpLineValue = - this.tmpLineValue_RU();
        }
        // </GEERU>

        AmountCur revenueAmount = lineValue;

        if (this.includeDiscValueInRevenue())
        {
            revenueAmount += discValue;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            revenueAmount = this.setRevenueAmount_BR(revenueAmount);
        }
        // </GBR>

        // <GEEPL>
        if (postExcise)
        {
            [ exciseValue, exciseTaxCode ] = this.calcExcise_PL();
            revenueAmount -= exciseValue;
        }
        // </GEEPL>

        // <GEERU>
        if (countryRegion_RU)
        {
            revenueAmount += tmpLineValue;
            inventProfileType = this.inventProfileType_RU();
        }

        if (! countryRegion_RU ||
                ( salesParmTable.InvoicePostingType_RU != SalesInvoicePostingType_RU::GoodsInRoute &&
                  inventProfileType != InventProfileType_RU::CommissionPrincipalAgent &&
                  inventProfileType != InventProfileType_RU::Bailee))
        {
            // </GEERU>
            ledgerVoucherTransObject = this.createLedgerVoucherTransObject(
                ledgerVoucherObject,
                ledgerDimensionMerged,
                -revenueAmount,
                exchangeRateHelper);

            if (!revenueAmount && custParameters.IsInvoiceZeroAmount)
            {
                ledgerVoucherObject.parmSkipZeroAmountCheck(true);
            }

            ledgerVoucherTransObject.parmTaxParentReferenceTableId(custInvoiceTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(custInvoiceTrans.RecId);
            ledgerVoucherTransObject.parmProjLedger(this.projLedger());

            if (isFinTagConfigurationSetForCurrent && SalesOrderFinTagFeature::isEnabled())
            {
                ledgerVoucherTransObject.parmFinTag(custInvoiceTrans.FinTag);
            }

            List ledgerVoucherTransactionList = this.createLedgerVoucherTransList(ledgerVoucherTransObject);
            this.addLedgerVoucherTransactions(ledgerVoucherTransactionList);

            // <GEERU>
            if (ledgerVoucherObject.ledgerBondClient_RU() && this.lineDiscountAmount() && formletterProvider.lineDiscountLedgerDimension())
            {
                LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
                ledgerBondClient.bondVRef2VRef(ledgerBondClient.findVRefByPostingType(formletterProvider.postingTypeLineDiscount()), ledgerBondClient.lastVrefId());
            }
        }
        // </GEERU>

        // <GEEPL>
        if (postExcise && exciseValue)
        {
            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                ledgerVoucherObject,
                this.postingSales(),
                LedgerDimensionFacade::serviceCreateLedgerDimension(TaxLedgerAccountGroup::accountLedgerDimension(exciseTaxCode, TaxDirection::OutgoingTax), custInvoiceTrans.DefaultDimension),
                this.currencyCode(),
                -exciseValue,
                exchangeRateHelper);
            ledgerVoucherTransObject.parmTaxParentReferenceTableId(custInvoiceTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(custInvoiceTrans.RecId);
            ledgerVoucherTransObject.parmProjLedger (this.projLedger());

            this.updateLedgerVoucherObject(ledgerVoucherObject, ledgerVoucherTransObject);

            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }
        // </GEEPL>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// An event handler delegate for updating ledger voucher object. This is intended to be called before
    /// object is being inserted into the voucher.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">The ledger voucher object.</param>
    /// <param name = "_ledgerVoucherTransObject">The ledger voucher transaction object.</param>
    delegate void updateLedgerVoucherObject(LedgerVoucherObject _ledgerVoucherObject, LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of <c>LedgerVoucherTransObject</c>.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The ledger posting reference to use for defaulting.
    /// </param>
    /// <param name="_ledgerDimensionMerged">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_revenueAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name="_exchangeRateHelper">
    /// The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <returns>
    /// An instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject createLedgerVoucherTransObject(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerDimensionAccount _ledgerDimensionMerged,
        AmountCur _revenueAmount,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        return LedgerVoucherTransObject::newTransactionAmountDefault(
            _ledgerVoucherObject,
            this.postingSales(),
            _ledgerDimensionMerged,
            this.currencyCode(),
            _revenueAmount,
            _exchangeRateHelper);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the invoice journal header for a source record.
    /// </summary>
    /// <param name="_source">
    /// The source record for which to post markup on the invoice journal header.
    /// </param>
    protected void postMarkupOnJour(Common _source)
    {
        // <GEERU>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            CustInvoiceJour_RU custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

            markup.parmCustInvoiceAccount_RU(custInvoiceJour.InvoiceAccount);
            markup.parmInvoicePostingType_RU(custInvoiceJour_RU.InvoicePostingType_RU);

            if (custInvoiceJour_RU.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute && !this.isProforma())
            {
                markup.parmExchRate(custInvoiceJour.ExchRate, custInvoiceJour.ExchRateSecondary, Currency::noYes2UnknownNoYes(custInvoiceJour.Triangulation));
            }
        }

        if (this.isProforma() && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            markup.postJournal(1,
                              this.sourceAmountMarkupOnJour(_source),
                              _source,
                              this.defaultDimensionMarkupOnJour(_source),
                              custInvoiceJour);
        }
        else
        {
            // </GEERU>
            markup.postInvoice(1,
                           this.sourceAmountMarkupOnJour(_source),
                           _source,
                           ledgerVoucher,
                           this.defaultDimensionMarkupOnJour(_source),
                           custInvoiceJour,
                           0,
                           '',
                           false,
                           totalOrderBalanceAbsoluteValue,
                           salesParmTable.ParmId,
                           SalesParmTable.TableRefId);
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for the journal lines.
    /// </summary>
    protected void postMarkupOnTrans()
    {
        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            markup.parmCustInvoiceAccount_RU(custInvoiceJour.InvoiceAccount);
            markup.parmInvoicePostingType_RU(custInvoiceJour.custInvoiceJour_RU().InvoicePostingType_RU);
            markup.parmPostNegativeMarkupAsCorrection_RU(postNegativeMarkupsAsCorrection_RU);
        }

        if (this.isProforma() && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            markup.postJournal(updateNow,
                              lineValue,
                              this.sourceMarkupOnTrans(),
                              this.defaultDimensionMarkupOnTrans(),
                              custInvoiceTrans);
        }
        else
        {
            // </GEERU>
            markup.postInvoice(updateNow,
                           lineValue,
                           this.sourceMarkupOnTrans(),
                           ledgerVoucher,
                           this.defaultDimensionMarkupOnTrans(),
                           custInvoiceTrans,
                           this.intercompanyAmountMarkupOnTrans());
            // <GEERU>
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the markup for a journal header.
    /// </summary>
    protected void postMarkupTable()
    {
        Query query = this.markupOnJourSourceQuery();
        if (query)
        {
            QueryRun queryRun = new QueryRun(query);
            while (queryRun.next())
            {
                if (queryRun.changed(this.tableIdSourceMarkupJour()))
                {
                    Common sourceMarkup = queryRun.get(this.tableIdSourceMarkupJour());
                    this.postMarkupOnJour(sourceMarkup);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the posting routines for the not stocked journal lines.
    /// </summary>
    protected void postNotStocked()
    {
        SalesInvoicePostNotStocked salesInvoicePostNotStocked = this.salesInvoicePostNotStocked();
        if (salesInvoicePostNotStocked)
        {
            salesInvoicePostNotStocked.postNotStocked();
            this.setNotStockedVariables(salesInvoicePostNotStocked);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnProforma</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the tax should be considered when a proforma journal is posted.
    /// </summary>
    /// <returns>
    /// true if the tax should be considered on the proforma journals; otherwise, false.
    /// </returns>
    protected boolean postTaxOnProforma()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the tax should be posted on update.
    /// </summary>
    /// <returns>
    /// true if the tax should be posted on update; otherwise, false.
    /// </returns>
    protected boolean postTaxOnUpdate()
    {
        // <GEERU>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            CustInvoiceJour_RU custInvoiceJour_RU = custInvoiceJour.custInvoiceJour_RU();

            if (custInvoiceJour_RU.InventProfileType_RU == InventProfileType_RU::CommissionAgent
                || custInvoiceJour_RU.InventProfileType_RU == InventProfileType_RU::CommissionPrincipalAgent
                || custInvoiceJour_RU.InventProfileType_RU == InventProfileType_RU::Bailee)
            {
                return false;
            }
        }
        // </GEERU>

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>preJournalLine_BR</Name>
				<Source><![CDATA[
    private void preJournalLine_BR(Common _journalLine)
    {
        custInvoiceTrans = _journalLine as CustInvoiceTrans;

        if (custInvoiceTrans && !journalLines_BR.find(custInvoiceTrans))
        {
            journalLines_BR.ins(custInvoiceTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>ProjLedger</c> object.
    /// </summary>
    /// <param name="_itemId">
    /// An item ID; optional.
    /// </param>
    /// <returns>
    /// An instance of the <c>ProjLedger</c> class.
    /// </returns>
    protected ProjLedger projLedger(ItemId _itemId = '')
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundingOffSign</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a rounding sign.
    /// </summary>
    /// <returns>
    /// The rounding sign.
    /// </returns>
    protected int roundingOffSign()
    {
        return -1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts a journal.
    /// </summary>
    public void run()
    {
        super();

        if (!this.isProforma() && this.CanCreateEinvoice_IT(numberSeq, custInvoiceJour))
        {
            EInvoice_IT::newCustInvoice(custInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>CanCreateEinvoice_IT</Name>
				<Source><![CDATA[
	/// <summary>
    /// Explicitly checks whether Italian electronic Invoce can be created
    /// </summary>
    /// <param name = "_numberSeq"><c>NumberSeq</c> instance of corresponding number sequence.</param>
    /// <param name = "_custInvoiceJour"><c>CustInvoiceJour</c> record, that will be used, for einvoice creation.</param>
    /// <returns>true if einvoice can be created and false otherwise.</returns>
    protected boolean CanCreateEinvoice_IT(NumberSeq _numberSeq, CustInvoiceJour _custInvoiceJour)
	{
		return true;
	}

]]></Source>
			</Method>
			<Method>
				<Name>salesInvoicePostNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an instance of the <c>SalesInvoicePostNotStocked</c> class.
    /// </summary>
    /// <returns>
    /// An instance of the <c>SalesInvoicePostNotStocked</c> class.
    /// </returns>
    /// <remarks>
    /// This method can also return null.
    /// </remarks>
    abstract protected SalesInvoicePostNotStocked salesInvoicePostNotStocked()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNotStockedVariables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a <c>SalesInvoiceJournalPost</c> object to a <c>SalesInvoicePostNotStocked</c> object.
    /// </summary>
    /// <param name="_salesInvoicePostNotStocked">
    /// An instance of the <c>SalesInvoicePostNotStocked</c> class.
    /// </param>
    protected void setNotStockedVariables(SalesInvoicePostNotStocked _salesInvoicePostNotStocked)
    {
        updateNow = _salesInvoicePostNotStocked.parmUpdateNow();
        updateNowInvent = _salesInvoicePostNotStocked.parmUpdateNowInvent();
        invoiceUpdatedOnly = _salesInvoicePostNotStocked.parmInvoiceUpdatedOnly();
        lineValue = _salesInvoicePostNotStocked.parmLineValue();
        lineValueInclTax = _salesInvoicePostNotStocked.parmLineValueInclTax();
        discValue = _salesInvoicePostNotStocked.parmDiscValue();
        cwUpdateNow = _salesInvoicePostNotStocked.parmCwUpdateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRevenueAmount_BR</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Sets the revenue amount.
    /// </summary>
    /// <param name="_revenueAmount">
    ///    The revenue amount to set
    /// </param>
    /// <returns>
    ///    The set revenue amount.
    /// </returns>
    /// <remarks>
    ///    Used in Brazil.
    /// </remarks>
    abstract protected AmountCur setRevenueAmount_BR(AmountCur _revenueAmount)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceAmountMarkupOnJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the miscellaneous charges amount for a <c>Common</c> record.
    /// </summary>
    /// <param name="_source">
    /// The source record for which to calculate the miscellaneous charges amount.
    /// </param>
    /// <returns>
    /// The calculated miscellaneous charges amount.
    /// </returns>
    /// <remarks>
    /// This method is used to calculate the miscellaneous charges on the header level.
    /// </remarks>
    abstract protected AmountCur sourceAmountMarkupOnJour(Common _source)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the record ID for the associated source document line.
    /// </summary>
    /// <returns>
    /// A record ID.
    /// </returns>
    protected RefRecId sourceDocumentLine()
    {
        return custInvoiceTrans.SourceDocumentLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the <c>UnitQty</c> value for a source line that is being invoiced.
    /// </summary>
    /// <returns>
    /// The <c>UnitQty</c> value for the source line that is being invoiced.
    /// </returns>
    abstract protected UnitQty sourceLineQuantity()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLineSalesUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the unit of measure for a source line.
    /// </summary>
    /// <returns>
    /// The unit of measure for the source line.
    /// </returns>
    /// <remarks>
    /// This method is used to post inventory.
    /// </remarks>
    abstract protected SalesUnit sourceLineSalesUnit()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceMarkupOnTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the source record to post the miscellaneous charges on the line level.
    /// </summary>
    /// <returns>
    /// A <c>Common</c> record .
    /// </returns>
    /// <remarks>
    /// This method is used to post the miscellaneous charges on the line level.
    /// </remarks>
    abstract protected Common sourceMarkupOnTrans()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>tableIdSourceMarkupJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the table ID for a table that is used to find the miscellaneous charges on the header
    /// level.
    /// </summary>
    /// <returns>
    /// A table ID.
    /// </returns>
    abstract protected TableId tableIdSourceMarkupJour()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpLineValue_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines a temporary line amount.
    /// </summary>
    /// <returns>
    ///   The temporary line amount.
    /// </returns>
    /// <remarks>
    ///    Used for calculating revenue amount when posting a line when the legal entity is in Russia.
    /// </remarks>
    abstract protected Amount tmpLineValue_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total amount for a sales invoice that is being posted.
    /// </summary>
    /// <returns>
    /// The total amount for the sales invoice.
    /// </returns>
    /// <remarks>
    /// This method is used to indicate whether the invoice is a credit note.
    /// </remarks>
    abstract protected AmountCur totalAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalQty_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the total quantity for the sales invoice being posted.
    /// </summary>
    /// <returns>
    ///    The total quantity for the sales invoice.
    /// </returns>
    /// <remarks>
    ///    Used for determine if the invoice is a credit note.
    /// </remarks>
    protected SalesQty totalQty_RU()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an instance of the <c>TransTxt</c> class.
    /// </summary>
    /// <returns>
    /// An instance of the <c>TransTxt</c> class.
    /// </returns>
    protected TransTxt transactionLogTxt()
    {
        return "@SYS16103";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a transaction log type.
    /// </summary>
    /// <returns>
    /// A <c>TransactionLogType</c> enumeration value.
    /// </returns>
    protected TransactionLogType transactionLogType()
    {
        return TransactionLogType::SalesInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a transaction date.
    /// </summary>
    /// <returns>
    /// The invoice transaction date.
    /// </returns>
    protected TransDate updateDate()
    {
        return custInvoiceJour.InvoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryFinancialForSalesInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory ledger for a sales invoice line.
    /// </summary>
    /// <param name = "_inventMovement">The inventory movement object.</param>
    /// <param name = "_salesParmLine">The sales order line update record.</param>
    /// <param name = "_salesParmSubLine">The sales order line connection update record.</param>
    /// <param name = "_inventUpdateFinancialTotals">The invent update financial totals object.</param>
    protected void updateInventoryFinancialForSalesInvoiceLine(
        InventMovement _inventMovement,
        SalesParmLine _salesParmLine,
        SalesParmSubLine _salesParmSubLine,
        InventUpdateFinancialTotals _inventUpdateFinancialTotals)
    {
        InventDim inventDim;
        InventDimParm inventDimParm;

        if (this.canUpdateInventoryFinancialForSalesInvoiceLine(_inventMovement, _salesParmLine, _salesParmSubLine, _inventUpdateFinancialTotals))
        {
            InventUpd_Financial inventUpd_Financial = this.initializeInventUpdForSalesInvoiceLine(_inventMovement, _salesParmLine, _salesParmSubLine, inventDim, inventDimParm);

            // <GTE>
            this.updateInventoryTax(_inventMovement, salesParmLine, inventUpd_Financial);
            // </GTE>

            inventUpd_Financial.updateNow();

            _inventUpdateFinancialTotals.addFromInventUpdFinancialInverted(inventUpd_Financial);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateInventoryFinancialForSalesInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the inventory ledger for a sales invoice line can be updated.
    /// </summary>
    /// <param name = "_inventMovement">The inventory movement object.</param>
    /// <param name = "_salesParmLine">The sales order line update record.</param>
    /// <param name = "_salesParmSubLine">The sales order line connection update record.</param>
    /// <param name = "_inventUpdateFinancialTotals">The invent update financial totals object.</param>
    /// <returns>returns true, inventory ledger for a sales invoice line can be updated.</returns>
    protected boolean canUpdateInventoryFinancialForSalesInvoiceLine(
        InventMovement _inventMovement,
        SalesParmLine _salesParmLine,
        SalesParmSubLine _salesParmSubLine,
        InventUpdateFinancialTotals _inventUpdateFinancialTotals)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventUpdForSalesInvoiceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>InventUpd_Financials</c> instance for updating inventory when invoicing a sales line.
    /// </summary>
    /// <param name = "_inventMovement">The inventory movement object.</param>
    /// <param name = "_salesParmLine">The sales order line update record.</param>
    /// <param name = "_salesParmSubLine">The sales order line connection update record.</param>
    /// <param name = "_inventDim">The inventory dimension values.</param>
    /// <param name = "_inventDimParm">The inventory dimension flags.</param>
    /// <returns>A new <c>InventUpd_Financial</c> instance.</returns>
    protected InventUpd_Financial initializeInventUpdForSalesInvoiceLine(
        InventMovement _inventMovement,
        SalesParmLine _salesParmLine,
        SalesParmSubLine _salesParmSubLine,
        InventDim _inventDim,
        InventDimParm _inventDimParm)
    {
        InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newSalesInvoice(_inventMovement,
            ledgerVoucher,
            this.invoiceNum(),
            _salesParmLine,
            _salesParmSubLine,
            _salesParmLine.physicalReduction(this.parmReduceOnHand()),
            _inventDim,
            _inventDimParm);

        inventUpd_Financial.parmFinancialJournalLine(custInvoiceTrans);

        return inventUpd_Financial;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the inventory ledger.
    /// </summary>
    /// <param name="_inventMovement">
    /// An <c>InventMovement</c> object.
    /// </param>
    protected void updateInventory(InventMovement _inventMovement)
    {
        SalesParmLine localSalesParmLine;
        SalesParmSubLine salesParmSubLine;
        CustPackingSlipTrans custPackingSlipTrans;
        
        SalesQty quantityMatched;
        InventQty inventoryQuantityMatched;
        PdsCWInventQty cwQuantityMatched;

        InventUpdateFinancialTotals inventUpdateFinancialTotals = InventUpdateFinancialTotals::construct();

        List list = SalesParmSubLine::buildSalesParmSubLineList(salesParmLine.RecId);
        Counter subLines = list.elements();

        if (subLines > 0)
        {
            ListEnumerator le = list.getEnumerator();
            SalesQty salesQtyLeft = salesParmLine.DeliverNow;
            InventQty inventQtyLeft = salesParmLine.InventNow;
            PdsCWInventQty cwQtyLeft = salesParmLine.PdsCWDeliverNow;

            while (le.moveNext())
            {
                salesParmSubLine = le.current();
                localSalesParmLine = salesParmLine.data();

                if (subLines == 1)
                {
                    localSalesParmLine.DeliverNow = salesQtyLeft;
                    localSalesParmLine.InventNow = inventQtyLeft;
                    localSalesParmLine.PdsCWDeliverNow = cwQtyLeft;
                }
                else
                {
                    localSalesParmLine.DeliverNow = salesParmSubLine.DeliverNow;
                    localSalesParmLine.InventNow = salesParmSubLine.InventNow;
                    localSalesParmLine.PdsCWDeliverNow = salesParmSubLine.PdsCWDeliverNow;
                }

                this.updateInventoryFinancialForSalesInvoiceLine(_inventMovement, localSalesParmLine, salesParmSubLine, inventUpdateFinancialTotals);

                subLines--;

                custPackingSlipTrans = CustPackingSlipTrans::findRecId(salesParmSubLine.JournalRefRecId,true);
                CustInvoicePackingSlipQuantityMatch::matchPackingSlipTransSourceDocumentLine(recordInsertListCustInvoicePackingSlipMatch, this.sourceDocumentLine(), custPackingSlipTrans,localSalesParmLine.DeliverNow,localSalesParmLine.InventNow);

                salesQtyLeft -= salesParmSubLine.DeliverNow;
                inventQtyLeft -= salesParmSubLine.InventNow;
                cwQtyLeft -= salesParmSubLine.PdsCWDeliverNow;
            }
        }
        else
        {
            if (salesParmLine.DeliverNow * this.sourceLineQuantity() > 0)
            {
                localSalesParmLine.data(salesParmLine);
                localSalesParmLine.RemainAfter = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(localSalesParmLine.ItemId,
                                                                                                                       localSalesParmLine.InventDimId,
                                                                                                                       localSalesParmLine.RemainBeforeInventPhysical,
                                                                                                                       localSalesParmLine.inventTable().inventUnitId(),
                                                                                                                       this.sourceLineSalesUnit(),
                                                                                                                       NoYes::Yes);

                localSalesParmLine.RemainAfterInvent = localSalesParmLine.RemainBeforeInventPhysical;

                localSalesParmLine.PdsCWRemainAfterInvent = localSalesParmLine.PdsCWRemainAfterInvent;

                int sign = salesParmLine.DeliverNow > 0 ? 1 : -1;

                while select forupdate custPackingSlipTrans
                    where custPackingSlipTrans.InventTransId == salesParmLine.InventTransId
                       && custPackingSlipTrans.FullyMatched == NoYes::No
                       && custPackingSlipTrans.Qty != 0
                {
                    SalesQty salesQuantityToMatch = sign * this.salesQuantityToMatchByCustPackingSlipTrans(
                        salesParmLine,
                        custPackingSlipTrans,
                        quantityMatched);

                    InventQty inventoryQuantityToMatch = sign * this.inventoryQuantityToMatchFromInventQty(
                                                            salesParmLine,
                                                            custPackingSlipTrans.remainInventFinancial(),
                                                            inventoryQuantityMatched);

                    PdsCWInventQty cwQuantityToMatch = PdsCatchWeight::cwQty(localSalesParmLine.ItemId, inventoryQuantityToMatch);

                    localSalesParmLine.DeliverNow = salesQuantityToMatch;
                    localSalesParmLine.InventNow = inventoryQuantityToMatch;
                    localSalesParmLine.PdsCWDeliverNow = cwQuantityToMatch;

                    salesParmSubLine.PdsCWDeliverNow = localSalesParmLine.PdsCWDeliverNow;

                    salesParmSubLine.DeliverNow = salesQuantityToMatch;
                    salesParmSubLine.InventNow = inventoryQuantityToMatch;

                    salesParmSubLine.LineRefRecId = localSalesParmLine.RecId;
                    salesParmSubLine.JournalRefRecId = custPackingSlipTrans.RecId;
                    salesParmSubLine.JournalRefTableId = tableNum(CustPackingSlipTrans);
                    salesParmSubLine.ParmId = localSalesParmLine.ParmId;

                    this.updateInventoryFinancialForSalesInvoiceLine(_inventMovement, localSalesParmLine, salesParmSubLine, inventUpdateFinancialTotals);

                    CustInvoicePackingSlipQuantityMatch::matchPackingSlipTransSourceDocumentLine(recordInsertListCustInvoicePackingSlipMatch, this.sourceDocumentLine(), custPackingSlipTrans,localSalesParmLine.DeliverNow,localSalesParmLine.InventNow);
                    quantityMatched += salesQuantityToMatch;
                    inventoryQuantityMatched += inventoryQuantityToMatch;
                    cwQuantityMatched += cwQuantityToMatch;
                    if (quantityMatched == salesParmLine.DeliverNow - inventUpdateFinancialTotals.parmUpdatePhysicalUnit())
                    {
                        break;
                    }
                }
            }

            if (quantityMatched != (salesParmLine.DeliverNow - inventUpdateFinancialTotals.parmUpdatePhysicalUnit()))
            {
                localSalesParmLine.data(salesParmLine);
                localSalesParmLine.DeliverNow -= quantityMatched;
                localSalesParmLine.InventNow -= inventoryQuantityMatched;
                localSalesParmLine.PdsCWDeliverNow -= cwQuantityMatched;
                localSalesParmLine.PdsCWRemainAfterInvent = salesParmLine.PdsCWRemainAfterInvent;
                localSalesParmLine.RemainAfter = salesParmLine.RemainAfter;
                localSalesParmLine.RemainAfterInvent = salesParmLine.RemainAfterInvent;
                salesParmSubLine = null;

                this.updateInventoryFinancialForSalesInvoiceLine(_inventMovement, localSalesParmLine, salesParmSubLine, inventUpdateFinancialTotals);
            }
        }

        cwUpdateNow = inventUpdateFinancialTotals.parmCWUpdateFinancial();
        cwInvoiceUpdatedOnly = inventUpdateFinancialTotals.parmCWUpdatePhysical();
        updateNow = inventUpdateFinancialTotals.parmUpdateFinancialUnit();
        updateNowInvent = inventUpdateFinancialTotals.parmUpdateFinancial();
        invoiceUpdatedOnly = inventUpdateFinancialTotals.parmUpdatePhysicalUnit();

        this.updateLineValues();
        this.updateSalesParmLineReducedQuantity();

        if (isConfigurationkeyEnabled(configurationKeyNum(Retail)))
        {
            RetailTransactionServiceFulfillment::updateFulfillmentStatus(this.salesParmLine.SalesLineRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesQuantityToMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the calculated sales quantity to match.
    /// </summary>
    /// <param name = "_salesParmLine">The <c>SalesParmLine</c> table record.</param>
    /// <param name = "_remainSalesFinancial">The remaining sales financial quantity.</param>
    /// <param name = "_quantityMatch">The quantity match.</param>
    /// <returns>The calculated sales quantity to match.</returns>
    protected SalesQty salesQuantityToMatch(
        SalesParmLine   _salesParmLine,
        SalesQty        _remainSalesFinancial,
        SalesQty        _quantityMatch)
    {
        return min(abs(_remainSalesFinancial), abs(_salesParmLine.DeliverNow - _quantityMatch));
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesQuantityToMatchByCustPackingSlipTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the calculated sales quantity to match from packing slip line.
    /// </summary>
    /// <param name = "_salesParmLine">The <c>SalesParmLine</c> table record.</param>
    /// <param name = "_custPackingSlipTrans">The <c>CustPackingSlipTrans</c> table record.</param>
    /// <param name = "_quantityMatch">The quantity match.</param>
    /// <returns>The calculated sales quantity to match.</returns>
    protected SalesQty salesQuantityToMatchByCustPackingSlipTrans(
        SalesParmLine _salesParmLine,
        CustPackingSlipTrans _custPackingSlipTrans,
        SalesQty _quantityMatch)
    {
        return this.salesQuantityToMatch(_salesParmLine, _custPackingSlipTrans.remainSalesFinancial(), _quantityMatch);
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryQuantityToMatchFromInventQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the calculated sales inventory quantity to match.
    /// </summary>
    /// <param name = "_salesParmLine">The <c>SalesParmLine</c> table record.</param>
    /// <param name = "_remainInventFinancial">The remaining inventory financial quantity.</param>
    /// <param name = "_quantityMatch">The inventory quantity match.</param>
    /// <returns>The calculated inventory quantity to match.</returns>
    protected InventQty inventoryQuantityToMatchFromInventQty(
        SalesParmLine   _salesParmLine,
        InventQty       _remainInventFinancial,
        InventQty       _quantityMatch)
    {
        return min(abs(_remainInventFinancial), abs(_salesParmLine.InventNow - _quantityMatch));
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventoryQuantityToMatch</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the calculated inventory quantity to match.
    /// </summary>
    /// <param name = "_salesParmLine">The <c>SalesParmLine</c> table record.</param>
    /// <param name = "_salesQuantityToMatch">The sales quantity.</param>
    /// <returns>The calculated inventory quantity to match.</returns>
    protected InventQty inventoryQuantityToMatch(
        SalesParmLine   _salesParmLine,
        SalesQty        _salesQuantityToMatch)
    {
        return EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(
                    _salesParmLine.ItemId,
                    _salesParmLine.InventDimId,
                    _salesQuantityToMatch,
                    this.sourceLineSalesUnit(),
                    _salesParmLine.inventTable().inventUnitId(),
                    NoYes::Yes);
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyCustInvoiceJourOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the customer invoice journal record.
    /// </summary>
    /// <param name = "_custInvoiceJour">The customer invoice journal record.</param>
    delegate void modifyCustInvoiceJourOnUpdate(CustInvoiceJour _custInvoiceJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyCustInvoiceTransOnUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the customer invoice transaction record.
    /// </summary>
    /// <param name = "_custInvoiceTrans">The customer invoice transaction record.</param>
    delegate void modifyCustInvoiceTransOnUpdate(CustInvoiceTrans _custInvoiceTrans)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a journal line.
    /// </summary>
    protected void updateJournalLine()
    {
        custInvoiceTrans.PdsCWQty = cwUpdateNow;
        custInvoiceTrans.PdsCWQtyPhysical = cwInvoiceUpdatedOnly;
        custInvoiceTrans.Qty = updateNow;
        custInvoiceTrans.InventQty = updateNowInvent;
        custInvoiceTrans.QtyPhysical = invoiceUpdatedOnly;
        custInvoiceTrans.LineAmount = lineValue;
        custInvoiceTrans.LineAmountTax = lineValueInclTax - lineValue;
        custInvoiceTrans.SumLineDisc = discValue;
        custInvoiceTrans.PartDelivery = this.isJournalLinePartDelivery();

        custInvoiceTrans.LineAmountMST = custInvoiceJour.amountMST(custInvoiceTrans.LineAmount);
        custInvoiceTrans.LineAmountTaxMST = custInvoiceJour.amountMST(custInvoiceTrans.LineAmountTax);
        custInvoiceTrans.SumLineDiscMST = custInvoiceJour.amountMST(custInvoiceTrans.SumLineDisc);

        this.modifyCustInvoiceTransOnUpdate(custInvoiceTrans);

        custInvoiceTrans.update();

        this.insertCreditInvoicingTrans(this.sourceLine());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates a journal header.
    /// </summary>
    protected void updateJournalTable()
    {
        this.initCustInvoiceJourFromTotals();

        custInvoiceJour.calcDue();
        custInvoiceJour.calcCashDiscDate();
        custInvoiceJour.Updated = NoYes::Yes;

        custInvoiceJour.Proforma = this.parmProforma();

        if (this.useBillOfLading())
        {
            WMSBillOfLading wmsBillOfLading = WMSBillOfLading::constructFromInvoice(custInvoiceJour, salesParmTable.salesParmUpdate(), salesParmTable);
            custInvoiceJour.BillOfLadingId = wmsBillOfLading.BillOfLadingId;
        }

        this.modifyCustInvoiceJourOnUpdate(custInvoiceJour);

        custInvoiceJour.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLineValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the line value variables that are based on a quantity that the inventory has posted.
    /// </summary>
    protected void updateLineValues()
    {
        lineValue = this.lineAmountExclTaxInventoryPosted();
        lineValueInclTax = this.lineAmountInventoryPosted();
        discValue = this.discAmountExclTaxcInventoryPosted();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNonPostedParmLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the records in the <c>SalesParmLine</c> table that have not yet been processed.
    /// </summary>
    /// <param name="_salesParmLine">
    /// A <c>SalesParmLine</c> record.
    /// </param>
    protected void updateNonPostedParmLines(SalesParmLine _salesParmLine)
    {
        SalesParmLine localSalesParmLine;

        while select RecId from localSalesParmLine
            where localSalesParmLine.ParmId == _salesParmLine.ParmId &&
                  localSalesParmLine.OrigSalesId == _salesParmLine.OrigSalesId &&
                  localSalesParmLine.InventTransId == _salesParmLine.InventTransId &&
                  // <GEERU>
                  (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) ||
                  localSalesParmLine.InventOwnerId_RU == _salesParmLine.InventOwnerId_RU)
             // </GEERU>
             && localSalesParmLine.TableRefId != _salesParmLine.TableRefId

        {
            SalesParmLine updateSalesParmLine = SalesParmLine::findRecId(localSalesParmLine.RecId, true);
            updateSalesParmLine.RemainBefore -= updateNow;
            updateSalesParmLine.RemainBeforeInvent -= updateNowInvent;
            updateSalesParmLine.PdsCWRemainBefore -= cwUpdateNow;
            updateSalesParmLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesParmLineReducedQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the quantities in a <c>SalesParmLine</c> record if the inventory has reduced the delivered
    /// quantity to on-hand.
    /// </summary>
    abstract protected void updateSalesParmLineReducedQuantity()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>useBillOfLading</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether to use the bill of lading when an invoice is posted.
    /// </summary>
    /// <returns>
    /// true if the bill of lading should be used; otherwise, false.
    /// </returns>
    protected boolean useBillOfLading()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInventOwnerIdRange_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if inventory owner should be used.
    /// </summary>
    /// <returns>
    /// true if inventory owner should be used; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Russian feature used when posting inventory.
    /// </remarks>
    abstract protected boolean useInventOwnerIdRange_RU()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventoryTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update inventory tax for transfer order receive.
    /// </summary>
    /// <param name = "_inventMovement">The <c>InventMovement</c> object.</param>
    /// <param name = "_salesParmLine">The <c>SalesParmLine</c> record.</param>
    /// <param name = "_inventUpd_Financial">The <c>InventUpd_Financial</c> record.</param>
    protected void updateInventoryTax(InventMovement _inventMovement, SalesParmLine _salesParmLine, InventUpd_Financial _inventUpd_Financial)
    {
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            ITaxDocument taxDocument = TaxBusinessService::calculateTax(TaxableDocumentObject::construct(this.parmTaxableDocumentDescriptor()));
            if (taxDocument)
            {
                _inventMovement.setTaxEngineInventMovement(TaxEngineInventMovement::construct(salesParmLine, taxDocument));
                ITaxDocumentLine taxDocumentLine = taxDocument.findLineBySource(custInvoiceTrans.TableId, custInvoiceTrans.RecId);
                if (taxDocumentLine)
                {
                    AmountCur costAmount = _inventUpd_Financial.parmCostAmountCur();
                    costAmount += taxDocumentLine.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                    costAmount -= taxDocumentLine.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
                    _inventUpd_Financial.parmCostAmountCur(costAmount);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runInvoicePostEvent</Name>
				<Source><![CDATA[
    private void runInvoicePostEvent()
    {
        if (custInvoiceJour.RecId)
        {
            InvoicePostedBusinessEvent::newFromInvoiceJour(InvoicePostedBusinessEventEntityType::SalesInvoiceEntity, custInvoiceJour).send();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    protected void endPost()
    {
        super();
        SalesInvoicePostedBusinessEvent::newFromCustInvoiceJour(custInvoiceJour).send();
        
        this.runInvoicePostEvent();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>