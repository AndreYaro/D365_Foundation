<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EmplExchAdjustmentCalc_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class EmplExchAdjustmentCalc_RU
{
    EmplExchAdj_RU      emplExchAdj;
    LedgerVoucher       ledgerVoucher;
    TransactionTxt      transTxt;
    LedgerVoucherObject ledgerVoucherObject;
    TransDate           transactionDate;
    boolean             isFromSettlement;

    CustVendExchAdjParm_W               custVendExchAdjParm;
    EmplAdvAdjustmentDocUpdate_RU       emplAdvAdjustmentDocUpdate;

    // Current values to use in ledgerDimensionObtainedEventHandler
    RTax25ExchAdjDimension          currentExchAdjDimension;
    TransactionSelect               currentUseProfile;
    NoneTableTrans                  currentDimSpec;
    LedgerDimensionDefaultAccount   currentSummaryAccount;
    LedgerDimensionDefaultAccount   currentOffsetAccount;
    DimensionDefault                currentDefaultDimension;
    boolean                         currentInheritPosting;
    boolean                         skipAdvanceTableUpdate;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcAndPostTaxExchRateDiff_RU</Name>
				<Source><![CDATA[
    public TaxAmount calcAndPostTaxExchRateDiff_RU(Amount                   _exchRateDiff,
                                                   EmplTrans_RU             _mainEmplTrans,
                                                   LedgerPostingType        _posting,
                                                   EmplTrans_RU             _exchRateTrans,
                                                   EmplAdvLine_RU           _emplAdvLine,
                                                   boolean                  _isReportingExchDiff,
                                                   LedgerDimensionAccount   _profitLossLedgerDimension,
                                                   LedgerDimensionAccount   _sumLedgerDimension)

    {
        TaxAmount               taxAmount;
        real                    convertFactor;
        TaxExchDiff_RU          tax;
        ExchAdjTaxableType_W    taxable;
        VendTrans               vendTrans;
        EmplAdvLine_RU          emplAdvLine = _emplAdvLine;

        convertFactor = _isReportingExchDiff ?
            (_mainEmplTrans.ReportingCurrencyAmount ? _exchRateDiff / _mainEmplTrans.ReportingCurrencyAmount : 0) :
            (_mainEmplTrans.AmountMST               ? _exchRateDiff / _mainEmplTrans.AmountMST               : 0);

        if (_mainEmplTrans.RefTableId == tableNum(VendTrans))
        {
            vendTrans = VendTrans::find(_mainEmplTrans.RefRecId);
        }

        tax = new TaxExchDiff_RU(ledgerVoucher.lastVoucher(),
                                 ledgerVoucher.lastTransDate(),
                                 '',
                                 vendTrans,
                                 convertFactor,
                                 emplAdvLine);

        tax.parmSkipDistribution(true);
        tax.parmOverrideDefaultDimension(true);
        tax.parmDimensionDefault(LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_profitLossLedgerDimension));

        taxable = custVendExchAdjParm.taxable(_posting);

        if (taxable == ExchAdjTaxableType_W::Tax)
        {
            tax.parmLedgerPostingType(_posting);
            tax.parmCustVendExchAdjParm(custVendExchAdjParm);
            tax.parmPostToReportingCurrency(_isReportingExchDiff);
            tax.calcAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher),
                            _mainEmplTrans.Voucher,
                            _mainEmplTrans.TransDate);

            taxAmount = tax.taxAmountCalculated();
        }

        return  taxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerVoucherObject</Name>
				<Source><![CDATA[
    public LedgerVoucherObject createLedgerVoucherObject(Voucher _voucher)
    {
        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(_voucher, transactionDate);

        if (! ledgerVoucherObject)
        {
        ledgerVoucherObject = LedgerVoucherObject::newVoucher(_voucher,
                                                              transactionDate,
                                                              SysModule::Employee_RU,
                                                              LedgerTransType::ExchAdjustment);

            ledgerVoucher.addVoucher(ledgerVoucherObject);
        }

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a list of distributions for a given <c>EmplTrans</c>.
    /// </summary>
    /// <param name="_emplTrans">
    /// EmplTrans cursor
    /// </param>
    /// <param name="_defaultLedgerDimension">
    /// The <c>LedgerDimensionAccount</c> to distribute the amounts to when the original distributions cannot be identified.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of the first <c>DimensionAttributeValueSet</c> record that provides the default values for the ledger dimension.
    /// </param>
    /// <param name="_accountingAmount">
    /// The amount to distribute in the accounting currency.
    /// </param>
    /// <param name="_reportingAmount">
    /// The amount to distribute in the reporting currency.
    /// </param>
    /// <param name="_inheritPosting">
    /// Is the LedgerDimensionAccount should be inherited.
    /// </param>
    /// <param name="_offsetDefaultAccount">
    /// The ID of the <c>DimensionAttributeValueCombination</c> record that specifies the initial dimension value for offset account.
    /// </param>
    /// <returns>
    ///  A list containing the collection of <c>CustVendTransDistribution</c> instances that were created.
    /// </returns>
    protected Enumerator getDistributions(
        EmplTrans_RU                    _emplTrans,
        LedgerDimensionAccount          _defaultLedgerDimension,
        DimensionDefault                _defaultDimension,
        Amount                          _accountingAmount,
        Amount                          _reportingAmount,
        boolean                         _inheritPosting = false,
        LedgerDimensionDefaultAccount   _offsetDefaultAccount = currentExchAdjDimension.getLedgerDimension())
    {
        CustVendTransExchAdjDistController_RU   controller          = CustVendTransExchAdjDistController_RU::construct();
        currentInheritPosting   = _inheritPosting;
        currentOffsetAccount    = _offsetDefaultAccount;
        controller.parmDefaultOffsetLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(_offsetDefaultAccount, _defaultDimension));
        controller.ledgerDimensionObtained += eventhandler(this.ledgerDimensionObtainedEventHandler);
        return controller.generateDistributions(
            this.getTransForDistributionController(_emplTrans),
            LedgerPostingType::EmplBalance_RU,
            _accountingAmount,
            _accountingAmount,
            _reportingAmount,
            _defaultLedgerDimension).getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributionsForVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a list of distributions for a given <c>VendInvoiceTrans</c>.
    /// </summary>
    /// <param name="_vendTrans">
    /// VendTrasn record.
    /// </param>
    /// <param name="_vendInvoiceTrans">
    /// VendInvoiceTrans record.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    /// The <c>LedgerDimensionAccount</c> to distribute the amounts to when the original distributions cannot be identified.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of the first <c>DimensionAttributeValueSet</c> record that provides the default values for the ledger dimension.
    /// </param>
    /// <param name="_accountingAmount">
    /// The amount to distribute in the accounting currency.
    /// </param>
    /// <param name="_reportingAmount">
    /// The amount to distribute in the reporting currency.
    /// </param>
    /// <returns>
    /// A list containing the collection of <c>CustVendTransDistribution</c> instances that were created.
    /// </returns>
    protected Enumerator getDistributionsForVendInvoiceTrans(VendTrans _vendTrans, VendInvoiceTrans _vendInvoiceTrans, LedgerDimensionAccount _defaultLedgerDimension,  DimensionDefault _defaultDimension, Amount _accountingAmount, Amount _reportingAmount)
    {
        CustVendTransExchAdjDistController_RU   controller          = CustVendTransExchAdjDistController_RU::construct();
        controller.parmDefaultOffsetLedgerDimension(
            LedgerDimensionFacade::serviceCreateLedgerDimension(currentExchAdjDimension.getLedgerDimension(), _defaultDimension));
        controller.parmSourceDocumentLine(SourceDocumentLine::find(_vendInvoiceTrans.SourceDocumentLine));
        return controller.generateDistributions(
            _vendTrans,
            LedgerPostingType::EmplBalance_RU,
            _accountingAmount,
            _accountingAmount,
            _reportingAmount,
            _defaultLedgerDimension).getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastExchAdjParameters</Name>
				<Source><![CDATA[
    protected container getLastExchAdjParameters(EmplTrans_RU _emplTrans,
                                                 TransDate    _transDate = _emplTrans.LastExchAdj,
                                                 boolean      _returnDimSpec = false)
    {
        EmplTrans_RU                  exchAdjTrans;
        EmplExchRateAdjustment_RU     emplExchRateAdjustment;
        DimensionDefault              defaultDimension;
        PostingProfile                postingProfile;
        LedgerDimensionDefaultAccount sumDefaultAccount;

        select firstonly LastExchAdjRate, ReportingLastExchAdjRate, LedgerDimension from exchAdjTrans
            order by TransDate desc, Correct asc, CreatedTransactionId desc
            where exchAdjTrans.RefTableId   == _emplTrans.TableId               &&
                  exchAdjTrans.RefRecId     == _emplTrans.RecId                 &&
                  exchAdjTrans.TransType    ==  EmplTransSourceType_RU::ExchAdj &&
                  exchAdjTrans.EmplAccount  == _emplTrans.EmplAccount           &&
                  exchAdjTrans.TransDate    <= _transDate
            join Dimensions, UseProfile, PostingProfile, ExchPrinciple, ConsideredDate, DateOfRate from emplExchRateAdjustment
                where emplExchRateAdjustment.CreatedTransactionId == exchAdjTrans.CreatedTransactionId;

        switch (emplExchRateAdjustment.Dimensions)
        {
            case NoneTableTrans::None :
                defaultDimension = 0;
                break;

            case NoneTableTrans::Table :
                defaultDimension = HcmEmployment::find(EmployeeTable_RU::findByEmployeeId(_emplTrans.EmplAccount).HcmEmployment).DefaultDimension;
                break;

            case NoneTableTrans::Transaction :
                defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_emplTrans.LedgerDimension);
                break;
        }

        switch (emplExchRateAdjustment.UseProfile)
        {
            case TransactionSelect::Selection:
                postingProfile = emplExchRateAdjustment.PostingProfile;
                break;

            case TransactionSelect::Transaction :
                postingProfile = _emplTrans.PostingProfile;
                break;
        }

        sumDefaultAccount = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension);

        return [emplExchRateAdjustment.ExchPrinciple,
                defaultDimension,
                postingProfile,
                sumDefaultAccount,
                emplExchRateAdjustment.ConsideredDate,
                emplExchRateAdjustment.DateOfRate,
                exchAdjTrans.LastExchAdjRate,
                exchAdjTrans.ReportingLastExchAdjRate,
                emplExchRateAdjustment.UseProfile
                ] + (_returnDimSpec ? [emplExchRateAdjustment.Dimensions] : conNull());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOpenAmounts</Name>
				<Source><![CDATA[
    protected container getOpenAmounts(EmplTrans_RU  _emplTrans,
                                       TransDate     _transDate = transactionDate)
    {
        EmplSettlement_RU   emplSettlement;
        AmountCur           transactionOpenAmount   = _emplTrans.AmountCur;
        AmountMST           accountingOpenAmount    = _emplTrans.AmountMST;
        AmountMSTSecondary  reportingOpenAmount     = _emplTrans.ReportingCurrencyAmount;

        if (_emplTrans.AmountCur > 0)
        {
            while select * from emplSettlement
                where emplSettlement.DebitRecId == _emplTrans.RecId &&
                      emplSettlement.TransDate  <= _transDate       &&
                      emplSettlement.SettleAmountCurDebit           &&
                      emplSettlement.SettleAmountCurCredit
            {
                transactionOpenAmount += - emplSettlement.SettleAmountCurDebit;

                if (emplSettlement.SettleAmountMSTDebit)
                {
                    accountingOpenAmount += - emplSettlement.SettleAmountMSTDebit;
                }
                else
                {
                    accountingOpenAmount += - emplSettlement.SettleAmountMST       + (emplSettlement.ExchAdjustment < 0 ? emplSettlement.ExchAdjustment : 0);
                }

                if (emplSettlement.ReportingSettleAmountDebit)
                {
                    reportingOpenAmount  += - emplSettlement.ReportingSettleAmountDebit;
                }
                else
                {
                    reportingOpenAmount  += - emplSettlement.ReportingSettleAmount + (emplSettlement.ReportingExchAdjustment < 0 ? emplSettlement.ReportingExchAdjustment : 0);
                }
            }
        }
        else
        {
            while select * from emplSettlement
                where emplSettlement.CreditRecId == _emplTrans.RecId &&
                      emplSettlement.TransDate   <= _transDate       &&
                      emplSettlement.SettleAmountCurDebit            &&
                      emplSettlement.SettleAmountCurCredit
            {
                transactionOpenAmount += - emplSettlement.SettleAmountCurCredit;

                if (emplSettlement.SettleAmountMSTCredit)
                {
                    accountingOpenAmount += - emplSettlement.SettleAmountMSTCredit;
                }
                else
                {
                    accountingOpenAmount += - emplSettlement.SettleAmountMST + (emplSettlement.ExchAdjustment > 0 ? emplSettlement.ExchAdjustment : 0);
                }

                if (emplSettlement.ReportingSettleAmountCredit)
                {
                    reportingOpenAmount += - emplSettlement.ReportingSettleAmountCredit;
                }
                else
                {
                    reportingOpenAmount += - emplSettlement.ReportingSettleAmount + (emplSettlement.ReportingExchAdjustment > 0 ? emplSettlement.ReportingExchAdjustment : 0);
                }
            }
        }

        return [transactionOpenAmount, accountingOpenAmount, reportingOpenAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransForDistributionController</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets <c>VendTrans</c> record for a given <c>EmplTrans</c> cursor.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmplTrans</c> record.
    /// </param>
    /// <returns>
    /// <c>VendTrans</c> record.
    /// </returns>
    protected CustVendTrans getTransForDistributionController(EmplTrans_RU _emplTrans)
    {
        if (_emplTrans.RefTableId == tableNum(VendTrans))
        {
            return VendTrans::find(_emplTrans.RefRecId);
        }
        else
        {
            return this.getVirtualCustVendTrans(_emplTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVirtualCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and return virtual <c>CustVendTrans</c> record for given <c>EmplTrans_RU</c> cursor.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmplTrans_RU</c> record.
    /// </param>
    /// <returns>
    /// Virtual <c>CustVendTrans</c> record.
    /// </returns>
    protected CustVendTrans getVirtualCustVendTrans(EmplTrans_RU _emplTrans)
    {
        EmplAdvLine_RU                          emplAdvLine         = EmplAdvLine_RU::findTransEmplRecId(_emplTrans.RecId, true);
        SourceDocumentLine                      sourceDocumentLine  = SourceDocumentLine::find(emplAdvLine.SourceDocumentLine);
        AccountingEvent                         accountingEvent     = AccountingDistribution::getLastSourceDocumentLineEvent(sourceDocumentLine.RecId);
        VendTrans ret;
        ret.CurrencyCode    = _emplTrans.CurrencyCode;
        ret.AccountingEvent = accountingEvent.RecId;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucher</Name>
				<Source><![CDATA[
    protected void initLedgerVoucher(EmplTrans_RU   _emplTrans)
    {
        NumberSeq numberSeq;
        Voucher   voucher;

        numberSeq = NumberSeq::newGetVoucher(emplExchAdj.numberSequence());
        voucher   = numberSeq.voucher();
        transTxt  = TransactionTxt::construct();

        transTxt.setType(emplExchAdj.transTxtType());
        transTxt.setLanguage(CompanyInfo::languageId());
        transTxt.setVoucher(voucher);
        transTxt.setFormLetter(_emplTrans.AdvanceId);
        transTxt.setKey1(_emplTrans.EmplAccount);

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                     SysModule::Employee_RU,
                                                     numberSeq.parmVoucherSequenceCode());

        ledgerVoucher.parmCheckBlockedDimensions(false);

        ledgerVoucher.addVoucher(
            LedgerVoucherObject::newVoucher(voucher,
                                            transactionDate,
                                            SysModule::Employee_RU,
                                            LedgerTransType::ExchAdjustment));

        ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transTxt.txt(emplExchAdj.transExchAdjTxt()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAdvanceAdjustment</Name>
				<Source><![CDATA[
    public boolean isAdvanceAdjustment(EmplTrans_RU _transDebit, EmplTrans_RU _transCredit)
    {
        if (LedgerParameters::find().ExchRateDiffCalcType_W == ExchRateDiffCalcType_W::Standard)
        {
            return false;
        }

        if (LedgerParameters::find().AdvanceAdjustment_W                          &&
            _transCredit.TransDate    >= _transDebit.TransDate                    &&
            (_transCredit.TransType   == EmplTransSourceType_RU::Unknown          ||
             _transCredit.TransType   == EmplTransSourceType_RU::VendInvoice      ||
             _transCredit.TransType   == EmplTransSourceType_RU::VendInvoiceTrans ||
             _transCredit.TransType   == EmplTransSourceType_RU::AdvLine)         &&
            (_transDebit.TransType    == EmplTransSourceType_RU::Bank             ||
             _transDebit.TransType    == EmplTransSourceType_RU::CashDoc))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryClosed</Name>
				<Source><![CDATA[
    private boolean isInventoryClosed(VendTrans _vendTrans, TransDate _transDate)
    {
        boolean   ret;
        TransDate closingDate;

        if (_vendTrans.RecId)
        {
            closingDate = InventClosing::closingDate();
            if (closingDate < _transDate)
            {
                closingDate = InventClosing::closingDate(false, InventTransCurrency_RU::SecondaryCur);
            }
            if (closingDate >= _transDate)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimensionObtainedEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Overrides account to profitLoss if _isOffset, dimension to RTax25
    /// </summary>
    /// <param name="_isOffset">
    ///  is the LedgerDimensionAccount refers to offset
    /// </param>
    /// <param name="_anyType">
    ///    reference to LedgerDimensionAcount
    /// </param>
    public void ledgerDimensionObtainedEventHandler(boolean _isOffset, SysAnyType _anyType)
    {
        LedgerDimensionAccount          ledgerDimension         = _anyType.value();
        DimensionDefault                ledgerDefaultDimension;
        LedgerDimensionDefaultAccount   defaultAccount          = (! currentInheritPosting && _isOffset) ? currentOffsetAccount :
                                                                              ((currentUseProfile == TransactionSelect::Transaction) ?
                                                                                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerDimension) :
                                                                                    currentSummaryAccount);

        ledgerDefaultDimension = (currentDimSpec == NoneTableTrans::Transaction) ?
                                        LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerDimension) :
                                        currentDefaultDimension;

        ledgerDefaultDimension = currentExchAdjDimension.getDefaultDimension(ledgerDefaultDimension);
        _anyType.value(LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, ledgerDefaultDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmplExchAdj</Name>
				<Source><![CDATA[
    public EmplExchAdj_RU parmEmplExchAdj(EmplExchAdj_RU _emplExchAdj = emplExchAdj)
    {
        emplExchAdj = _emplExchAdj;

        return emplExchAdj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFromSettlement</Name>
				<Source><![CDATA[
    public boolean parmIsFromSettlement(boolean _isFromSettlement = isFromSettlement)
    {
        isFromSettlement = _isFromSettlement;

        return isFromSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipAdvanceTableUpdate</Name>
				<Source><![CDATA[
    public boolean parmSkipAdvanceTableUpdate(boolean _value = skipAdvanceTableUpdate)
    {
        skipAdvanceTableUpdate = _value;
        return skipAdvanceTableUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAdvanceAdjTrans</Name>
				<Source><![CDATA[
    public EmplTrans_RU postAdvanceAdjTrans(EmplTrans_RU               _mainEmplTrans,
                                            AmountMSTExchAdjustment    _accountingExchAdjAmount,
                                            AmountMSTSecondary         _reportingExchAdjAmount,
                                            TransDate                  _transDate,
                                            LedgerVoucherObject        _ledgerVoucherObject,
                                            DimensionDefault           _defaultDimension   = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_mainEmplTrans.LedgerDimension),
                                            Common                     _sourceTable = null)
    {
        EmplTrans_RU                    exchAdjTrans;
        LedgerBondClient_RU             ledgerBondClient;
        EmplAdvTable_RU                 emplAdvTable = EmplAdvTable_RU::find(_mainEmplTrans.AdvanceId);
        EmplAdvLine_RU                  emplAdvLine  = EmplAdvLine_RU::findTransEmplRecId(_mainEmplTrans.RecId, true);
        LedgerPostingType               posting;
        LedgerPostingType               postingLedger;
        LedgerPostingType               reportingPosting;
        LedgerPostingType               reportingPostingLedger;
        VendTrans                       vendTrans;
        LedgerDimensionDefaultAccount   ledgerDimensionAccount, offsetLedgerDimensionAccount;
        ExchRate                        newExchRate;

        TaxAmount                       taxAmount;
        AmountMST                       accountingTaxAmountTotal;
        AmountMSTSecondary              reportingTaxAmountTotal;

        VendInvoiceJour                 vendInvoiceJour;
        VendInvoiceTrans                vendInvoiceTrans;
        CustVendSettle                  custVendSettle;
        RTax25ExchAdjDimension          exchAdjDimension;

        SourceDocumentLine              sourceDocumentLine;
        AccountingEvent                 accountingEvent;

        List                            sourceLineDistributionList;
        AmountMST                       distributionAmount;
        AmountMSTSecondary              reportingDistributionAmount;
        AmountMST                       remainAmount;
        AmountMSTSecondary              reportingRemainAmount;
        int                             elements;
        AllocationFactor                allocationFactor;
        ListEnumerator                  le;
        boolean                         distributionExist;
        CurrencyCode                    accountingCurrency  = Ledger::accountingCurrency();
        CurrencyCode                    reportingCurrency = Ledger::reportingCurrency();

        CustVendTransCorrespondentDistribution  distribution;
        Enumerator                              e;

        void postSpecial(Amount _exchAdjAmount, LedgerPostingType _postingType, boolean _isReporting)
        {
            if (_exchAdjAmount)
            {
                custVendExchAdjParm.rTax25ExchAdjDimension().parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(_postingType));

                currentExchAdjDimension = custVendExchAdjParm.rTax25ExchAdjDimension();
                currentDimSpec          = NoneTableTrans::Transaction;
                currentUseProfile       = TransactionSelect::Transaction;
                currentSummaryAccount   = exchAdjTrans.summaryLedgerDimension();
                currentDefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(exchAdjTrans.LedgerDimension);

                e = this.getDistributions(
                    _mainEmplTrans,
                    exchAdjTrans.summaryLedgerDimension(),
                    ledgerDimensionAccount,
                    _isReporting ? 0 : _exchAdjAmount,
                    _isReporting ? _exchAdjAmount: 0,
                    false,
                    custVendExchAdjParm.ledgerDimension(posting));

                while (e.moveNext())
                {
                    distribution = e.current();
                    this.postExchAdjLedgerTrans_SpecialPosting(_postingType,
                                                               _isReporting ?
                                                                    distribution.reportingAmount() :
                                                                    distribution.accountingAmount(),
                                                               distribution.offsetLedgerDimension(),
                                                               distribution.ledgerDimension(),
                                                               _mainEmplTrans,
                                                               exchAdjTrans.TransDate,
                                                               exchAdjTrans,
                                                               NoneTableTrans::Transaction,
                                                               _transDate,
                                                               emplAdvLine,
                                                               newExchRate,
                                                               _isReporting);
                }
            }
        }
        void postTaxes(LedgerDimensionAccount   _summaryLedgerDimension,
                       Amount                   _exchRateDiffLine,
                       DimensionDefault         _taxDefaultDimension,
                       TaxGroup                 _taxGroup,
                       TaxItemGroup             _taxItemGroup,
                       boolean                  _isReportingExchDiff)
        {
            Amount          exchRateDiffLineExclTax = _exchRateDiffLine;
            TaxExchDiff_RU  tax;
            boolean         correct = ledgerVoucher.findLedgerVoucherObject().parmCorrection();

            if (custVendExchAdjParm.taxable(posting) == ExchAdjTaxableType_W::Tax)
            {
                exchRateDiffLineExclTax = Tax::baseAmountExclTax(_taxGroup,
                                                                 _taxItemGroup,
                                                                 _transDate,
                                                                 _isReportingExchDiff ? reportingCurrency : accountingCurrency,
                                                                 _exchRateDiffLine,
                                                                 TaxModuleType::Purch);

                ledgerVoucher.findLedgerVoucherObject().parmCorrection(_isReportingExchDiff ? exchAdjTrans.ReportingCurrencyAmount > 0 : exchAdjTrans.AmountMST > 0);

                exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(_isReportingExchDiff ? reportingPosting : posting));

                tax = new TaxExchDiff_RU(ledgerVoucher.lastVoucher(),
                                         ledgerVoucher.lastTransDate(),
                                         '',
                                         vendTrans,
                                         0,
                                         emplAdvLine);

                tax.parmLedgerPostingType(_isReportingExchDiff ? reportingPostingLedger : postingLedger);
                tax.parmCustVendExchAdjParm(custVendExchAdjParm);
                tax.parmDimensionDefault(exchAdjDimension.getDefaultDimension(_taxDefaultDimension));
                tax.parmPostToReportingCurrency(_isReportingExchDiff);

                taxAmount = tax.taxCalcWithoutSource(_taxGroup,
                                                     _taxItemGroup,
                                                     _transDate,
                                                     accountingCurrency,
                                                     exchRateDiffLineExclTax,
                                                     TaxModuleType::Purch,
                                                     0,
                                                     '',
                                                     '',
                                                     TaxDirection::OutgoingTax,
                                                     GSTHSTTaxType_CA::None,
                                                     _transDate);

                if (CurrencyExchangeHelper::amount(exchRateDiffLineExclTax + taxAmount - _exchRateDiffLine))
                {
                    tax.adjustPennyDiff(CurrencyExchangeHelper::amount(exchRateDiffLineExclTax + taxAmount - _exchRateDiffLine));
                    taxAmount = CurrencyExchangeHelper::amount(_exchRateDiffLine - exchRateDiffLineExclTax);
                }

                if (ledgerBondClient)
                {
                    ledgerBondClient.addNewLogObject();
                }

                tax.saveAndPost(LedgerPostingController::newForLedgerPostingJournal(ledgerVoucher));

                ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                LedgerPostingType::EmplBalance_RU,
                                                                                _summaryLedgerDimension,
                                                                                _mainEmplTrans.CurrencyCode,
                                                                                0,
                                                                                _isReportingExchDiff ? 0 : - taxAmount,
                                                                                _isReportingExchDiff ? - taxAmount : 0));

                if (ledgerBondClient)
                {
                    if (ledgerBondClient.currentLogLength() > 0)
                    {
                        ledgerBondClient.bondLastVRef2CurrentLog();
                    }

                    ledgerBondClient.removeCurrentLogObject();
                }

                // restore original correction sign
                ledgerVoucher.findLedgerVoucherObject().parmCorrection(correct);
            }

            if (!_isReportingExchDiff)
            {
                if (vendTrans)
                {
                    emplAdvAdjustmentDocUpdate.updateCustVendInvoiceTrans(vendInvoiceTrans,
                                                                            newExchRate,
                                                                            exchRateDiffLineExclTax,
                                                                            taxAmount);
                }

                emplAdvAdjustmentDocUpdate.parmSkipAdvanceTableUpdate(this.parmSkipAdvanceTableUpdate());
                emplAdvAdjustmentDocUpdate.updateEmplAdvLine(_mainEmplTrans,
                                                             emplAdvLine,
                                                             newExchRate,
                                                             _exchRateDiffLine,
                                                             taxAmount);
            }
        }

        if (!emplAdvLine && _sourceTable.RecId && _sourceTable.TableId == tableNum(EmplAdvLine_RU))
        {
            emplAdvLine = _sourceTable;
        }

        custVendExchAdjParm = CustVendExchAdjParm_W::newFromParmEmpl(_mainEmplTrans);
        exchAdjDimension    = custVendExchAdjParm.rTax25ExchAdjDimension();

        posting                 = custVendExchAdjParm.postingType(_accountingExchAdjAmount);
        postingLedger           = EmplExchAdjustmentCalc_RU::getFinalPostingType(posting);
        reportingPosting        = custVendExchAdjParm.postingType(_reportingExchAdjAmount);
        reportingPostingLedger  = EmplExchAdjustmentCalc_RU::getFinalPostingType(reportingPosting);

        if (_mainEmplTrans.RefTableId == tableNum(VendTrans))
        {
            vendTrans       = VendTrans::find(_mainEmplTrans.RefRecId, true);
            vendInvoiceJour = CustVendTransData::construct(vendTrans).custVendInvoiceJour_RU();
        }

        ledgerDimensionAccount  = custVendExchAdjParm.ledgerDimension(posting);
        newExchRate             = emplAdvLine.AmountMst ? (emplAdvLine.AmountMst - _accountingExchAdjAmount) / emplAdvLine.AmountCur * 100 : 100;

        exchAdjTrans.EmplAccount                        = _mainEmplTrans.EmplAccount;
        exchAdjTrans.CurrencyCode                       = _mainEmplTrans.CurrencyCode;
        exchAdjTrans.TransDate                          = _transDate;
        exchAdjTrans.AmountCur                          = 0.0;
        exchAdjTrans.AmountMST                          = _accountingExchAdjAmount;
        exchAdjTrans.ReportingCurrencyAmount            = _reportingExchAdjAmount;
        exchAdjTrans.ExchAdjustmentRealized             = _accountingExchAdjAmount;
        exchAdjTrans.ReportingExchAdjustmentRealized    = _reportingExchAdjAmount;
        exchAdjTrans.ExchAdjustment                     = _accountingExchAdjAmount;
        exchAdjTrans.ReportingExchAdjustment            = _reportingExchAdjAmount;
        exchAdjTrans.PostingProfile                     = emplAdvTable.PostingProfile;
        exchAdjTrans.Txt                                = ledgerVoucher ? ledgerVoucher.findLedgerVoucherObject().lastTransTxt() : "";
        exchAdjTrans.TransType                          = EmplTransSourceType_RU::AdvanceAdj;

        exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(posting));
        exchAdjTrans.LedgerDimension                    = LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_mainEmplTrans.LedgerDimension), exchAdjDimension.getDefaultDimension(_defaultDimension));

        exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(reportingPosting));
        exchAdjTrans.ReportingDefaultDimension          = exchAdjDimension.getDefaultDimension(_defaultDimension);

        exchAdjTrans.AdvanceId                          = emplAdvTable.AdvanceId;
        exchAdjTrans.Closed                             = _transDate;
        exchAdjTrans.Correct                            = _accountingExchAdjAmount > 0;
        exchAdjTrans.ReportingCurrencyCorrect           = _reportingExchAdjAmount > 0;

        emplAdvAdjustmentDocUpdate = EmplAdvAdjustmentDocUpdate_RU::newFromSettlement(_transDate);

        ledgerVoucher.lastVoucher(_ledgerVoucherObject.parmVoucher());
        exchAdjTrans.Voucher = _ledgerVoucherObject.parmVoucher();
        exchAdjTrans.insert();

        _mainEmplTrans.ExchAdjustment         += _accountingExchAdjAmount;
        _mainEmplTrans.ExchAdjustmentRealized += _accountingExchAdjAmount;
        _mainEmplTrans.update();

        if (!custVendExchAdjParm.inheritInvoicePosting() || this.isInventoryClosed(vendTrans, _transDate))
        {
            postSpecial(_accountingExchAdjAmount,   posting,            false);
            postSpecial(_reportingExchAdjAmount,    reportingPosting,   true);
        }
        else
        {
            currentExchAdjDimension = exchAdjDimension;
            currentDimSpec          = NoneTableTrans::Transaction;
            currentUseProfile       = TransactionSelect::Transaction;
            currentSummaryAccount   = LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension);
            currentDefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(exchAdjTrans.LedgerDimension);

            sourceDocumentLine  = SourceDocumentLine::find(emplAdvLine.SourceDocumentLine);
            accountingEvent     = AccountingDistribution::getLastSourceDocumentLineEvent(sourceDocumentLine.RecId);
            distributionExist   = AccountingDistribution::existEventAndSourceDocumentLine(accountingEvent.RecId, sourceDocumentLine.RecId);
            ledgerBondClient    = _ledgerVoucherObject.ledgerBondClient_RU();

            if (distributionExist)
            {
                sourceLineDistributionList  = AccountingDistribution::getDistributionList(accountingEvent.RecId, sourceDocumentLine.RecId);
                elements                    = sourceLineDistributionList.elements();
                le                          = sourceLineDistributionList.getEnumerator();
            }
            else
            {
                elements            = 1;
                allocationFactor    = 1;
            }

            if (vendTrans)
            {
                offsetLedgerDimensionAccount = vendTrans.summaryLedgerDimension();

                select count(RecId) from vendInvoiceTrans
                    where vendInvoiceTrans.PurchID              == vendInvoiceJour.PurchId
                       && vendInvoiceTrans.InvoiceId            == vendInvoiceJour.InvoiceId
                       && vendInvoiceTrans.InvoiceDate          == vendInvoiceJour.InvoiceDate
                       && vendInvoiceTrans.NumberSequenceGroup  == vendInvoiceJour.NumberSequenceGroup
                       && vendInvoiceTrans.InternalInvoiceId    == vendInvoiceJour.InternalInvoiceId;

                elements                = any2int(vendInvoiceTrans.RecId);
                remainAmount            = _accountingExchAdjAmount;
                reportingRemainAmount   = _reportingExchAdjAmount;

                while select forupdate vendInvoiceTrans
                    where vendInvoiceTrans.PurchID              == vendInvoiceJour.PurchId
                       && vendInvoiceTrans.InvoiceId            == vendInvoiceJour.InvoiceId
                       && vendInvoiceTrans.InvoiceDate          == vendInvoiceJour.InvoiceDate
                       && vendInvoiceTrans.NumberSequenceGroup  == vendInvoiceJour.NumberSequenceGroup
                       && vendInvoiceTrans.InternalInvoiceId    == vendInvoiceJour.InternalInvoiceId
                {
                    offsetLedgerDimensionAccount = vendInvoiceTrans.LedgerDimension ? vendInvoiceTrans.LedgerDimension : offsetLedgerDimensionAccount;
                    elements--;

                    distributionAmount = elements > 0 ?
                        CurrencyExchangeHelper::amount(_accountingExchAdjAmount * (vendInvoiceTrans.LineAmount + vendInvoiceTrans.TaxAmount) / (vendInvoiceJour.InvoiceAmount + vendInvoiceJour.EndDisc + vendInvoiceJour.InvoiceRoundOff)) :
                        remainAmount;

                    // for each distribution
                    e = this.getDistributionsForVendInvoiceTrans(
                        vendTrans,
                        vendInvoiceTrans,
                        vendInvoiceTrans.LedgerDimension,
                        vendInvoiceTrans.DefaultDimension,
                        distributionAmount, 0
                        );
                    while (e.moveNext())
                    {
                        distribution = e.current();
                        postTaxes(distribution.ledgerDimension(),
                                  - distribution.accountingAmount(),
                                  LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.offsetLedgerDimension()),
                                  vendInvoiceTrans.TaxGroup,
                                  vendInvoiceTrans.TaxItemGroup,
                                  false);

                        distributionAmount  += taxAmount;
                        remainAmount        -= distributionAmount;
                    }

                    reportingDistributionAmount = elements > 0 ?
                        CurrencyExchangeHelper::amount(_reportingExchAdjAmount * (vendInvoiceTrans.LineAmount + vendInvoiceTrans.TaxAmount) / (vendInvoiceJour.InvoiceAmount + vendInvoiceJour.EndDisc + vendInvoiceJour.InvoiceRoundOff)) :
                        reportingRemainAmount;

                    e = this.getDistributionsForVendInvoiceTrans(
                        vendTrans,
                        vendInvoiceTrans,
                        vendInvoiceTrans.LedgerDimension,
                        vendInvoiceTrans.DefaultDimension,
                        0, reportingDistributionAmount);
                    while (e.moveNext())
                    {
                        distribution = e.current();
                        postTaxes(distribution.ledgerDimension(),
                                    - distribution.reportingAmount(),
                                    LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.offsetLedgerDimension()),
                                    vendInvoiceTrans.TaxGroup,
                                    vendInvoiceTrans.TaxItemGroup,
                                    true);

                        reportingDistributionAmount  += taxAmount;
                        reportingRemainAmount        -= reportingDistributionAmount;
                    }

                    if (custVendExchAdjParm.inheritInvoicePosting() && vendTrans.TransType == LedgerTransType::Purch)
                    {
                        if (! InventClosing::checkOpen(vendTrans.TransDate))
                        {
                            throw error("@SYS18447");
                        }

                        if (distributionAmount)
                        {
                            custVendSettle = CustVendSettle::construct(SysModule::Vend);
                            custVendSettle.parmTransactionDate_W(_transDate);
                            custVendSettle.inventSumAdjustOnAmountDiff_RU(vendInvoiceTrans,
                                                                          distributionAmount,
                                                                          reportingDistributionAmount,
                                                                          ledgerVoucher.lastVoucher(),
                                                                          vendInvoiceJour.CostLedgerVoucher,
                                                                          postingLedger,
                                                                          vendTrans.summaryLedgerDimension());
                        }
                    }
                }

                emplAdvAdjustmentDocUpdate.updateCustVendInvoiceJour(vendInvoiceJour, newExchRate);
            }
            else
            {
                offsetLedgerDimensionAccount = emplAdvLine.LedgerDimension;

                // post taxes
                exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(posting));

                e = this.getDistributions(
                    _mainEmplTrans,
                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                    ledgerDimensionAccount,
                    _accountingExchAdjAmount,
                    0,
                    custVendExchAdjParm.inheritInvoicePosting(),
                    custVendExchAdjParm.inheritInvoicePosting() ? offsetLedgerDimensionAccount : custVendExchAdjParm.ledgerDimension(posting));
                while (e.moveNext())
                {
                    distribution = e.current();

                    if (distribution.accountingAmount())
                    {
                        postTaxes(distribution.ledgerDimension(),
                                  - distribution.accountingAmount(),
                                  LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.offsetLedgerDimension()),
                                  emplAdvLine.TaxGroup,
                                  emplAdvLine.TaxItemGroup,
                                  false);

                        accountingTaxAmountTotal += taxAmount;
                    }
                }

                exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(reportingPosting));
                e = this.getDistributions(
                    _mainEmplTrans,
                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                    ledgerDimensionAccount,
                    0,
                    _reportingExchAdjAmount,
                    custVendExchAdjParm.inheritInvoicePosting(),
                    custVendExchAdjParm.inheritInvoicePosting() ? offsetLedgerDimensionAccount : custVendExchAdjParm.ledgerDimension(posting));

                while (e.moveNext())
                {
                    distribution = e.current();
                    if (distribution.reportingAmount())
                    {
                        postTaxes(distribution.ledgerDimension(),
                                  - distribution.reportingAmount(),
                                  LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(distribution.offsetLedgerDimension()),
                                  emplAdvLine.TaxGroup,
                                  emplAdvLine.TaxItemGroup,
                                  true);

                        reportingTaxAmountTotal += taxAmount;
                    }
                }
            }

            remainAmount          = _accountingExchAdjAmount + accountingTaxAmountTotal;
            reportingRemainAmount = _reportingExchAdjAmount  + reportingTaxAmountTotal;

            exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(posting));
            e = this.getDistributions(
                    _mainEmplTrans,
                    LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                    ledgerDimensionAccount,
                    _accountingExchAdjAmount + accountingTaxAmountTotal,
                    0,
                    custVendExchAdjParm.inheritInvoicePosting(),
                    custVendExchAdjParm.inheritInvoicePosting() ? offsetLedgerDimensionAccount : custVendExchAdjParm.ledgerDimension(posting));

            while (e.moveNext())
            {
                distribution = e.current();

                if (distribution.accountingAmount())
                {
                    ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicMST_RU(_ledgerVoucherObject,
                                                                                    LedgerPostingType::EmplBalance_RU,
                                                                                    distribution.ledgerDimension(),
                                                                                    _mainEmplTrans.CurrencyCode,
                                                                                    distribution.accountingAmount(),
                                                                                    _accountingExchAdjAmount > 0));

                    ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicMST_RU(_ledgerVoucherObject,
                                                                                    postingLedger,
                                                                                    distribution.offsetLedgerDimension(),
                                                                                    _mainEmplTrans.CurrencyCode,
                                                                                    - distribution.accountingAmount(),
                                                                                    _accountingExchAdjAmount > 0));

                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                }
            }

            exchAdjDimension.parmExchAdjType(RTax25ExchAdjDimension::postingType2AdjType(reportingPosting));
            e = this.getDistributions(
                _mainEmplTrans,
                LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                ledgerDimensionAccount,
                0,
                _reportingExchAdjAmount + reportingTaxAmountTotal,
                custVendExchAdjParm.inheritInvoicePosting(),
                custVendExchAdjParm.inheritInvoicePosting() ? offsetLedgerDimensionAccount : custVendExchAdjParm.ledgerDimension(posting));

            while (e.moveNext())
            {
                distribution = e.current();

                if (distribution.reportingAmount())
                {
                    ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(  _ledgerVoucherObject,
                                                                                            LedgerPostingType::EmplBalance_RU,
                                                                                            distribution.ledgerDimension(),
                                                                                            /*LedgerDimensionFacade::serviceCreateLedgerDimension(
                                                                                                DimensionStorage::getLedgerDefaultAccountFromLedgerDim(exchAdjTrans.LedgerDimension),
                                                                                                exchAdjDimension.getDefaultDimension(distributionDimensionDefault ? distributionDimensionDefault : _defaultDimension)),*/
                                                                                            _mainEmplTrans.CurrencyCode,
                                                                                            //reportingDistributionAmount,
                                                                                            distribution.reportingAmount(),
                                                                                            _reportingExchAdjAmount > 0));

                    ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicSecondary_RU(  _ledgerVoucherObject,
                                                                                            reportingPostingLedger,
                                                                                            distribution.offsetLedgerDimension(),
                                                                                            _mainEmplTrans.CurrencyCode,
                                                                                            - distribution.reportingAmount(),
                                                                                            _reportingExchAdjAmount > 0));

                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                }

                remainAmount          -= distributionAmount;
                reportingRemainAmount -= reportingDistributionAmount;
            }
        }

        return exchAdjTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchAdj</Name>
				<Source><![CDATA[
    protected EmplTrans_RU postExchAdj(EmplTrans_RU                  _emplTrans,
                                       boolean                       _unrealized,
                                       AmountMST                     _accountingExchAdjAmount,
                                       AmountMSTSecondary            _reportingExchAdjAmount,
                                       TransDate                     _lastExchAdjDate,
                                       ExchRate                      _lastExchAdjRate,
                                       ExchRate                      _reportingLastExchAdjRate,
                                       boolean                       _reverseTrans,
                                       boolean                       _createExchAdjTrans,
                                       DimensionDefault              _defaultDimension,
                                       PostingProfile                _postingProfile,
                                       LedgerDimensionDefaultAccount _sumDefaultAccount,
                                       boolean                       _createNewVoucherObject = false,
                                       Voucher                       _voucher                = '',
                                       boolean                       _update                 = true,
                                       boolean                       _postToLedger           = true,
                                       boolean                       _updateEmplTrans        = true)

    {
        EmplTrans_RU                exchAdjTrans;

        RTax25ExchAdjDimension      exchAdjDimension;
        LedgerPostingType           postingLedger,
                                    reportingPostingLedger;

        DimensionDefault            defaultDimension,
                                    reportingDefaultDimension;

        LedgerDimensionAccount      ledgerDimension,
                                    offsetLedgerDimension,
                                    reportingLedgerDimension,
                                    reportingOffsetLedgerDimension;

        CustVendExchAdjParm_W       emplExchAdjParm;

        if (_accountingExchAdjAmount || _reportingExchAdjAmount)
        {
            if (_createNewVoucherObject)
            {
                ledgerVoucherObject = this.createLedgerVoucherObject(_voucher);
            }
            else
            {
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
            }

            emplExchAdjParm     = CustVendExchAdjParm_W::newFromParmEmpl(_emplTrans, false, _unrealized, LedgerTransType::ExchAdjustment);
            exchAdjDimension    = emplExchAdjParm.rTax25ExchAdjDimension();

            exchAdjDimension.setLedgerDimensions(emplExchAdjParm.ledgerDimension(LedgerPostingType::ExchRateGain),
                                                 emplExchAdjParm.ledgerDimension(LedgerPostingType::ExchRateLoss));

            if (_updateEmplTrans)
            {
                if (_unrealized)
                {
                    _emplTrans.ExchAdjustmentUnrealized          += _accountingExchAdjAmount;
                    _emplTrans.ReportingExchAdjustmentUnrealized += _reportingExchAdjAmount;

                    if (_lastExchAdjDate && _lastExchAdjRate)
                    {
                        _emplTrans.LastExchAdj     = _lastExchAdjDate;
                        _emplTrans.LastExchAdjRate = _lastExchAdjRate;
                    }
                    if (_lastExchAdjDate && _reportingLastExchAdjRate)
                    {
                        _emplTrans.ReportingLastExchAdjRate = _reportingLastExchAdjRate;
                    }
                }
                else
                {
                    _emplTrans.ExchAdjustmentRealized          += _accountingExchAdjAmount;
                    _emplTrans.ReportingExchAdjustmentRealized += _reportingExchAdjAmount;
                }

                _emplTrans.ExchAdjustment          += _accountingExchAdjAmount;
                _emplTrans.ReportingExchAdjustment += _reportingExchAdjAmount;
            }

            exchAdjDimension.parmExchAdjType( (_reverseTrans ? -1 : 1) * _reportingExchAdjAmount < 0 ? RTax25ExchAdjType::Loss : RTax25ExchAdjType::Gain);
            reportingPostingLedger          = exchAdjDimension.getPostingType();
            reportingDefaultDimension       = exchAdjDimension.getDefaultDimension(_defaultDimension);
            reportingLedgerDimension        = LedgerDimensionFacade::serviceCreateLedgerDimension(_sumDefaultAccount, reportingDefaultDimension);
            reportingOffsetLedgerDimension  = LedgerDimensionFacade::serviceCreateLedgerDimension(exchAdjDimension.getLedgerDimension(), reportingDefaultDimension);

            exchAdjDimension.parmExchAdjType( (_reverseTrans ? -1 : 1) * _accountingExchAdjAmount < 0 ? RTax25ExchAdjType::Loss : RTax25ExchAdjType::Gain);
            postingLedger         = exchAdjDimension.getPostingType();
            defaultDimension      = exchAdjDimension.getDefaultDimension(_defaultDimension);
            ledgerDimension       = LedgerDimensionFacade::serviceCreateLedgerDimension(_sumDefaultAccount, defaultDimension);
            offsetLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(exchAdjDimension.getLedgerDimension(), defaultDimension);

            if (_createExchAdjTrans)
            {
                exchAdjTrans.RefTableId                 = _emplTrans.TableId;
                exchAdjTrans.RefRecId                   = _emplTrans.RecId;
                exchAdjTrans.TransDate                  = transactionDate;
                exchAdjTrans.EmplAccount                = _emplTrans.EmplAccount;
                exchAdjTrans.CurrencyCode               = _emplTrans.CurrencyCode;
                exchAdjTrans.AmountMST                  = _accountingExchAdjAmount;
                exchAdjTrans.ReportingCurrencyAmount    = _reportingExchAdjAmount;
                exchAdjTrans.SettleAmountMST            = _accountingExchAdjAmount;
                exchAdjTrans.ReportingSettleAmount      = _reportingExchAdjAmount;
                exchAdjTrans.Closed                     = transactionDate;
                exchAdjTrans.ExchAdjustment             = - _accountingExchAdjAmount;
                exchAdjTrans.ReportingExchAdjustment    = - _reportingExchAdjAmount;
                exchAdjTrans.Voucher                    = (_voucher) ? _voucher : ledgerVoucher.lastVoucher();
                exchAdjTrans.PostingProfile             = _postingProfile;
                exchAdjTrans.Txt                        = ledgerVoucher.findLedgerVoucherObject().lastTransTxt();
                exchAdjTrans.TransType                  = EmplTransSourceType_RU::ExchAdj;
                exchAdjTrans.LedgerDimension            = ledgerDimension;
                exchAdjTrans.ReportingDefaultDimension  = reportingDefaultDimension;

                if (_unrealized)
                {
                    exchAdjTrans.LastExchAdj                        = _lastExchAdjDate;
                    exchAdjTrans.LastExchAdjRate                    = _lastExchAdjRate;
                    exchAdjTrans.ReportingLastExchAdjRate           = _reportingLastExchAdjRate;
                    exchAdjTrans.ExchAdjustmentUnrealized           = - _accountingExchAdjAmount;
                    exchAdjTrans.ReportingExchAdjustmentUnrealized  = - _reportingExchAdjAmount;
                    exchAdjTrans.IsFromSettlement = isFromSettlement;
                }
                else
                {
                    exchAdjTrans.ExchAdjustmentRealized          = - _accountingExchAdjAmount;
                    exchAdjTrans.ReportingExchAdjustmentRealized = - _reportingExchAdjAmount;
                }

                exchAdjTrans.Correct                  = _reverseTrans;
                exchAdjTrans.ReportingCurrencyCorrect = _reverseTrans;
            }

            if (_update)
            {
                if (_createExchAdjTrans)
                {
                    exchAdjTrans.insert();
                }
                if (_updateEmplTrans)
                {
                    _emplTrans.update();
                }

                if (_postToLedger)
                {
                    this.postExchAdjToLedger(
                        _emplTrans,
                        _accountingExchAdjAmount,
                        _reportingExchAdjAmount,
                        postingLedger,
                        reportingPostingLedger,
                        ledgerDimension,
                        offsetLedgerDimension,
                        reportingLedgerDimension,
                        reportingOffsetLedgerDimension,
                        _reverseTrans);
                }
            }
        }

        return exchAdjTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchAdj_Distributed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts exchange adjustments for given <c>EmplTrans_RU</c> record with distributions.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmplTrans_RU</c> record.
    /// </param>
    /// <param name="_unrealized">
    /// A boolean value which shows that exchange adjustment is unrealized.
    /// </param>
    /// <param name="_accountingExchAdjAmount">
    /// Amount of exchange adjustment in accounting currency.
    /// </param>
    /// <param name="_reportingExchAdjAmount">
    /// Amount of exchange adjustment in reporting currency.
    /// </param>
    /// <param name="_lastExchAdjDate">
    /// Date of last exchange adjustment.
    /// </param>
    /// <param name="_lastExchAdjRate">
    /// Last exchange adjustment rate.
    /// </param>
    /// <param name="_reportingLastExchAdjRate">
    /// Last exchange adjustment rate for reporting currency.
    /// </param>
    /// <param name="_reverseTrans">
    /// A boolean parameter that shows that transaction is reversed.
    /// </param>
    /// <param name="_createExchAdjTrans">
    /// A boolean parameter that shows that <c>EmplTrans_RU</c> should be created.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of the <c>DimensionAttributeValueSet</c> record that provides the default values for
    /// the ledger dimension.
    /// </param>
    /// <param name="_postingProfile">
    /// Posting profile to use.
    /// </param>
    /// <param name="_sumDefaultAccount">
    /// The ID of the <c>DimensionAttributeValueSet</c> record that provides the default values for
    /// the ledger dimension.
    /// </param>
    /// <param name="_useProfile">
    /// Shows the source for ledger dimension.
    /// </param>
    /// <param name="_createNewVoucherObject">
    /// True if create new voucher object, false if use existing one.
    /// </param>
    /// <param name="_voucher">
    /// Voucher value.
    /// </param>
    /// <param name="_update">
    /// Shows if EmplTrans and exch adjustment trans should be created/updated.
    /// </param>
    /// <param name="_dimSpec">
    /// The source of dimension specification.
    /// </param>
    /// <param name="_exchAdjUnrealizedTransTmp">
    /// Temporary record of unrealized exch adjustment transaction.
    /// </param>
    /// <returns>
    /// <c>EmplTrans_RU</c> exch adjustment record.
    /// </returns>
    protected EmplTrans_RU postExchAdj_Distributed(EmplTrans_RU                  _emplTrans,
                                       boolean                       _unrealized,
                                       AmountMST                     _accountingExchAdjAmount,
                                       AmountMSTSecondary            _reportingExchAdjAmount,
                                       TransDate                     _lastExchAdjDate,
                                       ExchRate                      _lastExchAdjRate,
                                       ExchRate                      _reportingLastExchAdjRate,
                                       boolean                       _reverseTrans,
                                       boolean                       _createExchAdjTrans,
                                       DimensionDefault              _defaultDimension,
                                       PostingProfile                _postingProfile,
                                       LedgerDimensionDefaultAccount _sumDefaultAccount,
                                       TransactionSelect             _useProfile,
                                       boolean                       _createNewVoucherObject    = false,
                                       Voucher                       _voucher                   = '',
                                       boolean                       _update                    = true,
                                       NoneTableTrans                _dimSpec                   = NoneTableTrans::None,
                                       EmplTrans_RU                  _exchAdjUnrealizedTransTmp = null
                                       )
    {
        EmplTrans_RU        ret;
        EmplAdvLine_RU      emplAdvLine         = EmplAdvLine_RU::findTransEmplRecId(_emplTrans.RecId);

        void insertIntoTmp(EmplTrans_RU _trans)
        {
            if (! _update && _trans.AmountMST && _exchAdjUnrealizedTransTmp.isTmp())
            {
                _exchAdjUnrealizedTransTmp.data(_trans);
                _exchAdjUnrealizedTransTmp.insert();
            }
        }
        void postDistributedLedgerTrans(boolean _accounting)
        {
            Enumerator                              e;
            CustVendTransCorrespondentDistribution  distribution;
            RTax25ExchAdjDimension                  exchAdjDimension;
            CustVendExchAdjParm_W                   emplExchAdjParm;
            Amount                                  adjustmentAmount = _accounting ? _accountingExchAdjAmount : _reportingExchAdjAmount;
            emplExchAdjParm     = CustVendExchAdjParm_W::newFromParmEmpl(_emplTrans, false, _unrealized, LedgerTransType::ExchAdjustment);
            exchAdjDimension    = emplExchAdjParm.rTax25ExchAdjDimension();

            exchAdjDimension.setLedgerDimensions(emplExchAdjParm.ledgerDimension(LedgerPostingType::ExchRateGain),
                                                 emplExchAdjParm.ledgerDimension(LedgerPostingType::ExchRateLoss));
            // save parameters for event handler
            currentExchAdjDimension = exchAdjDimension;
            currentDimSpec          = _dimSpec;
            currentUseProfile       = _useProfile;
            currentSummaryAccount   = (_useProfile == TransactionSelect::Transaction) ? _emplTrans.LedgerDimension : _sumDefaultAccount;
            currentDefaultDimension = _defaultDimension;

            if (adjustmentAmount)
            {
                exchAdjDimension.parmExchAdjType( (_reverseTrans ? -1 : 1) * adjustmentAmount < 0 ? RTax25ExchAdjType::Loss : RTax25ExchAdjType::Gain);
                e = this.getDistributions(
                    _emplTrans,
                    LedgerDimensionFacade::serviceCreateLedgerDimension(_sumDefaultAccount, _defaultDimension),
                    _defaultDimension,
                    _accounting ? adjustmentAmount : 0,
                    _accounting ? 0 : adjustmentAmount
                );
                while (e.moveNext())
                {
                    distribution = e.current();
                    this.postExchAdjToLedger(
                        _emplTrans,
                        distribution.accountingAmount(),
                        distribution.reportingAmount(),
                        exchAdjDimension.getPostingType(),
                        exchAdjDimension.getPostingType(),
                        distribution.ledgerDimension(),
                        distribution.offsetLedgerDimension(),
                        distribution.ledgerDimension(),
                        distribution.offsetLedgerDimension(),
                        _reverseTrans);
                }
            }
        }
        void postWithDistributions()
        {
            // post not ditributed empl trans
            ret = this.postExchAdj(
                    _emplTrans,
                    _unrealized,
                    _accountingExchAdjAmount,
                    _reportingExchAdjAmount,
                    _lastExchAdjDate,
                    _lastExchAdjRate,
                    _reportingLastExchAdjRate,
                    _reverseTrans,
                    _createExchAdjTrans,
                    _defaultDimension,
                    _postingProfile,
                    (_useProfile == TransactionSelect::Transaction) ? _emplTrans.LedgerDimension : _sumDefaultAccount,
                    _createNewVoucherObject,
                    _voucher,
                    _update,
                    false,
                    true);
            insertIntoTmp(ret);

            if (_update)
            {
                postDistributedLedgerTrans(true);
                postDistributedLedgerTrans(false);
            }
        }

        if (_dimSpec == NoneTableTrans::Transaction || _useProfile == TransactionSelect::Transaction)
        {
            postWithDistributions();
        }
        else
        {
            ret = this.postExchAdj(
                _emplTrans,
                _unrealized,
                _accountingExchAdjAmount,
                _reportingExchAdjAmount,
                _lastExchAdjDate,
                _lastExchAdjRate,
                _reportingLastExchAdjRate,
                _reverseTrans,
                _createExchAdjTrans,
                _defaultDimension,
                _postingProfile,
                (_useProfile == TransactionSelect::Transaction) ? _emplTrans.LedgerDimension : _sumDefaultAccount,
                _createNewVoucherObject,
                _voucher,
                _update);
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchAdjLedgerTrans_SpecialPosting</Name>
				<Source><![CDATA[
    protected void postExchAdjLedgerTrans_SpecialPosting(LedgerPostingType              _posting,
                                                         Amount                         _exchRateDiff,
                                                         LedgerDimensionAccount         _profitLossLedgerDimension,
                                                         LedgerDimensionAccount         _sumLedgerDimension,
                                                         EmplTrans_RU                  _mainEmplTrans,
                                                         TransDate                     _transDate,
                                                         EmplTrans_RU                  _exchRateTrans,
                                                         NoneTableTrans                _dimSpec,
                                                         TransDate                     _transactionDate,
                                                         EmplAdvLine_RU                _emplAdvLine,
                                                         ExchRate                      _newExchRate,
                                                         boolean                       _isReportingExchDiff)
    {
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerBondClient_RU             ledgerBondClient        = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        Currency                        currency                = Currency::find(_mainEmplTrans.CurrencyCode);
        CurrencyCode                    secondaryCurrencyCode   = Ledger::reportingCurrency();
        Amount                          exchRateDiffExclTax;
        TaxAmount                       taxAmount;
        LedgerPostingType               postingLedger;
        int                             counter = 1;

        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
        }

        taxAmount = - this.calcAndPostTaxExchRateDiff_RU(_exchRateDiff,
                                                         _mainEmplTrans,
                                                         EmplExchAdjustmentCalc_RU::getFinalPostingType(_posting),
                                                         _exchRateTrans,
                                                         _emplAdvLine,
                                                         _isReportingExchDiff,
                                                         _profitLossLedgerDimension,
                                                         _sumLedgerDimension);

        exchRateDiffExclTax = _exchRateDiff - taxAmount;

        if (exchRateDiffExclTax)
        {
            postingLedger = _posting;

            if (_exchRateTrans.ExchAdjustmentRealized)
            {
                postingLedger          = EmplExchAdjustmentCalc_RU::getFinalPostingType(_posting);
            }

            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(ledgerVoucher.lastVoucher(), _transDate);

            ledgerVoucherTransObject  = LedgerVoucherTransObject::newAdjustmentDefault( ledgerVoucherObject,
                                                                                        postingLedger,
                                                                                        _profitLossLedgerDimension,
                                                                                        _mainEmplTrans.CurrencyCode,
                                                                                        _isReportingExchDiff ? 0 : - exchRateDiffExclTax,
                                                                                        _isReportingExchDiff ? - exchRateDiffExclTax : 0);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            ledgerVoucherTransObject  = LedgerVoucherTransObject::newAdjustmentDefault( ledgerVoucherObject,
                                                                                        LedgerPostingType::EmplBalance_RU,
                                                                                        _sumLedgerDimension,
                                                                                        _mainEmplTrans.CurrencyCode,
                                                                                        _isReportingExchDiff ? 0 : exchRateDiffExclTax,
                                                                                        _isReportingExchDiff ? exchRateDiffExclTax : 0);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondVRef2VRef(ledgerBondClient.lastVrefId(),
                                               ledgerBondClient.lastVrefId(-1));
            }
        }

        if (taxAmount)
        {
            ledgerVoucher.addTrans(LedgerVoucherTransObject::newBasicDefault(ledgerVoucherObject,
                                                                            LedgerPostingType::EmplBalance_RU,
                                                                            _sumLedgerDimension,
                                                                            _mainEmplTrans.CurrencyCode,
                                                                            0,
                                                                            _isReportingExchDiff ? 0 : taxAmount,
                                                                            _isReportingExchDiff ? taxAmount : 0));

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLastVRef2CurrentLog();
            }
        }

        if (ledgerBondClient)
        {
            ledgerBondClient.removeCurrentLogObject();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchAdjToLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Postd exchange adjustment to Ledger.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmpplTrans</c>
    /// </param>
    /// <param name="_accountingExchAdjAmount">
    /// Amount of exchange adjustment in accounting currency.
    /// </param>
    /// <param name="_reportingExchAdjAmount">
    /// Amount of exchange adjustment in reporting currency.
    /// </param>
    /// <param name="_postingLedger">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_reportingPostingLedger">
    /// The posting type of the general journal entry for reporting currency.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_offsetLedgerDimension">
    /// The dimension attribute value combination of the general journal corresponding entry.
    /// </param>
    /// <param name="_reportingLedgerDimension">
    /// The dimension attribute value combination of the general journal entry for reporting currency.
    /// </param>
    /// <param name="_reportingOffsetLedgerDimension">
    /// The dimension attribute value combination of the general journal corresponding entry for reporting currency.
    /// </param>
    /// <param name="_reverseTrans">
    /// A boolean parameter that determines if the general journal entry have to be correction.
    /// </param>
    protected void postExchAdjToLedger(EmplTrans_RU                  _emplTrans,
                                       AmountMST                     _accountingExchAdjAmount,
                                       AmountMSTSecondary            _reportingExchAdjAmount,
                                       LedgerPostingType             _postingLedger,
                                       LedgerPostingType             _reportingPostingLedger,
                                       LedgerDimensionAccount        _ledgerDimension,
                                       LedgerDimensionAccount        _offsetLedgerDimension,
                                       LedgerDimensionAccount        _reportingLedgerDimension,
                                       LedgerDimensionAccount        _reportingOffsetLedgerDimension,
                                       boolean                       _reverseTrans)
    {
        LedgerBondClient_RU         ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        if (_accountingExchAdjAmount)
        {
            ledgerVoucherTransObject =
                LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucherObject,
                                                            LedgerPostingType::EmplBalance_RU,
                                                            _ledgerDimension,
                                                            _emplTrans.CurrencyCode,
                                                            _accountingExchAdjAmount,
                                                            _reverseTrans);

            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

            ledgerVoucherTransObject =
                LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucherObject,
                                                            _postingLedger,
                                                            _offsetLedgerDimension,
                                                            _emplTrans.CurrencyCode,
                                                            - _accountingExchAdjAmount,
                                                            _reverseTrans);

            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLast2();
            }
        }

        if (_reportingExchAdjAmount)
        {
            ledgerVoucherTransObject =
                LedgerVoucherTransObject::newBasicSecondary_RU(ledgerVoucherObject,
                                                                LedgerPostingType::EmplBalance_RU,
                                                                _reportingLedgerDimension,
                                                                _emplTrans.CurrencyCode,
                                                                _reportingExchAdjAmount,
                                                                _reverseTrans);

            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

            ledgerVoucherTransObject =
                LedgerVoucherTransObject::newBasicSecondary_RU(ledgerVoucherObject,
                                                                _reportingPostingLedger,
                                                                _reportingOffsetLedgerDimension,
                                                                _emplTrans.CurrencyCode,
                                                                - _reportingExchAdjAmount,
                                                                _reverseTrans);

            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLast2();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRealizedExchAdj</Name>
				<Source><![CDATA[
    protected void postRealizedExchAdj(EmplTrans_RU              _mainEmplTrans,
                                       EmplSettlement_RU         _emplSettlement,
                                       EmplSettlement_RU         _exchAdjSettlement,
                                       AmountMSTExchAdjustment   _accountingExchAdjAmount,
                                       AmountMSTSecondary        _reportingExchAdjAmount,
                                       DimensionDefault          _defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_mainEmplTrans.LedgerDimension))
    {
        EmplTrans_RU            exchAdjTrans;
        EmplTrans_RU            tmpDebitTrans, tmpCreditTrans;
        DimensionDefault        defaultDimension = _defaultDimension ? _defaultDimension : LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_mainEmplTrans.LedgerDimension);
        boolean                 insertExchAdjSettlement = (_exchAdjSettlement) ? false : true;

        exchAdjTrans = this.postExchAdj(_mainEmplTrans,
                                        false,
                                        _accountingExchAdjAmount,
                                        _reportingExchAdjAmount,
                                        dateNull(),
                                        0,
                                        0,
                                        false,
                                        true,
                                        defaultDimension,
                                        _mainEmplTrans.PostingProfile,
                                        LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_mainEmplTrans.LedgerDimension),
                                        true,
                                        _emplSettlement.Voucher);

        if (exchAdjTrans)
        {
            if (_accountingExchAdjAmount < 0)
            {
                tmpDebitTrans  = _mainEmplTrans;
                tmpCreditTrans = exchAdjTrans;
            }
            else
            {
                tmpDebitTrans  = exchAdjTrans;
                tmpCreditTrans = _mainEmplTrans;
            }

            _exchAdjSettlement.DebitRecId            = tmpDebitTrans.RecId;
            _exchAdjSettlement.CreditRecId           = tmpCreditTrans.RecId;
            _exchAdjSettlement.SettleAmountMST       = abs(_accountingExchAdjAmount);
            _exchAdjSettlement.ReportingSettleAmount = abs(_reportingExchAdjAmount);

            if (insertExchAdjSettlement)
            {
                _exchAdjSettlement.TransDate = _emplSettlement.TransDate;
                _exchAdjSettlement.insert();
            }
            else
            {
                _exchAdjSettlement.update();
            }

            exchAdjTrans.selectForUpdate(true);
            exchAdjTrans.RefTableId = _emplSettlement.TableId;
            exchAdjTrans.RefRecId   = _emplSettlement.RecId;
            exchAdjTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processRealizedExchAdj</Name>
				<Source><![CDATA[
    public container processRealizedExchAdj(AmountMST          _exchRateDiff,
                                            AmountMSTSecondary _reportingExchRateDiff,
                                            EmplTrans_RU       _transDebit,
                                            EmplTrans_RU       _transCredit,
                                            EmplSettlement_RU  _emplSettlement,
                                            AmountCur          _settleDebitCur,
                                            AmountCur          _settleCreditCur,
                                            TransDate          _postingDate,
                                            Voucher            _voucher                = '',
                                            boolean            _update                 = true,
                                            EmplTrans_RU       _exchAdjUnrealizedTrans = null,
                                            boolean            _useSetlementProportion = _emplSettlement ? true : false)
    {
        AmountMST              periodUnrealizedAmountDebit, periodUnrealizedAmountCredit;
        AmountMST              unrealizedAmountDebit, unrealizedAmountCredit;
        AmountMST              finalExchRateDiff;
        AmountMSTSecondary     reportingPeriodUnrealizedAmountDebit, reportingPeriodUnrealizedAmountCredit;
        AmountMSTSecondary     reportingUnrealizedAmountDebit, reportingUnrealizedAmountCredit;
        AmountMSTSecondary     finalReportingExchRateDiff;

        transactionDate = _postingDate;

        // reverse of previously calculated unrealised exchange difference if it is needed
        [periodUnrealizedAmountDebit, unrealizedAmountDebit, reportingPeriodUnrealizedAmountDebit, reportingUnrealizedAmountDebit] =
            this.reverseUnrealizedExchAdj(  _transDebit,
                                            _emplSettlement,
                                            _settleDebitCur,
                                            _postingDate,
                                            _voucher,
                                            _update,
                                            _exchAdjUnrealizedTrans,
                                            _useSetlementProportion);

        [periodUnrealizedAmountCredit, unrealizedAmountCredit, reportingPeriodUnrealizedAmountCredit, reportingUnrealizedAmountCredit] =
            this.reverseUnrealizedExchAdj(  _transCredit,
                                            _emplSettlement,
                                            _settleCreditCur,
                                            _postingDate,
                                            _voucher,
                                            _update,
                                            _exchAdjUnrealizedTrans,
                                            _useSetlementProportion);

        finalExchRateDiff = _exchRateDiff +
                            unrealizedAmountDebit - periodUnrealizedAmountDebit +
                            unrealizedAmountCredit - periodUnrealizedAmountCredit;

        finalReportingExchRateDiff = _reportingExchRateDiff +
                                     reportingUnrealizedAmountDebit  - reportingPeriodUnrealizedAmountDebit +
                                     reportingUnrealizedAmountCredit - reportingPeriodUnrealizedAmountCredit;

        return [finalExchRateDiff, finalReportingExchRateDiff];
    }

]]></Source>
			</Method>
			<Method>
				<Name>processUnrealizedExchAdj</Name>
				<Source><![CDATA[
    public void processUnrealizedExchAdj(EmplTrans_RU                  _emplTrans,
                                         TransDate                     _postingDate,
                                         EmplExchPrinciples_RU         _exchPrinciples,
                                         DimensionDefault              _defaultDimension,
                                         PostingProfile                _postingProfile,
                                         TransDate                     _exchRateDate,
                                         ExchRate                      _exchRate,
                                         ExchRate                      _reportingExchRate,
                                         LedgerDimensionDefaultAccount _sumDefaultAccount,
                                         TransactionSelect             _useProfile,
                                         Voucher                       _voucher = '',
                                         NoneTableTrans                _dimSpec = NoneTableTrans::None
                                         )
    {
        AmountMST                     accountingNewAmount, accountingRegAmount, accountingReverseAmount;
        AmountMST                     accountingUnrealizedAmount, accountingPeriodUnrealizedAmount;
        AmountMST                     accountingOpenAmount;
        AmountMSTSecondary            reportingNewAmount, reportingRegAmount, reportingReverseAmount;
        AmountMSTSecondary            reportingUnrealizedAmount, reportingPeriodUnrealizedAmount;
        AmountMSTSecondary            reportingOpenAmount;
        AmountCur                     transactionOpenAmount;
        boolean                       createNewVoucherObject = isFromSettlement;
        EmplExchPrinciples_RU         exchPrinciples;
        DimensionDefault              defaultDimension;
        PostingProfile                postingProfile;
        LedgerDimensionDefaultAccount sumDefaultAccount;
        TransDate                     postingDate;
        TransDate                     exchRateDate;
        ExchRate                      exchRate;
        ExchRate                      reportingExchRate;
        NoneTableTrans                lastDimSpec;
        CurrencyExchangeHelper        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _exchRateDate);
        TransactionSelect             useProfile;

        transactionDate = _postingDate;

        [transactionOpenAmount, accountingOpenAmount, reportingOpenAmount] = this.getOpenAmounts(_emplTrans);

        if (! transactionOpenAmount)
        {
            return;
        }

        [accountingPeriodUnrealizedAmount, accountingUnrealizedAmount, reportingPeriodUnrealizedAmount, reportingUnrealizedAmount] =
            EmplExchAdjustmentCalc_RU::calcUnrealizedExchAdj(_emplTrans, null, transactionOpenAmount, transactionDate);

        if (_exchPrinciples != EmplExchPrinciples_RU::TransDatePrinciple)
        {
            accountingNewAmount     = CurrencyExchangeHelper::mstAmount(transactionOpenAmount, _emplTrans.CurrencyCode, _exchRateDate);
            accountingRegAmount     = accountingNewAmount - (accountingOpenAmount + accountingUnrealizedAmount - accountingPeriodUnrealizedAmount);
            accountingReverseAmount = - accountingPeriodUnrealizedAmount;

            reportingNewAmount      = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(_emplTrans.CurrencyCode, transactionOpenAmount);
            reportingRegAmount      = reportingNewAmount - (reportingOpenAmount + reportingUnrealizedAmount - reportingPeriodUnrealizedAmount);
            reportingReverseAmount  = - reportingPeriodUnrealizedAmount;
        }
        else
        {
            accountingReverseAmount = - accountingUnrealizedAmount;
            reportingReverseAmount  = - reportingUnrealizedAmount;
        }

        if (! isFromSettlement)
        {
            this.initLedgerVoucher(_emplTrans);
        }

        if (accountingRegAmount + accountingReverseAmount || reportingRegAmount + reportingReverseAmount)
        {
            if (accountingReverseAmount || reportingReverseAmount)
            {
                [exchPrinciples,
                defaultDimension,
                postingProfile,
                sumDefaultAccount,
                postingDate,
                exchRateDate,
                exchRate,
                reportingExchRate,
                useProfile,
                lastDimSpec] = this.getLastExchAdjParameters(_emplTrans, _emplTrans.LastExchAdj, true);

                this.postExchAdj_Distributed(
                                 _emplTrans,
                                 true,
                                 accountingReverseAmount,
                                 reportingReverseAmount,
                                 postingDate,
                                 exchRate,
                                 reportingExchRate,
                                 true,
                                 true,
                                 defaultDimension,
                                 postingProfile,
                                 sumDefaultAccount,
                                 useProfile,
                                 createNewVoucherObject,
                                 _voucher,
                                 true,
                                 lastDimSpec);
            }

            if (_exchPrinciples != EmplExchPrinciples_RU::TransDatePrinciple)
            {
                this.postExchAdj_Distributed(
                                 _emplTrans,
                                 true,
                                 accountingRegAmount,
                                 reportingRegAmount,
                                 _postingDate,
                                 _exchRate,
                                 _reportingExchRate,
                                 false,
                                 true,
                                 _defaultDimension,
                                 _postingProfile,
                                 _sumDefaultAccount,
                                 _useProfile,
                                 createNewVoucherObject,
                                 _voucher,
                                 true,
                                 _dimSpec);
            }
        }

        if (! isFromSettlement)
        {
            ledgerVoucher.end();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcFutureRealizedExchAdj</Name>
				<Source><![CDATA[
    public void recalcFutureRealizedExchAdj(EmplTrans_RU _emplTrans,
                                            TransDate    _postingDate = transactionDate)
    {
        EmplSettlement_RU   emplSettlement, exchAdjSettlement;
        EmplTrans_RU        transDebit, transCredit;
        AmountMST           accountingExchAdjAmount;
        AmountMSTSecondary  reportingExchAdjAmount;

        transactionDate = _postingDate;

        this.initLedgerVoucher(_emplTrans);

        while select forupdate emplSettlement order by TransDate asc
            where (emplSettlement.DebitRecId  == _emplTrans.RecId  ||
                   emplSettlement.CreditRecId == _emplTrans.RecId) &&
                  emplSettlement.TransDate    >  transactionDate   &&
                  emplSettlement.SettleAmountCurDebit              &&
                  emplSettlement.SettleAmountCurCredit
        {
            if (_emplTrans.AmountCur > 0)
            {
                transDebit = _emplTrans;

                select pessimisticLock firstonly transCredit
                    where transCredit.RecId == emplSettlement.CreditRecId;
            }
            else
            {
                transCredit = _emplTrans;

                select pessimisticLock firstonly transDebit
                    where transDebit.RecId == emplSettlement.DebitRecId;
            }

            transactionDate = emplSettlement.TransDate;

            exchAdjSettlement = this.reverseRealizedExchAdj(emplSettlement, transDebit, transCredit);

            if (emplSettlement.SettleAmountMSTDebit && emplSettlement.SettleAmountMSTCredit)
            {
                accountingExchAdjAmount = emplSettlement.SettleAmountMSTDebit + emplSettlement.SettleAmountMSTCredit;
            }
            else
            {
                accountingExchAdjAmount = - emplSettlement.ExchAdjustment;
            }

            if (emplSettlement.ReportingSettleAmountDebit && emplSettlement.ReportingSettleAmountCredit)
            {
                reportingExchAdjAmount = emplSettlement.ReportingSettleAmountDebit + emplSettlement.ReportingSettleAmountCredit;
            }
            else
            {
                reportingExchAdjAmount = - emplSettlement.ReportingExchAdjustment;
            }

            [accountingExchAdjAmount, reportingExchAdjAmount] = this.processRealizedExchAdj(accountingExchAdjAmount,
                                                           reportingExchAdjAmount,
                                                           transDebit,
                                                           transCredit,
                                                           emplSettlement,
                                                           emplSettlement.SettleAmountCurDebit,
                                                           emplSettlement.SettleAmountCurCredit,
                                                           transactionDate,
                                                           emplSettlement.Voucher,
                                                           true);

            emplSettlement.ExchAdjustment          = - accountingExchAdjAmount;
            emplSettlement.ReportingExchAdjustment = - reportingExchAdjAmount;
            emplSettlement.update();

            this.postRealizedExchAdj(accountingExchAdjAmount > 0 ? transDebit : transCredit,
                                     emplSettlement,
                                     exchAdjSettlement,
                                     - accountingExchAdjAmount,
                                     - reportingExchAdjAmount);
        }

        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>recalcFutureUnrealizedExchAdj</Name>
				<Source><![CDATA[
    public void recalcFutureUnrealizedExchAdj(EmplTrans_RU  _emplTrans,
                                              boolean       _reverseOnly = false,
                                              TransDate     _postingDate = transactionDate)
    {
        EmplTrans_RU                    exchAdjTrans, exchAdjTransCorrect;
        Map                             datesMap           = new Map(Types::Container, Types::Container);
        MapEnumerator                   datesMapEnumerator;
        TransDate                       transDate;
        Voucher                         voucher;
        EmplExchPrinciples_RU           exchPrinciples;
        DimensionDefault                defaultDimension;
        PostingProfile                  postingProfile;
        LedgerDimensionDefaultAccount   sumLedgerDimension;
        TransDate                       postingDate;
        TransDate                       exchRateDate;
        ExchRate                        exchRate;
        ExchRate                        reportingExchRate;
        TransactionSelect               useProfile;

        while select forupdate exchAdjTrans
            order by TransDate desc, Correct asc
            where exchAdjTrans.EmplAccount == _emplTrans.EmplAccount           &&
                  exchAdjTrans.TransDate   >  _postingDate                     &&
                  exchAdjTrans.RefTableId  == _emplTrans.TableId               &&
                  exchAdjTrans.RefRecId    == _emplTrans.RecId                 &&
                  exchAdjTrans.TransType   ==  EmplTransSourceType_RU::ExchAdj &&
                  ( exchAdjTrans.ExchAdjustmentUnrealized                      ||
                    exchAdjTrans.ReportingExchAdjustmentUnrealized )           &&
                  exchAdjTrans.LastExchAdj                                     &&
                  ( exchAdjTrans.LastExchAdjRate                               ||
                    exchAdjTrans.ReportingLastExchAdjRate )
        {
            [exchPrinciples,
             defaultDimension,
             postingProfile,
             sumLedgerDimension,
             postingDate,
             exchRateDate,
             exchRate,
             reportingExchRate,
             useProfile] = this.getLastExchAdjParameters(_emplTrans, exchAdjTrans.TransDate);

            if (!_reverseOnly && (! exchAdjTrans.Correct || (exchAdjTrans.LastExchAdj == _emplTrans.TransDate)))
            {
                datesMap.insert([exchAdjTrans.TransDate, exchAdjTrans.Voucher],
                                [exchPrinciples, defaultDimension, postingProfile, sumLedgerDimension, exchRateDate, exchRate, reportingExchRate, useProfile]);
            }

            transactionDate = exchAdjTrans.TransDate;

            exchAdjTransCorrect = this.postExchAdj_Distributed(
                                                   _emplTrans,
                                                   true,
                                                   exchAdjTrans.ExchAdjustmentUnrealized,
                                                   exchAdjTrans.ReportingExchAdjustmentUnrealized,
                                                   dateNull(),
                                                   exchRate,
                                                   reportingExchRate,
                                                   !exchAdjTrans.Correct,
                                                   true,
                                                   defaultDimension,
                                                   postingProfile,
                                                   LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(sumLedgerDimension),
                                                   useProfile,
                                                   true,
                                                   (_reverseOnly) ? ledgerVoucher.lastVoucher() : exchAdjTrans.Voucher);

            exchAdjTransCorrect.Reversed    = (_reverseOnly) ? NoYes::Yes : NoYes::No;
            exchAdjTransCorrect.LastExchAdj = dateNull();
            exchAdjTransCorrect.update();

            exchAdjTrans.Reversed           = (_reverseOnly) ? NoYes::Yes : NoYes::No;
            exchAdjTrans.LastExchAdj        = dateNull();
            exchAdjTrans.update();
        }

        transactionDate = _postingDate;

        if (! _reverseOnly)
        {
            [exchPrinciples,
             defaultDimension,
             postingProfile,
             sumLedgerDimension,
             postingDate,
             exchRateDate,
             exchRate,
             reportingExchRate,
             useProfile] = this.getLastExchAdjParameters(_emplTrans, transactionDate);

            if (postingDate)
            {
                _emplTrans.LastExchAdj              = postingDate;
                _emplTrans.LastExchAdjRate          = exchRate;
                _emplTrans.ReportingLastExchAdjRate = reportingExchRate;
                _emplTrans.update();
            }

            datesMapEnumerator = datesMap.getEnumerator();

            while (datesMapEnumerator.moveNext())
            {
                [transDate, voucher] = datesMapEnumerator.currentKey();

                [exchPrinciples,
                 defaultDimension,
                 postingProfile,
                 sumLedgerDimension,
                 exchRateDate,
                 exchRate,
                 reportingExchRate,
                 useProfile] = datesMapEnumerator.currentValue();

                 this.processUnrealizedExchAdj(_emplTrans,
                                              transDate,
                                              exchPrinciples,
                                              defaultDimension,
                                              postingProfile,
                                              exchRateDate,
                                              exchRate,
                                              reportingExchRate,
                                              LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(sumLedgerDimension),
                                              useProfile,
                                              voucher);
            }

            transactionDate = _postingDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseAdvanceAdjTrans</Name>
				<Source><![CDATA[
    public void reverseAdvanceAdjTrans(EmplSettlement_RU _emplSettlement, EmplTrans_RU _creditTrans)
    {
        VendTrans                       vendTrans;
        EmplTrans_RU                    exchAdjTrans                  = _emplSettlement.findEmplTransByRefRecId(EmplTransSourceType_RU::AdvanceAdj, true);
        EmplAdvAdjustmentDocUpdate_RU   emplAdvAdjustmentDocUpdateRev = EmplAdvAdjustmentDocUpdate_RU::newFromReverseSettlement(ledgerVoucher);

        if (_creditTrans.RefTableId == tableNum(VendTrans))
        {
            vendTrans = VendTrans::find(_creditTrans.RefRecId, true);
        }

        emplAdvAdjustmentDocUpdateRev.updateCustVendInvoiceJourReverse(vendTrans, exchAdjTrans, _creditTrans.RecId);

        if (vendTrans)
        {
            this.reverseInventSumAdjust(_emplSettlement.TransDate, _emplSettlement.Voucher, vendTrans);
        }

        if (exchAdjTrans)
        {
            exchAdjTrans.RefRecId               = 0;
            exchAdjTrans.RefTableId             = 0;
            exchAdjTrans.Reversed               = NoYes::Yes;
            exchAdjTrans.update();

            _creditTrans.ExchAdjustment                  -= exchAdjTrans.AmountMST;
            _creditTrans.ReportingExchAdjustment         -= exchAdjTrans.ReportingCurrencyAmount;
            _creditTrans.ExchAdjustmentRealized          -= exchAdjTrans.AmountMST;
            _creditTrans.ReportingExchAdjustmentRealized -= exchAdjTrans.ReportingCurrencyAmount;
            _creditTrans.update();

            exchAdjTrans.Voucher                    = ledgerVoucher.lastVoucher();
            exchAdjTrans.AmountCur                  = - exchAdjTrans.AmountCur;
            exchAdjTrans.AmountMST                  = - exchAdjTrans.AmountMST;
            exchAdjTrans.ReportingCurrencyAmount    = - exchAdjTrans.ReportingCurrencyAmount;
            exchAdjTrans.SettleAmountCur            = - exchAdjTrans.SettleAmountCur;
            exchAdjTrans.SettleAmountMST            = - exchAdjTrans.SettleAmountMST;
            exchAdjTrans.ReportingSettleAmount      = - exchAdjTrans.ReportingSettleAmount;
            exchAdjTrans.Correct                    = ! exchAdjTrans.Correct;
            exchAdjTrans.ReportingCurrencyCorrect   = ! exchAdjTrans.ReportingCurrencyCorrect;
            exchAdjTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseInventSumAdjust</Name>
				<Source><![CDATA[
    protected void reverseInventSumAdjust(TransDate        _reverseDate,
                                          Voucher          _reverseVoucher,
                                          CustVendTrans    _custVendTrans,
                                          LedgerVoucher    _ledgerVoucher = null)
    {
        InventTrans                 inventTrans;
        InventSettlement            inventSettlement, cancelSettlement;
        InventAdjustPostMSTCur_RU   inventAdjustPost;
        InventAdjustPostSecCur_RU   inventAdjustPostSecCur;

        inventAdjustPost = new InventAdjustPostMSTCur_RU(_custVendTrans.Voucher,
                                                         _custVendTrans.TransDate,
                                                         InventAdjustmentSpec::Total,
                                                         LedgerTransTxt::VendAmountDiffVend_RU,
                                                         ! _custVendTrans.Correct);

        inventAdjustPostSecCur = new InventAdjustPostSecCur_RU(_custVendTrans.Voucher,
                                                               _custVendTrans.TransDate,
                                                               InventAdjustmentSpec::Total,
                                                               LedgerTransTxt::VendAmountDiffVend_RU,
                                                               ! _custVendTrans.Correct);

        inventAdjustPost.parmCurrencyCode(_custVendTrans.CurrencyCode);
        inventAdjustPostSecCur.parmCurrencyCode(_custVendTrans.CurrencyCode);

        while select forupdate inventSettlement
            where inventSettlement.Voucher   == _reverseVoucher &&
                  inventSettlement.TransDate == _reverseDate    &&
                  inventSettlement.Cancelled == NoYes::No
        {
            inventTrans = InventTrans::findRecId(inventSettlement.TransRecId, true);

            if (! inventSettlement.checkRefInventTrans_RU(inventTrans))
                throw error("@SYS18447");

            if (! InventClosing::checkOpen(inventTrans.DateFinancial))
                throw error("@SYS18447");

            this.adjustInventTransToSettlement(inventTrans, inventSettlement);

            inventTrans.update();

            inventSettlement.Cancelled = NoYes::Yes;
            inventSettlement.update();

            cancelSettlement.clear();
            cancelSettlement = inventSettlement.data();

            cancelSettlement.TransDate            = _custVendTrans.TransDate;
            cancelSettlement.Voucher              = _custVendTrans.Voucher;
            cancelSettlement.QtySettled           = -inventSettlement.QtySettled;
            cancelSettlement.CostAmountSettled    = -inventSettlement.CostAmountSettled;
            cancelSettlement.CostAmountAdjustment = -inventSettlement.CostAmountAdjustment;
            cancelSettlement.Posted               = NoYes::No;
            cancelSettlement.insert();
        }

        inventAdjustPost.parmLedgerTransType_RU(_custVendTrans.TransType);
        inventAdjustPost.updateNow(_ledgerVoucher);

        inventAdjustPostSecCur.updateNow(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustInventTransToSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts inventory transaction amounts to inventroy settlement.
    /// </summary>
    /// <param name = "_inventTrans">An inventory transaction to be adjusted.</param>
    /// <param name = "_inventSettlement">An inventory settlement.</param>
    protected void adjustInventTransToSettlement(InventTrans _inventTrans, InventSettlement _inventSettlement)
    {
        switch (_inventSettlement.InventTransCurrency_RU)
        {
            case InventTransCurrency_RU::PrimaryCur :
                _inventTrans.QtySettled           -= _inventSettlement.QtySettled;
                _inventTrans.CostAmountSettled    -= _inventSettlement.CostAmountSettled;
                _inventTrans.CostAmountAdjustment -= _inventSettlement.CostAmountAdjustment;
                if (_inventTrans.Qty > 0)
                {
                    _inventTrans.CostAmountStd = _inventTrans.costValue();
                }
                break;

            case InventTransCurrency_RU::SecondaryCur :
                _inventTrans.QtySettledSecCur_RU           -= _inventSettlement.QtySettled;
                _inventTrans.CostAmountSettledSecCur_RU    -= _inventSettlement.CostAmountSettled;
                _inventTrans.CostAmountSecCurAdjustment_RU -= _inventSettlement.CostAmountAdjustment;
                if (_inventTrans.Qty > 0)
                {
                    _inventTrans.CostAmountStdSecCur_RU = _inventTrans.costValueSecCur_RU();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseRealizedExchAdj</Name>
				<Source><![CDATA[
    public EmplSettlement_RU reverseRealizedExchAdj(EmplSettlement_RU _emplSettlement,
                                                    EmplTrans_RU      _debitTrans,
                                                    EmplTrans_RU      _creditTrans)
    {
        EmplTrans_RU                  exchAdjTrans;
        EmplSettlement_RU             exchAdjSettlement;

        void reverseExchAdjTrans()
        {
            RecId recId = exchAdjTrans.RecId;

            // Reread exchAdjTrans record with enabled pessimisticLock
            select pessimisticLock firstonly exchAdjTrans
                where exchAdjTrans.RecId == recId;

            exchAdjTrans.RefRecId   = 0;
            exchAdjTrans.RefTableId = 0;
            exchAdjTrans.Reversed   = NoYes::Yes;
            exchAdjTrans.update();

            exchAdjTrans.Voucher                            = (isFromSettlement) ? ledgerVoucher.lastVoucher() : exchAdjTrans.Voucher;
            exchAdjTrans.AmountCur                          = - exchAdjTrans.AmountCur;
            exchAdjTrans.AmountMST                          = - exchAdjTrans.AmountMST;
            exchAdjTrans.SettleAmountCur                    = - exchAdjTrans.SettleAmountCur;
            exchAdjTrans.SettleAmountMST                    = - exchAdjTrans.SettleAmountMST;
            exchAdjTrans.ReportingSettleAmount              = - exchAdjTrans.ReportingSettleAmount;
            exchAdjTrans.ExchAdjustment                     = - exchAdjTrans.ExchAdjustment;
            exchAdjTrans.ExchAdjustmentRealized             = - exchAdjTrans.ExchAdjustmentRealized;
            exchAdjTrans.ExchAdjustmentUnrealized           = - exchAdjTrans.ExchAdjustmentUnrealized;
            exchAdjTrans.ReportingExchAdjustment            = - exchAdjTrans.ReportingExchAdjustment;
            exchAdjTrans.ReportingExchAdjustmentRealized    = - exchAdjTrans.ReportingExchAdjustmentRealized;
            exchAdjTrans.ReportingExchAdjustmentUnrealized  = - exchAdjTrans.ReportingExchAdjustmentUnrealized;
            exchAdjTrans.Correct                            =  !exchAdjTrans.Correct;
            exchAdjTrans.ReportingCurrencyCorrect           =  !exchAdjTrans.ReportingCurrencyCorrect;
            exchAdjTrans.insert();
        }

        exchAdjTrans = _emplSettlement.findEmplTransByRefRecId(EmplTransSourceType_RU::ExchAdj, true);

        if (exchAdjTrans)
        {
            select forupdate firstonly exchAdjSettlement
                where (exchAdjSettlement.DebitRecId  == _debitTrans.RecId   &&
                       exchAdjSettlement.CreditRecId == exchAdjTrans.RecId) ||
                      (exchAdjSettlement.CreditRecId == _creditTrans.RecId  &&
                       exchAdjSettlement.DebitRecId  == exchAdjTrans.RecId);

            if (! isFromSettlement)
            {
                this.postExchAdj(exchAdjTrans.ExchAdjustment > 0 ? _debitTrans : _creditTrans,
                                 false,
                                 exchAdjTrans.ExchAdjustment,
                                 exchAdjTrans.ReportingExchAdjustment,
                                 dateNull(),
                                 0,
                                 0,
                                 true,
                                 false,
                                 LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(exchAdjTrans.LedgerDimension),
                                 exchAdjTrans.PostingProfile,
                                 LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                                 true,
                                 exchAdjTrans.Voucher);
            }
            else
            {
                if (exchAdjTrans.ExchAdjustmentRealized > 0)
                {
                    _debitTrans.ExchAdjustmentRealized  += exchAdjTrans.ExchAdjustmentRealized;
                    _debitTrans.ExchAdjustment          += exchAdjTrans.ExchAdjustment;
                    _debitTrans.update();
                }
                else
                {
                    _creditTrans.ExchAdjustmentRealized += exchAdjTrans.ExchAdjustmentRealized;
                    _creditTrans.ExchAdjustment         += exchAdjTrans.ExchAdjustment;
                    _creditTrans.update();
                }

                if (exchAdjTrans.ReportingExchAdjustmentRealized > 0)
                {
                    _debitTrans.ReportingExchAdjustmentRealized  += exchAdjTrans.ReportingExchAdjustmentRealized;
                    _debitTrans.ReportingExchAdjustment          += exchAdjTrans.ReportingExchAdjustment;
                    _debitTrans.update();
                }
                else
                {
                    _creditTrans.ReportingExchAdjustmentRealized += exchAdjTrans.ReportingExchAdjustmentRealized;
                    _creditTrans.ReportingExchAdjustment         += exchAdjTrans.ReportingExchAdjustment;
                    _creditTrans.update();
                }
            }

            reverseExchAdjTrans();
        }

        select forupdate firstonly exchAdjTrans
            where exchAdjTrans.RefTableId == _debitTrans.TableId             &&
                  exchAdjTrans.RefRecId   == _debitTrans.RecId               &&
                  exchAdjTrans.Voucher    == _emplSettlement.Voucher         &&
                  exchAdjTrans.TransDate  == _emplSettlement.TransDate       &&
                  exchAdjTrans.TransType  == EmplTransSourceType_RU::ExchAdj &&
                  exchAdjTrans.Reversed   == NoYes::No;

        if (exchAdjTrans)
        {
            if (! isFromSettlement)
            {
                this.postExchAdj(_debitTrans,
                                 true,
                                 exchAdjTrans.ExchAdjustment,
                                 exchAdjTrans.ReportingExchAdjustment,
                                 _debitTrans.LastExchAdj,
                                 _debitTrans.LastExchAdjRate,
                                 _debitTrans.ReportingLastExchAdjRate,
                                 false,
                                 false,
                                 LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(exchAdjTrans.LedgerDimension),
                                 exchAdjTrans.PostingProfile,
                                 LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                                 true,
                                 exchAdjTrans.Voucher);
            }
            else
            {
                _debitTrans.ExchAdjustmentUnrealized            += exchAdjTrans.ExchAdjustmentUnrealized;
                _debitTrans.ExchAdjustment                      += exchAdjTrans.ExchAdjustment;
                _debitTrans.ReportingExchAdjustmentUnrealized   += exchAdjTrans.ReportingExchAdjustmentUnrealized;
                _debitTrans.ReportingExchAdjustment             += exchAdjTrans.ReportingExchAdjustment;
                _debitTrans.update();
            }

            reverseExchAdjTrans();
        }

        select forupdate firstonly exchAdjTrans
            where exchAdjTrans.RefTableId == _creditTrans.TableId            &&
                  exchAdjTrans.RefRecId   == _creditTrans.RecId              &&
                  exchAdjTrans.Voucher    == _emplSettlement.Voucher         &&
                  exchAdjTrans.TransDate  == _emplSettlement.TransDate       &&
                  exchAdjTrans.TransType  == EmplTransSourceType_RU::ExchAdj &&
                  exchAdjTrans.Reversed   == NoYes::No;

        if (exchAdjTrans)
        {
            if (! isFromSettlement)
            {
                this.postExchAdj(_creditTrans,
                                 true,
                                 exchAdjTrans.ExchAdjustment,
                                 exchAdjTrans.ReportingExchAdjustment,
                                 _creditTrans.LastExchAdj,
                                 _creditTrans.LastExchAdjRate,
                                 _creditTrans.ReportingLastExchAdjRate,
                                 false,
                                 false,
                                 LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(exchAdjTrans.LedgerDimension),
                                 exchAdjTrans.PostingProfile,
                                 LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(exchAdjTrans.LedgerDimension),
                                 true,
                                 exchAdjTrans.Voucher);
            }
            else
            {
                _creditTrans.ExchAdjustmentUnrealized           += exchAdjTrans.ExchAdjustmentUnrealized;
                _creditTrans.ExchAdjustment                     += exchAdjTrans.ExchAdjustment;
                _creditTrans.ReportingExchAdjustmentUnrealized  += exchAdjTrans.ReportingExchAdjustmentUnrealized;
                _creditTrans.ReportingExchAdjustment            += exchAdjTrans.ReportingExchAdjustment;
                _creditTrans.update();
            }

            reverseExchAdjTrans();
        }

        return exchAdjSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reverseUnrealizedExchAdj</Name>
				<Source><![CDATA[
    protected container reverseUnrealizedExchAdj(EmplTrans_RU       _emplTrans,
                                                 EmplSettlement_RU  _emplSettlement,
                                                 AmountCur          _settleAmountCur,
                                                 TransDate          _transDate,
                                                 Voucher            _voucher,
                                                 boolean            _update = true,
                                                 EmplTrans_RU       _exchAdjUnrealizedTransTmp = null,
                                                 boolean            _useSetlementProportion = _emplSettlement ? true : false
                                                 )
    {
        AmountMST                     accountingUnrealizedAmount, accountingPeriodUnrealizedAmount;
        AmountMSTSecondary            reportingUnrealizedAmount, reportingPeriodUnrealizedAmount;
        EmplExchPrinciples_RU         exchPrinciples;
        DimensionDefault              defaultDimension;
        PostingProfile                postingProfile;
        LedgerDimensionDefaultAccount sumDefaultAccount;
        TransDate                     postingDate;
        TransDate                     exchRateDate;
        ExchRate                      exchRate;
        ExchRate                      reportingExchRate;
        NoneTableTrans                lastDimSpec;
        TransactionSelect             useProfile;

        transactionDate = _transDate;

        if (_emplTrans.LastExchAdj)
        {
            [accountingPeriodUnrealizedAmount, accountingUnrealizedAmount, reportingPeriodUnrealizedAmount, reportingUnrealizedAmount] = EmplExchAdjustmentCalc_RU::calcUnrealizedExchAdj(_emplTrans, _emplSettlement, _settleAmountCur, _transDate, _useSetlementProportion);

            if (accountingPeriodUnrealizedAmount || reportingPeriodUnrealizedAmount)
            {
                [exchPrinciples,
                 defaultDimension,
                 postingProfile,
                 sumDefaultAccount,
                 postingDate,
                 exchRateDate,
                 exchRate,
                 reportingExchRate,
                 useProfile,
                 lastDimSpec] = this.getLastExchAdjParameters(_emplTrans, transactionDate, true);

                this.postExchAdj_Distributed(
                    _emplTrans,
                    true,
                    - accountingPeriodUnrealizedAmount,
                    - reportingPeriodUnrealizedAmount,
                    postingDate,
                    exchRate,
                    reportingExchRate,
                    true,
                    true,
                    defaultDimension,
                    postingProfile,
                    sumDefaultAccount,
                    useProfile,
                    !isFromSettlement,
                    _voucher,
                    _update,
                    lastDimSpec,
                    _exchAdjUnrealizedTransTmp);
            }
        }

        return [accountingPeriodUnrealizedAmount, accountingUnrealizedAmount, reportingPeriodUnrealizedAmount, reportingUnrealizedAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcUnrealizedExchAdj</Name>
				<Source><![CDATA[
    public static container calcUnrealizedExchAdj(EmplTrans_RU       _emplTrans,
                                                  EmplSettlement_RU  _emplSettlement,
                                                  AmountCur          _settleAmountCur,
                                                  TransDate          _transDate,
                                                  boolean            _useSetlementProportion = _emplSettlement ? true : false)
    {
        EmplSettlement_RU   transSettlement;
        TransDate           startDate;
        AmountCur           openAmountCur = _emplTrans.AmountCur;
        AmountMST           accountingPeriodUnrealizedAmount, accountingUnrealizedAmount;
        AmountMSTSecondary  reportingPeriodUnrealizedAmount, reportingUnrealizedAmount;
        TransDate           periodStartLocal;

        void updateAmounts(TransDate _toDate)
        {
            if (_toDate >= periodStartLocal)
            {
                accountingPeriodUnrealizedAmount += CurrencyExchangeHelper::amount(EmplExchAdjustmentCalc_RU::getUnrealizedExchAdjByPeriod(_emplTrans, max(startDate, periodStartLocal), _toDate) * (_useSetlementProportion ? abs(_settleAmountCur / (openAmountCur ? openAmountCur : _settleAmountCur)) : 1));
                reportingPeriodUnrealizedAmount += CurrencyExchangeHelper::amount(EmplExchAdjustmentCalc_RU::getReportingUnrealizedExchAdjByPeriod(_emplTrans, max(startDate, periodStartLocal), _toDate) * (_useSetlementProportion ? abs(_settleAmountCur / (openAmountCur ? openAmountCur : _settleAmountCur)) : 1));
            }

            accountingUnrealizedAmount += CurrencyExchangeHelper::amount(EmplExchAdjustmentCalc_RU::getUnrealizedExchAdjByPeriod(_emplTrans, startDate, _toDate) * (_useSetlementProportion ? abs(_settleAmountCur / (openAmountCur ? openAmountCur : _settleAmountCur)) : 1));
            reportingUnrealizedAmount  += CurrencyExchangeHelper::amount(EmplExchAdjustmentCalc_RU::getReportingUnrealizedExchAdjByPeriod(_emplTrans, startDate, _toDate) * (_useSetlementProportion ? abs(_settleAmountCur / (openAmountCur ? openAmountCur : _settleAmountCur)) : 1));
        }

        periodStartLocal = LedgerFiscalCalendar::findPeriodStartDateByDateWithIndex(CompanyInfoHelper::fiscalCalendarRecId(), _transDate);

        if (_emplTrans.LastExchAdj)
        {
            while select sum(SettleAmountCurDebit), sum(SettleAmountCurCredit) from transSettlement group by TransDate asc
                where (transSettlement.DebitRecId  == _emplTrans.RecId     ||
                       transSettlement.CreditRecId == _emplTrans.RecId)    &&
                       transSettlement.TransDate   >= _emplTrans.TransDate &&
                       transSettlement.TransDate   <=  _transDate          &&
                       (transSettlement.SettleAmountCurDebit               ||
                        transSettlement.SettleAmountCurCredit)             &&
                       transSettlement.RecId       !=  _emplSettlement.RecId
            {
                updateAmounts(transSettlement.TransDate);
                startDate        = transSettlement.TransDate + 1;
                openAmountCur   += (_emplTrans.AmountCur > 0) ? - transSettlement.SettleAmountCurDebit : - transSettlement.SettleAmountCurCredit;
            }
        }

        updateAmounts(_transDate);

        return [accountingPeriodUnrealizedAmount, accountingUnrealizedAmount, reportingPeriodUnrealizedAmount, reportingUnrealizedAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinalPostingType</Name>
				<Source><![CDATA[
    static public LedgerPostingType getFinalPostingType(LedgerPostingType _posting)
    {
        LedgerPostingType posting = _posting;

        if (_posting == LedgerPostingType::ExchRateGain || _posting == LedgerPostingType::ExchRateLoss)
        {
            posting = _posting == LedgerPostingType::ExchRateGain ? LedgerPostingType::AdvanceAdjustmentGain_RU : LedgerPostingType::AdvanceAdjustmentLoss_RU;
        }

        return posting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingUnrealizedExchAdjByPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns unrealized exchange adjustment in reporting currency
    /// </summary>
    /// <param name="_emplTrans">
    ///   Employee transaction
    /// </param>
    /// <param name="_fromDate">
    ///   start of period
    /// </param>
    /// <param name="_toDate">
    ///   end of period
    /// </param>
    /// <returns>
    ///   Exchange adjustment value
    /// </returns>
    public static AmountMSTSecondary getReportingUnrealizedExchAdjByPeriod(EmplTrans_RU _emplTrans, TransDate _fromDate, TransDate _toDate)
    {
        EmplTrans_RU exchAdjTrans;

        if (_emplTrans.LastExchAdj)
        {
            select sum(ReportingExchAdjustmentUnrealized) from exchAdjTrans
                where exchAdjTrans.EmplAccount == _emplTrans.EmplAccount &&
                    exchAdjTrans.TransDate >= _fromDate &&
                    exchAdjTrans.TransDate <= _toDate &&
                    exchAdjTrans.RefTableId == _emplTrans.TableId &&
                    exchAdjTrans.RefRecId == _emplTrans.RecId &&
                    exchAdjTrans.TransType == EmplTransSourceType_RU::ExchAdj &&
                    exchAdjTrans.LastExchAdj &&
                    exchAdjTrans.ReportingLastExchAdjRate &&
                    !(exchAdjTrans.ReportingCurrencyCorrect &&
                        exchAdjTrans.IsFromSettlement);
        }

        return - exchAdjTrans.ReportingExchAdjustmentUnrealized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnrealizedExchAdjByPeriod</Name>
				<Source><![CDATA[
    public static AmountMST getUnrealizedExchAdjByPeriod(EmplTrans_RU _emplTrans, TransDate _fromDate, TransDate _toDate)
    {
        EmplTrans_RU exchAdjTrans;

        if (_emplTrans.LastExchAdj)
        {
            select sum(ExchAdjustmentUnrealized) from exchAdjTrans
                where exchAdjTrans.EmplAccount == _emplTrans.EmplAccount &&
                    exchAdjTrans.TransDate >= _fromDate &&
                    exchAdjTrans.TransDate <= _toDate &&
                    exchAdjTrans.RefTableId == _emplTrans.TableId &&
                    exchAdjTrans.RefRecId == _emplTrans.RecId &&
                    exchAdjTrans.TransType == EmplTransSourceType_RU::ExchAdj &&
                    exchAdjTrans.LastExchAdj &&
                    exchAdjTrans.LastExchAdjRate &&
                    !(exchAdjTrans.Correct &&
                        exchAdjTrans.IsFromSettlement);
        }

        return - exchAdjTrans.ExchAdjustmentUnrealized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromAdvReject</Name>
				<Source><![CDATA[
    public static EmplExchAdjustmentCalc_RU newFromAdvReject(LedgerVoucher _ledgerVoucher)
    {
        EmplExchAdjustmentCalc_RU  emplExchAdjustment;

        emplExchAdjustment = new EmplExchAdjustmentCalc_RU();
        emplExchAdjustment.parmLedgerVoucher(_ledgerVoucher);

        return emplExchAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromExchAdj</Name>
				<Source><![CDATA[
    public static EmplExchAdjustmentCalc_RU newFromExchAdj(EmplExchAdj_RU _emplExchAdj)
    {
        EmplExchAdjustmentCalc_RU  emplExchAdjustment;

        emplExchAdjustment = new EmplExchAdjustmentCalc_RU();
        emplExchAdjustment.parmEmplExchAdj(_emplExchAdj);

        return emplExchAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newFromSettlement</Name>
				<Source><![CDATA[
    public static EmplExchAdjustmentCalc_RU newFromSettlement(LedgerVoucher _ledgerVoucher)
    {
        EmplExchAdjustmentCalc_RU  emplExchAdjustment;

        emplExchAdjustment = new EmplExchAdjustmentCalc_RU();
        emplExchAdjustment.parmLedgerVoucher(_ledgerVoucher);
        emplExchAdjustment.parmIsFromSettlement(true);

        return emplExchAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>summaryLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Summary ledger dimension
    /// </summary>
    /// <param name="_emplAccount">
    ///   Employee account
    /// </param>
    /// <param name="_postingProfile">
    ///   Posting profile
    /// </param>
    /// <returns>
    ///   <c>LedgerDimensionDefaultAccount</c>
    /// </returns>
    public static LedgerDimensionDefaultAccount summaryLedgerDimension(EmplAccount_RU _emplAccount, EmplPostingProfile_RU _postingProfile)
    {
        return EmplLedgerAccounts_RU::summaryLedgerDimension(_emplAccount, _postingProfile);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>