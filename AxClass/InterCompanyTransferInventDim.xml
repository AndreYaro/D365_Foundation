<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InterCompanyTransferInventDim</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InterCompanyTransferInventDim</c> class handles the invent dimensions transfer between
///    inter-company companies.
/// </summary>
/// <remarks>
///    The <c>run</c> method of this class must be overridden.
/// </remarks>
public class InterCompanyTransferInventDim
{
    #IsoCountryRegionCodes

    StatusIssue                                 statusIssue;
    InterCompanyEndpointActionPolicyTransfer    interCompanyTransferExternal;

    InterCompanyTradingValueMap                 fromInterCompanyTradingValueMap;
    InterCompanyTradingValueMap                 toInterCompanyTradingValueMap;

    TradeInterCompanyConv                       convInventLocation;
    TradeInterCompanyConv                       convInventProfile;
    VersioningUpdateType                        versioningUpdateType;
    Voucher                                     voucher;
    boolean                                     isWHSEnabledItem;
    InventTable                                 inventTable;
    InventDimParm                               trackingsDimBelowLocation;
    InterCompanyEndpointActionPolicyTransfer    actionPolicyTransfer;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>inventDimensionsBelowLocation</Name>
				<Source><![CDATA[
    private InventDimParm inventDimensionsBelowLocation(boolean _isBatchBelowLocation, boolean _isSerialBelowLocation)
    {
        InventDimParm inventDimsBelowLocation;
        if (_isBatchBelowLocation)
        {
            inventDimsBelowLocation.InventBatchIdFlag = NoYes::Yes;
        }
        if (_isSerialBelowLocation)
        {
            inventDimsBelowLocation.InventSerialIdFlag = NoYes::Yes;
        }
        return inventDimsBelowLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackingDimensionsBelowLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns all tracking dimensions that are below Location for an item.
    /// </summary>
    /// <param name = "_inventTable">The item.</param>
    /// <returns>An InventDimParm record with the tracking dimension that are below location.</returns>
    protected InventDimParm trackingDimensionsBelowLocation(InventTable _inventTable)
    {
        InventDimParm inventDimsBelowLocation;

        if (WHSInventTable::exist(_inventTable.ItemId))
        {
            inventDimsBelowLocation.InventSerialIdFlag = WHSReservationHierarchyInventDimUtil::isSerialBelowLocation(_inventTable);

            // For batch the policy determines if sync should happen. For WHS it doesn't matter if batch is above or below location
            inventDimsBelowLocation.InventBatchIdFlag  = false;
        }

        return inventDimsBelowLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAlreadyTransferredQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the inventory transaction quantity that already has the transferred dimensions.
    /// </summary>
    /// <param name="_inventTransOrigin">
    ///    The inventory transaction origin.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///    The inventory dimensions
    /// </param>
    /// <param name="_inventDimParmCriteria">
    ///    The inventory dimension parameters.
    /// </param>
    /// <param name="_inventTable">
    ///    The inventory table.
    /// </param>
    /// <param name="_isWHSEnabledItem">
    ///    A Boolean value that specifies if the item is a WHS enabled item.
    /// </param>
    /// <param name="_isBatchBelowLocation">
    ///    A Boolean value that specifies if batch numbers are below location in the reservation hierarchy.
    /// </param>
    /// <param name="_isSerialBelowLocation">
    ///    A Boolean value that specifies if serial numbers are below location in the reservation hierarchy.
    /// </param>
    /// <param name="_actionPolicyTransfer">
    ///    The intercompany action policy record containing information about which dimensions to transfer.
    /// </param>
    /// <returns>
    ///    A container contains the quantity in inventory unit and CW quantity.
    /// </returns>
    [SysObsolete('Use calculateAlreadyTransferredQuantities() instead.', false, 31\03\2019)]
    protected container pdsAlreadyTransferredQuantity(
        InventTransOrigin _inventTransOrigin,
        InventDim         _inventDimCriteria,
        InventDimParm     _inventDimParmCriteria,
        InventTable       _inventTable,
        boolean           _isWHSEnabledItem,
        boolean           _isBatchBelowLocation,
        boolean           _isSerialBelowLocation,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer = null)
    {
        InventDimParm inventDimsBelowLocation = this.inventDimensionsBelowLocation(_isBatchBelowLocation, _isSerialBelowLocation);
        PmfQtyDataCarrier quantities = this.calculateAlreadyTransferredQuantities(_inventTransOrigin, _inventDimCriteria, _inventDimParmCriteria);

        return [quantities.parmInventQty(), quantities.parmCwQty()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAlreadyTransferredQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the inventory transaction quantity that already has the transferred dimensions.
    /// </summary>
    /// <param name="_inventTransOrigin">
    ///    The inventory transaction origin.
    /// </param>
    /// <param name="_inventDimCriteria">
    ///    The inventory dimensions
    /// </param>
    /// <param name="_inventDimParmCriteria">
    ///    The inventory dimension parameters.
    /// </param>
    /// <returns>
    ///    The quantity in inventory unit and CW quantity.
    /// </returns>
    protected PmfQtyDataCarrier calculateAlreadyTransferredQuantities(
        InventTransOrigin _inventTransOrigin,
        InventDim         _inventDimCriteria,
        InventDimParm     _inventDimParmCriteria)
    {
        InventDim       inventDim;
        InventDim       inventDimJoin;
        InventDimParm   inventDimParm;
        InventTrans     inventTrans;
        InventTrans     inventTransQty;
        InventQty       qty;
        PdsCWInventQty  pdsCWQty;

        // find the quantity that already has transferred dimensions
        if (isWHSEnabledItem
           && this.canTransferInventDim(_inventDimParmCriteria)) 
        {
            // for WHS enabled items, need to group by warehouse, because batch and serial are not
            // sync'd to WHS enabled warehouses
            while select InventLocationId from inventDim
            group by InventLocationId
            exists join inventTrans
                where inventTrans.InventTransOrigin    == _inventTransOrigin.RecId
                   && (inventTrans.StatusReceipt       <= StatusReceipt::Registered
                   ||  inventTrans.InterCompanyInventDimTransferred == true)
                   && inventTrans.StatusIssue          == StatusIssue::None
                   && inventTrans.PackingSlipReturned  == NoYes::No
                   && inventTrans.InventDimId          == inventDim.InventDimId
            {
                inventDimParm = this.finalInventDimensionsToTransfer(
                                    _inventDimParmCriteria,
                                    inventDim.InventLocationId);

                select forceplaceholders sum(Qty), sum(PdsCWQty) from inventTransQty
                where inventTransQty.InventTransOrigin    == _inventTransOrigin.RecId
                   && (inventTransQty.StatusReceipt       <= StatusReceipt::Registered
                   ||  inventTransQty.InterCompanyInventDimTransferred == true)
                   && inventTransQty.StatusIssue          == StatusIssue::None
                   && inventTransQty.PackingSlipReturned  == NoYes::No
                #inventDimJoin(inventTransQty.InventDimId,inventDimJoin,_inventDimCriteria,inventDimParm)
                && inventDimJoin.InventLocationId      == inventDim.InventLocationId;

                qty      += inventTransQty.Qty;
                pdsCWQty += inventTransQty.PdsCWQty;
            }
        }
        else
        {
            select forceplaceholders sum(Qty), sum(PdsCWQty) from inventTransQty
            where inventTransQty.InventTransOrigin    == _inventTransOrigin.RecId
               && (inventTransQty.StatusReceipt       <= StatusReceipt::Registered
               ||  inventTransQty.InterCompanyInventDimTransferred == true)
               && inventTransQty.StatusIssue          == StatusIssue::None
               && inventTransQty.PackingSlipReturned  == NoYes::No
            #inventDimJoin(inventTransQty.InventDimId,inventDimJoin,_inventDimCriteria,_inventDimParmCriteria);

            qty      = inventTransQty.Qty;
            pdsCWQty = inventTransQty.PdsCWQty;
        }

        return PmfQtyDataCarrier::newStandard(qty, pdsCWQty);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCalculateInventoryQuantityAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the quantity in inventory unit that has to be adjusted for the current movement because
    /// of the update.
    /// </summary>
    /// <param name="_itemId">
    /// An item ID.
    /// </param>
    /// <param name="_cwActualQuantity">
    /// The actual quantity in catch weight unit.
    /// </param>
    /// <param name="_actualQuantity">
    /// The actual quantity in inventory unit.
    /// </param>
    /// <param name="_cwUpdatedQuantity">
    /// The updated quantity in catch weight unit.
    /// </param>
    /// <param name="_updatedQuantity">
    /// The updated quantity in inventory unit.
    /// </param>
    /// <returns>
    /// The quantity in inventory unit that has to be adjusted for the current movement because of the
    /// update.
    /// </returns>
    /// This method suggests the inventory quantity that needs to be adjusted in order to keep the remainder inventory quantity in the range
    /// between minimal and maximal allowed inventory quantity for the remain catch weight quantity. This is also applied to the case when
    /// remaining catch weight quantity is zero. In this case this method will suggest to adjust the leftover inventory quantity. This will
    /// allow to get rid of inventory transactions with 0 catch weight quantity.
    protected InventQty pdsCalculateInventoryQuantityAdjustment(
        ItemId          _itemId,
        PdsCWInventQty  _cwActualQuantity,
        InventQty       _actualQuantity,
        PdsCWInventQty  _cwUpdatedQuantity,
        InventQty       _updatedQuantity)
    {
        return _updatedQuantity - PdsCatchWeight::adjustSplitInventQty(
            _itemId,
            _cwActualQuantity,
            _actualQuantity,
            _cwUpdatedQuantity,
            _updatedQuantity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canTransferInventDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates if the inventory dimensions can be transferred.
    /// </summary>
    /// <param name="_inventDimParm">
    /// A <c>InventDimParm</c> buffer.
    /// </param>
    /// <returns>
    /// true if the inventory dimensions can be transferred; otherwise, false.
    /// </returns>
    private boolean canTransferInventDim(InventDimParm _inventDimParm)
    {
        Enumerator enum = this.transferableDimensions().getEnumerator();
        while (enum.moveNext())
        {
            FieldId fieldIdOnInventDimParm = enum.current();
            if (_inventDimParm.(fieldIdOnInventDimParm))
            {
                return true;
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferableDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a collection of the inventory dimensions that can be transferred.
    /// </summary>
    /// <returns>
    /// A collection of the inventory dimensions that can be transferred.
    /// </returns>
    protected Set transferableDimensions()
    {
        #InventDimDevelop

        Set dims = new Set(Types::Integer);

        dims.add(fieldNum(InventDimParm, InventLocationIdFlag));
        dims.add(fieldNum(InventDimParm, InventBatchIdFlag));
        dims.add(fieldNum(InventDimParm, InventProfileIdFlag_RU));
        dims.add(fieldNum(InventDimParm, InventSerialIdFlag));

        return dims;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalTransferInventDimParm</Name>
				<Source><![CDATA[
    /// <summary>
    ///    The final inventory dimension parameters to be transferred.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    The inventory dimension parameters.
    /// </param>
    /// <param name="_inventLocationId">
    ///    The inventory location ID.
    /// </param>
    /// <param name="_inventTable">
    ///    The inventory table.
    /// </param>
    /// <param name="_isWHSEnabledItem">
    ///    A Boolean value that specifies if the item is a WHS enabled item.
    /// </param>
    /// <param name="_isBatchBelowLocation">
    ///    A Boolean value that specifies if batch numbers are below location in the reservation hierarchy. Obsolete; parameter is not used.
    /// </param>
    /// <param name="_isSerialBelowLocation">
    ///    A Boolean value that specifies if serial numbers are below location in the reservation hierarchy.
    /// </param>
    /// <param name="_actionPolicyTransfer">
    ///    The intercompany action policy record containing information about which dimensions to transfer.
    /// </param>
    /// <returns>
    ///    The final inventory dimension parameters.
    /// </returns>
    /// <remarks>
    ///    Serial numbers that are below location in the reservation hierarchy of WHS enabled items
    ///    will not be synchronized.
    /// </remarks>
    [SysObsolete('Use finalInventDimensionsToTransfer() instead.', false, 31\03\2019)]
    protected InventDimParm finalTransferInventDimParm(
        InventDimParm    _inventDimParm,
        InventLocationId _inventLocationId,
        InventTable      _inventTable,
        boolean          _isWHSEnabledItem,
        boolean          _isBatchBelowLocation,
        boolean          _isSerialBelowLocation,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer = null)
    {
        InventDimParm inventDimsBelowLocation = this.inventDimensionsBelowLocation(_isBatchBelowLocation, _isSerialBelowLocation);
        
        return this.finalInventDimensionsToTransfer(_inventDimParm, _inventLocationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>finalInventDimensionsToTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    The final inventory dimension parameters to be transferred.
    /// </summary>
    /// <param name="_inventDimParm">
    ///    The inventory dimension parameters.
    /// </param>
    /// <param name="_inventLocationId">
    ///    The inventory location ID.
    /// </param>
    /// <returns>
    ///    The final inventory dimension parameters.
    /// </returns>
    /// <remarks>
    ///    Serial numbers that are below location in the reservation hierarchy of WHS enabled items
    ///    will not be synchronized.
    /// </remarks>
    protected InventDimParm finalInventDimensionsToTransfer(
        InventDimParm    _inventDimParm,
        InventLocationId _inventLocationId)
    {
        InventLocation  inventLocation;
        InventDimParm   inventDimParm;

        inventDimParm.data(_inventDimParm);

        if (!IntercompanyBatchSerialManualSyncContext::manualSyncInvoked() 
            && isWHSEnabledItem && this.canTransferInventDim(_inventDimParm))
        {
            inventLocation = InventLocation::find(_inventLocationId);

            if (!inventLocation
                || inventLocation.whsEnabled)
            {
                inventDimParm.InventBatchIdFlag  = actionPolicyTransfer.InventBatchId ? inventDimParm.InventBatchIdFlag : NoYes::No;
                inventDimParm.InventSerialIdFlag =  actionPolicyTransfer.InventSerialId ? inventDimParm.InventSerialIdFlag : NoYes::No;
            }
        }

        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(Common _common)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetReturnTransferred</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the InterCompanyInventDimTransferred flag for inventory transactions with status issue on order.
    /// </summary>
    /// <param name="_toInventTransId">
    /// The <c>InventTransId</c> for the inventory transactions to reset the InterCompanyInventDimTransferred flag.
    /// </param>
    private void resetReturnTransferred(InventTransId _toInventTransId)
    {
        InventTrans         toInventTrans;
        InventTransOrigin   toInventTransOrigin;

        ttsbegin;

        while select forupdate toInventTrans
            where toInventTrans.StatusIssue    == StatusIssue::OnOrder
                && toInventTrans.StatusReceipt == StatusReceipt::None
            exists join toInventTransOrigin
                where toInventTransOrigin.RecId    == toInventTrans.InventTransOrigin
                    && toInventTransOrigin.InventTransId == _toInventTransId
        {
            toInventTrans.InterCompanyInventDimTransferred = false;
            toInventTrans.doUpdate();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>returnToInventTransOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the to <c>InventTransOrigin</c> to be used for return order lines.
    /// </summary>
    /// <param name="_toInventTransId">
    /// The <c>InventTransId</c> for the return order line.
    /// </param>
    /// <returns>
    /// A <c>InventTransOrigin</c>.
    /// </returns>
    private InventTransOrigin returnToInventTransOrigin(InventTransId _toInventTransId)
    {
        InventTransOrigin   toInventTransOrigin;

        InventTrans toInventTrans = InventTrans::findTransId(_toInventTransId);
        if (toInventTrans.MarkingRefInventTransOrigin)
        {
            //The existing code expects to work with a receipt and then change the issue.
            // to achieve this we simply set the to (which is an issue) to the ref which is an receipt.
            toInventTransOrigin = InventTransOrigin::find(toInventTrans.MarkingRefInventTransOrigin);
        }

        return toInventTransOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransferDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a given dimension must be transferred. 
    /// </summary>
    /// <param name = "_inventDimFieldId">The field Id of the dimension.</param>
    /// <param name = "_actionPolicyTransfer">The policy.</param>
    /// <param name = "_forceTransfer">The forced transfer used when transferring invent dimensions automatically.</param>
    /// <returns>true if the dimension must be transferred.</returns>
    protected boolean mustTransferDimension(
        FieldId                                  _inventDimFieldId,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer,
        boolean                                  _forceTransfer        
        )
    {
        #InventDimDevelop

        switch (_inventDimFieldId)
        {
            case fieldNum(InventDim, InventSerialId):
                return (_forceTransfer || _actionPolicyTransfer.InventSerialId);

            case fieldNum(InventDim, InventBatchId):
                return (_forceTransfer || _actionPolicyTransfer.InventBatchId);
            
            case fieldNum(InventDim, InventLocationId):
                return fromInterCompanyTradingValueMap.XmlMapInventLocation != XMLMapExternalCode::NotSpecified
                    && toInterCompanyTradingValueMap.XmlMapInventLocation != XMLMapExternalCode::NotSpecified;

            case fieldNum(InventDim, InventProfileId_RU):
                return fromInterCompanyTradingValueMap.aifEndPointActionValueMapExt_RU().xmlMapInventProfile != XMLMapExternalCode::NotSpecified
                    && toInterCompanyTradingValueMap.aifEndPointActionValueMapExt_RU().xmlMapInventProfile != XMLMapExternalCode::NotSpecified;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateActionPolicyTransferInventoryDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the intercompany synchronization configuration inventory dimensions.
    /// </summary>
    /// <param name = "_actionPolicyTransfer">An instance of <c>InterCompanyEndpointActionPolicyTransfer</c> object.</param>
    /// <returns>true if the inventory dimensions are set; otherwise, false.</returns>
    protected boolean validateActionPolicyTransferInventoryDimension(InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer)
    {
        return (_actionPolicyTransfer.InventBatchId || _actionPolicyTransfer.InventSerialId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Transfers inventory dimensions from one lot ID to another.
    ///    Which includes packing slip, packing slip cancellation, packing slip correction scenarios.
    /// </summary>
    /// <param name="_fromDataAreaId">
    ///    The company from which the <c>_fromInventTransId</c> originates.
    /// </param>
    /// <param name="_fromInventTransId">
    ///    The lot ID from which the inventory dimensions are transferred.
    /// </param>
    /// <param name="_toDataAreaId">
    ///    The company from which the <c>_toInventTransId</c> originates.
    /// </param>
    /// <param name="_toInventTransId">
    ///    The lot ID to which the inventory dimensions are to be transferred.
    /// </param>
    /// <param name="_actionPolicyTransfer">
    ///    The intercompany action policy record containing information about which dimensions to transfer.
    /// </param>
    /// <param name="_statusIssue">
    ///    The highest issue status to search for on the lot ID to transfer to.
    /// </param>
    /// <param name="_documentNum">
    ///    The document number used when transferring a specific document (packing slip number or invoice number); optional.
    /// </param>
    /// <param name="_registerReceipt">
    ///    The receipt registration used when transferring as part of intercompany direct delivery posting; optional.
    /// </param>
    /// <param name="_forceTransfer">
    ///    The forced transfer used when transferring invent dimensions automatically; optional.
    /// </param>
    /// <param name="_overDelivery">
    ///    A Boolean value determining whether over delivery is allowed when fetching the <c>InventTrans</c> records; optional.
    /// </param>
    /// <param name="_statusReceipt">
    ///    The lowest receipt status to search for on the lot ID to transfer to; optional.
    /// </param>
    /// <returns>
    ///    true if inventory dimensions actually were transferred; otherwise, false.
    /// </returns>
    protected boolean transfer(
        DataAreaId                               _fromDataAreaId,
        InventTransId                            _fromInventTransId,
        DataAreaId                               _toDataAreaId,
        InventTransId                            _toInventTransId,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer,
        StatusIssue                              _statusIssue,
        Num                                      _documentNum     = "",
        boolean                                  _registerReceipt = true,
        boolean                                  _forceTransfer   = false,
        boolean                                  _overDelivery    = false,
        StatusReceipt                            _statusReceipt   = StatusReceipt::None)
    {
        InventTrans                         fromInventTrans;
        InventTransOrigin                   fromInventTransOrigin;
        InventTrans                         toInventTrans;
        InventTransOrigin                   toInventTransOrigin;
        InventTrans                         refInventTrans;
        InventTrans                         inventTransUpd;
        InventDim                           fromInventDim;
        InventDim                           toInventDim;
        InventDim                           inventDimUpd;
        InventDimParm                       inventDimParm;
        InventDimParm                       inventDimParmRegistration;
        InventDimParm                       inventDimParmUpd;

        Qty                                 fromQty;
        PdsCWInventQty                      pdsCWFromQty;
        InventQty                           inventQtyAdjustment;
        boolean                             cwItem;

        InventMovement                      movement;
        InventMovement                      movementRegistration;
        InventUpd_Reservation               reservation;
        InventUpdate                        inventUpdate;
        InventUpd_Registered                registered;

        boolean                             numbersTransfered;
        InventDimGroupSetup                 inventDimGroupSetup;

        InterCompanyEndpointActionPolicy    fromInterCompanyEndpointActionPolicy;
        InterCompanyTradingPartner          fromInterCompanyTradingPartner;
        InterCompanyTradingPartner          toInterCompanyTradingPartner;
        UnitOfMeasureRecId                  toUnitOfMeasureRecId;
        UnitOfMeasureRecId                  fromUnitOfMeasureRecId;
        Set                                 setOfIssueInventTransOriginIds;
        StatusReceipt                       toStatusReceiptLast               = StatusReceipt::None;
        RecId                               toInventTransRecIdLast            = 0;
        boolean                             isReturn                          = (_statusIssue == StatusIssue::None);
        boolean                             onlyUseOnOrderTransForReservation = true;
               
        boolean                             isCancelOrCorrect                 = (this.parmVersioningUpdateType() == VersioningUpdateType::Cancel || this.parmVersioningUpdateType() == VersioningUpdateType::Correction);
        InventDim                           inventDimJoin;

        actionPolicyTransfer = _actionPolicyTransfer;

        changecompany (_fromDataAreaId)
        {
            fromInventTransOrigin = InventTransOrigin::findByInventTransId(_fromInventTransId);

            select firstonly InterCompanyTradingPartner from fromInterCompanyEndpointActionPolicy
                where fromInterCompanyEndpointActionPolicy.RecId == _actionPolicyTransfer.InterCompanyEndpointActionPolicy;

            fromInterCompanyTradingPartner  = InterCompanyTradingPartner::find(fromInterCompanyEndpointActionPolicy.InterCompanyTradingPartner);
            fromInterCompanyTradingValueMap = fromInterCompanyTradingPartner.interCompanyTradingValueMap();
        }

        if (!_forceTransfer)
        {
            if (!this.validateActionPolicyTransferInventoryDimension(_actionPolicyTransfer)
                && fromInterCompanyTradingValueMap.XmlMapInventLocation == XMLMapExternalCode::NotSpecified)
            {
                if (this.pdsCanSyncInventQty(_fromDataAreaId, _fromInventTransId, _toDataAreaId, _toInventTransId))
                {
                    this.syncRemainPhysicalForDelivery(_fromDataAreaId, _fromInventTransId, _toDataAreaId, _toInventTransId, _statusIssue);
                }
                return numbersTransfered;
            }
        }
        
        if (!fromInventTransOrigin)//From order line is not stocked.
        {
            return numbersTransfered;
        }

        changecompany (_toDataAreaId)
        {
            setPrefix(strFmt("@SYS93821",TradeInterCompany::curCompanyName()));

            toInventTransOrigin = InventTransOrigin::findByInventTransId(_toInventTransId);
            if (toInventTransOrigin)
            {
                toInterCompanyTradingPartner  = InterCompanyTradingRelation::getRelatedTradingPartner(fromInterCompanyTradingPartner);
                toInterCompanyTradingValueMap = fromInterCompanyTradingPartner.interCompanyTradingValueMap();

                inventTable           = toInventTransOrigin.inventTable();
                inventDimParm         = null;
                inventDimGroupSetup   = InventDimGroupSetup::newInventTable(inventTable);
                isWHSEnabledItem      = WHSInventTable::exist(inventTable.ItemId);
                trackingsDimBelowLocation = this.trackingDimensionsBelowLocation(inventTable);

                Enumerator enum = this.transferableDimensions().getEnumerator();
                while (enum.moveNext())
                {
                    FieldId inventDimParmFieldId = enum.current();
                    FieldId inventDimFieldId = InventDim::dimParm2dim(inventDimParmFieldId);

                    if (inventDimGroupSetup.isDimensionActive(inventDimFieldId) &&
                        this.mustTransferDimension(inventDimFieldId, _actionPolicyTransfer, _forceTransfer))
                    {
                        inventDimParm.(inventDimParmFieldId) = NoYes::Yes;
                    }
                }

                if (isReturn && this.canTransferInventDim(inventDimParm))
                {
                    this.resetReturnTransferred(_toInventTransId);
                }
            }
            else
            {
                return numbersTransfered;
            }
        }

        if (this.canTransferInventDim(inventDimParm))
        {
            changecompany(_fromDataAreaId)
            {
                ttsbegin;

                // We need to have enough quantity on the "to" transactions to match everything on the "from" side for direct delivery or over-delivery.
                // Sync remainders to create additional estimated transactions.
                this.syncRemainPhysicalForDelivery(_fromDataAreaId, _fromInventTransId, _toDataAreaId, _toInventTransId, _statusIssue);

                setOfIssueInventTransOriginIds = new Set(Types::Int64);
                fromInventTrans = null;
                fromInventTransOrigin = InventTransOrigin::findByInventTransId(_fromInventTransId);

                #Query
                Query query = new Query();
                query.literals(#QueryForcePlaceholders);
                QueryBuildDataSource inventTransQbds = query.addDataSource(tableNum(InventTrans));
                inventTransQbds.addSelectionField(fieldNum(InventTrans, Qty), SelectionField::Sum);
                inventTransQbds.addSelectionField(fieldNum(InventTrans, PdsCWQty), SelectionField::Sum);
                inventTransQbds.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(fromInventTransOrigin.RecId));

                if (isCancelOrCorrect)
                {
                    inventTransQbds.addRange(fieldNum(InventTrans, PackingSlipReturned)).value(queryValue(NoYes::Yes));
                    inventTransQbds.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::None));
                    inventTransQbds.addRange(fieldNum(InventTrans, StatusIssue)).value(SysQuery::range(0, _statusIssue));
                    inventTransQbds.addRange(fieldNum(InventTrans, PackingSlipId)).value(queryValue(_documentNum));
                    inventTransQbds.addRange(fieldNum(InventTrans, Voucher)).value(queryValue(this.parmVoucher()));
                }
                else
                {
                    inventTransQbds.addRange(fieldNum(InventTrans, PackingSlipReturned)).value(queryValue(NoYes::No));
                    if (isReturn)
                    {
                        inventTransQbds.addRange(fieldNum(InventTrans, StatusIssue)).value(queryValue(StatusIssue::None));
                        inventTransQbds.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryRange(_statusReceipt, null));
                    }
                    else
                    {
                        inventTransQbds.addRange(fieldNum(InventTrans, StatusReceipt)).value(queryValue(StatusReceipt::None));
                        inventTransQbds.addRange(fieldNum(InventTrans, StatusIssue)).value(queryRange(null, _statusIssue));
                    }
                }

                QueryBuildDataSource inventDimQbds = inventTransQbds.addDataSource(tableNum(InventDim));
                inventDimQbds.addLink(fieldNum(InventTrans, InventDimId), fieldNum(InventDim, InventDimId));

                Enumerator enum = this.transferableDimensions().getEnumerator();
                while (enum.moveNext())
                {
                    FieldId fieldIdOnInventDimParm = enum.current();
                    if (inventDimParm.(fieldIdOnInventDimParm))
                    {
                        FieldId fieldIdOnInventDim = InventDim::dimParm2dim(fieldIdOnInventDimParm);
                        inventDimQbds.addGroupByField(fieldIdOnInventDim);
                    }
                }
                QueryRun queryRun = new QueryRun(query);
                while (queryRun.next())
                {
                    fromInventTrans = queryRun.get(tableNum(InventTrans));
                    fromInventDim = queryRun.get(tableNum(InventDim));
                    numbersTransfered = true;

                    fromQty      = isReturn ? fromInventTrans.Qty      : -fromInventTrans.Qty;
                    pdsCWFromQty = isReturn ? fromInventTrans.PdsCWQty : -fromInventTrans.PdsCWQty;

                    if (inventDimParm.InventLocationIdFlag && fromInventDim.InventLocationId)
                    {
                        convInventLocation = TradeInterCompanyConv::construct();
                        convInventLocation.axInventLocationId(fromInterCompanyTradingValueMap, fromInventDim.InventLocationId);
                    }
                    // <GEERU>
                    if (inventDimParm.InventProfileIdFlag_RU && fromInventDim.InventProfileId_RU)
                    {
                        convInventProfile = TradeInterCompanyConv::construct();
                        convInventProfile.axInventProfileId(fromInterCompanyTradingValueMap, fromInventDim.InventProfileId_RU);
                    }
                    // </GEERU>

                    fromUnitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(fromInventTransOrigin.inventTable().inventUnitId());

                    changecompany(_toDataAreaId)
                    {
                        inventDimParmUpd.data(inventDimParm);

                        // clear batch/serial parm if necessary
                        // if the warehouse is sync'd, this can be done once up front
                        if (   isWHSEnabledItem
                            && inventDimParmUpd.InventLocationIdFlag)
                        {
                            inventDimParmUpd = this.finalInventDimensionsToTransfer(
                                                    inventDimParmUpd,
                                                    convInventLocation
                                                        ? convInventLocation.axInventLocationId(toInterCompanyTradingValueMap)
                                                        : '');
                        }

                        toUnitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(toInventTransOrigin.inventTable().inventUnitId());

                        if (fromUnitOfMeasureRecId != toUnitOfMeasureRecId)
                        {
                            fromQty = EcoResProductUnitConverter::convertForReleasedProduct(toInventTransOrigin.ItemId,
                                                                                            toInventTransOrigin.ItemInventDimId,
                                                                                            fromQty,
                                                                                            fromUnitOfMeasureRecId,
                                                                                            toUnitOfMeasureRecId,
                                                                                            NoYes::Yes);
                        }

                        toInventTrans = null;

                        if (isReturn)
                        {
                            toInventTransOrigin = this.returnToInventTransOrigin(_toInventTransId);
                        }

                        var transferredQuantities = this.calculateAlreadyTransferredQuantities(
                                                            toInventTransOrigin,
                                                            fromInventDim,
                                                            inventDimParmUpd);

                        if (!isCancelOrCorrect)
                        {
                            fromQty      -= transferredQuantities.parmInventQty();
                            pdsCWFromQty -= transferredQuantities.parmCwQty();
                        }
                        else
                        {
                            fromQty      = fromQty <= transferredQuantities.parmInventQty() ? fromQty : transferredQuantities.parmInventQty();
                            pdsCWFromQty = pdsCWFromQty <= transferredQuantities.parmCwQty() ? pdsCWFromQty : transferredQuantities.parmCwQty();
                        }

                        toInventTransRecIdLast = 0;
                        toStatusReceiptLast = StatusReceipt::None;

                        while (fromQty > 0)
                        {
                            refInventTrans = null;

                            if (!isCancelOrCorrect)
                            {
                                select firstonly forupdate toInventTrans
                                    order by StatusReceipt desc,RecId asc
                                    where toInventTrans.InventTransOrigin == toInventTransOrigin.RecId
                                        && toInventTrans.StatusIssue == StatusIssue::None
                                        && toInventTrans.InterCompanyInventDimTransferred == false
                                        && (toInventTrans.StatusReceipt == StatusReceipt::Ordered
                                            || (toInventTrans.StatusReceipt == StatusReceipt::Received && _overDelivery))
                                        && ((toInventTrans.StatusReceipt == toStatusReceiptLast && toInventTrans.RecId > toInventTransRecIdLast)
                                            || toInventTrans.StatusReceipt < toStatusReceiptLast
                                            || toStatusReceiptLast == StatusReceipt::None);
                            }
                            else
                            {
                                toInventTrans = this.findToInventTrans(toInventTransOrigin, _overDelivery, inventDimJoin, fromInventDim, inventDimParmUpd, toStatusReceiptLast, toInventTransRecIdLast);
                            }

                            if (!toInventTrans)
                            {
                                break;
                            }

                            toStatusReceiptLast    = toInventTrans.StatusReceipt;
                            toInventTransRecIdLast = toInventTrans.RecId;

                            toInventDim = InventDim::find(toInventTrans.InventDimId);

                            // clear batch/serial parm if necessary
                            // if the warehouse is not sync'd, this needs to be done for every transaction
                            if (!inventDimParmUpd.InventLocationIdFlag)
                            {
                                inventDimParmUpd = this.finalInventDimensionsToTransfer(
                                                        inventDimParmUpd,
                                                        toInventDim.InventLocationId);
                            }

                            if (this.canTransferInventDim(inventDimParmUpd))
                            {
                                inventTransUpd = InventTrans::findRecId(toInventTrans.RecId, true);

                                if (!isCancelOrCorrect)
                                {
                                    /*
                                        Un-reserve the marked transactions since we are going to change dimensions on the receipts they are marked against.
                                        This should only be done once per Lot ID since it will remove reservations for the full reservOrdered quantity on a lot.
                                        The full re-reservation based on marking is done in the end by calling updateReserveRefTransIdOnOrder().
                                    */
                                    if (toInventTrans.MarkingRefInventTransOrigin && !setOfIssueInventTransOriginIds.in(toInventTrans.MarkingRefInventTransOrigin))
                                    {
                                        setOfIssueInventTransOriginIds.add(toInventTrans.MarkingRefInventTransOrigin);
                                        refInventTrans = InventTrans::findByInventTransOrigin(toInventTrans.MarkingRefInventTransOrigin);
                                        if (refInventTrans)
                                        {
                                            movement = InventMovement::construct(refInventTrans);
                                            if (movement.transIdSum().reserveOrdered())
                                            {
                                                reservation = InventUpd_Reservation::newParameters(movement, null, null, 0, -movement.transIdSum().reserveOrdered(), true, false, -movement.transIdSum().pdsCWReserveOrdered());
                                                reservation.updateNow();
                                            }
                                        }
                                    }
                                
                                    inventDimUpd   = InventDim::find(inventTransUpd.InventDimId);

                                    Enumerator transferableDims = this.transferableDimensions().getEnumerator();
                                    while (transferableDims.moveNext())
                                    {
                                        FieldId inventDimParmFieldId = transferableDims.current();
                                        if (inventDimParmUpd.(inventDimParmFieldId))
                                        {
                                            FieldId inventDimFieldId = InventDim::dimParm2dim(inventDimParmFieldId);
                                            if (fromInventTransOrigin.ItemId != toInventTransOrigin.ItemId)
                                            {
                                                this.initializeInventDimFieldWhenItemRename(inventDimFieldId, inventDimUpd, _fromDataAreaId, fromInventDim, fromInventTransOrigin.ItemId, toInventTransOrigin.ItemId);
                                            }
                                            else
                                            {
                                                this.initializeInventDimField(inventDimFieldId, inventDimUpd, _fromDataAreaId, fromInventDim, toInventTransOrigin.ItemId);
                                            }
                                        }
                                    }
                                }

                                cwItem = PdsGlobal::pdsIsCWItem(inventTransUpd.ItemId);

                                if (cwItem)
                                {
                                    if (fromQty < inventTransUpd.Qty)
                                    {
                                        inventQtyAdjustment = this.pdsCalculateInventoryQuantityAdjustment(
                                            inventTransUpd.ItemId,
                                            inventTransUpd.PdsCWQty,
                                            inventTransUpd.Qty,
                                            pdsCWFromQty,
                                            fromQty);

                                        inventTransUpd.updateSplit(fromQty, min(pdsCWFromQty, inventTransUpd.PdsCWQty));
                                    }
                                    else
                                    {
                                        if (pdsCWFromQty < inventTransUpd.PdsCWQty)
                                        {
                                            inventTransUpd.updateSplit(
                                                min(fromQty, inventTransUpd.Qty - PdsCatchWeight::minInventQty(
                                                    inventTransUpd.ItemId,
                                                    InventTransUpd.PdsCWQty - pdsCWFromQty)),
                                                pdsCWFromQty);
                                        }

                                        inventQtyAdjustment = fromQty - inventTransUpd.Qty;
                                    }
                                }
                                else
                                {
                                    if (fromQty < inventTransUpd.Qty)
                                    {
                                        inventTransUpd.updateSplit(fromQty);
                                    }
                                }

                                if (!isCancelOrCorrect)
                                {
                                    inventDimUpd = InventDim::findOrCreate(inventDimUpd);
                                    inventTransUpd.InventDimId = inventDimUpd.InventDimId;
                                    inventTransUpd.InterCompanyInventDimTransferred = true;
                                    inventUpdate = InventUpdate::newChangeTransDim(inventTransUpd.inventMovement());
                                    inventUpdate.parmAllowAutoReserveDim(false);
                                    inventUpdate.writeInventTrans(inventTransUpd,inventTransUpd.orig(),false);

                                    // this is triggered  by a direct delivery
                                    if (_registerReceipt)
                                    {
                                        // also include the registered transactions when finding marked transactions
                                        onlyUseOnOrderTransForReservation = false;
                                        movementRegistration = inventTransUpd.inventMovement();
                                        movementRegistration.inventDimGroupSetup().inventDimParmActive(inventDimParmRegistration);
                                        registered = InventUpd_Registered::newParameters(movementRegistration,inventTransUpd.inventDim(),inventDimParmUpd,inventTransUpd.inventDim(),inventDimParmUpd,inventTransUpd.Qty);
                                        registered.parmPreferedInventTransRecId(inventTransUpd.RecId);

                                        /*
                                            If the receipt is marked we don't want the quantity to be given to any ReservOrdered transactions
                                            because we want the quantity to go the marked issues which is handled in the end when calling updateReserveRefTransIdOnOrder.
                                        */
                                        if (inventTransUpd.MarkingRefInventTransOrigin)
                                        {
                                            registered.parmAllowAutoReserveDim(false);
                                        }
                                        registered.updateNow();
                                    }
                                }
                                else
                                {
                                    inventTransUpd.InterCompanyInventDimTransferred = false;
                                    inventTransUpd.update();
                                }

                                if (cwItem)
                                {
                                    // Re-distribute non-zero inventory quantity from inventory transaction with zero catch weight quantity, among related marked transactions.
                                    if (inventTransUpd.Qty != 0 && inventTransUpd.PdsCWQty == 0)
                                    {
                                        // Find related transactions that are marked
                                        InventTrans inventTransWithMarking;
                                        select firstonly RecId from inventTransWithMarking
                                        where   inventTransWithMarking.InventTransOrigin == inventTransUpd.InventTransOrigin
                                             && inventTransWithMarking.Qty      != 0
                                             && inventTransWithMarking.PdsCWQty != 0
                                             && inventTransWithMarking.MarkingRefInventTransOrigin != 0;

                                        // Skip distribution qty on marked transaction if there is no existing marking transaction
                                        if (inventTransWithMarking.RecId && !InventMovement::construct(inventTransUpd).pdsDistributeInventQtyOnMarkedTrans(inventTransUpd.Qty))
                                        {
                                            throw error("@SYS4000146");
                                        }
                                    }

                                    // Merge the inventory transactions which only quantities are different
                                    inventTransUpd.updateSumUp();
                                    // Adjust inventory quantities for CW item based inventory transactions

                                    if (inventQtyAdjustment)
                                    {
                                        if (!inventUpdate)
                                        {
                                            inventUpdate = InventUpdate::newChangeTransDim(inventTransUpd.inventMovement());
                                            inventUpdate.parmAllowAutoReserveDim(false);
                                        }
                                        inventUpdate.pdsAdjustInventoryQuantity(inventQtyAdjustment);

                                        inventQtyAdjustment = 0;
                                    }
                                }

                                if (fromQty < toInventTrans.Qty)
                                {
                                    fromQty = 0;
                                }
                                else
                                {
                                    fromQty -= inventTransUpd.Qty;
                                }

                                if (cwItem)
                                {
                                    if (pdsCWFromQty < toInventTrans.PdsCWQty)
                                    {
                                        pdsCWFromQty = 0;
                                    }
                                    else
                                    {
                                        pdsCWFromQty -= inventTransUpd.PdsCWQty;
                                    }
                                }
                            }
                        }
                    }
                }


                /*
                    We need to make sure that the marked issues are updated to ReservOrdered again to match any new dimensions e.g. serial numbers that was assigned to the receipts.
                    This only needs to be done once per movement so it is postponed until after the update of all receipts in _toDataAreaId
                */
                if (!isCancelOrCorrect && setOfIssueInventTransOriginIds.elements() > 0)
                {
                    changecompany(_toDataAreaId)
                    {
                        this.updateReserveRefTransIdOnOrder(setOfIssueInventTransOriginIds,onlyUseOnOrderTransForReservation);
                    }
                }
                ttscommit;
            }
        }

        return numbersTransfered;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;
        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVersioningUpdateType</Name>
				<Source><![CDATA[
    public VersioningUpdateType parmVersioningUpdateType(VersioningUpdateType _versioningUpdateType = versioningUpdateType)
    {
        versioningUpdateType = _versioningUpdateType;
        return versioningUpdateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimField</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a dimension on the passed <c>InventDim</c> record, and ensures related dimensions are created.
    /// </summary>
    /// <param name = "_inventDimFieldId">The invent dimension to initialize.</param>
    /// <param name = "_inventDim">The invent dimension to initialize.</param>
    /// <param name = "_fromDataAreaId">The data area to initialize from.</param>
    /// <param name = "_fromInventDim">The invent dimension to initialize from.</param>
    /// <param name = "_itemId">The item id.</param>
    protected void initializeInventDimField(
        FieldId                       _inventDimFieldId,
        InventDim                     _inventDim,
        DataAreaId                    _fromDataAreaId,
        InventDim                     _fromInventDim, 
        ItemId                        _itemId 
        )
    {
        #InventDimDevelop

        switch (_inventDimFieldId)
        {
            case fieldNum(InventDim, InventLocationId):
                _inventDim.InventLocationId = convInventLocation.axInventLocationId(toInterCompanyTradingValueMap);
                _inventDim.initFromInventLocation(_inventDim.inventLocation());
                break;

            // <GEERU>
            case fieldNum(InventDim, InventProfileId_RU):
                _inventDim.InventProfileId_RU = convInventProfile.axInventProfileId(toInterCompanyTradingValueMap);
                break;
            // </GEERU>

            case fieldNum(InventDim, InventBatchId):
                _inventDim.InventBatchId = _fromInventDim.InventBatchId;
                if (!InventBatch::exist(_inventDim.InventBatchId, _itemId))
                {
                    InventBatch fromInventBatch;
                    changeCompany(_fromDataAreaId)
                    {
                        fromInventBatch = InventBatch::find(_fromInventDim.inventBatchId, _itemId);
                    }

                    InventBatch inventBatch;
                    inventBatch.ItemId              = _itemId;
                    inventBatch.InventBatchId       = _inventDim.InventBatchId;
                    inventBatch.PdsVendBatchId 	    = _inventDim.InventBatchId;
                    inventBatch.PdsVendBatchDate    = fromInventBatch.ProdDate;
                    inventBatch.PdsVendExpiryDate   = fromInventBatch.ExpDate;
                    inventBatch.PdsShelfAdviceDate  = fromInventBatch.PdsShelfAdviceDate;
                    inventBatch.PdsBestBeforeDate   = fromInventBatch.PdsBestBeforeDate;
                    inventBatch.PdsUseVendBatchDate = NoYes::Yes;
                    inventBatch.PdsUseVendBatchExp  = NoYes::Yes;
                    inventBatch.insert();
                }
                break;

            case fieldNum(InventDim, InventSerialId):
                _inventDim.InventSerialId = _fromInventDim.InventSerialId;
                if (!InventSerial::exist(_inventDim.InventSerialId, _itemId))
                {
                    InventSerial fromInventSerial;
                    changeCompany(_fromDataAreaId)
                    {
                        fromInventSerial = InventSerial::find(_fromInventDim.InventSerialId, _itemId);
                    }
                    InventSerial inventSerial;
                    inventSerial.ItemId         = _itemId;
                    inventSerial.InventSerialId = _inventDim.InventSerialId;
                    inventSerial.ProdDate       = fromInventSerial.ProdDate;
                    inventSerial.insert();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventDimFieldWhenItemRename</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a dimension on the passed <c>InventDim</c> record, and ensures related dimensions are created when renaming item.
    /// </summary>
    /// <param name = "_inventDimFieldId">The invent dimension to initialize.</param>
    /// <param name = "_inventDim">The invent dimension to initialize.</param>
    /// <param name = "_fromDataAreaId">The data area to initialize from.</param>
    /// <param name = "_fromInventDim">The invent dimension to initialize from.</param>
    /// <param name = "_fromItemId">The from company item id.</param>
    /// <param name = "_toItemId">The to company item id.</param>
    protected void initializeInventDimFieldWhenItemRename(
        FieldId                       _inventDimFieldId,
        InventDim                     _inventDim,
        DataAreaId                    _fromDataAreaId,
        InventDim                     _fromInventDim,
        ItemId                        _fromItemId,
        ItemId                        _toItemId
        )
    {
        #InventDimDevelop

        switch (_inventDimFieldId)
        {
            case fieldNum(InventDim, InventLocationId):
                _inventDim.InventLocationId = convInventLocation.axInventLocationId(toInterCompanyTradingValueMap);
                _inventDim.initFromInventLocation(_inventDim.inventLocation());
                break;

            // <GEERU>
            case fieldNum(InventDim, InventProfileId_RU):
                _inventDim.InventProfileId_RU = convInventProfile.axInventProfileId(toInterCompanyTradingValueMap);
                break;
            // </GEERU>

            case fieldNum(InventDim, InventBatchId):
                _inventDim.InventBatchId = _fromInventDim.InventBatchId;
                if (!InventBatch::exist(_inventDim.InventBatchId, _toItemId))
                {
                    InventBatch fromInventBatch;
                    changeCompany(_fromDataAreaId)
                    {
                        fromInventBatch = InventBatch::find(_fromInventDim.inventBatchId, _fromItemId);
                    }

                    InventBatch inventBatch;
                    inventBatch.ItemId              = _toItemId;
                    inventBatch.InventBatchId       = _inventDim.InventBatchId;
                    inventBatch.PdsVendBatchId 	    = _inventDim.InventBatchId;
                    inventBatch.PdsVendBatchDate    = fromInventBatch.ProdDate;
                    inventBatch.PdsVendExpiryDate   = fromInventBatch.ExpDate;
                    inventBatch.PdsShelfAdviceDate  = fromInventBatch.PdsShelfAdviceDate;
                    inventBatch.PdsBestBeforeDate   = fromInventBatch.PdsBestBeforeDate;
                    inventBatch.PdsUseVendBatchDate = NoYes::Yes;
                    inventBatch.PdsUseVendBatchExp  = NoYes::Yes;
                    inventBatch.insert();
                }
                break;

            case fieldNum(InventDim, InventSerialId):
                _inventDim.InventSerialId = _fromInventDim.InventSerialId;
                if (!InventSerial::exist(_inventDim.InventSerialId, _toItemId))
                {
                    InventSerial fromInventSerial;
                    changeCompany(_fromDataAreaId)
                    {
                        fromInventSerial = InventSerial::find(_fromInventDim.InventSerialId, _fromItemId);
                    }
                    InventSerial inventSerial;
                    inventSerial.ItemId         = _toItemId;
                    inventSerial.InventSerialId = _inventDim.InventSerialId;
                    inventSerial.ProdDate       = fromInventSerial.ProdDate;
                    inventSerial.insert();
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReserveRefTransIdOnOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Attempts to update the reservations for marked inventory transactions that has status On order.
    /// </summary>
    /// <param name="_setOfIssueInventTransOriginIds">
    ///    A set containing the <c>InventTransOriginId</c> IDs of the marked issue transactions that should be updated.
    /// </param>
    /// <param name="_onlyUseOnOrderTransForReservation">
    ///    A Boolean value that specifies whether only Ordered transactions should be used when doing the reservation update.
    ///    If this value is set to true, registered transactions are also included when finding quantities that can be used for reservation.
    /// </param>
    protected void updateReserveRefTransIdOnOrder(
        Set     _setOfIssueInventTransOriginIds,
        boolean _onlyUseOnOrderTransForReservation = true)
    {
        SetEnumerator           se;
        InventTransOriginId     inventTransOriginId;
        InventTrans             inventTransIssue;
        InventMovement          movement;

        if (!_setOfIssueInventTransOriginIds)
        {
            return;
        }

        se = _setOfIssueInventTransOriginIds.getEnumerator();

        while (se.moveNext())
        {
            inventTransOriginId = se.current();

            inventTransIssue = InventTrans::findByInventTransOrigin(inventTransOriginId);

            if (inventTransIssue.RecId)
            {
                movement = InventMovement::construct(inventTransIssue);
                InventUpd_Reservation::updateReserveRefTransId(movement,_onlyUseOnOrderTransForReservation);

                if (movement.isItemWHSEnabled())
                {
                    movement.checkWHSLoadLineInventTransConsistency();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Instantiates the class based on a record buffer.
    /// </summary>
    /// <param name="_common">
    ///    The record buffer used for construction.
    /// </param>
    /// <returns>
    ///    An object of the class depending on the received record buffer.
    /// </returns>
    public static InterCompanyTransferInventDim construct(Common _common)
    {
        InterCompanyTransferInventDim       interCompanyTransferInventDim;
        InventTrans                         inventTrans;
        InventTransOrigin                   inventTransOrigin;
        PurchLine                           purchLine;
        SalesLine                           salesLine;

        switch (_common.TableId)
        {
            case tableNum(CustInvoiceJour)      : interCompanyTransferInventDim = new InterCompanyTransferInventDim_Journal(_common);       break;
            case tableNum(CustPackingSlipJour)  : interCompanyTransferInventDim = new InterCompanyTransferInventDim_Journal(_common);       break;
            case tableNum(InventTrans)          :
                inventTrans = _common;
                inventTransOrigin = inventTrans.inventTransOrigin();

                switch (inventTransOrigin.ReferenceCategory)
                {
                    case InventTransType::Purch :
                        purchLine = InventTransOriginPurchLine::purchLine(inventTrans.InventTransOrigin);
                        interCompanyTransferInventDim = new InterCompanyTransferInventDim_PurchLine(purchLine);
                        break;
                    case InventTransType::Sales :
                        salesLine = InventTransOriginSalesLine::salesLine(inventTrans.InventTransOrigin);
                        interCompanyTransferInventDim = new InterCompanyTransferInventDim_SalesLine(salesLine);
                        break;
                    default                       : throw error(strFmt("@SYS23396",funcName()));
                }
                break;
            case tableNum(PurchLine)            : interCompanyTransferInventDim = new InterCompanyTransferInventDim_PurchLine(_common);     break;
            case tableNum(SalesLine)            : interCompanyTransferInventDim = new InterCompanyTransferInventDim_SalesLine(_common);     break;
            case tableNum(VendInvoiceJour)      : interCompanyTransferInventDim = new InterCompanyTransferInventDim_Journal(_common);       break;
            case tableNum(VendPackingSlipJour)  : interCompanyTransferInventDim = new InterCompanyTransferInventDim_Journal(_common);       break;

            default                               : throw error(strFmt("@SYS23396",funcName()));
        }

        return interCompanyTransferInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Used when the inventory dimensions is transferred without any user action.
    /// </summary>
    /// <param name="_fromDataAreaId">
    ///    The company from which the <c>_fromInventTransId</c> originates.
    /// </param>
    /// <param name="_fromInventTransId">
    ///    The lot ID from which the inventory dimensions are transferred.
    /// </param>
    /// <param name="_toDataAreaId">
    ///    The company from which the <c>_toInventTransId</c> originates.
    /// </param>
    /// <param name="_toInventTransId">
    ///    The lot ID to which the inventory dimensions are to be transferred.
    /// </param>
    /// <param name="_actionPolicyTransfer">
    ///    The intercompany action policy record containing information about which dimensions to transfer.
    /// </param>
    /// <param name="_statusIssue">
    ///    The highest issue status to search for on the lot ID to transfer to.
    /// </param>
    /// <param name="_documentNum">
    ///    A document number used when transferring a specific document (packing slip number or invoice number); optional.
    /// </param>
    /// <param name="_registerReceipt">
    ///    Whether to use a receipt registration when transferring as part of intercompany direct delivery posting; optional.
    /// </param>
    /// <param name="_forceTransfer">
    ///    Whether to force transfer when transferring invent dimensions automatically; optional.
    /// </param>
    /// <param name="_overDelivery">
    ///    A Boolean value determining whether over delivery is allowed when fetching the <c>InventTrans</c> records; optional.
    /// </param>
    public static void doTransfer(
        DataAreaId                               _fromDataAreaId,
        InventTransId                            _fromInventTransId,
        DataAreaId                               _toDataAreaId,
        InventTransId                            _toInventTransId,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer,
        StatusIssue                              _statusIssue,
        Num                                      _documentNum     = '',
        boolean                                  _registerReceipt = false,
        boolean                                  _forceTransfer   = false,
        boolean                                  _overDelivery    = false)
    {
        InterCompanyTransferInventDim interCompanyTransferInventDim = new InterCompanyTransferInventDim(null);
        interCompanyTransferInventDim.transfer(_fromDataAreaId,_fromInventTransId,_toDataAreaId,_toInventTransId,_actionPolicyTransfer,_statusIssue,_documentNum,_registerReceipt,_forceTransfer,_overDelivery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTransferWithVersioningTypeAndVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Used when the inventory dimensions is transferred without any user action.
    /// </summary>
    /// <param name="_fromDataAreaId">
    ///    The company from which the <c>_fromInventTransId</c> originates.
    /// </param>
    /// <param name="_fromInventTransId">
    ///    The lot ID from which the inventory dimensions are transferred.
    /// </param>
    /// <param name="_toDataAreaId">
    ///    The company from which the <c>_toInventTransId</c> originates.
    /// </param>
    /// <param name="_toInventTransId">
    ///    The lot ID to which the inventory dimensions are to be transferred.
    /// </param>
    /// <param name="_actionPolicyTransfer">
    ///    The intercompany action policy record containing information about which dimensions to transfer.
    /// </param>
    /// <param name="_statusIssue">
    ///    The highest issue status to search for on the lot ID to transfer to.
    /// </param>
    /// <param name="_documentNum">
    ///    A document number used when transferring a specific document (packing slip number or invoice number); optional.
    /// </param>
    /// <param name="_registerReceipt">
    ///    Whether to use a receipt registration when transferring as part of intercompany direct delivery posting; optional.
    /// </param>
    /// <param name="_forceTransfer">
    ///    Whether to force transfer when transferring invent dimensions automatically; optional.
    /// </param>
    /// <param name="_overDelivery">
    ///    A Boolean value determining whether over delivery is allowed when fetching the <c>InventTrans</c> records; optional.
    /// </param>
    /// </param>
    /// <param name="_versioningUpdateType">
    ///    current operation type.
    ///    if versioningUpdateType is cancel / correction, set the field value InventTrans.InterCompanyInventDimTransferred as false in intercompany when the inventory dimensions were transferred before but now cancelled.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    current voucher number.
    public static void doTransferWithVersioningTypeAndVoucher(
        DataAreaId                               _fromDataAreaId,
        InventTransId                            _fromInventTransId,
        DataAreaId                               _toDataAreaId,
        InventTransId                            _toInventTransId,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer,
        StatusIssue                              _statusIssue,
        Num                                      _documentNum     = '',
        boolean                                  _registerReceipt = false,
        boolean                                  _forceTransfer   = false,
        boolean                                  _overDelivery    = false,
        VersioningUpdateType                     _versioningUpdateType = VersioningUpdateType::Initial,
        Voucher                                  _ledgerVoucher = '')
    {
        InterCompanyTransferInventDim interCompanyTransferInventDim = new InterCompanyTransferInventDim(null);
        interCompanyTransferInventDim.parmVersioningUpdateType(_versioningUpdateType);
        interCompanyTransferInventDim.parmVoucher(_ledgerVoucher);
        interCompanyTransferInventDim.transfer(_fromDataAreaId,_fromInventTransId,_toDataAreaId,_toInventTransId,_actionPolicyTransfer,_statusIssue,_documentNum,_registerReceipt,_forceTransfer,_overDelivery);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doTransferReturn</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Used when the inventory dimensions is transferred without any user action for return orders.
    /// </summary>
    /// <param name="_fromDataAreaId">
    ///    The company from which the <c>_fromInventTransId</c> originates.
    /// </param>
    /// <param name="_fromInventTransId">
    ///    The lot ID from which the inventory dimensions are transferred.
    /// </param>
    /// <param name="_toDataAreaId">
    ///    The company from which the <c>_toInventTransId</c> originates.
    /// </param>
    /// <param name="_toInventTransId">
    ///    The lot ID to which the inventory dimensions are to be transferred.
    /// </param>
    /// <param name="_actionPolicyTransfer">
    ///    The intercompany action policy record containing information about which dimensions to transfer.
    /// </param>
    /// <param name="_statusReceipt">
    ///    The highest Receipt to search for on the lot ID to transfer to.
    /// </param>
    /// <param name="_registerReceipt">
    ///    Whether to use a receipt registration when transferring as part of intercompany direct delivery posting; optional.
    /// </param>
    /// <param name="_forceTransfer">
    ///    Whether to force transfer when transferring invent dimensions automatically; optional.
    /// </param>
    public static void doTransferReturn(
        DataAreaId                               _fromDataAreaId,
        InventTransId                            _fromInventTransId,
        DataAreaId                               _toDataAreaId,
        InventTransId                            _toInventTransId,
        InterCompanyEndpointActionPolicyTransfer _actionPolicyTransfer,
        StatusReceipt                            _statusReceipt,
        boolean                                  _registerReceipt = false,
        boolean                                  _forceTransfer   = false)
    {
        InterCompanyTransferInventDim    interCompanyTransferInventDim;

        interCompanyTransferInventDim = new InterCompanyTransferInventDim(null);
        interCompanyTransferInventDim.transfer(_fromDataAreaId,
                                               _fromInventTransId,
                                               _toDataAreaId,
                                               _toInventTransId,
                                               _actionPolicyTransfer,
                                               StatusIssue::None,
                                               '',
                                               _registerReceipt,
                                               _forceTransfer,
                                               false,
                                               _statusReceipt);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findRelatedIntercompanyDimTransferred</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>InventDimId</c>.
    /// </summary>
    /// <param name="_inventTransId">
    /// The <c>InventTransId</c> for the inventory transaction.
    /// </param>
    /// <returns>
    /// A <c>InventDimId</c>.
    /// </returns>
    /// <remarks>
    /// Used for getting the right <c>InventDimId</c> for creating new inventory transaction in over delivery scenarios for intercompany orders.
    /// </remarks>
    public static InventDimId findRelatedIntercompanyDimTransferred(InventTransId   _inventTransId)
    {
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;

        select firstonly InventDimId from inventTrans
            order by StatusReceipt desc
                where inventTrans.InterCompanyInventDimTransferred == NoYes::Yes
                   && (inventTrans.StatusReceipt >= StatusReceipt::Purchased
                   &&  inventTrans.StatusReceipt <= StatusReceipt::Registered)
                   &&  inventTrans.StatusIssue   == StatusIssue::None
                        exists join inventTransOrigin
                            where inventTransOrigin.RecId          ==  inventTrans.InventTransOrigin
                               && inventTransOrigin.InventTransId  == _inventTransId;

        return inventTrans.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findInterCompanyDimTransferred</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns <c>InventDimId</c> from a given <c>InventTrans</c> if the <c>InventTrans</c> meets certain conditions.
    /// </summary>
    /// <param name = "_inventTransRecId">A <c>InventTrans</c> RecId</param>
    /// <returns>
    /// A <c>InventDimId</c>.
    /// </returns>
    internal static InventDimId findInterCompanyDimTransferred(RecId _inventTransRecId)
    {
        InventTrans inventTrans;

        select firstonly InventDimId from inventTrans
            where inventTrans.RecId == _inventTransRecId
                && inventTrans.InterCompanyInventDimTransferred == NoYes::Yes
                && inventTrans.StatusReceipt >= StatusReceipt::Purchased
                && inventTrans.StatusReceipt <= StatusReceipt::Registered
                && inventTrans.StatusIssue == StatusIssue::None;

        return inventTrans.InventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        InterCompanyTransferInventDim   interCompanyTransferInventDim;
        Object                          callerForm  = _args.caller();

        if (!_args.record())
        {
            throw error("@SYS25516");
        }

        switch (_args.record().TableId)
        {
            case tableNum(CustInvoiceJour)      : break;
            case tableNum(CustPackingSlipJour)  : break;
            case tableNum(InventTrans)          : break;
            case tableNum(VendInvoiceJour)      : break;
            case tableNum(VendPackingSlipJour)  : break;
            default                             : throw error(strFmt("@SYS23396",funcName()));
        }

        interCompanyTransferInventDim = InterCompanyTransferInventDim::construct(_args.record());
        interCompanyTransferInventDim.run();

        if (callerForm && formHasMethod(callerForm,identifierStr(doResearch)))
        {
            callerForm.doResearch(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCanSyncInventQty</Name>
				<Source><![CDATA[
    private boolean pdsCanSyncInventQty(
        DataAreaId      _fromDataAreaId,
        InventTransId   _fromInventTransId,
        DataAreaId      _toDataAreaId,
        InventTransId   _toInventTransId)
    {
        SalesLine salesLine;
        PurchLine purchLine;
        UnitOfMeasureSymbol toInventTransUnit;
        UnitOfMeasureSymbol fromInventTransUnit;

        changecompany(_toDataAreaId)
        {
            purchLine = PurchLine::findInventTransId(_toInventTransId);
            toInventTransUnit = InventTableModule::find(purchLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        }

        changecompany(_fromDataAreaId)
        {
            salesLine = SalesLine::findInventTransId(_fromInventTransId);
            fromInventTransUnit = InventTableModule::find(salesLine.ItemId, ModuleInventPurchSales::Invent).UnitId;
        }

        boolean isCatchWeight = PdsGlobal::pdsIsCWItem(salesLine.ItemId);

        PdsCWInventQty cwTotalFromQty = salesLine.PdsCWRemainInventFinancial;
        PdsCWInventQty cwTotalToQty = purchLine.PdsCWRemainInventFinancial + purchLine.PdsCWRemainInventPhysical;

        if (salesLine.RecId && purchLine.RecId && isCatchWeight && cwTotalFromQty == cwTotalToQty)
        {
            InventQty totalFromQty = salesLine.RemainInventFinancial;
            InventQty totalToQty = purchLine.RemainInventFinancial + purchLine.RemainInventPhysical;
            
            if (fromInventTransUnit != toInventTransUnit)
            {
                EcoResProductUnitConverter unitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                                                        salesLine.InventDimId,
                                                                                                                        fromInventTransUnit,
                                                                                                                        toInventTransUnit,
                                                                                                                        NoYes::Yes);

                if (unitConverter.canValueBeConverted())
                {
                    totalFromQty = unitConverter.convertValue(totalFromQty);
                }
            }

            return (totalFromQty > totalToQty);
        }
        else 
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncRemainPhysicalForDelivery</Name>
				<Source><![CDATA[
    private void syncRemainPhysicalForDelivery(
        DataAreaId      _fromDataAreaId,
        InventTransId   _fromInventTransId,
        DataAreaId      _toDataAreaId,
        InventTransId   _toInventTransId,
        StatusIssue     _statusIssue)
    {
        if (_statusIssue == StatusIssue::None)
        {
            return; // Not handling return flows.
        }

        InventQty totalToQty;
        PdsCWInventQty cwTotalToQty;
        UnitOfMeasureSymbol toInventTransUnit;
        SalesLine salesLine = SalesLine::findInventTransId(_fromInventTransId);
        changecompany(_toDataAreaId)
        {
            PurchLine purchLine = PurchLine::findInventTransId(_toInventTransId);
            toInventTransUnit = InventTableModule::find(purchLine.ItemId, ModuleInventPurchSales::Invent).UnitId;

            if (salesLine.OverDeliveryPct <= 0 && purchLine.DeliveryType != TradeLineDlvType::DropShip)
            {
                return; // Only relevant for direct delivery or over delivery
            }

            InventTransOrigin toInventTransOrigin = InventTransOrigin::findByInventTransId(_toInventTransId);

            InventTrans toInventTrans;
            select forceplaceholders sum(Qty), sum(PdsCWQty) from toInventTrans
                where toInventTrans.InventTransOrigin   == toInventTransOrigin.RecId
                    && toInventTrans.StatusIssue        == StatusIssue::None;

            totalToQty = toInventTrans.Qty;
            cwTotalToQty = toInventTrans.PdsCWQty;
        }

        InventTransOrigin fromInventTransOrigin = InventTransOrigin::findByInventTransId(_fromInventTransId);

        // Calculate the "from" quantities from inventory transactions, since deliver remainder is already zeroed
        // (we come here after sales transactions are already deducted).
        InventTrans fromInventTrans;
        select forceplaceholders sum(Qty), sum(PdsCWQty) from fromInventTrans
            where fromInventTrans.InventTransOrigin == fromInventTransOrigin.RecId
                && fromInventTrans.StatusIssue      <= _statusIssue
                && fromInventTrans.StatusReceipt    == StatusReceipt::None
                && fromInventTrans.PackingSlipReturned == NoYes::No;
                
        InventQty totalFromQty = -fromInventTrans.Qty;
        PdsCWInventQty cwTotalFromQty = -fromInventTrans.PdsCWQty;
                
        boolean isCatchWeight = PdsGlobal::pdsIsCWItem(salesLine.ItemId);

        UnitOfMeasureSymbol fromInventTransUnit = InventTableModule::find(salesLine.ItemId, ModuleInventPurchSales::Invent).UnitId;

        if (fromInventTransUnit != toInventTransUnit)
        {

            EcoResProductUnitConverter unitConverter = EcoResProductUnitConverter::newGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                                                        salesLine.InventDimId,
                                                                                                                        fromInventTransUnit,
                                                                                                                        toInventTransUnit,
                                                                                                                        NoYes::Yes);

            if (unitConverter.canValueBeConverted())
            {
                totalFromQty = unitConverter.convertValue(totalFromQty);
            }
        }

        boolean overdeliveryNotSynced = (!isCatchWeight && totalFromQty > totalToQty)
            || (isCatchWeight && cwTotalFromQty > cwTotalToQty);

        if (!overdeliveryNotSynced)
        {
            overdeliveryNotSynced = isCatchWeight && cwTotalFromQty == cwTotalToQty && totalFromQty > totalToQty;
        }

        if (overdeliveryNotSynced)
        {
            InventQty diffInventPhysical = totalToQty - totalFromQty;

            if (fromInventTransUnit != toInventTransUnit)
            {
                diffInventPhysical = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(salesLine.ItemId,
                                                                                                               salesLine.InventDimId,
                                                                                                               diffInventPhysical,
                                                                                                               toInventTransUnit,
                                                                                                               fromInventTransUnit,
                                                                                                               NoYes::Yes);
            }

            using (var context = IntercompanyTransferInventDimOverDeliveryContext::newFromParameter(true))
            {
                InterCompanyUpdateRemPhys::synchronize(
                    salesLine,
                    diffInventPhysical,
                    0, // Only working in inventory units here, leave qty in sales units as it is
                    InterCompanySkipUpdate::No,
                    cwTotalToQty - cwTotalFromQty);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findToInventTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds an <c>InventTrans</c> record.
    /// </summary>
    /// <param name = "_toInventTransOrigin">The inventory transaction origin.</param>
    /// <param name = "_overDelivery"> A Boolean value determining whether over delivery is allowed when fetching the <c>InventTrans</c> records.</param>
    /// <param name = "_inventDimJoin">The inventory dimensions.</param>
    /// <param name = "_fromInventDim">The invent dimension to initialize from.</param>
    /// <param name = "_inventDimParmUpd">The inventory dimension parameters.</param>
    /// <param name = "_toStatusReceiptLast">Status of quantity in relation to receipt.</param>
    /// <param name = "_toInventTransRecIdLast">RecId of <c>InventTrans</c>.</param>
    /// <returns>An <c>InventTrans</c> record.</returns>
    protected InventTrans findToInventTrans(InventTransOrigin	_toInventTransOrigin,
                                            boolean				_overDelivery,
                                            InventDim			_inventDimJoin,
                                            InventDim			_fromInventDim,
                                            InventDimParm		_inventDimParmUpd,
                                            StatusReceipt		_toStatusReceiptLast,
                                            RecId				_toInventTransRecIdLast)
    {
        InventTrans toInventTrans;

        select firstonly forupdate toInventTrans
            order by StatusReceipt desc,RecId asc
            where toInventTrans.InventTransOrigin == _toInventTransOrigin.RecId
                && (toInventTrans.StatusReceipt == StatusReceipt::Ordered
                    || (toInventTrans.StatusReceipt == StatusReceipt::Received && _overDelivery))
                && toInventTrans.StatusIssue == StatusIssue::None
                && toInventTrans.InterCompanyInventDimTransferred == true
                #inventDimJoin(toInventTrans.InventDimId, _inventDimJoin, _fromInventDim, _inventDimParmUpd)
                && ((toInventTrans.StatusReceipt == _toStatusReceiptLast && toInventTrans.RecId > _toInventTransRecIdLast)
                    || toInventTrans.StatusReceipt < _toStatusReceiptLast
                    || _toStatusReceiptLast == StatusReceipt::None);

        return toInventTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSynchronizationSuccessMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return message in case of synchronization success
    /// </summary>
    /// <returns>Message text</returns>
    protected str getSynchronizationSuccessMessage()
    {
        var message = "@SYS98954";

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            message = "@Inventory_Localization:SynchronizeBatchSerialGTDNumbersInfo";
        }

        return message;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSynchronizationFailedMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return message in case of synchronization failed
    /// </summary>
    /// <param name = "_statusIssue">Issue status of the caller</param>
    /// <returns>Message text</returns>
    protected str getSynchronizationFailedMessage(StatusIssue _statusIssue)
    {
        var message = strfmt("@SYS98955", _statusIssue);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            message = strfmt("@Inventory_Localization:SynchronizeBatchSerialGTDNumbersWarning", _statusIssue);
        }

        return message;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>