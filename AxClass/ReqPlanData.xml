<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ReqPlanData</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>ReqPlanData</c> class contains parameters and cache data for the current master planning run.
/// </summary>
public class ReqPlanData
{
    ReqPlanId                           reqPlanId;
    RefRecId                            reqPlanVersionRefRecId;
    ReqPlan                             reqPlan;

    ReqSetupCache                       reqSetupCache;
    ReqMemoryCacheCurrentSessionScope   memoryCacheCurrentSessionScope;

    boolean                             useSetupCache;
    boolean                             useSetupDimCache;
    boolean                             disableDbCache;
    boolean                             useReqTransCache;

    int                                 numberOfItemsProcessed = 0;

    ReqLog                              reqLog;
    ReqLog                              reqLogBackup;
    ReqLogCoverage                      reqLogCoverage;
    Integer                             logPoint;

    ReqTransCache                       reqTransCache;
    ReqCalcInMemoryCache                inMemoryCache;

    WorkCalendarSched                   workCalendarSched;

    ReqParameters                       reqParameters;

    TransDate                           todaysdate;

    ReqProcessId                        processId;

    Map                                 reqCovDimIdCache;

    ReqTraceLogger                      reqTraceLogger;
    LeanLocationCache                   leanLocationCache;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>actionUpdReqDatePurch</Name>
				<Source><![CDATA[
    public NoYes actionUpdReqDatePurch()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReqLog</Name>
				<Source><![CDATA[
    public void addReqLog(ReqTrans _reqTrans)
    {
        if (reqLog.ReqLogId)
        {
            reqLog.addReqTrans(_reqTrans.RefType,_reqTrans.IsForecastPurch);

            if (_reqTrans.RefType == ReqRefType::InventJournal)
            {
                if (_reqTrans.Qty > 0)
                {
                    reqLog.NumOfInventJournalReceipt++;
                }
                else
                {
                    reqLog.NumOfInventJournalIssue++;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addReqTransCache</Name>
				<Source><![CDATA[
    public void addReqTransCache(ReqTrans _reqTrans)
    {
        if (reqTransCache)
        {
            reqTransCache.add(_reqTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inMemoryCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the active instance of the in-memory cache.
    /// </summary>
    /// <returns>The active instance of the in-memory cache.</returns>
    public ReqCalcInMemoryCache inMemoryCache()
    {
        return inMemoryCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginInMemoryCacheScope</Name>
				<Source><![CDATA[
    /// <summary>
    /// Begins a scope in which the in-memory cache will be enabled.
    /// </summary>
    /// <returns>A disposable <c>ReqCalcInMemoryCacheScope</c> object which will disable the in-memory cache upon disposal.</returns>
    public ReqCalcInMemoryCacheScope beginInMemoryCacheScope()
    {
        if (inMemoryCache)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        inMemoryCache = ReqCalcInMemoryCache::construct();
        return ReqCalcInMemoryCacheScope::construct(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endInMemoryCacheScope</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the scope in which in-memory cache is enabled.
    /// </summary>
    public void endInMemoryCacheScope()
    {
        inMemoryCache = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bottleneckScheduling</Name>
				<Source><![CDATA[
    public SchedLimitBottleneck bottleneckScheduling()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForPickup</Name>
				<Source><![CDATA[
    private SalesCheckForPickup checkForPickup(ReqPO _reqPO)
    {
        return _reqPO.RefType == ReqRefType::TransferPlannedOrder
            ? SalesCheckForPickup::SecondCalendar
            : SalesCheckForPickup::Never;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covCapLimited</Name>
				<Source><![CDATA[
    public NoYes covCapLimited()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covPropertyLimited</Name>
				<Source><![CDATA[
    public NoYes covPropertyLimited()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covSchedMethod</Name>
				<Source><![CDATA[
    public ProdSchedMethod covSchedMethod()
    {
        return ProdSchedMethod::OperationScheduling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>covTimeFenceSchedBack</Name>
				<Source><![CDATA[
    public SchedTimeFenceBackSearchCap covTimeFenceSchedBack()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqLogRestorePoint</Name>
				<Source><![CDATA[
    void createReqLogRestorePoint()
    {
        reqLogBackup.data(reqLog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentReqPlanForecast</Name>
				<Source><![CDATA[
    public ReqPlanIdForecast currentReqPlanForecast()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>doActionCalc</Name>
				<Source><![CDATA[
    public boolean doActionCalc()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doAutoFirmPo</Name>
				<Source><![CDATA[
    public boolean doAutoFirmPo()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCalculateBatchExpiry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether batch expiry transactions must be calculated.
    /// </summary>
    /// <returns>true if batch expiry transactions must be calculated; otherwise, false</returns>
    internal boolean mustCalculateBatchExpiry()
    {
        return this.pdsUseShelfLife() && (this.doCovCalc() || this.doFuturesCalc());
    }

]]></Source>
			</Method>
			<Method>
				<Name>doCovCalc</Name>
				<Source><![CDATA[
    public boolean doCovCalc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doFuturesCalc</Name>
				<Source><![CDATA[
    public boolean doFuturesCalc()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dynamicNegativeDays</Name>
				<Source><![CDATA[
    public boolean dynamicNegativeDays()
    {
        return reqParameters.DynamicNegativeDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useItemFilterPreUpdate</Name>
				<Source><![CDATA[
    public boolean useItemFilterPreUpdate()
    {
        return reqParameters.ItemFilterPreUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useItemFilterPreCoverage</Name>
				<Source><![CDATA[
    public boolean useItemFilterPreCoverage()
    {
        return reqParameters.ItemFilterPreCoverage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNumberOfItemsProcessed</Name>
				<Source><![CDATA[
    public int parmNumberOfItemsProcessed(int _numberOfItemsProcessed = numberOfItemsProcessed)
    {
        numberOfItemsProcessed = _numberOfItemsProcessed;
        return numberOfItemsProcessed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastModelId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the inventory forecast model ID for the current master plan.
    /// </summary>
    /// <returns>
    ///    A string that contains the inventory forecast model ID.
    /// </returns>
    public ForecastModelId  forecastModelId()
    {
        return reqPlan.ForecastModelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresSched</Name>
				<Source><![CDATA[
    public NoYes futuresSched()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresUpdReqDateKanban</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether planned kanbans should be postponed to the futures date.
    /// </summary>
    /// <returns>
    ///    true if planned kanbans should be postponed to the futures date; otherwise, false.
    /// </returns>
    public NoYes futuresUpdReqDateKanban()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresUpdReqDatePurch</Name>
				<Source><![CDATA[
    public NoYes futuresUpdReqDatePurch()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>futuresUpdReqDateTransfer</Name>
				<Source><![CDATA[
    public NoYes futuresUpdReqDateTransfer()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSchedulingInPastPrevented</Name>
				<Source><![CDATA[
    public NoYes isSchedulingInPastPrevented()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReqCovDimIdCache</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the cache that is used for computing the MRP coverage dimension for the <c>ReqTrans</c>
    ///    records of type BOM line.
    /// </summary>
    /// <returns>
    ///    A <c>Map</c> that stores <c>[key=InventDimId#Item, value=CovInventDimId]</c>
    /// </returns>
    public Map getReqCovDimIdCache()
    {
        return reqCovDimIdCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>incrementRetryReqLog</Name>
				<Source><![CDATA[
    public void incrementRetryReqLog(Exception _exception)
    {
        switch (_exception)
        {
            case Exception::Deadlock        : reqLog.NumOfDeadLockRetry++; break;
            case Exception::UpdateConflict  : reqLog.NumOfUpdConflictRetry++; break;
            case Exception::Error           : reqLog.NumOfUnhandledErrorRetry++; break;
            case Exception::TransientSqlConnectionError : reqLog.NumOfTransientSqlConnectionErrorRetry++; break;

            default : throw error("@SYS107542");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an instance of the <c>ReqPlanData </c>class.
    /// </summary>
    /// <returns>
    ///    true if initialization succeeded; otherwise, false.
    /// </returns>
    public boolean init()
    {
        reqParameters   = ReqParameters::find();
        reqPlan         = ReqPlan::findReqPlanId(reqPlanId);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the master planning log record.
    /// </summary>
    /// <param name="_reqCalcUpdate">
    /// The type of master planning process (regeneration, net change, etc.)
    /// </param>
    /// <param name="_processId">
    /// The master planning process ID.
    /// </param>
    /// <param name="_clearLog">
    /// A flag that indicates whether to clear the infolog.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Thrown in case the number sequence for log entries does not exist.
    /// </exception>
    public void initReqLog(ReqCalcUpdate _reqCalcUpdate, ReqProcessId _processId, boolean _clearLog = true)
    {
        if (! NumberSequenceTable::checkExist(this.sequenceLogId()))
        {
            throw error("@SYS18447");
        }

        if (_clearLog)
        {
            infolog.clear(0);
        }

        logPoint                = infologLine();

        if (logPoint == 0)
        {
            logPoint = 1;
        }

        reqLog.clear();
        reqLog.ReqPlanId        = reqPlanId;
        reqLog.ReqLogId         = NumberSeq::newGetNumFromId(this.sequenceLogId()).num();
        reqLog.ProcessId        = _processId;

        reqLog.StartDateTime    = DateTimeUtil::getSystemDateTime();
        reqLog.ReqCalcUpdate    = _reqCalcUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqLogCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the coverage log which is used for coverage statistics.
    /// </summary>
    /// <param name="_processId">
    /// The master planning process ID.
    /// </param>
    public void initReqLogCoverage(ReqProcessId _processId)
    {
        reqLogCoverage = new ReqLogCoverage(_processId, curExt(), reqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initReqTransCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the requirements transactions cache.
    /// </summary>
    public void initReqTransCache()
    {
        if (!useReqTransCache)
        {
            reqTransCache = ReqTransCache_Periodic::newProcessId(reqPlanId, processId);
        }
        else
        {
            reqTransCache = ReqTransCache_Daily::newProcessId(reqPlanId, processId);
        }

        reqTransCache.parmReqPlanVersionRefRecId(this.parmReqPlanVersionRefRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertReqLog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a record in the master planning log table.
    /// </summary>
    /// <param name="_cancelled">
    /// true if the master planning has been cancelled; otherwise false.
    /// </param>
    /// <param name="_errors">
    /// true if an error has been encountered while processing an item or a general error has been encountered; otherwise false.
    /// </param>
    /// <param name="_isCompleteUpdate">
    /// true if running master planning with regeneration for all items; otherwise false.
    /// </param>
    /// <param name="_numOfChanges">
    /// Number of items handled by master planning.
    /// </param>
    /// <param name="_processId">
    /// The Id of the master planning run.
    /// </param>
    /// <param name="_comment">
    /// ReqComment containing a comment to be saved in the log entry.
    /// </param>
    public void insertReqLog(
        boolean         _cancelled,
        boolean         _errors,
        boolean         _isCompleteUpdate,
        ReqNumOfChanges _numOfChanges,
        ReqProcessId    _processId,
        ReqComment      _comment
        )
    {
        ReqProcessItem  reqProcessItem;
        ReqProcessList  reqProcessList;

        if (reqLog.ReqLogId)
        {
            ttsbegin;

            reqLog.Cancelled  = _cancelled;

            if (_cancelled)
            {
                //Also update the status of the process to cancelled
                update_recordset reqProcessList
                    setting Cancelled = true
                    where reqProcessList.ProcessId == _processId;
            }

            if (this.useItemFilterPreCoverage() && !this.useItemFilterPreUpdate())
            {
                reqLog.NumOfItems  = numberOfItemsProcessed;
            }
            else
            {
                select count(RecId) from reqProcessItem where reqProcessItem.ProcessId == processId;
                reqLog.NumOfItems  = int642int(reqProcessItem.RecId);
            }

            reqLog.NumOfLevels = reqTransCache.levelCount();

            reqLog.ProcessId           = _processId;
            reqLog.Comment             = _comment;

            reqLog.EndDateTime             = DateTimeUtil::getSystemDateTime();

            reqLog.UsedTodaysdate        = this.todaysdate();

            if (_errors)
            {
                reqLog.Log = infolog.copy(logPoint,infologLine());
            }

            reqLog.CompleteUpdate        = _isCompleteUpdate;
            reqLog.NumOfChanges          = _numOfChanges;

            ReqLog::insertUpdate(reqLog);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginCalendarDays</Name>
				<Source><![CDATA[
    public boolean marginCalendarDays()
    {
        return reqParameters.MarginCalendarDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginIssue</Name>
				<Source><![CDATA[
    public MarginIssue marginIssue(ReqSetupDim _setupDim)
    {
        return (_setupDim ? _setupDim.marginIssue() : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginOrder</Name>
				<Source><![CDATA[
    public MarginOrder  marginOrder(ReqSetupDim _setupDim)
    {
        return (_setupDim ? _setupDim.marginOrder() : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>marginReceipt</Name>
				<Source><![CDATA[
    public MarginReceipt marginReceipt(ReqSetupDim _setupDim)
    {
        return (_setupDim ? _setupDim.marginReceipt() : 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayTransBeActionAdvanced</Name>
				<Source><![CDATA[
    public boolean  mayTransBeActionAdvanced(
        ReqSetupDim  _setupDim,
        ReqTrans     _reqTrans)
    {
        if (_reqTrans.isStaticReceipt())
            return false;

        return _setupDim.mayItemBeActionAdvanced();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayTransBeActionCovFrom</Name>
				<Source><![CDATA[
    public boolean mayTransBeActionCovFrom(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans)
    {
        if (_reqTrans.Qty  < 0)
            return false;

        if (!_reqTrans.IsDerivedDirectly)
        {
            if (_reqTrans.isPlannedOrder())
            {
                return _setupDim.mayItemBeActionDecreased();
            }
            else
            if (_reqTrans.isStaticReceipt())
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayTransBeActionCovTo</Name>
				<Source><![CDATA[
    public boolean mayTransBeActionCovTo(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans,
        boolean         _inclPlannedOrder)
    {
        ReqTrans    reqTransLocal;

        if (! _reqTrans.isReceipt())
        {
            return false;
        }

        if (_reqTrans.RefType == ReqRefType::Sales || _reqTrans.RefType == ReqRefType::Quarantine)
        {
            return false;
        }

        if (_reqTrans.RefType == ReqRefType::TransferOrderReceive)
        {
            select firstonly RecId from reqTransLocal
                where reqTransLocal.PlanVersion             == reqPlanVersionRefRecId
                   && reqTransLocal.RefType                 == ReqRefType::TransferOrderShip
                   && reqTransLocal.RefId                   == _reqTrans.RefId;

            // If no coherent shipped requirement exist, the transfer has been shipped
            if (!reqTransLocal.RecId)
            {
                return false;
            }
        }

        if (_reqTrans.isPlannedOrder() && ! _inclPlannedOrder)
        {
            return false;
        }

        if (_reqTrans.isStaticReceipt())
        {
            return false;
        }

        if (! this.mustTransBeActionSet(_setupDim,_reqTrans))
        {
            return false;
        }

        if (! this.mayTransBeActionIncreased(_setupDim,_reqTrans))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayTransBeActionDecreased</Name>
				<Source><![CDATA[
    public boolean mayTransBeActionDecreased(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans)
    {
        if (_reqTrans.Qty  < 0)
            return false;

        if (_reqTrans.isStaticReceipt())
            return false;

        return _setupDim.mayItemBeActionDecreased();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayTransBeActionIncreased</Name>
				<Source><![CDATA[
    public boolean mayTransBeActionIncreased(
        ReqSetupDim    _setupDim,
        ReqTrans       _reqTrans)
    {
        if (_reqTrans.Qty  < 0)
            return false;

        return _setupDim.mayItemBeActionIncreased();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mayTransBeActionPostponed</Name>
				<Source><![CDATA[
    public boolean  mayTransBeActionPostponed(
        ReqSetupDim   _setupDim,
        ReqTrans      _reqTrans)
    {
        if (_reqTrans.isStaticReceipt())
            return false;

        return _setupDim.mayItemBeActionPostponed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrContinuityModelId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the inventory forecast model ID for the current master plan.
    /// </summary>
    /// <returns>
    ///     A string that contains the inventory forecast model ID.
    /// </returns>
    public MCRReqPlanIdContinuity  mcrContinuityModelId()
    {
        return reqPlan.mcrReqPlanIdContinuity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrIncludePastDueContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a <c>boolean</c> value indicating whether to include past due continuity forecast orders.
    /// </summary>
    /// <returns>
    ///     A <c>NoYes</c> indicating whether to include past due continuity forcast orders.
    /// </returns>
    NoYes mcrIncludePastDueContinuity()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMustContinuityInventBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the continuity invent records should be created.
    /// </summary>
    /// <param name="_setupDim">
    ///     The <c>ReqSetupDim</c> to check.
    /// </param>
    /// <param name="_mcrContinuityCustLine">
    ///     The <c>MCRContinuityCustLine</c> to check.
    /// </param>
    /// <returns>
    ///     true if continuity records should be created; otherwise, false.
    /// </returns>
    boolean  mcrMustContinuityInventBeCreated(ReqSetupDim _setupDim, MCRContinuityCustLine _mcrContinuityCustLine)
    {
        if (!_setupDim.setup().mustItemReqBeCreated())
        {
            return false;
        }

        if (this.timeFenceCoverage(_setupDim) <= 0)
        {
            return false;
        }

        if (_mcrContinuityCustLine.StartDate >= this.todaysdate() + this.timeFenceCoverage(_setupDim))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrMustContinuityMasterPlanBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether continuity master planning records should be created.
    /// </summary>
    /// <param name="_setupDim">
    /// The <c>ReqSetupDim</c> to check.
    /// </param>
    /// <param name="_reqDate">
    /// The <c>ReqDate</c> to check.
    /// </param>
    /// <returns>
    /// true if continuity master planning records should be created; otherwise, false.
    /// </returns>
    public boolean  mcrMustContinuityMasterPlanBeCreated(
        ReqSetupDim   _setupDim,
        ReqDate       _reqDate)
    {
        if (!_setupDim.setup().mustItemReqBeCreated())
        {
            return false;
        }

        if (this.mcrTimeFenceContinuityMasterPlan(_setupDim) <= 0)
        {
            return false;
        }

        if (_reqDate >= this.todaysdate() + this.mcrTimeFenceContinuityMasterPlan(_setupDim))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPastDueContinuityDays</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a an integer indicating how many days past due to include for continuity forecast orders.
    /// </summary>
    /// <returns>
    ///     An <c>int</c> value indicating the number of days past due to include for continity forecast orders.
    /// </returns>
    int mcrPastDueContinuityDays()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrPlanVersionContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the <c>RefRecId</c> for the continuity plan version.
    /// </summary>
    /// <returns>
    ///     The <c>RefRecId</c> of the related continuity plan.
    /// </returns>
    public RefRecId mcrPlanVersionContinuity()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrTimeFenceContinuityMasterPlan</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the time fence for the specified request group Id.
    /// </summary>
    /// <param name="_setupDim">
    /// The <c>ReqSetupDim</c> used to lookup the time fence.
    /// </param>
    /// <returns>
    /// The <c>TimeFenceMasterPlan</c> value for the specified <c>ReqSetupDim</c> or 0, if the
    /// <c>ReqSetupDim</c> is null.
    /// </returns>
    public TimeFenceMasterPlan mcrTimeFenceContinuityMasterPlan(ReqSetupDim _setupDim)
    {
        return _setupDim ? ReqGroup::find(_setupDim.reqGroupId()).MasterPlanTimeFence: 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUseContinuityPlan</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a <c>NoYes</c> indicating whether to use continuity plan.
    /// </summary>
    /// <returns>
    ///     A <c>NoYes</c> indicating whether or not to use continuity plan.
    /// </returns>
    NoYes mcrUseContinuityPlan()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrUseProbabilisticContinuity</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a <c>NoYes</c> indicating whether to multiply a probability factor for
    ///     the continuity demand that is generated during continuity scheduling.
    /// </summary>
    /// <returns>
    ///     yes if the probability factor should be multiplied for the continuity demand that is generated; otherwise, no.
    /// </returns>
    NoYes mcrUseProbabilisticContinuity()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustForecastInventBeCreated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines if a forecast line should be included in the requirement profile.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that contains coverage settings for a specific item ID and inventory
    ///    dimensions.
    /// </param>
    /// <param name="_forecastInvent">
    ///    A <c>ForecastInvent</c> record that specifies the forecast line.
    /// </param>
    /// <returns>
    ///    true if the forecast should be included in the requirement profile; otherwise, false.
    /// </returns>
    public boolean  mustForecastInventBeCreated(ReqSetupDim _setupDim, ForecastInvent _forecastInvent)
    {
        if (!_setupDim.setup().mustItemReqBeCreated())
            return false;

        if (this.timeFenceForecast(_setupDim) <= 0)
            return false;

        if (_forecastInvent.DateBudget >= this.todaysdate() + this.timeFenceForecast(_setupDim))
            return false;

        if (!WHSInventStatus::allowCreatePlannedOrder(_setupDim.inventDim().InventStatusId,false))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustKeepPlannedOrder</Name>
				<Source><![CDATA[
    public boolean mustKeepPlannedOrder(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans,
        Set             _setApprovedPlannedOrder
        )
    {
        if (!_setupDim.setup().mustItemReqBeCreated())
        {
            return false;
        }

        if (this.timeFenceLocking(_setupDim) > 0)
        {
            if (_reqTrans.ReqDate < this.todaysdate() + this.timeFenceLocking(_setupDim))
            {
                return true;
            }
        }

        if (_setApprovedPlannedOrder)
        {
            if (_setApprovedPlannedOrder.in(_reqTrans.RefId))
            {
                return true;
            }
        }
        else if (_reqTrans.getReqPo(this).ReqPOStatus == ReqPOStatus::Approved)
        {
            return true;
        }

        if (!ReqPoPreventDeletionContext::canBeDeleted(_reqTrans.RefId, _reqTrans.RefType))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransBeActionDerived</Name>
				<Source><![CDATA[
    public boolean  mustTransBeActionDerived(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans)
    {
        if (! _setupDim.mayItemBeActionDerived())
        {
            return false;
        }

        if ( ReqTrans::derivedRefType(_reqTrans.RefType) != ReqRefType::None
             && _reqTrans.Qty > 0)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransBeActionSet</Name>
				<Source><![CDATA[
    public boolean  mustTransBeActionSet(
        ReqSetupDim  _setupDim,
        ReqTrans     _reqTrans)
    {
        TimeFenceAction timeFenceAction;

        if (_reqTrans.Qty  <= 0)
            return false;

        timeFenceAction = this.timeFenceAction(_setupDim);

        if (timeFenceAction <= 0)
            return false;

        if (_reqTrans.ReqDate >= this.todaysdate() + timeFenceAction)
            return false;

        return _setupDim.mustItemBeActionMarked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransBeAutoAuthorized</Name>
				<Source><![CDATA[
    public boolean  mustTransBeAutoAuthorized(
        ReqSetupDim  _setupDim,
        ReqTrans     _reqTrans)
    {
        if (_reqTrans.IsDerivedDirectly)
            return false;

        if (this.timeFenceAuthorization(_setupDim) <= 0)
            return false;

        if (this.todaysdate() + this.timeFenceAuthorization(_setupDim) > this.getDateForFirmingTimeFence(_reqTrans))
            return true;

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDateForFirmingTimeFence</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal TransDate getDateForFirmingTimeFence(ReqTrans _reqTrans)
    {
        return _reqTrans.ReqDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransBeExploded</Name>
				<Source><![CDATA[
    public boolean  mustTransBeExploded(
        ReqSetupDim     _setupDim,
        ReqPO           _reqPO)
    {
        if (_reqPO.supplyPrinciple(this) != ReqSupplyPrinciple::Conversion)
        {
            return false;
        }

        if (this.timeFenceExplosion(_setupDim) <= 0)
        {
            return false;
        }

        if (!_setupDim.setup().bomId(_reqPO))
        {
            return false;
        }

        if (this.todaysdate() + this.timeFenceExplosion(_setupDim) > _reqPO.ReqDate)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransBeFuturesMarked</Name>
				<Source><![CDATA[
    public boolean  mustTransBeFuturesMarked(
        ReqSetupDim     _setupDim,
        ReqTrans        _reqTrans)
    {
        TimeFenceFutures timeFenceFutures;

        if (_reqTrans.RefType == ReqRefType::InventOnHand)
        {
            return false;
        }

        if (!_setupDim.mustItemBeFuturesMarked())
            return false;

        timeFenceFutures = this.timeFenceFutures(_setupDim);

        if (timeFenceFutures <= 0)
            return false;

        if (_reqTrans.ReqDate >= this.todaysdate() + timeFenceFutures)
            return false;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustTransBeScheduled</Name>
				<Source><![CDATA[
    public boolean  mustTransBeScheduled(
        ReqSetupDim     _setupDim,
        ReqPO           _reqPO)
    {
        TimeFenceCapacity timeFenceCapacity;

        if (_reqPO.Qty  <= 0 || ! _reqPO.ItemRouteId)
        {
            return false;
        }

        if (ReqTrans::refTypeCanReserveWorkCenter(_reqPO.RefType))
        {
            _setupDim.parmReqPO(_reqPO);

            if (! _setupDim.mustItemBeScheduled())
            {
                return false;
            }

            timeFenceCapacity = this.timeFenceCapacity(_setupDim);

            if (timeFenceCapacity <= 0)
            {
                return false;
            }

            if (_reqPO.ReqDate < this.todaysdate() + timeFenceCapacity)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(ReqPlanId _reqPlanId)
    {
        reqPlanId = _reqPlanId;
        reqCovDimIdCache = new Map(Types::String, Types::String);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReqSetupCacheBuilder</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>ReqSetupCacheBuilder</c>.
    /// </summary>
    /// <returns>A new <c>ReqSetupCacheBuilder</c>.</returns>
    protected ReqSetupCacheBuilder createReqSetupCacheBuilder()
    {
        ReqSetupCacheBuilder builder = new ReqSetupCacheBuilder();
        
        builder.parmUseSetupCache(useSetupCache);
        builder.parmUseSetupDimCache(useSetupDimCache);
        builder.parmDisableDbCache(disableDbCache);
        builder.parmMemoryCacheCurrentSessionScope(memoryCacheCurrentSessionScope);

        if (reqTransCache && processId && reqTransCache.isProcessMultithreaded())
        {
            builder.parmMemoryCacheCrossSessionScope(ReqMemoryCacheCrossSessionScope::newDataAreaScope('ReqPlanData:' + processId));
        }

        return builder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqSetupCache</Name>
				<Source><![CDATA[
    private ReqSetupCache reqSetupCache()
    {
        if (!reqSetupCache)
        {
            reqSetupCache = ReqSetupCache::newFromCacheBuilder(this.createReqSetupCacheBuilder());
        }

        return reqSetupCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqSetup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ReqSetup</c> object which describes item coverage setup for the specified item.
    /// </summary>
    /// <param name = "_itemId">The ID of the item.</param>
    /// <param name = "_inventTable">The <c>InventTable</c> record.</param>
    /// <returns>A <c>ReqSetup</c> object.</returns>
    public ReqSetup newReqSetup(ItemId _itemId, InventTable _inventTable = null)
    {
        return this.reqSetupCache().reqSetup(_itemId, _inventTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqSetupDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>ReqSetupDim</c> object which describes item coverage setup for the specified item and coverage inventory dimensions.
    /// </summary>
    /// <param name = "_reqSetup">The coverage setup for the specified item.</param>
    /// <param name = "_covInventDimId">The ID of the coverage inventory dimension values combination.</param>
    /// <returns>A <c>ReqSetupDim</c> object.</returns>
    public ReqSetupDim newReqSetupDim(ReqSetup _reqSetup, ReqCovInventDimId _covInventDimId)
    {
        ReqSetupDim result = this.reqSetupCache().reqSetupDim(_reqSetup, _covInventDimId);
        result.parmLeanLocationCache(leanLocationCache);
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqSetupDimReqPo</Name>
				<Source><![CDATA[
    public ReqSetupDim newReqSetupDimReqPo(ReqPO _reqPO)
    {
        return this.newReqSetupDim(this.newReqSetup(_reqPO.ItemId),_reqPO.CovInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqSetupDimReqTrans</Name>
				<Source><![CDATA[
    public ReqSetupDim newReqSetupDimReqTrans(ReqTrans _reqTrans)
    {
        return this.newReqSetupDim(this.newReqSetup(_reqTrans.ItemId),_reqTrans.CovInventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUseLatestPossibleSupplyFirst</Name>
				<Source><![CDATA[
    public ReqMustUseLatestPossibleSupplyFirst mustUseLatestPossibleSupplyFirst(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.mustUseLatestPossibleSupplyFirst() : NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onHandConsumption</Name>
				<Source><![CDATA[
    public ReqOnHandConsumptionStrategy onHandConsumption(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.onHandConsumption() : ReqOnHandConsumptionStrategy::BeforeAllOtherSupply;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDisableDbCache</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmDisableDbCache(boolean _disableDbCache = disableDbCache)
    {
        disableDbCache = _disableDbCache;
        return disableDbCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public ReqProcessId parmProcessId(ReqProcessId _processId = processId)
    {
        if (!prmisDefault(_processId))
        {
            processId = _processId;
        }

        return processId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public ReqPlanId parmReqPlanId(ReqPlanId _reqPlanId = reqPlanId)
    {
        reqPlanId = _reqPlanId;

        return reqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanVersionRefRecId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public RefRecId parmReqPlanVersionRefRecId(RefRecId _reqPlanVersionRefRecId = reqPlanVersionRefRecId)
    {
        reqPlanVersionRefRecId = _reqPlanVersionRefRecId;

        return reqPlanVersionRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTodaysDate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public void parmTodaysDate(TodaysDate _todaysDate)
    {
        todaysdate = _todaysDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseReqTransCache</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmUseReqTransCache(boolean _useReqTransCache = useReqTransCache)
    {
        useReqTransCache = _useReqTransCache;
        return useReqTransCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseSetupCache</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmUseSetupCache(boolean _useSetupCache = useSetupCache)
    {
        useSetupCache = _useSetupCache;
        return useSetupCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseSetupDimCache</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean parmUseSetupDimCache(boolean _useSetupDimCache = useSetupDimCache)
    {
        useSetupDimCache = _useSetupDimCache;
        return useSetupDimCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMemoryCacheCurrentSessionScope</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the scope for the cached objects that cannot be shared across sessions.
    /// </summary>
    /// <param name = "_memoryCacheCurrentSessionScope">The scope for the cached objects that cannot be shared across sessions.</param>
    /// <returns>The scope for the cached objects that cannot be shared across sessions.</returns>
    [Hookable(false)]
    public ReqMemoryCacheCurrentSessionScope parmMemoryCacheCurrentSessionScope(ReqMemoryCacheCurrentSessionScope _memoryCacheCurrentSessionScope = memoryCacheCurrentSessionScope)
    {
        memoryCacheCurrentSessionScope = _memoryCacheCurrentSessionScope;
        return memoryCacheCurrentSessionScope;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsUseShelfLife</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns if default shelf life functionality is enabled for master plan.
    /// </summary>
    /// <returns>Shelf life flag.</returns>
    public boolean pdsUseShelfLife()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>quotationProbabilityId</Name>
				<Source><![CDATA[
    smmQuotationProbabilityId quotationProbabilityId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqLog</Name>
				<Source><![CDATA[
    public ReqLog reqLog()
    {
        return reqLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqLogCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Planning coverage statistics for this instance.
    /// </summary>
    /// <returns>ReqLogCoverage</returns>
    public ReqLogCoverage reqLogCoverage()
    {
        return reqLogCoverage;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqReduceType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast reduction principle.
    /// </summary>
    /// <returns>
    ///    A <c>ReqReduceType</c> enumeration type that contains the reduction principle.
    /// </returns>
    public ReqReduceType reqReduceType()
    {
        return reqPlan.ForecastReduceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTimeFutures</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the future time that determines when a receipt is considered late.
    /// </summary>
    /// <returns>
    ///    An integer value that represents a time, which is expressed as seconds after midnight.
    /// </returns>
    public ReqTime reqTimeFutures()
    {
        return reqParameters.ReqTimeFutures;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTimePoDefault</Name>
				<Source><![CDATA[
    public ReqTimePoDefault reqTimePoDefault()
    {
        return reqParameters.ReqTimePoDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTraceLogger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the single-instance master planning trace logger.
    /// </summary>
    /// <returns>
    /// The master planning trace logger.
    /// </returns>
    public ReqTraceLogger reqTraceLogger()
    {
        if (!reqTraceLogger)
        {
            reqTraceLogger = ReqTraceLogger::newLoggers(ReqTraceTableLogger::construct(),
                                                        ReqTraceCrimsonLogger::newSinkProvider(ReqTraceCrimsonLogSink::construct()));
            reqTraceLogger.parmContext().startNewTrace();
        }

        return reqTraceLogger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransCache</Name>
				<Source><![CDATA[
    public ReqTransCache reqTransCache()
    {
        return reqTransCache;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreReqLog</Name>
				<Source><![CDATA[
    void restoreReqLog()
    {
        reqLog.data(reqLogBackup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedMarginBackward</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Backwards schedules a date on the calendar based on the specified parameters.
    /// </summary>
    /// <param name="_fromDate">
    ///     The starting date to schedule from.
    /// </param>
    /// <param name="_margin">
    ///     The days to traverse in the calendar.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public SchedDate schedMarginBackward(
        SchedDate       _fromDate,
        Days            _margin,
        ReqSetupDim     _setupDim,
        CalendarId      _secondaryCalendarId = '')
    {
        return this.schedMarginBackwardWithCalendar(_fromDate, _margin, _setupDim, _setupDim.reqCalendarId(), _secondaryCalendarId);        
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedMarginBackwardWithCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Backwards schedules a date on the calendar based on the specified parameters.
    /// </summary>
    /// <param name="_fromDate">
    ///     The starting date to schedule from.
    /// </param>
    /// <param name="_margin">
    ///     The days to traverse in the calendar.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <param name="_primaryCalendarId">
    ///     The ID of the primary calendar to use.
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use; optional.
    /// </param>
    /// <param name="_checkForPickup">
    ///     Determines which calendar should be checked for the sales pickup flag; optional.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public SchedDate schedMarginBackwardWithCalendar(
        SchedDate           _fromDate,
        Days                _margin,
        ReqSetupDim         _setupDim,
        CalendarId          _primaryCalendarId,
        CalendarId          _secondaryCalendarId = '',
        SalesCheckForPickup _checkForPickup = SalesCheckForPickup::Never)
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Backward,
            _fromDate,
            _margin,
            this.marginCalendarDays(),
            _primaryCalendarId,
            _secondaryCalendarId,
            _checkForPickup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedMarginForward</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Forward schedules a date on the calendar based on the specified parameters.
    /// </summary>
    /// <param name="_fromDate">
    ///     The starting date to schedule from.
    /// </param>
    /// <param name="_margin">
    ///     The days to traverse in the calendar.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use; optional.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public SchedDate schedMarginForward(
        SchedDate       _fromDate,
        Days            _margin,
        ReqSetupDim     _setupDim,
        CalendarId      _secondaryCalendarId = '')
    {
        return this.schedMarginForwardWithCalendar(_fromDate, _margin, _setupDim, _setupDim.reqCalendarId(), _secondaryCalendarId); 
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedMarginForwardWithCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Forward schedules a date on the calendar based on the specified parameters.
    /// </summary>
    /// <param name="_fromDate">
    ///     The starting date to schedule from.
    /// </param>
    /// <param name="_margin">
    ///     The days to traverse in the calendar.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <param name="_primaryCalendarId">
    ///     The ID of the primary calendar to use.
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use; optional.
    /// </param>
    /// <param name="_checkForPickup">
    ///     Determines which calendar should be checked for the sales pickup flag; optional.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public SchedDate schedMarginForwardWithCalendar(
        SchedDate           _fromDate,
        Days                _margin,
        ReqSetupDim         _setupDim,
        CalendarId          _primaryCalendarId,
        CalendarId          _secondaryCalendarId = '',
        SalesCheckForPickup _checkForPickup = SalesCheckForPickup::Never)
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Forward,
            _fromDate,
            _margin,
            this.marginCalendarDays(),
            _primaryCalendarId,
            _secondaryCalendarId,
            _checkForPickup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedReqDateIssue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Backwards schedules a date on the calendar based on the issue margin of the specified requirements.
    /// </summary>
    /// <param name="_reqDateDlv">
    ///     The requirement date to use as starting date for the scheduling.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public ReqDate schedReqDateIssue(
        ReqDateDlv  _reqDateDlv,
        ReqSetupDim _setupDim)
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Backward,
            _reqDateDlv,
            this.marginIssue(_setupDim),
            this.marginCalendarDays(),
            _setupDim.reqCalendarId(),
            '',
            SalesCheckForPickup::Never);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedReqDateOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Backwards schedules a date on the calendar based on the order margin of the specified requirements.
    /// </summary>
    /// <param name="_reqDateOrder">
    ///     The requirement date to use as starting date for the scheduling.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public ReqDateOrder schedReqDateOrder(
        ReqDateOrder    _reqDateOrder,
        ReqSetupDim     _setupDim,
        CalendarId      _secondaryCalendarId = '')
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Backward,
            _reqDateOrder,
            this.marginOrder(_setupDim),
            this.marginCalendarDays(),
            _setupDim.reqCalendarId(),
            _secondaryCalendarId,
            SalesCheckForPickup::Never);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedReqDateReceipt</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Forward schedules a date on the calendar based on the receipt margin of the specified requirements.
    /// </summary>
    /// <param name="_reqDateDlv">
    ///     The requirement date to use as starting date for the scheduling.
    /// </param>
    /// <param name="_setupDim">
    ///     The dimension-based planned order requirement setup.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public ReqDate schedReqDateReceipt(
        ReqDateDlv  _reqDateDlv,
        ReqSetupDim _setupDim)
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Forward,
            _reqDateDlv,
            this.marginReceipt(_setupDim),
            this.marginCalendarDays(),
            _setupDim.reqCalendarId(),
            '',
            SalesCheckForPickup::Never);
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedReqPoBackward</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Backwards schedules the specified planned order date based on the lead time and requirement setup.
    /// </summary>
    /// <param name="_fromDate">
    ///     The starting date to schedule from.
    /// </param>
    /// <param name="_reqPO">
    ///     The planned order to schedule.
    /// </param>
    /// <param name="_calendarId">
    ///     The ID of the primary calendar to use.
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public SchedDate schedReqPoBackward(
        SchedDate       _fromDate,
        ReqPO           _reqPO,
        CalendarId      _calendarId,
        CalendarId      _secondaryCalendarId = '')
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Backward,
            _fromDate,
            _reqPO.LeadTime,
            _reqPO.CalendarDays,
            _calendarId,
            _secondaryCalendarId,
            this.checkForPickup(_reqPO));
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedReqPoForward</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Forward schedules the specified planned order date based on the lead time and requirement setup.
    /// </summary>
    /// <param name="_fromDate">
    ///     The starting date to schedule from.
    /// </param>
    /// <param name="_reqPO">
    ///     The planned order to schedule.
    /// </param>
    /// <param name="_calendarId">
    ///     The ID of the primary calendar to use. For planned transfer orders this should be the transportation calendar. 
    /// </param>
    /// <param name="_secondaryCalendarId">
    ///     The ID of the secondary calendar to use. For planned transfer orders this should be the calendar of the receiving warehouse; optional.
    /// </param>
    /// <returns>
    ///     A date that complies with the parameters.
    /// </returns>
    public SchedDate schedReqPoForward(
        SchedDate       _fromDate,
        ReqPO           _reqPO,
        CalendarId      _calendarId,
        CalendarId      _secondaryCalendarId = '')
    {
        return this.workCalendarSched().schedDate(
            SchedDirection::Forward,
            _fromDate,
            _reqPO.LeadTime,
            _reqPO.CalendarDays,
            _calendarId,
            _secondaryCalendarId,
            SalesCheckForPickup::Never);
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchTradeAgreement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves whether to search for a trade agreement when determining a planned order lead time.
    /// </summary>
    /// <returns>true if a trade agreement search should be performed; otherwise, false.</returns>
    /// <remarks>There might be a direct use of ReqParameters to determine the parameter value from the <c>ReqSetupDim</c> 
    /// in case there is not enough context to create an instance of the <c>ReqPlanData</c>.</remarks>
    public boolean searchTradeAgreement()
    {
        return reqParameters.ReqSearchTradeAgreement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>searchTradeMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the strategy to use when searching for a trade agreement.
    /// </summary>
    /// <returns>A trade agreement search method.</returns>
    /// <remarks>There might be a direct use of ReqParameters to determine the parameter value from the <c>ReqSetupDim</c>
    /// in case there is not enough context to create an instance of the <c>ReqPlanData</c>.</remarks>
    public ReqSearchTradeMethod searchTradeMethod()
    {
        return reqParameters.ReqSearchTradeMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sequenceLogId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number sequence record ID for the master planning log numbers.
    /// </summary>
    /// <returns>
    ///    A record ID that identifies the number sequence record for master planning log entries.
    /// </returns>
    /// <remarks>
    ///    Always thrown. This method will be overridden on the derived classes.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The method is invoked.
    /// </exception>
    public ReqSequenceJobRefRecId sequenceLogId()
    {
        throw error(strFmt("@SYS18885", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>sequencePlannedOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the number sequence record ID for the planned orders number sequence.
    /// </summary>
    /// <returns>
    ///    The planned orders number sequence record ID.
    /// </returns>
    /// <remarks>
    ///    Always throws. This method will be overridden.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The method is invoked.
    /// </exception>
    public ReqSequencePORefRecId sequencePlannedOrder()
    {
        throw error(strFmt("@SYS18885", funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>subReqLog</Name>
				<Source><![CDATA[
    public void subReqLog(ReqTrans _reqTrans)
    {
        if (reqLog.ReqLogId)
        {
            reqLog.subReqTrans(_reqTrans.RefType,_reqTrans.IsForecastPurch);

            if (_reqTrans.RefType == ReqRefType::InventJournal)
            {
                if (_reqTrans.Qty > 0)
                {
                    reqLog.NumOfInventJournalReceipt--;
                }
                else 
                {
                    reqLog.NumOfInventJournalIssue--;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceAction</Name>
				<Source><![CDATA[
    public TimeFenceAction timeFenceAction(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceAction() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceAuthorization</Name>
				<Source><![CDATA[
    public TimeFenceAuthorization timeFenceAuthorization(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceAuthorization() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceBackRequisition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the backward requisition time fence.
    /// </summary>
    /// <param name="_setupDim">
    /// The <c>ReqSetupDim</c> to get the setting from.
    /// </param>
    /// <returns>
    /// Number of days in the past, during which demand from
    /// requisitions is included in master scheduling.
    /// </returns>
    public TimeFenceBackRequisition timeFenceBackRequisition(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceBackRequisition() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceBottleneckCap</Name>
				<Source><![CDATA[
    public SchedTimeFenceBottleneckCap timeFenceBottleneckCap(ReqSetupDim _setupDim)
    {
        return maxDate() - todaysdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceCapacity</Name>
				<Source><![CDATA[
    public TimeFenceCapacity timeFenceCapacity(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceCapacity() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceCoverage</Name>
				<Source><![CDATA[
    public TimeFenceCoverage timeFenceCoverage(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceCov() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceExplosion</Name>
				<Source><![CDATA[
    public TimeFenceExplosion timeFenceExplosion(ReqSetupDim _setupDim)
    {
        return _setupDim ?  _setupDim.timeFenceExplosion() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceFiniteCap</Name>
				<Source><![CDATA[
    public SchedTimeFenceFiniteCap timeFenceFiniteCap(ReqSetupDim _setupDim)
    {
        return maxDate() - todaysdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceMaxNegativeDaysFixed</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the negative days setting has been overridden by master plan.
    /// </summary>
    /// <returns>
    ///    true if negative days setting has been overridden; otherwise, false.
    /// </returns>
    public NoYes timeFenceMaxNegativeDaysFixed()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceMaxNegativeDays</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the maximum number of negative days time fence.
    /// </summary>
    /// <returns>
    ///    An integer that specifies the number of days which demand can precede the supply it is pegged to.
    /// </returns>
    /// <remarks>
    ///    During master planning, avoid creating new supply orders
    ///    if existing supply inside the negative days time fence will be able to cover the demand.
    /// </remarks>
    public ReqMaxNegativeDays timeFenceMaxNegativeDays()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceForecast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the forecast time fence for a specific item and coverage dimensions.
    /// </summary>
    /// <param name="_setupDim">
    ///    A <c>ReqSetupDim</c> object that contains coverage settings for a specific item ID and inventory
    ///    dimensions.
    /// </param>
    /// <returns>
    ///    An integer that specifies some days to determine the period in which the forecast is included.
    /// </returns>
    public TimeFenceMasterPlan timeFenceForecast(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceForecast() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceFutures</Name>
				<Source><![CDATA[
    public TimeFenceFutures timeFenceFutures(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceFutures() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>timeFenceLocking</Name>
				<Source><![CDATA[
    public TimeFenceLocking timeFenceLocking(ReqSetupDim _setupDim)
    {
        return _setupDim ? _setupDim.timeFenceLocking() : 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>todaysdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the system date if it is an open date/time according to the calendar or else the next open
    ///    date.
    /// </summary>
    /// <returns>
    ///    The system date if it is an open date/time according to the calendar; otherwise, the next open date.
    /// </returns>
    public TransDate todaysdate()
    {
        utcdatetime companyDateTime;

        if (! todaysdate)
        {
            companyDateTime = ReqPlanData::currentDateTime();
            todaysdate = WorkCalendar::findOpenDateForward(ReqParameters::find().TodaysdateCalendarId,
                                                           DateTimeUtil::date(companyDateTime),
                                                           DateTimeUtil::time(companyDateTime));
        }

        return todaysdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useForecastDemand</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates if demand forecast should be included in the requirement profile.
    /// </summary>
    /// <returns>
    ///    true if demand forecast should be included; otherwise, false.
    /// </returns>
    public NoYes useForecastDemand()
    {
        return reqPlan.UseForecastDemand;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useForecastSupply</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the supply forecast should be included in the requirement profile.
    /// </summary>
    /// <returns>
    ///    true if supply forecast should be included; otherwise, false.
    /// </returns>
    public NoYes useForecastSupply()
    {
        return reqPlan.UseForecastSupply;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInsertList</Name>
				<Source><![CDATA[
    public boolean useInsertList()
    {
        return useReqTransCache ? false : true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useInventOnHands</Name>
				<Source><![CDATA[
    public NoYes useInventOnHands()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useLockingTimeFence</Name>
				<Source><![CDATA[
    public boolean useLockingTimeFence()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useMovements</Name>
				<Source><![CDATA[
    public NoYes useMovements()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useQuotations</Name>
				<Source><![CDATA[
    public NoYes useQuotations()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>useRequestsForQuote</Name>
				<Source><![CDATA[
    NoYes useRequestsForQuote()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workCalendarSched</Name>
				<Source><![CDATA[
    public WorkCalendarSched workCalendarSched()
    {
        if (! workCalendarSched)
            workCalendarSched = new WorkCalendarSched();

        return workCalendarSched;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    private static ReqPlanData construct(ReqPlanId _reqPlanId)
    {
        ReqPlan reqPlan = ReqPlan::findReqPlanId(_reqPlanId);
        
        ReqPlanTypeFactoryAttribute         attribute       = new ReqPlanTypeFactoryAttribute(reqPlan.PlanType);
        SysExtensionGenericInstantiation    instantiation   = new SysExtensionGenericInstantiation(_reqPlanId);
        ReqPlanData                         instance        = SysExtensionAppClassFactory::getClassFromSysAttributeWithInstantiationStrategy(classStr(ReqPlanData), attribute, instantiation) as ReqPlanData;

        if (classIdGet(instance) == classNum(ReqPlanData))
        {
            throw error(strFmt("@SYS26908",reqPlan.PlanType));
        }

        return instance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentDateTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the current date/time in the master planning time zone.
    /// </summary>
    /// <returns>
    /// The current date/time in the master planning time zone.
    /// </returns>
    public static utcdatetime currentDateTime()
    {
        return DateTimeUtil::applyTimeZoneOffset(DateTimeUtil::getSystemDateTime(),DateTimeUtil::getCompanyTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqCalc</Name>
				<Source><![CDATA[
    public static ReqPlanData newReqCalc(
        ReqCalc         _reqCalc,
        boolean         _thisIsPeriodicProcess,
        ReqProcessId    _processId)
    {
        ReqPlanData reqPlanData = ReqPlanData::construct(_reqCalc.parmReqPlanId());
        reqPlanData.parmUseSetupCache(_reqCalc.useCache() != ReqUseCache::Minimum);
        reqPlanData.parmUseSetupDimCache(_reqCalc.useCache() == ReqUseCache::Maximum);
        reqPlanData.parmDisableDbCache(_reqCalc.useCache() == ReqUseCache::Minimum);

        reqPlanData.parmUseReqTransCache(!_thisIsPeriodicProcess);

        reqPlanData.parmReqPlanVersionRefRecId(_reqCalc.reqPlanVersionRefRecId());

        reqPlanData.parmProcessId(_processId);

        reqPlanData.init();

        reqPlanData.initReqTransCache();

        reqPlanData.reqTraceLogger().parmLogToTable(_reqCalc.parmEnableTableTraceLog());

        return reqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqPlanId</Name>
				<Source><![CDATA[
    public static ReqPlanData newReqPlanId(ReqPlanId _reqPlanId)
    {
        ReqPlanData reqPlanData = ReqPlanData::construct(_reqPlanId);

        reqPlanData.parmUseSetupCache(true);
        reqPlanData.parmUseSetupDimCache(true);
        reqPlanData.parmUseReqTransCache(false);
        reqPlanData.parmDisableDbCache(false);
        reqPlanData.parmReqPlanVersionRefRecId(ReqPlan::findReqPlanId(_reqPlanId).findActiveVersion().RecId);
        if (ReqPlanDataMemoryCacheCurrentSessionScopeFlight::instance().isEnabled())
        {
            reqPlanData.parmMemoryCacheCurrentSessionScope(new ReqMemoryCacheCurrentSessionScope());
        }
        reqPlanData.initReqTransCache();
        reqPlanData.init();

        return reqPlanData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqPlanVersion</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>ReqPlanData</c> class.
    /// </summary>
    /// <param name="_reqPlanVersionRefRecId">
    ///    The plan version to use.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>ReqPlanData</c> class.
    /// </returns>
    public static ReqPlanData newReqPlanVersion(RefRecId _reqPlanVersionRefRecId)
    {
        ReqPlanId   reqPlanId = ReqPlanVersion::find(_reqPlanVersionRefRecId).ReqPlanId;

        return ReqPlanData::newReqPlanId(reqPlanId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanLocationCache</Name>
				<Source><![CDATA[
    public LeanLocationCache parmLeanLocationCache(LeanLocationCache _leanLocationCache = leanLocationCache)
    {
        leanLocationCache = _leanLocationCache;

        return leanLocationCache;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>