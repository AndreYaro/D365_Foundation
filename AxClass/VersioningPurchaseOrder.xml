<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>VersioningPurchaseOrder</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>VersioningPurchaseOrder</c> class is used to implement a purchase order versioning state
///    model.
/// </summary>
class VersioningPurchaseOrder extends VersioningDocument
{
    PurchTable          purchTable;

    boolean             skipUpdatePurchTable;
    boolean             skipChangeRequest;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>setConfirmedDeliveryDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the confirmed delivery date to be the same as the specified delivery date if the confirmed delivery date is not already set.
    /// </summary>
    /// <param name = "_purchaseOrderResponseVersion">The <c>PurchaseOrderResponseVersion</c> record associated with the purchase lines to be updated.</param>
    /// <remarks>
    /// The desired outcome is to update the Confirmed Delivery Date for only the lines that would appear on the vendor's response. Therefore, lines that were cancelled, deleted, etc should not be updated.
    /// This is why this method joins the <c>PurchaseOrderResponseLine</c> table with the <c>PurchLine</c> table.
    /// </remarks>
    public void setConfirmedDeliveryDate(PurchaseOrderResponseVersion _purchaseOrderResponseVersion)
    {
        ttsbegin;

        this.setConfirmedDlvDateOnFirstPurchLineAndInitiateArchiving(_purchaseOrderResponseVersion);
        this.setConfirmedDlvDateOnRestOfPurchLines(_purchaseOrderResponseVersion);
        this.setEarliestConfirmedDeliveryDateHeader();
                
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEarliestConfirmedDeliveryDateHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the earliest confirmed delivery date on the purchase header
    /// </summary>
    private void setEarliestConfirmedDeliveryDateHeader()
    {
        if (!purchTable.isInterCompanyOrder())
        {
            purchTable.selectForUpdate(true);
            purchTable.reread();
            purchTable.ConfirmedDlvEarliest = PurchLine::earliestConfirmedDlv(purchTable.PurchId);
            purchTable.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setConfirmedDlvDateOnFirstPurchLineAndInitiateArchiving</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the confirmed delivery date on the first <c>PurchLine</c> which will initiate archiving for all the related <c>PurchLine</c> records.
    /// </summary>
    /// <param name = "_purchaseOrderResponseVersion">The <c>PurchaseOrderResponseVersion</c> record associated with the <c>PurchLine</c> to be updated.</param>
    /// <remarks>
    /// Selecting all the lines for update will cause an update conflict after the archiving caused by the update of the first line, this is the reason to split it into two updates.
    /// </remarks>
    private void setConfirmedDlvDateOnFirstPurchLineAndInitiateArchiving(PurchaseOrderResponseVersion _purchaseOrderResponseVersion)
    {
        PurchLine                   purchLine;
        PurchaseOrderResponseLine   purchaseOrderResponseLine;

        select firstonly forupdate purchLine
            where purchLine.ConfirmedDlv == dateNull()
                    && purchLine.DeliveryDate != dateNull()
                    && purchLine.PurchId == purchTable.PurchId
                    && !purchLine.IsDeleted
            exists join purchaseOrderResponseLine
                where purchaseOrderResponseLine.PurchaseOrderResponseHeader == _purchaseOrderResponseVersion.PurchaseOrderResponseHeader
                    && purchaseOrderResponseLine.PurchLine == purchLine.RecId;

        purchLine.ConfirmedDlv = purchLine.DeliveryDate;
        purchLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setConfirmedDlvDateOnRestOfPurchLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the confirmed delivery date to be the same as the specified delivery date if the confirmed delivery date is not already set.
    /// </summary>
    /// <param name = "_purchaseOrderResponseVersion">The <c>PurchaseOrderResponseVersion</c> record associated with the <c>PurchLine</c> to be updated.</param>
    private void setConfirmedDlvDateOnRestOfPurchLines(PurchaseOrderResponseVersion _purchaseOrderResponseVersion)
    {
        PurchLine                   purchLine;
        PurchaseOrderResponseLine   purchaseOrderResponseLine;

        if (!purchTable.isInterCompanyOrder())
        {
            purchLine.skipDataMethods(true);
            if (purchLine.shouldSkipEvents())
            {
                purchLine.skipEvents(true);
            }
        }

        // set based update lines and then update header's ConfirmedDlvEarliest once
        update_recordset purchLine
            setting ConfirmedDlv = purchLine.DeliveryDate
                where purchLine.ConfirmedDlv == dateNull()
                    && purchLine.DeliveryDate != dateNull()
                    && purchLine.PurchId == purchTable.PurchId
                    && !purchLine.IsDeleted
            exists join purchaseOrderResponseLine
                where purchaseOrderResponseLine.PurchaseOrderResponseHeader == _purchaseOrderResponseVersion.PurchaseOrderResponseHeader
                    && purchaseOrderResponseLine.PurchLine == purchLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveChangeRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Approves the current purchase order version.
    /// </summary>
    /// <remarks>
    /// If the changes that were made because an earlier version does not require manual reconfirmation, the new
    /// version is automatically confirmed. It does not require confirmation if the earlier version was
    /// confirmed and any record changes do not require confirmation.
    /// </remarks>
    /// <param name="isPlanOrderRef">
    /// The boolean to identify whether the PO reference to a planned order; Parameter is obsolete and is not used.
    /// </param>
    public void approveChangeRequest(boolean isPlanOrderRef = false)
    {
        ttsbegin;

        boolean isChangeConfirmationRequired = this.isPurchaseOrderChangeConfirmationRequired();

        super();

        this.autoCreateLoad();

        // If manual confirmation is not required, automatically re-confirm
        if (!isChangeConfirmationRequired)
        {
            this.runPurchaseOrderConfirmationProcess();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveWorkflowChangeRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Approves the change request coming from UI workflow and auto-confirms the purchase order
    /// if its changes do not require additional change management request.
    /// </summary>
    internal void approveWorkflowChangeRequest()
    {
        ttsbegin;

        boolean isChangeConfirmationRequired = this.isPurchaseOrderChangeConfirmationRequired();
        
        if (this.getDocumentState() != VersioningDocumentState::InReview)
        {
            // Only changes made to a document in state In Review can be approved.
            throw error("@SYS183976");
        }
        this.setDocumentState(VersioningDocumentState::Approved);
        this.createNewVersion();

        this.autoCreateLoad();

        if (purchTable.ProjId && purchTable.DocumentState == VersioningDocumentState::Approved &&
            (purchTable.PurchStatus == PurchStatus::Received || purchTable.PurchStatus == PurchStatus::Canceled) &&
            (purchTable.DocumentStatus == DocumentStatus::PackingSlip || purchTable.DocumentStatus == DocumentStatus::Cancelled))
        {
            this.updateItemReqOnCancelledPOApproval();
        }
        
        if (purchTable.DocumentState == VersioningDocumentState::Approved
            && !PurchTableHistory::existDocumentState(purchTable.PurchId, VersioningDocumentState::Confirmed))
        {
            PurchLine purchLine;
            while select forupdate purchLine
                where purchLine.PurchId == purchTable.PurchId
                && purchLine.IsDeleted
            {
                purchLine.type().updateSalesLineOnDeletePurchLine(true);
                if (!purchLine.BudgetReservationLine_PSN)
                {
                    PurchReqLine::clearPurchLineRef(purchLine.PurchReqLineRefId);

                    if (purchLine.PurchReqLineRefId)
                    {
                        PurchOrderRFQLineReference::deletePurchLineRef(purchLine);
                        purchLine.PurchReqLineRefId = emptyGuid();
                        purchLine.doUpdate();
                    }
                }
            }
        }

        // If manual confirmation is not required, automatically re-confirm
        if (!isChangeConfirmationRequired)
        {
            this.confirm();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoCreateLoad</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a load automatically for the purchase order.
    /// </summary>
    private void autoCreateLoad()
    {
        if (PurchParameters::find().ChangeRequestEnabled
          && purchTable.DocumentState == VersioningDocumentState::Approved)
        {
            PurchLine purchLine;

            while select purchLine
                where purchLine.PurchId == purchTable.PurchId
            {
                WHSAutoCreateLoadLine::newFromSourceLineTableBuffer(purchLine).autoCreateLoadLine();
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>rejectChangeRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Rejects the current change request.
    /// </summary>
    public void rejectChangeRequest()
    {
        ttsbegin;

        super();

        PurchLine purchLine;
        while select forupdate purchLine
        where purchLine.PurchId == purchTable.PurchId
            && purchLine.IsModified
        {
            this.updateRejectedLoadLine(purchLine);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateRejectedLoadLine</Name>
				<Source><![CDATA[
    private void updateRejectedLoadLine(PurchLine _purchLine)
    {
        boolean             whsEnabled = WHSInventEnabled::exist(_purchLine.ItemId);
        boolean             tmsEnabled = TMSInventEnabled::exist(_purchLine.ItemId);

        InventTransIdSum    inventTransIdSumDelivery;
        InventHandlingQty   origTotalQtyForLoad;
        InventHandlingQty   newTotalQtyForLoad;

        if (whsEnabled || tmsEnabled)
        {
            inventTransIdSumDelivery = InventTransIdSum::newTransOriginId(InventTransOrigin::findByInventTransId(_purchLine.InventTransId).RecId);

            boolean isCWItem = PdsGlobal::pdsIsCWItem(_purchLine.ItemId);

            if (isCWItem)
            {
                origTotalQtyForLoad = _purchLine.PdsCWRemainInventPhysical;
                newTotalQtyForLoad = inventTransIdSumDelivery.pdsCWReceipt() + inventTransIdSumDelivery.pdsCWIssue();
            }
            else
            {
                origTotalQtyForLoad = _purchLine.RemainInventPhysical;
                newTotalQtyForLoad = inventTransIdSumDelivery.receipt() + inventTransIdSumDelivery.issue();
            }

            if (newTotalQtyForLoad)
            {
                NoYesId autoCreate = (whsEnabled && WHSParameters::find().AutoCreateLoadPO) ||
                                    (tmsEnabled && TMSParameters::find().AutoCreateLoadPO);

                UnitOfMeasureSymbol purchLineOrigUnit = isCWItem ? _purchLine.pdsCWUnitId() : _purchLine.PurchUnit;

                WHSSrcLineChangeLoadLineUpdater srcLineChangeLoadLineUpdater = WHSSrcLineChangeLoadLineUpdater::newFromUpdateParameters(_purchLine,
                                                                                                                                    _purchLine.InventTransId,
                                                                                                                                    _purchLine.InventDimId,
                                                                                                                                    _purchLine.InventDimId,
                                                                                                                                    newTotalQtyForLoad,
                                                                                                                                    origTotalQtyForLoad,
                                                                                                                                    isCWItem ? _purchLine.pdsCWUnitId() : _purchLine.PurchUnit,
                                                                                                                                    purchLineOrigUnit,
                                                                                                                                    autoCreate);

                srcLineChangeLoadLineUpdater.updateLoadLines();

                WHSPurchLineUpdater purchLineUpdater = WHSSourceLineUpdater::newFromSourceLineTableBuffer(_purchLine);
                purchLineUpdater.setHandlingUpdateQuantities(_purchLine, origTotalQtyForLoad, purchLineOrigUnit, srcLineChangeLoadLineUpdater.getloadLineDiffHandlingQty());
                purchLineUpdater.updateTable();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchaseOrderChangeConfirmationRequired</Name>
				<Source><![CDATA[
    protected boolean isPurchaseOrderChangeConfirmationRequired()
    {
        boolean isChangeConfirmationRequired =
               !purchTable.ChangeRequestRequired        // if Change Request is not required confirmation must be needed as that is when archiving is done.
        || !this.doesHistoryExist()                 // if this is the first version of the order then confirmation must be needed as nothing was ever confirmed
        || PurchTableHistory::find(purchTable.PurchId, DateTimeUtil::maxValue()).DocumentState != VersioningDocumentState::Confirmed; // if previous version was not confirmed then confirmation is needed.
        // if previous version was confirmed new confirmation may still be needed if any of the record changes require confirmation (based on record.isChangeConfirmationRequired)

        // sync approved lines with external modules - inventory etc.
        PurchLine purchLine;
        while select forupdate purchLine
            where purchLine.PurchId == purchTable.PurchId
               && purchLine.IsModified
        {
            purchLine.type().updateApprovedLine();
            PurchLine purchLineOrig = purchLine.extensionOrig();

            if (this.mustSynchronizeSalesLineRef(purchLine))
            {
                purchLine.type().saveSynchronizedSalesLine(purchLineOrig, true);
            }

            isChangeConfirmationRequired = isChangeConfirmationRequired     // it was already detected that confirmation is needed
            || this.isPurchLineDeleted(purchLine);                          // confirmation is always needed after line deletion

            if (!isChangeConfirmationRequired)
            {
                PurchLineHistory purchLineHistory;
                select firstonly purchLineHistory
                    where purchLineHistory.InventTransId == purchLine.InventTransId;

                isChangeConfirmationRequired = !purchLineHistory || purchLine.purchLineVersioning().isChangeConfirmationRequired(purchLineHistory.purchLineVersioning());
            }
        }

        isChangeConfirmationRequired = isChangeConfirmationRequired
            || this.doPurchTableChangesRequireConfirmation()
            || this.doMarkupTransChangesRequireConfirmation()
            || SourceDocumentHeader::find(purchTable.SourceDocumentHeader).AccountingStatus != SourceDocumentAccountingStatus::Completed;

        return isChangeConfirmationRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchLineDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Check whether the purch line is deleted.
    /// </summary>
    /// <param name = "_purchLine">
    ///     An instance of the <c>Purchline</c> class.
    /// </param>
    /// <returns>
    ///     true if purch line is deleted; otherwise, false.
    /// </returns>
    protected boolean isPurchLineDeleted(PurchLine _purchLine)
    {
        return _purchline.IsDeleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runPurchaseOrderConfirmationProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the purchase order confirmation process through the <c>PurchFormLetter</c> framework.
    /// </summary>
    internal void runPurchaseOrderConfirmationProcess()
    {
        Map                        purchOrderMap    = new Map(Types::Int64, Types::Record);
        PurchFormLetter_PurchOrder purchFormLetter  = PurchFormLetter::construct(DocumentStatus::PurchaseOrder);

        purchOrderMap.insert(purchTable.RecId, purchTable);

        purchFormLetter.purchTable(purchTable);
        purchFormLetter.parmDataSourceRecordsPacked(purchOrderMap.pack());
        purchFormLetter.chooseLines();
        purchFormLetter.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveAgreementLineReleasedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>AgreementLineReleasedLine</c> records that belong to the purchase order and that are
    /// marked as modified to the history table.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    protected void archiveAgreementLineReleasedLine(PurchTableVersion _purchTableVersion)
    {
        #VersioningFieldLists

        PurchLine                           purchLine;
        AgreementLineReleasedLine           agreementLineReleasedLine;
        AgreementLineReleasedLineHistory    agreementLineReleasedLineHistory;

        ValidToDateTime                 prevVersionValidTo = _purchTableVersion.previousVersionValidTo();
        PurchTableValidPeriodVersion    purchTableValidPeriodVersion;
    
        agreementLineReleasedLineHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        while select RecId from agreementLineReleasedLine
            where agreementLineReleasedLine.IsDeleted
               && agreementLineReleasedLine.IsModified
            exists join purchLine
                where purchLine.InventTransId == agreementLineReleasedLine.PurchLineInventTransId
                    && purchLine.DataAreaId == agreementLineReleasedLine.PurchLineDataAreaId
                    && purchLine.PurchId == purchTable.PurchId
        {
            select firstOnly forUpdate agreementLineReleasedLineHistory
                where agreementLineReleasedLineHistory.AgreementLineReleasedLine == agreementLineReleasedLine.RecId;

            if (agreementLineReleasedLineHistory.RecId)
            {
                agreementLineReleasedLineHistory.ValidTo = prevVersionValidTo;
                agreementLineReleasedLineHistory.update();
            }
        }

        insert_recordset agreementLineReleasedLineHistory (#AgreementLineReleasedLineMapFieldList, AgreementLineReleasedLine, ValidFrom, ValidTo)
            select #AgreementLineReleasedLineMapFieldList, RecId from agreementLineReleasedLine
                where agreementLineReleasedLine.IsModified
                   && !agreementLineReleasedLine.IsDeleted
                join ValidFromDateTime, ValidToDateTime from purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId == _purchTableVersion.RecId
                exists join purchLine
                    where purchLine.InventTransId == agreementLineReleasedLine.PurchLineInventTransId
                       && purchLine.DataAreaId == agreementLineReleasedLine.PurchLineDataAreaId
                       && purchLine.PurchId == purchTable.PurchId;

        agreementLineReleasedLine.skipDataMethods(true);

        update_recordset agreementLineReleasedLine
            setting IsModified = NoYes::No
            where agreementLineReleasedLine.IsModified == NoYes::Yes
                exists join purchLine
                    where purchLine.InventTransId == agreementLineReleasedLine.PurchLineInventTransId
                       && purchLine.DataAreaId == agreementLineReleasedLine.PurchLineDataAreaId
                       && purchLine.PurchId == purchTable.PurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveCurrentVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies all the changed records of the purchase order to the history tables.
    /// </summary>
    /// <remarks>
    /// This method creates a new record in the <c>PurchaseTableVersion</c> table that has the current
    /// system date and calls all the archive methods to archive the individual tables. The archive methods
    /// update the <c>ValidTo</c> attribute of the latest archived version to the timestamp of the new
    /// order version, minus 1 second for any changed records that have the <c>IsModified</c> field set to
    /// the <c>NoYes::Yes</c> value. The changed records are inserted into the history tables with the
    /// <c>ValidTo</c> fields set to the result of the <c>DateTimeUtil.maxValue</c> method and the
    /// <c>ValidFrom</c> fields set to the timestamp of the order version that is created.
    /// </remarks>
    protected void archiveCurrentVersion()
    {
        ttsbegin;
        PurchTableVersion purchTableVersion = PurchTableVersion::findLatest(purchTable.PurchId, purchTable.DataAreaId, true);
        purchTableVersion.IsArchived = NoYes::Yes;
        purchTableVersion.update();

        ValidToDateTime validTo = DateTimeUtil::maxValue();

        this.archiveTax1099BoxDetail(purchTableVersion, validTo);
        this.archivePurchLine(purchTableVersion);
        this.archivePurchLineForeignTradeCategory(purchTableVersion);
        this.archiveMarkupTrans(purchTableVersion);
        this.archivePurchDeliverySchedule(purchTableVersion);
        this.archiveAgreementLineReleasedLine(purchTableVersion);
        this.archivePurchPrepayTable(purchTableVersion, validTo);
        this.archiveVendPaymSched(purchTableVersion, validTo);
        this.archiveVendPaymSchedLine(purchTableVersion, validTo);
        this.archivePurchTable(purchTableVersion, validTo);
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLineMarkupHistoryFromDate</Name>
				<Source><![CDATA[
    private ValidFromDateTime getNextLineMarkupHistoryFromDate(ValidToDateTime _prevVersionValidTo)
    {
        PurchLine purchLine;
        MarkupTrans markupTrans;
        MarkupTransHistory markupTransHistory;

        if (JoinTypeForMarkupTransHistoryChangedToCrossFlight::instance().isEnabled())
        {
            select firstonly RecId from purchLine
                where purchLine.PurchId == purchTable.PurchId
                join RecId from markupTrans
                    where markupTrans.TransTableId == purchLine.TableId
                        && markupTrans.TransRecId == purchLine.RecId
                        && markupTrans.IsDeleted
                        && markupTrans.IsModified
                    join ValidFrom from markupTransHistory
                        where markupTransHistory.ValidFrom > _prevVersionValidTo
                            && markupTransHistory.TransTableId == markupTrans.TransTableId
                            && markupTransHistory.TransRecId == markupTrans.TransRecId
                            && markupTransHistory.LineNum == markupTrans.LineNum;
        }
        else
        {
            select firstonly ValidFrom from markupTransHistory
                where markupTransHistory.ValidFrom > _prevVersionValidTo
                exists join markupTrans
                    where markupTrans.TransTableId == markupTransHistory.TransTableId
                        && markupTrans.TransRecId == markupTransHistory.TransRecId
                        && markupTrans.LineNum == markupTransHistory.LineNum
                        && markupTrans.IsDeleted
                        && markupTrans.IsModified
                    exists join purchLine
                        where purchLine.TableId == markupTrans.TransTableId
                            && purchLine.RecId == markupTrans.TransRecId
                            && purchLine.PurchId == purchTable.PurchId;
        }

        return markupTransHistory.ValidFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveMarkupTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies all the <c>MarkupTrans</c> records that belong to the purchase order and are marked as
    ///    modified to the history table.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    protected void archiveMarkupTrans(PurchTableVersion _purchTableVersion)
    {
        #VersioningFieldLists

        PurchLine           purchLine;
        MarkupTrans         markupTrans;
        MarkupTransHistory  markupTransHistory;

        ValidToDateTime                 prevVersionValidTo = _purchTableVersion.previousVersionValidTo();
        PurchTableValidPeriodVersion    purchTableValidPeriodVersion;

        ValidToDateTime nextVersionValidFrom = this.getNextLineMarkupHistoryFromDate(prevVersionValidTo);

        if (nextVersionValidFrom)
        {
            using (var activityContext = this.instrumentationLogger()
                .versioningPurchaseOrderActivities()
                .archiveMarkupTrans(_purchTableVersion.RecId, prevVersionValidTo, nextVersionValidFrom, funcName()))
            {
                throw error(strFmt("@SCM:UpdateMarkupTransHistoryError", prevVersionValidTo, nextVersionValidFrom));
            }
        }

        // Line Markup
        while select forUpdate markupTransHistory
            exists join markupTrans
                where markupTrans.TransTableId == markupTransHistory.TransTableId
                   && markupTrans.TransRecId == markupTransHistory.TransRecId
                   && markupTrans.LineNum == markupTransHistory.LineNum
                   && markupTrans.IsDeleted
                   && markupTrans.IsModified
                exists join purchLine
                    where purchLine.TableId == markupTrans.TransTableId
                       && purchLine.RecId == markupTrans.TransRecId
                       && purchLine.PurchId == purchTable.PurchId
        {
            markupTransHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
            markupTransHistory.ValidTo = prevVersionValidTo;
            markupTransHistory.update();
        }

        markupTransHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        insert_recordset markupTransHistory (#MarkupTransMapFieldList, #MarkupTransMapFieldList2, ValidFrom, ValidTo)
            select #MarkupTransMapFieldList, #MarkupTransMapFieldList2 from markupTrans
                where markupTrans.IsModified
                   && !markupTrans.IsDeleted
                join ValidFromDateTime, ValidToDateTime from purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId == _purchTableVersion.RecId
                exists join purchLine
                    where purchLine.TableId == markupTrans.TransTableId
                       && purchLine.RecId == markupTrans.TransRecId
                       && purchLine.PurchId == purchTable.PurchId;

        markupTrans.skipEvents(true);
        markupTrans.skipDataMethods(true);

        update_recordset markupTrans
            setting IsModified = NoYes::No
            where markupTrans.IsModified == NoYes::Yes
               && markupTrans.RecId != changedRecord.RecId
                exists join purchLine
                    where purchLine.TableId == markupTrans.TransTableId
                       && purchLine.RecId == markupTrans.TransRecId
                       && purchLine.PurchId == purchTable.PurchId;

        // Header Markup
        while select forupdate markupTransHistory
            exists join markupTrans
                where markupTrans.TransTableId == markupTransHistory.TransTableId
                    && markupTrans.TransRecId == markupTransHistory.TransRecId
                    && markupTrans.LineNum == markupTransHistory.LineNum
                    && markupTrans.IsDeleted
                    && markupTrans.IsModified
                    && markupTrans.TransTableId == purchTable.TableId
                    && markupTrans.TransRecId == purchTable.RecId
        {
            markupTransHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
            markupTransHistory.ValidTo = prevVersionValidTo;
            markupTransHistory.update();
        }

        insert_recordset markupTransHistory (#MarkupTransMapFieldList, #MarkupTransMapFieldList2, ValidFrom, ValidTo)
            select #MarkupTransMapFieldList, #MarkupTransMapFieldList2 from markupTrans
                where markupTrans.IsModified
                   && !markupTrans.IsDeleted
                   && markupTrans.TransTableId == purchTable.TableId
                   && markupTrans.TransRecId == purchTable.RecId
                join ValidFromDateTime, ValidToDateTime from purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId == _purchTableVersion.RecId;

        markupTrans.skipEvents(true);
        markupTrans.skipDataMethods(true);

        update_recordset markupTrans
            setting IsModified = NoYes::No
            where markupTrans.IsModified == NoYes::Yes
               && markupTrans.RecId != changedRecord.RecId
               && markupTrans.TransTableId == purchTable.TableId
               && markupTrans.TransRecId == purchTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archivePurchDeliverySchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>PurchDeliverySchedule</c> records that belong to the purchase order and are marked as
    /// modified to the history table.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    protected void archivePurchDeliverySchedule(PurchTableVersion _purchTableVersion)
    {
        PurchLine                       purchLine;
        PurchDeliverySchedule           purchDeliverySchedule;
        PurchDeliveryScheduleHistory    purchDeliveryScheduleHistory;

        ValidToDateTime                 prevVersionValidTo = _purchTableVersion.previousVersionValidTo();
        PurchTableValidPeriodVersion    purchTableValidPeriodVersion;

        purchDeliveryScheduleHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        if (VersioningPurchaseOrderPurchDeliveryScheduleArchivingFlight::instance().isEnabled())
        {
            while select forupdate purchDeliveryScheduleHistory
                exists join purchDeliverySchedule
                    where purchDeliverySchedule.RecId == purchDeliveryScheduleHistory.PurchDeliverySchedule
                       && purchDeliverySchedule.IsDeleted
                       && purchDeliverySchedule.IsModified
                    exists join purchLine
                        where purchLine.InventTransId == purchDeliverySchedule.DeliveryLine
                           && purchLine.PurchId == purchTable.PurchId
            {
                purchDeliveryScheduleHistory.ValidTo = prevVersionValidTo;
                purchDeliveryScheduleHistory.update();
            }
        }
        else
        {
            update_recordset purchDeliveryScheduleHistory
                setting ValidTo = prevVersionValidTo
                exists join purchDeliverySchedule
                    where purchDeliverySchedule.RecId == purchDeliveryScheduleHistory.PurchDeliverySchedule
                       && purchDeliverySchedule.IsDeleted
                       && purchDeliverySchedule.IsModified
                    exists join purchLine
                        where purchLine.InventTransId == purchDeliverySchedule.DeliveryLine
                           && purchLine.PurchId == purchTable.PurchId;

        }

        insert_recordset purchDeliveryScheduleHistory (PurchDeliverySchedule, OrderLine, ValidFrom, ValidTo)
            select RecId, OrderLine from purchDeliverySchedule
                where purchDeliverySchedule.IsModified
                   && !purchDeliverySchedule.IsDeleted
                join ValidFromDateTime, ValidToDateTime from purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId == _purchTableVersion.RecId
                exists join purchLine
                    where purchLine.InventTransId == purchDeliverySchedule.DeliveryLine
                       && purchLine.PurchId == purchTable.PurchId;

        purchDeliverySchedule.skipDataMethods(true);

        update_recordset purchDeliverySchedule
            setting IsModified = NoYes::No
            where purchDeliverySchedule.IsModified == NoYes::Yes
                exists join purchLine
                    where purchLine.InventTransId == purchDeliverySchedule.DeliveryLine
                       && purchLine.PurchId == purchTable.PurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archivePurchLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies all the <c>PurchLine</c> records that belong to the purchase order and are marked as
    ///    modified to the history table.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    protected void archivePurchLine(PurchTableVersion _purchTableVersion)
    {
        #VersioningFieldLists

        PurchLine           purchLine;
        PurchLine           changedPurchLine;
        PurchLineHistory    purchLineHistory;
        InventTransId       skipInventTransId;
        PurchLineForeignTradeCategory purchLineForeignTradeCategory;
        // <GIN>
        PurchLine_IN            purchLine_IN;
        PurchLineHistory_IN     purchLineHistory_IN;
        // </GIN>
        // <GEERU>
        PurchLine_W             purchLine_W;
        PurchLineHistory_W      purchLineHistory_W;
        // </GEERU>
        ValidToDateTime                 prevVersionValidTo = _purchTableVersion.previousVersionValidTo();
        PurchTableValidPeriodVersion    purchTableValidPeriodVersion;

        this.updatePurchLineHistoryValidTo(purchTable.PurchId, prevVersionValidTo);

        VersioningPurchaseOrderArchivePurchLine::newFromPurchTableVersion(_purchTableVersion).execute();

        // <GIN>
        if (PurchLine_IN::isExtensionEnabled())
        {
            insert_recordset purchLineHistory_IN (
                PurchLineHistory,
                #purchLineMapFieldList1_IN,
            #purchLineMapFieldList2_IN,
            #purchLineMapFieldList3_IN)
            select RecId from purchLineHistory
                join purchLine
                    where purchLine.InventTransId   == purchLineHistory.InventTransId
                       && purchLine.PurchId         == purchTable.PurchId
                join purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId    == _purchTableVersion.RecId
                       && purchLineHistory.validFrom            == purchTableValidPeriodVersion.ValidFromDateTime
                       && purchLineHistory.validTo              == purchTableValidPeriodVersion.ValidToDateTime
                join #purchLineMapFieldList1_IN, #purchLineMapFieldList2_IN, #purchLineMapFieldList3_IN
                    from purchLine_IN
                    where purchLine_IN.PurchLine == purchLine.RecId;
        }
        // </GIN>

        // <GEERU>
        if (PurchLine_W::isExtensionEnabled())
        {
            insert_recordset purchLineHistory_W (
                PurchLineHistory,
                #purchLineMapFieldList_W)
            select RecId from purchLineHistory
                join purchLine
                    where purchLine.InventTransId   == purchLineHistory.InventTransId
                       && purchLine.PurchId         == purchTable.PurchId
                join purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId    == _purchTableVersion.RecId
                       && purchLineHistory.validFrom            == purchTableValidPeriodVersion.ValidFromDateTime
                       && purchLineHistory.validTo              == purchTableValidPeriodVersion.ValidToDateTime
                join #purchLineMapFieldList_W
                    from purchLine_W
                    where purchLine_W.PurchLine == purchLine.RecId;
        }
        // </GEERU>

        if (changedRecord.TableId == tableNum(PurchLine))
        {
            changedPurchLine = changedRecord;
            skipInventTransId = changedPurchLine.InventTransId;
        }
        else if (changedRecord.TableId == tableNum(PurchLineForeignTradeCategory))
        {
            purchLineForeignTradeCategory = changedRecord;
            skipInventTransId = purchLineForeignTradeCategory.PurchLineInventTransId;
        }

        purchLine.skipDataMethods(true);
        purchLine.skipAosValidation(true);

        if (!Global::isFlightEnabled('VersioningPOSkipPurchLineEventsDisabled'))
        {
            purchLine.skipEvents(true);
        }

        update_recordset purchLine
            setting IsModified = NoYes::No
            where purchLine.PurchId == purchTable.PurchId
               && purchLine.IsModified
               && purchLine.InventTransId != skipInventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archivePurchLineForeignTradeCategory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>PurchLineForeignTradeCategory</c> records that belong to the purchase order and are
    /// marked as modified to the history table.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    protected void archivePurchLineForeignTradeCategory(PurchTableVersion _purchTableVersion)
    {
        #VersioningFieldLists

        PurchLine                               purchLine;
        PurchLineForeignTradeCategory           purchLineForeignTradeCategory;
        PurchLineForeignTradeCategoryHistory    purchLineForeignTradeCategoryHistory;

        ValidToDateTime                 prevVersionValidTo = _purchTableVersion.previousVersionValidTo();
        PurchTableValidPeriodVersion    purchTableValidPeriodVersion;

        purchLineForeignTradeCategoryHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        while select RecId from purchLineForeignTradeCategory
            where purchLineForeignTradeCategory.IsModified
               && purchLineForeignTradeCategory.IsDeleted
            exists join purchLine
                where purchLine.PurchId == purchTable.PurchId
                   && purchLine.InventTransId == purchLineForeignTradeCategory.PurchLineInventTransId
                   && purchLine.DataAreaId == purchLineForeignTradeCategory.PurchLineDataAreaId
        {
            select firstonly forupdate purchLineForeignTradeCategoryHistory
                where purchLineForeignTradeCategoryHistory.PurchLineForeignTradeCategory == purchLineForeignTradeCategory.RecId;

            if (purchLineForeignTradeCategoryHistory.RecId)
            {
                purchLineForeignTradeCategoryHistory.ValidTo = prevVersionValidTo;
                purchLineForeignTradeCategoryHistory.update();
            }
        }

        insert_recordset purchLineForeignTradeCategoryHistory (#PurchLineForeignTradeCategoryMapFieldList, purchLineForeignTradeCategory, ValidFrom, ValidTo)
            select #PurchLineForeignTradeCategoryMapFieldList, RecId from purchLineForeignTradeCategory
                where purchLineForeignTradeCategory.IsModified
                   && !purchLineForeignTradeCategory.IsDeleted
                join ValidFromDateTime, ValidToDateTime from purchTableValidPeriodVersion
                    where purchTableValidPeriodVersion.RecId == _purchTableVersion.RecId
                exists join purchLine
                    where purchLine.InventTransId == purchLineForeignTradeCategory.PurchLineInventTransId
                       && purchLine.DataAreaId == purchLineForeignTradeCategory.PurchLineDataAreaId
                       && purchLine.PurchId == purchTable.PurchId;

        purchLineForeignTradeCategory.skipDataMethods(true);
        purchLineForeignTradeCategory.skipEvents(true);

        update_recordset purchLineForeignTradeCategory
            setting IsModified = NoYes::No
            where purchLineForeignTradeCategory.IsModified == NoYes::Yes
               && purchLineForeignTradeCategory.RecId != changedRecord.RecId
                exists join purchLine
                    where purchLine.InventTransId == purchLineForeignTradeCategory.PurchLineInventTransId
                       && purchLine.DataAreaId == purchLineForeignTradeCategory.PurchLineDataAreaId
                       && purchLine.PurchId == purchTable.PurchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archivePurchPrepayTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the <c>PurchPrepayTable</c> record that is related to the purchase order to the history
    ///    table if it is marked as modified.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    /// <param name = "_validTo">
    /// The valid to date and time of the purchase order version being archived.
    /// </param>
    protected void archivePurchPrepayTable(PurchTableVersion _purchTableVersion, ValidToDateTime _validTo)
    {
        PurchPrepayTable        purchPrepayTable;
        PurchPrepayTableHistory purchPrepayTableHistory;
        ValidToDateTime         prevVersionValidTo = _purchTableVersion.previousVersionValidTo();

        purchPrepayTableHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        select firstonly forupdate purchPrepayTable
            where purchPrepayTable.PurchTable == purchTable.PurchId
               && purchPrepayTable.IsModified;

        if (purchPrepayTable)
        {
            if (!purchPrepayTable.IsDeleted)
            {
                purchPrepayTableHistory.initFromPurchPrepayTable(purchPrepayTable);
                purchPrepayTableHistory.ValidFrom  = _purchTableVersion.VersionDateTime;
                purchPrepayTableHistory.ValidTo    = _validTo;
                purchPrepayTableHistory.insert();
            }
            else
            {
                if (VendPurchPrepayTableArchivingFlight::instance().isEnabled())
                {
                    while select forupdate purchPrepayTableHistory
                        where purchPrepayTableHistory.PurchTable == purchPrepayTable.PurchTable
                    {
                        purchPrepayTableHistory.ValidTo = prevVersionValidTo;
                        purchPrepayTableHistory.update();
                    }
                }
                else
                {
                    update_recordset purchPrepayTableHistory
                        setting ValidTo = prevVersionValidTo
                        where purchPrepayTableHistory.PurchTable == purchPrepayTable.PurchTable;
                }
            }

            if (purchPrepayTable.RecId != changedRecord.RecId)
            {
                purchPrepayTable.IsModified = NoYes::No;
                purchPrepayTable.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextPurchTableHistoryFromDate</Name>
				<Source><![CDATA[
    private ValidFromDateTime getNextPurchTableHistoryFromDate(ValidToDateTime _prevVersionValidTo)
    {
        PurchTableHistory purchTableHistory;

        select firstonly ValidFrom from purchTableHistory
            where purchTableHistory.PurchId == purchTable.PurchId
                && purchTableHistory.ValidFrom > _prevVersionValidTo;

        return purchTableHistory.ValidFrom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archivePurchTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the <c>PurchTable</c> record that represents the purchase order to the history table if it
    ///    is marked as modified.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    /// <param name = "_validTo">
    /// The valid to date and time of the purchase order version being archived.
    /// </param>
    protected void archivePurchTable(PurchTableVersion _purchTableVersion, ValidToDateTime _validTo)
    {
        PurchTableHistory purchTableHistory;

        if (purchTable.IsModified == NoYes::Yes)
        {
            ValidFromDateTime nextVersionValidFrom = this.getNextPurchTableHistoryFromDate(_purchTableVersion.VersionDateTime);

            if (nextVersionValidFrom)
            {
                using (var activityContext = this.instrumentationLogger()
                    .versioningPurchaseOrderActivities()
                    .archivePurchTable(_purchTableVersion.RecId, _purchTableVersion.VersionDateTime, nextVersionValidFrom, funcName()))
                {
                    throw error(strFmt("@SCM:CreatePurchTableHistoryError", _purchTableVersion.VersionDateTime, nextVersionValidFrom));
                }
            }

            purchTableHistory.initFromPurchTable(purchTable.orig());
            purchTableHistory.ValidFrom  = _purchTableVersion.VersionDateTime;
            purchTableHistory.ValidTo    = _validTo;
            purchTableHistory.insert();

            purchTable.IsModified = NoYes::No;
            if (!this.parmSkipUpdatePurchTable())
            {
                purchTable.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveTax1099BoxDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>Tax1099BoxDetail</c> table record that represents the purchase order to the history
    /// table when it is marked as modified.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    /// <param name = "_validTo">
    /// The valid to date and time of the purchase order version being archived.
    /// </param>
    protected void archiveTax1099BoxDetail(PurchTableVersion _purchTableVersion, ValidToDateTime _validTo)
    {
        PurchLine                   purchLine;
        Tax1099BoxDetail            tax1099BoxDetail;
        Tax1099BoxDetailHistory     tax1099BoxDetailHistory;
        ValidToDateTime             prevVersionValidTo = _purchTableVersion.previousVersionValidTo();

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            tax1099BoxDetailHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

            while select forupdate tax1099BoxDetail
                join purchLine
                    where purchLine.PurchId == purchTable.PurchId &&
                        tax1099BoxDetail.RecId == purchLine.Tax1099RecId &&
                        purchLine.IsModified == NoYes::Yes
            {
                tax1099BoxDetailHistory.clear();

                if (!tax1099BoxDetail.IsDeleted)
                {
                    tax1099BoxDetailHistory.initFromTax1099BoxDetail(tax1099BoxDetail);
                    tax1099BoxDetailHistory.ValidFrom  = _purchTableVersion.VersionDateTime;
                    tax1099BoxDetailHistory.ValidTo    = _validTo;
                    tax1099BoxDetailHistory.Tax1099BoxDetailRecId = tax1099BoxDetail.RecId;
                    tax1099BoxDetailHistory.insert();
                }
                else
                {
                    update_recordset tax1099BoxDetailHistory
                        setting ValidTo = prevVersionValidTo
                        where tax1099BoxDetailHistory.Tax1099BoxDetailRecId == tax1099BoxDetail.RecId;
                }

                tax1099BoxDetail.IsModified = NoYes::No;
                tax1099BoxDetail.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveVendPaymSched</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Copies the <c>VendPaymSched</c> record that is related to the purchase order to the history table
    ///    if it is marked as modified.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    /// <param name = "_validTo">
    /// The valid to date and time of the purchase order version being archived.
    /// </param>
    protected void archiveVendPaymSched(PurchTableVersion _purchTableVersion, ValidToDateTime _validTo)
    {
        VendPaymSched           vendPaymSched;
        VendPaymSchedHistory    vendPaymSchedHistory;
        ValidToDateTime         prevVersionValidTo = _purchTableVersion.previousVersionValidTo();

        vendPaymSchedHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        select firstonly forupdate vendPaymSched
            where vendPaymSched.ExtTableId == purchTable.TableId
               && vendPaymSched.ExtRecId   == purchTable.RecId
               && vendPaymSched.IsModified;

        if (vendPaymSched)
        {
            if (!vendPaymSched.IsDeleted)
            {
                vendPaymSchedHistory.clear();
                vendPaymSchedHistory.initVendPaymSched(vendPaymSched);
                vendPaymSchedHistory.ValidFrom  = _purchTableVersion.VersionDateTime;
                vendPaymSchedHistory.ValidTo    = _validTo;
                vendPaymSchedHistory.insert();
            }
            else
            {
                select firstonly ValidFrom from vendPaymSchedHistory
                    where vendPaymSchedHistory.ExtTableId   ==  vendPaymSched.ExtTableId
                        && vendPaymSchedHistory.ExtRecId    ==  vendPaymSched.ExtRecId
                        && vendPaymSchedHistory.ValidFrom   >   prevVersionValidTo;

                if (vendPaymSchedHistory.ValidFrom)
                {
                    using (var activityContext = this.instrumentationLogger().versioningPurchaseOrderActivities().archiveVendPaymSched(_purchTableVersion.RecId, prevVersionValidTo, vendPaymSchedHistory.ValidFrom, funcName()))
                    {
                        throw error("@SCM:UpdateVendPaymSchedHistoryError");
                    }
                }
                
                if (VersioningPurchaseOrderVendPaymSchedArchivingFlight::instance().isEnabled())
                {
                    while select forupdate vendPaymSchedHistory
                        where vendPaymSchedHistory.ExtTableId   == vendPaymSched.ExtTableId
                           && vendPaymSchedHistory.ExtRecId     == vendPaymSched.ExtRecId
                           && vendPaymSchedHistory.ValidFrom    >  prevVersionValidTo
                    {
                        vendPaymSchedHistory.ValidTo = prevVersionValidTo;
                        vendPaymSchedHistory.update();
                    }
                }
                else
                {
                    update_recordset vendPaymSchedHistory
                        setting ValidTo = prevVersionValidTo
                        where vendPaymSchedHistory.ExtTableId   == vendPaymSched.ExtTableId
                           && vendPaymSchedHistory.ExtRecId     == vendPaymSched.ExtRecId
                           && vendPaymSchedHistory.ValidFrom    >   prevVersionValidTo;
                }

            }
             
            if (vendPaymSched.RecId != changedRecord.RecId)
            {
                vendPaymSched.IsModified = NoYes::No;
                vendPaymSched.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveVendPaymSchedLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies the <c>VendPaymSchedLine</c> records that are related to the purchase order and are marked
    /// as modified to the history table.
    /// </summary>
    /// <param name = "_purchTableVersion">
    /// The purchase order version being archived.
    /// </param>
    /// <param name = "_validTo">
    /// The valid to date and time of the purchase order version being archived.
    /// </param>
    protected void archiveVendPaymSchedLine(PurchTableVersion _purchTableVersion, ValidToDateTime _validTo)
    {
        VendPaymSched               vendPaymSched;
        VendPaymSchedLine           vendPaymSchedLine;
        VendPaymSchedLineHistory    vendPaymSchedLineHistory;
        ValidToDateTime             prevVersionValidTo = _purchTableVersion.previousVersionValidTo();

        vendPaymSchedLineHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        while select forupdate vendPaymSchedLine
            join vendPaymSched
                where vendPaymSched.ExtTableId      == purchTable.TableId
                   && vendPaymSched.ExtRecId        == purchTable.RecId
                   && vendPaymSchedLine.FatherRecID == vendPaymSched.RecId
                   && vendPaymSchedLine.IsModified
        {
            if (!vendPaymSchedLine.IsDeleted)
            {
                vendPaymSchedLineHistory.clear();
                vendPaymSchedLineHistory.initVendPaymSchedLine(vendPaymSchedLine);
                vendPaymSchedLineHistory.ValidFrom  = _purchTableVersion.VersionDateTime;
                vendPaymSchedLineHistory.ValidTo    = _validTo;
                vendPaymSchedLineHistory.insert();
            }
            else
            {
                if (VersioningPurchaseOrderVendPaymSchedLineArchivingFlight::instance().isEnabled())
                {
                    while select forupdate vendPaymSchedLineHistory
                        where vendPaymSchedLineHistory.VendPaymSchedLine == vendPaymSchedLine.RecId
                    {
                        vendPaymSchedLineHistory.ValidTo = prevVersionValidTo;
                        vendPaymSchedLineHistory.update();
                    }
                }
                else
                {
                    update_recordset vendPaymSchedLineHistory
                        setting ValidTo = prevVersionValidTo
                        where vendPaymSchedLineHistory.VendPaymSchedLine == vendPaymSchedLine.RecId;
                }
            }

            if (vendPaymSchedLine.RecId != changedRecord.RecId)
            {
                vendPaymSchedLine.IsModified = NoYes::No;
                vendPaymSchedLine.doUpdate();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>change</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts document state after a change to its record.
    /// </summary>
    /// <param name="_newRecord">
    /// The new version of the record.
    /// </param>
    /// <param name="_oldRecord">
    /// The old version of the record.
    /// </param>
    /// <returns>
    /// true if version archiving was performed in effect of the change; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If the state is <c>InReview</c> and the workflow isn't editable it will throw an exception, otherwise it will propagate
    /// the call to the super class VersioningDocument
    /// </remarks>
    public boolean change(Common _newRecord, Common _oldRecord)
    {
        if (this.isChangeRequestRequired()
            && this.getDocumentState() == VersioningDocumentState::InReview
            && !this.editableInWorkflow())
        {
            throw error(strFmt("@SCM:ChangesToPurchaseOrderOnlyAllowedInDraftState", purchTable.PurchId));
        }
        
        return super(_newRecord, _oldRecord);
    }

]]></Source>
			</Method>
			<Method>
				<Name>confirm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the document state on the current purchase order version to Confirmed.
    /// </summary>
    public void confirm()
    {
        PurchTableHistory purchTableHistory;

        ttsbegin;

        super();

        if (purchTable.ChangeRequestRequired && this.isLastVersionArchived())
        {
            purchTableHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

            update_recordset purchTableHistory
                setting DocumentState = VersioningDocumentState::Confirmed
                where purchTableHistory.PurchId == purchTable.PurchId
                   && purchTableHistory.ValidTo == DateTimeUtil::maxValue();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createChangeRequest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new change request for the purchase order.
    /// </summary>
    public void createChangeRequest()
    {
        ttsbegin;

        // Setting the modified flag to enable archiving even in case of no changes.
        purchTable.IsModified = NoYes::Yes;

        super();

        this.updatePurchLineHistoryRemainderQuantities();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchLineHistoryRemainderQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the remainder quantities on PurchLineHistory records to be able to revert to them and use the deliver reminder function.
    /// </summary>
    private void updatePurchLineHistoryRemainderQuantities()
    {
        PurchLineHistory    purchLineHistory;
        PurchLine           purchLine;

        purchLineHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

        update_recordset purchLineHistory
            setting RemainPurchPhysical         = purchLine.RemainPurchPhysical,
                    RemainPurchFinancial        = purchLine.RemainPurchFinancial,
                    RemainInventPhysical        = purchLine.RemainInventPhysical,
                    RemainInventFinancial       = purchLine.RemainInventFinancial,
                    PdsCWRemainInventPhysical   = purchline.PdsCWRemainInventPhysical,
                    PdsCWRemainInventFinancial  = purchline.PdsCWRemainInventFinancial
            where purchLineHistory.PurchId == purchTable.PurchId
               && purchLineHistory.ValidTo == DateTimeUtil::maxValue()
               join purchLine
                   where purchLine.InventTransId == purchLineHistory.InventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new version record.
    /// </summary>
    /// <param name="_versionTimeStamp">
    /// A version timestamp that will be used by the new record.
    /// </param>
    /// <param name="_isProformaVersion">
    /// A <c>Boolean</c> value indicating whether the version is temporary proforma; optional.
    /// </param>
    /// <returns>
    /// The record ID of the version created.
    /// </returns>
    protected RefRecId createNewVersion(VersioningTimeStamp _versionTimeStamp = DateTimeUtil::utcNow(),
                                         boolean _isProformaVersion = false)
    {
        PurchTableVersion purchTableVersion;

        purchTableVersion.PurchId               = purchTable.PurchId;
        purchTableVersion.PurchIdDataAreaId     = purchTable.DataAreaId;
        purchTableVersion.VersionDateTime       = _versionTimeStamp;
        purchTableVersion.IsArchived            = NoYes::No;
        purchTableVersion.Proforma              = _isProformaVersion;
        purchTableVersion.insert();

        return purchTableVersion.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesHistoryExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the purchase order has ever been copied to the history tables.
    /// </summary>
    /// <returns>
    ///    true if any version of the purchase order occurs in the history tables; otherwise, false.
    /// </returns>
    public boolean doesHistoryExist()
    {
        return VersioningPurchaseOrder::doesHistoryExistRunOnServer(purchTable.PurchId,
                                                                    purchTable.DataAreaId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doMarkupTransChangesRequireConfirmation</Name>
				<Source><![CDATA[
    protected boolean doMarkupTransChangesRequireConfirmation()
    {
        PurchLine           purchLine;
        MarkupTrans         markupTrans;
        MarkupTransHistory  markupTransHistory;
        boolean             isChangeConfirmationRequired;

        // Line Markup
        while select markupTrans
            exists join purchLine
                where purchLine.PurchId         == purchTable.PurchId
                   && markupTrans.TransTableId  == purchLine.TableId
                   && markupTrans.TransRecId    == purchLine.RecId
                   && markupTrans.IsModified
        {
            select firstonly markupTransHistory
                where markupTransHistory.TransTableId           == markupTrans.TransTableId
                   && markupTransHistory.TransRecId             == markupTrans.TransRecId
                   && markupTransHistory.LineNum                == markupTrans.LineNum;

            isChangeConfirmationRequired = isChangeConfirmationRequired     // it was already detected that confirmation is needed
                || markupTrans.IsDeleted                                    // confirmation is always needed after markup deletion
                || !markupTransHistory                                      // if markup hasn't ever been archived it always needs confirmation.
                || markupTrans.MarkupTransMap::isChangeConfirmationRequired(markupTransHistory);
        }

        // Header Markup
        while select markupTrans
            where markupTrans.TransTableId  == purchTable.TableId
               && markupTrans.TransRecId    == purchTable.RecId
               && markupTrans.IsModified
        {
            select firstonly forupdate markupTransHistory
                where markupTransHistory.TransTableId           == markupTrans.TransTableId
                   && markupTransHistory.TransRecId             == markupTrans.TransRecId
                   && markupTransHistory.LineNum                == markupTrans.LineNum;

            isChangeConfirmationRequired = isChangeConfirmationRequired     // it was already detected that confirmation is needed
                || markupTrans.IsDeleted                                    // confirmation is always needed after markup deletion
                || !markupTransHistory                                      // if markup hasn't ever been archived it always needs confirmation.
                || markupTrans.MarkupTransMap::isChangeConfirmationRequired(markupTransHistory);
        }
        return isChangeConfirmationRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doPurchTableChangesRequireConfirmation</Name>
				<Source><![CDATA[
    protected boolean doPurchTableChangesRequireConfirmation()
    {
        PurchTableHistory   purchTableHistory;
        boolean             isChangeConfirmationRequired;

        if (purchTable.IsModified == NoYes::Yes)
        {
            select firstonly purchTableHistory
                where purchTableHistory.PurchId == purchTable.PurchId;

            isChangeConfirmationRequired =
                   !purchTableHistory                                       // if header hasn't ever been archived it always needs confirmation.
                || purchTable.purchTableVersioning().isChangeConfirmationRequired(purchTableHistory.purchTableVersioning());

            // If the buffer is shown in a form, we have to reread it to avoid version conflict

            if (FormDataUtil::getFormDataSource(purchTable))
            {
                FormDataUtil::getFormDataSource(purchTable).reread();
            }
        }
        return isChangeConfirmationRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>editableInWorkflow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns if this VersioningPurchaseOrder is in an editable workflow.
    /// </summary>
    /// <returns>
    ///    true if the versioning document is in an editable workflow; otherwise false.
    /// </returns>
    public boolean editableInWorkflow()
    {
        return purchTable.editAllowed(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDocumentState</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the state of the current purchase order version.
    /// </summary>
    /// <returns>
    ///    The state of the document.
    /// </returns>
    public VersioningDocumentState getDocumentState()
    {
        return purchTable.DocumentState;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChangeConfirmationRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether a change to a record will require a purchase order confirmation.
    /// </summary>
    /// <param name="_newRecord">
    /// The new version of the record.
    /// </param>
    /// <param name="_oldRecord">
    /// The old version of the record.
    /// </param>
    /// <returns>
    /// true if the change requires confirmation; otherwise, false .
    /// </returns>
    protected boolean isChangeConfirmationRequired(Common _newRecord, Common _oldRecord)
    {
        MarkupTrans             markupTrans;
        SourceDocumentHeader    sourceDocumentHeader;

        TableId     tableId = (_oldRecord ? _oldRecord.TableId : _newRecord.TableId);
        Tax1099BoxDetail    tax1099BoxDetail;
        boolean             pubSectReturnValue;

        switch (tableId)
        {
            case tableNum(PurchTable):
                PurchTable      newPurchTable       = _newRecord;
                PurchTableMap   oldPurchTableMap    = _oldRecord;

                return !oldPurchTableMap || !newPurchTable || newPurchTable.purchTableVersioning().isChangeConfirmationRequired(oldPurchTableMap.purchTableVersioning());

            case tableNum(PurchLine):
                PurchLine       newPurchLine    = _newRecord;
                PurchLineMap    oldPurchLineMap = _oldRecord;

                return !oldPurchLineMap || !newPurchLine || newPurchLine.purchLineVersioning().isChangeConfirmationRequired(oldPurchLineMap.purchLineVersioning());

            case tableNum(MarkupTrans):
                markupTrans = _newRecord;
                return !_oldRecord || !_newRecord || markupTrans.MarkupTransMap::isChangeConfirmationRequired(_oldRecord);

            case tableNum(SourceDocumentHeader):
                sourceDocumentHeader = _oldRecord;
                return (sourceDocumentHeader.AccountingStatus == SourceDocumentAccountingStatus::Completed);

            case tableNum(Tax1099BoxDetail):
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    tax1099BoxDetail = _newRecord;
                    pubSectReturnValue = tax1099BoxDetail.Tax1099BoxDetailMap::isChangeConfirmationRequired(_oldRecord);
                }
                return pubSectReturnValue;
            // <GEERU>
            case tableNum(RAssetPurchTrans):
                return !_oldRecord || !_newRecord;
            // </GEERU>

            case tableNum(TransportationDocument):
                if (Tax::isTaxIntegrationEnabledForBusinessProcess(TaxIntegrationBusinessProcess::Purchase))
                {
                    TransportationDocument transportationDocumentOrig = _oldRecord;
                    TransportationDocument transportationDocument = _newRecord;

                    return !transportationDocumentOrig
                        || !transportationDocument
                        || transportationDocument.LoadedPostalAddress != transportationDocumentOrig.LoadedPostalAddress;
                }
                return false;

            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChangeRequestRequired</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether change request for the purchase order is required.
    /// </summary>
    /// <returns>
    ///     true if change request is required; otherwise, false.
    /// </returns>
    protected boolean isChangeRequestRequired()
    {
        return purchTable.ChangeRequestRequired && !skipChangeRequest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLastVersionArchived</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the last version was archived in the history tables.
    /// </summary>
    /// <returns>
    /// false if the last version has not yet been archived to the history tables or there is no version
    /// yet; otherwise, true.
    /// </returns>
    public boolean isLastVersionArchived()
    {
        PurchTableVersion purchTableVersion;

        purchTableVersion = PurchTableVersion::findLatest(purchTable.PurchId, purchTable.DataAreaId);

        return !purchTableVersion || purchTableVersion.IsArchived;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks <c>PurchTable</c> record as modified by setting IsModifed to Yes when a document state is changed
    /// because a change to the record will require document confirmation.
    /// </summary>
    protected void markModified()
    {
        super();
        purchTable.IsModified = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchTable</Name>
				<Source><![CDATA[
    protected PurchTable parmPurchTable(PurchTable _purchTable = purchTable)
    {
        purchTable = _purchTable;

        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipChangeRequest</Name>
				<Source><![CDATA[
    public boolean parmSkipChangeRequest(boolean _skipChangeRequest = skipChangeRequest)
    {
        skipChangeRequest = _skipChangeRequest;

        return skipChangeRequest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipUpdatePurchTable</Name>
				<Source><![CDATA[
    protected boolean parmSkipUpdatePurchTable(boolean _skipUpdatePurchTable = skipUpdatePurchTable)
    {
        skipUpdatePurchTable = _skipUpdatePurchTable;

        return skipUpdatePurchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetToDraft</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the document state to draft by cancelling current change request or creating a new change request.
    /// </summary>
    /// <returns>true if status was reset; otherwise, false.</returns>
    public boolean resetToDraft()
    {
        if (!this.isChangeRequestRequired())
        {
            return false;
        }

        if (this.canChangeBeRequested())
        {
            this.createChangeRequest();
        }
        else if (this.canCancelChangeRequest())
        {
            this.cancelChangeRequest();
        }

        return this.getDocumentState() == VersioningDocumentState::Draft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>restorePreviousVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restores the previous purchase order version from the history tables.
    /// </summary>
    protected void restorePreviousVersion()
    {
        PurchTableVersion   purchTableVersion;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            // check if purchTableVersion exists.
            select firstonly purchTableVersion
                order by purchTableVersion.VersionDateTime desc
                where purchTableVersion.PurchId             == purchTable.PurchId
                   && purchTableVersion.PurchIdDataAreaId   == purchTable.DataAreaId;

            if (!purchTableVersion)
            {
                // No previous version exists. Unable to revert the changes.
                throw error("@SYS183903");
            }

            this.restoreTax1099BoxDetail();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>restoreTax1099BoxDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Restores <c>Tax1099BoxDetail</c> records of the purchase order to their earlier versions from the
    /// history table.
    /// </summary>
    protected void restoreTax1099BoxDetail()
    {
        PurchLine                  purchLine;
        Tax1099BoxDetail           tax1099BoxDetail;
        Tax1099BoxDetailHistory    tax1099BoxDetailHistory;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            while select forupdate tax1099BoxDetail
                join purchLine
                    where purchLine.PurchId == purchTable.PurchId &&
                        tax1099BoxDetail.RecId == purchLine.Tax1099RecId
                outer join tax1099BoxDetailHistory
                    where tax1099BoxDetailHistory.Tax1099BoxDetailRecId == tax1099BoxDetail.RecId
                       && tax1099BoxDetailHistory.ValidTo               == DateTimeUtil::maxValue()
            {
                if (!tax1099BoxDetailHistory)
                {
                    if (!tax1099BoxDetail.IsDeleted)
                    {
                        tax1099BoxDetail.delete();
                    }
                }
                else
                {
                    tax1099BoxDetail.initFromTax1099BoxDetailHistory(tax1099BoxDetailHistory);
                    tax1099BoxDetail.IsDeleted  = NoYes::No;
                    tax1099BoxDetail.update();

                    // second doUpdate is needed as the first update will always set IsModified to Yes.
                    tax1099BoxDetail.IsModified = NoYes::No;
                    tax1099BoxDetail.doUpdate();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendToVendor</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the current purchase order version, setting Document state to <c>InExternalReview</c> enum value.
    /// </summary>
    public void sendToVendor()
    {
        PurchTableHistory purchTableHistory;

        ttsbegin;

        super();

        if (purchTable.ChangeRequestRequired && this.isLastVersionArchived())
        {
            purchTableHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);

            update_recordset purchTableHistory
                setting DocumentState = VersioningDocumentState::InExternalReview
                where purchTableHistory.PurchId == purchTable.PurchId
                   && purchTableHistory.ValidTo == DateTimeUtil::maxValue();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchaseOrderHeaderDistribution</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the purchase order header distribution if required.
    /// </summary>
    private void updatePurchaseOrderHeaderDistribution()
    {
        if (purchTable.DocumentState == VersioningDocumentState::InReview
            || purchTable.DocumentState == VersioningDocumentState::Approved
            || purchTable.DocumentState == VersioningDocumentState::Draft)
        {
            Debug::assert(purchTable.SourceDocumentLine);
            SourceDocumentLine sourceDocumentLine = SourceDocumentLine::find(purchTable.SourceDocumentLine);
            boolean updateDistribution = !sourceDocumentLine.StateContainer ||
                                         sourceDocumentLine.StateContainer != SourceDocumentLineItem::newFromSourceDocumentLine(sourceDocumentLine).parmCurrentStateContainer();
                
            if (updateDistribution)
            {
                purchTable.type().updateDistribution();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChangeRequestInReviewForDraftPurchaseOrder</Name>
				<Source><![CDATA[
    private boolean isChangeRequestInReviewForDraftPurchaseOrder(PurchTable _purchTable, VersioningDocumentState _versioningState)
    {
        return _purchTable
            && this.isChangeRequestRequired()
            && _versioningState == VersioningDocumentState::InReview
            && _purchTable.DocumentState == VersioningDocumentState::Draft;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDocumentState</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the document state of the purchase order.
    /// </summary>
    /// <param name="_versioningState">
    ///     The state to be set.
    /// </param>
    protected void setDocumentState(VersioningDocumentState _versioningState)
    {
        ttsbegin;

        if (this.isChangeRequestInReviewForDraftPurchaseOrder(purchTable, _versioningState))
        {
            this.updatePurchaseOrderHeaderDistribution();
        }

        purchTable.selectForUpdate(true);
        purchTable.DocumentState = _versioningState;

        if (purchTable)
        {
            // Update the drop shipment status
            if ( purchTable.MCRDropShipment
                && (purchTable.DocumentState == VersioningDocumentState::Approved || purchTable.DocumentState == VersioningDocumentState::Confirmed)
                && (changedRecord.TableId != tableNum(PurchLine)) ) // Line update should be handled in the PurchLineType update method. Lines are exluded here to avoid record update conflicts.
            {
                MCRDropShipStatusUpdate::updateDropShipStatus(purchTable);
            }

            if (!this.parmSkipUpdatePurchTable())
            {
                using (var purchTableSkipBusinessLogicContext = PurchTableSkipBusinessLogicContext::construct())
                {
                    purchTableSkipBusinessLogicContext.parmSkipUpdate(true);
                    purchTable.update();
                }

                this.updatePurchaseOrderHeaderDistribution();

                // If the buffer is shown in a form, we have to reread it to avoid version conflict

                if (FormDataUtil::getFormDataSource(purchTable))
                {
                    FormDataUtil::getFormDataSource(purchTable).reread();
                }
            }
            else
            {
                this.updatePurchaseOrderHeaderDistribution();
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePurchLineHistoryValidTo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>ValidTo</c> field for effective <c>PurchLineHistory</c> table records.
    /// </summary>
    /// <param name="_purchId">
    /// A <c>PurchId</c> used to match <c>PurchLineHistory</c> records.
    /// </param>
    /// <param name="_validTo">
    /// A time stamp used to set effective <c>PurchLineHistory</c> record <c>ValidTo</c> field value.
    /// </param>
    protected void updatePurchLineHistoryValidTo(PurchId _purchId, VersioningTimeStamp _validTo)
    {
        PurchLineHistory    purchLineHistory;
        PurchLine           purchLine;

        // Note that select and update_recordset works different on date effective tables
        // In this case select is needed since only effective record matching where criteria is needed
        while select forupdate purchLineHistory
        exists join purchLine
            where purchLine.InventTransId == purchLineHistory.InventTransId
                && purchLine.PurchId == _purchId
                && purchLine.IsDeleted
                && purchLine.IsModified
        {
            purchLineHistory.validTimeStateUpdateMode(ValidTimeStateUpdate::Correction);
            purchLineHistory.ValidTo = _validTo;
            purchLineHistory.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>archivedTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a set of tables that will be archived.
    /// </summary>
    /// <returns>
    /// A set of tables.
    /// </returns>
    public static Set archivedTables()
    {
        Set tables = new Set(Types::Integer);

        tables.add(tableNum(AgreementLineReleasedLine));
        tables.add(tableNum(InventDim));
        tables.add(tableNum(MarkupTrans));
        tables.add(tableNum(PurchDeliverySchedule));
        tables.add(tableNum(PurchLine));
        tables.add(tableNum(PurchLineForeignTradeCategory));
        tables.add(tableNum(PurchPrepayTable));
        tables.add(tableNum(PurchTable));
        tables.add(tableNum(VendPaymSched));
        tables.add(tableNum(VendPaymSchedLine));

        return tables;
    }

]]></Source>
			</Method>
			<Method>
				<Name>archiveTable2Table</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the table ID of a table that is archived.
    /// </summary>
    /// <param name="_archiveTable">
    /// A table ID of an archived table.
    /// </param>
    /// <returns>
    /// The table ID of a table that is archived.
    /// </returns>
    public static TableId archiveTable2Table(TableId _archiveTable)
    {
        TableId tableId;

        switch (_archiveTable)
        {
            case    tableNum(PurchTable),
                    tableNum(PurchTableHistory):
                tableId = tableNum(PurchTable);
                break;

            case    tableNum(PurchLine),
                    tableNum(PurchLineHistory):
                tableId = tableNum(PurchLine);
                break;

            case    tableNum(AgreementLineReleasedLine),
                    tableNum(AgreementLineReleasedLineHistory):
                tableId = tableNum(AgreementLineReleasedLine);
                break;

            case    tableNum(MarkupTrans),
                    tableNum(MarkupTransHistory):
                tableId = tableNum(MarkupTrans);
                break;

            case    tableNum(PurchDeliverySchedule),
                    tableNum(PurchDeliveryScheduleHistory):
                tableId = tableNum(PurchDeliverySchedule);
                break;

            case    tableNum(PurchLineForeignTradeCategory),
                    tableNum(PurchLineForeignTradeCategoryHistory):
                tableId = tableNum(PurchLineForeignTradeCategory);
                break;

            case    tableNum(PurchPrepayTable),
                    tableNum(PurchPrepayTableHistory):
                tableId = tableNum(PurchPrepayTable);
                break;

            case    tableNum(VendPaymSched),
                    tableNum(VendPaymSchedHistory):
                tableId = tableNum(VendPaymSched);
                break;

            case    tableNum(VendPaymSchedLine),
                    tableNum(VendPaymSchedLineHistory):
                tableId = tableNum(VendPaymSched);
                break;

            case    tableNum(InventDim):
                tableId = tableNum(InventDim);
                break;
        }

        return tableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCanChangeBeRequested</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Determines whether a change request can be created.
    /// </summary>
    /// <param name="_purchTable">
    ///   A <c>PurchTable</c> record.
    /// </param>
    /// <returns>
    ///   true if a change request can be created; otherwise, false.
    /// </returns>
    static public boolean checkCanChangeBeRequested(PurchTable _purchTable)
    {
        return VersioningPurchaseOrder::newPurchaseOrder(_purchTable).canChangeBeRequested();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHistoryExist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether a purchase order has been copied to the history tables.
    /// </summary>
    /// <param name="_purchTable">
    /// A <c>PurchTable</c> record that stores the purchase order header for which to check if any history
    /// exists.
    /// </param>
    /// <returns>
    /// true if any version of the purchase order occurs in the history tables; otherwise, false.
    /// </returns>
    static public boolean checkHistoryExist(PurchTable _purchTable)
    {
        return VersioningPurchaseOrder::newPurchaseOrder(_purchTable).doesHistoryExist();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    protected static VersioningPurchaseOrder construct()
    {
        return new VersioningPurchaseOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesHistoryExistCacheInsert</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates cache entry which indicates that <c>PurchTableVersion</c> exists for specified purchase order.
    /// </summary>
    /// <param name="_purchId">
    ///     The <c>PurchId</c> of the purchase order.
    /// </param>
    /// <param name="_dataAreaId">
    ///     The <c>DataAreaId</c> of the purchase order.
    /// </param>
    public static void doesHistoryExistCacheInsert(PurchId _purchId, DataAreaId _dataAreaId)
    {
        SysGlobalObjectCache    sgoc    = new SysGlobalObjectCache();
        GlobalObjectCacheScope  gocs    = VersioningPurchaseOrder::doesHistoryExistCacheScope();
        container               key     = [_purchId, _dataAreaId];

        sgoc.insert(gocs, key, [1]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesHistoryExistCacheRemove</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Removes the cached return value of <c>doesHistoryExist</c> method
    /// from the <c>SysGlobalObjectCache</c> by specifying the corresponding purchase order.
    /// </summary>
    /// <param name="_purchId">
    ///     The <c>PurchId</c> of the purchase order.
    /// </param>
    /// <param name="_dataAreaId">
    ///     The <c>DataAreaId</c> of the purchase order.
    /// </param>
    public static void doesHistoryExistCacheRemove(PurchId _purchId, DataAreaId _dataAreaId)
    {
        SysGlobalObjectCache    sgoc    = new SysGlobalObjectCache();
        GlobalObjectCacheScope  gocs    = VersioningPurchaseOrder::doesHistoryExistCacheScope();
        container               key     = [_purchId, _dataAreaId];

        sgoc.remove(gocs, key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesHistoryExistCacheScope</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Generates the <c>GlobalObjectCacheScope</c> used for caching the return value
    /// of the <c>doesHistoryExist</c> method.
    /// </summary>
    /// <returns>
    ///     The generated <c>GlobalObjectCacheScope</c>.
    /// </returns>
    protected static GlobalObjectCacheScope doesHistoryExistCacheScope()
    {
        return classStr(VersioningPurchaseOrder) + methodStr(VersioningPurchaseOrder, doesHistoryExist);
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesHistoryExistRunOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the purchase order has ever been copied to the history tables.
    /// </summary>
    /// <param name="_purchId">
    ///     The <c>PurchId</c> of the purchase order.
    /// </param>
    /// <param name="_dataAreaId">
    ///     The <c>DataAreaId</c> of the purchase order.
    /// </param>
    /// <returns>
    ///    true if any version of the purchase order occurs in the history tables; otherwise, false.
    /// </returns>
    protected static boolean doesHistoryExistRunOnServer(PurchId _purchId, DataAreaId _dataAreaId)
    {
        SysGlobalObjectCache    sgoc = new SysGlobalObjectCache();
        GlobalObjectCacheScope  gocs = VersioningPurchaseOrder::doesHistoryExistCacheScope();
        container               key = [_purchId, _dataAreaId];
        container               cachedValue;
        boolean                 versionExists;

        cachedValue = sgoc.find(gocs, key);
        if (cachedValue == conNull())
        {
            versionExists = (select firstonly purchTableVersion
                                where purchTableVersion.PurchId             == _purchId
                                    && purchTableVersion.PurchIdDataAreaId   == _dataAreaId).RecId != 0;
            if (versionExists)
            {
                sgoc.insert(gocs, key, [versionExists]);
            }
            return versionExists;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args _args)
    {
        PurchTable purchTable;
        VersioningAction versioningAction;

        if (!_args)
            throw error("@SYS25407");

        purchTable = _args.record();
        versioningAction = _args.parmEnum();

        switch (versioningAction)
        {
            case VersioningAction::RequestChange :
                VersioningPurchaseOrder::newPurchaseOrder(purchTable).createChangeRequest();
                
                if (PurchWorkflowValueContainFractionInfologMessageFlight::instance().isEnabled()
                    && purchTable.DocumentState == VersioningDocumentState::Draft)
                {
                    SourceDocumentHeader    sourceDocumentHeader;
                    SourceDocumentLine      sourceDocumentLine;

                    sourceDocumentHeader = SourceDocumentHeader::find(purchTable.SourceDocumentHeader);
                    AccountingDistributionProcessor::cacheAccountingDistNumbersForHeader(sourceDocumentHeader);

                    while select sourceDocumentLine
                        where sourceDocumentLine.SourceDocumentHeader == sourceDocumentHeader.RecId
                        && sourceDocumentLine.ParentSourceDocumentLine == 0
                        && (sourceDocumentLine.AccountingStatus == SourceDocumentLineAccountingStatus::FullyDistributed)
                    {
                        SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(sourceDocumentLine.getSourceDocumentLineImplementation(),
                            false,
                            SourceDocumentLineAccountingStatus::Draft);
                    }

                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPurchaseOrder</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Constructs <c>VersioningPurchaseOrder</c> object for a purchase order.
    /// </summary>
    /// <param name="_purchTable">
    ///    A <c>PurchTable</c> record that stores the purchase order header for which to create the object.
    /// </param>
    /// <param name="_skipUpdatePurchTable">
    ///    A <c>boolean</c> that indicates if the update of the <c>PurchTable</c> record should be skiped; optional.
    /// </param>
    /// <returns>
    ///    The constructed instance of the <c>VersioningPurchaseOrder</c> class.
    /// </returns>
    public static VersioningPurchaseOrder newPurchaseOrder(PurchTable _purchTable, boolean _skipUpdatePurchTable = false)
    {
        VersioningPurchaseOrder versioningPurchaseOrder = VersioningPurchaseOrder::construct();
        versioningPurchaseOrder.parmPurchTable(_purchTable);
        versioningPurchaseOrder.parmSkipUpdatePurchTable(_skipUpdatePurchTable);
        return versioningPurchaseOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateItemReqOnCancelledPOApproval</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates Item requirement when related cancelled PO is submitted to workflow for approval
    /// </summary>
    private void updateItemReqOnCancelledPOApproval()
    {
        PurchLine purchLine;

        while select purchLine
            where purchLine.PurchId == purchTable.PurchId
                && purchLine.InventRefTransId
        {
            PurchLineType purchLineType = purchLine.type(purchTable);
            PurchLine purchLineOrig = purchLine.extensionOrig();
                    
            if (SalesLine::findInventTransId(purchLine.InventRefTransId).RecId &&
                purchLine.isStocked() &&
                !purchLine.type().isPurchTableInterCompanyOrder())
            {
                purchLineType.saveSynchronizedSalesLine(purchLineOrig, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>workFlowTrackingStatusTable</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected internal WorkflowTrackingStatusTable workFlowTrackingStatusTable()
    {
        return Workflow::findTrackingStatusForDocument(this.parmPurchTable());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCancelWorkflow</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected internal boolean canCancelWorkflow()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSynchronizeSalesLineRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to synchronize sales order line associated with purchase order line
    /// upon purchase order approval.
    /// </summary>
    /// <param name="_purchLine">
    /// <c>_purchLine</c> The purchase order line which is updated.
    /// </param>
    protected internal boolean mustSynchronizeSalesLineRef(PurchLine _purchLine)
    {
        boolean ret = false;

        if (_purchLine.ProjId
            && _purchLine.InventRefId
            && SalesLine::findInventTransId(_purchLine.InventRefTransId).RecId
            && ProjParameters::find().CreateItemReqForPO == NoYes::Yes
            && _purchLine.isStocked()
            && !_purchLine.type().isPurchTableInterCompanyOrder())
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>