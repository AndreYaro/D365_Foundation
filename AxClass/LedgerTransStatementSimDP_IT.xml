<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerTransStatementSimDP_IT</Name>
	<SourceCode>
		<Declaration><![CDATA[
[
    SRSReportQueryAttribute(queryStr(LedgerTransStatement)),
    SRSReportParameterAttribute(classStr(LedgerTransStatementSimContract_IT))
]
public class LedgerTransStatementSimDP_IT extends SRSReportDataProviderPreProcessTempDB
{
    public LedgerTransStatementTmp ledgerTransStatementTmp;
    public RefrecId primaryFocusRecId;
    public RefrecId secondaryFocusRecId;
    public str mainFocusName, secondaryFocusName;
    public SimulationJournalGroupId_IT simulationJournalGroupId;
    public NoYes includeSimulation;

    public static const char OffsetAccountSeparator = ',';

    protected PreferredLocale locale = new Session().preferredLocale();

    private SysInstrumentationLogger instrumentationLogger = SysInstrumentationLoggerFactory::CreateLogger(classStr(LedgerTransStatementSimDP_IT));

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateEndingBalanceInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ending balance for the ledger accounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_endDate">
    /// The end date for the report date range.
    /// </param>
    /// <param name="_dimensionsTransTableType">
    /// The <c>DimensionsTransTableType</c> type for which the report is run.
    /// </param>
    private void calculateEndingBalanceInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        TransDate _endDate,
        DimensionsTransTableType _dimensionsTransTableType)
    {
        LedgerTransStatementStagingTmp sourceTrans;
        FiscalPeriodType endingBalancePeriodType = 4; // One more than closing transactions
        TransTxt closingText;
        NoYes endingBalance = NoYes::Yes;
        CurrentOperationsTax currentLayer = CurrentOperationsTax::Current;

        // Ending balance
        closingText = "@SYS50986";

        this.setUserConnection(sourceTrans);
        sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        insert_recordset _ledgerTransStatementTmp
           (PostingLayer,
            PeriodCode,
            TransDate,
            AmountCredit,
            AmountDebit,
            ReportingCurrencyAmountCredit,
            ReportingCurrencyAmountDebit,
            MainFocusValue,
            MainFocusDescription,
            GeneralJournalEntryDataArea,
            TransTxt,
            IsEndingBalance,
            IsSimulation_IT)
        select
            currentLayer,
            endingBalancePeriodType,
            _endDate,
            sum(AmountCredit),
            sum(AmountDebit),
            sum(ReportingCurrencyAmountCredit),
            sum(ReportingCurrencyAmountDebit),
            MainFocusValue,
            MainFocusDescription,
            GeneralJournalEntryDataArea,
            closingText,
            endingBalance,
            IsSimulation_IT
        from sourceTrans
            group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea, sourceTrans.IsSimulation_IT
            where sourceTrans.RecordType != DimensionsTransRecordType::Aggregate; // Filter out the sub-total records so that amounts are not considered twice

        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit,
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountCredit = 0, // Set this to 0 to avoid double-counting in the report total
            AmountDebit = 0,  // Set this to 0 to avoid double-counting in the report total
            ReportingCurrencyAmountCredit = 0,
            ReportingCurrencyAmountDebit = 0
        where _ledgerTransStatementTmp.PeriodCode == endingBalancePeriodType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyToReportTable</Name>
				<Source><![CDATA[
    private void copyToReportTable(LedgerTransStatementStagingTmp _ledgerTransStmtStagingTmp)
    {
        NoYes isFinalTrue = NoYes::Yes;

        insert_recordset ledgerTransStatementTmp
        (
            MainFocusValue,
            MainFocusName,
            MainFocusDescription,
            PeriodCode,
            TransDate,
            Voucher,
            AmountDebit,
            AmountCredit,
            AccumulatedMST,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            ReportingAccumulatedMST,
            AmountCur,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            AmountMSTDebCred,
            CurrencyCode,
            GeneralJournalAccountEntry,
            GeneralJournalEntry,
            GeneralJournalEntryDataArea,
            PreviousCreditTotal,
            PreviousDebitTotal,
            Reversed,
            SecondaryFocus,
            SecondaryFocusName,
            TaxAmount,
            TaxCode,
            TraceNum,
            TransTxt,
            OffsetAccount,
            IsFinalRecord,
            BudgetModelId,
            LedgerPostingType,
            RecordType,
            BudgetTransactionStatus,
            IsEndingBalance,
            GroupRowNum,
            IsSimulation_IT
        )
        select
            MainFocusValue,
            MainFocusName,
            MainFocusDescription,
            PeriodCode,
            TransDate,
            Voucher,
            AmountDebit,
            AmountCredit,
            AccumulatedMST,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            ReportingAccumulatedMST,
            AmountCur,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            AmountMSTDebCred,
            CurrencyCode,
            GeneralJournalAccountEntry,
            GeneralJournalEntry,
            GeneralJournalEntryDataArea,
            PreviousCreditTotal,
            PreviousDebitTotal,
            Reversed,
            SecondaryFocus,
            SecondaryFocusName,
            TaxAmount,
            TaxCode,
            TraceNum,
            TransTxt,
            OffsetAccount,
            isFinalTrue,
            BudgetModelId,
            LedgerPostingType,
            RecordType,
            BudgetTransactionStatus,
            IsEndingBalance,
            GroupRowNum,
            IsSimulation_IT
            from _ledgerTransStmtStagingTmp
        // Re-order the records since the report prints in recid order and the opening transactions were calculated
        // after some initial operating records were created
        order by MainFocusValue, IsEndingBalance, SecondaryFocus, GeneralJournalEntryDataArea, PeriodCode, RecordType, TransDate, Voucher, TaxCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerTransStatementTmp</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets data from the <c>LedgerTransStatementTmp</c> temporary table.
    /// </summary>
    /// <returns>
    /// Data from the <c>LedgerTransStatementTmp</c> table.
    /// </returns>
    [SRSReportDataSetAttribute(tableStr(LedgerTransStatementTmp))]
    public LedgerTransStatementTmp getLedgerTransStatementTmp()
    {
        select ledgerTransStatementTmp;
  
        return ledgerTransStatementTmp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByDayInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by day.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByDayInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        TransDate currentDate = _fromDate;

        this.groupTransactionsForDayInStaging(_ledgerTransStatementTmp);

        // Loop until all days have been summarized
        while (currentDate <= _toDate)
        {
            if (_generateEmptyPeriods)
            {
                // When grouping by day, we don't need to set day name as transaction text so pass empty string
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, currentDate, '');
            }

            // Move to the next day
            currentDate += 1;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByMonthInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by month.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByMonthInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        int month;
        TransTxt transTxt;
  
        // Summarize by month
        FromDate monthStart = dateStartMth(_fromDate);
        ToDate monthEnd = dateEndMth(_fromDate);

        // Loop until all months have been summarized
        while (monthStart <= _toDate)
        {
            month = mthOfYr(monthStart);
            transTxt = mthName(month);

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, monthStart, monthEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, monthStart, transTxt);
            }

            // Move to the next month
            monthStart = dateStartMth(monthEnd + 1);
            monthEnd = dateEndMth(monthStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByPeriodInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by the fiscal calendar period.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByPeriodInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        FiscalCalendarPeriod period;
        FiscalCalendarRecId fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());
        TransTxt transTxt;
    
        // Summarize by period
        FromDate periodStart = LedgerFiscalCalendar::findFirstDayofPeriod(fiscalCalendar, _fromDate);
        ToDate periodEnd = LedgerFiscalCalendar::findLastDayofPeriod(fiscalCalendar, _fromDate);

        // Loop until all periods have been summarized
        while (periodStart <= _toDate)
        {
            period = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendar, periodStart);
            transTxt = period.Name;

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, periodStart, periodEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, periodStart, transTxt);
            }

            // Move to the next period
            periodStart = LedgerFiscalCalendar::findFirstDayofPeriod(fiscalCalendar, periodEnd + 1);
            periodEnd = LedgerFiscalCalendar::findLastDayofPeriod(fiscalCalendar, periodStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByQuarterInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by quarter.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByQuarterInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        int quarter;
        FiscalCalendarRecId fiscalCalendar = Ledger::fiscalCalendar(CompanyInfo::current());
        TransTxt transTxt;

        // Summarize by quarter
        FromDate quarterStart = FiscalCalendars::findFirstDayOfQuarter(fiscalCalendar, _fromDate);
        ToDate quarterEnd = FiscalCalendars::findLastDayOfQuarter(fiscalCalendar, _fromDate);

        // Loop until all quarters have been summarized
        while (quarterStart <= _toDate)
        {
            quarter = LedgerFiscalCalendar::findQuarterByDate(fiscalCalendar, quarterStart);
            transTxt = strFmt("@SYS24735", quarter);

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, quarterStart, quarterEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, quarterStart, transTxt);
            }

            // Move to the next quarter
            quarterStart = FiscalCalendars::findFirstDayOfQuarter(fiscalCalendar, quarterEnd + 1);
            quarterEnd = FiscalCalendars::findLastDayOfQuarter(fiscalCalendar, quarterStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupByWeekInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by week.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The from date.
    /// </param>
    /// <param name="_toDate">
    /// The to date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether empty periods must be generated.
    /// </param>
    private void groupByWeekInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, boolean _generateEmptyPeriods)
    {
        int week;
        TransTxt transTxt;
 
        // Summarize by week
        FromDate weekStart = LedgerTransStatementSimDP_IT::dateStartWeek(_fromDate);
        ToDate weekEnd = dateEndWk(_fromDate);

        // Loop until all weeks have been summarized
        while (weekStart <= _toDate)
        {
            week = weekOfYear(weekStart);
            transTxt = strFmt("@SYS24734", week);

            this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, weekStart, weekEnd, transTxt);

            if (_generateEmptyPeriods)
            {
                this.insertEmptyPeriodInStaging(_ledgerTransStatementTmp, weekStart, transTxt);
            }

            // Move to the next week
            weekStart = LedgerTransStatementSimDP_IT::dateStartWeek(weekEnd + 1);
            weekEnd = dateEndWk(weekStart);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupTransactionsByRangeInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by date range.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The start date of the date range.
    /// </param>
    /// <param name="_toDate">
    /// The end date of the date range.
    /// </param>
    /// <param name="_txt">
    /// The transaction text to be used for the grouped transactions.
    /// </param>
    private void groupTransactionsByRangeInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, FromDate _fromDate, ToDate _toDate, TransTxt _txt)
    {
        LedgerTransStatementStagingTmp tmpTransGrouped;
        NoYes yes = NoYes::Yes;
        AmountCur transactionCurrencyAmount;

        this.setUserConnection(tmpTransGrouped);
        tmpTransGrouped.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        // Group the operating transactions within the date range, updating their text
        insert_recordset tmpTransGrouped
           (
            MainFocusValue,
            MainFocusDescription,
            SecondaryFocus,
            GeneralJournalEntryDataArea,
            PeriodCode,
            TransDate,
            AmountDebit,
            AmountCredit,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            AmountCur,
            AmountMSTDebCred,
            PreviousCreditTotal,
            PreviousDebitTotal,
            TransTxt,
            IsFinalRecord,
            IsSimulation_IT)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                _fromDate,
                sum(AmountDebit),
                sum(AmountCredit),
                sum(ReportingCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                sum(AmountMSTDebCred),
                sum(PreviousCreditTotal),
                sum(PreviousDebitTotal),
                _txt,
                yes,
                IsSimulation_IT
            from _ledgerTransStatementTmp
            group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea, PeriodCode, IsSimulation_IT
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate;

        // Fill in the summation
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;

        // Delete the source transactions
        delete_from _ledgerTransStatementTmp
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::No;

        // Update the transactions that were copied to mark them as non-final
        update_recordSet _ledgerTransStatementTmp setting
            IsFinalRecord = NoYes::No
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.TransDate >= _fromDate
                && _ledgerTransStatementTmp.TransDate <= _toDate
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>groupTransactionsForDayInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups the transactions by day.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    private void groupTransactionsForDayInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementStagingTmp tmpTransGrouped;
        NoYes yes = NoYes::Yes;
        AmountCur transactionCurrencyAmount;

        this.setUserConnection(tmpTransGrouped);
        tmpTransGrouped.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        // Group the operating transactions by date
        insert_recordset tmpTransGrouped
           (
            MainFocusValue,
            MainFocusDescription,
            SecondaryFocus,
            GeneralJournalEntryDataArea,
            PeriodCode,
            TransDate,
            AmountDebit,
            AmountCredit,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            AmountCur,
            AmountMSTDebCred,
            PreviousCreditTotal,
            PreviousDebitTotal,
            IsFinalRecord,
            IsSimulation_IT)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                PeriodCode,
                TransDate,
                sum(AmountDebit),
                sum(AmountCredit),
                sum(ReportingCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                transactionCurrencyAmount,
                sum(AmountMSTDebCred),
                sum(PreviousCreditTotal),
                sum(PreviousDebitTotal),
                yes,
                IsSimulation_IT
            from _ledgerTransStatementTmp
            group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea, PeriodCode, TransDate, IsSimulation_IT
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating;

        // Fill in the summation
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountDebit
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;

        // Delete the source transactions
        delete_from _ledgerTransStatementTmp
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::No;

        // Update the transactions that were copied to mark them as non-final
        update_recordSet _ledgerTransStatementTmp setting
            IsFinalRecord = NoYes::No
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating
                && _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertEmptyPeriodInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts periods for dates that do not have operating transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_txt">
    /// The transaction text.
    /// </param>
    private void insertEmptyPeriodInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, TransDate _transDate, TransTxt _txt = '')
    {
        LedgerTransStatementStagingTmp tmpTransGrouped;
        NoYes yes = NoYes::Yes;
        AmountCur amount;
        FiscalPeriodType operating = FiscalPeriodType::Operating;

        this.setUserConnection(tmpTransGrouped);
        tmpTransGrouped.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        // Insert empty transactions for all combinations that don't have an operating or opening transaction
        // for the given date
        insert_recordset tmpTransGrouped
           (
            MainFocusValue,
            MainFocusDescription,
            SecondaryFocus,
            GeneralJournalEntryDataArea,
            PeriodCode,
            TransDate,
            AmountDebit,
            AmountCredit,
            TransactionCurrencyAmountDebit,
            TransactionCurrencyAmountCredit,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            AmountMSTDebCred,
            PreviousCreditTotal,
            PreviousDebitTotal,
            TransTxt,
            IsFinalRecord,
            IsSimulation_IT)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                operating,
                _transDate,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                amount,
                _txt,
                yes,
                IsSimulation_IT
            from _ledgerTransStatementTmp
            group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea, IsSimulation_IT
            notExists join tmpTransGrouped
            where tmpTransGrouped.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                && tmpTransGrouped.MainFocusDescription == _ledgerTransStatementTmp.MainFocusDescription
                && tmpTransGrouped.SecondaryFocus == _ledgerTransStatementTmp.SecondaryFocus
                && tmpTransGrouped.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea
                && tmpTransGrouped.IsSimulation_IT == _ledgerTransStatementTmp.IsSimulation_IT
                && (tmpTransGrouped.PeriodCode == FiscalPeriodType::Operating
                // Consider only opening transactions, not opening balance line
                || (tmpTransGrouped.PeriodCode == FiscalPeriodType::Opening
                        && tmpTransGrouped.TransTxt != "@SYS53035"))
                && tmpTransGrouped.TransDate == _transDate;

        // Update the transactions that were copied to mark them as non-final
        update_recordSet _ledgerTransStatementTmp setting
            IsFinalRecord = NoYes::No
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Operating &&
                _ledgerTransStatementTmp.TransDate == _transDate &&
                _ledgerTransStatementTmp.IsFinalRecord == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDimensionInformationInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates dimension focus values and descriptions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The main dimension focus name.
    /// </param>
    /// <param name="_secondaryDimensionFocusName">
    /// The secondary dimension focus name.
    /// </param>
    /// <remarks>
    /// This method generates focus values based on <c>LedgerDimension</c> values.
    /// </remarks>
    private void populateDimensionInformationInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Name _dimensionFocusName,
        Name _secondaryDimensionFocusName = '')
    {
        DimensionFocusNameTmp dimNameTmpMainValue;

        this.setUserConnection(dimNameTmpMainValue);

        Query focusNameQuery = new Query();
        SysQuery::findOrCreateDataSource(focusNameQuery, tableNum(LedgerTransStatementStagingTmp));

        // Add a link to DimensionAttributeValueCombination, which is required to populate the dimension values
        QueryBuildDataSource davcDS = SysQuery::findOrCreateDataSource(focusNameQuery, tableNum(DimensionAttributeValueCombination), tableNum(LedgerTransStatementStagingTmp));
        davcDS.addLink(fieldNum(LedgerTransStatementStagingTmp, LedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));

        // Generate a distinct list of ledger dimensions to generate values for
        LedgerTransStatementStagingTmp querySource;
        this.setUserConnection(querySource);

        insert_recordset querySource
            (LedgerDimension)
        select LedgerDimension from _ledgerTransStatementTmp
        group by LedgerDimension;

        // Set temp table as the source of the query using QueryRun because it supports TempDB tables
        QueryRun focusNameQueryRun = new QueryRun(focusNameQuery);
        focusNameQueryRun.setRecord(querySource);
        focusNameQuery = focusNameQueryRun.query();

        // Generate the main focus values
        DimensionFocusNameTmp::generateFocusNames(dimNameTmpMainValue, focusNameQuery, _dimensionFocusName, this.parmUserConnection());

        // Update _ledgerTransStatementTmp with the main focus value
        update_recordset _ledgerTransStatementTmp setting
            MainFocusValue = dimNameTmpMainValue.FocusValue,
            MainFocusName = _dimensionFocusName,
            SecondaryFocusName = _secondaryDimensionFocusName
            join dimNameTmpMainValue
                where dimNameTmpMainValue.LedgerDimension == _ledgerTransStatementTmp.LedgerDimension;

        // Do the same thing for the secondary focus (if specified)
        if (_secondaryDimensionFocusName)
        {
            DimensionFocusNameTmp dimNameTmpSecondaryValue;
            this.setUserConnection(dimNameTmpSecondaryValue);

            DimensionFocusNameTmp::generateFocusNames(dimNameTmpSecondaryValue, focusNameQuery, _secondaryDimensionFocusName, this.parmUserConnection());

            // Update _ledgerTransStatementTmp with the secondary focus value
            update_recordset _ledgerTransStatementTmp setting
                SecondaryFocus = dimNameTmpSecondaryValue.FocusValue
                join dimNameTmpSecondaryValue
                    where dimNameTmpSecondaryValue.LedgerDimension == _ledgerTransStatementTmp.LedgerDimension;
        }

        // Generate main focus descriptions
        // The original table instance can be reused since we've already copied the contents out.
        DimensionFocusNameTmp::generateFocusDescriptions(dimNameTmpMainValue, _dimensionFocusName, this.parmUserConnection());

        // Update _ledgerTransStatementTmp with the main focus descriptions
        update_recordset _ledgerTransStatementTmp setting
            MainFocusDescription = dimNameTmpMainValue.FocusValue
            join dimNameTmpMainValue
                where dimNameTmpMainValue.LedgerDimension == _ledgerTransStatementTmp.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateDimInformationCashFlowInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates dimension focus values and descriptions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The main dimension focus name.
    /// </param>
    /// <param name="_secondaryDimensionFocusName">
    /// The secondary dimension focus name.
    /// </param>
    /// <remarks>
    /// This method generates focus values based on <c>MainAccount</c> and <c>DefaultDimension</c> values.
    /// </remarks>
    private void populateDimInformationCashFlowInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Name _dimensionFocusName,
        Name _secondaryDimensionFocusName = '')
    {
        DimensionFocusNameTmp dimNameTmpMainValue, dimNameTmpMainDesc, dimNameTmpSecondaryValue;

        this.setUserConnection(dimNameTmpMainValue);
        this.setUserConnection(dimNameTmpMainDesc);
        this.setUserConnection(dimNameTmpSecondaryValue);

        // Populate the table with the records to be calculated
        insert_recordset dimNameTmpMainValue (MainAccount, DefaultDimension)
            select MainAccount, DefaultDimension from _ledgerTransStatementTmp
            group by _ledgerTransStatementTmp.MainAccount, _ledgerTransStatementTmp.DefaultDimension;

        DimensionFocusNameTmp::generateFocusNamesDefaultDimension(dimNameTmpMainValue, _dimensionFocusName);

        // Update _ledgerTransStatementTmp with the main focus values
        update_recordset _ledgerTransStatementTmp setting
            MainFocusValue = dimNameTmpMainValue.FocusValue,
            MainFocusName = _dimensionFocusName,
            SecondaryFocusName = _secondaryDimensionFocusName
            join dimNameTmpMainValue
                where dimNameTmpMainValue.DefaultDimension == _ledgerTransStatementTmp.DefaultDimension
                    && dimNameTmpMainValue.MainAccount == _ledgerTransStatementTmp.MainAccount;

        // Do the same thing for the secondary focus (if specified)
        if (_secondaryDimensionFocusName)
        {
            insert_recordset dimNameTmpSecondaryValue (MainAccount, DefaultDimension)
                select MainAccount, DefaultDimension from _ledgerTransStatementTmp
                group by _ledgerTransStatementTmp.MainAccount, _ledgerTransStatementTmp.DefaultDimension;

            DimensionFocusNameTmp::generateFocusNamesDefaultDimension(dimNameTmpSecondaryValue, _secondaryDimensionFocusName);

            // Update _ledgerTransStatementTmp with the secondary focus values
            update_recordset _ledgerTransStatementTmp setting
                SecondaryFocus = dimNameTmpSecondaryValue.FocusValue
                join dimNameTmpSecondaryValue
                where dimNameTmpSecondaryValue.DefaultDimension == _ledgerTransStatementTmp.DefaultDimension
                    && dimNameTmpSecondaryValue.MainAccount == _ledgerTransStatementTmp.MainAccount;
        }

        // Generate main focus descriptions
        insert_recordset dimNameTmpMainDesc (MainAccount, DefaultDimension)
            select MainAccount, DefaultDimension from _ledgerTransStatementTmp
                group by _ledgerTransStatementTmp.MainAccount, _ledgerTransStatementTmp.DefaultDimension;

        DimensionFocusNameTmp::generateFocusDescriptionsDefaultDim(dimNameTmpMainDesc, _dimensionFocusName, this.parmUserConnection());

        // Update _ledgerTransStatementTmp with the main focus descriptions
        update_recordset _ledgerTransStatementTmp setting
            MainFocusDescription = dimNameTmpMainDesc.FocusValue
            join dimNameTmpMainDesc
                where dimNameTmpMainDesc.DefaultDimension == _ledgerTransStatementTmp.DefaultDimension
                    && dimNameTmpMainDesc.MainAccount == _ledgerTransStatementTmp.MainAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTempTableBudgetInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the temp table for budget transaction type.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_query">
    /// The query to use for generating data.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    /// <param name="_endDate">
    /// The report end date.
    /// </param>
    private void populateTempTableBudgetInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Query _query,
        FromDate _startDate,
        ToDate _endDate)
    {
        boolean hasRangesOrFilters = SysQuery::queryHasRangesOrFilters(_query);
        RecordInsertList recordInsertList;
        TransDate periodStartDate;
        QueryBuildDataSource qbdsBTL, qbdsBTH, qbds;
        QueryRun queryRun;
        BudgetTransactionLine budgetTransactionLine;
        BudgetTransactionHeader budgetTransactionHeader;
        CurrentOperationsTax current = CurrentOperationsTax::Current;
        FiscalPeriodType opening = FiscalPeriodType::Opening;
        FiscalPeriodType operating = FiscalPeriodType::Operating;
        int i;

        periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), _startDate);

        if (hasRangesOrFilters)
        {
            // The query has multiple top level data sources all of which get run when the quer is run. We are interested in only
            // Budget records so disable the other top level data sources.
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);

                if (qbds.table() != tableNum(BudgetTransactionLine))
                {
                    qbds.enabled(false);
                }
            }

            // Ranges or filters exist, so the BudgetTransactionLine records to process must
            // be looped over individually. Group by RecId and include other
            // fields that are in the select list to populate the trans list.
            qbdsBTL = _query.dataSourceTable(tableNum(BudgetTransactionLine));

            // Filter to the current date range
            qbdsBTH = _query.dataSourceTable(tableNum(BudgetTransactionHeader));

            if (qbdsBTH == null)
            {
                qbdsBTH = qbdsBTL.addDataSource(tableNum(BudgetTransactionHeader));
                qbdsBTH.fetchMode(QueryFetchMode::One2One);
                qbdsBTH.joinMode(JoinMode::InnerJoin);
                qbdsBTH.addLink(fieldNum(BudgetTransactionLine, BudgetTransactionHeader), fieldNum(BudgetTransactionHeader, RecId));
            }

            qbdsBTH.addRange(fieldNum(BudgetTransactionHeader, Date)).value(SysQuery::range(periodStartDate, _endDate, true));
            qbdsBTH.addRange(fieldNum(BudgetTransactionHeader, PrimaryLedger)).value(queryValue(Ledger::current()));

            // Group by BudgetTransactionLine.RecId to prevent the cardinality of the result set from increasing
            // due to other data sources added by the user in the SysQuery form
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, RecId));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, BudgetTransactionHeader));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, LedgerDimension));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, Comment));
            qbdsBTL.addGroupByField(fieldNum(BudgetTransactionLine, TransactionCurrency));
            qbdsBTH.addGroupByField(fieldNum(BudgetTransactionHeader, Date));
            qbdsBTH.addGroupByField(fieldNum(BudgetTransactionHeader, TransactionNumber));

            // Fill the staging table with the set of budget records to process
            new SkipAOSValidationPermission().assert();
            recordInsertList = new RecordInsertList(tableNum(LedgerTransStatementStagingTmp), true, true, true, true, true, _ledgerTransStatementTmp);
            queryRun = new queryRun(_query);

            while (queryRun.next())
            {
                _ledgerTransStatementTmp.clear();

                budgetTransactionLine = queryRun.get(tableNum(BudgetTransactionLine)) as BudgetTransactionLine;
                _ledgerTransStatementTmp.GeneralJournalAccountEntry = budgetTransactionLine.RecId;
                _ledgerTransStatementTmp.GeneralJournalEntry = budgetTransactionLine.GeneralJournalEntry;
                _ledgerTransStatementTmp.LedgerDimension = budgetTransactionLine.LedgerDimension;
                _ledgerTransStatementTmp.TransTxt = budgetTransactionLine.Comment;
                _ledgerTransStatementTmp.CurrencyCode = budgetTransactionLine.TransactionCurrency;

                budgetTransactionHeader = queryRun.get(tableNum(BudgetTransactionHeader)) as BudgetTransactionHeader;
                _ledgerTransStatementTmp.TransDate = budgetTransactionHeader.Date;
                _ledgerTransStatementTmp.Voucher = budgetTransactionHeader.TransactionNumber;
                _ledgerTransStatementTmp.BudgetModelId = budgetTransactionHeader.BudgetModelId;
                _ledgerTransStatementTmp.BudgetTransactionStatus = budgetTransactionHeader.TransactionStatus;

                // All budget transactions are operating
                _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Operating;

                if (budgetTransactionHeader.Date < _startDate)
                {
                    // Special case where start date of the report is after the start of the period, so operating
                    // transactions should be treated as opening to include them in the opening balance
                    _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Opening;
                }

                recordInsertList.add(_ledgerTransStatementTmp);
            }

            recordInsertList.insertDatabase();
            CodeAccessPermission::revertAssert();

            // Re-enable the data sources to prevent problems in future runs
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);
                if (qbds.table() != tableNum(BudgetTransactionLine))
                {
                    qbds.enabled(true);
                }
            }
        }
        else
        {
            // No filters or ranges were added, so instead populate the table with a simple set-based insert
            insert_recordset _ledgerTransStatementTmp
                (GeneralJournalAccountEntry,
                GeneralJournalEntry,
                LedgerDimension,
                TransTxt,
                CurrencyCode,
                TransDate,
                PostingLayer,
                PeriodCode,
                Voucher,
                BudgetModelId,
                BudgetTransactionStatus)
                select
                    RecId,
                    BudgetTransactionHeader,
                    LedgerDimension,
                    Comment,
                    TransactionCurrency
                from budgetTransactionLine
                join
                    @Date,
                    current,
                    operating,
                    TransactionNumber,
                    BudgetModelId,
                    TransactionStatus
                from budgetTransactionHeader
                    where budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader
                        && budgetTransactionHeader.Date >= _startDate
                        && budgetTransactionHeader.Date <= _endDate
                        && budgetTransactionHeader.PrimaryLedger == Ledger::current();

            // Add any additional operating transactions between the period opening
            // and the start of the report and treat them as opening transactions
            // so that opening + operating == current balance
            if (_startDate > periodStartDate)
            {
                insert_recordset _ledgerTransStatementTmp
                    (GeneralJournalAccountEntry,
                    GeneralJournalEntry,
                    LedgerDimension,
                    TransTxt,
                    CurrencyCode,
                    TransDate,
                    PostingLayer,
                    PeriodCode,
                    Voucher,
                    BudgetModelId,
                    BudgetTransactionStatus)
                select
                    RecId,
                    BudgetTransactionHeader,
                    LedgerDimension,
                    Comment,
                    TransactionCurrency
                from budgetTransactionLine
                    join @Date, current, opening, TransactionNumber, BudgetModelId, TransactionStatus from budgetTransactionHeader where
                        budgetTransactionHeader.RecId == budgetTransactionLine.BudgetTransactionHeader &&
                        budgetTransactionHeader.Date >= periodStartDate &&
                        budgetTransactionHeader.Date < _startDate &&
                        budgetTransactionHeader.PrimaryLedger == Ledger::current();
            }
        }

        // Fill in the credit amount
        update_recordSet _ledgerTransStatementTmp setting
            AmountCredit = budgetTransactionLine.AccountingCurrencyAmount * -1,
            PreviousCreditTotal = budgetTransactionLine.AccountingCurrencyAmount * -1,
            TransactionCurrencyAmountCredit = budgetTransactionLine.TransactionCurrencyAmount * -1,
            AmountCur = budgetTransactionLine.TransactionCurrencyAmount
            join budgetTransactionLine 
                where budgetTransactionLine.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && budgetTransactionLine.AccountingCurrencyAmount < 0;

        // Fill in the debit amount
        update_recordSet _ledgerTransStatementTmp setting
            AmountDebit = budgetTransactionLine.AccountingCurrencyAmount,
            PreviousDebitTotal = budgetTransactionLine.AccountingCurrencyAmount,
            TransactionCurrencyAmountDebit = budgetTransactionLine.TransactionCurrencyAmount,
            AmountCur = budgetTransactionLine.TransactionCurrencyAmount
            join budgetTransactionLine 
                where budgetTransactionLine.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && budgetTransactionLine.AccountingCurrencyAmount > 0;

        // Fill in the summation
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateTempTableLedgerInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the temp table for ledger transaction type.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_query">
    /// The query to use for generating data.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    /// <param name="_endDate">
    /// The report end date.
    /// </param>
    /// <param name="_includeOpening">
    /// A boolean value indicating whether opening transactions must be treated as operating transactions.
    /// </param>
    /// <param name="_includeClosing">
    /// A boolean value indicating whether closing transactions must be considered.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimension focus name.
    /// </param>
    /// <param name="_includeIntercompanyTaxVoucher">
    /// A boolean value indicating whether to look for voucher data associated with intercompany tax posting.
    /// </param>
    private void populateTempTableLedgerInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        Query _query,
        FromDate _startDate,
        ToDate _endDate,
        boolean _includeOpening,
        boolean _includeClosing,
        Name _dimensionFocusName,
        boolean _includeIntercompanyTaxVoucher,
        boolean _includeSimulation,
        List _postingLayers = null)
    {
        TransDate periodStartDate;
        QueryBuildDataSource qbdsGJAE, qbdsGJE, qbdsFCP, qbds, qbdsLedger, qbdsCompanyInfo;
        QueryRun queryRun;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        GeneralJournalEntry generalJournalEntry;
        Ledger ledger;
        CompanyInfo companyInfo;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        FiscalPeriodType opening = FiscalPeriodType::Opening;
        GeneralJournalAccountEntrySim_IT generalJournalAccountEntrySim;
        GeneralJournalEntrySim_IT generalJournalEntrySim;
        int i;
        LedgerTransStatementStagingTmp localLedgerTransStatmentTmp;

        this.setUserConnection(localLedgerTransStatmentTmp);
        localLedgerTransStatmentTmp.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), _startDate);

        boolean hasRangesOrFilters = SysQuery::queryHasRangesOrFilters(_query);

        if (hasRangesOrFilters)
        {
            // The query has multiple top level data sources all of which get run when the quer is run. We are interested in only
            // Ledger records so disable the other top level data sources.
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);

                if (qbds.table() != tableNum(GeneralJournalAccountEntry) && qbds.table() != tableNum(GeneralJournalAccountEntrySim_IT))
                {
                    qbds.enabled(false);
                }
            }

            // Ranges or filters exist, so the GeneralJournalAccountEntry records to process must
            // be looped over individually. Group by RecId and include other
            // fields that are in the select list to populate the trans list.
            qbdsGJAE = _query.dataSourceTable(tableNum(GeneralJournalAccountEntry));

            // Filter to the current date range
            qbdsGJE = qbdsGJAE.addDataSource(tableNum(GeneralJournalEntry));
            qbdsGJE.fetchMode(QueryFetchMode::One2One);
            qbdsGJE.joinMode(JoinMode::InnerJoin);
            qbdsGJE.addLink(fieldNum(GeneralJournalAccountEntry, GeneralJournalEntry), fieldNum(GeneralJournalEntry, RecId));
            qbdsGJE.addRange(fieldNum(GeneralJournalEntry, AccountingDate)).value(SysQuery::range(periodStartDate, _endDate, true));
            qbdsGJE.addRange(fieldNum(GeneralJournalEntry, Ledger)).value(queryValue(Ledger::current()));

            // Get the fiscal period type
            qbdsFCP = qbdsGJE.addDataSource(tableNum(FiscalCalendarPeriod));
            qbdsFCP.fetchMode(QueryFetchMode::One2One);
            qbdsFCP.joinMode(JoinMode::InnerJoin);
            qbdsFCP.addLink(fieldNum(GeneralJournalEntry, FiscalCalendarPeriod), fieldnum(FiscalCalendarPeriod, RecId));

            // Get the company
            qbdsLedger = qbdsGJE.addDataSource(tableNum(Ledger));
            qbdsLedger.fetchMode(QueryFetchMode::One2One);
            qbdsLedger.joinMode(JoinMode::InnerJoin);
            qbdsLedger.addSelectionField(fieldNum(Ledger, PrimaryForLegalEntity));
            qbdsLedger.addLink(fieldNum(GeneralJournalEntry, Ledger), fieldnum(Ledger, RecId));

            qbdsCompanyInfo = qbdsLedger.addDataSource(tableNum(CompanyInfo));
            qbdsCompanyInfo.fetchMode(QueryFetchMode::One2One);
            qbdsCompanyInfo.joinMode(JoinMode::InnerJoin);
            qbdsCompanyInfo.addSelectionField(fieldNum(CompanyInfo, DataArea));
            qbdsCompanyInfo.addLink(fieldNum(Ledger, PrimaryForLegalEntity), fieldnum(CompanyInfo, RecId));

            // Filter out closing transactions if necessary
            if (!_includeClosing)
            {
                qbdsFCP.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(SysQuery::valueNot(FiscalPeriodType::Closing));
            }

            // Group by GeneralJournalAccountEntry.RecId to prevent the cardinality of the result set from increasing
            // due to other data sources added by the user in the SysQuery form
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, RecId));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, GeneralJournalEntry));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, Text));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
            qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntry, PostingType));
            qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntry, AccountingDate));
            qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntry, PostingLayer));
            qbdsFCP.addGroupByField(fieldNum(FiscalCalendarPeriod, Type));
            qbdsCompanyInfo.addGroupByField(fieldNum(CompanyInfo, DataArea));

            // Fill the staging table with the set of GJAE records to process
            new SkipAOSValidationPermission().assert();
            RecordInsertList recordInsertList = new RecordInsertList(tableNum(LedgerTransStatementStagingTmp), true, true, true, true, true, _ledgerTransStatementTmp);
            queryRun = new queryRun(_query);

            while (queryRun.next())
            {
                _ledgerTransStatementTmp.clear();

                generalJournalAccountEntry = queryRun.get(tableNum(GeneralJournalAccountEntry));

                _ledgerTransStatementTmp.GeneralJournalAccountEntry = generalJournalAccountEntry.RecId;
                _ledgerTransStatementTmp.GeneralJournalEntry = generalJournalAccountEntry.GeneralJournalEntry;
                _ledgerTransStatementTmp.LedgerDimension = generalJournalAccountEntry.LedgerDimension;
                _ledgerTransStatementTmp.TransTxt = generalJournalAccountEntry.Text;
                _ledgerTransStatementTmp.CurrencyCode = generalJournalAccountEntry.TransactionCurrencyCode;
                _ledgerTransStatementTmp.LedgerPostingType = generalJournalAccountEntry.PostingType;

                generalJournalEntry = queryRun.get(tableNum(GeneralJournalEntry)) as GeneralJournalEntry;
                _ledgerTransStatementTmp.TransDate = generalJournalEntry.AccountingDate;
                _ledgerTransStatementTmp.PostingLayer = generalJournalEntry.PostingLayer;

                fiscalCalendarPeriod = queryRun.get(tableNum(FiscalCalendarPeriod)) as FiscalCalendarPeriod;
                _ledgerTransStatementTmp.PeriodCode = fiscalCalendarPeriod.Type;
                _ledgerTransStatementTmp.IsSimulation_IT = false;

                if (_includeOpening && _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening && _startDate == periodStartDate)
                {
                    // Special case if this is an opening transaction and the date range includes the period start date and
                    // includeOpeningTransactions is selected, then the opening transactions should be treated like normal
                    // operating transactions to include them in the list of transactions
                    _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Operating;
                }
                else if (generalJournalEntry.AccountingDate < _startDate)
                {
                    // Other special case where start date of the report is after the start of the period, so operating
                    // transactions should be treated as opening to include them in the opening balance
                    _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Opening;
                }

                companyInfo = queryRun.get(tableNum(CompanyInfo)) as CompanyInfo;
                _ledgerTransStatementTmp.GeneralJournalEntryDataArea = companyInfo.DataArea;

                recordInsertList.add(_ledgerTransStatementTmp);
            }

            if (_includeSimulation)
            {
                Query querySim = new Query(QueryStr(LedgerTrialBalanceSim_IT));
                querySim = LedgerTransStatementSimDP_IT::createQuerySim(_query, querySim);

                // Ranges or filters exist, so the GeneralJournalAccountEntry records to process must
                // be looped over individually. Group by RecId and include other
                // fields that are in the select list to populate the trans list.
                qbdsGJAE = querySim.dataSourceTable(tableNum(GeneralJournalAccountEntrySim_IT));

                // Filter to the current date range
                qbdsGJE = querySim.dataSourceTable(tableNum(GeneralJournalEntrySim_IT));
                qbdsGJE.addRange(fieldNum(GeneralJournalEntrySim_IT, AccountingDate)).value(SysQuery::range(periodStartDate, _endDate, true));
                qbdsGJE.addRange(fieldNum(GeneralJournalEntrySim_IT, Ledger)).value(queryValue(Ledger::current()));

                // Group by GeneralJournalAccountEntry.RecId to prevent the cardinality of the result set from increasing
                // due to other data sources added by the user in the SysQuery form

                //new order of group fields
                qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntrySim_IT, AccountingDate));
                qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntrySim_IT, PostingLayer));
                qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntrySim_IT, FiscalCalendarPeriod));
                qbdsGJE.addGroupByField(fieldNum(GeneralJournalEntrySim_IT, Ledger));

                qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntrySim_IT, RecId));
                qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntrySim_IT, GeneralJournalEntry));
                qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntrySim_IT, LedgerDimension));
                qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntrySim_IT, Text));
                qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntrySim_IT, TransactionCurrencyCode));
                qbdsGJAE.addGroupByField(fieldNum(GeneralJournalAccountEntrySim_IT, PostingType));

                querySim.dataSourceTable(tableNum(SimulationJournalGroupTable_IT)).addRange(fieldNum(SimulationJournalGroupTable_IT, GroupId)).value(SysQuery::value(simulationJournalGroupId));

                // Fill the staging table with the set of GJAE records to process
                queryRun = new queryRun(querySim);

                while (queryRun.next())
                {
                    generalJournalEntrySim = queryRun.get(tableNum(GeneralJournalEntrySim_IT)) as GeneralJournalEntrySim_IT;

                    fiscalCalendarPeriod = FiscalCalendarPeriod::find(generalJournalEntrySim.FiscalCalendarPeriod);

                    if (!_includeClosing && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
                    {
                        continue;
                    }

                    _ledgerTransStatementTmp.clear();
                    _ledgerTransStatementTmp.TransDate = generalJournalEntrySim.AccountingDate;
                    _ledgerTransStatementTmp.PostingLayer = generalJournalEntrySim.PostingLayer;

                    generalJournalAccountEntrySim = queryRun.get(tableNum(GeneralJournalAccountEntrySim_IT));

                    _ledgerTransStatementTmp.GeneralJournalAccountEntry = generalJournalAccountEntrySim.RecId;
                    _ledgerTransStatementTmp.GeneralJournalEntry = generalJournalAccountEntrySim.GeneralJournalEntry;
                    _ledgerTransStatementTmp.LedgerDimension = generalJournalAccountEntrySim.LedgerDimension;
                    _ledgerTransStatementTmp.TransTxt = generalJournalAccountEntrySim.Text;
                    _ledgerTransStatementTmp.CurrencyCode = generalJournalAccountEntrySim.TransactionCurrencyCode;
                    _ledgerTransStatementTmp.LedgerPostingType = generalJournalAccountEntrySim.PostingType;

                    _ledgerTransStatementTmp.PeriodCode = fiscalCalendarPeriod.Type;
                    _ledgerTransStatementTmp.IsSimulation_IT = true;

                    if (_includeOpening && _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening && _startDate == periodStartDate)
                    {
                        // Special case if this is an opening transaction and the date range includes the period start date and
                        // includeOpeningTransactions is selected, then the opening transactions should be treated like normal
                        // operating transactions to include them in the list of transactions
                        _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Operating;
                    }
                    else if (generalJournalEntrySim.AccountingDate < _startDate)
                    {
                        // Other special case where start date of the report is after the start of the period, so operating
                        // transactions should be treated as opening to include them in the opening balance
                        _ledgerTransStatementTmp.PeriodCode = FiscalPeriodType::Opening;
                    }

                    companyInfo = CompanyInfo::findRecId(Ledger::find(generalJournalEntrySim.Ledger).PrimaryForLegalEntity);
                    _ledgerTransStatementTmp.GeneralJournalEntryDataArea = companyInfo.DataArea;

                    recordInsertList.add(_ledgerTransStatementTmp);
                }
            }

            recordInsertList.insertDatabase();
            CodeAccessPermission::revertAssert();

            // Re-enable the data sources
            for (i = 1; i <= _query.childDataSourceCount(); i++)
            {
                qbds = _query.childDataSourceNo(i);

                if (qbds.table() != tableNum(GeneralJournalAccountEntry) && qbds.table() != tableNum(GeneralJournalAccountEntrySim_IT))
                {
                    qbds.enabled(true);
                }
            }
        }
        else
        {
            SimulationJournalGroupLine_IT simulationJournalGroupLine;
            LedgerJournalTable ledgerJournalTable;
            LedgerEntryJournalSim_IT ledgerEntryJournalSim;

            // No filters or ranges were added, so instead populate the table with a simple set-based insert
            // optionally including closing transactions if required
            if (_includeClosing)
            {
                insert_recordset _ledgerTransStatementTmp
                    (GeneralJournalAccountEntry,
                    GeneralJournalEntry,
                    LedgerDimension,
                    LedgerPostingType,
                    TransTxt,
                    CurrencyCode,
                    TransDate,
                    PostingLayer,
                    GeneralJournalEntryDataArea,
                    PeriodCode)
                select
                    RecId,
                    GeneralJournalEntry,
                    LedgerDimension,
                    PostingType,
                    Text,
                    TransactionCurrencyCode
                from generalJournalAccountEntry
                join
                    AccountingDate,
                    PostingLayer
                from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    && generalJournalEntry.AccountingDate >= _startDate
                    && generalJournalEntry.AccountingDate <= _endDate
                    && generalJournalEntry.Ledger == Ledger::current()
                join ledger
                    where ledger.RecId == generalJournalEntry.Ledger
                join DataArea from companyInfo
                    where companyInfo.RecId == ledger.PrimaryForLegalEntity
                join Type from fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod;
            }
            else
            {
                insert_recordset _ledgerTransStatementTmp
                    (GeneralJournalAccountEntry,
                    GeneralJournalEntry,
                    LedgerDimension,
                    LedgerPostingType,
                    TransTxt,
                    CurrencyCode,
                    TransDate,
                    PostingLayer,
                    GeneralJournalEntryDataArea,
                    PeriodCode)
                select
                    RecId,
                    GeneralJournalEntry,
                    LedgerDimension,
                    PostingType,
                    Text,
                    TransactionCurrencyCode
                from generalJournalAccountEntry
                join AccountingDate, PostingLayer from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.AccountingDate >= _startDate
                        && generalJournalEntry.AccountingDate <= _endDate
                        && generalJournalEntry.Ledger == Ledger::current()
                join ledger
                    where ledger.RecId == generalJournalEntry.Ledger
                join DataArea from companyInfo
                    where companyInfo.RecId == ledger.PrimaryForLegalEntity
                join Type from fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type != FiscalPeriodType::Closing;
            }

            //insert simulation records
            if (_includeSimulation)
            {
                if (simulationJournalGroupId)
                {
                    insert_recordset _ledgerTransStatementTmp
                        (GeneralJournalAccountEntry,
                        GeneralJournalEntry,
                        LedgerDimension,
                        TransTxt,
                        CurrencyCode,
                        IsSimulation_IT,
                        TransDate,
                        PostingLayer,
                        GeneralJournalEntryDataArea,
                        PeriodCode)
                    select
                        RecId,
                        GeneralJournalEntry,
                        LedgerDimension,
                        Text,
                        TransactionCurrencyCode,
                        _includeSimulation
                    from generalJournalAccountEntrySim
                    join AccountingDate, PostingLayer from generalJournalEntrySim
                        where generalJournalEntrySim.RecId == generalJournalAccountEntrySim.GeneralJournalEntry
                            && generalJournalEntrySim.AccountingDate >= _startDate
                            && generalJournalEntrySim.AccountingDate <= _endDate
                            && generalJournalEntrySim.Ledger == Ledger::current()
                    join ledger
                        where ledger.RecId == generalJournalEntrySim.Ledger
                    join DataArea from companyInfo
                        where companyInfo.RecId == ledger.PrimaryForLegalEntity
                    join Type from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == generalJournalEntrySim.FiscalCalendarPeriod
                            && fiscalCalendarPeriod.Type != FiscalPeriodType::Closing;
                }
                else
                {
                    insert_recordset _ledgerTransStatementTmp
                        (GeneralJournalAccountEntry,
                        GeneralJournalEntry,
                        LedgerDimension,
                        TransTxt,
                        CurrencyCode,
                        IsSimulation_IT,
                        TransDate,
                        PostingLayer,
                        GeneralJournalEntryDataArea,
                        PeriodCode)
                    select
                        RecId,
                        GeneralJournalEntry,
                        LedgerDimension,
                        Text,
                        TransactionCurrencyCode,
                        _includeSimulation
                    from generalJournalAccountEntrySim
                    join AccountingDate, PostingLayer from generalJournalEntrySim
                        where generalJournalEntrySim.RecId == generalJournalAccountEntrySim.GeneralJournalEntry
                            && generalJournalEntrySim.AccountingDate >= _startDate
                            && generalJournalEntrySim.AccountingDate <= _endDate
                            && generalJournalEntrySim.Ledger == Ledger::current()
                    join ledger
                        where ledger.RecId == generalJournalEntrySim.Ledger
                    join DataArea from companyInfo
                        where companyInfo.RecId == ledger.PrimaryForLegalEntity
                    join Type from fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == generalJournalEntrySim.FiscalCalendarPeriod
                            && fiscalCalendarPeriod.Type != FiscalPeriodType::Closing
                    exists join ledgerEntryJournalSim where
                        generalJournalEntrySim.LedgerEntryJournal == ledgerEntryJournalSim.RecId
                    join ledgerJournalTable where
                        ledgerEntryJournalSim.LedgerJournalTableDataAreaId == ledgerJournalTable.dataAreaId &&
                        ledgerEntryJournalSim.JournalNumber == ledgerJournalTable.JournalNum &&
                        ledgerJournalTable.Posted == NoYes::No
                    join simulationJournalGroupLine where
                        simulationJournalGroupLine.JournalName == ledgerJournalTable.JournalName &&
                        simulationJournalGroupLine.SimulationJournalGroupId == simulationJournalGroupId;
                }
            }

            // Update for the special case of opening transactions being included in the date range and includeOpening being specified
            // so those transactions should be treated as regular operating transactions
            if (_includeOpening && periodStartDate == _startDate)
            {
                update_recordSet _ledgerTransStatementTmp setting
                    PeriodCode = FiscalPeriodType::Operating
                    where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening;
            }

            // Add any additional operating transactions between the period opening and the start of the report and treat them as
            // opening transactions so that opening + operating == current balance
            if (_startDate > periodStartDate)
            {
                this.insertOpeningAndOperatingBalances(
                    _ledgerTransStatementTmp,
                    _postingLayers,
                    _startDate,
                    periodStartDate,
                    _dimensionFocusName,
                    _includeSimulation);
            }
        }

        // Include revenue/expense posting entry(s) associated with intercompany tax postings
        if (_includeIntercompanyTaxVoucher)
        {
            TaxTrans taxTrans;
            TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntryForTax, taxTransGeneralJournalAccountEntryForVoucher;

            insert_recordset localLedgerTransStatmentTmp
                (GeneralJournalAccountEntry,
                GeneralJournalEntry,
                LedgerDimension,
                LedgerPostingType,
                TransTxt,
                CurrencyCode,
                TransDate,
                PostingLayer,
                PeriodCode,
                GeneralJournalEntryDataArea)
                select _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.LedgerPostingType == LedgerPostingType::Tax
                join taxTransGeneralJournalAccountEntryForTax
                    where taxTransGeneralJournalAccountEntryForTax.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                        && taxTransGeneralJournalAccountEntryForTax.TaxTransRelationship == TaxTransRelationshipType::Tax
                join taxTrans
                    where taxTrans.RecId == taxTransGeneralJournalAccountEntryForTax.TaxTrans
                        && taxTrans.TaxObligationCompany == TaxObligationCompany::Source
                join taxTransGeneralJournalAccountEntryForVoucher
                    where taxTransGeneralJournalAccountEntryForVoucher.TaxTrans == taxTrans.RecId
                        && taxTransGeneralJournalAccountEntryForVoucher.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                join RecId, GeneralJournalEntry, LedgerDimension, PostingType, Text, TransactionCurrencyCode
                    from generalJournalAccountEntry
                    where generalJournalAccountEntry.RecId == taxTransGeneralJournalAccountEntryForVoucher.GeneralJournalAccountEntry
                join AccountingDate, PostingLayer
                    from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                join Type
                    from fiscalCalendarPeriod
                    where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                        && fiscalCalendarPeriod.Type != FiscalPeriodType::Closing
                join ledger
                    where ledger.RecId == generalJournalEntry.Ledger
                join DataArea
                    from companyInfo
                    where companyInfo.RecId == ledger.PrimaryForLegalEntity
                        && companyInfo.DataArea != taxTrans.dataAreaId;// ignore entries from the same company as they will already be included

            // Identify revenue/expense posting entry(s) associated with intercompany tax postings opening balance transactions
            if (_startDate > periodStartDate)
            {
                update_recordSet localLedgerTransStatmentTmp setting
                    PeriodCode = opening
                where localLedgerTransStatmentTmp.GeneralJournalEntryDataArea != taxTrans.dataAreaId
                    && localLedgerTransStatmentTmp.TransDate < _startDate;
            }
        }

        // Fill in the credit amount
        update_recordSet _ledgerTransStatementTmp setting
            AmountCredit = - generalJournalAccountEntry.AccountingCurrencyAmount,
            PreviousCreditTotal = - generalJournalAccountEntry.AccountingCurrencyAmount,
            TransactionCurrencyAmountCredit = - generalJournalAccountEntry.TransactionCurrencyAmount
        where _ledgerTransStatementTmp.IsSimulation_IT == false
        join generalJournalAccountEntry
            where generalJournalAccountEntry.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                && generalJournalAccountEntry.IsCredit == true;

        update_recordSet _ledgerTransStatementTmp setting
            AmountCredit = - generalJournalAccountEntrySim.AccountingCurrencyAmount,
            PreviousCreditTotal = - generalJournalAccountEntrySim.AccountingCurrencyAmount,
            TransactionCurrencyAmountCredit = - generalJournalAccountEntrySim.TransactionCurrencyAmount
            where _ledgerTransStatementTmp.IsSimulation_IT == true
            join generalJournalAccountEntrySim
                where generalJournalAccountEntrySim.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && generalJournalAccountEntrySim.IsCredit == true;

        // Fill in the debit amount
        update_recordSet _ledgerTransStatementTmp setting
            AmountDebit = generalJournalAccountEntry.AccountingCurrencyAmount,
            PreviousDebitTotal = generalJournalAccountEntry.AccountingCurrencyAmount,
            TransactionCurrencyAmountDebit = generalJournalAccountEntry.TransactionCurrencyAmount
            where _ledgerTransStatementTmp.IsSimulation_IT == false
            join generalJournalAccountEntry where
                generalJournalAccountEntry.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                && generalJournalAccountEntry.IsCredit == false;

        update_recordSet _ledgerTransStatementTmp setting
            AmountDebit = generalJournalAccountEntrySim.AccountingCurrencyAmount,
            PreviousDebitTotal = generalJournalAccountEntrySim.AccountingCurrencyAmount,
            TransactionCurrencyAmountDebit = generalJournalAccountEntrySim.TransactionCurrencyAmount
            where _ledgerTransStatementTmp.IsSimulation_IT == true
            join generalJournalAccountEntrySim where
                generalJournalAccountEntrySim.RecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                && generalJournalAccountEntrySim.IsCredit == false;

        // Fill in the summation
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit;

        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry, subledgerVoucherGeneralJournalEntry2;
        SubledgerVoucherGeneralJournalEntrySim_IT subledgerVoucherGeneralJournalEntrySim, subledgerVoucherGeneralJournalEntrySim2;
            
        // Fill in voucher information
        update_recordSet _ledgerTransStatementTmp setting
            Voucher = subledgerVoucherGeneralJournalEntry.Voucher
            where _ledgerTransStatementTmp.IsSimulation_IT == false
            join subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry
            notExists join subledgerVoucherGeneralJournalEntry2
            // Only fill in voucher if summarization didn't happen
            where subledgerVoucherGeneralJournalEntry2.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry
                && subledgerVoucherGeneralJournalEntry2.RecId != subledgerVoucherGeneralJournalEntry.RecId;

        update_recordSet _ledgerTransStatementTmp setting
            Voucher = subledgerVoucherGeneralJournalEntrySim.Voucher
            where _ledgerTransStatementTmp.IsSimulation_IT == true
            join subledgerVoucherGeneralJournalEntrySim
                where subledgerVoucherGeneralJournalEntrySim.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry
            notExists join subledgerVoucherGeneralJournalEntrySim2
            // Only fill in voucher if summarization didn't happen
            where subledgerVoucherGeneralJournalEntrySim2.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry
                && subledgerVoucherGeneralJournalEntrySim2.RecId != subledgerVoucherGeneralJournalEntrySim.RecId;

        // Fill in the voucher information for summarized records
        update_recordSet _ledgerTransStatementTmp setting
        Voucher = "@SYS342661" // This label is the text "Summarized"
        where _ledgerTransStatementTmp.Voucher == '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertOpeningAndOperatingBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Add any additional operating transactions between the period opening and the start of the report and treat them as
    /// opening transactions so that opening + operating == current balance
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_postingLayers">
    /// The posting layer criteria to filter the report by.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    /// <param name="_periodStartDate">
    /// The period start date.
    /// </param>
    /// <param name="_dimensionFocusName">
    /// The dimension focus name.
    /// </param>
    /// <param name="_includeSimulation">
    /// Include simulations.
    /// </param>
    private void insertOpeningAndOperatingBalances(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        List _postingLayers,
        FromDate _startDate,
        FromDate _periodStartDate,
        Name _dimensionFocusName,
        boolean _includeSimulation)
    {
        using (var activity = instrumentationLogger.activityContext(
            classStr(LedgerTransStatementSimDP_IT),
            methodStr(LedgerTransStatementSimDP_IT, insertOpeningAndOperatingBalances)))
        {
            FiscalCalendarPeriod fiscalCalendarPeriod;
            GeneralJournalAccountEntrySim_IT generalJournalAccountEntrySim;
            GeneralJournalEntrySim_IT generalJournalEntrySim;
            Ledger ledger;
            CompanyInfo companyInfo;
            FiscalPeriodType opening = FiscalPeriodType::Opening;

            if (FeatureStateProvider::IsFeatureEnabled(GeneralLedgerBalanceFeature::instance()))
            {
                DimensionHierarchy focusDimensionHierarchy = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, _dimensionFocusName);
                RefRecId mainAccountDimensionAttributeRecId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);
                DimensionHierarchyLevel mainAccountLevel = DimensionHierarchyLevel::findByDimensionHierarchyAndDimAttribute(focusDimensionHierarchy.RecId, mainAccountDimensionAttributeRecId);
                Map dimensionFilterMap = this.getQueryTableFieldFilter(this.parmQuery(), tableNum(DimensionAttributeValueCombination));
                Map mainAccountFilterMap;

                if (mainAccountLevel)
                {
                    mainAccountFilterMap = this.getQueryTableFieldFilter(this.parmQuery(), tableNum(MainAccount));
                }

                LedgerTransStatementOpeningBalance openingBalance = LedgerTransStatementOpeningBalance::newForLedgerTransStatementDP(
                this.parmUserConnection(),
                    _ledgerTransStatementTmp,
                    _startDate,
                    _periodStartDate,
                    _postingLayers,
                    focusDimensionHierarchy,
                    mainAccountFilterMap,
                    dimensionFilterMap);

                openingBalance.insertOpeningAndOperatingBalancesV2();
            }
            else
            {
                DimensionFocusBalance dimensionFocusBalance;

                insert_recordset _ledgerTransStatementTmp
                    (LedgerDimension,
                    TransDate,
                    PostingLayer,
                    PeriodCode,
                    AmountCredit,
                    TransactionCurrencyAmountCredit,
                    PreviousCreditTotal,
                    AmountDebit,
                    TransactionCurrencyAmountDebit,
                    PreviousDebitTotal,
                    GeneralJournalEntryDataArea)
                select
                    FocusLedgerDimension,
                    minOf(AccountingDate),
                    PostingLayer,
                    opening,
                    sum(CreditAccountingCurrencyAmount),
                    sum(CreditAccountingCurrencyAmount),
                    sum(CreditAccountingCurrencyAmount),
                    sum(DebitAccountingCurrencyAmount),
                    sum(DebitAccountingCurrencyAmount),
                    sum(DebitAccountingCurrencyAmount)
                from dimensionFocusBalance
                group by FocusLedgerDimension, PostingLayer
                where dimensionFocusBalance.AccountingDate >= _periodStartDate
                    && dimensionFocusBalance.AccountingDate < _startDate
                    && dimensionFocusBalance.Ledger == Ledger::current()
                    && (dimensionFocusBalance.FiscalCalendarPeriodType == FiscalPeriodType::Opening
                        || dimensionFocusBalance.FiscalCalendarPeriodType == FiscalPeriodType::Operating)
                    && dimensionFocusBalance.FocusDimensionHierarchy == DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, _dimensionFocusName).RecId
                join ledger
                    where ledger.RecId == dimensionFocusBalance.Ledger
                join DataArea from companyInfo
                    group by DataArea
                    where companyInfo.RecId == ledger.PrimaryForLegalEntity;
            }

            if (_includeSimulation)
            {
                if (!simulationJournalGroupId)
                {
                    insert_recordset _ledgerTransStatementTmp
                        (GeneralJournalAccountEntry,
                        GeneralJournalEntry,
                        LedgerDimension,
                        TransTxt,
                        CurrencyCode,
                        IsSimulation_IT,
                        GeneralJournalEntryDataArea,
                        TransDate,
                        PostingLayer,
                        PeriodCode)
                    select
                        RecId,
                        GeneralJournalEntry,
                        LedgerDimension,
                        Text,
                        TransactionCurrencyCode,
                        _includeSimulation
                    from generalJournalAccountEntrySim
                        order by generalJournalEntrySim.AccountingDate, generalJournalAccountEntrySim.IsCredit
                    join ledger
                        where ledger.RecId == generalJournalEntrySim.Ledger
                    join DataArea from companyInfo
                        where companyInfo.RecId == ledger.PrimaryForLegalEntity
                    join
                        AccountingDate,
                        PostingLayer,
                        opening
                    from generalJournalEntrySim
                        where generalJournalEntrySim.RecId == generalJournalAccountEntrySim.GeneralJournalEntry
                            && generalJournalEntrySim.AccountingDate >= _periodStartDate
                            && generalJournalEntrySim.AccountingDate < _startDate
                            && generalJournalEntrySim.Ledger == Ledger::current()
                    exists join fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == generalJournalEntrySim.FiscalCalendarPeriod
                            && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating;
                }
                else
                {
                    SimulationJournalGroupLine_IT simulationJournalGroupLine;
                    LedgerJournalTable ledgerJournalTable;
                    LedgerEntryJournalSim_IT ledgerEntryJournalSim;

                    insert_recordset _ledgerTransStatementTmp
                        (GeneralJournalAccountEntry,
                        GeneralJournalEntry,
                        LedgerDimension,
                        TransTxt,
                        CurrencyCode,
                        IsSimulation_IT,
                        GeneralJournalEntryDataArea,
                        TransDate,
                        PostingLayer,
                        PeriodCode)
                    select
                        RecId,
                        GeneralJournalEntry,
                        LedgerDimension,
                        Text,
                        TransactionCurrencyCode,
                        _includeSimulation
                    from generalJournalAccountEntrySim
                        order by generalJournalEntrySim.AccountingDate, generalJournalAccountEntrySim.IsCredit
                    join ledger
                        where ledger.RecId == generalJournalEntrySim.Ledger
                    join DataArea from companyInfo
                        where companyInfo.RecId == ledger.PrimaryForLegalEntity
                    join
                        AccountingDate,
                        PostingLayer,
                        opening
                    from generalJournalEntrySim
                        where generalJournalEntrySim.RecId == generalJournalAccountEntrySim.GeneralJournalEntry
                            && generalJournalEntrySim.AccountingDate >= _periodStartDate
                            && generalJournalEntrySim.AccountingDate < _startDate
                            && generalJournalEntrySim.Ledger == Ledger::current()
                    exists join fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == generalJournalEntrySim.FiscalCalendarPeriod
                            && fiscalCalendarPeriod.Type == FiscalPeriodType::Operating
                    exists join ledgerEntryJournalSim where
                        generalJournalEntrySim.LedgerEntryJournal == ledgerEntryJournalSim.RecId
                    join ledgerJournalTable where
                        ledgerEntryJournalSim.LedgerJournalTableDataAreaId == ledgerJournalTable.dataAreaId &&
                        ledgerEntryJournalSim.JournalNumber == ledgerJournalTable.JournalNum &&
                        ledgerJournalTable.Posted == NoYes::No
                    join simulationJournalGroupLine where
                        simulationJournalGroupLine.JournalName == ledgerJournalTable.JournalName &&
                        simulationJournalGroupLine.SimulationJournalGroupId == simulationJournalGroupId;
                }
            }

            update_recordSet _ledgerTransStatementTmp setting
                AmountCredit = - _ledgerTransStatementTmp.AmountCredit,
                TransactionCurrencyAmountCredit = - _ledgerTransStatementTmp.TransactionCurrencyAmountCredit,
                PreviousCreditTotal = - _ledgerTransStatementTmp.PreviousCreditTotal
            where _ledgerTransStatementTmp.GeneralJournalAccountEntry == 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildFieldMap</Name>
				<Source><![CDATA[
    private void buildFieldMap(Query _reportQuery, Map _fieldMap)
    {
        QueryBuildDataSource gjaeDS = _reportQuery.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        QueryBuildDataSource gjeDS = _reportQuery.dataSourceTable(tableNum(GeneralJournalEntry));
        QueryBuildDataSource fcpDS = _reportQuery.dataSourceTable(tableNum(FiscalCalendarPeriod));
        QueryBuildDataSource companyInfoDS = _reportQuery.dataSourceTable(tableNum(CompanyInfo));

        if (!companyInfoDS || !gjeDS || !gjaeDS || !fcpDS)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        _reportQuery.clearAllFields();

        // General journal entry fields
        int gjeUniqueId = gjeDS.uniqueId();
        QueryBuildFieldList gjeFL = gjeDS.fields();

        gjeFL.addField(fieldNum(GeneralJournalEntry, AccountingDate));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, TransDate), [gjeUniqueId, fieldStr(GeneralJournalEntry, AccountingDate)]);

        gjeFL.addField(fieldNum(GeneralJournalEntry, PostingLayer));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, PostingLayer), [gjeUniqueId, fieldStr(GeneralJournalEntry, PostingLayer)]);

        gjeFL.addField(fieldNum(GeneralJournalEntry, RecId));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalEntry), [gjeUniqueId, fieldStr(GeneralJournalEntry, RecId)]);

        // General journal account entry fields
        int gjaeUniqueId = gjaeDS.uniqueId();
        QueryBuildFieldList gjaeFL = gjaeDS.fields();

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, RecId));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalAccountEntry), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, RecId)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, LedgerDimension));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, LedgerDimension), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, LedgerDimension)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, Text));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, TransTxt), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, Text)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, TransactionCurrencyCode));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, CurrencyCode), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, TransactionCurrencyCode)]);

        gjaeFL.addField(fieldNum(GeneralJournalAccountEntry, PostingType));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, LedgerPostingType), [gjaeUniqueId, fieldStr(GeneralJournalAccountEntry, PostingType)]);

        // Fiscal calendar period fields
        int fcpUniqueId = fcpDS.uniqueId();
        QueryBuildFieldList fcpFL = fcpDS.fields();

        fcpFL.addField(fieldNum(FiscalCalendarPeriod, Type));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, PeriodCode), [fcpUniqueId, fieldStr(FiscalCalendarPeriod, Type)]);

        // Company info fields
        int companyInfoUniqueId = companyInfoDS.uniqueId();
        QueryBuildFieldList companyInfoFL = companyInfoDS.fields();

        companyInfoFL.addField(fieldNum(CompanyInfo, DataArea));
        _fieldMap.insert(fieldStr(LedgerTransStatementStagingTmp, GeneralJournalEntryDataArea), [companyInfoUniqueId, fieldStr(CompanyInfo, DataArea)]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>processGroupPerSecondaryDimInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates sub-totals by grouping per secondary dimension.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    private void processGroupPerSecondaryDimInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementStagingTmp sourceTrans;

        DimensionsTransRecordType aggregateRecordType = DimensionsTransRecordType::Aggregate;
        TransTxt subTotal = "@SYS7470";

        // Use Closing type for transactions containing sub-total since we want the sub-totals
        // to appear at the end of the transaction list
        FiscalPeriodType closing = FiscalPeriodType::Closing;

        this.setUserConnection(sourceTrans);
        sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        insert_recordset _ledgerTransStatementTmp
            (MainFocusValue,
            MainFocusDescription,
            SecondaryFocus,
            GeneralJournalEntryDataArea,
            TransTxt,
            PeriodCode,
            RecordType,
            AmountDebit,
            AmountCredit,
            ReportingCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            IsSimulation_IT)
            select
                MainFocusValue,
                MainFocusDescription,
                SecondaryFocus,
                GeneralJournalEntryDataArea,
                subTotal,
                closing,
                aggregateRecordType,
                sum(AmountDebit),
                sum(AmountCredit),
                sum(ReportingCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                IsSimulation_IT
            from sourceTrans
                group by MainFocusValue, MainFocusDescription, SecondaryFocus, GeneralJournalEntryDataArea, IsSimulation_IT
                where sourceTrans.PeriodCode == FiscalPeriodType::Operating;

        // Update the summation
        update_recordSet _ledgerTransStatementTmp setting
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processLayerInformationInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the temp table records for the given posting layer.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    /// <param name="_postingLayer">
    /// The posting layer.
    /// </param>
    private void processLayerInformationInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, OperationsTax _postingLayer)
    {
        // Since the standard case for running this report is to include all
        // current layer transactions and they represent the vast majority
        // of all records, it is more efficient to just pull in all layer information
        // and then selectively operate on the data instead of trying to
        // fix up all layer information during the initial data creation
        switch (_postingLayer)
        {
            case OperationsTax::Current:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Current;
                break;
            case OperationsTax::DminusS: // Operations - Tax
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Operations
                        && _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Tax;

                update_recordSet _ledgerTransStatementTmp setting
                    AmountCredit = - _ledgerTransStatementTmp.AmountCredit,
                    AmountDebit = - _ledgerTransStatementTmp.AmountDebit
                    where _ledgerTransStatementTmp.PostingLayer == CurrentOperationsTax::Tax;
                break;
            case OperationsTax::OnlyOperations:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Operations;
                break;
            case OperationsTax::OnlyTax:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Tax;
                break;
            case OperationsTax::Operations:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Operations
                        && _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Current;
                break;
            case OperationsTax::OperationsPlusTax:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Operations
                        && _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Tax;
                break;
            case OperationsTax::Tax:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Tax
                        && _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Current;
                break;
            case OperationsTax::Total:
                // Do nothing for total because all transactions should be included
                break;
            case OperationsTax::WarehouseCur_RU:
                delete_from _ledgerTransStatementTmp
                    where _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::WarehouseCur_RU
                        && _ledgerTransStatementTmp.PostingLayer != CurrentOperationsTax::Current;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOffsetAccountInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates offset accounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> buffer.
    /// </param>
    private void processOffsetAccountInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementOffsetAccountTmp offsetAccountTmp;
        MainAccount mainAccount;
        GeneralJournalAccountEntry generalJournalAccountEntry;
        DimensionAttributeValueCombination dimensionAttributeValueCombination;

        this.setUserConnection(offsetAccountTmp);

        // Start by pushing all data to process into a seperate temp table where
        // the individual account values can be dropped into individual columns
        insert_recordset offsetAccountTmp (GeneralJournalEntry, GeneralJournalAccountEntry)
            select GeneralJournalEntry, GeneralJournalAccountEntry from _ledgerTransStatementTmp;

        // Fill in the first offset account (where possible)
        update_recordSet offsetAccountTmp
            setting OffsetAcct1 = mainAccount.MainAccountId
            join MainAccountId 
                from mainAccount
            exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
            exists join generalJournalAccountEntry
                where generalJournalAccountEntry.LedgerDimension == dimensionAttributeValueCombination.RecId
                    && generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry
                    && offsetAccountTmp.IsSimulation_IT == false;

        GeneralJournalAccountEntrySim_IT generalJournalAccountEntrySim;

        update_recordSet offsetAccountTmp
            setting OffsetAcct1 = mainAccount.MainAccountId
            join mainAccount
            exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
            exists join generalJournalAccountEntrySim
                where generalJournalAccountEntrySim.LedgerDimension == dimensionAttributeValueCombination.RecId
                    && generalJournalAccountEntrySim.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntrysim.RecId != offsetAccountTmp.GeneralJournalAccountEntry
                    && offsetAccountTmp.IsSimulation_IT == true;

        // Fill in the second offset account (where possible)
        update_recordSet offsetAccountTmp
            setting OffsetAcct2 = mainAccount.MainAccountId
        join MainAccountId from mainAccount
            where mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct1
        exists join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
        exists join generalJournalAccountEntry
            where generalJournalAccountEntry.LedgerDimension == dimensionAttributeValueCombination.RecId
                && generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry
                && offsetAccountTmp.IsSimulation_IT == false;

        update_recordSet offsetAccountTmp
            setting OffsetAcct2 = mainAccount.MainAccountId
            join mainAccount
                where mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct1
            exists join dimensionAttributeValueCombination
                where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
            exists join generalJournalAccountEntrySim
                where generalJournalAccountEntrySim.LedgerDimension == dimensionAttributeValueCombination.RecId
                    && generalJournalAccountEntrySim.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                    && generalJournalAccountEntrySim.RecId != offsetAccountTmp.GeneralJournalAccountEntry
                    && offsetAccountTmp.IsSimulation_IT == true;

        // Fill in the third offset account (where possible)
        update_recordSet offsetAccountTmp
            setting OffsetAcct3 = mainAccount.MainAccountId
        join MainAccountId from mainAccount
            where mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct1
                && mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct2
        exists join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
        exists join generalJournalAccountEntry
            where generalJournalAccountEntry.LedgerDimension == dimensionAttributeValueCombination.RecId
                && generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry;

        // Use a label for all cases where more than three accounts exist
        update_recordSet offsetAccountTmp setting
            IsMoreThanThree = NoYes::Yes,
            OffsetDescription = "@SYS78137" // Multiple
        exists join mainAccount
            where mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct1
                && mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct2
                && mainAccount.MainAccountId != offsetAccountTmp.OffsetAcct3
        exists join dimensionAttributeValueCombination
            where dimensionAttributeValueCombination.MainAccount == mainAccount.RecId
        exists join generalJournalAccountEntry
            where generalJournalAccountEntry.LedgerDimension == dimensionAttributeValueCombination.RecId
                && generalJournalAccountEntry.GeneralJournalEntry == offsetAccountTmp.GeneralJournalEntry
                && generalJournalAccountEntry.RecId != offsetAccountTmp.GeneralJournalAccountEntry;

        // Concatenate the values into a total
        update_recordset offsetAccountTmp setting
            OffsetDescription = offsetAccountTmp.OffsetAcct1
            where offsetAccountTmp.OffsetAcct1
                && offsetAccountTmp.IsMoreThanThree == NoYes::No;

        update_recordset offsetAccountTmp setting
            OffsetDescription = offsetAccountTmp.OffsetDescription + OffsetAccountSeparator + offsetAccountTmp.OffsetAcct2
            where offsetAccountTmp.OffsetAcct2
                && offsetAccountTmp.IsMoreThanThree == NoYes::No;

        update_recordset offsetAccountTmp setting
            OffsetDescription = offsetAccountTmp.OffsetDescription + OffsetAccountSeparator + offsetAccountTmp.OffsetAcct3
            where offsetAccountTmp.OffsetAcct3
                && offsetAccountTmp.IsMoreThanThree == NoYes::No;

        // Copy the descriptions back to the source table
        update_recordSet _ledgerTransStatementTmp setting
            OffsetAccount = offsetAccountTmp.OffsetDescription
            join offsetAccountTmp
                where offsetAccountTmp.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && offsetAccountTmp.GeneralJournalEntry == _ledgerTransStatementTmp.GeneralJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processOpeningTransactionsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the opening transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The report start date.
    /// </param>
    /// <param name="_generateOpeningForNormalAccounts">
    /// A boolean value indicating whether accounts with transactions within the date range should have opening transactions.
    /// </param>
    private void processOpeningTransactionsInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp, 
        TransDate _fromDate, 
        boolean _generateOpeningForNormalAccounts)
    {
        LedgerTransStatementStagingTmp sourceTrans;
        LedgerTransStatementStagingTmp sourceTransNotExists;
        NoYes yes = NoYes::Yes;
        FiscalPeriodType opening = FiscalPeriodType::Opening;
        TransTxt openingText = "@SYS53035";
        CurrentOperationsTax currentLayer = CurrentOperationsTax::Current;
        boolean isSim = false;

        this.setUserConnection(sourceTrans);
        sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        this.setUserConnection(sourceTransNotExists);
        sourceTransNotExists.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        if (!_generateOpeningForNormalAccounts)
        {
            delete_from _ledgerTransStatementTmp
                where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening
                exists join sourceTrans
                    where sourceTrans.MainFocus == _ledgerTransStatementTmp.MainFocus
                        && sourceTrans.MainFocusName == _ledgerTransStatementTmp.MainFocusValue
                        && sourceTrans.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea
                        && sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusDescription
                        && sourceTrans.PeriodCode == FiscalPeriodType::Operating;
        }

        // Sum up all transactions by main focus and insert one opening transaction per combination
        insert_recordset _ledgerTransStatementTmp
           (IsGroupedOpeningTrans,
            PostingLayer,
            PeriodCode,
            AmountCredit,
            AmountDebit,
            TransactionCurrencyAmountCredit,
            TransactionCurrencyAmountDebit,
            ReportingCurrencyAmountCredit,
            ReportingCurrencyAmountDebit,
            MainFocusValue,
            MainFocusDescription,
            TransTxt,
            TransDate,
            GeneralJournalEntryDataArea,
            IsSimulation_IT)
            select
                yes,
                currentLayer,
                opening,
                sum(AmountCredit),
                sum(AmountDebit),
                sum(TransactionCurrencyAmountCredit),
                sum(TransactionCurrencyAmountDebit),
                sum(ReportingCurrencyAmountCredit),
                sum(ReportingCurrencyAmountDebit),
                MainFocusValue,
                MainFocusDescription,
                openingText,
                _fromDate,
                GeneralJournalEntryDataArea,
                IsSimulation_IT
            from sourceTrans
            group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea, sourceTrans.IsSimulation_IT
            where sourceTrans.PeriodCode == FiscalPeriodType::Opening;

        if (_generateOpeningForNormalAccounts)
        {
            // Insert zero balance opening records for those without any opening transactions
            insert_recordset _ledgerTransStatementTmp
               (IsGroupedOpeningTrans,
                PostingLayer,
                PeriodCode,
                MainFocusValue,
                GeneralJournalEntryDataArea,
                MainFocusDescription,
                TransTxt,
                TransDate,
                IsSimulation_IT)
                select
                    yes,
                    currentLayer,
                    opening,
                    MainFocusValue,
                    GeneralJournalEntryDataArea,
                    MainFocusDescription,
                    openingText,
                    _fromDate,
                    isSim
                    from sourceTrans
                    group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea
                where sourceTrans.IsSimulation_IT == false
                notExists join sourceTransNotExists
                    where sourceTransNotExists.MainFocusValue == sourceTrans.MainFocusValue
                        && sourceTransNotExists.IsGroupedOpeningTrans == true
                        && sourceTransNotExists.IsSimulation_IT == false;

            isSim = true;

            insert_recordset _ledgerTransStatementTmp
                (IsGroupedOpeningTrans,
                PostingLayer,
                PeriodCode,
                MainFocusValue,
                GeneralJournalEntryDataArea,
                MainFocusDescription,
                TransTxt,
                TransDate,
                IsSimulation_IT)
                select
                    yes,
                    currentLayer,
                    opening,
                    MainFocusValue,
                    GeneralJournalEntryDataArea,
                    MainFocusDescription,
                    openingText,
                    _fromDate,
                    isSim
                from sourceTrans
                group by sourceTrans.MainFocusValue, sourceTrans.MainFocusDescription, sourceTrans.GeneralJournalEntryDataArea
                where sourceTrans.IsSimulation_IT == true
                notExists join sourceTransNotExists
                    where sourceTransNotExists.MainFocusValue == sourceTrans.MainFocusValue
                        && sourceTransNotExists.IsGroupedOpeningTrans == true
                        && sourceTransNotExists.IsSimulation_IT == true;
        }

        // Delete the source records
        delete_from _ledgerTransStatementTmp
            where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening
                && _ledgerTransStatementTmp.IsGroupedOpeningTrans == false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes the report business logic.
    /// </summary>
    public void processReport()
    {
        LedgerTransStatementSimContract_IT contract = this.parmDataContract() as LedgerTransStatementSimContract_IT;
        DimensionsTransTableType dimensionsTransTableType = contract.parmTransaction();
        FromDate fromDate = contract.parmFromDate();
        ToDate toDate = contract.parmToDate();
        LedgerTransStatementStagingTmp ledgerTransStatementStagingTmp;

        mainFocusName = contract.parmPrimaryDimensionFocus();
        secondaryFocusName = contract.parmSecondaryDimensionFocus();
        primaryFocusRecId   = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, mainFocusName).RecId;
        secondaryFocusRecId = DimensionHierarchy::findByTypeAndName(DimensionHierarchyType::Focus, secondaryFocusName).RecId;

        this.setUserConnection(ledgerTransStatementTmp);
        this.setUserConnection(ledgerTransStatementStagingTmp);

        includeSimulation = contract.parmIncludeSimulation();
        simulationJournalGroupId = contract.parmSimulationJournalGroupId();

        // Populate the base processing table with data from the appropriate source table
        switch (dimensionsTransTableType)
        {
            case DimensionsTransTableType::LedgerBudget:
                this.populateTempTableBudgetInStaging(ledgerTransStatementStagingTmp, this.parmQuery(), fromDate, toDate);

                // Fill in the focus names and descriptions
                this.populateDimensionInformationInStaging(ledgerTransStatementStagingTmp, mainFocusName, secondaryFocusName);

                break;

            case DimensionsTransTableType::LedgerTrans:
                this.populateTempTableLedgerInStaging(
                    ledgerTransStatementStagingTmp,
                    this.parmQuery(),
                    fromDate,
                    toDate,
                    contract.parmOpeningTrans(),
                    contract.parmClosingTrans(),
                    contract.parmPrimaryDimensionFocus(),
                    contract.parmDisplayCompanyForLedgerAccount(),
                    includeSimulation);

                // Fill in the focus names and descriptions
                this.populateDimensionInformationInStaging(ledgerTransStatementStagingTmp, mainFocusName, secondaryFocusName);

                break;
        }

        // Process reversed transaction values
        this.processReversedTransactionsInStaging(ledgerTransStatementStagingTmp, contract.parmIncludeReversed());

        // Process "without trans" parameter. Run this after processReversedTransactions because that might delete
        // records if "Include reversed" is unmarked. processWithoutTrans should
        // run after unwanted records have been removed so that all accounts without operating transactions
        // are removed by processWithoutTrans
        this.processWithoutTransInStaging(
            ledgerTransStatementStagingTmp,
            contract.parmWithoutTrans(),
            contract.parmOpeningTrans(),
            contract.parmFromDate());

        // Group opening transactions
        if (dimensionsTransTableType == DimensionsTransTableType::LedgerTrans
            || dimensionsTransTableType == DimensionsTransTableType::LedgerBudget)
        {
            this.processOpeningTransactionsInStaging(ledgerTransStatementStagingTmp, fromDate, true);
        }
        else if (dimensionsTransTableType == DimensionsTransTableType::LedgerCov)
        {
            if (contract.parmWithoutTrans())
            {
                // We don't need opening balances for cash flow
                this.processOpeningTransactionsInStaging(ledgerTransStatementStagingTmp, fromDate, false);
            }
            else
            {
                // If "without Trans" is not selected, we only need to show the ledger accounts that have transactions
                // within the date range. Since we add transactions that are in the same period but outside the
                // date range as Opening transactions, delete such transactions
                delete_from ledgerTransStatementStagingTmp
                    where ledgerTransStatementStagingTmp.PeriodCode == FiscalPeriodType::Opening;
            }
        }

        // Sales tax specification
        if (contract.parmSalesTaxSpec())
        {
            this.processSalesTaxSpecificationInStaging(ledgerTransStatementStagingTmp, fromDate, toDate);
        }

        // Set offset account
        if (contract.parmOffsetAccount())
        {
            this.processOffsetAccountInStaging(ledgerTransStatementStagingTmp);
        }

        // Group by specification and generate records for empty periods if needed
        this.processSpecificationGroupingInStaging(
            ledgerTransStatementStagingTmp,
            contract.parmSpecification(),
            fromDate,
            toDate,
            contract.parmEmptyPeriods());

        if (dimensionsTransTableType == DimensionsTransTableType::LedgerCov && contract.parmWithoutTrans())
        {
            delete_from ledgerTransStatementStagingTmp
            where ledgerTransStatementStagingTmp.PeriodCode == FiscalPeriodType::Opening;
        }

        // Group by secondary dimension set - Subtotals are inserted as Closing transactions
        if (contract.parmGroupPerSec())
        {
            this.processGroupPerSecondaryDimInStaging(ledgerTransStatementStagingTmp);
        }

        // Calculate ending balance
        this.calculateEndingBalanceInStaging(ledgerTransStatementStagingTmp, toDate, dimensionsTransTableType);

        // Populate the accumulated and balance amounts for opening transactions
        this.updateOpeningAmountsInStaging(ledgerTransStatementStagingTmp);

        this.copyToReportTable(ledgerTransStatementStagingTmp);

        ledgerTransStatementStagingTmp = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processReversedTransactionsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes reversed transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_includeReversed">
    /// A boolean value indicating whether reversed transactions must be included.
    /// </param>
    private void processReversedTransactionsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, boolean _includeReversed)
    {
        TransactionReversalTrans transactionReversalTrans;

        if (_includeReversed)
        {
            // Set the trace number and reversed flag for reversed transactions
            // Reversed transactions so TransactionReversalTrans.Reversed flag will be true. Show "R" next to Trace number
            update_recordset _ledgerTransStatementTmp setting
                TraceNum = transactionReversalTrans.TraceNum,
                Reversed = "@SYS321480"
                join transactionReversalTrans
                    where transactionReversalTrans.RefTableId == tableNum(GeneralJournalAccountEntry)
                        && transactionReversalTrans.RefRecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                        && transactionReversalTrans.Reversed == NoYes::Yes;

            // Revoked transactions so TransactionReversalTrans.Reversed flag will be false. Don't show "R"
            update_recordset _ledgerTransStatementTmp setting
                TraceNum = transactionReversalTrans.TraceNum
                join transactionReversalTrans
                    where transactionReversalTrans.RefTableId == tableNum(GeneralJournalAccountEntry)
                        && transactionReversalTrans.RefRecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                        && transactionReversalTrans.Reversed == NoYes::No;
        }
        else
        {
            // Delete transactions which have been reversed. The original transaction is treated as
            // unreversed and needs to stay
            delete_from _ledgerTransStatementTmp
                exists join transactionReversalTrans
                    where transactionReversalTrans.RefTableId == tableNum(GeneralJournalAccountEntry)
                        && transactionReversalTrans.RefRecId == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                        && transactionReversalTrans.Reversed == NoYes::Yes;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSalesTaxSpecificationInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates sales tax codes and amounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_ToDate">
    /// The end date.
    /// </param>
    public void processSalesTaxSpecificationInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        FromDate _fromDate,
        ToDate _ToDate)
    {
        LedgerTransStatementStagingTmp tmpTransSalesTax;
        TaxTrans taxTrans;
        TaxTransGeneralJournalAccountEntry taxTransGeneralJournalAccountEntry;
        Statement statement;
        str updateRowNumSql;
        TableName taxTableName;
        UserConnection userConn = this.parmUserConnection();

        this.setUserConnection(tmpTransSalesTax);

        // Insert new records for transactions that have associated tax details
        insert_recordset tmpTransSalesTax
            (GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
            PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher, TaxCode, TaxAmount)
            select
                GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
                PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher
            from _ledgerTransStatementTmp
            group by _ledgerTransStatementTmp.MainFocusValue, _ledgerTransStatementTmp.MainFocusDescription, _ledgerTransStatementTmp.SecondaryFocus,
                _ledgerTransStatementTmp.PostingLayer, _ledgerTransStatementTmp.PeriodCode, _ledgerTransStatementTmp.GeneralJournalEntry, _ledgerTransStatementTmp.GeneralJournalEntryDataArea,
                _ledgerTransStatementTmp.GeneralJournalAccountEntry, _ledgerTransStatementTmp.TransDate, _ledgerTransStatementTmp.Voucher, taxTrans.TaxCode
                where _ledgerTransStatementTmp.TransDate >= _fromDate
                    && _ledgerTransStatementTmp.TransDate <= _ToDate
            join taxTransGeneralJournalAccountEntry
                where taxTransGeneralJournalAccountEntry.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && (taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::TransactionLineAccount
                        || taxTransGeneralJournalAccountEntry.TaxTransRelationship == TaxTransRelationshipType::CashDiscount)
            join TaxCode, sum(TaxAmount) from taxTrans
                where taxTrans.RecId == taxTransGeneralJournalAccountEntry.TaxTrans;

        // The Tempdb table isn't created until either a record is inserted or this select call is made, and therefore doesn't have a physical table name.
        // Because we aren't 100% sure an insert has occurred, execute a select call to ensure a physical table exists.
        select firstOnly RecId from tmpTransSalesTax;
        taxTableName = tmpTransSalesTax.getPhysicalTableName();

        // Update table with tax records to add the sorted GroupRowNum per GeneralJournalAccountEntry
        // Using Direct SQL here so that the ROW_NUMBER function of SQL can be utilized
        updateRowNumSql = 'UPDATE TAXTMP ';
        updateRowNumSql += 'SET GROUPROWNUM = X.ROWNUM ';
        updateRowNumSql += strFmt('FROM (SELECT RECID, ROW_NUMBER() OVER (PARTITION BY GENERALJOURNALACCOUNTENTRY ORDER BY TAXCODE) AS ROWNUM FROM tempdb..%1) X ', taxTableName);
        updateRowNumSql += strFmt('INNER JOIN tempdb..%1 TAXTMP ON X.RECID = TAXTMP.RECID ', taxTableName);

        new SqlStatementExecutePermission(updateRowNumSql).assert();
        statement = userConn.createStatement();
        statement.executeUpdateWithParameters(updateRowNumSql, SqlParams::create());
        CodeAccessPermission::revertAssert();

        // Update processing table with TaxCode and TaxAmount with values from first TaxCode record per GJAE
        update_recordSet _ledgerTransStatementTmp setting
            GroupRowNum = tmpTransSalesTax.GroupRowNum,
            TaxCode = tmpTransSalesTax.TaxCode,
            TaxAmount = tmpTransSalesTax.TaxAmount
            join GroupRowNum, TaxCode, TaxAmount
            from tmpTransSalesTax
                where tmpTransSalesTax.GeneralJournalAccountEntry == _ledgerTransStatementTmp.GeneralJournalAccountEntry
                    && tmpTransSalesTax.GroupRowNum <= 1;

        // Insert remaining records
        insert_recordset _ledgerTransStatementTmp
            (GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
            PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher, TaxCode, TaxAmount, GroupRowNum)
        select
            GeneralJournalAccountEntry, GeneralJournalEntry, GeneralJournalEntryDataArea, MainFocusDescription, MainFocusValue,
            PeriodCode, PostingLayer, SecondaryFocus, TransDate, Voucher, TaxCode, TaxAmount, GroupRowNum
        from tmpTransSalesTax
            where tmpTransSalesTax.GroupRowNum > 1;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSpecificationGroupingInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Groups records based on the given specification.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_specification">
    /// The <c>DimensionsLedgerTransSpecDim</c> specification type.
    /// </param>
    /// <param name="_fromDate">
    /// The start date.
    /// </param>
    /// <param name="_toDate">
    /// The end date.
    /// </param>
    /// <param name="_generateEmptyPeriods">
    /// A boolean value indicating whether records must be inserted for periods that do not have operating transactions.
    /// </param>
    private void processSpecificationGroupingInStaging(
        LedgerTransStatementStagingTmp _ledgerTransStatementTmp,
        DimensionsLedgerTransSpecDim _specification,
        FromDate _fromDate,
        ToDate _toDate,
        boolean _generateEmptyPeriods)
    {
        switch (_specification)
        {
            case DimensionsLedgerTransSpecDim::Day:
                this.groupByDayInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Month:
                this.groupByMonthInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Period:
                this.groupByPeriodInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Quarter:
                this.groupByQuarterInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
            case DimensionsLedgerTransSpecDim::Total:
                // Group everything to one record with no description
                this.groupTransactionsByRangeInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, '');
                break;
            case DimensionsLedgerTransSpecDim::Transaction:
                // No grouping, leave as is
                break;
            case DimensionsLedgerTransSpecDim::Week:
                this.groupByWeekInStaging(_ledgerTransStatementTmp, _fromDate, _toDate, _generateEmptyPeriods);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processWithoutTransInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes records for ledger accounts that do not have any transactions within the date range.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <param name="_withoutTrans">
    /// A boolean value indicating whether ledger accounts without transactions within the date range must be added.
    /// </param>
    /// <param name="_includeOpening">
    /// A boolean value indicating whether opening transactions must be treated as operating transactions.
    /// </param>
    /// <param name="_startDate">
    /// The report start date.
    /// </param>
    private void processWithoutTransInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp, boolean _withoutTrans, boolean _includeOpening, FromDate _startDate)
    {
        SkipAOSValidationPermission perm = new SkipAOSValidationPermission();
        perm.assert();

        LedgerTransStatementStagingTmp  sourceTrans;
        this.setUserConnection(sourceTrans);
        sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        TransDate periodStartDate = LedgerFiscalCalendar::findOpeningStartDateByDate(CompanyInfoHelper::fiscalCalendarRecId(), _startDate);

        if (!_withoutTrans)
        {
            // If withoutTrans and includeOpening are both not selected, the the opening transactions from the last fiscal period
            // should not be deleted.
            if (!_includeOpening && _startDate == periodStartDate)
            {
                FiscalCalendarPeriod fiscalCalendarPeriod;
                GeneralJournalEntry generalJournalEntry;

                delete_from _ledgerTransStatementTmp
                    exists join generalJournalEntry
                        where generalJournalEntry.RecId == _ledgerTransStatementTmp.GeneralJournalEntry
                    exists join fiscalCalendarPeriod
                        where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod
                            && fiscalCalendarPeriod.Type != FiscalPeriodType::Opening
                    notExists join sourceTrans
                        where sourceTrans.MainFocus == _ledgerTransStatementTmp.MainFocus
                            && sourceTrans.MainFocusName == _ledgerTransStatementTmp.MainFocusName
                            && sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                            && sourceTrans.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea
                            && sourceTrans.PeriodCode == FiscalPeriodType::Operating;

            }
            else
            {
                // If withoutTrans is not selected, delete the transactions that have no operating transactions in the given date range
                delete_from _ledgerTransStatementTmp
                    notExists join sourceTrans
                        where sourceTrans.MainFocus == _ledgerTransStatementTmp.MainFocus
                            && sourceTrans.MainFocusName == _ledgerTransStatementTmp.MainFocusName
                            && sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                            && sourceTrans.PeriodCode == FiscalPeriodType::Operating
                            && sourceTrans.GeneralJournalEntryDataArea == _ledgerTransStatementTmp.GeneralJournalEntryDataArea;
            }
        }
        CodeAccessPermission::revertAssert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUserConnection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the user connection on the table buffer.
    /// </summary>
    /// <param name="_common">
    /// The table buffer.
    /// </param>
    private void setUserConnection(Common _common)
    {
        UserConnection con = this.parmUserConnection();
       
        if (con)
        {
            _common.setConnection(con);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAccumulatedAmountsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates accumulated amounts.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    private void updateAccumulatedAmountsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        LedgerTransStatementTmpAccumulated tmpAccumulated;
        LedgerTransStatementStagingTmp sourceTrans;
  
        this.setUserConnection(sourceTrans);
        sourceTrans.linkPhysicalTableInstance(_ledgerTransStatementTmp);

        this.setUserConnection(tmpAccumulated);

        insert_recordset tmpAccumulated (LedgerTransStatementTmp, AccumulatedDebit, AccumulatedCredit, ReportingAccumulatedDebit, ReportingAccumulatedCredit)
            select RecId from _ledgerTransStatementTmp
                group by _ledgerTransStatementTmp.RecId
            join sum(AmountDebit), sum(AmountCredit), sum(ReportingCurrencyAmountDebit), sum(ReportingCurrencyAmountCredit) from sourceTrans
                where sourceTrans.MainFocusValue == _ledgerTransStatementTmp.MainFocusValue
                    && sourceTrans.RecId <= _ledgerTransStatementTmp.RecId
                    // Don't include accumulated amounts from sub-totals because that would
                    // result in amounts getting considered twice
                    && sourceTrans.RecordType != DimensionsTransRecordType::Aggregate
                    && sourceTrans.IsSimulation_IT == _ledgerTransStatementTmp.IsSimulation_IT;

        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = tmpAccumulated.AccumulatedDebit - tmpAccumulated.AccumulatedCredit,
            ReportingAccumulatedMST = tmpAccumulated.ReportingAccumulatedDebit - tmpAccumulated.ReportingAccumulatedCredit,
            PreviousDebitTotal = tmpAccumulated.AccumulatedDebit,
            PreviousCreditTotal = tmpAccumulated.AccumulatedCredit
            join tmpAccumulated
                where tmpAccumulated.LedgerTransStatementTmp == _ledgerTransStatementTmp.RecId;

        // Clear out the AmountDebit and AmountCredit from opening transactions
        update_recordSet _ledgerTransStatementTmp setting
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountDebit = 0.0,
            AmountCredit = 0.0,
            ReportingCurrencyAmountDebit = 0.0,
            ReportingCurrencyAmountCredit = 0.0
        where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOpeningAmountsInStaging</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates amounts for opening transactions.
    /// </summary>
    /// <param name="_ledgerTransStatementTmp">
    /// The <c>LedgerTransStatementStagingTmp</c> table buffer.
    /// </param>
    /// <remarks>
    /// This is the last step in the process to populate the <c>LedgerTransStatementStagingTmp</c> table.
    /// The clearing of the debit and credit amounts cannot be done until they are no longer needed by any other calculation.
    /// </remarks>
    private void updateOpeningAmountsInStaging(LedgerTransStatementStagingTmp _ledgerTransStatementTmp)
    {
        update_recordSet _ledgerTransStatementTmp setting
            AccumulatedMST = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            ReportingAccumulatedMST = _ledgerTransStatementTmp.ReportingCurrencyAmountDebit - _ledgerTransStatementTmp.ReportingCurrencyAmountCredit,
            AmountMSTDebCred = _ledgerTransStatementTmp.AmountDebit - _ledgerTransStatementTmp.AmountCredit,
            AmountDebit = 0.0,
            AmountCredit = 0.0,
            ReportingCurrencyAmountDebit = 0.0,
            ReportingCurrencyAmountCredit = 0.0
        where _ledgerTransStatementTmp.PeriodCode == FiscalPeriodType::Opening;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createQuerySim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a query that includes also simulations.
    /// </summary>
    /// <param name = "_sourceQuery">Starting query object.</param>
    /// <param name = "_targetQuery">Final query object.</param>
    /// <returns>The final query object.</returns>
    private static Query createQuerySim(Query _sourceQuery, Query _targetQuery)
    {
        Query newQuery = _targetQuery;

        FieldName ledgerDimensionFieldName = fieldstr(GeneralJournalAccountEntrySim_IT, LedgerDimension);
        QueryBuildDataSource newQueryBuildDataSource = newQuery.dataSourceTable(tableNum(GeneralJournalAccountEntrySim_IT));
        QueryBuildDataSource sourceQueryBuildDataSource = _sourceQuery.dataSourceTable(tableNum(GeneralJournalAccountEntry));

        return LedgerTransStatementSimDP_IT::createJoinedPartQuery(_sourceQuery, newQuery, true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateStartWeek</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets starting day of given week.
    /// </summary>
    /// <param name = "_transDate">The week to get its first day.</param>
    /// <returns>The starting day of given week.</returns>
    private static date dateStartWeek(date _transDate)
    {
        // firsDayOfWeek returns a number 0 to 6, Monday = 0 and Sunday = 6
        int firstDay = firstDayOfWeek() + 1;

        // dayofwk returns a number 1 to 7, Monday = 1 and Sunday = 7
        int dayOfWeek = dayOfWk(_transdate);

        int daysToSubtract;

        if (dayOfWeek < firstDay)
        {
            dayOfWeek += 7;
            daysToSubtract = dayOfWeek - firstDay;
        }

        Date dateStartOfWeek = _transDate - daysToSubtract;

        return dateStartOfWeek;
    }

]]></Source>
			</Method>
			<Method>
				<Name>conversionFromToSimulation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts between normal tables and simulation tables.
    /// </summary>
    /// <param name = "_tableId">Table ID.</param>
    /// <param name = "_isToSimulation">A boolean value that inticates if the conversion is to simulations.</param>
    /// <returns>The table conversion.</returns>
    public static TableId conversionFromToSimulation(TableId _tableId, boolean _isToSimulation)
    {
        TableId tableId = _tableId;

        if (_isToSimulation)
        {
            switch (_tableId)
            {
                case tableNum(GeneralJournalAccountEntry):
                    tableId = tableNum(GeneralJournalAccountEntrySim_IT);
                    break;

                case tableNum(GeneralJournalEntry):
                    tableId = tableNum(GeneralJournalEntrySim_IT);
                    break;

                case tableNum(GeneralJournalAccountEntrySim_IT):
                    tableId = tableNum(GeneralJournalAccountEntry);
                    break;

                case tableNum(GeneralJournalEntrySim_IT):
                    tableId = tableNum(GeneralJournalEntry);
                    break;
                case tableNum(LedgerEntryJournal):
                    tableId = tableNum(LedgerEntryJournalSim_IT);
                    break;
                case tableNum(LedgerEntryJournalSim_IT):
                    tableId = tableNum(LedgerEntryJournal);
                    break;
                default:
                    tableId = _tableId;
            }
        }

        return tableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>conversionFieldId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the FieldId of the destination table that corresponds to the given field of source table.
    /// </summary>
    /// <param name = "_tableIdFrom">Source table ID having the field to be converted.</param>
    /// <param name = "_fieldIdFrom">Field to be converted.</param>
    /// <param name = "TableIdTo">Destination table ID of the field that needs to be retrieved.</param>
    /// <returns>The FieldId of the destination table that corresponds to the given field of source table.</returns>
    public static int conversionFieldId(TableId _tableIdFrom, fieldId _fieldIdFrom, TableId _tableIdTo)
    {
        DictField tmpDictField = new DictField(_tableIdFrom, _fieldIdFrom);
        FieldName strFieldName = tmpDictField.name() ;

        return fieldName2id(_tableIdTo, strFieldName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createJoinedPartQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Joins given queries.
    /// </summary>
    /// <param name = "_sourceQuery">Source query object.</param>
    /// <param name = "_targetQuery">Target query object.</param>
    /// <param name = "_isToSimulation">A boolean value indicating whether to include simulation transactions.</param>
    /// <returns>A query that was obtained by joining source and target queries.</returns>
    public static Query createJoinedPartQuery(query _sourceQuery , Query _targetQuery, boolean _isToSimulation)
    {
        Map sourceTableMap;

        if (LedgerTransStatementSimDPCorrectSourceTableMapFlight::instance().isEnabled())
        {
            sourceTableMap = new Map(Types::Integer, Types::Integer);
        }
        else
        {
            sourceTableMap = new Map(Types::Integer, Types::String);
        }

        QueryBuildDataSource qbds, currentQbds;
        TableId tableIdFrom;
        QueryBuildLink qbk;
        QueryBuildRange qbr;
        FieldId fromFieldIdRelation, tofieldIdRelation, rangeFieldId;

        str rangeValue;
        int i, intRange;
        boolean setGeneralJournalEntry;
        boolean setGeneralJournalAccountEntry;

        for (i = 1; i <= _sourceQuery.dataSourceCount(); i++)
        {
            qbds = _sourceQuery.dataSourceNo(i);
            tableIdFrom = LedgerTransStatementSimDP_IT::conversionFromToSimulation(qbds.table(),_isToSimulation);

            //we need the higher qbds
            if (!sourceTableMap.exists(tableIdFrom))
            {
                sourceTableMap.insert(tableIdFrom, i);
            }
        }

        int lastQbdsInt = _targetQuery.dataSourceCount();
        QueryBuildDataSource lastQbds = _targetQuery.dataSourceNo(lastQbdsInt);

        if (sourceTableMap.exists(lastQbds.table()))
        {
            int currentDataSource, nextDataSource;
            TableId fromTableIdRelation, toTableIdRelation;

            for (i = sourceTableMap.lookup(lastQbds.table()); i <= _sourceQuery.dataSourceCount(); i++)
            {
                currentDataSource = i;
                nextDataSource = i+1;

                lastQbds = _targetQuery.dataSourceNo(lastQbdsInt);//last qbds of target query
                currentQbds = _sourceQuery.dataSourceNo(currentDataSource); //qbds of original query to copy to target query

                //copy of ranges
                for (intRange = 1; intRange <= currentQbds.rangeCount(); intRange++)
                {
                    qbr = currentQbds.range(intRange);
                    rangeValue = qbr.value();
                    rangeFieldId = LedgerTransStatementSimDP_IT::conversionFieldId(qbr.table(), qbr.field(), lastQbds.table());

                    if (rangeFieldId)
                    {
                        SysQuery::findOrCreateRange(lastQbds,rangeFieldId).value(rangeValue);
                    }

                    if (qbr.table() == tableNum(GeneralJournalEntry) || qbr.table() == tableNum(GeneralJournalEntrySim_IT))
                    {
                        setGeneralJournalEntry = false;
                    }

                    if (qbr.table() == tableNum(GeneralJournalAccountEntry) || qbr.table() == tableNum(GeneralJournalAccountEntrySim_IT))
                    {
                        setGeneralJournalAccountEntry = false;
                    }
                }

                //add joined data source as in the original query
                if (i+1 <= _sourceQuery.dataSourceCount())
                {
                    //original quey next data source
                    QueryBuildDataSource nextQbds = _sourceQuery.dataSourceNo(nextDataSource);
                    
                    //query copied
                    if (!nextQbds.joined())
                    {
                        break;
                    }
                    else
                    {
                        //add to target query the new joined datasource
                        QueryBuildDataSource newLastQbds = lastQbds.addDataSource(LedgerTransStatementSimDP_IT::conversionFromToSimulation(nextQbds.table(), _isToSimulation));

                        int intLink;

                        for (intLink = 1; intLink <= nextQbds.linkCount(); intLink++)
                        {
                            qbk = nextQbds.link(intLink);
                            //new tables relations
                            fromTableIdRelation = LedgerTransStatementSimDP_IT::conversionFromToSimulation(qbk.table(), _isToSimulation);
                            toTableIdRelation = LedgerTransStatementSimDP_IT::conversionFromToSimulation(qbk.relatedTable (), _isToSimulation);
                            //new fields relations
                            fromFieldIdRelation = LedgerTransStatementSimDP_IT::conversionFieldId(qbk.table(), qbk.field(),fromTableIdRelation);
                            toFieldIdRelation = LedgerTransStatementSimDP_IT::conversionFieldId(qbk.relatedtable(), qbk.relatedField(), toTableIdRelation);

                            if (fromFieldIdRelation && toFieldIdRelation)
                            {
                                newLastQbds.addLink( fromFieldIdRelation, toFieldIdRelation,_targetQuery.dataSourceTable(fromTableIdRelation).name() ) ;
                            }
                        }

                        newLastQbds.joinMode(nextQbds.joinMode());
                        lastQbdsInt++;
                    }
                }
            }

            // copy filters (eg. MainAccountId)
            for (i = 1; i <= _sourceQuery.dataSourceCount(); i++)
            {
                currentQbds = _sourceQuery.dataSourceNo(i);

                int filterCnt = 0;

                if (!currentQbds.embedded())
                {
                    filterCnt = _sourceQuery.queryFilterCount(currentQbds);
                }

                QueryFilter sourceFilter, targetFilter;
                int intFilter;
                str filterValue;

                for (intFilter = 1; intFilter <= filterCnt; intFilter++)
                {
                    sourceFilter = _sourceQuery.queryFilter(intFilter, currentQbds);
                    filterValue = sourceFilter.value();

                    fromTableIdRelation = LedgerTransStatementSimDP_IT::conversionFromToSimulation(sourceFilter.dataSource().table(), _isToSimulation);
                    QueryBuildDataSource targetQbds = _targetQuery.dataSourceTable(fromTableIdRelation);

                    FieldName strFieldName = sourceFilter.field();

                    if (targetQbds)
                    {
                        targetFilter = _targetQuery.addQueryFilter(targetQbds, strFieldName);
                        targetFilter.value(filterValue);
                    }
                }
            }
        }

        if (setGeneralJournalEntry)
        {
            lastQbds = _targetQuery.dataSourceTable(tableNum(GeneralJournalEntrySim_IT));
            currentQbds = _sourceQuery.dataSourceTable(tableNum(GeneralJournalEntry));

            if (currentQbds && lastQbds)
            {
                //copy of ranges
                for (intRange = 1; intRange <= currentQbds.rangeCount(); intRange++)
                {
                    qbr = currentQbds.range(intRange);
                    rangeValue = qbr.value();
                    rangeFieldId = LedgerTransStatementSimDP_IT::conversionFieldId(qbr.table(), qbr.field(), lastQbds.table());

                    if (rangeFieldId)
                    {
                        SysQuery::findOrCreateRange(lastQbds,rangeFieldId).value(rangeValue);
                    }
                }
            }
        }

        if (setGeneralJournalAccountEntry)
        {
            lastQbds = _targetQuery.dataSourceTable(tableNum(GeneralJournalAccountEntrySim_IT));
            currentQbds = _sourceQuery.dataSourceTable(tableNum(GeneralJournalAccountEntry));

            if (currentQbds && lastQbds)
            {
                //copy of ranges
                for (intRange = 1; intRange <= currentQbds.rangeCount(); intRange++)
                {
                    qbr = currentQbds.range(intRange);
                    rangeValue = qbr.value();
                    rangeFieldId = LedgerTransStatementSimDP_IT::conversionFieldId(qbr.table(), qbr.field(), lastQbds.table());

                    if (rangeFieldId)
                    {
                        SysQuery::findOrCreateRange(lastQbds,rangeFieldId).value(rangeValue);
                    }
                }
            }
        }

        return _targetQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQueryTableFieldFilter</Name>
				<Source><![CDATA[
    private Map getQueryTableFieldFilter(Query _query, int _tableNumber)
    {
        Map fieldValueFilterMap = new Map(Types::String, Types::String);

        int queryFilterCount = _query.queryFilterCount();
                
        for (int j = 1; j <= queryFilterCount; j++)
        {
            QueryFilter dynamicQueryFilter = _query.queryFilter(j);

            QueryBuildDataSource queryFilterDataSource = dynamicQueryFilter.datasource();

            if (dynamicQueryFilter != null && dynamicQueryFilter.value() != '')
            {
                if (queryFilterDataSource.table() == _tableNumber)
                {
                    fieldValueFilterMap.add(dynamicQueryFilter.field(), dynamicQueryFilter.value());
                }
            }
        }

        return fieldValueFilterMap;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>