<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SAFTReportTaxCollectionServiceInvoice_W</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The class collecting tax amounts in the dimension of the tax reporting codes for VAT Invoices.
/// </summary>
#ISOCountryRegionCodes
public class SAFTReportTaxCollectionServiceInvoice_W
{
    private SAFTVATInvoiceJour_PL journals;
    private SAFTVATInvoiceLines_PL lines;
    private SAFTVATInvoiceTaxes_PL taxes;
    private RecordInsertList journalsList;
    private RecordInsertList linesList;
    private RecordInsertList taxesList;

    private Query query;

    private CustInvoiceJour custInvoiceJour;
    private CustInvoiceJour_W custInvoiceJour_W;
    private ProjInvoiceJour projInvoiceJour;
    private CzCustAdvanceInvoiceTable custAdvanceInvoiceTable;
    private boolean isAssetSpecifiedInLines;
    RecIdCount jourCount = 1, lineCount = 1;
    container taxSourceRecIds, taxInventTransIds, taxData;
    private container projAdvanceInvoiceOrigData;
    private boolean countryRegion_PL = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]);
    private ProjAdvancesSettle projAdvancesSettle;
    private Map projAdvanceInvoiceJourIds;
    private boolean linkLinesToPreviousAdvanceInvoice;
    internal const str ServiceUnitOfMeasure = 'USŁUGA';

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instanciates the tax report service.
    /// </summary>
    /// <param name = "_query">Query containing tax transactions data sources.</param>
    public void new(Query _query)
    {
        query = _query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportInvoiceJournals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the invoice journals for SAFT tax reports.
    /// </summary>
    /// <returns>The set of invoice journals.</returns>
    public SAFTVATInvoiceJour_PL getReportInvoiceJournals()
    {
        return journals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportInvoiceLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the invoice lines for SAFT tax reports.
    /// </summary>
    /// <returns>The set of invoice lines.</returns>
    public SAFTVATInvoiceLines_PL getReportInvoiceLines()
    {
        return lines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportInvoiceTaxes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the data for SAFT tax reports.
    /// </summary>
    /// <returns>The set of tax transactions associated with sales tax reporting codes.</returns>
    public SAFTVATInvoiceTaxes_PL getReportInvoiceTaxes()
    {
        return taxes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reset</Name>
				<Source><![CDATA[
    private void reset()
    {
        projAdvancesSettle.clear();
        projAdvanceInvoiceOrigData = conNull();
        linkLinesToPreviousAdvanceInvoice = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupProjAdvanceInvoice</Name>
				<Source><![CDATA[
    private void setupProjAdvanceInvoice()
    {
        projAdvancesSettle = this.projAdvancesSettle();
        projAdvanceInvoiceOrigData = this.getProjOriginalAdvanceInvoiceId();
        projAdvanceInvoiceJourIds.add(projInvoiceJour.ProjInvoiceId, jourCount);
        linkLinesToPreviousAdvanceInvoice = this.shouldLinkAdvanceInvoiceLine();
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the report data collection service.
    /// </summary>
    public void run()
    {
        projAdvanceInvoiceJourIds = new Map(Types::String, Types::Int64);
        journalsList = new RecordInsertList(tableNum(SAFTVATInvoiceJour_PL), true, true, true, false, true, journals);
        linesList = new RecordInsertList(tableNum(SAFTVATInvoiceLines_PL), true, true, true, false, true, lines);
        taxesList = new RecordInsertList(tableNum(SAFTVATInvoiceTaxes_PL), true, true, true, false, true, taxes);

        QueryRun queryRun = new QueryRun(query);

        var dsCustJour = query.dataSourceTable(tableNum(CustInvoiceJour)) != null;
        var dsProjJour = query.dataSourceTable(tableNum(ProjInvoiceJour)) != null;
        var dsAdvance  = query.dataSourceTable(tableNum(CzCustAdvanceInvoiceTable)) != null;

        TableId prevInvTableId;
        RefRecId prevInvRecId;
        while (queryRun.next())
        {
            this.reset();
            custInvoiceJour = dsCustJour ? queryRun.get(tableNum(CustInvoiceJour)) : null;
            projInvoiceJour = dsProjJour ? queryRun.get(tableNum(ProjInvoiceJour)) : null;
            custAdvanceInvoiceTable = dsAdvance ? queryRun.get(tableNum(CzCustAdvanceInvoiceTable)) : null;
            this.clearData();

            if (dsCustJour && custInvoiceJour.RecId && (prevInvRecId != custInvoiceJour.RecId || prevInvTableId != custInvoiceJour.TableId))
            {
                prevInvTableId = custInvoiceJour.TableId;
                prevInvRecId = custInvoiceJour.RecId;
                custInvoiceJour_W = custInvoiceJour.custInvoiceJour_W();

                this.collectTaxes(custInvoiceJour.LedgerVoucher, custInvoiceJour.InvoiceDate);
                this.collectTaxesFromReversalAdvanceInvoice_Cust();
                if (taxSourceRecIds)
                {
                    CustInvoiceTrans custInvoiceTrans;
                    while select custInvoiceTrans
                        where custInvoiceTrans.SalesId == custInvoiceJour.SalesId
                            && custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
                            && custInvoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate
                            && custInvoiceTrans.numberSequenceGroup == custInvoiceJour.numberSequenceGroup
                    {
                        int idx = conFind(taxSourceRecIds, custInvoiceTrans.RecId);
                        if (!idx)
                        {
                            idx = conFind(taxInventTransIds, custInvoiceTrans.InventTransId);
                        }
                        if (idx)
                        {
                            this.createLinesDataByCustInvoiceTrans(custInvoiceTrans, idx);
                        }

                        this.createLinesDataByMarkupTransSource(custInvoiceTrans, custInvoiceJour);
                    }

                    this.createLinesDataByMarkupTransSource(custInvoiceJour, custInvoiceJour);
                    this.collectCustInvoiceJournals();
                }
            }
            else if (dsProjJour && projInvoiceJour.RecId && (prevInvRecId != projInvoiceJour.RecId || prevInvTableId != projInvoiceJour.TableId))
            {
                prevInvTableId = projInvoiceJour.TableId;
                prevInvRecId = projInvoiceJour.RecId;

                if (countryRegion_PL)
                {
                    this.setupProjAdvanceInvoice();
                }

                this.collectTaxes(projInvoiceJour.LedgerVoucher, projInvoiceJour.InvoiceDate);
                this.collectTaxesFromReversalAdvanceInvoice_Proj();
                if (taxSourceRecIds)
                {
                    ProjInvoiceCost projInvoiceCost;
                    while select projInvoiceCost
                    where projInvoiceCost.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                        && projInvoiceCost.InvoiceDate == projInvoiceJour.InvoiceDate
                    {
                        int idx = conFind(taxSourceRecIds, projInvoiceCost.RecId);
                        if (idx)
                        {
                            this.createLinesDataByProjInvoiceCost(projInvoiceCost, idx);
                        }
                    }
                    ProjInvoiceEmpl projInvoiceEmpl;
                    while select projInvoiceEmpl
                    where projInvoiceEmpl.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                        && projInvoiceEmpl.InvoiceDate == projInvoiceJour.InvoiceDate
                    {
                        int idx = conFind(taxSourceRecIds, projInvoiceEmpl.RecId);
                        if (idx)
                        {
                            this.createLinesDataByProjInvoiceEmpl(projInvoiceEmpl, idx);
                        }
                    }
                    ProjInvoiceItem projInvoiceItem;
                    while select projInvoiceItem
                    where projInvoiceItem.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                        && projInvoiceItem.InvoiceDate == projInvoiceJour.InvoiceDate
                    {
                        int idx = conFind(taxSourceRecIds, projInvoiceItem.RecId);
                        if (!idx)
                        {
                            idx = conFind(taxInventTransIds, projInvoiceItem.InventTransId);
                        }
                        if (idx)
                        {
                            this.createLinesDataByProjInvoiceItem(projInvoiceItem, idx);
                        }

                        this.createLinesDataByMarkupTransSource(projInvoiceItem, projInvoiceJour);
                    }
                    ProjInvoiceOnAcc projInvoiceOnAcc;
                    while select projInvoiceOnAcc
                    where projInvoiceOnAcc.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                        && projInvoiceOnAcc.InvoiceDate == projInvoiceJour.InvoiceDate
                    {
                        int idx = conFind(taxSourceRecIds, projInvoiceOnAcc.RecId);
                        if (idx)
                        {
                            this.createLinesDataByProjInvoiceOnAcc(projInvoiceOnAcc, idx);
                        }
                    }
                    ProjInvoiceRevenue projInvoiceRevenue;
                    while select projInvoiceRevenue
                    where projInvoiceRevenue.ProjInvoiceId == projInvoiceJour.ProjInvoiceId
                        && projInvoiceRevenue.InvoiceDate == projInvoiceJour.InvoiceDate
                    {
                        int idx = conFind(taxSourceRecIds, projInvoiceRevenue.RecId);
                        if (idx)
                        {
                            this.createLinesDataByProjInvoiceRevenue(projInvoiceRevenue, idx);
                        }
                    }

                    this.createLinesDataByMarkupTransSource(projInvoiceJour, projInvoiceJour);
                    this.collectProjInvoiceJournals();
                }
            }
            else if (dsAdvance && custAdvanceInvoiceTable.RecId && (prevInvRecId != custAdvanceInvoiceTable.RecId || prevInvTableId != custAdvanceInvoiceTable.TableId))
            {
                prevInvTableId = custAdvanceInvoiceTable.TableId;
                prevInvRecId = custAdvanceInvoiceTable.RecId;

                this.collectTaxes(custAdvanceInvoiceTable.Voucher, custAdvanceInvoiceTable.InvoiceDate);
                if (taxSourceRecIds)
                {
                    this.collectOrigDocumentLines();
                    this.collectCustAdvanceInvoices();
                }
            }
        }
        journalsList.insertDatabase();
        linesList.insertDatabase();
        taxesList.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearData</Name>
				<Source><![CDATA[
    private void clearData()
    {
        custInvoiceJour_W.clear();
        isAssetSpecifiedInLines = false;
        taxSourceRecIds = conNull();
        taxInventTransIds = conNull();
        taxData = conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectCustInvoiceJournals</Name>
				<Source><![CDATA[
    private void collectCustInvoiceJournals()
    {
        journals.clear();
        journals.SourceTableId = custInvoiceJour.TableId;
        journals.SourceRecId = custInvoiceJour.RecId;
        journals.initByCustAccount(custInvoiceJour.InvoiceAccount);
        journals.DocumentDate = custInvoiceJour.DocumentDate;
        journals.InclTax = custInvoiceJour.InclTax;
        journals.InvoiceAmountCur = custInvoiceJour.InvoiceAmount;
        journals.InvoiceAmountMST = custInvoiceJour.InvoiceAmountMST;
        journals.CurrencyCode = custInvoiceJour.CurrencyCode;
        journals.InvoiceDate = custInvoiceJour_W.SalesDate_W ? custInvoiceJour_W.SalesDate_W : custInvoiceJour.InvoiceDate;
        journals.InvoiceId = custInvoiceJour.InvoiceId;
        journals.IsAssetSpecifiedInLines = isAssetSpecifiedInLines;

        str origInvoiceId;
        InvoiceDate origInvoiceDate;

        if (CustInvoiceJourOrigInvoices_PLFlight::instance().isEnabled())
        {
            str origInvoiceDates;
            [origInvoiceId, origInvoiceDates] = this.origCustInvoiceIdAndDate();
            journals.OrigInvoiceDatesStr = origInvoiceDates;
        }
        else
        {
            [origInvoiceId, origInvoiceDate] = this.origCustInvoiceIdAndDate();
            journals.OrigInvoiceDate = origInvoiceDate;
        }

        journals.IsCreditNote = origInvoiceId || custInvoiceJour.creditNote();
        journals.OrigInvoiceId = origInvoiceId;
        journals.ReasonTableRef = custInvoiceJour.ReasonTableRef;
        journals.SplitPayment = this.getSplitPaymentViaCustTrans_W(custInvoiceJour.InvoiceDate, custInvoiceJour.LedgerVoucher);

        this.addJournal(journals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalAmount</Name>
				<Source><![CDATA[
    private Amount getTotalAmount()
    {
        ProjAdvancesSettle settlements;
        ProjInvoiceOnAcc projInvoiceOnAcc;
        ProjOnAccTrans projOnAccTrans;
        TaxTrans taxTrans;

        select sum(SourceBaseAmountCur), sum(SourceTaxAmountCur) from taxTrans
            where taxTrans.Voucher == projInvoiceJour.LedgerVoucher
                && taxTrans.TransDate == projInvoiceJour.InvoiceDate
            exists join projInvoiceOnAcc
                where projInvoiceOnAcc.TableId == taxTrans.SourceTableId
                    && projInvoiceOnAcc.RecId == taxTrans.SourceRecId
            exists join projOnAccTrans
                where projOnAccTrans.TransId == projInvoiceOnAcc.TransId
            exists join settlements
                where settlements.TransRecId == projOnAccTrans.RecId;
        
        return abs(taxTrans.SourceBaseAmountCur + taxTrans.SourceTaxAmountCur) * sign(projInvoiceJour.InvoiceAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectProjInvoiceJournals</Name>
				<Source><![CDATA[
    private void collectProjInvoiceJournals()
    {
        journals.clear();
        journals.SourceTableId = projInvoiceJour.TableId;
        journals.SourceRecId = projInvoiceJour.RecId;
        journals.initByCustAccount(projInvoiceJour.InvoiceAccount);
        journals.DocumentDate = projInvoiceJour.DocumentDate_W;
        journals.InvoiceAmountCur = projInvoiceJour.InvoiceAmount;
        journals.InvoiceAmountMST = projInvoiceJour.amountMST_W();
        journals.CurrencyCode = projInvoiceJour.CurrencyId;
        journals.InvoiceDate = projAdvancesSettle.VatDueDate_W ? projAdvancesSettle.VatDueDate_W : projInvoiceJour.InvoiceDate;
        journals.InvoiceId = projInvoiceJour.ProjInvoiceId;
        journals.IsAssetSpecifiedInLines = isAssetSpecifiedInLines;

        if (countryRegion_PL)
        {
            journals.CustAdvance = projAdvancesSettle ? NoYes::Yes : NoYes::No;
            journals.CustAdvanceSettle = projAdvanceInvoiceOrigData && projAdvanceInvoiceOrigData != conNull() ? NoYes::Yes : NoYes::No;

            if (projAdvancesSettle)
            {
                journals.InvoiceAmountCur = this.getTotalAmount();
            }
        }

        str origInvoiceId;

        if (CustInvoiceJourOrigInvoices_PLFlight::instance().isEnabled())
        {
            str origInvoiceDates;
            [origInvoiceId, origInvoiceDates] = this.origProjInvoiceIdsAndDates();
            journals.OrigInvoiceDatesStr = origInvoiceDates;
        }
        else
        {
            InvoiceDate origInvoiceDate;
            [origInvoiceId, origInvoiceDate] = this.origProjInvoiceIdAndDate();
            journals.OrigInvoiceDate = origInvoiceDate;
        }

        journals.IsCreditNote = origInvoiceId || projInvoiceJour.isCreditNote_CZ();
        journals.OrigInvoiceId = origInvoiceId;
        journals.ReasonTableRef = projInvoiceJour.ReasonTableRef;
        journals.SplitPayment = this.getSplitPaymentViaCustTrans_W(projInvoiceJour.InvoiceDate, projInvoiceJour.LedgerVoucher);

        this.addJournal(journals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectCustAdvanceInvoices</Name>
				<Source><![CDATA[
    private void collectCustAdvanceInvoices()
    {
        journals.clear();
        journals.SourceTableId = custAdvanceInvoiceTable.TableId;
        journals.SourceRecId = custAdvanceInvoiceTable.RecId;
        journals.initByCustAccount(custAdvanceInvoiceTable.InvoiceAccount);
        journals.DocumentDate = custAdvanceInvoiceTable.DocumentDate;
        journals.InvoiceAmountCur = custAdvanceInvoiceTable.InvoiceAmount;
        journals.InvoiceAmountMST = custAdvanceInvoiceTable.invoiceAmountMST();
        journals.CurrencyCode = custAdvanceInvoiceTable.CurrencyCode;
        journals.InvoiceDate = custAdvanceInvoiceTable.InvoiceDate;
        journals.InvoiceId = custAdvanceInvoiceTable.InvoiceId;

        InvoiceId origInvoiceId;
        InvoiceDate origInvoiceDate;
        [origInvoiceId, origInvoiceDate] = this.origAdvInvoiceIdAndDate();
        journals.IsCreditNote = origInvoiceId || custAdvanceInvoiceTable.creditNote();
        journals.OrigInvoiceDate = origInvoiceDate;
        journals.OrigInvoiceId = origInvoiceId;
        journals.SplitPayment = this.getSplitPaymentViaCustTrans_W(custAdvanceInvoiceTable.InvoiceDate, custAdvanceInvoiceTable.Voucher);

        this.addJournal(journals);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addJournal</Name>
				<Source><![CDATA[
    private void addJournal(SAFTVATInvoiceJour_PL _journal)
    {
        _journal.RecId = jourCount;
        journalsList.add(_journal);
        jourCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectProjAdvanceInvoiceTaxes</Name>
				<Source><![CDATA[
    private void collectProjAdvanceInvoiceTaxes(Voucher _voucher, TransDate _transDate)
    {
        TaxTrans taxTrans;
        ProjInvoiceOnAcc projInvoiceOnAcc;
        ProjOnAccTrans projOnAccTrans;
        ProjAdvancesSettle projAdvancesSettleLocal;

        while select taxTrans
            where taxTrans.Voucher == _voucher
                && taxTrans.TransDate == _transDate
            exists join projInvoiceOnAcc
                where projInvoiceOnAcc.TableId == taxTrans.SourceTableId
                    && projInvoiceOnAcc.RecId == taxTrans.SourceRecId
            exists join projOnAccTrans
                where projOnAccTrans.TransId == projInvoiceOnAcc.TransId
            exists join projAdvancesSettleLocal
                where projAdvancesSettleLocal.TransRecId == projOnAccTrans.RecId
        {
            // Only collect taxes if they belong to settled advances
            this.createTransDataFromTaxTrans(taxTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projAdvancesSettle</Name>
				<Source><![CDATA[
    private ProjAdvancesSettle projAdvancesSettle()
    {
        ProjAdvancesSettle settle;

        select firstonly settle
            where settle.ProjInvoiceJour == projInvoiceJour.RecId;

        return settle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectTaxes</Name>
				<Source><![CDATA[
    private void collectTaxes(Voucher _voucher, TransDate _transDate, Voucher _voucherToReplaceReversalOne = '', TransDate _transDateToReplaceReversalOne = dateNull())
    {
        if (countryRegion_PL && projAdvancesSettle)
        {
            this.collectProjAdvanceInvoiceTaxes(_voucher, _transDate);
        }
        else
        {
            TaxTrans taxTrans;

            while select taxTrans
                where taxTrans.Voucher == _voucher
                    && taxTrans.TransDate == _transDate
            {
                if (_voucherToReplaceReversalOne && _transDateToReplaceReversalOne)
                {
                    taxTrans.Voucher = _voucherToReplaceReversalOne;
                    taxTrans.TransDate = _transDateToReplaceReversalOne;
                }
                this.createTransDataFromTaxTrans(taxTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByCustInvoiceTrans</Name>
				<Source><![CDATA[
    private void createLinesDataByCustInvoiceTrans(CustInvoiceTrans _custInvoiceTrans, int _idx)
    {
        lines.clear();
        lines.ParentRecId = jourCount;
        lines.ProductDescription = _custInvoiceTrans.Name;
        lines.InvoiceId = _custInvoiceTrans.InvoiceId;
        lines.Qty = _custInvoiceTrans.Qty;
        lines.ItemId = _custInvoiceTrans.ItemId;
        lines.UnitOfMeasure = _custInvoiceTrans.SalesUnit;
        lines.AmountCurNett = _custInvoiceTrans.LineAmount;
        lines.AmountCurGross = _custInvoiceTrans.LineAmount + (_custInvoiceTrans.TaxAmount ? _custInvoiceTrans.TaxAmount : _custInvoiceTrans.LineAmountTax);
        lines.AssetId = _custInvoiceTrans.AssetId;
        isAssetSpecifiedInLines = isAssetSpecifiedInLines || _custInvoiceTrans.AssetId != '';
        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate] = conPeek(taxData, _idx);
        lines.InclTax = custInvoiceJour.InclTax;

        this.addLine(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLinkAdvanceInvoiceLine</Name>
				<Source><![CDATA[
    private boolean shouldLinkAdvanceInvoiceLine()
    {
        // When project invoice journals are posted with customer advances as advance invoices and then settled against fees/expenses/items etc. they are posted as 2 separate ProjInvoiceJour records:
        // a) The journal that posted the customer advances
        // b) The journal settling the advances and fees/expenses/items
        // When we encounter journal a, we store in the map, its invoice ID and the RecId of the journal item created for that record
        // If we encounter record b, identified by the invoice original ID for record b matching a key in the map, we link the line to the advance posted by record a
        return countryRegion_PL &&
            projAdvanceInvoiceOrigData && projAdvanceInvoiceJourIds.exists(conPeek(projAdvanceInvoiceOrigData, 1));
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateAdvanceInvoiceLineInfo</Name>
				<Source><![CDATA[
    private void populateAdvanceInvoiceLineInfo(
        AmountCur _amountCur,
        CategoryId _categoryId,
        Description _description)
    {
        lines.AmountCur = _amountCur;
        lines.UnitPrice = lines.AmountCur / lines.Qty;
        lines.UnitOfMeasure = _categoryId;
        lines.TaxAmountCur = lines.AmountCur * (lines.TaxRate / 100);
        lines.Description = _description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceCostLine</Name>
				<Source><![CDATA[
    private void createProjInvoiceCostLine(
        ProjInvoiceCost _projInvoiceCost,
        int _idx,
        NoYes _origDocLine,
        RefRecId _parentRecId,
        boolean _advanceInvoice)
    {
        lines.clear();
        lines.ParentRecId = _parentRecId;
        lines.IsOrigDocLine = _origDocLine;
        lines.ProductDescription = _projInvoiceCost.Txt;
        lines.InvoiceId = _projInvoiceCost.ProjInvoiceId;
        lines.Qty = _projInvoiceCost.Qty;
        lines.AmountCurNett = _projInvoiceCost.LineAmount;
        lines.AmountCurGross = _projInvoiceCost.LineAmount + (_projInvoiceCost.TaxAmount ? _projInvoiceCost.TaxAmount : this.getTaxAmountCurFromTaxData(_idx));
        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate] = conPeek(taxData, _idx);

        if (_advanceInvoice)
        {
            this.populateAdvanceInvoiceLineInfo(_projInvoiceCost.LineAmount, _projInvoiceCost.CategoryId, _projInvoiceCost.Txt);
        }

        this.addLine(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByProjInvoiceCost</Name>
				<Source><![CDATA[
    private void createLinesDataByProjInvoiceCost(ProjInvoiceCost _projInvoiceCost, int _idx)
    {
        this.createProjInvoiceCostLine(_projInvoiceCost, _idx, NoYes::No, jourCount, false);

        if (linkLinesToPreviousAdvanceInvoice)
        {
            this.createProjInvoiceCostLine(_projInvoiceCost, _idx, NoYes::Yes, projAdvanceInvoiceJourIds.lookup(conPeek(projAdvanceInvoiceOrigData, 1)), true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceEmplLine</Name>
				<Source><![CDATA[
    private void createProjInvoiceEmplLine(
        ProjInvoiceEmpl _projInvoiceEmpl,
        int _idx,
        NoYes _origDocLine,
        RefRecId _parentRecId,
        boolean _advanceInvoice)
    {
        lines.clear();
        lines.ParentRecId = _parentRecId;
        lines.IsOrigDocLine = _origDocLine;
        lines.ProductDescription = _projInvoiceEmpl.Txt;
        lines.InvoiceId = _projInvoiceEmpl.ProjInvoiceId;
        lines.Qty = _projInvoiceEmpl.Qty;
        lines.AmountCurNett = _projInvoiceEmpl.LineAmount;
        lines.AmountCurGross = _projInvoiceEmpl.LineAmount + (_projInvoiceEmpl.TaxAmount ? _projInvoiceEmpl.TaxAmount : this.getTaxAmountCurFromTaxData(_idx));
        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate] = conPeek(taxData, _idx);

        if (_advanceInvoice)
        {
            this.populateAdvanceInvoiceLineInfo(_projInvoiceEmpl.LineAmount, _projInvoiceEmpl.CategoryId, _projInvoiceEmpl.Txt);
        }

        this.addLine(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByProjInvoiceEmpl</Name>
				<Source><![CDATA[
    private void createLinesDataByProjInvoiceEmpl(ProjInvoiceEmpl _projInvoiceEmpl, int _idx)
    {
        this.createProjInvoiceEmplLine(_projInvoiceEmpl, _idx, NoYes::No, jourCount, false);

        if (linkLinesToPreviousAdvanceInvoice)
        {
            this.createProjInvoiceEmplLine(_projInvoiceEmpl, _idx, NoYes::Yes, projAdvanceInvoiceJourIds.lookup(conPeek(projAdvanceInvoiceOrigData, 1)), true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceItemLine</Name>
				<Source><![CDATA[
    private void createProjInvoiceItemLine(
        ProjInvoiceItem _projInvoiceItem,
        int _idx,
        AssetId _assetId,
        NoYes _origDocLine,
        RefRecId _parentRecId,
        boolean _advanceInvoice)
    {
        lines.clear();
        lines.ParentRecId = _parentRecId;
        lines.IsOrigDocLine = _origDocLine;
        lines.ProductDescription = _projInvoiceItem.Txt;
        lines.InvoiceId = _projInvoiceItem.ProjInvoiceId;
        lines.Qty = _projInvoiceItem.Qty;
        lines.ItemId = _projInvoiceItem.ItemId;
        lines.AmountCurNett = _projInvoiceItem.LineAmount;
        lines.AmountCurGross = _projInvoiceItem.LineAmount + (_projInvoiceItem.TaxAmount ? _projInvoiceItem.TaxAmount : this.getTaxAmountCurFromTaxData(_idx));
        lines.AssetId = _assetId;
        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate] = conPeek(taxData, _idx);

        if (_advanceInvoice)
        {
            this.populateAdvanceInvoiceLineInfo(_projInvoiceItem.LineAmount, _projInvoiceItem.CategoryId, _projInvoiceItem.Txt);
        }

        this.addLine(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByProjInvoiceItem</Name>
				<Source><![CDATA[
    private void createLinesDataByProjInvoiceItem(ProjInvoiceItem _projInvoiceItem, int _idx)
    {
        AssetId assetId;

        if (_projInvoiceItem.InventTransId)
        {
            RefRecId inventTransOriginId = InventTransOrigin::findByInventTransId(_projInvoiceItem.InventTransId).RecId;
            if (inventTransOriginId)
            {
                assetId = AssetInventTrans::findByInventTransOriginId(inventTransOriginId).AssetId;
                isAssetSpecifiedInLines = isAssetSpecifiedInLines || lines.AssetId != '';
            }
        }

        this.createProjInvoiceItemLine(_projInvoiceItem, _idx, assetId, NoYes::No, jourCount, false);

        if (linkLinesToPreviousAdvanceInvoice)
        {
            this.createProjInvoiceItemLine(_projInvoiceItem, _idx, assetId, NoYes::Yes, projAdvanceInvoiceJourIds.lookup(conPeek(projAdvanceInvoiceOrigData, 1)), true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjAdvanceInvoiceDataFromOnAcc</Name>
				<Source><![CDATA[
    private void createProjAdvanceInvoiceDataFromOnAcc(ProjInvoiceOnAcc _projInvoiceOnAcc)
    {
        ProjOnAccTrans projOnAccTrans;
        ProjAdvancesSettle projAdvancesSettleLocal;

        select firstonly projOnAccTrans
            where projOnAccTrans.TransDate == _projInvoiceOnAcc.TransDate
                && projOnAccTrans.TransId == _projInvoiceOnAcc.TransId
            exists join projAdvancesSettleLocal
                where projAdvancesSettleLocal.TransRecId == projOnAccTrans.RecId;

        if (projOnAccTrans)
        {
            lines.IsOrigDocLine = NoYes::Yes;
            this.populateAdvanceInvoiceLineInfo(projOnAccTrans.amountCurrency(), ServiceUnitOfMeasure, projOnAccTrans.Description);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByProjInvoiceOnAcc</Name>
				<Source><![CDATA[
    private void createLinesDataByProjInvoiceOnAcc(ProjInvoiceOnAcc _projInvoiceOnAcc, int _idx)
    {
        lines.clear();
        lines.ParentRecId = jourCount;
        lines.ProductDescription = _projInvoiceOnAcc.Txt;
        lines.InvoiceId = _projInvoiceOnAcc.ProjInvoiceId;
        lines.Qty = _projInvoiceOnAcc.Qty;
        lines.AmountCurNett = _projInvoiceOnAcc.Amount;
        lines.AmountCurGross = _projInvoiceOnAcc.Amount + (_projInvoiceOnAcc.TaxAmount ? _projInvoiceOnAcc.TaxAmount : this.getTaxAmountCurFromTaxData(_idx));
        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate] = conPeek(taxData, _idx);

        if (countryRegion_PL)
        {
            lines.AmountCurNett = abs(lines.AmountCurNett);
            lines.AmountCurGross = abs(lines.AmountCurGross);

            this.createProjAdvanceInvoiceDataFromOnAcc(_projInvoiceOnAcc);
        }

        this.addLine(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProjInvoiceRevenueLine</Name>
				<Source><![CDATA[
    private void createProjInvoiceRevenueLine(
        ProjInvoiceRevenue _projInvoiceRevenue,
        int _idx,
        NoYes _origDocLine,
        RefRecId _parentRecId,
        boolean _advanceInvoice)
    {
        lines.clear();
        lines.IsOrigDocLine = _origDocLine;
        lines.ParentRecId = _parentRecId;
        lines.ProductDescription = _projInvoiceRevenue.Txt;
        lines.InvoiceId = _projInvoiceRevenue.ProjInvoiceId;
        lines.Qty = _projInvoiceRevenue.Qty;
        lines.AmountCurNett = _projInvoiceRevenue.LineAmount;
        lines.AmountCurGross = _projInvoiceRevenue.LineAmount + (_projInvoiceRevenue.TaxAmount ? _projInvoiceRevenue.TaxAmount : this.getTaxAmountCurFromTaxData(_idx));
        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate] = conPeek(taxData, _idx);

        if (_advanceInvoice)
        {
            this.populateAdvanceInvoiceLineInfo(_projInvoiceRevenue.LineAmount, _projInvoiceRevenue.CategoryId, _projInvoiceRevenue.Txt);
        }

        this.addLine(lines);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByProjInvoiceRevenue</Name>
				<Source><![CDATA[
    private void createLinesDataByProjInvoiceRevenue(ProjInvoiceRevenue _projInvoiceRevenue, int _idx)
    {
        this.createProjInvoiceRevenueLine(_projInvoiceRevenue, _idx, NoYes::No, jourCount, false);

        if (linkLinesToPreviousAdvanceInvoice)
        {
            this.createProjInvoiceRevenueLine(_projInvoiceRevenue, _idx, NoYes::Yes, projAdvanceInvoiceJourIds.lookup(conPeek(projAdvanceInvoiceOrigData, 1)), true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountCurFromTaxData</Name>
				<Source><![CDATA[
    private TaxAmountCur getTaxAmountCurFromTaxData(int _idx)
    {
        const int TaxAmountCurIdx = 6;
        TaxAmountCur ret;
        RefRecId sourceRecId = conpeek(taxSourceRecIds, _idx);
        InventTransId inventTransId = conpeek(taxInventTransIds, _idx);
        for (int i = conLen(taxData); i > 0; i--)
        {
            if (conpeek(taxSourceRecIds, i) == sourceRecId || conpeek(taxInventTransIds, i) == inventTransId)
            {
                ret += conpeek(conpeek(taxData, i), TaxAmountCurIdx);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLine</Name>
				<Source><![CDATA[
    private void addLine(SAFTVATInvoiceLines_PL _line)
    {
        _line.RecId = lineCount;
        linesList.add(_line);
        lineCount++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectOrigDocumentLines</Name>
				<Source><![CDATA[
    private void collectOrigDocumentLines()
    {
        void linesInit()
        {
            lines.clear();
            lines.ParentRecId = jourCount;
            lines.IsOrigDocLine = NoYes::Yes;
        }

        if (custAdvanceInvoiceTable.FreeInvoiceRefRecId)
        {
            CustInvoiceLine custInvoiceLine;

            while select Description, Quantity, UnitPrice, ParentRecId from custInvoiceLine
                where custInvoiceLine.ParentRecId == custAdvanceInvoiceTable.FreeInvoiceRefRecId
            {
                linesInit();
                lines.initByCustInvoiceLine(custInvoiceLine);
                this.addLine(lines);
            }
        }
        if (custAdvanceInvoiceTable.SalesId)
        {
            SalesLine salesLine;
            PlCustAdvanceInvoiceItems plCustAdvanceInvoiceItems;

            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
            {
                if (custAdvanceInvoiceTable.Type == AdvanceInvoiceType_W::CreditNote)
                {
                    SalesTable salesTable;

                    while select SalesId from salesLine
                        where salesLine.SalesId == custAdvanceInvoiceTable.SalesId
                        join RecId from salesTable
                            where salesTable.SalesId == salesLine.SalesId
                        join plCustAdvanceInvoiceItems
                            where plCustAdvanceInvoiceItems.RefTableId == salesLine.TableId
                               && plCustAdvanceInvoiceItems.RefRecId == salesLine.RecId
                    {
                        PlCustAdvanceInvoiceItems plCustAdvanceInvoiceItemsCreditNote = this.lookupPlCustAdvanceInvoiceItemsCreditNote(plCustAdvanceInvoiceItems);

                        if (plCustAdvanceInvoiceItemsCreditNote)
                        {
                            linesInit();
                            lines.initByPlCustAdvanceInvoiceItems(plCustAdvanceInvoiceItemsCreditNote, salesLine.SalesId);

                            TmpTaxWorkTrans tmpTaxTrans = new SAFTaxTransHelper_PL().getTaxForSalesTable(salesTable.RecId);
                            lines.initByTmpTaxWorkTrans(tmpTaxTrans, salesLine.TableId, salesLine.RecId);

                            this.addLine(lines);
                        }
                    }
                }
                else
                {
                    while select SalesId from salesLine
                        where salesLine.SalesId == custAdvanceInvoiceTable.SalesId
                        join plCustAdvanceInvoiceItems
                            where plCustAdvanceInvoiceItems.ParentRecId == custAdvanceInvoiceTable.RecId
                               && plCustAdvanceInvoiceItems.RefTableId == salesLine.TableId
                               && plCustAdvanceInvoiceItems.RefRecId == salesLine.RecId
                    {
                        linesInit();
                        lines.initByPlCustAdvanceInvoiceItems(plCustAdvanceInvoiceItems, salesLine.SalesId);
                        this.addLine(lines);
                    }
                }
            }
            else
            {
                while select InventDimId, ItemId, SalesQty, SalesUnit, SalesPrice, SalesId from salesLine
                    where salesLine.SalesId == custAdvanceInvoiceTable.SalesId
                {
                    linesInit();
                    lines.initBySalesLine(salesLine);
                    this.addLine(lines);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lookupPlCustAdvanceInvoiceItemsCreditNote</Name>
				<Source><![CDATA[
    private PlCustAdvanceInvoiceItems lookupPlCustAdvanceInvoiceItemsCreditNote(PlCustAdvanceInvoiceItems _advanceInvoiceRecord)
    {
        PlCustAdvanceInvoiceItems plCustAdvanceInvoiceItemsCreditNote;

        select firstonly plCustAdvanceInvoiceItemsCreditNote
            where plCustAdvanceInvoiceItemsCreditNote.RefRecId == _advanceInvoiceRecord.RecId
                && plCustAdvanceInvoiceItemsCreditNote.RefTableId == _advanceInvoiceRecord.TableId;

        while (plCustAdvanceInvoiceItemsCreditNote && plCustAdvanceInvoiceItemsCreditNote.ParentRecId != custAdvanceInvoiceTable.RecId)
        {
            RecId prevRecId = plCustAdvanceInvoiceItemsCreditNote.RecId;

            select firstonly plCustAdvanceInvoiceItemsCreditNote
                where plCustAdvanceInvoiceItemsCreditNote.RefRecId == prevRecId
                    && plCustAdvanceInvoiceItemsCreditNote.RefTableId == _advanceInvoiceRecord.TableId;
        }

        return plCustAdvanceInvoiceItemsCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransDataFromTaxTrans</Name>
				<Source><![CDATA[
    private void createTransDataFromTaxTrans(TaxTrans _taxTrans)
    {
        boolean isCreditNote = this.isCreditNote(_taxTrans);

        _taxTrans.TaxAmount = _taxTrans.SourceTaxAmountCur;
        _taxTrans.TaxBaseAmount = _taxTrans.SourceBaseAmountCur;

        TmpTaxReportById tmpTaxReportById;
        tmpTaxReportById = _taxTrans.taxAmountByTaxDirectionAndReportId(tmpTaxReportById, isCreditNote);

        boolean isFirstRecord = true;
        while select Amount, TaxReportField from tmpTaxReportById
        {
            if (isFirstRecord)
            {
                taxes.clear();
                taxes.InvoiceJourRecId = jourCount;
                taxes.initFromTaxTrans(_taxTrans);
                taxes.PaymentTaxCode = TaxTable::find(_taxTrans.TaxCode).PaymentTaxCode;
                taxes.TaxExemptCode = TaxGroupData::find(_taxTrans.TaxGroup, _taxTrans.TaxCode).TaxExemptCode;
                isFirstRecord = false;
                taxSourceRecIds += _taxTrans.SourceRecId;
                taxInventTransIds += _taxTrans.InventTransId;
                taxData += [[_taxTrans.TaxCode, _taxTrans.ExemptTax, _taxTrans.ReverseCharge_W, taxes.TaxExemptCode, _taxTrans.TaxValue, -_taxTrans.TaxAmountCur]];
            }
            taxes.initFromTmpTaxTransReportId(tmpTaxReportById);
            taxesList.add(taxes);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectTaxesFromReversalAdvanceInvoice_Cust</Name>
				<Source><![CDATA[
    private void collectTaxesFromReversalAdvanceInvoice_Cust()
    {
        CustAdvanceInvoiceSettlement_W custAdvanceInvoiceSettlement;
        CzCustAdvanceInvoiceTable reversalAdvanceInvoice;

        while select Voucher, InvoiceDate from reversalAdvanceInvoice
            exists join custAdvanceInvoiceSettlement
                where (custAdvanceInvoiceSettlement.InvoiceJourRecId == custInvoiceJour.RecId
                    && custAdvanceInvoiceSettlement.ReversalAdvanceInvoiceRecId == reversalAdvanceInvoice.RecId)
                    || (custAdvanceInvoiceSettlement.CreditNoteRecId == custInvoiceJour.RecId
                    && custAdvanceInvoiceSettlement.ReversalCancellationRecId == reversalAdvanceInvoice.RecId)
        {
            if (reversalAdvanceInvoice.RecId)
            {
                this.collectTaxes(reversalAdvanceInvoice.Voucher, reversalAdvanceInvoice.InvoiceDate, custInvoiceJour.LedgerVoucher, custInvoiceJour.InvoiceDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>collectTaxesFromReversalAdvanceInvoice_Proj</Name>
				<Source><![CDATA[
    private void collectTaxesFromReversalAdvanceInvoice_Proj()
    {
        ProjAdvanceInvoiceSettlement_W projAdvanceInvoiceSettlement;
        CzCustAdvanceInvoiceTable reversalAdvanceInvoice;

        while select Voucher, InvoiceDate from reversalAdvanceInvoice
            exists join projAdvanceInvoiceSettlement
                where projAdvanceInvoiceSettlement.InvoiceJourRecId == projInvoiceJour.RecId
                    && projAdvanceInvoiceSettlement.ReversalAdvanceInvoiceRecId == reversalAdvanceInvoice.RecId
        {
            if (reversalAdvanceInvoice.RecId)
            {
                this.collectTaxes(reversalAdvanceInvoice.Voucher, reversalAdvanceInvoice.InvoiceDate, projInvoiceJour.LedgerVoucher, projInvoiceJour.InvoiceDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNote</Name>
				<Source><![CDATA[
    private boolean isCreditNote(TaxTrans _taxTrans)
    {
        boolean ret = true;

        if (((_taxTrans.TaxBaseAmount > 0 || _taxTrans.TaxAmount > 0) &&
            _taxTrans.TaxOrigin != TaxOrigin::TaxReversed &&
            (_taxTrans.TaxDirection == TaxDirection::IncomingTax ||
            _taxTrans.TaxDirection == TaxDirection::UseTax ||
            _taxTrans.TaxDirection == TaxDirection::TaxTransaction)) ||

            ((_taxTrans.TaxBaseAmount < 0 || _taxTrans.TaxAmount < 0) &&
            _taxTrans.TaxOrigin == TaxOrigin::TaxReversed &&
            (_taxTrans.TaxDirection == TaxDirection::IncomingTax ||
            _taxTrans.TaxDirection == TaxDirection::UseTax ||
            _taxTrans.TaxDirection == TaxDirection::TaxTransaction)) ||

            ((_taxTrans.TaxBaseAmount < 0 || _taxTrans.TaxAmount < 0) &&
            _taxTrans.TaxOrigin != TaxOrigin::TaxReversed &&
            (_taxTrans.TaxDirection == TaxDirection::OutgoingTax ||
            _taxTrans.TaxDirection == TaxDirection::TaxExemptPurchase ||
            _taxTrans.TaxDirection == TaxDirection::TaxExemptSales)) ||

            ((_taxTrans.TaxBaseAmount > 0 || _taxTrans.TaxAmount > 0) &&
            _taxTrans.TaxOrigin == TaxOrigin::TaxReversed &&
            (_taxTrans.TaxDirection == TaxDirection::OutgoingTax ||
            _taxTrans.TaxDirection == TaxDirection::TaxExemptPurchase ||
            _taxTrans.TaxDirection == TaxDirection::TaxExemptSales)))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitPaymentViaPaymMode</Name>
				<Source><![CDATA[
    private int getSplitPaymentViaPaymMode(CustAccount _accountNum, TransDate _transDate, Voucher _voucher, InvoiceId _invoiceId = '')
    {
        int ret;
        CustTrans custTrans;
        CustPaymModeTable custPaymMode;
        select firstonly SplitPayment_W from custPaymMode
            exists join RecId from custTrans
            where custTrans.PaymMode == custPaymMode.PaymMode
                && (!_invoiceId || custTrans.Invoice == _invoiceId)
                && custTrans.AccountNum == _accountNum
                && custTrans.TransDate == _transDate
                && custTrans.Voucher == _voucher;
        ret = custPaymMode.SplitPayment_W;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitPaymentViaCustTrans_W</Name>
				<Source><![CDATA[
    private int getSplitPaymentViaCustTrans_W(TransDate _transDate, Voucher _voucher)
    {
        int ret;
        CustTrans custTrans;
        CustTrans_W custTrans_W;
        select firstonly SplitPayment_W, VoluntarySplitPayment_W from custTrans_W
            exists join RecId from custTrans
            where custTrans.RecId == custTrans_W.CustTrans
                && custTrans.Voucher == _voucher
                && custTrans.TransDate == _transDate;
        ret = custTrans_W.SplitPayment_W && !custTrans_W.VoluntarySplitPayment_W;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>origCustInvoiceIdAndDate</Name>
				<Source><![CDATA[
    private container origCustInvoiceIdAndDate()
    {
        // PL credit note always refers to one invoice
        CustInvoiceTrans invoiceTrans, origTrans;
        CustInvoiceTrans_W invoiceTrans_W;

        if (CustInvoiceJourOrigInvoices_PLFlight::instance().isEnabled())
        {
            return SAFTReportInvoiceIdDateStringBuilder_W::newFromInvoiceIdDateSet(CustInvoiceJour::originalCustInvoices_PL(custInvoiceJour))
                .getInvoiceIdDateStringContainer();
        }

        select firstonly InvoiceId, InvoiceDate from origTrans
            exists join invoiceTrans
                where invoiceTrans.InvoiceId == custInvoiceJour.InvoiceId &&
                    invoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate &&
                    invoiceTrans.SalesId == custInvoiceJour.SalesId &&
                    invoiceTrans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
            exists join invoiceTrans_W
                where invoiceTrans_W.CustInvoiceTrans == invoiceTrans.RecId &&
                    invoiceTrans_W.RefReturnInvoiceTrans_W == origTrans.RecId;

        return [origTrans.InvoiceId, origTrans.InvoiceDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjOriginalAdvanceInvoiceId</Name>
				<Source><![CDATA[
    private container getProjOriginalAdvanceInvoiceId()
    {
        ProjAdvancesSettle settled;
        ProjInvoiceJour settledProjInvoiceJour;

        select firstonly ProjInvoiceId, InvoiceDate from settledProjInvoiceJour
            exists join settled
                where settled.ProjInvoiceJour == settledProjInvoiceJour.RecId
                    && (settled.SettlementProjInvoiceJour != 0 && settled.SettlementProjInvoiceJour == projInvoiceJour.RecId);

        if (settledProjInvoiceJour)
        {
            return [settledProjInvoiceJour.ProjInvoiceId, settledProjInvoiceJour.InvoiceDate];
        }

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProjOriginalAdvanceInvoiceIdSet</Name>
				<Source><![CDATA[
    private void populateProjOriginalAdvanceInvoiceIdSet(Set _originalInvoiceSet, RefRecId _projInvoiceJourRecId)
    {
        ProjAdvancesSettle settled;
        ProjInvoiceJour settledProjInvoiceJour;

        while select RecId, ProjInvoiceId, InvoiceDate from settledProjInvoiceJour
            exists join settled
            where settled.ProjInvoiceJour == settledProjInvoiceJour.RecId
                && settled.SettlementProjInvoiceJour == _projInvoiceJourRecId
        {
            if (_originalInvoiceSet.add([settledProjInvoiceJour.ProjInvoiceId, settledProjInvoiceJour.InvoiceDate]))
            {
                this.populateProjOriginalAdvanceInvoiceIdSet(_originalInvoiceSet, settledProjInvoiceJour.RecId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>origProjInvoiceIdAndDate</Name>
				<Source><![CDATA[
    private container origProjInvoiceIdAndDate()
    {
        List origInvoices = projInvoiceJour.getParentOriginalInvoices();
        if (!origInvoices.empty())
        {
            var i = origInvoices.getEnumerator();
            i.moveNext();
            SAFTInvoiceData_W invoiceData = i.current();
            return [invoiceData.parmInvoiceId(), invoiceData.parmInvoiceDate()];
        }

        // if we couldn't find a match, we then check if this invoice was settling a project advance invoice
        if (countryRegion_PL)
        {
            return projAdvanceInvoiceOrigData;
        }

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>origProjInvoiceIdsAndDates</Name>
				<Source><![CDATA[
    private container origProjInvoiceIdsAndDates()
    {
        SAFTReportInvoiceIdDateStringBuilder_W invoiceIdBuilder = SAFTReportInvoiceIdDateStringBuilder_W::newFromInvoiceIdDateList(projInvoiceJour.getParentOriginalInvoices());

        // if we couldn't find a match, we then check if this invoice was settling a project advance invoice
        if (invoiceIdBuilder.isEmpty() && countryRegion_PL)
        {
            Set originalInvoiceSet = new Set(Types::Container);

            this.populateProjOriginalAdvanceInvoiceIdSet(originalInvoiceSet, projInvoiceJour.RecId);

            invoiceIdBuilder = SAFTReportInvoiceIdDateStringBuilder_W::newFromInvoiceIdDateSet(originalInvoiceSet);
        }

        return invoiceIdBuilder.getInvoiceIdDateStringContainer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>origAdvInvoiceIdAndDate</Name>
				<Source><![CDATA[
    private container origAdvInvoiceIdAndDate()
    {
        // PL credit note always refers to one invoice for display purposes
        CzCustAdvanceInvoiceTable originalInvoiceTable;
        CzCustAdvanceInvoiceLine  originalInvoiceLine;
        CzCustAdvanceInvoiceLine  creditNoteLine;

        select firstonly InvoiceId, InvoiceDate from originalInvoiceTable
            exists join originalInvoiceLine
                where originalInvoiceLine.ParentRecId == originalInvoiceTable.RecId
            exists join creditNoteLine
                where creditNoteLine.OrigAdvanceInvoiceLineRecId == originalInvoiceLine.RecId &&
                      creditNoteLine.ParentRecId == custAdvanceInvoiceTable.RecId;

        return [originalInvoiceTable.InvoiceId, originalInvoiceTable.InvoiceDate];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByMarkupTransSource</Name>
				<Source><![CDATA[
    private void createLinesDataByMarkupTransSource(Common _source, CustVendInvoiceJour _custVendInvoiceJour)
    {
        MarkupTrans markupTrans;

        while select markupTrans
            where markupTrans.TransTableId == _source.TableId
               && markupTrans.TransRecId == _source.RecId
        {
            int idx = conFind(taxSourceRecIds, markupTrans.RecId);
            if (idx)
            {
                this.createLinesDataByMarkupTrans(markupTrans, idx, _custVendInvoiceJour);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLinesDataByMarkupTrans</Name>
				<Source><![CDATA[
    private void createLinesDataByMarkupTrans(MarkupTrans _markupTrans, int _idx, CustVendInvoiceJour _custVendInvoiceJour)
    {
        lines.clear();
        lines.ParentRecId = jourCount;
        lines.ProductDescription = _markupTrans.Txt;
        lines.InvoiceId = _custVendInvoiceJour.InvoiceId;
        lines.Qty = 1;
        lines.UnitOfMeasure = ServiceUnitOfMeasure;
        lines.AmountCurNett = CurrencyExchangeHelper::curAmount2CurAmount(
            -_markupTrans.Posted,
            _markupTrans.CurrencyCode,
            _custVendInvoiceJour.CurrencyCode,
            _custVendInvoiceJour.DocumentDate ? _custVendInvoiceJour.DocumentDate : _custVendInvoiceJour.InvoiceDate);

        [lines.TaxCode, lines.ExemptTax, lines.ReverseCharge, lines.TaxExemptCode, lines.TaxRate, lines.AmountCurGross] = conPeek(taxData, _idx);
        lines.AmountCurGross += lines.AmountCurNett;

        this.addLine(lines);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>