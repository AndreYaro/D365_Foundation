<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalTransUpdateAsset</Name>
	<SourceCode>
		<Declaration><![CDATA[
final class LedgerJournalTransUpdateAsset extends LedgerJournalTransUpdate
{
    #ISOCountryRegionCodes

    private List nonRecoverableTaxAmountCurList;
    private boolean checkTaxParameters_IN = TaxParameters::checkTaxParameters_IN();
    private boolean checkDepreciationParams_IN = AssetParameters::checkAssetParameters_IN();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    boolean check(LedgerJournalTrans        _ledgerJournalTrans,
                  boolean                   _checkNoSettlement = true,
                  LedgerVoucher             _ledgerVoucher = null,
                  LedgerPostingMessageLog   _ledgerPostingMessageCollection = null)
    {
        boolean ok;

        ok = super(_ledgerJournalTrans, _checkNoSettlement, _ledgerVoucher, _ledgerPostingMessageCollection) && this.checkAsset(_ledgerJournalTrans);
        ok = this.checkTaxCombination(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherCheck</Name>
				<Source><![CDATA[
    public boolean ledgerVoucherCheck(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerVoucher _ledgerVoucher,
        boolean _checkNoSettlement = true,
        boolean _reversalsMayExist = false
        )
    {
        boolean ok = true;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        AssetBookTable assetBookTable = AssetBookTable::find(ledgerJournalTrans_Asset.BookId);

        if (assetBookTable.postToGeneralLedger())
        {
            ok = super(_ledgerJournalTrans, _ledgerVoucher, _checkNoSettlement, _reversalsMayExist);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAsset</Name>
				<Source><![CDATA[
    boolean checkAsset(LedgerJournalTrans ledgerJournalTrans)
    {
        AssetPost           assetPost;
        LedgerJournalTable  ledgerJournalTable;
        LedgerJournalTrans_Asset    ledgerJournalTrans_Asset = ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        boolean             budget;

        AssetBook           assetBookLocal;

        ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();
        budget = ledgerJournalTable.JournalType == LedgerJournalType::AssetBudgets;

        if (checkDepreciationParams_IN)
        {
            assetBookLocal = AssetBook::find(ledgerJournalTrans_Asset.AssetId, ledgerJournalTrans_Asset.BookId);
        }

        assetPost = AssetPost::newLedgerJournalTrans(null, ledgerJournalTrans, null, ledgerJournalTrans_Asset, isOffset, 0);

        if (checkDepreciationParams_IN && assetBookLocal.AssetGroupDepreciation_IN)
        {
            assetPost = AssetPost::newLedgerJournalTrans_IN(null,ledgerJournalTrans,ledgerJournalTrans_Asset,0);
        }

        if (ledgerJournalTable.JournalType == LedgerJournalType::Assets)
        {
            if (checkDepreciationParams_IN && assetBookLocal.AssetGroupDepreciation_IN         &&
            (ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::Depreciation   ||
                ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::DepreciationAdj))
            {
                return assetPost.check_IN(budget, false);
            }
            else
            {
                return assetPost.check(budget);
            }
        }

        else if (checkDepreciationParams_IN && ledgerJournalTable.JournalType == LedgerJournalType::Daily)
        {
            if (assetBookLocal.AssetGroupDepreciation_IN                                     &&
            (ledgerJournalTrans_Asset.TransType   == AssetTransTypeJournal::Depreciation  ||
                ledgerJournalTrans_Asset.TransType   == AssetTransTypeJournal::DepreciationAdj))
            {
                return assetPost.check_IN(budget, false);
            }
            else
            {
                return assetPost.check(budget, false);
            }
        }
        else
        {
            return assetPost.check(budget, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWhenPost</Name>
				<Source><![CDATA[
    boolean checkWhenPost(
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans          _originalLedgerJournalTrans,
        boolean                     _checkNoSettlement = true,
        LedgerPostingMessageLog     _ledgerPostingMessageCollection = null)
    {
        boolean ok;
        ;

        ok = super(_ledgerJournalTrans, _originalLedgerJournalTrans, _checkNoSettlement, _ledgerPostingMessageCollection);
        ok = this.checkTaxCombination(_ledgerJournalTrans, _ledgerPostingMessageCollection) && ok;
        ok = this.checkAsset(_ledgerJournalTrans) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeRateDate</Name>
				<Source><![CDATA[
    private TransDate getExchangeRateDate(AssetBook _assetBookLocal, LedgerJournalTrans   _ledgerJournalTrans)
    {
        TransDate exchangeRateDate;

        exchangeRateDate = _assetBookLocal.exchangeRateDate();

        if (!exchangeRateDate)
        {
            exchangeRateDate = _ledgerJournalTrans.TransDate;
        }

        return exchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount ledgerDimension(LedgerJournalTrans _journalTrans)
    {
        AssetPostingProfile assetPostingProfile = _journalTrans.PostingProfile;
        LedgerJournalTrans_Asset ledgerJournalTrans_Asset = _journalTrans.findLedgerJournalTransAssetSibling();
        AssetTable assetTable;

        if (!assetPostingProfile)
        {
            assetPostingProfile = AssetBook::find(_journalTrans.parmAccount(), ledgerJournalTrans_Asset.BookId).PostingProfile;
        }

        assetTable = AssetTable::findByLedgerDimension(_journalTrans.parmLedgerDimension());
        return AssetLedgerAccounts::assetLedgerDimension(assetTable.AssetId,
                                                       ledgerJournalTrans_Asset.BookId,
                                                       AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType
                                                           // <GJP>
                                                           , ledgerJournalTrans_Asset.DocumentType_JP
                                                           // </GJP>
                                                           ),
                                                       assetPostingProfile
                                                       // <GJP>
                                                       , ledgerJournalTrans_Asset.DocumentType_JP
                                                       // </GJP>
                                                       );
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDerivedTaxLedger</Name>
				<Source><![CDATA[
    private void updateDerivedTaxLedger(
        LedgerVoucher _ledgerVoucher,
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans _ledgerJournalTransDerived,
        TaxAmount _taxInCostPiceAmount,
        AssetBookId _assetBookId = '')
    {
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerVoucherObject         ledgerVoucherObject;
        LedgerVoucherObject         originalLedgerVoucherObject;
        LedgerJournalTrans_Asset    ledgerJournalTrans_AssetDerived = _ledgerJournalTransDerived.findLedgerJournalTransAssetSibling();
        CurrencyExchangeHelper      exchangeRateHelper;
        LedgerDimensionDefaultAccount defaultLedgerDimension;
        LedgerDimensionAccount mergedLedgerDimension;
        CurrentOperationsTax postingLayer;
        TransDate exchangeRateDate;

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        ledgerJournalTrans_AssetDerived.BookId = _assetBookId;
        if (_assetBookId != '')
        {
            exchangeRateDate = AssetBook::find(ledgerJournalTrans_AssetDerived.AssetId, _assetBookId).exchangeRateDate();
        }

        postingLayer = AssetBookTable::find(ledgerJournalTrans_AssetDerived.BookId).CurrentOperationsTax;
        if (ledgerVoucherObject.parmPostingLayer() != postingLayer)
        {
            // save the original
            originalLedgerVoucherObject = ledgerVoucherObject;

            // search for a posting voucher for the posting layer
            ledgerVoucherObject = _ledgerVoucher.findReference(
                originalLedgerVoucherObject.parmSubledgerVoucher(),
                originalLedgerVoucherObject.parmAccountingDate(),
                postingLayer);

            if (ledgerVoucherObject == null)
            {
                // create a new posting voucher for the posting layer
                ledgerVoucherObject = LedgerVoucherObject::newReference(
                    originalLedgerVoucherObject.parmSubledgerVoucher(),
                    originalLedgerVoucherObject.parmAccountingDate(),
                    originalLedgerVoucherObject.parmSysModule());

                ledgerVoucherObject.parmPostingLayer(postingLayer);
                _ledgerVoucher.addVoucher(ledgerVoucherObject);
            }
        }

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTransDerived.ExchRate);
        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTransDerived.ExchRateSecond);
        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTransDerived.ReportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTransDerived.ReportingCurrencyExchRateSecondary);

        mergedLedgerDimension = this.getOffsetLedgerDimensionDerived(
            _ledgerJournalTransDerived,
            _ledgerJournalTrans,
            ledgerJournalTrans_AssetDerived,
            _ledgerJournalTransDerived);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                    ledgerVoucherObject,
                                    LedgerPostingType::LedgerJournal,
                                    mergedLedgerDimension,
                                    _ledgerJournalTransDerived.CurrencyCode,
                                    -_taxInCostPiceAmount,
                                    exchangeRateHelper);
        ledgerVoucherTransObject.parmSourceTableId(_ledgerJournalTransDerived.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_ledgerJournalTransDerived.RecId);
        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTransDerived.Qty);
        ledgerVoucherTransObject.parmReasonRefRecID(_ledgerJournalTransDerived.ReasonRefRecID);
        ledgerVoucherTransObject.parmPaymentReference(_ledgerJournalTransDerived.PaymReference);

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        mergedLedgerDimension = this.getLedgerDimensionDerived(
            _ledgerJournalTransDerived,
            _ledgerJournalTrans,
            ledgerJournalTrans_AssetDerived,
            _ledgerJournalTransDerived);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                    ledgerVoucherObject,
                                    LedgerPostingType::LedgerJournal,
                                    mergedLedgerDimension,
                                    _ledgerJournalTransDerived.CurrencyCode,
                                    _taxInCostPiceAmount,
                                    exchangeRateHelper);
        ledgerVoucherTransObject.parmSourceTableId(_ledgerJournalTransDerived.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_ledgerJournalTransDerived.RecId);
        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTransDerived.Qty);
        ledgerVoucherTransObject.parmReasonRefRecID(_ledgerJournalTransDerived.ReasonRefRecID);
        ledgerVoucherTransObject.parmHistoricalExchangeRateDate(exchangeRateDate? exchangeRateDate : _ledgerJournalTransDerived.TransDate);
        ledgerVoucherTransObject.parmPaymentReference(_ledgerJournalTransDerived.PaymReference);

        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            _ledgerVoucher.bondLast2_RU();
        }

        if (originalLedgerVoucherObject != null)
        {
            // change back to the original posting voucher
            ledgerVoucherObject = _ledgerVoucher.findReference(
                originalLedgerVoucherObject.parmSubledgerVoucher(),
                originalLedgerVoucherObject.parmAccountingDate(),
                originalLedgerVoucherObject.parmPostingLayer());

            Debug::assert(ledgerVoucherObject != null);
            originalLedgerVoucherObject = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssetPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an <c>AssetPost</c> object.
    /// </summary>
    /// <param name = "_ledgerVoucher">
    /// A <c>ledgervoucher</c> object.
    /// </param>
    /// <param name = "_posting">
    /// The ledger posting type.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    /// A  ledger journal transaction record.
    /// </param>
    /// <param name = "_originalLedgerJournalTrans">
    /// The original ledger journal transaction record.
    /// </param>
    /// <param name = "_assetBook">
    /// Fixed asset book table record.
    /// </param>
    /// <param name = "_ledgerJournalTrans_Asset">
    /// Asset journal line record.
    /// </param>
    /// <param name = "_taxAmount">
    /// The tax amount on the asset group.
    /// </param>
    /// <param name = "_taxInCostPriceAmount">
    /// The tax amount in cost price on the asset group.
    /// </param>
    /// <returns>
    /// The new instance of <c>AssetPost</c> class.
    /// </returns>
    protected AssetPost createAssetPost(
        LedgerVoucher               _ledgerVoucher,
        LedgerPostingType           _posting,
        LedgerJournalTrans          _ledgerJournalTrans,
        LedgerJournalTrans          _originalLedgerJournalTrans,
        AssetBook                   _assetBook,
        LedgerJournalTrans_Asset    _ledgerJournalTrans_Asset,
        TaxAmount                   _taxAmount,
        TaxAmount                   _taxInCostPriceAmount
        )
    {
        AssetPost                       assetPost;

        if ((checkTaxParameters_IN || checkDepreciationParams_IN) && _posting != LedgerPostingType::Tax)
        {
            if (checkDepreciationParams_IN && _assetBook.Depreciation)
            {
                if (totLoiAmount)
                {
                    assetPost = AssetPost::newLedgerJournalTrans_IN(_ledgerVoucher, _ledgerJournalTrans, _ledgerJournalTrans_Asset, _taxAmount, _taxInCostPriceAmount, totLoiAmount);
                }
                else
                {
                    assetPost = AssetPost::newLedgerJournalTrans(_ledgerVoucher, _ledgerJournalTrans, _originalLedgerJournalTrans, _ledgerJournalTrans_Asset, isOffset, _taxAmount, _taxInCostPriceAmount);
                }
            }
            else if (checkDepreciationParams_IN)
            {
                assetPost = AssetPost::newLedgerJournalTrans_IN(_ledgerVoucher, _ledgerJournalTrans, _ledgerJournalTrans_Asset, _taxAmount, _taxInCostPriceAmount, totLoiAmount);
            }
            else if (checkTaxParameters_IN && totLoiAmount)
            {
                assetPost = AssetPost::newLedgerJournalTrans_IN(_ledgerVoucher, _ledgerJournalTrans, _ledgerJournalTrans_Asset, _taxAmount, _taxInCostPriceAmount, totLoiAmount);
            }
            else
            {
                assetPost = AssetPost::newLedgerJournalTrans(_ledgerVoucher, _ledgerJournalTrans, _originalLedgerJournalTrans, _ledgerJournalTrans_Asset, isOffset, _taxAmount, _taxInCostPriceAmount);
            }
        }
        else
        {
            assetPost = AssetPost::newLedgerJournalTrans(_ledgerVoucher, _ledgerJournalTrans, _originalLedgerJournalTrans, _ledgerJournalTrans_Asset, isOffset, _taxAmount, _taxInCostPriceAmount);
        }

        return assetPost;

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    public void updateNow(LedgerVoucher        _ledgerVoucher,
                   LedgerPostingType    _posting,
                   LedgerJournalTrans   _ledgerJournalTrans,
                   LedgerJournalTrans   _originalLedgerJournalTrans,
                   boolean              _interCompany = false
                   , boolean            _reversalsMayExist = true,
                   boolean              _isDueToDueFromAccount =  false
                   )
    {
        TaxAmount                       taxAmount;
        TaxAmount                       taxInCostPriceAmount;
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerVoucherObject             originalLedgerVoucherObject;
        LedgerJournalTable              ledgerJournalTable;
        LedgerJournalTrans              ledgerJournalTransDerived;
        LedgerJournalTrans_Asset        ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        LedgerDimensionAccount          mergedLedgerDimension;
        LedgerBondClient_RU             ledgerBondClient_RU = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        TaxUncommitted_IN               taxUncommittedIN;
        TaxUncommitted                  taxUncommittedLoc;
        LedgerDimensionDefaultAccount   operationLedgerAccount;
        LedgerDimensionAccount          operationLedgerDimension;
        LedgerPostingController         ledgerPostingController;
        #ISOCountryRegionCodes
        CurrentOperationsTax            postingLayer;
        AmountCur                       assetBookTableDerivedJournalAmountCur;
        AmountCur                       assetBookTableDerivedJournalAmountReporting;
        AssetDocumentType_JP            derivedDocumentType;
        RefRecId                        derivedDocumentRecid;

        ttsbegin;

        taxAmount = 0;

        if (ledgerBondClient_RU)
        {
            ledgerBondClient_RU.addNewLogObject();
        }

        if (_posting == LedgerPostingType::InterCompany)
        {
            this.updateNowInterCompanyPostingType(_ledgerVoucher, _ledgerJournalTrans, _originalLedgerJournalTrans);
        }
        else
        {
            AssetBook assetBook = AssetBook::find(ledgerJournalTrans_Asset.AssetId, ledgerJournalTrans_Asset.BookId);
            AssetBookTable assetBookTable = assetBook.assetBookTable();

            ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            ledgerJournalTable = _originalLedgerJournalTrans.ledgerJournalTable();

            if (taxVoucherService.isTaxable(_originalLedgerJournalTrans, isOffset))
            {
                taxAmount = taxVoucherService.taxAmountForAssetType(_originalLedgerJournalTrans, _interCompany);

                // <GTE>
                if(TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
                {
                    if (!TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_originalLedgerJournalTrans).skipTaxDocument())
                    {
                        taxInCostPriceAmount = this.getTaxInCostPriceAmountGTE(_originalLedgerJournalTrans);
                    }
                    else
                    {
                        taxInCostPriceAmount = 0;
                    }
                }
                else
                {
                    // </GTE>
                    taxInCostPriceAmount = taxVoucherService.getTransactionalTaxInCostPriceForLine(_originalLedgerJournalTrans, _interCompany);
                    // <GTE>
                }
                // </GTE>
            }

            if (checkTaxParameters_IN)
            {
                while select LoadOnInventoryTax, CustomsDuty from taxUncommittedIN
                        where taxUncommittedIN.TaxUncommitted
                            join  RecId from taxUncommittedLoc
                                where taxUncommittedLoc.SourceTableId == _ledgerJournalTrans.TableId
                                    && taxUncommittedLoc.SourceRecId   == _ledgerJournalTrans.RecId
                                    && taxUncommittedIN.TaxUncommitted == taxUncommittedLoc.RecId
                {
                    totLoiAmount += taxUncommittedIN.LoadOnInventoryTax;

                    if (taxUncommittedIN.CustomsDuty && _ledgerJournalTrans.AmountCurDebit != 0 && _ledgerJournalTrans.AmountCurCredit == 0)
                    {
                        //By default, the customs tax will always be 100% load on inventory
                        totLoiAmount += taxUncommittedIN.CustomsDuty;
                        taxInCostPriceAmount += taxUncommittedIN.CustomsDuty;
                    }
                }
            }

            if ((checkTaxParameters_IN || checkDepreciationParams_IN) && _posting != LedgerPostingType::Tax)
            {
                if (!inclTax && FormulaDesigner_IN::isPriceInclTaxLine(_ledgerJournalTrans.TaxItemGroup) &&
                    _ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets && _ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Ledger)
                {
                    taxAmount = taxVoucherService.priceInclTaxAmount_IN(_ledgerJournalTrans);
                }
            }

            AssetPost assetPost = this.createAssetPost(_ledgerVoucher, _posting, _ledgerJournalTrans, _originalLedgerJournalTrans, assetBook, ledgerJournalTrans_Asset, taxAmount, taxInCostPriceAmount);

            // ---------------------------------------------------------------------------
            // Post the transaction in the context of its original journal and value model
            // ---------------------------------------------------------------------------
            if (checkDepreciationParams_IN                     &&
                assetBook.AssetGroupDepreciation_IN    &&
                (ledgerJournalTrans_Asset.TransType   == AssetTransTypeJournal::Depreciation ||
                ledgerJournalTrans_Asset.TransType    == AssetTransTypeJournal::DepreciationAdj))
            {
                if (assetBook.currentOperationsTax() == CurrentOperationsTax::None)
                {
                    assetPost.post_IN(false, false);
                }
                else
                {
                    assetPost.post_IN(true, false);
                }
            }
            else
            {
                // This isn't a derogatory tax value model, so post it into both the general ledger and fixed assets sub ledger.
                if (_ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
                    && assetBook.IsDerogatoryBook_FR
                    && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]))
                {
                    // This is a derogatory tax value model so just post into the fixed assets sub ledger.
                    assetPost.post(false, false);
                }
                else if (!assetBookTable.postToGeneralLedger())
                {
                    assetPost.post(false, false);
                }
                else
                {
                    // This isn't a derogatory tax value model, so post it into both the general ledger and fixed assets sub ledger.
                    assetPost.post(true, false);
                }
            }

            boolean isOneVoucherFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetOneVoucherFeature::instance());
            Voucher depreciationAdjustmentVoucher;
            if (isOneVoucherFeatureEnabled)
            {
                depreciationAdjustmentVoucher = assetPost.parmDepreciationAdjVoucher();
            }

            // --------------------------------------------------------------------------------------
            // Post non-recoverable tax amount in the context of its original journal and value model
            // --------------------------------------------------------------------------------------
            if (assetBookTable.postToGeneralLedger())
            {
                nonRecoverableTaxAmountCurList = this.getNonRecoverableTaxAmountCurList(_originalLedgerJournalTrans, _interCompany, _isDueToDueFromAccount);
                if (nonRecoverableTaxAmountCurList
                    && ((isOffset && _originalLedgerJournalTrans.isOffsetTaxable())
                        || (!isOffset && _originalLedgerJournalTrans.isPrimaryTaxable())))
                {
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
                    {
                        if (_originalLedgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
                        {
                            operationLedgerAccount = AssetTable::findByLedgerDimension(_originalLedgerJournalTrans.LedgerDimension).assetLedgerDimension(_originalLedgerJournalTrans.PostingProfile,
                            AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType),ledgerJournalTrans_Asset.BookId);

                            operationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(operationLedgerAccount, _originalLedgerJournalTrans.DefaultDimension);
                        }
                        else
                        {
                            changecompany (_originalLedgerJournalTrans.OffsetCompany)
                            {
                                operationLedgerAccount = AssetTable::findByLedgerDimension(_originalLedgerJournalTrans.OffsetLedgerDimension).assetLedgerDimension(_originalLedgerJournalTrans.PostingProfile,
                                AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType), ledgerJournalTrans_Asset.BookId);

                                operationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(operationLedgerAccount, _originalLedgerJournalTrans.OffsetDefaultDimension);
                            }
                        }
                    }
                    else
                    {
                        operationLedgerAccount = AssetLedgerAccounts::assetLedgerDimension(
                        ledgerJournalTrans_Asset.AssetId,
                        ledgerJournalTrans_Asset.BookId,
                        AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType
                            // <GJP>
                            , ledgerJournalTrans_Asset.DocumentType_JP
                            // </GJP>
                            ),
                        AssetPost::postingProfileFromLedgerJournalTrans(_originalLedgerJournalTrans, ledgerJournalTrans_Asset.BookId)
                        // <GJP>
                        , ledgerJournalTrans_Asset.DocumentType_JP
                        // </GJP>
                        );

                        if (_originalLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
                        {
                            operationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(operationLedgerAccount, _originalLedgerJournalTrans.OffsetDefaultDimension);
                        }
                        else
                        {
                            operationLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(operationLedgerAccount, _originalLedgerJournalTrans.DefaultDimension);
                        }
                    }

                    ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);

                    this.postNonReoverableTax(
                    _ledgerVoucher,
                    ledgerPostingController,
                    _originalLedgerJournalTrans,
                    _ledgerJournalTrans,
                    operationLedgerDimension,
                    _interCompany,
                    _isDueToDueFromAccount);
                }
            }

            // ---------------------------------------------
            // Post the transaction for derived value models
            // ---------------------------------------------
            if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT])
                || _ledgerJournalTrans.ledgerJournalTable().AssetTransferType_LT == LtAssetTransferType::NotTransfer)
            {
                ledgerJournalTable = _ledgerJournalTrans.ledgerJournalTable();
                ledgerJournalTransDerived = _ledgerJournalTrans.data();

                if (ledgerJournalTable.JournalType != LedgerJournalType::Assets)

                {
                    // The AssetBookTableDerivedJournal records haven't been created yet,
                    // so default them in.
                    LedgerJournalEngine::createDefsForAssetBookTableDerivedJourn(_ledgerJournalTrans, ledgerJournalTrans_Asset);
                }

                while select assetBookTableDerivedJournal
                    where assetBookTableDerivedJournal.RefRecId == _ledgerJournalTrans.RecId
                {

                    if (AssetPostDerivedBookInvalidStatusFlight::instance().isEnabled()
                        && ledgerJournalTrans_Asset.TransType != AssetTransTypeJournal::DisposalSale 
                        && ledgerJournalTrans_Asset.TransType != AssetTransTypeJournal::DisposalScrap)
                    {
                        AssetBook assetBookDerived = AssetBook::find(ledgerJournalTrans_Asset.AssetId, assetBookTableDerivedJournal.AssetBookId);
                        AssetStatusType assetBookDerivedStatusType = AssetStatusType::construct(assetBookDerived.Status);
                        if (!assetBookDerivedStatusType.canBePostedTo())
                        {
                            continue;
                        }
                    }

                    if (this.isAccountTypeFixedAsset(ledgerJournalTransDerived, _originalLedgerJournalTrans))
                    {
                        // If the main account and offset account of a LedgerJournalTrans are both of FixedAssets type, AssetBookTableDerivedJournal.AmountCur
                        // of this record is assigned to the value correspond to offset account, which is the opposite number of the value correspond to main account.
                        // So, for the main Account, do the following conversion
                        assetBookTableDerivedJournalAmountCur = -assetBookTableDerivedJournal.AmountCur;
                        assetBookTableDerivedJournalAmountReporting = -assetBookTableDerivedJournal.ReportingCurrencyAmount;
                    }
                    else
                    {
                        assetBookTableDerivedJournalAmountCur = assetBookTableDerivedJournal.AmountCur;
                        assetBookTableDerivedJournalAmountReporting = assetBookTableDerivedJournal.ReportingCurrencyAmount;
                    }

                    if (assetBookTableDerivedJournalAmountCur > 0)
                    {
                        ledgerJournalTransDerived.AmountCurDebit = (assetBookTableDerivedJournalAmountCur - taxAmount);
                        ledgerJournalTransDerived.AmountCurCredit = 0;
                    }
                    else
                    {
                        ledgerJournalTransDerived.AmountCurDebit = 0;
                        ledgerJournalTransDerived.AmountCurCredit = -(assetBookTableDerivedJournalAmountCur - taxAmount);
                    }

                    if (assetBookTableDerivedJournalAmountReporting > 0)
                    {
                        ledgerJournalTrans_Asset.AmountDebitReportingCurrency = (assetBookTableDerivedJournalAmountReporting - taxAmount);
                        ledgerJournalTrans_Asset.AmountCreditReportingCurrency = 0;
                    }
                    else
                    {
                        ledgerJournalTrans_Asset.AmountDebitReportingCurrency = 0;
                        ledgerJournalTrans_Asset.AmountCreditReportingCurrency = -(assetBookTableDerivedJournalAmountReporting - taxAmount);
                    }

                    // Point the asset transaction to the derived value model. This is just a temporary buffer, that's selected within this method,
                    // so there's no need to worry about wiping out existing values.
                    ledgerJournalTrans_Asset.BookId = assetBookTableDerivedJournal.AssetBookId;

                    AssetBook assetBookLocal = AssetBook::find(ledgerJournalTrans_Asset.AssetId, ledgerJournalTrans_Asset.BookId);
                    AssetBookTable assetBookTableLocal = assetBookLocal.assetBookTable();
                    
                    this.setUpDefaultDimensionsAndOffsetDefaultDimensions(
                        ledgerJournalTransDerived,
                        assetBookLocal,
                        assetBookTableLocal.CurrentOperationsTax,
                        ledgerJournalTable.DefaultDimension,
                        _ledgerJournalTrans.DefaultDimension,
                        _ledgerJournalTrans.getLedgerJournalTransOffsetDefaultDimensions(),
                        _originalLedgerJournalTrans.getLedgerJournalTransDefaultDimensions());

                    if (checkDepreciationParams_IN && assetBookLocal.Depreciation)
                    {
                        if (totLoiAmount)
                        {
                            assetPost = AssetPost::newLedgerJournalTrans_IN(_ledgerVoucher, ledgerJournalTransDerived, ledgerJournalTrans_Asset, 0, taxInCostPriceAmount, totLoiAmount);
                        }
                        else
                        {
                            assetPost = AssetPost::newLedgerJournalTrans(_ledgerVoucher, ledgerJournalTransDerived, _originalLedgerJournalTrans, ledgerJournalTrans_Asset, isOffset, 0, taxInCostPriceAmount);
                        }
                    }
                    else if (checkDepreciationParams_IN)
                    {
                        assetPost = AssetPost::newLedgerJournalTrans_IN(_ledgerVoucher, ledgerJournalTransDerived, ledgerJournalTrans_Asset, 0, taxInCostPriceAmount, totLoiAmount);
                    }
                    else if (checkTaxParameters_IN && totLoiAmount)
                    {
                        assetPost = AssetPost::newLedgerJournalTrans_IN(_ledgerVoucher, ledgerJournalTransDerived, ledgerJournalTrans_Asset, 0, taxInCostPriceAmount, totLoiAmount);
                    }
                    else
                    {
                        assetPost = AssetPost::newLedgerJournalTrans(_ledgerVoucher, ledgerJournalTransDerived, _originalLedgerJournalTrans, ledgerJournalTrans_Asset, isOffset, 0, taxInCostPriceAmount);

                        if (ledgerJournalTrans_Asset.DocumentType_JP != AssetDocumentType_JP::None
                            && ledgerJournalTrans_Asset.AssetDocumentEntry_JP)
                        {
                            [derivedDocumentType, derivedDocumentRecid] = assetPost.refreshAssetDocumentDerived_JP();
                        }
                    }

                    assetPost.parmIsDerivedBookPosting(true);

                    if (isOneVoucherFeatureEnabled)
                    {
                        assetPost.parmDepreciationAdjVoucher(depreciationAdjustmentVoucher);
                    }

                    if (checkDepreciationParams_IN                                                       &&
                        assetBookLocal.AssetGroupDepreciation_IN                                      &&
                    (ledgerJournalTrans_Asset.TransType   == AssetTransTypeJournal::Depreciation   ||
                        ledgerJournalTrans_Asset.TransType   == AssetTransTypeJournal::DepreciationAdj))
                    {
                        if (assetBook.currentOperationsTax() == CurrentOperationsTax::None)
                        {
                            assetPost.post_IN(false, false);
                        }
                        else
                        {
                            assetPost.post_IN(true, false);
                        }

                        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                        mergedLedgerDimension = this.getOffsetLedgerDimensionDerived(
                            _ledgerJournalTrans,
                            _ledgerJournalTrans,
                            ledgerJournalTrans_Asset,
                            ledgerJournalTransDerived);

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                ledgerVoucherObject,
                                LedgerPostingType::LedgerJournal,
                                mergedLedgerDimension,
                                ledgerJournalTransDerived.CurrencyCode,
                                -ledgerJournalTransDerived.amount(),
                                exchangeRateHelper);
                        if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
                        {
                            ledgerVoucherTransObject.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());
                        }
                        ledgerVoucherTransObject.parmSourceTableId(ledgerJournalTransDerived.TableId);
                        ledgerVoucherTransObject.parmSourceRecId(ledgerJournalTransDerived.RecId);
                        ledgerVoucherTransObject.parmQuantity(ledgerJournalTransDerived.Qty);
                        _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                        if (taxInCostPriceAmount)
                        {
                            this.updateDerivedTaxLedger(_ledgerVoucher, _ledgerJournalTrans, ledgerJournalTransDerived, taxInCostPriceAmount, ledgerJournalTrans_Asset.BookId);
                        }
                    }
                    else if (checkTaxParameters_IN)
                    {
                        if (ledgerJournalTransDerived.AccountType == LedgerJournalACType::FixedAssets
                            && assetBookLocal.IsDerogatoryBook_FR
                            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]))
                        {
                            // This is a derogatory tax value model so just post into the fixed assets sub ledger.
                            assetPost.post(false, false);
                        }
                        else if (!assetBookTableLocal.postToGeneralLedger())
                        {
                            assetPost.post(false, false);
                        }
                        else
                        {
                            // This isn't a derogatory tax value model, so post it into both the general ledger and fixed assets sub ledger.
                            assetPost.post(true, false);
                            postingLayer = assetBookTableLocal.CurrentOperationsTax;
                            if (ledgerVoucherObject.parmPostingLayer() != postingLayer)
                            {
                                // save the original
                                originalLedgerVoucherObject = ledgerVoucherObject;

                                // search for a posting voucher for the posting layer
                                ledgerVoucherObject = _ledgerVoucher.findReference(
                                    originalLedgerVoucherObject.parmSubledgerVoucher(),
                                    originalLedgerVoucherObject.parmAccountingDate(),
                                    postingLayer);

                                if (ledgerVoucherObject == null)
                                {
                                    // create a new posting voucher for the posting layer
                                    ledgerVoucherObject = LedgerVoucherObject::newReference(
                                        originalLedgerVoucherObject.parmSubledgerVoucher(),
                                        originalLedgerVoucherObject.parmAccountingDate(),
                                        originalLedgerVoucherObject.parmSysModule());

                                    ledgerVoucherObject.parmPostingLayer(postingLayer);
                                    _ledgerVoucher.addVoucher(ledgerVoucherObject);
                                }

                                ledgerVoucherObject.parmJournalCategory(_ledgerJournalTrans.TransactionType);
                            }

                            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                            exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
                            exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
                            exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
                            exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

                            mergedLedgerDimension = this.getOffsetLedgerDimensionDerived(
                                _ledgerJournalTrans,
                                _ledgerJournalTrans,
                                ledgerJournalTrans_Asset,
                                ledgerJournalTransDerived);

                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                ledgerVoucherObject,
                                LedgerPostingType::LedgerJournal,
                                mergedLedgerDimension,
                                ledgerJournalTransDerived.CurrencyCode,
                                -ledgerJournalTransDerived.amount(),
                                exchangeRateHelper);
                            if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
                            {
                                ledgerVoucherTransObject.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());
                            }

                            ledgerVoucherTransObject.parmSkipBlockedForManualEntryCheck(true);
                            ledgerVoucherTransObject.parmSourceTableId(ledgerJournalTransDerived.TableId);
                            ledgerVoucherTransObject.parmSourceRecId(ledgerJournalTransDerived.RecId);
                            ledgerVoucherTransObject.parmQuantity(ledgerJournalTransDerived.Qty);
                            ledgerVoucherTransObject.parmPaymentReference(ledgerJournalTransDerived.PaymReference);
                            _ledgerVoucher.addTrans(ledgerVoucherTransObject);

                            if (originalLedgerVoucherObject != null)
                            {
                                // change back to the original posting voucher
                                ledgerVoucherObject = _ledgerVoucher.findReference(
                                    originalLedgerVoucherObject.parmSubledgerVoucher(),
                                    originalLedgerVoucherObject.parmAccountingDate(),
                                    originalLedgerVoucherObject.parmPostingLayer());

                                Debug::assert(ledgerVoucherObject != null);
                                originalLedgerVoucherObject = null;
                            }

                            if (taxInCostPriceAmount)
                            {
                                this.updateDerivedTaxLedger(_ledgerVoucher, _ledgerJournalTrans, ledgerJournalTransDerived, taxInCostPriceAmount, ledgerJournalTrans_Asset.BookId);
                            }
                        }
                    }
                    else
                    {
                        if (ledgerJournalTransDerived.AccountType == LedgerJournalACType::FixedAssets
                            && assetBookLocal.IsDerogatoryBook_FR
                            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR]))
                        {
                            // This is a derogatory tax value model so just post into the fixed assets sub ledger.
                            assetPost.post(false, false);
                        }
                        else if (!assetBookTableLocal.PostToGeneralLedger())
                        {
                            assetPost.post(false, false);
                        }
                        else
                        {
                            if ( ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::None
                                || !ledgerJournalTrans_Asset.AssetDocumentEntry_JP
                                || assetPost.isAssetDocumentPostable_JP())
                            {

                                postingLayer = assetBookTableLocal.CurrentOperationsTax;
                                if (ledgerVoucherObject.parmPostingLayer() != postingLayer)
                                {
                                    // save the original
                                    originalLedgerVoucherObject = ledgerVoucherObject;

                                    // serach for a posting voucher for the posting layer
                                    ledgerVoucherObject = _ledgerVoucher.findReference(
                                        originalLedgerVoucherObject.parmSubledgerVoucher(),
                                        originalLedgerVoucherObject.parmAccountingDate(),
                                        postingLayer);

                                    if (ledgerVoucherObject == null)
                                    {
                                        // create a new posting voucher for the posting layer
                                        ledgerVoucherObject = LedgerVoucherObject::newReference(
                                            originalLedgerVoucherObject.parmSubledgerVoucher(),
                                            originalLedgerVoucherObject.parmAccountingDate(),
                                            originalLedgerVoucherObject.parmSysModule());

                                        ledgerVoucherObject.parmPostingLayer(postingLayer);
                                        _ledgerVoucher.addVoucher(ledgerVoucherObject);
                                    }

                                    ledgerVoucherObject.parmJournalCategory(_ledgerJournalTrans.TransactionType);
                                }

                                // This isn't a derogatory tax value model, so post it into both the general ledger and fixed assets sub ledger.
                                assetPost.post(true, false);

                                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                                exchangeRateHelper.parmExchangeRate1(ledgerJournalTransDerived.ExchRate);
                                exchangeRateHelper.parmExchangeRate2(ledgerJournalTransDerived.ExchRateSecond);
                                exchangeRateHelper.parmReportingExchangeRate1(ledgerJournalTransDerived.ReportingCurrencyExchRate);
                                exchangeRateHelper.parmReportingExchangeRate2(ledgerJournalTransDerived.ReportingCurrencyExchRateSecondary);

                                mergedLedgerDimension = this.getOffsetLedgerDimensionDerived(
                                    _ledgerJournalTrans,
                                    _ledgerJournalTrans, 
                                    ledgerJournalTrans_Asset,                                     
                                    ledgerJournalTransDerived,
                                    derivedDocumentType,
                                    true);

                                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                    ledgerVoucherObject,
                                    LedgerPostingType::LedgerJournal,
                                    mergedLedgerDimension,
                                    ledgerJournalTransDerived.CurrencyCode,
                                    -ledgerJournalTransDerived.amount(),
                                    exchangeRateHelper);

                                if (ledgerJournalTrans_Asset.isDepreciationTransactionType() && ledgerJournalTrans_Asset.amountReportingCurrency())
                                {
                                    ledgerVoucherTransObject.parmReportingCurrencyAmount(-ledgerJournalTrans_Asset.amountReportingCurrency());
                                }

                                if (_originalLedgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::FixedAssets)
                                && taxVoucherService.isTaxable(_originalLedgerJournalTrans, isOffset))
                                {
                                    ledgerVoucherTransObject.parmUseTaxParentTaxUncommitted(taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Source);
                                    ledgerVoucherTransObject.parmTaxParentReferenceTableId(ledgerJournalTransDerived.TableId);
                                    ledgerVoucherTransObject.parmTaxParentReferenceRecId(ledgerJournalTransDerived.RecId);
                                }
                                ledgerVoucherTransObject.parmSkipBlockedForManualEntryCheck(true);
                                ledgerVoucherTransObject.parmQuantity(ledgerJournalTransDerived.Qty);
                                ledgerVoucherTransObject.parmReasonRefRecID(ledgerJournalTransDerived.ReasonRefRecID);
                                ledgerVoucherTransObject.parmPaymentReference(ledgerJournalTransDerived.PaymReference);

                                if (FeatureStateProvider::isFeatureEnabled(AssetOneVoucherFeature::instance()))
                                {
                                    ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
                                }
                                else
                                {
                                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                                }

                                if (originalLedgerVoucherObject != null)
                                {
                                    // change back to the original posting voucher
                                    ledgerVoucherObject = _ledgerVoucher.findReference(
                                        originalLedgerVoucherObject.parmSubledgerVoucher(),
                                        originalLedgerVoucherObject.parmAccountingDate(),
                                        originalLedgerVoucherObject.parmPostingLayer());

                                    Debug::assert(ledgerVoucherObject != null);
                                    originalLedgerVoucherObject = null;
                                }

                                if (taxInCostPriceAmount)
                                {
                                    this.updateDerivedTaxLedger(_ledgerVoucher, _ledgerJournalTrans, ledgerJournalTransDerived, taxInCostPriceAmount, ledgerJournalTrans_Asset.BookId);
                                }
                            }
                        }
                    }
                }
            }
        }

        if (ledgerBondClient_RU)
        {
            ledgerBondClient_RU.bondLog2Log();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpDefaultDimensionsAndOffsetDefaultDimensions</Name>
				<Source><![CDATA[
    private void setUpDefaultDimensionsAndOffsetDefaultDimensions(
        LedgerJournalTrans _ledgerJournalTrans,
        AssetBook _assetBookLocal,
        CurrentOperationsTax _postingLevel,
        DimensionDefault _journalDefaultDimensions,
        DimensionDefault _lineDefaultDimensions,
        DimensionDefault _lineOffsetDefaultDimensions,
        DimensionDefault _originalDefaultDimensions)
    {
        // For derogatory book derived transaction's default dimension should be the same as parent's
        if (!_assetBookLocal.IsDerogatoryBook_FR)
        {
            _ledgerJournalTrans.DefaultDimension = this.getDerivedDefaultDimensions(
                            _assetBookLocal,
                            _postingLevel,
                            _journalDefaultDimensions,
                            _lineDefaultDimensions);

            // If offset transaction offset account data was swapped with account data
            // and 0 was assigned for OffsetLedgerDimension in LedgerJournalCheckPost.ledgerJournalTransOffset().
            // Take default dimensions from original transaction.
            if (isOffset && _lineOffsetDefaultDimensions == 0 && _originalDefaultDimensions)
            {
                _lineOffsetDefaultDimensions = _originalDefaultDimensions;
            }

            _ledgerJournalTrans.OffsetDefaultDimension = this.getDerivedDefaultDimensions(
                            _assetBookLocal,
                            _postingLevel,
                            _journalDefaultDimensions,
                            _lineOffsetDefaultDimensions);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDerivedDefaultDimensions</Name>
				<Source><![CDATA[
    private DimensionDefault getDerivedDefaultDimensions(
        AssetBook _assetBookLocal,
        CurrentOperationsTax _postingLevel,
        DimensionDefault _journalDefaultDimensions,
        DimensionDefault _lineDefaultDimensions)
    {
        DimensionDefault defaultDimension = 0;

        if(_postingLevel != CurrentOperationsTax::None)
        {
            defaultDimension = LedgerDimensionDefaultFacade::serviceMergeDefaultDimensions(
                _journalDefaultDimensions,
                _assetBookLocal.DefaultDimension,
                _lineDefaultDimensions);
        }

        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNonReoverableTax</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts non recoverable tax.
    /// </summary>
    /// <param name="_ledgerVoucher">The <c>LedgerVoucher</c> instance.</param>
    /// <param name="_ledgerPostingController">The <c>LedgerPostingController</c> instance.</param>
    /// <param name="_originalLedgerJournalTrans">The original <c>LedgerJournalTrans</c> to post.</param>
    /// <param name="_ledgerJournalTrans">The <c>LedgerJournalTrans</c> to post.</param>
    /// <param name="_ledgerDimensionId">The ledger account dimension that non recoverable tax to be post.</param>
    /// <param name="_interCompany">True if this is an intercompany journal; otherwise, false.</param>
    /// <param name="_isDueToDueFromAccountLocal">True if this is a due to or due from account; otherwise, false.</param>
    public void postNonReoverableTax(
        LedgerVoucher           _ledgerVoucher,
        LedgerPostingController _ledgerPostingController,
        LedgerJournalTrans      _originalLedgerJournalTrans,
        LedgerJournalTrans      _ledgerJournalTrans,
        LedgerDimensionAccount  _ledgerDimensionId,
        boolean                 _interCompany               = false,
        boolean                 _isDueToDueFromAccountLocal = false
        )
    {
        nonRecoverableTaxAmountCurList = nonRecoverableTaxAmountCurList ? nonRecoverableTaxAmountCurList : this.getNonRecoverableTaxAmountCurList(_originalLedgerJournalTrans, _interCompany, _isDueToDueFromAccountLocal);

        if (nonRecoverableTaxAmountCurList && !nonRecoverableTaxAmountCurList.empty())
        {
            TaxAmountCur nonRecoverableTaxAmountCur;
            LedgerPostingType nonRecoverableTaxLedgerPostingType;
            CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _ledgerPostingController.getReference().parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
            exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
            exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
            exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

            ListEnumerator nonRecoverableTaxAmountCurListEnumerator = nonRecoverableTaxAmountCurList.getEnumerator();
            while (nonRecoverableTaxAmountCurListEnumerator.moveNext())
            {
                [nonRecoverableTaxLedgerPostingType, nonRecoverableTaxAmountCur] = nonRecoverableTaxAmountCurListEnumerator.current();

                if (nonRecoverableTaxAmountCur)
                {
                    LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                        _ledgerPostingController.getReference(),
                        nonRecoverableTaxLedgerPostingType,
                        _ledgerDimensionId,
                        _ledgerJournalTrans.CurrencyCode,
                        nonRecoverableTaxAmountCur,
                        exchangeRateHelper);

                    ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
                    ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
                    ledgerVoucherTransObject.parmText(_ledgerJournalTrans.Txt);
                    ledgerVoucherTransObject.parmPaymentReference(_ledgerJournalTrans.PaymReference);
                    ledgerVoucherTransObject.setTaxTransRelationshipType(TaxTransRelationshipType::TaxInCostPrice);

                    if (_ledgerJournalTrans.AccountType == LedgerJournalACType::Project)
                    {
                        ledgerVoucherTransObject.parmProjLedger(ProjLedger::newLedgerJournalTax(_ledgerJournalTrans));
                    }

                    ledgerVoucherTransObject.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);
                    _ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }

                if (TaxEnginePostingProcessor::isAsyncTaxDocumentPostingMode())
                {
                    GeneralJournalAccountEntryTransactionLink transactionLink;

                    ttsbegin;
                    transactionLink.LedgerDimension = _ledgerDimensionId;
                    transactionLink.SourceRecId = _ledgerJournalTrans.RecId;
                    transactionLink.SourceTableId = tableNum(LedgerJournalTrans);
                    transactionLink.AccountingCurrentAmount = exchangeRateHelper.calculateTransactionToAccounting(_ledgerJournalTrans.CurrencyCode, nonRecoverableTaxAmountCur, true);
                    transactionLink.TransactionCurrency = _ledgerJournalTrans.CurrencyCode;
                    transactionLink.TransactionCurrencyAmount = nonRecoverableTaxAmountCur;
                    transactionLink.IsTaxInCostPrice = NoYes::Yes;
                    transactionLink.insert();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNonRecoverableTaxAmountCurList</Name>
				<Source><![CDATA[
    private List getNonRecoverableTaxAmountCurList(
        LedgerJournalTrans _originalLedgerJournalTrans,
        boolean _interCompany = false,
        boolean _isDueToDueFromAccountLocal = false)
    {
        List ret;

        // if apply sales tax taxation rules, all tax amount is not recoverable. The tax amount is posted in previous steps, so it should not call post again here.
        if (!TaxParameters::find().PurchTaxOnOperations)
        {
            //<GTE>
            if (_originalLedgerJournalTrans.Transferred == NoYes::No
                && TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                ret = this.getNonRecoverableTaxAmountCurListFromGTE(_originalLedgerJournalTrans);
            }
            else
            {
                //</GTE>
                ret = taxVoucherService.getNonRecoverableTaxAmountCurList(_originalLedgerJournalTrans, _interCompany, _isDueToDueFromAccountLocal);
                //<GTE>
            }
            //</GTE>
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionDerived</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount  getLedgerDimensionDerived(
        LedgerJournalTrans _ledgerJournalTransPostingProfile,
        LedgerJournalTrans _ledgerJournalTransMainBook,
        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
        LedgerJournalTrans _ledgerJournalTransDerived)
    {
        LedgerDimensionDefaultAccount ledgerDimension = AssetLedgerAccounts::assetLedgerDimension(
            _ledgerJournalTransPostingProfile.parmAccount(),
            _ledgerJournalTrans_Asset.BookId,
            AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType),
            _ledgerJournalTransPostingProfile.PostingProfile);

        DimensionDefault defaultDimension = DimensionDefaultFacade::serviceMergeDefaultDimensions(
            _ledgerJournalTransDerived.DefaultDimension,
            _ledgerJournalTransMainBook.DefaultDimension);

        return this.mergeLedgerDimensionAndDefaultDimension(ledgerDimension, _ledgerJournalTransDerived.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimensionDerived</Name>
				<Source><![CDATA[
    internal LedgerDimensionAccount getOffsetLedgerDimensionDerived(
        LedgerJournalTrans _ledgerJournalTransPostingProfile,
        LedgerJournalTrans _ledgerJournalTransMainBook,
        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
        LedgerJournalTrans _ledgerJournalTransDerived,
        AssetDocumentType_JP _derivedDocumentType = AssetDocumentType_JP::None,
        boolean _considerDefaultDimensionWhenOffsetLedgerDimensionDoesNotExist = false)
    {
        LedgerDimensionDefaultAccount ledgerDimension = AssetLedgerAccounts::assetOffsetLedgerDimension(
            _ledgerJournalTransPostingProfile.parmAccount(),
            _ledgerJournalTrans_Asset.BookId,
            AssetPost::assetTransTypeJournal2AssetTransType(
                _ledgerJournalTrans_Asset.TransType,
                _derivedDocumentType),
            _ledgerJournalTransPostingProfile.PostingProfile,
            true,
            _derivedDocumentType);

        DimensionDefault defaultDimension;
        if (FixedAssetDefaultOffsetDimensionFlight::instance().isEnabled()
            && _considerDefaultDimensionWhenOffsetLedgerDimensionDoesNotExist == true
            && _ledgerJournalTransDerived.OffsetLedgerDimension == 0
            && _ledgerJournalTransDerived.OffsetDefaultDimension == 0
            && _ledgerJournalTransMainBook.OffsetLedgerDimension == 0
            && _ledgerJournalTransMainBook.OffsetDefaultDimension == 0)
        {
            defaultDimension = DimensionDefaultFacade::serviceMergeDefaultDimensions(
                _ledgerJournalTransDerived.DefaultDimension,
                _ledgerJournalTransMainBook.getLedgerJournalTransDefaultDimensions());
        }
        else
        {
            defaultDimension = DimensionDefaultFacade::serviceMergeDefaultDimensions(
                _ledgerJournalTransDerived.OffsetDefaultDimension,
                _ledgerJournalTransMainBook.getLedgerJournalTransOffsetDefaultDimensions());
        }

        return this.mergeLedgerDimensionAndDefaultDimension(
            ledgerDimension,
            defaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNowInterCompanyPostingType</Name>
				<Source><![CDATA[
    private void updateNowInterCompanyPostingType(LedgerVoucher        _ledgerVoucher,
                                                    LedgerJournalTrans _ledgerJournalTrans,
                                                    LedgerJournalTrans _originalLedgerJournalTrans)
    {
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerJournalTable              ledgerJournalTable;
        AmountCur                       interCompanyAmount;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        LedgerJournalTrans_Asset        ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();
        AssetBook                       assetBookLocal = AssetBook::find(ledgerJournalTrans_Asset.AssetId, ledgerJournalTrans_Asset.BookId);

        ledgerJournalTable = _originalLedgerJournalTrans.ledgerJournalTable();
        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(_ledgerJournalTrans.ExchRate);
        exchangeRateHelper.parmExchangeRate2(_ledgerJournalTrans.ExchRateSecond);
        exchangeRateHelper.parmReportingExchangeRate1(_ledgerJournalTrans.ReportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(_ledgerJournalTrans.ReportingCurrencyExchRateSecondary);

        Debug::assert(_ledgerJournalTrans.AccountType == LedgerJournalACType::Ledger);

        interCompanyAmount = _ledgerJournalTrans.amount() + taxVoucherService.taxAmountForAssetTypeInterCompanyAccount(_originalLedgerJournalTrans, isOffset);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                    ledgerVoucherObject,
                    LedgerPostingType::InterCompany,
                    _ledgerJournalTrans.parmLedgerDimension(),
                    _ledgerJournalTrans.CurrencyCode,
                    interCompanyAmount,
                    exchangeRateHelper);

        if (_originalLedgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::FixedAssets) && taxVoucherService.isTaxable(_originalLedgerJournalTrans, isOffset))
        {
            ledgerVoucherTransObject.parmUseTaxParentTaxUncommitted(taxVoucherService.parmTaxObligationCompany() == TaxObligationCompany::Source);
            ledgerVoucherTransObject.parmTaxParentReferenceTableId(_ledgerJournalTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(_ledgerJournalTrans.RecId);
        }

        ledgerVoucherTransObject.parmQuantity(_ledgerJournalTrans.Qty);
        ledgerVoucherTransObject.parmReasonRefRecID(_ledgerJournalTrans.ReasonRefRecID);
        ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);
        ledgerVoucherTransObject.parmPaymentReference(_ledgerJournalTrans.PaymReference);

        ledgerVoucherTransObject.parmHistoricalExchangeRateDate(this.getExchangeRateDate(assetBookLocal, _ledgerJournalTrans));
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountTypeFixedAsset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that verifies the type of  main account and offset account is "FixedAsset".
    /// </summary>
    /// <param name="ledgerJournalTransDerived">
    ///    Main account and offset account of a LedgerJournalTrans
    /// </param>
    /// <param name="_originalLedgerJournalTrans">
    ///    Main account and offset account of a LedgerJournalTrans
    /// </param>
    /// <returns>
    ///  True if the main account and offset account of a LedgerJournalTrans are FixedAsset, else returns false.
    /// </returns>
    private boolean isAccountTypeFixedAsset(LedgerJournalTrans ledgerJournalTransDerived, LedgerJournalTrans   _originalLedgerJournalTrans)
    {
        if (ledgerJournalTransDerived.LedgerDimension
            && ledgerJournalTransDerived.OffsetLedgerDimension == 0
            && _originalLedgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets
            && _originalLedgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets
            && _originalLedgerJournalTrans.LedgerDimension != 0
            && _originalLedgerJournalTrans.OffsetLedgerDimension != 0
            && ledgerJournalTransDerived.OffsetAccountType == LedgerJournalACType::FixedAssets
            && ledgerJournalTransDerived.AccountType == LedgerJournalACType::FixedAssets)
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxInCostPriceAmountGTE</Name>
				<Source><![CDATA[
    // <GTE>
    private AmountCur getTaxInCostPriceAmountGTE(LedgerJournalTrans _ledgerJournalTrans)
    {
        AmountCur           taxInCostPriceAmount;
        ITaxDocument        taxDocument;
        ITaxDocumentLine    taxDocumentLineObject;
        ITaxableDocument    taxableDocument;

        taxableDocument = TaxableDocumentObject::construct(
            TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_ledgerJournalTrans));

        taxDocument = TaxBusinessService::calculateTax(taxableDocument);

        if (taxDocument)
        {
            taxDocumentLineObject   = taxDocument.findLineBySource(_ledgerJournalTrans.TableId, _ledgerJournalTrans.RecId);

            if (taxDocumentLineObject)
            {
                taxInCostPriceAmount    = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                taxInCostPriceAmount    -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();
            }
        }

        return taxInCostPriceAmount;
    }
    // </GTE>

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>