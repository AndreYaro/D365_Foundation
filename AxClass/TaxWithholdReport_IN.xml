<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithholdReport_IN</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Runs the settlement process for India withholding tax.
/// </summary>
class TaxWithholdReport_IN extends RunBaseBatch implements BatchRetryable
{
    NoYes                               updateNow;

    TaxWithholdType_IN                  taxType;
    TaxInformationRecId_IN              tanNumber;
    TaxWithholdPeriodRecId_IN           settlementPeriod;
    TaxWithholdPaymentVersion_IN        paymentVersion;
    TransDate                           fromDate;
    TransDate                           toDate;
    TransDate                           transactionDate;

    NumberSeq                           numberSeq;
    Voucher                             voucher;
    TaxWithholdPeriods_IN               taxWithholdPeriods;
    TaxWithholdSettledPeriods_IN        taxWithholdSettledPeriods;
    TaxPurchaseTaxPost                  taxPurchaseTaxPost;

    Counter                             transactions;
    Counter                             taxTransactions;
    LedgerVoucher                       ledgerVoucher;
    VendVoucher                         vendVoucher;
    VendAccount                         vendAccount;
    LedgerAccount                       taxReportAccount;
    DimensionDefault                    dimensionLoc;
    AmountCur                           totalClearingAmount;
    Counter                             counterK;
    boolean                             checkTransactions;
    LedgerPostingType                   ledgerPostingTypeLoc;

    TaxWithholdTANNumber_IN             taxWithholdTANNumber;
    TaxWithholdPeriod_IN                taxWithholdPeriod;

    Counter                             versionMax;
    Counter                             versionMin;

    #define.CurrentVersion(2)
    #localMacro.CurrentList
        updateNow,
        taxType,
        taxWithholdTANNumber,
        taxWithholdPeriod,
        paymentVersion,
        fromDate,
        transactionDate
    #endMacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    public boolean canGoBatch()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether update  is happening for original or only doing corrections.
    /// </summary>
    /// <returns>
    /// If update is happeing first time returns true otherwise false.
    /// </returns>
    public boolean checkForUpdate()
    {
        if (updateNow)
        {
            if (paymentVersion == TaxWithholdPaymentVersion_IN::Original &&
                taxWithholdSettledPeriods.VersionNum > 0)
                return checkFailed("@GLS6131");
            if (paymentVersion == TaxWithholdPaymentVersion_IN::LatestCorrections &&
                taxWithholdSettledPeriods.VersionNum == 0)
                return checkFailed("@SYS62062");
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxAuthorityDefaultDimension</Name>
				<Source><![CDATA[
    private boolean checkTaxAuthorityDefaultDimension()
    {
        VendTable vendTable = VendTable::find(TaxWithholdAuthorities_IN::find(TaxWithholdHead_IN::find(settlementPeriod).TaxWithholdAuthorities).VendAccount);
        if (vendTable.DefaultDimension == 0 && LedgerInterunitBalancer::isBalancingEnabled())
        {
            return checkFailed(strFmt('@Tax_WithholdTax:DimensionMissing', vendTable.AccountNum));
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWithholdCompanyGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks withholding company group.
    /// </summary>
    public void checkWithholdCompanyGroup()
    {
        TaxWithholdTrans_IN                 taxTrans;
        TaxWithholdComponentGroupRecId_IN   componentGroupLoc;
        Counter                             counterI = 1;
        Counter                             counterJ = 1;
        container                           conComponentGroup = conNull();

        versionMax  = TaxWithholdReport_IN::counterMax(paymentVersion, settlementPeriod, fromDate, taxType, tanNumber);
        versionMin  = TaxWithholdReport_IN::counterMin(paymentVersion, settlementPeriod, fromDate, taxType, tanNumber);

        while select taxTrans
            group by TaxWithholdComponentGroup, TaxWithholdSettlementPeriod, CurrencyCode, LedgerDimension
            where taxTrans.TaxWithholdSettlementPeriod == settlementPeriod
                && taxTrans.TransDate                  >= fromDate
                && taxTrans.TransDate                  <= toDate
                && taxTrans.TaxWithholdRegNumber       == tanNumber
                && taxTrans.RecoverableAccount         == false
                && taxTrans.NatureOfAssessee           == NatureOfAssessee_IN::Company
                && taxTrans.TaxRepCounter              >= versionMin
                && taxTrans.TaxRepCounter              <= versionMax
                && taxTrans.Settled                    == false
                && taxTrans.Source                     != TaxModuleType::TaxWithhold_IN
                && taxTrans.IsTaxInterim != NoYes::Yes
        {
            if (!conFind(conComponentGroup, taxTrans.TaxWithholdComponentGroup))
            {
                conComponentGroup = conPoke(conComponentGroup, counterI, taxTrans.TaxWithholdComponentGroup);
                counterI++;
            }
        }
        for (counterJ = 1; counterJ <= conLen(conComponentGroup); counterJ++)
        {
            totalClearingAmount = 0;
            ttsbegin;
            numberSeq           = NumberSeq::newGetVoucher(TaxWithholdParameters_IN::numRefTaxReportingVoucher(),false);
            voucher             = numberSeq.voucher();
            ttscommit;
            componentGroupLoc   = conPeek(conComponentGroup, counterJ);
            this.updateNow(componentGroupLoc, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkWithholdOthersGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks other withholding company group.
    /// </summary>
    public void checkWithholdOthersGroup()
    {
        TaxWithholdTrans_IN                 taxTrans;
        TaxWithholdComponentGroupRecId_IN   componentGroupLoc;
        Counter                             counterI = 1;
        Counter                             counterJ = 1;
        container                           conComponentGroup = conNull();

        versionMax  = TaxWithholdReport_IN::counterMax(paymentVersion, settlementPeriod, fromDate, taxType, tanNumber);
        versionMin  = TaxWithholdReport_IN::counterMin(paymentVersion, settlementPeriod, fromDate, taxType, tanNumber);

        while select taxTrans
            group by TaxWithholdComponentGroup, TaxWithholdSettlementPeriod, CurrencyCode, LedgerDimension
            where taxTrans.TaxWithholdSettlementPeriod == settlementPeriod
                && taxTrans.TransDate                  >= fromDate
                && taxTrans.TransDate                  <= toDate
                && taxTrans.TaxWithholdRegNumber       == tanNumber
                && taxTrans.RecoverableAccount         == false
                && taxTrans.NatureOfAssessee           != NatureOfAssessee_IN::Company
                && taxTrans.TaxRepCounter              >= versionMin
                && taxTrans.TaxRepCounter              <= versionMax
                && taxTrans.Settled                    == false
                && taxTrans.Source                     != TaxModuleType::TaxWithhold_IN
                && taxTrans.IsTaxInterim != NoYes::Yes
        {
            if (!conFind(conComponentGroup, taxTrans.TaxWithholdComponentGroup))
            {
                conComponentGroup = conPoke(conComponentGroup, counterI, taxTrans.TaxWithholdComponentGroup);
                counterI++;
            }
        }
        for (counterJ = 1; counterJ <= conLen(conComponentGroup); counterJ++)
        {
            totalClearingAmount = 0;
            ttsbegin;
            numberSeq           = NumberSeq::newGetVoucher(TaxWithholdParameters_IN::numRefTaxReportingVoucher(),false);
            voucher             = numberSeq.voucher();
            ttscommit;
            componentGroupLoc = conPeek(conComponentGroup, counterJ);
            this.updateNow(componentGroupLoc, false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// To show the dialog.
    /// </summary>
    /// <returns>
    /// Returns formrun instance.
    /// </returns>
    public Object dialog()
    {
        Args     args = new  Args();
        FormRun  taxWithholdReport;

        args.name(formStr(TaxWithholdReport_IN));
        args.caller(this);

        taxWithholdReport = classfactory.formRunClass(args);

        taxWithholdReport.init();

        return taxWithholdReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    public void getLast()
    {
        super();
        updateNow               = NoYes::No;
        taxType                 = TaxWithholdType_IN::TDS;
        tanNumber               = 0;
        settlementPeriod        = 0;
        paymentVersion          = TaxWithholdPaymentVersion_IN::Original;
        fromDate                = dateNull();
        transactionDate         = dateNull();
        taxWithholdPeriod       = '';
        taxWithholdTANNumber    = '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertIntoSettledPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts records into <c> TaxWithholdSettledPeriods_IN </c> table.
    /// </summary>
    public void insertIntoSettledPeriod()
    {
        TaxWithholdSettledPeriods_IN    taxWithholdSettledPeriodsLoc;

        ttsbegin;
        taxWithholdSettledPeriodsLoc.TaxType                     = taxType;
        taxWithholdSettledPeriodsLoc.TaxWithholdSettlementPeriod = settlementPeriod;
        taxWithholdSettledPeriodsLoc.FromDate                    = fromDate;
        taxWithholdSettledPeriodsLoc.ToDate                      = toDate;
        taxWithholdSettledPeriodsLoc.VersionNum                  = 0;
        taxWithholdSettledPeriodsLoc.TaxWithholdRegNumber        = tanNumber;
        taxWithholdSettledPeriodsLoc.insert();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromDate</Name>
				<Source><![CDATA[
    public TransDate parmFromDate(TransDate _fromDate = fromDate)
    {
        fromDate = _fromDate;
        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentVersion</Name>
				<Source><![CDATA[
    public TaxWithholdPaymentVersion_IN parmPaymentVersion(TaxWithholdPaymentVersion_IN _paymentVersion = paymentVersion)
    {
        paymentVersion = _paymentVersion;
        return paymentVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSettlementPeriod</Name>
				<Source><![CDATA[
    public TaxWithholdPeriod_IN parmSettlementPeriod(TaxWithholdPeriod_IN _settlementPeriod = taxWithholdPeriod)
    {
        taxWithholdPeriod = _settlementPeriod;
        return taxWithholdPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTANNumber</Name>
				<Source><![CDATA[
    public TaxWithholdTANNumber_IN parmTANNumber(TaxWithholdTANNumber_IN _taxWithholdTANNumber = taxWithholdTANNumber)
    {
        taxWithholdTANNumber = _taxWithholdTANNumber;
        return taxWithholdTANNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxType</Name>
				<Source><![CDATA[
    public TaxWithholdType_IN  parmTaxType(TaxWithholdType_IN _taxType = taxType)
    {
        taxType = _taxType;
        return taxType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionDate</Name>
				<Source><![CDATA[
    public TransDate parmTransactionDate(TransDate _transactionDate = transactionDate)
    {
        transactionDate = _transactionDate;
        return transactionDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateNow</Name>
				<Source><![CDATA[
    public NoYes parmUpdateNow(NoYes _updateNow = updateNow)
    {
        updateNow = _updateNow;
        return updateNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the Ledger voucher during the settlement process.
    /// </summary>
    /// <param name="_ledgerDimensionId">
    /// Ledger dimension Id is used to post the ledger voucher.
    /// </param>
    /// <param name="_dimension">
    /// Dimension is used to post the ledger voucher.
    /// </param>
    /// <param name="_currencyCode">
    /// Currency code is used to post the ledger voucher.
    /// </param>
    /// <param name="_taxAmount">
    /// Ledger voucher posts this amount value.
    /// </param>
    protected void post(LedgerDimensionDefaultAccount   _ledgerDimensionId,
                        DimensionDefault                      _dimension,
                        CurrencyCode                    _currencyCode,
                        TaxWithholdAmount               _taxAmount)
    {
        CurrencyExchangeHelper  currencyExchangeHelper;

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucher.findLedgerVoucherObject().parmAccountingDate());
        if (_taxAmount)
        {
            LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                         ledgerPostingTypeLoc,
                                                                                         LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimensionId),
                                                                                         _currencyCode,
                                                                                         _taxAmount,
                                                                                         currencyExchangeHelper);
            ledgerVoucherTransObject.parmText("@Tax_WithholdTax:WithholdTaxPayment");
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
            if (vendAccount)
            {
                totalClearingAmount += ((_taxAmount) * -1);
            }
            transactions++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingVersionUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates version number.
    /// </summary>
    public void reportingVersionUpdate()
    {
        if (counterK == 0)
        {
            TaxWithholdSettledPeriods_IN::versionSumUp(settlementPeriod, taxType, tanNumber, fromDate);
            counterK++;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs settlement process.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// If tax withold period does not exist then it throws the error.
    /// </exception>
    /// <exception cref="Exception::UpdateConflictNotRecovered">
    /// If update connflict then it throws the error.
    /// </exception>
    /// <exception cref="Exception::UpdateConflict">
    ///  If update connflict then it throws the error.
    /// </exception>
    public void  run()
    {
        #OCCRetryCount
        boolean                         canUpdate;
        TaxWithholdTrans_IN             taxWithholdTrans;

        transactions    = 0;
        taxTransactions = 0;

        System.Diagnostics.Stopwatch sw = System.Diagnostics.Stopwatch::StartNew();
        try
        {
            tanNumber        = TaxWithholdRegNumbers_IN::findByTaxRegistrationNumber(taxWithholdTANNumber, TaxRegistrationType_IN::Company).RecId;
            settlementPeriod = TaxWithholdHead_IN::findByTaxPeriodHead(taxWithholdPeriod, taxType).RecId;

            taxWithholdPeriods      = TaxWithholdPeriods_IN::findByTaxPeriod(settlementPeriod, taxType, fromDate);
            ledgerPostingTypeLoc    = taxType == TaxWithholdType_IN::TDS ? LedgerPostingType::TDS_IN : LedgerPostingType::TCS_IN;
            if (taxWithholdPeriods)
            {
                fromDate    = taxWithholdPeriods.FromDate;
                toDate      = taxWithholdPeriods.ToDate;

                if (!TaxWithholdSettledPeriods_IN::exist(settlementPeriod, taxType, tanNumber, fromDate, toDate))
                {
                    this.insertIntoSettledPeriod();
                }
                taxWithholdSettledPeriods = TaxWithholdSettledPeriods_IN::findByTaxPeriod(settlementPeriod, taxType, fromDate, tanNumber);
                if (updateNow)
                {
                    canUpdate = this.checkForUpdate() && this.checkTaxAuthorityDefaultDimension();
                }
                if (updateNow && canUpdate)
                {
                    ttsbegin;
                    this.checkWithholdCompanyGroup();
                    this.checkWithholdOthersGroup();

                    this.reportingVersionUpdate();

                    if ((!taxTransactions && !transactions) && !checkTransactions)
                    {
                        numberSeq           = NumberSeq::newGetVoucher(TaxWithholdParameters_IN::numRefTaxReportingVoucher(),false);
                        voucher             = numberSeq.voucher();
                        this.updateNow();
                        warning("@GLS6133");
                    }
                    if (taxTransactions)
                    {
                        if (!transactions)
                        {
                            while select forupdate Voucher from taxWithholdTrans
                                where taxWithholdTrans.Voucher   == voucher
                                   && taxWithholdTrans.TransDate == transactionDate
                            {
                                taxWithholdTrans.Voucher = '';
                                taxWithholdTrans.update();
                            }
                            numberSeq.abort();
                        }

                        TransactionLog::create(TransactionLogType::TaxReport, voucher);
                    }
                    ttscommit;
                }
            }
            else
            {
                throw error("@SYS24993");
            }
        }

        catch (Exception::Deadlock)
        {
            retry;
        }

        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        finally
        {
            sw.Stop();
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceIN00058, funcName(), GlobalizationInstrumentationHelper::DefaultFeatureVersion, SysCountryRegionCode::countryInfo(), sw.ElapsedMilliseconds);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Saves the record and post the ledger voucher for this settlement process.
    /// </summary>
    /// <param name="_taxWithholdTrans">
    /// Buffer of <c> TaxWithholdTrans_IN </c>
    /// </param>
    public void saveAndPost(TaxWithholdTrans_IN   _taxWithholdTrans)
    {
        TaxWithholdTrans_IN     taxTransOffsetTrans;
        AmountCur               taxAmountCur;
        LedgerDimensionAccount  offsetTaxLedgerDimension;
        AccountingDistribution accountingDistribution;

        CurrencyCode currencyCode = _taxWithholdTrans.TaxWithholdCurrency;
        if (_taxWithholdTrans.SourceDocumentLine)
        {
            select count(RecId) from accountingDistribution
                where accountingDistribution.SourceDocumentLine == _taxWithholdTrans.SourceDocumentLine
                    && accountingDistribution.AccountingEvent != 0
                    && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing;

            int64 lineCount = accountingDistribution.RecId;
            int64 currentLine = 0;
            TaxAmountCur totalTaxAmountCur = 0;
            AllocationFactor effectiveAllocationFactor;

            while select accountingDistribution
                where accountingDistribution.SourceDocumentLine == _taxWithholdTrans.SourceDocumentLine
                    && accountingDistribution.AccountingEvent != 0
                    && accountingDistribution.ReferenceRole != AccountingDistributionReferenceRole::Reversing
            {
                currentLine++;

                if (currentLine < lineCount)
                {
                    effectiveAllocationFactor = (_taxWithholdTrans.AdjustedTaxWithholdAmount != 0) ? accountingDistribution.TransactionCurrencyAmount / _taxWithholdTrans.AdjustedTaxWithholdAmount : 0;

                    taxAmountCur = _taxWithholdTrans.TaxTaxWithholdAmount * effectiveAllocationFactor;
                }
                else
                {
                    taxAmountCur = _taxWithholdTrans.TaxTaxWithholdAmount - totalTaxAmountCur;
                }

                taxAmountCur = CurrencyExchangeHelper::amount(taxAmountCur, currencyCode);
                totalTaxAmountCur += taxAmountCur;

                this.post(
                    accountingDistribution.LedgerDimension,
                    dimensionLoc,
                    currencyCode,
                    taxAmountCur * -1);
            }
        }
		else
        {
            taxAmountCur = CurrencyExchangeHelper::amount(_taxWithholdTrans.TaxTaxWithholdAmount, currencyCode);

            offsetTaxLedgerDimension = TaxWHTTransGeneralJournalAccountEntry_IN::getLedgerDimensionForTaxWithholdTrans(_taxWithholdTrans.RecId, TaxTransRelationshipType::Tax);
            
            this.post(
                offsetTaxLedgerDimension ? offsetTaxLedgerDimension : _taxWithholdTrans.LedgerDimension,
                dimensionLoc,
                currencyCode,
                taxAmountCur * -1);
		}

        taxTransOffsetTrans.clear();
        taxTransOffsetTrans.Voucher                     = voucher;
        taxTransOffsetTrans.TransDate                   = transactionDate;
        taxTransOffsetTrans.Source                      = TaxModuleType::TaxWithhold_IN;
        taxTransOffsetTrans.TaxWithholdValue            = _taxWithholdTrans.TaxWithholdValue;
        taxTransOffsetTrans.TaxWithholdCode             = _taxWithholdTrans.TaxWithholdCode;
        taxTransOffsetTrans.CurrencyCode                = _taxWithholdTrans.CurrencyCode;
        taxTransOffsetTrans.TaxWithholdBaseAmountCur    = _taxWithholdTrans.TaxWithholdBaseAmountCur * -1;
        taxTransOffsetTrans.TaxWithholdAmountCur        = _taxWithholdTrans.TaxWithholdAmountCur * -1;
        taxTransOffsetTrans.AdjustedBaseAmount          = _taxWithholdTrans.AdjustedBaseAmount * -1;
        taxTransOffsetTrans.AdjustedTaxWithholdAmount   = _taxWithholdTrans.AdjustedTaxWithholdAmount * -1;

        taxTransOffsetTrans.TaxWithholdGroup            = _taxWithholdTrans.TaxWithholdGroup;
        taxTransOffsetTrans.LedgerDimension             = _taxWithholdTrans.LedgerDimension;

        taxTransOffsetTrans.WithholdBaseAmount          = _taxWithholdTrans.WithholdBaseAmount * -1;
        taxTransOffsetTrans.TaxWithholdAmount           = _taxWithholdTrans.TaxWithholdAmount * -1;

        taxTransOffsetTrans.TaxWithholdCurrency         = _taxWithholdTrans.TaxWithholdCurrency;
        taxTransOffsetTrans.TaxWithholdAmountOrigin     = _taxWithholdTrans.TaxWithholdAmountOrigin * -1;
        taxTransOffsetTrans.TaxTaxWithholdAmount        = _taxWithholdTrans.TaxTaxWithholdAmount * -1;

        taxTransOffsetTrans.TaxWithholdSettlementPeriod = settlementPeriod;
        taxTransOffsetTrans.RateOfDeduction             = _taxWithholdTrans.RateOfDeduction;
        taxTransOffsetTrans.Settled                     = true;
        taxTransOffsetTrans.NatureOfAssessee            = _taxWithholdTrans.NatureOfAssessee;
        taxTransOffsetTrans.SettledVoucher              = _taxWithholdTrans.Voucher;
        taxTransOffsetTrans.TaxWithholdRegNumber        = _taxWithholdTrans.TaxWithholdRegNumber;
        taxTransOffsetTrans.TaxType                     = _taxWithholdTrans.TaxType;
        taxTransOffsetTrans.insertTaxReporting(fromDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxReportDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// To find the tax report date.
    /// </summary>
    /// <param name="_period">
    /// Record id of <c> TaxWithholdPeriod_IN </c>
    /// </param>
    /// <param name="_taxType">
    /// Tax wotholding type is used to find the record.
    /// </param>
    /// <param name="_date">
    /// Date is used to initialize the tax date.
    /// </param>
    /// <param name="_accountNum">
    /// Account number is used to find the record.
    /// </param>
    /// <returns>
    /// Returns tax report date.
    /// </returns>

    public TransDate taxReportDate(TaxWithholdPeriodRecId_IN _period,
                                   TaxWithholdType_IN        _taxType,
                                   TransDate                 _date,
                                   AccountNum                _accountNum)
    {
        TransDate   taxDate;
        PaymTermId  paymTermId;

        taxDate     = _date;
        paymTermId  = VendTable::find(_accountNum).PaymTermId;

        if (!taxDate)
        {
            taxDate  = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }
        else if (paymTermId)
        {
            taxDate     = PaymTerm::advanceDate(paymTermId, taxDate);
        }
        return taxDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxReportVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c> TaxWithholdReportVoucher_IN </c> table.
    /// </summary>
    /// <returns>
    /// Buffer of <c> TaxWithholdReportVoucher_IN </c> table.
    /// </returns>
    public TaxWithholdReportVoucher_IN taxReportVoucher()
    {
        TaxWithholdReportVoucher_IN    taxReportVoucher;

        taxReportVoucher.TaxWithholdSettlementPeriod = settlementPeriod;
        taxReportVoucher.TransDate                   = transactionDate;
        taxReportVoucher.Voucher                     = voucher;
        taxReportVoucher.TaxType                     = taxType;
        taxReportVoucher.TaxWithholdRegNumber              = tanNumber;
        taxReportVoucher.FromDate                    = fromDate;
        taxReportVoucher.ToDate                      = toDate;
        taxReportVoucher.PaymentVersion              = paymentVersion;
        taxReportVoucher.TaxRepCounter               = TaxWithholdSettledPeriods_IN::findByTaxPeriod(settlementPeriod, taxType, fromDate, tanNumber).VersionNum;
        return taxReportVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);

        switch (version)
        {
            case #CurrentVersion :
                [version, #CurrentList] = _packedClass;
                break;

            default :
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and post <c> TaxWithholdTrans_IN</c> table.
    /// </summary>
    /// <param name="_componentGroupLoc">
    /// Record id of <c> TaxWithholdComponentGroup_IN </c>
    /// </param>
    /// <param name="_checkCompany">
    /// Boolean to check the company.
    /// </param>
    /// <returns>
    /// Returns the counter value.
    /// </returns>
    public Counter updateAndPost(
        TaxWithholdComponentGroupRecId_IN _componentGroupLoc,
        boolean                           _checkCompany)
    {
        return this.updateAndPostTaxtrans(fromDate, toDate, _componentGroupLoc, _checkCompany);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAndPostTaxtrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates and post <c> TaxWithholdTrans_IN</c> table.
    /// </summary>
    /// <param name="_fromDate">
    /// From date is used to find the record.
    /// </param>
    /// <param name="_toDate">
    /// To date is used to find the record.
    /// </param>
    /// <param name="_componentGroupLoc">
    /// Record id of <c> TaxWithholdComponentGroup_IN </c> is used to find the record.
    /// </param>
    /// <param name="_checkCompany">
    ///  Boolean to check the company.
    /// </param>
    /// <returns>
    ///  Returns the counter value.
    /// </returns>
    public Counter updateAndPostTaxtrans(FromDate                           _fromDate,
                                         ToDate                             _toDate,
                                         TaxWithholdComponentGroupRecId_IN  _componentGroupLoc,
                                         boolean                            _checkCompany)
    {
        TaxWithholdTrans_IN         taxWithholdTrans, taxWithholdTransLoc;
        Counter                     transactionsInTax;
        TaxWithholdSettleTrans_IN   taxWithholdSettleTrans;

        if (_checkCompany)
        {
            while select sum(TaxWithholdBaseAmountCur),
                          sum(TaxWithholdAmountCur),
                          sum(WithholdBaseAmount),
                          sum(TaxWithholdAmount),
                          sum(AdjustedBaseAmount),
                          sum(AdjustedTaxWithholdAmount),
                          sum(TaxWithholdAmountOrigin),
                          sum(TaxTaxWithholdAmount),
                          TaxWithholdRegNumber,
                          TaxType
                       from taxWithholdTrans
                       group by TaxWithholdComponentGroup, TaxWithholdSettlementPeriod, LedgerDimension, NatureOfAssessee, CurrencyCode, TaxWithholdCurrency,
                                TaxWithholdCode, TaxWithholdValue, TaxWithholdGroup, RateOfDeduction, Voucher, TaxWithholdComponent, TaxWithholdRegNumber, TaxType
                       where taxWithholdTrans.TaxWithholdSettlementPeriod == settlementPeriod
                            && taxWithholdTrans.TransDate                  >= _fromDate
                            && taxWithholdTrans.TransDate                  <= _toDate
                            && taxWithholdTrans.TaxWithholdComponentGroup  == _componentGroupLoc
                            && taxWithholdTrans.TaxWithholdRegNumber       == tanNumber
                            && taxWithholdTrans.RecoverableAccount         == false
                            && taxWithholdTrans.NatureOfAssessee           == NatureOfAssessee_IN::Company
                            && taxWithholdTrans.TaxRepCounter              >= versionMin
                            && taxWithholdTrans.TaxRepCounter              <= versionMax
                            && taxWithholdTrans.Settled                    == false
                            && taxWithholdTrans.Source                     != TaxModuleType::TaxWithhold_IN
                            && taxWithholdTrans.IsTaxInterim != NoYes::Yes

            {
                if (taxWithholdTrans.TaxWithholdBaseAmountCur
                    || taxWithholdTrans.TaxWithholdAmountCur
                    || taxWithholdTrans.WithholdBaseAmount
                    || taxWithholdTrans.TaxWithholdAmount
                    || taxWithholdTrans.TaxTaxWithholdAmount)
                {
                    while select * from taxWithholdTransLoc
                    where taxWithholdTransLoc.TaxWithholdSettlementPeriod == settlementPeriod
                        && taxWithholdTransLoc.TransDate                  >= _fromDate
                        && taxWithholdTransLoc.TransDate                  <= _toDate
                        && taxWithholdTransLoc.TaxWithholdComponentGroup  == _componentGroupLoc
                        && taxWithholdTransLoc.TaxWithholdRegNumber       == tanNumber
                        && taxWithholdTransLoc.RecoverableAccount         == false
                        && taxWithholdTransLoc.NatureOfAssessee           == NatureOfAssessee_IN::Company
                        && taxWithholdTransLoc.TaxRepCounter              >= versionMin
                        && taxWithholdTransLoc.TaxRepCounter              <= versionMax
                        && taxWithholdTransLoc.Settled                    == false
                        && taxWithholdTransLoc.Source                     != TaxModuleType::TaxWithhold_IN
                        && taxWithholdTransLoc.TaxWithholdCode            == taxWithholdTrans.TaxWithholdCode
                        && taxWithholdTransLoc.TaxWithholdComponent       == taxWithholdTrans.TaxWithholdComponent
                        && taxWithholdTransLoc.CurrencyCode               == taxWithholdTrans.CurrencyCode
                        && taxWithholdTransLoc.TaxWithholdCurrency        == taxWithholdTrans.TaxWithholdCurrency
                        && taxWithholdTransLoc.TaxWithholdValue           == taxWithholdTrans.TaxWithholdValue
                        && taxWithholdTransLoc.TaxWithholdGroup           == taxWithholdTrans.TaxWithholdGroup
                        && taxWithholdTransLoc.RateOfDeduction            == taxWithholdTrans.RateOfDeduction
                        && taxWithholdTransLoc.Voucher                    == taxWithholdTrans.Voucher
                        && taxWithholdTransLoc.TaxType                    == taxWithholdTrans.TaxType
                        && taxWithholdTransLoc.IsTaxInterim != NoYes::Yes
                    {
                        this.saveAndPost(taxWithholdTransLoc);
                        transactionsInTax++;
                    }
                }
                if (!TaxWithholdSettleTrans_IN::findByVoucher(voucher, taxWithholdTrans.Voucher))
                {
                    taxWithholdSettleTrans.initFromTaxWithholdTrans(taxWithholdTrans, voucher, settlementPeriod, taxType, tanNumber);
                }
            }
        }
        else
        {
            while select sum(TaxWithholdBaseAmountCur),
                          sum(TaxWithholdAmountCur),
                          sum(WithholdBaseAmount),
                          sum(TaxWithholdAmount),
                          sum(AdjustedBaseAmount),
                          sum(AdjustedTaxWithholdAmount),
                          sum(TaxWithholdAmountOrigin),
                          sum(TaxTaxWithholdAmount),
                          TaxWithholdRegNumber,
                          TaxType
                       from taxWithholdTrans
                       group by TaxWithholdComponentGroup, TaxWithholdSettlementPeriod, CurrencyCode, LedgerDimension, TaxWithholdCurrency, TaxWithholdComponent,
                                TaxWithholdCode, TaxWithholdValue, TaxWithholdGroup, RateOfDeduction, Voucher, NatureOfAssessee, TaxWithholdRegNumber, TaxType
                       where taxWithholdTrans.TaxWithholdSettlementPeriod == settlementPeriod
                            && taxWithholdTrans.TransDate                  >= _fromDate
                            && taxWithholdTrans.TransDate                  <= _toDate
                            && taxWithholdTrans.TaxWithholdComponentGroup  == _componentGroupLoc
                            && taxWithholdTrans.TaxWithholdRegNumber       == tanNumber
                            && taxWithholdTrans.RecoverableAccount         == false
                            && taxWithholdTrans.NatureOfAssessee           != NatureOfAssessee_IN::Company
                            && taxWithholdTrans.TaxRepCounter              >= versionMin
                            && taxWithholdTrans.TaxRepCounter              <= versionMax
                            && taxWithholdTrans.Settled                    == false
                            && taxWithholdTrans.Source                     != TaxModuleType::TaxWithhold_IN
                            && taxWithholdTrans.IsTaxInterim != NoYes::Yes
            {
                if (taxWithholdTrans.TaxWithholdBaseAmountCur
                    || taxWithholdTrans.TaxWithholdAmountCur
                    || taxWithholdTrans.WithholdBaseAmount
                    || taxWithholdTrans.TaxWithholdAmount
                    || taxWithholdTrans.TaxTaxWithholdAmount)
                {
                    while select * from taxWithholdTransLoc
                    where taxWithholdTransLoc.TaxWithholdSettlementPeriod == settlementPeriod
                        && taxWithholdTransLoc.TransDate                  >= _fromDate
                        && taxWithholdTransLoc.TransDate                  <= _toDate
                        && taxWithholdTransLoc.TaxWithholdComponentGroup  == _componentGroupLoc
                        && taxWithholdTransLoc.TaxWithholdRegNumber       == tanNumber
                        && taxWithholdTransLoc.RecoverableAccount         == false
                        && taxWithholdTransLoc.NatureOfAssessee           != NatureOfAssessee_IN::Company
                        && taxWithholdTransLoc.TaxRepCounter              >= versionMin
                        && taxWithholdTransLoc.TaxRepCounter              <= versionMax
                        && taxWithholdTransLoc.Settled                    == false
                        && taxWithholdTransLoc.Source                     != TaxModuleType::TaxWithhold_IN
                        && taxWithholdTransLoc.TaxWithholdCode            == taxWithholdTrans.TaxWithholdCode
                        && taxWithholdTransLoc.TaxWithholdComponent       == taxWithholdTrans.TaxWithholdComponent
                        && taxWithholdTransLoc.CurrencyCode               == taxWithholdTrans.CurrencyCode
                        && taxWithholdTransLoc.TaxWithholdCurrency        == taxWithholdTrans.TaxWithholdCurrency
                        && taxWithholdTransLoc.TaxWithholdValue           == taxWithholdTrans.TaxWithholdValue
                        && taxWithholdTransLoc.TaxWithholdGroup           == taxWithholdTrans.TaxWithholdGroup
                        && taxWithholdTransLoc.RateOfDeduction            == taxWithholdTrans.RateOfDeduction
                        && taxWithholdTransLoc.Voucher                    == taxWithholdTrans.Voucher
                        && taxWithholdTransLoc.TaxType                    == taxWithholdTrans.TaxType
                        && taxWithholdTransLoc.IsTaxInterim != NoYes::Yes
                    {
                        this.saveAndPost(taxWithholdTransLoc);
                        transactionsInTax++;
                    }
                }
                if (!TaxWithholdSettleTrans_IN::findByVoucher(voucher, taxWithholdTrans.Voucher))
                {
                    taxWithholdSettleTrans.initFromTaxWithholdTrans(taxWithholdTrans, voucher, settlementPeriod, taxType, tanNumber);
                }
            }
        }
        return transactionsInTax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEmptyChallanInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the challan info to the trans which are totally reversed.
    /// </summary>
    /// <param name="_fromDate">
    /// From date.
    /// </param>
    /// <param name="_toDate">
    /// To date.
    /// </param>
    /// <param name="_componentGroupLoc">
    /// Tax withhold component group.
    /// </param>
    /// <param name="_voucher">
    /// Voucher.
    /// </param>
    /// <param name="_tanNumber">
    /// Tax account number.
    /// </param>
    public void updateEmptyChallanInfo(
        FromDate                           _fromDate,
        ToDate                             _toDate,
        TaxWithholdComponentGroupRecId_IN  _componentGroupLoc,
        Voucher                            _voucher,
        TaxInformationRecId_IN             _tanNumber)
    {
        TaxWithholdSettleTrans_IN   taxWithholdSettleTrans;
        TaxWithholdTrans_IN         taxWithholdTrans;

        #define.EmptyChallanNumber('Empty')
        #define.EmptyBSRCode('Empty')

        while select taxWithholdSettleTrans
            group by OrigVoucher, TaxWithholdComponentGroup, NatureOfAssessee
            where   taxWithholdSettleTrans.TaxWithholdComponentGroup   == _componentGroupLoc
                &&  taxWithholdSettleTrans.Voucher                     == _voucher
                &&  taxWithholdSettleTrans.TransDate                   >= _fromDate
                &&  taxWithholdSettleTrans.TransDate                   <= _toDate
                &&  taxWithholdSettleTrans.TaxWithholdRegNumber        == _tanNumber
        {
            update_recordSet taxWithholdTrans
                setting ChallanNumber   = #EmptyChallanNumber,
                        BSRCode         = #EmptyBSRCode
                where   taxWithholdTrans.Voucher                    == taxWithholdSettleTrans.OrigVoucher
                    &&  taxWithholdTrans.NatureOfAssessee           == taxWithholdSettleTrans.NatureOfAssessee
                    &&  taxWithholdTrans.TaxWithholdComponentGroup  == _componentGroupLoc
                    &&  taxWithholdTrans.TaxWithholdRegNumber       == _tanNumber
                    &&  taxWithholdTrans.ChallanNumber              == ''
                    &&  taxWithholdTrans.BSRCode                    == '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates ans post ledger voucher to run settlement process.
    /// </summary>
    /// <param name="_componentGroupLoc">
    /// Record id of <c> TaxWithholdComponentGroup_IN </c> is used to find the record.
    /// </param>
    /// <param name="_checkCompany">
    ///  Boolean to check the company.
    /// </param>
    /// <param name="_calculate">
    /// Boolean to check the calculation.
    /// </param>
    public void updateNow(TaxWithholdComponentGroupRecId_IN _componentGroupLoc = 0,
                          boolean                           _checkCompany = false,
                          boolean                           _calculate = false)
    {
        TaxWithholdReportVoucher_IN     taxReportVoucher;
        DueDate                         dueDate;
        VendTrans                       vendTrans;
        VendTable                       vendTable;
        TaxAmount                       taxAmount;
        TransactionTxt                  transactionTxt;

        vendAccount     = TaxWithholdAuthorities_IN::find(TaxWithholdHead_IN::find(settlementPeriod).TaxWithholdAuthorities).VendAccount;

        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType(LedgerTransTxt::TaxReporting);
        transactionTxt.setVoucher(voucher);

        transactionTxt.setKey1(TaxWithholdHead_IN::find(settlementPeriod).Period);

        ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                     SysModule::Tax,
                                                     numberSeq.parmVoucherSequenceCode());

        ledgerVoucher.parmCheckBlockedDimensions(false);

        ledgerVoucher.addVoucher(
            LedgerVoucherObject::newVoucher(voucher,
                                            transactionDate,
                                            SysModule::Tax,
                                            LedgerTransType::Tax));

        ledgerVoucher.findLedgerVoucherObject().lastTransTxt(transactionTxt.txt());
        taxPurchaseTaxPost = new TaxPurchaseTaxPost(ledgerVoucher, toDate);
        taxTransactions += this.updateAndPost(_componentGroupLoc, _checkCompany);
        taxPurchaseTaxPost.postPurchaseTax();
        if (vendAccount)
        {
            vendTable = VendTable::find(vendAccount);
        }
        if (taxTransactions || transactions)
        {
            dueDate   = this.taxReportDate(settlementPeriod, taxType, toDate, vendTable.AccountNum);
            taxAmount = totalClearingAmount;

            if (taxAmount == 0)
            {
                this.updateEmptyChallanInfo(fromDate, toDate, _componentGroupLoc, voucher, tanNumber);
            }

            vendVoucher = CustVendVoucher::construct(SysModule::Vend,
                                                     vendTable.AccountNum,
                                                     taxAmount,
                                                     vendTable.Currency,
                                                     LedgerTransTxt::TaxReporting,
                                                     vendTable.DefaultDimension,
                                                     VendParameters::find().PostingProfile,
                                                     LedgerPostingType::VendBalance,
                                                     vendTable.PaymTermId,
                                                     SettlementType::None,
                                                     HcmWorker::userId2Worker(curUserId()),
                                                     NoYes::Yes,
                                                     '',
                                                     dateNull(),
                                                     0,
                                                     dueDate);

            vendVoucher.parmTransTxt("@Tax_WithholdTax:WithholdTaxPayment");
            vendVoucher.parmPaymMode(vendTable.PaymMode);
            vendVoucher.parmPaymSpec(vendTable.PaymSpec);
            vendVoucher.parmTaxWitholdSettled_IN(true);
            vendVoucher.parmTaxWithholdTAN_IN(tanNumber);

            vendVoucher.parmExchRate(
                          ExchangeRateHelper::exchRate(vendTable.Currency, transactionDate));

            vendVoucher.parmExchRateSecondary(
                           ExchangeRateHelper::exchRateSecond(vendTable.Currency, transactionDate));

            vendVoucher.post(ledgerVoucher,
                             vendTrans,
                             NoYes::No,
                             UnknownNoYes::Unknown);
        }
        taxReportVoucher = this.taxReportVoucher();
        taxReportVoucher.insert();
        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the parameters are valid.
    /// </summary>
    /// <param name="calledFrom">
    /// The caller of this class.
    /// </param>
    /// <returns>
    /// Returns ture if all validation are passed.
    /// </returns>
    public boolean validate(Object calledFrom = null)
    {
        TransDate                           fromDateLoc;
        TransDate                           toDateLoc;
        Container                           DateCon;
        TaxWithholdStatement_IN             taxWithholdStatement;
        TaxWithholdStatement_IN             taxWithholdStatementLoc;

        boolean ret = super(calledFrom);

        if (ret)
        {
            if (!taxWithholdTANNumber)
            {
                 ret = ret && checkFailed(strFmt("@SYS26332", "@GLS5353"));
            }
            if (!taxWithholdPeriod)
            {
                 ret = ret && checkFailed(strFmt("@SYS26332", "@SYS60050"));
            }
            if (!fromDate)
            {
                ret = ret && checkFailed(strFmt("@SYS24993", settlementPeriod, taxType));
            }
            if (!transactionDate)
            {
                 ret = ret && checkFailed(strFmt("@SYS26332", "@SYS67"));
            }
            if (taxWithholdTANNumber)
            {
                if (!TaxWithholdRegNumbers_IN::exist(taxWithholdTANNumber, TaxRegistrationType_IN::Company))
                {
                    ret = ret && checkFailed(strFmt("@GLS5447", taxWithholdTANNumber, TaxRegistrationType_IN::Company));
                }
            }

            if (taxWithholdPeriod)
            {
                if (!TaxWithholdHead_IN::findByTaxPeriodHead(taxWithholdPeriod, taxType))
                {
                    ret = ret && checkFailed(strFmt("@GLS5445", taxWithholdPeriod, taxType));
                }
            }

            if (ret == true)
            {
                DateCon     = TaxWithholdStatementReportHelper::getFromToDateAndPeriodEnd(fromDate);
                fromDateLoc = conPeek(DateCon,2);
                toDateLoc   = conPeek(DateCon,3);

                if (taxType == TaxWithholdType_IN::TDS)
                {
                    taxWithholdStatement    = TaxWithholdStatement_IN::Form26Q;
                    taxWithholdStatementLoc = TaxWithholdStatement_IN::Form27Q;

                }
                else
                {
                    taxWithholdStatement = TaxWithholdStatement_IN::Form27EQ;
                }

                if (TaxWithholdProvisionalReceipt_IN::isStatementGeneratedForPeriod(taxWithholdTANNumber,
                                                                taxWithholdStatement,
                                                                taxWithholdStatementLoc,
                                                                fromDateLoc,
                                                                toDateLoc))
                {
                    ret = checkFailed("@TaxLocalization:ResettlementAndAuthorityPaymentIsNotAvailable");
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>counterMax</Name>
				<Source><![CDATA[
    /// <summary>
    /// to find the  maximum counter value .
    /// </summary>
    /// <param name="_paymentVersion">
    /// Payment version is used to find the record.
    /// </param>
    /// <param name="_period">
    /// Period is used to find the record.
    /// </param>
    /// <param name="_fromDate">
    /// From date is used to find the record.
    /// </param>
    /// <param name="_taxType">
    /// Tax type is used to find the record.
    /// </param>
    /// <param name="_tanNumber">
    ///  Tan number is used to find the record.
    /// </param>
    /// <returns>
    /// Maximum counter value.
    /// </returns>
    public static Counter counterMax(TaxWithholdPaymentVersion_IN   _paymentVersion,
                                            TaxWithholdPeriodRecId_IN      _period,
                                            TransDate                      _fromDate,
                                            TaxWithholdType_IN             _taxType,
                                            TaxInformationRecId_IN         _tanNumber)
    {
        if  (_paymentVersion == TaxWithholdPaymentVersion_IN::Original)
            return 0;
        else
            return TaxWithholdSettledPeriods_IN::findByTaxPeriod(_period, _taxType, _fromDate, _tanNumber).VersionNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>counterMin</Name>
				<Source><![CDATA[
    /// <summary>
    /// to find the minimum counter value .
    /// </summary>
    /// <param name="_paymentVersion">
    /// Payment version is used to find the record.
    /// </param>
    /// <param name="_period">
    /// Period is used to find the record.
    /// </param>
    /// <param name="_fromDate">
    /// From date is used to find the record.
    /// </param>
    /// <param name="_taxType">
    /// Tax type is used to find the record.
    /// </param>
    /// <param name="_tanNumber">
    ///  Tan number is used to find the record.
    /// </param>
    /// <returns>
    /// minimum counter value.
    /// </returns>
    public static Counter counterMin(TaxWithholdPaymentVersion_IN   _paymentVersion,
                                            TaxWithholdPeriodRecId_IN      _period,
                                            TransDate                      _fromDate,
                                            TaxWithholdType_IN             _taxType,
                                            TaxInformationRecId_IN         _tanNumber)
    {
        Integer counter;

        switch (_paymentVersion)
        {
            case TaxWithholdPaymentVersion_IN::Original :
                counter= 0;
                break;

            case TaxWithholdPaymentVersion_IN::LatestCorrections :
                counter = TaxWithholdSettledPeriods_IN::findByTaxPeriod(_period, _taxType, _fromDate, _tanNumber).VersionNum;
                break;

            default :
                break;
        }
        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void  main(Args  _args)
    {
        TaxWithholdReport_IN            taxWithholdReport;
        #Operator_IN

        taxWithholdReport = new TaxWithholdReport_IN();

        if (taxWithholdReport.prompt())
        {
            taxWithholdReport.runOperation();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// To find the in terms of name whether it is correction or original settlement.
    /// </summary>
    /// <param name="_paymentVersion">
    /// Payment version is used to find the record.
    /// </param>
    /// <param name="_settlementPeriod">
    /// Settlement is used to find the record.
    /// </param>
    /// <param name="_fromDate">
    /// From date is used to find the record.
    /// </param>
    /// <param name="_taxType">
    /// Tax type is used to find the record.
    /// </param>
    /// <param name="_tanNumber">
    /// TAN number is used to find the record.
    /// </param>
    /// <param name="_reported">
    /// boolean to check earlier reported or not.
    /// </param>
    /// <returns>
    /// Return latest corection value in case of correction otherwise 0.
    /// </returns>
    public static Name taxVersion(TaxWithholdPaymentVersion_IN  _paymentVersion,
                                         TaxWithholdPeriodRecId_IN     _settlementPeriod,
                                         TransDate                     _fromDate,
                                         TaxWithholdType_IN            _taxType,
                                         TaxInformationRecId_IN        _tanNumber,
                                         NoYes                         _reported = NoYes::No)
    {
        Name    name;
        Counter latestVersion;

        switch (_paymentVersion)
        {
            case TaxWithholdPaymentVersion_IN::Original :
                name = strFmt('%1', 0);
                break;

            case TaxWithholdPaymentVersion_IN::LatestCorrections  :
                latestVersion = TaxWithholdSettledPeriods_IN::findByTaxPeriod(_settlementPeriod, _taxType, _fromDate, _tanNumber).VersionNum;
                if (_reported)
                {
                    latestVersion -= 1;
                }
                name = strFmt('%1', latestVersion);
                break;

            default :
                break;
        }
        return name;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for execution the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// true if the batch task is retryable; otherwise, false.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        // return false as cannot run in batch
        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>