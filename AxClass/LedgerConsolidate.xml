<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerConsolidate</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>LedgerConsolidate</c> class performs consolidations of ledger amounts.
/// </summary>
public class LedgerConsolidate extends RunBaseBatch implements BatchRetryable
{
    const int ParallelProcessingDefaultBundleSize = 8;
    const int CurrentVersion = 6;

    const int Version14 = 14;
    const int Version1 = 1; // after 14
    const int Version2 = 2;
    const int Version3 = 3;
    const int Version4 = 4;
    const int Version5 = 5;
    const int emptyBatchRecId = 0;

    #LOCALMACRO.ListVersion14
        Mode,
        FromAccount,
        ToAccount,
        FromDate,
        ToDate,
        budgetExchangeRateType,
        FromModel,
        ToModel,
        TransferCurrent,
        TransferBudget,
        CompanyGroupAccounts,
        consolidateAccountGroup,
        Companies,
        description,
        eliminations,
        processMode,
        glPostingDate,
        releaseDate,
        reasonRefRecId,
        processFullBalanceRebuild,
        consolidatedCompany,
        dimAttrMainAccountId,
        errorAccount,
        isChildBatchFinalTask,
        isChildBatchRuntimeTask,
        packedCompanyDimensionMapping
        // <GBR>
        , transferTransactionsOnly_BR
        // </GBR>
    #ENDMACRO

    #LOCALMACRO.ListVersion1
        #ListVersion14
        ,exportedFileURLs
    #ENDMACRO

    #LOCALMACRO.ListVersion2
        #ListVersion1
        ,consolidationAmountSource
    #ENDMACRO

    #LOCALMACRO.ListVersion3
        #ListVersion2
        , ledgerConsolidateHistRecId
    #ENDMACRO

    #LOCALMACRO.ListVersion4
        #ListVersion3
        , fullConsolidationToDate
    #ENDMACRO

    #LOCALMACRO.ListVersion5
        #ListVersion4
        , fullConsolidationFromDate
    #ENDMACRO

    #LOCALMACRO.CurrentList
        #ListVersion5
        , consolidateAccountingCurrency
    #ENDMACRO

    boolean             isChildBatchFinalTask;
    boolean             isChildBatchRuntimeTask;

    LedgerConsMode      mode;

    MainAccountNum      fromAccount;
    MainAccountNum      toAccount;

    TransDate           fromDate;
    TransDate           toDate;

    recId               budgetExchangeRateType;
    BudgetModelId       fromModel;
    BudgetModelId       toModel;

    Description         description;

    NoYes               transferCurrent;
    NoYes               transferBudget;
    NoYes               companyGroupAccounts;
    // <GBR>
    NoYes               transferTransactionsOnly_BR;
    // </GBR>
    NoYes               processFullBalanceRebuild;
    LedgerConsolidateAccountGroupRecId  consolidateAccountGroup;

    container           eliminations;
    container           eliminationReasonRefRecId;
    int                 numberOfEliminationRules;
    int                 numberOfEliminationJournals;

    LedgerEliminationProcessMode    processMode;
    TransDate                       glPostingDate;
    LedgerEliminationRule           ledgerEliminationRule;
    LedgerEliminationProcessRule    ledgerEliminationProcessRule;
    LedgerEliminationRuleId         eliminationRule;
    container                       ledgerEliminationJournals;

    container           companies;
    MainAccountNum      errorAccount;

    // Local RecIds: used for FK's because the table are packed/unpacked which results in the normal RecId's being lost
    recId               consTransLocalRecId;
    recId               consDimAttrLocalRecId;

    // Variables used for creating ledgerDimensions in the consolidated company
    LedgerDimensionBuilder  ledgerDimensionBuilder;
    recId                   dimAttrMainAccountId;
    Map                     tagCategoryLookupTable;             // Key: DimensionAttribute.RecId<Destination>   Value: FinancialTagCategory.RecId
    Map                     sourceToConsDimAttrTranslation;
    recId                   dimensionAttributeSetId;            // Dimensions in the source dimensions map with a non-None specification

    // Variables needed by tmpLedgerConsTransWrite and ledgerExchAdj
    Map                 sourceDimAttrIdLookupTable;         // Key: DimensionAttribute.RecId<Source>    Value: TmpLedgerConsDimensionAttribute.RecId
    Map                 companyDimensionMapping;
    container           packedCompanyDimensionMapping;
    MapEnumerator       companyDimensionEnumerator;
    Map                 acctNumDimAttrValueIdLookup;        // Key: AccountNumber<Source>               Value: DimensionAttributeValueId<pseudo>
    Map                 groupDimensionDimAttrValueIdLookup; // Key: GroupDimension<Source>              Value: DimensionAttributeValueId<pseudo>
    HashKey             companyDimAttrValueHashKey;         // Pseduo hash key for DimensionAttributeValue record representing the "company" as the display value.
    // additional variables specific to fillConsolidatedDimensionValues and getConsolidatedDimensionValues
    int64               consolidatedDimAttrIdArray[];
    int64               consolidatedDimAttrValueIdArray[];
    HashKey             consolidatedDimAttrValueHashKeyArray[];
    str                 consolidatedDisplayValueArray[];

    boolean             mayBeExecuted;

    CompanyId           companyOrigin;

    PostReleaseDate     releaseDate;
    ReasonRefRecID      reasonRefRecID;

    Counter             countTransact;
    Counter             countOutput;
    CompanyId                   companyId;

    BudgetConsolidationManager  budgetConsolidationManager;
    CompanyId                   consolidatedCompany;

    LedgerConsolidateHist       ledgerConsolidateHist;

    container           exportedFileURLs;

    RefRecId templateId;

    private LedgerConsolidateAmountSource consolidationAmountSource;
    private LedgerConsolidateAccountingCurrency consolidateAccountingCurrency;
    private RecId ledgerConsolidateHistRecId;
    private TransDate fullConsolidationToDate;
    private TransDate fullConsolidationFromDate;
    private boolean useDualCurrency;
    private boolean useParallelProcessingFeature; // not packed

    private SysInstrumentationLogger logger;
    private LedgerConsolidatePerformanceMonitor monitor;
    private boolean deletePerformanceEnhancement = LedgerConsolidateDeletePerformanceEnhancementFlight::instance().isEnabled();
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>amountMSTSecondary</Name>
				<Source><![CDATA[
    AmountMSTSecondary amountMSTSecondary(
        AmountCur          _amountCur,
        CurrencyCode       _currencyCode,
        TransDate          _date,
        ExchRate           _exchRate            = 0,
        ExchRate           _exchRateSecondary   = 0,
        NoYes              _triangulation       = NoYes::Yes
        )
    {
        CurrencyExchangeHelper exchHelper;

        if (Ledger::reportingCurrency(CompanyInfo::current()))
        {
            exchHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _date);
            exchHelper.parmExchangeRate1(_exchRate);
            exchHelper.parmExchangeRate2(_exchRateSecondary);
            return exchHelper.calculateTransactionCurrencyToReportingCurrency(_currencyCode, _amountCur);
        }
        else
        {
            return 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    /// true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A class that can be used in a batch journal is a class for which the same parameters can be used
    /// repeatedly. The dialog box can be shown and the parameters can be changed but parameters of some
    /// classes might build on data that is only valid for a short time. A class cannot always be run two
    /// times with the same parameters. If the <c>canGoBatch</c> method returns false, this method will not
    /// have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupDialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Provides a way to clean up after a dialog box has been canceled.
    /// </summary>
    void cleanupDialog()
    {
        mayBeExecuted = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companies</Name>
				<Source><![CDATA[
    container companies(container _companies = companies)
    {
        companies = _companies;
        return companies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>companyGroupAccounts</Name>
				<Source><![CDATA[
    NoYes companyGroupAccounts(NoYes _companyGroupAccounts = companyGroupAccounts)
    {
        companyGroupAccounts = _companyGroupAccounts;
        return companyGroupAccounts;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createErrorTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates an adjustment to the error account if the consolidated amount for a date does not balance.
    /// </summary>
    /// <param name="_ledgerConsolidateHist">
    /// The consolidation tracking buffer to update.
    /// </param>
    /// <param name="_balanceProfitLoss">
    /// The error account to retrieve.
    /// </param>
    /// <param name="_companyId">
    /// The company ID of the company in which the data originated.
    /// </param>
    /// <param name="_offsetAmounts">
    /// A list of containers that contain the posting layer, accounting currency amount, and the reporting
    /// currency amount.
    /// </param>
    /// <param name="_lastLocalSummaryTransactionId">
    /// The local record ID of the last temporary record that was processed.
    /// </param>
    /// <param name="_consolidationDimensionValueItem">
    /// The table that holds the dimension value detail records.
    /// </param>
    /// <param name="_generalJournalController">
    /// The general journal controller used to transfer the result of the consolidation.
    /// </param>
    /// <exception cref="M:Exception::Error">
    /// No account was defined.
    /// </exception>
    private void createErrorTransaction(
        LedgerConsolidateHist                   _ledgerConsolidateHist,
        BalanceProfitLoss                       _balanceProfitLoss,
        CompanyId                               _companyId,
        List                                    _offsetAmounts,
        recId                                   _lastLocalSummaryTransactionId,
        TmpLedgerConsDimensionValueItem         _consolidationDimensionValueItem,
        LedgerPostingGeneralJournalController   _generalJournalController)
    {
        GeneralJournalAccountEntry      generalJournalAccountEntry;
        DimensionAttributeValue         dimAttrValueMainAccount;
        MainAccount                     mainAccount;
        GeneralJournalEntry             generalJournalEntry;
        FiscalCalendarPeriod            fiscalCalendarPeriod;
        LedgerEntry                     ledgerEntry;
        boolean                         abortErrorAccount;
        MainAccountNum                  ledgerAccount;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        ListEnumerator                  amountListEnumerator;
        CurrentOperationsTax            postingLayer;
        moneyMST                        accountingCurrencyBalance;
        moneyMST                        reportingCurrencyBalance;
        TransDate                       transactionDate;
        FiscalPeriodType                transactionFiscalPeriodType;
        boolean							isErrorAccount = false;

        if (_balanceProfitLoss == BalanceProfitLoss::ProfitLoss)
        {
            defaultLedgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::ConsolidateDiffProfitLoss);
        }
        else
        {
            defaultLedgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::ConsolidateDiffBalance);
        }

        abortErrorAccount = LedgerParameters::find().AbortErrorAccount;

        if (!defaultLedgerDimension)
        {
            defaultLedgerDimension = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::ErrorAccount);
            isErrorAccount = true;

            if (!abortErrorAccount && !defaultLedgerDimension)
            {
                throw error("@SYS53511");
            }
        }

        amountListEnumerator = _offsetAmounts.getEnumerator();

        while (amountListEnumerator.moveNext())
        {
            [postingLayer, transactionFiscalPeriodType, transactionDate, accountingCurrencyBalance, reportingCurrencyBalance] = amountListEnumerator.current();
            if (abortErrorAccount && isErrorAccount)
            {
                if(LedgerVoucherDisplayCorrectDecimalsInErrorsFlight::instance().isEnabled())
                {
                    str imbalanceAmount;

                    if (reportingCurrencyBalance == 0)
                    {
                        imbalanceAmount = LedgerAmountDecimalValues::decimalAmount(accountingCurrencyBalance, Ledger::accountingCurrency());
                    }
                    else
                    {
                        imbalanceAmount = LedgerAmountDecimalValues::decimalAmount(reportingCurrencyBalance, Ledger::reportingCurrency());
                    }

                    error(strFmt(
                        "@SYS53510",
                        date2StrUsr(transactionDate, DateFlags::FormatAll),
                        transactionFiscalPeriodType,
                        imbalanceAmount));
                }
                else
                {
                    if (reportingCurrencyBalance == 0)
                    {
                        error(strFmt(
                            "@SYS53510",
                            date2StrUsr(transactionDate, DateFlags::FormatAll),
                            transactionFiscalPeriodType,
                            accountingCurrencyBalance));
                    }
                    else
                    {
                        error(strFmt(
                            "@SYS53510",
                            date2StrUsr(transactionDate, DateFlags::FormatAll),
                            transactionFiscalPeriodType,
                            reportingCurrencyBalance));
                    }
                }
            }
            else
            {
                // Create the ledger dimension
                ledgerAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(defaultLedgerDimension);
                mainAccount = MainAccount::findByMainAccountId(ledgerAccount);

                if (!abortErrorAccount && !defaultLedgerDimension)
                {
                    throw error(strFmt("@GLS222332", ledgerAccount));
                }

                dimAttrValueMainAccount = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(dimAttrMainAccountId, mainAccount.RecId, false, true);
                generalJournalAccountEntry.clear();
                generalJournalAccountEntry.LedgerDimension = this.getLedgerDimension(
                        _companyId,
                        ledgerAccount,
                        dimAttrValueMainAccount.RecId,
                        dimAttrValueMainAccount.HashKey,
                        _lastLocalSummaryTransactionId,
                        _consolidationDimensionValueItem);

                // Always use the accounting currency of the consolidation company for these reasons
                // 1. consolidationAmountSource is N/A because it is related to the source company
                // 2. there can be multiple source companies
                // 3. the transaction currency doesn't matter because the transaction currency amount is zero
                generalJournalAccountEntry.TransactionCurrencyCode = Ledger::accountingCurrency();
                // transaction currency amount is zero because this entry is to balance the accounting and reporting currency amounts
                generalJournalAccountEntry.AccountingCurrencyAmount = -accountingCurrencyBalance;
                generalJournalAccountEntry.ReportingCurrencyAmount = -reportingCurrencyBalance;
                generalJournalAccountEntry.LedgerDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(generalJournalAccountEntry.LedgerDimension);

                generalJournalEntry.clear();
                generalJournalEntry.AccountingDate = transactionDate;
                fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(CompanyInfo::current()), transactionDate, transactionFiscalPeriodType);
                Debug::assert(fiscalCalendarPeriod != null);
                generalJournalEntry.FiscalCalendarPeriod = fiscalCalendarPeriod.RecId;
                generalJournalEntry.FiscalCalendarYear = fiscalCalendarPeriod.FiscalCalendarYear;
                generalJournalEntry.Ledger = Ledger::current();
                generalJournalEntry.PostingLayer = postingLayer;
                generalJournalEntry.AcknowledgementDate = transactionDate;
                generalJournalEntry.SubledgerVoucherDataAreaId = curExt();

                ledgerEntry.ConsolidatedCompany = _companyId;

                _generalJournalController.addForConsolidate(
                    generalJournalEntry,
                    generalJournalAccountEntry,
                    ledgerEntry,
                    _ledgerConsolidateHist);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerConsolidateHistory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>LedgerConsolidateHist</c> record for the current consolidation activity.
    /// </summary>
    /// <param name="_companyId">
    /// The ID of the subsidiary company.
    /// </param>
    /// <returns>
    /// A <c>LedgerConsolidateHist</c> record for the current consolidation activity.
    /// </returns>
    private LedgerConsolidateHist createLedgerConsolidateHistory(CompanyId _companyId)
    {
        LedgerConsolidateHist ledgerConsolidateHistory;
        ledgerConsolidateHistory.CompanyIdOrigin = _companyId;
        ledgerConsolidateHistory.Description = description;

        if (this.isInBatch())
        {
            ledgerConsolidateHistory.BatchJobId = BatchHeader::getCurrentBatchHeader().parmBatchHeaderId();
        }

        if (FeatureStateProvider::isFeatureEnabled(LedgerConsolidateTemplateFeature::instance()))
        {
            ledgerConsolidateHistory.ProcessDateTime = DateTimeUtil::getSystemDateTime();
            ledgerConsolidateHistory.FromDate = fromDate;
            ledgerConsolidateHistory.ToDate = toDate;
            ledgerConsolidateHistory.ConsolidateTemplate = templateId;
        }

        ledgerConsolidateHistory.insert();

        monitor.parmConsolidationId(ledgerConsolidateHistory.RecId);

        return ledgerConsolidateHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTotals</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates the summarized amounts in the GL of the target company.
    /// </summary>
    /// <param name="_companyId">
    ///    The company the data originated in.
    /// </param>
    /// <param name="_proportion">
    ///    The percentage of the account balances to consolidate.
    /// </param>
    /// <param name="_balanceProfitLoss">
    ///    A <c>BalanceProfitLoss</c> that specifies if the account is a balance sheet or pnl account.
    /// </param>
    /// <param name="_sumTransact">
    ///    A <c>TmpLedgerConsTrans</c> that determines whether a single summarized ledger transaction be
    ///    created.
    /// </param>
    /// <param name="_consolidationDimensionValueItem">
    ///    The table holding the dimension value detail records.
    /// </param>
    /// <param name="_generalJournalController">
    ///    The general journal controller used to transfer the result of the consolidation.
    /// </param>
    protected void createTotals(
        CompanyId                               _companyId,
        Percent                                 _proportion,
        BalanceProfitLoss                       _balanceProfitLoss,
        TmpLedgerConsTrans                      _sumTransact,
        TmpLedgerConsDimensionValueItem         _consolidationDimensionValueItem,
        LedgerPostingGeneralJournalController   _generalJournalController)
    {
        GeneralJournalAccountEntry  generalJournalAccountEntry;
        // <GBR>
        GeneralJournalAccountEntry_W generalJournalAccountEntryW;
        // </GBR>
        GeneralJournalEntry         generalJournalEntry;
        LedgerEntry                 ledgerEntry;

        DimensionAttributeValue dimAttrValueMainAccount;
        MainAccount             mainAccount;
        MainAccountNum          accountNumber;
        MainAccountNum          priorAccountNum;
        TransDate               lastTransactionDate;
        FiscalPeriodType        lastFiscalPeriodType;
        recId                   lastLocalSummaryTransactionId;
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        FiscalCalendarRecId     fiscalCalendarRecId;
        LedgerRecId             ledgerRecId;
        Map                     postingLayerAmounts = new Map(Types::Enum, Types::Container);
        List                    offsetAmounts = new List(Types::Container);
        TransactionTxt          transactionTxt = TransactionTxt::construct();

        transactionTxt.setType(LedgerTransTxt::LedgerConsolidate);
        transactionTxt.setKey1(_companyId);

        Debug::assert(ledgerConsolidateHist.RecId != 0);

        ttsbegin;

        ledgerRecId = Ledger::current();
        fiscalCalendarRecId = Ledger::fiscalCalendar();
        CurrencyCode accountingCurrency = Ledger::accountingCurrency();
        CurrencyCode reportingCurrency = Ledger::reportingCurrency();

        // Filter by company isn't necessary as records are deleted after processing and the table is only filled for one company at a time
        while select * from _sumTransact
            order by _sumTransact.TransDate, _sumTransact.PeriodCode
        {
            if ((lastTransactionDate != _sumTransact.TransDate) || (lastFiscalPeriodType != _sumTransact.PeriodCode))
            {
                MapEnumerator postingLayerEnumerator = postingLayerAmounts.getEnumerator();

                while (postingLayerEnumerator.moveNext())
                {
                    AmountMST accountingCurrencyAmount;
                    AmountMSTSecondary reportingCurrencyAmount;

                    [accountingCurrencyAmount, reportingCurrencyAmount] = postingLayerAmounts.lookup(postingLayerEnumerator.currentKey());

                    if (accountingCurrencyAmount != 0 || reportingCurrencyAmount != 0)
                    {
                        offsetAmounts.addEnd(this.packOffset(postingLayerEnumerator.currentKey(), lastFiscalPeriodType, lastTransactionDate, accountingCurrencyAmount, reportingCurrencyAmount));
                    }
                }

                lastTransactionDate = _sumTransact.TransDate;
                lastFiscalPeriodType = _sumTransact.PeriodCode;
                postingLayerAmounts = new Map(Types::Enum, Types::Container);
            }

            lastLocalSummaryTransactionId = _sumTransact.LocalRecId;

            generalJournalEntry = null;
            generalJournalEntry.AccountingDate = _sumTransact.TransDate;
            generalJournalEntry.AcknowledgementDate = _sumTransact.AcknowledgementDate;
            fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(fiscalCalendarRecId, _sumTransact.TransDate, _sumTransact.PeriodCode);

            Debug::assert(fiscalCalendarPeriod != null);

            generalJournalEntry.FiscalCalendarYear = fiscalCalendarPeriod.FiscalCalendarYear;
            generalJournalEntry.FiscalCalendarPeriod = fiscalCalendarPeriod.RecId;
            generalJournalEntry.PostingLayer = _sumTransact.OperationsTax;
            generalJournalEntry.Ledger = ledgerRecId;
            generalJournalEntry.SubledgerVoucherDataAreaId = curExt();

            ledgerEntry.ConsolidatedCompany = _companyId;

            if (priorAccountNum != _sumTransact.MainAccountId)
            {
                accountNumber = LedgerConsolidate::initMainAccount(_companyId, _sumTransact.MainAccountId, _sumTransact.MainAccountName, _sumTransact.OriginalMainAccountId, companyGroupAccounts, errorAccount);

                if (mainAccount.MainAccountId != accountNumber)
                {
                    mainAccount = MainAccount::findByMainAccountId(accountNumber);
                    dimAttrValueMainAccount = DimensionAttributeValue::findByDimensionAttributeAndEntityInst(dimAttrMainAccountId, mainAccount.RecId, false, true);
                }
            }

            // <GBR>
            if (BrazilParameters::isEnabled() && _sumTransact.ConsolidatedVoucher_BR)
            {
                generalJournalEntry.DocumentDate                    = _sumTransact.DocumentDate_BR;
                generalJournalEntry.DocumentNumber                  = _sumTransact.DocumentNumber_BR;
                generalJournalEntry.JournalCategory                 = _sumTransact.JournalCategory_BR;

                if (this.mode() == LedgerConsMode::Online)
                {
                    generalJournalAccountEntryW.ConsolidatedRefRecId_BR  = _sumTransact.ConsolidatedRefRecId_BR;
                }

                generalJournalAccountEntryW.ConsolidatedVoucher_BR   = _sumTransact.ConsolidatedVoucher_BR;
                generalJournalAccountEntry.IsCorrection             = _sumTransact.IsCorrection_BR;
                generalJournalAccountEntry.PostingType              = _sumTransact.PostingType_BR;

                transactionTxt.setCustVendName(_sumTransact.Text_BR);

                _proportion = 100;
            }
            // </GBR>

            transactionTxt.setKey2(_sumTransact.MainAccountId);
            generalJournalAccountEntry.Text = transactionTxt.txt();

            generalJournalAccountEntry.LedgerDimension = this.getLedgerDimension(
                    _companyId,
                    accountNumber,
                    dimAttrValueMainAccount.RecId,
                    dimAttrValueMainAccount.HashKey,
                    _sumTransact.LocalRecId,
                    _consolidationDimensionValueItem);

            generalJournalAccountEntry.IsCredit = _sumTransact.Crediting;
            generalJournalAccountEntry.Quantity = _sumTransact.Qty * _proportion / 100;

            if (useDualCurrency && _sumTransact.ReportingCurrencyCode == '' && _sumTransact.ReportingCurrencyAmount == 0)
            {
                consolidationAmountSource = LedgerConsolidateAmountSource::AccountingCurrencyAmount;
            }

            this.setGeneralLedgerSourceAmount(generalJournalAccountEntry, _sumTransact, consolidationAmountSource, _proportion);

            // Get the currency exchange helper based on the account and use it to convert currency
            CurrencyExchangeHelper currencyExchHelper = this.getCurrencyExchangeHelper(_sumTransact.OriginalMainAccountId, accountNumber, generalJournalEntry.AccountingDate, CompanyInfo::current(_companyId));

            this.setGeneralLedgerDualCurrencyAmounts(generalJournalAccountEntry, _sumTransact, _proportion, currencyExchHelper, accountingCurrency, reportingCurrency);

            // check all amounts because accounting and reporting amounts may not depend on the transaction amount
            if (generalJournalAccountEntry.TransactionCurrencyAmount != 0 || generalJournalAccountEntry.AccountingCurrencyAmount != 0
                || generalJournalAccountEntry.ReportingCurrencyAmount != 0 || generalJournalAccountEntry.Quantity != 0)
            {
                countOutput++;
                generalJournalAccountEntry.LedgerDimension = LedgerDimensionFacade::serviceApplyFixedDimensions(generalJournalAccountEntry.LedgerDimension);

                _generalJournalController.addForConsolidate(
                    generalJournalEntry,
                    generalJournalAccountEntry,
                    ledgerEntry,
                    ledgerConsolidateHist
                    // <GBR>
                    , generalJournalAccountEntryW
                    // </GBR>
                );

                // total per posting layer
                if (!postingLayerAmounts.exists(generalJournalEntry.PostingLayer))
                {
                    postingLayerAmounts.insert(generalJournalEntry.PostingLayer, [0, 0]);
                }

                AmountMST accountingCurrencyAmount;
                AmountMSTSecondary reportingCurrencyAmount;

                [accountingCurrencyAmount, reportingCurrencyAmount] = postingLayerAmounts.lookup(generalJournalEntry.PostingLayer);

                accountingCurrencyAmount += generalJournalAccountEntry.AccountingCurrencyAmount;
                reportingCurrencyAmount += generalJournalAccountEntry.ReportingCurrencyAmount;

                postingLayerAmounts.insert(generalJournalEntry.PostingLayer, [accountingCurrencyAmount, reportingCurrencyAmount]);
            }
        }

        delete_from _sumTransact;

        // load the list with only those posting layers with amounts to offset
        MapEnumerator postingLayerEnumerator = postingLayerAmounts.getEnumerator();

        while (postingLayerEnumerator.moveNext())
        {
            AmountMST accountingCurrencyAmount;
            AmountMSTSecondary reportingCurrencyAmount;

            [accountingCurrencyAmount, reportingCurrencyAmount] = postingLayerAmounts.lookup(postingLayerEnumerator.currentKey());

            if (accountingCurrencyAmount != 0 || reportingCurrencyAmount != 0)
            {
                offsetAmounts.addEnd(this.packOffset(postingLayerEnumerator.currentKey(), lastFiscalPeriodType, lastTransactionDate, accountingCurrencyAmount, reportingCurrencyAmount));
            }
        }

        if (offsetAmounts.elements() > 0)
        {
            this.createErrorTransaction(
                ledgerConsolidateHist,
                _balanceProfitLoss,
                _companyId,
                offsetAmounts,
                lastLocalSummaryTransactionId,
                _consolidationDimensionValueItem,
                _generalJournalController);
        }

        if (transferBudget && (budgetConsolidationManager != null))
        {
            // toDate and fromDate are for the full consolidation because LedgerConsMode::Import does not support batch threads
            budgetConsolidationManager.saveConsolidatedBudgetTransactons(sourceToConsDimAttrTranslation);
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGeneralLedgerSourceAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the source amount of the general ledger.
    /// </summary>
    /// <param name = "_generalJournalAccountEntry">The <c>GeneralJournalAccountEntry</c> table.</param>
    /// <param name = "_sumTransact">The <c>TmpLedgerConsTrans</c> table.</param>
    /// <param name = "_consolidationAmountSource">The consolidation amount source.</param>
    /// <param name = "_proportion">The proportion of the source amount.</param>
    private void setGeneralLedgerSourceAmount(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        TmpLedgerConsTrans _sumTransact,
        LedgerConsolidateAmountSource _consolidationAmountSource,
        Percent _proportion)
    {
        if (_consolidationAmountSource == LedgerConsolidateAmountSource::AccountingCurrencyAmount)
        {
            _generalJournalAccountEntry.TransactionCurrencyCode = _sumTransact.CurrencyCode;

            _generalJournalAccountEntry.TransactionCurrencyAmount = CurrencyExchange::round(
                    _sumTransact.AmountCur * _proportion / 100,
                    _generalJournalAccountEntry.TransactionCurrencyCode);
        }
        else if (_consolidationAmountSource == LedgerConsolidateAmountSource::ReportingCurrencyAmount)
        {
            _generalJournalAccountEntry.TransactionCurrencyCode = _sumTransact.ReportingCurrencyCode;
                
            _generalJournalAccountEntry.TransactionCurrencyAmount = CurrencyExchange::round(
                    _sumTransact.ReportingCurrencyAmount * _proportion / 100,
                    _generalJournalAccountEntry.TransactionCurrencyCode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGeneralLedgerDualCurrencyAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the accounting and reporting amounts of the general ledger.
    /// </summary>
    /// <param name = "_generalJournalAccountEntry">The <c>GeneralJournalAccountEntry</c> table.</param>
    /// <param name = "_sumTransact">The <c>TmpLedgerConsTrans</c> table.</param>
    /// <param name = "_proportion">The proportion of the source amount.</param>
    /// <param name = "_currencyExchHelper">The <c>CurrencyExchangeHelper</c> class.</param>
    /// <param name = "_accountingCurrency">The accounting currency.</param>
    /// <param name = "_reportingCurrency">The reporting currency.</param>
    private void setGeneralLedgerDualCurrencyAmounts(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        TmpLedgerConsTrans _sumTransact,
        Percent _proportion,
        CurrencyExchangeHelper _currencyExchHelper,
        CurrencyCode _accountingCurrency,
        CurrencyCode _reportingCurrency)
    {
        if (useDualCurrency)
        {
            // accounting
            if (_accountingCurrency == _sumTransact.CurrencyCode)
            {
                _generalJournalAccountEntry.AccountingCurrencyAmount = CurrencyExchange::round(
                    _sumTransact.AmountCur * _proportion / 100,
                    _accountingCurrency);
            }
            else if (_accountingCurrency == _sumTransact.ReportingCurrencyCode)
            {
                _generalJournalAccountEntry.AccountingCurrencyAmount = CurrencyExchange::round(
                    _sumTransact.ReportingCurrencyAmount * _proportion / 100,
                    _accountingCurrency);
            }
            else
            {
                _generalJournalAccountEntry.AccountingCurrencyAmount = _currencyExchHelper.calculateTransactionToAccounting(
                    _generalJournalAccountEntry.TransactionCurrencyCode,     // Currency code
                    _generalJournalAccountEntry.TransactionCurrencyAmount,   // Amount
                    true);                                                   // Round
            }

            // reporting
            if (_reportingCurrency == _sumTransact.CurrencyCode)
            {
                _generalJournalAccountEntry.ReportingCurrencyAmount = CurrencyExchange::round(
                    _sumTransact.AmountCur * _proportion / 100,
                    _reportingCurrency);
            }
            else if (_reportingCurrency == _sumTransact.ReportingCurrencyCode)
            {
                _generalJournalAccountEntry.ReportingCurrencyAmount = CurrencyExchange::round(
                    _sumTransact.ReportingCurrencyAmount * _proportion / 100,
                    _reportingCurrency);
            }
            else
            {
                _generalJournalAccountEntry.ReportingCurrencyAmount = _currencyExchHelper.calculateTransactionCurrencyToReportingCurrency(
                    _generalJournalAccountEntry.TransactionCurrencyCode,     // Currency code
                    _generalJournalAccountEntry.TransactionCurrencyAmount);  // Amount
                // round is the default
            }
        }
        else
        {
            // legacy behavior
            _generalJournalAccountEntry.AccountingCurrencyAmount = _currencyExchHelper.calculateTransactionToAccounting(
                _generalJournalAccountEntry.TransactionCurrencyCode,     // Currency code
                _generalJournalAccountEntry.TransactionCurrencyAmount,   // Amount
                true);                                                   // Round

            _generalJournalAccountEntry.ReportingCurrencyAmount = _currencyExchHelper.calculateTransactionCurrencyToReportingCurrency(
                _generalJournalAccountEntry.TransactionCurrencyCode,     // Currency code
                _generalJournalAccountEntry.TransactionCurrencyAmount);  // Amount
            // round is the default
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteData</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the data that was created that originated in a given company for an account and date range
    /// </summary>
    /// <param name="_companyId">
    ///    The company being consolidated.
    /// </param>
    /// <remarks>
    ///    When the data from a company is being consolidated into the current company any transactional or
    ///    budget data that was created during a previous consolidation for the account and date range must be
    ///    removed. This prevents the over or under statement of account values.
    /// </remarks>
    /// <exception cref="M:Exception::Error">
    ///    The transaction date for a ledger transaction does not fall in a valid period.
    /// </exception>
    protected void deleteData(CompanyId _companyId)
    {
        GeneralJournalAccountEntry              generalJournalAccountEntry;
        // <GBR>
        GeneralJournalAccountEntry_W            generalJournalAccountEntryW;
        // </GBR>
        GeneralJournalEntry                     generalJournalEntry;
        MainAccount                             mainAccount;
        LedgerConsolidateHist                   ledgerConsolidateHistLocal;
        LedgerConsolidateHistRef                ledgerConsolidateHistRef;
        recId                                   calendarRecId = CompanyInfoHelper::fiscalCalendarRecId();
        LedgerRecId                             ledgerRecId;
        LedgerChartOfAccountsRecId              ledgerChartOfAccountsRecId;
        TableId                                 generalJournalAccountEntryTableId;

        if (transferCurrent)
        {
            //
            // There exists a one to one relationship between the ledger and consolidation record.
            // We only know which company a ledger record originated in by using the consolidation record.
            // The balances contain values per account/day across all ledger entries which requires us to
            // select on a day by day basis per account so the balances can be updated correctly.
            //

            ledgerRecId                         = Ledger::current();
            ledgerChartOfAccountsRecId          = LedgerChartOfAccounts::current();
            generalJournalAccountEntryTableId   = tableNum(GeneralJournalAccountEntry);

            TransDate deleteFromDate = fromDate;
            TransDate deleteToDate = toDate;
            boolean isMainAccountSet;

            if (isChildBatchRuntimeTask)
            {
                deleteFromDate = fullConsolidationFromDate;
                deleteToDate = fullConsolidationToDate;
            }

            if (!deleteFromDate || !deleteToDate)
            {
                throw error("@GeneralLedger:GeneralJournalCleanupDateCriteriaRequired");
            }

            if (deletePerformanceEnhancement)
            {
                isMainAccountSet = (fromAccount != '' || toAccount != '');

                SysDaQueryObject queryGJE = this.createSysObjectForGJETable(generalJournalEntry, ledgerRecId, deleteFromDate, deleteToDate);
                SysDaQueryObject queryGJAE = this.createSysObjectForGJAETable(generalJournalAccountEntry, generalJournalEntry);

                SysDaQueryObject queryHistRef = this.createSysObjectForHistRefTable(ledgerConsolidateHistRef, generalJournalAccountEntry);
                SysDaQueryObject queryHist = this.createSysObjectForHistTable(ledgerConsolidateHist, ledgerConsolidateHistRef, _companyId);

                queryGJE.joinClause(SysDaJoinKind::InnerJoin, queryGJAE);
                queryGJAE.joinClause(SysDaJoinKind::InnerJoin, queryHistRef);
                queryHistRef.joinClause(SysDaJoinKind::InnerJoin, queryHist);

                if (isMainAccountSet)
                {
                    SysDaQueryObject queryMainAccount = this.createSysObjectForMainAccountTable(
                        mainAccount, generalJournalAccountEntry, ledgerChartOfAccountsRecId, fromAccount, toAccount);

                    queryHist.joinClause(SysDaJoinKind::InnerJoin, queryMainAccount);
                }
        
                SysDaSearchObject searchObject = new SysDaSearchObject(queryGJE);
                SysDaSearchStatement searchStatement = new SysDaSearchStatement();
                searchStatement.next(searchObject);
            }
            else
            {
                select firstonly AccountingDate from generalJournalEntry
                    order by generalJournalEntry.AccountingDate
                    where generalJournalEntry.AccountingDate >= deleteFromDate &&
                        generalJournalEntry.AccountingDate <= deleteToDate &&
                        generalJournalEntry.Ledger == ledgerRecId
                    exists join generalJournalAccountEntry
                        where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                    exists join ledgerConsolidateHistLocal
                        where ledgerConsolidateHistLocal.CompanyIdOrigin == _companyId
                        exists join ledgerConsolidateHistRef
                            where ledgerConsolidateHistRef.TransTableId == generalJournalAccountEntryTableId &&
                                ledgerConsolidateHistRef.TransRecid == generalJournalAccountEntry.RecId &&
                                ledgerConsolidateHistRef.RefRecId == ledgerConsolidateHistLocal.RecId
                            exists join mainAccount
                                where mainAccount.RecId == generalJournalAccountEntry.MainAccount &&
                                    mainAccount.LedgerChartOfAccounts == ledgerChartOfAccountsRecId &&
                                    mainAccount.MainAccountId >= fromAccount &&
                                    (!toAccount || mainAccount.MainAccountId <= toAccount);
            }

            if (generalJournalEntry.RecId)
            {
                LedgerFiscalCalendarPeriod ledgerFiscalCalendarPeriod = LedgerFiscalCalendar::findLedgerPeriodByPeriodTypeDate(calendarRecId,
                    generalJournalEntry.AccountingDate,
                    FiscalPeriodType::Operating);

                if (ledgerFiscalCalendarPeriod.Status != FiscalPeriodStatus::Open)
                {
                    FiscalCalendarPeriod fiscalCalendarPeriod = FiscalCalendarPeriod::find(ledgerFiscalCalendarPeriod.FiscalCalendarPeriod);
                    if (ledgerFiscalCalendarPeriod.Status == FiscalPeriodStatus::Closed)
                    {
                        throw error(strFmt("@GeneralLedger:ConsolidatedTransStatusNotReversibleClosed",
                            fiscalCalendarPeriod.Name,
                            FiscalPeriodStatus::Closed));
                    }
                    else
                    {
                        throw error(strFmt("@GeneralLedger:ConsolidatedTransStatusNotReversibleOnHold",
                            fiscalCalendarPeriod.Name,
                            ledgerFiscalCalendarPeriod.Status,
                            FiscalPeriodStatus::Open));
                    }
                }
            }

            monitor.parmConsolidationId(ledgerConsolidateHistLocal.RecId);

            using (SysInstrumentationActivityContext context = monitor.enterDeleteConsolidationTransactions())
            {
                generalJournalAccountEntry.skipDeleteActions(true);
                generalJournalAccountEntry.skipDataMethods(true);
                generalJournalAccountEntry.skipEvents(true);

                if (deletePerformanceEnhancement)
                {
                    // In order to remove exists join from deletion,
                    // find and insert RecId of GJAE records to be deleted into a temp table first.
                    GeneralJournalAccountEntryRecIdTmp tmpGJAERecIdTobeDeleted;

                    if (isMainAccountSet)
                    {
                        insert_recordset tmpGJAERecIdTobeDeleted (GeneralJournalAccountEntry)
                        select RecId from generalJournalAccountEntry
                            join generalJournalEntry
                                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                                    generalJournalEntry.AccountingDate >= deleteFromDate &&
                                    generalJournalEntry.AccountingDate <= deleteToDate &&
                                    generalJournalEntry.Ledger == ledgerRecId
                            join ledgerConsolidateHistLocal
                                where ledgerConsolidateHistLocal.CompanyIdOrigin == _companyId
                            join ledgerConsolidateHistRef
                                where ledgerConsolidateHistRef.TransTableId == generalJournalAccountEntryTableId &&
                                    ledgerConsolidateHistRef.TransRecid == generalJournalAccountEntry.RecId &&
                                    ledgerConsolidateHistRef.RefRecId == ledgerConsolidateHistLocal.RecId
                            join mainAccount
                                where mainAccount.RecId == generalJournalAccountEntry.MainAccount &&
                                    mainAccount.LedgerChartOfAccounts == ledgerChartOfAccountsRecId &&
                                    mainAccount.MainAccountId >= fromAccount &&
                                    (!toAccount || mainAccount.MainAccountId <= toAccount);
                    }
                    else
                    {
                        insert_recordset tmpGJAERecIdTobeDeleted (GeneralJournalAccountEntry)
                        select RecId from generalJournalAccountEntry
                            join generalJournalEntry
                                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                                    generalJournalEntry.AccountingDate >= deleteFromDate &&
                                    generalJournalEntry.AccountingDate <= deleteToDate &&
                                    generalJournalEntry.Ledger == ledgerRecId
                            join ledgerConsolidateHistLocal
                                where ledgerConsolidateHistLocal.CompanyIdOrigin == _companyId
                            join ledgerConsolidateHistRef
                                where ledgerConsolidateHistRef.TransTableId == generalJournalAccountEntryTableId &&
                                    ledgerConsolidateHistRef.TransRecid == generalJournalAccountEntry.RecId &&
                                    ledgerConsolidateHistRef.RefRecId == ledgerConsolidateHistLocal.RecId;
                    }

                    delete_from generalJournalAccountEntry
                        exists join tmpGJAERecIdTobeDeleted
                            where tmpGJAERecIdTobeDeleted.GeneralJournalAccountEntry == generalJournalAccountEntry.RecId;
                }
                else
                {
                    delete_from generalJournalAccountEntry
                        exists join generalJournalEntry
                            where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry &&
                                generalJournalEntry.AccountingDate >= deleteFromDate &&
                                generalJournalEntry.AccountingDate <= deleteToDate &&
                                generalJournalEntry.Ledger == ledgerRecId
                        exists join ledgerConsolidateHistLocal
                            where ledgerConsolidateHistLocal.CompanyIdOrigin == _companyId
                            exists join ledgerConsolidateHistRef
                                where ledgerConsolidateHistRef.TransTableId == generalJournalAccountEntryTableId &&
                                    ledgerConsolidateHistRef.TransRecid == generalJournalAccountEntry.RecId &&
                                    ledgerConsolidateHistRef.RefRecId == ledgerConsolidateHistLocal.RecId
                                exists join mainAccount
                                    where mainAccount.RecId == generalJournalAccountEntry.MainAccount &&
                                        mainAccount.LedgerChartOfAccounts == ledgerChartOfAccountsRecId &&
                                        mainAccount.MainAccountId >= fromAccount &&
                                        (!toAccount || mainAccount.MainAccountId <= toAccount);
                }

                Counter countDeleted = generalJournalAccountEntry.RowCount();

                // <GBR>
                if (BrazilParameters::isEnabled())
                {
                    delete_from generalJournalAccountEntryW
                        notexists join generalJournalAccountEntry
                            where generalJournalAccountEntry.RecId == generalJournalAccountEntryW.GeneralJournalAccountEntry;
                    }
                // </GBR>

                // Delete the ledger consolidation history references.
                delete_from ledgerConsolidateHistRef
                    where ledgerConsolidateHistRef.TransTableId == generalJournalAccountEntryTableId
                    exists join ledgerConsolidateHistLocal
                        where ledgerConsolidateHistLocal.RecId == ledgerConsolidateHistRef.RefRecId &&
                              ledgerConsolidateHistLocal.CompanyIdOrigin == _companyId
                    notexists join generalJournalAccountEntry
                        where generalJournalAccountEntry.RecId == ledgerConsolidateHistRef.TransRecid;

                monitor.exitDeleteConsolidationTransactions(context, countDeleted);
            }
        }

        if (transferBudget)
        {
            this.setUpBudgetConsolidationManager();
            budgetConsolidationManager.parmSubsidiaryCompany(_companyId);
            budgetConsolidationManager.removeConsolidatedBudgetTransactions();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteDataAllCompanies</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the data that was created that originated from each company for the account and date range.
    /// </summary>
    protected void deleteDataAllCompanies()
    {
        int idx;

        while (idx < conLen(companies))
        {
            idx++;

            [companyId] = conPeek(companies,idx);

            this.deleteData(companyId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Deletes the specified journal.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number to delete.
    /// </param>
    /// <remarks>
    ///    This method should be called in the company for which the journal exists.
    /// </remarks>
    protected void deleteJournal(LedgerJournalId _journalNum)
    {
        LedgerJournalTrans  ledgerJournalTransLocal;
        LedgerJournalTable  ledgerJournalTablelocal;

        ttsbegin;

        // delete the header and lines
        ledgerJournalTablelocal = LedgerJournalTable::find(_journalNum,true);

        if (ledgerJournalTablelocal)
        {
            // determine if any ledger journal trans records exist for the journal
            select firstonly ledgerJournalTransLocal
                where ledgerJournalTransLocal.JournalNum == _journalNum;

            // Only one voucher is used per journal and this method will delete all the records with the voucher number
            if (ledgerJournalTransLocal)
            {
                LedgerJournalTrans::deleteTransFromVoucher(ledgerJournalTransLocal.JournalNum,
                                                           ledgerJournalTransLocal.Voucher);
            }

            ledgerJournalTablelocal.delete();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>descriptionNote</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the consolidation description.
    /// </summary>
    /// <param name = "_description">A string that is a description of the consolidation.</param>
    /// <returns>A string.</returns>
    Description descriptionNote(Description _description = description)
    {
        description = _description;
        return description;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@GeneralLedger:Consolidations";
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    /// interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    Object dialog()
    {
        mayBeExecuted = false;

        DialogRunbase dialog =  Dialog::newFormnameRunbase(formStr(LedgerConsolidate), this);

        this.dialogInternal(dialog);

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportTransact</Name>
				<Source><![CDATA[
    private str exportTransact(
        CompanyId                       _companyId,
        Filename                        _filename,
        TmpLedgerConsTrans              _sumTransact,
        TmpLedgerConsDimensionValueItem _consolidationDimensionValueItem,
        TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute
        )
    {
        container packedTables = this.packTables(_companyId, _sumTransact, _consolidationDimensionValueItem, _consolidationDimensionAttribute);

        // <GBR>
        if (this.isTransferOnly_BR())
        {
            return LedgerConsolidateFile::exportTransferOnly_BR(packedTables, _filename, _companyId, companyGroupAccounts);
        }
        // </GBR>
        else
        {
            return LedgerConsolidateFile::exportFile(packedTables, _filename, _companyId, companyGroupAccounts);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillConsolidatedDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills the class variables with the dimension values for the specified ledger dimension. The values are filtered by the consolidation specifications.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension that represents the unfiltered dimension values.
    /// </param>
    /// <param name="_specificationAccountNum">
    ///    The account number that is used when the specification is the <c>AccountNum</c> value.
    /// </param>
    /// <returns>
    ///    The number of dimension values.
    /// </returns>
    /// <remarks>
    ///    The filtered dimension values are stored in the <c>consolidatedDimAttrIdArray</c>,
    ///    <c>consolidatedDimAttrValueIdArray</c> and the <c>consolidatedDisplayValueArray</c> class variables.
    /// </remarks>
    protected int fillConsolidatedDimensionValues(LedgerDimensionAccount _ledgerDimension, MainAccountNum _specificationAccountNum)
    {
        DimensionAttributeValue                 dimAttrValue;
        DimensionAttributeLevelValue            dimAttrLevelValue;
        DimensionAttributeValueGroupCombination dimAttrValueGroupCombination;

        // Extract dimension values
        Map levelValues = new Map(Types::Int64, Types::Container);
        while select DimensionAttribute, GroupDimension, HashKey, RecId from dimAttrValue group by dimAttrValue.DimensionAttribute, dimAttrValue.RecId, dimAttrValue.GroupDimension, dimAttrLevelValue.DisplayValue, dimAttrValue.HashKey
            where dimAttrValue.DimensionAttribute != dimAttrMainAccountId
            join DisplayValue from dimAttrLevelValue
                    where dimAttrLevelValue.DimensionAttributeValue == dimAttrValue.RecId
            join RecId from dimAttrValueGroupCombination
                    where dimAttrValueGroupCombination.DimensionAttributeValueGroup == dimAttrLevelValue.DimensionAttributeValueGroup &&
                        dimAttrValueGroupCombination.DimensionAttributeValueCombination == _ledgerDimension
        {
            levelValues.insert(dimAttrValue.DimensionAttribute, [dimAttrLevelValue.DisplayValue, dimAttrValue.RecId, dimAttrValue.HashKey, dimAttrValue.GroupDimension]);
        }

        int valueSetCount = this.populateFilteredDimensionValueCollections(_ledgerDimension, _specificationAccountNum, levelValues);

        return valueSetCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateFilteredDimensionValueCollections</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Populates the class variables with dimension values that are filtered by the consolidation specifications.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension that represents the unfiltered dimension values.
    /// </param>
    /// <param name="_specificationAccountNum">
    ///    The account number that is used when the specification is the <c>AccountNum</c> value.
    /// </param>
    /// <param name="_levelValues">
    ///    A map with the dimension value information for the specified ledger dimension. The map has a key of a RecId of a <c>DimensionAttribute</c> record and value of
    ///    a container with: dimension display value, RecId of a <c>DimensionAttributeValue</c> record, hash key of a <c>DimensionAttributeValue</c> record, and group dimension value.
    /// </param>
    /// <returns>
    ///    The number of dimension values.
    /// </returns>
    protected int populateFilteredDimensionValueCollections(LedgerDimensionAccount _ledgerDimension, MainAccountNum _specificationAccountNum, Map _levelValues)
    {
        // Build filtered dimension value collection
        int valueSetCount;
        companyDimensionEnumerator.reset();
        while (companyDimensionEnumerator.moveNext())
        {
            recId dimAttrId = companyDimensionEnumerator.currentKey();
            container dimensionMappingValue = companyDimensionEnumerator.currentValue();
            LedgerConsDim specification = conPeek(dimensionMappingValue, LedgerConsolidateDefinitions::DimensionMapping_Specification);

            container dimensionValueCollection = this.getDimensionValueCollection(_ledgerDimension, _specificationAccountNum, _levelValues, dimAttrId, specification);

            DimensionValue displayValue = conPeek(dimensionValueCollection, 1);

            if (displayValue)
            {
                valueSetCount++;
                consolidatedDimAttrIdArray[valueSetCount] = dimAttrId;
                consolidatedDimAttrValueIdArray[valueSetCount] = conPeek(dimensionValueCollection, 2);
                consolidatedDimAttrValueHashKeyArray[valueSetCount] = conPeek(dimensionValueCollection, 3);
                consolidatedDisplayValueArray[valueSetCount] = displayValue;
            }
        }

        return valueSetCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionValueCollection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the dimension-related values for the specified dimension attribute given the consolidation specification.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension that represents the unfiltered dimension values.
    /// </param>
    /// <param name="_specificationAccountNum">
    ///    The account number that is used when the specification is the <c>AccountNum</c> value.
    /// </param>
    /// <param name="_levelValues">
    ///    A map with the dimension value information for the specified ledger dimension. The map has a key of a RecId of a <c>DimensionAttribute</c> record and value of
    ///    a container with: dimension display value, RecId of a <c>DimensionAttributeValue</c> record, hash key of a <c>DimensionAttributeValue</c> record, and group dimension value.
    /// </param>
    /// <param name = "_dimAttrId">
    ///    The record Id of a <c>DimensionAttribute</c> record.
    /// </param>
    /// <param name = "_specification">
    ///    The <c>LedgerConsDim</c> enumeration value.
    /// </param>
    /// <returns>
    ///    A container with three values: dimension display value, RecId of a <c>DimensionAttributeValue</c> record, and hash key of a <c>DimensionAttributeValue</c> record.
    /// </returns>
    protected container getDimensionValueCollection(LedgerDimensionAccount _ledgerDimension,
        MainAccountNum _specificationAccountNum,
        Map _levelValues,
        recId _dimAttrId,
        LedgerConsDim _specification)
    {
        DimensionValue displayValue;
        recId dimAttrValueId;
        HashKey dimAttrValueHashKey;
        DimensionExt groupDimension;

        switch (_specification)
        {
            case LedgerConsDim::None:
                displayValue = '';
                break;

            case LedgerConsDim::Dimension:
                    if (_levelValues.exists(_dimAttrId))
                {
                    [displayValue, dimAttrValueId, dimAttrValueHashKey, groupDimension] = _levelValues.lookup(_dimAttrId);
                }
                else
                {
                    displayValue = '';
                }
                break;

            case LedgerConsDim::CompanyGroup:
                    if (_levelValues.exists(_dimAttrId))
                {
                    [displayValue, dimAttrValueId, dimAttrValueHashKey, groupDimension] = _levelValues.lookup(_dimAttrId);
                    displayValue = groupDimension;
                    if (displayValue)
                    {
                        if (LedgerConsolidateWithGroupDimensionFlight::instance().isEnabled())
                        {
                            groupDimensionDimAttrValueIdLookup.insert(displayValue, dimAttrValueHashKey);
                        }

                        dimAttrValueHashKey = this.getPseudoDimensionAttributeValueId(groupDimensionDimAttrValueIdLookup, displayValue);
                    }
                }
                else
                {
                    displayValue = '';
                }
                break;

            case LedgerConsDim::Company :
                displayValue = this.getCompanyInfoValue();
                dimAttrValueHashKey = companyDimAttrValueHashKey;
                break;

            case LedgerConsDim::AccountNum :
                displayValue = _specificationAccountNum;
                dimAttrValueHashKey = this.getPseudoDimensionAttributeValueId(acctNumDimAttrValueIdLookup, _specificationAccountNum);
                break;
        }

        return [displayValue, dimAttrValueId, dimAttrValueHashKey];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCompanyInfoValue</Name>
				<Source><![CDATA[
    private DimensionValue getCompanyInfoValue()
    {
        DimAttributeCompanyInfo dimAttributeCompanyInfo;
        DimensionValue displayValue;

        // The kernel has an issue where curext() sometimes returns in upper case, sometimes returns in lower case
        // Dimensions must retain the correct casing that the user physically keyed into the CompanyInfo / LegalEntity id.
        // Hence we are taking the value from view instead of curext().
        select Value from dimAttributeCompanyInfo
            where dimAttributeCompanyInfo.Value == curext();

        displayValue = dimAttributeCompanyInfo.Value;
        return displayValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the from Main account.
    /// </summary>
    /// <param name = "_fromAccount">The from account.</param>
    /// <returns>The ID of a Main account.</returns>
    MainAccountNum fromAccount(MainAccountNum _fromAccount = fromAccount)
    {
        fromAccount = _fromAccount;
        return fromAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the from date.
    /// </summary>
    /// <param name = "_fromDate">The from date.</param>
    /// <returns>The from date.</returns>
    TransDate fromDate(TransDate _fromDate = fromDate)
    {
        fromDate = _fromDate;
        return fromDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fromModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the from budget model.
    /// </summary>
    /// <param name = "_fromModel">The ID of a budget model.</param>
    /// <returns>The ID of a budget model.</returns>
    BudgetModelId fromModel(BudgetModelId _fromModel = fromModel)
    {
        fromModel = _fromModel;
        return fromModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getConsolidatedDimensionValues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the dimension values filtered by the specifications.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The ledger dimension that represents the unfiltered dimension values.
    /// </param>
    /// <param name="_specificationAccountNum">
    ///    The account number to use when the specification is the <c>AccountNum</c> data type.
    /// </param>
    /// <returns>
    ///    A map that holds the filtered dimension values.
    /// </returns>
    /// <remarks>
    ///    The map key is the record ID of the <c>DimensionAttribute</c> record for the source dimension.The
    ///    map value is display value for the dimension value.
    /// </remarks>
    public Map getConsolidatedDimensionValues(LedgerDimensionAccount _ledgerDimension, MainAccountNum _specificationAccountNum)
    {
        Map consolidatedDimensionValues;
        int i;
        int valueSetCount;

        valueSetCount = this.fillConsolidatedDimensionValues(_ledgerDimension, _specificationAccountNum);

        consolidatedDimensionValues = new Map(Types::Int64, Types::String);
        for (i = 1; i <= valueSetCount; i++)
        {
            consolidatedDimensionValues.insert(consolidatedDimAttrIdArray[i], consolidatedDisplayValueArray[i]);
        }

        return consolidatedDimensionValues;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchangeHelper</Name>
				<Source><![CDATA[
    protected CurrencyExchangeHelper getCurrencyExchangeHelper(MainAccountNum _sourceAccountNumber, MainAccountNum _targetAccountNumber, TransDate _accountingDate, RefRecId _sourceLegalEntity)
    {
        LedgerConsolidateCurrencyConversion currencyConversion;
        CurrencyExchangeHelper              helper = CurrencyExchangeHelper::construct();

        // Default helper to the values from the consolidation ledger, which is the fallback
        helper.parmLedgerRecId(Ledger::current());

        if (companyGroupAccounts)
        {
            if (LedgerConsolidateCheckCOAForCurrencyExchangeFlight::instance().isEnabled())
            {
                if (LedgerChartOfAccounts::current() == Ledger::chartOfAccounts(_sourceLegalEntity))
                {
                    // Only when chart of accounts are the same between source company and consolidate company,
                    // search for the target account because the option to use the target account is enabled.
                    select currencyConversion where
                        currencyConversion.SourceLegalEntity == _sourceLegalEntity
                        && currencyConversion.FromAccount <= _targetAccountNumber
                        && currencyConversion.ToAccount >= _targetAccountNumber;
                }
            }
            else
            {
                // Search for the target account because the option to use the target account is enabled.
                select currencyConversion where
                    currencyConversion.SourceLegalEntity == _sourceLegalEntity
                    && currencyConversion.FromAccount <= _targetAccountNumber
                    && currencyConversion.ToAccount >= _targetAccountNumber;
            }
        }

        if ((!companyGroupAccounts) || (currencyConversion == null))
        {
            // Search for the source account because either the option to use the target account is not enabled
            // or a row corresponding to the target account was not found.
            select currencyConversion where
                currencyConversion.SourceLegalEntity == _sourceLegalEntity
                && currencyConversion.FromAccount <= _sourceAccountNumber
                && currencyConversion.ToAccount >= _sourceAccountNumber;
        }

        // If specific information for this account exists, use it
        if (currencyConversion)
        {
            // Set date to accounting date if specified
            if (currencyConversion.ConversionDate == LedgerConsolidateConversionDate::TransactionDate)
            {
                helper.parmExchangeDate(_accountingDate);
            }
            else if (currencyConversion.ConversionDate == LedgerConsolidateConversionDate::ConsolidationDate)
            {
                if (isChildBatchRuntimeTask)
                {
                    helper.parmExchangeDate(fullConsolidationToDate);
                }
                else
                {
                    helper.parmExchangeDate(toDate);
                }
            }

            // If a specific rate is provided as a user specified rate, use that value
            if (currencyConversion.ExchangeRate && currencyConversion.ConversionDate == LedgerConsolidateConversionDate::Specified)
            {
                helper.parmExchangeRate1(currencyConversion.ExchangeRate);
            }
   
            if (currencyConversion.ExchangeRateType)
            {
                helper.parmExchangeRateTypeRecId(currencyConversion.ExchangeRateType);
            }
        }

        return helper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDimensionsAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a sorted list of the dimensions from the source dimensions.
    /// </summary>
    /// <param name="_consolidationDimensionAttribute">
    ///    The table that holds the source dimension records.
    /// </param>
    /// <param name="_deleteRecord">
    ///    true if the source dimension record must be deleted; optional.
    /// </param>
    /// <returns>
    ///    The list of destination dimension attribute IDs in the correct order.
    /// </returns>
    /// <remarks>
    ///    All records in the dimension table are deleted.
    /// </remarks>
    public List getDimensionsAttributes(TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute, boolean _deleteRecord = true)
    {
        DimensionAttribute  dimAttr;
        List                dimAttrIds;

        dimAttrIds = new List(Types::Int64);
        while select _consolidationDimensionAttribute
            order by _consolidationDimensionAttribute.LocalRecId
        {
            select firstonly RecId from dimAttr where dimAttr.Name == _consolidationDimensionAttribute.Name;
            dimAttrIds.addEnd(dimAttr.RecId);

            if (_deleteRecord)
            {
                // Clear record so it won't be processed in next company  (Note: consolidationDimAttr.LegalEntity is not being set by import)
                _consolidationDimensionAttribute.delete();
            }
        }

        return dimAttrIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    boolean getFromDialog()
    {
        mayBeExecuted = true;
        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a ledger dimension for the specified account and dimension values.
    /// </summary>
    /// <param name="_companyId">
    /// The data area ID for the dimension values.
    /// </param>
    /// <param name="_accountNum">
    /// The main account for the combination.
    /// </param>
    /// <param name="_mainAccountDimensionAttributeValueId">
    /// The record ID of the <c>DimensionAttributeValue</c> record corresponding to the main account.
    /// </param>
    /// <param name="_mainAccountDimensionAttributeValueHashKey">
    /// The hash key of the <c>DimensionAttributeValue</c> record corresponding to the main account.
    /// </param>
    /// <param name="_localSumTransactionId">
    /// The local record ID of the <c>TmpLedgerConsTrans</c> record.
    /// </param>
    /// <param name="_consolidationDimensionValueItem">
    /// The table holding dimension values.
    /// </param>
    /// <returns>
    /// The ledger dimension for the combination.
    /// </returns>
    protected LedgerDimensionAccount getLedgerDimension(
        CompanyId                           _companyId,
        MainAccountNum                      _accountNum,
        recId                               _mainAccountDimensionAttributeValueId,
        HashKey                             _mainAccountDimensionAttributeValueHashKey,
        recId                               _localSumTransactionId,
        TmpLedgerConsDimensionValueItem     _consolidationDimensionValueItem)
    {
        recId                       destinationDimAttrId;
        Map                         dimensionValues;

        // Extract rule dimension values
        dimensionValues = new Map(Types::Int64, Types::String);

        while select LocalConsDimensionAttribute, Value from _consolidationDimensionValueItem
            where _consolidationDimensionValueItem.LocalConsTrans == _localSumTransactionId
        {
            destinationDimAttrId = sourceToConsDimAttrTranslation.lookup(_consolidationDimensionValueItem.LocalConsDimensionAttribute);
            dimensionValues.insert(destinationDimAttrId, _consolidationDimensionValueItem.Value);
        }

        return ledgerDimensionBuilder.getLedgerDimension(_accountNum, _mainAccountDimensionAttributeValueId, _mainAccountDimensionAttributeValueHashKey, dimensionValues);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionFromValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a ledger dimension for the specified account and dimension values.
    /// </summary>
    /// <param name="_accountNum">
    /// The main account for the combination.
    /// </param>
    /// <param name="_mainAccountDimensionAttributeValueId">
    /// The record ID of the <c>DimensionAttributeValue</c> record corresponding to the main account.
    /// </param>
    /// <param name="_mainAccountDimensionAttributeValueHashKey">
    /// The hash key of the <c>DimensionAttributeValue</c> record corresponding to the main account.
    /// </param>
    /// <param name="_dimensionValues">
    /// The map containing the dimension values.
    /// </param>
    /// <returns>
    /// The ledger dimension for the combination.
    /// </returns>
    /// <remarks>
    /// Ledger dimensions are only created in the consolidated company.
    /// </remarks>
    public LedgerDimensionAccount getLedgerDimensionFromValues(
        MainAccountNum  _accountNum,
        recId           _mainAccountDimensionAttributeValueId,
        HashKey         _mainAccountDimensionAttributeValueHashKey,
        Map             _dimensionValues)
    {
        return ledgerDimensionBuilder.getLedgerDimension(
            _accountNum,
            _mainAccountDimensionAttributeValueId,
            _mainAccountDimensionAttributeValueHashKey,
            _dimensionValues);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPseudoDimensionAttributeValueId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets a value that can be hashed for the dimension value that is specified.
    /// </summary>
    /// <param name="_lookupTable">
    ///    The cache that is used to store the lookup results so that repeated calls will return the same
    ///    value.
    /// </param>
    /// <param name="_displayValue">
    ///    The display value of the dimension value.
    /// </param>
    /// <returns>
    ///    A unique hash key value for each unique dimension value.
    /// </returns>
    /// <remarks>
    ///    The return value is used when a combination hash is created where the dimension value does not have
    ///    a <c>DimensionAttributeValue</c> record. As the combination is stored in a shredded format and not
    ///    in the standard combination value, it is not desired to create a real
    ///    <c>DimensionAttributeValue</c> record. This is the reason for the pseudo hash key.
    /// </remarks>
    private HashKey getPseudoDimensionAttributeValueId(Map _lookupTable, DimensionValue _displayValue)
    {
        HashKey hashKey;

        if (_lookupTable.exists(_displayValue))
        {
            hashKey = _lookupTable.lookup(_displayValue);
        }
        else
        {
            hashKey = newGuid();
            _lookupTable.insert(_displayValue, hashKey);
        }

        return hashKey;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectedDimensionAttributes</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the selected dimension attributes from source consolidation dimension.
    /// </summary>
    /// <param name = "_companyId">
    /// The company ID.
    /// </param>
    /// <param name = "_consolidationDimensionAttribute">
    /// A <c>TmpLedgerConsDimensionAttribute</c> table buffer.
    /// </param>
    [Wrappable(true)]
    protected final void getSelectedDimensionAttributes(CompanyId _companyId, TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute)
    {
        DimensionAttribute dimAttr;
        LedgerConsolidateSourceDimension ledgerConsolidateSourceDimension;

        // Fill {TmpLedgerConsDimensionAttribute, sourceDimAttrIdLookupTable
        sourceDimAttrIdLookupTable = new Map(Types::Int64, Types::Int64);
        sourceToConsDimAttrTranslation = new Map(Types::Int64, Types::Int64);
        while select Name, RecId from dimAttr
                order by ledgerConsolidateSourceDimension.Ordinal
            join RecId from ledgerConsolidateSourceDimension
                where ledgerConsolidateSourceDimension.DimensionAttribute == dimAttr.RecId &&
                        ledgerConsolidateSourceDimension.Specification != LedgerConsDim::None
        {
            consDimAttrLocalRecId++;
            _consolidationDimensionAttribute.LocalRecId = consDimAttrLocalRecId;
            _consolidationDimensionAttribute.Name = dimAttr.Name;
            _consolidationDimensionAttribute.LegalEntity = _companyId;
            _consolidationDimensionAttribute.insert();
            sourceDimAttrIdLookupTable.insert(dimAttr.RecId, _consolidationDimensionAttribute.LocalRecId);
            sourceToConsDimAttrTranslation.insert(_consolidationDimensionAttribute.LocalRecId, dimAttr.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importTransact</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports transactions for the consolidation.
    /// </summary>
    /// <param name = "_companyId">
    /// The company ID.
    /// </param>
    /// <param name = "_filename">
    /// The full path to the file that contains transactions for the consolidation.
    /// </param>
    /// <param name = "_sumTransact">
    /// The <c>TmpLedgerConsTrans</c> table buffer that will contain the ledger transactions to consolidate.
    /// </param>
    /// <param name = "_consolidationDimensionValueItem">
    /// A <c>TmpLedgerConsDimensionValueItem</c> table buffer.
    /// </param>
    /// <param name = "_consolidationDimensionAttribute">
    /// A <c>TmpLedgerConsDimensionAttribute</c> table buffer.
    /// </param>
    /// <param name = "_proportion">
    /// The percentage of the specified company to include in the consolidation.
    /// </param>
    protected void importTransact(
        CompanyId                       _companyId,
        Filename                        _filename,
        TmpLedgerConsTrans              _sumTransact,
        TmpLedgerConsDimensionValueItem _consolidationDimensionValueItem,
        TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute,
        Percent                         _proportion
        )
    {
        DimensionAttribute  dimAttr;
        LedgerConsolidateFile consolidateFile = LedgerConsolidateFile::construct();
        consolidateFile.import(_filename);
        this.unPackTables(consolidateFile.packTables(), _sumTransact, _consolidationDimensionValueItem, _consolidationDimensionAttribute);

        // Compare company id with value filled by unPackTables
        if (_companyId != companyOrigin)
        {
            // The company listed in the import file is not source company %1.  Choose a different file name.
            throw error(strFmt("@SYS303742", _companyId));
        }

        // Compare source dimensions in import file with system dimensions
        sourceDimAttrIdLookupTable = new Map(Types::Int64, Types::Int64);
        sourceToConsDimAttrTranslation = new Map(Types::Int64, Types::Int64);

        while select Name, LocalRecId from _consolidationDimensionAttribute
            order by _consolidationDimensionAttribute.LocalRecId
        {
            select firstonly RecId from dimAttr where dimAttr.Name == _consolidationDimensionAttribute.Name;
            if (dimAttr)
            {
                sourceDimAttrIdLookupTable.insert(dimAttr.RecId, _consolidationDimensionAttribute.LocalRecId);
                sourceToConsDimAttrTranslation.insert(_consolidationDimensionAttribute.LocalRecId, dimAttr.RecId);
            }
            else
            {
                // One or more dimensions defined in the consolidations file does not match the current financial dimensions. You must update consolidation financial dimensions before you can process consolidations.
                //     You must update consolidation financial dimensions before you can process consolidations.
                throw error("@SYS303733");
            }
        }

        if (transferBudget)
        {
            // toDate and fromDate are for the full consolidation because LedgerConsMode::Import does not support batch threads

            this.setUpBudgetConsolidationManager();

            budgetConsolidationManager.parmSubsidiaryCompany(companyOrigin);
            // Consolidation Online and Consolidation Import process both has share (proportion)
            // setting for the amount-to-consolidate per subsidiary company.  Set the proportion
            // to perform budget consolidation online or budget consolidation import process.
            budgetConsolidationManager.parmProportion(_proportion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    public void initParmDefault()
    {
        super();

        // Default the process full balance rebuild to true when no sys last values exist.
        processFullBalanceRebuild = NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>intializeLedgerDimensionBuilder</Name>
				<Source><![CDATA[
    private void intializeLedgerDimensionBuilder(TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute, boolean _deleteRecord = true)
    {
        DimensionAttribute              dimAttr;
        DimensionAttributeDirCategory   dimAttrDirCategory;
        FinancialTagCategory            financialTagCategory;
        DimensionAttributeSetStorage    dimAttrSetStorage;
        List                            dimAttrIds;
        ListEnumerator                  dimAttrEnumerator;
        recId                           dimAttrId;
        boolean                         destinationNeeded;

        dimAttrIds = this.getDimensionsAttributes(_consolidationDimensionAttribute, _deleteRecord);
        destinationNeeded = (mode == LedgerConsMode::Import) || (mode == LedgerConsMode::Online);

        tagCategoryLookupTable = new Map(Types::Int64, Types::Int64);
        dimAttrSetStorage = new DimensionAttributeSetStorage();
        dimAttrEnumerator = dimAttrIds.getEnumerator();
        while (dimAttrEnumerator.moveNext())
        {
            dimAttrId = dimAttrEnumerator.current();
            dimAttr = DimensionAttribute::find(dimAttrId);
            dimAttrSetStorage.addItem(dimAttr.RecId, dimAttr.HashKey, NoYes::Yes);

            if (destinationNeeded)
            {
                select firstonly RecId from dimAttr
                        where dimAttr.BackingEntityType == tableNum(DimensionFinancialTag) &&
                            dimAttr.RecId == dimAttrId
                    join RecId from dimAttrDirCategory
                        where dimAttrDirCategory.DimensionAttribute == dimAttr.RecId
                    join RecId from financialTagCategory
                        where dimAttrDirCategory.DirCategory == financialTagCategory.RecId;

                if (dimAttr)
                {
                    tagCategoryLookupTable.insert(dimAttr.RecId, financialTagCategory.RecId);
                }
            }
        }
        dimensionAttributeSetId = dimAttrSetStorage.save();

        ledgerDimensionBuilder = LedgerDimensionBuilder::construct(dimensionAttributeSetId);
        ledgerDimensionBuilder.setDimensionAttributes(dimAttrIds);
        ledgerDimensionBuilder.setTagCategories(tagCategoryLookupTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransferOnly_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the ledger consolidation should be done by transaction level.
    /// </summary>
    /// <returns>
    /// True if the ledger consolidation should be done by transaction level; otherwise, false.
    /// </returns>
    public boolean isTransferOnly_BR()
    {
        return BrazilParameters::isEnabled() && transferTransactionsOnly_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueUserId</Name>
				<Source><![CDATA[
    public userId lastValueUserId()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>mode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the consolidation mode.
    /// </summary>
    /// <returns>The consolidation mode.</returns>
    LedgerConsMode mode()
    {
        return mode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        if (companyDimensionMapping)
        {
            packedCompanyDimensionMapping = companyDimensionMapping.pack();
        }

        return [CurrentVersion, #CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>packTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Packs the information for the consolidation into a container. Used by the export consolidation function.
    /// </summary>
    /// <param name = "_companyId">
    /// The company ID.
    /// </param>
    /// <param name = "_sumTransact">
    /// The <c>TmpLedgerConsTrans</c> table buffer that will contain the ledger transactions to consolidate.
    /// </param>
    /// <param name = "_consolidationDimensionValueItem">
    /// A <c>TmpLedgerConsDimensionValueItem</c> table buffer.
    /// </param>
    /// <param name = "_consolidationDimensionAttribute">
    /// A <c>TmpLedgerConsDimensionAttribute</c> table buffer.
    /// </param>
    /// <returns>
    /// A container with all the information for the consolidation.
    /// </returns>
    protected container packTables(
        CompanyId                       _companyId,
        TmpLedgerConsTrans              _sumTransact,
        TmpLedgerConsDimensionValueItem _consolidationDimensionValueItem,
        TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute
        )
    {
        MainAccount     mainAccount;

        List            listTrans = new List(Types::Record);
        List            listDimensionValues = new List(Types::Record);
        List            listDimensions = new List(Types::Record);
        container       packedBudgetConsolidationManager;
        Map             mapAccounts = new Map(Types::String, Types::Record);

        //  Begin - inline methods
        void saveAccount(MainAccountNum account)
        {
            if (!companyGroupAccounts)
            {
                if (!mapAccounts.exists(account))
                {
                    mainAccount = MainAccount::findByMainAccountId(account);

                    mapAccounts.insert(account,mainAccount.data());
                }
            }
        }
        //  End - inline methods

        while select _sumTransact where _sumTransact.TmpDataAreaId == _companyId
        {
            saveAccount(_sumTransact.MainAccountId);
            listTrans.addEnd(_sumTransact.data());
        }

        while select _consolidationDimensionValueItem where _consolidationDimensionValueItem.LegalEntity == _companyId
        {
            listDimensionValues.addEnd(_consolidationDimensionValueItem.data());
        }

        while select _consolidationDimensionAttribute where _consolidationDimensionAttribute.LegalEntity == _companyId
        {
            listDimensions.addEnd(_consolidationDimensionAttribute.data());
        }

        if (transferBudget)
        {
            budgetConsolidationManager.parmConsolidationAccounts(mapAccounts);
            // Pack budget transactions to be exported and collect the consolidated ledger accounts information
            packedBudgetConsolidationManager = budgetConsolidationManager.pack();
            // Transfer the consolidated ledger accounts information back
            mapAccounts = budgetConsolidationManager.parmConsolidationAccounts();
        }

        return [listDimensions.pack(), listTrans.pack(), listDimensionValues.pack(), packedBudgetConsolidationManager, mapAccounts.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetExchangeRateType</Name>
				<Source><![CDATA[
    public recId parmBudgetExchangeRateType(recId _budgetExchangeRateType = budgetExchangeRateType)
    {
        budgetExchangeRateType = _budgetExchangeRateType;

        return budgetExchangeRateType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmConsolidateAccountGroup</Name>
				<Source><![CDATA[
    public LedgerConsolidateAccountGroupRecId parmConsolidateAccountGroup(LedgerConsolidateAccountGroupRecId _consolidateAccountGroup = consolidateAccountGroup)
    {
        consolidateAccountGroup = _consolidateAccountGroup;

        return consolidateAccountGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEliminations</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the elimination container.
    /// </summary>
    /// <param name="_eliminations">
    ///    The elimination container that contains values that are used when the class variable is set;
    ///    optional.
    /// </param>
    /// <returns>
    ///    A container that contains the eliminations rules.
    /// </returns>
    public container parmEliminations(container _eliminations = eliminations)
    {
        eliminations = _eliminations;
        return eliminations;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGlPostingDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the date value from the form into the class variable.
    /// </summary>
    /// <param name="_glPostingDate">
    ///    The date value from the form; optional.
    /// </param>
    /// <returns>
    ///    The date value of the class variable.
    /// </returns>
    public TransDate parmGlPostingDate(TransDate _glPostingDate  = glPostingDate)
    {
        glPostingDate  = _glPostingDate;

        return glPostingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsChildBatchFinalTask</Name>
				<Source><![CDATA[
    public boolean parmIsChildBatchFinalTask(boolean _isChildBatchFinalTask = isChildBatchFinalTask)
    {
        isChildBatchFinalTask = _isChildBatchFinalTask;
        return isChildBatchFinalTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsChildBatchRuntimeTask</Name>
				<Source><![CDATA[
    public boolean parmIsChildBatchRuntimeTask(boolean _isChildBatchRuntimeTask = isChildBatchRuntimeTask)
    {
        isChildBatchRuntimeTask = _isChildBatchRuntimeTask;
        return isChildBatchRuntimeTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerConsMode</Name>
				<Source><![CDATA[
    LedgerConsMode parmLedgerConsMode(LedgerConsMode _mode =  LedgerConsMode::Online)
    {
        mode = _mode;
        return mode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessFullBalanceRebuild</Name>
				<Source><![CDATA[
    public NoYes parmProcessFullBalanceRebuild(NoYes _processFullBalanceRebuild = processFullBalanceRebuild)
    {
        processFullBalanceRebuild = _processFullBalanceRebuild;
        return processFullBalanceRebuild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the processing mode value from the form into the class variable.
    /// </summary>
    /// <param name="_processMode">
    ///    The processing mode value from the form; optional.
    /// </param>
    /// <returns>
    ///    The processing mode value of the class variable.
    /// </returns>
    public LedgerEliminationProcessMode parmProcessMode(LedgerEliminationProcessMode _processMode = processMode)
    {
        processMode = _processMode;

        return processMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleaseDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value from the form to the class variable.
    /// </summary>
    /// <param name="_releaseDate">
    ///    The release date value from the form; optional.
    /// </param>
    /// <returns>
    ///    The release date value of the class variable.
    /// </returns>
    public PostReleaseDate parmReleaseDate(PostReleaseDate _releaseDate  = releaseDate)
    {
        releaseDate  = _releaseDate;

        return releaseDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransferTransactionsOnly_BR</Name>
				<Source><![CDATA[
    NoYes parmTransferTransactionsOnly_BR(NoYes _transferTransactionsOnly = transferTransactionsOnly_BR)
    {
        transferTransactionsOnly_BR = _transferTransactionsOnly;
        return transferTransactionsOnly_BR;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Launches the posting process for the specified journal.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal to post
    /// </param>
    /// <param name="_succeeded">
    ///    A Boolean value that indicates whether the journal should be posted.
    /// </param>
    protected void postJournal(LedgerJournalId _journalNum, boolean _succeeded)
    {
        LedgerJournalCheckPost  ledgerJournalCheckPost;

        // relase the blocking flag or the journal will not post
        this.releaseJournal(_journalNum);

        if (_succeeded)
        {
            ttsbegin;

            ledgerJournalCheckPost = LedgerJournalCheckPost::construct(LedgerJournalType::Elimination);
            ledgerJournalCheckPost.parmJournalNum(_journalNum);
            ledgerJournalCheckPost.parmPost(true);

            LedgerJournalCheckPost::processOperation(ledgerJournalCheckPost);

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTmpLedgerConsTransWrite_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes after the tmpLedgerConsTransWrite method.
    /// </summary>
    /// <param name="_transact">
    /// The <c>TmpLedgerConsTrans</c> record from the tmpLedgerConsTransWrite method.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record from the tmpLedgerConsTransWrite method.
    /// </param>
    /// <param name="_generalJournalEntry">
    /// The <c>GeneralJournalEntry</c> record from the tmpLedgerConsTransWrite method.
    /// </param>
    public void postTmpLedgerConsTransWrite_BR(
        TmpLedgerConsTrans          _transact,
        GeneralJournalAccountEntry  _generalJournalAccountEntry,
        GeneralJournalEntry         _generalJournalEntry)
    {
        SubledgerVoucherGeneralJournalEntry voucher;

        ttsBegin;

        voucher = SubledgerVoucherGeneralJournalEntry::findByGeneralJournalEntry(_generalJournalEntry);

        _transact.ConsolidatedVoucher_BR    = voucher.Voucher;
        _transact.DocumentDate_BR           = _generalJournalEntry.DocumentDate;
        _transact.DocumentNumber_BR         = _generalJournalEntry.DocumentNumber;
        _transact.JournalCategory_BR        = _generalJournalEntry.JournalCategory;
        _transact.ConsolidatedRefRecId_BR   = _generalJournalAccountEntry.RecId;
        _transact.IsCorrection_BR           = _generalJournalAccountEntry.IsCorrection;
        _transact.PostingType_BR            = _generalJournalAccountEntry.PostingType;
        _transact.Text_BR                   = _generalJournalAccountEntry.Text;

        _transact.write();

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processEliminationJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the specified processing on the journals created during elimination processing.
    /// </summary>
    /// <param name="_processingOption">
    ///    The processing option to perform.
    /// </param>
    /// <remarks>
    ///    The processing options are release, post, and delete.
    /// </remarks>
    protected void processEliminationJournal(int _processingOption)
    {
        int             elimationContainerIdx;
        int             eliminationJournalCount;
        CompanyId       journalCompany;
        LedgerJournalId journalNum;
        container       errorsLogged;
        boolean         errorsExist;
        boolean         succeeded;

        try
        {
            // a retry clears out the infolog so we must restore from the container if errors did exist
            if (errorsExist)
            {
                infolog.import(errorsLogged);
                errorsExist = false;
            }

            while (eliminationJournalCount < numberOfEliminationJournals)
            {
                eliminationJournalCount++;

                // get the rule, journal number, company and success of the processing
                elimationContainerIdx++;
                eliminationRule = conPeek(ledgerEliminationJournals,elimationContainerIdx);
                elimationContainerIdx++;
                journalNum = conPeek(ledgerEliminationJournals,elimationContainerIdx);
                elimationContainerIdx++;
                journalCompany = conPeek(ledgerEliminationJournals,elimationContainerIdx);
                elimationContainerIdx++;
                succeeded = conPeek(ledgerEliminationJournals,elimationContainerIdx);

                if (journalCompany == curext())
                {
                    switch (_processingOption)
                    {
                        case LedgerConsolidateDefinitions::EliminateRelease:
                            this.releaseJournal(journalNum);
                            break;
                        case LedgerConsolidateDefinitions::EliminateDelete:
                            this.deleteJournal(journalNum);
                            break;
                        case LedgerConsolidateDefinitions::EliminatePost:
                            this.postJournal(journalNum,succeeded);
                            break;
                        default :
                            break;
                    }
                }
                else
                {
                    changecompany(journalCompany)
                    {
                        switch (_processingOption)
                        {
                            case LedgerConsolidateDefinitions::EliminateRelease:
                                this.releaseJournal(journalNum);
                                break;
                            case LedgerConsolidateDefinitions::EliminateDelete:
                                this.deleteJournal(journalNum);
                                break;
                            case LedgerConsolidateDefinitions::EliminatePost:
                                this.postJournal(journalNum,succeeded);
                                break;
                            default :
                                break;
                        }
                    }
                }
            }
        }
        catch (Exception::Error)
        {
            errorsExist = true;

            // save the errors in a container so they can be restored
            errorsLogged = infolog.export();

            retry;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processEliminationRules</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the steps that are required to process the elimination rules.
    /// </summary>
    /// <remarks>
    ///    The set of steps are as follows:
    ///    <list type="number">
    ///       <item>
    ///          <description>All rules are validated before any rule is processed.</description>
    ///       </item>
    ///       <item>
    ///          <description>All the rules are run. If an error is encountered, all journals are deleted and
    ///          processing is stopped.</description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             The <c>datelastrun</c> value is updated for each elimination rule processed.
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>The journals are either posted or made available to modify.</description>
    ///       </item>
    ///    </list>
    /// </remarks>
    protected void processEliminationRules()
    {
        int         eliminationJournalIdx;
        container   ledgerEliminationResult;
        container   errorsLogged;
        boolean     errorsExist;

        this.validateFullConsolidationDateRange();

        numberOfEliminationRules = conLen(eliminations);

        try
        {
            // a retry clears out the infolog so we must restore from the container if errors did exist
            if (errorsExist)
            {
                infolog.import(errorsLogged);
                errorsExist = false;
            }
            // Warning occur if release date is greater than session date.
            if (releaseDate > DateTimeUtil::utcNow())
            {
                info("@SYS114915");
            }
            while (eliminationJournalIdx < numberOfEliminationRules)
            {
                eliminationJournalIdx++;
                [eliminationRule,reasonRefRecID] = conPeek(eliminations,eliminationJournalIdx);

                // only process valid rules
                if (LedgerEliminationRule::validateEliminationRule(eliminationRule, toDate, glPostingDate))
                {
                    ledgerEliminationProcessRule = LedgerEliminationProcessRule::construct();

                    // processElimination throws errors so no return is required
                    ledgerEliminationResult = ledgerEliminationProcessRule.processElimination(eliminationRule,
                                                                fromDate,
                                                                toDate,
                                                                glPostingDate,
                                                                releaseDate,
                                                                reasonRefRecID);

                    // Add the processing result to the journals container
                    ledgerEliminationJournals += ledgerEliminationResult;
                    numberOfEliminationJournals++;
                }
                else
                {
                    error("@SYS108432");
                    error(strFmt("@SYS108433",eliminationRule));
                }
            }
        }
        catch (Exception::Error)
        {
            errorsExist = true;

            error(strFmt("@SYS108433",eliminationRule));
            // save the errors in a container so they can be restored
            errorsLogged = infolog.export();

            retry;
        }

        // all the processing succeeded
        this.updateEliminationDateLastRun();

        if (processMode == LedgerEliminationProcessMode::PostOnly)
        {
            this.processEliminationJournal(LedgerConsolidateDefinitions::EliminatePost);
        }
        else
        {
            this.processEliminationJournal(LedgerConsolidateDefinitions::EliminateRelease);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFinalTasks</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Processes the final consolidation tasks.
    /// </summary>
    protected void processFinalTasks()
    {
        this.validateFullConsolidationDateRange();
        
        // now process elimination rules selected if Online
        if ((mode == LedgerConsMode::Online) && conLen(eliminations) > 0)
        {
            this.processEliminationRules();
        }

        if ((mode == LedgerConsMode::Import || mode == LedgerConsMode::Online) && processFullBalanceRebuild)
        {
            if (Dynamics.AX.Application.FeatureStateProvider::IsFeatureEnabled(GeneralLedgerBalanceFeature::instance()))
            {
                GeneralLedgerBalanceWork::scheduleRebuildBalancesForLedger(
                    Ledger::current(),
                    fromDate,
                    toDate,
                    LedgerConsolidate::description());
            }
            else
            {
                // Rebuild the balances of all the initialized dimension sets in the consolidation company.
                // The balances must be rebuilt because the dimension set balances update process does
                // not support updating balances when general journal records are deleted.
                if (this.parmCurrentBatch().BatchJobId)
                {
                    DimensionFocusInitializeBalance::saveBatchDetails(this.parmCurrentBatch().BatchJobId, LedgerConsolidate::description());
                }

                DimensionFocusBalanceRebuildDateContract dimensionFocusBalanceRebuildDateContract = new DimensionFocusBalanceRebuildDateContract();
                dimensionFocusBalanceRebuildDateContract.parmLedgerRecId(Ledger::current());
                dimensionFocusBalanceRebuildDateContract.parmFromDate(fromDate);
                dimensionFocusBalanceRebuildDateContract.parmToDate(toDate);

                DimensionFocusInitializeBalance::processFullRebuildWithDateContract(dimensionFocusBalanceRebuildDateContract);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processFullBalanceRebuild</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ProcessFullBalanceRebuild</c> parameter.
    /// </summary>
    /// <param name="_processFullBalanceRebuild">
    ///    The value to set.
    /// </param>
    /// <returns>
    ///    The value of the <c>ProcessFullBalanceRebuild</c> parameter.
    /// </returns>
    public NoYes processFullBalanceRebuild(NoYes _processFullBalanceRebuild = processFullBalanceRebuild)
    {
        processFullBalanceRebuild = _processFullBalanceRebuild;
        return processFullBalanceRebuild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the system blocked field in the journal so that it can be edited.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal to update.
    /// </param>
    /// <remarks>
    ///    This method should be called in the company in which the journal exists.
    /// </remarks>
    protected void releaseJournal(LedgerJournalId _journalNum)
    {
        LedgerJournalTable  ledgerJournalTablelocal;

        ttsbegin;

        // release the header
        ledgerJournalTablelocal = LedgerJournalTable::find(_journalNum,true);

        if (ledgerJournalTablelocal)
        {
            ledgerJournalTablelocal.SystemBlocked = false;
            ledgerJournalTablelocal.update();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDualCurrencyEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if dual currency is used
    /// </summary>
    /// <returns>true if consolidate amount source is accounting currency and consolidate accounting currency is accounting currency amount; otherwise, false.</returns>
    public boolean isDualCurrencyEnabled()
    {
        return (consolidationAmountSource == LedgerConsolidateAmountSource::AccountingCurrencyAmount && consolidateAccountingCurrency == LedgerConsolidateAccountingCurrency::UseAccountingCurrencyAmount)
            || (consolidationAmountSource == LedgerConsolidateAmountSource::ReportingCurrencyAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that does the actual job of the class.
    /// </summary>
    void run()
    {
        #avifiles

        MainAccount                             mainAccount;
        TmpLedgerConsTrans                      sumTransact;
        TmpLedgerConsDimensionValueItem         consolidationDimValueItem;
        TmpLedgerConsDimensionAttribute         consolidationDimAttr;
        int                                     idx;
        Percent                                 proportion;
        BalanceProfitLoss                       balanceProfitLoss;
        Filename                                filename;

        LedgerConsolidate                       childConsolidateFinal;
        BatchHeader                             batchHeader;

        logger = SysInstrumentationLoggerFactory::CreateLogger(classStr(LedgerConsolidate));
        monitor = LedgerConsolidatePerformanceMonitor::construct(logger);
        monitor.parmConsolidationId(ledgerConsolidateHistRecId);

        if (BrazilParameters::isEnabled())
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00070, funcName());
        }

        // check the feature here so the child tasks have the value
        useDualCurrency = this.isDualCurrencyEnabled();
        useParallelProcessingFeature = FeatureStateProvider::isFeatureEnabled(LedgerConsolidateParallelProcessingFeature::instance());

        if (!useDualCurrency)
        {
            // consolidationAmountSource is forced to AccountingCurrencyAmount for a legacy consolidation
            consolidationAmountSource = LedgerConsolidateAmountSource::AccountingCurrencyAmount;
        }

        if (isChildBatchRuntimeTask)
        {
            // Only run the child runtime task as all details were intialized for
            // the task by the parent consolidation task that generated it.
            if (isChildBatchFinalTask)
            {
                this.processFinalTasks();
            }
            else
            {
                if (mode == LedgerConsMode::Online &&
                    companyDimensionMapping.elements() == 0)
                {
                    // Get the dimension mapping as it was not packed by the parent task.
                    companyDimensionMapping = LedgerConsolidateSourceDimension::getCompanyDimensionMapping(curext());
                }

                this.sumAndTransfer(sumTransact, consolidationDimAttr, consolidationDimValueItem);
            }

            return;
        }

        if (! this.validate())
        {
            return;
        }

        // Consolidation process runs in consolidated company (setup constants for this process)
        consolidatedCompany = strUpr(curext());
        dimAttrMainAccountId = DimensionAttribute::getWellKnownDimensionAttribute(DimensionAttributeType::MainAccount);

        // Initialize local RecId's
        consDimAttrLocalRecId = 0;
        consTransLocalRecId = 0;

        errorAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(LedgerSystemAccounts::defaultAccount(LedgerPostingType::ErrorAccount)).MainAccountId;

        if (!fromDate)
        {
            fromDate = dateNull();
        }

        if (!toDate)
        {
            toDate = dateMax();
        }

        if (mode == LedgerConsMode::export)
        {
            companyDimensionMapping = LedgerConsolidateSourceDimension::getCompanyDimensionMapping(curext());

            ttsbegin;

            while (idx < conLen(companies))
            {
                idx++;

                [companyId, proportion, balanceProfitLoss, filename] = conPeek(companies,idx);

                this.getSelectedDimensionAttributes(companyId, consolidationDimAttr);
                this.intializeLedgerDimensionBuilder(consolidationDimAttr, false);

                companyDimensionEnumerator = companyDimensionMapping.getEnumerator();
                this.sumUpTransact(companyId, sumTransact, consolidationDimValueItem, proportion);
                str exportedFile = this.exportTransact(companyId, filename, sumTransact, consolidationDimValueItem, consolidationDimAttr);

                exportedFileURLs += exportedFile;

                delete_from consolidationDimAttr
                    where consolidationDimAttr.LegalEntity == companyId;
            }

            ttscommit;
        }
        else
        {
            if (mode == LedgerConsMode::Online)
            {
                companyDimensionMapping = LedgerConsolidateSourceDimension::getCompanyDimensionMapping(curext());
            }

            this.checkForExistingConsolidations();

            // Delete all existing data before processing the new data.
            this.deleteDataAllCompanies();

            if (this.isInBatch())
            {
                // Create child runtime tasks for each company in the batch.
                batchHeader = this.getBatchHeader();

                // Add a final task based on the settings from the parent batch task.
                childConsolidateFinal = this.createLedgerConsolidateFinalTask();

                batchHeader.addRuntimeTask(childConsolidateFinal, this.parmCurrentBatch().RecId);

                for (idx = 1; idx <= conLen(companies); idx++)
                {
                    container ledgerConsolidateCompanies = conPeek(companies, idx);
                    companyId = conPeek(ledgerConsolidateCompanies, 1);

                    // Preallocate the history record and provide it to the child task(s)
                    // because we want 1 history per company but may have n child tasks
                    ledgerConsolidateHist = this.createLedgerConsolidateHistory(companyId);

                    // Create a child task per company based on the settings of the parent batch task
                    LedgerConsolidate childConsolidateCompany = new LedgerConsolidate();
                    childConsolidateCompany.unpack(this.pack());
                    childConsolidateCompany.parmIsChildBatchRuntimeTask(true);
                    childConsolidateCompany.companies([ledgerConsolidateCompanies]);
                    childConsolidateCompany.ledgerConsolidateHistRecId = ledgerConsolidateHist.RecId;
                    // save the full consolidation fromDate and toDate because they may be needed later
                    childConsolidateCompany.fullConsolidationFromDate = childConsolidateCompany.fromDate();
                    childConsolidateCompany.fullConsolidationToDate = childConsolidateCompany.toDate();
                    // Notes
                    // 1) this batch task is a template for the date chunks when useParallelProcessingFeature is true
                    // 2) this batch task is created when useParallelProcessingFeature is false

                    if (useParallelProcessingFeature)
                    {
                        // Divide the date range into smaller ranges, roughly weeks
                        LedgerConsolidateDateRanges ledgerConsolidateDateRanges = this.getBatchTaskDateRanges(companyId);
                        if (ledgerConsolidateDateRanges == null)
                        {
                            throw error("@GeneralLedger:LedgerConsolidateDateRangesNoRanges");
                        }

                        // Queue one consolidation per company, date range (week)
                        List dateRangesList = ledgerConsolidateDateRanges.getDateRanges(fromDate, toDate);
                        ListEnumerator dateRangesEnumerator = dateRangesList.getEnumerator();
                        while (dateRangesEnumerator.moveNext())
                        {
                            LedgerConsolidateDateRangeParams dateRange = dateRangesEnumerator.current();
                            TransDate rangeStartDate = dateRange.parmStartDate();
                            TransDate rangeEndDate = dateRange.parmEndDate();

                            // Copy the company task and override the date range and caption
                            LedgerConsolidate childConsolidateCompanyDateRangeChunk = new LedgerConsolidate();
                            childConsolidateCompanyDateRangeChunk.unpack(childConsolidateCompany.pack());
                            childConsolidateCompanyDateRangeChunk.fromDate(rangeStartDate);
                            childConsolidateCompanyDateRangeChunk.toDate(rangeEndDate);
                            // ledgerConsolidateHistRecId is inherited from childConsolidateCompany
                            // fullConsolidationToDate is inherited from childConsolidateCompany
                            // fullConsolidationFromDate is inherited from childConsolidateCompany
                            
                            // e.g. Consolidating legal entity <company> for <start date>..<end date>
                            childConsolidateCompanyDateRangeChunk.batchInfo().parmCaption(strFmt("@SYS4080919", companyId, strFmt("@SYS342745", rangeStartDate, rangeEndDate)));
                            
                            batchHeader.addRuntimeTask(childConsolidateCompanyDateRangeChunk, this.parmCurrentBatch().RecId);

                            // Update the final task to be dependent on the child runtime task.
                            batchHeader.addDependency(childConsolidateFinal, childConsolidateCompanyDateRangeChunk, BatchDependencyStatus::Finished);
                        }
                    }
                    else
                    {
                        // Queue one consolidation per company
                        childConsolidateCompany.batchInfo().parmCaption(strFmt("@SYS4080919", companyId, this.parmCurrentBatch().Caption));
                        batchHeader.addRuntimeTask(childConsolidateCompany, this.parmCurrentBatch().RecId);

                        // Update the final task to be dependent on the child runtime task
                        batchHeader.addDependency(childConsolidateFinal, childConsolidateCompany, BatchDependencyStatus::Finished);
                    }
                }

                batchHeader.save();
            }
            else
            {
                this.sumAndTransfer(sumTransact, consolidationDimAttr, consolidationDimValueItem);

                this.processFinalTasks();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchHeader</Name>
				<Source><![CDATA[
    protected BatchHeader getBatchHeader()
    {
        return BatchHeader::getCurrentBatchHeader();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerConsolidateFinalTask</Name>
				<Source><![CDATA[
    protected LedgerConsolidate createLedgerConsolidateFinalTask()
    {
        LedgerConsolidate ledgerConsolidate = new LedgerConsolidate();
        ledgerConsolidate.unpack(this.pack());
        ledgerConsolidate.parmIsChildBatchRuntimeTask(true);
        ledgerConsolidate.parmIsChildBatchFinalTask(true);
        ledgerConsolidate.batchInfo().parmCaption(strFmt("@SYS4080918", this.parmCurrentBatch().Caption));

        return ledgerConsolidate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMayExecute</Name>
				<Source><![CDATA[
    void setMayExecute(boolean newValue)
    {
        mayBeExecuted = newValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setUpBudgetConsolidationManager</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets up the <c>BudgetConsolidationManager</c> instance to manage budget consolidation process.
    /// </summary>
    private void setUpBudgetConsolidationManager()
    {
        if (budgetConsolidationManager == null)
        {
            budgetConsolidationManager = new BudgetConsolidationManager();
        }

        budgetConsolidationManager.parmLedgerConsolidate(this);
        budgetConsolidationManager.parmConsolidatedCompany(consolidatedCompany);
        budgetConsolidationManager.parmConsolidationMode(mode);
        budgetConsolidationManager.parmFromBudgetModelId(fromModel);
        budgetConsolidationManager.parmFromConsolidationAccount(fromAccount);
        budgetConsolidationManager.parmFromDate(fromDate);
        budgetConsolidationManager.parmToBudgetModelId(toModel);
        budgetConsolidationManager.parmToConsolidationAccount(toAccount);
        budgetConsolidationManager.parmToDate(toDate);
        budgetConsolidationManager.parmUseConsolidationAccount(companyGroupAccounts);
        budgetConsolidationManager.parmDescription(description);
        budgetConsolidationManager.parmLedgerDimensionBuilder(ledgerDimensionBuilder);
        budgetConsolidationManager.parmBudgetExchangeRateType(budgetExchangeRateType);
        budgetConsolidationManager.parmConsolidationHistoryRecId(ledgerConsolidateHist.RecId);
        budgetConsolidationManager.parmErrorAccount(errorAccount);
        budgetConsolidationManager.parmConsolidateAccountGroup(consolidateAccountGroup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumAndTransfer</Name>
				<Source><![CDATA[
    private void sumAndTransfer(
        TmpLedgerConsTrans              _sumTransact,
        TmpLedgerConsDimensionAttribute _consolidationDimAttr,
        TmpLedgerConsDimensionValueItem _consolidationDimValueItem)
    {
        int                                     idx;
        Percent                                 proportion;
        BalanceProfitLoss                       balanceProfitLoss;
        Filename                                filename;
        LedgerPostingGeneralJournalController   generalJournalController;

        try
        {
            while (idx < conLen(companies))
            {
                idx++;

                [companyId, proportion, balanceProfitLoss, filename] = conPeek(companies,idx);

                if (ledgerConsolidateHistRecId)
                {
                    // Batch child tasks have supplied ledgerConsolidateHistRecId to support partitioned work.
                    ledgerConsolidateHist = LedgerConsolidateHist::find(ledgerConsolidateHistRecId);

                    // History not found or does not match
                    if (ledgerConsolidateHist.RecId != ledgerConsolidateHistRecId)
                    {
                        throw error(error::wrongUseOfFunction(funcName()));
                    }
                }
                else
                {
                    ledgerConsolidateHist = this.createLedgerConsolidateHistory(companyId);
                }

                if (mode == LedgerConsMode::Online)
                {
                    this.getSelectedDimensionAttributes(companyId, _consolidationDimAttr);
                    this.intializeLedgerDimensionBuilder(_consolidationDimAttr);
                    companyDimensionEnumerator = companyDimensionMapping.getEnumerator();

                    this.sumUpTransact(companyId, _sumTransact, _consolidationDimValueItem, proportion);
                }
                else
                {
                    if (mode == LedgerConsMode::Import)
                    {
                        this.importTransact(companyId, filename, _sumTransact, _consolidationDimValueItem, _consolidationDimAttr, proportion);
                        this.intializeLedgerDimensionBuilder(_consolidationDimAttr);
                    }
                }

                using (SysInstrumentationActivityContext context = monitor.enterTransferConsolidationTransactions())
                {
                    generalJournalController = LedgerPostingGeneralJournalController::construct();
                    this.createTotals(companyId, proportion, balanceProfitLoss, _sumTransact, _consolidationDimValueItem, generalJournalController);
                    generalJournalController.transfer();

                    monitor.exitTransferConsolidationTransactions(context, countOutput);
                }

                // These variables are scoped to a single company
                ledgerConsolidateHistRecId = 0;
                ledgerConsolidateHist = null;
            }
        }
        catch
        {
            // Delete all data to ensure no partial updates were committed.
            // During processing a transaction scope can not be used to rollback the updates
            // due to blocking issues it causes with the shared data creation per consolidated company.
            this.deleteDataAllCompanies();

            throw error("@SYS4080920");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>sumUpTransact</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ledger transactions that will be consolidated for the specified source company.
    /// </summary>
    /// <param name = "_companyId">
    /// The source company ID.
    /// </param>
    /// <param name = "_transact">
    /// The <c>TmpLedgerConsTrans</c> table buffer that will contain the ledger transactions to consolidate.
    /// </param>
    /// <param name = "_consolidationDimensionValueItem">
    /// A <c>TmpLedgerConsDimensionValueItem</c> table buffer.
    /// </param>
    /// <param name = "_proportion">
    /// The percentage of the specified company to include in the consolidation.
    /// </param>
    protected void sumUpTransact(
        CompanyId                       _companyId,
        TmpLedgerConsTrans              _transact,
        TmpLedgerConsDimensionValueItem _consolidationDimensionValueItem,
        Percent                         _proportion)
    {
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        GeneralJournalEntry                 generalJournalEntry;
        FiscalCalendarPeriod                fiscalCalendarPeriod;
        QueryRun                            queryRun;
        CurrencyCode                        currencyCode;
        MainAccount                         mainAccount;
        MainAccountNum                      ledgerAccount;
        MainAccountNum                      filteredLedgerAccount;
        MainAccountNum                      priorledgerAccount;
        AccountName                         mainAccountName;
        MainAccountConsolidateAccount       mainAccountConsolidateAccount;
        DimensionAttributeValueCombination  dimensionAttributeValueCombination;

        changecompany(_companyId)
        {
            using (SysInstrumentationActivityContext context = monitor.enterAggregateTransactions(
                fromDate,
                toDate,
                companyGroupAccounts,
                transferCurrent,
                transferBudget,
                processFullBalanceRebuild,
                transferTransactionsOnly_BR))
            {
                currencyCode = Ledger::accountingCurrency();
                groupDimensionDimAttrValueIdLookup = new Map(Types::String, Types::Guid);

                if (transferCurrent)
                {
                    TmpLedgerConsQuery tmpLedgerConsQuery = this.getSelectedAccounts();

                    acctNumDimAttrValueIdLookup = new Map(Types::String, Types::Guid);
                    companyDimAttrValueHashKey = newGuid();

                    queryRun = new QueryRun(this.getQuery());
                    queryRun.setCursor(tmpLedgerConsQuery);

                    while (queryRun.next())
                    {
                        generalJournalAccountEntry = queryRun.get(tableNum(GeneralJournalAccountEntry)) as GeneralJournalAccountEntry;
                        generalJournalEntry = queryRun.get(tableNum(GeneralJournalEntry)) as GeneralJournalEntry;
                        fiscalCalendarPeriod = queryRun.get(tableNum(FiscalCalendarPeriod)) as FiscalCalendarPeriod;
                        mainAccount = queryRun.get(tableNum(MainAccount)) as MainAccount;

                        dimensionAttributeValueCombination = queryRun.get(tableNum(DimensionAttributeValueCombination));
                        ledgerAccount = mainAccount.MainAccountId;

                        if (priorledgerAccount != ledgerAccount)
                        {
                            priorledgerAccount = ledgerAccount;
                            // Cache this in the common case
                            mainAccountName = MainAccount.Name;

                            if (companyGroupAccounts)
                            {
                                if (consolidateAccountGroup)
                                {
                                    mainAccountConsolidateAccount = mainAccountConsolidateAccount::findById(mainAccount.RecId, consolidateAccountGroup);

                                    if (!mainAccountConsolidateAccount.ConsolidationMainAccount)
                                    {
                                        // The consolidation account for main account %1 in legal entity %2 for consolidation account group %3 is not specified, so main account %1 was used.
                                        info(strFmt("@GLS222072", ledgerAccount, _companyId, LedgerConsolidateAccountGroup::find(consolidateAccountGroup).Name));
                                        filteredLedgerAccount = ledgerAccount;
                                    }
                                    else
                                    {
                                        filteredLedgerAccount = mainAccountConsolidateAccount.ConsolidationMainAccount;
                                        // Use the overriden name, even if blank
                                        mainAccountName = mainAccountConsolidateAccount.Name;
                                    }
                                }
                                else if (!mainAccount.ConsolidationMainAccount)
                                {
                                    // The consolidation account for main account %1 in legal entity %2 is not specified, so main account %1 was used.
                                    info(strFmt("@SYS24289", ledgerAccount, _companyId));
                                    filteredLedgerAccount = ledgerAccount;
                                }
                                else
                                {
                                    filteredLedgerAccount = mainAccount.ConsolidationMainAccount;
                                }
                            }
                            else
                            {
                                filteredLedgerAccount = ledgerAccount;
                            }
                        }
                        priorledgerAccount = ledgerAccount;

                        this.tmpLedgerConsTransWrite(
                            _transact,
                            filteredLedgerAccount,
                            mainAccountName,
                            dimensionAttributeValueCombination.AccountStructure,
                            _consolidationDimensionValueItem,
                            generalJournalAccountEntry,
                            generalJournalEntry,
                            fiscalCalendarPeriod,
                            currencyCode,
                            priorledgerAccount);

                        if (this.isTransferOnly_BR())
                        {
                            this.postTmpLedgerConsTransWrite_BR(_transact, generalJournalAccountEntry, generalJournalEntry);
                        }
                    }
                }

                if (transferBudget)
                {
                    this.setUpBudgetConsolidationManager();

                    budgetConsolidationManager.parmSubsidiaryCompany(_companyId);

                    // Consolidation Online and Consolidation Import process both has share (proportion)
                    // setting for the amount-to-consolidate per subsidiary company.  Set the proportion
                    // to perform budget consolidation online or budget consolidation import process.
                    budgetConsolidationManager.parmProportion(_proportion);

                    // Consolidate budget transactions for the subsidiary company.
                    budgetConsolidationManager.consolidateBudgetTransactions();
                }

                monitor.exitAggregateTransactions(context, countTransact);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectedAccounts</Name>
				<Source><![CDATA[
    private TmpLedgerConsQuery getSelectedAccounts()
    {
        TmpLedgerConsQuery tmpLedgerConsQuery;
        MainAccount mainAccount;
        MainAccountConsolidateAccount mainAccountConsolidateAccount;

        RecId ledgerRecId = LedgerChartOfAccounts::current();

        if (consolidateAccountGroup)
        {
            // Insert for the accounts specified on the MainAccountConsolidateAccount table if it exists for the group and is within the from/to range.
            insert_recordset tmpLedgerConsQuery (MainAccountId)
            select MainAccountId from mainAccount
                where mainAccount.LedgerChartOfAccounts == ledgerRecId
            exists join mainAccountConsolidateAccount
                where mainAccountConsolidateAccount.MainAccount == mainAccount.RecId &&
                    mainAccountConsolidateAccount.ConsolidateAccountGroup == consolidateAccountGroup &&
                    mainAccountConsolidateAccount.ConsolidationMainAccount >= fromAccount &&
                    (!toAccount || mainAccountConsolidateAccount.ConsolidationMainAccount <= toAccount);

            // Insert for the accounts not specified on the MainAccountConsolidateAccount table if it is within the from/to range.
            insert_recordset tmpLedgerConsQuery (MainAccountId)
            select MainAccountId from mainAccount
                where mainAccount.LedgerChartOfAccounts == ledgerRecId &&
                    mainAccount.MainAccountId >= fromAccount &&
                    (!toAccount || mainAccount.MainAccountId <= toAccount)
            notexists join mainAccountConsolidateAccount
                where mainAccountConsolidateAccount.MainAccount == mainAccount.RecId &&
                    mainAccountConsolidateAccount.ConsolidateAccountGroup == consolidateAccountGroup;
        }
        else
        {
            insert_recordset tmpLedgerConsQuery (MainAccountId)
            select MainAccountId from mainAccount
                where mainAccount.LedgerChartOfAccounts == ledgerRecId &&
                (
                    (companyGroupAccounts
                        && ((mainAccount.ConsolidationMainAccount >= fromAccount
                        && (!toAccount || mainAccount.ConsolidationMainAccount <= toAccount))
                        || (mainAccount.ConsolidationMainAccount == ''
                        && mainAccount.MainAccountId >= fromAccount
                        && (!toAccount || mainAccount.MainAccountId <= toAccount))))
                    ||
                    (!companyGroupAccounts
                        && mainAccount.MainAccountId >= fromAccount
                        && (!toAccount || mainAccount.MainAccountId <= toAccount))
                );
        }

        return tmpLedgerConsQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuery</Name>
				<Source><![CDATA[
    private Query getQuery()
    {
        Query query = new Query(queryStr(GeneralJournalConsolidate));

        // <GBR>
        if (this.isTransferOnly_BR())
        {
            query = new query(queryStr(GeneralJournalConsolidate_BR));
        }
        // </GBR>

        QueryBuildDataSource qbds;

        // Restrict general journal entry to current ledger, date range and closing or regular periods
        qbds = query.dataSourceTable(tableNum(GeneralJournalEntry));
        qbds.addRange(fieldNum(GeneralJournalEntry, Ledger)).value(SysQuery::value(Ledger::current()));
        qbds.addRange(fieldNum(GeneralJournalEntry, AccountingDate)).value(queryRange(fromDate, toDate));

        qbds = query.dataSourceTable(tableNum(FiscalCalendarPeriod));
        qbds.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(queryValue(FiscalPeriodType::Operating));
        qbds.addRange(fieldNum(FiscalCalendarPeriod, Type)).value(queryValue(FiscalPeriodType::Closing));

        // Restrict general journal account entry to posting types other than TransferOpeningClosing
        qbds = query.dataSourceTable(tableNum(GeneralJournalAccountEntry));
        qbds.addRange(fieldNum(GeneralJournalAccountEntry, PostingType)).value(SysQuery::valueNot(LedgerPostingType::TransferOpeningClosing));

        // Join to main account to filter by accounts
        qbds = query.dataSourceTable(tableNum(DimensionAttributeValueCombination));

        // <GBR>
        if (!this.isTransferOnly_BR())
        {
            qbds.addGroupByField(fieldNum(DimensionAttributeValueCombination, AccountStructure));
        }
        // </GBR>

        qbds = qbds.addDataSource(tableNum(MainAccount));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.joinMode(JoinMode::InnerJoin);
        qbds.addLink(fieldNum(DimensionAttributeValueCombination, MainAccount), fieldNum(MainAccount, RecId));

        // Restrict to current COA and proper account types
        qbds.addRange(fieldNum(MainAccount, LedgerChartOfAccounts)).value(queryValue(LedgerChartOfAccounts::current()));
        qbds.addRange(fieldNum(MainAccount, Type)).value(SysQuery::range(DimensionLedgerAccountType::ProfitAndLoss, DimensionLedgerAccountType::Equity));

        // <GBR>
        if (!this.isTransferOnly_BR())
        {
            // </GBR>
            // Group by main account and add the main account fields to the selected field list.
            qbds.addGroupByField(fieldNum(MainAccount, MainAccountId));
            qbds.addGroupByField(fieldNum(MainAccount, RecId));
            qbds.addGroupByField(fieldNum(MainAccount, Name));
            qbds.addGroupByField(fieldNum(MainAccount, ConsolidationMainAccount));
            qbds.addGroupByField(fieldNum(MainAccount, Type));
            // <GBR>
        }
        // </GBR>

        qbds = qbds.addDataSource(tableNum(TmpLedgerConsQuery));
        qbds.addLink(fieldNum(MainAccount, MainAccountId), fieldNum(TmpLedgerConsQuery, MainAccountId));
        qbds.fetchMode(QueryFetchMode::One2One);
        qbds.joinMode(JoinMode::ExistsJoin);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tmpLedgerConsTransWrite</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void tmpLedgerConsTransWrite(
        TmpLedgerConsTrans              _transact,
        MainAccountNum                  _ledgerAccount,
        AccountName                     _accountName,
        recId                           _accountStructureId,
        TmpLedgerConsDimensionValueItem _consolidationDimensionValueItem,
        GeneralJournalAccountEntry      _generalJournalAccountEntry,
        GeneralJournalEntry             _generalJournalEntry,
        FiscalCalendarPeriod            _fiscalCalendarPeriod,
        CurrencyCode                    _currencyCode,
        MainAccountNum                  _oldAccountNum)
    {
        #LedgerSHA1Hash

        boolean useITAckDate;
        boolean isCreateTransaction;
        DimensionHashContainer hash;
        int     i;
        int     valueSetCount;

        // Get dimension values and compute hash
        valueSetCount = this.fillConsolidatedDimensionValues(_generalJournalAccountEntry.LedgerDimension, _oldAccountNum);
        if (valueSetCount != 0)
        {
            hash = DimensionAttributeValueSetStorage::getHashFromArray(consolidatedDimAttrValueHashKeyArray, valueSetCount);
        }

        useITAckDate = LedgerParameters::find().AcknowledgementDate_IT;

        // The current company is the source company because the calling method changes scope to the
        // source company. We can't get the reporting currency in the calling method, like we get the
        // accounting currency, because we can't add a parameter for it.
        CurrencyCode sourceReportingCurrencyCode = Ledger::reportingCurrency();

        ttsbegin;
        isCreateTransaction = false;

        // Try to update existing records first, since it is more common to have an existing record
        // than to be inserting a new record
        // <GBR>
        if (this.isTransferOnly_BR())
        {
            _transact.clear();
        }
        else
        // </GBR>
        if (!useITAckDate)
        {
            update_recordset _transact
                setting
                    AmountCur               = _transact.AmountCur   + _generalJournalAccountEntry.AccountingCurrencyAmount,
                    ReportingCurrencyAmount = _transact.ReportingCurrencyAmount + _generalJournalAccountEntry.ReportingCurrencyAmount,
                    Qty                     = _transact.Qty         + _generalJournalAccountEntry.Quantity,
                    MainAccountName         = _accountName,
                    OriginalMainAccountId   = _oldAccountNum
            where _transact.MainAccountId           == _ledgerAccount
                   && _transact.DimensionHierarchy  == _accountStructureId
                   && _transact.TransDate           == _generalJournalEntry.AccountingDate
                   && _transact.PeriodCode          == _fiscalCalendarPeriod.Type
                   && _transact.CurrencyCode        == _currencyCode
                   && ((!useDualCurrency) || (_transact.ReportingCurrencyCode == sourceReportingCurrencyCode))
                   && _transact.Crediting           == _generalJournalAccountEntry.IsCredit
                   && _transact.OperationsTax       == _generalJournalEntry.PostingLayer
                   && _transact.Hash                == hash
                   && _transact.TmpDataAreaId       == curext();
        }
        else
        {
            update_recordset _transact
                setting
                    AmountCur               = _transact.AmountCur   + _generalJournalAccountEntry.AccountingCurrencyAmount,
                    ReportingCurrencyAmount = _transact.ReportingCurrencyAmount + _generalJournalAccountEntry.ReportingCurrencyAmount,
                    Qty                     = _transact.Qty         + _generalJournalAccountEntry.Quantity,
                    MainAccountName         = _accountName,
                    OriginalMainAccountId   = _oldAccountNum
                where _transact.MainAccountId       == _ledgerAccount
                   && _transact.DimensionHierarchy  == _accountStructureId
                   && _transact.TransDate           == _generalJournalEntry.AccountingDate
                   && _transact.AcknowledgementDate == _generalJournalEntry.AcknowledgementDate
                   && _transact.PeriodCode          == _fiscalCalendarPeriod.Type
                   && _transact.CurrencyCode        == _currencyCode
                   && ((!useDualCurrency) || (_transact.ReportingCurrencyCode == sourceReportingCurrencyCode))
                   && _transact.Crediting           == _generalJournalAccountEntry.IsCredit
                   && _transact.OperationsTax       == _generalJournalEntry.PostingLayer
                   && _transact.Hash                == hash
                   && _transact.TmpDataAreaId       == curext();
        }

        // If no rows were updated, then this is a new row that needs to be inserted
        if (_transact.RowCount() == 0
        // <GBR>
        || (this.isTransferOnly_BR() && _transact.RecId == 0))
        // </GBR>
        {
            isCreateTransaction = true;
            consTransLocalRecId++;

            _transact.LocalRecId            = consTransLocalRecId;
            _transact.MainAccountId         = _ledgerAccount;
            _transact.MainAccountName       = _accountName;
            _transact.OriginalMainAccountId = _oldAccountNum;
            _transact.DimensionHierarchy    = _accountStructureId;
            _transact.TransDate             = _generalJournalEntry.AccountingDate;
            _transact.PeriodCode            = _fiscalCalendarPeriod.Type;
            _transact.CurrencyCode          = _currencyCode;
            _transact.ReportingCurrencyCode = sourceReportingCurrencyCode;
            _transact.Crediting             = _generalJournalAccountEntry.IsCredit;
            _transact.OperationsTax         = _generalJournalEntry.PostingLayer;
            _transact.Hash                  = hash;
            _transact.TmpDataAreaId         = curext();
            _transact.AmountCur             = _generalJournalAccountEntry.AccountingCurrencyAmount;
            _transact.ReportingCurrencyAmount = _generalJournalAccountEntry.ReportingCurrencyAmount;
            _transact.Qty                   = _generalJournalAccountEntry.Quantity;

            if (useITAckDate)
            {
                _transact.AcknowledgementDate = _generalJournalEntry.AcknowledgementDate;
            }
            else
            {
                _transact.AcknowledgementDate = _generalJournalEntry.AccountingDate;
            }

            _transact.write();
        }

        ttscommit;

        // Create value item records
        if (isCreateTransaction)
        {
            _consolidationDimensionValueItem.LocalConsTrans = _transact.LocalRecId;
            _consolidationDimensionValueItem.LegalEntity = curext();
            for (i = 1; i <= valueSetCount; i++)
            {
                _consolidationDimensionValueItem.LocalConsDimensionAttribute = sourceDimAttrIdLookupTable.lookup(consolidatedDimAttrIdArray[i]);
                _consolidationDimensionValueItem.Value = consolidatedDisplayValueArray[i];
                _consolidationDimensionValueItem.insert();
            }
        }

        countTransact++;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDimAttrIdLookupTable</Name>
				<Source><![CDATA[
    internal Map parmSourceDimAttrIdLookupTable()
    {
        return sourceDimAttrIdLookupTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerConsolidateTemplateId</Name>
				<Source><![CDATA[
    internal RefRecId parmLedgerConsolidateTemplateId(RefRecId _template = templateId)
    {
        templateId = _template;
        return templateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the to Main account.
    /// </summary>
    /// <param name = "_toAccount">The to account.</param>
    /// <returns>The ID of a Main account.</returns>
    MainAccountNum toAccount(MainAccountNum _toAccount = toAccount)
    {
        toAccount = _toAccount;
        return toAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the to date.
    /// </summary>
    /// <param name = "_toDate">The to date.</param>
    /// <returns>The to date.</returns>
    TransDate toDate(TransDate _toDate  = toDate)
    {
        toDate  = _toDate;
        return toDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>toModel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the to budget model.
    /// </summary>
    /// <param name = "_toModel">The ID of a budget model.</param>
    /// <returns>The ID of a budget model.</returns>
    BudgetModelId toModel(BudgetModelId _toModel = toModel)
    {
        toModel  = _toModel;
        return toModel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the to transfer budget value.
    /// </summary>
    /// <param name = "_transferBudget">A <c>NoYes</c> value.</param>
    /// <returns>A <c>NoYes</c> value indicating if budget amounts should be consolidated.</returns>
    NoYes transferBudget(NoYes _transferBudget = transferBudget)
    {
        transferBudget = _transferBudget;
        return transferBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferCurrent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the to transfer current value.
    /// </summary>
    /// <param name = "_transferCurrent">A <c>NoYes</c> value.</param>
    /// <returns>A <c>NoYes</c> value indicating if ledger amounts should be consolidated.</returns>
    NoYes transferCurrent(NoYes _transferCurrent = transferCurrent)
    {
        transferCurrent = _transferCurrent;
        return transferCurrent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consolidationAmountSource</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the consolidation amount source value.
    /// </summary>
    /// <param name = "_consolidationAmountSource">A <c>LedgerConsolidateAmountSource</c> value.</param>
    /// <returns>A <c>LedgerConsolidateAmountSource</c> value indicating the consolidation amount source.</returns>
    internal LedgerConsolidateAmountSource consolidationAmountSource(LedgerConsolidateAmountSource _consolidationAmountSource = consolidationAmountSource)
    {
        consolidationAmountSource = _consolidationAmountSource;
        return consolidationAmountSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>consolidateAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the consolidation accounting currency.
    /// </summary>
    /// <param name = "_consolidateAccountingCurrency">A <c>LedgerConsolidateAccountingCurrency</c> value.</param>
    /// <returns>A <c>LedgerConsolidateAccountingCurrency</c> value indicating the consolidation accounting currency.</returns>
    internal LedgerConsolidateAccountingCurrency consolidateAccountingCurrency(LedgerConsolidateAccountingCurrency _consolidateAccountingCurrency = consolidateAccountingCurrency)
    {
        consolidateAccountingCurrency = _consolidateAccountingCurrency;
        return consolidateAccountingCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        Integer version = conPeek(packedClass,1);

        switch (version)
        {
            case Version14:
                [version, #ListVersion14] = packedClass;
                break;

            case Version1:
                [version, #ListVersion1] = packedClass;
                break;
                
            case Version2:
                [version, #ListVersion2] = packedClass;
                break;

            case Version3:
                [version, #ListVersion3] = packedClass;
                break;
      
            case Version4:
                [version, #ListVersion4] = packedClass;
                break;

            case Version5:
                [version, #ListVersion5] = packedClass;
                break;
            
            case CurrentVersion :
                [version, #CurrentList] = packedClass;
                break;

            default :
                return false;
        }

        if (packedCompanyDimensionMapping != conNull())
        {
            companyDimensionMapping = Map::create(packedCompanyDimensionMapping);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unPackTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unpacks the information for the consolidation into a container. Used by the import consolidation function.
    /// </summary>
    /// <param name = "_packedTables">
    /// A container with the information for the consolidation.
    /// </param>
    /// <param name = "_sumTransact">
    /// The <c>TmpLedgerConsTrans</c> table buffer that will contain the ledger transactions to consolidate.
    /// </param>
    /// <param name = "_consolidationDimensionValueItem">
    /// A <c>TmpLedgerConsDimensionValueItem</c> table buffer.
    /// </param>
    /// <param name = "_consolidationDimensionAttribute">
    /// A <c>TmpLedgerConsDimensionAttribute</c> table buffer.
    /// </param>
    void unPackTables(
        container                       _packedTables,
        TmpLedgerConsTrans              _sumTransact,
        TmpLedgerConsDimensionValueItem _consolidationDimensionValueItem,
        TmpLedgerConsDimensionAttribute _consolidationDimensionAttribute
        )
    {
        container       conDimensions, conTrans, conDimensionValues, packedBudgetConsolidationManager, conAccounts;
        List            listDimensions, listTrans, listDimensionValues;
        Map             mapAccounts;
        MapIterator     mi;
        ListIterator    li;
        MainAccount     mainAccount;
        MainAccount     tmpMainAccount;
        MainAccountNum  account;

        tmpMainAccount.setTmp();
        [conDimensions, conTrans, conDimensionValues, packedBudgetConsolidationManager, conAccounts, companyOrigin] = _packedTables;

        listDimensions = List::create(conDimensions);
        listTrans = List::create(conTrans);
        listDimensionValues = List::create(conDimensionValues);
        mapAccounts = Map::create(conAccounts);
        budgetConsolidationManager = BudgetConsolidationManager::create(packedBudgetConsolidationManager);

        li = new ListIterator(listDimensions);
        li.begin();
        while (li.more())
        {
            _consolidationDimensionAttribute.data(li.value());
            _consolidationDimensionAttribute.RecId = 0;
            _consolidationDimensionAttribute.doInsert();
            li.next();
        }

        li = new ListIterator(listTrans);
        li.begin();
        while (li.more())
        {
            _sumTransact.data(li.value());

            if (_sumTransact.TransDate >= fromDate && _sumTransact.TransDate <= toDate)
            {
                _sumTransact.RecId = 0;
                _sumTransact.doInsert();
            }

            li.next();
        }

        li = new ListIterator(listDimensionValues);
        li.begin();
        while (li.more())
        {
            _consolidationDimensionValueItem.data(li.value());
            _consolidationDimensionValueItem.RecId = 0;
            _consolidationDimensionValueItem.doInsert();
            li.next();
        }
        mi = new MapIterator(mapAccounts);
        mi.begin();
        while (mi.more())
        {
            [account,tmpMainAccount] = mi.valuePair();
            mainAccount = MainAccount::findByMainAccountId(account);
            if (!mainAccount)
            {
                mainAccount.data(tmpMainAccount);
                mainAccount.RecId = 0;
                mainAccount.insert();
            }
            mi.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateEliminationDateLastRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates ledger elimination rules with the date they were last run.
    /// </summary>
    protected void updateEliminationDateLastRun()
    {
        int             elimationJournalIdx = 0;
        int             elimationContainerIdx = 0;
        CompanyId       journalCompany;
        LedgerJournalId journalNum;
        container       errorsLogged;
        boolean         errorsExist;
        boolean         succeeded;

        ttsbegin;

        try
        {
            // a retry clears out the infolog so we must restore from the container if errors did exist
            if (errorsExist)
            {
                infolog.import(errorsLogged);
                errorsExist = false;
            }

            while (elimationJournalIdx < numberOfEliminationJournals)
            {
                elimationJournalIdx++;

                elimationContainerIdx++;
                eliminationRule = conPeek(ledgerEliminationJournals, elimationContainerIdx);
                elimationContainerIdx++;
                journalNum = conPeek(ledgerEliminationJournals, elimationContainerIdx);
                elimationContainerIdx++;
                journalCompany = conPeek(ledgerEliminationJournals, elimationContainerIdx);
                elimationContainerIdx++;
                succeeded = conPeek(ledgerEliminationJournals, elimationContainerIdx);

                if (succeeded)
                {
                    ledgerEliminationRule = LedgerEliminationRule::find(eliminationRule, true);
                    ledgerEliminationRule.DateLastRun = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                    ledgerEliminationRule.update();
                }
            }
        }
        catch (Exception::Error)
        {
            errorsExist = true;

            // save the errors in a container so they can be restored
            errorsLogged = infolog.export();

            retry;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    boolean validate(Object calledFrom = null)
    {
        if ((mode == LedgerConsMode::Online || mode == LedgerConsMode::Import) &&
            (CompanyInfo::isConsolidationCompany() == NoYes::No))
        {
            return checkFailed("@SYS21028");
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesCompanyExist</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the company is valid for the consolidation process.
    /// </summary>
    /// <param name="_companyId">
    ///    The data area ID for the company.
    /// </param>
    /// <returns>
    ///    true if the company is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The company must exist and must not be a virtual company for the consolidations to occur.
    /// </remarks>
    public static boolean doesCompanyExist(CompanyId _companyId)
    {
        DataArea dataArea;

        if (!_companyId)
        {
            return false;
        }

        select firstonly RecId, IsVirtual from dataArea where dataArea.Id == _companyId;
        if (!dataArea.RecId || dataArea.IsVirtual)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMainAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the specified ledger account.
    /// </summary>
    /// <param name="_companyId">
    ///    The subsidiary company ID.
    /// </param>
    /// <param name="_accountNum">
    ///    The main account to initialize.
    /// </param>
    /// <param name="_accountName">
    ///    The description of the main account to initialize.
    /// </param>
    /// <param name="_originalAccountNum">
    ///    The original main account associated with the account number.
    /// </param>
    /// <param name="_useConsolidationAccount">
    ///    A Boolean value that indicates whether the subsidiary company main account has specific
    ///    consolidated company account mapping.
    /// </param>
    /// <param name="_errorAccount">
    ///    The error main account.
    /// </param>
    /// <returns>
    ///    The initialized main account.
    /// </returns>
    /// <exception cref="M:Exception::Error">
    ///    The consolidation account was not found in the subsidiary company main account.
    /// </exception>
    public static MainAccountNum initMainAccount(
        CompanyId       _companyId,
        MainAccountNum  _accountNum,
        AccountName     _accountName,
        MainAccountNum  _originalAccountNum,
        boolean         _useConsolidationAccount,
        MainAccountNum  _errorAccount = '')
    {
        MainAccount fromTable;
        MainAccount toTable;
        MainAccount mainAccount;

        mainAccount = MainAccount::findByMainAccountId(_accountNum);

        if (!mainAccount)
        {
            // Finds the main account record in the subsidiary company.
            changecompany(_companyId)
            {
                // Fall back to the original account number if a consolidation account has been specified
                fromTable = MainAccount::findByMainAccountId(_useConsolidationAccount ? _originalAccountNum : _accountNum);
            }

            toTable.clear();

            // Only copy the minimum fields required (as some may be references to data outside of the current COA and therefore invalid)
            toTable.MainAccountId = _accountNum;
            toTable.Name = _accountName;
            toTable.Type = fromTable.Type;
            toTable.MainAccountTemplate = fromTable.MainAccountTemplate;
            toTable.AccountCategoryRef = fromTable.AccountCategoryRef;
            toTable.ExchangeAdjusted = fromTable.ExchangeAdjusted;
            toTable.LedgerChartOfAccounts = LedgerChartOfAccounts::current();

            toTable.insert();

            // Apply the translation values.
            MainAccountTranslation::applyTranslations(fromTable.RecId, toTable.RecId);

            return _accountNum;
        }
        else
        {
            boolean isAccountNum = LedgerConsolidate::isMainAccountTypeValid(mainAccount);

            if (isAccountNum)
            {
                return _accountNum;
            }
            else
            {
                if (_errorAccount)
                {
                    // The account type of %1 is incorrect for main account %2 in legal entity %3, which is the consolidation legal entity. Error account %4 was used.
                    checkFailed(strFmt("@SYS340680", mainAccount.Type, _accountNum, curext(), _errorAccount));
                    return _errorAccount;
                }
                else
                {
                    // The account type of %1 is incorrect for main account %2 in legal entity %3, which is the consolidation legal entity. The error account also is not set up.
                    throw error(strFmt("@SYS340681", mainAccount.Type, _accountNum, curext()));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMainAccountTypeValid</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the specified main account is valid for consolidation transactions.
    /// </summary>
    /// <param name = "_mainAccount">
    /// The <c>MainAccount</c> record.
    /// </param>
    /// <returns>
    /// true if the main account is valid for consolidation transactions; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final static boolean isMainAccountTypeValid(MainAccount _mainAccount)
    {
        boolean isMainAccountTypeValid;

        switch (_mainAccount.Type)
        {
            case DimensionLedgerAccountType::ProfitAndLoss:
            case DimensionLedgerAccountType::Revenue:
            case DimensionLedgerAccountType::Expense:
            case DimensionLedgerAccountType::BalanceSheet:
            case DimensionLedgerAccountType::Asset:
            case DimensionLedgerAccountType::Liability:
            case DimensionLedgerAccountType::Equity:
            case DimensionLedgerAccountType::Total:
                // Budget register entries can be made against Total accounts, so include in the consolidation to maintain the detail for budget
                // Ledger prevents posting to Total accounts, so including for Budget will not affect Ledger
                isMainAccountTypeValid = true;
                break;

            case DimensionLedgerAccountType::Common_CN:
                    if (LedgerParameters::isCommonAccountType_CN())
                {
                    isMainAccountTypeValid = true;
                    break;
                }
                else
                {
                    // The account type of %1 is incorrect for main account %2 in legal entity %3, which is the consolidation legal entity. The common account is not set up.
                    throw error(strFmt("@GLS64244", _mainAccount.Type, _mainAccount.MainAccountId, curext()));
                }
        }

        return isMainAccountTypeValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exportFilesToUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Exports the generated consolidation files to the user through the browser.
    /// </summary>
    protected void exportFilesToUser()
    {
        Browser br = new Browser();
        for (int i = 1; i <= conLen(exportedFileURLs); i++)
        {
            str exportURL = conPeek(exportedFileURLs, i);
            if (exportURL)
            {
                br.navigate(exportURL);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    static void main(Args args)
    {
        LedgerConsolidate   ledgerConsolidate;

        ledgerConsolidate  = LedgerConsolidate::newLedgerConsolidate(args.parmEnum());

        if (ledgerConsolidate.validate())
        {
            if (ledgerConsolidate.prompt())
            {
                ledgerConsolidate.runOperation();

                LedgerConsMode mode = any2Enum(args.parmEnum());
                if (mode == LedgerConsMode::export)
                {
                    ledgerConsolidate.exportFilesToUser();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerConsolidate</Name>
				<Source><![CDATA[
    static LedgerConsolidate newLedgerConsolidate(LedgerConsMode _mode =  LedgerConsMode::Online)
    {
        LedgerConsolidate ledgerConsolidate;

        ledgerConsolidate = new LedgerConsolidate();
        ledgerConsolidate.getLast();
        ledgerConsolidate.parmLedgerConsMode(_mode);

        return ledgerConsolidate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCurrencyConversionDefaultExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the default exchange rate on the specified <c>LedgerConsolidateCurrencyConversion</c> record.
    /// </summary>
    /// <param name="_ledgerConsolidateCurrencyConversion">
    ///    The <c>LedgerConsolidateCurrencyConversion</c> record for which to set the default exchange rate.
    /// </param>
    /// <param name="_consolidationTransDate">
    ///    The transaction date for the consolidation.
    /// </param>
    public static void setCurrencyConversionDefaultExchRate(
        LedgerConsolidateCurrencyConversion _ledgerConsolidateCurrencyConversion,
        TransDate                           _consolidationTransDate)
    {
        ExchangeRateHelper exchangeRateHelper;

        if (_ledgerConsolidateCurrencyConversion.ConversionDate == LedgerConsolidateConversionDate::ConsolidationDate)
        {
            exchangeRateHelper = ExchangeRateHelper::newExchangeDate(
                Ledger::current(),
                Ledger::accountingCurrency(_ledgerConsolidateCurrencyConversion.SourceLegalEntity),
                _consolidationTransDate);

            exchangeRateHelper.parmExchangeRateTypeRecId(_ledgerConsolidateCurrencyConversion.ExchangeRateType);

            _ledgerConsolidateCurrencyConversion.ExchangeRate = exchangeRateHelper.getExchangeRate1();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCurrencyConversionDefaultExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the default exchange rate for the <c>LedgerConsolidateCurrencyConversion</c> records.
    /// </summary>
    /// <param name="_consolidationTransDate">
    ///    The transaction date for the consolidation.
    /// </param>
    public static void updateCurrencyConversionDefaultExchRate(TransDate _consolidationTransDate)
    {
        LedgerConsolidateCurrencyConversion ledgerConsolidateCurrencyConversion;

        ttsBegin;

        while select forUpdate ledgerConsolidateCurrencyConversion
            where ledgerConsolidateCurrencyConversion.ConversionDate == LedgerConsolidateConversionDate::ConsolidationDate
        {
            LedgerConsolidate::setCurrencyConversionDefaultExchRate(
                ledgerConsolidateCurrencyConversion,
                _consolidationTransDate);

            ledgerConsolidateCurrencyConversion.update();
        }

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateHistRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates <c>LedgerConsolidateHistRef</c> record with the specified consolidation activity history record ID, transaction's record ID, and table ID.
    /// </summary>
    /// <param name="_ledgerConsolidateHistRecId">
    /// The consolidation activity history record ID.
    /// </param>
    /// <param name="_transTableId">
    /// The consolidation transaction table ID.
    /// </param>
    /// <param name="_transRecId">
    /// The consolidation transaction record ID.
    /// </param>
    public  static void updateHistRef(
        recId       _ledgerConsolidateHistRecId,
        tableId     _transTableId,
        recId       _transRecId
        )
    {
        LedgerConsolidateHistRef    ledgerConsolidateHistRef;

        ledgerConsolidateHistRef.RefRecId = _ledgerConsolidateHistRecId;
        ledgerConsolidateHistRef.TransTableId = _transTableId;
        ledgerConsolidateHistRef.TransRecid = _transRecId;
        ledgerConsolidateHistRef.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>packOffset</Name>
				<Source><![CDATA[
    private container packOffset(CurrentOperationsTax _postingLayer, FiscalPeriodType _periodType, TransDate _transactionDate, AmountMST _amount, AmountMSTSecondary _amountSecond)
    {
        return [_postingLayer, _periodType, _transactionDate, _amount, _amountSecond];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatch</Name>
				<Source><![CDATA[
    public boolean canGoBatch()
    {
        boolean ret = super();

        if (mode == LedgerConsMode::export)
        {
            ret = false;
            // Ensure a previous batch-enabled import or online execution doesn't cause the export operation to run in batch.
            this.batchInfo().parmBatchExecute(false);
        }
        else
        {
            // Always run in batch for consolidations import or online.
            this.batchInfo().parmBatchExecute(true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustGoBatch</Name>
				<Source><![CDATA[
    public boolean mustGoBatch()
    {
        boolean ret = super();

        if (LedgerConsolidationSafeDeletionFlight::instance().isEnabled())
        {
            if (mode == LedgerConsMode::export)
            {
                ret = false;
                // Ensure a previous batch-enabled import or online execution doesn't cause the export operation to run in batch.
                this.batchInfo().parmBatchExecute(false);
            }
            else
            {
                // Always run in batch for consolidations import or online.
                this.batchInfo().parmBatchExecute(true);
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForExistingConsolidations</Name>
				<Source><![CDATA[
    private void checkForExistingConsolidations()
    {
        if (LedgerConsolidationSafeDeletionFlight::instance().isEnabled())
        {
            this.validateFullConsolidationDateRange();

            BatchHeader batchHeader;
            RefRecId batchRecId = emptyBatchRecId;
            if (this.isInBatch())
            {
                batchHeader = BatchHeader::getCurrentBatchHeader(); //batchHeader is really the batchJobId
                batchRecId = batchHeader.parmBatchHeaderId();
            }

            LedgerConsolidateHistDeleteValidate ledgerConsolidateHistDeleteValidate;
            ledgerConsolidateHistDeleteValidate = new LedgerConsolidateHistDeleteValidate();
            if (this.isInBatch())
            {
                ledgerConsolidateHistDeleteValidate.setValuesFromLedgerConsolidate(this);
            }

            if (!ledgerConsolidateHistDeleteValidate.validateTransactionsCanBeDeleted(batchRecId))
            {
                throw error("@GeneralLedger:ConsolidationBatchNotAllowedError");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public final boolean isRetryable()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBatchTaskDateRanges</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the date ranges that will be used to create batch tasks.
    /// </summary>
    /// <param name="_companyId">
    /// The company ID.
    /// </param>
    /// <returns>
    /// The date ranges.
    /// </returns>
    /// <remarks>
    /// The start date of the first date range must be the start date of the consolidation.
    /// The end date of the last date range must be the end date of the consolidation.
    /// The date ranges cannot have any gaps or overlap.
    /// For example, [2018/01/01,2018/12/31] or [2018/01/01,2018/06/30,2018/07/01,2018/12/31]
    /// </remarks>
    protected LedgerConsolidateDateRanges getBatchTaskDateRanges(CompanyId _companyId)
    {
        LedgerConsolidateDateRanges dateRanges = LedgerConsolidateDateRanges::construct();

        TransDate dateRangeStart = fromDate;
        TransDate dateRangeEnd = toDate;
        while (dateRangeStart <= toDate)
        {
            dateRangeEnd = dateRangeStart + (ParallelProcessingDefaultBundleSize - 1); // subtract one for inclusive

            if (dateRangeEnd > toDate)
            {
                dateRangeEnd = toDate;
            }

            dateRanges.addDateRange(dateRangeStart, dateRangeEnd);

            dateRangeStart = dateRangeEnd + 1;
        }

        return dateRanges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFullConsolidationDateRange</Name>
				<Source><![CDATA[
    private void validateFullConsolidationDateRange()
    {
        if (useParallelProcessingFeature)
        {
            // For an instance of this class to contain the full consolidation date range in the toDate and fromDate fields, 
            // it has to be one of the following:
            // 1. not a child batch task: isChildBatchRuntimeTask and isChildBatchFinalTask are both false
            // 2. the final child batch task: isChildBatchRuntimeTask and isChildBatchFinalTask are both true
            if (isChildBatchRuntimeTask != isChildBatchFinalTask)
            {
                // fail because the batch task does not contain the full consolidation date range when it should
                throw error(error::wrongUseOfFunction(funcName()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSysObjectForGJETable</Name>
				<Source><![CDATA[
    private SysDaQueryObject createSysObjectForGJETable(
        GeneralJournalEntry _generalJournalEntry,
        RefRecId _ledger,
        TransDate _fromDate,
        TransDate _toDate)
    {
        FieldName accountingDate = fieldStr(GeneralJournalEntry, AccountingDate);
        FieldName ledger = fieldStr(GeneralJournalEntry, Ledger);

        SysDaQueryObject sysQueryObj = new SysDaQueryObject(_generalJournalEntry);

        var whereClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(_generalJournalEntry, ledger),
            new SysDaValueExpression(_ledger))
            .and(new SysDaGreaterThanOrEqualsExpression(
                new SysDaFieldExpression(_generalJournalEntry, accountingDate),
                new SysDaValueExpression(_fromDate)))
            .and(new SysDaLessThanOrEqualsExpression(
                new SysDaFieldExpression(_generalJournalEntry, accountingDate),
                new SysDaValueExpression(_toDate)));

        sysQueryObj.whereClause(whereClause);

        sysQueryObj.projection().Add(accountingDate);
        sysQueryObj.firstOnlyHint = SysDaFirstOnlyHint::FirstOnly1;
        sysQueryObj.orderByClause(new SysDaOrderBys().add(accountingDate));

        return sysQueryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSysObjectForGJAETable</Name>
				<Source><![CDATA[
    private SysDaQueryObject createSysObjectForGJAETable(
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        GeneralJournalEntry _generalJournalEntry)
    {
        SysDaQueryObject sysQueryObj = new SysDaQueryObject(_generalJournalAccountEntry);
        sysQueryObj.projection().add('');

        var whereClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(_generalJournalAccountEntry, fieldStr(GeneralJournalAccountEntry, GeneralJournalEntry)),
            new SysDaFieldExpression(_generalJournalEntry, fieldStr(GeneralJournalEntry, RecId)));

        sysQueryObj.whereClause(whereClause);

        return sysQueryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSysObjectForHistRefTable</Name>
				<Source><![CDATA[
    private SysDaQueryObject createSysObjectForHistRefTable(
        LedgerConsolidateHistRef _ledgerConsolidateHistRef,
        GeneralJournalAccountEntry _generalJournalAccountEntry)
    {
        SysDaQueryObject sysQueryObj = new SysDaQueryObject(_ledgerConsolidateHistRef);
        sysQueryObj.projection().add('');

        var whereClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(_ledgerConsolidateHistRef, fieldStr(LedgerConsolidateHistRef, TransTableId)),
            new SysDaValueExpression(tableNum(GeneralJournalAccountEntry)))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_ledgerConsolidateHistRef, fieldStr(LedgerConsolidateHistRef, TransRecId)),
                new SysDaFieldExpression(_generalJournalAccountEntry, fieldStr(GeneralJournalAccountEntry, RecId))));

        sysQueryObj.whereClause(whereClause);

        return sysQueryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSysObjectForHistTable</Name>
				<Source><![CDATA[
    private SysDaQueryObject createSysObjectForHistTable(
        LedgerConsolidateHist _ledgerConsolidateHist,
        LedgerConsolidateHistRef _ledgerConsolidateHistRef,
        CompanyId _originCompany)
    {
        SysDaQueryObject sysQueryObj = new SysDaQueryObject(_ledgerConsolidateHist);
        sysQueryObj.projection().add('');

        var whereClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(_ledgerConsolidateHist, fieldStr(LedgerConsolidateHist, CompanyIdOrigin)),
            new SysDaValueExpression(_originCompany))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_ledgerConsolidateHist, fieldStr(LedgerConsolidateHist, RecId)),
                new SysDaFieldExpression(_ledgerConsolidateHistRef, fieldStr(LedgerConsolidateHistRef, RefRecId))));

        sysQueryObj.whereClause(whereClause);

        return sysQueryObj;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSysObjectForMainAccountTable</Name>
				<Source><![CDATA[
    private SysDaQueryObject createSysObjectForMainAccountTable(
        MainAccount _mainAccount,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        RefRecId _ledgerChartOfAccounts,
        MainAccountNum _fromMainAccount = '',
        MainAccountNum _toMainAccount = '')
    {
        SysDaQueryObject sysQueryObj = new SysDaQueryObject(_mainAccount);
        sysQueryObj.projection().add('');

        var whereClause = new SysDaEqualsExpression(
            new SysDaFieldExpression(_mainAccount, fieldStr(MainAccount, LedgerChartOfAccounts)),
            new SysDaValueExpression(_ledgerChartOfAccounts))
            .and(new SysDaGreaterThanOrEqualsExpression(
                new SysDaFieldExpression(_mainAccount, fieldStr(MainAccount, MainAccountId)),
                new SysDaValueExpression(_fromMainAccount)))
            .and(new SysDaLessThanOrEqualsExpression(
                new SysDaFieldExpression(_mainAccount, fieldStr(MainAccount, MainAccountId)),
                new SysDaValueExpression(_toMainAccount)))
            .and(new SysDaEqualsExpression(
                new SysDaFieldExpression(_mainAccount, fieldStr(MainAccount, RecId)),
                new SysDaFieldExpression(_generalJournalAccountEntry, fieldStr(GeneralJournalAccountEntry, MainAccount))));

        sysQueryObj.whereClause(whereClause);

        return sysQueryObj;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>