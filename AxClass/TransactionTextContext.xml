<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TransactionTextContext</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TransactionTextContext</c> class enables additional parameter value
/// functionality for documents having a transaction text associated with posting.
/// </summary>
[SourceDocumentEnumLiteralExtension(enumStr(LedgerTransTxt), enumLiteralStr(LedgerTransTxt, None))]
public abstract class TransactionTextContext
{
    LedgerTransTxt      ledgerTransTxt;
    container           parameters;
    
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>getParameterValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the actual values for the parameter keys for the particular transaction type.
    /// </summary>
    /// <param name="_transactTxt">
    /// The <c>TransactTxt</c> table record to look up the parameters.
    /// </param>
    /// <returns>
    /// A <c>Map</c> that contains the key value pairs for each parameter.
    /// </returns>
    /// <remarks>
    /// The map is sorted by negative parameter number to ensure the key value is not the prefix of another
    /// key value when the transaction text is generated by string replacement.
    /// </remarks>
    public final Map getParameterValues(TransactTxt _transactTxt)
    {
        DictField                       dictField;
        DictEnum                        dictEnum;
        TableId                         tableId;
        FieldId                         fieldId;
        Map                             ret;
        Counter                         i;
        Common                          common;
        TransactionTextParameterSetup   transactionTextParameterSetup;

        ret = new Map(Types::Integer, Types::String);

        this.setParameters();

        for (i = 1; i <= conLen(parameters); i++)
        {
            common = conPeek(parameters, i);

            //Find the parameter according the recId of TransactTxt and RefTableName
            while select ParameterNumber, ReferenceFieldName
                from transactionTextParameterSetup
                where transactionTextParameterSetup.TransactText == _transactTxt.RecId
                   && transactionTextParameterSetup.ReferenceTableName == tableId2Name(common.TableId)
            {
                tableId = common.TableId;
                fieldId = fieldName2id(tableId, transactionTextParameterSetup.ReferenceFieldName);
                dictField = new DictField(tableId, fieldId);

                if (dictField.type() == Types::Enum)
                {
                    // Enums need special consideration while running under IL as they are seen as int
                    dictEnum = new dictEnum(dictField.enumId());

                    ret.insert(
                        -transactionTextParameterSetup.ParameterNumber,
                        strFmt("%1", dictEnum.index2Label(common.(fieldName2id(common.TableId, transactionTextParameterSetup.ReferenceFieldName)))));
                }
                else
                {
                    // Insert the parameter's actual value in map, sorted by parameter No.
                    ret.insert(
                        -transactionTextParameterSetup.ParameterNumber,
                        strFmt("%1", common.(fieldName2id(common.TableId, transactionTextParameterSetup.ReferenceFieldName))));
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSupportedTables</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a list of tables supported for use with the specified transaction type.
    /// </summary>
    /// <returns>
    /// A container that contains the table ID of tables supported by specified transaction type.
    /// </returns>
    /// <remarks>
    /// The container contains only those tables associated with the specified transaction type.
    /// </remarks>
    public abstract container getSupportedTables()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the transaction type.
    /// </summary>
    /// <param name="_ledgerTransText">
    /// The <c>LedgerTransTxt</c> value that represents the specified transaction type.
    /// </param>
    private void parmTransactionType(LedgerTransTxt _ledgerTransText)
    {
        ledgerTransTxt = _ledgerTransText;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the parameter variable to contain the table buffers used with the specified transaction type.
    /// </summary>
    /// <remarks>
    /// This method must be called before it tries to map the table fields and values for the transaction
    /// text setup parameters.
    /// </remarks>
    public abstract void setParameters()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTableBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets a particular table buffer for the specified transaction type.
    /// </summary>
    /// <param name="_common">
    /// The <c>Common</c> table record buffer that is passed in and then set based on the table ID of the
    /// buffer.
    /// </param>
    /// <returns>
    /// true if the table is supported and buffer is saved; otherwise false.
    /// </returns>
    /// <remarks>
    /// The common record buffer is cast to the appropriate table through switch logic. This method can be
    /// called repeatedly to assign multiple buffers.
    /// </remarks>
    public abstract boolean setTableBuffer(Common  _common)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides a string representing the list of parameters by table name and field name.
    /// </summary>
    /// <param name="_transactTxt">
    /// The <c>TransactTxt</c> record to use for the lookup.
    /// </param>
    /// <returns>
    /// A string with the table name and field name of each custom parameter setup for the selected <c>TransactTxt</c> record.
    /// </returns>
    /// <remarks>
    /// The results are returned in the fashion: %n = TableName.FieldName
    /// </remarks>
    public static Description255 getParameters(RefRecId _transactTxt)
    {
        Description255                  ret;
        TransactionTextParameterSetup   transactionTextParameterSetup;
        int                             variableCount;

        while select ParameterNumber, ReferenceTableName, ReferenceFieldName
            from transactionTextParameterSetup
            order by ParameterNumber
            where transactionTextParameterSetup.TransactText == _transactTxt
        {
            if (variableCount > 0)
            {
                ret += ', ';
            }

            ret +=  '%' + int2str(transactionTextParameterSetup.ParameterNumber) +
                    ' = ' + transactionTextParameterSetup.ReferenceTableName +
                    '.' + transactionTextParameterSetup.ReferenceFieldName;

            variableCount++;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTypeSupported</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the transaction type is supported for transaction text custom parameters.
    /// </summary>
    /// <param name="_type">
    /// The <c>LedgerTransTxt</c> type to check against.
    /// </param>
    /// <returns>
    /// true if the transaction type is supported; otherwise, false.
    /// </returns>
    public static boolean isTypeSupported(LedgerTransTxt _type)
    {
        SourceDocumentExtensionKey extensionKey = [enumNum(LedgerTransTxt), _type];

        TransactionTextContext transactionTextContext = SourceDocumentExtensionFactory::newObject(classNum(TransactionTextContext), extensionKey);

        return transactionTextContext != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newForTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>TransactionTextContext</c> class.
    /// </summary>
    /// <param name="_type">
    /// The <c>LedgerTransTxt</c> enumeration type representing the specified transaction type that will be
    /// used to create the <c>TransactionTextContext</c> instance.
    /// </param>
    /// <returns>
    /// A <c>TransactionTextContext</c> instance.
    /// </returns>
    /// <exception cref="M:Exception::Warning">
    /// Thrown when method is called using a <c>LedgerTransTxt</c> type that is not supported.
    /// </exception>
    public static TransactionTextContext newForTransactionType(LedgerTransTxt _type)
    {
        TransactionTextContext transactionTextContext;
        SourceDocumentExtensionKey extensionKey = [enumNum(LedgerTransTxt), _type];

        if (TransactionTextContext::isTypeSupported(_type))
        {
            transactionTextContext = SourceDocumentExtensionFactory::newObject(classNum(TransactionTextContext), extensionKey);
            transactionTextContext.parmTransactionType(_type);
        }
        else
        {
            throw warning(strFmt("@GLS63908", _type));
        }

        return transactionTextContext;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionTextContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set transaction text context for the TransactionTxt.
    /// </summary>
    //// <param name="_transactionTxt">
    /// The <c>TransactionTxt</c> used to set transaction text context.
    /// </param>
    /// <param name="_type">
    /// The <c>LedgerTransTxt</c> type to check against and create a transactionTextContext instance.
    /// </param>
    /// <param name="_common">
    /// The <c>Common</c> table record buffer used to set table buffer.
    /// </param>
    public static void setTransactionTextContext(TransactionTxt _transactionTxt, LedgerTransTxt _type, Common _common)
    {
        if (TransactionTextContext::isTypeSupported(_type))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_type);
            transactionTextContext.setTableBuffer(_common);
            _transactionTxt.setTransactionTextContext(transactionTextContext);
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>