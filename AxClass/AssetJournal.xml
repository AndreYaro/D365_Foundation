<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetJournal</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>AssetJournal</c> class is used to create asset journal transactions and vouchers.
/// </summary>
class AssetJournal
{
    // <GEEU><GCN><GJP>
    #isoCountryRegionCodes
    // </GJP></GCN></GEEU>
    TransactionTxt              transactionTxt;

    LedgerJournalTrans          ledgerJournalTrans;
    LedgerJournalTrans_Asset    ledgerJournalTrans_Asset;
    LedgerJournalEngine         ledgerJournalEngine;

    Voucher                     voucher;
    LedgerJournalId             journalNum;
    AssetTransTypeJournal       assetTransType;
    LedgerJournalAC             ledgerJournalOffsetAccount;
    LedgerDimensionDefaultAccount defaultJournalOffsetLedgerDimension;
    NewVoucher                  newVoucherType;

    boolean                     oneVoucher;
    boolean                     isCatchUpDepreciation;
    boolean                     isDepreciationAdjustment;
    // <GEEPL>
    TransDate                   lastDeprTransDate;
    // </GEEPL>
    // <GCN>
    LedgerVoucherTypeId_CN      voucherType_CN;
    Voucher_CN                  voucher_CN;
    boolean                     isChineseVoucher;
    Voucher_CN                  prevVoucherCN;
    // </GCN>
    // <GCN><GJP>
    AssetAllocationRule_CN      allocationRule;
    AssetAllocationRuleLine_CN  allocationRuleLine;
    Voucher                     prevVoucher;
    boolean                     isCNorJPRegion;
    // </GJP></GCN>
    boolean                     isIsoRU;
    Correct_RU                  correct_RU;
    TransDate                   accountingDate_RU;

    ReasonRefRecID              reasonRefRecID;
    ReasonCode                  reasonCode;
    ReasonComment               reasonComment;
    AssetAmountReportingCurrency  reportingCurrencyAmount;
    // <GIN>
    [SysObsolete('isLedgerJournalTransUpdate for the module is deprecated, use isLedgerJournalTransUpdate_IN instead', false, 11\06\2024)]
    boolean                     isLedgerJournalTransUpdate;
    boolean isLedgerJournalTransUpdate_IN;
    // </GIN>
    private boolean isProposal;
    private LineNum journalLineNum;
    private boolean skipAutoJournalLineNum;
    private AssetDepreciationPeriod assetDepreciationPeriod = AssetDepreciationPeriod::construct();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a transaction for an asset journal.
    /// </summary>
    /// <param name="_amount">
    ///    The amount of the transaction.
    /// </param>
    /// <param name="_assetBook">
    ///    The asset book of the transaction.
    /// </param>
    /// <param name="_transDate">
    ///    The date of the transaction.
    /// </param>
    /// <param name="_assetBudgetModelId">
    ///    The budget model of the transaction; optional.
    /// </param>
    /// <param name="_period">
    ///    The depreciation period of the transaction; optional.
    /// </param>
    /// <param name="_consumptionQty">
    ///    The amount of the fixed asset to consume; optional.
    /// </param>
    /// <param name="_revaluationTrans">
    ///    A flag that indicates whether this transaction is for revaluating the fixed asset; optional.
    /// </param>
    /// <param name="_revaluationAmount">
    ///    The amount to revaluate if it is a revaluation; optional.
    /// </param>
    /// <param name="_custTransId">
    ///    The associated customer transaction record if this is customer-related; optional.
    /// </param>
    /// <param name="_firstTransDate">
    ///    The first transaction date of the transaction; optional.
    /// </param>
    /// <param name="_isProposalAcquisition">
    ///    If this is an acquisition proposal; optional.
    /// </param>
    /// <param name="_isPriorYear">
    ///    If this is for prior year; optional.
    /// </param>
    /// <param name="_assetDocumentType">
    ///    The asset document type; optional.
    /// </param>
    /// <param name="_assetDocumentEntryRecId">
    ///    The asset document entry recid; optional.
    /// </param>
    /// <param name="_reserveJournals">
    ///    List of information for special reserve transaction.
    /// </param>
    /// <param name = "_prevLedgerJournalTrans">
    ///     The previous <c>LedgerJournalTrans</c> record; optional.
    /// </param>
    /// <param name="_ledgerJournalTransTxt">
    ///    Custom transaction description; optional.
    /// </param>
    /// <param name="_defaultDimension_RU">The default dimension; optional.</param>
    public void createTrans(
        AmountCur                      _amount,
        AssetBook                      _assetBook,
        TransDate                      _transDate,
        AssetBudgetModelId             _assetBudgetModelId     = '',
        AssetDepreciationTime          _period                 = 0,
        AssetConsumptionQty            _consumptionQty         = 0,
        AssetRevaluationTrans          _revaluationTrans       = false,
        AssetRevaluationAmount         _revaluationAmount      = 0,
        RecId                          _custTransId            = 0,
        TransDate                      _firstTransDate         = dateNull(),
        boolean                        _isProposalAcquisition  = false,
        boolean                        _isPriorYear            = false
        // <GJP>
        ,AssetDocumentType_JP          _assetDocumentType       = AssetDocumentType_JP::None
        ,AssetDocumentRecId_JP         _assetDocumentEntryRecId = 0
        ,List                          _reserveJournals         = null,
        // </GJP>
        LedgerJournalTrans            _prevLedgerJournalTrans   = null,
        LedgerJournalTransTxt         _ledgerJournalTransTxt = '',
        DimensionDefault              _defaultDimension_RU   = 0
        )
    {
        LedgerJournalTable ledgerJournalTable;

        // <GJP>
        #AssetDepCalculation_JP
        container reserveInfo;
        boolean isJPRegion = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoJP]);
        // </GJP>
        // <GIN>
        boolean depreciationParameters_IN = AssetParameters::checkAssetParameters_IN();
        // </GIN>

        // <GCN>
        isChineseVoucher = LedgerParameters::isChineseVoucher_CN();
        // </GCN>

        this.populateLedgerJournalTrans(_amount, _assetBook, _transDate,
            _assetBudgetModelId, _period, _consumptionQty, _revaluationTrans,
            _revaluationAmount, _custTransId, _firstTransDate, _isPriorYear,
            _assetDocumentType, _assetDocumentEntryRecId, _prevLedgerJournalTrans,
            _ledgerJournalTransTxt, _defaultDimension_RU);

        // <GIN>
        if (isLedgerJournalTransUpdate_IN || isLedgerJournalTransUpdate)
        {
            return;
        }
        // </GIN>

        ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();
        if (ledgerJournalTable.CurrentOperationsTax != AssetBookTable::find(_assetBook.BookId).CurrentOperationsTax)
        {
            throw error(strFmt("@FixedAssets:FA_MessageError_DiscrepancyBetweenJournalAndBookPostingLayers",
                           ledgerJournalTrans.parmAccount(),
                           _assetBook.BookId,
                           ledgerJournalTable.CurrentOperationsTax,
                           AssetBookTable::find(_assetBook.BookId).CurrentOperationsTax));
        }

        // <GCN>
        if (isChineseVoucher)
        {
            // Fill the voucher type with the value user selected in the proposal dialog.
            ledgerJournalTrans.LedgerVoucherType_CN = LedgerVoucherType_CN::findByNaturalKey(voucherType_CN).RecId;
            ledgerJournalTrans.Voucher_CN = voucher_CN;
            ledgerJournalTrans.write();

            // Do not forget about saving previous chineese voucher value in intended variablelist
            // Otherwise all chineese voucher logic will not work.
            prevVoucherCN = ledgerJournalTrans.Voucher_CN;
        }
        else
        {
        // </GCN>
           ledgerJournalTrans.insert();
        // <GCN>
        }
        // </GCN>


        if (AssetParameters::transTypeRequiresValidation(this.parmAssetTransType())
            && (ledgerJournalTrans.ReasonRefRecID == 0
                || !ReasonTableRef::find(ledgerJournalTrans.ReasonRefRecID).Reason))
        {
            // The Reason code required.
            warning (strFmt("@SYS110217", "@SYS111246"));
        }

        if (isDepreciationAdjustment)
        {
            this.parmLedgerJournalTrans(ledgerJournalTrans);
        }

        ledgerJournalTrans_Asset.RefRecId = ledgerJournalTrans.RecId;
        ledgerJournalTrans_Asset.IsAdjustedDepreciation = isCatchUpDepreciation;
        ledgerJournalTrans_Asset.insert();

        // If we are creating lines for an asset journal then we must also create the AssetBookTableDerivedJournal
        // records as they can be modified on this form.

        if (depreciationParameters_IN)
        {
            this.fillDerivedJournals_IN(ledgerJournalTrans, ledgerJournalTrans_Asset, _assetBook);
        }
        else if (ledgerJournalTable.JournalType == LedgerJournalType::Assets)
        {
            LedgerJournalEngine::createDefsForAssetBookTableDerivedJourn(ledgerJournalTrans, ledgerJournalTrans_Asset);
        }

        if (ledgerJournalEngine)
        {
            ledgerJournalEngine.write(ledgerJournalTrans);
        }
        // <GJP>
        if (isJPRegion
            && ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::ExtraordinaryDepreciation)
        {
            // Stores the information for current special reserve journal
            if (ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::AdditionalDepReserve)
            {
                reserveInfo = conNull();
                reserveInfo = conIns(reserveInfo, #PosForReserveDate, ledgerJournalTrans.TransDate);
                if (ledgerJournalTrans.AmountCurCredit)
                {
                    reserveInfo = conIns(reserveInfo, #PosForReserveAmount, -ledgerJournalTrans.AmountCurCredit);
                }
                else
                {
                    reserveInfo = conIns(reserveInfo, #PosForReserveAmount, LedgerJournalTrans.AmountCurDebit);
                }
                reserveInfo = conIns(reserveInfo, #PosForReserveRecId, ledgerJournalTrans_Asset.RecId);
                reserveInfo = conIns(reserveInfo, #PosForReserveTableId, tableNum(LedgerJournalTrans_Asset));
                reserveInfo = conIns(reserveInfo, #PosForReserveDocType, LedgerJournalTrans_Asset.DocumentType_JP);

                _reserveJournals.addEnd(reserveInfo);
            }
            //Create extra information for current special allocation journals
            else if (ledgerJournalTrans_Asset.DocumentType_JP == AssetDocumentType_JP::AdditionalDepReserveAllocation)
            {
                AssetDepDistributionLine_JP::updateAssetDepDistribution(
                    0,
                    ledgerJournalTrans_Asset.TableId,
                    ledgerJournalTrans_Asset.RecId,
                    LedgerJournalTrans.TransDate,
                    _assetDocumentType);
            }
        }
        // </GJP>
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates a <c>LedgerJournalTrans</c> and <c>LedgerJournalTrans_Asset</c> buffers for an asset journal.
    /// </summary>
    /// <param name="_amount">The amount of the transaction.</param>
    /// <param name="_assetBook">The asset book of the transaction.</param>
    /// <param name="_transDate">The date of the transaction.</param>
    /// <param name="_assetBudgetModelId">The budget model of the transaction; optional.</param>
    /// <param name="_period">The depreciation period of the transaction; optional.</param>
    /// <param name="_consumptionQty">The amount of the fixed asset to consume; optional.</param>
    /// <param name="_revaluationTrans">A flag that indicates whether this transaction is for revaluating the fixed asset; optional.</param>
    /// <param name="_revaluationAmount">The amount to revaluate if it is a revaluation; optional.</param>
    /// <param name="_custTransId">The associated customer transaction record if this is customer-related; optional.</param>
    /// <param name="_firstTransDate">The first transaction date of the transaction; optional.</param>
    /// <param name="_isPriorYear">If this is for prior year; optional.</param>
    /// <param name="_assetDocumentType">The asset document type; optional.</param>
    /// <param name="_assetDocumentEntryRecId">The asset document entry recid; optional.</param>
    /// <param name="_prevLedgerJournalTrans">The previous <c>LedgerJournalTrans</c> record; optional.</param>
    /// <param name="_ledgerJournalTransTxt">Custom transaction description; optional.</param>
    /// <param name="_defaultDimension_RU">The default dimension; optional.</param>
    public void populateLedgerJournalTrans(
        AmountCur _amount,
        AssetBook _assetBook,
        TransDate _transDate,
        AssetBudgetModelId _assetBudgetModelId = '',
        AssetDepreciationTime _period = 0,
        AssetConsumptionQty _consumptionQty = 0,
        AssetRevaluationTrans _revaluationTrans = false,
        AssetRevaluationAmount _revaluationAmount = 0,
        RecId _custTransId = 0,
        TransDate _firstTransDate = dateNull(),
        boolean _isPriorYear = false,
        // <GJP>
        AssetDocumentType_JP _assetDocumentType = AssetDocumentType_JP::None,
        AssetDocumentRecId_JP _assetDocumentEntryRecId = 0,
        LedgerJournalTrans _prevLedgerJournalTrans = null,
        // </GJP>
        LedgerJournalTransTxt _ledgerJournalTransTxt = '',
        DimensionDefault _defaultDimension_RU = 0
    )
    {
        LedgerJournalTable ledgerJournalTable;
        AssetRefAssetId refAssetId;
        LedgerJournalEngine localJournalEngine;
        LedgerDimensionDefaultAccount defaultOffsetLedgerDimension;

        // <GCN><GJP>
        DimensionDynamicAccount offsetledgerdimension;
        // </GJP></GCN> 

        // <GIN>
        boolean depreciationParameters_IN = AssetParameters::checkAssetParameters_IN();
        isLedgerJournalTransUpdate_IN = false;
        isLedgerJournalTransUpdate = false;
        // </GIN>

        // <GCN>
        isChineseVoucher = LedgerParameters::isChineseVoucher_CN();
        // </GCN>

        AssetTable assetTable = _assetBook.assetTable();
        AssetBookTable assetBookTable = _assetBook.assetBookTable();


        // <GIN>
        if (depreciationParameters_IN)
        {
            if (!_assetBook)
            {
                return;
            }
            if (_assetBook.AssetGroupDepreciation_IN == NoYes::Yes
                && (assetTransType == AssetTransTypeJournal::Depreciation
                    || assetTransType == AssetTransTypeJournal::DepreciationAdj))
            {
                if (this.updateJournal_IN(_assetBook, _amount, _transDate))
                {
                    isLedgerJournalTransUpdate_IN = true;
                    isLedgerJournalTransUpdate = true;
                    return;
                }
            }
            if (!_assetBook.Depreciation && !_assetBook.AssetGroupDepreciation_IN)
            {
                if (this.IsTransTypeDepreciationRelated_IN(assetTransType))
                {
                    refAssetId = _assetBook.AssetId;
                    assetTable = AssetTable::depreciatingAncestor(_assetBook);
                    if (!assetTable)
                    {
                        return;
                    }
                }
            }
        }
        // </GIN>
        else
        {
            if (!_assetBook.Depreciation)
            {
                if (AssetCalculateDepreciationFieldFlight::instance().isEnabled())
                {
                    if (assetTransType == AssetTransTypeJournal::DepreciationAdj
                        && _assetBook.IsTrueUpDepreciation)
                    {
                        refAssetId = _assetBook.AssetId;
                        assetTable = AssetTable::depreciatingAncestor(_assetBook);
                    }
                    else if (this.IsTransTypeDepreciationRelated(assetTransType))
                    {
                        refAssetId = _assetBook.AssetId;
                        assetTable = AssetTable::depreciatingAncestor(_assetBook);
                        if (!assetTable)
                        {
                            return;
                        }
                    }
                }
                else if (this.IsTransTypeDepreciationRelated(assetTransType))
                {
                    refAssetId = _assetBook.AssetId;
                    assetTable = AssetTable::depreciatingAncestor(_assetBook);
                    if (!assetTable)
                    {
                        return;
                    }
                }
            }
        }

        ledgerJournalTrans.JournalNum = journalNum;

        // <GCN><GJP>
        if (!prevVoucher)
        {
        // </GJP></GCN>
            // For derogatory transactions of type Depreciation, Derogatory increase/decrease,
            // make sure that the transactions have the same vouchers.  The reversal process needs
            // all derogatory transactions to share the same voucher numbers.
            if ((_assetBook.AssetDerogatoryModel_FR || _assetBook.IsDerogatoryBook_FR)
                && (assetTransType == AssetTransTypeJournal::Depreciation
                 || assetTransType == AssetTransTypeJournal::DerogatoryDecrease
                 || assetTransType == AssetTransTypeJournal::DerogatoryIncrease))
            {
                voucher = this.getLastVoucherByJournalNumAndTransDate(
                    ledgerJournalTrans.JournalNum,
                    _transDate,
                    _assetBook.AssetId);

                // <GCN>
                if (isChineseVoucher)
                {
                    if (!voucherType_CN)
                    {
                        voucherType_CN = LedgerVoucherType_CN::findDefault().Id;
                    }
                    voucher_CN = this.getLastVoucherByJourNumAndTransDate_CN(ledgerJournalTrans.JournalNum,
                                                                            _transDate);
                }
                // </GCN>
                if (!voucher)
                {
                    this.createVoucher();
                }
            }

            // When depreciation adjustment is created with acquisition adjustment, the voucher info assigned to the
            // Acquisition Adjustment is reused.  If the voucher info is missing, the voucher is created.
            else if (isDepreciationAdjustment
                && oneVoucher
                && assetTransType == AssetTransTypeJournal::DepreciationAdj)
            {
                if (!voucher)
                {
                    if (AssetJournalCreateVoucherFlight::instance().isEnabled())
                    {
                        this.createRealVoucher();
                    }
                    else
                    {
                        this.createVoucher();
                    }
                }
            }
            else if (this.takeNewVoucher())
            {
                // <GEEPL>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    if (assetTransType != AssetTransTypeJournal::AccumulatedDepreciation_PL
                        && assetTransType != AssetTransTypeJournal::PostingOffAccDepreciation_PL)
                    {
                        if (assetTransType == AssetTransTypeJournal::NotCostAllocatedPart_PL)
                        {
                            if (!lastDeprTransDate || lastDeprTransDate != _transDate)
                            {
                                this.createVoucher();
                            }
                        }
                        else
                        {
                            this.createVoucher();
                        }
                        lastDeprTransDate = _transDate;
                    }
                }
                else
                {
                // </GEEPL>
                    this.createVoucher();
                // <GEEPL>
                }
                // </GEEPL>
            }
        // <GCN><GJP>
        }
        else
        {
            voucher = prevVoucher;
        }
        // </GJP></GCN>

        // <GCN>
        if (!prevVoucherCN)
        {
            if (isChineseVoucher)
            {
                if (!voucherType_CN)
                {
                    voucherType_CN = LedgerVoucherType_CN::findDefault().Id;
                }
                this.createVoucher_CN(_transDate);
            }
        }
        else
        {
            voucher_CN = prevVoucherCN;
        }
        // </GCN>
        ledgerJournalTrans.clear();

        ledgerJournalTrans.initValue();

        ledgerJournalTrans.JournalNum               = journalNum;
        ledgerJournalTrans.LineNum                  = this.getNextLineNum();
        ledgerJournalTrans.Voucher                  = voucher;
        ledgerJournalTrans.parmAccount(_assetBook.AssetId, LedgerJournalACType::FixedAssets);

        if (_prevLedgerJournalTrans)
        {
            ledgerJournalTrans.PostingProfile = _prevLedgerJournalTrans.PostingProfile;
        }
        else if (assetBookTable.postToGeneralLedger())
        {
            ledgerJournalTrans.PostingProfile           = assetTable.postingProfile(_assetBook.BookId);
        }
        ledgerJournalTrans.TransactionType          = LedgerTransType::FixedAssets;
        ledgerJournalTrans.TransDate                = _transDate;
        ledgerJournalTrans.CurrencyCode             = Ledger::accountingCurrency();
        ledgerJournalTrans.ExchRate                 = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);

        ledgerJournalTrans.ReasonRefRecID = ReasonTableRef::createReasonTableRef(reasonCode, reasonComment);

        if (!_ledgerJournalTransTxt)
        {
            if (isDepreciationAdjustment)
            {
                transactionTxt = TransactionTxt::construct(LedgerTransTxt::DepreciationAdjustment);

                if (!AssetDepreciationAdjustmentPriorYearFlight::instance().isEnabled())
                {
                    ledgerJournalTrans_Asset.IsPriorYear = _isPriorYear;
                }
            }
            else
            {
                transactionTxt = TransactionTxt::construct(LedgerTransTxt::FixedAssetsPostingLedger);
                transactionTxt.setDate(_firstTransDate ? _firstTransDate : _transDate);
                transactionTxt.setVoucher(voucher);
                transactionTxt.setKey1(assetTable.AssetId);
                transactionTxt.setKey2(assetTable.AssetGroup);
            }

            if (TransactionTextContext::isTypeSupported(LedgerTransTxt::FixedAssetsPostingLedger))
            {
                TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::FixedAssetsPostingLedger);
                transactionTextContext.setTableBuffer(assetTable);
                transactionTxt.setTransactionTextContext(transactionTextContext);
            }

            ledgerJournalTrans.Txt = transactionTxt.txt();
        }
        else
        {
            ledgerJournalTrans.Txt = _ledgerJournalTransTxt;
        }

        if (_firstTransDate 
            && _transDate 
            && !ledgerJournalTrans.Txt)
        {
            AssetTableInterval calendarInterval = AssetTableInterval::construct(
                _assetBook.depreciationProfile(), 
                assetBookTable.FiscalCalendar);

            if (calendarInterval.findFirstDayOfYear(_assetBook.LastDepreciationDate) == calendarInterval.findFirstDayOfYear(_transDate))
            {
                ledgerJournalTrans.Txt = strFmt("@FixedAssets:DescForDepProposal", 
                    date2StrUsr(calendarInterval.startOfPeriod(_assetBook.LastDepreciationDate + 1), DateFlags::FormatAll),
                    date2StrUsr(_transDate, DateFlags::FormatAll));
            }
            else if (calendarInterval.findFirstDayOfYear(_assetBook.UsedFromDate) == calendarInterval.findFirstDayOfYear(_transDate))
            {
                ledgerJournalTrans.Txt = strFmt("@FixedAssets:DescForDepProposal",
                    date2StrUsr(_assetBook.UsedFromDate, DateFlags::FormatAll),
                    date2StrUsr(_transDate, DateFlags::FormatAll));
            }
            else
            {
                ledgerJournalTrans.Txt = strFmt("@FixedAssets:DescForDepProposal", 
                    date2StrUsr(calendarInterval.findFirstDayOfYear(_transDate), DateFlags::FormatAll),
                    date2StrUsr(_transDate, DateFlags::FormatAll));
            }
        }

        ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;

        if (_prevLedgerJournalTrans)
        {
            ledgerJournalTrans.parmOffsetLedgerDimension(_prevLedgerJournalTrans.parmOffsetLedgerDimension());
        }
        else if (assetBookTable.postToGeneralLedger())
        {
            // <GCN><GJP>
            if (isCNorJPRegion && allocationRuleLine.OffsetLedgerDimension != 0)
            {
                GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceJP00032, funcName());
                defaultOffsetLedgerDimension = allocationRuleLine.OffsetLedgerDimension;
            }
            else
            {
            // </GJP></GCN>
                // Accept the default dimension if it was provided from the caller.
                if (defaultJournalOffsetLedgerDimension)
                {
                    defaultOffsetLedgerDimension = defaultJournalOffsetLedgerDimension;
                }
                else
                {
                    defaultOffsetLedgerDimension = assetTable.assetOffsetLedgerDimension(
                        ledgerJournalTrans.PostingProfile,
                        AssetPost::assetTransTypeJournal2AssetTransType(assetTransType
                            // <GJP>
                            ,_assetDocumentType
                            // </GJP>
                            ),
                        _assetBook.BookId,
                        // A Depreciation Adjustment transaction is posted automatically with a sale transaction
                        // is generated when automatic posted is selected on parameter form.
                        // Verification for offset account is necessary to make sure that offset deprecation transactions
                        // are properly created.
                        (isDepreciationAdjustment ? true : false )
                        // <GJP>
                        ,_assetDocumentType
                        ,_assetDocumentEntryRecId
                        // </GJP>
                        );
                }
            // <GCN><GJP>
            }
            // </GJP></GCN>

            // Set offset ledger dimension
            LedgerDimensionAccount ledgerDimension = this.getOffsetLedgerDimension(defaultOffsetLedgerDimension, _assetBook, LedgerJournalACType::FixedAssets);

            ledgerJournalTrans.parmOffsetLedgerDimension(ledgerDimension);
        }
        else
        {
            ledgerJournalTrans.parmOffsetLedgerDimension(0);
        }

        ledgerJournalTrans.CustTransId              = _custTransId;
        if (_amount > 0)
        {
            if (assetTransType == AssetTransTypeJournal::Depreciation
                && LedgerParameters::find().TransactionReversalCorrection
                && _assetBook.depreciationProfile().FullYearDepreciation_DE
                && _assetBook.depreciationProfile().Method == AssetDepreciationMethod::StraightLineLifeRemaining)

            {
                ledgerJournalTrans.AmountCurCredit = this.roundAmount(-_amount, ledgerJournalTrans.CurrencyCode, _assetBook.BookId);
            }
            else
            {
                ledgerJournalTrans.AmountCurDebit = this.roundAmount(_amount, ledgerJournalTrans.CurrencyCode, _assetBook.BookId);
            }
        }
        else
        {
            ledgerJournalTrans.AmountCurCredit = this.roundAmount(-_amount, ledgerJournalTrans.CurrencyCode, _assetBook.BookId);
        }

        if (ledgerJournalEngine)
        {
            ledgerJournalEngine.voucherTotals(ledgerJournalTrans, true);
        }

        // Create the related LedgerJournalTrans_Asset record.
        ledgerJournalTrans_Asset.clear();
        ledgerJournalTrans_Asset.AssetId                = ledgerJournalTrans.parmAccount();
        ledgerJournalTrans_Asset.Company                = ledgerJournalTrans.Company;
        ledgerJournalTrans_Asset.BudgetModel            = _assetBudgetModelId;
        ledgerJournalTrans_Asset.DepreciationTime       = _period;
        ledgerJournalTrans_Asset.RefAssetID             = refAssetId;
        ledgerJournalTrans_Asset.ConsumptionQuantity    = _consumptionQty;
        ledgerJournalTrans_Asset.BookId                 = _assetBook.BookId;
        ledgerJournalTrans_Asset.RevaluationTrans       = _revaluationTrans;
        ledgerJournalTrans_Asset.RevaluationAmount      = _revaluationAmount;
        ledgerJournalTrans_Asset.TransType              = assetTransType;
        
        if (AssetDepreciationAdjustmentPriorYearFlight::instance().isEnabled()
            && isDepreciationAdjustment)
        {
            ledgerJournalTrans_Asset.IsPriorYear = _isPriorYear;
        }

        if (AssetDepreciationPeriodFlight::instance().isEnabled()
            && isDepreciationAdjustment
            && _isPriorYear == true
            && assetDepreciationPeriod != null
            && assetDepreciationPeriod.isPeriodDefined())
        {
            ledgerJournalTrans_Asset.PeriodFromDate = assetDepreciationPeriod.parmPeriodFromDate();
            ledgerJournalTrans_Asset.PeriodToDate = assetDepreciationPeriod.parmPeriodToDate();
            ledgerJournalTrans_Asset.OriginalTransDate = _transDate;
            ledgerJournalTrans_Asset.OriginalIsPriorYear = ledgerJournalTrans_Asset.IsPriorYear;
        }

        if (ledgerJournalTrans_Asset.isDepreciationTransactionType()
            || ledgerJournalTrans_Asset.isDerogatoryTransactionType_FR())
        {
            if (reportingCurrencyAmount > 0)
            {
                ledgerJournalTrans_Asset.AmountDebitReportingCurrency = this.roundAmount(reportingCurrencyAmount, ledgerJournalTrans_Asset.reportingCurrency(), _assetBook.BookId);
            }
            else
            {
                ledgerJournalTrans_Asset.AmountCreditReportingCurrency = this.roundAmount(-reportingCurrencyAmount, ledgerJournalTrans_Asset.reportingCurrency(), _assetBook.BookId);
            }
        }

        _assetBook.hasHalfYearDepreciation_CZ(ledgerJournalTrans_Asset.TransType, ledgerJournalTrans.TransDate);

        // <GJP>
        if ( _assetDocumentType != AssetDocumentType_JP::None
            && AssetDocumentUtility_JP::isAssetDocumentEnabled())
        {
            if (AssetDocumentUtility_JP::isDocumentTypeWithoutEntry(_assetDocumentType))
            {
                ledgerJournalTrans_Asset.DocumentType_JP = _assetDocumentType;
                ledgerJournalTrans_Asset.AssetDocumentEntry_JP = 0;
            }
            else
            {
                ledgerJournalTrans_Asset.DocumentType_JP = _assetDocumentType;
                ledgerJournalTrans_Asset.AssetDocumentEntry_JP = _assetDocumentEntryRecId;
            }
        }
        else
        {
            ledgerJournalTrans_Asset.DocumentType_JP = AssetDocumentType_JP::None;
            ledgerJournalTrans_Asset.AssetDocumentEntry_JP = 0;
        }
        // </GJP>

        // <GIN>
        if (depreciationParameters_IN)
        {
            ledgerJournalTrans_Asset.AssetGroup_IN = _assetBook.AssetGroup;
        }
        // </GIN>

        // set the defaultDimension field
        localJournalEngine = new LedgerJournalEngine();
        if (_prevLedgerJournalTrans)
        {
            ledgerJournalTrans.DefaultDimension = _prevLedgerJournalTrans.DefaultDimension;
        }
        else if (assetBookTable.postToGeneralLedger())
        {
            localJournalEngine.initDefaultDimension(ledgerJournalTrans, ledgerJournalTrans_Asset);
        }

        // <GCN><GJP>
        if (isCNorJPRegion)
        {
            offsetledgerdimension = this.replaceAllocationDimensionValue_CN(ledgerJournalTrans.parmOffsetLedgerDimension(), defaultOffsetLedgerDimension, allocationRule, allocationRuleLine);
            if (offsetledgerdimension)
            {
                ledgerJournalTrans.parmOffsetLedgerDimension(offsetledgerdimension);
            }
        }
        // </GJP></GCN>

        this.parmLedgerJournalTrans(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the offset ledger account for the default account.
    /// </summary>
    /// <param name="_defaultLedgerDimension">
    /// The default account.
    /// </param>
    /// <param name="_assetBook">
    /// The asset book record.
    /// </param>
    /// <param name="_accountType">
    /// The account type of the entity.
    /// </param>
    /// <returns>
    /// The ledger account.
    /// </returns>
    [Wrappable]
    final protected LedgerDimensionAccount getOffsetLedgerDimension(
        LedgerDimensionDefaultAccount _defaultLedgerDimension, 
        AssetBook                     _assetBook, 
        LedgerJournalACType           _accountType)
    {
        LedgerDimensionAccount ledgerDimension = ledgerJournalTrans.getOffsetLedgerDimensionForProposal(
                                                     _defaultLedgerDimension,
                                                     _assetBook.AssetId,
                                                     _accountType,
                                                     _assetBook.BookId);
        
        if (!ledgerDimension)
        {
            ledgerDimension = ledgerJournalTrans.getOffsetLedgerDimensionForLedgerType(
                                  ledgerJournalTrans.LedgerJournalTable().parmOffsetLedgerDimension(),
                                  ledgerJournalTrans.getOffsetCompany());
        }
        
        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransForReserve</Name>
				<Source><![CDATA[
    public void createTransForReserve(AssetTrans           _assetTrans,
                                      TransDate            _transDate,
                                      TransDate            _transferLimitDate,
                                      AssetBudgetModelId   _assetBudgetModelId = '')
    {
        LedgerJournalTable              ledgerJournalTable;
        SubledgerVoucherGeneralJournalEntry subledgerVoucherGeneralJournalEntry;
        GeneralJournalEntry                 generalJournalEntry;
        GeneralJournalAccountEntry          generalJournalAccountEntry;
        AmountCur                       amount;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;

        ledgerJournalTrans.JournalNum               = journalNum;
        ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();

        if (this.takeNewVoucher())
        {
            this.createVoucher();
        }
        // <GCN>
        isChineseVoucher = LedgerParameters::isChineseVoucher_CN();

        if (isChineseVoucher && !voucherType_CN)
        {
            voucherType_CN = LedgerVoucherType_CN::findDefault().Id;
        }
        if (isChineseVoucher && voucherType_CN)
        {
            this.createVoucher_CN(_transDate);
        }
        // </GCN>

        transactionTxt    = TransactionTxt::construct(LedgerTransTxt::FixedAssetsReverseReserve);
        transactionTxt.setDate(_transDate);
        transactionTxt.setVoucher(voucher);
        transactionTxt.setKey1(_assetTrans.AssetId);
        transactionTxt.setKey2(_assetTrans.BookId);

        AssetBook assetBook = AssetBook::find(_assetTrans.AssetId, _assetTrans.BookId);
        AssetBookTable assetBookTable = assetBook.assetBookTable();

        ledgerJournalTrans.clear();
        ledgerJournalTrans.initValue();

        ledgerJournalTrans.JournalNum               = journalNum;
        ledgerJournalTrans.Voucher                  = voucher;
        if (assetBookTable.postToGeneralLedger() && _transferLimitDate < _transDate)
        {
            ledgerJournalTrans.AccountType = LedgerJournalACType::Ledger;
            defaultLedgerDimension = AssetParameters::find().LedgerDimension;
            ledgerJournalTrans.parmLedgerDimension(
                ledgerJournalTrans.getLedgerDimensionForLedgerType(
                    defaultLedgerDimension,
                    ledgerJournalTrans.Company));
        }
        else
        {
            // Set the account type, but don't default a fixed asset
            ledgerJournalTrans.parmAccount('', LedgerJournalACType::FixedAssets);
        }
        ledgerJournalTrans.TransactionType          = LedgerTransType::FixedAssets;

        if (assetBookTable.postToGeneralLedger())
        {
            ledgerJournalTrans.PostingProfile           = AssetTable::find(_assetTrans.AssetId).postingProfile(_assetTrans.BookId);

            // Find the account entry corresponding to the asset trans
            select firstonly LedgerDimension from generalJournalAccountEntry
                where generalJournalAccountEntry.PostingType == LedgerPostingType::FixedAssetsDebit &&
                    generalJournalAccountEntry.TransactionCurrencyAmount == -_assetTrans.AmountCur &&
                    generalJournalAccountEntry.IsCredit == true &&
                    generalJournalAccountEntry.TransactionCurrencyCode == _assetTrans.CurrencyCode
            exists join RecId from generalJournalEntry
                where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
            exists join RecId from subledgerVoucherGeneralJournalEntry
                where subledgerVoucherGeneralJournalEntry.GeneralJournalEntry == generalJournalEntry.RecId &&
                    subledgerVoucherGeneralJournalEntry.Voucher == _assetTrans.Voucher &&
                    subledgerVoucherGeneralJournalEntry.AccountingDate == _assetTrans.TransDate;

            // Set offset ledger dimension
            ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
            if (generalJournalAccountEntry.LedgerDimension)
            {
                ledgerJournalTrans.parmOffsetLedgerDimension(generalJournalAccountEntry.LedgerDimension);
            }
        }
        ledgerJournalTrans.TransDate                = _transDate;
        ledgerJournalTrans.CurrencyCode             = Ledger::accountingCurrency();
        ledgerJournalTrans.ExchRate                 = ExchangeRateHelper::exchRate(ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate);

        ledgerJournalTrans.Txt                      = transactionTxt.txt();
        amount = - _assetTrans.AmountMST;
        if (amount > 0)
        {
            ledgerJournalTrans.AmountCurDebit = this.roundAmount(amount, ledgerJournalTrans.CurrencyCode, _assetTrans.BookId);
        }
        else
        {
            ledgerJournalTrans.AmountCurCredit = this.roundAmount(-amount, ledgerJournalTrans.CurrencyCode, _assetTrans.BookId);
        }

        if (ledgerJournalTable.CurrentOperationsTax != assetBookTable.CurrentOperationsTax)
        {
            throw error(strFmt("@FixedAssets:FA_MessageError_DiscrepancyBetweenJournalAndBookPostingLayers",
                               ledgerJournalTrans.parmAccount(),
                               _assetTrans.BookId,
                               ledgerJournalTable.CurrentOperationsTax,
                               assetBookTable.CurrentOperationsTax
                              )
                       );
        }

        if (ledgerJournalEngine)
        {
            ledgerJournalEngine.voucherTotals(ledgerJournalTrans, true);
        }
        // <GCN>
        if (isChineseVoucher)
        {
            // Fill the voucher type with the value user selected in the proposal dialog.
            ledgerJournalTrans.LedgerVoucherType_CN = LedgerVoucherType_CN::findByNaturalKey(voucherType_CN).RecId;
            ledgerJournalTrans.Voucher_CN = voucher_CN;
            ledgerJournalTrans.write();
        }
        else
        {
        // </GCN>
            ledgerJournalTrans.insert();
        // <GCN>
        }
        // </GCN>
        if (ledgerJournalTrans.AccountType == LedgerJournalACType::FixedAssets)
        {
            // This is a fixed assets transaction, so create a LedgerJournalTrans_Asset record for it.
            ledgerJournalTrans_Asset.RefRecId           = ledgerJournalTrans.RecId;
            ledgerJournalTrans_Asset.AssetId            = ledgerJournalTrans.parmAccount();
            ledgerJournalTrans_Asset.Company            = ledgerJournalTrans.Company;
            ledgerJournalTrans_Asset.TransType          = assetTransType;
            ledgerJournalTrans_Asset.BudgetModel        = _assetBudgetModelId;
            ledgerJournalTrans_Asset.ReserveTransId     = _assetTrans.RecId;
            ledgerJournalTrans_Asset.BookId             = _assetTrans.BookId;
            ledgerJournalTrans_Asset.insert();
        }

        if (ledgerJournalEngine)
            ledgerJournalEngine.write(ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Creates a new voucher number.
    /// </summary>
    public void createVoucher()
    {
        LedgerJournalTable ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();

        if (AssetJournalCreateVoucherFlight::instance().isEnabled())
        {
            voucher = new JournalVoucherNum(JournalTableData::newTable(ledgerJournalTable)).getNew(false);
        }
        else
        {
            boolean isOneVoucherFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetOneVoucherFeature::instance());
            if (ledgerJournalTable.VoucherAllocatedAtPosting && isOneVoucherFeatureEnabled)
            {
                LedgerJournalName ledgerJournalName = LedgerJournalName::find(ledgerJournalTable.JournalName);
                voucher = NumberSeq::newGetVoucherFromId(ledgerJournalName.NumberSequenceTable, false).voucher();
            }
            else
            {
                voucher = new JournalVoucherNum(JournalTableData::newTable(ledgerJournalTable)).getNew(false);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createRealVoucher</Name>
				<Source><![CDATA[
    private void createRealVoucher()
    {
        LedgerJournalTable ledgerJournalTable = ledgerJournalTrans.ledgerJournalTable();

        if (ledgerJournalTable.VoucherAllocatedAtPosting)
        {
            LedgerJournalName ledgerJournalName = LedgerJournalName::find(ledgerJournalTable.JournalName);
            voucher = NumberSeq::newGetVoucherFromId(ledgerJournalName.NumberSequenceTable, false).voucher();
        }
        else
        {
            voucher = new JournalVoucherNum(JournalTableData::newTable(ledgerJournalTable)).getNew(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucher_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates Chinese voucher number for the given transaction date.
    /// </summary>
    /// <param name="_transDate">
    /// The date for which the voucher_CN will be created.
    /// </param>
    private void createVoucher_CN(TransDate _transDate)
    {
        RefRecId            numberSequenceTableRecId;

        numberSequenceTableRecId = LedgerVoucherType_CN::find(LedgerVoucherType_CN::findByNaturalKey(voucherType_CN).RecId).NumberSequenceTable;
        voucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(numberSequenceTableRecId, _transDate).voucher();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fillDerivedJournals_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update all journals related to this asset journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>Ledgerjournaltrans</c> buffer for the asset transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// A <c>Ledgerjournaltrans_asset</c> buffer for the asset transaction.
    /// </param>
    /// <param name="_assetBook">
    /// An <c>Assetbook</c> buffer of the of the asset.
    /// </param>
    public void fillDerivedJournals_IN(LedgerJournalTrans       _ledgerJournalTrans,
                                       LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                       AssetBook                _assetBook)
    {
        AssetBookTable              assetBookTableLocal;
        AssetBookTable              assetBookTableLoc;
        AssetBookTableDerived       assetBookTableDerivedLocal;
        container                   depreciationMarked,
                                    groupDepreciationMarked,
                                    depreciationMarkedNew,
                                    groupDepreciationMarkedNew;
        AssetTransType              assetTransTypeLocal = AssetPost::assetTransTypeJournal2AssetTransType(assetTransType);

        if (_assetBook.AssetGroupDepreciation_IN)
        {
            LedgerJournalEngine::fillAssetGroupBookTableDerivedJournal_IN(ledgerJournalTrans, ledgerJournalTrans_Asset);
        }
        else
        {
            assetBookTableLocal = AssetBookTable::find(_assetBook.BookId);
            if (assetTransType == AssetTransTypeJournal::Depreciation ||
                assetTransType == AssetTransTypeJournal::DepreciationAdj)
            {
                while select BookIdDerived from assetBookTableDerivedLocal
                    where assetBookTableDerivedLocal.BookId         == _assetBook.BookId
                       && assetBookTableDerivedLocal.AssetTransType == assetTransTypeLocal
                {
                    assetBookTableLoc           = AssetBookTable::find(assetBookTableDerivedLocal.BookIdDerived);
                    depreciationMarked          = [AssetBook::find(ledgerJournalTrans.parmAccount(),assetBookTableLocal.BookId).Depreciation,1];
                    depreciationMarkedNew       = [AssetBook::find(ledgerJournalTrans.parmAccount(),assetBookTableLoc.BookId).Depreciation,1];
                    groupDepreciationMarked     = [AssetBook::find(ledgerJournalTrans.parmAccount(),assetBookTableLocal.BookId).AssetGroupDepreciation_IN,1];
                    groupDepreciationMarkedNew  = [AssetBook::find(ledgerJournalTrans.parmAccount(),assetBookTableLoc.BookId).AssetGroupDepreciation_IN,1];

                    if ((conPeek(depreciationMarked,1)      == 1 && conPeek(depreciationMarkedNew,1)        == 1) ||
                        (conPeek(groupDepreciationMarked,1)  == 1 && conPeek(groupDepreciationMarkedNew,1)  == 1))
                    {
                        LedgerJournalEngine::fillAssetBookTableDerivedJournal_IN(ledgerJournalTrans, ledgerJournalTrans_Asset, assetBookTableDerivedLocal.BookIdDerived);
                    }
                }
            }
            else
            {
                LedgerJournalEngine::createDefsForAssetBookTableDerivedJourn(ledgerJournalTrans, ledgerJournalTrans_Asset);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastVoucherByJournalNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the latest voucher number for the specified journal.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number to find in the voucher.
    /// </param>
    /// <returns>
    ///    A voucher number that was retrieved by the Ledger Journal Transaction search.
    /// </returns>
    private Voucher getLastVoucherByJournalNum(LedgerJournalId _journalNum)
    {
        LedgerJournalTrans  ledgerJournalTrxs;

        ledgerJournalTrxs.selectForUpdate(false);
        select firstonly Voucher from ledgerJournalTrxs
            order by Voucher desc
            where   ledgerJournalTrxs.JournalNum == _journalNum;

        return ledgerJournalTrxs.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastVoucherByJournalNum_CN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the latest voucher number for the specified journal.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number for which the voucher_CN will be searched for.
    /// </param>
    /// <returns>
    ///    A chinese voucher number that was retrieved by the Ledger Journal Transaction search.
    /// </returns>
    public Voucher_CN getLastVoucherByJournalNum_CN(LedgerJournalId _journalNum = ledgerJournalTrans.JournalNum)
    {
        LedgerJournalTrans      ledgerJournalTransLocal;

        select firstonly Voucher_CN from ledgerJournalTransLocal
                    order by Voucher_CN desc
                    where ledgerJournalTransLocal.JournalNum == _journalNum;

        return ledgerJournalTransLocal.Voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastVoucherByJournalNumAndTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the latest voucher number for the specified journal and transaction date.
    /// </summary>
    /// <param name="_journalNum">
    ///    The journal number to find in the voucher.
    /// </param>
    /// <param name="_transDate">
    ///    The date to find in the voucher.
    /// </param>
    /// <param name="_assetId">
    ///    Current asset Id.
    /// </param>
    /// <returns>
    ///    A voucher number that was retrieved by the Ledger Journal Transaction search.
    /// </returns>
    private Voucher getLastVoucherByJournalNumAndTransDate(
        LedgerJournalId _journalNum, 
        TransDate _transDate, 
        AssetId _assetId)
    {
        LedgerJournalTrans  ledgerJournalTrxs;
        LedgerJournalTrans_Asset ledgerJournalTrans_assetLocal;

        select firstonly Voucher from ledgerJournalTrxs
            order by Voucher desc
            where ledgerJournalTrxs.JournalNum == _journalNum
                && ledgerJournalTrxs.TransDate == _transDate
            exists join ledgerJournalTrans_assetLocal
                where ledgerJournalTrans_assetLocal.RefRecId == ledgerJournalTrxs.RecId
                    && ledgerJournalTrans_assetLocal.AssetId == _assetId;

        return ledgerJournalTrxs.Voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastVoucherByJourNumAndTransDate_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// This function will return the latest Chinese voucher number for the given Jounral and transaction date.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number for which the voucher_CN will be searched for.
    /// </param>
    /// <param name="_transDate">
    /// The date for which the voucher will be searched for.
    /// </param>
    /// <returns>
    /// A Chinese voucher number that was returned by the Ledger Journal Transaction search.
    /// </returns>
    private Voucher_CN getLastVoucherByJourNumAndTransDate_CN(LedgerJournalId _journalNum, TransDate _transDate)
    {
        LedgerJournalTrans  ledgerJournalTrxs;

        select firstonly Voucher_CN from ledgerJournalTrxs
            order by Voucher_CN desc
            where   ledgerJournalTrxs.JournalNum == _journalNum
                &&  ledgerJournalTrxs.TransDate == _transDate;

        return ledgerJournalTrxs.Voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(LedgerJournalId _journalNum, AssetTransTypeJournal _assetTransType)
    {
        journalNum = _journalNum;
        assetTransType = _assetTransType;

        newVoucherType = LedgerJournalTable::find(journalNum).ledgerJournalName().NewVoucher;

        isCNorJPRegion = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCN, #isoJP]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocationRule_CN</Name>
				<Source><![CDATA[
    public AssetAllocationRule_CN parmAllocationRule_CN(AssetAllocationRule_CN _allocationRule = allocationRule)
    {
        allocationRule = _allocationRule;
        return allocationRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllocationRuleLine_CN</Name>
				<Source><![CDATA[
    public AssetAllocationRuleLine_CN parmAllocationRuleLine_CN(AssetAllocationRuleLine_CN _allocationRuleLine = allocationRuleLine)
    {
        allocationRuleLine = _allocationRuleLine;
        return allocationRuleLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetTransType</Name>
				<Source><![CDATA[
    public AssetTransTypeJournal parmAssetTransType(AssetTransTypeJournal _assetTransType = assetTransType)
    {
        assetTransType = _assetTransType;
        return assetTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetTransTypeJournal</Name>
				<Source><![CDATA[
    public AssetTransTypeJournal parmAssetTransTypeJournal(AssetTransTypeJournal _assetTransType = assetTransType)
    {
        assetTransType = _assetTransType;

        return assetTransType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCNVoucher_CN</Name>
				<Source><![CDATA[
    public Voucher_CN parmCNVoucher_CN()
    {
        return voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCatchUpDepreciation</Name>
				<Source><![CDATA[
    public boolean parmIsCatchUpDepreciation(boolean _isCatchUpDepreciation = isCatchUpDepreciation)
    {
        isCatchUpDepreciation = _isCatchUpDepreciation;

        return isCatchUpDepreciation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDepreciationAdjustment</Name>
				<Source><![CDATA[
    public boolean parmIsDepreciationAdjustment(boolean _isDepreciationAdjustment = isDepreciationAdjustment)
    {
        isDepreciationAdjustment = _isDepreciationAdjustment;

        return isDepreciationAdjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAssetDepreciationPeriod</Name>
				<Source><![CDATA[
    internal AssetDepreciationPeriod parmAssetDepreciationPeriod(AssetDepreciationPeriod _assetDepreciationPeriod = assetDepreciationPeriod)
    {
        assetDepreciationPeriod = _assetDepreciationPeriod;

        return assetDepreciationPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsOneVoucher</Name>
				<Source><![CDATA[
    public boolean parmIsOneVoucher(boolean _isOneVoucher = oneVoucher)
    {
        oneVoucher = _isOneVoucher;

        return oneVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmLedgerJournalOffsetLedgerDimension(
        LedgerDimensionDefaultAccount _defaultJournalOffsetLedgerDimension)
    {
        defaultJournalOffsetLedgerDimension = _defaultJournalOffsetLedgerDimension;
        return defaultJournalOffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>LedgerJournalTrans</c> table used for the asset journals being created.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> table.
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalTrans</c> for the asset journals being created.
    /// </returns>
    public LedgerJournalTrans parmLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTrans)
    {
        ledgerJournalTrans = _ledgerJournalTrans;

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans_Asset</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Gets or sets the <c>LedgerJournalTrans_Asset</c> table used for the asset journals being created.
    /// </summary>
    /// <param name="_ledgerJournalTrans_Asset">The <c>LedgerJournalTrans_Asset</c> table.</param>
    /// <returns>The <c>LedgerJournalTrans_Asset</c> for the asset journals being created.</returns>
    public LedgerJournalTrans_Asset parmLedgerJournalTrans_Asset(LedgerJournalTrans_Asset _ledgerJournalTrans_Asset = ledgerJournalTrans_Asset)
    {
        ledgerJournalTrans_Asset = _ledgerJournalTrans_Asset;
        return ledgerJournalTrans_Asset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevCNVoucher_CN</Name>
				<Source><![CDATA[
    public Voucher_CN parmPrevCNVoucher_CN(Voucher_CN _voucher = prevVoucherCN)
    {
        prevVoucherCN = _voucher;
        return prevVoucherCN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrevVoucher_CN</Name>
				<Source><![CDATA[
    public Voucher parmPrevVoucher_CN(Voucher _voucher = prevVoucher)
    {
        prevVoucher = _voucher;
        return prevVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonCode</Name>
				<Source><![CDATA[
    public ReasonCode parmReasonCode(ReasonCode _reasonCode = reasonCode)
    {
        reasonCode = _reasonCode;
        return reasonCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonComment</Name>
				<Source><![CDATA[
    public ReasonComment parmReasonComment(ReasonComment _reasonComment = reasonComment)
    {
        reasonComment = _reasonComment;
        return reasonComment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRefRecId</Name>
				<Source><![CDATA[
    public ReasonRefRecID parmReasonRefRecId(ReasonRefRecID _reasonRefRecID = reasonRefRecID)
    {
        reasonRefRecID  = _reasonRefRecID;
        return reasonRefRecID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    public Voucher parmVoucher(Voucher _voucher = voucher)
    {
        voucher = _voucher;

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyAmount</Name>
				<Source><![CDATA[
    public AssetAmountReportingCurrency parmReportingCurrencyAmount(AssetAmountReportingCurrency _reportingCurrencyAmount = reportingCurrencyAmount)
    {
        reportingCurrencyAmount = _reportingCurrencyAmount;

        return reportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the voucher type used for the asset journals being created.
    /// </summary>
    /// <param name="_voucherType_CN">
    /// A <c>LedgerVoucherTypeId_CN</c> value representing the voucher type to be used.
    /// </param>
    /// <returns>
    /// The voucher type for the asset journals being created.
    /// </returns>
    public LedgerVoucherTypeId_CN parmVoucherType_CN(LedgerVoucherTypeId_CN _voucherType_CN = voucherType_CN)
    {
        voucherType_CN = _voucherType_CN;
        return voucherType_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate_RU</Name>
				<Source><![CDATA[
    public TransDate parmAccountingDate_RU(TransDate _accountingDate = accountingDate_RU)
    {
        accountingDate_RU = _accountingDate;
        return accountingDate_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCorrect_RU</Name>
				<Source><![CDATA[
    public Correct_RU parmCorrect_RU(Correct_RU _correct = correct_RU)
    {
        correct_RU = _correct;
        return correct_RU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>replaceAllocationDimensionValue_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Replace the main account and the dimension value of one specific demision from a given ledger dimension according to the allocation rule and rule line.
    /// </summary>
    /// <param name="_sourceLedgerDimension">
    /// The given ledger dimension.
    /// </param>
    /// <param name="_defaultOffsetLedgerAccount">
    /// The given offset ledger account.
    /// </param>
    /// <param name="_allocationRule">
    /// The allocation rule for the asset to follow.
    /// </param>
    /// <param name="_allocationRuleLine">
    /// The allocation rule line for current journal line to follow.
    /// </param>
    /// <returns>
    /// Returns a new ledger dimension with new main account and dimension value.
    /// </returns>
    private DimensionDynamicAccount replaceAllocationDimensionValue_CN(
        DimensionDynamicAccount         _sourceLedgerDimension,
        LedgerDimensionDefaultAccount   _defaultOffsetLedgerAccount,
        AssetAllocationRule_CN          _allocationRule,
        AssetAllocationRuleLine_CN      _allocationRuleLine)
    {
        DimensionAttribute                  dimension;
        DimensionAttributeValue             dimensionVal;
        LedgerDimensionAccount              mainAccDimension;
        DimensionDefault                    defaultDimension;
        DimensionAttributeValueSetStorage   dimensionAttributeValueSetStorage;
        LedgerDimensionAccount              result = 0;

        if (!_allocationRule || _allocationRuleLine == null || !_sourceLedgerDimension)
        {
            return result;
        }

        GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceJP00032, funcName());

        defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_sourceLedgerDimension);
        dimension = DimensionAttribute::find(_allocationRule.DimensionAttribute);
        dimensionVal = DimensionAttributeValue::find(_allocationRuleLine.Key);
        if (allocationRuleLine.OffsetLedgerDimension)
        {
            mainAccDimension = allocationRuleLine.OffsetLedgerDimension;
        }
        else
        {
            mainAccDimension = _defaultOffsetLedgerAccount;
        }

        dimensionAttributeValueSetStorage = DimensionAttributeValueSetStorage::find(defaultDimension);
        dimensionAttributeValueSetStorage.addItem(dimensionVal);

        result = LedgerDimensionFacade::serviceCreateLedgerDimension(mainAccDimension, dimensionAttributeValueSetStorage.save());

        if (!result)
        {
            select firstOnly Name from dimension
                where dimension.RecId == allocationRule.DimensionAttribute;
            if (dimension)
            {
                // @SYS4002357 - Invalid allocation rule %1. Failed to allocate to dimension %2 - %3 for main account %4.
                throw error(strFmt("@SYS4002357",
                                        allocationRule.RuleId,
                                        dimension.Name,
                                        allocationRuleLine.LocalizedValue,
                                        LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(allocationRuleLine.OffsetLedgerDimension)));
            }
            else
            {
                // @SYS4002361 - Invalid Financial dimension %1.
                error(strFmt("@SYS4002361", allocationRule.DimensionAttribute));
                // @SYS4002357 - Invalid allocation rule %1. Failed to allocate to dimension %2 - %3 for main account %4.
                throw error(strFmt("@SYS4002357",
                                    allocationRule.RuleId,
                                    allocationRule.DimensionAttribute,
                                    allocationRuleLine.LocalizedValue,
                                    LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(allocationRuleLine.OffsetLedgerDimension)));
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>takeNewVoucher</Name>
				<Source><![CDATA[
    private boolean takeNewVoucher()
    {
        boolean         ret = false;

        switch (newVoucherType)
        {
            case NewVoucher::BalanceSheet:
                ret = true;
                break;

            case NewVoucher::OneVoucher:
                voucher = this.getLastVoucherByJournalNum(journalNum);
                if (!voucher)
                {
                    ret = true;
                }
                break;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournal_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the journal for this asset.
    /// </summary>
    /// <param name="_assetBook">
    /// Asset book of the asset.
    /// </param>
    /// <param name="_amount">
    /// The amount to be updated.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// Returns true if journal is updated.
    /// </returns>
    private boolean updateJournal_IN(AssetBook      _assetBook,
                                     AmountCur      _amount,
                                     TransDate      _transDate)
    {
        LedgerJournalTrans          ledgerJournalTransLoc;
        LedgerJournalTrans_Asset    ledgerJournalTransAssetLoc;
        boolean                     ret = false;

        AssetBook                       assetBook;
        AssetBookTableDerived           assetBookTableDerived;
        AssetBookTableDerivedJournal    assetBookTableDerivedJournal;
        Amount                          amount;
        AssetTransType                  assetTransTypeLoc = AssetPost::assetTransTypeJournal2AssetTransType(assetTransType);

        ttsbegin;

        select forupdate ledgerJournalTransLoc
        join ledgerJournalTransAssetLoc
        where ledgerJournalTransLoc.JournalNum          == journalNum
           && ledgerJournalTransLoc.TransDate           == _transDate
           && ledgerJournalTransAssetLoc.AssetGroup_IN  == _assetBook.AssetGroup
           && ledgerJournalTransAssetLoc.BookId         == _assetBook.BookId
           && ledgerJournalTransLoc.RecId               == ledgerJournalTransAssetLoc.RefRecId;

        if (ledgerJournalTransLoc)
        {
            if (ledgerJournalTransLoc.AmountCurCredit)
            {
                if (_amount > 0)
                {
                    if (_amount > ledgerJournalTransLoc.AmountCurCredit)
                    {
                        ledgerJournalTransLoc.AmountCurDebit = _amount - ledgerJournalTransLoc.AmountCurCredit;
                        ledgerJournalTransLoc.AmountCurCredit = 0;
                    }
                    else
                    {
                        ledgerJournalTransLoc.AmountCurCredit += _amount;
                    }
                }
                else
                {
                    ledgerJournalTransLoc.AmountCurCredit += abs(_amount);
                }
            }
            else
            {
                if (_amount > 0)
                {
                    ledgerJournalTransLoc.AmountCurDebit += abs(_amount);
                }
                else
                {
                    if (abs(_amount) > ledgerJournalTransLoc.AmountCurDebit)
                    {
                        ledgerJournalTransLoc.AmountCurCredit = abs(_amount) - ledgerJournalTransLoc.AmountCurDebit;
                        ledgerJournalTransLoc.AmountCurDebit = 0;
                    }
                    else
                    {
                        ledgerJournalTransLoc.AmountCurDebit += _amount;
                    }
                }
            }
            ledgerJournalTransLoc.update();
            ret = true;
        }

        if (ret)
        {
            // As Posting calls this method we need to make sure we check the primary account type first.
            // The reason for this is that posting shifts the offset field values into the primary fields
            // when posting the offset account.  But it does not clear the offset account type field and
            // this caused problems when posting a transactions with Fixed Assets as an offset.
            if (ledgerJournalTransLoc.AccountType == LedgerJournalACType::FixedAssets)
            {
                amount  = ledgerJournalTransLoc.amount();
            }
            else
            {
                amount  = - ledgerJournalTransLoc.amount();
            }

            select firstOnly forUpdate assetBookTableDerivedJournal
                where assetBookTableDerivedJournal.RefRecId == ledgerJournalTransLoc.RecId
                exists join assetBookTableDerived
                    where assetBookTableDerived.BookId == ledgerJournalTransAssetLoc.BookId
                        && assetBookTableDerived.BookIdDerived == assetBookTableDerivedJournal.AssetBookId;

            if (assetBookTableDerivedJournal.RecId)
            {
                assetBookTableDerivedJournal.AmountCur  = amount;
                assetBookTableDerivedJournal.update();
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>roundAmount</Name>
				<Source><![CDATA[
    private AssetAmount roundAmount(AssetAmount _amount, CurrencyCode _currencyCode, AssetBookId bookId = '')
    {
        AssetAmount ret = CurrencyExchangeHelper::amount(_amount, _currencyCode);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the indicator the asset journal being created from proposal.
    /// </summary>
    /// <param name = "_isProposal">Indicator of journal being created from proposal.</param>
    /// <returns>True if asset journal creation called from proposal; otherwise, false.</returns>
    public boolean parmIsProposal(boolean _isProposal = isProposal)
    {
        isProposal = _isProposal;

        return isProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalLineNum</Name>
				<Source><![CDATA[
    internal LineNum parmJournalLineNum(LineNum _journalLineNum = journalLineNum)
    {
        journalLineNum = _journalLineNum;

        return journalLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipAutoJournalLineNum</Name>
				<Source><![CDATA[
    internal boolean parmSkipAutoJournalLineNum(LineNum _skipAutoJournalLineNum = skipAutoJournalLineNum)
    {
        skipAutoJournalLineNum = _skipAutoJournalLineNum;

        return skipAutoJournalLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNextLineNum</Name>
				<Source><![CDATA[
    private LineNum getNextLineNum()
    {
        if (!skipAutoJournalLineNum)
        {
            if (!journalLineNum)
            {
                journalLineNum = LedgerJournalTrans::lastLineNum(journalNum);
            }

            journalLineNum++;
        }

        return journalLineNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsTransTypeDepreciationRelated</Name>
				<Source><![CDATA[
    private boolean IsTransTypeDepreciationRelated(AssetTransTypeJournal _assetTransType)
    {
        boolean ret = false;

        if (_assetTransType == AssetTransTypeJournal::Depreciation
            || _assetTransType == AssetTransTypeJournal::NotCostAllocatedPart_PL
            || _assetTransType == AssetTransTypeJournal::DepreciationAdj
            || _assetTransType == AssetTransTypeJournal::DerogatoryIncrease
            || _assetTransType == AssetTransTypeJournal::DerogatoryDecrease
            || _assetTransType == AssetTransTypeJournal::ExtraordinaryDepreciation)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>IsTransTypeDepreciationRelated_IN</Name>
				<Source><![CDATA[
    private boolean IsTransTypeDepreciationRelated_IN(AssetTransTypeJournal _assetTransType)
    {
        boolean ret = false;

        if (_assetTransType == AssetTransTypeJournal::Depreciation
            || _assetTransType == AssetTransTypeJournal::DepreciationAdj
            || _assetTransType == AssetTransTypeJournal::DerogatoryIncrease
            || _assetTransType == AssetTransTypeJournal::DerogatoryDecrease
            || _assetTransType == AssetTransTypeJournal::ExtraordinaryDepreciation)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>