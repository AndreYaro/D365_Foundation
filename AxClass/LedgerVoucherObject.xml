<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerVoucherObject</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The LedgerVoucherObject class contains the transactions for a reference number.
/// </summary>
public class LedgerVoucherObject
{
    GeneralJournalEntry generalJournalEntry;

    // <GEEU>
    GeneralJournalEntry_W generalJournalEntryW;
    // </GEEU>

    SysModule sysModule;
    NumberSequenceCode voucherSeriesCode;

    // collections
    LedgerVoucherTransList transactionCollection;
    Map transactionAmountsByCurrency;

    // defaults
    boolean isCorrectionDefault;
    PaymReference paymentReferenceDefault;
    TransactionTextLarge textDefault;
    DimensionDefault defaultDimension;

    RecId sourceRecIdDefault;
    TableId sourceTableIdDefault;

    MoneyMST transactionCurrencyBalance;
    MoneyMST accountingCurrencyBalance;
    MoneyMST reportingCurrencyBalance;

    boolean isReferenceValidated;
    boolean isReferenceValid;
    boolean isLedgerPostingJournalIdForReferenceValidated;
    boolean isLedgerPostingJournalIdForReferenceValid;
    boolean ignoreTransactionCurrencyBalance;
    boolean useBalanceDifference;
    boolean trackTransactionAmountsByCurrency;
    boolean isPosted;
    boolean hasDefaultDescription;

    // last
    AmountMST lastAmountMST; // The last transaction made
    AmountCur lastAmountCur;
    CurrencyCode lastCurrencyCode;

    // internal
    boolean voucherCheck;
    boolean skipPeriodStatusValidation;
    boolean skipPeriodTypeValidation;
    boolean skipZeroAmountCheck;
    boolean isExplicitBudgetCheckRequired;

    // cache
    RecId legalEntity;
    private FinTagRecId finTag;
    DataAreaId legalEntityDataArea;

    // <GEERU>
    LedgerBondServer_RU ledgerBondServer;
    LedgerBondClient_RU ledgerBondClient;
    LedgerBondApplier_RU bondApplier;
    LedgerBondTransAdapter_GeneralJournal_RU bondAdapter;
    SysOperationProgress bondProgress;
    AmountMSTSecondary lastAmountMSTSecondary;
    #ISOCountryRegionCodes
    // </GEERU>

    Ledger ledger;
    LedgerParameters ledgerParameters;
    // <GSA>
    ProjId  projIdDefault_SA;
    // </GSA>
    DimensionBalancingValidator dimensionBalancingValidator;
    // <GIN>
    boolean isTaxWithholdParametersEnabled;
    // </GIN>
    ReasonRefRecID reasonRef;

    LedgerTmpInterunitBalancerAccountEntry ledgerTmpInterunitBalancerAccountEntry;
    LedgerTmpInterunitBalancerTotal ledgerTmpInterunitBalancerTotal;

    boolean skipCheckIfThereAreNoTransactions = true;
    private boolean isDisplayCorrectDecimalsInErrors = LedgerVoucherDisplayCorrectDecimalsInErrorsFlight::instance().isEnabled();
    private AccountingEventRecId accountingEventRecId;

    #DEFINE.CurrentVersion(1)
    #LOCALMACRO.CurrentList
                sysModule,
                voucherSeriesCode,
                isCorrectionDefault,
                paymentReferenceDefault,
                sourceRecIdDefault,
                sourceTableIdDefault,
                useBalanceDifference,
                trackTransactionAmountsByCurrency,
                voucherCheck,
                isExplicitBudgetCheckRequired,
                skipPeriodStatusValidation,
                skipPeriodTypeValidation,
                projIdDefault_SA,
                isTaxWithholdParametersEnabled,
                reasonRef
    ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmAccountingEventRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get and set the accounting event for the ledger voucher object
    /// </summary>
    /// <param name = "_accountingEventRecId">The accounting event that this ledger voucher object belongs</param>
    /// <returns>Accounting event that this ledger voucher object belongs</returns>
    public AccountingEventRecId parmAccountingEventRecId(AccountingEventRecId _accountingEventRecId = accountingEventRecid)
    {
        accountingEventRecid = _accountingEventRecId;

        return accountingEventRecid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addBalanceAdjustments</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the balance adjustments to posting journal.
    /// </summary>
    /// <param name = "_journal">
    /// The ledger posting journal.
    /// </param>
    /// <param name = "_interunitBalancer">
    /// The <c>LedgerVoucherInterunitBalancer</c> instance.  The parameter is provided for extensibillity, it is not consumed in this method.
    /// </param>
    /// <returns>
    /// A container that has two Boolean values. The first indicates whether the accounting currency balance and the reporting currency balance are
    /// valid and the second indicates whether something was posted.
    /// </returns>
    [Wrappable(true)]
    protected final container addBalanceAdjustments(
        LedgerVoucher _journal,
        LedgerVoucherInterunitBalancer _interunitBalancer)
    {
        LedgerVoucherTransObject postingTransaction;
        TransactionTxt transactionText;
        LedgerDimensionAccount accountingLedgerDimension;
        LedgerDimensionAccount reportingLedgerDimension;
        boolean isAccountingValid;
        boolean isReportingValid;
        boolean postedSomething;

        postedSomething = false;

        if (useBalanceDifference || accountingCurrencyBalance == 0.0)
        {
            isAccountingValid = true;
        }
        else
        {
            [isAccountingValid, accountingLedgerDimension] = this.checkBalanceAccountingCurrency(_journal);
        }

        if (useBalanceDifference || reportingCurrencyBalance == 0.0)
        {
            isReportingValid = true;
        }
        else
        {
            [isReportingValid, reportingLedgerDimension] = this.checkBalanceReportingCurrency(_journal);
        }

        if (isAccountingValid && isReportingValid && !useBalanceDifference)
        {
            // post only if both are valid
            if (accountingCurrencyBalance != 0.0)
            {
                postingTransaction = LedgerVoucherTransObject::newAdjustmentDefault(
                    this,
                    LedgerPostingType::MSTDiff,
                    accountingLedgerDimension,
                    ledger.AccountingCurrency,
                    -accountingCurrencyBalance,
                    0.0); // reporting currency amount

                transactionText  = TransactionTxt::construct(LedgerTransTxt::LedgerMSTDiff);
                transactionText.setVoucher(this.parmSubledgerVoucher());

                postingTransaction.parmText(transactionText.txt());

                this.addTrans(postingTransaction, false);

                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    dimensionBalancingValidator.calculateDimensionBalance(postingTransaction.parmLedgerDimensionId(), postingTransaction.parmAccountingCurrencyAmount());
                }

                // <GEERU>
                if (ledgerBondServer)
                {
                    ledgerBondServer.setBondTransMSTDiff(ledgerBondServer.findBondTransObject(this.vrefIDByTrans_RU(postingTransaction)));
                }
                // </GEERU>

                postedSomething = true;
            }

            if (reportingCurrencyBalance != 0.0)
            {
                postingTransaction = LedgerVoucherTransObject::newAdjustmentDefault(
                    this,
                    LedgerPostingType::MSTDiffSecond,
                    reportingLedgerDimension,
                    ledger.AccountingCurrency,
                    0.0, // accounting currency amount
                    -reportingCurrencyBalance);

                transactionText  = TransactionTxt::construct(LedgerTransTxt::LedgerMSTDIFFSecond);
                transactionText.setVoucher(this.parmSubledgerVoucher());

                postingTransaction.parmText(transactionText.txt());

                this.addTrans(postingTransaction, false);

                // <GEERU>
                if (ledgerBondServer)
                {
                    ledgerBondServer.setBondTransMSTSecondDiff(ledgerBondServer.findBondTransObject(this.vrefIDByTrans_RU(postingTransaction)));
                }
                // </GEERU>

                postedSomething = true;
            }

            // <GEERU>
            if (ledgerBondServer)
            {
                ledgerBondServer.processDiff(this.parmAccountingDate());
            }
            // </GEERU>
        }

        return [(isAccountingValid && isReportingValid), postedSomething];
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToGeneralJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified information to the general journal.
    /// </summary>
    /// <param name="_postingJournal">
    /// The posting journal.
    /// </param>
    /// <param name="_adjustedTransferLevel">
    /// The adjusted transfer level of the transaction.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The GeneralJournalAccountEntry record.
    /// </param>
    /// <param name="_ledgerEntry">
    /// The LedgerEntry record.
    /// </param>
    /// <param name="_taxTransactionRelationshipCollection">
    /// A collection of the <c>TaxTrans</c> table relationship information.
    /// </param>
    /// <param name="_generalJournalAccountEntryW">
    /// The country specific general journal account entry record; optional.
    /// </param>
    /// <param name="_crossCompanyTaxLinkCollections">
    /// A collection of cross company tax link collections.
    /// </param>
    /// <remarks>
    /// This method is for ledger posting framework internal use only.
    /// </remarks>
    public void addToGeneralJournal(
        LedgerVoucher _postingJournal,
        DetailSummary _adjustedTransferLevel,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerEntry _ledgerEntry,
        LedgerPostingOneToManyCollection _taxTransactionRelationshipCollection,
        GeneralJournalAccountEntry_W _generalJournalAccountEntryW = null,
        Map _crossCompanyTaxLinkCollections = null // optional for backward compatibility
        )
    {
        _postingJournal.addToGeneralJournalEntry(
            _adjustedTransferLevel,
            generalJournalEntry,
            _generalJournalAccountEntry,
            _ledgerEntry,
            _taxTransactionRelationshipCollection,
            _crossCompanyTaxLinkCollections
            // <GEEU>
            ,generalJournalEntryW
            ,_generalJournalAccountEntryW
            // </GEEU>
            );
    }

]]></Source>
			</Method>
			<Method>
				<Name>addToSubledgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the specified information to the subledger journal.
    /// </summary>
    /// <param name="_postingJournal">
    /// The posting journal.
    /// </param>
    /// <param name="_adjustedTransferLevel">
    /// The adjusted transfer level of the transaction.
    /// </param>
    /// <param name="_generalJournalAccountEntry">
    /// The <c>GeneralJournalAccountEntry</c> record.
    /// </param>
    /// <param name="_taxTransactionRelationshipCollection">
    /// A collection of the <c>TaxTrans</c> table relationship information.
    /// </param>
    /// <remarks>
    /// This method is for ledger voucher framework internal use only.
    /// </remarks>
    public void addToSubledgerJournal(
        LedgerVoucher _postingJournal,
        DetailSummary _adjustedTransferLevel,
        GeneralJournalAccountEntry _generalJournalAccountEntry,
        LedgerPostingOneToManyCollection _taxTransactionRelationshipCollection)
    {
        _postingJournal.addToSubledgerJournalEntry(
            _adjustedTransferLevel,
            generalJournalEntry,
            _generalJournalAccountEntry,
            _taxTransactionRelationshipCollection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a transaction.
    /// </summary>
    /// <param name = "_transaction">
    /// The <c>LedgerVoucherTransObject</c> instance.
    /// </param>
    /// <param name = "_allocate">
    /// Indicates if the transaction must be allocated; optional.
    /// </param>
    /// <param name = "_obsolete">
    /// Not used; optional.
    /// </param>
    /// <param name = "_skipLastValueUpdate">
    /// Indicates if the last value update should be skipped; optional.
    /// </param>
    public void addTrans(LedgerVoucherTransObject _transaction, boolean _allocate = true, boolean _obsolete = false, boolean _skipLastValueUpdate = false)
    {
        CurrencyCode    currencyCode;
        AmountMST       amountInTransactionCurrency;
        AmountMST       amountInAccountingCurrency;
        AmountMST       amountForCurrency;

        // <GEERU>
        boolean      countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        amountInTransactionCurrency = _transaction.parmTransactionCurrencyAmount();
        amountInAccountingCurrency = _transaction.parmAccountingCurrencyAmount();

        if (!_skipLastValueUpdate)
        {
            // set the last values for the LVO to the values from the LVTO being added here in case the values are zero
            lastAmountCur = amountInTransactionCurrency;
            lastAmountMST = amountInAccountingCurrency;
        }

        if (this.shouldAddTrans(_transaction, _allocate, _obsolete, _skipLastValueUpdate))
        {
            currencyCode = _transaction.parmCurrencyCode();

            // this will no longer be needed when a LedgerVoucherObject
            // default is added to all LedgerVoucherTransObject factory methods
            if (_transaction.parmText() == '' && !_transaction.parmDiscardLastTransTxt())
            {
                _transaction.parmText(textDefault);
            }
            else
            {
                textDefault = _transaction.parmText();
            }

            if (paymentReferenceDefault != '')
            {
                _transaction.parmPaymentReference(paymentReferenceDefault);
            }

            isReferenceValidated = false;
            isReferenceValid = false;
            isLedgerPostingJournalIdForReferenceValidated = false;
            isLedgerPostingJournalIdForReferenceValid = false;

            // <GIN>
            if (isTaxWithholdParametersEnabled)
            {
                _transaction.parmIsTaxWithholdParametersEnabled_IN(isTaxWithholdParametersEnabled);
            }
            // </GIN>

            transactionCollection.add(_transaction);

            // <GEERU>
            if (countryRegion_RU)
            {
                this.bond_afterAddTrans_RU(_transaction);
            }
            // </GEERU>

            if (_allocate && (!_transaction.parmIgnoreAllocation()))
            {
                changeCompany(legalEntityDataArea)
                {
                    this.allocateTransaction(_transaction);
                }
            }

            if (lastCurrencyCode != currencyCode)
            {
                if (lastCurrencyCode)
                {
                    // ignore the transaction currency balance when the reference contains more than one different currency
                    ignoreTransactionCurrencyBalance = true;
                }

                lastCurrencyCode = currencyCode;
            }

            // <GEEU>
            if (CustVendTransPostingLog_RU::usePostingLog())
            {
                lastAmountMSTSecondary = _transaction.parmReportingCurrencyAmount();
            }
            // </GEEU>

            if (transactionCollection.elements() == 1 || defaultDimension == 0)
            {
                // the ledger dimension from the first transaction is used as a default dimension
                defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_transaction.parmLedgerDimensionId());
            }

            this.updateBalances(
                amountInTransactionCurrency,
                _transaction.parmAccountingCurrencyAmount(),
                _transaction.parmReportingCurrencyAmount());

            if (trackTransactionAmountsByCurrency)
            {
                if (transactionAmountsByCurrency.exists(currencyCode))
                {
                    amountForCurrency = transactionAmountsByCurrency.lookup(currencyCode);
                }
                else
                {
                    amountForCurrency = 0;
                }

                amountForCurrency += amountInTransactionCurrency;

                transactionAmountsByCurrency.insert(currencyCode, amountForCurrency);
            }

            this.parmSkipZeroAmountCheck(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldAddTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a transaction should be added.
    /// </summary>
    /// <param name = "_transaction">
    /// The <c>LedgerVoucherTransObject</c> instance.
    /// </param>
    /// <param name = "_allocate">
    /// Indicates if the transaction must be allocated.
    /// </param>
    /// <param name = "_obsolete">
    /// Not used.
    /// </param>
    /// <param name = "_skipLastValueUpdate">
    /// Indicates if the last value update should be skipped.
    /// </param>
    /// <returns>
    /// true if a transaction should be added; otherwise, false.
    /// </returns>
    protected boolean shouldAddTrans(LedgerVoucherTransObject _transaction, boolean _allocate, boolean _obsolete, boolean _skipLastValueUpdate)
    {
        return (_transaction.parmTransactionCurrencyAmount() != 0 ||
                _transaction.parmAccountingCurrencyAmount() != 0 ||
                _transaction.parmReportingCurrencyAmount() != 0 ||
                _transaction.parmQuantity() != 0 ||
                this.parmSkipZeroAmountCheck());
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateTransaction</Name>
				<Source><![CDATA[
    private void allocateTransaction(LedgerVoucherTransObject _baseTransaction)
    {
        LedgerAllocationController  controller;
        LedgerAllocationItem        baseItem;
        LedgerAllocationItem        allocationItem;
        LedgerVoucherTransObject    transaction;
        List                        allocationItemList;
        ListEnumerator              enumerator;
        LedgerDimensionAccount      ledgerDimension;
        RecId                       mainAccountId;
        MainAccountLegalEntity      mainAccountLegalEntity;

        // <GEERU>
        // Map <allocationItem -> List<offset cllocation items>>
        Map                         bondingMap_RU           = ledgerBondClient ? new Map(Types::Class, Types::Class) : null;
        // Map <allocation item -> LedgerVoucheTransObject>
        Map                         itemToTransactionMap_RU = ledgerBondClient ? new Map(Types::Class, Types::Class) : null;
        boolean   countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        ledgerDimension = _baseTransaction.parmLedgerDimensionId();

        // Skip out early on the allocation if the main account doesn't have allocation
        mainAccountId = LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(ledgerDimension);

        mainAccountLegalEntity = MainAccountLegalEntity::findByMainAccountLegalEntity(mainAccountId, legalEntity);

        if (!mainAccountLegalEntity.AutoAllocate ||
            !this.ledgerAllocationExists(mainAccountId, legalEntity, _baseTransaction))
        {
            return;
        }

        baseItem = this.initBaseItemFromBaseTransaction(_baseTransaction);
        controller = LedgerAllocationController::construct(_baseTransaction.parmCurrencyCode());

        // <GEERU>
        if (countryRegion_RU)
        {
            allocationItemList = controller.allocate(baseItem, bondingMap_RU);
        }
        else
        {
        // </GEERU>
            allocationItemList = controller.allocate(baseItem);
        // <GEERU>
        }
        // </GEERU>

        // <GEERU>
        if (ledgerBondClient)
        {
            ledgerBondClient.addNewLogObject();
            ledgerBondClient.startSkipping();
        }
        // </GEERU>
        enumerator = allocationItemList.getEnumerator();
        while (enumerator.moveNext())
        {
            allocationItem = enumerator.current();

            transaction = LedgerVoucherTransObject::newLedgerAllocationItem(_baseTransaction, allocationItem);

            this.addTrans(transaction, false, false, true);

            // <GEERU>
            if (itemToTransactionMap_RU)
            {
                itemToTransactionMap_RU.insert(allocationItem, transaction);
            }
            // </GEERU>
        }

        // <GEERU>
        if (countryRegion_RU)
        {
            this.applyAllocationBonding_RU(bondingMap_RU, itemToTransactionMap_RU);
            if (ledgerBondClient)
            {
                ledgerBondClient.removeCurrentLogObject();
                ledgerBondClient.endSkipping();
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerAllocationExists</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified record in the <c>LedgerAllocation</c> table exists.
    /// </summary>
    /// <param name = "_mainAccountId">
    /// The record ID of the related <c>MainAccount</c> record.
    /// </param>
    /// <param name = "_legalEntity">
    /// The record ID of the related <c>CompanyInfo</c> record.
    /// </param>
    /// <param name = "_baseTransaction">
    /// An instance of the <c>LedgerVoucherTransObject</c> class.
    /// </param>
    /// <returns>
    /// true if the specified record exists; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean ledgerAllocationExists(RecId _mainAccountId, RecId _legalEntity, LedgerVoucherTransObject _baseTransaction)
    {
        return LedgerAllocation::existsForMainAccountAndLegalEntity(_mainAccountId, _legalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initBaseItemFromBaseTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the Ledger allocation item instance.
    /// </summary>
    /// <param name = "_baseTransaction">
    /// The Base transaction.
    /// </param>
    /// <returns>
    /// The instance of the ledger allocation item.
    /// </returns>
    protected LedgerAllocationItem initBaseItemFromBaseTransaction(LedgerVoucherTransObject _baseTransaction)
    {
        LedgerAllocationItem baseItem = LedgerAllocationItem::constructFromLedgerDimension(_baseTransaction.parmLedgerDimensionId());
        baseItem.setAmounts(
            _baseTransaction.parmTransactionCurrencyAmount(),
            _baseTransaction.parmAccountingCurrencyAmount(),
            _baseTransaction.parmReportingCurrencyAmount(),
            _baseTransaction.parmQuantity(),
            0.0);

        return baseItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyAllocationBonding_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Applies bonding to allocaton transaction
    /// </summary>
    /// <param name="_bondingMap_RU">
    /// maps negative allocated items to lists of offset detailed allocation items
    /// </param>
    /// <param name="_itemToTransactionMap_RU">
    /// maps allocation items to <c>LedgerVoucherTransObject</c>'s
    /// </param>
    protected void applyAllocationBonding_RU(Map _bondingMap_RU, Map _itemToTransactionMap_RU)
    {
        MapEnumerator pairsEnumerator;
        if (ledgerBondClient)
        {
            pairsEnumerator = _bondingMap_RU.getEnumerator();
            while (pairsEnumerator.moveNext())
            {
                ledgerBondClient.bondVRef2Log(this.vrefIDByTrans_RU(_itemToTransactionMap_RU.lookup(pairsEnumerator.currentKey())),
                                              this.bond_ledgerAllocationItemsToLog_RU(pairsEnumerator.currentValue(), _itemToTransactionMap_RU));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_afterAddTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Performs all bonding action after _transaction is added
    /// </summary>
    /// <param name="_transaction">
    ///   transaction which was recentrly added by addTrans
    /// </param>
    protected void bond_afterAddTrans_RU(LedgerVoucherTransObject _transaction)
    {
        if (ledgerBondServer)
        {
            ledgerBondServer.addTrans(bondAdapter.adapt(_transaction,  DetailSummary::Detail));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_afterPost_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  performs all action after some collection of transactions were posted to bondAdapter
    /// </summary>
    /// <param name="_journal">
    ///  LedgerVoucher
    /// </param>
    private void bond_afterPost_RU(LedgerVoucher _journal)
    {
        if (ledgerBondServer)
        {
            isPosted = bondAdapter.insertList(bondApplier.getResult(), _journal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_afterPostCurrencyDiff_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Performs bonding action action after adjust.
    /// </summary>
    /// <param name="_amountCur">
    ///   The transaction amount.
    /// </param>
    /// <param name="_currencyCode">
    ///   The currency code of transction.
    /// </param>
    /// <param name="_transObject">
    ///   The transaction which was recently added by addTrans.
    /// </param>
    /// <param name="_logTable">
    ///   The correspondence log.
    /// </param>

    public void bond_afterPostCurrencyDiff_RU(AmountCur _amountCur, CurrencyCode _currencyCode, LedgerVoucherTransObject _transObject, TmpLedgerBondLogTable_RU  _logTable)
    {
        LedgerBondTransObject_RU    bondTransObject;

        if (ledgerBondClient && _amountCur)
        {
            bondTransObject = ledgerBondClient.bondTransObject(bondAdapter.getID(_transObject));
            while select _logTable
                where _logTable.CurrencyCode == _currencyCode   &&
                      _logTable.Crediting    != bondTransObject.remainCrediting()
            {
                ledgerBondClient.bondVRef2VRef(bondTransObject.vrefId(), _logTable.BondId);
                if (bondTransObject.remainAmountCur() == 0)
                {
                    break;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_initApplier_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>LedgerBondApplier_RU</c> class if bond is enabled.
    /// </summary>
    protected void bond_initApplier_RU()
    {
        if (ledgerBondServer)
        {
            boolean haveMore = transactionCollection.first();

            while (haveMore)
            {
                LedgerVoucherTransObject trans = transactionCollection.item();
                ledgerBondServer.updateLedgerDimension(bondAdapter.adapt(trans,  DetailSummary::Detail));
                haveMore = transactionCollection.next();
            }

            bondApplier = new LedgerBondApplier_RU(ledgerBondClient, ledgerBondServer, bondAdapter);
            bondApplier.onManualBond += eventHandler(this.bond_showManualAction_RU);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_ledgerAllocationItemsToLog_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns container of vrefID's by list of allocation items
    /// </summary>
    /// <param name="_items">
    ///  List of <c>LedgerAllocationItem</c>
    /// </param>
    /// <param name="_itemToTransactionMap_RU">
    ///  Maps <c>LedgerAllocationItem</c> to <c>LedgerVoucherTransObject</c> which is obrtained
    /// by posting the item
    /// </param>
    /// <returns>
    ///  Container of vrefid's of transactions generated from given list of items
    /// </returns>
    protected container bond_ledgerAllocationItemsToLog_RU(List _items, Map _itemToTransactionMap_RU)
    {
        Enumerator i = _items.getEnumerator();
        container ret;
        while (i.moveNext())
        {
            ret += this.vrefIDByTrans_RU(_itemToTransactionMap_RU.lookup(i.current()));
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bond_showManualAction_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Shows the warning with ability to open Manual correspondence form.
    /// </summary>
    /// <param name="_warningMessage">
    /// Text of message.
    /// </param>
    /// <param name="_helpURL">
    /// URL
    /// </param>
    public void bond_showManualAction_RU(str _warningMessage,
                                  str _helpURL)
    {
        SysInfoAction_LedgerBondManual_RU action =
            new SysInfoAction_LedgerBondManual_RU(formStr(LedgerBondManual_RU),
                                                  this.parmReferenceNumber());
        setPrefix(strFmt("@SYS25866", this.parmReferenceNumber()));
        warning(_warningMessage, _helpURL, action);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bondAddToApplier_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Adds specified transaction to bondApplier
    /// </summary>
    /// <param name="_trans">
    ///   transaction
    /// </param>
    /// <param name="_detailSummary">
    ///   final detail level calculated by transaction and ledger voucher settings
    /// </param>
    /// <remarks>
    ///    The method is intended to be called instead of addToGeneralJournal by LedgerVoucherTransObject,
    ///    but providing LedgerVoucherTransObject identity
    /// </remarks>
    void bondAddToApplier_RU(LedgerVoucherTransObject _trans, DetailSummary _detailSummary)
    {
        bondApplier.add(bondAdapter.adapt(_trans, _detailSummary));
        bondProgress.setText(strFmt("@GLS111584", bondProgress.getCount_RU(2) + 1, bondProgress.getTotal(2)), 2);
        bondProgress.incCount(1, 2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>bondInit_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initialization of LedgerBond objects if bond is enabled
    /// </summary>
    protected void bondInit_RU()
    {
        if (LedgerParameters::find().Correspondence_RU)
        {
            ledgerBondServer = new LedgerBondServer_RU();
            ledgerBondClient = new LedgerBondClient_RU(ledgerBondServer, generalJournalEntry.AccountingDate);
            bondAdapter      = new LedgerBondTransAdapter_GeneralJournal_RU(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableVoucherValidationEvenIfThereAreNoTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Enables voucher validation even if there are no transactions.
    /// </summary>
    public void enableVoucherValidationEvenIfThereAreNoTransactions()
    {
        skipCheckIfThereAreNoTransactions = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the ledger posting reference.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// true if the ledger posting reference is valid; otherwise, false.
    /// </returns>
    public boolean check(LedgerVoucher _journal)
    {
        boolean ok = true;
        FiscalCalendarPeriod fiscalCalendarPeriod;
        FiscalCalendarYear fiscalCalendarYear;

        #define.SubledgerJournalMustExist(true)

        if (this.shouldCheckLedgerPostingJournalId(_journal))
        {
            if (!isLedgerPostingJournalIdForReferenceValidated)
            {
                setPrefix(strFmt("@SYS25866", this.parmVoucher()));

                changecompany(legalEntityDataArea)
                {
                    // ledger posting journal should be validated regardless of whether there are transactions or not
                    isLedgerPostingJournalIdForReferenceValid = this.checkLedgerPostingJournalId(_journal);
                }

                isLedgerPostingJournalIdForReferenceValidated = true;
            }

            if (!isLedgerPostingJournalIdForReferenceValid)
            {
                return false;
            }
        }

        if (transactionCollection.elements() == 0 && skipCheckIfThereAreNoTransactions)
        {
            // perf: do nothing if there are no transactions
            return true;
        }

        if (!isReferenceValidated)
        {
            setPrefix(strFmt("@SYS25866", this.parmVoucher()));

            changecompany(legalEntityDataArea)
            {
                if (!_journal.isAccountingDateValid(generalJournalEntry.AccountingDate, generalJournalEntry.FiscalCalendarPeriod))
                {
                    // If the company, accounting date, and fiscal calendar period combination has
                    // not been validated or is not valid then it must run through the validation
                    // code again in order to report the correct errors for this instance.

                    if (ledger.FiscalCalendar == 0)
                    {
                        ok = checkFailed("@SYS128634");

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorLedgerHasNoFiscalCalendar);
                    }

                    if (generalJournalEntry.FiscalCalendarPeriod == 0)
                    {
                        ok = checkFailed(strFmt("@SYS17614", generalJournalEntry.AccountingDate));

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorJournalEntryFiscalCalendarPeriodZero);
                    }

                    if (generalJournalEntry.FiscalCalendarYear == 0)
                    {
                        ok = checkFailed(strFmt("@SYS328431", generalJournalEntry.AccountingDate));

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorJournalEntryFiscalCalendarYearZero);
                    }

                    fiscalCalendarPeriod = FiscalCalendarPeriod::find(generalJournalEntry.FiscalCalendarPeriod);

                    fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(
                        ledger.FiscalCalendar,
                        generalJournalEntry.AccountingDate);

                    if (fiscalCalendarPeriod == null)
                    {
                        ok = checkFailed(strFmt("@SYS17614", generalJournalEntry.AccountingDate));

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorFiscalCalendarPeriodNotFound);
                    }
                    else if (fiscalCalendarYear == null)
                    {
                        ok = checkFailed(strFmt("@SYS17614", generalJournalEntry.AccountingDate));

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorFiscalCalendarYearNotFound);
                    }
                    else if (fiscalCalendarPeriod.FiscalCalendarYear != fiscalCalendarYear.RecId)
                    {
                        ok = checkFailed(strFmt("@SYS17614", generalJournalEntry.AccountingDate));

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorFiscalCalendarPeriodDoesNotMatchYear);
                    }
                    else if (generalJournalEntry.AccountingDate > fiscalCalendarPeriod.EndDate)
                    {
                        ok = checkFailed(strFmt("@SYS17614", generalJournalEntry.AccountingDate));

                        LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorAccountingDateBeyondFiscalPeriodEndDate);
                    }

                    //Do not check for period status/code when posting from opening sheet.
                    if (_journal.parmOpeningSheet_ES())
                    {
                        if (!skipPeriodTypeValidation && fiscalCalendarPeriod != null && fiscalCalendarPeriod.Type == FiscalPeriodType::Closing)
                        {
                            ok = checkFailed("@SYS321299");
                        }
                    }
                    else
                    {
                        if (!skipPeriodStatusValidation && fiscalCalendarPeriod != null && fiscalCalendarPeriod.currentLedgerPeriodStatus() != FiscalPeriodStatus::Open)
                        {
                            ok = checkFailed(strFmt("@SYS17615", generalJournalEntry.AccountingDate));

                            LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorFiscalPeriodIsNotOpen);
                        }

                        if (!skipPeriodTypeValidation && fiscalCalendarPeriod != null && fiscalCalendarPeriod.Type == FiscalPeriodType::Opening)
                        {
                            ok = checkFailed("@SYS16774");

                            LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorPostingNotPermittedInOpeningFiscalPeriod);
                        }
                    }

                    ok = LedgerFiscalCalendar::checkModuleIsOpen(sysModule, generalJournalEntry.AccountingDate, fiscalCalendarPeriod) && ok;

                    if (ok)
                    {
                        _journal.addAccountingDateToCache(generalJournalEntry.AccountingDate, generalJournalEntry.FiscalCalendarPeriod);
                    }
                }

                if (this.parmSubledgerVoucher() == '')
                {
                    ok = checkFailed("@SYS24569");

                    LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorNoVoucherSpecified);
                }
                else
                {
                    if (voucherCheck)
                    {
                        ok = GeneralLedgerExtension::validateReferenceNumber(
                            ledger.FiscalCalendar,
                            ledgerParameters.CheckVoucher,
                            generalJournalEntry.SubledgerVoucher,
                            generalJournalEntry.AccountingDate,
                            legalEntityDataArea,
                            sysModule == SysModule::Cust || generalJournalEntry.JournalCategory == LedgerTransType::Cust,
                            sysModule == SysModule::Purch || generalJournalEntry.JournalCategory == LedgerTransType::Purch,
                            #SubledgerJournalMustExist) && ok;
                    }
                }

                // <GCN>
                if (LedgerParameters::isChineseVoucher_CN()
                    && _journal.parmLedgerVoucherType_CN() != 0
                    && this.getLedgerVoucherType_CN().RecId != _journal.parmLedgerVoucherType_CN())
                {
                    // Voucher %1 doesn't meet the voucher type rules.
                    ok = checkFailed(strFmt("@GLS60254", _journal.parmVoucher_CN()));
                }
                // </GCN>

                if (useBalanceDifference)
                {
                    ok = this.checkBalanceDifference(_journal) && ok;
                }
                else
                {
                    ok = this.checkBalance(_journal, true) && ok;
                }

                if (!_journal.parmCheckTransOnInsert())
                {
                    ok = this.checkTransactions(_journal) && ok;
                }

                isReferenceValidated = true;
                isReferenceValid = ok;
            }
        }

        return isReferenceValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAccountStructure</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the transaction list in the collection.
    /// </summary>
    /// <returns>
    ///     True if checked successful, otherwise false.
    /// </returns>
    protected boolean checkAccountStructure()
    {
        boolean                     ret;
        boolean                     haveMore;
        LedgerVoucherTransObject    transObject;
        LedgerDimensionAccount      ledgerDimension;
        GeneralJournalAccountEntry  generalJournalAccountEntry;

        haveMore = transactionCollection.first();

        while (haveMore)
        {
            transObject = transactionCollection.item();
            generalJournalAccountEntry = transObject.parmGeneralJournalAccountEntry();
            ledgerDimension = generalJournalAccountEntry.LedgerDimension;

            ret = TaxBranchType::checkAccountStrucForLedgerDimension(ledgerDimension);

            if (!ret)
            {
                break;
            }
            haveMore = transactionCollection.next();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies the ledger posting reference is balanced.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <param name="_useRoundingBalanceCheck">
    /// A value that indicates whether to use the rounding balance check.
    /// </param>
    /// <returns>
    /// true if the ledger posting reference is balanced; otherwise, false.
    /// </returns>
    private boolean checkBalance(LedgerVoucher _journal, boolean _useRoundingBalanceCheck)
    {
        boolean isValid;

        if (useBalanceDifference)
        {
            isValid = this.checkBalanceDifference(_journal);
        }
        else
        {
            if (this.isCurrencyBalanceZero())
            {
                isValid = true;
            }
            else if (_useRoundingBalanceCheck)
            {
                isValid = this.checkBalanceRound(_journal);
            }
            else
            {
                isValid = false;
            }

            if (!isValid)
            {
                if(isDisplayCorrectDecimalsInErrors)
                {
                    CurrencyCode accountingCurrency = Ledger::accountingCurrency();
                    CurrencyCode reportingCurrency = Ledger::reportingCurrency();

                    isValid = checkFailed(strFmt(
                        "@SYS70033",
                        LedgerJournalTrans::findTmpVoucher(this.parmSubledgerVoucher(), _journal.parmTmpVoucherMap()),
                        generalJournalEntry.AccountingDate,
                        LedgerAmountDecimalValues::decimalAmount(accountingCurrencyBalance, accountingCurrency),
                        LedgerAmountDecimalValues::decimalAmount(reportingCurrencyBalance, reportingCurrency)));
                }
                else
                {
                    isValid = checkFailed(strFmt(
                        "@SYS70033",
                        LedgerJournalTrans::findTmpVoucher(this.parmSubledgerVoucher(), _journal.parmTmpVoucherMap()),
                        generalJournalEntry.AccountingDate,
                        accountingCurrencyBalance,
                        reportingCurrencyBalance));
                }

                if (accountingCurrencyBalance != 0.0)
                {
                    LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorOutOfBalanceAccountingCurrency);
                }

                if (reportingCurrencyBalance != 0.0)
                {
                    LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorOutOfBalanceReportingCurrency);
                }

                this.showErrorTransactions(_journal.parmTmpVoucherMap());
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCurrencyBalanceZero</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the Accounting, Reporting and Transaction currency balances are zero.
    /// </summary>
    /// <returns>
    /// Returns true if the Accounting, Reporting and Transaction currency balances are zero;
    /// </returns>
    [Wrappable(true)]
    final protected boolean isCurrencyBalanceZero()
    {
        return ((transactionCurrencyBalance == 0.0 || ignoreTransactionCurrencyBalance)
                && accountingCurrencyBalance == 0.0
                && reportingCurrencyBalance == 0.0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBalanceAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the accounting currency balance.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// A Boolean value that indicates whether the accounting currency balance is
    /// valid and the ledger dimension for the automatic adjustment if it is required
    /// in a container.
    /// </returns>
    /// <remarks>
    /// The accounting currency balance is valid when it is zero or when an
    /// automatic adjustment will make it zero.
    /// </remarks>
    private container checkBalanceAccountingCurrency(LedgerVoucher _journal)
    {
        LedgerDimensionAccount ledgerDimension;
        LedgerDimensionDefaultAccount defaultAccount;
        boolean isValid = true;

        if (accountingCurrencyBalance != 0.0)
        {
            AmountMST maxRoundingDifferenceAccountingCurrency = this.maximumRoundingDifferenceInAccountingCurrency(
                ledgerParameters,
                _journal.parmLedgerJournalId());

            if (abs(accountingCurrencyBalance) > maxRoundingDifferenceAccountingCurrency)
            {
                // no message is needed because the reference will be out of balance
                isValid = false;
            }
            else
            {
                defaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::MSTDiff);
                if (defaultAccount == 0)
                {
                    if (ledgerParameters.AbortErrorAccount)
                    {
                        isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::MSTDiff));
                    }
                    else
                    {
                        defaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::ErrorAccount);
                        if (defaultAccount == 0)
                        {
                            isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::ErrorAccount));
                        }
                        else
                        {
                            ledgerDimension =
                                LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, defaultDimension);

                            if (ledgerDimension == 0)
                            {
                                isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::ErrorAccount));
                            }
                        }
                    }
                }
                else
                {
                    ledgerDimension =
                        LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, defaultDimension);

                    if (ledgerDimension == 0)
                    {
                        isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::MSTDiff));
                    }
                }
            }
        }

        return [isValid, ledgerDimension];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBalanceDifference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the reference is balanced against the current balance of the reference number and accounting date.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// true if the reference is balanced against the current balance of the reference number and accounting date; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The balances of the accounting currency amount and reporting currency amount are checked.
    /// </remarks>
    private boolean checkBalanceDifference(LedgerVoucher _journal)
    {
        boolean ok = true;
        MoneyMST currentAccountingCurrencyBalance;
        MoneyMST currentReportingCurrencyBalance;

        [currentAccountingCurrencyBalance, currentReportingCurrencyBalance] =
            GeneralLedgerExtension::getBalances(this.parmSubledgerVoucher(), generalJournalEntry.AccountingDate);

        currentAccountingCurrencyBalance += accountingCurrencyBalance;
        currentReportingCurrencyBalance += reportingCurrencyBalance;

        if (currentAccountingCurrencyBalance != 0 || currentReportingCurrencyBalance != 0)
        {
            if(isDisplayCorrectDecimalsInErrors)
            {
                CurrencyCode accountingCurrency = Ledger::accountingCurrency();
                CurrencyCode reportingCurrency = Ledger::reportingCurrency();

                ok = checkFailed(strFmt(
                    "@SYS70033",
                    LedgerJournalTrans::findTmpVoucher(generalJournalEntry.SubledgerVoucher, _journal.parmTmpVoucherMap()),
                    generalJournalEntry.AccountingDate,
                    LedgerAmountDecimalValues::decimalAmount(currentAccountingCurrencyBalance, accountingCurrency),
                    LedgerAmountDecimalValues::decimalAmount(currentReportingCurrencyBalance, reportingCurrency))) && ok;
            }
            else
            {
                ok = checkFailed(strFmt(
                    "@SYS70033",
                    LedgerJournalTrans::findTmpVoucher(generalJournalEntry.SubledgerVoucher, _journal.parmTmpVoucherMap()),
                    generalJournalEntry.AccountingDate,
                    currentAccountingCurrencyBalance,
                    currentReportingCurrencyBalance)) && ok;
            }

            if (accountingCurrencyBalance != 0.0)
            {
                LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorOutOfBalanceAccountingCurrency);
            }

            if (reportingCurrencyBalance != 0.0)
            {
                LedgerVoucherInstrumentation::logError(LedgerJournalInstrumentationConstants::VoucherErrorOutOfBalanceReportingCurrency);
            }

            this.showErrorTransactions(_journal.parmTmpVoucherMap());
        }

        isReferenceValidated = true;
        isReferenceValid = ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBalanceReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the reporting currency balance.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// A Boolean value that indicates whether the reporting currency balance is
    /// valid and the ledger dimension for the automatic adjustment if it is required
    /// in a container.
    /// </returns>
    /// <remarks>
    /// The reporting currency balance is valid when it is zero or when an
    /// automatic adjustment will make it zero.
    /// </remarks>
    private container checkBalanceReportingCurrency(LedgerVoucher _journal)
    {
        LedgerDimensionAccount ledgerDimension;
        LedgerDimensionDefaultAccount defaultAccount;
        boolean isValid = true;

        if (reportingCurrencyBalance != 0.0)
        {
            AmountMST maxRoundingDifferenceReportingCurrency = this.maximumRoundingDifferenceInReportingCurrency(
                ledgerParameters,
                _journal.parmLedgerJournalId());

            if (abs(reportingCurrencyBalance) > maxRoundingDifferenceReportingCurrency)
            {
                // no message is needed because the reference will be out of balance
                isValid = false;
            }
            else
            {
                defaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::MSTDiffSecond);
                if (defaultAccount == 0)
                {
                    if (ledgerParameters.AbortErrorAccount)
                    {
                        isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::MSTDiffSecond));
                    }
                    else
                    {
                        defaultAccount = LedgerSystemAccounts::getDefaultAccount(LedgerPostingType::ErrorAccount);
                        if (defaultAccount == 0)
                        {
                            isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::ErrorAccount));
                        }
                        else
                        {
                            ledgerDimension =
                                LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, defaultDimension);

                            if (ledgerDimension == 0)
                            {
                                isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::ErrorAccount));
                            }
                        }
                    }
                }
                else
                {
                    ledgerDimension =
                        LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, defaultDimension);

                    if (ledgerDimension == 0)
                    {
                        isValid = checkFailed(strFmt("@SYS24816", LedgerPostingType::MSTDiffSecond));
                    }
                }
            }
        }

        return [isValid, ledgerDimension];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBalanceRound</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies the ledger posting reference is balanced within the rounding limits.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// true if the ledger posting reference is balanced within the rounding limits; otherwise, false.
    /// </returns>
    private boolean checkBalanceRound(LedgerVoucher _journal)
    {
        LedgerDimensionAccount accountingAccount;
        LedgerDimensionAccount reportingAccount;
        boolean isValidAccounting;
        boolean isValidReporting;
        boolean isValidTransaction;

        isValidTransaction = this.isTransactionCurrencyBalanceZero();

        [isValidAccounting, accountingAccount] = this.checkBalanceAccountingCurrency(_journal);

        [isValidReporting, reportingAccount] = this.checkBalanceReportingCurrency(_journal);

        return isValidTransaction && isValidAccounting && isValidReporting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionCurrencyBalanceZero</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies if the Transaction currency balance is zero.
    /// </summary>
    /// <returns>
    /// Returns true if the Transaction currency balance is zero; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    final protected boolean isTransactionCurrencyBalanceZero()
    {
        return ((transactionCurrencyBalance == 0.0) || ignoreTransactionCurrencyBalance);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerPostingJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the ledger posting journal.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// true if the voucher series for posting journals related to the specified
    /// voucher series code is set up correctly; otherwise, false.
    /// </returns>
    /// <remarks>
    /// This method is for ledger posting framework internal use only.
    /// </remarks>
    public boolean checkLedgerPostingJournalId(LedgerVoucher _journal)
    {
        NumberSequenceCode voucherSeriesCodeLocal = voucherSeriesCode ? voucherSeriesCode : _journal.parmVoucherSeriesCode();

        if (this.shouldCheckLedgerPostingJournalId(_journal) && voucherSeriesCodeLocal)
        {
            LedgerPostingJournalVoucherSeries ledgerPostingJournalVoucherSeries = LedgerPostingJournalVoucherSeries::find(voucherSeriesCodeLocal);

            if (ledgerPostingJournalVoucherSeries == null || !ledgerPostingJournalVoucherSeries)
            {
                return checkFailed(
                    strFmt("@SYS62431", voucherSeriesCodeLocal),
                    '',
                    SysInfoAction_Formrun::newFormnameDesc(formStr(LedgerPostingJournal), "@SYS60620"));
            }
            else
            {
                if (!this.isAccountingDateValidForLedgerPostingJournalId(_journal, ledgerPostingJournalVoucherSeries))
                {
                    return checkFailed(strFmt(
                        "@SYS62685",
                        LedgerJournalTrans::findTmpVoucher(this.parmSubledgerVoucher(), _journal.parmTmpVoucherMap()),
                        voucherSeriesCodeLocal,
                        ledgerPostingJournalVoucherSeries.LedgerPostingJournalId));
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAccountingDateValidForLedgerPostingJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the accounting date is valid for the ledger posting.
    /// </summary>
    /// <remarks>
    /// _journal needed here is for chain of command purposes.
    /// </remarks>
    /// <param name = "_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <param name = "_ledgerPostingJournalVoucherSeries">
    /// The table <c>LedgerPostingJournalVoucherSeries</c> buffer.
    /// </param>
    /// <returns>
    /// true if the accounting date is valid; otherwise, false.
    /// </returns>
    protected boolean isAccountingDateValidForLedgerPostingJournalId(LedgerVoucher _journal, LedgerPostingJournalVoucherSeries _ledgerPostingJournalVoucherSeries)
    {
        boolean ret;
        if (_ledgerPostingJournalVoucherSeries == null)
        {
            ret = checkFailed(
                    strFmt("@SYS62431", voucherSeriesCode),
                    '',
                    SysInfoAction_Formrun::newFormnameDesc(formStr(LedgerPostingJournal), "@SYS60620"));
        }
        else
        {
            ret = _ledgerPostingJournalVoucherSeries.isDateValid(this.parmAccountingDate());
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCheckLedgerPostingJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether validating the ledger posting journal is required.
    /// </summary>
    /// <param name = "_journal">
    /// The <c>LedgerVoucher</c> object.
    /// </param>
    /// <returns>
    /// Returns true, if the ledger posting journal should be validated; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldCheckLedgerPostingJournalId(LedgerVoucher _journal)
    {
        boolean ret;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE]))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkOpeningTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the accounting date is in a previous period and opening transactions have
    /// been created for the current year.
    /// </summary>
    /// <remarks>
    /// The results are posted to the <c>Infolog</c>.
    /// </remarks>
    private void checkOpeningTrans()
    {
        TransDate periodStartDate;

        // verify the system date is correct
        periodStartDate =
            LedgerFiscalCalendar::findOpeningPeriodStartDateByDate(ledger.FiscalCalendar, DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));

        if (generalJournalEntry.AccountingDate < periodStartDate)
        {
            // verify the period start date is correct or change to accounting date or something else
            if (GeneralJournalEntry::existForOpeningPeriod(ledger.FiscalCalendar, periodStartDate))
            {
                warning("@SYS25676");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the transactions of the current object.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// true if no errors were found; otherwise, false.
    /// </returns>
    private boolean checkTransactions(LedgerVoucher _journal)
    {
        LedgerVoucherTransObject trans;
        boolean ok = true;
        boolean haveMore;

        haveMore = transactionCollection.first();
        while (haveMore)
        {
            trans = transactionCollection.item();

            ok = trans.checkData(_journal, this) && ok;

            if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
            {
                dimensionBalancingValidator.calculateDimensionBalance(trans.parmLedgerDimensionId(), trans.parmAccountingCurrencyAmount());
            }

            if (trans.isModified())
            {
                // update because the transaction collection does not have reference semantics
                transactionCollection.update(trans);
            }

            haveMore = transactionCollection.next();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInternalCollection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the internal collection of general journal account entries.
    /// </summary>
    /// <returns>
    /// The internal collection of general journal account entries.
    /// </returns>
    /// <remarks>
    /// This method should be used only when absolutely necessary.
    /// </remarks>
    public LedgerVoucherTransList getInternalCollection()
    {
        return transactionCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDimensionForTaxTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns ledgerDimension for given tax transaction recID and given relation type (for unposted transactions)
    /// </summary>
    /// <param name="_taxTrans"><c>TaxTrans</c> <c>recID</c></param>
    /// <param name="_type">relationship type</param>
    /// <returns>Ledger dimension or 0 if no such tax transaction</returns>
    public LedgerDimensionAccount getLedgerDimensionForTaxTrans_RU(RefRecId _taxTrans, TaxTransRelationshipType _type)
    {
        LedgerVoucherTransList           ledgerVoucherTransList = this.getInternalCollection();
        LedgerVoucherTransObject         ledgerVoucherTransObject;
        boolean                          haveVoucherTrans;
        LedgerPostingOneToManyCollection taxLinks;
        Set                              typesSet;
        SetEnumerator                    typesEnumerator;
        container                        typesContainer;
        TaxTransRelationshipType         type;

        for (haveVoucherTrans = ledgerVoucherTransList.first(); haveVoucherTrans; haveVoucherTrans = ledgerVoucherTransList.next())
        {
            ledgerVoucherTransObject = ledgerVoucherTransList.item();

            taxLinks = ledgerVoucherTransObject.parmTaxLinks();

            typesSet = taxLinks.find(_taxTrans);
            typesEnumerator = typesSet.getEnumerator();

            while (typesEnumerator.moveNext())
            {
                typesContainer = typesEnumerator.current();
                // The TaxTransRelationshipType is the first object in the container
                type = conPeek(typesContainer, 1);

                if (type == _type)
                {
                    return ledgerVoucherTransObject.parmLedgerDimensionId();
                }
            }
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger voucher type.
    /// </summary>
    /// <returns>
    /// The ledger voucher type.
    /// </returns>
    public LedgerVoucherType_CN getLedgerVoucherType_CN()
    {
        boolean                             more;
        List                                debitAccList  = new List(Types::Container);
        List                                creditAccList= new List(Types::Container);
        LedgerVoucherTransObject            ledgerVoucherTransObject;
        LedgerVoucherTypeRule_CN            voucherTypeRule;
        LedgerVoucherType_CN                voucherType;
        MainAccountNum                      ledgerAccount;

        more = transactionCollection.first();
        while (more)
        {
            ledgerVoucherTransObject = transactionCollection.item();

            ledgerAccount = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(ledgerVoucherTransObject.parmLedgerDimensionId());

            if (ledgerVoucherTransObject.isCredit())
            {
                creditAccList.addEnd([ledgerAccount, LedgerJournalACType::Ledger]);
            }
            else
            {
                debitAccList.addEnd([ledgerAccount, LedgerJournalACType::Ledger]);
            }

            more = transactionCollection.next();
        }

        voucherTypeRule = LedgerVoucherTypeRule_CN::newFromAccount(debitAccList, creditAccList);
        if (voucherTypeRule)
        {
            voucherType = voucherTypeRule.getVoucherType();
        }

        return voucherType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionAmountsByCurrency</Name>
				<Source><![CDATA[
    public Map getTransactionAmountsByCurrency()
    {
        if (!trackTransactionAmountsByCurrency)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return transactionAmountsByCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionsForPostingType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a list of ledger posting transaction of a specific posting type.
    /// </summary>
    /// <param name="_postingType">
    /// The specific posting type whose transactions are required in list.
    /// </param>
    /// <returns>
    /// A list of ledger posting transaction for the specified posting type.
    /// </returns>
    public List getTransactionsForPostingType(LedgerPostingType _postingType)
    {
        List    list = new List(Types::Class);
        boolean haveMore;

        haveMore =  transactionCollection.first();

        while ( haveMore )
        {
            if ( transactionCollection.item().parmPostingType() == _postingType )
            {
                list.addEnd( transactionCollection.item() );
            }
            haveMore = transactionCollection.next();
        }

        return list;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets values based on a ledger voucher.
    /// </summary>
    /// <param name = "_journal">
    /// The <c>LedgerVoucher</c> instance.
    /// </param>
    public void initFromJournal(LedgerVoucher _journal)
    {
        generalJournalEntry.RecId = _journal.getNextTemporaryRecId();

        if (sysModule == SysModule::None)
        {
            sysModule = _journal.parmSysModuleDefault();
        }

        if (voucherSeriesCode == '' && _journal.parmVoucherSeriesCode())
        {
            this.parmVoucherSeriesCode(_journal.parmVoucherSeriesCode());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the Chinese voucher type.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Throw an error when get voucher type unsuccessfully.
    /// </exception>
    public void initLedgerVoucherType_CN()
    {
        LedgerVoucherType_CN ledgerVoucherType;

        if (!generalJournalEntryW.LedgerVoucherType_CN)
        {
            ledgerVoucherType = this.getLedgerVoucherType_CN();

            if (!ledgerVoucherType)
            {
                // Fail to get voucher type
                throw error("@GLS60253");
            }

            generalJournalEntryW.LedgerVoucherType_CN = ledgerVoucherType.RecId;

            NumberSeq numberSeqVoucher = 
                NumberSeq_Voucher_CN::newGetVoucherFromCode(ledgerVoucherType.NumberSequenceTable, this.parmAccountingDate());

            FiscalPeriodType fiscalPeriodType = 
                this.parmFiscalCalendarPeriod() ?
                FiscalCalendarPeriod::find(this.parmFiscalCalendarPeriod()).Type :
                FiscalPeriodType::Operating;

            NumberSeq_Voucher_CN numberSeqVoucher_CN = numberSeqVoucher as NumberSeq_Voucher_CN;
            if (numberSeqVoucher_CN)
            {
                numberSeqVoucher_CN.parmFiscalPeriodType(fiscalPeriodType);
            }

            generalJournalEntryW.Voucher_CN = numberSeqVoucher.voucher();

            NumberSeq_Voucher_CN::isUsed(
                LedgerVoucherType_CN::find(generalJournalEntryW.LedgerVoucherType_CN).NumberSequenceTable,
                generalJournalEntryW.Voucher_CN,
                this.parmAccountingDate(),
                fiscalPeriodType);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the isPosted value.
    /// </summary>
    /// <returns>
    /// The isPosted value.
    /// </returns>
    public boolean isPosted()
    {
        return isPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the amount in the currency of the last added transaction.
    /// </summary>
    /// <returns>
    ///    The transaction amount in currency.
    /// </returns>
    public AmountCur lastAmountCur()
    {
        return lastAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns amount in default currency of the last added transaction.
    /// </summary>
    /// <returns>
    ///    The amount in default currency of the last added transaction.
    /// </returns>
    public AmountMST lastAmountMST()
    {
        return lastAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastAmountMSTSecondary_RU</Name>
				<Source><![CDATA[
    public AmountMSTSecondary lastAmountMSTSecondary_RU()
    {
        return lastAmountMSTSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastTransTxt</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns transaction text of the last added transaction.
    /// </summary>
    /// <param name="_transTxt">
    ///    A transaction text; optional.
    /// </param>
    /// <returns>
    ///    The transaction text of the last added transaction.
    /// </returns>
    public TransactionTextLarge lastTransTxt(TransactionTextLarge _transTxt = textDefault)
    {
        textDefault = _transTxt;
        return textDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerBondClient_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///  returns current <c>LedgerBondClient_RU</c>
    /// </summary>
    /// <returns>
    ///  LedgerBondClient_RU
    /// </returns>
    public LedgerBondClient_RU ledgerBondClient_RU()
    {
        return ledgerBondClient;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRoundingDifferenceInAccountingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum rounding difference amount in accounting currency.
    /// </summary>
    /// <param name = "_ledgerParameters">The <c>LedgerParameters</c> table record to determine the default value.</param>
    /// <param name = "_ledgerJournalId">The journal number to provide journal level override; optional.</param>
    /// <returns>The maximum rounding difference amount threshold for accounting currency.</returns>
    /// <remarks>
    /// Extension point for chain of command.
    /// </remarks>
    protected AmountMST maximumRoundingDifferenceInAccountingCurrency(LedgerParameters _ledgerParameters, LedgerJournalId _ledgerJournalId)
    {
        return _ledgerParameters.MaxRoundingDifferenceMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maximumRoundingDifferenceInReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the maximum rounding difference amount in reporting currency.
    /// </summary>
    /// <param name = "_ledgerParameters">The <c>LedgerParameters</c> table record to determine the default value.</param>
    /// <param name = "_ledgerJournalId">The journal number to provide journal level override; optional.</param>
    /// <returns>The maximum rounding difference amount threshold for reporting currency.</returns>
    /// <remarks>
    /// Extension point for chain of command.
    /// </remarks>
    protected AmountMST maximumRoundingDifferenceInReportingCurrency(LedgerParameters _ledgerParameters, LedgerJournalId _ledgerJournalId)
    {
        return _ledgerParameters.MaxRoundingDifferenceMSTSecond;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(Voucher _subledgerVoucher, TransDate _accountingDate)
    {
        // <GEERU>
        boolean     countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
        // read these records so we don't have to call their find methods many times
        legalEntity = CompanyInfo::current();
        legalEntityDataArea = curext();
        ledger = Ledger::find(Ledger::current());
        ledgerParameters = LedgerParameters::find();

        if (ledger == null)
        {
            throw error(Error::missingRecord(funcName()));
        }

        generalJournalEntry.Ledger = ledger.RecId;

        generalJournalEntry.SubledgerVoucher = _subledgerVoucher;
        generalJournalEntry.SubledgerVoucherDataAreaId = curext();
        generalJournalEntry.AccountingDate = _accountingDate;
        generalJournalEntry.Ledger = ledger.RecId;

        this.updateFiscalCalendarPeriod();
        this.updateAcknowledgementDate(generalJournalEntry.AccountingDate);

        voucherCheck = true;
        isReferenceValidated = false;
        isReferenceValid = true;

        transactionCollection = LedgerVoucherTransList::construct();

        // <GEERU>
        if (countryRegion_RU)
        {
            this.bondInit_RU();
        }
        // </GEERU>
        transactionAmountsByCurrency = new Map(Types::String, Types::Real);

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            dimensionBalancingValidator = DimensionBalancingValidator::construct();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public TransDate parmAccountingDate(TransDate _accountingDate = generalJournalEntry.AccountingDate)
    {
        TransDate   previousAccountingDate;

        if (!prmisDefault(_accountingDate))
        {
            previousAccountingDate = generalJournalEntry.AccountingDate;
            generalJournalEntry.AccountingDate = _accountingDate;

            this.updateFiscalCalendarPeriod();

            this.updateAcknowledgementDate(previousAccountingDate);

            this.updateLedgerPostingJournal();
            // <GEERU>
            if (ledgerBondClient)
            {
                ledgerBondClient.parmTransDate(_accountingDate);
            }
            // </GEERU>
        }

        // perf: Returning the parameter is correct and much faster than accessing a table field
        return _accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAcknowledgementDate</Name>
				<Source><![CDATA[
    public AcknowledgementDate parmAcknowledgementDate(AcknowledgementDate _acknowledgementDate = generalJournalEntry.AcknowledgementDate)
    {
        generalJournalEntry.AcknowledgementDate = _acknowledgementDate;

        return generalJournalEntry.AcknowledgementDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBondProgress_RU</Name>
				<Source><![CDATA[
    public SysOperationProgress parmBondProgress_RU(SysOperationProgress _value = bondProgress)
    {
        bondProgress = _value;
        return bondProgress;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBudgetSourceRecId</Name>
				<Source><![CDATA[
    public RecId parmBudgetSourceRecId(RecId _budgetSourceRecId = generalJournalEntry.BudgetSourceLedgerEntryPosted)
    {
        generalJournalEntry.BudgetSourceLedgerEntryPosted = _budgetSourceRecId;

        return generalJournalEntry.BudgetSourceLedgerEntryPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCorrection</Name>
				<Source><![CDATA[
    // Obsolete: use parmIsCorrectionDefault
    public boolean parmCorrection(boolean _correction = isCorrectionDefault)
    {
        isCorrectionDefault = _correction;
        return isCorrectionDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocument</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or Sets the document date and document number.
    /// </summary>
    /// <param name="_documentDate">
    ///    The new document date value; optional.
    /// </param>
    /// <param name="_documentNumber">
    ///    The new document number value; optional.
    /// </param>
    /// <returns>
    ///    A container holding the current values of the document date and document number.
    /// </returns>
    public container parmDocument(
        DocumentDate _documentDate = generalJournalEntry.DocumentDate,
        DocumentNum _documentNumber = generalJournalEntry.DocumentNumber)
    {
        generalJournalEntry.DocumentDate = _documentDate;
        generalJournalEntry.DocumentNumber = _documentNumber;

        return [generalJournalEntry.DocumentDate, generalJournalEntry.DocumentNumber];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentDate</Name>
				<Source><![CDATA[
    public DocumentDate parmDocumentDate(DocumentDate _documentDate = generalJournalEntry.DocumentDate)
    {
        generalJournalEntry.DocumentDate = _documentDate;

        return generalJournalEntry.DocumentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDocumentNumber</Name>
				<Source><![CDATA[
    public DocumentNum parmDocumentNumber(DocumentNum _documentNumber = generalJournalEntry.DocumentNumber)
    {
        generalJournalEntry.DocumentNumber = _documentNumber;

        return generalJournalEntry.DocumentNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalCalendarPeriod</Name>
				<Source><![CDATA[
    public FiscalCalendarPeriodRecId parmFiscalCalendarPeriod(FiscalCalendarPeriodRecId _fiscalCalendarPeriod = generalJournalEntry.FiscalCalendarPeriod)
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;
        FiscalCalendarPeriodRecId prevFiscalCalendarPeriod = generalJournalEntry.FiscalCalendarPeriod;

        generalJournalEntry.FiscalCalendarPeriod = _fiscalCalendarPeriod;

        if (prevFiscalCalendarPeriod != generalJournalEntry.FiscalCalendarPeriod)
        {
            if (generalJournalEntry.FiscalCalendarPeriod == 0)
            {
                generalJournalEntry.FiscalCalendarYear = 0;
            }
            else
            {
                fiscalCalendarPeriod = FiscalCalendarPeriod::find(generalJournalEntry.FiscalCalendarPeriod);
                generalJournalEntry.FiscalCalendarYear = fiscalCalendarPeriod.FiscalCalendarYear;
            }
        }

        return generalJournalEntry.FiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFiscalCalendarPeriodRecId</Name>
				<Source><![CDATA[
    public FiscalCalendarPeriodRecId parmFiscalCalendarPeriodRecId(FiscalCalendarPeriodRecId _fiscalCalendarPeriod = generalJournalEntry.FiscalCalendarPeriod)
    {
        this.parmFiscalCalendarPeriod(_fiscalCalendarPeriod);
 
        return generalJournalEntry.FiscalCalendarPeriod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGeneralJournalEntry</Name>
				<Source><![CDATA[
    public GeneralJournalEntry parmGeneralJournalEntry(GeneralJournalEntry _generalJournalEntry = generalJournalEntry.data())
    {
        generalJournalEntry = _generalJournalEntry.data();

        return generalJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmGeneralJournalEntryRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the record ID of the general journal entry.
    /// </summary>
    /// <param name="_generalJournalEntryRecId">
    /// The record ID of the general journal entry; optional.
    /// </param>
    /// <returns>
    /// The record ID of the general journal entry.
    /// </returns>
    /// <remarks>
    /// This value is only meaningful after the ledger voucher has been posted.
    /// </remarks>
    public GeneralJournalEntryRecId parmGeneralJournalEntryRecId(GeneralJournalEntryRecId _generalJournalEntryRecId = generalJournalEntry.RecId)
    {
        generalJournalEntry.RecId = _generalJournalEntryRecId;

        return generalJournalEntry.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCorrectionDefault</Name>
				<Source><![CDATA[
    public boolean parmIsCorrectionDefault(boolean _isCorrectionDefault = isCorrectionDefault)
    {
        isCorrectionDefault = _isCorrectionDefault;

        return isCorrectionDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsExplicitBudgetCheckRequired</Name>
				<Source><![CDATA[
    public boolean parmIsExplicitBudgetCheckRequired(boolean _isExplicitBudgetCheckRequired = isExplicitBudgetCheckRequired)
    {
        isExplicitBudgetCheckRequired = _isExplicitBudgetCheckRequired;

        return isExplicitBudgetCheckRequired;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsTaxWithholdParametersEnabled_IN</Name>
				<Source><![CDATA[
    public boolean parmIsTaxWithholdParametersEnabled_IN(boolean _isTaxWithholdParametersEnabled = isTaxWithholdParametersEnabled)
    {
        isTaxWithholdParametersEnabled = _isTaxWithholdParametersEnabled;
        return isTaxWithholdParametersEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalCategory</Name>
				<Source><![CDATA[
    public LedgerTransType parmJournalCategory(LedgerTransType _journalCategory = generalJournalEntry.JournalCategory)
    {
        generalJournalEntry.JournalCategory = _journalCategory;

        return generalJournalEntry.JournalCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the journal number parameter.
    /// </summary>
    /// <param name="_journalNumber">
    /// The journal number parameter; optional.
    /// </param>
    /// <returns>
    /// The journal number parameter.
    /// </returns>
    /// <remarks>
    /// This value is generated during ledger posting and is only meaningful after
    /// the ledger voucher has been posted.
    /// </remarks>
    public Voucher parmJournalNumber(Voucher _journalNumber = generalJournalEntry.JournalNumber)
    {
        generalJournalEntry.JournalNumber = _journalNumber;

        return generalJournalEntry.JournalNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the reference to the LedgerPostingJournal table.
    /// </summary>
    /// <param name="_ledgerPostingJournal">
    /// The reference to the LedgerPostingJournal table; optional.
    /// </param>
    /// <returns>
    /// The reference to the LedgerPostingJournal table.
    /// </returns>
    public LedgerPostingJournalId parmLedgerPostingJournal(LedgerPostingJournalId _ledgerPostingJournal = generalJournalEntry.LedgerPostingJournal)
    {
        LedgerPostingJournalVoucherSeries postingJournalVoucherSeries;
        boolean needUpdate = (generalJournalEntry.LedgerPostingJournal != _ledgerPostingJournal);

        generalJournalEntry.LedgerPostingJournal = _ledgerPostingJournal;

        if (needUpdate)
        {
            // reverse engineer the voucher series code
            if (generalJournalEntry.LedgerPostingJournal == '')
            {
                voucherSeriesCode = '';
            }
            else
            {
                postingJournalVoucherSeries =
                    LedgerPostingJournalVoucherSeries::findByDateLedgerPostingJournalId(generalJournalEntry.LedgerPostingJournal,generalJournalEntry.AccountingDate);

                voucherSeriesCode = postingJournalVoucherSeries.VoucherSeries;
            }
        }

        return generalJournalEntry.LedgerPostingJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerPostingJournalId</Name>
				<Source><![CDATA[
    public LedgerPostingJournalId parmLedgerPostingJournalId(LedgerPostingJournalId _ledgerPostingJournalId = generalJournalEntry.LedgerPostingJournal)
    {
        this.parmLedgerPostingJournal(_ledgerPostingJournalId);

        return generalJournalEntry.LedgerPostingJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTransType</Name>
				<Source><![CDATA[
    // Obsolete: use parmTransactionTypeDefault
    public LedgerTransType parmLedgerTransType(LedgerTransType _journalCategory = generalJournalEntry.JournalCategory)
    {
        generalJournalEntry.JournalCategory = _journalCategory;

        return generalJournalEntry.JournalCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucherType_CN</Name>
				<Source><![CDATA[
    public LedgerVoucherTypeRefRecId_CN parmLedgerVoucherType_CN(
        LedgerVoucherTypeRefRecId_CN _ledgerVoucherType_CN = generalJournalEntryW.LedgerVoucherType_CN)
    {
        generalJournalEntryW.LedgerVoucherType_CN = _ledgerVoucherType_CN;
        return generalJournalEntryW.LedgerVoucherType_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHasDefaultDescription</Name>
				<Source><![CDATA[
    public boolean parmHasDefaultDescription(boolean _hasDefaultDescription = hasDefaultDescription)
    {
        hasDefaultDescription = _hasDefaultDescription;
        
        return hasDefaultDescription;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedger</Name>
				<Source><![CDATA[
    public Ledger parmLedger()
    {
        return ledger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLegalEntity</Name>
				<Source><![CDATA[
    public DataAreaId parmLegalEntity()
    {
        return legalEntityDataArea;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentReference</Name>
				<Source><![CDATA[
    // Obsolete: use parmPaymentReferenceDefault
    public PaymReference parmPaymentReference(PaymReference _paymReference = paymentReferenceDefault)
    {
        paymentReferenceDefault = _paymReference;
        return paymentReferenceDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymentReferenceDefault</Name>
				<Source><![CDATA[
    public PaymReference parmPaymentReferenceDefault(PaymReference _paymentReferenceDefault = paymentReferenceDefault)
    {
        paymentReferenceDefault = _paymentReferenceDefault;

        return paymentReferenceDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostingLayer</Name>
				<Source><![CDATA[
    public CurrentOperationsTax parmPostingLayer(CurrentOperationsTax _postingLayer = generalJournalEntry.PostingLayer)
    {
        generalJournalEntry.PostingLayer = _postingLayer;

        return generalJournalEntry.PostingLayer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjIdDefault_SA</Name>
				<Source><![CDATA[
    public ProjId parmProjIdDefault_SA(ProjId _projIdDefault_SA = projIdDefault_SA)
    {
        if (ledgerParameters.IsZakatEnabled_SA)
        {
            projIdDefault_SA = _projIdDefault_SA;
        }

        return projIdDefault_SA;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReasonRef</Name>
				<Source><![CDATA[
    public ReasonRefRecID  parmReasonRef(ReasonRefRecID _reasonRef = reasonRef)
    {
        reasonRef = _reasonRef;
        return reasonRef;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReferenceNumber</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmSubledgerVoucher
    public Voucher parmReferenceNumber(Voucher _subledgerVoucher = generalJournalEntry.SubledgerVoucher)
    {
        generalJournalEntry.SubledgerVoucher = _subledgerVoucher;

        return generalJournalEntry.SubledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipPeriodStatusValidation</Name>
				<Source><![CDATA[
    public boolean parmSkipPeriodStatusValidation(boolean _skipPeriodStatusValidation = skipPeriodStatusValidation)
    {
        skipPeriodStatusValidation = _skipPeriodStatusValidation;

        return skipPeriodStatusValidation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipPeriodTypeValidation</Name>
				<Source><![CDATA[
    public boolean parmSkipPeriodTypeValidation(boolean _skipPeriodTypeValidation = skipPeriodTypeValidation)
    {
        skipPeriodTypeValidation = _skipPeriodTypeValidation;

        return skipPeriodTypeValidation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipZeroAmountCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>skipZeroAmountCheck</c> variable that indicates to allow the zero amount record,  adding and posting of voucher.
    /// </summary>
    /// <param name="_skipZeroAmountCheck">
    /// The setting the value for skipZeroAmountCheck
    /// </param>
    /// <returns>
    /// The skipZeroAmountCheck value.
    /// </returns>
    public boolean parmSkipZeroAmountCheck(boolean _skipZeroAmountCheck = skipZeroAmountCheck)
    {
        skipZeroAmountCheck = _skipZeroAmountCheck;

        return skipZeroAmountCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceRecIdDefault</Name>
				<Source><![CDATA[
    public RecId parmSourceRecIdDefault(RecId _sourceRecIdDefault = sourceRecIdDefault)
    {
        sourceRecIdDefault = _sourceRecIdDefault;

        return sourceRecIdDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceTableIdDefault</Name>
				<Source><![CDATA[
    public TableId parmSourceTableIdDefault(TableId _sourceTableIdDefault = sourceTableIdDefault)
    {
        sourceTableIdDefault = _sourceTableIdDefault;

        return sourceTableIdDefault;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubledgerJournalEntryRecId</Name>
				<Source><![CDATA[
    public SubledgerJournalEntryRecId parmSubledgerJournalEntryRecId(SubledgerJournalEntryRecId _subledgerJournalEntryRecId)
    {
        // the GeneralJournalEntry.SubledgerJournalEntry field is not persisted, but it exists
        // because encapsulating the link from GJE to SJE is clean and eliminates the need
        // to store a GJE to SJE mapping which improves performance and reduces clutter
        generalJournalEntry.SubledgerJournalEntry = _subledgerJournalEntryRecId;
        return generalJournalEntry.SubledgerJournalEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubledgerVoucher</Name>
				<Source><![CDATA[
    public Voucher parmSubledgerVoucher(Voucher _subledgerVoucher = generalJournalEntry.SubledgerVoucher)
    {
        generalJournalEntry.SubledgerVoucher = _subledgerVoucher;

        return generalJournalEntry.SubledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSubledgerVoucherDataAreaId</Name>
				<Source><![CDATA[
    public SelectableDataArea parmSubledgerVoucherDataAreaId(SelectableDataArea _subledgerVoucherDataAreaId = generalJournalEntry.SubledgerVoucherDataAreaId)
    {
        generalJournalEntry.SubledgerVoucherDataAreaId = _subledgerVoucherDataAreaId;

        return generalJournalEntry.SubledgerVoucherDataAreaId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSysModule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>sysModule</c> variable that indicates the module from which the posting was called and determines whether the module is open for posting.
    /// </summary>
    /// <param name="_sysModule">
    /// The new <c>SysModule</c> value; optional.
    /// </param>
    /// <returns>
    /// The new <c>SysModule</c> value.
    /// </returns>
    public SysModule parmSysModule(SysModule _sysModule = sysModule)
    {
        sysModule = _sysModule;

        return sysModule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTrackTransactionAmountsByCurrency</Name>
				<Source><![CDATA[
    public boolean parmTrackTransactionAmountsByCurrency(boolean _trackTransactionAmountsByCurrency = trackTransactionAmountsByCurrency)
    {
        trackTransactionAmountsByCurrency = _trackTransactionAmountsByCurrency;

        return trackTransactionAmountsByCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionTypeDefault</Name>
				<Source><![CDATA[
    public LedgerTransType parmTransactionTypeDefault(LedgerTransType _journalCategory = generalJournalEntry.JournalCategory)
    {
        generalJournalEntry.JournalCategory = _journalCategory;

        return generalJournalEntry.JournalCategory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransDate</Name>
				<Source><![CDATA[
    // Obsolete: use parmAccountingDate
    public TransDate parmTransDate(TransDate _transDate = generalJournalEntry.AccountingDate)
    {
        this.parmAccountingDate(_transDate);

        return generalJournalEntry.AccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseBalanceDifference</Name>
				<Source><![CDATA[
    public boolean parmUseBalanceDifference(boolean _useBalanceDifference = useBalanceDifference)
    {
        useBalanceDifference = _useBalanceDifference;

        return useBalanceDifference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher</Name>
				<Source><![CDATA[
    // OBSOLETE: use parmSubledgerVoucher
    public Voucher parmVoucher(Voucher _subledgerVoucher = generalJournalEntry.SubledgerVoucher)
    {
        generalJournalEntry.SubledgerVoucher = _subledgerVoucher;

        return generalJournalEntry.SubledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucher_CN</Name>
				<Source><![CDATA[
    public Voucher_CN parmVoucher_CN(Voucher_CN _voucher_CN = generalJournalEntryW.Voucher_CN)
    {
        generalJournalEntryW.Voucher_CN = _voucher_CN;
        return generalJournalEntryW.Voucher_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets or gets the <c>voucherCheck</c> variable that indicates whether validation must check for duplicate voucher numbers.
    /// </summary>
    /// <param name="_voucherCheck">
    ///    The Boolean value to set the <c>voucherCheck</c> variable to.
    /// </param>
    /// <returns>
    ///    The value of the <c>voucherCheck</c> variable.
    /// </returns>
    public boolean parmVoucherCheck(boolean _voucherCheck = voucherCheck)
    {
        voucherCheck = _voucherCheck;
        return voucherCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherSeriesCode</Name>
				<Source><![CDATA[
    public NumberSequenceCode parmVoucherSeriesCode(NumberSequenceCode _voucherSeriesCode = voucherSeriesCode)
    {
        NumberSequenceCode previousVoucherSeriesCode = voucherSeriesCode;

        voucherSeriesCode = _voucherSeriesCode;

        if (previousVoucherSeriesCode != voucherSeriesCode)
        {
            this.updateLedgerPostingJournal();
        }

        return voucherSeriesCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTmpInterunitBalancerAccountEntry</Name>
				<Source><![CDATA[
    public LedgerTmpInterunitBalancerAccountEntry parmLedgerTmpInterunitBalancerAccountEntry(LedgerTmpInterunitBalancerAccountEntry _ledgerTmpInterunitBalancerAccountEntry = ledgerTmpInterunitBalancerAccountEntry)
    {
        ledgerTmpInterunitBalancerAccountEntry.linkPhysicalTableInstance(_ledgerTmpInterunitBalancerAccountEntry);

        return ledgerTmpInterunitBalancerAccountEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerTmpInterunitBalancerTotal</Name>
				<Source><![CDATA[
    public LedgerTmpInterunitBalancerTotal parmLedgerTmpInterunitBalancerTotal(LedgerTmpInterunitBalancerTotal _ledgerTmpInterunitBalancerTotal = ledgerTmpInterunitBalancerTotal)
    {
        ledgerTmpInterunitBalancerTotal.linkPhysicalTableInstance(_ledgerTmpInterunitBalancerTotal);

        return ledgerTmpInterunitBalancerTotal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFinTag</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public FinTagRecId parmFinTag(FinTagRecId _finTag = finTag)
    {
        finTag = _finTag;
        return finTag ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfInitLastCostAmt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes lastAmountCur and lastAmountMST parameters to zero.
    /// </summary>
    /// <remarks>
    /// <syntax>
    /// public void pmfInitLastCostAmt()
    /// </syntax>
    /// </remarks>
    public void pmfInitLastCostAmt()
    {
        lastAmountCur    = 0;
        lastAmountMST    = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks and posts the transactions of this ledger posting reference.
    /// </summary>
    /// <param name="_journal">
    /// The ledger posting journal of this ledger posting reference.
    /// </param>
    /// <returns>
    /// true if the current object was posted successfully; otherwise, false.
    /// </returns>
    public boolean post(LedgerVoucher _journal)
    {
        LedgerVoucherInterunitBalancer interunitBalancer;
        LedgerVoucherTransObject trans;
        LedgerVoucherTransObject interunitTrans;
        List newTransactions;
        boolean addedTransactions;
        boolean haveMore;
        boolean isValid;
        boolean isValidToPost;
        boolean isUpdated;
        boolean isUpdatedTemp;
        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        Debug::assert(!isPosted);

        if (transactionCollection.elements() == 0)
        {
            // perf: do nothing if there are no transactions
            return true;
        }

        addedTransactions = false;
        isValidToPost = true;

        changecompany(legalEntityDataArea)
        {
            isValid = this.check(_journal);
            isValidToPost = isValidToPost && isValid;

            if (isValidToPost)
            {
                if (LedgerInterunitBalancer::isBalancingEnabled())
                {
                    interunitBalancer = LedgerVoucherInterunitBalancer::construct();
                    interunitBalancer.parmLedgerTmpInterunitBalancerAccountEntry(ledgerTmpInterunitBalancerAccountEntry);
                    interunitBalancer.parmLedgerTmpInterunitBalancerTotal(ledgerTmpInterunitBalancerTotal);
                }

                [isValid, haveMore] = this.addBalanceAdjustments(_journal, interunitBalancer);
                isValidToPost = isValidToPost && isValid;
                addedTransactions = addedTransactions || haveMore;

                if (ledgerBondClient)
                {
                    this.bond_initApplier_RU();
                }

                // post children
                haveMore = transactionCollection.first();
                while (haveMore)
                {
                    trans = transactionCollection.item();

                    isUpdated = trans.post(_journal, this);

                    // If the transaction has an interunit reference specified, the transaction is already added to the interunit
                    // transaction collection.
                    if (interunitBalancer != null && !trans.parmInterunitReference())
                    {
                        isUpdatedTemp = interunitBalancer.addTrans(trans);
                        isUpdated = isUpdated || isUpdatedTemp;
                    }

                    if (isUpdated)
                    {
                        // perf: list implementation requires explicit updates because it does not use references
                        transactionCollection.update(trans);
                    }

                    haveMore = transactionCollection.next();
                }

                if (isValidToPost)
                {
                    if (interunitBalancer != null)
                    {
                        newTransactions = new List(Types::Class);
                        ledgerTmpInterunitBalancerAccountEntry = interunitBalancer.performBalancing();

                        haveMore = transactionCollection.first();
                        while (haveMore)
                        {
                            trans = transactionCollection.item();

                            interunitTrans = trans.performInterunitBalancing(ledgerTmpInterunitBalancerAccountEntry);
                            if (interunitTrans != null)
                            {
                                newTransactions.addEnd(interunitTrans);
                            }

                            haveMore = transactionCollection.next();
                        }

                        [isValid, isValidToPost, addedTransactions] = this.processInterunitTransactions(_journal, newTransactions, isValid, isValidToPost, addedTransactions);
                    }

                    if (addedTransactions)
                    {
                        haveMore = transactionCollection.first();
                        while (haveMore)
                        {
                            trans = transactionCollection.item();

                            isUpdated = trans.post(_journal, this);

                            if (isUpdated && interunitBalancer != null && !trans.IsInterunitAdjustment())
                            {
                                isUpdatedTemp = interunitBalancer.addTrans(trans);
                                isUpdated = isUpdated || isUpdatedTemp;
                            }

                            if (isUpdated)
                            {
                                // perf: list implementation requires explicit updates because it does not use references
                                transactionCollection.update(trans);
                            }

                            haveMore = transactionCollection.next();
                        }
                    }
                }
                else
                {
                    isValidToPost = checkFailed("@SYS24803");
                }
            }

            // <GEERU>
            if (countryRegion_RU)
            {
                this.bond_afterPost_RU(_journal);
            }
            // </GEERU>

            if (isValidToPost)
            {
                // final absolute balance check
                isValid = this.checkBalance(_journal, false);
                if (!isValid)
                {
                    isValidToPost = checkFailed("@SYS24803");
                }

                if (isValid
                    && isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && (LedgerJournalTable::find(_journal.parmJournalNumber()).JournalType != LedgerJournalType::Cost
                    ||  LedgerJournalTrans_Project::find(LedgerJournalTrans::find(_journal.parmJournalNumber(), this.parmVoucher(), false).RecId).RecId)
                    && !dimensionBalancingValidator.checkDimensionBalance())
                {
                    isValidToPost = false;
                }

                // <GTH>
                if (isValid && TaxThaiGovCertificationFeatureChecker::isTaxBranchEnabled())
                {
                    isValid = this.checkAccountStructure();
                }
                // </GTH>

                // <GCN>
                if (!isValidToPost && LedgerParameters::isChineseVoucher_CN())
                {
                    NumberSeq_Voucher_CN::release(
                        LedgerVoucherType_CN::find(this.parmLedgerVoucherType_CN()).NumberSequenceTable,
                        this.parmVoucher_CN(),
                        this.parmAccountingDate());

                    this.parmLedgerVoucherType_CN(0);
                    this.parmVoucher_CN('');
                }
                // </GCN>

                if (isValidToPost && transactionCollection.elements() > 0
                    // <GEERU>
                    && !ledgerBondClient
                    // </GEERU>
                    )
                {
                    isPosted = true;
                }
            }
        }

        return isValidToPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processInterunitTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the inter unit entries to transaction.
    /// </summary>
    /// <param name = "_journal">
    /// The ledger posting journal.
    /// </param>
    /// <param name = "_newTransactions">
    /// The list of new transactions.
    /// </param>
    /// <param name = "_isValid">
    /// A boolean value indicating whether the journal is valid.
    /// </param>
    /// <param name = "_isValidToPost">
    /// A boolean value indicating whether the journal is valid to post.
    /// </param>
    /// <param name = "_addedTransactions">
    /// A boolean value indicating whether the transaction was added.
    /// </param>
    /// <returns>
    /// The container containing boolean isValid, isValidToPost, addedTransactions values.
    /// </returns>
    [Wrappable(true)]
    protected final container processInterunitTransactions(
        LedgerVoucher _journal,
        List _newTransactions,
        boolean _isValid,
        boolean _isValidToPost,
        boolean _addedTransactions)
    {
        boolean isValid = _isValid;
        boolean isValidToPost = _isValidToPost;
        boolean addedTransactions = _addedTransactions;

        ListEnumerator enumerator = _newTransactions.getEnumerator();
        while (enumerator.moveNext())
        {
            LedgerVoucherTransObject interunitTrans = enumerator.current();

            if (interunitTrans != null)
            {
                isValid = interunitTrans.checkData(_journal, this);
                isValidToPost = isValidToPost && isValid;

                if (isValid)
                {
                    this.addTrans(interunitTrans);

                    addedTransactions = true;
                }
            }
        }

        return [isValid, isValidToPost, addedTransactions];
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the transaction from the ledger posting reference.
    /// </summary>
    /// <param name="_transaction">
    /// The transaction to be removed.
    /// </param>
    public void removeTrans(LedgerVoucherTransObject _transaction)
    {
        if (_transaction == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        this.updateBalances(
            -_transaction.parmTransactionCurrencyAmount(),
            -_transaction.parmAccountingCurrencyAmount(),
            -_transaction.parmReportingCurrencyAmount());

        transactionCollection.remove(_transaction);

        // <GEERU>
        if (ledgerBondServer)
        {
            ledgerBondServer.removeTrans(this.vrefIDByTrans_RU(_transaction));
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldPostToSubledgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates whether the <c>LedgerVoucherObject</c> should post to Subledger Journal.
    /// </summary>
    /// <returns>
    /// true if it should be posted to subledger journal; otherwise, false.
    /// </returns>
    public boolean shouldPostToSubledgerJournal()
    {
        // the GeneralJournalEntry.SubledgerJournalEntry field is not persisted, but it exists
        // because encapsulating the link from GJE to SJE is clean and eliminates the need
        // to store a GJE to SJE mapping which improves performance and reduces clutter
        // The AccounteventRecId will only be assigned a value in two stage invoice posting process.
        // In this process, we skip some subledger journalization process in first stage, so the
        // SubledgerJournalEntry has not been generated yet at this point, but we still want to 
        // continue post to subledger at this point.
        return (generalJournalEntry.SubledgerJournalEntry != 0 || this.parmAccountingEventRecId() != 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showErrorTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows an <c>infolog</c> with information about all the transactions on the voucher.
    /// </summary>
    /// <param name="_subledgerVoucherCollection">
    /// The collection of subledger vouchers used during ledger posting.
    /// </param>
    /// <remarks>
    ///    This method is called when validation shows that the voucher does not balance.
    /// </remarks>
    public void showErrorTransactions(Map _subledgerVoucherCollection)
    {
        LedgerVoucherTransObject transaction;
        boolean haveMore;

        setPrefix("@SYS4872");

        haveMore = transactionCollection.first();
        while (haveMore)
        {
            transaction = transactionCollection.item();

            if (isDisplayCorrectDecimalsInErrors)
            {
                CurrencyCode transactionCurrency = transaction.parmTransactionCurrencyCode();
                CurrencyCode accountingCurrency = Ledger::accountingCurrency();
                CurrencyCode reportingCurrency = Ledger::reportingCurrency();

                info(strFmt(
                    "@SYS27675",
                    LedgerJournalTrans::findTmpVoucher(this.parmSubledgerVoucher(), _subledgerVoucherCollection),
                    this.parmAccountingDate(),
                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(transaction.parmLedgerDimensionId()),
                    LedgerAmountDecimalValues::decimalAmount(transaction.parmTransactionCurrencyAmount(), transactionCurrency),
                    LedgerAmountDecimalValues::decimalAmount(transaction.parmAccountingCurrencyAmount(), accountingCurrency),
                    LedgerAmountDecimalValues::decimalAmount(transaction.parmReportingCurrencyAmount(), reportingCurrency),
                    transactionCurrency,
                    transaction.parmText()));
            }
            else
            {
                info(strFmt(
                    "@SYS27675",
                    LedgerJournalTrans::findTmpVoucher(this.parmSubledgerVoucher(), _subledgerVoucherCollection),
                    this.parmAccountingDate(),
                    LedgerDimensionFacade::getDisplayValueForLedgerDimension(transaction.parmLedgerDimensionId()),
                    transaction.parmTransactionCurrencyAmount(),
                    transaction.parmAccountingCurrencyAmount(),
                    transaction.parmReportingCurrencyAmount(),
                    transaction.parmTransactionCurrencyCode(),
                    transaction.parmText()));
            }

            haveMore = transactionCollection.next();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionCollection_RU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the collection of ledger posting transactions.
    /// </summary>
    /// <returns>
    /// The collection of ledger posting transactions..
    /// </returns>
    public LedgerVoucherTransList transactionCollection_RU()
    {
        return transactionCollection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transElements</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the number of transactions within the voucher.
    /// </summary>
    /// <returns>
    ///    A <c>Counter</c> value with the number of transactions.
    /// </returns>
    /// <remarks>
    ///    Not currently used.
    /// </remarks>
    public Counter transElements()
    {
        return transactionCollection.elements();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAcknowledgementDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the acknowledgement date when the accounting date is changed.
    /// </summary>
    /// <param name="_previousAccountingDate">
    /// The accounting date value before the change.
    /// </param>
    /// <remarks>
    /// This method expects the new accounting date value has been set.
    /// </remarks>
    private void updateAcknowledgementDate(TransDate _previousAccountingDate)
    {
        if (generalJournalEntry.AccountingDate == _previousAccountingDate)
        {
            generalJournalEntry.AcknowledgementDate = generalJournalEntry.AccountingDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBalances</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Accounting, Reporting and Transaction currency balances based on the amounts of ledger posting reference.
    /// </summary>
    /// <param name = "_transactionCurrencyAmount">
    /// The amount in the transaction currency.
    /// </param>
    /// <param name = "_accountingCurrencyAmount">
    /// The amount in the accounting currency.
    /// </param>
    /// <param name = "_reportingCurrencyAmount">
    /// The amount in the reporting currency.
    /// </param>
    [Wrappable(true)]
    protected final void updateBalances(
        MoneyMST _transactionCurrencyAmount,
        MoneyMST _accountingCurrencyAmount,
        MoneyMST _reportingCurrencyAmount)
    {
        transactionCurrencyBalance += _transactionCurrencyAmount;
        accountingCurrencyBalance += _accountingCurrencyAmount;
        reportingCurrencyBalance += _reportingCurrencyAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFiscalCalendarPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the fiscal calendar period when the accounting date is changed.
    /// </summary>
    /// <param name="_fiscalPeriodType">
    /// The type of the fiscal period.
    /// </param>
    /// <remarks>
    /// This method expects the new accounting date value has been set.
    /// </remarks>
    private void updateFiscalCalendarPeriod(FiscalPeriodType _fiscalPeriodType = FiscalPeriodType::Operating)
    {
        FiscalCalendarPeriod fiscalCalendarPeriod;
        FiscalPeriodType periodType;

        if (generalJournalEntry.FiscalCalendarPeriod == 0)
        {
            periodType = _fiscalPeriodType;
        }
        else
        {
            // read the current period because we want to use the period code
            select firstonly Type from fiscalCalendarPeriod
                where fiscalCalendarPeriod.RecId == generalJournalEntry.FiscalCalendarPeriod;

            if (fiscalCalendarPeriod == null)
            {
                periodType = _fiscalPeriodType;
            }
            else
            {
                periodType = fiscalCalendarPeriod.Type;
            }
        }

        fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(
            ledger.FiscalCalendar,
            generalJournalEntry.AccountingDate,
            periodType);

        generalJournalEntry.FiscalCalendarPeriod = fiscalCalendarPeriod.RecId;
        generalJournalEntry.FiscalCalendarYear = fiscalCalendarPeriod.FiscalCalendarYear;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerPostingJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the ledger posting journal when the accounting date or voucher
    /// series code are changed.
    /// </summary>
    /// <remarks>
    /// This method expects the new accounting date or voucher series code value
    /// has been set.
    /// </remarks>
    protected void updateLedgerPostingJournal()
    {
        LedgerPostingJournalVoucherSeries   ledgerPostingJournalVoucherSeries;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoBE]))
        {
            if (voucherSeriesCode == '')
            {
                generalJournalEntry.LedgerPostingJournal = '';
                generalJournalEntry.LedgerPostingJournalDataAreaId = '';
            }
            else
            {
                ledgerPostingJournalVoucherSeries = LedgerPostingJournalVoucherSeries::find(voucherSeriesCode);
                if (generalJournalEntry.JournalCategory == LedgerTransType::GeneralJournal
                    || generalJournalEntry.JournalCategory == LedgerTransType::Purch
                    || generalJournalEntry.JournalCategory == LedgerTransType::Sales)
                {
                    generalJournalEntry.LedgerPostingJournal = ledgerPostingJournalVoucherSeries.LedgerPostingJournalId;
                }
                else
                {
                    this.parmLedgerPostingJournal(ledgerPostingJournalVoucherSeries.LedgerPostingJournalId);
                }
                generalJournalEntry.LedgerPostingJournalDataAreaId  = ledgerPostingJournalVoucherSeries.DataAreaId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the ledger voucher trans list
    /// </summary>
    /// <param name = "_transaction">Transaction Object</param>
    public void updateTrans(LedgerVoucherTransObject _transaction)
    {
        transactionCollection.update(_transaction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>vrefIDByTrans_RU</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns internal ledger bond related identificator for _trans
    /// </summary>
    /// <param name="_trans">
    ///    Transaction object
    /// </param>
    /// <returns>
    ///    BondId
    /// </returns>
    LedgerBondId_RU vrefIDByTrans_RU(LedgerVoucherTransObject _trans)
    {
        return bondAdapter.getID(_trans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReference</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the LedgerVoucherObject class.
    /// </summary>
    /// <param name="_subledgerVoucher">
    /// The subledger voucher used to identify the associate entries.
    /// </param>
    /// <param name="_accountingDate">
    /// The accounting date of the associated entries.
    /// </param>
    /// <param name="_sysModule">
    /// The system module of the associated entries; optional.
    /// </param>
    /// <returns>
    /// A new instance of the LedgerVoucherObject class.
    /// </returns>
    /// <remarks>
    /// A reference number was previously known as a voucher.
    /// </remarks>
    public static LedgerVoucherObject newReference(
        Voucher _subledgerVoucher,
        TransDate _accountingDate,
        SysModule _sysModule = SysModule::None)
    {
        LedgerVoucherObject postingReference = new LedgerVoucherObject(_subledgerVoucher, _accountingDate);

        postingReference.parmSysModule(_sysModule);

        return postingReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerVoucherObject</c> class using the specified values.
    /// </summary>
    /// <param name="_voucher">
    /// The subledger voucher.
    /// </param>
    /// <param name="_transDate">
    /// The accounting date; optional.
    /// </param>
    /// <param name="_sysModule">
    /// The module; optional.
    /// </param>
    /// <param name="_ledgerTransType">
    /// The transaction type; optional.
    /// </param>
    /// <param name="_isCorrectionDefault">
    /// The correction default; optional.
    /// </param>
    /// <param name="_operationsTax">
    /// The posting layer; optional.
    /// </param>
    /// <param name="_documentNum">
    /// The document number; optional.
    /// </param>
    /// <param name="_documentDate">
    /// The document date; optional.
    /// </param>
    /// <param name="_acknowledgementDate">
    /// The ackknowledgement date; optional.
    /// </param>
    /// <param name="_checkVoucher">
    /// A value that indicates whether to check the subledger voucher; optional.
    /// </param>
    /// <returns>
    /// A new instance of the <c>LedgerVoucherObject</c> class.
    /// </returns>
    /// <remarks>
    /// The <c>newReference</c> method is an updated version of this method.
    /// </remarks>
    public static LedgerVoucherObject newVoucher(
        Voucher             _voucher,
        TransDate           _transDate          = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),
        SysModule           _sysModule          = SysModule::None,
        LedgerTransType     _ledgerTransType    = LedgerTransType::None,
        NoYes               _isCorrectionDefault = NoYes::No,
        CurrentOperationsTax _operationsTax     = CurrentOperationsTax::Current,
        DocumentNum         _documentNum        = '',
        DocumentDate        _documentDate       = dateNull(),
        AcknowledgementDate _acknowledgementDate = dateNull()
        , boolean           _checkVoucher       = true
        )
    {
        LedgerVoucherObject ledgerVoucherObject = new LedgerVoucherObject(_voucher, _transDate);
        ledgerVoucherObject.parmSysModule(_sysModule);
        ledgerVoucherObject.parmLedgerTransType(_ledgerTransType);
        ledgerVoucherObject.parmIsCorrectionDefault(_isCorrectionDefault);
        ledgerVoucherObject.parmPostingLayer(_operationsTax);

        if (_acknowledgementDate != dateNull())
        {
            ledgerVoucherObject.parmAcknowledgementDate(_acknowledgementDate);
        }

        if (_documentDate || _documentNum)
        {
            ledgerVoucherObject.parmDocument(_documentDate, _documentNum);
        }

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
             ledgerVoucherObject.parmVoucherCheck(_checkVoucher);
        }
        // </GEERU>

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static LedgerVoucherObject construct(Voucher _subledgerVoucher, TransDate _accountingDate)
    {
        return new LedgerVoucherObject(_subledgerVoucher, _accountingDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAllTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes all the transaction from the ledger posting reference.
    /// </summary>
    public void removeAllTrans()
    {
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            dimensionBalancingValidator = DimensionBalancingValidator::construct();
        }

        transactionCurrencyBalance = 0;
        accountingCurrencyBalance = 0;
        reportingCurrencyBalance = 0;

        transactionCollection = LedgerVoucherTransList::construct();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.bondInit_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStatePackable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the state of the object can be packed.
    /// </summary>
    /// <returns>true if the state of the object can be packed; otherwise false.</returns>
    public boolean isStatePackable()
    {
        return ledgerBondServer == null &&
               ledgerBondClient == null &&
               bondApplier == null &&
               bondProgress == null &&
               lastAmountMSTSecondary == 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        if (this.isStatePackable())
        {
            GeneralJournalEntry localGeneralJournalEntry;

            buf2Buf(generalJournalEntry, localGeneralJournalEntry);
            return [#CurrentVersion,
                    #CurrentList,
                    buf2Con(localGeneralJournalEntry),
                    buf2Con(generalJournalEntryW)];
        }
        else
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        boolean success = false;
        container packedGeneralJournalEntry;
        container packedGeneralJournalEntryW;

        Version version = RunBase::getVersion(_packedClass);
    
        switch (version)
        {
            case #CurrentVersion:
                [version,
                 #CurrentList,
                 packedGeneralJournalEntry,
                 packedGeneralJournalEntryW] = _packedClass;
    
                success = true;
                break;
        }
        generalJournalEntry = con2Buf(packedGeneralJournalEntry);
        generalJournalEntryW = con2Buf(packedGeneralJournalEntryW);
    
        return success;
    }

]]></Source>
			</Method>
			<Method>
				<Name>create</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the <c>LedgerVoucherObject</c> class using a serialized instance of the class.
    /// </summary>
    /// <param name = "_packedClass">The container with serialized instance of the class.</param>
    /// <returns>A new instance of the <c>LedgerVoucherObject</c> class.</returns>
    public static LedgerVoucherObject create(container _packedClass)
    {
        LedgerVoucherObject ledgerVoucherObject = new LedgerVoucherObject('', dateNull());

        if (!ledgerVoucherObject.unpack(_packedClass))
        {
            throw error(error::wrongUseOfFunction(funcName()));
        }

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the voucher respects the current general ledger parameters settings for handling duplicate vouchers.
    /// </summary>
    /// <param name = "_voucher">The voucher which is to be validated.</param>
    /// <param name = "_ledgerVoucherNumberSequenceCode">The sequence code, which is to be used by the voucher.</param>
    /// <param name = "_transDate">The transaction date.</param>
    /// <returns>True if the voucher is valid; false, otherwise.</returns>
    public static boolean validateVoucher(Voucher _voucher, NumberSequenceCode _ledgerVoucherNumberSequenceCode, TransDate _transDate)
    {
        var ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary, SysModule::Invent, _ledgerVoucherNumberSequenceCode);
        
        var ledgerVoucherObject = LedgerVoucherObject::newVoucher(_voucher, _transDate, SysModule::Invent, LedgerTransType::Invent);

        ledgerVoucherObject.enableVoucherValidationEvenIfThereAreNoTransactions();
        ledgerVoucherObject.parmVoucherSeriesCode(_ledgerVoucherNumberSequenceCode);

        if (!ledgerVoucherObject.check(ledgerVoucher))
        {
            throw Exception::Error;
        }

        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>