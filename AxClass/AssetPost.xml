<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class AssetPost
{
    #isoCountryRegionCodes
    AssetTable assetTable;
    AssetTrans assetTrans;

    VendAccount vendAccount;
    VendInvoiceId vendInvoiceId;
    PurchId purchId;
    private VendInvoiceTrans vendInvoiceTrans;
    private PurchLine purchLine;
    private AssetTrans origAssetTransForCreditNote;
    private VendInvoiceTrans origVendInvoiceTransForCreditNote;
    private boolean isReversePOCurrencyFeatureEnabled;

    CustAccount custAccount;
    CustInvoiceId custInvoiceId;

    AssetDepreciationTime depreciationTime;
    LedgerVoucher ledgerVoucher;
    Voucher inventJournalTransVoucher;

    ExchRate exchRate;
    ExchrateSecondary exchRateSecond;
    ExchRate reportingCrossRate;
    ReportingCurrencyExchRate reportingCurrencyExchRate;
    ReportingCurrencyExchRateSecondary reportingCurrencyExchRateSecond;

    LedgerJournalTrans ledgerJournalTrans;
    LedgerJournalTrans originalLedgerJournalTrans;
    LedgerJournalTrans_Asset ledgerJournalTrans_Asset;
    boolean cashDiscTransaction;

    TaxAmountCur taxAmountInCostPriceCur;

    private boolean isDerivedBookPosting;
    boolean isInventorySoldTransNeeded;
    boolean isAccountsPayableAcquisition;
    boolean isProjEstimate;
    // <GEEEE>
    // <GEELT>
    boolean isCreditNote;
    // </GEELT>
    // </GEEEE>

    // <GIN>
    AssetGroupTrans_IN assetGroupTrans;
    AssetGroupInformation_IN assetGroupInformation;
    TaxAmountCur loadOnInventory;
    // </GIN>

    // <GEEPL>
    Percent assetSaleFactor;
    // </GEEPL>

    boolean isOffset;

    boolean isIsoJP;
    boolean isAssetDocumentEnable;
    private boolean isManuallyChangeDepProfileEnable_JP;
    private boolean isAssemblingEnabled_JP;
    AssetDocumentType_JP assetDocumentType_JP;
    AssetDocumentRecId_JP assetDocumentEntryRecId;
    VendInvoiceInfoLine_Asset vendInvoiceInfoLineAsset;
    // reduction entry
    // <GJP>
    AssetAmount reductionEntryAdjustment_JP;
    AmountCur reductionEntryAdjustmentCurVoucher_JP;
    AmountMST reductionEntryAdjustmentMSTVoucher_JP;
    private AssetAmount reductionEntryAdjustmentCurrentPeriod_JP;

    LedgerDimensionDefaultAccount disposalOffsetAccount;
    // </GJP>
    AssetDepreciationStartDate depreciationStartDate;

    boolean isIsoRU;
    private boolean isIsoIT;
    private boolean isIsoPL;
    private boolean isIsoCZ;
    private boolean isIsoEE;
    private boolean isIsoLT;
    private boolean isIsoIN;
    private boolean checkDepreciationParams_IN;
    private boolean isDepreciationIncomeTaxActEnable_IN;
    private boolean isIsoCN;
    private boolean isDepreciationPolicyEnabled_CN;

    PurchLine purchLineForInventSoldTrans;
    private RecId mainBookAssetTransRecId;

    private CurrentOperationsTax postingLayer;
    private boolean needToUpdateLedger;
    private boolean isOneVoucherFeatureEnabled;
    private AssetReversalRelatedVoucherManager assetReversalRelatedVoucherManager;
    private Voucher depreciationAdjustmentVoucher;
    private FinTagRecId finTag;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>findTransactionText</Name>
				<Source><![CDATA[
    private ledgerJournalTransTxt findTransactionText(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans_Asset _ledgerJournalTransAsset)
    {
        TransactionTextContext  transactionTextContext;
        TransactionTxt transactionTxt;
        LedgerJournalTransTxt ledgerJournalTransTxt;

        if (_ledgerJournalTransAsset.isSplitTransaction())
        {
            ledgerJournalTransTxt = "@SYS67430";
        }
        else if (_ledgerJournalTrans.Txt)
        {
            ledgerJournalTransTxt = _ledgerJournalTrans.Txt;
        }
        else
        {
            transactionTxt = TransactionTxt::construct(LedgerTransTxt::FixedAssetsPostingLedger);
            transactionTxt.setDate(_ledgerJournalTrans.TransDate);
            transactionTxt.setVoucher(assetTrans.Voucher);
            transactionTxt.setLanguage(currentUserLanguage());
            transactionTxt.setFormLetter(assetTrans.AssetId);
            transactionTxt.setKey1(assetTrans.AssetId);
            transactionTxt.setKey2(AssetTable::find(assetTrans.AssetId).AssetGroup);

            if (TransactionTextContext::isTypeSupported(LedgerTransTxt::FixedAssetsPostingLedger))
            {
                transactionTextContext = TransactionTextContext::newForTransactionType(LedgerTransTxt::FixedAssetsPostingLedger);
                transactionTextContext.setTableBuffer(assetTable);
                transactionTxt.setTransactionTextContext(transactionTextContext);
            }
            ledgerJournalTransTxt = transactionTxt.txt();
        }

        return ledgerJournalTransTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesAssetBookAllowPostingToGeneralLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method verifies if the asset book allows ledger posting.
    /// If not then it will thrown an error. asset books which do not allow ledger posting cannot
    /// be used in PO, Invoice, FTI, Project, Budget and Inventory
    /// </summary>
    /// <param name = "_assetBook">The asset book to check</param>
    /// <returns>true if posting is allowed to the General Ledger; otherwise, throws an error</returns>
    public boolean doesAssetBookAllowPostingToGeneralLedger(AssetBook _assetBook)
    {
        if (_assetBook.assetBookTable().postToGeneralLedger())
        {
            return true;
        }
        else
        {
            throw error(strFmt("@FixedAssets:FA_ErrorMessage_ValueModelNoLedgerPosting", _assetBook.BookId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcReductionEntryAdjustment_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates japan reduction entry adjustment based transaction date.
    /// </summary>
    /// <param name="_assetTrans">
    /// The main <c>AssetTrans</c> record.
    /// </param>
    private void calcReductionEntryAdjustment_JP(AssetTrans _assetTrans)
    {
        if (!this.isReductionEntryAcquisition_JP())
        {
            return;
        }
        
        AssetDocumentEntry_JP assetDocumentEntry = AssetDocumentEntry_JP::find(assetDocumentEntryRecId);

        // calculate reduction entry adjustment
        if (assetDocumentEntry)
        {
            AssetAmount acqAmount;
            AssetDepBookMap_JP assetBookMap = AssetDepBookMap_JP::findByAssetIdBookId(_assetTrans.AssetId, _assetTrans.BookId);
            AssetDocumentTable_JP assetDocumentTable = AssetDocumentTable_JP::find(assetDocumentEntry.AssetDocumentTable_JP);
            AssetTableInterval assetTableInterval = assetBookMap.AssetDepBookMap_JP::assetTableInterval();
            AssetDocumentReductionEntryTable_JP reductionEntryDocument = AssetDocumentReductionEntryTable_JP::findByDocumentEntry(assetDocumentEntry.RecId);

            // calculate acquisition
            if (assetDocumentTable.Type == AssetDocumentType_JP::AssetReductionEntry_Reserve
                || reductionEntryDocument.DocumentDate <= assetTableInterval.findFirstDayOfYear(_assetTrans.transDate))
            {
                acqAmount = assetBookMap.AcquisitionPrice;
            }
            else if (assetDocumentTable.Type == AssetDocumentType_JP::AssetReductionEntry_DirectOff)
            {
                acqAmount = assetBookMap.AcquisitionPrice + reductionEntryDocument.PostAmountMST;
            }

            if (acqAmount)
            {
                AssetTransDate transDate;
                AssetReductionEntryProfile_JP reductionEntryProfile = AssetReductionEntryProfile_JP::find(assetDocumentTable.DocumentId);

                // calculate depreciation amount
                if (assetDocumentTable.Type == AssetDocumentType_JP::AssetReductionEntry_Reserve
                    && reductionEntryProfile.AllocationConvention == AssetReductionEntryConvention_JP::None)
                {
                    transDate = assetTableInterval.findFirstDayOfYear(assetTableInterval.endPeriod(_assetTrans.TransDate)+1);
                }
                else
                {
                    transDate = assetTableInterval.findFirstDayOfYear(_assetTrans.TransDate);
                }

                AssetAmount depAmount = AssetDepTransMap_JP::calcBeginningBalOfAccumulatedDepAmtMst(assetBookMap, assetTableInterval, transDate);

                if (depAmount)
                {
                    AssetAmount amountLoc = _assetTrans.AmountMST;
                    reductionEntryAdjustment_JP = amountLoc - AssetReductionEntryManager_JP::getPostAdjustmentAmountMST(amountLoc, acqAmount, depAmount);
                    reductionEntryAdjustment_JP = AssetDepCalculationHelper_JP::roundOffDepreciation(reductionEntryAdjustment_JP);

                    if (reductionEntryProfile.Method == AssetReductionEntryMethod_JP::DirectOff)
                    {
                        AssetAmount depAmountCur = AssetDepTransMap_JP::calcAccumulatedDepAmountMstInCurYear(
                            assetBookMap,
                            assetTableInterval,
                            _assetTrans.transDate);

                        if (depAmountCur)
                        {
                            reductionEntryAdjustmentCurrentPeriod_JP = amountLoc - AssetReductionEntryManager_JP::getPostAdjustmentAmountMST(amountLoc, acqAmount, depAmountCur);
                            reductionEntryAdjustmentCurrentPeriod_JP = AssetDepCalculationHelper_JP::roundOffDepreciation(reductionEntryAdjustmentCurrentPeriod_JP);
                        }
                    }
                }
            }
        }

        // apply adjustment to transaction
        if (reductionEntryAdjustment_JP)
        {
            if (!reductionEntryAdjustmentCurrentPeriod_JP)
            {
                assetTrans.IsPriorYear = NoYes::Yes;
            }

            if (assetTrans.TransType == AssetTransType::ReductionEntryReserve_JP
                && assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_Reserve)
            {
                AmountCur amountCur = CurrencyExchangeHelper::curAmount(reductionEntryAdjustment_JP, _assetTrans.CurrencyCode, _assetTrans.TransDate);

                assetTrans.AmountMST -= reductionEntryAdjustment_JP;
                assetTrans.AmountCur -= amountCur;
                reductionEntryAdjustmentCurVoucher_JP = amountCur;
                reductionEntryAdjustmentMSTVoucher_JP = reductionEntryAdjustment_JP;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks for valid conditions to post the asset.
    /// </summary>
    /// <param name="budget">
    ///    A Boolean value that specifies whether there is a budget; optional.
    /// </param>
    /// <param name="_checkNetBookValue">
    ///    A Boolean value that specifies whether you want to check the net book value; optional.
    /// </param>
    /// <returns>
    ///    true if conditions are valid; otherwise, false.
    /// </returns>
    public boolean check(boolean budget = false, boolean _checkNetBookValue = true)
    {
        AssetBook assetBookDerived;
        AssetBookTableDerived assetBookTableDerived;
        AssetSumCalc_Trans assetSumCalc_TransDerived;
        boolean ok = true;
        AssetStatusType assetStatusType;
        AssetSumCalc_Trans assetSumCalc_Trans;
        AmountMST journalAmount;
        AssetDepreciationProfile depreciationProfile;
        AssetLowValueCost_AU lowValueCost;

        // <GCN>
        TransDate depreciationEndDate;
        AssetBookTable assetBookTable;
        #define.ONE_DAY(1)
        // </GCN>
        // <GEECZ>
        AssetTableInterval deprInterval;
        // </GEECZ>
        
        // <GJP>
        AmountMST reductionEntryLimit;
        AmountMST reductionEntryAmount;
        AssetDocumentReductionEntryTable_JP reductionEntry;
        AssetTableInterval assetTableInterval;
        // </GJP>
        
        if (!assetTrans.AssetId)
        {
            AssetPostInstrumentation::logError(AssetInstrumentationConstants::AssetMustBeSpecified);
            return checkFailed("@SYS67760");
        }

        if (!assetTrans.BookId)
        {
            AssetPostInstrumentation::logError(AssetInstrumentationConstants::BookMustBeSpecified);
            return checkFailed("@FixedAssets:FA_MessageError_BookMustBeSpecified");
        }

        if (!assetTrans.TransType)
        {
            AssetPostInstrumentation::logError(AssetInstrumentationConstants::TransactionTypeMustBeSpecified);
            return checkFailed("@SYS67907");
        }

        //Return ok to avoid afterward checking if it is transfer journal.
        if (this.assetTransferType_LT() != LtAssetTransferType::NotTransfer)
        {
            return ok;
        }

        AssetBook assetBook = AssetBook::find(assetTrans.AssetId, assetTrans.BookId);

        if (!assetBook)
        {
            AssetPostInstrumentation::logError(AssetInstrumentationConstants::BookDoesNotExistForFixedAsset);
            return checkFailed(strFmt("@FixedAssets:FA_MessageError_BookDoesNotExistForFixedAsset", assetBook.BookId, assetBook.AssetId));
        }
        
        // Clean the cache before validation
        AssetCacheManager::removeCacheAssetTrans(assetBook.AssetId, assetBook.BookId);

        if (isDepreciationPolicyEnabled_CN)
        {
            assetBookTable = AssetBookTable::find(assetBook.BookId);
        }

        // Make sure that derogatory main value model has corresponding derogatory tax model.
        if (assetBook.AssetDerogatoryModel_FR && !AssetBook::checkExist(assetBook.AssetId, assetBook.AssetDerogatoryModel_FR))
        {
            // %1 derogatory tax model is not properly assigned to %2 asset.
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::DerogatoryBookDoesNotAssign,
                assetBook.RecId);
            ok = checkFailed(strFmt("@SYS110748", assetBook.AssetDerogatoryModel_FR, assetBook.AssetId));
        }

        // valid trans.type
        if (!this.checkTransType(assetTrans.TransType))
        {
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::TransactionTypeIsNotSupported,
                assetBook.RecId);
            ok = checkFailed(strFmt("@SYS51070", assetTrans.TransType));
        }

        if (isIsoJP
            && assetTrans.TransType == AssetTransType::Acquisition
            && assetBook.Status == AssetStatus::NoAcquisition
            && AssetBookTable::find(assetBook.BookId).AcquisitionOnFirstDayCheckType_JP == AssetAcquisitionOnFirstDayCheckType_JP::Error)
        {
            assetTableInterval = assetBook.AssetGroupDepBookMap_JP::assetTableInterval();
            if (assetTrans.TransDate == assetTableInterval.findFirstDayOfYear(assetTrans.TransDate))
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::FANeedsToBePostedInDecember,
                    assetBook.RecId);
                ok = checkFailed(strFmt("@SYP4860931", assetBook.AssetId, "@SYP4860914"));
            }
        }

        assetStatusType = AssetStatusType::construct(assetBook.Status);

        if (!isIsoEE && !assetStatusType.canBePostedTo())
        {
            if (!this.isBookStatusTransTypeAllowedForPosting(assetStatusType, assetTrans.TransType))
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::TransTypeCanNotBePostedToFAWithCurrentStatus,
                    assetBook.RecId);
                return checkFailed(strFmt("@SYS68296", assetBook.Status, assetTrans.TransType));
            }

            if ((assetBook.Status != AssetStatus::Sold
                    && assetBook.Status != AssetStatus::Scrapped
                    && assetBook.Status != AssetStatus::Closed)
                && checkDepreciationParams_IN
                && !assetBook.AssetGroupDepreciation_IN)
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::BookHasBeenSoldOrScrapped,
                    assetBook.RecId);
                ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookHasBeenSoldOrScrapped", assetBook.AssetId, assetBook.BookId));
            }
        }

        // assetBook.depreciation flag set?
        if (!assetBook.Depreciation
            && (assetTrans.TransType == AssetTransType::Depreciation
            || assetTrans.TransType == AssetTransType::DepreciationAdj
            || assetTrans.TransType == AssetTransType::DerogatoryDecrease
            || assetTrans.TransType == AssetTransType::DerogatoryIncrease
            || assetTrans.TransType == AssetTransType::BonusDepreciation
            || assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation))
        {
            if (checkDepreciationParams_IN)
            {
                if (!assetBook.AssetGroupDepreciation_IN)
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::BookHasNotBeenSetupForDepreciation,
                        assetBook.RecId);
                    ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookHasNotBeenSetupForDepreciation", assetBook.AssetId, assetBook.BookId));
                }
            }
            else
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::BookHasNotBeenSetupForDepreciation,
                    assetBook.RecId);
                ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookHasNotBeenSetupForDepreciation", assetBook.AssetId, assetBook.BookId));
            }
        }

        // In Journals we can have one Asset that posted a depreciation while the next is posting the Acquisition.
        // Do we handle this in the Journals code? Has this asset been acquired?
        if (!assetStatusType.isAcquired()
            // <GEEHU>
            && !(assetBookTable.LowCostAsset_HU && assetTrans.TransType == AssetTransType::Depreciation)
            // </GEEHU>
            )
        {
            if (assetTrans.TransType != AssetTransType::Acquisition
                // <GEEU>
                && assetTrans.TransType != AssetTransType::PreAcquisition_CZ
                && assetTrans.TransType != AssetTransType::AccumulatedDepreciation_PL
                // </GEEU>
                // <GJP>
                && assetTrans.TransType != AssetTransType::ReductionEntryReserve_JP
                // </GJP>
                && assetBook.Depreciation
                && !budget
                && !ledgerJournalTrans_Asset.isSplitTransaction())
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::AcquisitionDoesNotExistForBook,
                    assetBook.RecId);
                ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_AcquisitionDoesNotExistForBook", assetBook.AssetId, assetBook.BookId));
            }
        }
        else
        {
            if (!cashDiscTransaction
                && !budget
                && assetTrans.TransType == AssetTransType::Acquisition
                && !AssetParameters::find().MultiAcquisition
                && assetTrans.AmountCur
                && assetStatusType.isAcquired()
                && ledgerJournalTrans_Asset.DocumentType_JP != AssetDocumentType_JP::AssetReductionEntry_DirectOff
                && (AssetPost::getNumberOfAcquisitionTransactions(assetTrans.AssetId, assetTrans.BookId) >= 1))
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::AcquisitionAlreadyExists,
                    assetBook.RecId);
                ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_AcquisitionAlreadyExists", assetBook.AssetId, assetBook.BookId));
            }
        }

        FiscalCalendar fiscalCalendar = FiscalCalendar::find(Ledger::fiscalCalendar(CompanyInfo::current()));
        if (!this.canPostToFiscalPeriod(assetBook, fiscalCalendar))
        {
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::FiscalPeriodIsNotOpen,
                assetBook.RecId);
            ok = checkFailed(strFmt("@SYS95697", date2StrUsr(assetTrans.TransDate, DateFlags::FormatAll), fiscalCalendar.CalendarId));
        }

        if (_checkNetBookValue == true
            && !ledgerJournalTrans
            && assetTrans.TransType != AssetTransType::DisposalSale
            && assetTrans.TransType != AssetTransType::DisposalScrap)
        {
            assetSumCalc_Trans = AssetSumCalc_Trans::newAssetYear(assetBook.AssetId, assetBook.BookId);

            if (assetBook.NegativeNetBookValue == NoYes::No
                && assetSumCalc_Trans.isNegativeNetBookValue(assetTrans.AmountMST))
            {
                AssetPostInstrumentation::logError(
                  AssetInstrumentationConstants::NetBookValueWillBeNegative,
                  assetBook.RecId);
                        
                return checkFailed(strFmt("@FixedAssets:FA_MessageError_PostedNetBookValueWillBeNegative", assetBook.AssetId, assetBook.BookId));
            }

            if (assetBook.ExceedingNetBookValue == NoYes::No
                && assetTrans.TransType != AssetTransType::Acquisition
                && assetTrans.TransType != AssetTransType::AcquisitionAdj
                && assetTrans.TransType != AssetTransType::CapitalReserveTransfer
                // <GEEU>
                && assetTrans.TransType != AssetTransType::PreAcquisition_CZ
                // </GEEU>
                && assetSumCalc_Trans.isNetBookValueHigherThanAcquisition(assetTrans.AmountMST)
                && (!isIsoJP
                    || (isIsoJP && ledgerJournalTrans_Asset.doesAffectNetBookValue_JP() && ledgerJournalTrans_Asset.doesAffectAcquisitionCost_JP())))
            {
                AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::NetBookValueHigherThanAcquisition,
                        assetBook.RecId);
                        
                return checkFailed(strFmt("@FixedAssets:FA_MessageError_NetBookValueHigherThanAcquisition", assetBook.AssetId, assetBook.BookId));
            }
        }

        // only when derived journal has assets, validate those.
        if (ledgerJournalTrans
            && assetTrans.TransType != AssetTransType::DisposalSale
            && assetTrans.TransType != AssetTransType::DisposalScrap)
        {
            AssetBookTableDerivedJournal derivedJournal;

            if (AssetPostDerivedBookInvalidStatusFlight::instance().isEnabled())
            {
                while select assetBookTableDerived
                where assetBookTableDerived.BookId == assetBook.BookId
                    && assetBookTableDerived.AssetTransType == assetTrans.TransType
                join assetBookDerived
                    where assetBookDerived.AssetId == assetBook.AssetId
                        && assetBookDerived.BookId == assetBookTableDerived.BookIdDerived
                join derivedJournal
                    where derivedJournal.RefRecId == ledgerJournalTrans.RecId
                    && derivedJournal.AssetBookId == assetBookDerived.BookId
                {
                    if (assetBookDerived)
                    {
                        if (assetBookDerived.NegativeNetBookValue == NoYes::No)
                        {
                            assetSumCalc_TransDerived = AssetSumCalc_Trans::newAssetYear(assetBook.AssetId, AssetBookTableDerived.BookIdDerived);

                            if (assetSumCalc_TransDerived.isNegativeNetBookValue(assetTrans.AmountMST))
                            {
                                AssetPostInstrumentation::logError(
                                    AssetInstrumentationConstants::NetBookValueWillBeNegative,
                                    assetBook.RecId);
                                return checkFailed(strFmt("@FixedAssets:FA_MessageError_PostedNetBookValueWillBeNegative", assetBook.AssetId, assetBookTableDerived.BookIdDerived));
                            }
                        }

                        AssetStatusType assetBookDerivedStatusType = AssetStatusType::construct(assetBookDerived.Status);
                        if (!assetBookDerivedStatusType.canBePostedTo())
                        {
                            Info(strFmt("@FixedAssets:DerivedBookCannotBePostedTo", assetBook.AssetId, assetBookTableDerived.BookIdDerived, assetBookDerived.Status));
                        }
                    }
                }
            }
            else
            {
                while select assetBookTableDerived
                where assetBookTableDerived.BookId == assetBook.BookId
                    && assetBookTableDerived.AssetTransType == assetTrans.TransType
                join assetBookDerived
                    where assetBookDerived.AssetId == assetBook.AssetId
                        && assetBookDerived.BookId == assetBookTableDerived.BookIdDerived
                        && assetBookDerived.NegativeNetBookValue == NoYes::No
                join derivedJournal
                    where derivedJournal.RefRecId == ledgerJournalTrans.RecId
                    && derivedJournal.AssetBookId == assetBookDerived.BookId
                {
                    if (assetBookDerived)
                    {
                        assetSumCalc_TransDerived = AssetSumCalc_Trans::newAssetYear(assetBook.AssetId, AssetBookTableDerived.BookIdDerived);

                        if (assetSumCalc_TransDerived.isNegativeNetBookValue(assetTrans.AmountMST))
                        {
                            AssetPostInstrumentation::logError(
                            AssetInstrumentationConstants::NetBookValueWillBeNegative,
                            assetBook.RecId);
                            return checkFailed(strFmt("@FixedAssets:FA_MessageError_PostedNetBookValueWillBeNegative", assetBook.AssetId, assetBookTableDerived.BookIdDerived));
                        }
                    }
                }
            }
        }

        // Check for valid disposal
        if (this.checkAssetTransTypeValidForDisposal())
        {
            if (!assetStatusType.canBeDisposed())
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::FAWithCurrentStatusCanNotBeDisposed,
                    assetBook.RecId);
                return checkFailed(strFmt("@SYS68296", assetBook.Status, assetTrans.TransType));
            }
            //Check the scrap run date is not in the month before last depreciation run date
            if (isDepreciationPolicyEnabled_CN)
            {
                if (assetBook.LastDepreciationDate
                    && (assetBook.LastDepreciationDate > endmth(assetTrans.TransDate)))
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::FACanNotBeDisposedOnThatDate,
                        assetBook.RecId);
                    return checkFailed(strFmt("@GLS61003", assetBook.AssetId, assetTrans.TransDate, assetBook.LastDepreciationDate));
                }
                else if (assetBook.acquisitionDate
                        && (assetBook.acquisitionDate > assetTrans.TransDate))
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::FACanNotBeDisposedOnThatDate,
                        assetBook.RecId);
                    return checkFailed(strFmt("@GLS61003", assetBook.AssetId, assetTrans.TransDate, assetBook.acquisitionDate));
                }

                if (assetBookTable.IsDeprecateInDisposal_CN)
                {
                    depreciationEndDate = assetBook.calcDepreciationEndDate_CN();
                    if (assetBook.LastDepreciationDate
                        && assetBook.LastDepreciationDate < depreciationEndDate)
                    {
                        if (depreciationEndDate < assetTrans.TransDate)
                        {
                            checkFailed(strFmt("@GLS61002", assetBook.LastDepreciationDate + #ONE_DAY, depreciationEndDate, assetBook.AssetId));
                        }
                        else
                        {
                            checkFailed(strFmt("@GLS61002", assetBook.LastDepreciationDate + #ONE_DAY, assetBook.getPeriodEnd_CN(assetTrans.TransDate), assetBook.AssetId));
                        }
                    }
                    else
                    {
                        if (!assetBook.LastDepreciationDate
                            && assetBook.DepreciationStartDate
                            && assetBook.DepreciationStartDate < assetTrans.TransDate
                            && assetBook.DepreciationStartDate < depreciationEndDate)
                        {
                            if (depreciationEndDate < assetTrans.TransDate)
                            {
                                checkFailed(strFmt("@GLS61002", assetBook.DepreciationStartDate, depreciationEndDate, assetBook.AssetId));
                            }
                            else
                            {
                                checkFailed(strFmt("@GLS61002", assetBook.DepreciationStartDate, assetBook.getPeriodEnd_CN(assetTrans.TransDate), assetBook.AssetId));
                            }
                        }
                    }
                }
            }
            if (assetTrans.TransDate < assetBook.acquisitionDate)
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::DisposalEarlierThanAcquisition,
                    assetBook.RecId);
                return checkFailed("@SYS328957");
            }
        }

        // check for valid depreciation
        if ((assetTrans.TransType == AssetTransType::Depreciation
            || assetTrans.TransType == AssetTransType::DepreciationAdj
            || assetTrans.TransType == AssetTransType::DerogatoryDecrease
            || assetTrans.TransType == AssetTransType::DerogatoryIncrease
            || assetTrans.TransType == AssetTransType::BonusDepreciation
            )
            // <GEEHU>
            && !assetBookTable.LowCostAsset_HU
            // </GEEHU>
            )

        {
            if (!assetStatusType.canBeDepreciated()
                && !budget
                && !ledgerJournalTrans_Asset.isSplitTransaction())
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::FAWithCurrentStatusCanNotBeDepreciated,
                    assetBook.RecId);
                return checkFailed(strFmt("@SYS68296", assetBook.Status, assetTrans.TransType));
            }

            ok = this.checkLastDepreciationDate(assetBook);
        }

        if (assetTrans.TransType == AssetTransType::BonusDepreciation
            && !ledgerJournalTrans_Asset.isSplitTransaction()
            && AssetTrans::existDepreciationTrans(assetBook.AssetId, assetBook.BookId))
        {
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::SpecialDepreciationIsNotAllowed,
                assetBook.RecId);
            ok = checkFailed(strFmt("@FixedAssets:FA_ErrorMessage_PostingSpecialDepreciationWithDepreciation", assetBook.AssetId, assetBook.BookId));
        }

        if (assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation)
        {
            depreciationProfile = assetBook.depreciationExtProfile();
        }
        else
        {
            depreciationProfile = assetBook.depreciationProfile();
        }

        if (ledgerJournalTrans)
        {
            this.checkPostingLayer(assetBook.BookId);
        }

        // Check the transaction date in an proper range of Fixed Assets's service life
        // And adjustment operation can not happens in the last depreciation date
        if (isDepreciationPolicyEnabled_CN
            && assetBook.DepreciationConvention == AssetDepreciationConvention::None)
        {
            if (conFind([AssetTransType::AcquisitionAdj,
                        AssetTransType::Revaluation,
                        AssetTransType::WriteDownAdj,
                        AssetTransType::WriteUpAdj],
                        assetTrans.TransType)
                && !conFind([AssetDepreciationMethod::Consumption,
                            AssetDepreciationMethod::LowValuePool],
                            depreciationProfile.Method))
            {
                if (assetTrans.TransDate > assetBook.calcDepreciationPreviousMonthEndDate_CN())
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::FACanNotBeAdjusted,
                        assetBook.RecId);
                    ok = checkFailed("@GLS61016");
                }
            }
        }

        // check for consumption quantity if this asset is depreciated by the consumption-method.
        if (depreciationProfile.Method == AssetDepreciationMethod::Consumption
            && assetTrans.ConsumptionQty == 0
            && assetTrans.TransType == AssetTransType::Depreciation)
        {
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::ConsumptionQuantityMustBeSpecified,
                assetBook.RecId);
            ok = checkFailed("@SYS71122");
        }

        // check amount for low value pools
        if (assetTrans.TransType == AssetTransType::Acquisition ||
            assetTrans.TransType == AssetTransType::AcquisitionAdj)
        {
            if (AssetBook::isLowValuePoolBook(assetTrans.BookId))
            {
                if (!ledgerJournalTrans)
                {
                    journalAmount = assetTrans.AmountMST;
                }
                else
                {
                    journalAmount = ledgerJournalTrans.calcBaseAmountMSTIncTaxInCostPrice();
                }

                lowValueCost =  AssetBook::getLowValueCost(assetTrans.BookId);
                if (abs(journalAmount) >= lowValueCost)
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::TransactionCannotBePostedToLowValuePool,
                        assetBook.RecId);
                    ok = checkFailed(
                        strFmt("@FixedAssets:FA_MessageError_TransactionCannotBePostedToLowValuePool", 
                            assetBook.AssetId,
                            assetBook.BookId,
                            lowValueCost));
                }
            }
        }

        // <GJP>
        if (isAssetDocumentEnable
            && assetDocumentEntryRecId
            && (assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_DirectOff
                || assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_Reserve)
            && (assetTrans.TransType == AssetTransType::ReductionEntryReserve_JP
                || assetTrans.TransType == AssetTransType::Acquisition))
        {
            reductionEntry = AssetDocumentReductionEntryTable_JP::findByDocumentEntry(assetDocumentEntryRecId);
            reductionEntryLimit = AssetReductionEntryProfile_JP::findByReductionEntryTableRecId(reductionEntry.RecId).getMaxReductionEntryAmount(assetBook);
            reductionEntryAmount = -assetTrans.AmountMST;

            if (( reductionEntryAmount + reductionEntry.PostAmountMST ) > reductionEntryLimit)
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::ReductionEntryAmountIsOverLimitation,
                    assetBook.RecId);
                ok = checkFailed("@SYS4006138");
            }
        }
        // </GJP>

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBookStatusTransTypeAllowedForPosting</Name>
				<Source><![CDATA[
    private boolean isBookStatusTransTypeAllowedForPosting(AssetStatusType _assetStatusType, AssetTransType _transType)
    {
        boolean isTransTypeAllowedForPosting = true;

        switch (_transType)
        {
            case AssetTransType::Acquisition:
                isTransTypeAllowedForPosting = _assetStatusType.allowAcquisitionTransactions();
                break;
            case AssetTransType::AcquisitionAdj:
                isTransTypeAllowedForPosting = _assetStatusType.allowAcquisitionAdjTransactions();
                break;
            case AssetTransType::Depreciation:
                isTransTypeAllowedForPosting = _assetStatusType.allowDepreciationTransactions();
                break;
            case AssetTransType::DepreciationAdj:
                isTransTypeAllowedForPosting = _assetStatusType.allowDepreciationAdjTransactions();
                break;
            case AssetTransType::DisposalSale:
                isTransTypeAllowedForPosting = _assetStatusType.allowDisposalSaleTransactions();
                break;
            case AssetTransType::DisposalScrap:
                isTransTypeAllowedForPosting = _assetStatusType.allowDisposalScrapTransactions();
                break;
            case AssetTransType::Revaluation:
                isTransTypeAllowedForPosting = _assetStatusType.allowRevaluationTransactions();
                break;
            case AssetTransType::WriteDownAdj:
                isTransTypeAllowedForPosting = _assetStatusType.allowWriteDownAdjTransactions();
                break;
            case AssetTransType::WriteUpAdj:
                isTransTypeAllowedForPosting = _assetStatusType.allowWriteUpAdjTransactions();
                break;
            case AssetTransType::CapitalReserve:
                isTransTypeAllowedForPosting = _assetStatusType.allowProvisionForReverseTransactions();
                break;
            case AssetTransType::CapitalReserveTransfer:
                isTransTypeAllowedForPosting = _assetStatusType.allowTransferFromReverseTransactions();
                break;
            case AssetTransType::ExtraordinaryDepreciation:
                isTransTypeAllowedForPosting = _assetStatusType.allowExtraordinaryDepreciationTransactions();
                break;
            case AssetTransType::BonusDepreciation:
                isTransTypeAllowedForPosting = _assetStatusType.allowSpecialDepreciationAllowanceTransactions();
                break;
            default:
                break;
        }

        return isTransTypeAllowedForPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostToFiscalPeriod</Name>
				<Source><![CDATA[
    private boolean canPostToFiscalPeriod(AssetBook _assetBook, FiscalCalendar _fiscalCalendar)
    {
        AssetBookTable assetBookTable = AssetBookTable::find(_assetBook.BookId);
        
        if (_fiscalCalendar.RecId
            && !(assetBookTable.CurrentOperationsTax == CurrentOperationsTax::None)
            && !(LedgerFiscalCalendar::isDateInOpenPeriod(_fiscalCalendar.RecId, assetTrans.TransDate)))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetTransTypeValidForDisposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current asset transaction type is valid for disposal.
    /// </summary>
    /// <returns>
    /// true if the current asset transaction type is valid for disposal; otherwise, false.
    /// </returns>
    protected boolean checkAssetTransTypeValidForDisposal()
    {
        return (assetTrans.TransType == AssetTransType::DisposalSale || assetTrans.TransType == AssetTransType::DisposalScrap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPostingLayer</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the journal posting layer is equal to the book posting layer.
    /// </summary>
    /// <param name = "_bookId">The asset book id to check.</param>
    /// <returns>True if the journal posting layer is equal to the book posting layer; otherwise, false.</returns>
    protected boolean checkPostingLayer(AssetBookId _bookId)
    {
        if (AssetBookTable::find(_bookId).CurrentOperationsTax != ledgerJournalTrans.ledgerJournalTable().CurrentOperationsTax)
        {
            AssetPostInstrumentation::logError(AssetInstrumentationConstants::DiscrepancyBetweenJournalAndBookPostingLayers);
            return checkFailed(
                strFmt("@FixedAssets:FA_MessageError_DiscrepancyBetweenJournalAndBookPostingLayers",
                        ledgerJournalTrans.parmAccount(),
                        _bookId,
                        ledgerJournalTrans.ledgerJournalTable().CurrentOperationsTax,
                        AssetBookTable::find(_bookId).CurrentOperationsTax));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>check_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for valid conditions to post the asset.
    /// </summary>
    /// <param name="budget">
    /// A boolean value whether a budget is associated with the asset.
    /// </param>
    /// <param name="_checkNetBookValue">
    /// A boolean value whether the asset's value should be checked with the netbook value.
    /// </param>
    /// <returns>
    /// Returns true if asset can be posted.
    /// </returns>
    boolean check_IN(boolean budget = false, boolean _checkNetBookValue = true)
    {
        AssetBook assetBook;
        boolean ok = true;
        AssetStatusType assetStatusType;
        boolean isNotAcquired = false;
        boolean isAcquired = false;
        LedgerJournalTrans_Asset assetLedgerJournalTrans;
        RecId calendarRecId;

        if (!assetGroupInformation.AssetGroup)
        {
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::GroupMustBeSpecified,
                assetBook.RecId);
            return checkFailed("@GLS5979");
        }

        if (!assetGroupInformation.TransType)
        {
            AssetPostInstrumentation::logError(
                AssetInstrumentationConstants::TransactionTypeMustBeSpecified,
                assetBook.RecId);
            return checkFailed("@SYS67907");
        }

        // has this asset been acquired?

        ttsbegin;
        while select forupdate assetBook
            where assetBook.AssetGroup == assetGroupInformation.AssetGroup
               && assetBook.BookId == assetGroupTrans.BookId
               && assetBook.AssetGroupDepreciation_IN == NoYes::Yes
        {
            assetBook.LastDepreciationDate = assetGroupInformation.TransDate;
            assetBook.update();
        }
        ttscommit;
        while select Status from assetBook
            where assetBook.AssetGroup == assetGroupInformation.AssetGroup
               && assetBook.BookId == assetGroupTrans.BookId
        {
            assetStatusType = AssetStatusType::construct(assetBook.Status);
            if (!assetStatusType.canBePostedTo())
            {
                if (!(assetBook.Status == AssetStatus::Sold || assetBook.Status == AssetStatus::Scrapped))
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::BookHasBeenSoldOrScrapped,
                        assetBook.RecId);
                    ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_BookHasBeenSoldOrScrapped", assetBook.AssetGroup, assetBook.BookId));
                }
            }
            if (assetBook.Status == AssetStatus::NoAcquisition)
            {
                isNotAcquired = true;
            }
            else
            {
                isAcquired = true;
            }
        }

        if (isNotAcquired == true && isAcquired == false)
        {
            if (!assetStatusType.isAcquired())
            {
                if (assetGroupInformation.TransType != AssetTransType::Acquisition)
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::AcquisitionDoesNotExistForBook,
                        assetBook.RecId);
                    ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_AcquisitionDoesNotExistForBook", assetGroupInformation.AssetGroup, assetGroupTrans.BookId));
                }
            }
        }
        else
        {
            if (!assetStatusType.isAcquired())
            {
                if (assetGroupInformation.TransType != AssetTransType::Acquisition && assetBook.Depreciation && !budget )
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::AcquisitionDoesNotExistForBook,
                        assetBook.RecId);
                    ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_AcquisitionDoesNotExistForBook", assetGroupInformation.AssetGroup, assetGroupTrans.BookId));
                }
            }
            else
            {
                if (!cashDiscTransaction && !AssetParameters::find().MultiAcquisition &&
                    assetTrans.TransType == AssetTransType::Acquisition && assetTrans.AmountCur > 0 &&
                    !budget)
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::AcquisitionAlreadyExists,
                        assetBook.RecId);
                    ok = checkFailed(strFmt("@FixedAssets:FA_MessageError_AcquisitionAlreadyExists", assetGroupTrans.AssetId, assetGroupTrans.BookId));
                }
            }
        }

        // if asset calendar, make sure the transaction date exists in an open period
        while select BookId from assetBook
            where assetBook.AssetGroup == assetGroupInformation.AssetGroup
               && assetBook.BookId == assetGroupTrans.BookId
        {
            calendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());

            // check that calendar exists on depreciation book
            if (calendarRecId)
            {
                if (!LedgerFiscalCalendar::isDateInOpenPeriod(calendarRecId, assetGroupInformation.TransDate))
                {
                    AssetPostInstrumentation::logError(
                        AssetInstrumentationConstants::FiscalPeriodIsNotOpen,
                        assetBook.RecId);
                    ok = checkFailed(strFmt("@SYS95697", assetGroupInformation.TransDate, FiscalCalendar::find(calendarRecId).CalendarId));
                }
            }
        }

        if (assetGroupInformation.TransType == AssetTransType::Depreciation ||
            assetGroupInformation.TransType == AssetTransType::DepreciationAdj)
        {
            while select Status from assetBook
                where assetBook.AssetGroup == assetGroupInformation.AssetGroup
                   && assetBook.BookId == assetGroupTrans.BookId
            {
                if (isNotAcquired == true && isAcquired == false)
                {
                    assetStatusType = AssetStatusType::construct(assetBook.Status);
                    if (!assetStatusType.canBeDepreciated())
                    {
                        if (!(assetBook.Status == AssetStatus::Sold || assetBook.Status == AssetStatus::Scrapped))
                        {
                            AssetPostInstrumentation::logError(
                                AssetInstrumentationConstants::DisposedFACanNotBeDepreciated,
                                assetBook.RecId);
                            return checkFailed(strFmt("@SYS68296", assetBook.Status, assetGroupInformation.TransType));
                        }
                    }
                }
            }
        }

        // Check for currentOperationsTax
        assetLedgerJournalTrans = LedgerJournalTrans_Asset::find(ledgerJournalTrans.RecId);

        if (assetLedgerJournalTrans)
        {
            select BookId from assetBook
                where assetBook.BookId == assetLedgerJournalTrans.BookId;
            if (AssetBookTable::find(assetBook.BookId).CurrentOperationsTax != assetLedgerJournalTrans.ledgerJournalTable().CurrentOperationsTax)
            {
                AssetPostInstrumentation::logError(
                    AssetInstrumentationConstants::DiscrepancyBetweenJournalAndBookPostingLayers,
                    assetBook.RecId);
                return checkFailed(
                    strFmt("@FixedAssets:FA_MessageError_DiscrepancyBetweenJournalAndBookPostingLayers",
                        ledgerJournalTrans.parmAccount(),
                        assetLedgerJournalTrans.BookId,
                        assetLedgerJournalTrans.ledgerJournalTable().CurrentOperationsTax,
                        AssetBookTable::find(assetLedgerJournalTrans.BookId).CurrentOperationsTax));
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the transaction type is supported for posting.
    /// </summary>
    /// <param name="_transType">
    /// The transaction type to check.
    /// </param>
    /// <returns>
    /// true if the transaction type is supported; otherwise, false.
    /// </returns>
    protected boolean checkTransType(AssetTransType _transType)
    {
        boolean ret = true;

        if (isDepreciationIncomeTaxActEnable_IN
            && _transType != AssetTransType::None
            && _transType != AssetTransType::Acquisition
            && _transType != AssetTransType::AcquisitionAdj
            && _transType != AssetTransType::Depreciation
            && _transType != AssetTransType::DepreciationAdj
            && _transType != AssetTransType::Revaluation
            && _transType != AssetTransType::WriteUpAdj
            && _transType != AssetTransType::WriteDownAdj
            && _transType != AssetTransType::DisposalSale
            && _transType != AssetTransType::DisposalScrap
            && _transType != AssetTransType::NetBookValue
            && _transType != AssetTransType::ProfitLoss
            && _transType != AssetTransType::AcqPriorYears
            && _transType != AssetTransType::AcqThisYear
            && _transType != AssetTransType::AcqAdjPriorYears
            && _transType != AssetTransType::AcqAdjThisYear
            && _transType != AssetTransType::DepPriorYears
            && _transType != AssetTransType::DepThisYear
            && _transType != AssetTransType::DepAdjPriorYears
            && _transType != AssetTransType::DepAdjThisYear
            && _transType != AssetTransType::RevaluePriorYears
            && _transType != AssetTransType::RevalueThisYear
            && _transType != AssetTransType::WriteUpAdjPriorYears
            && _transType != AssetTransType::WriteUpAdjThisYear
            && _transType != AssetTransType::WriteDownAdjPriorYears
            && _transType != AssetTransType::WriteDownAdjThisYear
            && _transType != AssetTransType::CapitalReserve
            && _transType != AssetTransType::CapitalReserveTransfer
            && _transType != AssetTransType::ExtraordinaryDepreciation
            && _transType != AssetTransType::DerogatoryDecrease
            && _transType != AssetTransType::DerogatoryIncrease
            && assetTrans.TransType != AssetTransType::BonusDepreciation)
        {
            ret = false;
        }

        // <GJP>
        if (isAssetDocumentEnable)
        {
            ret = AssetDocumentUtility_JP::isValidAssetTransType(assetTrans.TransType, assetDocumentType_JP, ret);
        }
        // </GJP>

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssetTransForPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>AssetTrans</c> record for the posting process.
    /// </summary>
    /// <param name = "_assetBook">
    /// The <c>AssetBook</c> record being updated during the posting process.
    /// </param>
    /// <returns>
    /// The <c>AssetStatusType</c> class instance of the specified asset book's depreciating ancestor.
    /// </returns>
    /// <remarks>
    /// This is a support method for post().
    /// </remarks>
    protected AssetStatusType createAssetTransForPost(AssetBook _assetBook)
    {
        AssetTable tmpAssetTable;
        AssetBook tmpAssetBook;

        if (!_assetBook.Depreciation &&
            (assetTrans.TransType == AssetTransType::Depreciation               ||
             assetTrans.TransType == AssetTransType::DepreciationAdj            ||
             assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation))
        {
            // <GIN>
            if (checkDepreciationParams_IN)
            {
                if (!_assetBook.AssetGroupDepreciation_IN)
                {
                    tmpAssetTable = AssetTable::depreciatingAncestor(_assetBook);
                    if (!tmpAssetTable)
                    {
                        throw error(strFmt("@SYS67913",assetTrans.AssetId));
                    }

                    tmpAssetBook = AssetBook::find(tmpAssetTable.AssetId, assetTrans.BookId);

                    if (!tmpAssetBook)
                    {
                        throw error(strFmt("@SYS67913",assetTrans.AssetId));
                    }

                    assetTrans.AssetId = tmpAssetBook.AssetId;
                    assetTrans.TransType = AssetTransType::AcquisitionAdj;
                }
            }
            else
            {
                // </GIN>
                // We have to post on a father which can be depreciated
                tmpAssetTable = AssetTable::depreciatingAncestor(_assetBook);
                if (!tmpAssetTable)
                {
                    throw error(strFmt("@SYS67913",assetTrans.AssetId));
                }

                tmpAssetBook = AssetBook::find(tmpAssetTable.AssetId, assetTrans.BookId);

                if (!tmpAssetBook)
                {
                    throw error(strFmt("@SYS67913",assetTrans.AssetId));
                }

                assetTrans.AssetId = tmpAssetBook.AssetId;
                assetTrans.TransType = AssetTransType::AcquisitionAdj;
                // <GIN>
            }
            // </GIN>
        }

        AssetStatusType assetStatusType = AssetStatusType::construct(tmpAssetBook.Status);

        if (this.checkAssetTransTypeValidForDisposal())
        {
            // <GIN>
            AssetPostDisposal_IN assetPostGroupDisposal;
            AssetSumCalc_Trans_IN assetSumAllYears;
            // </GIN>

            AssetPostDisposal assetPostDisposal = this.createAssetPostDisposal(_assetBook, isDepreciationIncomeTaxActEnable_IN);

            if (isDepreciationIncomeTaxActEnable_IN)
            {
                assetPostGroupDisposal = new AssetPostDisposal_IN(ledgerVoucher, assetGroupTrans);
                assetSumAllYears = AssetSumCalc_Trans_IN::newAssetYear(assetGroupInformation.AssetGroup, assetGroupTrans.BookId, assetGroupInformation.TransDate, AssetYear::All);
            }

            if (assetStatusType.updateLedger() && _assetBook.assetBookTable().postToGeneralLedger())
            {
                assetPostDisposal.post();

                if (isDepreciationIncomeTaxActEnable_IN
                    && _assetBook.AssetGroupDepreciation_IN
                    && ((assetGroupInformation.AmountMst + assetSumAllYears.netBookValue()) <= 0))
                {
                    assetPostGroupDisposal.post();
                }
            }

            assetPostDisposal.createAssetTrans(exchRate, exchRateSecond);
            if (isAssemblingEnabled_JP)
            {
                disposalOffsetAccount = assetPostDisposal.getNBVOffsetAccount_JP();
            }

            if (isDepreciationIncomeTaxActEnable_IN
                && ((assetGroupInformation.AmountMst + assetSumAllYears.netBookValue()) <= 0))
            {
                assetPostGroupDisposal.createAssetTrans(exchRate, exchRateSecond);
            }
        }

        //Determine low value pool type (if not already specified) for assets books using low value pool depreciation
        if (!assetTrans.LowValuePoolType_AU && _assetBook.depreciationMethod() == AssetDepreciationMethod::LowValuePool)
        {
            switch (assetTrans.TransType)
            {
                case AssetTransType::Acquisition:
                    assetTrans.LowValuePoolType_AU = AssetLowValuePoolType_AU::LowCostAsset;
                    break;
                case AssetTransType::AcquisitionAdj:
                    assetTrans.LowValuePoolType_AU = AssetLowValuePoolType_AU::SecondElementCost;
                    break;
            }
        }

        if (assetStatusType.updateLedger())
        {
            if ((needToUpdateLedger
                && assetTrans.TransType != AssetTransType::Acquisition
                && assetTrans.TransType != AssetTransType::AcquisitionAdj)
                || (vendInvoiceId && AssetBookTable::find(assetTrans.BookId).CurrentOperationsTax != CurrentOperationsTax::None))
            {
                assetTrans.LedgerDimension = this.getMergedLedgerDimensionForDefaultAccount();
            }
        }

        assetTrans.insert();

        // Keep the RecId for the main book of the AssetTrans record created during posting.
        // The process for derived books AssetTrans creation reuses the AssetTrans buffer.
        if (mainBookAssetTransRecId == 0)
        {
            mainBookAssetTransRecId = assetTrans.RecId;
        }

        if (isDepreciationIncomeTaxActEnable_IN
            && _assetBook.AssetGroupDepreciation_IN == NoYes::Yes)
        {
            assetGroupInformation.insert();
            assetGroupTrans.AssetGroupInformation = assetGroupInformation.RecId;
            assetGroupTrans.insert();
        }

        return assetStatusType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssetPostDisposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>AssetPostDisposal</c> instance for posting.
    /// </summary>
    /// <param name = "_assetBook">
    /// The <c>AssetBook</c> record being updated during the posting process.
    /// </param>
    /// <param name = "_depreciationIncomeTaxAct">
    /// The value of the income tax act depreciation parameter.
    /// </param>
    /// <returns>
    /// An <c>AssetPostDisposal</c> class instance.
    /// </returns>
    protected AssetPostDisposal createAssetPostDisposal(AssetBook _assetBook, boolean _depreciationIncomeTaxAct)
    {
        AssetPostDisposal assetPostDisposal;

        if (!isIsoPL)
        {
            assetPostDisposal = new AssetPostDisposal(ledgerVoucher, assetTrans);
            // <GEEEE>
            // <GEELT>
            assetPostDisposal.parmIsCreditNote(isCreditNote);
            // </GEELT>
            // </GEEEE>
        }
        else
        {
            assetPostDisposal = new AssetPostDisposal_Pl(ledgerVoucher, assetTrans);
            assetPostDisposal.parmAssetSaleFactor(assetSaleFactor);
        }


        // <GIN>
        if (_depreciationIncomeTaxAct)
        {
            assetPostDisposal.parmAssetGroupTrans_IN(assetGroupTrans);
        }
        // </GIN>

        assetPostDisposal.parmLedgerJournalTransRecId(ledgerJournalTrans.RecId);
        assetPostDisposal.parmIsDerivedBookPosting(isDerivedBookPosting);

        return assetPostDisposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDepreciationAdjustment</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is used to create a new transaction line with respect to adjustment transaction.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// Constructing a buffer of AssetJournal based on _ledgerJournalTrans.
    /// </param>
    /// <param name="_assetBook">
    /// Passing _assetBook table buffer to calculate adjustment value.
    /// </param>
    /// <param name="_adjustedDepreciationAmount">
    /// The amount for which the depreciation adjustment is created.
    /// </param>
    /// <param name="_isPriorYear">
    ///    If this is for prior year; optional.
    /// </param>
    /// <param name="_assetTransTypeJournal">
    ///    Transaction type; optional.
    /// </param>
    /// <returns>
    /// Returns true if the depreciation adjustment is created, otherwise false.
    /// </returns>
    private boolean createDepreciationAdjustment(
        LedgerJournalTrans _ledgerJournalTrans,
        AssetBook _assetBook,
        AssetAmount _adjustedDepreciationAmount,
        AssetAmountReportingCurrency _adjustedDepreciationAmountReportingCurrency,
        boolean _isPriorYear = false,
        AssetTransTypeJournal _assetTransTypeJournal =  AssetTransTypeJournal::DepreciationAdj)
    {
        AssetTrans assetTransNew;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerJournalTrans ledgerJournalTransLocal;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        boolean isPrimaryAdjustedDepreciationCreated;
        AssetAmount primaryAdjustedDepreciation;
        AssetAmountReportingCurrency primaryAdjustedDepreciationReportingCurrency;
        TransDate exchangeRateDate;

        if (_adjustedDepreciationAmount)
        {
            AssetBookTable assetBookTable = _assetBook.assetBookTable();

            AssetJournal assetJournal = new AssetJournal(_ledgerJournalTrans.JournalNum , _assetTransTypeJournal);
            primaryAdjustedDepreciation = _adjustedDepreciationAmount * -1;
            primaryAdjustedDepreciationReportingCurrency = _adjustedDepreciationAmountReportingCurrency * -1;
            assetJournal.parmIsCatchUpDepreciation(true);
            assetJournal.parmIsDepreciationAdjustment(true);
            assetJournal.parmIsOneVoucher(true);
            this.setVoucherOnAssetJournal(assetJournal, _ledgerJournalTrans);

            ReasonTableRef reasonTableRef = reasonTableRef::find(_ledgerJournalTrans.ReasonRefRecID);
            assetJournal.parmReasonCode(reasonTableRef.Reason);
            
            // <GJP>
            if (isIsoJP)
            {
                assetJournal.createTrans(
                    primaryAdjustedDepreciation,
                    _assetBook,
                    _ledgerJournalTrans.TransDate,
                    '',
                    0,
                    0,
                    false,
                    0,
                    0,
                    dateNull(),
                    false,
                    _isPriorYear);
            }
            else
            {
                // </GJP>
                // If the True Depreciation is calculated, and the voucher is generated for derived value model,
                // journal lines are not needed for this value model.
                assetJournal.parmReportingCurrencyAmount(primaryAdjustedDepreciationReportingCurrency);

                if (_assetBook.IsTrueUpDepreciation
                    && AssetBookTableDerivedJournal::exist(_ledgerJournalTrans.RecId, _assetBook.BookId)
                    && _ledgerJournalTrans.ledgerJournalTable().CurrentOperationsTax != assetBookTable.CurrentOperationsTax)
                {
                    assetJournal.populateLedgerJournalTrans(primaryAdjustedDepreciation,  _assetBook, _ledgerJournalTrans.TransDate);
                }
                else
                {
                    assetJournal.createTrans(primaryAdjustedDepreciation,  _assetBook, _ledgerJournalTrans.TransDate);
                }
                // <GJP>
            }
            // </GJP>

            assetTransNew.data(assetTrans);
            assetTransNew.TransType = AssetPost::assetTransTypeJournal2AssetTransType(_assetTransTypeJournal);
            assetTransNew.AmountMST = primaryAdjustedDepreciation;
            assetTransNew.AmountCur = primaryAdjustedDepreciation;
            assetTransNew.ReportingCurrencyAmount = primaryAdjustedDepreciationReportingCurrency;
            
            if (!isDerivedBookPosting)
            {
                // Store depreciation adjustment voucher from the parent asset book posting so that it can be used during derived books posting
                this.parmDepreciationAdjVoucher(assetJournal.parmVoucher());
            }

            assetTransNew.Voucher = assetJournal.parmVoucher();
            assetTransNew.CurrencyCode = Ledger::accountingCurrency();

            if (_assetTransTypeJournal == AssetTransTypeJournal::DerogatoryIncrease || _assetTransTypeJournal == AssetTransTypeJournal::DerogatoryDecrease)
            {
                assetTransNew.BookId = _assetBook.BookId;
            }

            if (isIsoJP)
            {
                assetTransNew.IsPriorYear = _isPriorYear;
            }

            if (assetBookTable.postToGeneralLedger() && !_assetBook.IsDerogatoryBook_FR)
            {
                ledgerJournalTransLocal = assetJournal.parmLedgerJournalTrans();
                ledgerDimensionDefaultAccount = assetTable.assetLedgerDimension(
                    ledgerJournalTransLocal.PostingProfile,
                    AssetPost::assetTransTypeJournal2AssetTransType(_assetTransTypeJournal),
                    _assetBook.BookId);
                ledgerDimensionMerged = this.createLedgerDimension(ledgerDimensionDefaultAccount);

                assetTransNew.LedgerDimension = ledgerDimensionMerged;
            }
            
            assetTransNew.FinTag = finTag;
            assetTransNew.insert();

            if (isOneVoucherFeatureEnabled)
            {
                Voucher previousDepreciationAdjustmentVoucher = ledgerJournalTrans.Voucher ? ledgerJournalTrans.Voucher : inventJournalTransVoucher;
                if (assetReversalRelatedVoucherManager)
                {
                    assetReversalRelatedVoucherManager.addReversalRelatedVouchers(previousDepreciationAdjustmentVoucher, assetTransNew.Voucher, assetTransNew.TransDate);
                }

                AssetInstrumentationLogger::createLogger(AssetInstrumentationConstants::AssetOneVoucherFeatureLog)
                    .logOneVoucherScenario(
                        AssetInstrumentationConstants::TrueUpDepreciation,
                        isOneVoucherFeatureEnabled);
            }

            if (assetBookTable.postToGeneralLedger() && !_assetBook.IsDerogatoryBook_FR)
            {
                // Creating ledger entries for the depreciation adjustment transactions
                LedgerVoucherObject originalLedgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(assetJournal.parmVoucher());

                if (isOneVoucherFeatureEnabled)
                {
                    if (ledgerVoucherObject == null)
                    {
                        ledgerVoucherObject = LedgerVoucherObject::newReference(
                            assetJournal.parmVoucher(),
                            originalLedgerVoucherObject.parmAccountingDate(),
                            originalLedgerVoucherObject.parmSysModule());

                        ledgerVoucherObject.parmPostingLayer(originalLedgerVoucherObject.parmPostingLayer());
                        ledgerVoucherObject.parmDocumentDate(originalLedgerVoucherObject.parmDocumentDate());
                        ledgerVoucherObject.parmDocumentNumber(originalLedgerVoucherObject.parmDocumentNumber());
                        ledgerVoucherObject.parmJournalCategory(originalLedgerVoucherObject.parmJournalCategory());
                        ledgerVoucher.addVoucher(ledgerVoucherObject);
                    }
                }
                else
                {
                    ledgerVoucherObject = originalLedgerVoucherObject;
                }

                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::current(),
                ledgerJournalTransLocal.TransDate);
                exchangeRateHelper.parmExchangeRate1(exchRate);
                exchangeRateHelper.parmExchangeRate2(exchRateSecond);
                exchangeRateHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);
                exchangeRateHelper.parmReportingExchangeRate2(reportingCurrencyExchRateSecond);

                // Creating ledgerVoucherTransObject for Fixed assets, credit/Debit
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                ledgerVoucherObject,
                (ledgerJournalTransLocal.amount() > 0 ? any2Enum(LedgerPostingType::FixedAssetsDebit) : any2Enum(LedgerPostingType::FixedAssetsCredit)),
                ledgerDimensionMerged,
                assetTransNew.CurrencyCode,
                ledgerJournalTransLocal.AmountCurDebit > 0 ? ledgerJournalTransLocal.AmountCurDebit : -ledgerJournalTransLocal.AmountCurCredit,
                exchangeRateHelper);

                exchangeRateDate = _assetBook.exchangeRateDate();
                ledgerVoucherTransObject.parmHistoricalExchangeRateDate(exchangeRateDate? exchangeRateDate : ledgerJournalTransLocal.TransDate);
                ledgerVoucherTransObject.parmText(assetTransNew.Txt);
                ledgerVoucherTransObject.parmFinTag(assetTransNew.FinTag);
                ledgerVoucherTransObject.parmReasonRefRecID(ledgerJournalTransLocal.ReasonRefRecID);
                this.addTransIntoLedgerVoucherObject(ledgerVoucherTransObject, ledgerVoucherObject);

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerJournalTransLocal.OffsetLedgerDimension, assetTransNew.DefaultDimension);

                // Creating ledgerVoucherTransObject for Ledger journal
                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                ledgerVoucherObject,
                LedgerPostingType::LedgerJournal,
                ledgerDimensionMerged,
                assetTransNew.CurrencyCode,
                ledgerJournalTransLocal.AmountCurDebit > 0 ? -ledgerJournalTransLocal.AmountCurDebit : ledgerJournalTransLocal.AmountCurCredit,
                exchangeRateHelper);
                ledgerVoucherTransObject.parmReasonRefRecID(ledgerJournalTransLocal.ReasonRefRecID);
                ledgerVoucherTransObject.parmFinTag(ledgerJournalTrans.FinTag);
                ledgerVoucherTransObject.parmPaymentReference(LedgerJournalTrans.PaymReference);
                this.addTransIntoLedgerVoucherObject(ledgerVoucherTransObject, ledgerVoucherObject);

                isPrimaryAdjustedDepreciationCreated = true;
            }
        }

        return isPrimaryAdjustedDepreciationCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDerogatoryAdjustment_FR</Name>
				<Source><![CDATA[
    private void createDerogatoryAdjustment_FR(AssetBook _assetBook)
    {
        AssetBook assetBookBase;
        select firstonly assetBookBase
            where assetBookBase.AssetId == _assetBook.AssetId
                && assetBookBase.AssetDerogatoryModel_FR == _assetBook.BookId;

        if (assetBookBase.IsTrueUpDepreciation == NoYes::Yes)
        {
            AssetAmount baseDepreciationAdjustment = -AssetTrans::amountMSTPerDateTransTypes(
                    assetBookBase.AssetId,
                    assetBookBase.BookId,
                    [AssetTransType::DepreciationAdj],
                    assetTrans.TransDate,
                    assetTrans.TransDate);

            if (baseDepreciationAdjustment != 0)
            {
                AssetAmount baseDepreciationAdjustmentReportingCurrency = -AssetTrans::amountReportingCurrencyPerDateTransTypes(
                    assetBookBase.AssetId,
                    assetBookBase.BookId,
                    [AssetTransType::DepreciationAdj],
                    assetTrans.TransDate,
                    assetTrans.TransDate);

                container priorYearAmount = AssetBook::calculateCatchUpDepreciation(_assetBook, ledgerJournalTrans.TransDate);
                AssetAmount adjustedDerogatoryDepreciationAmount = conPeek(priorYearAmount, 1) + conPeek(priorYearAmount, 2);

                if (adjustedDerogatoryDepreciationAmount != 0)
                {
                    AssetAmountReportingCurrency adjustedDerogatoryDepreciationAmountReportingCurrency;

                    if (baseDepreciationAdjustmentReportingCurrency)
                    {
                        container priorYearAmountReportingCurrency = AssetBook::calculateCatchupDepreciationPerCurrency(_assetBook, assetTrans.TransDate, true);
                        adjustedDerogatoryDepreciationAmountReportingCurrency = conPeek(priorYearAmountReportingCurrency, 1)  + conPeek(priorYearAmountReportingCurrency, 2);
                    }

                    AssetTransType assetTransType;
                    AssetTransTypeJournal assetTransTypeJournal;
                    AssetAmount derogatoryAmount = adjustedDerogatoryDepreciationAmount - baseDepreciationAdjustment;

                    if (derogatoryAmount > 0)
                    {
                        [assetTransType, assetTransTypeJournal] = [AssetTransType::DerogatoryIncrease, AssetTransTypeJournal::DerogatoryIncrease];
                    }
                    else
                    {
                        [assetTransType, assetTransTypeJournal] = [AssetTransType::DerogatoryDecrease, AssetTransTypeJournal::DerogatoryDecrease];
                    }

                    this.createDepreciationAdjustment(
                        ledgerJournalTrans,
                        assetBookBase,
                        derogatoryAmount,
                        adjustedDerogatoryDepreciationAmountReportingCurrency - baseDepreciationAdjustmentReportingCurrency,
                        false,
                        derogatoryAmount > 0 ? AssetTransTypeJournal::DerogatoryIncrease : AssetTransTypeJournal::DerogatoryDecrease);

                    this.createDepreciationAdjustment(
                        ledgerJournalTrans,
                        _assetBook,
                        adjustedDerogatoryDepreciationAmount,
                        adjustedDerogatoryDepreciationAmountReportingCurrency);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLedgerDimension</Name>
				<Source><![CDATA[
    private void updateLedgerDimension(AssetTrans _assetTrans, LedgerDimensionAccount _ledgerDimension)
    {
        if (_assetTrans.RecId)
        {
            _assetTrans.selectForUpdate(true);
            _assetTrans.LedgerDimension = _ledgerDimension;
            _assetTrans.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDepreciationAdjustmentNonGL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new transaction line with respect to an adjustment transaction.
    /// </summary>
    /// <param name="_assetBook">
    /// Passing <c>AssetBook</c> table buffer to calculate adjustment value.
    /// </param>
    /// <param name="_primaryAdjustedDepreciation">
    /// The amount for which the depreciation adjument will be created.
    /// </param>
    /// <param name="_isPriorYear">
    ///    If this is for prior year; optional.
    /// </param>
    /// <returns>
    /// Returns true if the depreciation adjustment is created, otherwise false.
    /// </returns>
    private boolean createDepreciationAdjustmentNonGL(
        AssetBook _assetBook,
        AssetAmount _primaryAdjustedDepreciation,
        AssetAmountReportingCurrency _primaryAdjustedDepreciationReportingCurrency,
        boolean _isPriorYear = false)
    {
        boolean isPrimaryAdjustedDepreciationCreated;
        AssetTrans assetTransNew;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherObject originalLedgerVoucherObject;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        TransDate exchangeRateDate;

        if (_primaryAdjustedDepreciation)
        {
            assetTransNew.data(assetTrans);
            assetTransNew.TransType = AssetTransType::DepreciationAdj;
            // Depreciation amounts should be negative amounts.
            assetTransNew.AmountMST = -_primaryAdjustedDepreciation;
            assetTransNew.AmountCur = -_primaryAdjustedDepreciation;
            assetTransNew.ReportingCurrencyAmount = -_primaryAdjustedDepreciationReportingCurrency;

            // <GJP>
            if (isIsoJP)
            {
                assetTransNew.IsPriorYear = _isPriorYear;
            }
            // </GJP>
            assetTransNew.insert();

            AssetBookTable assetBookTable = _assetBook.assetBookTable();

            if (assetBookTable.postToGeneralLedger())
            {
                ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

                CurrentOperationsTax postingLayerForDepreciationAdjustment = assetBookTable.CurrentOperationsTax;

                if (ledgerVoucherObject.parmPostingLayer() != postingLayerForDepreciationAdjustment)
                {
                    // save the original
                    originalLedgerVoucherObject = ledgerVoucherObject;

                    // search for a posting voucher for the posting layer
                    ledgerVoucherObject = ledgerVoucher.findReference(
                        originalLedgerVoucherObject.parmSubledgerVoucher(),
                        originalLedgerVoucherObject.parmAccountingDate(),
                        postingLayerForDepreciationAdjustment);

                    if (ledgerVoucherObject == null)
                    {
                        // create a new posting voucher for the posting layer
                        ledgerVoucherObject = LedgerVoucherObject::newReference(
                        originalLedgerVoucherObject.parmSubledgerVoucher(),
                        originalLedgerVoucherObject.parmAccountingDate(),
                        originalLedgerVoucherObject.parmSysModule());

                        ledgerVoucherObject.parmPostingLayer(postingLayerForDepreciationAdjustment);
                        ledgerVoucher.addVoucher(ledgerVoucherObject);
                    }
                }

                ledgerVoucherObject.parmVoucherCheck(false);

                exchangeRateHelper = this.getExchangeRateHelper(ledgerVoucherObject);

                ledgerDimensionDefaultAccount = AssetLedgerAccounts::assetLedgerDimension(
                                                assetTable.AssetId,
                                                assetTransNew.BookId,
                                                assetTransNew.TransType,
                                                assetTransNew.PostingProfile);

                ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, assetTransNew.DefaultDimension);

                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                        ledgerVoucherObject,
                                        ((assetTransNew.AmountCur) > 0 ? any2Enum(LedgerPostingType::FixedAssetsDebit) : any2Enum(LedgerPostingType::FixedAssetsCredit)),
                                        ledgerDimensionMerged,
                                        assetTransNew.CurrencyCode,
                                        assetTransNew.AmountCur,
                                        exchangeRateHelper);
                ledgerVoucherTransObject.parmSourceTableId(assetTransNew.TableId);
                ledgerVoucherTransObject.parmSourceRecId(assetTransNew.RecId);
                ledgerVoucherTransObject.parmReasonRefRecID(assetTransNew.ReasonRefRecId);
                exchangeRateDate = _assetBook.exchangeRateDate();
                ledgerVoucherTransObject.parmHistoricalExchangeRateDate(exchangeRateDate? exchangeRateDate : assetTransNew.TransDate);
                ledgerVoucherTransObject.parmText(assetTransNew.Txt);
                ledgerVoucher.addTrans(ledgerVoucherTransObject);

                if (originalLedgerVoucherObject != null)
                {
                    // change back to the original posting voucher
                    ledgerVoucherObject = ledgerVoucher.findReference(
                        originalLedgerVoucherObject.parmSubledgerVoucher(),
                        originalLedgerVoucherObject.parmAccountingDate(),
                        originalLedgerVoucherObject.parmPostingLayer());

                    Debug::assert(ledgerVoucherObject != null);
                }

                this.postToFixedAssetOffset(assetTransNew, false);

                isPrimaryAdjustedDepreciationCreated = true;
            }
        }
        return isPrimaryAdjustedDepreciationCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createInventorySoldTransaction</Name>
				<Source><![CDATA[
    protected void createInventorySoldTransaction()
    {
        purchLineForInventSoldTrans = PurchLine::findRecId(assetTable.PurchLineRecId);

        if (!this.shouldCreateInventorySoldTransaction())
        {
            return;
        }

        InventTransOriginId inventTransOriginId = InventTransOriginPurchLine::findInventTransOriginId(
                                                        purchLineForInventSoldTrans.DataAreaId,
                                                        purchLineForInventSoldTrans.InventTransId);

        if (!this.haveSoldTransactions(inventTransOriginId))
        {
            this.doSummarization(ledgerVoucher);
            InventMov_Purch movement = InventMov_Purch::newFromPurchLine(purchLineForInventSoldTrans);

            VendInvoiceInfoLine vendInvoiceInfoLine = this.getVendInvoiceInfoLine(assetTable.PurchLineRecId, ledgerVoucher.lastVoucher());
            
            VendInvoiceInfoTable vendInvoiceInfoTable = VendInvoiceInfoTable::findPurchId(purchLineForInventSoldTrans.PurchId, vendInvoiceInfoLine.ParmId);
                      
            UnknownNoYes fixedEuroTriangulation = UnknownNoYes::Unknown;
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                fixedEuroTriangulation = Currency::noYes2UnknownNoYes(vendInvoiceInfoTable.euroTriangulation);
            }

            // VendInvoiceInfoSubLine is used for receipt scenarios, but since this execution is for invoicing scenarios only, the buffer is null.
            VendInvoiceInfoSubLine  vendInvoiceInfoSubLine = null;

            InventUpd_Financial inventFinancial = InventUpd_Financial::newPurchInvoice(movement,
                    ledgerVoucher,
                    vendInvoiceInfoTable.Num,
                    assetTrans.AmountCur,
                    assetTrans.CurrencyCode,
                    vendInvoiceInfoTable.FixedExchRate,
                    vendInvoiceInfoTable.ExchRateSecondary,
                    fixedEuroTriangulation,
                    vendInvoiceInfoLine,
                    vendInvoiceInfoSubLine);
                        
            InventTrans origInventTrans;
            AssetInventTrans assetInventTrans;
            InventTransOriginId newInventTransOriginId;

            while select RecId from origInventTrans
                order by Voucher
                where
                    origInventTrans.InventTransOrigin == inventTransOriginId
                    && origInventTrans.StatusIssue == StatusIssue::None
                    && origInventTrans.InvoiceId == vendInvoiceInfoTable.Num
                exists join assetInventTrans
                where
                    assetInventTrans.InventTransOrigin == origInventTrans.InventTransOrigin &&
                    assetInventTrans.AssetId == purchLineForInventSoldTrans.AssetId
            {
                InventTrans matchedOrigInventTrans = InventTrans::findRecId(origInventTrans.RecId);

                if (matchedOrigInventTrans)
                {
                    InventMov_Virtuel movement_Virtuel = InventMov_Virtuel::newAutoLossAsset(inventFinancial, matchedOrigInventTrans, newInventTransOriginId);
                    InventUpd_Financial financial_Virtuel = InventUpd_Financial::newAutoLossProfit(movement_Virtuel, inventFinancial);
                    financial_Virtuel.updateNow();

                    // set newInventTransOriginId value  - re-use the existing inventTransOriginId for the current source document
                    newInventTransOriginId = movement_Virtuel.inventTransOriginId();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>haveSoldTransactions</Name>
				<Source><![CDATA[
    private boolean haveSoldTransactions(InventTransOriginId _inventTransOriginId)
    {
        InventTrans origInventTransSold;
        AssetInventTrans assetInventTrans;

        select firstonly RecId from origInventTransSold
            where
                origInventTransSold.InventTransOrigin == _inventTransOriginId &&
                origInventTransSold.StatusIssue == StatusIssue::Sold
            exists join assetInventTrans
            where
                assetInventTrans.InventTransOrigin == origInventTransSold.InventTransOrigin &&
                assetInventTrans.AssetId == purchLineForInventSoldTrans.AssetId;

        return origInventTransSold.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCreateInventorySoldTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the inventory sold transaction should be created.
    /// </summary>
    /// <returns>
    /// true if the inventory sold transaction should be created; otherwise, false.
    /// </returns>
    protected boolean shouldCreateInventorySoldTransaction()
    {
        Debug::assert(purchLineForInventSoldTrans != null);
        
        return purchLineForInventSoldTrans.isStocked();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceInfoLine</Name>
				<Source><![CDATA[
    private VendInvoiceInfoLine getVendInvoiceInfoLine(RefRecId _purchLineRecId, Voucher _ledgerVoucher)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;
        AssetTransVendInvoiceTrans assetTransVendInvoiceTrans;

        select vendInvoiceInfoLine
                where vendInvoiceInfoLine.PurchLineRecId == _purchLineRecId
                    && vendInvoiceInfoLine.ParmId != ''
                join assetTransVendInvoiceTrans
                    where assetTransVendInvoiceTrans.VendInvoiceInfoLine == vendInvoiceInfoLine.RecId
                        && assetTransVendInvoiceTrans.AssetTransVoucher == _ledgerVoucher;

        // If vendInvoiceInfoLine is empty, may be we have no appropriate record in AssetTransVendInvoiceTrans.
        // Get vendInvoiceInfoLine from PO in this case.
        Debug::assert(vendInvoiceInfoLine != null);
        if(!vendInvoiceInfoLine)
        {
            vendInvoiceInfoLine = VendInvoiceInfoLine::findByPurchLineRefRecId(_purchLineRecId);
        }

        return vendInvoiceInfoLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTrueUpDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create Depreciation adjustments based on <c>AssetBook</c> buffer.
    /// </summary>
    /// <param name = "_assetBook">
    /// The <c>AssetBook</c> buffer.
    /// </param>
    /// <returns>
    /// Returns true if the Depreciation adjustments required; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    final protected boolean createTrueUpDepreciation(AssetBook _assetBook)
    {
        container priorYearAmount;
        container priorYearAmountReportingCurrency;
        AssetAmount thisYearAdjustedDepreciation;
        AssetAmount priorYearsAdjustedDepreciation;
        AssetAmount thisYearAdjustedDepreciationReportingCurrency;
        AssetAmount priorYearsAdjustedDepreciationReportingCurrency;
        boolean returnValue;

        if (_assetBook.IsTrueUpDepreciation && _assetBook.isTrueUpDepreciationRequired())
        {
            priorYearAmount = AssetBook::calculateCatchUpDepreciation(_assetBook, assetTrans.TransDate);
            priorYearsAdjustedDepreciation = conPeek(priorYearAmount, 1);
            thisYearAdjustedDepreciation = conPeek(priorYearAmount, 2);

            boolean hasSameAccoutingAndReportingCurrency = Ledger::reportingCurrency() == Ledger::accountingCurrency();
            boolean executeReportingCurrencyLogic;

            if (!hasSameAccoutingAndReportingCurrency)
            {
                executeReportingCurrencyLogic = Ledger::reportingCurrency() != '';
            }

            if (executeReportingCurrencyLogic)
            {
                priorYearAmountReportingCurrency = AssetBook::calculateCatchupDepreciationPerCurrency(_assetBook, assetTrans.TransDate, true);
                priorYearsAdjustedDepreciationReportingCurrency = conPeek(priorYearAmountReportingCurrency, 1);
                thisYearAdjustedDepreciationReportingCurrency = conPeek(priorYearAmountReportingCurrency, 2);
            }

            if (priorYearsAdjustedDepreciation
                && AssetAdditionalAcquisitions::applyAdditionalAcquistionsLogic(_assetBook.depreciationProfile()))
            {
                thisYearAdjustedDepreciation += priorYearsAdjustedDepreciation;
                priorYearsAdjustedDepreciation = 0;

                if (executeReportingCurrencyLogic)
                {
                    thisYearAdjustedDepreciationReportingCurrency += priorYearsAdjustedDepreciationReportingCurrency;
                    priorYearsAdjustedDepreciationReportingCurrency = 0;
                }
            }

            if (isAccountsPayableAcquisition
                || cashDiscTransaction
                || inventJournalTransVoucher
                || isProjEstimate)
            {
                if (thisYearAdjustedDepreciation)
                {
                    if (hasSameAccoutingAndReportingCurrency)
                    {
                        thisYearAdjustedDepreciationReportingCurrency = thisYearAdjustedDepreciation;
                    }

                    returnValue = this.createDepreciationAdjustmentNonGL(
                        _assetBook,
                        thisYearAdjustedDepreciation,
                        thisYearAdjustedDepreciationReportingCurrency);
                }

                if (priorYearsAdjustedDepreciation)
                {
                    // <GJP>
                    if (isIsoJP)
                    {
                        returnValue = this.createDepreciationAdjustmentNonGL(
                            _assetBook,
                            priorYearsAdjustedDepreciation,
                            0,
                            true);
                    }
                    else
                    {
                        // </GJP>
                        if (hasSameAccoutingAndReportingCurrency)
                        {
                            priorYearsAdjustedDepreciationReportingCurrency = priorYearsAdjustedDepreciation;
                        }

                        returnValue = this.createDepreciationAdjustmentNonGL(
                            _assetBook,
                            priorYearsAdjustedDepreciation,
                            priorYearsAdjustedDepreciationReportingCurrency);
                        // <GJP>
                    }
                    // </GJP>
                }
            }
            else
            {
                if (thisYearAdjustedDepreciation)
                {
                    if (hasSameAccoutingAndReportingCurrency)
                    {
                        thisYearAdjustedDepreciationReportingCurrency = thisYearAdjustedDepreciation;
                    }

                    returnValue = this.createDepreciationAdjustment(
                        ledgerJournalTrans,
                        _assetBook,
                        thisYearAdjustedDepreciation,
                        thisYearAdjustedDepreciationReportingCurrency);
                }

                if (priorYearsAdjustedDepreciation)
                {
                    // <GJP>
                    if (isIsoJP)
                    {
                        returnValue = this.createDepreciationAdjustment(
                            ledgerJournalTrans,
                            _assetBook,
                            priorYearsAdjustedDepreciation,
                            0,
                            true);
                    }
                    else
                    {
                        // </GJP>
                        if (hasSameAccoutingAndReportingCurrency)
                        {
                            priorYearsAdjustedDepreciationReportingCurrency = priorYearsAdjustedDepreciation;
                        }

                        returnValue = this.createDepreciationAdjustment(
                            ledgerJournalTrans,
                            _assetBook,
                            priorYearsAdjustedDepreciation,
                            priorYearsAdjustedDepreciationReportingCurrency);
                        // <GJP>
                    }
                    // </GJP>
                }
            }
        }
        else if (_assetBook.IsDerogatoryBook_FR)
        {
            this.createDerogatoryAdjustment_FR(_assetBook);
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineNumberDerogatoryPeriods_FR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the number of periods between the last posting and the date of the current posting.
    /// </summary>
    /// <param name="_assetBook">
    ///    The table buffer of the value model for which the number of periods will be calculated.
    /// </param>
    /// <param name="_lastTransDate">
    ///    The date on which the derogatory depreciation will be posted.
    /// </param>
    /// <returns>
    ///    The number of periods between the last derogatory posting and the current one.
    /// </returns>
    /// <remarks>
    ///    This method is used for French derogatory depreciation. Tax volume models are not posted to the GL.
    ///    The number between postings must be calculated manually. If you decide to summarize the posting,
    ///    the number of periods must be combined.
    /// </remarks>
    private AssetDepreciationTime determineNumberDerogatoryPeriods_FR(AssetBook _assetBook, AssetTransDate _lastTransDate)
    {
        AssetDepreciationTime numberOfPeriods;
        AssetTransDate prevTransDate;
        AssetTransDate currentTransDate;
        AssetTableInterval depreciationInterval;

        // Create the interval object to help determining the number of periods.
        depreciationInterval = AssetTableInterval::construct(_assetBook.depreciationProfile(),
            AssetBookTable::find(_assetBook.BookId).FiscalCalendar);

        // If the value model has not been depreciated, use the aquisition date.
        // Otherwise, use the last depreciation date.
        if (!_assetBook.LastDepreciationDate)
        {
            prevTransDate = depreciationInterval.endPeriod(_assetBook.UsedFromDate);

            if ((_assetBook.depreciationProfile().Method == AssetDepreciationMethod::RBSL ||
                 _assetBook.depreciationAltProfile().Method == AssetDepreciationMethod::RBSL))
            {
                if (_assetBook.depreciationProfile().DepreciationYear == AssetDepreciationYear::Calendar)
                {
                    numberOfPeriods = mthOfYr(_assetBook.UsedFromDate) - 1;
                }
                else
                {
                    numberOfPeriods = depreciationInterval.indexofPeriod(_assetBook.UsedFromDate) - 1;
                }
            }
        }
        else
        {
            prevTransDate = depreciationInterval.endPeriod(_assetBook.LastDepreciationDate) + 1;
        }

        // Calculate the number of periods between the current and the last one.
        _lastTransDate = depreciationInterval.endPeriod(_lastTransDate);
        currentTransDate = depreciationInterval.endPeriod(prevTransDate);

        while (currentTransDate && currentTransDate <= _lastTransDate)
        {
            numberOfPeriods++;
            currentTransDate = depreciationInterval.endPeriod(currentTransDate + 1);
        }

        // Make sure that the number of periods is not greater then the number of the remaining periods.
        // It is possible that the derogatory transactions can be summarized and the transaction date
        // can be beyond the life of the value model.
        if (numberOfPeriods > _assetBook.LifeTimeRest)
        {
            numberOfPeriods = _assetBook.LifeTimeRest;
        }

        return numberOfPeriods;
    }

]]></Source>
			</Method>
			<Method>
				<Name>existAssetTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether <c>AssetTrans</c> table records related to the specified buffers exist.
    /// </summary>
    /// <param name="_tmpLedgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table record that might hold a relation to an <c>AssetTrans</c> table
    ///    record.
    /// </param>
    /// <param name="_tmpLedgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table record that might hold a relation to an <c>AssetTrans</c>
    ///    table record.
    /// </param>
    /// <returns>
    ///    true if a related <c>AssetTrans</c> table record exists; otherwise, false.
    /// </returns>
    private boolean existAssetTrans(LedgerJournalTrans _tmpLedgerJournalTrans, LedgerJournalTrans_Asset _tmpLedgerJournalTrans_Asset)
    {
        AssetTrans tmpAssetTrans;
        
        select firstonly RecId from tmpAssetTrans
            where tmpAssetTrans.AssetId == ledgerJournalTrans.parmAccount() &&
                  tmpAssetTrans.TransDate == _tmpLedgerJournalTrans.TransDate &&
                  tmpAssetTrans.TransType == AssetPost::assetTransTypeJournal2AssetTransType(_tmpLedgerJournalTrans_Asset.TransType)  &&
                  tmpAssetTrans.BookId == _tmpLedgerJournalTrans_Asset.BookId &&
                  tmpAssetTrans.Voucher == _tmpLedgerJournalTrans.Voucher;

        return tmpAssetTrans.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCashDiscTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Initializes class for posting of cash discount asset transaction.
    /// </summary>
    /// <param name = "_assetTrans">
    ///   Original asset transaction to post discount for.
    /// </param>
    /// <param name = "_custVendTrans">
    ///   Customer or vendor transaction.
    /// </param>
    /// <param name = "_discAmountMST">
    ///   New transaction amount.
    /// </param>
    /// <param name = "_baseAmountMST">
    ///   Part of original transaction amount which was used for discount calculation.
    /// </param>
    public void initFromCashDiscTrans(AssetTrans _assetTrans, CustVendTrans _custVendTrans, AssetAmount _discAmountMST, AssetAmount _baseAmountMST = 0)
    {
        CurrencyExchangeHelper currencyHelper;
        AssetBook assetBook;

        assetTrans.AssetId = _assetTrans.AssetId;
        assetTrans.BookId = _assetTrans.BookId;

        assetBook = assetBook::find(assetTrans.AssetId, assetTrans.BookId);

        this.validateAssetBookPostingLayer(assetBook, _custVendTrans.Voucher);

        assetTrans.TransType = _assetTrans.TransType;
        assetTrans.TransDate = _custVendTrans.TransDate;
        assetTrans.Voucher = _custVendTrans.Voucher;

        assetTrans.Txt = _custVendTrans.Txt;
        assetTrans.CurrencyCode = _custVendTrans.CurrencyCode;

        exchRate = _custVendTrans.ExchRate;
        exchRateSecond = _custVendTrans.ExchRateSecond;
        reportingCrossRate = _custVendTrans.ReportingCurrencyCrossRate;

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), assetTrans.TransDate);
        currencyHelper.parmExchangeRate1(exchRate);
        currencyHelper.parmExchangeRate2(exchRateSecond);
        currencyHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);
        currencyHelper.parmReportingExchangeRate2(reportingCurrencyExchRateSecond);

        assetTrans.AmountCur = -currencyHelper.calculateAccountingToTransaction(assetTrans.CurrencyCode, _discAmountMST, true);

        // The amount cannot be set as sent in since a round can occur converting between currencies.
        // To be sure to balance with the ledger amounts we must convert to transaction currency then back to MST.
        assetTrans.AmountMST = currencyHelper.calculateTransactionToAccounting(assetTrans.CurrencyCode, assetTrans.AmountCur, true);

        if (Ledger::reportingCurrency())
        {
            assetTrans.ReportingCurrencyAmount = currencyHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, assetTrans.AmountCur, true);
        }

        assetTrans.DefaultDimension = _assetTrans.DefaultDimension;
        assetTrans.PostingProfile = _assetTrans.PostingProfile;
        assetTrans.AssetGroup = _assetTrans.AssetGroup;

        if (_baseAmountMST)
        {
            assetTrans.CashDiscBaseAmountMST = _baseAmountMST;
            assetTrans.CashDiscBaseTransId = _assetTrans.RecId;
        }

        cashDiscTransaction = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the data from the <c>CustInvoiceTrans</c> table to the <c>AssetTrans</c> table.
    /// </summary>
    /// <param name="_custInvoiceTrans">
    ///    The <c>CustInvoiceTrans</c> table buffer that holds the customer invoice line data.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The value model was not specified.
    /// </exception>
    public void initFromCustInvoiceTrans(CustInvoiceTrans _custInvoiceTrans)
    {
        AssetBook assetbook;

        assetTrans.AssetId = _custInvoiceTrans.AssetId;
        assetTrans.BookId = _custInvoiceTrans.AssetBookId ? _custInvoiceTrans.AssetBookId : AssetParameters::find().BookIdDefault;

        assetbook = Assetbook::find(assetTrans.AssetId, assetTrans.BookId);

        this.validateAssetBookPostingLayer(assetBook, ledgerVoucher.lastVoucher());

        assetTrans.TransType = AssetTransType::DisposalSale;
        assetTrans.TransDate = _custInvoiceTrans.InvoiceDate;
        assetTrans.Voucher = ledgerVoucher.lastVoucher();
        assetTrans.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(_custInvoiceTrans.ReasonRefRecId, assetTrans.DataAreaId);

        assetTrans.Txt = _custInvoiceTrans.Name;
        assetTrans.CurrencyCode = _custInvoiceTrans.CurrencyCode;
        assetTrans.AmountCur = -_custInvoiceTrans.LineAmount;
        assetTrans.AmountMST = -CurrencyExchangeHelper::mstAmount(_custInvoiceTrans.LineAmount, _custInvoiceTrans.CurrencyCode, _custInvoiceTrans.InvoiceDate);
        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), _custInvoiceTrans.InvoiceDate);
            assetTrans.ReportingCurrencyAmount = -currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(_custInvoiceTrans.CurrencyCode, _custInvoiceTrans.LineAmount);
        }
        assetTrans.DefaultDimension = _custInvoiceTrans.DefaultDimension;
        assetTrans.PostingProfile = AssetBook::find(assetTrans.AssetId, assetTrans.BookId).PostingProfile;
        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;

        custAccount = CustInvoiceJour::findFromCustInvoiceTrans(_custInvoiceTrans.SalesId,
                                                                                _custInvoiceTrans.InvoiceId,
                                                                                _custInvoiceTrans.InvoiceDate,
                                                                                _custInvoiceTrans.NumberSequenceGroup).OrderAccount;

        custInvoiceId = _custInvoiceTrans.InvoiceId;

        if (! assetTrans.BookId)
        {
            throw error("@FixedAssets:FA_MessageError_BookMustBeSpecified");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWmsLocation</Name>
				<Source><![CDATA[
    private void validateWmsLocation(
        InventJournalTrans inventJournalTrans)
    {
        InventDim inventDim = InventDim::find(inventJournalTrans.InventDimId);
        WMSLocation wmsLocation = WMSLocation::find(inventDim.wmsLocationId, inventDim.InventLocationId);

        if (wmsLocation.inputBlockingCauseId && inventJournalTrans.Qty > 0)
        {
            throw error(strFmt("@SYS72264", inventDim.wmsLocationId));
        }

        if (wmsLocation.outputBlockingCauseId && inventJournalTrans.Qty < 0)
        {
            throw error(strFmt("@SYS72265", inventDim.wmsLocationId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class for posting of asset transaction originated from <c>InventJournalTrans</c> table buffer.
    /// </summary>
    /// <param name = "inventJournalTrans">The <c>InventJournalTrans</c> table buffer from which to initialize.</param>
    /// <param name = "inventUpd_Financial">A new instance of <c>InventUpd_Financial</c> class.</param>
    public void initFromInventJournalTrans(InventJournalTrans inventJournalTrans, InventUpd_Financial inventUpd_Financial)
    {
        InventMov_Journal   movement;
        AssetBook assetBook;

        assetTrans.AssetId = inventJournalTrans.AssetId;
        assetTrans.BookId = inventJournalTrans.AssetBookId ? inventJournalTrans.AssetBookId : AssetParameters::find().BookIdDefault;
        assetBook = assetBook::find(assetTrans.AssetId, assetTrans.BookId);

        this.validateAssetBookPostingLayer(assetBook, inventJournalTrans.Voucher);

        assetTrans.TransType = AssetPost::assetTransTypeJournal2AssetTransType(inventJournalTrans.AssetTransType);
        assetTrans.TransDate = inventJournalTrans.TransDate;
        assetTrans.Voucher = inventJournalTrans.Voucher;
        inventJournalTransVoucher = inventJournalTrans.Voucher;

        this.validateWmsLocation(inventJournalTrans);

        assetTrans.Txt = enum2str(assetTrans.TransType);
        assetTrans.CurrencyCode = Ledger::accountingCurrency();
        assetTrans.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(inventJournalTrans.ReasonRefRecId, assetTrans.DataAreaId);

        assetTrans.DefaultDimension = inventJournalTrans.DefaultDimension;
        assetTrans.PostingProfile = AssetBook::find(assetTrans.AssetId, assetTrans.BookId).PostingProfile;
        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;

        if (inventUpd_Financial)
        {
            assetTrans.AmountCur = -inventUpd_Financial.updCostAmountLedger();
            assetTrans.AmountMST =  assetTrans.AmountCur;
        }
        else
        {
            movement = InventMovement::construct(inventJournalTrans);

            assetTrans.AmountCur = -abs(inventJournalTrans.CostAmount) * movement.transSign();
            assetTrans.AmountMST =  assetTrans.AmountCur;
        }

        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), assetTrans.TransDate);
            assetTrans.ReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, assetTrans.AmountCur);
        }

        if (! assetTrans.BookId)
        {
            throw error("@FixedAssets:FA_MessageError_BookMustBeSpecified");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class for posting of asset transaction originated from <c>InventMovement</c> table buffer.
    /// </summary>
    /// <param name = "inventMovement">The <c>InventMovement</c> table buffer from which to initialize.</param>
    /// <param name = "inventUpd_Financial">A new instance of <c>InventUpd_Financial</c> class.</param>
    /// <param name = "amountMST">Amount in accounting currency for the transaction amount.</param>
    public void initFromInventMovement(InventMovement inventMovement, InventUpd_Financial inventUpd_Financial, AmountMST amountMST)
    {
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;
        Voucher             invoiceVoucher;

        AssetBook assetbook;

        select firstonly InventTransId, Party, RecId from inventTransOrigin
            where inventTransOrigin.RecId == inventMovement.inventTransOriginId()
               && inventTransOrigin.ReferenceCategory == InventTransType::Purch
            join InvoiceId, CurrencyCode from inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                   && inventTrans.InvoiceId == inventUpd_Financial.parmInvoiceId()  //to get correct invent trans record for the current invoice when the line has been split/partial invoice posting.
                   && (!inventUpd_Financial.parmPackingSlipId()   || inventTrans.PackingSlipId == inventUpd_Financial.parmPackingSlipId())
                   && (!inventUpd_Financial.parmVoucherPhysical() || inventTrans.VoucherPhysical == inventUpd_Financial.parmVoucherPhysical());

        assetTrans.TransType = AssetTransType::Acquisition;

        if (inventTransOrigin)
        {
            vendAccount = VendTable::findByPartyRecId(inventTransOrigin.Party).AccountNum;
            vendInvoiceId = inventTrans.InvoiceId;

            purchLine = InventTransOriginPurchLine::purchLine(inventTransOrigin.RecId);
            purchId = purchLine.PurchId;

            assetTrans.TransType = AssetPost::assetTransTypePurch2AssetTransType(purchLine.AssetTransTypePurch);
        }

        assetTrans.AssetId = inventMovement.assetId();
        assetTrans.BookId = inventMovement.assetBookId() ? inventMovement.assetBookId() : AssetParameters::find().BookIdDefault;
        assetBook = assetBook::find(assetTrans.AssetId, assetTrans.BookId);

        assetTrans.TransDate = inventUpd_Financial.parmLedgerVoucher().lastTransDate();

        // The vouchers need to be the same for the invoice and asset transactions.  Inventory might have different voucher series used then AP.
        // The voucher from the vendor invoice needs to be assigned to the asset transaction, so that the invoice and fixed asset transaction
        // can be found for the discount amount deduction calculation.
        if (AssetParameters::find().DeductCashDisc)
        {
            VendInvoiceJour     vendInvoiceJour;

            select firstonly LedgerVoucher from vendInvoiceJour
                where vendInvoiceJour.PurchId == purchId
                   && vendInvoiceJour.InvoiceId == vendInvoiceId
                   && vendInvoiceJour.InvoiceDate == assetTrans.TransDate;

            invoiceVoucher = vendInvoiceJour.LedgerVoucher;
        }

        assetTrans.Voucher = invoiceVoucher ? invoiceVoucher : inventUpd_Financial.parmLedgerVoucher().lastVoucher();

        this.validateAssetBookPostingLayer(assetBook, assetTrans.Voucher);

        assetTrans.Txt = enum2str(assetTrans.TransType);
        assetTrans.CurrencyCode = inventTrans.CurrencyCode;
        assetTrans.AmountCur = CurrencyExchangeHelper::curAmount(amountMST, assetTrans.CurrencyCode, assetTrans.TransDate);

        // For cancelled transactions that have no Transaction amount determined from the inventory tranactions,
        // the amount to reverse is based on the line amount.
        if (amountMST == 0
            && purchLine.QtyOrdered < 0
            && purchLine.LineAmount != 0)
        {
            assetTrans.AmountMST = purchLine.lineAmountMST();
        }
        else
        {
            assetTrans.AmountMST = amountMST;
        }
        assetTrans.AmountCur = CurrencyExchangeHelper::curAmount(assetTrans.AmountMST, assetTrans.CurrencyCode, assetTrans.TransDate);
        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), assetTrans.TransDate);
            assetTrans.ReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, assetTrans.AmountCur);
        }

        assetTrans.DefaultDimension = inventMovement.defaultDimension();
        assetTrans.PostingProfile = AssetBook::find(assetTrans.AssetId, assetTrans.BookId).PostingProfile;
        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;

        if (isIsoIT)
        {
            // Set depreciation start date
            depreciationStartDate = purchLine.DepreciationStartDate;
        }

        if (! assetTrans.BookId)
        {
            throw error("@FixedAssets:FA_MessageError_BookMustBeSpecified");
        }

        isAccountsPayableAcquisition = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInventMovement_AssetDocument_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>AssetPost</c> by <c>AssetDocumentPostInvoiceAdapter_JP</c> instance.
    /// </summary>
    /// <param name="_adapter">
    /// The <c>AssetDocumentPostInvoiceAdapter_JP</c> instance.
    /// </param>
    /// <exception cref="Exception::Error">
    /// Throws exception if no valid value model.
    /// </exception>
    public void initFromInventMovement_AssetDocument_JP(AssetDocumentPostInvoiceAdapter_JP _adapter)
    {
        assetTrans = _adapter.initAssetTrans(assetTrans);

        if (!assetTrans.BookId)
        {
            throw error("@FixedAssets:FA_MessageError_BookMustBeSpecified");
        }

        assetDocumentType_JP = _adapter.parmAssetDocumentTable().Type;
        assetDocumentEntryRecId = _adapter.parmAssetDocumentEntry().RecId;
        vendInvoiceInfoLineAsset = _adapter.parmVendInvoiceInfoLineAsset();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromInvoiceCashDiscTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes this instance from the specified <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer from which to initialize.
    /// </param>
    /// <remarks>
    ///    This method is used when the cash discount is applied on the vendor invoice.
    /// </remarks>
    public void initFromInvoiceCashDiscTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        ledgerJournalTrans = _ledgerJournalTrans;
        ledgerJournalTrans_Asset = _ledgerJournalTrans.findLedgerJournalTransAssetSibling();

        assetTrans.AssetId = ledgerJournalTrans.parmAccount();
        assetTrans.BookId = ledgerJournalTrans_Asset.BookId;
        assetTrans.TransType = AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType);
        assetTrans.TransDate = ledgerJournalTrans.TransDate;
        assetTrans.Voucher = ledgerJournalTrans.Voucher;
        assetTrans.Txt = ledgerJournalTrans.Txt ? ledgerJournalTrans.Txt : ledgerJournalTrans.ledgerJournalTable().Name;
        assetTrans.CurrencyCode = ledgerJournalTrans.CurrencyCode;
        assetTrans.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(ledgerJournalTrans.ReasonRefRecID, assetTrans.DataAreaId);

        assetTrans.AmountMST = -CurrencyExchangeHelper::mstAmount(ledgerJournalTrans.CashDiscAmount, assetTrans.CurrencyCode, assetTrans.TransDate);
        assetTrans.AmountCur = -ledgerJournalTrans.CashDiscAmount;

        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), assetTrans.TransDate);
            currencyExchangeHelper.parmErrorType(AifErrorType::Exception);
            currencyExchangeHelper.parmReportingExchangeRate1(ledgerJournalTrans.ReportingCurrencyExchRate);
            currencyExchangeHelper.parmReportingExchangeRate2(ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
            assetTrans.ReportingCurrencyAmount = -currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, ledgerJournalTrans.CashDiscAmount);
        }

        assetTrans.DefaultDimension = ledgerJournalTrans.DefaultDimension;

        assetTrans.PostingProfile = AssetTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension()).postingProfile(ledgerJournalTrans_Asset.BookId);

        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;

        cashDiscTransaction = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an instance of the <c>AssetPost</c> class from the specified <c>LedgerJournalTrans</c>
    ///    table buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer from which to initialize.
    /// </param>
    /// <param name="_originalLedgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> table buffer not modified by posting.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    ///    The <c>LedgerJournalTrans_Asset</c> table buffer from which to initialize.
    /// </param>
    /// <param name="_isOffset">
    ///    true if posting the offset; false if posting the primary.
    /// </param>
    /// <param name="_taxAmount">
    ///    The amount of tax to subtract from the amount returned from the amount method on the specified
    ///    <c>LedgerJournalTrans</c> record; optional.
    /// </param>
    /// <param name="_taxAmountInCostPrice">
    ///    The amount of tax already included in the price to add back to the amount returned from the amount
    ///    method on the specified <c>LedgerJournalTrans</c> record; optional.
    /// </param>
    public void initFromLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans,
                                           LedgerJournalTrans _originalLedgerJournalTrans,
                                           LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                           boolean _isOffset,
                                           TaxAmount _taxAmount = 0,
                                           TaxAmount _taxAmountInCostPrice = 0)
    {
        VendTrans vendTrans;
        CustTrans custTrans;
        LedgerJournalACType ledgerJournalAccountType;
        boolean ledgerJournalAccountTypeIsSet;
        LedgerJournalTrans ledgerJournalTransCustVend;

        // Perform additional verification because the AssetParameter table option disables the acquisitions from PO
        if (!AssetParameters::find().AssetAllowAcqPostingPO)
        {
            isInventorySoldTransNeeded = true;
        }

        ledgerJournalTrans = _ledgerJournalTrans;
        originalLedgerJournalTrans = _originalLedgerJournalTrans;
        ledgerJournalTrans_Asset = _ledgerJournalTrans_Asset;
        isOffset = _isOffset;

        // <GJP>
        if (isAssetDocumentEnable)
        {
            assetDocumentEntryRecId = ledgerJournalTrans_Asset.AssetDocumentEntry_JP;
            if (assetDocumentEntryRecId
                || AssetDocumentUtility_JP::isDocumentTypeWithoutEntry(ledgerJournalTrans_Asset.DocumentType_JP))
            {
                assetDocumentType_JP = ledgerJournalTrans_Asset.DocumentType_JP;
            }
        }
        // </GJP>

        assetTrans.AssetId = ledgerJournalTrans.parmAccount();
        assetTrans.TransType = AssetPost::assetTransTypeJournal2AssetTransType(ledgerJournalTrans_Asset.TransType
                                            // <GJP>
                                            ,assetDocumentType_JP
                                            // </GJP>
                                            );
        assetTrans.TransDate = ledgerJournalTrans.TransDate;
        assetTrans.Voucher = ledgerJournalTrans.Voucher;
        assetTrans.Approver = ledgerJournalTrans.Approver;
        assetTrans.AssetTransSubType = ledgerJournalTrans_Asset.AssetTransSubType;

        if (isIsoCZ
            && ledgerJournalTrans_Asset.isSplitTransaction())
        {
            assetTrans.PostingType_W = RAssetPostingType::Split;
        }

        assetTrans.Txt = this.findTransactionText(ledgerJournalTrans, ledgerJournalTrans_Asset);
        assetTrans.PaymReference = ledgerJournalTrans.PaymReference;

        assetTrans.CurrencyCode = ledgerJournalTrans.CurrencyCode;
        assetTrans.AmountCur = CurrencyExchange::round(ledgerJournalTrans.amount() - _taxAmount + _taxAmountInCostPrice, ledgerJournalTrans.CurrencyCode);
        assetTrans.AmountMST = ledgerJournalTrans.calcAmountMST()
            - CurrencyExchangeHelper::mstAmount(_taxAmount - _taxAmountInCostPrice, ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate,
                Currency::noYes2UnknownNoYes(ledgerJournalTrans.Triangulation), ledgerJournalTrans.ExchRate, ledgerJournalTrans.ExchRateSecond);

        if (Ledger::reportingCurrency())
        {
            if (AssetPost::isFixedAssetReportingCurrencyAmountShouldBeUsed(ledgerJournalTrans, ledgerJournalTrans_Asset))
            {
                assetTrans.ReportingCurrencyAmount = ledgerJournalTrans_Asset.amountReportingCurrency();
            }
            else
            {
                CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerJournalTrans.TransDate);
                currencyExchangeHelper.parmErrorType(AifErrorType::Exception);
                currencyExchangeHelper.parmReportingExchangeRate1(ledgerJournalTrans.ReportingCurrencyExchRate);
                currencyExchangeHelper.parmReportingExchangeRate2(ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
                assetTrans.ReportingCurrencyAmount = ledgerJournalTrans.calcAmountReportingCurrency()
                    - currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(ledgerJournalTrans.CurrencyCode, _taxAmount - _taxAmountInCostPrice);
            }
        }
        assetTrans.DefaultDimension = ledgerJournalTrans.DefaultDimension;
        assetTrans.ReasonRefRecId = ReasonTableRef::checkCreateInCompany(ledgerJournalTrans.ReasonRefRecID, assetTrans.DataAreaId);
        assetTrans.PostingProfile = AssetPost::postingProfileFromLedgerJournalTrans(ledgerJournalTrans, ledgerJournalTrans_Asset.BookId);
        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;
        assetTrans.ConsumptionQty = ledgerJournalTrans_Asset.ConsumptionQuantity;
        assetTrans.BookId = ledgerJournalTrans_Asset.BookId;
        assetTrans.RevaluationTrans = ledgerJournalTrans_Asset.RevaluationTrans;
        assetTrans.RevaluationAmount = ledgerJournalTrans_Asset.RevaluationAmount;
        assetTrans.RevaluedTransID = ledgerJournalTrans.CustTransId;
        assetTrans.ReserveTransId = ledgerJournalTrans_Asset.ReserveTransId;
        assetTrans.IsPriorYear = ledgerJournalTrans_Asset.IsPriorYear;

        assetTrans.PeriodFromDate = ledgerJournalTrans_Asset.PeriodFromDate;
        assetTrans.PeriodToDate = ledgerJournalTrans_Asset.PeriodToDate;

        // <GEEU>
        assetTrans.DocumentNum_W = ledgerJournalTrans.DocumentNum;
        assetTrans.DocumentDate_W = ledgerJournalTrans.DocumentDate;
        // </GEEU>

        //set low value pool fields
        assetTrans.LowValuePoolType_AU = ledgerJournalTrans_Asset.LowValuePoolType_AU;
        assetTrans.lvpTransferId_AU = ledgerJournalTrans_Asset.lvpTransferId_AU;

        exchRate = ledgerJournalTrans.ExchRate;
        exchRateSecond = ledgerJournalTrans.ExchRateSecond;
        reportingCurrencyExchRate = ledgerJournalTrans.ReportingCurrencyExchRate;
        reportingCurrencyExchRateSecond = ledgerJournalTrans.ReportingCurrencyExchRateSecondary;
        depreciationTime = ledgerJournalTrans_Asset.DepreciationTime;
        taxAmountInCostPriceCur = _taxAmountInCostPrice;
        finTag = ledgerJournalTrans.FinTag;

        // Determine if this Fixed Assets transaction is related to a Customer or Vendor Transaction.  This will only be relevant for
        // Fixed Asset Acquisition transactions related to Vendor transactions or Fixed Assets Disposal a??? Sale / Disposal a??? Scrap
        // transactions related to Customer transactions.  If it is we need to capture additional information to attach to the
        // AssetBook or AssetDepBook record.
        if (ledgerJournalTrans.parmOffsetLedgerDimension())
        {
            switch (ledgerJournalTrans.OffsetAccountType)
            {
                case LedgerJournalACType::Cust:
                    custAccount = ledgerJournalTrans.parmOffsetAccount();
                    custInvoiceId = ledgerJournalTrans.Invoice;
                    break;

                case LedgerJournalACType::Vend:
                    vendAccount = ledgerJournalTrans.parmOffsetAccount();
                    vendInvoiceId = ledgerJournalTrans.Invoice;
                    break;
            }
        }
        else
        {
            // If the Vendor or Customer transaction was not part of a single line voucher then we must search other lines
            // in this same voucher to determine if a related Vendor or Customer transaction does exist.
            switch (ledgerJournalTrans_Asset.TransType)
            {
                case AssetTransTypeJournal::Acquisition:
                case AssetTransTypeJournal::Preacquisition_CZ:
                    // This is a vendor transaction
                    if (ledgerJournalTrans.VendTransId)
                    {
                        // Get vendor account and invoice.
                        select firstonly AccountNum, Invoice from vendTrans
                            where vendTrans.RecId == ledgerJournalTrans.VendTransId;

                        vendAccount = vendTrans.AccountNum;
                        vendInvoiceId = vendTrans.Invoice;
                    }
                    else
                    {
                        // There's no vendTransId so the vendor information will be
                        // retrieved in the if statement below.
                        ledgerJournalAccountType = LedgerJournalACType::Vend;
                        ledgerJournalAccountTypeIsSet = true;
                    }
                    break;

                case AssetTransTypeJournal::DisposalSale,
                    AssetTransTypeJournal::DisposalScrap:
                    // This is a customer transaction.
                    if (ledgerJournalTrans.CustTransId)
                    {
                        select firstonly AccountNum, Invoice from custTrans
                            where custTrans.RecId == ledgerJournalTrans.CustTransId;

                        custAccount = custTrans.AccountNum;
                        custInvoiceId = custTrans.Invoice;
                    }
                    else
                    {
                        // There's no CustTransId so the customer information will be
                        // retrieved in the if statement below.
                        ledgerJournalAccountType = LedgerJournalACType::Cust;
                        ledgerJournalAccountTypeIsSet = true;
                    }
                    break;
            }

            if (ledgerJournalAccountTypeIsSet)
            {
                // Get the customer or vendor information for the voucher.
                // If there are multiple vendors or customers in a voucher
                // the first one found in the voucher will be defaulted to.
                select firstonly LedgerDimension, AccountType, Invoice, Company from ledgerJournalTransCustVend
                    where ledgerJournalTransCustVend.JournalNum == _ledgerJournalTrans.JournalNum &&
                          ledgerJournalTransCustVend.Voucher == _ledgerJournalTrans.Voucher &&
                          ledgerJournalTransCustVend.TransDate == _ledgerJournalTrans.TransDate &&
                          ledgerJournalTransCustVend.OffsetLedgerDimension == 0 &&
                          ledgerJournalTransCustVend.AccountType == ledgerJournalAccountType;

                if (ledgerJournalTransCustVend)
                {
                    switch (ledgerJournalTransCustVend.AccountType)
                    {
                        case LedgerJournalACType::Cust:
                            custAccount = ledgerJournalTransCustVend.parmAccount();
                            custInvoiceId = ledgerJournalTransCustVend.Invoice;
                            break;

                        case LedgerJournalACType::Vend:
                            vendAccount = ledgerJournalTransCustVend.parmAccount();
                            vendInvoiceId = ledgerJournalTransCustVend.Invoice;
                            break;
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFixedAssetReportingCurrencyAmountShouldBeUsed</Name>
				<Source><![CDATA[
    internal static boolean isFixedAssetReportingCurrencyAmountShouldBeUsed(
        LedgerJournalTrans _ledgerJournalTrans,
        LedgerJournalTrans_Asset _ledgerJournalTrans_Asset)
    {
        boolean returnValue = false;

        if (_ledgerJournalTrans
            && _ledgerJournalTrans_Asset
            && Ledger::reportingCurrency() != Ledger::accountingCurrency()
            && (_ledgerJournalTrans_Asset.isDepreciationTransactionType()
                || (FeatureStateProvider::isFeatureEnabled(AssetSplitReportingCurrencyFeature::instance()) 
                    && _ledgerJournalTrans_Asset.isSplitTransaction())))
        {
            if (_ledgerJournalTrans_Asset.amountReportingCurrency() != 0)
            {
                returnValue = true;
            }
            else
            {
                LogisticsAddressCountryRegionISOCode isoCode = SysCountryRegionCode::countryInfo();
                LedgerJournalTable journalTable = LedgerJournalTable::find(_ledgerJournalTrans.JournalNum);

                returnValue = isoCode != #isoJP && isoCode != #isoIN && isoCode != #isoCN && isoCode != #isoPL
                    && journalTable.JournalType == LedgerJournalType::Assets
                    && !_ledgerJournalTrans_Asset.isSplitTransaction();
            }
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doSummarization</Name>
				<Source><![CDATA[
    private void doSummarization(LedgerVoucher _ledgerVoucher)
    {
        if(_ledgerVoucher != null)
        {
            _ledgerVoucher.parmDetailSummary(DetailSummary::Summary);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initGroupDataFromAssetTrans_IN</Name>
				<Source><![CDATA[
    private void initGroupDataFromAssetTrans_IN()
    {
        assetGroupTrans.Approver = assetTrans.Approver;
        assetGroupTrans.AssetId = assetTrans.AssetId;
        assetGroupTrans.BookId = assetTrans.BookId;
        assetGroupTrans.DefaultDimension = assetTrans.DefaultDimension;
        assetGroupTrans.PostingProfile = assetTrans.PostingProfile;
        assetGroupTrans.ReserveTransId = assetTrans.ReserveTransId;
        assetGroupTrans.RevaluedTransId = assetTrans.RevaluedTransID;
        assetGroupTrans.Voucher = assetTrans.Voucher;

        assetGroupInformation.AmountCur = assetTrans.AmountCur;
        assetGroupInformation.AmountMst = assetTrans.AmountMst;
        assetGroupInformation.AssetGroup = assetTrans.AssetGroup;

        if (assetTrans.TransType == AssetTransType::BonusDepreciation)
        {
            assetGroupInformation.BonusId = this.getFirstBonusId(assetTrans.BookId, assetTrans.AssetGroup);
        }

        assetGroupInformation.CurrencyCode = assetTrans.CurrencyCode;
        assetGroupInformation.ConsumptionQty = assetTrans.ConsumptionQty;
        assetGroupInformation.Reclassification = assetTrans.Reclassification;
        assetGroupInformation.ReserveTransferDone = assetTrans.ReserveTransferDone;
        assetGroupInformation.RevaluationAmount = assetTrans.RevaluationAmount;
        assetGroupInformation.RevaluationDone = assetTrans.RevaluationDone;
        assetGroupInformation.RevaluationTrans = assetTrans.RevaluationTrans;
        assetGroupInformation.TransDate = assetTrans.TransDate;
        assetGroupInformation.TransType = assetTrans.TransType;
        assetGroupInformation.Txt = assetTrans.Txt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromLedgerJournalTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize from a <c>LedgerJournalTrans</c> buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// A <c>LedgerJournalTrans_Asset</c> buffer
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount on the asset group.
    /// </param>
    /// <param name="_taxAmountInCostPrice">
    /// The tax amount in cost price on the asset group.
    /// </param>
    void initFromLedgerJournalTrans_IN(LedgerJournalTrans _ledgerJournalTrans,
                                       LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                       TaxAmount _taxAmount = 0,
                                       TaxAmount _taxAmountInCostPrice = 0)
    {
        VendTrans vendTrans;

        ledgerJournalTrans = _ledgerJournalTrans;

        // For the AssetGroupDepreciation the parmAccount() will get the AssetId of the first asset,
        // same thing which will get in the LedgerJournalTrans record.
        assetGroupTrans.AssetId = ledgerJournalTrans.parmAccount();
        assetGroupTrans.Voucher = ledgerJournalTrans.Voucher;
        assetGroupTrans.Approver = ledgerJournalTrans.Approver;
        assetGroupTrans.DefaultDimension = ledgerJournalTrans.DefaultDimension;
        assetGroupInformation.TransType = AssetPost::assetTransTypeJournal2AssetTransType(_ledgerJournalTrans_Asset.TransType);
        assetGroupInformation.TransDate = ledgerJournalTrans.TransDate;
        assetGroupInformation.Txt = ledgerJournalTrans.Txt ? ledgerJournalTrans.Txt : ledgerJournalTrans.ledgerJournalTable().Name;
        assetGroupInformation.CurrencyCode = ledgerJournalTrans.CurrencyCode;
        assetGroupInformation.AmountCur = CurrencyExchange::round(ledgerJournalTrans.amount() - _taxAmount + _taxAmountInCostPrice, ledgerJournalTrans.CurrencyCode);
        assetGroupInformation.AmountMst = ledgerJournalTrans.calcAmountMST()
            - CurrencyExchangeHelper::mstAmount(_taxAmount - _taxAmountInCostPrice, ledgerJournalTrans.CurrencyCode, ledgerJournalTrans.TransDate,
                Currency::noYes2UnknownNoYes(ledgerJournalTrans.Triangulation), ledgerJournalTrans.ExchRate, ledgerJournalTrans.ExchRateSecond);
        assetGroupTrans.DefaultDimension = ledgerJournalTrans.DefaultDimension;

        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets)
        {
            assetGroupTrans.PostingProfile = AssetTable::find(ledgerJournalTrans.parmAccount()).postingProfile(_ledgerJournalTrans_Asset.BookId);
        }
        else
        {
            assetGroupTrans.PostingProfile = ledgerJournalTrans.PostingProfile;
        }

        assetGroupTrans.BookId = _ledgerJournalTrans_Asset.BookId;

        assetGroupInformation.AssetGroup = _ledgerJournalTrans_Asset.AssetGroup_IN;
        assetGroupInformation.ConsumptionQty = _ledgerJournalTrans_Asset.ConsumptionQuantity;
        assetGroupInformation.RevaluationTrans = _ledgerJournalTrans_Asset.RevaluationTrans;
        assetGroupInformation.RevaluationAmount = _ledgerJournalTrans_Asset.RevaluationAmount;
        assetGroupTrans.RevaluedTransID = _ledgerJournalTrans.CustTransId;
        assetGroupTrans.ReserveTransId = _ledgerJournalTrans_Asset.ReserveTransId;

        //  Related to bonus depreciation...

        if (_ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::BonusDepreciation)
        {
            assetGroupInformation.BonusId = this.getFirstBonusId(_ledgerJournalTrans_Asset.BookId, _ledgerJournalTrans_Asset.AssetGroup_IN);
        }

        depreciationTime = _ledgerJournalTrans_Asset.DepreciationTime;
        taxAmountInCostPriceCur = _taxAmountInCostPrice;

        if (isIsoIT)
        {
            // Set depreciation start date
            depreciationStartDate = ledgerJournalTrans_Asset.DepreciationStartDate;
        }

        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Cust)
        {
            custAccount = ledgerJournalTrans.parmOffsetAccount();
            custInvoiceId = ledgerJournalTrans.Invoice;
        }
        else
        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Vend)
        {
            vendAccount = ledgerJournalTrans.parmOffsetAccount();
            vendInvoiceId = ledgerJournalTrans.Invoice;
        }
        else
        {
            if (ledgerJournalTrans.VendTransId)
            {
                select firstonly AccountNum, Invoice from vendTrans
                    where vendTrans.RecId == ledgerJournalTrans.VendTransId;

                vendAccount = vendTrans.AccountNum;
                vendInvoiceId = vendTrans.Invoice;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the class for posting of asset transaction originated from <c>ProjControlPeriodTable</c> table buffer.
    /// </summary>
    /// <param name = "_projControlPeriodTable">The <c>ProjControlPeriodTable</c> table buffer from which to initialize.</param>
    /// <param name = "_amountMST">The transaction amount, in the accounting currency.</param>
    public void initFromProjEstimate(ProjControlPeriodTable _projControlPeriodTable, AmountMST _amountMST)
    {
        assetTrans.AssetId = _projControlPeriodTable.AssetIdNew;

        if (_projControlPeriodTable.AssetBookId == '')
        {
            assetTrans.BookId = _projControlPeriodTable.bookId();
        }
        else
        {
            assetTrans.BookId = _projControlPeriodTable.AssetBookId;
        }

        AssetBook assetBook = assetBook::find(assetTrans.AssetId, assetTrans.BookId);

        this.validateAssetBookPostingLayer(assetBook, ledgerVoucher.lastVoucher());

        assetTrans.TransType = AssetTransType::Acquisition;
        assetTrans.TransDate = ledgerVoucher.lastTransDate();
        assetTrans.Voucher = ledgerVoucher.lastVoucher();

        assetTrans.Txt = strFmt("@SYS78497",_projControlPeriodTable.ProjId);
        assetTrans.CurrencyCode = Ledger::accountingCurrency();
        assetTrans.AmountCur = CurrencyExchangeHelper::curAmount(_amountMST, assetTrans.CurrencyCode, assetTrans.TransDate);
        assetTrans.AmountMST = _amountMST;
        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), assetTrans.TransDate);
            assetTrans.ReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, assetTrans.AmountCur);
        }
        assetTrans.DefaultDimension = _projControlPeriodTable.projTable().DefaultDimension;
        assetTrans.PostingProfile = AssetBook::find(assetTrans.AssetId, assetTrans.BookId).PostingProfile;
        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;
        isProjEstimate = true;

        if (!assetTrans.BookId)
        {
            throw error("@FixedAssets:FA_MessageError_BookMustBeSpecified");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchComplementaryInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an instance of the <c>AssetPost</c> class from the a given purchase complementary invoice line.
    /// </summary>
    /// <param name="_purchComplInvoiceLine">
    /// The <c>PurchComplementaryInvoiceLine</c> containing the given line of the purch complementary invoice.
    /// </param>
    /// <param name="_purchComplInvoice">
    /// The <c>PurchComplementaryInvoiceHeader</c> containing the given header of the purch complementary invoice.
    /// </param>
    /// <param name="_amountToAdd">
    /// The transaction amount, in the accounting currency.
    /// </param>
    public void initFromPurchComplementaryInvoice(PurchComplementaryInvoiceLine _purchComplInvoiceLine,
                                                  PurchComplementaryInvoiceHeader _purchComplInvoice,
                                                  AmountMST _amountToAdd)
    {
        AssetBook assetBook;

        assetTrans.AssetId = _purchComplInvoiceLine.AssetId;
        assetTrans.BookId = _purchComplInvoiceLine.AssetBookId ? _purchComplInvoiceLine.AssetBookId : AssetParameters::find().BookIdDefault;
        assetBook = assetBook::find(assetTrans.AssetId, assetTrans.BookId);

        this.validateAssetBookPostingLayer(assetBook, ledgerVoucher.lastVoucher());

        assetTrans.TransType = AssetTransType::AcquisitionAdj;
        assetTrans.TransDate = _purchComplInvoice.TransDate;
        assetTrans.Voucher = ledgerVoucher.lastVoucher();
        assetTrans.Txt = _purchComplInvoiceLine.Description;
        assetTrans.CurrencyCode = _purchComplInvoice.Currency;
        assetTrans.AmountCur = _amountToAdd;
        assetTrans.AmountMST = assetTrans.AmountCur;
        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), assetTrans.TransDate);
            assetTrans.ReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, assetTrans.AmountCur);
        }
        assetTrans.DefaultDimension = _purchComplInvoice.DefaultDimension;
        assetTrans.PostingProfile = AssetBook::find(assetTrans.AssetId, assetTrans.BookId).PostingProfile;
        assetTrans.AssetGroup = _purchComplInvoiceLine.AssetGroup ? _purchComplInvoiceLine.AssetGroup : AssetTable::find(assetTrans.AssetId).AssetGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes an instance of the <c>AssetPost</c> class from the specified <c>VendInvoiceTrans</c> table buffer.
    /// </summary>
    /// <param name="_vendInvoiceTrans">
    ///    The <c>VendInvoiceTrans</c> table buffer from which to initialize.
    /// </param>
    /// <param name="_vendInvoiceJour">
    ///    The <c>VendInvoiceJour</c> table buffer from which to initialize.
    /// </param>
    /// <param name="_vendInvoiceInfoLine_Asset">
    ///    The <c>VendInvoiceInfoLine_Asset</c> table buffer from which to initialize.
    /// </param>
    /// <param name="_tax">
    ///     The <c>Tax</c> object from which to initialize.
    /// </param>
    public void initFromVendInvoiceTrans(
        VendInvoiceTrans _vendInvoiceTrans,
        VendInvoiceJour _vendInvoiceJour,
        VendInvoiceInfoLine_Asset _vendInvoiceInfoLine_Asset,
        Tax _tax = null)
    {
        vendInvoiceTrans = _vendInvoiceTrans;
        this.populatePurchInfo(_vendInvoiceTrans);

        CurrencyExchangeHelper transExchRateHelper = this.initExchangeRateHelperFromVendInvoiceJour(_vendInvoiceJour, _vendInvoiceTrans.InvoiceDate);
        
        assetTrans.TransType = AssetPost::assetTransTypePurch2AssetTransType(_vendInvoiceInfoLine_Asset.AssetTransTypePurch);
        assetTrans.AssetId = _vendInvoiceInfoLine_Asset.AssetId;
        assetTrans.AssetGroup = AssetTable::find(assetTrans.AssetId).AssetGroup;

        assetTrans.BookId = _vendInvoiceInfoLine_Asset.AssetBookId;
        AssetBook assetBook = assetBook::find(assetTrans.AssetId, assetTrans.BookId);

        this.validateAssetBookPostingLayer(assetBook, _vendInvoiceJour.LedgerVoucher);

        assetTrans.Voucher = _vendInvoiceJour.LedgerVoucher;
        assetTrans.TransDate = _vendInvoiceTrans.InvoiceDate;
        assetTrans.Txt = enum2str(assetTrans.TransType);

        origAssetTransForCreditNote = this.findOrigAssetTransForCreditNote();

        assetTrans.CurrencyCode = this.getCurrencyCodeFromVendInvoiceTrans();
        assetTrans.AmountCur = this.getAmountCurFromVendInvoiceTrans();

        if (!origAssetTransForCreditNote.RecId)
        {
            this.applyTax(_vendInvoiceInfoLine_Asset, _tax);
            this.applyMiscCharges(_vendInvoiceJour, transExchRateHelper);
        }

        assetTrans.AmountMST = this.getAmountMSTFromVendInvoiceTrans(transExchRateHelper);

        if (Ledger::reportingCurrency())
        {
            assetTrans.ReportingCurrencyAmount = this.getReportingAmountFromVendInvoiceTrans(transExchRateHelper);
        }

        if (!origAssetTransForCreditNote.RecId)
        {
            this.applyLoadOnInventory(_vendInvoiceJour);
        }

        if (isReversePOCurrencyFeatureEnabled
            && !purchLine.isStocked())
        {
            assetTrans.CurrencyCode = Ledger::accountingCurrency();
            assetTrans.AmountCur = assetTrans.AmountMST;
        }

        assetTrans.DefaultDimension = _vendInvoiceTrans.DefaultDimension;

        assetTrans.PostingProfile = AssetBook::find(assetTrans.AssetId, assetTrans.BookId).PostingProfile;

        vendAccount = _vendInvoiceJour.OrderAccount;
        vendInvoiceId = _vendInvoiceJour.InvoiceId;

        isAccountsPayableAcquisition = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePurchInfo</Name>
				<Source><![CDATA[
    private void populatePurchInfo(VendInvoiceTrans _vendInvoiceTrans)
    {
        if (!_vendInvoiceTrans.isNonPO())
        {
            purchLine = _vendInvoiceTrans.purchLine();
            purchId = purchLine.PurchId;

            if (isIsoIT)
            {
                // Set depreciation start date
                depreciationStartDate = purchLine.DepreciationStartDate;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initExchangeRateHelperFromVendInvoiceJour</Name>
				<Source><![CDATA[
    private CurrencyExchangeHelper initExchangeRateHelperFromVendInvoiceJour(
        VendInvoiceJour _vendInvoiceJour,
        TransDate _date)
    {
        CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(assetTrans.companyInfo().RecId),
            _date);
        
        exchRate = _vendInvoiceJour.ExchRate;
        exchRateSecond = _vendInvoiceJour.ExchRateSecondary;
        reportingCurrencyExchRate = _vendInvoiceJour.ReportingCurrencyExchangeRate;

        transExchRateHelper.parmExchangeRate1(exchRate);
        transExchRateHelper.parmExchangeRate2(exchRateSecond);
        transExchRateHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);

        return transExchRateHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrigAssetTransForCreditNote</Name>
				<Source><![CDATA[
    private AssetTrans findOrigAssetTransForCreditNote()
    {
        if (isReversePOCurrencyFeatureEnabled
            && this.isCreditNotePO()
            && purchLine.CurrencyCode != Ledger::accountingCurrency())
        {
            origVendInvoiceTransForCreditNote = AssetTransVendInvoiceTrans::getOrigVendInvoiceTransForCreditNote(purchLine.RecId);

            if (origVendInvoiceTransForCreditNote.RecId
                && purchLine.PurchPrice == origVendInvoiceTransForCreditNote.PurchPrice
                && purchLine.CurrencyCode == origVendInvoiceTransForCreditNote.CurrencyCode)
            {
                origAssetTransForCreditNote = AssetTrans::find(AssetTransVendInvoiceTrans::findByVendInvoiceTrans(origVendInvoiceTransForCreditNote.RecId).AssetTrans);
            }
        }

        return origAssetTransForCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditNotePO</Name>
				<Source><![CDATA[
    private boolean isCreditNotePO()
    {
        return purchLine.AssetId
            && purchLine.PurchQty < 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyCodeFromVendInvoiceTrans</Name>
				<Source><![CDATA[
    private CurrencyCode getCurrencyCodeFromVendInvoiceTrans()
    {
        CurrencyCode currencyCode = vendInvoiceTrans.CurrencyCode;

        if (isReversePOCurrencyFeatureEnabled
            && origAssetTransForCreditNote)
        {
            currencyCode = origAssetTransForCreditNote.CurrencyCode;
        }
        
        return currencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountCurFromVendInvoiceTrans</Name>
				<Source><![CDATA[
    private Amount getAmountCurFromVendInvoiceTrans()
    {
        Amount amountCur = vendInvoiceTrans.LineAmount;

        if (isReversePOCurrencyFeatureEnabled
            && origAssetTransForCreditNote)
        {
            amountCur = origAssetTransForCreditNote.AmountCur / origVendInvoiceTransForCreditNote.Qty * purchLine.PurchQty;
        }
        
        return amountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyTax</Name>
				<Source><![CDATA[
    private void applyTax(
        VendInvoiceInfoLine_Asset _vendInvoiceInfoLine_Asset,
        Tax _tax = null)
    {
        if (_tax)
        {
            assetTrans.AmountCur += _tax.taxInCostPrice(tableNum(VendInvoiceInfoLine), _vendInvoiceInfoLine_Asset.VendInvoiceInfoLineRecId);

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                assetTrans.AmountCur -= _tax.taxInCostPrice_BR(tableNum(VendInvoiceInfoLine), _vendInvoiceInfoLine_Asset.VendInvoiceInfoLineRecId);

                MarkupTrans markupTrans;
                while select RecId from markupTrans
                    where markupTrans.TransTableId == tableNum(VendInvoiceInfoLine)
                        && markupTrans.TransRecId == _vendInvoiceInfoLine_Asset.VendInvoiceInfoLineRecId
                {
                    assetTrans.AmountCur -= _tax.taxInCostPrice_BR(markupTrans.TableId, markupTrans.RecId);
                }
            }
            // </GBR>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyMiscCharges</Name>
				<Source><![CDATA[
    private void applyMiscCharges(
        VendInvoiceJour _vendInvoiceJour,
        CurrencyExchangeHelper _transExchRateHelper)
    {
        AmountMST itemMiscChargesMST = MarkupTrans::getItemMiscChargesAmount(
            vendInvoiceTrans.TableId, vendInvoiceTrans.RecId, _vendInvoiceJour.CurrencyCode,
            Currency::noYes2UnknownNoYes(_vendInvoiceJour.Triangulation), _vendInvoiceJour.ExchRate, _vendInvoiceJour.ExchRateSecondary);

        if (itemMiscChargesMST)
        {
            assetTrans.AmountCur += _transExchRateHelper.calculateAccountingToTransaction(vendInvoiceTrans.CurrencyCode, itemMiscChargesMST, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAmountMSTFromVendInvoiceTrans</Name>
				<Source><![CDATA[
    private Amount getAmountMSTFromVendInvoiceTrans(CurrencyExchangeHelper _transExchRateHelper)
    {
        Amount amountMST = _transExchRateHelper.calculateTransactionToAccounting(assetTrans.CurrencyCode, assetTrans.AmountCur, true);

        if (isReversePOCurrencyFeatureEnabled
            && origAssetTransForCreditNote)
        {
            amountMST = origAssetTransForCreditNote.AmountMST / origVendInvoiceTransForCreditNote.Qty * purchLine.PurchQty;
        }
        
        return amountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReportingAmountFromVendInvoiceTrans</Name>
				<Source><![CDATA[
    private Amount getReportingAmountFromVendInvoiceTrans(CurrencyExchangeHelper _transExchRateHelper)
    {
        Amount amountReporting = _transExchRateHelper.calculateTransactionCurrencyToReportingCurrency(assetTrans.CurrencyCode, assetTrans.AmountCur, true);

        if (isReversePOCurrencyFeatureEnabled
            && origAssetTransForCreditNote)
        {
            amountReporting = origAssetTransForCreditNote.ReportingCurrencyAmount / origVendInvoiceTransForCreditNote.Qty * purchLine.PurchQty;
        }
        
        return amountReporting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyLoadOnInventory</Name>
				<Source><![CDATA[
    private void applyLoadOnInventory(VendInvoiceJour _vendInvoiceJour)
    {
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            AmountMST loadOnInventoryMST;
            AmountCur loadOnInventoryCur;
            [loadOnInventoryMST, loadOnInventoryCur] = this.getLoadOnInventoryFromTaxDocument(_vendInvoiceJour, vendInvoiceTrans);
            assetTrans.AmountMST += loadOnInventoryMST;
            assetTrans.AmountCur += loadOnInventoryCur;

            if (Ledger::reportingCurrency())
            {
                assetTrans.ReportingCurrencyAmount += this.getLoadOnInventoryFromTaxDocumentRep(_vendInvoiceJour, vendInvoiceTrans);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAssetDocumentPostable_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether asset posting with asset document.
    /// </summary>
    /// <returns>
    /// Return ture if the asset posting is with asset document, otherwise, return false.
    /// </returns>
    public boolean isAssetDocumentPostable_JP()
    {
        boolean ret = false;

        if (isAssetDocumentEnable
            && assetDocumentType_JP
            && assetDocumentEntryRecId)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDepreciationFinished</Name>
				<Source><![CDATA[
    private boolean isDepreciationFinished(AssetBook _assetBook)
    {
        boolean retValue;
        AssetSumCalc_Trans assetSumCalc_Trans = AssetSumCalc_Trans::newAssetYear(_assetBook.AssetId, _assetBook.BookId);

        if (assetSumCalc_Trans.acquisitionValue() < 0)
        {
            retValue = this.isDepreciationFinishedWithPositiveAcquisition(_assetBook, assetSumCalc_Trans);
        }
        else
        {
            retValue = this.isDepreciationFinishedWithNegativeAcquisition(_assetBook, assetSumCalc_Trans);
        }

        return retValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDepreciationFinishedWithPositiveAcquisition</Name>
				<Source><![CDATA[
    private boolean isDepreciationFinishedWithPositiveAcquisition(AssetBook _assetBook, AssetSumCalc_Trans _assetSumCalc_Trans)
    {
        boolean isDepreciationFinished = false;

        if (assetTrans.AmountMST > 0
            && _assetBook.AssetBookTable().NetBookValueRest == 0
            && _assetSumCalc_Trans.netBookValue() >= this.getAssetScrapValue(_assetBook))
        {
            isDepreciationFinished = true;
        }

        return isDepreciationFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDepreciationFinishedWithNegativeAcquisition</Name>
				<Source><![CDATA[
    private boolean isDepreciationFinishedWithNegativeAcquisition(AssetBook _assetBook, AssetSumCalc_Trans _assetSumCalc_Trans)
    {
        boolean isDepreciationFinished = false;

        if (assetTrans.AmountMST < 0
            && _assetBook.AssetBookTable().NetBookValueRest == 0
            && _assetSumCalc_Trans.netBookValue() <= this.getAssetScrapValue(_assetBook))
        {
            isDepreciationFinished = true;
        }

        return isDepreciationFinished;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAssetScrapValue</Name>
				<Source><![CDATA[
    private AssetScrapValue getAssetScrapValue(AssetBook _assetBook)
    {
        if (isDepreciationPolicyEnabled_CN)
        {
            return _assetBook.calcAssetScrapValueByDate_CN(assetTrans.TransDate);
        }

        return _assetBook.ScrapValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReductionEntryAcquisition_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether current transaction is reduction entry acquisition transaction.
    /// </summary>
    /// <returns>
    /// If the current transaction is a reduction entry
    /// </returns>
    private boolean isReductionEntryAcquisition_JP()
    {
        boolean ret;

        if (( assetTrans.TransType == AssetTransType::Acquisition
                    && assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_DirectOff)
                || ( assetTrans.TransType == AssetTransType::ReductionEntryReserve_JP
                    && assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_Reserve))
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isVoucherPostingNeededForPurchOrderAcquisitions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if voucher posting should happen given special cases that can occur when asset
    /// is acquired from a purchase order.
    /// </summary>
    /// <param name = "_postVouchers">The current state of whether posting vouchers should happen.</param>
    /// <param name = "_assetBook">The <c>AssetBook</c> that is being posted.</param>
    /// <returns>true if vouchers should be posted; false, otherwise.</returns>
    protected boolean isVoucherPostingNeededForPurchOrderAcquisitions(boolean _postVouchers, AssetBook _assetBook)
    {
        AssetPostPurchaseLineInfo assetPostPurchaseLineInfo;
        boolean isStockedItem;
        
        // For an acquisition transaction that originated from an PO where a direct posting into Fixed Asset is disabled,
        // inventory posting needs to be executed for stocked items.  Posting of the voucher for the offset account specified
        // on the journal is not executed, since the inventory posting already does for the voucher.
        if (_postVouchers
            && (assetTrans.TransType == AssetTransType::Acquisition
            || assetTrans.TransType == AssetTransType::AcquisitionAdj)
            && isInventorySoldTransNeeded
            && assetTable.PurchLineRecId != 0
            && !AssetBookTableDerivedJournal::exist(ledgerJournalTrans.RecId, _assetBook.BookId))
        {
            assetPostPurchaseLineInfo = AssetPost::getPurchaseTransactionAcquisitionInfo(
                    assetTrans.AssetId,
                    assetTrans.BookId,
                    assetTrans.AmountMST,
                    assetTrans.Voucher);

            if (assetPostPurchaseLineInfo)
            {
                isStockedItem = assetPostPurchaseLineInfo.parmIsStockedItem();
                isInventorySoldTransNeeded = assetPostPurchaseLineInfo.parmIsAcquisitionAmountForPO();
            }

            if (isInventorySoldTransNeeded)
            {
                if (isStockedItem)
                {
                    if (assetPostPurchaseLineInfo.parmIsPostFinancialInventory())
                    {
                        _postVouchers = false;
                    }
                }
                else
                {
                    isInventorySoldTransNeeded = false;
                }
            }
        }

        return _postVouchers;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(LedgerVoucher _ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;
        isOneVoucherFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetOneVoucherFeature::instance());
        isReversePOCurrencyFeatureEnabled = FeatureStateProvider::isFeatureEnabled(AssetReversePOForeignCurrencyFeature::instance());

        switch (SysCountryRegionCode::countryInfo())
        {
            case #isoJP:
                isIsoJP = true;
                isAssetDocumentEnable = AssetDocumentUtility_JP::isAssetDocumentEnabled();
                isManuallyChangeDepProfileEnable_JP = AssetParameters::isManuallyChangeDepProfileEnable_JP();
                isAssemblingEnabled_JP = AssetComponent_JP::isAssemblingEnabled();
                break;

            case #isoIN:
                isIsoIN = true;
                checkDepreciationParams_IN = AssetParameters::checkAssetParameters_IN();
                isDepreciationIncomeTaxActEnable_IN = AssetParameters::isDepreciationIncomeTaxActEnable_IN();
                break;

            case #isoRU:
                isIsoRU = true;
                break;

            case #isoIT:
                isIsoIT = true;
                break;

            case #isoPL:
                isIsoPL = true;
                break;

            case #isoCN:
                isIsoCN = true;
                isDepreciationPolicyEnabled_CN = AssetParameters::isDepreciationPolicyEnabled();
                break;

            case #isoCZ:
                isIsoCZ = true;
                break;

            case #isoEE:
                isIsoEE = true;
                break;

            case #isoLT:
                isIsoLT = true;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTransferType_LT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LtAssetTransferType</c> from the journal header.
    /// </summary>
    /// <returns>The <c>LtAssetTransferType</c> type.</returns>
    protected LtAssetTransferType assetTransferType_LT()
    {
        LtAssetTransferType assetTransferType;

        if (isIsoLT)
        {
            assetTransferType = ledgerJournalTrans.ledgerJournalTable().AssetTransferType_LT;
        }

        return assetTransferType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCreditNote</Name>
				<Source><![CDATA[
    public boolean parmIsCreditNote(boolean _isCreditNote = isCreditNote)
    {
        isCreditNote = _isCreditNote;
        return isCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmloadOnInventoryAmount_IN</Name>
				<Source><![CDATA[
    TaxAmountCur  parmloadOnInventoryAmount_IN(TaxAmountCur _loadOnInventory = loadOnInventory)
    {
        loadOnInventory = _loadOnInventory;
        return  loadOnInventory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyAssetStatus</Name>
				<Source><![CDATA[
    private void verifyAssetStatus(AssetBook _assetBook, AssetAllowPreAcquisition_CZ _assetAllowPreAcquisition)
    {
        if (assetTrans.AmountMST < 0
            && _assetBook.Status != AssetStatus::TransferredToLowValuePool
            && AssetSumCalc_Trans::newAssetYear(_assetBook.AssetId, _assetBook.BookId).netBookValue() == 0)
        {
            // If voiding depreciations/acquisitions and net book value is 0, status should be reset.
            _assetBook.LastDepreciationDate = dateNull();
            // <GEEU>
            if (_assetAllowPreAcquisition != AssetAllowPreAcquisition_CZ::No)
            {
                _assetBook.Status = AssetStatus::Acquired_CZ;
            }
            else
            {
                // </GEEU>
                _assetBook.Status = AssetStatus::NoAcquisition;
                // <GEEU>
            }
            // </GEEU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the asset transaction and updates the related <c>AssetTable</c> record and the
    ///    <c>AssetBook</c> record.
    /// </summary>
    /// <param name="_updateLedger">
    ///    A Boolean value that indicates whether to update the general ledger.
    /// </param>
    /// <param name="_autoDerivedPosting">
    ///    A Boolean value that indicates whether to update the derived Value Models and Depreciation Books.
    /// </param>
    /// <param name="postToCurrent">
    /// A Boolean value to determine postTocurrent is true or false
    /// </param>
    /// <param name="postToFAOffset">
    /// A boolean value indicating if the acquisition transaction has to be posted to Fixed asset offset account during
    /// acquisition of an asset through purchase order.
    /// </param>
    public void post(boolean _updateLedger = false,
                     boolean _autoDerivedPosting = true,
                     boolean postToCurrent = false,
                     boolean postToFAOffset = false)
    {
        AssetBook assetBook;
        AssetStatusType assetStatusType;
        AssetParameters assetParameters = AssetParameters::find();
        boolean postVouchers;

        // <GEERU>
        LedgerBondClient_RU ledgerBondClient_RU;
        // </GEERU>
        boolean isAdjustedDepreciationCreated;

        needToUpdateLedger = _updateLedger;

        ttsbegin;

        assetBook = AssetBook::find(assetTrans.AssetId, assetTrans.BookId, true);
        assetTable = AssetTable::find(assetBook.AssetId, true);

        // clean the cache before posting
        AssetCacheManager::removeCacheAssetTrans(assetTrans.AssetId, assetTrans.BookId);

        assetReversalRelatedVoucherManager = this.createAssetReversalRelatedVoucherManager();

        this.calcReductionEntryAdjustment_JP(assetTrans);

        assetStatusType = this.createAssetTransForPost(assetBook);

        this.rereadAssetBook(assetParameters, assetBook);

        postVouchers = this.isVoucherPostingNeededForPurchOrderAcquisitions(needToUpdateLedger, assetBook);

        // <GEELT>
        if (this.assetTransferType_LT() == LtAssetTransferType::NotTransfer)
        {
            // </GEELT>

            isAdjustedDepreciationCreated = this.postForTransType(needToUpdateLedger, _autoDerivedPosting, postToCurrent, postToFAOffset, assetBook, assetParameters);

            // <GJP>
            if (isIsoJP && assetDocumentType_JP != AssetDocumentType_JP::AssetRetirementObligation)
            {
                AssetDepreciationProfile depProfile = assetBook.AssetDepBookMap_JP::depreciationProfileOnDate(assetTrans.TransDate);
                if (depProfile.NumOfYearsEquallyDivided_JP > 0)
                {
                    assetBook.AssetDepBookMap_JP::updateEquallyDividedStartDateForTrans(assetTrans);
                }

                if (!assetBook.AssetRevisedAcquisitionCost_JP
                    && (depProfile.Method == AssetDepreciationMethod::NewDecliningBalance200_JP
                        ||depProfile.Method == AssetDepreciationMethod::NewDecliningBalance250_JP))
                {
                    assetBook.AssetDepBookMap_JP::updateAssetRevisedAcquisitionCost(assetTrans);
                }
            }

            if (isIsoJP)
            {
                if (assetTrans.TransType == AssetTransType::AdditionalDepReserveAllocation_JP)
                {
                    AssetDepDistributionLine_JP::copyDepDistributionLinesByTableIdRecId(
                        tableNum(LedgerJournalTrans_Asset),
                        ledgerjournalTrans_Asset.RecId,
                        tableNum(AssetTrans),
                        assetTrans.RecId,
                        assetTrans.Voucher);
                    AssetDepDistributionLine_JP::updateAmountMST(tableNum(AssetTrans), assetTrans.RecId);
                }
                else if (assetTrans.TransType == AssetTransType::AdditionalDepReserve_JP)
                {
                    AssetDepDistributionLine_JP::updateRefReserve(
                        tableNum(LedgerJournalTrans_Asset),
                        LedgerJournalTrans_Asset.RecId,
                        tableNum(AssetTrans),
                        assetTrans.RecId);
                }
            }
            // </GJP>

            assetBook.update();

            // <GJP>
            if (isAssetDocumentEnable
                && assetTrans.TransType == AssetTransType::ExtraordinaryDepreciation
                && assetDocumentType_JP == AssetDocumentType_JP::AssetAcceleratedDepreciation
                && assetDocumentEntryRecId)
            {
                AssetAcceleratedDepDocumentStatusManager_JP::updateByPostOfAssetDocumentEntry(assetDocumentEntryRecId);
            }
            // </GJP>

            // <GEELT>
        }
        // </GEELT>

        // <GEERU>
        if (isIsoRU)
        {
            ledgerBondClient_RU = ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        }

        if (ledgerBondClient_RU)
        {
            ledgerBondClient_RU.addNewLogObject();
        }
        // </GEERU>

        boolean updateLedger = assetStatusType.updateLedger();

        //Post assembling if necessary
        if (isAssemblingEnabled_JP
            && updateLedger && this.needToAssemble_JP(assetTrans.AssetId, disposalOffsetAccount))
        {
            AssetComponentPost_JP::postAssetComponent_JP(
                ledgerJournalTrans_Asset,
                ledgerJournalTrans,
                assetTrans,
                ledgerVoucher,
                disposalOffsetAccount);
        }

        postingLayer = AssetBookTable::find(assetTrans.BookId).CurrentOperationsTax;

        if (updateLedger)
        {
            if (postVouchers)
            {
                this.postToGeneralLedger(assetBook, isAdjustedDepreciationCreated, postToFAOffset);
            }
            else if (isReversePOCurrencyFeatureEnabled
                && vendInvoiceId
                && postingLayer != CurrentOperationsTax::None
                && !purchLine.isStocked())
            {
                this.postToGLNonStockedItem();
            }
            else if (!assetTrans.LedgerDimension && vendInvoiceId && postingLayer != CurrentOperationsTax::None)
            {
                LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount = this.retrieveDimensionDefaultAccountForPostToGeneralLedger();
                LedgerDimensionAccount ledgerDimensionMerged = this.createLedgerDimension(ledgerDimensionDefaultAccount);
                this.updateLedgerDimension(assetTrans, ledgerDimensionMerged);
            }
        }

        // The last depreciation transaction is reduced if the value model setup
        // contains a net book value amount that shall be left
        this.reduceLastDepreciation(needToUpdateLedger, assetStatusType);

        this.updateAssetTransRevalueId(assetTrans.RevaluedTransID);
        this.updateAssetTransReserveTransId(assetTrans.ReserveTransId);

        // <GJP>
        if (this.isAssetDocumentPostable_JP())
        {
            AssetDocumentProcessor_JP::submitAssetDocument(
                assetDocumentEntryRecId,
                assetTrans.TransType,
                assetTrans.TableId,
                assetTrans.RecId
            );
        }
        // </GJP>

        if (_autoDerivedPosting)
        {
            this.postDerived(assetStatusType.updateLedger());
        }

        // <GEERU>
        if (ledgerBondClient_RU)
        {
            if (ledgerBondClient_RU.currentLogLength() == 2)
            {
                ledgerBondClient_RU.bondLastVRef2CurrentLog();
            }
            ledgerBondClient_RU.removeCurrentLogObject();
        }
        // </GEERU>

        this.saveReversalRelatedVouchers();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToGLNonStockedItem</Name>
				<Source><![CDATA[
    private void postToGLNonStockedItem()
    {
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        CurrencyExchangeHelper exchangeRateHelper = this.getExchangeRateHelper(ledgerVoucherObject);

        LedgerVoucherTransObject ledgerVoucherTransObject = this.getGLTransactionForNonStokedItem(
            ledgerVoucherObject,
            exchangeRateHelper);
    
        ledgerVoucher.addTrans(ledgerVoucherTransObject);

        if (!assetTrans.LedgerDimension)
        {
            this.updateLedgerDimension(assetTrans, ledgerVoucherTransObject.parmLedgerDimensionId());
        }

        LedgerVoucherTransObject ledgerVoucherTransObjectOffset = this.getOffsetGLTransactionForNonStokedItem(
            ledgerVoucherObject,
            exchangeRateHelper);

        ledgerVoucher.addTrans(ledgerVoucherTransObjectOffset);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getGLTransactionForNonStokedItem</Name>
				<Source><![CDATA[
    private LedgerVoucherTransObject getGLTransactionForNonStokedItem(
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = this.instantiateLedgerVoucherTransObjectForPostToGeneralLedger(
            _ledgerVoucherObject,
            any2Enum(LedgerPostingType::FixedAssetsDebit),
            this.getMergedLedgerDimensionForDefaultAccount(),
            assetTrans.CurrencyCode,
            assetTrans.AmountCur,
            _exchangeRateHelper);

        ledgerVoucherTransObject.parmText(assetTrans.Txt);
        ledgerVoucherTransObject.parmPaymentReference(AssetTrans.PaymReference);
        ledgerVoucherTransObject.parmReasonRefRecID(assetTrans.ReasonRefRecId);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOffsetGLTransactionForNonStokedItem</Name>
				<Source><![CDATA[
    private LedgerVoucherTransObject getOffsetGLTransactionForNonStokedItem(
        LedgerVoucherObject _ledgerVoucherObject,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = this.instantiateLedgerVoucherTransObjectForPostToGeneralLedger(
            _ledgerVoucherObject,
            any2Enum(LedgerPostingType::PurchExpense),
            this.getPurchExpenceLedgerDimension(),
            assetTrans.CurrencyCode,
            - assetTrans.AmountCur,
            _exchangeRateHelper);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMergedLedgerDimensionForDefaultAccount</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getMergedLedgerDimensionForDefaultAccount()
    {
        return this.createLedgerDimension(this.retrieveDimensionDefaultAccountForPostToGeneralLedger());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchExpenceLedgerDimension</Name>
				<Source><![CDATA[
    private LedgerDimensionAccount getPurchExpenceLedgerDimension()
    {
        AccountingDistribution accountingDistribution;

        select LedgerDimension from accountingDistribution
            where accountingDistribution.SourceDocumentLine == vendInvoiceTrans.SourceDocumentLine;

        return accountingDistribution.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postForTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs posting for the specific asset transaction type.
    /// </summary>
    /// <param name="_updateLedger">
    /// A Boolean value that indicates whether to update the general ledger.
    /// </param>
    /// <param name="_autoDerivedPosting">
    /// A Boolean value that indicates whether to update the derived Value Models and Depreciation Books.
    /// </param>
    /// <param name="postToCurrent">
    /// A Boolean value to determine postTocurrent is true or false.
    /// </param>
    /// <param name="postToFAOffset">
    /// A boolean value indicating if the acquisition transaction has to be posted to Fixed asset offset account during
    /// acquisition of an asset through purchase order.
    /// </param>
    /// <param name="_assetBook">
    /// An <c>AssetBook</c> record.
    /// </param>
    /// <param name="_assetParameters">
    /// An <c>AssetParameters</c> record.
    /// </param>
    /// <returns>
    /// true if adjusted depreciation was created; otherwise, false.
    /// </returns>
    protected boolean postForTransType(boolean _updateLedger, boolean _autoDerivedPosting, boolean postToCurrent, boolean postToFAOffset, AssetBook _assetBook, AssetParameters _assetParameters)
    {
        boolean isAdjustedDepreciationCreated;

        switch (assetTrans.TransType)
        {
            case AssetTransType::Acquisition:
                isAdjustedDepreciationCreated = this.updatePostCaseForAcquisition(_assetBook, _assetParameters);
                break;
            // <GEEU>
            case AssetTransType::PreAcquisition_CZ:
                this.updatePostCaseForPreAcquisition_CZ(_assetBook);
                break;
            // </GEEU>
            case AssetTransType::AcquisitionAdj:
                isAdjustedDepreciationCreated = this.updatePostCaseForAcquisitionAdj(_assetBook, assetTable);
                break;
            case AssetTransType::CapitalReserveTransfer:
                isAdjustedDepreciationCreated = this.updatePostCaseForCapitalReserveTransfer(_assetBook);
                break;
            case AssetTransType::DisposalScrap:
                this.updatePostCaseForDisposalScrap(_assetBook);
                break;
            case AssetTransType::DisposalSale:
                this.updatePostCaseForDisposalSale(_assetBook);
                break;
            case AssetTransType::DepreciationAdj:
                this.updatePostCaseForDepreciationAdj(_assetBook);
                break;
            case AssetTransType::Depreciation:
            // <GEEPL>
            case AssetTransType::DepreciationNotCost_PL:
                // </GEEPL>
                this.updatePostCaseForDepreciation(_assetBook);
                break;
            case AssetTransType::ExtraordinaryDepreciation:
                this.updatePostCaseForExtraordinaryDepreciation(_assetBook);
                break;
            case AssetTransType::BonusDepreciation:
                this.updatePostCaseForBonusDepreciation(_assetBook);
                break;
            // <GJP>
            case AssetTransType::SpecialDepReserve_JP:
            case AssetTransType::SpecialDepReserveAllocation_JP:
                this.updatePostCaseForSpecialDepReserve_JP(_assetBook);
                break;
            case AssetTransType::AdditionalDepReserve_JP:
                this.updatePostCaseForAdditionalDepReserve_JP(_assetBook);
                break;
            case AssetTransType::AdditionalDepReserveAllocation_JP:
                this.updatePostCaseForAdditionalDepReserveAllocation_JP(_assetBook);
                break;
            case AssetTransType::ReductionEntryReserve_JP:
                this.updatePostCaseForReductionEntryReserve_JP(_assetBook);
                break;
            case AssetTransType::ReductionEntryReserveAllocation_JP:
                this.updatePostCaseForReductionEntryReserveAllocation_JP(_assetBook);
                break;
            // </GJP>
        }

        return isAdjustedDepreciationCreated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger dimension for the specified combination.
    /// </summary>
    /// <param name = "_ledgerDimensionDefaultAccount">
    /// The ID of the <c>DimensionAttributeValueCombination</c> record that specifies the initial dimension.
    /// </param>
    /// <returns>
    /// The ID of the <c>LedgerDimensionAccount</c> record.
    /// </returns>
    protected LedgerDimensionAccount createLedgerDimension(LedgerDimensionDefaultAccount _ledgerDimensionDefaultAccount)
    {
        return LedgerDimensionFacade::serviceApplyFixedAndRecreateLedgerDimension(LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimensionDefaultAccount, assetTrans.DefaultDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToGeneralLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the corresponding General Ledger transactions that are related to this Fixed Assets transaction.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    /// <param name = "_isAdjustedDepreciationCreated">true if adjusted depreciation was created; false, otherwise</param>
    /// <param name = "_postToFAOffset">A boolean value indicating if the acquisition transaction has to be posted to Fixed asset
    /// offset account during acquisition of an asset through purchase order.
    /// </param>
    protected void postToGeneralLedger(
        AssetBook _assetBook,
        boolean _isAdjustedDepreciationCreated,
        boolean _postToFAOffset)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherObject originalLedgerVoucherObject;
        TransDate exchangeRateDate;
         
        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        // parameter postToCurrent is added because it is resulting voucher imbalance without it
        if (ledgerVoucherObject.parmPostingLayer() != postingLayer
            || (isOneVoucherFeatureEnabled 
                && _assetBook.IsTrueUpDepreciation 
                && _isAdjustedDepreciationCreated 
                && depreciationAdjustmentVoucher 
                && ledgerVoucherObject.parmSubledgerVoucher() != assetTrans.Voucher))
        {
            // save the original
            originalLedgerVoucherObject = ledgerVoucherObject;

            // search for a posting voucher for the posting layer
            ledgerVoucherObject = ledgerVoucher.findReference(
                assetTrans.Voucher,
                originalLedgerVoucherObject.parmAccountingDate(),
                postingLayer);

            if (ledgerVoucherObject == null)
            {
                // create a new posting voucher for the posting layer
                ledgerVoucherObject = LedgerVoucherObject::newReference(
                    assetTrans.Voucher,
                    originalLedgerVoucherObject.parmAccountingDate(),
                    originalLedgerVoucherObject.parmSysModule());

                ledgerVoucherObject.parmPostingLayer(postingLayer);
                ledgerVoucherObject.parmAcknowledgementDate(originalLedgerVoucherObject.parmAcknowledgementDate());
                ledgerVoucher.addVoucher(ledgerVoucherObject);
            }
        }

        // Depreciation adjustment created with Acquisition Adjustment needs to have the same voucher number.
        // A validation for a duplicated voucher is not needed.
        if (ledgerVoucherObject
            && _assetBook.IsTrueUpDepreciation
            && _isAdjustedDepreciationCreated)
        {
            ledgerVoucherObject.parmVoucherCheck(false);
        }

        exchangeRateHelper = this.getExchangeRateHelper(ledgerVoucherObject);

        if (assetTrans.LedgerDimension)
        {
            ledgerDimensionMerged = assetTrans.LedgerDimension;
        }
        else
        {
            ledgerDimensionDefaultAccount = this.retrieveDimensionDefaultAccountForPostToGeneralLedger();
            ledgerDimensionMerged = this.createLedgerDimension(ledgerDimensionDefaultAccount);
        }

        ledgerVoucherTransObject = this.instantiateLedgerVoucherTransObjectForPostToGeneralLedger(
                                    ledgerVoucherObject,
                                    (assetTrans.AmountMST
                                    // <GJP>
                                    + reductionEntryAdjustmentMSTVoucher_JP
                                    // </GJP>
                                    > 0 ? any2Enum(LedgerPostingType::FixedAssetsDebit) : any2Enum(LedgerPostingType::FixedAssetsCredit)),
                                    ledgerDimensionMerged,
                                    assetTrans.CurrencyCode,
                                    assetTrans.AmountCur - taxAmountInCostPriceCur
                                    // <GJP>
                                    + reductionEntryAdjustmentCurVoucher_JP
                                    // </GJP>
                                    ,
                                    exchangeRateHelper);

        if (AssetPost::isFixedAssetReportingCurrencyAmountShouldBeUsed(ledgerJournalTrans, ledgerJournalTrans_Asset))
        {
            ledgerVoucherTransObject.parmReportingCurrencyAmount(ledgerJournalTrans_Asset.amountReportingCurrency());
        }

        if (ledgerJournalTrans.canAccountTypeBeTaxed(LedgerJournalACType::FixedAssets) &&
            ((!isOffset && originalLedgerJournalTrans.isPrimaryTaxable()) ||
            (isOffset && originalLedgerJournalTrans.isOffsetTaxable())))
        {
            ledgerVoucherTransObject.parmTaxParentReferenceTableId(ledgerJournalTrans.TableId);
            ledgerVoucherTransObject.parmTaxParentReferenceRecId(ledgerJournalTrans.RecId);
        }
        
        ledgerVoucherTransObject.parmText(assetTrans.Txt);
        ledgerVoucherTransObject.parmPaymentReference(ledgerJournalTrans.PaymReference);
        ledgerVoucherTransObject.parmReasonRefRecID(ledgerJournalTrans.ReasonRefRecID ? ledgerJournalTrans.ReasonRefRecID : assetTrans.ReasonRefRecId);

        if (assetTrans.TransType != AssetTransType::PreAcquisition_CZ)
        {
            exchangeRateDate = _assetBook.exchangeRateDate();
            ledgerVoucherTransObject.parmHistoricalExchangeRateDate(exchangeRateDate ? exchangeRateDate : ledgerJournalTrans.TransDate);
        }

        ledgerVoucher.addTrans(ledgerVoucherTransObject);

        if (!assetTrans.LedgerDimension)
        {
            this.updateLedgerDimension(assetTrans, ledgerVoucherTransObject.parmLedgerDimensionId());
        }

        if (originalLedgerVoucherObject != null)
        {
            // change back to the original posting voucher
            ledgerVoucherObject = ledgerVoucher.findReference(
                originalLedgerVoucherObject.parmSubledgerVoucher(),
                originalLedgerVoucherObject.parmAccountingDate(),
                originalLedgerVoucherObject.parmPostingLayer());

            Debug::assert(ledgerVoucherObject != null);
            originalLedgerVoucherObject = null;
        }

        if (_postToFAOffset && (assetTrans.TransType == AssetTransType::Acquisition
            // <GJP>
            || assetTrans.TransType ==  AssetTransType::ReductionEntryReserve_JP)
            // </GJP>
            )
        {
            this.postToFixedAssetOffset(assetTrans);
        }

        // <GJP>
        if (isAssetDocumentEnable && reductionEntryAdjustment_JP
            && this.isReductionEntryAcquisition_JP())
        {
            AssetReductionEntryManager_JP::postReductionEntryAdjustment(
                assetTrans,
                assetTable,
                ledgerJournalTrans,
                ledgerVoucher,
                exchRate,
                exchRateSecond,
                assetDocumentType_JP,
                assetDocumentEntryRecId,
                reductionEntryAdjustment_JP,
                reductionEntryAdjustmentCurrentPeriod_JP);
        }
        // </GJP>
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveDimensionDefaultAccountForPostToGeneralLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the ledger dimension to which to post for a transaction.
    /// </summary>
    /// <returns>
    /// The ledger dimension.
    /// </returns>
    [Wrappable]
    final protected LedgerDimensionDefaultAccount retrieveDimensionDefaultAccountForPostToGeneralLedger()
    {
        return AssetLedgerAccounts::assetLedgerDimension(
                   assetTable.AssetId,
                   assetTrans.BookId,
                   assetTrans.TransType,
                   assetTrans.PostingProfile
                   // <GJP>
                   , assetDocumentType_JP
                   , assetDocumentEntryRecId
                   // </GJP>
                   );
    }

]]></Source>
			</Method>
			<Method>
				<Name>instantiateLedgerVoucherTransObjectForPostToGeneralLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>LedgerVoucherTransObject</c> class for the postToGeneralLedger method.
    /// </summary>
    /// <param name="_defaultLedgerPostingReference">
    ///    The ledger posting reference to use for defaulting.
    /// </param>
    /// <param name="_postingType">
    ///    The posting type of the general journal entry.
    /// </param>
    /// <param name="_ledgerDimensionId">
    ///    The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name="_transactionCurrencyAmount">
    ///    The amount in the transaction currency.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <returns>
    ///    A new instance of the <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    /// <remarks>
    ///    The default ledger posting reference is used to set the transaction type and exchange rate date.
    /// </remarks>
    protected LedgerVoucherTransObject instantiateLedgerVoucherTransObjectForPostToGeneralLedger(
        LedgerVoucherObject _defaultLedgerPostingReference,
        LedgerPostingType _postingType,
        LedgerDimensionAccount _ledgerDimensionId,
        CurrencyCode _transactionCurrencyCode,
        Money _transactionCurrencyAmount,
        CurrencyExchangeHelper _exchangeRateHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                            _defaultLedgerPostingReference,
                                            _postingType,
                                            _ledgerDimensionId,
                                            _transactionCurrencyCode,
                                            _transactionCurrencyAmount,
                                            _exchangeRateHelper);
        ledgerVoucherTransObject.parmFinTag(finTag);
        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetTransRevalueId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update whether revaluation has been performed on the asset transaction.
    /// </summary>
    /// <param name = "_revaluedTransId">The revaluation transaction record Id.</param>
    protected void updateAssetTransRevalueId(RecId _revaluedTransId)
    {
        AssetTrans assetTransactions;
        
        if (_revaluedTransId)
        {
            select firstonly forupdate assetTransactions
                where assetTransactions.RecId == _revaluedTransId;

            if (assetTransactions)
            {
                assetTransactions.RevaluationDone = !assetTransactions.RevaluationDone;
                assetTransactions.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetTransReserveTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update whether a reserver transfer has been performed on the asset transaction.
    /// </summary>
    /// <param name = "_reserveTransId">The reserve transfer transaction record Id.</param>
    protected void updateAssetTransReserveTransId(RecId _reserveTransId)
    {
        AssetTrans assetTransactions;
        
        if (_reserveTransId)
        {
            select firstonly forupdate assetTransactions
                   where assetTransactions.RecId == _reserveTransId;

            if (assetTransactions)
            {
                assetTransactions.ReserveTransferDone = NoYes::Yes;
                assetTransactions.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>post_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post the asset transaction.
    /// </summary>
    /// <param name="_updateLedger">
    /// A boolean value whether the ledger book should be updated or not.
    /// </param>
    /// <param name="_autoDerivedPosting">
    /// A boolean value whether the value models derived from this asset should also be updated.
    /// </param>
    public void post_IN(boolean _updateLedger = false,
                        boolean _autoDerivedPosting = true)
    {
        AssetGroupTrans_IN assetTransactions;
        AssetGroupInformation_IN locAssetGroupInformation;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        LedgerDimensionAccount ledgerDimensionMerged;
        CurrencyExchangeHelper exchangeRateHelper;

        ttsbegin;
        assetGroupInformation.insert();

        assetGroupTrans.AssetGroupInformation = assetGroupInformation.RecId;
        assetGroupTrans.insert();

        if (_updateLedger)
        {
            ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

            ledgerDimensionDefaultAccount = AssetLedgerAccounts::assetLedgerDimension(
                                                assetGroupTrans.AssetId,
                                                assetGroupTrans.BookId,
                                                assetGroupInformation.TransType,
                                                assetGroupTrans.PostingProfile);

            ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, assetGroupTrans.DefaultDimension);

            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                                                                         ledgerVoucherObject.parmAccountingDate());
            exchangeRateHelper.parmExchangeRate1(exchRate);
            exchangeRateHelper.parmExchangeRate2(exchRateSecond);

            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                            ledgerVoucherObject,
                                            (assetGroupInformation.AmountMst > 0 ? any2Enum(LedgerPostingType::FixedAssetsDebit) : any2Enum(LedgerPostingType::FixedAssetsCredit)),
                                            ledgerDimensionMerged,
                                            assetGroupInformation.CurrencyCode,
                                            assetGroupInformation.AmountCur - taxAmountInCostPriceCur,
                                            exchangeRateHelper);

            ledgerVoucherTransObject.parmSourceTableId(ledgerJournalTrans.TableId);
            ledgerVoucherTransObject.parmSourceRecId(ledgerJournalTrans.RecId);

            ledgerVoucherTransObject.parmText(ledgerJournalTrans.Txt);
            ledgerVoucherTransObject.parmPaymentReference(ledgerJournalTrans.PaymReference);
            ledgerVoucherTransObject.parmReasonRefRecID(ledgerJournalTrans.ReasonRefRecID);
            ledgerVoucherTransObject.parmFinTag(ledgerJournalTrans.FinTag);
            ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        // The last depreciation transaction is reduced if the value model setup
        // contains a net book value amount that shall be left
        if (assetGroupTrans.RevaluedTransID)
        {
            select firstonly assetTransactions
                where assetTransactions.RecId == assetGroupTrans.RevaluedTransID;

            if (assetTransactions)
            {
                locAssetGroupInformation = AssetGroupInformation_IN::find(assetTransactions.AssetGroupInformation, true);
            }

            if (locAssetGroupInformation)
            {
                locAssetGroupInformation.RevaluationDone = !assetGroupInformation.RevaluationDone;
                locAssetGroupInformation.update();
            }
        }

        if (assetGroupTrans.ReserveTransId)
        {
            select firstonly assetTransactions
                   where assetTransactions.RecId == assetGroupTrans.ReserveTransId;

            if (assetTransactions)
            {
                locAssetGroupInformation = AssetGroupInformation_IN::find(assetTransactions.AssetGroupInformation, true);
            }

            if (locAssetGroupInformation)
            {
                locAssetGroupInformation.ReserveTransferDone = NoYes::Yes;
                locAssetGroupInformation.update();
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postDerived</Name>
				<Source><![CDATA[
    void postDerived(boolean _updateLedger = false)
    {
        AssetBookId assetBookId = assetTrans.BookId;
        AssetTransType assetTransType = assetTrans.TransType;
        AssetBookTableDerived assetBookTableDerived;
        AssetBookTable assetBookTable;
        AssetBook assetBook;
        // <GJP>
        AssetDocumentType_JP assetDocumentTypeLoc;
        AssetDocumentRecId_JP assetDocumentEntryRecIdLoc;
        AssetTransType assetTransTypeLoc;
        LedgerVoucherObject ledgerVoucherObject;
        // </GJP>

        boolean tempUpdateLedger = _updateLedger;
        this.parmIsDerivedBookPosting(true);

        while select BookIdDerived from assetBookTableDerived
            where assetBookTableDerived.BookId == assetBookId
               && assetBookTableDerived.AssetTransType == assetTransType
        join CurrentOperationsTax from assetBookTable
            where assetBookTable.BookId == assetBookTableDerived.BookIdDerived
        join IsDerogatoryBook_FR, AssetGroupDepreciation_IN from assetBook
            where assetBook.AssetId == assetTable.AssetId
               && assetBook.BookId == assetBookTable.BookId
        {
            assetTrans.BookId = assetBookTableDerived.BookIdDerived;
            assetTrans.LedgerDimension = 0;
            assetTrans.RecId = 0;

            _updateLedger = tempUpdateLedger;
            // Clean up cash disc originator for derived value models
            assetTrans.CashDiscBaseTransId = 0;
            assetTrans.CashDiscBaseAmountMST = 0;

            //If this is a derogatory book, prevent posting into GL.
            if (assetBook.IsDerogatoryBook_FR)
            {
                _updateLedger = false;
            }

            if (!assetBookTable.postToGeneralLedger())
            {
                _updateLedger = false;
            }

            // <GJP>
            if (isAssetDocumentEnable
                && assetDocumentType_JP
                && (assetDocumentEntryRecId
                    || AssetDocumentUtility_JP::isDocumentTypeWithoutEntry(assetDocumentType_JP)))
            {
                assetDocumentTypeLoc = assetDocumentType_JP;
                assetDocumentEntryRecIdLoc = assetDocumentEntryRecId;
                assetTransTypeLoc = assetTrans.TransType;
                this.refreshAssetDocumentDerived_JP();
            }

            if (assetDocumentTypeLoc == AssetDocumentType_JP::None
                || !assetDocumentEntryRecIdLoc
                || AssetDocumentUtility_JP::isDocumentTypeWithoutEntry(assetDocumentType_JP)
                || this.isAssetDocumentPostable_JP())
            {
                // </GJP>
                if (isDepreciationIncomeTaxActEnable_IN && assetBook.AssetGroupDepreciation_IN == NoYes::Yes)
                {
                    this.initGroupDataFromAssetTrans_IN();
                }

                this.post(_updateLedger, false);

                if (_updateLedger)
                {
                    ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
                    this.postToFixedAssetOffset(assetTrans, ledgerVoucherObject.parmVoucherCheck());
                }
                // <GJP>
            }
            if (isAssetDocumentEnable
                && assetDocumentTypeLoc
                && (assetDocumentEntryRecIdLoc
                    || AssetDocumentUtility_JP::isDocumentTypeWithoutEntry(assetDocumentType_JP)))
            {
                assetDocumentType_JP = assetDocumentTypeLoc;
                assetDocumentEntryRecId = assetDocumentEntryRecIdLoc;
                assetTrans.TransType = assetTransTypeLoc;
            }
            // </GJP>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToFixedAssetOffset</Name>
				<Source><![CDATA[
    private void postToFixedAssetOffset(AssetTrans _assetTrans, boolean _validateVoucher = true)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherObject originalLedgerVoucherObject;
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        CurrentOperationsTax postingLayerForOffset = AssetBookTable::find(_assetTrans.BookId).CurrentOperationsTax;

        if (ledgerVoucherObject.parmPostingLayer() != postingLayerForOffset)
        {
            // save the original
            originalLedgerVoucherObject = ledgerVoucherObject;

            // search for a posting voucher for the posting layer
            ledgerVoucherObject = ledgerVoucher.findReference(
                originalLedgerVoucherObject.parmSubledgerVoucher(),
                originalLedgerVoucherObject.parmAccountingDate(),
                postingLayerForOffset);

            if (ledgerVoucherObject == null)
            {
                // create a new posting voucher for the posting layer
                ledgerVoucherObject = LedgerVoucherObject::newReference(
                    originalLedgerVoucherObject.parmSubledgerVoucher(),
                    originalLedgerVoucherObject.parmAccountingDate(),
                    originalLedgerVoucherObject.parmSysModule());

                ledgerVoucherObject.parmPostingLayer(postingLayerForOffset);
                ledgerVoucher.addVoucher(ledgerVoucherObject);
            }
        }

        ledgerVoucherObject.parmVoucherCheck(_validateVoucher);

        exchangeRateHelper = this.getExchangeRateHelper(ledgerVoucherObject);

        ledgerDimensionDefaultAccount = this.getDefaultAssetLedgerDimensionAccount(_assetTrans);

        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, assetTrans.DefaultDimension);

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                    ledgerVoucherObject,
                                    ((-_assetTrans.AmountCur) > 0 ? any2Enum(LedgerPostingType::FixedAssetsDebit) : any2Enum(LedgerPostingType::FixedAssetsCredit)),
                                    ledgerDimensionMerged,
                                    _assetTrans.CurrencyCode,
                                    -_assetTrans.AmountCur,
                                    exchangeRateHelper);
        ledgerVoucherTransObject.parmSourceTableId(_assetTrans.TableId);
        ledgerVoucherTransObject.parmSourceRecId(_assetTrans.RecId);
        ledgerVoucherTransObject.parmReasonRefRecID(_assetTrans.ReasonRefRecId);
        ledgerVoucherTransObject.parmPaymentReference(_assetTrans.PaymReference);

        this.addTransIntoLedgerVoucherObject(ledgerVoucherTransObject, ledgerVoucherObject);

        if (originalLedgerVoucherObject != null)
        {
            // change back to the original posting voucher
            ledgerVoucherObject = ledgerVoucher.findReference(
                originalLedgerVoucherObject.parmSubledgerVoucher(),
                originalLedgerVoucherObject.parmAccountingDate(),
                originalLedgerVoucherObject.parmPostingLayer());

            Debug::assert(ledgerVoucherObject != null);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAssetLedgerDimensionAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger dimension used for posting a fixed assets offset transaction.
    /// </summary>
    /// <param name = "_assetTrans">The <c>AssetTrans</c> table buffer.</param>
    /// <returns>The ledger dimension used for posting a fixed assets offset transaction.</returns>
    protected LedgerDimensionDefaultAccount getDefaultAssetLedgerDimensionAccount(AssetTrans _assetTrans)
    {
        return AssetLedgerAccounts::assetOffsetLedgerDimension(
            _assetTrans.AssetId,
            _assetTrans.BookId,
            _assetTrans.TransType,
            _assetTrans.PostingProfile,
            // <GJP> 
            false,
            assetDocumentType_JP
            // </GJP>
        );
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateAssetTransForReduceLastDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>AssetTrans</c> table buffer when the last depreciation transaction is reduced if the value model setup contains a net book value amount that shall be left.
    /// </summary>
    /// <param name = "_netBookValueRest">
    /// The Leave net book value of Asset book.
    /// </param>
    /// <returns>
    /// Returns the updated <c>AssetTrans</c> table buffer with transaction and reporting currency amount to reduce last depreciation.
    /// </returns>
    [Wrappable(true)]
    final protected AssetTrans populateAssetTransForReduceLastDepreciation(AmountMST _netBookValueRest)
    {
        AssetTrans newAssetTrans = assetTrans.data();
        newAssetTrans.AmountMST = CurrencyExchangeHelper::amount(_netBookValueRest);

        if (newAssetTrans.CurrencyCode == Ledger::accountingCurrency())
        {
            newAssetTrans.AmountCur = newAssetTrans.AmountMST;
        }
        else
        {
            newAssetTrans.AmountCur = CurrencyExchangeHelper::curAmount(newAssetTrans.AmountMST, newAssetTrans.CurrencyCode, newAssetTrans.TransDate);
        }

        if (Ledger::reportingCurrency())
        {
            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), newAssetTrans.TransDate);
            newAssetTrans.ReportingCurrencyAmount = currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(newAssetTrans.CurrencyCode, newAssetTrans.AmountCur, true);
        }

        return newAssetTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reduceLastDepreciation</Name>
				<Source><![CDATA[
    public void reduceLastDepreciation(boolean _updateLedger, AssetStatusType _assetStatusType)
    {
        AssetTrans newAssetTrans;
        AmountMST netBookValueRest;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerDimensionAccount ledgerDimensionMerged;
        LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
        CurrencyExchangeHelper exchangeRateHelper;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherObject originalLedgerVoucherObject;
        TransDate exchangeRateDate;

        if (assetTrans.TransType == AssetTransType::Depreciation)
        {
            netBookValueRest = this.getNetBookValueRest();

            if (netBookValueRest != 0)
            {
                if (AssetSumCalc_Trans::newAssetYear(assetTrans.AssetId, assetTrans.BookId).netBookValue() == 0)
                {
                    ttsbegin;
                    newAssetTrans = this.populateAssetTransForReduceLastDepreciation(netBookValueRest);

                    newAssetTrans.insert();

                    if (_updateLedger && _assetStatusType.updateLedger())
                    {
                        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

                        if (ledgerVoucherObject.parmPostingLayer() != postingLayer)
                        {
                            // save the original
                            originalLedgerVoucherObject = ledgerVoucherObject;

                            // search for a posting voucher for the posting layer
                            ledgerVoucherObject = ledgerVoucher.findReference(
                                originalLedgerVoucherObject.parmSubledgerVoucher(),
                                originalLedgerVoucherObject.parmAccountingDate(),
                                postingLayer);

                            if (ledgerVoucherObject == null)
                            {
                                // create a new posting voucher for the posting layer
                                ledgerVoucherObject = LedgerVoucherObject::newReference(
                                    originalLedgerVoucherObject.parmSubledgerVoucher(),
                                    originalLedgerVoucherObject.parmAccountingDate(),
                                    originalLedgerVoucherObject.parmSysModule());

                                ledgerVoucherObject.parmPostingLayer(postingLayer);
                                ledgerVoucher.addVoucher(ledgerVoucherObject);
                            }
                        }

                        exchangeRateHelper = this.getExchangeRateHelper(ledgerVoucherObject);

                        ledgerDimensionDefaultAccount = AssetLedgerAccounts::assetLedgerDimension(
                                                            assetTable.AssetId,
                                                            newAssetTrans.BookId,
                                                            newAssetTrans.TransType,
                                                            newAssetTrans.PostingProfile);

                        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, newAssetTrans.DefaultDimension);

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucherObject,
                                                    LedgerPostingType::FixedAssetsDebit,
                                                    ledgerDimensionMerged,
                                                    newAssetTrans.CurrencyCode,
                                                    newAssetTrans.AmountCur,
                                                    exchangeRateHelper);
                        ledgerVoucherTransObject.parmSourceTableId(newAssetTrans.TableId);
                        ledgerVoucherTransObject.parmSourceRecId(newAssetTrans.RecId);
                        ledgerVoucherTransObject.parmReasonRefRecID(newAssetTrans.ReasonRefRecId);
                        exchangeRateDate = AssetBook::find(newAssetTrans.AssetId, newAssetTrans.BookId).exchangeRateDate();
                        ledgerVoucherTransObject.parmText(newAssetTrans.Txt);

                        ledgerVoucherTransObject.parmHistoricalExchangeRateDate(exchangeRateDate? exchangeRateDate : newAssetTrans.TransDate);

                        ledgerVoucher.addTrans(ledgerVoucherTransObject);

                        ledgerDimensionDefaultAccount = AssetLedgerAccounts::assetOffsetLedgerDimension(
                                                            assetTable.AssetId,
                                                            newAssetTrans.BookId,
                                                            newAssetTrans.TransType,
                                                            newAssetTrans.PostingProfile);

                        ledgerDimensionMerged = LedgerDimensionFacade::serviceCreateLedgerDimension(ledgerDimensionDefaultAccount, newAssetTrans.DefaultDimension);

                        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                    ledgerVoucherObject,
                                                    LedgerPostingType::FixedAssetsCredit,
                                                    ledgerDimensionMerged,
                                                    newAssetTrans.CurrencyCode,
                                                    - newAssetTrans.AmountCur,
                                                    exchangeRateHelper);
                        ledgerVoucherTransObject.parmSourceTableId(newAssetTrans.TableId);
                        ledgerVoucherTransObject.parmSourceRecId(newAssetTrans.RecId);
                        ledgerVoucherTransObject.parmReasonRefRecID(newAssetTrans.ReasonRefRecId);
                        ledgerVoucherTransObject.parmPaymentReference(newAssetTrans.PaymReference);
                        ledgerVoucher.addTrans(ledgerVoucherTransObject);

                        if (originalLedgerVoucherObject != null)
                        {
                            // change back to the original posting voucher
                            ledgerVoucherObject = ledgerVoucher.findReference(
                                originalLedgerVoucherObject.parmSubledgerVoucher(),
                                originalLedgerVoucherObject.parmAccountingDate(),
                                originalLedgerVoucherObject.parmPostingLayer());

                            Debug::assert(ledgerVoucherObject != null);
                            originalLedgerVoucherObject = null;
                        }
                    }

                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNetBookValueRest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Leave net book value of Asset book.
    /// </summary>
    /// <returns>
    /// Returns the Leave net book value.
    /// </returns>
    [Wrappable(true)]
    final protected AmountMST getNetBookValueRest()
    {
        return AssetBook::find(assetTrans.AssetId, assetTrans.BookId).getNetBookValueRest(AssetBookTable::find(assetTrans.BookId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>refreshAssetDocumentDerived_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Refresh <c>assetDocumentType_JP</c> and <c>assetDocumentRecId</c> for derived posting
    /// </summary>
    /// <returns>
    /// Returns asset document type and asset document entry id.
    /// </returns>
    public container refreshAssetDocumentDerived_JP()
    {
        AssetDocument_JP documentLoc;

        if (assetTrans.AssetId
            && assetTrans.BookId)
        {
            if (assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_DirectOff
                || assetDocumentType_JP == AssetDocumentType_JP::AssetReductionEntry_Reserve)
            {
                documentLoc = AssetReductionEntryManager_JP::getAssetReductionEntryDocByAssetBook(
                                assetTrans.AssetId, assetTrans.BookId);

                if (documentLoc != null)
                {
                    assetDocumentType_JP = documentLoc.parmAssetDocumentTable().Type;
                    assetDocumentEntryRecId = documentLoc.parmAssetDocumentEntry().RecId;

                    if (assetDocumentEntryRecId)
                    {
                        if (ledgerJournalTrans_Asset.RecId)
                        {
                            assetTrans.TransType = AssetPost::assetTransTypeJournal2AssetTransType(
                                                        ledgerJournalTrans_Asset.TransType
                                                        ,assetDocumentType_JP);
                        }
                        else if (vendInvoiceInfoLineAsset.RecId)
                        {
                            assetTrans.TransType = AssetDocumentUtility_JP::assetTransTypePurch2AssetTransType(
                                                          vendInvoiceInfoLineAsset.AssetTransTypePurch,
                                                          assetDocumentType_JP);
                        }
                    }
                }
                else
                {
                    assetDocumentType_JP = AssetDocumentType_JP::None;
                    assetDocumentEntryRecId = 0;
                }
            }

            if (assetDocumentType_JP == AssetDocumentType_JP::AssetRetirementObligation)
            {
                assetDocumentEntryRecId = AssetDocumentEntry_JP::findByDocumentAssetIdBookId(
                    AssetDocumentEntry_JP::find(assetDocumentEntryRecId).AssetDocumentTable_JP,
                    assetTrans.AssetId,
                    assetTrans.BookId).RecId;
            }
        }

        return [assetDocumentType_JP, assetDocumentEntryRecId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>rereadAssetBook</Name>
				<Source><![CDATA[
    private void rereadAssetBook(AssetParameters _assetParameters, AssetBook _assetBook)
    {
        if (isDepreciationPolicyEnabled_CN)
        {
            _assetBook.reread();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDepreciationStartDate</Name>
				<Source><![CDATA[
    private AssetBook setDepreciationStartDate(TransDate _depreciationStartDate, AssetBook _assetBook)
    {
        // Set depreciation start date for italy
        if (isIsoIT
            && _depreciationStartDate
            && _assetBook.DepreciationConvention == AssetDepreciationConvention::None)
        {
            _assetBook.DepreciationStartDate = _depreciationStartDate;
        }
        return _assetBook;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAcquisitionForPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates asset acquisition information for an <c>AssetBook</c> table buffer during posting.
    /// </summary>
    /// <param name="_assetBook">
    /// The <c>AssetBook</c> buffer to update.
    /// </param>
    /// <remarks>
    /// This is a support method for the <c>AssetPost.post</c> method.
    /// </remarks>
    protected void updateAcquisitionForPost(AssetBook _assetBook)
    {
        LedgerJournalTable ledgerJournalTable;

        if (_assetBook.Status == AssetStatus::NoAcquisition
            // <GEEU>
            || _assetBook.Status == AssetStatus::Acquired_CZ
            // </GEEU>
            )
        {
            _assetBook.Status = AssetStatus::Open;
            _assetBook.AcquisitionPrice = assetTrans.AmountMST;
            _assetBook.AcquisitionPriceReportingCurrency = assetTrans.ReportingCurrencyAmount;
            _assetBook.DefaultDimension = _assetBook.DefaultDimension ? _assetBook.DefaultDimension : assetTrans.DefaultDimension;
            // <GJP>
            if (isIsoJP)
            {
                _assetBook.calcLifeTime();
            }
            // </GJP>
            ledgerJournalTable = LedgerJournalTable::find(ledgerJournalTrans.JournalNum);

            // Verify if the transction originated from the Split of the asset.
            if (ledgerJournalTrans_Asset.AssetTransSubType != AssetTransactionSubType::Split
                || ledgerJournalTable.Name != "@SYS67430" && !_assetBook.IsMigratedAsset)
            {
                // If the Place in service is different from Acquisition date on the value model,
                // Place in service value is not updated, however, the Acquisition date is update with
                // the value from the transaction.
                // If the acquisition date and place in service on the value model are the same,
                // the Acquisition date from the transaction will be assigned to these columns.
                if (_assetBook.acquisitionDate && _assetBook.UsedFromDate)
                {
                    if (_assetBook.acquisitionDate == _assetBook.UsedFromDate)
                    {
                        _assetBook.UsedFromDate = assetTrans.TransDate;
                    }
                }
                else
                {
                    // Place in service is not required value on the value model record.
                    // In case the value is not provided, assign the Acquisition date.
                    if (!_assetBook.UsedFromDate)
                    {
                        _assetBook.UsedFromDate = assetTrans.TransDate;
                    }
                }

                _assetBook.calcDepreciationStartDate();
            }

            if (!isIsoIT
                || (ledgerJournalTable.Name != "@SYS67430"
                || ledgerJournalTrans_Asset.AssetTransSubType != AssetTransactionSubType::Split))
            {
                _assetBook.AcquisitionDate = assetTrans.TransDate;
            }
        }
        else
        {
            _assetBook.AcquisitionPrice = AssetTrans::acquisitionAmount(_assetBook.AssetId, dateMax(), _assetBook.BookId);
            _assetBook.AcquisitionPriceReportingCurrency = AssetTrans::acquisitionAmountReportingCurrency(_assetBook.AssetId, dateMax(), _assetBook.BookId);
        }

        //Update the asset for low value pool transfers
        if (assetTrans.LVPTransferId_AU)
        {
            _assetBook.Status = AssetStatus::TransferredToLowValuePool;
            _assetBook.LVPTransferId_AU = assetTrans.LVPTransferId_AU;
            _assetBook.LVPTransferDate_AU = assetTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFromPurchParmLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>AssetTable</c> table buffer from values in the <c>PurchParmLine</c> table
    /// </summary>
    /// <param name="_assetTable">
    ///    An <c>AssetTable</c> table buffer.
    /// </param>
    protected void updateFromPurchParmLine(AssetTable _assetTable)
    {
        PurchParmLine purchParmLine;
        PurchParmLine_Asset purchParmLine_Asset;

        if (_assetTable.PurchLineRecId)
        {
            purchParmLine = PurchParmLine::findByPurchLineRefRecId(assetTable.PurchLineRecId);
        }
        if (purchParmLine)
        {
            purchParmLine_Asset = purchParmLine.purchParmLine_Asset(true);

            if ((assetTrans.TransType == AssetTransType::Acquisition)
                && (assetTable.Quantity == 0)
                && (purchParmLine.ReceiveNow > 0))
            {
                assetTable.UnitCost = purchParmLine.amountMST(purchParmLine.PurchPrice,
                                                        purchParmLine.purchParmTable().TransDate) ;
                assetTable.UnitOfMeasure = PurchLine::findRecId(purchParmLine.PurchLineRecId).PurchUnit;
                assetTable.Quantity = purchParmLine.ReceiveNow;
                assetTable.doUpdate();
            }

            purchParmLine_Asset.AssetAcquired = NoYes::Yes;
            purchParmLine_Asset.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFromVendInvoiceInfoLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>AssetTable</c> table buffer based on values from the <c>VendInvoiceInfoline</c>
    ///    table.
    /// </summary>
    /// <param name="_assetTable">
    ///    An <c>AssetTable</c> table buffer.
    /// </param>
    protected void updateFromVendInvoiceInfoLine(AssetTable _assetTable)
    {
        VendInvoiceInfoLine vendInvoiceInfoLine;

        if (_assetTable.PurchLineRecId)
        {
            vendInvoiceInfoLine =  VendInvoiceInfoLine::findByPurchLineRefRecId(assetTable.PurchLineRecId);
        }
        
        if (vendInvoiceInfoLine)
        {
            this.updateAssetTableInfo(vendInvoiceInfoLine);
            this.updateVendInvoiceInfoLineAssetInfo(vendInvoiceInfoLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetTableInfo</Name>
				<Source><![CDATA[
    private void updateAssetTableInfo(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        if (assetTrans.TransType == AssetTransType::Acquisition
            && _vendInvoiceInfoLine.ReceiveNow > 0
            && !this.parmIsDerivedBookPosting())
        {
            assetTable.UnitCost = _vendInvoiceInfoLine.amountMST(
                _vendInvoiceInfoLine.PurchPrice,
                _vendInvoiceInfoLine.vendInvoiceInfoTable().TransDate);
            assetTable.UnitOfMeasure = PurchLine::findRecId(_vendInvoiceInfoLine.PurchLineRecId).PurchUnit;
            assetTable.Quantity = _vendInvoiceInfoLine.ReceiveNow;
            assetTable.update();
        }
        else if (assetTrans.TransType == AssetTransType::Acquisition
            && _vendInvoiceInfoLine.ReceiveNow < 0
            && !this.parmIsDerivedBookPosting())
        {
            assetTable.Quantity = assetTable.Quantity + _vendInvoiceInfoLine.ReceiveNow;
            assetTable.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendInvoiceInfoLineAssetInfo</Name>
				<Source><![CDATA[
    private void updateVendInvoiceInfoLineAssetInfo(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        VendInvoiceInfoLine_Asset vendInvoiceInfoLine_Asset = VendInvoiceInfoLine_Asset::findByVendInvoiceInfoLineRecId(_vendInvoiceInfoLine.RecId, true);
        vendInvoiceInfoLine_Asset.AssetAcquired = NoYes::Yes;
        vendInvoiceInfoLine_Asset.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForAcquisition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// acquisition.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    /// <param name = "_assetParameters">The related <c>AssetParameter</c> record.</param>
    /// <returns>true if adjusted depreciation is created; false, otherwise.</returns>
    protected boolean updatePostCaseForAcquisition(AssetBook _assetBook, AssetParameters _assetParameters)
    {
        boolean isAdjustedDepreciationCreatedLocal;
        
        if ((isInventorySoldTransNeeded) && (assetTable.PurchLineRecId != 0) &&
            !(AssetBookTableDerivedJournal::exist(ledgerJournalTrans.RecId, _assetBook.BookId)))
        {
            // Create an inventory sold transaction after posting an invoice
            // if it isn't created before with a fixed asset
            this.createInventorySoldTransaction();
        }

        this.updateVendInformation(_assetBook);
        this.updateFromVendInvoiceInfoLine(assetTable);
        this.updateAcquisitionForPost(_assetBook);

        // Make sure the transaction did not originate from the Split of the asset.
        if (!ledgerJournalTrans_Asset.isSplitTransaction())
        {
            // <GJP>
            // For reduction entry direct-off method, no need to create true up depreciation
            if (!isAssetDocumentEnable
                || assetDocumentType_JP != AssetDocumentType_JP::AssetReductionEntry_DirectOff
                || !assetDocumentEntryRecId)
            {
                // </GJP>
                isAdjustedDepreciationCreatedLocal = this.createTrueUpDepreciation(_assetBook);
                // <GJP>
            }
            // </GJP>
        }

        this.verifyAssetStatus(_assetBook, _assetParameters.AllowPreAcquisition_CZ);

        _assetBook = this.setDepreciationStartDate(depreciationStartDate, _assetBook);

        return isAdjustedDepreciationCreatedLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendInformation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates of fixed asset book.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    internal void updateVendInformation(AssetBook _assetBook)
    {
        _assetBook.PurchId = purchId;
        _assetBook.VendAccount = vendAccount;
        _assetBook.VendInvoiceId = vendInvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForPreAcquisition_CZ</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>PreAcquisition_CZ</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForPreAcquisition_CZ(AssetBook _assetBook)
    {
        if (assetTrans.AmountMST < 0
            && AssetSumCalc_Trans::newAssetYear(_assetBook.AssetId, _assetBook.BookId).preAcquisitionValue_CZ() <= 0)
        {
            _assetBook.Status = AssetStatus::NoAcquisition;
        }
        else
        {
            if (_assetBook.Status == AssetStatus::NoAcquisition)
            {
                _assetBook.Status = AssetStatus::Acquired_CZ;
                _assetBook.AcquisitionPrice = assetTrans.AmountMST;
                _assetBook.AcquisitionPriceReportingCurrency = assetTrans.ReportingCurrencyAmount;
            }
            else if (_assetBook.Status == AssetStatus::Acquired_CZ)
            {
                _assetBook.AcquisitionPrice = AssetTrans::amountMSTPerDateTranstype(_assetBook.AssetId,
                                                                                        maxDate(),
                                                                                        _assetBook.BookId,
                                                                                        AssetTransType::PreAcquisition_CZ);
                _assetBook.AcquisitionPriceReportingCurrency = AssetTrans::amountReportingCurrencyPerDateTranstype(_assetBook.AssetId,
                                                                                                                    maxDate(),
                                                                                                                    _assetBook.BookId,
                                                                                                                    AssetTransType::PreAcquisition_CZ);
            }
            
            _assetBook.CategorizationDate_CZ = assetTrans.TransDate;
        }

        this.updateVendInformation(_assetBook);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForAcquisitionAdj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// Acquisition adjustment.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    /// <param name = "_assetTable">The related <c>AssetTable</c>.</param>
    /// <returns>true if adjusted depreciation is created; false, otherwise.</returns>
    protected boolean updatePostCaseForAcquisitionAdj(AssetBook _assetBook, AssetTable _assetTable)
    {
        boolean isAdjustedDepreciationCreatedLocal;
        
        if ((isInventorySoldTransNeeded) && (assetTable.PurchLineRecId != 0) &&
            !(AssetBookTableDerivedJournal::exist(ledgerJournalTrans.RecId, _assetBook.BookId)))
        {
            // Create an inventory sold transaction after posting an invoice
            // if it isn't created before with a fixed asset
            this.createInventorySoldTransaction();
        }

        this.updateFromVendInvoiceInfoLine(assetTable);
        this.updateAcquisitionForPost(_assetBook);

        // Make sure the transaction did not originate from the Split of the asset.
        if (!ledgerJournalTrans_Asset.isSplitTransaction())
        {
            isAdjustedDepreciationCreatedLocal = this.createTrueUpDepreciation(_assetBook);
        }

        _assetBook = this.setDepreciationStartDate(depreciationStartDate, _assetBook);

        return isAdjustedDepreciationCreatedLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForCapitalReserveTransfer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// Capital Reserve Transfer.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    /// <returns>true if adjusted depreciation is created; false, otherwise.</returns>
    protected boolean updatePostCaseForCapitalReserveTransfer(AssetBook _assetBook)
    {
        boolean isAdjustedDepreciationCreatedLocal;
        
        this.updateAcquisitionForPost(_assetBook);

        // Make sure the transaction did not originate from the Split of the asset.
        if (!ledgerJournalTrans_Asset.isSplitTransaction())
        {
            isAdjustedDepreciationCreatedLocal = this.createTrueUpDepreciation(_assetBook);
        }

        return isAdjustedDepreciationCreatedLocal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForDisposalScrap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>DisposalScrap</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForDisposalScrap(AssetBook _assetBook)
    {
        if (!isIsoPL
            || assetSaleFactor == 100)
        {
            _assetBook.disposalDate = assetTrans.TransDate;
            _assetBook.Status = AssetStatus::Scrapped;
            _assetBook.CustAccount = custAccount;
            _assetBook.CustInvoiceId = custInvoiceId;

            // If this is a low value pool book, the status should remain open
            if (!AssetPost_LowValuePoolFlight::instance().isEnabled()
                && AssetBook::isLowValuePoolBook(_assetBook.BookId))
            {
                _assetBook.Status = AssetStatus::Open;
            }
            else
            {
                _assetBook.Status = AssetStatus::Scrapped;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForDisposalSale</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>DisposalSale</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForDisposalSale(AssetBook _assetBook)
    {
        // For Poland, a partial disposal is allowed.  Additionally,
        // a user is able to create a correction transaction for the original sale.
        // For these cases, the asset is not marked as sold.
        if (!isIsoPL || assetSaleFactor == 100)
        {
            _assetBook.SaleValue = assetTrans.AmountMST;
            _assetBook.DisposalDate = assetTrans.TransDate;
            _assetBook.Status = AssetStatus::Sold;
            _assetBook.CustAccount = custAccount;
            _assetBook.CustInvoiceId = custInvoiceId;

            // If this is a low value pool book, the status should remain open
            if (
                // <GEEEE>
                // <GEELT>
                // If it is a credit note for the original sale, the status needs to be open.
                this.parmIsCreditNote() ||
                // </GEELT>
                // </GEEEE>
                (!AssetPost_LowValuePoolFlight::instance().isEnabled()
                 && AssetBook::isLowValuePoolBook(_assetBook.BookId))
                )
            {
                _assetBook.Status = AssetStatus::Open;
            }
            else
            {
                _assetBook.Status = AssetStatus::Sold;
            }
        }
        else
        {
            _assetBook.SaleValue += assetTrans.AmountMST;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForDepreciationAdj</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// Depreciation adjustment.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForDepreciationAdj(AssetBook _assetBook)
    {
        // Set the asset's status to Closed if its net book value is zero.
        if (this.isDepreciationFinished(_assetBook))
        {
            this.updateAssetBookStatus(_assetBook);
        }

        _assetBook.LifeTimeRest = this.getLifeTimeRest(_assetBook, assetTrans);

    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetBookStatus</Name>
				<Source><![CDATA[
    private void updateAssetBookStatus(AssetBook _assetBook)
    {
        // If this is a low value pool depreciation book, the status should remain open
        if (!AssetPost_LowValuePoolFlight::instance().isEnabled()
            && AssetBook::isLowValuePoolBook(_assetBook.BookId))
        {
            _assetBook.Status = AssetStatus::Open;
        }
        else
        {
            _assetBook.Status = AssetStatus::Closed;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// Depreciation.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForDepreciation(AssetBook _assetBook)
    {
        // Set the asset's status to Closed if its net book value is zero and
        // the derogatory depreciation has been fully depreciated.
        if (_assetBook.AssetDerogatoryModel_FR)
        {
            AssetSumCalc_Trans assetSumCalcTrans = AssetSumCalc_Trans::newAssetYear(_assetBook.AssetId, _assetBook.BookId);
            
            if (assetSumCalcTrans.netBookValue() <= _assetBook.ScrapValue && !assetSumCalcTrans.derogatoryValue())   // finished derogatory depreciation
            {
                this.updateAssetBookStatus(_assetBook);
            }
        }
        else
        {
            if (this.isDepreciationFinished(_assetBook))   // finished depreciating
            {
                this.updateAssetBookStatus(_assetBook);
            }
        }

        // Derogatory transactions are not posted to the GL journals, and the service life
        // needs to modified manually.
        if (_assetBook.IsDerogatoryBook_FR)
        {
            if (AssetPostDerogatoryBook_FRDepreciationTimeFlight::instance().isEnabled())
            {
                AssetTableMethod assetTableMethod = AssetTableMethod::construct(_assetBook, assetTrans.TransDate);
                assetTableMethod.calc();
                depreciationTime = assetTableMethod.depPeriod();
            }
            else
            {
                depreciationTime = this.determineNumberDerogatoryPeriods_FR(_assetBook, assetTrans.TransDate);
            }
        }

        _assetBook.LifeTimeRest = this.getLifeTimeRest(_assetBook, assetTrans);
        
        if (_assetBook.LastDepreciationDate < assetTrans.TransDate)
        {
            _assetBook.LastDepreciationDate = assetTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForExtraordinaryDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// Extraordinary depreciation.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForExtraordinaryDepreciation(AssetBook _assetBook)
    {
        if (this.isDepreciationFinished(_assetBook))
        {
            // The asset has become fully depreciated.
            if (AssetPost_LowValuePoolFlight::instance().isEnabled() 
                || !AssetBook::isLowValuePoolBook(_assetBook.BookId))
            {
                // Set the status to closed since it's not a low value pool asset.
                _assetBook.Status = AssetStatus::Closed;
            }
        }

        // <GJP>
        if (isAssetDocumentEnable
            && assetDocumentType_JP == AssetDocumentType_JP::AssetAcceleratedDepreciation
            && assetDocumentEntryRecId)
        {
            if (_assetBook.LastDepreciationDateAccelerated_JP < assetTrans.TransDate)
            {
                _assetBook.LastDepreciationDateAccelerated_JP = assetTrans.TransDate;
            }
        }
        else
        {
            // </GJP>
            if (_assetBook.LastDepreciationDateExtraOrd < assetTrans.TransDate)
            {
                _assetBook.LastDepreciationDateExtraOrd = assetTrans.TransDate;
            }
            // <GJP>
        }
        // </GJP>

        // <GJP>
        if (isIsoJP
            && assetDocumentType_JP == AssetDocumentType_JP::AdditionalDepDirectOff
            && AssetDepreciationProfile::isSpecialDepMethod_JP(_assetBook.depreciationExtProfile().Method))
        {
            if (!_assetBook.SpecialDepStartDate_JP || _assetBook.SpecialDepStartDate_JP > assetTrans.TransDate)
            {
                _assetBook.SpecialDepStartDate_JP = assetTrans.TransDate;
            }
        }
        // </GJP>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForBonusDepreciation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// Bonus depreciation.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForBonusDepreciation(AssetBook _assetBook)
    {
        if (this.isDepreciationFinished(_assetBook))
        {
            _assetBook.Status = AssetStatus::Closed;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForSpecialDepReserve_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>SpecialDepReserve_JP</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForSpecialDepReserve_JP(AssetBook _assetBook)
    {
        if (_assetBook.LastDepreciationDateExtraOrd < assetTrans.TransDate)
        {
            _assetBook.LastDepreciationDateExtraOrd = assetTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForAdditionalDepReserve_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>AdditionalDepReserve_JP</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForAdditionalDepReserve_JP(AssetBook _assetBook)
    {
        if (_assetBook.LastDepreciationDateExtraOrd < assetTrans.TransDate)
        {
            _assetBook.LastDepreciationDateExtraOrd = assetTrans.TransDate;
        }
                 
        // update special start date
        if (!_assetBook.SpecialDepStartDate_JP || _assetBook.SpecialDepStartDate_JP > AssetTrans.TransDate)
        {
            _assetBook.SpecialDepStartDate_JP = AssetTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForAdditionalDepReserveAllocation_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>AdditionalDepReserveAllocation_JP</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForAdditionalDepReserveAllocation_JP(AssetBook _assetBook)
    {
        if (_assetBook.SpecialDepLastAllocationDate_JP < assetTrans.TransDate)
        {
            _assetBook.SpecialDepLastAllocationDate_JP = assetTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForReductionEntryReserve_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>ReductionEntryReserve_JP</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForReductionEntryReserve_JP(AssetBook _assetBook)
    {
        if (!_assetBook.AllocationStartDate_JP
            || _assetBook.AllocationStartDate_JP > assetTrans.TransDate)
        {
            _assetBook.AssetDepBookMap_JP::setAllocationStartDate(assetTrans.TransDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostCaseForReductionEntryReserveAllocation_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Does the appropriate updates needed during post for transactions of type
    /// <c>ReductionEntryReserveAllocation_JP</c>.
    /// </summary>
    /// <param name = "_assetBook">The related <c>AssetBook</c>.</param>
    protected void updatePostCaseForReductionEntryReserveAllocation_JP(AssetBook _assetBook)
    {
        if (_assetBook.LastReserveAllocationDate_JP < assetTrans.TransDate)
        {
            _assetBook.LastReserveAllocationDate_JP = assetTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetAccountType2AssetTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts <c>AssetAccountType</c> to <c>AssetTransType</c> enumeration value.
    /// </summary>
    /// <param name = "_assetAccountType">The <c>AssetAccountType</c> to convert.</param>
    /// <returns>The converted <c>AssetTransType</c> enumeration value.</returns>
    /// <remarks>
    /// Add a post-method handler for returning the right value when extending the <c>AssetAccountType</c> enumeration.
    /// </remarks>
    public static AssetTransType assetAccountType2AssetTransType(AssetAccountType _assetAccountType)
    {
        switch (_assetAccountType)
        {
            case AssetAccountType::Acquisition:                     return AssetTransType::Acquisition;
            case AssetAccountType::AcquisitionAdj:                  return AssetTransType::AcquisitionAdj;
            // <GEEU>
            case AssetAccountType::PreAcquisition_CZ:               return AssetTransType::PreAcquisition_CZ;
            // </GEEU>
            case AssetAccountType::BonusDepreciation:               return AssetTransType::BonusDepreciation;
            case AssetAccountType::Depreciation:                    return AssetTransType::Depreciation;
            case AssetAccountType::DepreciationAdj:                 return AssetTransType::DepreciationAdj;
            case AssetAccountType::Revaluation:                     return AssetTransType::Revaluation;
            case AssetAccountType::WriteUpAdj:                      return AssetTransType::WriteUpAdj;
            case AssetAccountType::WriteDownAdj:                    return AssetTransType::WriteDownAdj;
            case AssetAccountType::DisposalSale:                    return AssetTransType::DisposalSale;
            case AssetAccountType::DisposalScrap:                   return AssetTransType::DisposalScrap;
            case AssetAccountType::CapitalReserve:                  return AssetTransType::CapitalReserve;
            case AssetAccountType::CapitalReserveTransfer:          return AssetTransType::CapitalReserveTransfer;
            case AssetAccountType::ExtraordinaryDepreciation:       return AssetTransType::ExtraordinaryDepreciation;
            case AssetAccountType::DerogatoryDecrease:              return AssetTransType::DerogatoryDecrease;
            case AssetAccountType::DerogatoryIncrease:              return AssetTransType::DerogatoryIncrease;
            // <GEEPL>
            case AssetAccountType::NotCostAllocatedPart_PL:         return AssetTransType::DepreciationNotCost_PL;
            case AssetAccountType::AccumulatedDepreciation_PL:      return AssetTransType::AccumulatedDepreciation_PL;
            case AssetAccountType::PostingOffAccDepreciation_PL:    return AssetTransType::PostOffAccDepreciation_PL;
            // </GEEPL>
            case AssetAccountType::MajorRepairs_RU:                 return AssetTransType::MajorRepairs_RU;
            case AssetAccountType::PartialTakeDown_RU:              return AssetTransType::PartialTakeDown_RU;
            case AssetAccountType::CurrencyWriteUpAdj_RU:           return AssetTransType::CurrencyWriteUpAdj_RU;
            case AssetAccountType::CurrencyWriteDownAdj_RU:         return AssetTransType::CurrencyWriteDownAdj_RU;
            case AssetAccountType::Other_RU:                        return AssetTransType::Other_RU;
        }

        return AssetTransType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTransType2AssetTransTypeJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts <c>AssetTransType</c> to <c>AssetTransTypeJournal</c> enumeration value.
    /// </summary>
    /// <param name = "_assetTransType">The <c>AssetTransType</c> enumeration value to convert.</param>
    /// <returns>The converted <c>AssetTransTypeJournal</c> enumeration value.</returns>
    /// <remarks>
    /// Add a post-method handler for returning the right value when extending the <c>AssetTransType</c> enumeration.
    /// </remarks>
    public static AssetTransTypeJournal assetTransType2AssetTransTypeJournal(AssetTransType _assetTransType)
    {
        switch (_assetTransType)
        {
            case AssetTransType::Acquisition:                   return AssetTransTypeJournal::Acquisition;
            case AssetTransType::AcquisitionAdj:                return AssetTransTypeJournal::AcquisitionAdj;
            // <GEEU>
            case AssetTransType::PreAcquisition_CZ:             return AssetTransTypeJournal::Preacquisition_CZ;
            // </GEEU>
            case AssetTransType::BonusDepreciation:             return AssetTransTypeJournal::BonusDepreciation;
            case AssetTransType::Depreciation:                  return AssetTransTypeJournal::Depreciation;
            case AssetTransType::DepreciationAdj:               return AssetTransTypeJournal::DepreciationAdj;
            case AssetTransType::Revaluation:                   return AssetTransTypeJournal::Revaluation;
            case AssetTransType::WriteUpAdj:                    return AssetTransTypeJournal::WriteUpAdj;
            case AssetTransType::WriteDownAdj:                  return AssetTransTypeJournal::WriteDownAdj;
            case AssetTransType::DisposalSale:                  return AssetTransTypeJournal::DisposalSale;
            case AssetTransType::DisposalScrap:                 return AssetTransTypeJournal::DisposalScrap;
            case AssetTransType::CapitalReserve:                return AssetTransTypeJournal::CapitalReserve;
            case AssetTransType::CapitalReserveTransfer:        return AssetTransTypeJournal::CapitalReserveTransfer;
            case AssetTransType::ExtraordinaryDepreciation:     return AssetTransTypeJournal::ExtraordinaryDepreciation;
            case AssetTransType::DerogatoryDecrease:            return AssetTransTypeJournal::DerogatoryDecrease;
            case AssetTransType::DerogatoryIncrease:            return AssetTransTypeJournal::DerogatoryIncrease;
            // <GEEPL>
            case AssetTransType::DepreciationNotCost_PL:        return AssetTransTypeJournal::NotCostAllocatedPart_PL;
            case AssetTransType::AccumulatedDepreciation_PL:    return AssetTransTypeJournal::AccumulatedDepreciation_PL;
            case AssetTransType::PostOffAccDepreciation_PL:     return AssetTransTypeJournal::PostingOffAccDepreciation_PL;
            // </GEEPL>
            case AssetTransType::MajorRepairs_RU:               return AssetTransTypeJournal::MajorRepairs_RU;
            case AssetTransType::Disposal_RU:                   return AssetTransTypeJournal::Disposal_RU;
            case AssetTransType::PartialTakeDown_RU:            return AssetTransTypeJournal::PartialTakeDown_RU;
            case AssetTransType::Lending_RU:                    return AssetTransTypeJournal::Lending_RU;
            case AssetTransType::LendingRet_RU:                 return AssetTransTypeJournal::LendingRet_RU;
            case AssetTransType::Other_RU:                      return AssetTransTypeJournal::Other_RU;
            case AssetTransType::CompanyIssue_RU:               return AssetTransTypeJournal::CompanyIssue_RU;
            case AssetTransType::CompanyReceipt_RU:             return AssetTransTypeJournal::CompanyReceipt_RU;
            case AssetTransType::CurrencyWriteUpAdj_RU:         return AssetTransTypeJournal::CurrencyWriteUpAdj_RU;
            case AssetTransType::CurrencyWriteDownAdj_RU:       return AssetTransTypeJournal::CurrencyWriteDownAdj_RU;
        }
        
        return AssetTransTypeJournal::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTransTypeJournal2AssetTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maps from <c>AssetTransTypeJournal</c> and <c>AssetDocumentType_JP</c> to <c>AssetTransType</c>
    /// </summary>
    /// <param name="assetTransTypeJournal">
    /// The asset journal type.
    /// </param>
    /// <param name="_assetDocumentType_JP">
    /// The asset document type; optional.
    /// </param>
    /// <returns>
    /// The <c>AssetTrans</c> transaction type.
    /// </returns>
    /// <remarks>
    /// Add a post-method handler for returning the right value when extending the <c>AssetTransTypeJournal</c> enumeration.
    /// </remarks>
    public static AssetTransType assetTransTypeJournal2AssetTransType(AssetTransTypeJournal _assetTransTypeJournal,
        AssetDocumentType_JP _assetDocumentType_JP = AssetDocumentType_JP::None)
    {
        // <GJP>
        if (_assetDocumentType_JP ==  AssetDocumentType_JP::None)
        {
            // </GJP>
            switch (_assetTransTypeJournal)
            {
                case AssetTransTypeJournal::Acquisition:                    return AssetTransType::Acquisition;
                case AssetTransTypeJournal::AcquisitionAdj:                 return AssetTransType::AcquisitionAdj;
                // <GEEU>
                case AssetTransTypeJournal::Preacquisition_CZ:              return AssetTransType::PreAcquisition_CZ;
                // </GEEU>
                case AssetTransTypeJournal::BonusDepreciation:              return AssetTransType::BonusDepreciation;
                case AssetTransTypeJournal::Depreciation:                   return AssetTransType::Depreciation;
                case AssetTransTypeJournal::DepreciationAdj:                return AssetTransType::DepreciationAdj;
                case AssetTransTypeJournal::Revaluation:                    return AssetTransType::Revaluation;
                case AssetTransTypeJournal::WriteUpAdj:                     return AssetTransType::WriteUpAdj;
                case AssetTransTypeJournal::WriteDownAdj:                   return AssetTransType::WriteDownAdj;
                case AssetTransTypeJournal::DisposalSale:                   return AssetTransType::DisposalSale;
                case AssetTransTypeJournal::DisposalScrap:                  return AssetTransType::DisposalScrap;
                case AssetTransTypeJournal::CapitalReserve:                 return AssetTransType::CapitalReserve;
                case AssetTransTypeJournal::CapitalReserveTransfer:         return AssetTransType::CapitalReserveTransfer;
                case AssetTransTypeJournal::ExtraordinaryDepreciation:      return AssetTransType::ExtraordinaryDepreciation;
                case AssetTransTypeJournal::DerogatoryDecrease:             return AssetTransType::DerogatoryDecrease;
                case AssetTransTypeJournal::DerogatoryIncrease:             return AssetTransType::DerogatoryIncrease;
                // <GEEPL>
                case AssetTransTypeJournal::NotCostAllocatedPart_PL:        return AssetTransType::DepreciationNotCost_PL;
                case AssetTransTypeJournal::AccumulatedDepreciation_PL:     return AssetTransType::AccumulatedDepreciation_PL;
                case AssetTransTypeJournal::PostingOffAccDepreciation_PL:   return AssetTransType::PostOffAccDepreciation_PL;
                // </GEEPL>
                case AssetTransTypeJournal::MajorRepairs_RU:                return AssetTransType::MajorRepairs_RU;
                case AssetTransTypeJournal::Disposal_RU:                    return AssetTransType::Disposal_RU;
                case AssetTransTypeJournal::PartialTakeDown_RU:             return AssetTransType::PartialTakeDown_RU;
                case AssetTransTypeJournal::Lending_RU:                     return AssetTransType::Lending_RU;
                case AssetTransTypeJournal::LendingRet_RU:                  return AssetTransType::LendingRet_RU;
                case AssetTransTypeJournal::Other_RU:                       return AssetTransType::Other_RU;
                case AssetTransTypeJournal::CompanyIssue_RU:                return AssetTransType::CompanyIssue_RU;
                case AssetTransTypeJournal::CompanyReceipt_RU:              return AssetTransType::CompanyReceipt_RU;
                case AssetTransTypeJournal::CurrencyWriteUpAdj_RU:          return AssetTransType::CurrencyWriteUpAdj_RU;
                case AssetTransTypeJournal::CurrencyWriteDownAdj_RU:        return AssetTransType::CurrencyWriteDownAdj_RU;
            }
            // <GJP>
        }
        else
        {
            return AssetDocumentUtility_JP::assetTransTypeJournal2AssetTransType_JP(
                _assetTransTypeJournal,
                _assetDocumentType_JP);
        }
        // </GJP>
               
        return AssetTransType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetTransTypePurch2AssetTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Maps from <c>AssetTransTypePurch</c> and <c>AssetDocumentType_JP</c> to <c>AssetTransType</c>
    /// </summary>
    /// <param name="assetTransTypePurch">
    /// The asset transaction purchase order type.
    /// </param>
    /// <param name="_assetDocumentType_JP">
    /// The asset document type; optional.
    /// </param>
    /// <returns>
    /// The <c>AssetTrans</c> transaction type.
    /// </returns>
    public static AssetTransType assetTransTypePurch2AssetTransType(
            AssetTransTypePurch assetTransTypePurch,
            AssetDocumentType_JP _assetDocumentType_JP = AssetDocumentType_JP::None
        )
    {
        // <GJP>
        if (_assetDocumentType_JP ==  AssetDocumentType_JP::None)
        {
            // </GJP>
            switch (assetTransTypePurch)
            {
                case AssetTransTypePurch::Acquisition:        return AssetTransType::Acquisition;
                case AssetTransTypePurch::AcquisitionAdj:     return AssetTransType::AcquisitionAdj;
                case AssetTransTypePurch::PreAcquisition_CZ:  return AssetTransType::PreAcquisition_CZ;
            }
            // <GJP>
        }
        else
        {
            return AssetDocumentUtility_JP::assetTransTypePurch2AssetTransType(assetTransTypePurch, _assetDocumentType_JP);
        }
        // </GJP>

        return AssetTransType::None;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct_W</Name>
				<Source><![CDATA[
    public static AssetPost construct_W(LedgerVoucher _ledgerVoucher)
    {
        switch (SysCountryRegionCode::countryInfo())
        {
            case #IsoCZ:
                return new AssetPost_CZ(_ledgerVoucher);

            case #IsoHU:
                return new AssetPost_HU(_ledgerVoucher);

            case #IsoPL:
                return new AssetPost_PL(_ledgerVoucher);
        }

        return new AssetPost(_ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPurchaseTransactionAcquisitionInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the information regarding the purchase order associated with the fixed asset transaction.
    /// </summary>
    /// <param name="_assetId">
    /// The Asset ID of the fixed asset transaction.
    /// </param>
    /// <param name="_bookId">
    /// The value model Id of the fixed asset transaction.
    /// </param>
    /// <param name="_assetTransAmount">
    /// The amount of the fixed asset transaction.
    /// </param>
    /// <param name="_assetVoucher">
    /// The voucher of the fixed asset transaction.
    /// </param>
    /// <param name="_isPurchaseLineDimensionNeeded">
    /// Determines if the Purchase Line Dimension Account needs to be retrieved.
    /// </param>
    /// <returns>
    /// <c>AssetPostPurchaseLineInfo</c> object that stores the three values:
    /// 1. If the item on the purchase order is stocked item.
    /// 2. The acquisition amount specified on the purchase order.
    /// 3. The Ledger Dimension specified on the purchase order.
    /// 4. If item requires the value of the items to be posted to the inventory receipt account.
    /// </returns>
    public static AssetPostPurchaseLineInfo getPurchaseTransactionAcquisitionInfo(
        AssetId _assetId,
        AssetBookId _bookId,
        AssetAmount _assetTransAmount,
        Voucher _assetVoucher,
        boolean _isPurchaseLineDimensionNeeded = false)
    {
        AssetPostPurchaseLineInfo assetPostPurchaseLineInfo = new AssetPostPurchaseLineInfo();
        AssetTable assetTable;
        boolean isStockedItem;
        boolean isPostFinancialInventory;
        boolean isAcquisitionAmountForPO;
        PurchLine purchLine;
        AssetAmount acquisitionAmountToDate;
        LedgerDimensionAccount purchaseLineDimension;
        SourceDocumentLine purchaseSourceDocumentLine;
        AccountingDistribution accountingDistribution;
        AccountingEvent accountingEvent;
        VendInvoiceTrans vendInvoiceTrans;
        InventModelGroup inventModelGroup;

        select firstonly PurchLineRecId from assetTable
            where assetTable.AssetId == _assetId
        join * from purchLine
            where purchLine.RecId == assetTable.PurchLineRecId;

        if (purchLine)
        {
            select sum(LineAmountMST) from vendInvoiceTrans
                where vendInvoiceTrans.InventTransId == purchLine.InventTransId;

            acquisitionAmountToDate = AssetTrans::amountMSTPerDateTransTypes(
                        _assetId,
                        _bookId,
                        [AssetTransType::Acquisition, AssetTransType::AcquisitionAdj],
                        dateNull(),
                        maxDate(),
                        _assetVoucher);

            // If the amount posted for the acquisitions todate in Fixed Assets transactions is less than invoiced purchase order amounts,
            // the amount is applied towards the PO.
            if ((_assetTransAmount + acquisitionAmountToDate) <= vendInvoiceTrans.LineAmountMST)
            {
                isAcquisitionAmountForPO = true;
            }

            if (purchLine.isStocked())
            {
                isStockedItem = true;

                inventModelGroup = InventTable::find(purchLine.ItemId).modelGroup();
                isPostFinancialInventory = inventModelGroup.PostOnhandFinancial;
            }
            else
            {
                isStockedItem = false;

                // For Acquisitions originated from PO for non-stocked items, the original LedgerDimension is need for the Fixed Asset transaction.
                // PurchLine can be changed during invoicing, in that case VendInvoiceTrans.SourceDocumentLine is used to find the correct LedgerDimension.
                if (_isPurchaseLineDimensionNeeded
                    && isAcquisitionAmountForPO
                    && purchLine.InventTransId)
                {
                    select SourceDocumentHeader, RecId from purchaseSourceDocumentLine
                    join RecId from vendInvoiceTrans
                        where vendInvoiceTrans.InventTransId == purchLine.InventTransId
                        && vendInvoiceTrans.SourceDocumentLine == purchaseSourceDocumentLine.RecId;
                    if (purchaseSourceDocumentLine.RecId)
                    {
                        accountingEvent = AccountingEvent::getCurrentEvent(purchaseSourceDocumentLine.SourceDocumentHeader, OperationsTax::Current);
                        accountingDistribution = AccountingDistribution::getFirstDistribution(purchaseSourceDocumentLine.RecId, accountingEvent.RecId);
                        purchaseLineDimension = accountingDistribution.LedgerDimension;
                    }
                }
            }
        }

        assetPostPurchaseLineInfo.parmIsStockedItem(isStockedItem);
        assetPostPurchaseLineInfo.parmIsAcquisitionAmountForPO(isAcquisitionAmountForPO);
        assetPostPurchaseLineInfo.parmPurchaseLineDimension(purchaseLineDimension);
        assetPostPurchaseLineInfo.parmIsPostFinancialInventory(isPostFinancialInventory);

        return assetPostPurchaseLineInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCashDiscTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>CustVendTrans</c> buffer.
    /// </summary>
    /// <param name = "_assetTrans">
    ///   Original asset transaction to post discount for.
    /// </param>
    /// <param name = "_custVendTrans">
    ///   Customer or vendor transaction.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///   Voucher that should be used for new transaction
    /// </param>
    /// <param name = "_discAmountMST">
    ///   New transaction amount.
    /// </param>
    /// <param name = "_baseAmountMST">
    ///   Part of original transaction amount which was used for discount calculation.
    /// </param>
    /// <returns>
    ///   New instance of <c>AssetPost</c> class.
    /// </returns>
    public static AssetPost newCashDiscTrans(AssetTrans _assetTrans,
                                      CustVendTrans _custVendTrans,
                                      LedgerVoucher _ledgerVoucher,
                                      AssetAmount _discAmountMST,
                                      AssetAmount _baseAmountMST = 0)
    {
        // <GEEU>
        AssetPost assetPost = AssetPost::construct_W(_ledgerVoucher);
        // </GEEU>

        assetPost.initFromCashDiscTrans(_assetTrans, _custVendTrans, _discAmountMST, _baseAmountMST);

        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCustInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>CustInvoiceTrans</c> buffer.
    /// </summary>
    /// <param name = "_ledgerVoucher">An instance of Voucher object used during posting.</param>
    /// <param name = "_custInvoiceTrans"><c>CustInvoiceTrans</c> table buffer.</param>
    /// <returns>New instance of <c>AssetPost</c> class.</returns>
    public static AssetPost newCustInvoiceTrans(LedgerVoucher _ledgerVoucher, CustInvoiceTrans _custInvoiceTrans)
    {
        // <GEEU>
        AssetPost assetPost = AssetPost::construct_W(_ledgerVoucher);
        // </GEEU>
        
        assetPost.initFromCustInvoiceTrans(_custInvoiceTrans);
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>InventJournalTrans</c> buffer.
    /// </summary>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> object used for posting the asset transactions to general ledger.</param>
    /// <param name = "_inventJournalTrans">The <c>InventJournalTrans</c> record to create asset transactions from.</param>
    /// <param name = "_inventUpd_Financial">An instance of <c>InventUpd_Financial</c> class.</param>
    /// <returns>New instance of <c>AssetPost</c> class.</returns>
    public static AssetPost newInventJournalTrans(LedgerVoucher _ledgerVoucher,
                                           InventJournalTrans _inventJournalTrans,
                                           InventUpd_Financial _inventUpd_Financial)
    {
        // <GEEU>
        AssetPost assetPost = AssetPost::construct_W(_ledgerVoucher);
        // </GEEU>
        
        assetPost.initFromInventJournalTrans(_inventJournalTrans, _inventUpd_Financial);
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>InventMovement</c> buffer.
    /// </summary>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> object used for posting the asset transactions to general ledger.</param>
    /// <param name = "_inventMovement">The <c>InventMovement</c> record to create asset transactions from.</param>
    /// <param name = "_inventUpd_Financial"An instance of <c>InventUpd_Financial</c> class.></param>
    /// <param name = "_amountMST">Amount in accounting currency for the transaction amount.</param>
    /// <returns>New instance of <c>AssetPost</c> class.</returns>
    public static AssetPost newInventMovement(LedgerVoucher _ledgerVoucher,
                                       InventMovement _inventMovement,
                                       InventUpd_Financial _inventUpd_Financial,
                                       AmountMST _amountMST)
    {
        // <GEEU>
        AssetPost assetPost = AssetPost::construct_W(_ledgerVoucher);
        // </GEEU>

        assetPost.initFromInventMovement(_inventMovement, _inventUpd_Financial, _amountMST);
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInvoiceCashDiscTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>LedgerJournalTrans</c> buffer
    /// when the cash discount is applied on the vendor invoice (only for Spain).
    /// </summary>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> object used for posting the asset transactions to general ledger.</param>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> record to create asset transactions from.</param>
    /// <returns>New instance of <c>AssetPost</c> class.</returns>
    public static AssetPost newInvoiceCashDiscTrans(LedgerVoucher _ledgerVoucher, LedgerJournalTrans _ledgerJournalTrans)
    {
        // <GEEU>
        AssetPost assetPost = AssetPost::construct_W(_ledgerVoucher);
        // </GEEU>
        
        assetPost.initFromInvoiceCashDiscTrans(_ledgerJournalTrans);

        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>LedgerJournalTrans</c>
    /// and <c>LedgerJournalTrans_Asset</c> buffers.
    /// </summary>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> object used for posting the asset transactions to general ledger.</param>
    /// <param name = "_ledgerJournalTrans">The <c>LedgerJournalTrans</c> table buffer from which to initialize.</param>
    /// <param name = "_originalLedgerJournalTrans">The <c>LedgerJournalTrans</c> table buffer not modified by posting.</param>
    /// <param name = "_ledgerJournalTrans_Asset">The <c>LedgerJournalTrans_Asset</c> table buffer from which to initialize.</param>
    /// <param name = "_isOffset">true if posting the offset; false if posting the primary.</param>
    /// <param name = "_taxAmount">The amount of tax to subtract from the amount returned from the amount method on the specified
    ///    <c>LedgerJournalTrans</c> record; optional.</param>
    /// <param name = "_taxAmountInCostPrice">The amount of tax already included in the price to add back to the amount returned from the amount
    ///    method on the specified <c>LedgerJournalTrans</c> record; optional.</param>
    /// <returns>New instance of <c>AssetPost</c> class.</returns>
    public static AssetPost newLedgerJournalTrans(LedgerVoucher _ledgerVoucher,
                                           LedgerJournalTrans _ledgerJournalTrans,
                                           LedgerJournalTrans _originalLedgerJournalTrans,
                                           LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                           boolean _isOffset,
                                           TaxAmount _taxAmount = 0,
                                           TaxAmount _taxAmountInCostPrice = 0)
    {
        AssetPost assetPost;
        assetPost = AssetPost::construct_W(_ledgerVoucher);
        assetPost.initFromLedgerJournalTrans(_ledgerJournalTrans, _originalLedgerJournalTrans, _ledgerJournalTrans_Asset, _isOffset, _taxAmount, _taxAmountInCostPrice);
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournalTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize an <c>Assetpost</c> object.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// A <c>ledgervoucher</c> object
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name="_ledgerJournalTrans_Asset">
    /// A <c>LedgerJournalTrans_Asset</c> buffer.
    /// </param>
    /// <param name="_taxAmount">
    /// The tax amount on the asset group.
    /// </param>
    /// <param name="_taxAmountInCostPrice">
    /// The tax amount in cost price on the asset group.
    /// </param>
    /// <param name="_loiAmount">
    /// The load on inventory amount.
    /// </param>
    /// <returns>
    /// An <c>AssetPost</c> object.
    /// </returns>
    public static AssetPost newLedgerJournalTrans_IN(LedgerVoucher _ledgerVoucher,
                                                     LedgerJournalTrans _ledgerJournalTrans,
                                                     LedgerJournalTrans_Asset _ledgerJournalTrans_Asset,
                                                     TaxAmount _taxAmount = 0,
                                                     TaxAmount _taxAmountInCostPrice = 0,
                                                     TaxAmountCur _loiAmount = 0)

    {
        AssetPost assetPost = new AssetPost(_ledgerVoucher);
        AssetBook assetBook;

        assetPost.parmloadOnInventoryAmount_IN(_loiAmount);

        assetBook = AssetBook::find(_ledgerJournalTrans.parmAccount(), _ledgerJournalTrans_Asset.BookId);

        if (assetBook.AssetGroupDepreciation_IN &&
            (_ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::Depreciation ||
            _ledgerJournalTrans_Asset.TransType == AssetTransTypeJournal::DepreciationAdj))
        {
            assetPost.initFromLedgerJournalTrans_IN(_ledgerJournalTrans,
                                                    _ledgerJournalTrans_Asset,
                                                    _taxAmount,
                                                    _taxAmountInCostPrice);
        }
        else
        {
            assetPost.initFromLedgerJournalTrans(_ledgerJournalTrans,
                                                 null,
                                                 _ledgerJournalTrans_Asset,
                                                 false,
                                                 _taxAmount,
                                                 _taxAmountInCostPrice);

            if (assetBook.AssetGroupDepreciation_IN)
            {
                assetPost.initFromLedgerJournalTrans_IN(_ledgerJournalTrans,
                                                        _ledgerJournalTrans_Asset,
                                                        _taxAmount,
                                                        _taxAmountInCostPrice);
            }
        }
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on <c>ProjControlPeriodTable</c> buffer.
    /// </summary>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> object used for posting the asset transactions to general ledger.</param>
    /// <param name = "_projControlPeriodTable">The <c>ProjControlPeriodTable</c> record to create asset transactions from.</param>
    /// <param name = "_assetAmount">Amount in accounting currency for the transaction amount.</param>
    /// <returns>New instance of <c>AssetPost</c> class.</returns>
    public static AssetPost newProjEstimate(LedgerVoucher _ledgerVoucher, ProjControlPeriodTable _projControlPeriodTable, AmountMST _assetAmount)
    {
        AssetPost assetPost = new AssetPost(_ledgerVoucher);
        
        assetPost.initFromProjEstimate(_projControlPeriodTable, _assetAmount);
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates new instance of <c>AssetPost</c> class and initializes <c>AssetTrans</c> buffer based on a purchase invoice line.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The <c>LedgerVoucher</c> object used for posting the asset transactions to general ledger.
    /// </param>
    /// <param name="_vendInvoiceTrans">
    ///    The <c>VendInvoiceTrans</c> record to create asset transactions from.
    /// </param>
    /// <param name="_vendInvoiceJour">
    ///    The <c>VendInvoiceJour</c> record to create asset transactions from.
    /// </param>
    /// <param name="_vendInvoiceInfoLine_Asset">
    ///    The <c>VendInvoiceInfoLine_Asset</c> table buffer from which to initialize.
    /// </param>
    /// <param name="_tax">
    ///     The <c>Tax</c> object from which tax amounts for the <c>VendInvoiceTrans</c> can be accessed.
    /// </param>
    /// <returns>
    ///    A <c>AssetPost</c> class instantiated with values from a purchase order invoice line.
    /// </returns>
    /// <remarks>
    ///    Used for creating asset transactions for non inventoried purchase order lines.
    /// </remarks>
    public static AssetPost newVendInvoiceTrans(LedgerVoucher _ledgerVoucher,
                                                VendInvoiceTrans _vendInvoiceTrans,
                                                VendInvoiceJour _vendInvoiceJour,
                                                VendInvoiceInfoLine_Asset _vendInvoiceInfoLine_Asset,
                                                Tax _tax = null)
    {
        AssetPost assetPost = new AssetPost(_ledgerVoucher);

        assetPost.initFromVendInvoiceTrans(_vendInvoiceTrans, _vendInvoiceJour, _vendInvoiceInfoLine_Asset, _tax);
        return assetPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingProfileFromLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the posting profile to use for posting from <c>LedgerJournalTrans</c>
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> instance used to figure out the posting profile.
    /// </param>
    /// <param name="_assetBook">
    /// The <c>AssetBook</c> instance for which the posting profile needs to be found out.
    /// </param>
    /// <returns>
    /// The posting profile to be used for posting.
    /// </returns>
    public static PostingProfile postingProfileFromLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans, AssetBookId _assetBook)
    {
        if (_ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::FixedAssets
            || _ledgerJournalTrans.PostingProfile == '')
        {
            return AssetPost::determinePostingProfile(_ledgerJournalTrans, _assetBook);
        }
        else
        {
            return _ledgerJournalTrans.PostingProfile;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>determinePostingProfile</Name>
				<Source><![CDATA[
    private static PostingProfile determinePostingProfile(LedgerJournalTrans _ledgerJournalTrans, AssetBookId _assetBook)
    {
        AssetTable assetTable = AssetTable::findByLedgerDimension(_ledgerJournalTrans.parmLedgerDimension());
        return assetTable.postingProfile(_assetBook);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoucherOnAssetJournal</Name>
				<Source><![CDATA[
    private void setVoucherOnAssetJournal(AssetJournal _assetJournal, ledgerJournalTrans _ledgerJournalTrans)
    {
        if (isOneVoucherFeatureEnabled)
        {
            if (isDerivedBookPosting)
            {
                _assetJournal.parmVoucher(depreciationAdjustmentVoucher);
            }
        }
        else
        {
            // Most scenarios, we are coming from FA journal or General Journal which uses ledgerJournalTrans
            if (_ledgerJournalTrans.Voucher)
            {
                _assetJournal.parmVoucher(_ledgerJournalTrans.Voucher);
            }
            else if (inventJournalTransVoucher)
            {
                // However, we could also be calling from Inventory to Fixed Assets journal which uses InventJournalTrans
                _assetJournal.parmVoucher(inventJournalTransVoucher);
            }
        }
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLifeTimeRest</Name>
				<Source><![CDATA[
    private AssetLifeTimeRest getLifeTimeRest(AssetBook _assetBook, AssetTrans _assetTrans)
    {
        AssetDepProfileChange_JP depProfileChange;
        AssetLifeTimeRest lifeTimeRest = _assetBook.LifeTimeRest;

        // update life time remaining is any of the Straight line, reducing balance or factor
        // depreciation methods.  The depreciationTime is only set if used proposal to
        // create the journal line.
        if (isManuallyChangeDepProfileEnable_JP)
        {
            // If this is the first time that transaction time passes depreciation profile changeover date,
            // do an adjustment on the life time rest
            depProfileChange = AssetDepProfileChange_JP::find(_assetBook.TableId, _assetBook.RecId, assetTrans.TransDate);
            if (depProfileChange && _assetBook.LastDepreciationDate < depProfileChange.ValidFrom)
            {
                if (depProfileChange.IsUseEquallyDividedFormula)
                {
                    lifeTimeRest = depProfileChange.LifeTime;
                }
                else
                {
                    lifeTimeRest = _assetBook.LifeTimeRest - _assetBook.LifeTime + depProfileChange.LifeTime;
                }
            }
        }

        if (_assetBook.needToUpdateLifeTimeWithDepreciationTime()
            && assetTrans.TransType != AssetTransType::DepreciationNotCost_PL
            && this.needToUpdateLifeTimeRest_CN(_assetBook))
        {
            lifeTimeRest -= depreciationTime;
        }

        if (lifeTimeRest < 0)
        {
            lifeTimeRest = 0.0;
        }

        return lifeTimeRest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needToUpdateLifeTimeRest_CN</Name>
				<Source><![CDATA[
    private boolean needToUpdateLifeTimeRest_CN(AssetBook _assetBook)
    {
        boolean ret = true;

        if (isIsoCN)
        {
            ret = _assetBook.LastDepreciationDate < assetTrans.TransDate
                || (assetTrans.TransType == AssetTransType::DepreciationAdj
                    && _assetBook.LastDepreciationDate == assetTrans.TransDate);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoadOnInventoryFromTaxDocument</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get load on inventory amount from tax document.
    /// </summary>
    /// <param name = "_vendInvoiceJour">The vendor invoice journal.</param>
    /// <param name = "_vendInvoiceTrans">The vendor invoice trans.</param>
    /// <returns>The container contains the load on inventory amount in transaction and accounting currency.</returns>
    protected container getLoadOnInventoryFromTaxDocument(VendInvoiceJour _vendInvoiceJour, VendInvoiceTrans _vendInvoiceTrans)
    {
        AmountCur loadOnInventoryCur;
        AmountMST loadOnInventoryMST;

        ITaxableDocument taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_vendInvoiceJour));
        ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
        if (taxDocumentObject)
        {
            ITaxDocumentLine taxDocumentLineObject = taxDocumentObject.findLineBySource(_vendInvoiceTrans.TableId, _vendInvoiceTrans.RecId);
            if (taxDocumentLineObject)
            {
                loadOnInventoryCur = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountTransactionCurrency();
                loadOnInventoryCur -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountTransactionCurrency();

                loadOnInventoryMST = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountAccountingCurrency();
                loadOnInventoryMST -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountAccountingCurrency();
            }
        }
        return [loadOnInventoryMST, loadOnInventoryCur];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoadOnInventoryFromTaxDocumentRep</Name>
				<Source><![CDATA[
    private Amount getLoadOnInventoryFromTaxDocumentRep(VendInvoiceJour _vendInvoiceJour, VendInvoiceTrans _vendInvoiceTrans)
    {
        Amount loadOnInventoryRep;

        ITaxableDocument taxableDocument = TaxableDocumentObject::construct(TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(_vendInvoiceJour));
        ITaxDocument taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);
        if (taxDocumentObject)
        {
            ITaxDocumentLine taxDocumentLineObject = taxDocumentObject.findLineBySource(_vendInvoiceTrans.TableId, _vendInvoiceTrans.RecId);
            if (taxDocumentLineObject)
            {
                loadOnInventoryRep = taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountReportingCurrency();
                loadOnInventoryRep -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountReportingCurrency();
            }
        }

        return loadOnInventoryRep;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAssetBookPostingLayer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether the specified posting layer is available on the book and throws an error when it is not expected value.
    /// </summary>
    /// <param name = "_assetBook">
    /// The asset book record.
    /// </param>
    /// <param name = "_voucherId">
    /// The voucher number.
    ///</param>
    /// <param name = "_postingLayer">
    /// The posting layer.
    /// </param>
    protected void validateAssetBookPostingLayer(AssetBook _assetBook,
        Voucher _voucherId,
        CurrentOperationsTax _postingLayer = CurrentOperationsTax::Current)
    {
        this.doesAssetBookAllowPostingToGeneralLedger(_assetBook);
        
        if (_assetBook.assetBookTable().CurrentOperationsTax != _postingLayer)
        {
            throw error(strfmt("@FixedAssets:FA_Error_FixedAssetBookNotInCurrentLayer", _voucherId, enum2Str(_postingLayer)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMainBookAssetTransRecId</Name>
				<Source><![CDATA[
    internal RecId parmMainBookAssetTransRecId()
    {
        return mainBookAssetTransRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>needToAssemble_JP</Name>
				<Source><![CDATA[
    private boolean needToAssemble_JP(AssetId _assetId, LedgerDimensionDefaultAccount _disposalAccount = 0)
    {
        return _disposalAccount || AssetComponent_JP::isAssemblingExist(_assetId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfAcquisitionTransactions</Name>
				<Source><![CDATA[
    private static int64 getNumberOfAcquisitionTransactions(AssetId _assetId, AssetBookId _bookId)
    {
        AssetTransTmp assetTransTmp = AssetCacheManager::getCacheAssetTrans(_assetId, _bookId);
        select count(RecId) from assetTransTmp
            where assetTransTmp.AssetId == _assetId
                && assetTransTmp.BookId == _bookId
                && assetTransTmp.Txt != "@SYS67430"
                && assetTransTmp.TransType == AssetTransType::Acquisition;
        return assetTransTmp.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDerivedBookPosting</Name>
				<Source><![CDATA[
    internal boolean parmIsDerivedBookPosting(boolean _isDerivedBookPosting = isDerivedBookPosting)
    {
        isDerivedBookPosting = _isDerivedBookPosting;
        return isDerivedBookPosting;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstBonusId</Name>
				<Source><![CDATA[
    private AssetBonusId getFirstBonusId(
        AssetBookId _bookId,
        AssetGroupId _assetGroupId)
    {
        AssetGroupSetupBonus assetGroupSetupBonus;

        select firstonly BonusId from assetGroupSetupBonus
            where assetGroupSetupBonus.BookId == _bookId
               && assetGroupSetupBonus.AssetGroupId == _assetGroupId;

        return assetGroupSetupBonus.BonusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLastDepreciationDate</Name>
				<Source><![CDATA[
    private boolean checkLastDepreciationDate(AssetBook _assetBook)
    {
        boolean ret = true;

        // Split assets can contain multiple depreciations for the same date. Validation can be ignored for these transactions.
        boolean doValidateAssetSplit_JP = this.checkAssetSplit_JP();

        if (assetTrans.TransType == AssetTransType::Depreciation
                && doValidateAssetSplit_JP
                && !AssetParameters::isAllowMultipleDepreciation())
        {
            if (ledgerJournalTrans.TransDate <= _assetBook.LastDepreciationDate)
            {
                ret = checkFailed(strfmt("@FixedAssets:FA_AssetPreventMultipleDepreciationMessage",
                        _assetBook.AssetId,
                        _assetBook.BookId));
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAssetSplit_JP</Name>
				<Source><![CDATA[
    protected boolean checkAssetSplit_JP() 
    { 
        return !(AssetSplitBreakUpTransactionsByYearFeature::isEnabled() && assetTrans.AssetTransSubType == AssetTransactionSubType::Split); 
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDepreciationAdjVoucher</Name>
				<Source><![CDATA[
    internal Voucher parmDepreciationAdjVoucher(Voucher _depreciationAdjustmentVoucher = depreciationAdjustmentVoucher)
    {
        depreciationAdjustmentVoucher = _depreciationAdjustmentVoucher;
        return depreciationAdjustmentVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addTransIntoLedgerVoucherObject</Name>
				<Source><![CDATA[
    private void addTransIntoLedgerVoucherObject(
        LedgerVoucherTransObject _ledgerVoucherTransObject,
        ledgerVoucherObject _ledgerVoucherObject)
    {
        if (isOneVoucherFeatureEnabled)
        {
            ledgerVoucher.addTrans(_ledgerVoucherTransObject);
        }
        else
        {
            _ledgerVoucherObject.addTrans(_ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAssetReversalRelatedVoucherManager</Name>
				<Source><![CDATA[
    private AssetReversalRelatedVoucherManager createAssetReversalRelatedVoucherManager()
    {
        if (isOneVoucherFeatureEnabled
            && !isDerivedBookPosting)
        {
            assetReversalRelatedVoucherManager = AssetReversalRelatedVoucherManager::construct();
        }

        return assetReversalRelatedVoucherManager;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveReversalRelatedVouchers</Name>
				<Source><![CDATA[
    private void saveReversalRelatedVouchers()
    {
        if (isOneVoucherFeatureEnabled
            && assetReversalRelatedVoucherManager)
        {
            assetReversalRelatedVoucherManager.save();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeRateHelper</Name>
				<Source><![CDATA[
    private CurrencyExchangeHelper getExchangeRateHelper(LedgerVoucherObject _ledgerVoucherObject)
    {
        CurrencyExchangeHelper exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(exchRate);
        exchangeRateHelper.parmExchangeRate2(exchRateSecond);
        exchangeRateHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);
        exchangeRateHelper.parmReportingExchangeRate2(reportingCurrencyExchRateSecond);

        return exchangeRateHelper;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>