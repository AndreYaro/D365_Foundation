<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TaxWithhold_CustPaym</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>TaxWithhold</c> class is the tax calculation class for Withhold of customer payment.
/// </summary>
class TaxWithhold_CustPaym extends TaxWithhold
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calcPaymentAmtPerLineWithMarkupTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the amount to calculate the WHT tax. This amount will be adjusted based on discounts and
    ///    taxes applied to the invoice line.
    /// </summary>
    /// <param name="_specTrans">
    ///    The <c>SpecTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_inventTransId">
    ///    The <c>InventTransId</c> value that references the ID of the inventory record.
    /// </param>
    /// <param name="_isCorrection">
    ///    A parameter that determines whether the base amount has to be adjusted.
    /// </param>
    /// <param name="_invoiceAmountLine">
    ///    The <c>BaseInvoice</c> amount that represents the total base amount.
    /// </param>
    /// <param name="_invoiceAmountAll">
    ///    The invoice amount that represents the total base amount.
    /// </param>
    /// <param name="_isInclTax">
    ///    A parameter that indicates whether included taxes are included in the sales tax amounts.
    /// </param>
    /// <param name="_sourceDocumentLineRecId">
    ///    A <c>SourceDocumentLine</c> record ID.
    /// </param>
    /// <param name="_invoiceLineRecId">
    ///    The <c>VendInvoiceTrans</c> RecId.
    /// </param>
    /// <param name="_calculateForMarkupTrans">
    ///    Indicates do we calculate payment amount for the charge codes.
    /// </param>
    /// <param name="_invoiceAmountLineWithoutTax">
    ///    GWHTax transaction amount. Without tax.
    /// </param>
    /// <param name="_taxValue">
    ///    GWHTax transaction tax value.
    /// </param>
    /// <returns>
    ///    An amount to use to calculate the WHT tax.
    /// </returns>
    protected AmountCur calcPaymentAmtPerLineWithMarkupTrans_TH(SpecTrans _specTrans,
        InventTransId _inventTransId,
        boolean   _isCorrection,
        AmountCur _invoiceAmountLine,
        AmountCur _invoiceAmountAll,
        boolean _isInclTax,
        RefRecId _sourceDocumentLineRecId = 0,
        RefRecId _invoiceLineRecId = 0,
        boolean _calculateForMarkupTrans = false,
        AmountCur _invoiceAmountLineWithoutTax = 0,
        TaxValue _taxValue = 0)
    {
        CustTransCashDisc   custTransCashDisc;
        CashDiscAmount      cashDiscAmount;
        AmountCur           paymentAmtPerLine;
        TaxTrans            taxTrans;
        CustVendTransOpen   custVendTransOpen;
        SourceDocumentLine  sourceDocumentLine;

        if (_isCorrection)
        {
            if (_invoiceAmountAll)
            {
                paymentAmtPerLine = _invoiceAmountLine * _specTrans.Balance01 / _invoiceAmountAll;
            }
            else
            {
                paymentAmtPerLine = 0;
            }
        }
        else
        {
            paymentAmtPerLine = _invoiceAmountLine;
        }

        if (finalPayment)
        {
            cashDiscAmount = this.getCashdisc_TH(_specTrans);

            if (cashDiscAmount)
            {
                custVendTransOpen = _specTrans.custTransOpen();
                custTransCashDisc = CustTransCashDisc::findCashDisc(custVendTransOpen.TableId,
                                                                    custVendTransOpen.RecId);
                if (CashDisc::find(custTransCashDisc.CashDiscCode).Percent)
                {
                    if (_isInclTax)
                    {
                        cashDiscAmount = _invoiceAmountLine * (CashDisc::find(custTransCashDisc.CashDiscCode).Percent / 100);
                        paymentAmtPerLine += abs(cashDiscAmount);
                    }
                    else
                    {
                        TaxValue taxValue;

                        if(_calculateForMarkupTrans)
                        {
                            taxValue = _taxValue;
                        }
                        else
                        {
                            if (_sourceDocumentLineRecId)
                            {
                                select firstonly TaxValue from taxTrans
                                    exists join ParentSourceDocumentLine, RecId from sourceDocumentLine
                                    where taxTrans.SourceDocumentLine == sourceDocumentLine.RecId
                                        && sourceDocumentLine.ParentSourceDocumentLine == _sourceDocumentLineRecId;
                            }
                            else
                            {
                                select firstonly TaxValue from taxTrans
                                    where taxTrans.InventTransId == _inventTransId
                                    && (!enableWHTOnCharges || taxTrans.SourceTableId != tableNum(MarkupTrans));
                            }

                            taxValue = taxTrans.TaxValue;
                        }

                        if ( 100 + taxValue)
                        {
                            cashDiscAmount = (_invoiceAmountLine * 100 / ( 100 + taxValue)) *
                                                (CashDisc::find(custTransCashDisc.CashDiscCode).Percent / 100);
                        }
                        else
                        {
                            cashDiscAmount = 0;
                        }
                        paymentAmtPerLine += abs(cashDiscAmount);
                    }
                }
                else
                {
                    if (_invoiceAmountAll - abs(cashDiscAmount))
                    {
                        paymentAmtPerLine += cashDiscAmount * (_invoiceAmountLine / (_invoiceAmountAll - abs(cashDiscAmount)));
                    }
                    else
                    {
                        paymentAmtPerLine = 0;
                    }
                }
            }
        }

        return paymentAmtPerLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createItemTaxWithholdTrans_TH</Name>
				<Source><![CDATA[
    protected void createItemTaxWithholdTrans_TH(
        SpecTrans               _specTransLoc,
        CustVendTrans           _custVendTrans,
        AmountCur               _currentInvoiceAmountSettle,
        CrossExchRate           _settleExchRate,
        boolean                 _isCorrection,
        boolean                 _printMessageHeader)
    {
        CustInvoiceJour         custInvoiceJour;
        CustInvoiceTrans        custInvoiceTrans;
        boolean                 inclTax;
        boolean wasWHTChargeCodesCalculation;

        changecompany(_specTransLoc.RefCompany)
        {
            custInvoiceJour = CustInvoiceJour::findFromCustTrans(_custVendTrans.Invoice,
                                                                _custVendTrans.TransDate,
                                                                _custVendTrans.AccountNum);

            inclTax = custInvoiceJour.InclTax;

            if (enableWHTOnCharges)
            {
                // Generate TaxWithholdTrans record for GWHT for charge codes for the order or invoice headers.
                wasWHTChargeCodesCalculation = this.createItemTaxWithholdTransForChargeCodeHeader(_specTransLoc,
                    _custVendTrans,
                    custInvoiceJour,
                    _currentInvoiceAmountSettle,
                    _settleExchRate,
                    _isCorrection,
                    inclTax,
                    _printMessageHeader);

                _printMessageHeader = !wasWHTChargeCodesCalculation;
            }

            // Loop through each line of the invoice and calculate the WHT amount.
            while select custInvoiceTrans
                    where custInvoiceTrans.SalesId == custInvoiceJour.SalesId
                        && custInvoiceTrans.InvoiceDate == custInvoiceJour.InvoiceDate
                        && custInvoiceTrans.InvoiceId == custInvoiceJour.InvoiceId
                        && custInvoiceTrans.NumberSequenceGroup == custInvoiceJour.NumberSequenceGroup
            {
                // Determine if each line has all the WHT info.
                if (this.isCalculateTaxWithholdingNeeded_TH(
                        custInvoiceTrans.TaxWithholdGroup_TH,
                        custInvoiceTrans.TaxWithholdItemGroupHeading_TH,
                        custInvoiceTrans))
                {
                    //  Determine if Custor number needs to printed.
                    this.printTaxWithholdHeaderInfo(_printMessageHeader, _custVendTrans.AccountNum);

                    // Generate TaxWithholdTrans record that will have WHT info.
                    this.generateTaxWithholdRecordWithMarkupTrans(_specTransLoc,
                        _custVendTrans,
                        custInvoiceTrans,
                        _currentInvoiceAmountSettle,
                        custInvoiceTrans.TaxWithholdItemGroupHeading_TH,
                        _settleExchRate,
                        _isCorrection,
                        inclTax);

                    _printMessageHeader = false;
                }

                if (enableWHTOnCharges)
                {
                    // Generate TaxWithholdTrans record for GWHT for charge codes for the order or invoice line.
                    wasWHTChargeCodesCalculation = this.createItemTaxWithholdTransForChargeCodeLines(_specTransLoc,
                        _custVendTrans,
                        custInvoiceTrans,
                        _currentInvoiceAmountSettle,
                        _settleExchRate,
                        _isCorrection,
                        inclTax,
                        _printMessageHeader);

                    _printMessageHeader = !wasWHTChargeCodesCalculation;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxWithholdTrans</Name>
				<Source><![CDATA[
    public void createTaxWithholdTrans(CustVendTrans    _custTrans,
                                    SpecTrans           _specTrans,
                                    AmountCur           _invoiceAmountSettle,
                                    CrossExchRate       _settleExchRate,
                                    boolean             _printMessageHeader = true)
    {
        TaxWithholdTrans      taxWithholdTrans;
        TaxWithholdGroupData  taxWithholdGroupData;
        TmpTaxWithhold        tmpTaxWithhold;
        boolean               printMessageHeader = _printMessageHeader;
        CustTable             customer;
        Map                   mapOfTaxesToBeCalculated;
        MapEnumerator         enumerator;
        AmountCur             invoiceAmountSettle = _invoiceAmountSettle;
        // <GBR>
        AmountCur             taxWithholdTotalAmount;
        // </GBR>

        if (_custTrans.Invoice == '')
        {
            //only calculate tax withholding if VendTrans has an invoice number
            return;
        }

        // Find the customer of the account number and company from the vendTrans
        customer = CustTable::findByCompany(_custTrans.company(), _custTrans.AccountNum);

        if (customer.TaxWithholdCalculate_TH == false && ledgerJournalTrans.TaxWithholdGroup == '')
        {
            // neither the payment of invoice vendor have tax withholding no calculation needed.
            return;
        }
        else if ((customer.TaxWithholdCalculate_TH == false && ledgerJournalTrans.TaxWithholdGroup != '')
            || (customer.TaxWithholdCalculate_TH == true && ledgerJournalTrans.TaxWithholdGroup == ''))
        {
            // give worning message that tax won't be calculated
            info("@SYS120362");

            TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                GlobalizationConstants::FeatureReferenceTAX00037,
                funcName(),
                TaxWithHoldInstrumentationTelemetry::SettleTransactions,
                this.parentTypeForGHWTTelemetry(),
                false,
                0,
                0);

            return;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            //only calculate tax withholding if VendTrans has an withholding tax calculation and is not credit payment
            if (this.isCreditPayment_BR(_custTrans))
            {
                warning("@GLS50773");

                TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                    GlobalizationConstants::FeatureReferenceTAX00037,
                    funcName(),
                    TaxWithHoldInstrumentationTelemetry::SettleTransactions,
                    this.parentTypeForGHWTTelemetry(),
                    false,
                    0,
                    0);

                return;
            }

            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceBR00042, funcName());
        }
        // </GBR>

        Debug::assert(curext() == _custTrans.company());

        mapOfTaxesToBeCalculated = TaxWithhold::getInvoiceTaxWithholdIntersection_BR(_custTrans);

        if (!mapOfTaxesToBeCalculated.elements())
        {
            TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
                GlobalizationConstants::FeatureReferenceTAX00037,
                funcName(),
                TaxWithHoldInstrumentationTelemetry::SettleTransactions,
                this.parentTypeForGHWTTelemetry(),
                false,
                0,
                0);

            return;
        }

        // GWHT telemetry
        int64 createdWithholdingTaxCount;
        TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

        ttsbegin;

        enumerator = mapOfTaxesToBeCalculated.getEnumerator();

        while (enumerator.moveNext())
        {
            taxWithholdTrans.clear();
            taxWithholdGroupData.TaxWithholdCode = conPeek(enumerator.currentKey(), 2);

            if (BrazilParameters::isEnabled())
            {
                taxWithholdTrans.IntersectionWithholdBaseAmount_BR = enumerator.currentValue();
            }

            selectedTaxWithholdTrans = new RecordSortedList(tablenum(TaxWithholdTrans));
            selectedTaxWithholdTrans.sortOrder(fieldnum(TaxWithholdTrans, RecId));

            this.initTaxWithholdTrans(taxWithholdTrans,
                                      _custTrans,
                                      _specTrans,
                                      _invoiceAmountSettle,
                                      customer.TaxWithholdGroup_TH);
            taxWithholdTrans.insert();
            this.findTmpTaxWithhold(taxWithholdTrans); // creates a new TmpTaxWithhold in TmpTaxWithholdList
            taxWithholdTrans.TaxWithholdCode = taxWithholdGroupData.TaxWithholdCode;
            taxWithholdTrans = this.initFromTaxWithholdCode(taxWithholdTrans, _settleExchRate);
            taxWithholdTrans.update();

            // <GBR>
            if (BrazilParameters::isEnabled() &&
                !taxWithholdTrans.InvoiceTaxWithholdAmount)
            {
                printMessageHeader = false;
            }
            // </GBR>

            if (printMessageHeader)
            {
                this.printTaxWithholdHeaderInfo(printMessageHeader, taxWithholdTrans.CustAccount);
            }

            tmpTaxWithhold = this.findTmpTaxWithhold(taxWithholdTrans);
            if (taxWithholdTrans.InvoiceTaxWithholdAmount
            // <GBR>
                && !BrazilParameters::isEnabled())
            // </GBR>
            {
                info (strfmt("@GLS615", taxWithholdTrans.Invoice,
                                        taxWithholdTrans.InvoiceCurrency,
                                        abs(taxWithholdTrans.InvoiceWithholdBaseAmount),
                                        tmpTaxWithhold.TaxWithholdCode,
                                        abs(tmpTaxWithhold.TaxWithholdBase),
                                        abs(taxWithholdTrans.InvoiceTaxWithholdAmount)));
            }

            printMessageHeader = false;
            // <GBR>
            taxWithholdTotalAmount += taxWithholdTrans.InvoiceTaxWithholdAmount;
            // </GBR>

            createdWithholdingTaxCount++;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            // if the withholding tax amount is higher than the payment amount, the withholding tax amount should be limited up to payment amount.
            if (taxWithholdTotalAmount && abs(taxWithholdTotalAmount) > abs(_invoiceAmountSettle))
            {
                this.adjustWhtAmountPaymLimit_BR(_specTrans, taxWithholdTotalAmount, _invoiceAmountSettle);
            }

            this.printWhtTransAmount_BR(_specTrans);
        }
        // </GBR>

        ttscommit;

        TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
            GlobalizationConstants::FeatureReferenceTAX00037,
            funcName(),
            TaxWithHoldInstrumentationTelemetry::SettleTransactions,
            this.parentTypeForGHWTTelemetry(),
            true,
            createdWithholdingTaxCount,
            stopwatch.elapsedMilliseconds());
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTaxWithholdTrans_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the withholding taxes based on each invoice and tax withholding group and tax
    ///    withholding item group that is specified on each invoice line.
    /// </summary>
    /// <param name="_specTrans">
    ///    A <c>SpecTrans</c> table buffer that references the payment record for which the calculation will
    ///    be done.
    /// </param>
    /// <param name="_settleExchRate">
    ///    The exchange rate to use during calculation.
    /// </param>
    /// <param name="_printMessageHeader">
    ///    A parameter that will determine whether the vendor or customer name has to be printed on the
    ///    withholding dialog box.
    /// </param>
    /// <remarks>
    ///    This withholding calculation checks whether the amount is a based amount.
    ///
    ///    This method uses caching.  If adding a new call to this method please be
    ///    sure to clear the cache after the call.  See the method <c>clearCache</c> on the
    ///    <c>TaxWithhold</c> class.
    /// </remarks>
    void createTaxWithholdTrans_TH(SpecTrans                   _specTrans,
                                       CrossExchRate           _settleExchRate,
                                       boolean                 _printMessageHeader = true)
    {
        boolean                 printMessageHeader = _printMessageHeader;

        AmountCur               adjustedAllInvoicesAmountSettleTotal;
        AmountCur               currentInvoiceAmountSettle;

        boolean                 isCorrection = false;
        boolean                 isAllInvoiceAmountSettleTotalCalculated = false;
        TaxWithholdBase         taxWithholdMinAmount;
        CustTrans               custTrans;
        SpecTrans               specTransLoc;
        CustInvoiceJour         custInvoiceJour;
        QueryRun                queryRun = new QueryRun(queryStr(TaxWithholdCustQuery_TH));

        overrideWithholding     = false;
        taxWithholdMinAmount = abs(LedgerParameters::find().TaxWithholdMinInvoice_TH);

        // Loop through all the settlement records for the given payment record.
        // Calculated the withholding tax for each invoice.

        ttsbegin;

        queryRun.query().dataSourceTable(tableNum(SpecTrans)).addRange(fieldNum(SpecTrans, SpecRecId)).value(queryValue(_specTrans.SpecRecId));
        queryRun.query().dataSourceTable(tableNum(SpecTrans)).addRange(fieldNum(SpecTrans, SpecCompany)).value(queryValue(_specTrans.SpecCompany));
        queryRun.query().dataSourceTable(tableNum(SpecTrans)).addRange(fieldNum(SpecTrans, SpecTableId)).value(queryValue(_specTrans.SpecTableId));

        if (_specTrans.RefTableId == tableNum(CustTransOpen))
        {
            CustTransOpen custTransOpen = CustTransOpen::find(_specTrans.RefRecId);
            custTrans = CustTransOpen::find(_specTrans.RefRecId).custTrans();

            queryRun.query().dataSourceTable(tableNum(CustTrans)).addRange(fieldNum(CustTrans, RecId)).value(queryValue(custTransOpen.RefRecId));
            queryRun.query().dataSourceTable(tableNum(CustInvoiceJour)).addRange(fieldNum(CustInvoiceJour, InvoiceAccount)).value(queryValue(custTransOpen.AccountNum));
            queryRun.query().dataSourceTable(tableNum(CustInvoiceJour)).addRange(fieldNum(CustInvoiceJour, InvoiceId)).value(queryValue(custTrans.Invoice));
            queryRun.query().dataSourceTable(tableNum(CustInvoiceJour)).addRange(fieldNum(CustInvoiceJour, InvoiceDate)).value(queryValue(custTrans.TransDate));
            queryRun.query().dataSourceTable(tableNum(CustInvoiceTrans)).addRange(fieldNum(CustInvoiceTrans, InvoiceId)).value(queryValue(custTrans.Invoice));
            queryRun.query().dataSourceTable(tableNum(CustInvoiceTrans)).addRange(fieldNum(CustInvoiceTrans, InvoiceDate)).value(queryValue(custTrans.TransDate));
        }

        while (queryRun.next())
        {
            specTransLoc     = queryRun.get(tableNum(SpecTrans));
            custTrans        = queryRun.get(tableNum(custTrans));
            custInvoiceJour  = queryRun.get(tableNum(CustInvoiceJour));

            if (this.shouldSkipForCreatingWithholdingTax(custTrans))
            {
                continue;
            }

            currentInvoiceAmountSettle = this.totalInvoiceAmountSettled_TH(specTransLoc,
                                                                           null,
                                                                           null,
                                                                            custTrans,
                                                                            custInvoiceJour);

            isCorrection = (currentInvoiceAmountSettle != specTransLoc.Balance01);

            if (abs(currentInvoiceAmountSettle) >= taxWithholdMinAmount)
            {
                this.createItemTaxWithholdTrans_TH(
                    specTransLoc,
                    custTrans,
                    currentInvoiceAmountSettle,
                    _settleExchRate,
                    isCorrection,
                    _printMessageHeader);
            }
            else
            {
                // Determine the total base amount for all the invoices marked for seattlement.
                if (!isAllInvoiceAmountSettleTotalCalculated)
                {
                    adjustedAllInvoicesAmountSettleTotal = this.totalAllInvoicesAmountSettled_TH(specTransLoc);
                    isAllInvoiceAmountSettleTotalCalculated = true;
                }

                if (abs(adjustedAllInvoicesAmountSettleTotal) >= taxWithholdMinAmount)
                {
                    this.createItemTaxWithholdTrans_TH(
                        specTransLoc,
                        custTrans,
                        currentInvoiceAmountSettle,
                        _settleExchRate,
                        isCorrection,
                        _printMessageHeader);
                }
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccumulatedPaymentAmount_BR</Name>
				<Source><![CDATA[
    protected void getAccumulatedPaymentAmount_BR(TaxWithholdTable _taxWithholdTable)
    {
        LedgerJournalTrans              localLedgerJournalTrans;
        LedgerJournalTransPayment_BR    localLedgerJournalTransPaym;
        TaxWithholdTrans    taxWithholdTrans;

        date                periodStart;
        date                periodEnd;

        container               dataAreaIdList = this.crossCompanyList_BR();

        QueryRun qr;

        dataAreaId              taxWithholdCompany = SalesParameters::find().TaxWithholdCompany_BR;

        accumPayment    = 0;
        sumAccumpayment = 0;
        accumBaseAmountFromPreviousPayment = 0;

        if (_taxWithholdTable.TaxWithholdBaseType != TaxWithholdBaseType::PctGrsAmtMonth)
        {
            return ;
        }

        periodStart = dateStartMth(ledgerJournalTrans.TransDate);
        periodEnd   = dateEndMth(periodStart);

        // accumulated in closed/posted transactions
        select crosscompany : dataAreaIdList sum(InvoiceBaseAmount)
            from taxWithholdTrans
                        where taxWithholdTrans.PartyId_BR                        == this.partyId_BR() &&
                              taxWithholdTrans.Source_BR                         == TaxWithholdSource::CustPayment &&
                              taxWithholdTrans.TaxWithholdCode                   == _taxWithholdTable.TaxWithholdCode &&
                              taxWithholdTrans.TransDate                         >= periodStart &&
                              taxWithholdTrans.TransDate                         <= periodEnd &&
                              taxWithholdTrans.TaxWithholdIsSelected_BR          == NoYes::Yes
                exists join localLedgerJournalTrans
                    where   localLedgerJournalTrans.RecId                      == taxWithholdTrans.LedgerJourTransRecId_BR
                exists join localLedgerJournalTransPaym
                    where localLedgerJournalTransPaym.TaxWithholdEditStatus_BR   == LedgerTransTaxWithholdEditStatus_BR::Closed;

        sumAccumpayment = taxWithholdTrans.InvoiceBaseAmount;

        qr = this.accumulatedPaymentQueryRun_BR(_taxWithholdTable, periodStart, periodEnd);
        qr.allowCrossCompany(SalesParameters::find().TaxWithholdCalculateCrossCompany_BR);

        while (qr.next())
        {
            taxWithholdTrans = qr.get(tablenum(TaxWithholdTrans));

            changecompany(taxWithholdTrans.DataAreaId)
            {
                // do not sum payment if withholding company is different
                if (qr.allowCrossCompany() && SalesParameters::find().TaxWithholdCompany_BR != taxWithholdCompany)
                {
                    continue;
                }
            }

            accumPayment +=   taxWithholdTrans.TaxWithholdAccumulatedBaseAmount ? 0 : taxWithholdTrans.InvoiceWithholdBaseAmount
                            - taxWithholdTrans.TaxNotTaxableByTreaty
                            - taxWithholdTrans.TaxNotTaxableExpenses;

            accumBaseAmountFromPreviousPayment += -taxWithholdTrans.TaxWithholdAccumulatedBaseAmount;

            selectedTaxWithholdTrans.ins(taxWithholdTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCashdisc_TH</Name>
				<Source><![CDATA[
    protected AmountCur getCashdisc_TH(SpecTrans   _specTrans)
    {
        CustTransCashDisc  custTransCashDisc;
        CustTransOpen custTransOpen;

        custTransOpen = CustTransOpen::find(_specTrans.RefRecId);
        custTransCashDisc = CustTransCashDisc::find(tablenum(CustTransOpen),
                                                    custTransOpen.RecId,
                                                    ledgerJournalTrans.TransDate,
                                                    CustPaymModeTable::discGraceDays(ledgerJournalTrans.PaymMode));
        return custTransCashDisc.CashDiscAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceAmountInclDisc_TH</Name>
				<Source><![CDATA[
    // function to get the Final Payment when the WitholdBase amount is specified
    protected AmountCur getInvoiceAmountInclDisc_TH(SpecTrans _specTrans, CustVendTrans _custVendTrans, AmountCur _invoiceAmountSettle)
    {
        AmountCur   cashDiscAmt;
        AmountCur   finalPaymentAmount;

        finalPayment = false;
        finalPaymentAmount = _custVendTrans.AmountCur - _custVendTrans.SettleAmountCur;
        cashDiscAmt = this.getCashdisc_TH(_specTrans);

        if ((_specTrans.Balance01 + cashDiscAmt) == finalPaymentAmount)
        {
            finalPayment = true;
            return finalPaymentAmount;
        }

        return _invoiceAmountSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxWithholdGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets withholding tax group for specified customer or vendor transaction.
    /// </summary>
    /// <param name="_custVendTrans">
    /// A <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <returns>
    /// Withholding tax group.
    /// </returns>
    protected TaxWithholdGroup getTaxWithholdGroup(CustVendTrans _custVendTrans)
    {
        // <GTH>
        if (isTaxWithholdEnabledTH)
        {
            if (ledgerJournalTrans.TaxWithholdGroup)
            {
                return ledgerJournalTrans.TaxWithholdGroup;
            }
        }
        // </GTH>

        return CustTable::findByCompany(_custVendTrans.company(), _custVendTrans.AccountNum).TaxWithholdGroup_TH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromTaxWithholdCode</Name>
				<Source><![CDATA[
    public TaxWithholdTrans initFromTaxWithholdCode(TaxWithholdTrans _taxWithholdTrans, CrossExchRate _settleExchRate)
    {
        TaxWithholdTrans taxWithholdTrans;

        taxWithholdTrans = super(_taxWithholdTrans, _settleExchRate);

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            taxWithholdTrans.LedgerDimension = TaxWithholdTable::find(taxWithholdTrans.TaxWithholdCode).TaxIncomingLedgerDimension_BR;
        }
        // </GBR>

        return taxWithholdTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCalculateTaxWithholdingNeeded_TH</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method will determine if the withholding tax needs to be calculated.
    /// </summary>
    /// <param name="_taxWithholdGroup">
    /// The id of the Tax withholding group specified for the transaction.
    /// </param>
    /// <param name="_taxWithholdItemGroupId_TH">
    /// The id of the Tax withholding item group specified for the transaction.
    /// </param>
    /// <param name="_custVendInvoiceTrans">
    /// CustVendInvoiceTrans record used to determine the item type.
    /// </param>
    /// <returns>
    /// If the tax withholding group, tax withholding Item group, and the item is service type,
    /// and the journal is marked of WHT calculation, function returns true.
    /// Otherwise, the return value is false.
    /// </returns>
    protected boolean isCalculateTaxWithholdingNeeded_TH(
        TaxWithholdGroup            _taxWithholdGroup,
        TaxWithholdItemGroupId_TH   _taxWithholdItemGroupId_TH,
        CustVendInvoiceTrans   _custVendInvoiceTrans)
    {
        boolean returnValue = super(_taxWithholdGroup, _taxWithholdItemGroupId_TH, _custVendInvoiceTrans);

        if (isTaxWithholdEnabledTH)
        {
            return returnValue;
        }

        returnValue = returnValue
            && (ledgerJournalTrans.TaxWithholdCalculate_TH == NoYes::Yes
            || (ledgerJournalTrans.TaxWithholdCalculate_TH == NoYes::No
            &&  CustPaymModeTable::find(ledgerJournalTrans.PaymMode).PaymOnInvoice == NoYes::Yes));

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCreditPayment_BR</Name>
				<Source><![CDATA[
    protected boolean isCreditPayment_BR(CustVendTrans _custTrans)
    {
        return _custTrans.AmountCur <= 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>partyId_BR</Name>
				<Source><![CDATA[
    protected DirPartyNumber partyId_BR()
    {
        CustTable custTable;

        changeCompany(ledgerJournalTrans.Company)
        {
            custTable = CustTable::find(ledgerJournalTrans.parmAccount());
        }

        return DirPartyTable::findRec(custTable.Party).PartyNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printTaxWithholdHeaderInfo</Name>
				<Source><![CDATA[
    // /<GBR>
    protected void printTaxWithholdHeaderInfo(boolean _printMessageHeader, CustVendAC _custVendAccount)
    {
        if (_printMessageHeader)
        {
            info (strfmt("@SYS316728", _custVendAccount));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdCalculate_BR</Name>
				<Source><![CDATA[
    protected boolean taxWithholdCalculate_BR()
    {
        return CustTable::find(ledgerJournalTrans.parmAccount()).TaxWithholdCalculate_TH;
    }

]]></Source>
			</Method>
			<Method>
				<Name>taxWithholdSource_BR</Name>
				<Source><![CDATA[
    protected TaxWithholdSource taxWithholdSource_BR()
    {
        return TaxWithholdSource::CustPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalinvoiceAmountSettled_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the sum of all the invoices base amount to use to determine the WHT tax.
    /// </summary>
    /// <param name="_specTrans">
    ///    The <c>SpecTrans</c> table buffer that references the settlement record and related to the invoices.
    /// </param>
    /// <param name="_vendTrans">
    ///    The <c>VendTrans</c> table buffer; optional.
    /// </param>
    /// <param name="_vendInvoiceJour">
    ///    The <c>VendInvoiceJour</c> table buffer; optional.
    /// </param>
    /// <param name="_custTrans">
    ///    The <c>CustTrans</c> table buffer; optional.
    /// </param>
    /// <param name="_custInvoiceJour">
    ///    The <c>CustInvoiceJour</c> table buffer; optional.
    /// </param>
    /// <returns>
    ///    The total base amount of all invoices marked as settlement.
    /// </returns>
    protected AmountCur totalinvoiceAmountSettled_TH(SpecTrans _specTrans,
                                                     VendTrans       _vendTrans = null,
                                                     VendInvoiceJour _vendInvoiceJour = null,
                                                     CustTrans _custTrans = null,
                                                     CustInvoiceJour _custInvoiceJour = null)
    {
        #Tax
        AmountCur   totalInvoiceAmount;
        CustInvoiceJour custInvoiceJourLoc;
        CustInvoiceTrans custInvoiceTransLoc;
        CustTrans    custTransLoc;
        SysGlobalCache          cache = classfactory.globalCache();

        if (cache.isSet(#TaxWithholdCustPaymCacheKey, _specTrans.RecId) == true)
        {
            return cache.get(#TaxWithholdCustPaymCacheKey, _specTrans.RecId);
        }

        if (_custTrans)
        {
            custTransLoc = _custTrans;
        }
        else
        {
            custTransLoc = _specTrans.custTrans();
        }

        if (custTransLoc.Invoice == '')
        {
            //only calculate tax withholding if VendTrans has an invoice number
            cache.set(#TaxWithholdCustPaymCacheKey, _specTrans.RecId, 0);
            return 0;
        }

        changecompany(_specTrans.RefCompany)
        {
            if (_custInvoiceJour)
            {
                custInvoiceJourLoc = _custInvoiceJour;
            }
            else
            {
                custInvoiceJourLoc = CustInvoiceJour::findFromCustTrans(custTransLoc.Invoice,
                                                                        custTransLoc.TransDate,
                                                                        custTransLoc.AccountNum);
            }

            if (enableWHTOnCharges) // including markupTrans for header
            {
                totalInvoiceAmount += this.findMarkupValue_TH(tableNum(CustInvoiceJour), custInvoiceJourLoc.RecId);
            }

            while select custInvoiceTransLoc
                    where custInvoiceTransLoc.SalesId == custInvoiceJourLoc.SalesId
                        && custInvoiceTransLoc.InvoiceDate == custInvoiceJourLoc.InvoiceDate
                        && custInvoiceTransLoc.InvoiceId == custInvoiceJourLoc.InvoiceId
                        && custInvoiceTransLoc.NumberSequenceGroup == custInvoiceJourLoc.NumberSequenceGroup
            {
                totalInvoiceAmount += this.totalInvoiceLineAmountSettled_TH(custInvoiceTransLoc,
                                                                            custInvoiceJourLoc.InclTax);
            }
        }

        cache.set(#TaxWithholdCustPaymCacheKey, _specTrans.RecId, totalInvoiceAmount);

        return totalInvoiceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalInvoiceLineAmountSettled_TH</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the sum of an invoice base amount that will be used to determine the WHT tax.
    /// </summary>
    /// <param name="_custVendInvoiceTrans">
    ///    A <c>CustVendInvoiceTrans</c> that references the invoices.
    /// </param>
    /// <param name="_inclTax">
    ///    A parameter that indicates whether the invoice has taxes included.
    /// </param>
    /// <returns>
    ///    The total base amount of an invoice marked of settlement.
    /// </returns>
    protected AmountCur totalInvoiceLineAmountSettled_TH(
        CustVendInvoiceTrans _custVendInvoiceTrans, 
        boolean _inclTax)
    {
        TaxTrans            taxTransLoc;
        AmountCur           totalInvoiceAmount;
        AmountCur           costAmountPosted;
        SourceDocumentLine  sourceDocumentLine;

        CustInvoiceTrans custInvoiceTransLoc = _custVendInvoiceTrans;

        if (_inclTax)
        {
            costAmountPosted = custInvoiceTransLoc.LineAmount + custInvoiceTransLoc.LineAmountTax;
        }
        else
        {
            costAmountPosted = custInvoiceTransLoc.LineAmount;
        }

        if (_inclTax)
        {
            select firstonly taxTransLoc
                where taxTransLoc.InventTransId == custInvoiceTransLoc.InventTransId;

            costAmountPosted = costAmountPosted * 100 / (100 + taxTransLoc.TaxValue);
        }

        totalInvoiceAmount = costAmountPosted + custInvoiceTransLoc.LineAmountTax;

        if (!skipMarkupTransOnLines)
        {
            totalInvoiceAmount += this.findMarkupValue_TH(tablenum(CustInvoiceTrans), custInvoiceTransLoc.RecId);
        }

        if (!_inclTax)
        {
            AmountCur taxTransAmount;
            taxTransAmount = this.getSalesTaxAmount(custInvoiceTransLoc);
            totalInvoiceAmount -= taxTransAmount;
        }

        return CurrencyExchangeHelper::amount(totalInvoiceAmount, custInvoiceTransLoc.CurrencyCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesTaxAmount</Name>
				<Source><![CDATA[
    private AmountCur getSalesTaxAmount(CustInvoiceTrans _custInvoiceTransLoc)
    {
        SourceDocumentLine sourceDocumentLine;
        if (_custInvoiceTransLoc.SourceDocumentLine)
        {
            // CustInvoiceTransLoc.SourceDocumentLine for sales order is also not empty, so add this to make sure SO can go to invent trans id approach
            select firstonly RecId from sourceDocumentLine
                where sourceDocumentLine.ParentSourceDocumentLine == _custInvoiceTransLoc.SourceDocumentLine
                    && sourceDocumentLine.SourceRelationType == tableNum(TaxTrans);
        }

        TaxTrans taxTransLoc;
        if (sourceDocumentLine)
        {
            select sum(SourceTaxAmountCur) from taxTransLoc
                join sourceDocumentLine
                where taxTransLoc.SourceDocumentLine == sourceDocumentLine.RecId
                    && sourceDocumentLine.ParentSourceDocumentLine == _custInvoiceTransLoc.SourceDocumentLine;
        }
        else if (_custInvoiceTransLoc.InventTransId)
        {
            // Keep original logic, to get all the tax trans amount, not only current invoice, avoid break anyone.
            select sum(SourceTaxAmountCur) from taxTransLoc
                where taxTransLoc.InventTransId == _custInvoiceTransLoc.InventTransId
                    && (!enableWHTOnCharges || taxTransLoc.SourceTableId != tableNum(MarkupTrans));
        }

        return taxTransLoc.SourceTaxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowedReverseTaxWithHold_BR</Name>
				<Source><![CDATA[
    public static boolean allowedReverseTaxWithHold_BR(
                                    TaxWithholdTrans _taxWithholdTrans,
                                    TransDate      _paymentDate)
    {
        TaxWithholdTrans            rschTaxWithholdTrans;
        date                        periodStart;
        date                        periodEnd;
        ;

        periodStart = Global::dateStartMth(_paymentDate);
        periodEnd   = Global::dateEndMth(periodStart);

        // See if any WHT records exist created after this taxwithHoldTrans record, is for the same customer,
        // is for the same month, uses the same code, has WHT calculated, and has not been previously reversed.  If a record
        // is found, then this taxwithHoldTrans record was included in WHT of some other payment.  Therefore,
        // this record cannot be reversed.  You must first reverse other WHT trans that occurred after
        // this taxHoldTransData record.
        select firstonly rschTaxWithholdTrans
        order by RecId asc
        where (rschTaxWithholdTrans.CustAccount                 == _taxWithholdTrans.CustAccount        // Same customer
              && rschTaxWithholdTrans.TransDate                 >= periodStart                          // Within same month
              && rschTaxWithholdTrans.TransDate                 <= periodEnd
              && rschTaxWithholdTrans.TaxWithholdCode           == _taxWithholdTrans.TaxWithholdCode    // Using same code
              && rschTaxWithholdTrans.RecId                     >  _taxWithholdTrans.RecId              // Record created after withHoldTransData
              && rschTaxWithholdTrans.Voucher                  != _taxWithholdTrans.Voucher             // Not posted on the same voucher
              && (rschTaxWithholdTrans.InvoiceTaxWithholdAmount != 0                                    // Has WHT calculated
              || rschTaxWithholdTrans.TaxWithholdBaseAmount     != 0)
              && rschTaxWithholdTrans.CanBeReversed_BR          == NoYes::Yes);                         // Has not been prviously reversed
        if (rschTaxWithholdTrans)
        {
            throw error("@GLS2210");
            //This record was already considered into the tax withHold amount
            //calculation for the current period
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustTransForReverseTaxWithhold_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates CustTrans records to reverse the settled tax withholding transaction.
    /// </summary>
    /// <param name="_existingCustTransTaxWithhold">
    /// The CustTrans record that will be reversed.
    /// </param>
    /// <param name="_voucher">
    /// The voucher number of the reversal transction.
    /// </param>
    /// <param name="_reversalTransDate">
    /// The date of the reversal transaction.
    /// </param>
    public static void createCustTransForReverseTaxWithhold_BR(
        CustTrans _existingCustTransTaxWithhold,
        Voucher _voucher,
        TransDate _reversalTransDate)
    {
        CustTrans offsetCustTransReversed;
        CustTransOpen   custTransOpen;
        ;

        // create a new cust trans that reverse the cust trans for tax withholding
        offsetCustTransReversed.data(_existingCustTransTaxWithhold);

        offsetCustTransReversed.Voucher = _voucher;
        offsetCustTransReversed.TransDate = _reversalTransDate;

        offsetCustTransReversed.AmountCur = -_existingCustTransTaxWithhold.AmountCur;
        offsetCustTransReversed.AmountMST = -_existingCustTransTaxWithhold.AmountMST;
        offsetCustTransReversed.SettleAmountCur = offsetCustTransReversed.AmountCur;
        offsetCustTransReversed.SettleAmountMST = offsetCustTransReversed.AmountMST;
        offsetCustTransReversed.ExchAdjustment = -_existingCustTransTaxWithhold.ExchAdjustment;
        offsetCustTransReversed.CustExchAdjustmentRealized = -_existingCustTransTaxWithhold.CustExchAdjustmentRealized;
        offsetCustTransReversed.CustExchAdjustmentUnrealized = -_existingCustTransTaxWithhold.CustExchAdjustmentUnrealized;

        offsetCustTransReversed.LastSettleDate = _reversalTransDate;
        offsetCustTransReversed.LastSettleVoucher = _existingCustTransTaxWithhold.Voucher;
        offsetCustTransReversed.LastSettleAccountNum = _existingCustTransTaxWithhold.AccountNum;
        offsetCustTransReversed.LastSettleCompany = _existingCustTransTaxWithhold.DataAreaId;
        offsetCustTransReversed.OffsetRecid = _existingCustTransTaxWithhold.RecId;

        offsetCustTransReversed.Closed = _reversalTransDate;

        offsetCustTransReversed.Txt = strfmt('%1 %2', "@SYS110624", _existingCustTransTaxWithhold.Txt);

        offsetCustTransReversed.insert();

        // update the existing tax withhold cust trans record
        _existingCustTransTaxWithhold.SettleAmountMST = _existingCustTransTaxWithhold.AmountMST;
        _existingCustTransTaxWithhold.SettleAmountCur = _existingCustTransTaxWithhold.AmountCur;

        _existingCustTransTaxWithhold.LastSettleDate = _reversalTransDate;
        _existingCustTransTaxWithhold.LastSettleVoucher = offsetCustTransReversed.Voucher;
        _existingCustTransTaxWithhold.LastSettleAccountNum = offsetCustTransReversed.AccountNum;
        _existingCustTransTaxWithhold.LastSettleCompany = offsetCustTransReversed.DataAreaId;

        _existingCustTransTaxWithhold.Closed = _reversalTransDate;
        _existingCustTransTaxWithhold.OffsetRecid = offsetCustTransReversed.RecId;
        _existingCustTransTaxWithhold.update();

        delete_from custTransOpen
            where custTransOpen.RefRecId == _existingCustTransTaxWithhold.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>markRelatedVouchers_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Marks releated tax withold settlement records when the payment
    /// transaction is marked.
    /// </summary>
    /// <param name="_currencyCode">
    /// The currency for the settlement record.
    /// </param>
    /// <param name="_custSettlement">
    /// The CustSettlement record that is being marked.
    /// </param>
    /// <param name="_specification">
    /// The current <c>SpecTransManager</c> instance containing marked settlements for reversal.
    /// </param>
    /// <remarks>
    /// Method is called any time a payment settlement records is marked
    /// for reversal since tax withhold transactions should always be reversed
    /// when reversing the payment.
    /// </remarks>
    static void markRelatedVouchers_BR(
        CustCurrencyCode _currencyCode,
        CustSettlement _custSettlement,
        SpecTransManager  _specification)
    {
        CustSettlement          custSettlement;
        boolean                 payment = false;
        CustTrans               custTrans;
        ;

        if (_custSettlement.SettleAmountCur > 0)
        {
                payment = true;
        }

        if (payment)
        {
            while select crosscompany custSettlement where
                custSettlement.TransRecId    == _custSettlement.TransRecId &&
                custSettlement.TransCompany  == _custSettlement.TransCompany &&
                custSettlement.CanBeReversed == true &&
                custSettlement.TransDate     == _custSettlement.TransDate &&
                custSettlement.AccountNum    == _custSettlement.AccountNum &&
                custSettlement.RecId         != _custSettlement.RecId
            {
                custTrans = custSettlement.custVendTrans();

                // Only want payments, invoices, or withholding tax  Cust type is used for withholding tax.
                if (custTrans.TransType == LedgerTransType::Cust ||
                    custTrans.TransType == LedgerTransType::None ||
                    custTrans.TransType == LedgerTransType::Payment ||
                    custTrans.TransType == LedgerTransType::Sales)
                {
                    if ( custSettlement && _specification.existForOtherSpec(_custSettlement.DataAreaId, _custSettlement.TableId, _custSettlement.RecId) == false)
                    {
                        custSettlement.CustVendSettlement::markThisAndRelatedOffsets(_specification, _currencyCode);
                    }
                }
            }
        }
        else
        {
            while select crosscompany custSettlement where
                custSettlement.OffsetRecid   == _custSettlement.OffsetRecid &&
                custSettlement.OffsetCompany == _custSettlement.OffsetCompany &&
                custSettlement.CanBeReversed == true &&
                custSettlement.TransDate     == _custSettlement.TransDate &&
                custSettlement.AccountNum    == _custSettlement.AccountNum &&
                custSettlement.RecId         != _custSettlement.RecId
            {
                custTrans = custSettlement.custVendTrans();

                // Only want payments, invoices, or withholding tax  Cust type is used for withholding tax.
                if (custTrans.TransType == LedgerTransType::Cust ||
                    custTrans.TransType == LedgerTransType::None ||
                    custTrans.TransType == LedgerTransType::Payment ||
                    custTrans.TransType == LedgerTransType::Sales)
                {
                    if (_specification.existForOtherSpec(_custSettlement.DataAreaId, _custSettlement.TableId, _custSettlement.RecId) == false)
                    {
                        custSettlement.CustVendSettlement::markThisAndRelatedOffsets(_specification, _currencyCode);
                    }
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxWithhold</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts and settles the tax withholding transaction.
    /// </summary>
    /// <param name="_paymTransLedgerVoucher">
    ///    The <c>LedgerVoucher</c> object of the payment transaction.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that is associated with the tax withholding.
    /// </param>
    public static void postTaxWithhold(
        LedgerVoucher       _paymTransLedgerVoucher,
        LedgerJournalTrans  _ledgerJournalTrans)
    {
        SpecTrans                   specTrans;
        TaxWithholdTrans            taxWithholdTrans;
        // <GTH>
        TaxWithholdTransExtensionTH taxWithholdTransExtensionTH;
        boolean                     isThaiTaxWithholdFeatureEnabled = TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled();
        // </GTH>
        CustVoucherTaxWithhold      custVoucherTaxWithhold;
        CustTrans                   custTrans;
        CustTrans                   invoiceCustTrans;
        LedgerVoucherTransObject    ledgerVoucherTransObject;
        LedgerVoucherGroup          ledgerVoucherGroup;
        LedgerVoucher               taxWithholdTransLedgerVoucher;
        CompanyId                   currentCompany;
        NumberSequenceReference     numberSeqRef;
        NumberSeq                   numberSeq;
        ExchRate                    exchRate;
        ExchRate                    exchRateSecond;
        ExchangeRateHelper          exchangeRateHelper;
        boolean                     isTriangulated;
        CurrencyExchangeHelper      currencyExchangeHelper;
        LedgerDimensionAccount      mergedLedgerDimension;
        LedgerVoucherObject         ledgerVoucherObject;
        boolean isEnableGlobalWHTFeatureAndParam = TaxWithholdingGlobalFeature::isFeatureAndParamEnabled();
        boolean isTaxWHTCustPayExchRateUsingInvoiceCurrencyFlightEnabled = TaxWHTCustPayExchRateUsingInvoiceCurrencyFlight::instance().isEnabled();
        boolean isTaxWHTPostWithAccountingCurAmtFlightEnabled = TaxWHTPostWithAccountingCurAmtFlight::instance().isEnabled();

        // GWHT telemetry
        int64 updatedTaxWithholdingTransCount;
        TradeInstrumentationStopwatch stopWatch = TradeInstrumentationStopwatch::newStopwatch();

        if (_ledgerJournalTrans.TaxWithholdGroup)
        {
            ttsbegin;

            ledgerVoucherGroup = LedgerVoucherGroup::construct();

            while select forupdate crossCompany * from specTrans
                order RefCompany
                where specTrans.SpecCompany == _ledgerJournalTrans.DataAreaId &&
                      specTrans.SpecTableId == _ledgerJournalTrans.TableId &&
                      specTrans.SpecRecId   == _ledgerJournalTrans.RecId
            {
                taxWithholdTrans = null;
                custTrans = null;
                invoiceCustTrans = null;

                changecompany(specTrans.RefCompany)
                {
                    while select forupdate taxWithholdTrans
                        where taxWithholdTrans.SpecTransId == specTrans.RecId
                    {
                        updatedTaxWithholdingTransCount++;

                        if (currentCompany != specTrans.RefCompany)
                        {
                            // get a new ledger voucher and add to ledger voucher group
                            currentCompany = specTrans.RefCompany;

                            numberSeqRef = CustParameters::numRefCustPaymVoucher();
                            numberSeq = NumberSeq::newGetVoucher(numberSeqRef);

                            taxWithholdTransLedgerVoucher = LedgerVoucher::newLedgerPost(
                                                                DetailSummary::Detail,
                                                                SysModule::Cust,
                                                                numberSeqRef.numberSequenceTable().NumberSequence);

                            taxWithholdTransLedgerVoucher.parmCompanyId(currentCompany);
                            taxWithholdTransLedgerVoucher.parmCheckBlockedDimensions(_paymTransLedgerVoucher.parmCheckBlockedDimensions());

                            ledgerVoucherGroup.addLedgerVoucher(taxWithholdTransLedgerVoucher);
                        }

                        // get the next voucher number
                        taxWithholdTransLedgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(numberSeq.voucher(),
                                                                 _paymTransLedgerVoucher.lastTransDate(),
                                                                 SysModule::Cust,
                                                                 LedgerTransType::Cust));

                        select DefaultDimension, PostingProfile from invoiceCustTrans
                            where taxWithholdTrans.CustTransInvoiceId == invoiceCustTrans.RecId;

                        // Find the exchange rate for the taxWithholdTrans transaction date and invoice currency
                        exchangeRateHelper = ExchangeRateHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(currentCompany).RecId),
                            isTaxWHTCustPayExchRateUsingInvoiceCurrencyFlightEnabled ? taxWithholdTrans.InvoiceCurrency : taxWithholdTrans.PaymCurrency,
                            taxWithholdTrans.TransDate);
                        exchRate = exchangeRateHelper.getExchangeRate1();
                        exchRateSecond = exchangeRateHelper.getExchangeRate2();

                        ledgerVoucherObject = taxWithholdTransLedgerVoucher.findLedgerVoucherObject();
                        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                            ledgerVoucherObject.parmAccountingDate());

                        currencyExchangeHelper.parmExchangeRate1(exchRate);
                        currencyExchangeHelper.parmExchangeRate2(exchRateSecond);

                        mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdTrans.LedgerDimension, invoiceCustTrans.DefaultDimension);

                        // <GBR>
                        if (BrazilParameters::isEnabled())
                        {
                            taxWithholdTrans.InvoiceTaxWithholdAmount   = taxWithholdTrans.InvoiceTaxWithholdAmount * -1;
                            taxWithholdTrans.TaxTaxWithholdAmount       = taxWithholdTrans.TaxTaxWithholdAmount * -1;
                            taxWithholdTrans.CustVendTransOpenRecId_BR  = specTrans.RefRecId;
                        }
                        // <GBR>

                        // Posting of the withholding tax on the withholding tax account
                        // <GTH>
                        if (isThaiTaxWithholdFeatureEnabled
                            || (isTaxWHTPostWithAccountingCurAmtFlightEnabled
                                && isEnableGlobalWHTFeatureAndParam))
                        {
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                                taxWithholdTransLedgerVoucher.findLedgerVoucherObject(),
                                LedgerPostingType::TaxWithhold,
                                mergedLedgerDimension,
                                taxWithholdTrans.InvoiceCurrency,
                                - taxWithholdTrans.InvoiceTaxWithholdAmount,
                                - taxWithholdTrans.TaxWithholdAmount,
                                currencyExchangeHelper);
                        }
                        else
                        {
                        // </GTH>
                            ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                                    taxWithholdTransLedgerVoucher.findLedgerVoucherObject(),
                                    LedgerPostingType::TaxWithhold,
                                    mergedLedgerDimension,
                                    taxWithholdTrans.InvoiceCurrency,
                                    - taxWithholdTrans.InvoiceTaxWithholdAmount,
                                    - taxWithholdTrans.TaxTaxWithholdAmount,
                                    currencyExchangeHelper);
                        // <GTH>
                        }
                        // </GTH>

                        // <GBR>
                        if (BrazilParameters::isEnabled())
                        {
                            ledgerVoucherTransObject.parmPaymentReference(_ledgerJournalTrans.PaymReference);
                            ledgerVoucherTransObject.parmPaymMode(_ledgerJournalTrans.PaymMode);

                            taxWithholdTrans.TransDate = _ledgerJournalTrans.TransDate;
                            taxWithholdTrans.CanBeReversed_BR = NoYes::Yes;
                        }
                        // </GBR>

                        ledgerVoucherTransObject.parmSourceRecId(taxWithholdTrans.RecId);
                        ledgerVoucherTransObject.parmSourceTableId(taxWithholdTrans.TableId);
                        ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);
                        taxWithholdTransLedgerVoucher.addTrans(ledgerVoucherTransObject);

                        // <GTH>
                        if (isThaiTaxWithholdFeatureEnabled)
                        {
                            taxWithholdTransExtensionTH = taxWithholdTrans.taxWithholdTransExtensionTH();
                            if (taxWithholdTransExtensionTH.AccountingCurExpenseAmount != 0.0)
                            {
                                // Add the expense trans for withholding tax if needed.
                                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(taxWithholdTransExtensionTH.ExpenseLedgerDimension, invoiceCustTrans.DefaultDimension);

                                ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAccountingAmountsDefault(
                                    ledgerVoucherObject,
                                    LedgerPostingType::TaxWithhold,
                                    mergedLedgerDimension,
                                    taxWithholdTrans.InvoiceCurrency,
                                    taxWithholdTransExtensionTH.InvoiceCurExpenseAmount,
                                    taxWithholdTransExtensionTH.AccountingCurExpenseAmount,
                                    currencyExchangeHelper);
                                ledgerVoucherTransObject.parmSourceTableId(taxWithholdTrans.TableId);
                                ledgerVoucherTransObject.parmSourceRecId(taxWithholdTrans.RecId);
                                ledgerVoucherTransObject.parmTransTxt(_ledgerJournalTrans.Txt);
                                taxWithholdTransLedgerVoucher.addTrans(ledgerVoucherTransObject);
                            }
                        }
                        // </GTH>

                        taxWithholdTrans.SettlementVoucher = taxWithholdTransLedgerVoucher.lastVoucher();

                        // Posting of the withholding tax on the customer account and on the summary account
                        custVoucherTaxWithhold = CustVoucher::newCustVoucherTaxWithhold(taxWithholdTrans,
                                                                                        invoiceCustTrans.DefaultDimension,
                                                                                        invoiceCustTrans.PostingProfile,
                                                                                        exchRate,
                                                                                        exchRateSecond,
                                                                                        isTriangulated);

                        // prevent create customer transactions with amount = 0
                        custVoucherTaxWithhold.parmTransTxt(_ledgerJournalTrans.Txt);
                        // <GTH>
                        if (isThaiTaxWithholdFeatureEnabled
                            || (isTaxWHTPostWithAccountingCurAmtFlightEnabled
                                && isEnableGlobalWHTFeatureAndParam))
                        {
                            custVoucherTaxWithhold.parmAmountMST(taxWithholdTrans.displayAccountingCurDeductableAmount());
                        }
                        else
                        {
                        // </GTH>
                            custVoucherTaxWithhold.parmAmountMST(taxWithholdTrans.TaxTaxWithholdAmount);
                        // <GTH>
                        }
                        // </GTH>

                        // <GBR>
                        if (BrazilParameters::isEnabled())
                        {
                            ledgerVoucherTransObject.parmTransTxt(custVoucherTaxWithhold.getTransactionTxt_BR(_ledgerJournalTrans.parmAccount(), taxwithholdtrans.TaxWithholdCode, invoicecustTrans.Invoice, _paymTransLedgerVoucher));
                        }

                        // prevent create customer transactions with amount = 0
                        if (!BrazilParameters::isEnabled() || taxWithholdTrans.InvoiceTaxWithholdAmount)
                        {
                        // </GBR>
                            custVoucherTaxWithhold.post(taxWithholdTransLedgerVoucher, custTrans);
                            custVoucherTaxWithhold.settleTaxWithhold(custTrans, taxWithholdTransLedgerVoucher.lastTransDate());
                            TaxWithhold::changeWhtTransAccumBaseAmountToZero_BR(_ledgerJournalTrans, taxWithholdTrans);
                        // <GBR>
                        }
                        // </GBR>

                        taxWithholdTrans.Posted = NoYes::Yes;
                        taxWithholdTrans.CustTransPaymId = custTrans.RecId;

                        taxWithholdTrans.Voucher = _ledgerJournalTrans.Voucher;
                        taxWithholdTrans.update();

                        specTrans.Balance01 += taxWithholdTrans.InvoiceTaxWithholdAmount;
                        specTrans.update();
                    }
                }
            }

            ledgerVoucherGroup.end();

            // create related vouchers, may need to change processing to check for duplicate parent voucher
            if (_paymTransLedgerVoucher != null)
            {
                taxWithholdTransLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(curext(),
                    CustParameters::numRefCustPaymVoucher().numberSequenceTable().NumberSequence);
                if (taxWithholdTransLedgerVoucher != null)
                {
                    taxWithholdTransLedgerVoucher.createVoucherLinks(_paymTransLedgerVoucher.lastVoucher(), _paymTransLedgerVoucher.lastTransDate());
                }
            }

            ttscommit;
        }

        TaxWithHoldInstrumentationTelemetry::logGWHTTelemetry(
            GlobalizationConstants::FeatureReferenceTAX00037,
            funcName(),
            TaxWithHoldInstrumentationTelemetry::Posting,
            enum2Str(SalesPurch::Sales),
            true,
            updatedTaxWithholdingTransCount,
            stopwatch.elapsedMilliseconds());

    }

]]></Source>
			</Method>
			<Method>
				<Name>unmarkRelatedVouchers_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Unmarks releated tax withold settlement records when the payment
    /// transaction is unmarked.
    /// </summary>
    /// <param name="_custSettlement">
    /// The CustSettlement record that is being unmarked.
    /// </param>
    /// <param name="_specification">
    /// The current <c>SpecTransManager</c> instance containing marked settlements for reversal.
    /// </param>
    /// <remarks>
    /// Method is called any time a payment settlement records is unmarked
    /// for reversal since tax withhold transactions should never be reversed
    /// without also reversing the payment.
    /// </remarks>
    static void unmarkRelatedVouchers_BR(CustSettlement _custSettlement,
                                        SpecTransManager  _specification)
    {
        CustSettlement          custSettlement;
        boolean                 payment = false;
        CustTrans               custTrans;
        ;

        if (_custSettlement.SettleAmountCur > 0)
        {
                payment = true;
        }

        if (payment)
        {
            while select crosscompany custSettlement where
                custSettlement.TransRecId    == _custSettlement.TransRecId &&
                custSettlement.TransCompany  == _custSettlement.TransCompany &&
                custSettlement.CanBeReversed == true &&
                custSettlement.TransDate     == _custSettlement.TransDate &&
                custSettlement.AccountNum    == _custSettlement.AccountNum &&
                custSettlement.RecId         != _custSettlement.RecId
            {
                custTrans = custSettlement.custVendTrans();

                // Only want payments, invoices, or withholding tax  Cust type is used for withholding tax.
                if (custTrans.TransType == LedgerTransType::Cust ||
                    custTrans.TransType == LedgerTransType::None ||
                    custTrans.TransType == LedgerTransType::Payment ||
                    custTrans.TransType == LedgerTransType::Sales)
                {
                    custSettlement.CustVendSettlement::unmarkThisAndRelatedOffsets(_specification);
                }
            }
        }
        else
        {
            while select crosscompany custSettlement where
                custSettlement.OffsetRecid   == _custSettlement.OffsetRecid &&
                custSettlement.OffsetCompany == _custSettlement.OffsetCompany &&
                custSettlement.CanBeReversed == true &&
                custSettlement.TransDate     == _custSettlement.TransDate &&
                custSettlement.AccountNum    == _custSettlement.AccountNum &&
                custSettlement.RecId         != _custSettlement.RecId
            {
                custTrans = custSettlement.custVendTrans();

                // Only want payments, invoices, or withholding tax  Cust type is used for withholding tax.
                if (custTrans.TransType == LedgerTransType::Cust ||
                    custTrans.TransType == LedgerTransType::None ||
                    custTrans.TransType == LedgerTransType::Payment ||
                    custTrans.TransType == LedgerTransType::Sales)
                {
                    custSettlement.CustVendSettlement::unmarkThisAndRelatedOffsets(_specification);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetWhTaxAmountIfPaymAmountIsLess_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the tax withhold amount if payment amount is less than tax withhold amount.
    /// </summary>
    /// <param name = "_taxWithholdTrans">The buffer of <c>TaxWithholdTrans</c>.</param>
    /// <param name = "_settleExchRate">The settlement exchange rate.</param>
    protected void resetWhTaxAmountIfPaymAmountIsLess_BR(TaxWithholdTrans _taxWithholdTrans, CrossExchRate _settleExchRate)
    {
        TaxWithholdBaseCur amountOring = _taxWithholdTrans.InvoiceWithholdBaseAmount;

        super(_taxWithholdTrans, _settleExchRate);

        if (accumPayment)
        {
            //The sign of the amount keep the same as the original value.
            if ((amountOring > 0 && _taxWithholdTrans.InvoiceWithholdBaseAmount < 0)
                || (amountOring < 0 && _taxWithholdTrans.InvoiceWithholdBaseAmount > 0))
            {
                _taxWithholdTrans.InvoiceWithholdBaseAmount = _taxWithholdTrans.InvoiceWithholdBaseAmount * -1;
                _taxWithholdTrans.PaymWithholdBaseAmount = _taxWithholdTrans.PaymWithholdBaseAmount * -1;
                _taxWithholdTrans.WithholdBaseAmount = _taxWithholdTrans.WithholdBaseAmount * -1;
                _taxWithholdTrans.TaxWithholdBaseAmount = _taxWithholdTrans.TaxWithholdBaseAmount * -1;
            }
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>