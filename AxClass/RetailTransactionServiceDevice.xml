<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>RetailTransactionServiceDevice</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Application.Instrumentation;

public class RetailTransactionServiceDevice
{
    private const int DeviceTokenValidationFailedErrorCode = 1;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>activateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <param name="physicalDeviceId">
    /// ID of the physical device.
    /// </param>
    /// <param name="_forceActivate">
    /// A value indicating whether to force the Activation of a device when the physical device identifiers are different.
    /// </param>
    /// <param name="_deviceType">
    /// The device type value.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container activateDevice(RetailDeviceId deviceId, RetailTerminalId terminalId, RetailStaffId staffId, RetailPhysicalDeviceId physicalDeviceId = '', boolean _forceActivate = false, RetailDeviceTypeId _deviceType = -1)
    {
        return RetailTransactionServiceDevice::_activateDevice(false, deviceId, terminalId, staffId, physicalDeviceId, _forceActivate, _deviceType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>_activateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="isMassActivation">Is mass activation request?</param>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <param name="physicalDeviceId">
    /// ID of the physical device.
    /// </param>
    /// <param name="_forceActivate">
    /// A value indicating whether to force the Activation of a device when the physical device identifiers are different.
    /// </param>
    /// <param name="_deviceType">
    /// The device type value.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    private static container _activateDevice(boolean isMassActivation, RetailDeviceId deviceId, RetailTerminalId terminalId, RetailStaffId staffId, RetailPhysicalDeviceId physicalDeviceId = '', boolean _forceActivate = false, RetailDeviceTypeId _deviceType = -1)
    {
        #OCCRetryCount

        RetailDevice device;
        System.Exception clrException;
        str traceMessage;
        container deviceActivationResponse = [false, '', ''];

        try
        {
            device = RetailDevice::find(deviceId, true);

            if (device == null)
            {
                // 1. Device activation on a new device with specified terminal.
                deviceActivationResponse = RetailTransactionServiceDevice::activateNewDeviceByTerminalId(deviceId, terminalId, staffId, physicalDeviceId, _deviceType);
            }
            else if (device.Terminal || isMassActivation)
            {
                // 2. Device activation with pre-assigned terminal.
                deviceActivationResponse = RetailTransactionServiceDevice::activateExistingDeviceByTerminalAssociation(device, terminalId, staffId, physicalDeviceId, _forceActivate, _deviceType, isMassActivation);
            }
            else if (RetailSharedParameters::find().AllowTerminalAssociationFromDevice)
            {
                // 3. Device activation with specified terminal.
                deviceActivationResponse = RetailTransactionServiceDevice::activateExistingDeviceByTerminalId(device, terminalId, staffId, physicalDeviceId, _deviceType);
            }
            else
            {
                // 4. Device neither is assigned to a terminal, nor the register number association from device is allowed from AX settings.
                deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:DeviceNotAssignedToTerminalLabel", 'Device is neither assigned to a terminal, nor the register number association from device is allowed from AX settings.');
            }
        }
        #StandardRetryCatchBlock
        catch (Exception::CLRError)
        {
            clrException = CLRInterop::getLastException();
            str clrExceptionMessage = 'Exception::CLRError';
            str clrExceptionStackTrace = '';
            if (clrException != null)
            {
                clrExceptionMessage = clrException.get_Message();
                clrExceptionStackTrace = clrException.ToString();

                System.Exception innerException = clrException.get_InnerException();
                if (innerException)
                {
                    clrExceptionMessage = innerException.get_Message();
                    clrExceptionStackTrace = innerException.ToString();
                }
            }

            traceMessage = strFmt('%1. CLR Exception: %2\n%3',
                'Generating device token failed during device activation. Please ensure the that Algorithm Name of Manage Device Token field in Retail Shared Parameters sercurity form is set properly',
                clrExceptionMessage, clrExceptionStackTrace);

            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceTokenGenerationFailed", traceMessage);
        }
        catch
        {
            // This is a general AX error so use the last infolog for the error details.
            traceMessage = strFmt('%1  AX Exception: %2',
                'An error occurred in AOS while activating the device.',
                infolog.text(Global::infologLine()));
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@REX31", traceMessage);
        }

        return deviceActivationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateDevice63</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container activateDevice63(RetailDeviceId deviceId, RetailTerminalId terminalId, RetailStaffId staffId)
    {
        RetailDevice theDevice, terminalDevices;
        RetailTerminalTable theTerminal;
        container deviceActivationResponse = [false, '', '', '', '', '', '', '']; // Status, ErrorMsg, terminalRecId, storeRecId, terminalId, storeName, activationGuid, sequenceNumberXmlDoc
        container deviceActivationResponseNew = [false, '', ''];
        deviceActivationResponseNew = RetailTransactionServiceDevice::activateDevice(deviceId, terminalId, staffId, '', false, -1);

        if (!conPeek(deviceActivationResponseNew, 1)) // Activation failed, extract the error message
        {
            deviceActivationResponse = conPoke(deviceActivationResponse, 1, conPeek(deviceActivationResponseNew, 1));
        }
        else
        {
            theDevice = RetailDevice::find(deviceId, true);
            theTerminal = RetailTerminalTable::find(theDevice.Terminal);

            // Only need to update addtional ActivationGuid for 63
            // theDevice.Terminal = theTerminal.terminalId;
            // theDevice.ActivationStatus = RetailDeviceActivationStatusBase::Activated;
            // theDevice.ActivationStaffId = staffId;
            theDevice.ActivationGuid = newGuid();
            theDevice.update();
            deviceActivationResponse = [true, '',
                        theTerminal.RecId,
                        theTerminal.StoreRecId,
                        theTerminal.terminalId,
                        theTerminal.storeName(),
                        guid2str(theDevice.ActivationGuid)];    // 32 digits Guid separated by hyphens, enclosed in braces
        }

        return deviceActivationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deactivateDevice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activate the device.
    /// </summary>
    /// <param name="deviceId">
    /// ID of the Device.
    /// </param>
    /// <param name="terminalId">
    /// ID of the terminal.
    /// </param>
    /// <param name="staffId">
    /// ID of the staff.
    /// </param>
    /// <returns>
    /// A container object containing status of activation, error message (if any) and the details of the device - terminal, store
    /// </returns>
    /// <remarks>
    /// Validates the Device with the activation code and generates a token.
    /// </remarks>
    public static container deactivateDevice(RetailDeviceId deviceId, RetailTerminalId terminalId, RetailStaffId staffId, str deviceToken, boolean validateToken)
    {
        RetailDevice device;
        RetailTerminalTable terminal;
        RetailTerminalId deactivateTerminalId;
        container deviceDeactivationResponse = [false, '']; // Status, ErrorMsg

        container deviceDeactivationInvalidTokenResponse(RetailTerminalTable theTerminal, RetailDevice theDevice)
        {
            container result = RetailTransactionServiceDevice::deviceManagementResponse(theTerminal, theDevice, '');
            result = conIns(result, conLen(result) + 1, DeviceTokenValidationFailedErrorCode);
            result = conPoke(result, 1, false);
            result = conPoke(result, 2, "@REX31");
            return result;
        }

        // Activate the device on the terminal
        container deactivate(RetailDevice theDevice, RetailTerminalTable theTerminal)
        {
            if (theTerminal)
            {
                // Sets the activation status to deactivated only if the current status is not disabled.
                if (theDevice.ActivationStatus != RetailDeviceActivationStatusBase::Disabled)
                {
                    theDevice.ActivationStatus = RetailDeviceActivationStatusBase::Deactivated;
                }

                theDevice.Terminal = '';
                theDevice.DeactivationStaffId = staffId;
                theDevice.PhysicalDeviceId = '';
                theDevice.DeviceTokenData = '';
                theDevice.DeviceTokenSalt = '';
                theDevice.DeviceTokenAlgorithm = '';
                theDevice.update();
                deviceDeactivationResponse =  RetailTransactionServiceDevice::deviceManagementResponse(terminal, device, '');
            }
            else
            {
                // Device not assigned to a terminal!
                deviceDeactivationResponse =  [false, "@REX31"];
            }

            return deviceDeactivationResponse;
        }

        // Validate if the Staff is allowed to activate devices on this terminal
        boolean staffAllowedForTerminal(RetailTerminalId _terminalId, RetailStaffId _staffId)
        {
            RetailTerminalTable terminalTable;
            RetailStaffTable staffTable;
            DirAddressBook dirAddressBook;
            DirAddressBookParty dirAddressBookParty;
            RetailStoreAddressBook retailStoreAddressBook;
            HcmWorker hcmWorker;

            // Check if the Staff and Terminal (via Store) have at least one common Address Book
            // Terminal-> Store -> StoreAddressBook (type: employee) -> Addressbook
            // Staff -> Worker -> AddressBookParty -> Addressbook
            select firstOnly RecId from dirAddressBook
                exists join retailStoreAddressBook
                    where dirAddressBook.RecId == retailStoreAddressBook.AddressBook
                        && retailStoreAddressBook.AddressBookType == RetailAddressBookType::Employee
                exists join terminalTable
                    where retailStoreAddressBook.StoreRecId == terminalTable.StoreRecId
                        && terminalTable.terminalId == _terminalId
                exists join dirAddressBookParty
                    where dirAddressBook.RecId == dirAddressBookParty.AddressBook
                exists join hcmWorker
                    where dirAddressBookParty.Party == hcmWorker.Person
                        && hcmWorker.PersonnelNumber == _staffId;

            return (dirAddressBook.RecId != 0);
        }
        ;

        try
        {
            // Does the device exist?
            device = RetailDevice::find(deviceId, true);

            if (device)
            {
                // Check if the device has a terminal associated or not, if not (i.e. Disabled or Deactivated already),
                // we use the user input terminal identifier to find the terminal.
                if (device.Terminal != '')
                {
                    deactivateTerminalId = device.Terminal;
                }
                else
                {
                    deactivateTerminalId = terminalId;
                }

                terminal = RetailTerminalTable::find(deactivateTerminalId);

                if (validateToken && !device.validateToken(deviceToken))
                {
                    deviceDeactivationResponse =  deviceDeactivationInvalidTokenResponse(terminal, device);
                }
                else if (!staffAllowedForTerminal(deactivateTerminalId, staffId))
                {
                    // Insufficient Permissions to deactivate devices
                    deviceDeactivationResponse = [false, "@REX31"];
                    ApplicationEventSource::EventWriteRetailTransactionServiceDeviceWarning(funcName(), 'Insufficient permissions to deactivate the device.');
                }
                else if (deactivateTerminalId != terminalId)
                {
                    // Device invalid!
                    deviceDeactivationResponse = [false, "@REX31"];
                    ApplicationEventSource::EventWriteRetailTransactionServiceDeviceWarning(funcName(), 'Invalid device.');
                }
                else
                {
                    //Deactivate the device.
                    deviceDeactivationResponse = deactivate(device, terminal);
                }
            }
            else
            {
                // Device is not found
                deviceDeactivationResponse = [false, "@REX30"];
                ApplicationEventSource::EventWriteRetailTransactionServiceDeviceWarning(funcName(), 'Invalid device id.');
            }
        }
        catch
        {
            // Error
            deviceDeactivationResponse = [false, "@REX31"];
            ApplicationEventSource::EventWriteRetailTransactionServiceDeviceFailure(funcName(), 'An error occured while activating the device.');
        }

        return deviceDeactivationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberSequenceSeedData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the number sequence seed data for a terminal.
    /// </summary>
    /// <param name="_terminalId">
    /// ID of the terminal.
    /// </param>
    /// <returns>
    /// A container object containing the xml with the available number sequence seed data.
    /// </returns>
    public static container getNumberSequenceSeedData(RetailTerminalId _terminalId)
    {
        XmlDocument         xmlDoc;
        XmlElement          xmlRoot, xmlSeedData, xmlRecord;
        Map                 sequenceDataMap;
        MapEnumerator       enumerator;
        RetailStoreTable    theStore;
        RetailTerminalTable terminal;
        boolean             success;
        str                 message;
        str                 xmlString;

        int currentSessionId = sessionId();

        try
        {
            terminal = RetailTerminalTable::find(_terminalId);

            if (!terminal)
            {
                success = false;
                xmlString = '';
                message = "@SYP4910264";
            }
            else
            {
                theStore = RetailStoreTable::findRecId(terminal.StoreRecId);
                sequenceDataMap = RetailPOSSeedData::GetOrCalculateSeedDataCollection(theStore.StoreNumber, _terminalId);
                xmlDoc  = XmlDocument::newBlank('utf-16LE');
                xmlRoot = xmlDoc.createElement('ArrayOfNumberSequenceSeedData');
                xmlRoot.setAttribute('xmlns', 'http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Commerce.Runtime.DataModel');

                enumerator = new MapEnumerator(sequenceDataMap);
                while (enumerator.MoveNext())
                {
                    xmlSeedData = xmlDoc.createElement('NumberSequenceSeedData');

                    xmlRecord = xmlDoc.createElement('DataTypeValue');
                    xmlRecord.innerText(int2str(enumerator.currentKey()));
                    xmlSeedData.appendChild(xmlRecord);

                    xmlRecord = xmlDoc.createElement('DataValue');
                    xmlRecord.innerText(int642str(enumerator.currentValue()));
                    xmlSeedData.appendChild(xmlRecord);

                    // Adding last transaction info in the number sequence seed data
                    RetailNumberSequenceSeedDataTmp numberSequenceSeedDataTmp;

                    numberSequenceSeedDataTmp = RetailNumberSequenceSeedDataTmp::findBySessionAndType(currentSessionId, enumerator.currentKey());

                    if (numberSequenceSeedDataTmp)
                    {
                        if (numberSequenceSeedDataTmp.TransactionDateTime)
                        {
                            xmlRecord = xmlDoc.createElement('LastTransactionCreatedDateTime');
                            xmlRecord.setAttribute(RetailTransactionServiceTransactions::dateTimeOffsetXmlNsKey, RetailTransactionServiceTransactions::dateTimeOffsetXmlNsValue);
                            xmlRecord.innerXml(RetailTransactionServiceUtilities::utcDateTimeToDateTimeStringWithOffset(numberSequenceSeedDataTmp.TransactionDateTime));
                            xmlSeedData.appendChild(xmlRecord);
                        }

                        xmlRecord = xmlDoc.createElement('LastTransactionDataValue');
                        xmlRecord.innerText(int642Str(numberSequenceSeedDataTmp.ReceiptNumber));
                        xmlSeedData.appendChild(xmlRecord);

                        xmlRecord = xmlDoc.createElement('LastTransactionId');
                        xmlRecord.innerText(numberSequenceSeedDataTmp.TransactionId);
                        xmlSeedData.appendChild(xmlRecord);
                    }

                    xmlRoot.appendChild(xmlSeedData);
                }

                xmlDoc.appendChild(xmlRoot);
                xmlString = xmlDoc.toString();
                success = true;
                message = '';
            }

            return [success, message, xmlString];
        }
        finally
        {
            // Clearing related temporary table records that are created during the RetailPOSSeedData::GetOrCalculateSeedDataCollection method.
            RetailNumberSequenceSeedDataTmp::deleteAllSessionRecords(currentSessionId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailableTerminals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of terminal with device activation information by the store number.
    /// </summary>
    /// <param name="_storeId">
    /// The store identifier.
    /// </param>
    /// <param name="_deviceType">
    /// The device type value to be searched (optional).
    /// </param>
    /// <param name="_top">
    /// The number of terminal information records to get.
    /// </param>
    /// <param name="_skip">
    /// The number of terminal information records to skip.
    /// </param>
    /// <returns>
    /// A container having the list of terminals of the specified store in XML string.
    /// </returns>
    public static container getAvailableTerminals(RetailStoreId _storeId, RetailDeviceTypeId _deviceType = enum2int(RetailDeviceTypeBase::None), int64 _top = 100, int64 _skip = 0)
    {
        #define.arrayOfTerminalInfo('ArrayOfTerminalInfo');
        #define.terminalInfo('TerminalInfo');
        #define.terminalId('TerminalId');
        #define.deviceNumber('DeviceNumber');
        #define.terminalName('Name');
        #define.deviceType('DeviceType');
        #define.activationStatusValue('ActivationStatusValue');

        RetailTerminalDeviceView retailTerminalDeviceView;
        RetailStoreTable retailStoreTable;
        RetailDeviceTypes inputDeviceType;
        XmlDocument xmlDoc;
        XmlElement xmlRoot, xmlTerminalInfo, xmlRecord;
        Query   q;
        QueryRun qr;
        QueryBuildDataSource qbds;
        QueryBuildRange qbr;

        boolean allowTerminalAssociation = false;

        retailStoreTable = RetailStoreTable::find(_storeId);
        if (!retailStoreTable)
        {
            // Returns false when store with the input _storeId cannot be found.
            return [false, strFmt("@Retail:StoreCannotBeFound", _storeId), ''];
        }
        else
        {
            inputDeviceType = RetailDeviceTypes::find(_deviceType);
            if (inputDeviceType == null)
            {
                ApplicationEventSource::EventWriteRetailTransactionServiceDeviceInfoLog(funcName(), strFmt('No matching device with type %1 can be found.', _deviceType));
            }

            xmlDoc = XmlDocument::newBlank('utf-16LE');
            xmlRoot = xmlDoc.createElement(#arrayOfTerminalInfo);
            xmlRoot.setAttribute('xmlns', 'http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Commerce.Runtime.TransactionService.Serialization');

            q = new Query(queryStr(RetailTerminalDeviceQuery));
            qbds = q.dataSourceTable(tableNum(RetailTerminalDeviceView));
            qbds.addRange(fieldNum(RetailTerminalDeviceView, StoreRecId)).value(int642Str(retailStoreTable.RecId)); // Filtered by target store recId.
            qbds.addRange(fieldNum(RetailTerminalDeviceView, ActivationAvailabilityStatus)).value(SysQuery::valueNot(RetailDeviceActivationAvailabilityStatusBase::Disabled));

            // If terminal device association is not allowed, then filters out terminals that are not associated with any device.
            allowTerminalAssociation = RetailSharedParameters::find().AllowTerminalAssociationFromDevice;
            if (!allowTerminalAssociation)
            {
                qbds.addRange(fieldNum(RetailTerminalDeviceView, DeviceId)).value(SysQuery::valueNotEmptyString()); // Filtered out records with empty deviceId.
            }

            // If input device type is found, then filters by the given device type.
            if (inputDeviceType != null)
            {
                qbr = qbds.addRange(fieldNum(RetailTerminalDeviceView, DeviceType));
                qbr.value(queryValue(inputDeviceType.Type));   // Filtered by target device type.

                // If allow terminal assocaition is true, then also include records with empty device type.
                if (allowTerminalAssociation)
                {
                    qbr = qbds.addRange(fieldNum(RetailTerminalDeviceView, DeviceType));
                    qbr.value(SysQuery::valueEmptyString());        // Adding an OR condition for undefined device type.
                }
            }

            qbds.addSortField(fieldNum(RetailTerminalDeviceView, ActivationAvailabilityStatus), SortOrder::Ascending);  // Most available device for activation first.
            qbds.addSortField(fieldNum(RetailTerminalDeviceView, TerminalId), SortOrder::Ascending);                    // Then sort by the terminal id.

            qr = new QueryRun(q);

            if (_top > 0)
            {
                // Gets the records from _skip to _skip+_top.
                qr.enablePositionPaging(true);
                qr.addPageRange(_skip + 1, _top);
            }

            while (qr.next())
            {
                retailTerminalDeviceView = qr.get(tableNum(RetailTerminalDeviceView), 1);

                xmlTerminalInfo = xmlDoc.createElement(#terminalInfo);

                xmlRecord = xmlDoc.createElement(#terminalId);
                xmlRecord.innerText(retailTerminalDeviceView.TerminalId);
                xmlTerminalInfo.appendChild(xmlRecord);

                xmlRecord = xmlDoc.createElement(#terminalName);
                xmlRecord.innerText(retailTerminalDeviceView.Name);
                xmlTerminalInfo.appendChild(xmlRecord);

                xmlRecord = xmlDoc.createElement(#deviceNumber);
                xmlRecord.innerText(retailTerminalDeviceView.DeviceId);
                xmlTerminalInfo.appendChild(xmlRecord);

                xmlRecord = xmlDoc.createElement(#deviceType);
                xmlRecord.innerText(int2Str(enum2int(retailTerminalDeviceView.DeviceType)));
                xmlTerminalInfo.appendChild(xmlRecord);

                xmlRecord = xmlDoc.createElement(#activationStatusValue);
                xmlRecord.innerText(int2str(retailTerminalDeviceView.ActivationStatusValue));
                xmlTerminalInfo.appendChild(xmlRecord);

                xmlRoot.appendChild(xmlTerminalInfo);
            }

            xmlDoc.appendChild(xmlRoot);

            return [true, '', xmlDoc.toString()]; // Status, ErrorMsg, XmlResultSet
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAvailableDevices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the list of devices available for device activation based on the device type.
    /// </summary>
    /// <param name="_deviceType">
    /// The device type value to be searched.
    /// </param>
    /// <param name="_top">
    /// The number of device records to get.
    /// </param>
    /// <param name="_skip">
    /// The number of device records to skip.
    /// </param>
    /// <returns>
    /// A container having the list of devices associated with the device type in XML string.
    /// </returns>
    /// <remarks>
    /// A device available for activation means that it has not been assigned to a terminal, in Pending or Deactivated states,
    /// and its device type matches the input device type.
    /// </remarks>
    public static container getAvailableDevices(RetailDeviceTypeId _deviceType = -1, int64 _top = 100, int64 _skip = 0)
    {
        #define.ArrayOfDevice('ArrayOfDevice');
        #define.device('Device');
        #define.deviceNumber('DeviceNumber');
        #define.deviceType('DeviceType');
        #define.activationStatusValue('ActivationStatusValue');

        RetailDevice device;
        RetailDeviceTypes retailDeviceType;
        XmlDocument xmlDoc;
        XmlElement xmlRoot, xmlDevice, xmlRecord;
        int64 numOfRecords = 1;

        xmlDoc = XmlDocument::newBlank('utf-16LE');
        xmlRoot = xmlDoc.createElement(#ArrayOfDevice);
        xmlRoot.setAttribute('xmlns', 'http://schemas.datacontract.org/2004/07/Microsoft.Dynamics.Commerce.Runtime.TransactionService.Serialization');

        retailDeviceType = RetailDeviceTypes::find(_deviceType);

        if (retailDeviceType)
        {
            while select DeviceId, ActivationStatus, Terminal
                from device
                    order by DeviceId
                    where device.ActivationStatus != RetailDeviceActivationStatusBase::Disabled
                        && device.ActivationStatus != RetailDeviceActivationStatusBase::Activated
                        && device.Type == retailDeviceType.RecId
                        && device.Terminal == ''
            {
                // Gets the records from _skip to _skip+_top.
                if (numOfRecords > _skip && numOfRecords - _skip <= _top)
                {
                    xmlDevice = xmlDoc.createElement(#device);

                    xmlRecord = xmlDoc.createElement(#deviceNumber);
                    xmlRecord.innerText(device.DeviceId);
                    xmlDevice.appendChild(xmlRecord);

                    xmlRecord = xmlDoc.createElement(#deviceType);
                    xmlRecord.innerText(int2str(retailDeviceType.Type));
                    xmlDevice.appendChild(xmlRecord);

                    xmlRecord = xmlDoc.createElement(#activationStatusValue);
                    xmlRecord.innerText(int2str(enum2int(device.ActivationStatus)));
                    xmlDevice.appendChild(xmlRecord);

                    xmlRoot.appendChild(xmlDevice);
                }

                numOfRecords++;
            }
        }
        else
        {
            ApplicationEventSource::EventWriteRetailTransactionServiceDeviceInfoLog(funcName(), strFmt('No matching device with type %1 can be found.', _deviceType));
        }

        xmlDoc.appendChild(xmlRoot);

        return [true, '', xmlDoc.toString()]; // Status, ErrorMsg, XmlResultSet
    }

]]></Source>
			</Method>
			<Method>
				<Name>deviceManagementResponse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a response for device management api calls (activation, deactivation, authentication).
    /// </summary>
    /// <param name = "theTerminal">The terminal.</param>
    /// <param name = "theDevice">The device.</param>
    /// <param name = "deviceToken">The device token.</param>
    /// <returns>The response data.</returns>
    public static container deviceManagementResponse(RetailTerminalTable theTerminal, RetailDevice theDevice, str deviceToken)
    {
        return [true,
                    '',
                    theTerminal.RecId,
                    theTerminal.StoreRecId,
                    theTerminal.terminalId,
                    theTerminal.storeName(),
                    theDevice.Type,
                    theDevice.DeviceTokenData,
                    theDevice.DeviceTokenSalt,
                    theDevice.DeviceTokenAlgorithm,
                    theDevice.ActivatedDateTime,
                    enum2int(theDevice.ActivationStatus),
                    theDevice.DeactivateComments,
                    theDevice.DeactivatedDateTime,
                    theDevice.Description,
                    theDevice.DeviceTokenIssueTime,
                    enum2int(theDevice.UseInMemoryDeviceDataStorage),
                    theDevice.PhysicalDeviceId,
                    theDevice.DeviceId,
                    theDevice.RecId,
                    deviceToken];
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateNewDeviceByTerminalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activates a new device with given device info on the terminal identifier specified.
    /// </summary>
    /// <param name="_deviceId">The device identifier.</param>
    /// <param name="_terminalId">The identifier of the terminal to be associated with the device.</param>
    /// <param name="_staffId">The staff identifier.</param>
    /// <param name="_physicalDeviceId">The physical device identifier.</param>
    /// <param name="_deviceType">The device type value.</param>
    /// <returns>A container object containing status of activation, error message (if any), and the details of the device.</returns>
    private static container activateNewDeviceByTerminalId(RetailDeviceId _deviceId, RetailTerminalId _terminalId, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId = '', RetailDeviceTypeId _deviceType = -1)
    {
        RetailTerminalTable terminal;
        RetailDeviceTypes deviceType;
        container deviceActivationResponse = [false, '', ''];

        terminal = RetailTerminalTable::find(_terminalId);
        deviceType = RetailDeviceTypes::find(_deviceType);

        // Performs the common validation first.
        deviceActivationResponse = RetailTransactionServiceDevice::checkDeviceActivationPrerequisite(_deviceId, terminal, _staffId);
        if (!conPeek(deviceActivationResponse, 1))
        {
            // Returns when common validation failed.
            return deviceActivationResponse;
        }

        if (deviceType == null)
        {
            // Device type field is not defined.
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:DeviceTypeNotFound", 'The given device type cannot be found during device activation.');
        }
        else if (_physicalDeviceId == '')
        {
            // Physical device Id is not provided
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:UndefinedPhysicalDeviceId", 'The physical device Id is not provided as an input during device activation.');
        }
        else if (!RetailSharedParameters::find().AllowTerminalAssociationFromDevice)
        {
            // Allow terminal association from device setting is disabled while trying to create and activate a new device.
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:EnableAllowTerminalAssociationForDeviceCreation", 'Cannot create a device due to allow terminal association from device retail parameter setting is disabled.');
        }
        else
        {
            // Create and activate a device based on input device identifier and associate it with the terminal.
            deviceActivationResponse = RetailTransactionServiceDevice::createAndActivate(_deviceId, terminal, _staffId, _physicalDeviceId, deviceType.RecId);
        }

        return deviceActivationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateExistingDeviceByTerminalAssociation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activates the device with existing device record on the terminal associated with this device.
    /// </summary>
    /// <param name="_device">The device to be activated.</param>
    /// <param name="_terminalId">The identifier of the terminal to be associated with the device.</param>
    /// <param name="_staffId">The staff identifier.</param>
    /// <param name="_physicalDeviceId">The physical device identifier.</param>
    /// <param name="_forceActivate>The value indicating whether to force the Activation of a device when the physical device identifiers are different.</param>
    /// <param name="_deviceType">The device type value.</param>
    /// <param name="_isMassActivation">Is mass activation.</param>
    /// <returns>A container object containing status of activation, error message (if any), and the details of the device.</returns>
    private static container activateExistingDeviceByTerminalAssociation(RetailDevice _device, RetailTerminalId _terminalId, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId = '', boolean _forceActivate = false, RetailDeviceTypeId _deviceType = -1, boolean _isMassActivation=false)
    {
        // Constants
        #define.DeviceAlreadyActivatedErrorCode('DeviceAlreadyActivated');
        #define.AttemptToActivateFromDifferentPhysicalDeviceErrorCode('AttemptToActivateFromDifferentPhysicalDevice');

        // Variables
        RetailTerminalTable terminal;
        container deviceActivationResponse = [false, '', ''];

        terminal = RetailTerminalTable::find(_device.Terminal);

        // Performs the common validation first.
        deviceActivationResponse = RetailTransactionServiceDevice::checkDeviceActivationPrerequisite(_device.DeviceId, terminal, _staffId, _device.ActivationStatus);
        if (!conPeek(deviceActivationResponse, 1))
        {
            // Returns when common validation failed.
            return deviceActivationResponse;
        }

        if (_isMassActivation && (!_device.AllowMassActivation || _device.ActivationStatus != RetailDeviceActivationStatusBase::Pending))
        {
            // This device is not enabled for mass activation.
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailMassActivationNotEnabled", 'Given device is not enabled for mass activation in AX.');
        }
        else if (!RetailTransactionServiceDevice::isValidDeviceType(_device.Type, _deviceType))
        {
            // The input device type does not match the preset device type in RetalDevice table.
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:InvalidDeviceTypeLabel", 'Given device type does not match the predefined device type in AX.');
        }
        else if (_device.ActivationStatus == RetailDeviceActivationStatusBase::Activated)
        {
            if (_device.Terminal != _terminalId && _terminalId != '')
            {
                // Device already activated!
                deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@REX4520244", 'Device already activated.', #DeviceAlreadyActivatedErrorCode);
            }
            else if (!_physicalDeviceId || (_device.PhysicalDeviceId != _physicalDeviceId && !_forceActivate))
            {
                if (!_physicalDeviceId)
                {
                    // If no input device id, we setDevice already activated!
                    deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@REX4520244", 'Device already activated.', #DeviceAlreadyActivatedErrorCode);
                }
                else
                {
                    // If the input physical device id is not same as the one as the current activated device
                    // and device is not set to be forcely activated, returns an error code.
                    deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@REX4520244", 'Device already activated on another physical device.', #AttemptToActivateFromDifferentPhysicalDeviceErrorCode);
                }
            }
            else
            {
                // Idempodent device activation i.e., activation request coming from:
                // 1. The same physical device;
                // 2. Two physical devices but with _forceActivation = true.
                deviceActivationResponse = RetailTransactionServiceDevice::activate(_device, terminal, _staffId, _physicalDeviceId);
            }
        }
        else if (_device.Terminal != _terminalId && _terminalId != '')
        {
            // When device in Pending or Deactivated, do not allow the activation when input terminal number does not match the one associated with the device.
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:InputTerminalIdNotMatch", 'The user input terminal identifier does not match the terminal identifier associated with the device to be activated.');
        }
        else
        {
            //Activate using the pre-assigned terminal id
            deviceActivationResponse = RetailTransactionServiceDevice::activate(_device, terminal, _staffId, _physicalDeviceId);
        }

        return deviceActivationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateExistingDeviceByTerminalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activates the device with existing device record on the terminal identifier specified.
    /// </summary>
    /// <param name="_device">The device to be activated.</param>
    /// <param name="_terminalId">The identifier of the terminal activated the device on.</param>
    /// <param name="_staffId">The staff identifier.</param>
    /// <param name="_physicalDeviceId">The physical device identifier.</param>
    /// <param name="_deviceType">The device type value.</param>
    /// <returns>A container object containing status of activation, error message (if any), and the details of the device.</returns>
    private static container activateExistingDeviceByTerminalId(RetailDevice _device, RetailTerminalId _terminalId, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId = '',  RetailDeviceTypeId _deviceType = -1)
    {
        RetailTerminalTable terminal;
        container deviceActivationResponse = [false, '', ''];

        terminal = RetailTerminalTable::find(_terminalId);

        // Performs the common validation first.
        deviceActivationResponse = RetailTransactionServiceDevice::checkDeviceActivationPrerequisite(_device.DeviceId, terminal, _staffId, _device.ActivationStatus);
        if (!conPeek(deviceActivationResponse, 1))
        {
            // Returns when common validation failed.
            return deviceActivationResponse;
        }

        if (!RetailTransactionServiceDevice::isValidDeviceType(_device.Type, _deviceType))
        {
            // The input device type does not match the preset device type in RetalDevice table.
            deviceActivationResponse = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:InvalidDeviceTypeLabel", 'Given device type does not match the predefined device type in AX.');
        }
        else
        {
            deviceActivationResponse = RetailTransactionServiceDevice::activate(_device, terminal, _staffId, _physicalDeviceId);
        }

        return deviceActivationResponse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createAndActivate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and activates the device on the terminal for the staff.
    /// </summary>
    /// <param name = "_deviceId">The device to be activated.</param>
    /// <param name = "_terminal">The terminal will be associated with the device.</param>
    /// <param name = "_staffId">The staff identifier.</param>
    /// <param name = "_physicalDeviceId">The physical device identifier.</param>
    /// <param name = "_deviceTypeRecId">The device type record identifier.</param>
    /// <returns>The device activation response data.</returns>
    private static container createAndActivate(RetailDeviceId _deviceId, RetailTerminalTable _terminal, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId, RetailDeviceTypeRecId _deviceTypeRecId)
    {
        RetailDevice newDevice;

        if (_deviceId == '')
        {
            _deviceId = RetailDevice::GetNextDeviceId();
        }

        if (_deviceId == '')
        {
            return RetailTransactionServiceDevice::activateDeviceFailed("@REX31", 'An error occured while creating a new device identifier.');
        }
        else if (RetailDevice::find(_deviceId))
        {
            // Returns error if the device identifier already exists.
            return RetailTransactionServiceDevice::activateDeviceFailed("@Retail:DeviceIdAlreadyExists", strFmt('There is already a device record of the same device identifier %1 you are trying to activate with.', _deviceId));
        }

        ttsbegin;
        newDevice.DeviceId = _deviceId;
        newDevice.Terminal = _terminal.terminalId;
        newDevice.ActivationStatus = RetailDeviceActivationStatusBase::Activated;
        newDevice.ActivationStaffId = _staffId;
        newDevice.PhysicalDeviceId = _physicalDeviceId;
        newDevice.Type = _deviceTypeRecId;
        newDevice.DeActivationStaffId = '';
        RetailDevice::setStatusDateTime(newDevice);

        newDevice.insert();

        str token = newDevice.generateToken();
        ttscommit;

        return RetailTransactionServiceDevice::deviceManagementResponse(_terminal, newDevice, token);
    }

]]></Source>
			</Method>
			<Method>
				<Name>activate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Activates the device on the terminal for the staff.
    /// </summary>
    /// <param name = "_theDevice">The device to be activated.</param>
    /// <param name = "_theTerminal">The terminal will be associated with the device.</param>
    /// <param name = "_staffId">The staff identifier.</param>
    /// <param name = "_physicalDeviceId">The physical device identifier.</param>
    /// <returns>The device activation response data.</returns>
    private static container activate(RetailDevice _theDevice, RetailTerminalTable _theTerminal, RetailStaffId _staffId, RetailPhysicalDeviceId _physicalDeviceId)
    {
        ttsbegin;
        _theDevice.Terminal = _theTerminal.terminalId;
        _theDevice.ActivationStatus = RetailDeviceActivationStatusBase::Activated;
        _theDevice.ActivatedDateTime = DateTimeUtil::utcNow();
        _theDevice.ActivationStaffId = _staffId;
        _theDevice.PhysicalDeviceId = _physicalDeviceId;
        _theDevice.DeActivationStaffId = '';

        if (_theDevice.IsActivationValidationRequired() && !_theDevice.validateActiveDeviceCount())
        {
            ttsabort;
            return RetailTransactionServiceDevice::activateDeviceFailed('@SYP4861349', strFmt('@Retail:RetailDeviceActiveDeviceCountExceeded', _theDevice.DeviceId));
        }
        else
        {
            str token = _theDevice.generateToken();
            ttscommit;
            return RetailTransactionServiceDevice::deviceManagementResponse(_theTerminal, _theDevice, token);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>activateDeviceFailed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates the device activation error response.
    /// </summary>
    /// <param name = "_errorMessage">The device activation failure error message.</param>
    /// <param name = "_traceMessage">The device activation failure trace message.</param>
    /// <param name = "_errorCode">The device activation failure error code.</param>
    /// <returns>The device activation failed response in the format of Status, ErrorMsg, and ErrorCode.</returns>
    private static container activateDeviceFailed(str _errorMessage, str _traceMessage, str _errorCode = '')
    {
        if (_errorCode != '')
        {
            _traceMessage = strFmt('Error code: %1. Error Message %2.', _errorCode, _traceMessage);
        }

        ApplicationEventSource::EventWriteRetailTransactionServiceDeviceWarning('activateDevice', _traceMessage);
        return [false, _errorMessage, _errorCode];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDeviceActivationPrerequisite</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verifies the common device activation prerequisites.
    /// </summary>
    /// <param name="_deviceId">The identifier of the device to be activated.</param>
    /// <param name="_terminal">The terminal on which the device will be activated.</param>
    /// <param name="_staffId">The staff identifier.</param>
    /// <param name="_">The physical device identifier.</param>
    /// <param name="_deviceType">The device type value.</param>
    /// <returns>A container object containing check status.</returns>
    /// <remarks>This function holds the common device activation validation logics.</remarks>
    private static container checkDeviceActivationPrerequisite(RetailDeviceId _deviceId, RetailTerminalTable _terminal, RetailStaffId _staffId, RetailDeviceActivationStatusBase _activationStatus = 0)
    {
        RetailDevice terminalDevices;
        container response = [true, ''];

        if (_terminal == null)
        {
            // Terminal is not found.
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:TerminalNotFoundLabel", 'Device is not assigned to a terminal, or the input register number cannot be found.');
        }
        else if (!RetailTransactionServiceDevice::isTerminalAssignedToStore(_terminal))
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@SYP4910132", 'The terminal associated with the device does not exist, or is not assigned to a store.');
        }
        else if (!RetailTransactionServiceDevice::isTerminalAvailable(_deviceId, _terminal.terminalId))
        {
            // Another device is already assigned to the terminal.
            select firstOnly1 terminaldevices where terminaldevices.DeviceId != _deviceId && terminaldevices.Terminal == _terminal.terminalId;
            response = RetailTransactionServiceDevice::activateDeviceFailed(strFmt("@Retail:DeviceAlreadyAssignedToTerminalLabel", terminaldevices.DeviceId, terminalDevices.Terminal), 'Device cannot be activated (another device is already assigned to the terminal).');
        }
        else if (!RetailDeviceActivationValidationJob::WorkerAllowedForTerminal(_terminal.terminalId, _staffId))
        {
            // Insufficient Permissions to activate devices, or the staff does not belong to the store's address book.
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:InsufficientDeviceActivationPermissionLabel", 'Insufficient permissions to activate the device, or the staff does not belong to the store address book.');
        }
        else if (_activationStatus == RetailDeviceActivationStatusBase::Disabled)
        {
            // Device in Disabled status could not be Activated unless reset to Pending or Deactivated status.
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:DeviceIsDisabled", 'Activation of a disabled device is not supported. Please set the device status to Deactivated or Pending.');
        }
        else if (!RetailDeviceActivationValidationJob::ValidateStoreLanguage(_terminal.terminalId))
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_StoreLanguage", strFmt('The terminal %1 associated store\'s language is not set up properly.', _terminal.terminalId));
        }
        else if (!RetailDeviceActivationValidationJob::ValidateTerminalVisualProfile(_terminal.terminalId))
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_TerminalVisualProfile", strFmt('The terminal %1 visual profile is not set up properly.', _terminal.terminalId));
        }
        else if (!RetailDeviceActivationValidationJob::ValidateStoreFunctionalityProfile(_terminal.terminalId))
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_FunctionalityProfile", strFmt('The terminal %1 associated store\'s functionality profile is not set up properly.', _terminal.terminalId));
        }
        else if (!RetailDeviceActivationValidationJob::ValidateStoreHardwareProfile(_terminal.terminalId))
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_HardwareProfile", strFmt('The terminal %1 associated associated hardware profile is not set up properly.', _terminal.terminalId));
        }
        else if (!RetailDeviceActivationValidationJob::ValidateRegisterLayoutMissing(_terminal.terminalId))
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_RegisterLayoutMissing", strFmt('The terminal %1 layout is missing.', _terminal.terminalId));
        }
        else if (!RetailDeviceActivationValidationJob::ValidateOperationsCount())
        {
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_OperationsCount", 'No POS operation defined.');
        }
        else if (!RetailDeviceActivationValidationJob::ValidateCountryRegionIsoCodes())
        {
            // No duplicate country region ISO codes is allowed in logistics address.
            response = RetailTransactionServiceDevice::activateDeviceFailed("@Retail:RetailDeviceActivationValidationJob_DuplicateBlankIsoCodes", 'No duplicate country region ISO codes is allowed in logistics address.');
        }

        return response;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTerminalAssignedToStore</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the terminal is assigned to a store.
    /// </summary>
    /// <param name = "_terminal">The terminal will be associated with the activation device.</param>
    /// <returns><c>True</c>, if the terminal is assigned to a store; <c>False</c>, otherwise.</returns>
    private static boolean isTerminalAssignedToStore(RetailTerminalTable _terminal)
    {
        boolean result;

        result = (_terminal && (_terminal.StoreRecId != 0));

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isValidDeviceType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the input device type matches the target device type record.
    /// </summary>
    /// <param name = "_deviceTypeRecId">The target device type record identifier.</param>
    /// <param name = "_inputDeviceType">The input device type.</param>
    /// <returns><c>True</c>, if the input device type matches the target device type; <c>False</c>, otherwise.</returns>
    private static boolean isValidDeviceType(RetailDeviceTypeRecId _deviceTypeRecId, RetailDeviceTypeId _inputDeviceType)
    {
        RetailDeviceTypes retailDeviceType;
        boolean result = true;

        // Skip the validation if no device type from input.
        if (_inputDeviceType != -1)
        {
            retailDeviceType = RetailDeviceTypes::findRecId(_deviceTypeRecId);
            if (retailDeviceType == null || retailDeviceType.Type != _inputDeviceType)
            {
                result = false;
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTerminalAvailable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the terminal is available for device activation (there is no other device assigned to the terminal).
    /// </summary>
    /// <param name = "_deviceId">The device identifier.</param>
    /// <param name = "_terminalId">Ther terminal identifer.</param>
    /// <returns><c>True</c>, if there is no other device assigned terminal; <c>False</c>, otherwise.</returns>
    private static boolean isTerminalAvailable(RetailDeviceId _deviceId, RetailTerminalId _terminalId)
    {
        RetailDevice terminalDevices;
        boolean result;

        select firstOnly1 terminaldevices where terminaldevices.DeviceId != _deviceId && terminaldevices.Terminal == _terminalId;

        result = (terminalDevices == null);

        return result;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>