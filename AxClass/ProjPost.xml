<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>ProjPost</c> class serves as the base class for all project posting.
/// </summary>
/// <remarks>
///    Each transaction will extend this class and provide any additional functionality required.
/// </remarks>
class ProjPost
{
    ProjTrans               projTrans;

    ProjLedgerStatus        ledgerStatusCostValue;
    boolean                 ledgerStatusTurnover;
    boolean                 enterCost;
    boolean                 enterSalesAccrued;
    boolean                 enterTurnover;
    boolean                 reverseAccrued;
    boolean                 useTransCurrReverseAccrued;
    AmountCur               adjustmentLedgerSalesAmount;
    boolean                 enterSalesAccruedParm;
    boolean                 createTrans;
    boolean                 updateTrans;
    boolean                 adjustment;
    boolean                 enterAccruedOnAcc;
    boolean                 notEnterNoneLedger;
    boolean                 notEnterNeverLedger;
    boolean                 checkCreditNoteItem;
    boolean                 notForecastReduction;
    private boolean         doNotUpdateBudget;
    private boolean         isSalesOrderCreditNote;

    boolean                 forecastUpdate;
    boolean                 committedCostCreate;
    boolean                 committedCostReverse;
    boolean                 postToGeneralLedger;
    boolean                 suppressBudgetMessages;

    ProjTransStatus         transStatus;
    private boolean postItemPhysically;

    boolean                 elimination;

    TmpProjAdjustmentCreate adjustBuffer;
    TmpProjAdjustmentCreateCost adjustBufferCost;
    TmpProjAdjustmentCreateSale adjustBufferSale;

    TaxAmountCur            taxAmountCur;

    AmountMST               ledgerCostAmountMST;
    AmountMST               ledgerSalesAmountMST;

    LedgerDimensionDefaultAccount ledgerDimensionDefaultAccount;
    LedgerPostingType       postingType;
    ProjAdjustRefId         adjustRefId;
    InventTransId           inventTransId;

    LedgerVoucher           ledgerVoucher;

    ProjTransIdBase         transIdCost;
    RefRecId                saleRefRecId;
    ProjTransIdBase         transIdSales;
    ProjTransIdBase         transIdOrig;
    ProjTransIdBase         transIdRef; //partial invoice of PO,SO,IR,ProdOrder, it links to the original projTransId in purchLine,etc.
    ProjTransIdBase         transIdReference;
    ProjTransIdBase         adjRefTransId;
    ProjTransIdBase         transIdNew;

    boolean                 costUseOrig;
    boolean                 salesUseOrig;
    boolean					ledgerStatusCostOrig;
    NoYes                   allocationError;

    ProjPeriodTo            periodWIP;
    ProjOriginCost          originCost;

    ProjTransType           transactionType;
    ProjFunctionType        functionType;

    // This date will be only used for the purchase order
    TransDate               purchaseOrderDate;
    TransDate               tmpPaymentDate;
    ProjPaymentStatus       tmpPaymentStatus;
    ExchRate                exchangeRate, reportingExchangeRate;

    ProjItemTransCostType   projItemTransCostType;

    ProjTransactionOrigin   transactionOrigin;
    ProjLedgerOrigin        ledgerOrigin;

    ProjTransactionOrigin   transactionOriginOrig;

    SalesLine               salesLine;
    SalesQty                salesQty;
    // <GEERU>
    Tax                     tax;
    // </GEERU>

    boolean                 m_bPSAAdjustment;
    boolean                 creditNote;
    ProjProposalJour        projProposalJour;
    TransDate               adjustmentDate;

    Map                     costDistributions;
    Map                     saleDistributions;
    List                    fundingSourceList;

    boolean                 isDimensionUptake;

    List                    invoiceLedgerList;
    // <GIN>
    TaxAmountCur            loadOnInventory;
    AmountMST               customsLedgerAmountMST;
    // </GIN>
    // <GIN><GEERU>
    #ISOcountryRegionCodes
    // </GEERU></GIN>

    boolean                 skipCheckLedgerTransDate;

    TableId                 taxParentReferenceTableId;
    RecId                   taxParentReferenceRecId;

    container               splitTransQtyCon;
    // <GEEU>
    LedgerCorrection        adjustCorrection;
    boolean                 countryRegion_RU;
    // </GEEU>

    RefRecId                taxInformationRecId;
    ProjFundingSourceRefId  projFundingSourceRefId;

    boolean                     isContractLineUsed;
    boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>adjustmentLedgerSalesAmount</Name>
				<Source><![CDATA[
    protected AmountCur adjustmentLedgerSalesAmount()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>budgetUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the budget amount.
    /// </summary>
    public void budgetUpdate()
    {
        ProjBudgetTransaction           projBudgetTransaction;
        ProjBudgetTransactionLine       projBudgetTransactionLine;
        ProjBudgetTransactionManager    projBudgetTransactionManager;
        ProjBudgetAdjustmentType        projBudgetAdjustmentType;
        ProjEmplTransCost               projEmplTransCost;
        ProjEmplTransSale               projEmplTransSale;
        LedgerJournalTrans              ledgerJournalTransLoc;

        projBudgetTransactionLine = ProjBudgetTransactionLine::construct(projTrans.buffer());
        // If this is an Indirect Component Journal, get the Indirect component-related costs instead of the original ProjEmplTrans cost/sales prices
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && this is PSAProjPostEmplIndirectJournal)
        {
            select sum(psaIndirectCost) from projEmplTransCost where projEmplTransCost.TransId == projTrans.transId();
            select sum(psaIndirectRevenue) from projEmplTransSale where projEmplTransSale.TransId == projTrans.transId();

            projBudgetTransactionLine.parmCostAmount(projEmplTransCost.psaIndirectCost);
            projBudgetTransactionLine.parmSalesAmount(projEmplTransSale.psaIndirectRevenue);
        }
        else
        {
            if (this.parmPostItemPhysically() && FeatureStateProvider::isFeatureEnabled(ProjCancelItemReqPackingSlipFeature::instance()))
            {
                projBudgetTransactionLine.parmCostAmount(projTrans.transCostItemPhysical());
            }
            else
            {
                projBudgetTransactionLine.parmCostAmount(projTrans.transCost());
            }
            
            if (projTrans.buffer().TableId == tableNum(LedgerJournalTrans))
            {
                ledgerJournalTransLoc = projTrans.buffer();
                if (ledgerJournalTransLoc.ledgerJournalTable().LedgerJournalInclTax)
                {
                    projBudgetTransactionLine.parmCostAmount(projTrans.transCost() - this.parmTaxAmountCur());
                }
            }
            projBudgetTransactionLine.parmSalesAmount(projTrans.transTurnover());
        }

        projBudgetTransactionLine.parmTransIdRef(this.getRefTransId());

        projBudgetTransaction = new ProjBudgetTransaction();
        projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);
        projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
        projBudgetAdjustmentType = this.getbudgetAdjustmentType();

        if (!projBudgetTransactionManager.adjustBudget(projBudgetAdjustmentType))
        {
            throw error("@Proj:BudgetError");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterAccruedCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the posting should have an accrued credit amount.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted.
    /// </remarks>
    public boolean checkEnterAccruedCredit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterAccruedDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the posting should have an accrued debit amount.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    This method will should be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted.
    /// </remarks>
    public boolean checkEnterAccruedDebit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterCostValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the posting requires posting to a cost account and whether a non-zero value has been entered.
    /// </summary>
    /// <returns>
    ///    true if the value for cost is non-zero and the post to the cost account is true; otherwise, false.
    /// </returns>
    protected boolean checkEnterCostValue()
    {
        return  (this.parmEnterCost() && (projTrans.transCost() != 0));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterNeverLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks the project ledger status field for costs to determine whether costs are posted to general ledgers.
    /// </summary>
    /// <returns>
    ///    true if the project ledger status for costs is equal to the enumeration value <c>ProjLedgerStatus::Never</c>; otherwise, false.
    /// </returns>
    public boolean checkEnterNeverLedger()
    {
        if (this.parmLedgerStatusCost() == ProjLedgerStatus::Never && !this.parmNotEnterNeverLedger())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterNoneLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to determine whether there should be a ledger posting of costs.
    /// </summary>
    /// <returns>
    /// true if there is no posting of costs; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The result of this method may be the results of the project ledger status that is equal to the
    /// enumeration value <c>ProjLedgerStatus::None</c>. Otherwise, a transaction type that is equal to the
    /// enumeration value <c>ProjTransType::Hour</c> which is not posting accrued sales or revenue.
    /// </remarks>
    public boolean checkEnterNoneLedger()
    {
        if ((projTrans && projTrans.transType() == ProjTransType::Hour)
            && !(this.checkEnterTurnover() || this.checkEnterSalesAccrued())
            && ((this.parmLedgerStatusCost() == ProjLedgerStatus::None) || this.checkLedgerStatusOrig() && !this.parmNotEnterNoneLedger()))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether the transaction requires the entry of accrued on-account values.
    /// </summary>
    /// <returns>
    /// The result of the <c>parmEnterAccruedOnAcc()</c> method.
    /// </returns>
    public boolean checkEnterOnAcc()
    {
        if (this.parmEnterAccruedOnAcc())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterOnAccCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the posting should have a credit amount for the on-account account.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted.
    /// </remarks>
    public boolean checkEnterOnAccCredit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterOnAccDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the posting should have a debit amount for the on-account account.
    /// </summary>
    /// <returns>
    ///    true.
    /// </returns>
    /// <remarks>
    ///    This method will should be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted.
    /// </remarks>
    public boolean checkEnterOnAccDebit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterSalesAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the accrued sales amount has been entered and is expected to be posted.
    /// </summary>
    /// <returns>
    ///    true if the accrued sales amount is nonzero and the method <c>parmEnterSalesAccrued()</c> returns true; otherwise, false.
    /// </returns>
    protected boolean checkEnterSalesAccrued()
    {
        return  this.parmEnterSalesAccrued()  &&
            projTrans.canBeAccrued() &&
            projTrans.transTurnover();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkEnterTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether revenue should be posted for the transaction.
    /// </summary>
    /// <returns>
    ///    true if the revenue amount is non-zero and the method <c>parmEnterTurnover()</c> returns true; otherwise, false.
    /// </returns>
    protected boolean checkEnterTurnover()
    {
        return this.parmEnterTurnover() && projTrans.transTurnover();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks whether the transaction should be posted to the general ledgers.
    /// </summary>
    /// <returns>
    ///    true if amounts should be posted to general ledgers; otherwise, false.
    /// </returns>
    /// <remarks>
    ///       This method makes calls to the following methods:
    ///
    ///    <list type="bullet">
    ///       <item>
    ///          <description>
    ///             <c>checkEnterCostValue()</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>checkEnterNeverLedger()</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>checkEnterNoneLedger()</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>checkEnterOnAcc()</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>checkEnterSalesAccrued()</c>
    ///          </description>
    ///       </item>
    ///       <item>
    ///          <description>
    ///             <c>checkEnterTurnover()</c>
    ///          </description>
    ///       </item>
    ///    </list>
    /// </remarks>
    protected boolean checkLedger()
    {
        if (this.checkEnterCostValue()
            || this.checkEnterSalesAccrued()
            || this.checkEnterTurnover()
            || this.checkEnterNeverLedger()
            || this.checkEnterNoneLedger()
            || this.checkEnterOnAcc()
        )
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerStatusOrig</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the ledger posting status is set not to post.
    /// </summary>
    /// <returns>
    /// true if the project ledger status is equal to the enumeration value <c>ProjLedgerStatus::None</c>;
    /// otherwise, false.
    /// </returns>
    public boolean checkLedgerStatusOrig()
    {
        return (projTrans.ledgerStatusCost() == ProjLedgerStatus::None);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLedgerTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks that the transaction has a valid date. Then, verifies that a posting period has been setup for the date and that the period is open for posting.
    /// </summary>
    /// <returns>
    ///    true if the system can create a ledger entry for the date; otherwise, false.
    /// </returns>
    protected boolean checkLedgerTransDate()
    {
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        TransDate				accountingDate;

        if (ledgerVoucher && ledgerVoucher.findLedgerVoucherObject())
        {
            accountingDate = ledgerVoucher.findLedgerVoucherObject().parmAccountingDate();
            fiscalCalendarPeriod = FiscalCalendarPeriod::find(ledgerVoucher.findLedgerVoucherObject().parmFiscalCalendarPeriodRecId());
        }
        else if (projTrans)
        {
            accountingDate = this.getAccountingDateFromTrans();
            fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(Ledger::fiscalCalendar(CompanyInfo::current()), accountingDate, FiscalPeriodType::Operating);
        }

        if (accountingDate)
        {
            if (!fiscalCalendarPeriod)
            {
                return checkFailed(strFmt("@SYS17614",date2StrUsr(accountingDate, DateFlags::FormatAll)));
            }

            if (!ProjParameters::find().IsAccountingDateUpdateAllowed)
            {
                if (fiscalCalendarPeriod.currentLedgerPeriodStatus() !=  FiscalPeriodStatus::Open)
                {
                    return checkFailed(strFmt("@SYS17615", date2StrUsr(accountingDate, DateFlags::FormatAll)));
                }

                if (!LedgerFiscalCalendar::checkModuleIsOpen(SysModule::Project, accountingDate, fiscalCalendarPeriod))
                {
                    return false;
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAccountingDateFromTrans</Name>
				<Source><![CDATA[
    private TransDate getAccountingDateFromTrans()
    {
        TransDate accountingDate;

        if (projTrans is ProjTransCostJournal || 
			projTrans is ProjTransItemProdTable || 
			projTrans is ProjTransEmplJournal)
        { 
            accountingDate = projTrans.ledgerTransDate();
        }
		else
        {
            accountingDate = projTrans.transDate();
        }

        return accountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQtyNegative</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the transaction should check for negative quantity values.
    /// </summary>
    /// <returns>
    ///    Returns true.
    /// </returns>
    /// <remarks>
    ///    This method should be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted.
    /// </remarks>
    public boolean checkQtyNegative()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkReverseCommittedCost</Name>
				<Source><![CDATA[
    public boolean checkReverseCommittedCost()
    {
        if (!projTrans)
        {
            return false;
        }

        if (this.parmCommittedCostReverse()
            && projTrans.mustHandleCommittedCost()
            && CostControlTransCommittedCost::findOpenedByProjTransID(this.parmTransIdCost()))
        {
            return true;
        }
        else
        {
            return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to make sure that the mandatory transaction fields contain values.
    /// </summary>
    /// <param name="throwerror">
    /// Indicates whether an error should be thrown when a validation fails. May be set to null. The
    /// default value is true; optional.
    /// </param>
    /// <returns>
    ///  true if the basic fields contain values. The following fields are checked by this routine:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>Project ID</description>
    ///   </item>
    ///   <item>
    ///   <description>Category ID</description>
    ///   </item>
    ///   <item>
    ///   <description>Currency ID for Sales</description>
    ///   </item>
    ///   <item>
    ///   <description>Transaction Date</description>
    ///   </item>
    ///  </list>
    /// </returns>
    /// <remarks>
    /// The <paramref name="throwerror" /> parameter is not used in this method and is provided for
    /// extending the functionality through an override method. This method will call <c>checkFailed()</c>
    /// for all checked fields that do not contain a valid value.
    /// </remarks>
    public boolean checkTrans(boolean throwerror = true)
    {
        boolean ok  = true;

        if (!ProjTable::find(projTrans.projId()))
        {
            ok = checkFailed("@SYS50152");
        }

        ok  = (ok && ProjTable::find(projTrans.projId()).status().journalCheckStatus());

        if (!projTrans.currencyIdSales())
        {
            ok = checkFailed("@SYS25991") && ok;
        }

        if (!projTrans.categoryId() || !ProjCategory::find(projTrans.categoryId()))
        {
            ok = checkFailed("@SYS50153") && ok;
        }

        if (projTrans.buffer().TableId != tableNum(SalesLine))
        {
            if (!projTrans.linePropertyId())
            {
                ok = checkFailed("@SYS50154") && ok;
            }
        }

        if (!this.parmSkipCheckLedgerTransDate() && !this.checkLedgerTransDate())
        {
            ok  = false;
        }

        if (projTrans.mustValidateBudget() && !ProjPost::validateBudget(projTrans.buffer()))
        {
            ok  = false;
        }

        if (projTrans.mustHandleActivity() && !projTrans.activityNumber())
        {
            ok = checkFailed("@Proj:MissingActivity") && ok;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a budget update is required.
    /// </summary>
    /// <returns>
    /// true if budget update is required; otherwise, false.
    /// </returns>
    public boolean checkUpdateBudget()
    {
        boolean ret;

        if (!projTrans)
        {
            ret = false;
        }
        else if (ProjTable::find(projTrans.projId()).UseBudgeting && !this.parmDoNotUpdateBudget())
        {
            ret =  projTrans.mustHandleBudget() || this.parmSalesOrderCreditNote();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateForecast</Name>
				<Source><![CDATA[
    public boolean checkUpdateForecast()
    {
        if (!projTrans)
        {
            return false;
        }

        // just do reverse committed cost in inventory, should not reduce forecast
        if (this.parmCommittedCostReverse() && notForecastReduction)
        {
            return false;
        }

        return projTrans.mustHandleForecast();
    }

]]></Source>
			</Method>
			<Method>
				<Name>committedCostReverse</Name>
				<Source><![CDATA[
    public void committedCostReverse()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>costEnterCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the posting should have a credit amount for the cost account.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by the class that extends this class to provide the necessary
    /// functionality for the transaction that is being posted.
    /// </remarks>
    protected boolean costEnterCredit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costEnterDebit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the posting should have a debit amount for the cost account.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// This method should be overridden by the class that extends this class to provide the necessary
    /// functionality for the transaction that is being posted.
    /// </remarks>
    protected boolean costEnterDebit()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>costValueCUR</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the cost amount for the transaction.
    /// </summary>
    /// <returns>
    ///    The cost amount for the transaction.
    /// </returns>
    protected AmountCur costValueCUR()
    {
        return projTrans.transCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostSalesDistributions</Name>
				<Source><![CDATA[
    public void createCostSalesDistributions(AmountCur _totalCostAmount, AmountCur _totalSaleAmount)
    {
        ProjFundingEngine       projFundingEngine;

        costDistributions = new Map(Types::Int64, Types::Real);
        saleDistributions = new Map(Types::Int64, Types::Real);

        projFundingEngine = ProjFundingEngine::construct(projTrans, _totalCostAmount ,  _totalSaleAmount);
        if (projFundingEngine.allocate())
        {
            costDistributions = projFundingEngine.parmCostDistributions();
            saleDistributions = projFundingEngine.parmSaleDistributions();
            fundingSourceList = projFundingEngine.parmfundingSourceAllocation();
        }
        else
        {
            allocationError = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCostSalesDistributionsForSingleFS</Name>
				<Source><![CDATA[
    public void createCostSalesDistributionsForSingleFS(ProjFundingSourceRefId _projFundingSourceRefId, AmountCur _totalCostAmount, AmountCur _totalSaleAmount)
    {
        ProjFundingEngine projFundingEngine = ProjFundingEngine::construct(projTrans, _totalCostAmount,  _totalSaleAmount);

        costDistributions = new Map(Types::Int64, Types::Real);
        saleDistributions = new Map(Types::Int64, Types::Real);

        projFundingEngine.parmSingleFundingSourceRequired(true);
        projFundingEngine.setSingleFundingSourceRefId(_projFundingSourceRefId);
        
        if (projFundingEngine.allocate())
        {
            costDistributions = projFundingEngine.parmCostDistributions();
            saleDistributions = projFundingEngine.parmSaleDistributions();
            fundingSourceList = projFundingEngine.parmfundingSourceAllocation();
        }
        else
        {
            allocationError = true;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFundingAllocationListBasedOnTrx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines the internal funding allocation map based on an existing transaction.
    /// </summary>
    /// <param name="projTransType">
    /// The transaction type of the transaction that is being used to define the funding allocation map.
    /// </param>
    public void createFundingAllocationListBasedOnTrx(ProjTransType projTransType)
    {
        MapEnumerator           mapEnumerator;
        ProjSplitAllocation     allocation;
        ProjCostTransCost       projCostTransCost;
        ProjEmplTransCost       projEmplTransCost;
        ProjItemTransCost       projItemTransCost;
        ProjRevenueTransSale    projRevenueTransSale;
        ProjOnAccTransSale      projOnAccTransSale;
        AmountCur               totalTrxAmount;
        AmountCur               amountToMap;
        List                    fundingSourceAllocation;
        Map                     fundingList;
        boolean                 firstRecord = true;

        fundingList = new Map(Types::Int64, Types::Real);
        fundingSourceAllocation = new List( Types::Class );

        switch (projTransType)
        {
            case ProjTransType::Cost :
            while select LineAmount, FundingSource from projCostTransCost
                where projCostTransCost.TransId == this.parmProjTrans().transId()
                {
                    totalTrxAmount = totalTrxAmount + projCostTransCost.LineAmount;
                    amountToMap = projCostTransCost.LineAmount;
                    if (fundingList.exists(projOnAccTransSale.FundingSource))
                    {
                        //Update value to map
                        amountToMap = fundingList.lookup(projOnAccTransSale.FundingSource) + amountToMap;
                        fundingList.remove(projCostTransCost.FundingSource);
                    }
                    fundingList.insert(projCostTransCost.FundingSource, amountToMap);
                }
                break;

            case ProjTransType::Hour :
                // Get the hour transactions related to specific funding source using <c>TransIdRef</c> field.
                if (ProjCalcIndirectCostForMulFundSrcFlight::instance().isEnabled()
                    && ProjEmplTrans::find(this.parmProjTrans().transId()).TransactionOrigin == ProjOrigin::Timesheet)
                {
                    ProjEmplTrans projEmplTransOrig;

                    while select LineAmount, FundingSource from projEmplTransCost
                        exists join projEmplTransOrig
                            where projEmplTransOrig.TransId == projEmplTransCost.TransId
                               && projEmplTransOrig.TransIdRef == this.parmProjTrans().transId()
                    {
                        totalTrxAmount = totalTrxAmount + projEmplTransCost.LineAmount;
                        amountToMap = projEmplTransCost.LineAmount;

                        if (fundingList.exists(projEmplTransCost.FundingSource))
                        {
                            // Update value to map
                            amountToMap = fundingList.lookup(projEmplTransCost.FundingSource) + amountToMap;
                            fundingList.remove(projEmplTransCost.FundingSource);
                        }

                        fundingList.insert(projEmplTransCost.FundingSource, amountToMap);
                    }
                }
                else
                {
                    while select LineAmount, FundingSource from projEmplTransCost
                        where projEmplTransCost.TransId == this.parmProjTrans().transId()
                    {
                        totalTrxAmount = totalTrxAmount + projEmplTransCost.LineAmount;
                        amountToMap = projEmplTransCost.LineAmount;
                        if (fundingList.exists(projEmplTransCost.FundingSource))
                        {
                            //Update value to map
                            amountToMap = fundingList.lookup(projEmplTransCost.FundingSource) + amountToMap;
                            fundingList.remove(projEmplTransCost.FundingSource);
                        }
                        fundingList.insert(projEmplTransCost.FundingSource, amountToMap);
                    }
                }
                break;

            case ProjTransType::Item :
            while select LineAmount, FundingSource from projItemTransCost
                        where projItemTransCost.InventTransId == this.parmProjTrans().inventTransId()
                {
                    totalTrxAmount = totalTrxAmount + projItemTransCost.LineAmount;
                    amountToMap = projItemTransCost.LineAmount;
                    if (fundingList.exists(projItemTransCost.FundingSource))
                    {
                        //Update value to map
                        amountToMap = fundingList.lookup(projItemTransCost.FundingSource) + amountToMap;
                        fundingList.remove(projItemTransCost.FundingSource);
                    }
                    fundingList.insert(projItemTransCost.FundingSource, amountToMap);
                }
                break;

            case ProjTransType::Revenue :
            while select LineAmount, FundingSource from projRevenueTransSale
                        where projRevenueTransSale.TransId == this.parmProjTrans().transId()
                {
                    totalTrxAmount = totalTrxAmount + projRevenueTransSale.LineAmount;
                    amountToMap = projRevenueTransSale.LineAmount;
                    if (fundingList.exists(projRevenueTransSale.FundingSource))
                    {
                        //Update value to map
                        amountToMap = fundingList.lookup(projRevenueTransSale.FundingSource) + amountToMap;
                        fundingList.remove(projRevenueTransSale.FundingSource);
                    }
                    fundingList.insert(projRevenueTransSale.FundingSource, amountToMap);
                }
                break;

            case ProjTransType::OnAccount :
            while select Amount, FundingSource from projOnAccTransSale
                        where projOnAccTransSale.TransId == this.parmProjTrans().transId()
                {
                    totalTrxAmount = totalTrxAmount + projOnAccTransSale.Amount;
                    amountToMap = projOnAccTransSale.Amount;
                    if (fundingList.exists(projOnAccTransSale.FundingSource))
                    {
                        //Update value to map
                        amountToMap = fundingList.lookup(projOnAccTransSale.FundingSource) + amountToMap;
                        fundingList.remove(projOnAccTransSale.FundingSource);
                    }
                    fundingList.insert(projOnAccTransSale.FundingSource, amountToMap);
                }
                break;

            default :
        }
        while select Amount, FundingSource from projOnAccTransSale
                where projOnAccTransSale.TransId == this.parmProjTrans().transId()
        {
            totalTrxAmount = totalTrxAmount + projOnAccTransSale.Amount;
            amountToMap = projOnAccTransSale.Amount;
            if (fundingList.exists(projOnAccTransSale.FundingSource))
            {
                //Update value to map
                amountToMap = fundingList.lookup(projOnAccTransSale.FundingSource) + amountToMap;
                fundingList.remove(projOnAccTransSale.FundingSource);
            }
            fundingList.insert(projOnAccTransSale.FundingSource, amountToMap);
        }

        //Traverse the funding sources and create the list and percentages
        mapEnumerator = fundingList.getEnumerator();
        while ( mapEnumerator.moveNext() )
        {
            if (totalTrxAmount != 0.00)
            {
                allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                         mapEnumerator.currentValue()/totalTrxAmount * 100,
                                                         0,
                                                         firstRecord ? NoYes::Yes : NoYes::No );
            }
            else
            {
                //
                // This code should not be executed as TrxAmount values should not be 0.00.
                // Handle possible divide by zero error
                //
                allocation = ProjSplitAllocation::construct( mapEnumerator.currentKey(),
                                                         100,
                                                         0,
                                                         firstRecord ? NoYes::Yes : NoYes::No );
            }
            fundingSourceAllocation.addEnd( allocation );
            firstRecord = false;
        }

        this.parmFundingSourceList( fundingSourceAllocation );
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountCostValueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension for posting the credit side of transactions for costs.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension for posting credit amounts for costs.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted; otherwise, it will throw an exception.
    /// </remarks>
    public LedgerDimensionDefaultAccount creditAccountCostValueLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountOnAccLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension for posting the credit side of transactions for on-account accounts.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension for posting credit amounts for the on-account account.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class to provide the necessary functionality for the transaction that is being posted. Otherwise, it will throw an exception.
    /// </remarks>
    public LedgerDimensionDefaultAccount creditAccountOnAccLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountSalesAccruedLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension that is used for posting accrued sales amounts.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension for posting accrued sales amounts.
    /// </returns>
    public LedgerDimensionDefaultAccount creditAccountSalesAccruedLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return projTrans.salesOffsetAccountLedgerDimension(_fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditAccountTurnoverLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension that is used for posting revenue amounts.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension that is used for posting revenue amounts.
    /// </returns>
    public LedgerDimensionDefaultAccount creditAccountTurnoverLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return projTrans.revenueAccountLedgerDimension(_fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyIdCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the currency code for cost transactions.
    /// </summary>
    /// <returns>
    ///    The currency for cost transactions.
    /// </returns>
    public CurrencyCode currencyIdCost()
    {
        return projTrans.currencyIdCost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyIdSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the currency code for the sales transactions.
    /// </summary>
    /// <returns>
    ///    The currency code for sales transactions.
    /// </returns>
    public CurrencyCode currencyIdSales()
    {
        if (this.parmReverseAccrued())
        {
            if (this.parmUseTransCurrReverseAccrued())
            {
                return projTrans.currencyIdSales();
            }
            else
            {
                return CompanyInfoHelper::standardCurrency();
            }
        }

        return projTrans.currencyIdSales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountCostValueLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension that is used for the debit side of a posting transaction for costs.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The ledger dimension used for posting debit amounts of cost transactions.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class; otherwise, an exception message will be thrown when the method is called.
    /// </remarks>
    public LedgerDimensionDefaultAccount debitAccountCostValueLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountOnAccLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension that is used for the debit side of posting an on-account transaction.
    /// </summary>
    /// <param name="_fundingSourceId">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The posting dimension for debit amounts of on-account transactions.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class; otherwise, an exception message will be thrown when the method is called.
    /// </remarks>
    public LedgerDimensionDefaultAccount debitAccountOnAccLedgerDimension(ProjFundingSourceRefId _fundingSourceId )
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>debitAccountSalesAccruedLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger dimension that is used for the debit side of a posting transaction for sales-accrued revenue.
    /// </summary>
    /// <param name="_fundingSourceID">
    ///    The funding Source associated with the project contract to be used by this transaction.
    /// </param>
    /// <returns>
    ///    The posting dimension for the debit amount of sales-accrued revenue transactions.
    /// </returns>
    /// <remarks>
    ///    This method must be overridden by the class that extends this class; otherwise, an exception message will be thrown when the method is called.
    /// </remarks>
    public LedgerDimensionDefaultAccount debitAccountSalesAccruedLedgerDimension(ProjFundingSourceRefId _fundingSourceID )
    {
        return projTrans.salesValueAccountLedgerDimension(_fundingSourceID);
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the dimension value from the <c>projTrans</c> instance variable.
    /// </summary>
    /// <returns>
    /// The dimension value from the <c>projTrans</c> instance variable.
    /// </returns>
    public DimensionDefault defaultDimension()
    {
        return projTrans.defaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the exchange rate to use to compute amounts in the default currency.
    /// </summary>
    /// <returns>
    /// Returns the value zero.
    /// </returns>
    /// <remarks>
    /// When the value zero is passed to the routine for computing amounts in the default currency, the
    /// exchange rate is retrieved from the tables.
    /// </remarks>
    public ExchRate exchRate()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyExchRate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieve the reporting currency exchange rate to use to compute amounts in the reporting currency.
    /// </summary>
    /// <returns>
    /// Returns the value zero.
    /// </returns>
    public ExchRate reportingCurrencyExchRate()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the exchange rate to use for a sales amount posting.
    /// </summary>
    /// <returns>
    /// The exchange rate to use for a sales amount posting.
    /// </returns>
    /// <remarks>
    /// If the <c>parmReverseAccrued</c> method returns true, the exchange rate that is returned will be
    /// zero. When the value is zero, the routine to compute currency amounts will look up the exchange
    /// rate from the currency exchange table.
    /// </remarks>
    public ExchRate exchRateSales()
    {
        if (this.parmReverseAccrued())
        {
            if (this.parmUseTransCurrReverseAccrued())
            {
                AmountCur postedExchRate = this.getPostedExchRateSales();
                if (postedExchRate)
                {
                    return postedExchRate;
                }
                return projTrans.exchRateSales();
            }
            else
            {
                return 0;
            }
        }

        return projTrans.exchRateSales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSalesByPostingType</Name>
				<Source><![CDATA[
    [ Wrappable(false) ]
    protected ExchRate exchRateSalesByPostingType(LedgerPostingType _ledgerPostingType = LedgerPostingType::None)
    {
        if (this.parmReverseAccrued())
        {
            if (this.parmUseTransCurrReverseAccrued())
            {
                // The current transaction is reversing the Accrued revenue amount, get the original exchange rate for reversal
                AmountCur postedExchRate = this.getPostedExchRateSales(_ledgerPostingType);
                if (postedExchRate)
                {
                    return postedExchRate;
                }
                return projTrans.exchRateSales();
            }
            else
            {
                return 0;
            }
        }

        return projTrans.exchRateSales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostedExchRateSales</Name>
				<Source><![CDATA[
    private ExchRate getPostedExchRateSales(LedgerPostingType _ledgerPostingType = LedgerPostingType::None)
    {
        ProjOpsFinancialsLogger logger = ProjOpsFinancialsLogger::createLogger(classStr(ProjPost));
        using (var activityContext = logger.projOpsFinActivity().featureInstrumentationContext(ProjOpsFinancialsInstrumentationActivites::ProjGetPostedExchRateSalesFromGL))
        {
            GeneralJournalAccountEntry generalJournalAccountEntry;
            GeneralJournalEntry generalJournalEntry;
            ProjTransPosting projTransPosting;

            ProjTransIdBase projTransId = this.parmAdjRefTransId() ? this.parmAdjRefTransId() : projTrans.transId();
            CurrencyCode currencyCode = this.currencyIdSales();
            LedgerRecId currLedgerRecId = Ledger::current();

            select reverse firstonly AccountingCurrencyAmount, TransactionCurrencyAmount, RecId from generalJournalAccountEntry
                join RecId from generalJournalEntry
                    where generalJournalEntry.RecId == generalJournalAccountEntry.GeneralJournalEntry
                        && generalJournalEntry.Ledger == currLedgerRecId
                join RecId from projTransPosting
                    where projTransPosting.Voucher == generalJournalEntry.SubledgerVoucher
                        && projTransPosting.LedgerTransDate == generalJournalEntry.AccountingDate
                        && projTransPosting.TransId == projTransId
                        && generalJournalAccountEntry.TransactionCurrencyCode == currencyCode
                        && generalJournalAccountEntry.AccountingCurrencyAmount != 0
                        && generalJournalAccountEntry.TransactionCurrencyAmount != 0
                        && (_ledgerPostingType == LedgerPostingType::None || generalJournalAccountEntry.PostingType == _ledgerPostingType);

            ExchRate postedExchRateSales;
            if (generalJournalAccountEntry.RecId)
            {
                postedExchRateSales = generalJournalAccountEntry.getAccountingExchangeRate();
            }

            logger.logInformation(strFmt("GeneralJournalAccountEntry RecId: %1, TransId: %2, TransactionCurrencyCode: %3, Ledger RecId: %4, Posted exchange rate sales: %5",
                generalJournalAccountEntry.RecId, projTransId, currencyCode, currLedgerRecId, postedExchRateSales));

            return postedExchRateSales;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondary</Name>
				<Source><![CDATA[
    public ExchRate exchRateSecondary()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondarySales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the secondary exchange rate to use in posting sales amounts.This value is used when
    /// triangulation is required to determine the default currency amount.
    /// </summary>
    /// <returns>
    /// The secondary exchange rate to use for computing sales amounts.
    /// </returns>
    /// <remarks>
    /// If the method <c>parmReverseAccrued()</c> returns true, the exchange rate that is returned will be
    /// 0. When the value is 0, the routine to compute currency amounts will look up the exchange rate from
    /// the currency exchange table.
    /// </remarks>
    public ExchRate exchRateSecondarySales()
    {
        if (this.parmReverseAccrued())
        {
            if (this.parmUseTransCurrReverseAccrued())
            {
                return projTrans.exchRateSecondarySales();
            }
            else
            {
                return 0;
            }
        }

        return projTrans.exchRateSecondarySales();
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSecondaryTurnover</Name>
				<Source><![CDATA[
    public ExchRate exchRateSecondaryTurnover()
    {
        return projTrans.exchRateSecondarySales(ledgerVoucher.findLedgerVoucherObject().parmTransDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateTurnover</Name>
				<Source><![CDATA[
    public ExchRate exchRateTurnover()
    {
        return projTrans.exchRateSales(ledgerVoucher.findLedgerVoucherObject().parmTransDate());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerDateForOrigTrans</Name>
				<Source><![CDATA[
    public date getLedgerDateForOrigTrans(ProjCostTrans _projCostTransOrig)
    {
        ProjCostTrans projCostTransOrigLoc = ProjCostTrans::find(_projCostTransOrig.TransId);
        while (projCostTransOrigLoc.AdjRefTransId)
        {
            projCostTransOrigLoc = ProjCostTrans::find(projCostTransOrigLoc.AdjRefTransId);
        }

        ProjCostTransCost projCostTransCostLoc;
        select firstonly LedgerTransdate from projCostTransCostLoc
            where projCostTransCostLoc.TransId == projCostTransOrigLoc.TransId;

        if (!projCostTransCostLoc.LedgerTransdate)
        {
            throw error(strFmt("@Proj:AdjustmentLedgerTransDateNotFoundError", projCostTransOrigLoc.TransId));
        }

        return projCostTransCostLoc.LedgerTransdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>forecastUpdate</Name>
				<Source><![CDATA[
    public void forecastUpdate()
    {
        ProjForecastReduce  projForecastReduce;

        projForecastReduce=ProjForecastReduce::newProjPost(projTrans,
                                                       projTrans.qty(),
                                                       projTrans.transCost());
        projForecastReduce.parmProjTransIdOrig(this.parmTransIdOrig());
        projForecastReduce.parmProjTransId(this.parmTransIdCost());

        projForecastReduce.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getbudgetAdjustmentType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Obtains the adjustment type of budget.
    /// </summary>
    /// <returns>
    /// The adjustment type of budget.
    /// </returns>
    protected ProjBudgetAdjustmentType getbudgetAdjustmentType()
    {
        ProjBudgetAdjustmentType      projBudgetAdjustmentType;

        if (projTrans.transType() == ProjTransType::Revenue)
        {
            if (!this.parmTransIdOrig())
            {
                projBudgetAdjustmentType = ProjBudgetAdjustmentType::Decrement;
            }
        }
        else
        {
            if (!this.parmTransIdOrig())
            {
                projBudgetAdjustmentType = ProjBudgetAdjustmentType::Decrement;
            }
        }

        return projBudgetAdjustmentType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrencyExchHelperForReversingEntry</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the current transaction is part of a reversing entry journal and if so it gets an
    /// instance of CurrencyExchangeHelper using the date from the original transaction.
    /// </summary>
    /// <returns>
    /// An instance of CurrencyExchangeHelper.
    /// </returns>
    /// <remarks>
    /// Handles CurrencyExchangeHelper instance creation for Reversal Entry Journals.
    /// </remarks>
    public CurrencyExchangeHelper getCurrencyExchHelperForReversingEntry()
    {
        LedgerJournalTrans      ledgerJournalTrans;
        LedgerJournalTrans      ledgerJournalTransOrig;
        CurrencyExchangeHelper  exchangeRateHelper;

        if (this.parmProjTrans().buffer().TableId == tableNum(LedgerJournalTrans))
        {
            ledgerJournalTrans = this.parmProjTrans().buffer();

            if (!ledgerJournalTrans.ReverseEntry)
            {
                ledgerJournalTransOrig = LedgerJournalTrans::findByReverse(ledgerJournalTrans.RecId);
            }

            if (ledgerJournalTransOrig && ledgerJournalTransOrig.ReverseEntry)
            {
                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::current(), ledgerJournalTransOrig.TransDate);
            }
        }
        return exchangeRateHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceLedgerList</Name>
				<Source><![CDATA[
    public List getInvoiceLedgerList()
    {
        return invoiceLedgerList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRefTransId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Obtains the reference transaction ID that is associated with the project transaction.
    /// </summary>
    /// <returns>
    /// The reference transaction ID.
    /// </returns>
    protected ProjTransIdBase getRefTransId()
    {
        ProjTransIdBase projTransIdBase;

        if ((projTrans.transType() == ProjTransType::Revenue && projTrans.salesPrice() < 0)
            || (projTrans.transType() != ProjTransType::Revenue && projTrans.qty() < 0)
            || this.parmTransIdOrig())
        {
            projTransIdBase  = this.parmTransIdOrig();
        }

        return projTransIdBase;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSalesLine</Name>
				<Source><![CDATA[
    protected void initSalesLine()
    {
        projTrans = ProjTrans::newSalesLine(salesLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    public void initUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>investmentElimination</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the investment elimination value.
    /// </summary>
    /// <returns>
    ///    Returns false.
    /// </returns>
    public boolean investmentElimination()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPLPostingRequiredForTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether PnL posting is needed for the given project ID and transaction type.
    /// </summary>
    /// <param name = "_wipProject">Estimate project.</param>
    /// <param name = "_projTrans">Transaction being posted.</param>
    /// <returns>true if PnL posting should be done; otherwise, false.</returns>
    private static boolean isPLPostingRequiredForTransType(ProjWIPTable _wipProject, ProjTrans _projTrans)
    {
        boolean ret = false;
        boolean multipleContractLineFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        ProjTransType projTransType = _projTrans.transType();
        PSAContractLineItems contractLine = PSAContractLineItems::find(_projTrans.psaContractLineNum());
        // Check if project/wip project is eliminated
        if (_wipProject.fixedPriceEligibleForOnlyPLPosting())
        {
            if((projTransType == ProjTransType::Hour && contractLine.IncludeHourTrans == NoYes::Yes) ||
                             (projTransType == ProjTransType::Cost && contractLine.IncludeExpenseTrans == NoYes::Yes) ||
                             (projTransType == ProjTransType::Item && contractLine.IncludeItemTrans == NoYes::Yes) ||
                             (projTransType == ProjTransType::Revenue && contractLine.IncludeFeeTrans == NoYes::Yes))
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerStatusCostAndEnterCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes ledger status and enter cost parameters.
    /// </summary>
    /// <param name = "_projTrans">
    /// The project transaction on which the parameters are initialized.
    /// </param>
    protected void initializeLedgerStatusCostAndEnterCost(ProjTrans _projTrans)
    {
        InventModelGroup inventModelGroup = InventTable::modelGroupByItemId(_projTrans.itemId());

        if (inventModelGroup.PostOnhandFinancial || !inventModelGroup.StockedProduct)
        {
            if (_projTrans.projLineProperty().ToBeCapitalize)
            {
                ProjTable projTable = _projTrans.projTable();

                SalesLine salesLineLocal;
                if (_projTrans.buffer().TableId == tableNum(SalesLine))
                {
                    salesLineLocal = _projTrans.buffer();
                }

                ProjWIPTable wipProject = _projTrans.getWIPProject();
                if(contractLineBasedRevRecFeature && wipProject.IsContractLineUsed)
                {
                    // Project cost must be recognized for eliminated projects as well
                    if (ProjPost::isPLPostingRequiredForTransType(wipProject,_projTrans)
                        && !ProjControlPeriodTable::eliminated(wipProject.ProjId, wipProject.ControlId))
                    {
                        this.parmLedgerStatusCost(ProjLedgerStatus::Operations);

                        // Even though Revenue recognition accounting rule is set to no WIP, still need to recognize project cost.
                        if (!inventModelGroup.StockedProduct
                            && salesLineLocal.SalesType == SalesType::ItemReq
                            && projTable.projGroup().CompletePrincip == ProjCompletePrincip::NoWIP)
                        {
                            this.parmEnterCost(true);
                        }
                    }
                    else if(ProjLedgerStatusOperationsFlight::instance().isEnabled()
                        && ProjPost::isPLPostingRequiredForTransType(wipProject,_projTrans)
                        && ProjControlPeriodTable::eliminated(wipProject.ProjId, wipProject.ControlId))
                    {
                        this.parmLedgerStatusCost(ProjLedgerStatus::Operations);

                        if (!inventModelGroup.StockedProduct
                            && salesLineLocal.SalesType == SalesType::ItemReq)
                        {
                            this.parmEnterCost(true);
                        }
                    }
                    else
                    {
                        this.parmEnterCost(true);

                        if (ProjRevRecHelper::item2LedgerStatus(ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).ItemLedgerStatus) == ProjLedgerStatus::Operations
                            && salesLineLocal && salesLineLocal.SalesType == SalesType::ItemReq
                            && FeatureStateProvider::isFeatureEnabled(ProjEnableProfitAndLossItemReqConsumptionFlight::instance()))
                        {
                            this.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                        }
                        else
                        {
                            this.parmLedgerStatusCost(ProjLedgerStatus::BalanceSheet);
                        }
                    }
                
                }
                else
                {
                    // Project cost must be recognized for eliminated projects as well
                    if (ProjTable::isPLPostingRequiredForTransType(projTable.ProjId, _projTrans.transType())
                        && !ProjControlPeriodTable::eliminated(projTable.wipProject, ProjWIPTable::find(projTable.wipProject).ControlId))
                    {
                        this.parmLedgerStatusCost(ProjLedgerStatus::Operations);

                        // Even though Revenue recognition accounting rule is set to no WIP, still need to recognize project cost.
                        if (!inventModelGroup.StockedProduct
                        && salesLineLocal.SalesType == SalesType::ItemReq
                        && projTable.projGroup().CompletePrincip == ProjCompletePrincip::NoWIP)
                        {
                            this.parmEnterCost(true);
                        }
                    }
                    else if(ProjLedgerStatusOperationsFlight::instance().isEnabled()
                        && ProjTable::isPLPostingRequiredForTransType(projTable.ProjId, _projTrans.transType())
                        && ProjControlPeriodTable::eliminated(projTable.wipProject, ProjWIPTable::find(projTable.wipProject).ControlId))
                    {
                        this.parmLedgerStatusCost(ProjLedgerStatus::Operations);

                        if (!inventModelGroup.StockedProduct
                            && salesLineLocal.SalesType == SalesType::ItemReq)
                        {
                            this.parmEnterCost(true);
                        }
                    }
                    else
                    {
                        this.parmEnterCost(true);

                        if (ProjRevRecHelper::getItemLedgerStatus(projTable, false) == ProjLedgerStatus::Operations
                        && salesLineLocal && salesLineLocal.SalesType == SalesType::ItemReq
                        && FeatureStateProvider::isFeatureEnabled(ProjEnableProfitAndLossItemReqConsumptionFlight::instance()))
                        {
                            this.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                        }
                        else
                        {
                            this.parmLedgerStatusCost(ProjLedgerStatus::BalanceSheet);
                        }
                    }
                }
            }
            else 
            {
                if (_projTrans is ProjTransSalesLine 
                    && !inventModelGroup.StockedProduct
                    && ProjEnableVoucherLinesForItemTransactionsFlight::instance().isEnabled())
                {
                    // Set the enter cost, when there is an item requirement for a sales line exists.
                    // This condition will help the ledger voucher transaction creation in the subsequent method <c>checkEnterCostValue</c> of ProjPost class.

                    SalesLine salesLineLocal;
                    if (_projTrans.buffer().TableId == tableNum(SalesLine))
                    {
                        salesLineLocal = _projTrans.buffer();
                    }

                    if (salesLineLocal && salesLineLocal.SalesType == SalesType::ItemReq)
                    {
                        this.parmEnterCost(true);
                    }
                }
                
                this.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransCorrection</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the project transaction should be posted as correction or not.
    /// </summary>
    /// <param name="_amountCur">
    /// The amount on the transaction.
    /// </param>
    /// <param name="_adjustmentCorrection">
    /// The value indicating whether transaction is an adjustment correction.
    /// </param>
    /// <param name="_projOrigin">
    /// The origin of project transaction.
    /// </param>
    /// <returns>
    /// true if the project transaction should be posted as correction; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The transaction would be a correction if either of the following are true: It is an adjustment
    /// transaction and <paramref name="_adjustmentcorrection" /> parameter is true. The amount is negative
    /// and the Project parameter to post negative transactions as correction is enabled.
    /// </remarks>
    public LedgerCorrection isTransCorrection(AmountCur         _amountCur = this.costValueCUR()-this.parmTaxAmountCur(),
                                          LedgerCorrection  _adjustmentCorrection = this.parmAdjustCorrection(),
                                          ProjOrigin        _projOrigin = this.parmLedgerOrigin())
    {
        if (_projOrigin == ProjOrigin::Adjustment)
        {
            return _adjustmentCorrection;
        }
        else
        {
            LedgerJournalTrans ledgerJournalTrans = this.parmProjTrans().buffer() as LedgerJournalTrans;

            if (ledgerJournalTrans != null)
            {
                LedgerJournalTrans_Project ledgerJournalTrans_Project = LedgerJournalTrans_Project::find(ledgerJournalTrans.RecId);
                return ledgerJournalTrans_Project.Correction && (ledgerJournalTrans.AmountCurCredit < 0 || ledgerJournalTrans.AmountCurDebit < 0);
            }
            else
            {
                // Treat as correction when GL correction flag on and it is a credit note proposal.
                ProjCostTransSale projCostTransSale = ProjCostTransSale::findByTransIdFundingSourceId(this.parmTransIdSales(), projTrans.fundingSource());
                return (projCostTransSale 
                    && projCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal 
                    && LedgerParameters::find().TransactionReversalCorrection);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerCostAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>LedgerCostAmountMST</c>, which represents the amount in the default currency.
    /// </summary>
    /// <param name="_ledgerCostAmountMST">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>LedgerCostAmountMST</c>.
    /// </returns>
    protected AmountMST ledgerCostAmountMST(AmountMST _ledgerCostAmountMST = ledgerCostAmountMST)
    {
        ledgerCostAmountMST = _ledgerCostAmountMST;

        return ledgerCostAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerSalesAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sales account to be posted to the general ledger.
    /// </summary>
    /// <returns>
    /// The sales amount to be posted to the general ledger.
    /// </returns>
    /// <remarks>
    /// If this transaction is a reversing entry, the value will be the negative value of the value that is
    /// returned by the <c>salesAmountMST</c> method; otherwise, the value will be the revenue amount of
    /// the transaction.
    /// </remarks>
    public AmountCur ledgerSalesAmount()
    {
        if (this.parmReverseAccrued())
        {
            if (this.parmUseTransCurrReverseAccrued())
            {
                if (this.adjustmentLedgerSalesAmount())
                {
                    return -this.adjustmentLedgerSalesAmount();
                }
                else if (this.salesAmountMST())
                {
                    return -projTrans.transTurnover();
                }
            }
            else
            {
                return -this.salesAmountMST();
            }
        }

        return projTrans.transTurnover();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerTransActionsCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the transaction and then posts the transaction to the ledger.
    /// </summary>
    /// <remarks>
    ///    This method is called by the <c>PostTrans()</c> method.
    /// </remarks>
    protected void ledgerTransActionsCreate()
    {
        if (!this.checkLedger())
        {
            return;
        }

        if (!projTrans)
        {
            throw error("@SYS3458");
        }

        if (this.checkEnterCostValue())
        {
            this.postCost();
        }

        if (this.checkEnterSalesAccrued())
        {
            this.postTurnoverAccrued();
        }

        if (this.checkEnterTurnover())
        {
            this.postTurnover();
        }

        if (this.checkEnterNeverLedger())
        {
            this.postNeverLedger();
        }

        if (this.checkEnterNoneLedger())
        {
            this.postNoneLedger();
        }

        if (this.checkEnterOnAcc())
        {
            this.postOnAccAccrued();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a new instance of <c>ProjPost</c>.
    /// </summary>
    /// <param name="_buffer">
    /// The table for the transaction type.
    /// </param>
    /// <remarks>
    /// This method is typically overridden by the class that extends this class.
    /// </remarks>
    public void new(Common _buffer)
    {
        allocationError = NoYes::No;
        postToGeneralLedger = true;
        // <GEERU>
        countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTrans</Name>
				<Source><![CDATA[
    public Common newTrans()
    {
        Common  buffer;

        return buffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>oneVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether one voucher was created for the journal.
    /// </summary>
    /// <returns>
    /// true if there is only one voucher created for the journal; otherwise, false.
    /// </returns>
    protected boolean oneVoucher()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjRefTransId</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmAdjRefTransId(ProjTransIdBase _adjRefTransId = adjRefTransId)
    {
        adjRefTransId  = _adjRefTransId;

        return adjRefTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsContractLineUsed</Name>
				<Source><![CDATA[
    public boolean parmIsContractLineUsed(boolean _isContractLineUsed = isContractLineUsed)
    {
        isContractLineUsed  = _isContractLineUsed;

        return isContractLineUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustBuffer</Name>
				<Source><![CDATA[
    protected TmpProjAdjustmentCreate parmAdjustBuffer(TmpProjAdjustmentCreate  _adjustBuffer = adjustBuffer)
    {
        adjustBuffer  = _adjustBuffer;

        return adjustBuffer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmadjustBufferCost</Name>
				<Source><![CDATA[
    protected TmpProjAdjustmentCreateCost parmadjustBufferCost(TmpProjAdjustmentCreateCost  _adjustBufferCost = adjustBufferCost)
    {
        adjustBufferCost  = _adjustBufferCost;

        return adjustBufferCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmadjustBufferSale</Name>
				<Source><![CDATA[
    protected TmpProjAdjustmentCreateSale parmadjustBufferSale(TmpProjAdjustmentCreateSale  _adjustBufferSale = adjustBufferSale)
    {
        adjustBufferSale  = _adjustBufferSale;

        return adjustBufferSale;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustCorrection</Name>
				<Source><![CDATA[
    public LedgerCorrection parmAdjustCorrection(LedgerCorrection _adjustCorrection = adjustCorrection)
    {
        adjustCorrection = _adjustCorrection;
        return adjustCorrection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustment</Name>
				<Source><![CDATA[
    public boolean parmAdjustment(boolean  _adjustment = adjustment)
    {
        adjustment  = _adjustment;

        return adjustment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustmentDate</Name>
				<Source><![CDATA[
    public TransDate parmAdjustmentDate(TransDate  _adjustmentDate = adjustmentDate)
    {
        adjustmentDate  = _adjustmentDate;

        return adjustmentDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustmentLedgerSalesAmount</Name>
				<Source><![CDATA[
    protected AmountCur parmAdjustmentLedgerSalesAmount(AmountCur _adjustmentLedgerSalesAmount = adjustmentLedgerSalesAmount)
    {
        adjustmentLedgerSalesAmount = _adjustmentLedgerSalesAmount;

        return adjustmentLedgerSalesAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAdjustRefId</Name>
				<Source><![CDATA[
    public ProjAdjustRefId parmAdjustRefId(ProjAdjustRefId    _adjustRefId    = adjustRefId)
    {
        adjustRefId = _adjustRefId;

        return adjustRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmcheckCreditNoteItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>checkCreditNoteItem</c>.
    /// </summary>
    /// <param name="_checkCreditNoteItem">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>checkCreditNoteItem</c>.
    /// </returns>
    protected boolean parmcheckCreditNoteItem(boolean  _checkCreditNoteItem = checkCreditNoteItem)
    {
        checkCreditNoteItem  = _checkCreditNoteItem;

        return checkCreditNoteItem;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCommittedCostReverse</Name>
				<Source><![CDATA[
    public boolean parmCommittedCostReverse(boolean _committedCostReverse=committedCostReverse)
    {
        committedCostReverse = _committedCostReverse;

        return committedCostReverse;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCostUseOrig</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>costUseOrig</c>.
    /// </summary>
    /// <param name="_costUseOrig">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>costUseOrig</c>.
    /// </returns>
    public boolean parmCostUseOrig(boolean _costUseOrig = costUseOrig)
    {
        costUseOrig  = _costUseOrig;

        return costUseOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerStatusCostOrig</Name>
				<Source><![CDATA[
    public boolean parmLedgerStatusCostOrig(boolean _ledgerStatusCostOrig = ledgerStatusCostOrig)
    {
        ledgerStatusCostOrig = _ledgerStatusCostOrig;
        return ledgerStatusCostOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesOrderCreditNote</Name>
				<Source><![CDATA[
    public boolean parmSalesOrderCreditNote(boolean _isSalesOrderCreditNote = isSalesOrderCreditNote)
    {
        isSalesOrderCreditNote = _isSalesOrderCreditNote;
        return isSalesOrderCreditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreateTrans</Name>
				<Source><![CDATA[
    protected boolean parmCreateTrans(boolean  _createTrans = createTrans)
    {
        createTrans  = _createTrans;

        return createTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmElimination</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>Elimination</c>.
    /// </summary>
    /// <param name="_elimination">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>Elimination</c>.
    /// </returns>
    protected boolean parmElimination(boolean _elimination = elimination)
    {
        elimination  = _elimination;

        return elimination;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnterAccruedOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>EnterAccruedOnAcc</c>.
    /// </summary>
    /// <param name="_enterAccruedOnAcc">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>EnterAccruedOnAcc</c>.
    /// </returns>
    protected boolean parmEnterAccruedOnAcc(boolean _enterAccruedOnAcc = enterAccruedOnAcc)
    {
        enterAccruedOnAcc  = _enterAccruedOnAcc;

        return enterAccruedOnAcc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnterCost</Name>
				<Source><![CDATA[
    protected boolean parmEnterCost(boolean  _enterCost = enterCost)
    {
        enterCost  = _enterCost;

        return enterCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnterSalesAccrued</Name>
				<Source><![CDATA[
    protected boolean parmEnterSalesAccrued(boolean _enterSalesAccrued = enterSalesAccrued)
    {
        enterSalesAccrued  = _enterSalesAccrued;

        return enterSalesAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEnterTurnover</Name>
				<Source><![CDATA[
    protected boolean parmEnterTurnover(boolean  _enterTurnover = enterTurnover)
    {
        enterTurnover  = _enterTurnover;

        return enterTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFundingSourceList</Name>
				<Source><![CDATA[
    public List parmFundingSourceList(List  _fundingSourceList = fundingSourceList)
    {
        fundingSourceList = _fundingSourceList;

        return fundingSourceList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventTransId</Name>
				<Source><![CDATA[
    public InventTransId parmInventTransId(InventTransId   _inventTransId  = inventTransId)
    {
        inventTransId   = _inventTransId;

        return inventTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsCreditNote</Name>
				<Source><![CDATA[
    public boolean parmIsCreditNote(boolean _creditNote = creditNote)
    {
        creditNote  = _creditNote;

        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDimensionUptake</Name>
				<Source><![CDATA[
    protected boolean parmIsDimensionUptake(boolean _isDimensionUptake = isDimensionUptake)
    {
        isDimensionUptake = _isDimensionUptake;

        return isDimensionUptake;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>LedgerDimension</c>.
    /// </summary>
    /// <param name="_ledgerDimension">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>LedgerDimension</c>.
    /// </returns>
    protected LedgerDimensionDefaultAccount parmLedgerDimension(LedgerDimensionDefaultAccount _ledgerDimension  = ledgerDimensionDefaultAccount)
    {
        ledgerDimensionDefaultAccount = _ledgerDimension;

        return ledgerDimensionDefaultAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerOrigin</Name>
				<Source><![CDATA[
    public ProjLedgerOrigin parmLedgerOrigin(ProjLedgerOrigin _ledgerOrigin = ledgerOrigin)
    {
        ledgerOrigin = _ledgerOrigin;

        return ledgerOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerStatusCost</Name>
				<Source><![CDATA[
    public ProjLedgerStatus parmLedgerStatusCost(ProjLedgerStatus _ledgerStatusCostValue = ledgerStatusCostValue)
    {
        ledgerStatusCostValue  = _ledgerStatusCostValue;

        return ledgerStatusCostValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>LedgerVoucher</c>.
    /// </summary>
    /// <param name="_ledgerVoucher">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>LedgerVoucher</c>.
    /// </returns>
    public LedgerVoucher parmLedgerVoucher(LedgerVoucher _ledgerVoucher = ledgerVoucher)
    {
        ledgerVoucher = _ledgerVoucher;

        return ledgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmloadOnInventoryAmount_IN</Name>
				<Source><![CDATA[
    public TaxAmountCur  parmloadOnInventoryAmount_IN(TaxAmountCur _loadOnInventory = loadOnInventory)
    {
        loadOnInventory = _loadOnInventory;
        return  loadOnInventory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNotEnterNeverLedger</Name>
				<Source><![CDATA[
    public boolean parmNotEnterNeverLedger(boolean _notEnterNeverLedger = notEnterNeverLedger)
    {
        notEnterNeverLedger = _notEnterNeverLedger;

        return notEnterNeverLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNotEnterNoneLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>NotEnterNoneLedger</c>.
    /// </summary>
    /// <param name="_notEnterNoneLedger">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>NotEnterNoneLedger</c>.
    /// </returns>
    protected boolean parmNotEnterNoneLedger(boolean  _notEnterNoneLedger = notEnterNoneLedger)
    {
        notEnterNoneLedger  = _notEnterNoneLedger;

        return notEnterNoneLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmNotForecastReduction</Name>
				<Source><![CDATA[
    public boolean parmNotForecastReduction(boolean  _notForecastReduction = notForecastReduction)
    {
        notForecastReduction  = _notForecastReduction;

        return notForecastReduction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDoNotUpdateBudget</Name>
				<Source><![CDATA[
    public boolean parmDoNotUpdateBudget(boolean _doNotUpdateBudget = doNotUpdateBudget)
    {
        doNotUpdateBudget = _doNotUpdateBudget;

        return doNotUpdateBudget;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOriginCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>OriginCost</c>.
    /// </summary>
    /// <param name="_originCost">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>OriginCost</c>.
    /// </returns>
    public ProjOriginCost parmOriginCost(ProjOriginCost  _originCost = originCost)
    {
        originCost  = _originCost;

        return originCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPeriodWIP</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>PeriodWIP</c>.
    /// </summary>
    /// <param name="_periodWIP">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>PeriodWIP</c>.
    /// </returns>
    public ProjPeriodTo parmPeriodWIP(ProjPeriodTo _periodWIP = periodWIP)
    {
        periodWIP  = _periodWIP;

        return periodWIP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostToGeneralLedger</Name>
				<Source><![CDATA[
    public boolean parmPostToGeneralLedger(boolean _postToGeneralLedger = postToGeneralLedger)
    {
        postToGeneralLedger  = _postToGeneralLedger;

        return postToGeneralLedger;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjItemTransCostType</Name>
				<Source><![CDATA[
    public ProjItemTransCostType parmProjItemTransCostType(ProjItemTransCostType _projItemTransCostType = projItemTransCostType)
    {
        projItemTransCostType = _projItemTransCostType;

        return projItemTransCostType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjFundingSource</Name>
				<Source><![CDATA[
    public projFundingSourceRefId parmProjFundingSource(projFundingSourceRefId _projFundingSourceRefId = projFundingSourceRefId)
    {
        projFundingSourceRefId = _projFundingSourceRefId;

        return projFundingSourceRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjProposalJour</Name>
				<Source><![CDATA[
    public ProjProposalJour parmProjProposalJour(ProjProposalJour _projProposalJour = projProposalJour)
    {
        projProposalJour = _projProposalJour;

        return projProposalJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTrans</Name>
				<Source><![CDATA[
    public ProjTrans parmProjTrans(ProjTrans _projTrans = projTrans)
    {
        projTrans = _projTrans;

        return projTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReverseAccrued</Name>
				<Source><![CDATA[
    protected boolean parmReverseAccrued(boolean _reverseAccrued = reverseAccrued)
    {
        reverseAccrued  = _reverseAccrued;

        return reverseAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaleRefRecId</Name>
				<Source><![CDATA[
    public RefRecId parmSaleRefRecId(RefRecId _saleRefRecId = saleRefRecId)
    {
        saleRefRecId = _saleRefRecId;

        return saleRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesAmountMST</Name>
				<Source><![CDATA[
    protected AmountMST parmSalesAmountMST(AmountMST _ledgerSalesAmountMST = ledgerSalesAmountMST)
    {
        ledgerSalesAmountMST = _ledgerSalesAmountMST;

        return ledgerSalesAmountMST;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesLine</Name>
				<Source><![CDATA[
    public SalesLine parmSalesLine(SalesLine _salesLine = salesLine)
    {
        salesLine = _salesLine;

        return salesLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesQty</Name>
				<Source><![CDATA[
    public SalesQty parmSalesQty(SalesQty _salesQty = salesQty)
    {
        salesQty = _salesQty;

        return salesQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmsalesUseOrig</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>salesUseOrig</c>.
    /// </summary>
    /// <param name="_salesUseOrig">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>salesUseOrig</c>.
    /// </returns>
    public boolean parmsalesUseOrig(boolean _salesUseOrig = salesUseOrig)
    {
        salesUseOrig  = _salesUseOrig;

        return salesUseOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipCheckLedgerTransDate</Name>
				<Source><![CDATA[
    public boolean parmSkipCheckLedgerTransDate(boolean _skipCheckLedgerTransDate = skipCheckLedgerTransDate)
    {
        skipCheckLedgerTransDate = _skipCheckLedgerTransDate;
        return skipCheckLedgerTransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSplitTransQtyCon</Name>
				<Source><![CDATA[
    public container parmSplitTransQtyCon(container _splitTransQtyCon = splitTransQtyCon)
    {
        splitTransQtyCon = _splitTransQtyCon;

        return splitTransQtyCon;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmsuppressBudgetMessages</Name>
				<Source><![CDATA[
    public boolean parmsuppressBudgetMessages(boolean  _suppressBudgetMessages = suppressBudgetMessages)
    {
        suppressBudgetMessages  = _suppressBudgetMessages;

        return suppressBudgetMessages;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTax_RU</Name>
				<Source><![CDATA[
    public Tax parmTax_RU(Tax _tax = tax)
    {
        tax = _tax;
        return tax;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxAmountCur</Name>
				<Source><![CDATA[
    public TaxAmountCur parmTaxAmountCur(TaxAmountCur   _taxAmount = taxAmountCur)
    {
        taxAmountCur    = _taxAmount;

        return taxAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxInformation_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the value of <c>TaxInformationRecId</c>.
    /// </summary>
    /// <param name="_taxInformationRecId">
    /// The value to set; optional.
    /// </param>
    /// <returns>
    /// The value of <c>TaxInformationRecId</c>.
    /// </returns>
    public RefRecId parmTaxInformation_IN(RefRecId _taxInformationRecId = taxInformationRecId)
    {
        taxInformationRecId = _taxInformationRecId;
        return taxInformationRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxParentReferenceRecId</Name>
				<Source><![CDATA[
    public RecId parmTaxParentReferenceRecId(RecId _taxParentReferenceRecId = taxParentReferenceRecId)
    {
        taxParentReferenceRecId = _taxParentReferenceRecId;

        return taxParentReferenceRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxParentReferenceTableId</Name>
				<Source><![CDATA[
    public TableId parmTaxParentReferenceTableId(TableId _taxParentReferenceTableId = taxParentReferenceTableId)
    {
        taxParentReferenceTableId = _taxParentReferenceTableId;

        return taxParentReferenceTableId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionOrigin</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin parmTransactionOrigin(ProjTransactionOrigin _transactionOrigin = transactionOrigin)
    {
        transactionOrigin = _transactionOrigin;

        return transactionOrigin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionOriginOrig</Name>
				<Source><![CDATA[
    public ProjTransactionOrigin parmTransactionOriginOrig(ProjTransactionOrigin _transactionOriginOrig = transactionOriginOrig)
    {
        transactionOriginOrig  = _transactionOriginOrig;

        return transactionOriginOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransIdCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>TransIdCost</c>.
    /// </summary>
    /// <param name="_transId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>TransIdCost</c>.
    /// </returns>
    protected ProjTransIdBase parmTransIdCost(ProjTransIdBase _transId = transIdCost)
    {
        transIdCost  = _transId;

        return transIdCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransIdNew</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmTransIdNew()
    {
        return transIdNew;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransIdOrig</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>TransIdOrig</c>.
    /// </summary>
    /// <param name="_transId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>TransIdOrig</c>.
    /// </returns>
    public ProjTransIdBase parmTransIdOrig(ProjTransIdBase _transId = transIdOrig)
    {
        transIdOrig  = _transId;

        return transIdOrig;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransIdRef</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmTransIdRef(ProjTransIdBase _transIdRef = transIdReference)
    {
        transIdReference  = _transIdRef;

        return transIdReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransIdSales</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>TransIdSales</c>.
    /// </summary>
    /// <param name="_transId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>TransIdSales</c>.
    /// </returns>
    protected ProjTransIdBase parmTransIdSales(ProjTransIdBase _transId = transIdSales)
    {
        transIdSales  = _transId;

        return transIdSales;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>TransStatus</c>.
    /// </summary>
    /// <param name="_transStatus">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>TransStatus</c>.
    /// </returns>
    public ProjTransStatus parmTransStatus(ProjTransStatus  _transStatus = transStatus)
    {
        transStatus  = _transStatus;

        return transStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPostItemPhysically</Name>
				<Source><![CDATA[
    public boolean parmPostItemPhysically(boolean _postItemPhysically = postItemPhysically)
    {
        postItemPhysically = _postItemPhysically;

        return postItemPhysically;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUpdateTrans</Name>
				<Source><![CDATA[
    protected boolean parmUpdateTrans(boolean  _updateTrans = updateTrans)
    {
        updateTrans  = _updateTrans;

        return updateTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseTransCurrReverseAccrued</Name>
				<Source><![CDATA[
    protected boolean parmUseTransCurrReverseAccrued(boolean _useTransCurrReverseAccrued = useTransCurrReverseAccrued)
    {
        useTransCurrReverseAccrued = _useTransCurrReverseAccrued;

        return useTransCurrReverseAccrued;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the ledger journal entries for posting to cost accounts.
    /// </summary>
    /// <remarks>
    ///    This method is called by the method <c>ledgerTransActionsCreate()</c>.
    /// </remarks>
    protected void postCost()
    {
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        ProjLedger                      tmpProjLedger;
        Voucher                         voucher;
        AmountCur                       amountCur;
        AmountMST                       locLedgerCostAmountMST;
        MapEnumerator                   fundingAllocationEnumerator;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        LedgerDimensionAccount          mergedLedgerDimension;
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerVoucherObject             ledgerVoucherObject;
        ProjFundingSource               projFundingSource;
        Map                             splitTransQty;
        // <GIN>
        boolean                     countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        // </GIN>
        // <GEERU>
        LedgerBondClient_RU             ledgerBondClient;
        // </GEERU>

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        exchangeRateHelper = this.getCurrencyExchHelperForReversingEntry();

        if (!exchangeRateHelper)
        {
            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        }

        if (this.exchRate())
        {
            exchangeRateHelper.parmExchangeRate1(this.exchRate());
        }
        else
        {
            exchangeRateHelper.parmExchangeRate1(this.parmExchangeRate());
        }

        exchangeRateHelper.parmExchangeRate2(this.exchRateSecondary());

        if (ProjAdjustmentUpdateOverrideReportingExchRateFlight::instance().isEnabled())
        {
            if (this.reportingCurrencyExchRate())
            {
                exchangeRateHelper.parmReportingExchangeRate1(this.reportingCurrencyExchRate());
            }
            else
            {
                exchangeRateHelper.parmReportingExchangeRate1(this.parmReportingExchangeRate());
            }
        }
        
        if (this.costEnterDebit())
        {
            locLedgerCostAmountMST = 0;
            this.postingType(this.postingTypeCost());
            amountCur = this.costValueCUR() - this.parmTaxAmountCur();

            if (!fundingSourceList)
            {
                throw error(strFmt("@SYS22828", funcName()));
            }
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList, amountCur, this.currencyIdCost()).getEnumerator();
            if (splitTransQtyCon)
            {
                splitTransQty = Map::create(splitTransQtyCon);
            }
            else
            {
                splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
            }
            while ( fundingAllocationEnumerator.moveNext() )
            {
                tmpProjLedger = ProjLedger::newProjectCost(projTrans, this.parmTransIdCost(),
                                this.parmTransactionOrigin(),
                                this.parmLedgerOrigin(),
                                this.investmentElimination() ? false : this.parmElimination(),
                                fundingAllocationEnumerator.currentKey(),
                                (splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : projTrans.qty()));

                defaultLedgerDimension = this.parmLedgerDimension(this.debitAccountCostValueLedgerDimension(fundingAllocationEnumerator.currentKey()));
                
                // need to merge the default account with the default dimensions
                if (this.parmLedgerOrigin() == ProjOrigin::Adjustment && this.parmTransStatus() == ProjTransStatus::Adjusted && FeatureStateProvider::isFeatureEnabled(ProjAdjustmentKeepOrigFinDimOnReversingTransFeature::instance()))
                {
                    // For adjusted reverting transaction, directly take default dimension from original transaction
                    mergedLedgerDimension = this.mergeLedgerDimensionDebit(defaultLedgerDimension, this.defaultDimension(), 0);
                }
                else
                {
                    projFundingSource = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                    mergedLedgerDimension = this.mergeLedgerDimensionDebit(defaultLedgerDimension, this.defaultDimension(), projFundingSource.DefaultDimension);
                }

                if (postToGeneralLedger)
                {
                    ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostCostDebit(
                        ledgerVoucherObject,
                        mergedLedgerDimension,
                        this.currencyIdCost(),
                        fundingAllocationEnumerator,
                        exchangeRateHelper,
                        splitTransQty,
                        tmpProjLedger);

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    locLedgerCostAmountMST += ledgerVoucher.lastAmountMST();
                }
                else
                {
                    if (ledgerVoucher && ledgerVoucher.lastVoucher())
                    {
                        voucher     = ledgerVoucher.lastVoucher();
                    }
                    else
                    {
                        voucher     = '';
                    }

                    if (this.parmAdjustment() && this.parmAdjustmentDate())
                    {
                        AmountMST costAmountMSTLoc = CurrencyExchangeHelper::mstAmount(fundingAllocationEnumerator.currentValue(), this.currencyIdCost(), projTrans.transDate());                        

                        ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                                this.postingType(),
                                                projTrans.defaultDimension(),
                                                voucher,
                                                this.parmAdjustmentDate(),
                                                costAmountMSTLoc,
                                                mergedLedgerDimension).insert();

                        locLedgerCostAmountMST += costAmountMSTLoc;
                    }
                    else
                    {
                        ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                                this.postingType(),
                                                projTrans.defaultDimension(),
                                                voucher,
                                                projTrans.transDate(),
                                                fundingAllocationEnumerator.currentValue(),
                                                mergedLedgerDimension).insert();

                        locLedgerCostAmountMST += CurrencyExchangeHelper::mstAmount(fundingAllocationEnumerator.currentValue(), this.currencyIdCost(), projTrans.transDate());
                    }
                }
            }
        }

        if (this.costEnterCredit())
        {
            locLedgerCostAmountMST = 0;
            this.postingType(this.postingTypeOffsetCost());

            amountCur = - this.costValueCUR() - this.parmTaxAmountCur();

            if (!fundingSourceList)
            {
                throw error(strFmt("@SYS22828", funcName()));
            }
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, this.currencyIdCost()).getEnumerator();
            if (splitTransQtyCon)
            {
                splitTransQty = Map::create(splitTransQtyCon);
            }
            else
            {
                splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
            }
            while ( fundingAllocationEnumerator.moveNext() )
            {
                var currentFundingAllocation = fundingAllocationEnumerator.currentKey();
                tmpProjLedger = ProjLedger::newProjectCost(projTrans, this.parmTransIdCost(),
                        this.parmTransactionOrigin(),
                        this.parmLedgerOrigin(),
                        this.investmentElimination() ? false : this.parmElimination(),
                        currentFundingAllocation,
                        splitTransQty.exists(currentFundingAllocation) ? splitTransQty.lookup(currentFundingAllocation) * 1 : projTrans.qty());

                defaultLedgerDimension = this.parmLedgerDimension(this.creditAccountCostValueLedgerDimension(currentFundingAllocation));
                // need to merge the default account with the default dimensions
                if (this.mustMergeProjPayrollDimensions())
                {
                    this.parmProjFundingSource(fundingAllocationEnumerator.currentKey());
                    mergedLedgerDimension = this.mergeLedgerDimension(defaultLedgerDimension, this.getFinancialDimensionsForProjPayrollAllocationType(tmpProjLedger));
                    boolean ok = ProjPost::validateDimension(mergedLedgerDimension);

                    mergedLedgerDimension = ok ? mergedLedgerDimension : this.mergeLedgerDimension(mergedLedgerDimension, ProjTable::find(projTrans.projId()).DefaultDimension, ProjFundingSource::find(projFundingSourceRefId).DefaultDimension);
                }
                else
                {
                    projFundingSource = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                    mergedLedgerDimension = this.mergeLedgerDimension(defaultLedgerDimension, this.defaultDimension(), projFundingSource.DefaultDimension);
                }

                if (postToGeneralLedger)
                {
                    ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostCostCredit(
                        ledgerVoucherObject,
                        mergedLedgerDimension,
                        this.currencyIdCost(),
                        fundingAllocationEnumerator,
                        exchangeRateHelper,
                        splitTransQty,
                        tmpProjLedger);

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    locLedgerCostAmountMST+=ledgerVoucher.lastAmountMST();
                }
                else
                {
                    if (ledgerVoucher && ledgerVoucher.lastVoucher())
                    {
                         voucher     = ledgerVoucher.lastVoucher();
                    }
                    else
                    {
                        voucher     = '';
                    }

                    if (this.parmAdjustment() && this.parmAdjustmentDate())
                    {
                        AmountMST costAmountMSTLoc = CurrencyExchangeHelper::mstAmount(fundingAllocationEnumerator.currentValue(), this.currencyIdCost(), projTrans.transDate());

                        ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                                this.postingType(),
                                                projTrans.defaultDimension(),
                                                voucher,
                                                this.parmAdjustmentDate(),
                                                costAmountMSTLoc,
                                                mergedLedgerDimension).insert();

                        locLedgerCostAmountMST += costAmountMSTLoc;
                    }
                    else
                    {
                        ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                                this.postingType(),
                                                projTrans.defaultDimension(),
                                                voucher,
                                                projTrans.transDate(),
                                                fundingAllocationEnumerator.currentValue(),
                                                mergedLedgerDimension).insert();

                        locLedgerCostAmountMST += CurrencyExchangeHelper::mstAmount(fundingAllocationEnumerator.currentValue(), this.currencyIdCost(), projTrans.transDate());
                    }
                }
            }
        }

        // <GEERU>
        if (countryRegion_RU
            && this.costEnterDebit()
            && this.costEnterCredit()
            && postToGeneralLedger)
        {
            ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();
            if (ledgerBondClient)
            {
                ledgerBondClient.bondLog2Log(ledgerVoucherObject.parmAccountingDate(),
                    ledgerBondClient.getDebitLog(),
                    ledgerBondClient.getCreditLog(),
                    [fieldNum(TmpLedgerBondLogTable_RU, BondId)]);
            }
        }
        // </GEERU>

        this.ledgerCostAmountMST(locLedgerCostAmountMST);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustMergeProjPayrollDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the financial dimensions for project payroll must be merged.
    /// </summary>
    /// <returns>
    /// true if it must be merged; otherwise, false.
    /// </returns>
    protected boolean mustMergeProjPayrollDimensions()
    {
        return this.postingType() == LedgerPostingType::ProjPayrollAllocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger dimension for the specified combination.
    /// </summary>
    /// <param name = "_ledgerDimensionId">
    /// The ID of the first <c>DimensionAttributeValueCombination</c> record that specifies the initial dimension
    /// values.
	/// </param>
    /// <param name = "_dimensionDefault1">
    /// The ID of the secound <c>DimensionAttributeValueSet</c> record that provides the default values for
    /// the ledger dimension.
	/// </param>
    /// <param name = "_dimensionDefault2">
    /// The ID of the third <c>DimensionAttributeValueSet</c> record that provides the default values for
    /// the ledger dimension; optional.
	/// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueCombination</c> record.
	/// </returns>
    protected LedgerDimensionAccount mergeLedgerDimension(RecId _ledgerDimensionId, DimensionDefault _dimensionDefault1, DimensionDefault _dimensionDefault2 = 0)
    {
        return LedgerDimensionFacade::serviceCreateLedgerDimension(_ledgerDimensionId, _dimensionDefault1, _dimensionDefault2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mergeLedgerDimensionDebit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a ledger dimension for the specified combination in case of debit amount.
    /// </summary>
    /// <param name = "_ledgerDimensionId">
    /// The ID of the first <c>DimensionAttributeValueCombination</c> record that specifies the initial dimension
    /// values.
    /// </param>
    /// <param name = "_dimensionDefault1">
    /// The ID of the secound <c>DimensionAttributeValueSet</c> record that provides the default values for
    /// the ledger dimension.
    /// </param>
    /// <param name = "_dimensionDefault2">
    /// The ID of the third <c>DimensionAttributeValueSet</c> record that provides the default values for
    /// the ledger dimension.
    /// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueCombination</c> record.
    /// </returns>
    protected LedgerDimensionAccount mergeLedgerDimensionDebit(RecId _ledgerDimensionId, DimensionDefault _dimensionDefault1, DimensionDefault _dimensionDefault2)
    {
        return this.mergeLedgerDimension(_ledgerDimensionId, _dimensionDefault1, _dimensionDefault2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherTransObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>LedgerVoucherTransObject</c> given as first parameter based on the additional parameters.
    /// </summary>
    /// <param name = "_ledgerVoucherTransObject">
    /// The <c>LedgerVoucherTransObject</c> to be initialized.
    /// </param>
    /// <param name = "_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> on which the transaction object is based on.
    /// </param>
    /// <param name = "_fundingAllocation">
    /// The record identifier of the funding allocation record.
    /// </param>
    /// <param name = "_splitTransQty">
    /// The quantity distribution map.
    /// </param>
    /// <param name = "_tmpProjLedger">
    /// The related project ledger instance.
    /// </param>
    protected void initializeLedgerVoucherTransObject(
        LedgerVoucherTransObject    _ledgerVoucherTransObject,
        LedgerVoucherObject         _ledgerVoucherObject,
        RecId                       _fundingAllocation,
        Map                         _splitTransQty,
        ProjLedger                  _tmpProjLedger
        )
    {
        _ledgerVoucherTransObject.parmTaxParentReferenceTableId(this.parmTaxParentReferenceTableId());
        _ledgerVoucherTransObject.parmTaxParentReferenceRecId(this.parmTaxParentReferenceRecId());
        _ledgerVoucherTransObject.parmQuantity((_splitTransQty.exists(_fundingAllocation) ? _splitTransQty.lookup(_fundingAllocation) * 1 : projTrans.qty()));
        _ledgerVoucherTransObject.parmProjLedger(_tmpProjLedger);
        _ledgerVoucherTransObject.parmText(projTrans.txt());
        _ledgerVoucherTransObject.parmFinTag(projTrans.finTag());

        if (projTrans.txt() == '' && !_ledgerVoucherObject.parmHasDefaultDescription())
        {
            _ledgerVoucherTransObject.parmDiscardLastTransTxt(true);
        }

        // <GEEU>
        if (LedgerParameters::isStornoEnabledEE() || LedgerParameters::find().TransactionReversalCorrection)
        {
            _ledgerVoucherTransObject.parmIsCorrection(this.isTransCorrection());
        }
        // </GEEU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the dimension against the account structure.
    /// </summary>
    /// <param name="_ledgerDimensionId">
    /// The <c>_ledgerDimensionId</c> holds merger dimension.
    /// </param>
    /// <returns>
    /// true if the dimension is validated; otherwise, false.
    /// </returns>
    public static boolean validateDimension(LedgerDimensionBase _ledgerDimensionId)
    {
        boolean valid = true;

        DimensionValidationRequest dimensionValidationRequest = DimensionValidationRequest::newForLedgerDimension(_ledgerDimensionId);

        DimensionValidationStatusContract dimensionValidationStatusContract = DimensionValidation::getStatus(dimensionValidationRequest);

        if (!dimensionValidationStatusContract.isValid())
        {
            valid = false;
        }
        return valid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinancialDimensionsForProjPayrollAllocationType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the financial dimensions for the <c>ProjPayrollAllocation</c> ledger posting type.
    /// </summary>
    /// <param name = "_projLedger">
    ///    An instance of the <c>ProjLedger</c> class.
    /// </param>
    /// <returns>
    ///    The Id of a <c>DimensionAttributeValueSet</c> record.
    /// </returns>
    protected DimensionDefault getFinancialDimensionsForProjPayrollAllocationType(ProjLedger _projLedger)
    {
        return this.defaultDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the value of <c>PostingType</c>.
    /// </summary>
    /// <param name="_postingType">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of <c>PostingType</c>.
    /// </returns>
    protected LedgerPostingType postingType(LedgerPostingType _postingType = postingType)
    {
        postingType   = _postingType;

        return postingType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger posting type that is associated with posting project costs based on the current project ledger status.
    /// </summary>
    /// <returns>
    ///    The ledger posting type for project costs.
    /// </returns>
    /// <remarks>
    ///    This method must be implemented in the class that extends from it.
    /// </remarks>
    public LedgerPostingType postingTypeCost()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetCost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ledger posting type for project offset cost posting based on the current ledger status of the project.
    /// </summary>
    /// <returns>
    ///    The ledger posting type for project offset costs.
    /// </returns>
    /// <remarks>
    ///    This method must be implemented in the class that extends from it.
    /// </remarks>
    public LedgerPostingType postingTypeOffsetCost()
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>LedgerPostingType::ProjWIPInvoicedOnAccount</c>.
    /// </summary>
    /// <returns>
    ///    The enumeration value <c>LedgerPostingType::ProjWIPInvoicedOnAccount</c>.
    /// </returns>
    public LedgerPostingType postingTypeOffsetOnAcc()
    {
        return LedgerPostingType::ProjWIPInvoicedOnAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOffsetTurnoverAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>LedgerPostingType::ProjSalesvalueOffset</c>.
    /// </summary>
    /// <returns>
    ///    The enumeration value <c>LedgerPostingType::ProjSalesvalueOffset</c>.
    /// </returns>
    public LedgerPostingType postingTypeOffsetTurnoverAccrued()
    {
        return LedgerPostingType::ProjSalesvalueOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>LedgerPostingType::ProjAccruedRevenueOnAccount</c>.
    /// </summary>
    /// <returns>
    ///    <c>LedgerPostingType::ProjAccruedRevenueOnAccount</c>.
    /// </returns>
    public LedgerPostingType postingTypeOnAcc()
    {
        return LedgerPostingType::ProjAccruedRevenueOnAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeRetainage</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>LedgerPostingType::PSAProjRetain</c>.
    /// </summary>
    /// <returns>
    ///    <c>LedgerPostingType::PSAProjRetain</c>.
    /// </returns>
    protected LedgerPostingType postingTypeRetainage()
    {
        return LedgerPostingType::PSAProjRetain;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>LedgerPostingType::ProjTurnover</c>.
    /// </summary>
    /// <returns>
    ///    <c>LedgerPostingType::ProjTurnover</c>.
    /// </returns>
    protected LedgerPostingType postingTypeTurnover()
    {
        return LedgerPostingType::ProjTurnover;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingTypeTurnoverAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the enumeration value <c>LedgerPostingType::ProjSalesValue</c>.
    /// </summary>
    /// <returns>
    ///    <c>LedgerPostingType::ProjSalesValue</c>.
    /// </returns>
    public LedgerPostingType postingTypeTurnoverAccrued()
    {
        return LedgerPostingType::ProjSalesvalue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNeverLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the posting of ledger journal entries when the ledger posting type is equal to the enumeration value <c>LedgerPostingType::ProjNeverLedger</c>.
    /// </summary>
    /// <remarks>
    ///    This routine is called by the method <c>ledgerTransActionsCreate()</c>.
    /// </remarks>
    public void postNeverLedger()
    {
        ProjLedger          projLedger;
        Voucher             voucher;
        Map                 splitTransQty;
        MapEnumerator       fundingAllocationEnumerator;
        TransDate           transDate;

        if (ledgerVoucher && ledgerVoucher.lastVoucher())
        {
            voucher     = ledgerVoucher.lastVoucher();
            transDate   = ledgerVoucher.findLedgerVoucherObject().parmAccountingDate();

            if (!transDate)
            {
                transDate   = projTrans.transDate();
            }
        }
        else
        {
            voucher     = '';
            transDate   = projTrans.transDate();
        }

        if (!fundingSourceList)
        {
            throw error(strFmt("@SYS22828", funcName()));
        }        
        fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,projTrans.transCostMST(),this.currencyIdCost()).getEnumerator();
        if (splitTransQtyCon)
        {
            splitTransQty = Map::create(splitTransQtyCon);
        }
        else
        {
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
        }
        while ( fundingAllocationEnumerator.moveNext() )
        {
            projLedger  = ProjLedger::newProjectCost(projTrans,this.parmTransIdCost(),
                                    this.parmTransactionOrigin(),
                                    this.parmLedgerOrigin(),
                                    NoYes::No,
                                    fundingAllocationEnumerator.currentKey(),
                                    splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : projTrans.qty());

            if (projLedger)
            {
                this.initNewNeverLedger(
                    projLedger,                    
                    projTrans.defaultDimension(),
                    voucher,
                    transDate,
                    fundingAllocationEnumerator).insert();                                
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initNewNeverLedger</Name>
				<Source><![CDATA[
    protected ProjLedgerUpdate initNewNeverLedger(
        Object              _projLedger,        
        DimensionDefault    _dimension,
        Voucher             _voucher,
        TransDate           _transDate,
        MapEnumerator       _fundingAllocationEnumerator)
    {
        return ProjLedgerUpdate::newNeverLedger(_projLedger,
            LedgerPostingType::ProjNeverLedger,                                                                           
            _dimension,
            _voucher,
            _transDate,
            _fundingAllocationEnumerator.currentValue());
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNoneLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the posting of ledger journal entries when the ledger posting type is equal to the enumeration value <c>LedgerPostingType::ProjNoneLedger</c>.
    /// </summary>
    /// <remarks>
    ///    This routine is called by the method <c>ledgerTransActionsCreate()</c>.
    /// </remarks>
    public void postNoneLedger()
    {
        ProjLedger          projLedger;
        AmountMST           costAmountMST;
        TransDate           transDate;
        Voucher             voucher;
        MapEnumerator       fundingAllocationEnumerator;
        Map                 splitTransQty;

        if (ledgerVoucher && ledgerVoucher.findLedgerVoucherObject())
        {
            transDate   = ledgerVoucher.findLedgerVoucherObject().parmAccountingDate();

            if (!transDate)
            {
                transDate   = projTrans.transDate();
            }
        }
        else
        {
            transDate   = projTrans.transDate();
        }

        if (ledgerVoucher && ledgerVoucher.lastVoucher())
        {
            voucher     = ledgerVoucher.lastVoucher();
        }
        else
        {
            voucher     = '';
        }

        if (this.checkQtyNegative() && (projTrans.ledgerStatusCost() == ProjLedgerStatus::None)) // allready posted in No ledger
        {
            costAmountMST  = -projTrans.transCostMST();
        }
        else
        {
            costAmountMST   = projTrans.transCostMST();
        }

        if (!fundingSourceList)
        {
            throw error(strFmt("@SYS22828", funcName()));
        }
        fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, costAmountMST, this.currencyIdCost()).getEnumerator();
        if (splitTransQtyCon)
        {
            splitTransQty = Map::create(splitTransQtyCon);
        }
        else
        {
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
        }
        while ( fundingAllocationEnumerator.moveNext() )
        {
            projLedger  = ProjLedger::newProjectCost(projTrans,this.parmTransIdCost(),
                                this.parmTransactionOrigin(),
                                this.parmLedgerOrigin(),
                                NoYes::No,
                                fundingAllocationEnumerator.currentKey(),
                                splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : projTrans.qty());

            if (this.checkQtyNegative() && (projTrans.ledgerStatusCost() == ProjLedgerStatus::None))
            {
                projLedger.parmProjQty(splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * -1);
            }

            if (projLedger)
            {
                ProjLedgerUpdate::newNoneLedger(projLedger,
                                            LedgerPostingType::ProjNoLedger,
                                            projTrans.defaultDimension(),
                                            voucher,
                                            transDate,
                                            fundingAllocationEnumerator.currentValue()).insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOnAccAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the ledger journal entries for posting to on-account accrued revenue accounts.
    /// </summary>
    /// <remarks>
    ///    This routine is called by the method <c>ledgerTransActionsCreate()</c>.
    /// </remarks>
    protected void postOnAccAccrued()
    {
        ProjLedger                      tmpProjLedger;
        Voucher                         voucher;
        AmountCur                       amountCur;
        MapEnumerator                   fundingAllocationEnumerator;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        LedgerDimensionAccount          mergedLedgerDimension;
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        ProjFundingSource               projFundingSource;
        // <GEERU>
        LedgerBondClient_RU             ledgerBondClient;
        // </GEERU>

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(this.exchRateSales());
        exchangeRateHelper.parmExchangeRate2(this.exchRateSecondarySales());

        if (this.checkEnterOnAccDebit())
        {
            this.postingType(this.postingTypeOnAcc());

            amountCur = this.ledgerSalesAmount();
            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, this.currencyIdSales()).getEnumerator();

            while ( fundingAllocationEnumerator.moveNext() )
            {
                // Create the proj ledger object
                projFundingSource = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                tmpProjLedger = ProjLedger::newProjectSales(projTrans,
                                                        this.parmTransIdSales(),
                                                        this.parmTransactionOrigin(),
                                                        this.parmLedgerOrigin(),
                                                        this.parmElimination(),
                                                        fundingAllocationEnumerator.currentKey());

                defaultLedgerDimension = this.parmLedgerDimension(this.debitAccountOnAccLedgerDimension(fundingAllocationEnumerator.currentKey()));

                // need to merge the default account with the default dimensions
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), projFundingSource.DefaultDimension);

                if (postToGeneralLedger)
                {
                    ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostOnAccAccrued(
                        ledgerVoucherObject,
                        mergedLedgerDimension,
                        this.currencyIdSales(),
                        fundingAllocationEnumerator,
                        exchangeRateHelper,
                        tmpProjLedger);

                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }
                else
                {
                    if (ledgerVoucher && ledgerVoucher.lastVoucher())
                    {
                        voucher = ledgerVoucher.lastVoucher();
                    }
                    else
                    {
                        voucher = '';
                    }

                    ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                            this.postingType(),
                                            projTrans.defaultDimension(),
                                            voucher,
                                            projTrans.transDate(),
                                            fundingAllocationEnumerator.currentValue(),
                                            mergedLedgerDimension).insert();
                }
            }
        }

        if (this.checkEnterOnAccCredit())
        {
            this.postingType(this.postingTypeOffsetOnAcc());

            // Create the proj ledger object
            amountCur = -this.ledgerSalesAmount();

            if (!fundingSourceList)
            {
                throw error(strFmt("@SYS22828", funcName()));
            }

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, this.currencyIdSales()).getEnumerator();

            while ( fundingAllocationEnumerator.moveNext() )
            {
                tmpProjLedger = ProjLedger::newProjectSales(projTrans,
                                                        this.parmTransIdSales(),
                                                        this.parmTransactionOrigin(),
                                                        this.parmLedgerOrigin(),
                                                        this.parmElimination());

                defaultLedgerDimension = this.parmLedgerDimension(this.creditAccountOnAccLedgerDimension(fundingAllocationEnumerator.currentKey()));

                // need to merge the default account with the default dimensions
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension());

                if (postToGeneralLedger)
                {
                    ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostOnAccAccrued(
                        ledgerVoucherObject,
                        mergedLedgerDimension,
                        this.currencyIdSales(),
                        fundingAllocationEnumerator,
                        exchangeRateHelper,
                        tmpProjLedger);
                    
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);
                }
                else
                {
                    if (ledgerVoucher && ledgerVoucher.lastVoucher())
                    {
                        voucher = ledgerVoucher.lastVoucher();
                    }
                    else
                    {
                        voucher = '';
                    }

                    ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                            this.postingType(),
                                            projTrans.defaultDimension(),
                                            voucher,
                                            projTrans.transDate(),
                                            fundingAllocationEnumerator.currentValue(),
                                            mergedLedgerDimension).insert();
                }
            }
        }

        // <GEERU>
        if (countryRegion_RU
        && this.checkEnterOnAccDebit()
        && this.checkEnterOnAccCredit())
        {
            ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLog2Log(ledgerVoucherObject.parmAccountingDate(),
                ledgerBondClient.getDebitLog(),
                ledgerBondClient.getCreditLog(),
                [fieldNum(TmpLedgerBondLogTable_RU, BondId)]);
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the creating and posting of ledger journal entries for the transaction.
    /// </summary>
    /// <remarks>
    ///    This routine calls the methods <c>projTransCreate()</c>, <c>ledgerTransActionsCreate()</c>, and <c>projTransUpdate()</c>.
    /// </remarks>
    public void postTrans()
    {
        ProjOpsFinancialsInstrumentationActivites activities = ProjOpsFinancialsLogger::createLogger(classStr(ProjPost)).projOpsFinActivity();

        using (var activityContext = activities.postTransContext(this.parmCreateTrans(), this.parmUpdateTrans()))
        {
            LedgerVoucherObject ledgerVoucherObject;
            TransDate           transDate;

            if (this.oneVoucher())
            {
                if (ledgerVoucher && ledgerVoucher.findLedgerVoucherObject())
                {
                    ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

                    if (projTrans)
                    {
                        transDate = ledgerVoucherObject.parmTransDate();
                        ledgerVoucherObject.parmTransDate(projTrans.transDate());
                    }
                }
            }

            if (this.checkLedger()&& !this.checkLedgerTransDate())
            {
                throw Exception::Error;
            }

            if (this.parmCreateTrans())
            {
                using (var activityContextCreate = activities.createTransContext())
                {
                    this.projTransCreate();
                }

                if (allocationError == true)
                {
                    throw Global::error("@SYS136009");
                }

                if (this.checkReverseCommittedCost())
                {
                    this.committedCostReverse();
                }
                else
                {
                    if (this.checkUpdateBudget())
                    {
                        this.budgetUpdate();
                    }
                    else if (this.checkUpdateForecast())
                    {
                        this.forecastUpdate();
                    }
                }
            }
            this.ledgerTransActionsCreate();

            //update the old transactions
            if (this.parmUpdateTrans())
            {
                using (var activityContextUpdate = activities.updateTransContext())
                {
                    this.projTransUpdate();
                }
            }

            if (transDate)
            {
                ledgerVoucherObject.parmTransDate(transDate);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    /// Handles the ledger journal entries for posting to sales accounts.
    /// </summary>
    /// <remarks>
    /// This routine is called by the <c>ledgerTransActionsCreate</c> method.
    /// </remarks>
    protected void postTurnover()
    {
        ProjProposalRevenue projProposalRevenue = ProjProposalRevenue::find(projTrans.transId(), projTrans.proposalId());
        this.initIsContractLineUsed(projTrans);

        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();
        invoiceLedgerList = new List(Types::Class);

        CurrencyExchangeHelper exchangeRateHelper;
        ProjOnAccTransSale projOnAccTransDeduct;

        select firstonly RecId, LedgerTransdate, TransId from projOnAccTransDeduct
            where projOnAccTransDeduct.TransId == projTrans.transId();

        boolean isTransTypeOnAccDeduction = false;
        boolean enableCreditNoteUseOrigInvoiceDateForExchRateFlight = FeatureStateProvider::isFeatureEnabled(ProjCreditNoteUseOrigInvoiceDateForExchRateFlight::instance());
        boolean setReportingExchangeRate = (ProjProjectOperationsIntegrationFeatureHelper::isFeatureEnabled() && ProjReportingCurrencyExchRateFlight::instance().isEnabled());

        if (projTrans.transType() == ProjTransType::OnAccount
            && projTrans.psaIsOnAccount() == NoYes::Yes
            && projOnAccTransDeduct.projOnAccTrans().TransactionOrigin == ProjOrigin::Deduction)
        {
            isTransTypeOnAccDeduction = true;
            exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), projOnAccTransDeduct.LedgerTransdate);

            if (setReportingExchangeRate)
            {
                exchangeRateHelper.parmReportingExchangeRate1(this.exchRateReportingCurrency(true));
            }
        }
        else
        {            
            // For project invoice proposal posting, system considers fixed exchange rate defined under project contract if exists.
            ProjInvoiceCurrency projInvoiceCurrencyLoc;
            ProjInvoiceProjId projInvoiceProjId;

            if (contractLineBasedRevRecFeature && isContractLineUsed)
            {
                projInvoiceProjId = PSAContractLineItems::find(projTrans.psaContractLineNum()).ProjInvoiceProjId;
            }
            else
            {
                projInvoiceProjId = ProjTable::find(projTrans.projId()).ProjInvoiceProjId;
            }

            projInvoiceCurrencyLoc = ProjInvoiceCurrency::find(projInvoiceProjId, projTrans.currencyIdSales());

            if (projInvoiceCurrencyLoc.ExchRate)
            {
                exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                exchangeRateHelper.parmExchangeRate1(projInvoiceCurrencyLoc.ExchRate);
            }                                
            
            if (!projInvoiceCurrencyLoc.ExchRate)
            {
                InvoiceDate invoiceDate;

                if (enableCreditNoteUseOrigInvoiceDateForExchRateFlight && projTrans.transStatus() == ProjTransStatus::CreditnoteProposal)
                {
                    // Considers original transaction invoice date to pick exchange rate for project credit note invoice posting as well.
                    invoiceDate = this.getCreditNoteOrigTransInvoiceDate(ledgerVoucherObject);
                }
                
                if (invoiceDate)
                {
                    exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), invoiceDate);
                }
                else
                {
                    exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());
                    exchangeRateHelper.parmExchangeRate1(this.exchRateTurnover());
                    exchangeRateHelper.parmExchangeRate2(this.exchRateSecondaryTurnover());

                    if (setReportingExchangeRate)
                    {
                        ProjOnAccTrans projOnAccTrans;
                        ProjProposalOnAcc projProposalOnAcc;

                        select count(RecId) from projOnAccTrans
                        exists join projProposalOnAcc
                            where projProposalOnAcc.ProposalId == projTrans.proposalId()
                                && projProposalOnAcc.TransId == projOnAccTrans.TransId
                                && projOnAccTrans.PSAIsOnAccount == NoYes::Yes
                                && projOnAccTrans.TransactionOrigin == ProjOrigin::Deduction;

                        // Set reporting currency exchange rate if retainer exists.
                        if (projOnAccTrans.RecId > 0)
                        {
                            ExchRate reportingExchRate = this.exchRateReportingCurrency();

                            if (reportingExchRate)
                            {
                                exchangeRateHelper.parmReportingExchangeRate1(reportingExchRate);
                            }
                        }
                    }
                }
            }

            if (projInvoiceProjId != '')
            {
                ProjInvoiceCurrency projInvoiceCurrency = ProjInvoiceCurrency::getFixedRateAgreementForReportingCurrency(projInvoiceProjId);

                if (projInvoiceCurrency)
                {
                    // Setting the reporting exchange rate from fixed exchange rate defined in contract.
                    exchangeRateHelper.parmReportingExchangeRate1(
                        ProjInvoiceCurrency::applyReciprocalForFixedExchangeRate(
                            Ledger::defaultExchangeRateType(),
                            projTrans.currencyIdSales(),
                            projInvoiceCurrency.CurrencyId,
                            projTrans.transDate(),
                            projInvoiceCurrency));

                }
            }
        }

        boolean isRetained = ((ProjCategory::find(projTrans.categoryId()).psaCustPaymentRetention && projProposalRevenue.IsRetained)
                                || projProposalRevenue.IsReleased);

        if (isRetained)
        {
            this.postingType(this.postingTypeRetainage());
        }
        else
        {
            this.postingType(this.postingTypeTurnover());
        }

        AmountCur amountCur;
        // <GEERU>
        if (countryRegion_RU)
        {
            amountCur = -projTrans.transTurnover() + (tax && TaxParameters::find().TaxSpecPosting_RU ?
                                                  tax.taxPrLine(projTrans.tableId(), projTrans.recId()) :
                                                  0);
        }
        else
        {
            // </GEERU>
            // <GTE>
            if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
            {
                amountCur = -ProjTrans.transTurnoverGTE();
            }
            else
            {
                // </GTE>
                amountCur = -projTrans.transTurnover();
                // <GTE>
            }
            // </GTE>
            // <GEERU>

            if (!isTransTypeOnAccDeduction && !ledgerVoucher.parmIsAdvanceDeducted())
            {
                // Checks and posts negative entry for customer advance based on IsPreBill condition
                PSAProjProposalProj psaProjProposalProj;

                if(contractLineBasedRevRecFeature && isContractLineUsed)
                {
                    select firstonly ProjProposalId, InvoicedNow from psaProjProposalProj
                        where psaProjProposalProj.ProjProposalId == projTrans.proposalId()
                            && psaProjProposalProj.ContractLineNum == projTrans.psaContractLineNum()
                            && psaProjProposalProj.IsPreBill == NoYes::Yes;
                }
                else
                {
                    select firstonly ProjProposalId, InvoicedNow from psaProjProposalProj
                        where psaProjProposalProj.ProjProposalId == projTrans.proposalId()
                            && psaProjProposalProj.ProjId == projTrans.projId()
                            && psaProjProposalProj.IsPreBill == NoYes::Yes;
                }

                if (psaProjProposalProj.InvoicedNow)
                {
                    ProjProposalOnAcc projProposalOnAccBill;
                    ProjOnAccTransSale projOnAccTransSale;
                    ProjOnAccTrans projOnAccTrans;

                    // Executes for each deduction record.
                    while select LedgerTransdate, Amount, TransStatus from projOnAccTransSale
                        exists join projOnAccTrans
                            where projOnAccTrans.TransId == projOnAccTransSale.TransId
                                && projOnAccTrans.PSAIsOnAccount == NoYes::Yes
                        exists join projProposalOnAccBill
                            where projProposalOnAccBill.TransId == projOnAccTransSale.TransId
                                && projProposalOnAccBill.ProposalId == psaProjProposalProj.ProjProposalId
                    {
                        // Considers original transaction invoice date to pick exchange rate for project credit note invoice posting as well.
                        // If transaction status is credit note proposal and customer advance is present then post positive entry.
                        if (projOnAccTransSale.TransStatus == ProjTransStatus::CreditnoteProposal)
                        {
                            amountCur += projOnAccTransSale.Amount;

                            CurrencyExchangeHelper exchangeRateHelperPreBill = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), projOnAccTransSale.LedgerTransdate);
                            this.turnoverLedgerPosting(-projOnAccTransSale.Amount, exchangeRateHelperPreBill, isRetained, ledgerVoucherObject);
                        }
                        else
                        {
                            amountCur -= projOnAccTransSale.Amount;

                            CurrencyExchangeHelper exchangeRateHelperPreBill = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), projOnAccTransSale.LedgerTransdate);
                            this.turnoverLedgerPosting(projOnAccTransSale.Amount, exchangeRateHelperPreBill, isRetained, ledgerVoucherObject);
                        }

                        ledgerVoucher.parmIsAdvanceDeducted(true);
                    }
                }
            }
        }
        // </GEERU>
        this.turnoverLedgerPosting(amountCur, exchangeRateHelper, isRetained, ledgerVoucherObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>turnoverLedgerPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts project ledger transactions.
    /// </summary>
    /// <param name="_amountCur">
    ///    The transaction currency amount to be posted.
    /// </param>
    /// <param name="_exchangeRateHelper">
    ///    The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name="_isRetained">
    ///    Indicates whether this is an customer payment retention.
    /// </param>
    /// <param name="_ledgerVoucherObject">
    ///    The ledger posting reference that is used.
    /// </param>
    /// <remarks>
    ///    This routine is called by the method <c>postTurnover()</c> for posting ledger transactions.
    /// </remarks>
    private void turnoverLedgerPosting(AmountCur _amountCur, CurrencyExchangeHelper _exchangeRateHelper, boolean _isRetained, LedgerVoucherObject _ledgerVoucherObject)
    {
        if (!fundingSourceList)
        {
            throw error(strFmt("@SYS22828", funcName()));
        }

        MapEnumerator fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, _amountCur, projTrans.currencyIdSales()).getEnumerator();

        Map splitTransQty;
        if (splitTransQtyCon)
        {
            splitTransQty = Map::create(splitTransQtyCon);
        }
        else
        {
            splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
        }

        ProjLedger tmpProjLedger;
        LedgerDimensionDefaultAccount defaultLedgerDimension;
        ProjFundingSource projFundingSource;
        LedgerDimensionAccount mergedLedgerDimension;
        LedgerVoucherTransObject ledgerVoucherTransObject;
        Voucher voucher;

        while ( fundingAllocationEnumerator.moveNext() )
        {
            if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
            {
                // Create the proj ledger object
                tmpProjLedger = ProjLedger::newProjectSales(projTrans,
                                            this.parmTransIdSales(),
                                            this.parmTransactionOrigin(),
                                            this.parmLedgerOrigin(),
                                            this.parmElimination(),
                                            fundingAllocationEnumerator.currentKey(),
                                            splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
                                
                if (_isRetained)
                {
                    defaultLedgerDimension = this.parmLedgerDimension(LedgerSystemAccounts::getDefaultAccount(this.postingType()));
                }
                else
                {
                    defaultLedgerDimension = this.parmLedgerDimension(this.creditAccountTurnoverLedgerDimension(fundingAllocationEnumerator.currentKey()));
                }

                // need to merge the default account with the default dimensions
                projFundingSource = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), projFundingSource.DefaultDimension);
                
                if (postToGeneralLedger)
                {
                    ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostTurnover(_ledgerVoucherObject, mergedLedgerDimension, fundingAllocationEnumerator, _exchangeRateHelper, splitTransQty, tmpProjLedger);
                    ledgerVoucher.addTrans(ledgerVoucherTransObject);

                    invoiceLedgerList.addEnd(ledgerVoucherTransObject);
                }
                else
                {
                    if (ledgerVoucher && ledgerVoucher.lastVoucher())
                    {
                        voucher = ledgerVoucher.lastVoucher();
                    }
                    else
                    {
                        voucher = '';
                    }

                    ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                            this.postingType(),
                                            projTrans.defaultDimension(),
                                            voucher,
                                            projTrans.transDate(),
                                            fundingAllocationEnumerator.currentValue(),
                                            mergedLedgerDimension).insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForPostCostDebit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucherTransObject</c> given as first parameter based on the additional parameters.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The ledger posting reference that is used.
    /// </param>
    /// <param name = "_mergedLedgerDimension">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name = "_fundingAllocationEnumerator">
    ///     The funding allocation map enumerator.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name = "_splitTransQty">
    ///     The quantity distribution map.
    /// </param>
    /// <param name = "_tmpProjLedger">
    ///     The related project ledger instance.
    /// </param>
    /// <returns>
    ///     The initialized object of <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject initLedgerVoucherTransObjectForPostCostDebit(
        LedgerVoucherObject         _ledgerVoucherObject,
        LedgerDimensionAccount      _mergedLedgerDimension,
        CurrencyCode                _currencyCode,
        MapEnumerator               _fundingAllocationEnumerator,
        CurrencyExchangeHelper      _exchangeRateHelper,
        Map                         _splitTransQty,
        ProjLedger                  _tmpProjLedger
        )
    {
        this.updateExchangeRateHelperWithRates(_exchangeRateHelper);

        ProjExchangeRateParameters insertParameters = ProjExchangeRateParameters::current();

        if (insertParameters)
        {
            _exchangeRateHelper.parmReportingExchangeRate1(insertParameters.getReportingExchRate());
        }

        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                             _ledgerVoucherObject,
                             this.postingType(),
                             _mergedLedgerDimension,
                             _currencyCode,
                             _fundingAllocationEnumerator.currentValue(),
                             _exchangeRateHelper);

        this.initializeLedgerVoucherTransObject(ledgerVoucherTransObject,
                        _ledgerVoucherObject,
                        _fundingAllocationEnumerator.currentValue(),
                        _splitTransQty,
                        _tmpProjLedger);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForPostCostCredit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucherTransObject</c> given as first parameter based on the additional parameters.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The ledger posting reference that is used.
    /// </param>
    /// <param name = "_mergedLedgerDimension">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name = "_fundingAllocationEnumerator">
    ///     The funding allocation map enumerator.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name = "_splitTransQty">
    ///     The quantity distribution map.
    /// </param>
    /// <param name = "_tmpProjLedger">
    ///     The related project ledger instance.
    /// </param>
    /// <returns>
    ///     The initialized object of <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject initLedgerVoucherTransObjectForPostCostCredit(
        LedgerVoucherObject         _ledgerVoucherObject,
        LedgerDimensionAccount      _mergedLedgerDimension,
        CurrencyCode                _currencyCode,
        MapEnumerator               _fundingAllocationEnumerator,
        CurrencyExchangeHelper      _exchangeRateHelper,
        Map                         _splitTransQty,
        ProjLedger                  _tmpProjLedger
        )
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                             _ledgerVoucherObject,
                             this.postingType(),
                             _mergedLedgerDimension,
                             _currencyCode,
                             _fundingAllocationEnumerator.currentValue(),
                             _exchangeRateHelper);

        this.initializeLedgerVoucherTransObject(ledgerVoucherTransObject,
                        _ledgerVoucherObject,
                        _fundingAllocationEnumerator.currentValue(),
                        _splitTransQty,
                        _tmpProjLedger);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForPostOnAccAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucherTransObject</c> given as first parameter based on the additional parameters.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The ledger posting reference that is used.
    /// </param>
    /// <param name = "_mergedLedgerDimension">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name = "_fundingAllocationEnumerator">
    ///     The funding allocation map enumerator.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name = "_tmpProjLedger">
    ///     The related project ledger instance.
    /// </param>
    /// <returns>
    ///     The initialized object of <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject initLedgerVoucherTransObjectForPostOnAccAccrued(
        LedgerVoucherObject         _ledgerVoucherObject,
        LedgerDimensionAccount      _mergedLedgerDimension,
        CurrencyCode                _currencyCode,
        MapEnumerator               _fundingAllocationEnumerator,
        CurrencyExchangeHelper      _exchangeRateHelper,
        ProjLedger                  _tmpProjLedger
        )
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                             _ledgerVoucherObject,
                             this.postingType(),
                             _mergedLedgerDimension,
                             _currencyCode,
                             _fundingAllocationEnumerator.currentValue(),
                             _exchangeRateHelper);

        ledgerVoucherTransObject.parmTaxParentReferenceTableId(this.parmTaxParentReferenceTableId());
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(this.parmTaxParentReferenceRecId());
        ledgerVoucherTransObject.parmQuantity(projTrans.qty());
        ledgerVoucherTransObject.parmProjLedger(_tmpProjLedger);

        // <GEEU>
        if (LedgerParameters::isStornoEnabledEE())
        {
            ledgerVoucherTransObject.parmIsCorrection(this.isTransCorrection(this.ledgerSalesAmount()));
        }
        // </GEEU>

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForPostTurnoverAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucherTransObject</c> given as first parameter based on the additional parameters.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The ledger posting reference that is used.
    /// </param>
    /// <param name = "_mergedLedgerDimension">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name="_currencyCode">
    ///    The currency code of the general journal entry.
    /// </param>
    /// <param name = "_fundingAllocationEnumerator">
    ///     The funding allocation map enumerator.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name = "_splitTransQty">
    ///     The quantity distribution map.
    /// </param>
    /// <param name = "_tmpProjLedger">
    ///     The related project ledger instance.
    /// </param>
    /// <returns>
    ///     The initialized object of <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    protected LedgerVoucherTransObject initLedgerVoucherTransObjectForPostTurnoverAccrued(
        LedgerVoucherObject         _ledgerVoucherObject,
        LedgerDimensionAccount      _mergedLedgerDimension,
        CurrencyCode                _currencyCode,
        MapEnumerator               _fundingAllocationEnumerator,
        CurrencyExchangeHelper      _exchangeRateHelper,
        Map                         _splitTransQty,
        ProjLedger                  _tmpProjLedger
        )
    {
        ProjExchangeRateParameters insertParameters = ProjExchangeRateParameters::current();

        if (insertParameters)
        {
            _exchangeRateHelper.parmReportingExchangeRate1(insertParameters.getReportingExchRate());
        }

        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                             _ledgerVoucherObject,
                             this.postingType(),
                             _mergedLedgerDimension,
                             _currencyCode,
                             _fundingAllocationEnumerator.currentValue(),
                             _exchangeRateHelper);

        // If this posting is a credit note, get the original posting amounts to reverse
        if (ProjCreditNoteVoucherAmountFixV2Flight::instance().isEnabled() && this.parmProjTrans().transStatus() == ProjTransStatus::CreditnoteProposal)
        {
            InvoiceDate invoiceDate = this.getCreditNoteOrigTransInvoiceDate(_ledgerVoucherObject);

            if (invoiceDate)
            {
                AmountCur invoiceLineAmount = this.getCreditNotePostingReverseLineAmountMST(ledgerVoucherTransObject, invoiceDate);

                if (invoiceLineAmount != 0.00)
                {
                    ledgerVoucherTransObject.parmAccountingCurrencyAmount(invoiceLineAmount);
                }
            }
        }

        ledgerVoucherTransObject.parmQuantity(_splitTransQty.exists(_fundingAllocationEnumerator.currentKey()) ? _splitTransQty.lookup(_fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
        ledgerVoucherTransObject.parmProjLedger(_tmpProjLedger);

        // <GEEU>
        if (LedgerParameters::isStornoEnabledEE())
        {
            ledgerVoucherTransObject.parmIsCorrection(this.isTransCorrection(this.ledgerSalesAmount()));
        }
        // </GEEU>

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCreditNotePostingReverseLineAmountMST</Name>
				<Source><![CDATA[
    private AmountMST getCreditNotePostingReverseLineAmountMST(LedgerVoucherTransObject _currentLedgerVoucherTransObject, InvoiceDate _originalTransInvoiceDate)
    {
        ProjTransPosting projTransPosting;

        if (ProjCreditNoteReversalAmountFundingSourceFlight::instance().isEnabled())
        {
            select firstonly AmountMst from projTransPosting
                order by projTransPosting.RecId desc
                where projTransPosting.TransId == this.parmProjTrans().transId()
                    && projTransPosting.LedgerTransDate == _originalTransInvoiceDate
                    && projTransPosting.PostingType == _currentLedgerVoucherTransObject.parmPostingType()
                    && projTransPosting.ProjFundingSource == projTrans.fundingSource()
                    && projTransPosting.LedgerOrigin == projOrigin::Invoice;
        }
        else
        {
            select firstonly AmountMst from projTransPosting
                order by projTransPosting.RecId desc
                where projTransPosting.TransId == this.parmProjTrans().transId()
                    && projTransPosting.LedgerTransDate == _originalTransInvoiceDate
                    && projTransPosting.PostingType == _currentLedgerVoucherTransObject.parmPostingType()
                    && projTransPosting.LedgerOrigin == projOrigin::Invoice;
        }

        return -projTransPosting.AmountMst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForPostTurnover</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes the <c>LedgerVoucherTransObject</c> based on the parameters.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">
    ///     The ledger posting reference that is used.
    /// </param>
    /// <param name = "_mergedLedgerDimension">
    ///     The dimension attribute value combination of the general journal entry.
    /// </param>
    /// <param name = "_fundingAllocationEnumerator">
    ///     An instance of <c>MapEnumerator</c>.
    /// </param>
    /// <param name = "_exchangeRateHelper">
    ///     The accounting currency amount and secondary currency amount exchange rates.
    /// </param>
    /// <param name = "_splitTransQty">
    ///     The quantity distribution map.
    /// </param>
    /// <param name = "_tmpProjLedger">
    ///     The related project ledger instance.
    /// </param>
    /// <returns>
    ///     The initializes object of <c>LedgerVoucherTransObject</c> class.
    /// </returns>
    [Wrappable(true)]
    final protected LedgerVoucherTransObject initLedgerVoucherTransObjectForPostTurnover(
        LedgerVoucherObject     _ledgerVoucherObject, 
        LedgerDimensionAccount  _mergedLedgerDimension, 
        MapEnumerator           _fundingAllocationEnumerator, 
        CurrencyExchangeHelper  _exchangeRateHelper, 
        Map                     _splitTransQty, 
        ProjLedger              _tmpProjLedger
        )
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
            _ledgerVoucherObject,
            this.turnoverLedgerPostingType(),
            _mergedLedgerDimension,
            projTrans.currencyIdSales(),
            _fundingAllocationEnumerator.currentValue(),
            _exchangeRateHelper);

        ledgerVoucherTransObject.parmTaxParentReferenceTableId(this.parmTaxParentReferenceTableId());
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(this.parmTaxParentReferenceRecId());
        ledgerVoucherTransObject.parmQuantity(_splitTransQty.exists(_fundingAllocationEnumerator.currentKey()) ? _splitTransQty.lookup(_fundingAllocationEnumerator.currentKey()) * 1 : 0.0);
        ledgerVoucherTransObject.parmProjLedger(_tmpProjLedger);
        ledgerVoucherTransObject.parmText(projTrans.txt());

        if (projTrans.txt() == '' && !_ledgerVoucherObject.parmHasDefaultDescription())
        {
            ledgerVoucherTransObject.parmDiscardLastTransTxt(true);
        }

        ledgerVoucherTransObject.parmIsCorrection(this.isTransCorrection(projTrans.transTurnover()));
        
        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateReportingCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the reporting currency exchange rate for proj ops wip accrued reversal posting.
    /// </summary>
    /// <param name="_psaOnAccTransDeduction">
    /// true if project transaction is associated to a <c>ProjOnAccTrans</c> record; otherwise, false.
    /// </param>
    /// <returns>
    /// The reporting currency exchange rate for proj ops wip accrued reversal posting.
    /// </returns>
    private ExchRate exchRateReportingCurrency(boolean _psaOnAccTransDeduction = false)
    {
        TransactionID projTransId = projTrans.transId();
        ExchRate reportingCurrencyExchRate;

        if (projTransId)
        {
            // Fetch trans id linked to ProjOnAccTrans deduction record.
            if (_psaOnAccTransDeduction)
            {
                ProjOnAccTrans projOnAccTransDeduction = ProjOnAccTrans::find(projTransId);

                if (projOnAccTransDeduction)
                {
                    ProjOnAccTrans projOnAccTrans;

                    select firstonly TransId from projOnAccTrans
                        where projOnAccTrans.RecId == projOnAccTransDeduction.PSARefRecId;

                    if (projOnAccTrans)
                    {
                        projTransId = projOnAccTrans.TransId;
                    }
                }
            }

            GeneralJournalAccountEntry generalJournalAccountEntry;
            GeneralJournalEntry generalJournalEntry;
            ProjTransPosting projTransPosting;

            select firstonly RecId from projTransPosting
                where projTransPosting.TransId == projTransId
                join RecId from generalJournalEntry
                    where generalJournalEntry.SubledgerVoucher == projTransPosting.Voucher
                        && generalJournalEntry.AccountingDate == projTransPosting.LedgerTransDate
                        && generalJournalEntry.SubLedgerVoucherDataAreaId == projTransPosting.DataAreaId
                        && generalJournalEntry.Ledger == Ledger::current()
                join TransactionCurrencyAmount, ReportingCurrencyAmount from generalJournalAccountEntry
                    where generalJournalAccountEntry.GeneralJournalEntry == generalJournalEntry.RecId
                        && generalJournalAccountEntry.TransactionCurrencyCode == this.currencyIdSales()
                        && generalJournalAccountEntry.ReportingCurrencyAmount != 0;

            if (generalJournalAccountEntry.RecId)
            {
                reportingCurrencyExchRate = generalJournalAccountEntry.getReportingExchangeRate();
            }
        }

        return reportingCurrencyExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTurnoverAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Handles the ledger journal entries for posting to accrued revenue accounts.
    /// </summary>
    /// <remarks>
    ///    This routine is called by the method <c>ledgerTransActionsCreate()</c>.
    /// </remarks>
    protected void postTurnoverAccrued()
    {
        ProjLedger                      tmpProjLedger;
        Voucher                         voucher;
        AmountCur                       amountCur;
        MapEnumerator                   fundingAllocationEnumerator;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        LedgerDimensionAccount          mergedLedgerDimension;
        CurrencyExchangeHelper          exchangeRateHelper;
        LedgerVoucherObject             ledgerVoucherObject;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        ProjFundingSource               projFundingSource;
        Map                             splitTransQty;
        // <GEERU>
        LedgerBondClient_RU             ledgerBondClient;
        // </GEERU>

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject();

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), ledgerVoucherObject.parmAccountingDate());

        if (ProjWIPAccruedRevenueReversalExchangeRateFlight::instance().isEnabled())
        {
            exchangeRateHelper.parmExchangeRate1(this.exchRateSalesByPostingType(this.postingTypeTurnoverAccrued()));
        }
        else
        {
            exchangeRateHelper.parmExchangeRate1(this.exchRateSales());
        }

        exchangeRateHelper.parmExchangeRate2(this.exchRateSecondarySales());

        // Use reporting currency exchange rate from original trans posting for WIP accrued reversal scenario.
        if (this.parmReverseAccrued()
            && this.parmUseTransCurrReverseAccrued()
            && ProjReportingCurrencyExchRateFlight::instance().isEnabled())
        {
            ExchRate reportingCurrencyExchRate = this.exchRateReportingCurrency();

            if (reportingCurrencyExchRate)
            {
                exchangeRateHelper.parmReportingExchangeRate1(reportingCurrencyExchRate);
            }
        }

        if (this.checkEnterAccruedDebit())
        {
            this.postingType(this.postingTypeTurnoverAccrued());
            amountCur = -this.ledgerSalesAmount();

            if (!fundingSourceList)
            {
                throw error(strFmt("@SYS22828", funcName()));
            }

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions(fundingSourceList, amountCur, this.currencyIdSales()).getEnumerator();

            if (splitTransQtyCon)
            {
                splitTransQty = Map::create(splitTransQtyCon);
            }
            else
            {
                splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
            }

            while ( fundingAllocationEnumerator.moveNext() )
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    // Create the proj ledger object
                    tmpProjLedger = ProjLedger::newProjectSales(projTrans,this.parmTransIdSales(),
                                                            this.parmTransactionOrigin(),
                                                            this.parmLedgerOrigin(),
                                                            this.parmElimination(),
                                                            fundingAllocationEnumerator.currentKey(),
                                                            splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);

                    defaultLedgerDimension = this.parmLedgerDimension(this.debitAccountSalesAccruedLedgerDimension(fundingAllocationEnumerator.currentKey()));

                    // need to merge the default account with the default dimensions
                    projFundingSource = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), projFundingSource.DefaultDimension);

                    if (postToGeneralLedger)
                    {
                        ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostTurnoverAccrued(
                            ledgerVoucherObject,
                            mergedLedgerDimension,
                            this.currencyIdSales(),
                            fundingAllocationEnumerator,
                            exchangeRateHelper,
                            splitTransQty,
                            tmpProjLedger);

                        ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    }
                    else
                    {
                        if (ledgerVoucher && ledgerVoucher.lastVoucher())
                        {
                            voucher     = ledgerVoucher.lastVoucher();
                        }
                        else
                        {
                            voucher     = '';
                        }

                        ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                                this.postingType(),
                                                projTrans.defaultDimension(),
                                                voucher,
                                                projTrans.transDate(),
                                                fundingAllocationEnumerator.currentValue(),
                                                mergedLedgerDimension).insert();
                    }
                }
            }
        }

        if (this.checkEnterAccruedCredit())
        {
            this.postingType(this.postingTypeOffsetTurnoverAccrued());
            amountCur = this.ledgerSalesAmount();

            if (!fundingSourceList)
            {
                throw error(strFmt("@SYS22828", funcName()));
            }

            fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( fundingSourceList,amountCur,this.currencyIdSales()).getEnumerator();

            if (splitTransQtyCon)
            {
                splitTransQty = Map::create(splitTransQtyCon);
            }
            else
            {
                splitTransQty = ProjFundingEngine::distributeQty(fundingSourceList, projTrans.qty());
            }

            while ( fundingAllocationEnumerator.moveNext() )
            {
                if (ProjFundingSource::isExternalFunding(fundingAllocationEnumerator.currentKey()))
                {
                    //  Create the proj ledger object
                    tmpProjLedger = ProjLedger::newProjectSales(projTrans,this.parmTransIdSales(),
                                                             this.parmTransactionOrigin(),
                                                             this.parmLedgerOrigin(),
                                                             this.parmElimination(),
                                                             fundingAllocationEnumerator.currentKey(),
                                                             splitTransQty.exists(fundingAllocationEnumerator.currentKey()) ? splitTransQty.lookup(fundingAllocationEnumerator.currentKey()) * 1 : 0.0);

                    defaultLedgerDimension = this.parmLedgerDimension(this.creditAccountSalesAccruedLedgerDimension(fundingAllocationEnumerator.currentKey()));

                    // need to merge the default account with the default dimensions
                    projFundingSource = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                    mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, this.defaultDimension(), projFundingSource.DefaultDimension);

                    if (postToGeneralLedger)
                    {
                        ledgerVoucherTransObject = this.initLedgerVoucherTransObjectForPostTurnoverAccrued(
                            ledgerVoucherObject,
                            mergedLedgerDimension,
                            this.currencyIdSales(),
                            fundingAllocationEnumerator,
                            exchangeRateHelper,
                            splitTransQty,
                            tmpProjLedger);

                        ledgerVoucher.addTrans(ledgerVoucherTransObject);
                    }
                    else
                    {
                        if (ledgerVoucher && ledgerVoucher.lastVoucher())
                        {
                            voucher = ledgerVoucher.lastVoucher();
                        }
                        else
                        {
                            voucher = '';
                        }

                        ProjLedgerUpdate::newNoGeneralLedger(tmpProjLedger,
                                                this.postingType(),
                                                projTrans.defaultDimension(),
                                                voucher,
                                                projTrans.transDate(),
                                                fundingAllocationEnumerator.currentValue(),
                                                mergedLedgerDimension).insert();
                    }
                }
            }
        }
        // <GEERU>
        if (countryRegion_RU
            && this.checkEnterAccruedDebit()
            && this.checkEnterAccruedCredit())
        {
            ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLog2Log(ledgerVoucherObject.parmAccountingDate(),
                    ledgerBondClient.getDebitLog(),
                    ledgerBondClient.getCreditLog(),
                    [fieldNum(TmpLedgerBondLogTable_RU, BondId)]);
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransCreate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allows for extensibility in creating a transaction posting. The method contains no code.
    /// </summary>
    /// <remarks>
    /// This method is called by the <c>postTrans</c> method before the <c>ledgerTransActionsCreate</c>
    /// method when the <c>parmCreateTrans</c> method is true.
    /// </remarks>
    public void projTransCreate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>projTransUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Allows for extensibility in creating a transaction posting. The method contains no code.
    /// </summary>
    /// <remarks>
    ///    This method is called by <c>postTrans()</c> after the method <c>ledgerTransActionsCreate()</c> when the method <c>parmUpdateTrans()</c> is true.
    /// </remarks>
    public void projTransUpdate()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>salesAmountMST</Name>
				<Source><![CDATA[
    protected AmountMST salesAmountMST()
    {
        return projTrans.ledgerSalesAmountMST();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustomsAmount_IN</Name>
				<Source><![CDATA[
    private LedgerVoucherTransObject setCustomsAmount_IN(
    LedgerVoucherTransObject _ledgerVoucherTransObject,
    MapEnumerator            _fundingAllocationEnumerator,
    TransDate                _accountingDate)
    {
        customsLedgerAmountMST  = CurrencyExchangeHelper::amountCur2MST(
            this.costValueCUR() - this.parmTaxAmountCur() + loadOnInventory,
            this.currencyIdCost(),
            this.exchRate(),
            _accountingDate);
        
        _ledgerVoucherTransObject.parmTransactionCurrencyAmount(_fundingAllocationEnumerator.currentValue() + this.parmTaxAmountCur() + loadOnInventory);
        _ledgerVoucherTransObject.parmAccountingCurrencyAmount(customsLedgerAmountMST);

        // _RU method is used for India after MS suggestion, later this will become API as told by hongch.
        AmountMST taxAmountLOI = CurrencyExchangeHelper::amountCur2MST(this.costValueCUR() - this.parmTaxAmountCur() + loadOnInventory, this.currencyIdCost(), this.exchRate(), _accountingDate);
        _ledgerVoucherTransObject.parmReportingCurrencyAmount(CurrencyExchangeHelper::amountMST2MSTSecond_RU(taxAmountLOI, _accountingDate));

        return _ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setFundingSource</Name>
				<Source><![CDATA[
    public void setFundingSource(ProjFundingSourceRefId _fundingSourceRefId, AmountCur _retainAmount)
    {
        costDistributions = new Map(Types::Int64, Types::Real);
        saleDistributions = new Map(Types::Int64, Types::Real);

        saleDistributions.insert(_fundingSourceRefId, _retainAmount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulation</Name>
				<Source><![CDATA[
    public UnknownNoYes triangulation()
    {
        return UnknownNoYes::Unknown;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triangulationSales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns an enumeration value that specifies whether triangulation is required for computing the
    /// exchange rate.
    /// </summary>
    /// <returns>
    /// An enumeration value that specifies whether triangulation is required for computing the exchange
    /// rate.
    /// </returns>
    public UnknownNoYes triangulationSales()
    {
        if (this.parmReverseAccrued())
        {
            return UnknownNoYes::Unknown;
        }

        return Currency::noYes2UnknownNoYes(projTrans.triangulationSales());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjItemTransCost</Name>
				<Source><![CDATA[
    public void updateProjItemTransCost(ProjItemTrans  _projItemTrans, Voucher _voucher)
    {
        ProjItemTransCost   projItemTransCost;
        ProjLedger          projLedger;

        while select forupdate projItemTransCost
        where projItemTransCost.InventTransId   == _projItemTrans.InventTransId
           && projItemTransCost.ProjAdjustRefId == _projItemTrans.ProjAdjustRefId
        {
            projItemTransCost.ItemType  = ProjItemTrans::transactionOriginToItemType(_projItemTrans.TransactionOrigin);

            projItemTransCost.update();

            projLedger = ProjLedger::newInventCostAdjust(_projItemTrans.ProjId,_projItemTrans.InventTransId,_projItemTrans.ProjAdjustRefId,
                                                     _projItemTrans.TransactionOrigin, true);

            if (projLedger)
            {
                ProjLedgerUpdate::newNoneLedger(projLedger,
                                            LedgerPostingType::ProjNeverLedger,
                                            _projItemTrans.DefaultDimension,
                                            _voucher,
                                            projItemTransCost.LedgerTransdate,
                                            projItemTransCost.AmountMST).insert();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkCreateProjCost</Name>
				<Source><![CDATA[
    public static boolean checkCreateProjCost(ItemId itemId, ProjId projId)
    {
        if (!projId)
        {
            return false;
        }

        if (!itemId)
        {
            return false;
        }

        if (InventTable::modelGroupByItemId(itemId).PostOnhandFinancial)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSplitList</Name>
				<Source><![CDATA[
    public static List createSplitList( ProjFundingSourceRefId _fundingSourceId )
    {
        List    splitList = new List( Types::Class);

        splitList.addEnd( ProjSplitAllocation::construct( _fundingSourceId, 100,0,NoYes::Yes ));

        return splitList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>financialInventPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts project ledger transactions.
    /// </summary>
    /// <param name="_financial">
    /// The inventory update financial object.
    /// </param>
    public static void financialInventPost(InventUpd_Financial   _financial)
    {
        ProjItemTrans       projItemTrans;
        ProjItemTransCost   projItemTransCost;
        ProjLedger          projLedger;
        ProjPost            projPost;

        //Post offset project ledger transactions
        projPost = ProjPost::newInventUpd_PhysicalAdjust(_financial.movement(),
                                    _financial.parmLedgerVoucher(),
                                    _financial.updFinancialUnit(),
                                    ProjTrans::postedPhysicalValue(_financial),
                                    _financial.movement().projAdjustRefId(),
                                    false,
                                    _financial.movement().transId());
        projPost.createFundingAllocationListBasedOnTrx(ProjTransType::Item);
        projPost.postTrans();
        ProjPost::postItemReverseTransaction(projPost);

        //Post project ledger transactions
        projPost = ProjPost::newInventUpd_PhysicalAdjust(_financial.movement(),
                                    _financial.parmLedgerVoucher(),
                                    -_financial.updFinancialUnit(),
                                    -_financial.updCostAmountLedger(),
                                    _financial.movement().projAdjustRefId(),
                                    false,
                                    _financial.movement().transId());
        projPost.createFundingAllocationListBasedOnTrx(ProjTransType::Item);
        projPost.postTrans();
        ProjPost::postItemReverseTransaction(projPost);

        //If inventory is not financial updated create never ledger update for the final project item cost
        projItemTrans = ProjItemTrans::findInvent(_financial.movement().transId(), _financial.movement().projAdjustRefId());
        if (ProjPost::checkCreateProjCost(projItemTrans.ItemId, projItemTrans.ProjId))
        {
            select projItemTransCost
            where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId &&
                projItemTransCost.Voucher == _financial.parmLedgerVoucher().lastVoucher() &&
                projItemTransCost.CostType == ProjItemTransCostType::Cost;

            if (projItemTransCost)
            {
                projLedger = ProjLedger::newInventCostAdjust(
                                        projItemTrans.ProjId,
                                        projItemTrans.InventTransId,
                                        projItemTrans.ProjAdjustRefId,
                                        projItemTrans.TransactionOrigin,
                                        true);

                if (projLedger)
                {
                    ProjLedgerUpdate::newNoneLedger(
                                    projLedger,
                                    LedgerPostingType::ProjNeverLedger,
                                    projItemTrans.DefaultDimension,
                                    _financial.parmLedgerVoucher().lastVoucher(),
                                    projItemTransCost.LedgerTransdate,
                                    projItemTransCost.AmountMST).insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventAdjustPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method that handles posting of adjustment amount from the inventory close to the same account type as the original item
    /// </summary>
    /// <param name="_accountingDate">
    /// Accounting date to be used for posting adjustments
    /// </param>
    /// <param name="_voucher">
    /// Voucher Id
    /// </param>
    /// <remarks>
    /// handles posting of adjustment amount from the inventory close to the same account type as the original item
    /// </remarks>
    public static void inventAdjustPost(AccountingDate _accountingDate, Voucher _voucher)

    {
        Args                            args;
        ProjPeriodPostingLedger         projPeriodPostingLedger;
        ProjPeriodPostingSelectCost     projPeriodPostingSelectCost;
        ProjItemTrans                   projItemTrans;
        ProjItemTransCost               projItemTransCost;
        ProjTrans                       projTrans;
        boolean                         canPost;
        TmpProjPeriodic                 tmpProjPeriodic;
        TmpProjPeriodicCost             tmpProjPeriodicCost;
        TmpProjPeriodicSale             tmpProjPeriodicSale;
        ProjTable                       projTable;

        if (!isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            return;
        }

        boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
        
        projPeriodPostingSelectCost = new ProjPeriodPostingSelectCost();
        if (!enableProjMultipleContractLinesForProjectFeature)
        {
            projPeriodPostingSelectCost.parmProjInternal(NoYes::Yes);
            projPeriodPostingSelectCost.parmProjTimeMaterial(NoYes::Yes);
        }
        projPeriodPostingSelectCost.parmProjLedgerStatus(ProjLedgerStatus::BalanceSheet);

        ProjItemTransSale chargeable;
        boolean contractLineBasedRevRecFeature = ProjContractLineBasedRevenueRecognitionFeatureHelper::isFeatureEnabled();
        
        while select projItemTransCost
            where projItemTransCost.LedgerStatusCost == ProjLedgerStatus::Operations &&
                projItemTransCost.ProjInventAdjust == true &&
                projItemTransCost.Voucher == _voucher
            join ProjTransId, ProjId from projItemTrans
                where projItemTrans.InventTransId == projItemTransCost.InventTransId &&
                    projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
            join projTable
                where projTable.ProjId == projItemTrans.ProjId &&
                    projTable.Status != ProjStatus::Completed
            exists join chargeable
                where chargeable.ProjTransId == projItemTrans.ProjTransId &&
                        (chargeable.TransStatus == ProjTransStatus::Posted ||
                         chargeable.TransStatus == ProjTransStatus::InvoiceProposal) &&
                         chargeable.FundingSource == projItemTransCost.FundingSource
        {
            projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);
            ProjWIPTable wipProject = projTrans.getWIPProject();
            if(contractLineBasedRevRecFeature && wipProject.IsContractLineUsed)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                if (!revProfile || revProfile.ItemLedgerStatus != ProjLedgerStatusItem::BalanceSheet)
                {
                    continue;
                }
                else
                {
                    // If original transaction ledger status is not <C>BalanceSheet</C> then additional or adjusted amount ledger status should not updated to <C>BalanceSheet</C>.
                    ProjItemTransCost projItemTransCostOrig;
                    select firstonly LedgerStatusCost, RecId from projItemTransCostOrig
                        where projItemTransCostOrig.InventTransId == projItemTransCost.InventTransId
                           && projItemTransCostOrig.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                           && projItemTransCostOrig.ProjInventAdjust == false;

                    if (projItemTransCostOrig.RecId
                        && projItemTransCostOrig.LedgerStatusCost != ProjLedgerStatus::BalanceSheet)
                    {
                        continue;
                    }
                }
            }
            else if (enableProjMultipleContractLinesForProjectFeature)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Item, false);
                if (!revProfile || revProfile.ItemLedgerStatus != ProjLedgerStatusItem::BalanceSheet)
                {
                    continue;
                }
                else
                {
                    // If original transaction ledger status is not <C>BalanceSheet</C> then additional or adjusted amount ledger status should not updated to <C>BalanceSheet</C>.
                    ProjItemTransCost projItemTransCostOrig;
                    select firstonly LedgerStatusCost, RecId from projItemTransCostOrig
                        where projItemTransCostOrig.InventTransId == projItemTransCost.InventTransId
                           && projItemTransCostOrig.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                           && projItemTransCostOrig.ProjInventAdjust == false;

                    if (projItemTransCostOrig.RecId
                        && projItemTransCostOrig.LedgerStatusCost != ProjLedgerStatus::BalanceSheet)
                    {
                        continue;
                    }
                }
            }
            else
            {
                ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
                if (!projGroup || projGroup.ItemTransCost != ProjLedgerStatus::BalanceSheet)
                {
                    continue;
                }
                else
                {
                    // If original transaction ledger status is not <C>BalanceSheet</C> then additional or adjusted amount ledger status should not updated to <C>BalanceSheet</C>.
                    ProjItemTransCost projItemTransCostOrig;
                    select firstonly LedgerStatusCost, RecId from projItemTransCostOrig
                        where projItemTransCostOrig.InventTransId == projItemTransCost.InventTransId
                           && projItemTransCostOrig.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
                           && projItemTransCostOrig.ProjInventAdjust == false;

                    if (projItemTransCostOrig.RecId 
                        && projItemTransCostOrig.LedgerStatusCost != ProjLedgerStatus::BalanceSheet)
                    {
                        continue;
                    }
                }
            }

            canPost = true;

            select tmpProjPeriodic
                where tmpProjPeriodic.TransId == projTrans.transId();

            if (!tmpProjPeriodic)
            {
                tmpProjPeriodic.clear();
                tmpProjPeriodic.CategoryId          = projTrans.categoryId();
                tmpProjPeriodic.DefaultDimension    = projTrans.defaultDimension();
                tmpProjPeriodic.ProjId              = projTrans.projId();
                tmpProjPeriodic.Qty                 = projTrans.qty();
                tmpProjPeriodic.TransDate           = projTrans.transDate();
                tmpProjPeriodic.TransId             = projTrans.transId();
                tmpProjPeriodic.Resource            = projTrans.resource();
                tmpProjPeriodic.ResourceCategory    = projTrans.resourceCategory();
                tmpProjPeriodic.ActivityNumber      = projTrans.activityNumber();
                tmpProjPeriodic.InventTransId       = projTrans.inventTransId();
                tmpProjPeriodic.Txt                 = projTrans.txt();
                tmpProjPeriodic.Voucher             = projTrans.voucherOriginal();
                tmpProjPeriodic.ProjLinePropertyId  = projTrans.linePropertyId();
                tmpProjPeriodic.TaxGroup            = projTrans.taxGroup();
                tmpProjPeriodic.TaxItemGroup        = projTrans.taxItemGroup();
                tmpProjPeriodic.TransType           = projTrans.transType();
                tmpProjPeriodic.Origin              = projTrans.origin();
                tmpProjPeriodic.ProjIdentResource   = projTrans.projIdentResource();
                tmpProjPeriodic.PackingSlipId       = projTrans.packingSlipId();
                tmpProjPeriodic.LedgerDimension     = projTrans.itemLedgerAccountLedgerDimension();
                tmpProjPeriodic.AcknowledgementDate = projTrans.transDate();
                tmpProjPeriodic.ContractLineNum     = projTrans.psaContractLineNum();
                tmpProjPeriodic.insert();
            }

            tmpProjPeriodicCost.clear();
            tmpProjPeriodicCost.TransId             = projTrans.transId();
            tmpProjPeriodicCost.CostRefRecId        = projTrans.recId();
            tmpProjPeriodicCost.CurrencyId          = projTrans.currencyIdCost();
            tmpProjPeriodicCost.ProjAdjustRefId     = projTrans.projAdjustRefId();
            tmpProjPeriodicCost.ItemlineNum         = projTrans.itemLineNum();
            tmpProjPeriodicCost.CostPrice           = projTrans.costPrice();
            tmpProjPeriodicCost.TransStatus         = projTrans.transStatus();
            tmpProjPeriodicCost.LedgerStatusCost    = projTrans.ledgerStatusCost();
            tmpProjPeriodicCost.CostAmount          = projTrans.transCost();
            tmpProjPeriodicCost.insert();
        }

        if (canPost)
        {
            args = new Args();
            args.parmEnumType(enumNum(ProjCostSales));
            args.parmEnum(enum2int(ProjCostSales::Cost));

            projPeriodPostingLedger  = ProjPeriodPostingLedger::construct(args);
            projPeriodPostingLedger.getLast();

            projPeriodPostingLedger.parmProjLedgerStatus(ProjLedgerStatus::BalanceSheet);
            projPeriodPostingLedger.parmtransActionDate(_accountingDate);
            projPeriodPostingLedger.parmAcknowledgementDate(_accountingDate);

            projPeriodPostingLedger.parmTmpProjPeriodic(tmpProjPeriodic);
            projPeriodPostingLedger.parmTmpProjPeriodicCost(tmpProjPeriodicCost);
            projPeriodPostingLedger.parmTmpProjPeriodicSale(tmpProjPeriodicSale);

            projPeriodPostingLedger.runOperation();
        }

        ProjPost::inventAdjustPostBudgetUpdate(_voucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initIsContractLineUsed</Name>
				<Source><![CDATA[
    public void initIsContractLineUsed(ProjTrans _projTrans = projTrans)
    {
        if(!contractLineBasedRevRecFeature)
        {
            this.parmIsContractLineUsed(false);
        }
        else
        {
            this.parmIsContractLineUsed(projTrans.getWIPProject().IsContractLineUsed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a new instance of <c>ProjPost</c> for posting ledger entries.
    /// </summary>
    /// <param name="_buffer">
    /// The table for the transaction type.
    /// </param>
    /// <returns>
    /// A new <c>ProjPost</c> object for posting from period transactions.
    /// </returns>
    /// <remarks>
    ///  This method is only valid for the following tables:
    ///  <list type="bullet">
    ///   <item>
    ///   <description>InventJournalTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>LedgerJournalTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>ProjCostTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>ProjEmpTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>ProjItemTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>ProjJournalTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>ProjRevenueTrans</description>
    ///   </item>
    ///   <item>
    ///   <description>PurchLine</description>
    ///   </item>
    ///  </list>
    ///  Passing any other table in the <paramref name="_buffer" />
    ///   parameter will throw the error: Project posting is not implemented for this type.
    /// </remarks>
    public static ProjPost newCheckTrans(Common _buffer)
    {
        ProjPost                projPost;
        ProjJournalTrans        projJournalTrans;

        switch (_buffer.TableId)
        {
            case tableNum(ProjJournalTrans)          :
                projJournalTrans   = _buffer;
                if (projJournalTrans.projJournalTable().JournalType == ProjJournalType::Hour)
                {
                    projPost    = new ProjPostEmplJournal (_buffer);
                }
                else
                {
                    projPost    = new ProjPostRevenueJournal (_buffer);
                }
                break;
            case tableNum(LedgerJournalTrans)        :
                projPost = new ProjPostCostJournal         (_buffer);
                break;

            case tableNum(InventJournalTrans):
                projPost = new ProjPostItemJournal(_buffer);
                break;

            case tableNum(ProdTableProj):
                projPost = new ProjPostItemJournal(_buffer);
                projPost.initUpdate();
                break;

            case tableNum(ProdBOMTransProj):
                projPost = new ProjPostItemJournal(_buffer);
                break;

            case tableNum(PurchLine):
                projPost = ProjPostItemInventUpd_Financial::newProjPostItemPurchLine(_buffer);
                projPost.parmSkipCheckLedgerTransDate(true);
                break;

            case tableNum(ProdTable):
                projPost = ProjPostItemInventUpd_Financial::newProjPostItemProdTable(_buffer);
                break;

            case tableNum(ProdJournalBOM):
                projPost = ProjPostItemInventUpd_Physical::newProjPostItemProdJournalBOM(_buffer);
                break;

            case tableNum(SalesLine)          :
                projPost = ProjPost::newProjPostItemSalesLine(_buffer);
                break;

            default :
                EventHandlerResult result = new EventHandlerResult();
                ProjPost::newCheckTransDelegate(_buffer, result);
                if(result.hasResult())
                {
                    projPost = result.result() as ProjPost;
                }
                else
                {
                    throw error("@SYS50155");
                }
        }

        projPost.parmCreateTrans(false);
        projPost.parmUpdateTrans(false);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckTransDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Delegate for getting a new instance of <c>ProjPost</c> for posting ledger entries.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_eventHandlerResult">
    ///     An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjPost</c> object for posting from period transactions.
    /// </param>
    static delegate void newCheckTransDelegate(Common _buffer, EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCheckTransAmount</Name>
				<Source><![CDATA[
    public static ProjPost newCheckTransAmount(Common _transBuffer, Common _transAmountBuffer)
    {
        ProjPost                    projPost;
        ProjEmplTrans               projEmplTrans;
        ProjEmplTransSale           projEmplTransSale;

        ProjCostTrans               projCostTrans;
        ProjCostTransSale           projCostTransSale;

        ProjItemTrans               projItemTrans;
        ProjItemTransSale           projItemTransSale;

        ProjRevenueTrans            projRevenueTrans;
        ProjRevenueTransSale        projRevenueTransSale;
        ProjId                      projId;
        ProjTable                   projTable;
        ProjWIPTable                wipProject;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjEmplTransSale):
                projEmplTrans = _transBuffer;
                projEmplTransSale = _transAmountBuffer;
                projPost = new ProjPostEmplTransSale(projEmplTrans, projEmplTransSale);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransSale.FundingSource ) );
                break;

            case tableNum(ProjCostTransSale):
                projCostTrans = _transBuffer;
                projCostTransSale = _transAmountBuffer;
                projPost = new ProjPostCostTransSale(projCostTrans, projCostTransSale);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransSale.FundingSource ) );
                break;

            case tableNum(ProjItemTransSale):
                projItemTrans = _transBuffer;
                projItemTransSale = _transAmountBuffer;
                projPost = new ProjPostItemTransSale(projItemTrans, projItemTransSale);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projItemTransSale.FundingSource ) );
                break;

            case tableNum(ProjRevenueTransSale):
                projRevenueTrans = _transBuffer;
                projRevenueTransSale = _transAmountBuffer;
                projPost = new ProjPostRevenueTransSale(projRevenueTrans, projRevenueTransSale);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projRevenueTransSale.FundingSource ) );
                projId = projRevenueTrans.ProjId;
                projTable = ProjTable::find(projId);
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.initIsContractLineUsed();
        projPost.parmCreateTrans(false);
        projPost.parmUpdateTrans(false);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateCostEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting cost estimates to ledger entries.
    /// </summary>
    /// <param name="_buffer">
    ///    The table for the transaction type.
    /// </param>
    /// <param name="_bufferCost">
    ///    The transaction cost amount table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger items for posting.
    /// </param>
    /// <param name="_reverse">
    ///    Indicates whether this is a reversing transaction.
    /// </param>
    /// <param name="_elimination">
    ///    Indicates whether this is an elimination transaction.
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for estimates of project costs.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the tables LedgerJournalTrans and ProjCostTrans. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error: Project posting is not
    ///    implemented for this type.
    /// </remarks>
    public static ProjPost newCreateCostEstimate(
    Common        _buffer,
    Common        _bufferCost,
    LedgerVoucher _ledgerVoucher,
    boolean       _reverse,
    boolean       _elimination)
    {
        ProjPost            projPost;
        ProjLedgerStatus    projLedgerStatus;
        LedgerJournalTrans  ledgerJournalTrans;
        ProjCostTrans       projCostTrans;
        ProjCostTransCost   projCostTransCost;

        switch (_buffer.TableId)
        {
            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans = _buffer;
                projPost = new ProjPostCostEstimate(ledgerJournalTrans, null);
                projPost.parmCreateTrans(true);
                // No funding source specified
                projPost.parmFundingSourceList( ProjPost::createSplitList(0));
                projPost.parmUpdateTrans(true);
                break;

            case tableNum(ProjCostTrans):
                projCostTrans = _buffer;
                projCostTransCost = _bufferCost;
                projPost    = new ProjPostCostEstimate(projCostTrans, projCostTransCost);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransCost.FundingSource ) );
                projPost.parmUpdateTrans(true);
                break;

            default :
                throw error("@SYS50155");
        }

        if (_reverse)
        {
            projLedgerStatus = ProjLedgerStatus::Never;
        }
        else
        {
            projLedgerStatus = ProjLedgerStatus::Operations;
        }

        projPost.parmReverseAccrued  (_reverse);
        projPost.parmElimination     (_elimination);
        projPost.parmLedgerStatusCost(projLedgerStatus);
        projPost.parmLedgerVoucher   (_ledgerVoucher);

        projPost.parmEnterCost       (true);
        projPost.parmOriginCost      (ProjOriginCost::Estimate);

        projPost.parmTransactionOrigin(ProjOrigin::EstimateAccruedLoss);
        projPost.initIsContractLineUsed();

        if (_reverse && _elimination)
        {
            projPost.parmLedgerOrigin(ProjOrigin::ReverseElimination);
        }
        else
        {
            if (_elimination)
            {
                projPost.parmLedgerOrigin(ProjOrigin::EliminateEstimate);
            }
            else
            {
                if (_reverse)
                {
                    projPost.parmLedgerOrigin(ProjOrigin::ReverseEstimate);
                }
                else
                {
                    projPost.parmLedgerOrigin(ProjOrigin::PostEstimate);
                }
            }
        }

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateCostEstimateInvestment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting cost estimates for investment projects to ledger entries.
    /// </summary>
    /// <param name="_buffer">
    ///    A table for transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger items for posting.
    /// </param>
    /// <param name="_reverse">
    ///    Indicates if it is a reversing transaction.
    /// </param>
    /// <param name="_elimination">
    ///    Indicates if it is an elimination transaction.
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for investment cost estimates.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the table LedgerJournalTrans. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error: Project posting is not implemented for
    ///    this type.
    /// </remarks>
    public static ProjPost newCreateCostEstimateInvestment(
    Common                  _buffer,
    LedgerVoucher           _ledgerVoucher,
    boolean                 _reverse,
    boolean                 _elimination)
    {
        ProjPost                projPost;
        ProjLedgerStatus        projLedgerStatus;
        LedgerJournalTrans      ledgerJournalTrans;
        ProjActivateTrans       costTransTurnover;
        ProjId                  projId;
        ProjTrans               projTrans;
        
        switch (_buffer.TableId)
        {
            case tableNum(LedgerJournalTrans):
                ledgerJournalTrans  = _buffer;
                projId              = ledgerJournalTrans.parmAccount();
                projPost = new ProjPostCostJournal(_buffer);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                break;
            default :
                throw error("@SYS50155");
        }

        projLedgerStatus = ProjRevRecHelper::getCostLedgerStatus(ProjTable::find(projId));

        projTrans          = ProjTrans::newLedgerJournalTrans(ledgerJournalTrans);
        costTransTurnover = ProjRevRecHelper::postWIPCostForProject(ProjTable::find(projTrans.projId()));
        
        projPost.parmEnterSalesAccrued(costTransTurnover);

        projPost.parmReverseAccrued(_reverse);
        projPost.parmElimination(_elimination);
        projPost.parmLedgerStatusCost(projLedgerStatus);
        projPost.parmLedgerVoucher(_ledgerVoucher);

        projPost.parmEnterCost(true);
        projPost.parmOriginCost(ProjOriginCost::InvestmentProject);
        projPost.parmTransactionOrigin(ProjOrigin::EliminationInvestment);
        projPost.parmLedgerOrigin(ProjOrigin::EliminationInvestment);
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProdTransAndLedger</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProdTransAndLedger(ProdRouteTrans            _prodRouteTrans,
                                                   ProdJournalRoute          _prodJournalRoute,
                                                   ProdJournalRouteProj      _prodJournalRouteProj,
                                                   ProjTransIdBase           _projTransId,
                                                   LedgerVoucher             _ledgerVoucher)
    {
        ProjPostEmplJournal     projPost;
        ProjTrans               projTrans;
        ProjActivateTrans transTurnover;
        ProjLedgerStatus emplLedgerStatus;

        projTrans = ProjTrans::newProdJournalRouteProj(_prodRouteTrans, _prodJournalRoute, _prodJournalRouteProj);

        projPost = new ProjPostEmplJournal(_prodJournalRouteProj);
        ProjTable projTable = ProjTable::find(projTrans.projId());

        if(projPost.parmIsContractLineUsed())
        {
            ProjWIPTable wipProject = projTrans.getWIPProject();
            ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
            transTurnover = revProfile.PostWIPEmpl;
            emplLedgerStatus = revProfile.EmplLedgerStatus;
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Hour);
            transTurnover = revProfile.PostWIPEmpl;
            emplLedgerStatus = revProfile.EmplLedgerStatus;
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
            transTurnover = projGroup.EmplTransTurnover;
            emplLedgerStatus = projGroup.EmplTransCost;
        }

        projPost.parmLedgerStatusCost(emplLedgerStatus);
        ProjWIPTable wipProject = projTrans.getWIPProject();

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet)
        {
            if (projTrans.projLineProperty().ToBeCapitalize)
            {
                if (ProjPost::isPLPostingRequiredForTransType(wipProject, projTrans) || ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
                {
                    projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                }
            }
            else
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::None)
        {
            if (ProjPost::isPLPostingRequiredForTransType(wipProject, projTrans) || ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if (projPost.isLedgerStatusPostingCost(projPost.parmLedgerStatusCost()))
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmEnterSalesAccrued(transTurnover);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmProdJournalRoute(_prodJournalRoute);
        projPost.parmProdRouteTrans(_prodRouteTrans);
        projPost.parmProjTransId(_projTransId);
        projPost.initUpdate();
        projPost.initIsContractLineUsed(projTrans);

        projPost.parmTransactionOrigin(ProjOrigin::ProductionConsumed);
        projPost.parmLedgerOrigin(ProjOrigin::ProductionConsumed);

        projPost.parmCommittedCostReverse(true);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjCostAndLedger</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjCostAndLedger(
    Common                _buffer,
    LedgerVoucher         _ledgerVoucher,
    LedgerJournalType     _ledgerJournalType,
    TaxAmount             _taxAmountInCostPrice = 0,
    boolean               _adjustment = false,
    boolean               _reverseCommittedCost=true)
    {
        ProjPost                projPost;
        LedgerJournalTrans      ledgerJournalTrans;
        ProjTrans               projTrans;
        ProjOriginCost          originCost;
        ProjOrigin              transactionOrigin;

        switch (_buffer.TableId)
        {
            case tableNum(LedgerJournalTrans):
                projPost = new ProjPostCostJournal(_buffer);
                projPost.parmCommittedCostReverse(_reverseCommittedCost);
                break;
            default :
                throw error("@SYS50155");
        }

        ledgerJournalTrans  = _buffer;

        projTrans           = ProjTrans::newLedgerJournalTrans(ledgerJournalTrans);

        ProjActivateTrans costTransTurnover;
        ProjLedgerStatus costLedgerStatus;        
        ProjTable projTablePostWIPCost = ProjTable::find(projTrans.projId());
        ProjTable projTableCostLedgerStatus = ProjTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension());
        ProjWIPTable wipProject = projTrans.getWIPProject();

        if(wipProject.IsContractLineUsed)
        {
            if (PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeExpenseTrans == NoYes::No)
            {
                costTransTurnover = NoYes::No;
                costLedgerStatus = ProjLedgerStatus::Operations;
            }
            else
            {
                costTransTurnover = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).PostWIPCost;
            }

            if (!projTableCostLedgerStatus.ProjInvoiceProjId)
            {
                // Internal project, post cost to P/L accounts.
                costLedgerStatus = ProjLedgerStatus::Operations;
            }
            else if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeExpenseTrans == NoYes::Yes)
            {
                costLedgerStatus = ProjRevRecHelper::cost2LedgerStatus(ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).CostLedgerStatus);
         
            }
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            if (!projTablePostWIPCost.ProjInvoiceProjId)
            {
                costTransTurnover = NoYes::No;
            }
            else
            {
                costTransTurnover = ProjRevRecHelper::getRevProfileForTransactionType(projTablePostWIPCost, ProjTransType::Cost).PostWIPCost;
            }

            if (!projTableCostLedgerStatus.ProjInvoiceProjId)
            {
                // Internal project, post cost to P/L accounts.
                costLedgerStatus = ProjLedgerStatus::Operations;
            }
            else
            {
                costLedgerStatus = ProjRevRecHelper::cost2LedgerStatus(ProjRevRecHelper::getRevProfileForTransactionType(projTableCostLedgerStatus, ProjTransType::Cost).CostLedgerStatus);
            }
        }
        else
        {
            costTransTurnover = ProjGroup::find(projTablePostWIPCost.ProjGroupId).CostTransTurnover;
            costLedgerStatus = ProjGroup::find(projTableCostLedgerStatus.ProjGroupId).CostTransCost;
        }

        projPost.parmEnterSalesAccrued(costTransTurnover);
        projPost.parmLedgerStatusCost(costLedgerStatus);

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet)
        {
            if (projTrans.projLineProperty().ToBeCapitalize)
            {
                if (ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
                {
                    projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                }
            }
            else
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if (projPost.isLedgerStatusPostingCost(projPost.parmLedgerStatusCost()))
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmLedgerVoucher(_ledgerVoucher);

        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Daily:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                break;

            case LedgerJournalType::Approval:
                originCost  = ProjOriginCost::InvoiceApprovalJournal;
                transactionOrigin = ProjOrigin::InvoiceApprovalJournal;
                break;

            case LedgerJournalType::Cost:
                originCost  = ProjOriginCost::Cost;
                transactionOrigin = ProjOrigin::CostJournal;
                break;

            case LedgerJournalType::VendInvoiceRegister:
                originCost  = ProjOriginCost::InvoiceJournal;
                transactionOrigin = ProjOrigin::InvoiceJournal;
                break;

            default:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                break;
        }

        if (projTrans.module() == ModuleAxapta::Expense)
        {
            transactionOrigin = ProjOrigin::ExpenseManagement;
        }

        projPost.parmOriginCost(originCost);
        projPost.parmTaxAmountCur(_taxAmountInCostPrice);

        projPost.parmTransactionOrigin(transactionOrigin);

        if (!_adjustment)
        {
            projPost.parmLedgerOrigin(transactionOrigin);
        }
        else
        {
            projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        }

        projPost.parmsuppressBudgetMessages(true);
        projPost.parmIsDimensionUptake(true);
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjAdvancedJournalNeverLedger</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjAdvancedJournalNeverLedger(
        Common _buffer,
        LedgerVoucher _ledgerVoucher)
    {
        ProjPost projPost;
        ProjAdvancedJournalLine projAdvancedJournalLine;
        ProjActivateTrans transTurnover;

        switch (_buffer.TableId)
        {
            case tableNum(ProjAdvancedJournalLine):
                projAdvancedJournalLine = _buffer;
                if (projAdvancedJournalLine.TransType == ProjTransType::Item)
                {
                    projPost = new ProjPostAdvancedJournalItemNeverLedger(projAdvancedJournalLine);
                }
                else if (projAdvancedJournalLine.TransType == ProjTransType::Cost)
                {
                    projPost = new ProjPostAdvancedJournalCostNeverLedger(projAdvancedJournalLine);
                    projPost.parmTaxAmountCur(projAdvancedJournalLine.ProvidedTaxAmount);
                }
                else if (projAdvancedJournalLine.TransType == ProjTransType::Hour)
                {
                    projPost = new ProjPostAdvancedJournalHourNeverLedger(projAdvancedJournalLine);
                }
                else
                {
                    throw error(strFmt("@SYS22828",funcName()));
                }
                break;
            default :
                throw error("@SYS50155");
        }

        ProjTable projTableLoc = ProjTable::find(projAdvancedJournalLine.ProjId);
        projPost.parmTransactionOrigin(ProjOrigin::ProjAdvancedJournal);
        projPost.parmLedgerOrigin(ProjOrigin::ProjAdvancedJournal);
        projPost.parmTransactionOriginOrig(ProjOrigin::ProjAdvancedJournal);
        projPost.parmInventTransId(projAdvancedJournalLine.InventTransId);

        if (!projTableLoc.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            // Internal project, post cost to P/L accounts.
            transTurnover = NoYes::No;
        }
        else
        {
            transTurnover = ProjRevRecHelper::postWIPEmplForProject(projTableLoc);
        }

        projPost.parmCommittedCostReverse(true);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::Never);
        projPost.parmEnterSalesAccrued(transTurnover);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjCostAndLedger_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new project and ledger.
    /// </summary>
    /// <param name="_buffer">
    /// The buffer.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher.
    /// </param>
    /// <param name="_ledgerJournalType">
    /// The ledger journal type.
    /// </param>
    /// <param name="_taxAmountInCostPrice">
    /// The in cost price tax amount.
    /// </param>
    /// <param name="_loiAmount">
    /// The loi amount.
    /// </param>
    /// <returns>
    /// The instance of the <c>ProjPost</c> class.
    /// </returns>
    public static ProjPost newCreateProjCostAndLedger_IN(
    Common                _buffer,
    LedgerVoucher         _ledgerVoucher,
    LedgerJournalType     _ledgerJournalType,
    TaxAmount             _taxAmountInCostPrice     = 0,
    TaxAmountCur          _loiAmount                = 0)
    {
        ProjPost                projPost;
        LedgerJournalTrans      ledgerJournalTrans;
        ProjTrans               projTrans;
        ProjActivateTrans       costTransTurnover;
        ProjOriginCost          originCost;
        ProjOrigin              transactionOrigin;

        switch (_buffer.TableId)
        {
            case tableNum(LedgerJournalTrans):
                projPost = new ProjPostCostJournal(_buffer);
                break;
            default :
                throw error("@SYS50155");
        }

        ledgerJournalTrans  = _buffer;

        projTrans           = ProjTrans::newLedgerJournalTrans(ledgerJournalTrans);
        ProjTable projTable = ProjTable::findByLedgerDimension(ledgerJournalTrans.parmLedgerDimension());
        ProjLedgerStatus costLedgerStatus = ProjRevRecHelper::getCostLedgerStatus(projTable);

        projPost.parmEnterSalesAccrued(costTransTurnover);

        projPost.parmLedgerStatusCost(costLedgerStatus);

        if (projPost.parmLedgerStatusCost())
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmLedgerVoucher(_ledgerVoucher);

        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Daily:
                originCost         = ProjOriginCost::GeneralJournal;
                transactionOrigin  = ProjOrigin::GeneralJournal;
                break;
            case LedgerJournalType::Approval:
                originCost         = ProjOriginCost::InvoiceApprovalJournal;
                transactionOrigin  = ProjOrigin::InvoiceApprovalJournal;
                break;
            case LedgerJournalType::Cost:
                originCost         = ProjOriginCost::Cost;
                transactionOrigin  = ProjOrigin::CostJournal;
                break;
            case LedgerJournalType::VendInvoiceRegister:
                originCost         = ProjOriginCost::InvoiceJournal;
                transactionOrigin  = ProjOrigin::InvoiceJournal;
                break;
            default:
                originCost         = ProjOriginCost::GeneralJournal;
                transactionOrigin  = ProjOrigin::GeneralJournal;
                break;
        }
        projPost.parmloadOnInventoryAmount_IN(_loiAmount);
        projPost.parmOriginCost(originCost);
        projPost.parmTaxAmountCur(_taxAmountInCostPrice);
        projPost.parmsuppressBudgetMessages(true);
        projPost.parmIsDimensionUptake(true);
        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjCostAndLedgerAdj</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjCostAndLedgerAdj(
    Common                _buffer,
    LedgerVoucher         _ledgerVoucher,
    LedgerJournalType     _ledgerJournalType,
    boolean               _reverseCommittedCost=true,
    ProjTransactionOrigin _transactionOriginOrig = ProjOrigin::None)
    {
        ProjPost                projPost;
        LedgerJournalTrans      ledgerJournalTrans;
        ProjTrans               projTrans;
        ProjOriginCost          originCost;
        ProjOrigin              transactionOrigin;

        switch (_buffer.TableId)
        {
            case tableNum(LedgerJournalTrans):
                projPost = new ProjPostCostJournal(_buffer);
                projPost.parmCommittedCostReverse(true);
                break;

            default :
                throw error("@SYS50155");
        }

        ledgerJournalTrans  = _buffer;

        projTrans           = ProjTrans::newLedgerJournalTrans(ledgerJournalTrans);
        projPost.parmEnterSalesAccrued(false);

        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmEnterCost(false);

        projPost.parmLedgerVoucher(_ledgerVoucher);

        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Daily:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                if (transactionOrigin != _transactionOriginOrig)
                {
                    transactionOrigin = _transactionOriginOrig;
                }
                break;

            case LedgerJournalType::Approval:
                originCost  = ProjOriginCost::InvoiceApprovalJournal;
                transactionOrigin = ProjOrigin::InvoiceApprovalJournal;
                break;

            case LedgerJournalType::Cost:
                originCost  = ProjOriginCost::Cost;
                transactionOrigin = ProjOrigin::CostJournal;
                break;

            case LedgerJournalType::VendInvoiceRegister:
                originCost  = ProjOriginCost::InvoiceJournal;
                transactionOrigin = ProjOrigin::InvoiceJournal;
                if (transactionOrigin != _transactionOriginOrig)
                {
                    transactionOrigin = _transactionOriginOrig;
                }
                break;

            default:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                break;
        }

        if (projTrans.module() == ModuleAxapta::Expense)
        {
            transactionOrigin = ProjOrigin::ExpenseManagement;
        }

        projPost.parmOriginCost(originCost);
        projPost.parmTaxAmountCur(0);

        projPost.parmTransactionOrigin(transactionOrigin);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCostAndTransactionOrigin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the cost origin and transaction origin for this transaction post.
    /// </summary>
    /// <param name = "_ledgerJournalType"><c>LedgerJournalType</c> enum value.</param>
    /// <param name = "_transactionOriginOrig"><c>ProjTransactionOrigin</c> enum value.</param>
    public void setCostAndTransactionOrigin(
    LedgerJournalType     _ledgerJournalType,
    ProjTransactionOrigin _transactionOriginOrig)
    {
        ProjOriginCost origCost;
        ProjOrigin origTransaction;

        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Daily:
                origCost  = ProjOriginCost::GeneralJournal;
                origTransaction = ProjOrigin::GeneralJournal;
                if (origTransaction != _transactionOriginOrig)
                {
                    origTransaction = _transactionOriginOrig;
                }
                break;

            case LedgerJournalType::Approval:
                origCost  = ProjOriginCost::InvoiceApprovalJournal;
                origTransaction = ProjOrigin::InvoiceApprovalJournal;
                break;

            case LedgerJournalType::Cost:
                origCost  = ProjOriginCost::Cost;
                origTransaction = ProjOrigin::CostJournal;
                break;

            case LedgerJournalType::VendInvoiceRegister:
                origCost  = ProjOriginCost::InvoiceJournal;
                origTransaction = ProjOrigin::InvoiceJournal;
                if (origTransaction != _transactionOriginOrig)
                {
                    origTransaction = _transactionOriginOrig;
                }
                break;

            default:
                origCost  = ProjOriginCost::GeneralJournal;
                origTransaction = ProjOrigin::GeneralJournal;
                break;
        }
        this.parmOriginCost(origCost);
        this.parmTransactionOrigin(origTransaction);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjCostAndLedgerCostAdjForBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>ProjPost</c> instance for posting cost side of the transaction.
    /// </summary>
    /// <param name = "_projCostTrans">The newly posted <c>ProjCostTrans</c> table buffer. </param>
    /// <param name = "_tmpProjAdjustmentCreateCost"> <c>TmpProjAdjustmentCreateCost</c> table buffer which contains the adjusted cost side of the transaction. </param>
    /// <param name = "_ledgerVoucher"> <c>LedgerVoucher</c> object. </param>
    /// <param name = "_ledgerJournalType"> <c>LedgerJournalType</c> enum type. </param>
    /// <param name = "_ledgerStatusCost"><c>ProjLedgerStatus</c> enum value.</param>
    /// <param name = "_transactionOriginOrig"> <c>ProjTransactionOrigin</c> enum type. </param>
    /// <returns> A derived <c>ProjPost</c> object. </returns>
    /// <remarks>This method is handled for a specific scenario where the 
	/// ledger status cost of the original expense transaction needs to be honored.
	/// </remarks>
	internal static ProjPost newCreateProjCostAndLedgerCostAdjForBalance(
    ProjCostTrans               _projCostTrans,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    LedgerJournalType           _ledgerJournalType,
    ProjLedgerStatus            _ledgerStatusCost,
    ProjTransactionOrigin       _transactionOriginOrig = ProjOrigin::None)
    {
        ProjPost projPost = new ProjPostCostJournalCostAdj(_projCostTrans, _tmpProjAdjustmentCreateCost);
        projPost.parmCommittedCostReverse(true);

        ProjTrans projTrans = ProjTrans::newProjTransCostTransCostAdj(_projCostTrans, _tmpProjAdjustmentCreateCost);
        projPost.parmEnterSalesAccrued(false);

		projPost.parmLedgerStatusCost(_ledgerStatusCost);
        
        if (_ledgerStatusCost == ProjLedgerStatus::BalanceSheet)
        {
            if (!projTrans.projLineProperty().ToBeCapitalize)
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }
        
        projPost.parmEnterCost(true);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);

        // set originCost and transactionOrigin
        projPost.setCostAndTransactionOrigin(_ledgerJournalType, _transactionOriginOrig);
        if (projTrans.module() == ModuleAxapta::Expense)
        {
            projPost.parmTransactionOrigin(ProjOrigin::ExpenseManagement);
        }
        
        projPost.parmTaxAmountCur(0);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateCost.FundingSource ) );
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjCostAndLedgerCost</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjCostAndLedgerCost(
    ProjCostTrans               _projCostTrans,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    LedgerJournalType           _ledgerJournalType,
    boolean                     _reverseCommittedCost=true,
    ProjTransactionOrigin       _transactionOriginOrig = ProjOrigin::None
)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        ProjOriginCost          originCost;
        ProjOrigin              transactionOrigin;

        projPost = new ProjPostCostJournalCostAdj(_projCostTrans, _tmpProjAdjustmentCreateCost);
        projPost.parmCommittedCostReverse(true);

        projTrans = ProjTrans::newProjTransCostTransCostAdj(_projCostTrans, _tmpProjAdjustmentCreateCost);
        projPost.parmEnterSalesAccrued(false);
        ProjWIPTable wipProject = projTrans.getWIPProject();
        ProjLedgerStatus costLedgerStatus;
        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeExpenseTrans)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                costLedgerStatus =  ProjRevRecHelper::cost2LedgerStatus(revProfile.CostLedgerStatus);
            }
        }
        else
        {
            ProjTable projTable = ProjTable::find(projTrans.projId());
            costLedgerStatus = ProjRevRecHelper::getCostLedgerStatus(projTable);
        }

        projPost.parmLedgerStatusCost(costLedgerStatus);

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet)
        {
            if (projTrans.projLineProperty().ToBeCapitalize)
            {
                if (ProjPost::isPLPostingRequiredForTransType(wipProject,projTrans) ||  ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
                {
                    projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                }
            }
            else
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if (projPost.isLedgerStatusPostingCost(projPost.parmLedgerStatusCost()))
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmLedgerVoucher(_ledgerVoucher);

        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Daily:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                if (transactionOrigin != _transactionOriginOrig)
                {
                    transactionOrigin = _transactionOriginOrig;
                }
                break;

            case LedgerJournalType::Approval:
                originCost  = ProjOriginCost::InvoiceApprovalJournal;
                transactionOrigin = ProjOrigin::InvoiceApprovalJournal;
                break;

            case LedgerJournalType::Cost:
                originCost  = ProjOriginCost::Cost;
                transactionOrigin = ProjOrigin::CostJournal;
                break;

            case LedgerJournalType::VendInvoiceRegister:
                originCost  = ProjOriginCost::InvoiceJournal;
                transactionOrigin = ProjOrigin::InvoiceJournal;
                if (transactionOrigin != _transactionOriginOrig)
                {
                    transactionOrigin = _transactionOriginOrig;
                }
                break;

            default:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                break;
        }

        if (projTrans.module() == ModuleAxapta::Expense)
        {
            transactionOrigin = ProjOrigin::ExpenseManagement;
        }

        projPost.parmOriginCost(originCost);
        projPost.parmTaxAmountCur(0);

        projPost.parmTransactionOrigin(transactionOrigin);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateCost.FundingSource ) );
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjCostAndLedgerSale</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjCostAndLedgerSale(
    ProjCostTrans               _projCostTrans,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    LedgerVoucher               _ledgerVoucher,
    LedgerJournalType           _ledgerJournalType,
    boolean                     _reverseCommittedCost=true,
    ProjTransactionOrigin       _transactionOriginOrig = ProjOrigin::None
)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        ProjActivateTrans       costTransTurnover;
        ProjOriginCost          originCost;
        ProjOrigin              transactionOrigin;

        projPost = new ProjPostCostJournalSaleAdj(_projCostTrans, _tmpProjAdjustmentCreateSale);
        projPost.parmCommittedCostReverse(_reverseCommittedCost);

        projTrans = ProjTrans::newProjTransCostTransSaleAdj(_projCostTrans, _tmpProjAdjustmentCreateSale);
        ProjWIPTable wipProject = projTrans.getWIPProject();
        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeExpenseTrans)
            {
                costTransTurnover = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).PostWIPCost;
            }
        }
        else
        {
            costTransTurnover = ProjRevRecHelper::postWIPCostForProject(ProjTable::find(projTrans.projId()));
        }
        
        projPost.parmEnterSalesAccrued(costTransTurnover);

        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmEnterCost(false);

        projPost.parmLedgerVoucher(_ledgerVoucher);

        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        switch (_ledgerJournalType)
        {
            case LedgerJournalType::Daily:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                if (transactionOrigin != _transactionOriginOrig)
                {
                    transactionOrigin = _transactionOriginOrig;
                }
                break;

            case LedgerJournalType::Approval:
                originCost  = ProjOriginCost::InvoiceApprovalJournal;
                transactionOrigin = ProjOrigin::InvoiceApprovalJournal;
                break;

            case LedgerJournalType::Cost:
                originCost  = ProjOriginCost::Cost;
                transactionOrigin = ProjOrigin::CostJournal;
                break;

            case LedgerJournalType::VendInvoiceRegister:
                originCost  = ProjOriginCost::InvoiceJournal;
                transactionOrigin = ProjOrigin::InvoiceJournal;
                if (transactionOrigin != _transactionOriginOrig)
                {
                    transactionOrigin = _transactionOriginOrig;
                }
                break;

            default:
                originCost  = ProjOriginCost::GeneralJournal;
                transactionOrigin = ProjOrigin::GeneralJournal;
                break;
        }

        if (projTrans.module() == ModuleAxapta::Expense)
        {
            transactionOrigin = ProjOrigin::ExpenseManagement;
        }

        projPost.parmOriginCost(originCost);
        projPost.parmTaxAmountCur(0);

        projPost.parmTransactionOrigin(transactionOrigin);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateSale.FundingSource ) );
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransAndLedgerDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Delegate for getting a new instance of <c>ProjPost</c> for posting ledger journal.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///     The ledger items for posting.
    /// </param>
    /// <param name = "_reverseCommittedCost">
    ///     A boolean value whether reverse committed cost required in transaction.
    /// </param>
    /// <param name = "_adjustment">
    ///     A boolean value for adjustment required in transaction.
    /// </param>
    /// <param name = "_transactionOriginOrig">
    ///     The origin of project transaction.
    /// </param>
    /// <param name = "_psaContractLineNum">
    ///     The value of billing rule.
    /// </param>
    /// <param name = "_eventHandlerResult">
    ///      An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjPost</c> object for posting ledger journal.
    /// </param>
    static delegate void newCreateProjTransAndLedgerDelegate(
        Common _buffer, 
        LedgerVoucher _ledgerVoucher,
        boolean _reverseCommittedCost,
        boolean _adjustment,
        ProjTransactionOrigin _transactionOriginOrig,
        PSAContractLineNum _psaContractLineNum,
        EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransAndLedger</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a new instance of <c>ProjPost</c> for posting ledger journal.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///     The ledger items for posting.
    /// </param>
    /// <param name = "_reverseCommittedCost">
    ///     true if reverse committed cost required in transaction; otherwise, false. Optional.
    /// </param>
    /// <param name = "_adjustment">
    ///     true if adjustment required in transaction; otherwise, false. Optional.
    /// </param>
    /// <param name = "_transactionOriginOrig">
    ///     The origin of project transaction.
    /// </param>
    /// <param name = "_psaContractLineNum">
    ///     The value of billing rule.
    /// </param>
    /// <returns>
    ///     A new <c>ProjPost</c> object for posting ledger journal.
    /// </returns>
    public static ProjPost newCreateProjTransAndLedger(Common                   _buffer,
                                                   LedgerVoucher            _ledgerVoucher,
                                                   boolean                  _reverseCommittedCost =true,
                                                   boolean                  _adjustment = false,
                                                   ProjTransactionOrigin    _transactionOriginOrig = ProjOrigin::None,
                                                   PSAContractLineNum       _psaContractLineNum = '')

    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        ProjJournalTrans        projJournalTrans;
        ProjActivateTrans       transTurnover;
        ProjJournalType         journalType;

        if (_buffer.TableId != tableNum(ProjJournalTrans))
        {
            throw error("@SYS50155");
        }

        projJournalTrans   = _buffer;
        projTrans          = ProjTrans::newProjJournalTrans(projJournalTrans);

        journalType        = ProjJournalTable::find(projJournalTrans.JournalId).JournalType;
        ProjWIPTable wipProject = projTrans.getWIPProject();

        switch (journalType)
        {
            case ProjJournalType::Hour :
                projPost    = new ProjPostEmplJournal   (_buffer);
                projPost.parmTransactionOrigin(ProjOrigin::HourJournal);
                projPost.parmLedgerOrigin(ProjOrigin::HourJournal);
                break;

            case ProjJournalType::Revenue:
                projPost    = new ProjPostRevenueJournal(_buffer, _psaContractLineNum);
                projPost.parmTransactionOrigin(ProjOrigin::FeeJournal);
                projPost.parmLedgerOrigin(ProjOrigin::FeeJournal);
                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                ProjPost::newCreateProjTransAndLedgerDelegate(_buffer, _ledgerVoucher, _reverseCommittedCost, _adjustment, _transactionOriginOrig, _psaContractLineNum, result);
                if(result.hasResult())
                {
                    projPost = result.result() as ProjPost;
                }
                else
                {
                    throw error("@SYS50155");
                }
        }

        switch (journalType)
        {
            case ProjJournalType::Hour:
                ProjTable projTableLoc = ProjTable::find(projJournalTrans.ProjId);
                if(wipProject.IsContractLineUsed)
                {
                }
                if (!projTableLoc.ProjInvoiceProjId && ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
                {
                    // Internal project, post cost to P/L accounts.
                    transTurnover = NoYes::No;
                    projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                }
                else
                {
                    transTurnover = ProjRevRecHelper::postWIPEmplForProject(projTableLoc);
                    projPost.parmLedgerStatusCost(ProjPost::getEmplLedgerStatusCost(projJournalTrans, projTrans));
                }

                if (projPost.isLedgerStatusPostingCost(ProjPost.parmLedgerStatusCost()))
                {
                    projPost.parmEnterCost(true);
                }
                break;

            case ProjJournalType::Revenue:
                transTurnover = ProjRevRecHelper::postWIPFeeForProject(ProjTable::find(projJournalTrans.ProjId));
                break;
        }

        switch (journalType)
        {
            case ProjJournalType::Hour :
                projPost.parmCommittedCostReverse(_reverseCommittedCost);
                break;

            case ProjJournalType::Revenue:
                break;
        }

        projPost.parmEnterSalesAccrued(transTurnover);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);
        projPost.initIsContractLineUsed(projTrans);

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _adjustment)
        {
            projPost.parmLedgerOrigin(ProjOrigin::Adjustment);

            if (journalType == ProjJournalType::Hour)
            {
                projPost.parmTransactionOrigin(_transactionOriginOrig);
                projPost.parmTransactionOriginOrig(_transactionOriginOrig);
            }
        }
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransAndLedgerAdjDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Delegate for getting a new instance of <c>ProjPost</c> for posting ledger adjustment journal.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///     The ledger items for posting.
    /// </param>
    /// <param name = "_transactionOriginOrig">
    ///     The origin of project transaction.
    /// </param>
    /// <param name = "_reverseCommittedCost">
    ///     A boolean value for reverse committed cost required in transaction.
    /// </param>
    /// <param name = "_eventHandlerResult">
    ///     An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjPost</c> object for posting ledger adjustment journal.
    /// </param>
    static delegate void newCreateProjTransAndLedgerAdjDelegate(
        Common _buffer, 
        LedgerVoucher _ledgerVoucher,
        ProjTransactionOrigin _transactionOriginOrig,
        boolean _reverseCommittedCost,
        EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransAndLedgerAdj</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a new instance of <c>ProjPost</c> for posting ledger adjustment journal.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///     The ledger items for posting.
    /// </param>
    /// <param name = "_transactionOriginOrig">
    ///     The origin of project transaction.
    /// </param>
    /// <param name = "_reverseCommittedCost">
    ///     true if reverse committed cost required in transaction; otherwise, false. Optional.
    /// </param>
    /// <returns>
    ///     A new <c>ProjPost</c> object for posting ledger adjustment journal.
    /// </returns>
    public static ProjPost newCreateProjTransAndLedgerAdj(
        Common                   _buffer,
        LedgerVoucher            _ledgerVoucher,
        ProjTransactionOrigin    _transactionOriginOrig = ProjOrigin::None,
        boolean                  _reverseCommittedCost = true)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        ProjJournalTrans        projJournalTrans;
        ProjJournalType         journalType;

        if (_buffer.TableId != tableNum(ProjJournalTrans))
        {
            throw error("@SYS50155");
        }

        projJournalTrans   = _buffer;
        projTrans          = ProjTrans::newProjJournalTrans(projJournalTrans);

        journalType        = ProjJournalTable::find(projJournalTrans.JournalId).JournalType;

        switch (journalType)
        {
            case ProjJournalType::Hour:
                projPost = new ProjPostEmplJournal(_buffer);
                projPost.parmTransactionOrigin(ProjOrigin::HourJournal);
                projPost.parmLedgerOrigin(ProjOrigin::HourJournal);
                break;

            case ProjJournalType::Revenue:
                projPost = new ProjPostRevenueJournal(_buffer, projJournalTrans.PSAProjOrigTransId ? ProjRevenueTrans::find(projJournalTrans.PSAProjOrigTransId).PSAContractLineNum : '');
                projPost.parmTransactionOrigin(ProjOrigin::FeeJournal);
                projPost.parmLedgerOrigin(ProjOrigin::FeeJournal);
                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                ProjPost::newCreateProjTransAndLedgerAdjDelegate(_buffer, _ledgerVoucher, _transactionOriginOrig, _reverseCommittedCost, result);
                if(result.hasResult())
                {
                    projPost = result.result() as ProjPost;
                }
                else
                {
                    throw error("@SYS50155");
                }
        }

        if (journalType == ProjJournalType::Hour)
        {
            projPost.parmNotEnterNoneLedger(true);
            projPost.parmNotEnterNeverLedger(true);
            projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
            projPost.parmEnterCost(false);
            projPost.parmCommittedCostReverse(_reverseCommittedCost);
        }

        projPost.parmEnterSalesAccrued(false);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);

        projPost.parmTransactionOrigin(_transactionOriginOrig);
        projPost.parmTransactionOriginOrig(_transactionOriginOrig);
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransAndLedgerAdjCost</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransAndLedgerAdjCost(
    Common                      _buffer,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    ProjTransactionOrigin       _transactionOriginOrig,
    boolean                     _reverseCommittedCost = true
)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                projPost    = new ProjPostEmplJournalCostAdj(_buffer, _tmpProjAdjustmentCreateCost);
                projPost.parmTransactionOrigin(ProjOrigin::HourJournal);
                projPost.parmLedgerOrigin(ProjOrigin::HourJournal);
                projTrans = ProjTrans::newProjTransEmplTransCostAdj(_buffer, _tmpProjAdjustmentCreateCost);
                break;

            default:
                throw error("@SYS50155");
        }

        ProjWIPTable wipProject = projTrans.getWIPProject();
        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeHourTrans)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                projPost.parmLedgerStatusCost(revProfile.EmplLedgerStatus);
            }
        }
        else
        {
            projPost.parmLedgerStatusCost(ProjRevRecHelper::getEmplLedgerStatus(ProjTable::find(projTrans.projId())));
        }

        

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet)
        {
            if (projTrans.projLineProperty().ToBeCapitalize)
            {
                if (ProjPost::isPLPostingRequiredForTransType(wipProject,projTrans) ||  ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
                {
                    projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
                }
            }
            else
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::None)
        {
            if (ProjPost::isPLPostingRequiredForTransType(wipProject,projTrans) || ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if (projPost.isLedgerStatusPostingCost(projPost.parmLedgerStatusCost()))
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmCommittedCostReverse(_reverseCommittedCost);

        projPost.parmEnterSalesAccrued(false);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);

        projPost.parmTransactionOrigin(_transactionOriginOrig);
        projPost.parmTransactionOriginOrig(_transactionOriginOrig);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateCost.FundingSource ) );
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransAndLedgerAdjSale</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransAndLedgerAdjSale(
    Common                      _buffer,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    LedgerVoucher               _ledgerVoucher,
    ProjTransactionOrigin       _transactionOriginOrig = ProjOrigin::None,
    boolean                     reverseCommittedCost=true
)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        ProjActivateTrans       transTurnover;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                projPost    = new ProjPostEmplJournalSaleAdj(_buffer, _tmpProjAdjustmentCreateSale);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                projPost.parmTransactionOrigin(ProjOrigin::HourJournal);
                projPost.parmLedgerOrigin(ProjOrigin::HourJournal);
                projTrans = ProjTrans::newProjTransEmplTransSaleAdj(_buffer, _tmpProjAdjustmentCreateSale);
                break;

            case tableNum(ProjRevenueTrans):
                projPost    = new ProjPostRevenueJournalSaleAdj(_buffer, _tmpProjAdjustmentCreateSale);
                projPost.parmTransactionOrigin(ProjOrigin::FeeJournal);
                projPost.parmLedgerOrigin(ProjOrigin::FeeJournal);
                projTrans = ProjTrans::newProjTransRevenueTransSaleAdj(_buffer, _tmpProjAdjustmentCreateSale);
                break;

            default:
                throw error("@SYS50155");
        }

        ProjWIPTable wipProject = projTrans.getWIPProject();

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                if(wipProject.IsContractLineUsed)
                {
                    if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeExpenseTrans)
                    {
                        transTurnover = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).PostWIPEmpl;
                    }
                }
                else
                {
                    transTurnover = ProjRevRecHelper::postWIPEmplForProject(ProjTable::find(projTrans.projId()));
                }
                
                projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
                projPost.parmEnterCost(false);
                break;

            case tableNum(ProjRevenueTrans):
                if(wipProject.IsContractLineUsed)
                {
                    if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeExpenseTrans)
                    {
                        transTurnover = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject).PostWIPEmpl;
                    }
                }
                else
                {
                    transTurnover = ProjRevRecHelper::postWIPFeeForProject(ProjTable::find(projTrans.projId()));
                }
                
                break;
        }

        if (_buffer.TableId == tableNum(ProjEmplTrans))
        {
            projPost.parmCommittedCostReverse(true);
        }

        projPost.parmEnterSalesAccrued(transTurnover);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);

        projPost.parmTransactionOrigin(_transactionOriginOrig);

        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateSale.FundingSource ) );
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItem</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItem(
    Common          _buffer,
    LedgerVoucher   _ledgerVoucher,
    ProjAdjustRefId _projAdjustRefId    = '',
    NoYes           _notReduceForecast  = false,
    InventTransId   _inventTransId      = '',
    SalesQty        _salesQty           = 0)
    {
        CustPackingSlipTrans    custPackingSlipTrans;
        InventJournalTrans      inventJournalTrans;
        ProjProposalItem        projProposalItem;
        ProdTable               prodTable;
        ProdTableProj           prodTableProj;
        ProdBOMTransProj        prodBOMTransProj;

        ProjPost                projPost;
        ProjActivateTrans       itemTransTurnover;
        ProjTrans               projTrans;
        ProjItemType            projItemType;
        ProjWIPTable wipProject;

        ProjLedgerStatus itemLedgerStatus;
        ProjTable projTableLoc;
        boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        switch (_buffer.TableId)
        {
            case tableNum(CustPackingSlipTrans):
                custPackingSlipTrans = _buffer;
                SalesLine salesLineLocal = custPackingSlipTrans.salesLine();
                projTrans = ProjTrans::newSalesLine(salesLineLocal);
                projPost = new ProjPostItemPackingSlip(custPackingSlipTrans);
                projTableLoc = ProjTable::find(projTrans.projId());
                wipProject = projTrans.getWIPProject();

                if(wipProject.IsContractLineUsed)
                {
                    if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
                    {
                        ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                        itemLedgerStatus =  ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
                    }
                }
                else if (!projTableLoc.ProjInvoiceProjId && enableProjMultipleContractLinesForProjectFeature)
                {
                    itemLedgerStatus = ProjLedgerStatus::Operations;
                }
                else
                {
                    itemLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTableLoc);
                }

                if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet
                    || (FeatureStateProvider::isFeatureEnabled(ProjEnableProfitAndLossItemReqConsumptionFlight::instance()) 
                        && salesLineLocal && salesLineLocal.SalesType == SalesType::ItemReq && !salesLineLocal.isStocked() && itemLedgerStatus == ProjLedgerStatus::Operations))
                {
                    projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
                }

                projPost.parmSalesQty(_salesQty);
                projPost.parmTransactionOrigin(ProjOrigin::ItemRequirement);
                projPost.parmLedgerOrigin(ProjOrigin::ItemRequirement);
                projPost.parmInventTransId(custPackingSlipTrans.InventTransId);
                projPost.parmUpdateTrans(true);

                if (ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled()) 
                {
                    ProjFundingSourceRefId projFundingSourceRefId = ProjPost::projFundingSourceRefIdForSalesLine(salesLineLocal);
                    projPost.parmFundingSourceList(ProjPost::createSplitList(projFundingSourceRefId));
                }
                break;

            case tableNum(ProjProposalItem):
                projTrans = ProjTrans::newProjProposalItem(_buffer);
                projProposalItem = _buffer;
                projItemType = projProposalItem.ItemType;
                projPost = new ProjPostItemProposal(_buffer);                
                projTableLoc = ProjTable::find(projTrans.projId());

                projPost.parmTransactionOrigin(ProjOrigin::SalesOrder);
                projPost.parmLedgerOrigin(ProjOrigin::SalesOrder);
                projPost.parmUpdateTrans(true);
                break;

            case tableNum(InventJournalTrans):
                inventJournalTrans = _buffer;
                projTrans = ProjTrans::newInventJournalTrans(inventJournalTrans);
                projPost = new ProjPostItemJournal(_buffer);
                projTableLoc = ProjTable::find(inventJournalTrans.ProjId);

                projPost.parmTransactionOrigin(ProjOrigin::ItemJournal);
                projPost.parmLedgerOrigin(ProjOrigin::ItemJournal);

                wipProject = projTrans.getWIPProject();

                if(wipProject.IsContractLineUsed)
                {
                    if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
                    {
                        ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                        itemLedgerStatus =  ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
                    }
                }
                else if (!projTableLoc.ProjInvoiceProjId && enableProjMultipleContractLinesForProjectFeature)
                {
                    itemLedgerStatus = ProjLedgerStatus::Operations;
                }
                else
                {
                    itemLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTableLoc);
                }

                if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
                {
                    projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
                }
                projPost.parmInventTransId(inventJournalTrans.InventTransId);
                projPost.parmUpdateTrans(true);
                break;

            case tableNum(ProdTableProj):
                prodTableProj = _buffer;
                prodTable = ProdTable::find(prodTableProj.ProdId);
                projTrans = ProjTrans::newProjTransProdInvent(prodTableProj, _inventTransId);
                projPost = new ProjPostItemJournal(_buffer);
                projTableLoc = ProjTable::find(projTrans.projId());

                wipProject = projTrans.getWIPProject();

                if(wipProject.IsContractLineUsed)
                {
                    if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
                    {
                        ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                        itemLedgerStatus =  ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
                    }
                }
                else if (!projTableLoc.ProjInvoiceProjId && enableProjMultipleContractLinesForProjectFeature)
                {
                    itemLedgerStatus = ProjLedgerStatus::Operations;
                }
                else
                {
                    itemLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTableLoc);
                }

                if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
                {
                    projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
                }
                projPost.parmInventTransId(_inventTransId);
                projPost.parmTransactionOrigin(ProjOrigin::ProductionConsumed);
                projPost.parmLedgerOrigin(ProjOrigin::ProductionConsumed);
                projPost.initUpdate();
                break;

            case tableNum(ProdBOMTransProj):
                prodBOMTransProj = _buffer;
                projTrans = ProjTrans::newProjTransProdBOMTransProj(prodBOMTransProj);
                projPost = new ProjPostItemJournal(_buffer);
                projTableLoc = ProjTable::find(projTrans.projId());

                wipProject = projTrans.getWIPProject();

                if (!projTableLoc.ProjInvoiceProjId && (wipProject.IsContractLineUsed || enableProjMultipleContractLinesForProjectFeature))
                {
                    itemLedgerStatus = ProjLedgerStatus::Operations;
                }
                else
                {
                    itemLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTableLoc);
                }

                if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
                {
                    projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
                }
                projPost.parmTransactionOrigin(ProjOrigin::ProductionConsumed);
                projPost.parmLedgerOrigin(ProjOrigin::ProductionConsumed);
                break;

            default :
                // Project posting is not implemented for this type.
                throw error("@SYS50155");
        }

        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans && projItemType != ProjItemType::SalesOrder)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                itemTransTurnover =  revProfile.PostWIPItem;
            }
            else
            {
                itemTransTurnover = NoYes::No;
            }
        }
        if ((projItemType && projItemType == ProjItemType::SalesOrder) ||
            (enableProjMultipleContractLinesForProjectFeature && !projTableLoc.ProjInvoiceProjId))
        {
            itemTransTurnover = NoYes::No;
        }
        else
        {
            itemTransTurnover = ProjRevRecHelper::postWIPItemForProject(projTableLoc);
        }
        projPost.parmEnterSalesAccrued(itemTransTurnover);

        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmNotForecastReduction(_notReduceForecast);
        projPost.parmCommittedCostReverse(true);
        projPost.parmCreateTrans(true);
        projPost.initIsContractLineUsed();


        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemCancel</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItemCancel(
        Common _buffer,
        LedgerVoucher _ledgerVoucher,
        ProjAdjustRefId _projAdjustRefId,
        SalesLine _salesLine,
        NoYes _notReduceForecast = false)
    {
        ProjPost projPost;
        
        if (_buffer.TableId == tableNum(ProjItemTrans))
        {
            ProjItemTrans projItemTrans = _buffer;
            ProjTrans projTrans = ProjTrans::newSalesLine(_salesLine);
            projPost = new ProjPostItemPackingSlipCancel(projItemTrans);

            ProjTable projTableLoc = ProjTable::find(projItemTrans.ProjId);
            boolean enableProjMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();
            ProjLedgerStatus itemLedgerStatus;

            if (!projTableLoc.ProjInvoiceProjId && enableProjMultipleContractLinesForProjectFeature)
            {
                itemLedgerStatus = ProjLedgerStatus::Operations;
            }
            else
            {
                itemLedgerStatus = ProjRevRecHelper::getItemLedgerStatus(projTableLoc);
            }
            
            if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet
                || (_salesLine && _salesLine.SalesType == SalesType::ItemReq && !_salesLine.isStocked() && itemLedgerStatus == ProjLedgerStatus::Operations
                    && FeatureStateProvider::isFeatureEnabled(ProjEnableProfitAndLossItemReqConsumptionFlight::instance())))
            {
                projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
            }
    
            projPost.parmTransactionOrigin(ProjOrigin::ItemRequirement);
            projPost.parmLedgerOrigin(ProjOrigin::ItemRequirement);
            projPost.parmInventTransId(projItemTrans.InventTransId);
            projPost.parmUpdateTrans(true);

            if (ProjItemRequirementMultipleFundingSourcesFeatureHelper::isFeatureEnabled())
            {
                ProjFundingSourceRefId projFundingSourceRefId = ProjPost::projFundingSourceRefIdForSalesLine(_salesLine);
                projPost.parmFundingSourceList(ProjPost::createSplitList(projFundingSourceRefId));
            }
            else
            {
                projPost.createFundingAllocationListBasedOnTrx(ProjTransType::Item);
            }

            ProjActivateTrans itemTransTurnover;
            if (enableProjMultipleContractLinesForProjectFeature && !projTableLoc.ProjInvoiceProjId)
            {
                itemTransTurnover = NoYes::No;
            }
            else
            {
                itemTransTurnover = ProjRevRecHelper::postWIPItemForProject(projTableLoc);
            }

            projPost.parmEnterSalesAccrued(itemTransTurnover);
            projPost.parmAdjustRefId(_projAdjustRefId);
            projPost.parmLedgerVoucher(_ledgerVoucher);
            projPost.parmNotForecastReduction(_notReduceForecast);
            projPost.parmCommittedCostReverse(true);
            projPost.parmCreateTrans(true);
        }
        else
        {
            // Project posting is not implemented for this type.
            throw error("@SYS50155");
        }

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projFundingSourceRefIdForSalesLine</Name>
				<Source><![CDATA[
    protected static ProjFundingSourceRefId projFundingSourceRefIdForSalesLine(SalesLine _salesLine)
    {
        ProjFundingSourceRefId projFundingSourceRefId = _salesLine.ProjFundingSource;
        //Ensure that funding source list contains only one funding source for packing slip posting
        if (!projFundingSourceRefId)
        {
            projFundingSourceRefId = _salesLine.salesTable().FundingSource;
        }
        if (!projFundingSourceRefId)
        {
            projFundingSourceRefId = _salesLine.projTable().getProjectDefaultInvoiceAccount(false);
            ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(ProjPost));
            using (var activityContext = logger.projOpsManagementActivity().projItemReqWithMultipleFundingSourcesContext())
            {
                logger.logInformation(strFmt("Posting packing slip - funding source not present on line and header. SalesLine: %1, Project funding source used: %2", int642str(_salesLine.RecId), int642str(projFundingSourceRefId)));
            }
        }
        return projFundingSourceRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemAdjust</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting an item adjustment to ledger entries.
    /// </summary>
    /// <param name="_buffer">
    ///    The table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger items for posting.
    /// </param>
    /// <param name="_reverseCommittedCost">
    ///    Whether to reverse the committed cost
    /// </param>
    /// <param name="_createTrans">
    ///    Creates a transaction; optional.
    /// </param>
    /// <param name="_enterSalesAccrued">
    ///    Indicates whether accrued revenue values are required; optional.
    /// </param>
    /// <param name="_enterCost">
    ///    Indicates whether cost values are required; optional.
    /// </param>
    /// <param name="_transId">
    ///    Identifier for the transaction that is being adjusted; optional.
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for adjustment of project item transactions.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the table TmpProjAdustmentCreate. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error: Project posting is not implemented
    ///    for this type.
    /// </remarks>

    public static ProjPost newCreateProjTransItemAdjust(
    Common          _buffer,
    LedgerVoucher   _ledgerVoucher,
    boolean         _reverseCommittedCost,
    boolean         _createTrans        = true,
    boolean         _enterSalesAccrued  = false,
    boolean         _enterCost          = false,
    ProjTransIdBase _transId            = ''
)
    {
        TmpProjAdjustmentCreate tmpProjAdjustmentCreate;
        ProjPost                projPost;

        ProjTrans               projTrans;
        ProjActivateTrans itemTransTurnover;
        ProjLedgerStatus itemLedgerStatus;

        switch (_buffer.TableId)
        {
            case tableNum(TmpProjAdjustmentCreate)  :
                tmpProjAdjustmentCreate = _buffer;
                projPost                = new ProjPostItemPackingSlip_Adj(_buffer);
                projPost.parmAdjustmentDate(tmpProjAdjustmentCreate.Transdate);
                projTrans               = ProjTrans::newTmpProjAdjustmentCreate(tmpProjAdjustmentCreate);
                break;

            default :
                throw error("@SYS50155");
        }
        ProjTable projTable = ProjTable::find(tmpProjAdjustmentCreate.ProjId);
        ProjWIPTable wipProject = projTrans.getWIPProject();

        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                itemTransTurnover = revProfile.PostWIPItem;
                itemLedgerStatus =  ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
            }
        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Item);
            itemTransTurnover = revProfile.PostWIPItem;
            itemLedgerStatus = ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
            itemTransTurnover = projGroup.ItemTransTurnover;
            itemLedgerStatus = projGroup.ItemTransCost;
        }

        projPost.parmEnterSalesAccrued(false);
        projPost.parmEnterCost(false);
        if (isConfigurationkeyEnabled(configurationKeyNum(Project)) && _enterCost)
        {
            if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
            {
                projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
            }
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_enterSalesAccrued && itemTransTurnover)
            {
                projPost.parmTransIdSales(_transId);
            }

            projPost.parmEnterSalesAccrued(itemTransTurnover);
        }
        projPost.parmLedgerVoucher(_ledgerVoucher);

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            projPost.parmCreateTrans(_createTrans);
        }
        else
        {
            projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
            projPost.parmCommittedCostReverse(_reverseCommittedCost);
            projPost.parmCreateTrans(true);
        }
        projPost.parmTransactionOrigin(ProjItemTrans::find(tmpProjAdjustmentCreate.TransID).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemAdjustNeg</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting a negative item adjustment to ledger entries.
    /// </summary>
    /// <param name="_buffer">
    ///    The table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger items for posting.
    /// </param>
    /// <param name="_projAdjustRefId">
    ///    The project identifier for adjustment posting. May be set to null. The default value is an empty string; optional.
    /// </param>
    /// <param name="_transId">
    ///    The identifier of the transaction to be adjusted; optional.
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for a negative adjustment for an inventory item.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the table TmpProjAdustmentCreate. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error: Project posting is not implemented
    ///    for this type.
    /// </remarks>
    public static ProjPost newCreateProjTransItemAdjustNeg(
    Common          _buffer,
    LedgerVoucher   _ledgerVoucher,
    ProjAdjustRefId _projAdjustRefId,
    ProjTransIdBase _transId
)
    {
        ProjPost    projPost;

        switch (_buffer.TableId)
        {
            case tableNum(TmpProjAdjustmentCreate)  :
                projPost = new ProjPostItemPackingSlip_AdjNeg(_buffer);
                projPost.parmCostUseOrig(false);
                projPost.parmsalesUseOrig(false);
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(false);
        projPost.parmEnterCost(false);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(false);

        projPost.parmCreateTrans(true);
        projPost.parmTransactionOrigin(ProjItemTrans::find(_transId).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemCostAdjustWithSameLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes a new instance of <c>ProjPostItemPackingSlip_Adj</c>
    /// and is used for creating adjusted stocked item transaction.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate"><c>TmpProjAdjustmentCreate</c> table buffer.</param>
    /// <param name = "_fundingSourceList">List of funding sources.</param>
    /// <param name = "_ledgerVoucher"><c>LedgerVoucher</c> object.</param>
    /// <param name = "_ledgerStatusCost"><c>ProjLedgerStatus</c> enum value.</param>
    /// <param name = "_costValueCURMultiplier">A value used to multiply transaction currency amount.</param>
    /// <returns><c>ProjPostItemPackingSlip_Adj</c> instance.</returns>
    public static ProjPost newCreateProjTransItemCostAdjustWithSameLedger(TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
																		  List                        _fundingSourceList,
																		  LedgerVoucher               _ledgerVoucher,
																	      Projledgerstatus            _ledgerStatusCost,
																		  int                         _costValueCURMultiplier=1)
    {
        ProjPostItemPackingSlip_Adj projPost = new ProjPostItemPackingSlip_Adj(_tmpProjAdjustmentCreate);
        projPost.parmLedgerStatusCost(_ledgerStatusCost);
        ProjTrans projTrans = projPost.parmProjTrans();
        if (_ledgerStatusCost == ProjLedgerStatus::BalanceSheet &&
                InventTable::modelGroupByItemId(projTrans.itemId()).PostOnhandFinancial)
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmEnterSalesAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(true);
        projPost.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);

        projPost.parmCreateTrans(false);
        projPost.parmTransactionOrigin(ProjItemTrans::find(_tmpProjAdjustmentCreate.TransID).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList(_fundingSourceList);
        projPost.parmCostValueCURMultiplier(_costValueCURMultiplier);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemCostAdjust</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItemCostAdjust(
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    List                        _fundingSourceList,
    LedgerVoucher               _ledgerVoucher,
    boolean                     _reverseCommittedCost=true,
    int                         _costValueCURMultiplier=1
)
    {
        ProjPostItemPackingSlip_Adj projPost;
        ProjLedgerStatus            ledgerStatusCost;
        ProjTrans                   projTrans;

        projPost = new ProjPostItemPackingSlip_Adj(_tmpProjAdjustmentCreate);
        projTrans = ProjTrans::newTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate);
        ProjWIPTable wipProject = projTrans.getWIPProject();
        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                if(ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus) == ProjLedgerStatus::BalanceSheet)
                {
                    projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
                }
            }
        }
        else  if (ProjRevRecHelper::getItemLedgerStatus(ProjTable::find(_tmpProjAdjustmentCreate.ProjId)) == ProjLedgerStatus::BalanceSheet)
        {
            projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
        }

        projPost.parmEnterSalesAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(true);
        projPost.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);

        projPost.parmCreateTrans(false);

        ProjItemTrans projItemTransOrig = ProjItemTrans::find(_tmpProjAdjustmentCreate.TransID);
        projPost.parmTransactionOrigin(projItemTransOrig.TransactionOrigin);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList(_fundingSourceList);
        projPost.parmCostValueCURMultiplier(_costValueCURMultiplier);
        projPost.initIsContractLineUsed();

        if (projPost.parmTransactionOrigin() == ProjOrigin::ItemRequirement)
        {
            // For each adjustment set ProjAdjustRefId on the project transaction 
            // if the root of adjustments was posted with item req feature on
            ProjItemTrans rootProjItemTrans;
            select firstonly RecId from rootProjItemTrans 
                where rootProjItemTrans.ProjTransIdRef == projItemTransOrig.ProjTransIdRef
                    && rootProjItemTrans.AdjRefTransId == ''
                    && rootProjItemTrans.TransIdPackSlip != '';

            if (rootProjItemTrans.RecId)
            {
                projPost.parmAdjustRefId(_tmpProjAdjustmentCreate.ProjAdjustRefId);
            }
        }

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemCostAdjustNegWithSameLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and initializes an instance of <c>ProjPostItemPackingSlip_AdjNeg</c>
    /// and honors the <c>ProjLedgerStatus</c> of the original transaction.
    /// </summary>
    /// <param name = "_tmpProjAdjustmentCreate"><c>TmpProjAdjustmentCreate</c> table buffer.</param>
    /// <param name = "_fundingSourceList">A list of funding sources.</param>
    /// <param name = "_ledgerVoucher"><c>LedgerVoucher</c> instance.</param>
    /// <param name = "_projAdjustRefId"><c>ProjAdjustRefId</c> of the item transaction.</param>
    /// <param name = "_transId">Transaction ID of the original transaction.</param>
    /// <param name = "_projLedgerStatus"><c>ProjLedgerStatus</c>of the original posted transaction.</param>
    /// <returns><c>ProjPostItemPackingSlip_AdjNeg</c> instance.</returns>
    public static ProjPost newCreateProjTransItemCostAdjustNegWithSameLedger(
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    List                        _fundingSourceList,
    LedgerVoucher               _ledgerVoucher,
    ProjAdjustRefId             _projAdjustRefId,
    ProjTransIdBase             _transId,
    ProjLedgerStatus            _projLedgerStatus)
    {
        ProjPost    projPost = new ProjPostItemPackingSlip_AdjNeg(_tmpProjAdjustmentCreate);
        ProjTrans   projTrans = ProjTrans::newTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate);

        if (projTrans.transCostBalance())
        {
            if (_projLedgerStatus == ProjLedgerStatus::BalanceSheet)
            {
                projPost.parmEnterCost(true);
            }
            projPost.parmLedgerStatusCost(_projLedgerStatus);
        }

        boolean costUseOrig = projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet ? true : false;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(costUseOrig);
        projPost.parmsalesUseOrig(false);

        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(false);

        projPost.parmCreateTrans(false);
        projPost.parmTransactionOrigin(ProjItemTrans::find(_transId).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList(_fundingSourceList);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemCostAdjustNeg</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItemCostAdjustNeg(
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    List                        _fundingSourceList,
    LedgerVoucher               _ledgerVoucher,
    ProjAdjustRefId             _projAdjustRefId,
    ProjTransIdBase             _transId
)
    {
        ProjPost    projPost = new ProjPostItemPackingSlip_AdjNeg(_tmpProjAdjustmentCreate);
        ProjTrans   projTrans = ProjTrans::newTmpProjAdjustmentCreate(_tmpProjAdjustmentCreate);

        if (projTrans.transCostBalance())
        {
            projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
        }

        boolean costUseOrig = projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet ? true : false;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(costUseOrig);
        projPost.parmsalesUseOrig(false);

        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(false);

        projPost.parmCreateTrans(false);
        projPost.parmTransactionOrigin(ProjItemTrans::find(_transId).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList(_fundingSourceList);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemSale</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItemSale(
    Common          _proposalBuffer,
    Common          _proposalDetailBuffer,
    Common          _transBuffer,
    Common          _transAmountBuffer,
    LedgerVoucher   _ledgerVoucher,
    ProjAdjustRefId _projAdjustRefId    = '',
    NoYes           _notReduceForecast  = false,
    InventTransId   _inventTransId      = '',
    SalesQty        _salesQty           = 0)
    {
        ProjProposalItem            projProposalItem;
        ProjProposalItemDetail      projProposalItemDetail;
        ProjItemTrans               projItemTrans;
        ProjItemTransSale           projItemTransSale;

        ProjPost                    projPost;
        ProjItemType                projItemType;
        ProjActivateTrans           itemTransTurnover;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjItemTransSale):
                projProposalItem = _proposalBuffer;
                projProposalItemDetail = _proposalDetailBuffer;
                projItemTrans = _transBuffer;
                projItemTransSale = _transAmountBuffer;

                projItemType            = projProposalItem.ItemType;
                projPost = new ProjPostItemProposalSale(projProposalItem, projProposalItemDetail, projItemTrans, projItemTransSale);
                projPost.parmTransactionOrigin(ProjOrigin::SalesOrder);
                projPost.parmLedgerOrigin(ProjOrigin::SalesOrder);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projItemTransSale.FundingSource ) );

                if(ProjBudgetUpdateBudgetForSalesOrderCreditNoteFlight::instance().isEnabled())
                {
                    projPost.parmSalesOrderCreditNote(projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal);
                }

                break;
            default :
                throw error("@SYS50155");
        }

        if (projItemType && projItemType == ProjItemType::SalesOrder)
        {
            itemTransTurnover = NoYes::No;
        }
        else
        {
            ProjWIPTable wipProject = projPost.parmProjTrans().getWIPProject();
            if(wipProject.IsContractLineUsed)
            {
                if(PSAContractLineItems::find(projItemTrans.PSAContractLineNum).IncludeItemTrans)
                {
                    ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                    itemTransTurnover =  revProfile.PostWIPItem;
                }
            }
            else
            {
                itemTransTurnover = ProjRevRecHelper::postWIPItemForProject(ProjTable::find(projProposalItem.projId()));
            }
        }
        projPost.parmEnterSalesAccrued(itemTransTurnover);

        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmNotForecastReduction(_notReduceForecast);
        projPost.parmCommittedCostReverse(true);
        projPost.parmCreateTrans(true);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemSaleAdjust</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItemSaleAdjust(
    ProjItemTrans               _projItemTransNew,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    LedgerVoucher               _ledgerVoucher,
    ProjTransIdBase             _transId,
    boolean                     _reverseCommittedCost=true
)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        ProjActivateTrans       itemTransTurnover;

        projPost = new ProjPostItemPackingSlipSale_Adj(_projItemTransNew, _tmpProjAdjustmentCreate, _tmpProjAdjustmentCreateSale);
        projTrans = ProjTrans::newTmpProjAdjustmentCreateSale(_tmpProjAdjustmentCreate, _tmpProjAdjustmentCreateSale);


        ProjWIPTable wipProject = projTrans.getWIPProject();
        
        if(wipProject.IsContractLineUsed && PSAContractLineItems::find(_projItemTransNew.PSAContractLineNum).IncludeItemTrans)
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
            itemTransTurnover =  revProfile.PostWIPItem;
        }
        
        else
        {
            itemTransTurnover = ProjRevRecHelper::postWIPItemForProject(ProjTable::find(_tmpProjAdjustmentCreate.ProjId));
        }
        if (itemTransTurnover)
        {
            projPost.parmTransIdSales(_transId);
        }

        projPost.parmEnterSalesAccrued(itemTransTurnover);
        projPost.parmEnterCost(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmCommittedCostReverse(true);
        projPost.parmAdjustmentDate(_tmpProjAdjustmentCreate.Transdate);

        projPost.parmCreateTrans(true);
        projPost.parmTransactionOrigin(ProjItemTrans::find(_tmpProjAdjustmentCreate.TransID).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateSale.FundingSource ) );
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCreateProjTransItemSaleAdjustNeg</Name>
				<Source><![CDATA[
    public static ProjPost newCreateProjTransItemSaleAdjustNeg(
    ProjItemTrans               _projItemTransNew,
    TmpProjAdjustmentCreate     _tmpProjAdjustmentCreate,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    LedgerVoucher               _ledgerVoucher,
    ProjAdjustRefId             _projAdjustRefId,
    ProjTransIdBase             _transId,
    RefRecId                    _saleRefRecId
)
    {
        ProjPost    projPost;
        boolean     enterSalesAccrued;
        boolean     salesUseOrig;
        ProjTrans   projTrans;

        projTrans = ProjTrans::newTmpProjAdjustmentCreateSale(_tmpProjAdjustmentCreate, _tmpProjAdjustmentCreateSale);

        enterSalesAccrued = ProjItemTransSale::find(_saleRefRecId).LedgerSalesPosted;

        projPost = new ProjPostItemPackingSlipSale_AdjNeg(_projItemTransNew, _tmpProjAdjustmentCreate, _tmpProjAdjustmentCreateSale);
        salesUseOrig = enterSalesAccrued;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(false);
        projPost.parmsalesUseOrig(salesUseOrig);

        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(enterSalesAccrued);
        projPost.parmEnterCost(false);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(false);

        projPost.parmCreateTrans(true);
        projPost.parmTransactionOrigin(ProjItemTrans::find(_transId).TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateSale.FundingSource ) );
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projPostCreating</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate for getting the new <c>ProjPost</c> instance.
    /// </summary>
    /// <param name = "_transBuffer">The table for transaction.</param>
    /// <param name = "_transAmountBuffer">The table for transaction amount.</param>
    /// <param name = "_ledgerVoucher">The ledger items for posting.</param>
    /// <param name = "_projLedgerStatusCost">The project ledger status.</param>
    /// <param name = "_ledgerOrigin">The project ledger origin.</param>
    /// <param name = "_elimination">Indicates if it is an elimination transaction.</param>
    /// <param name = "_checkCreditNoteItem">Indicates if it is a credit note item.</param>
    /// <param name = "_psaIndirectComponentTrans">A <c>PSAIndirectComponentTrans</c> record buffer.</param>
    /// <param name = "_result">An <c>EventHandlerResult</c> instance, where subscribers can provide the new <c>ProjPost</c> instance.</param>
    static delegate void projPostCreating(
    Common                      _transBuffer,
    Common                      _transAmountBuffer,
    LedgerVoucher               _ledgerVoucher,
    ProjLedgerStatus            _projLedgerStatusCost,
    ProjLedgerOrigin            _ledgerOrigin,
    boolean                     _elimination,
    boolean                     _checkCreditNoteItem,
    PSAIndirectComponentTrans   _psaIndirectComponentTrans,
    EventHandlerResult          _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterCost</Name>
				<Source><![CDATA[
    public static ProjPost newEnterCost(
    Common              _buffer,
    LedgerVoucher       _ledgerVoucher,
    ProjLedgerStatus    _projLedgerStatusCost,
    ProjLedgerOrigin    _ledgerOrigin,
    boolean             _elimination            = false,
    boolean             _checkCreditNoteItem    = false,
    Common              _tProjProposal          = null)

    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;
        ProjItemTransCost       projItemTransCost;

        switch (_buffer.TableId)
        {
            case tableNum(ProjCostTrans)             :
                projPost = new ProjPostCostTrans(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                break;
            case tableNum(ProjEmplTrans)             :
                projPost = new ProjPostEmplTrans(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                break;
            case tableNum(ProjItemTransCost)         :
                projPost = new ProjPostItemTransCost(_buffer);
                projPost.parmcheckCreditNoteItem(_checkCreditNoteItem);
                projItemTransCost = _buffer;
                transactionOrigin = ProjItemTrans::findInvent(projItemTransCost.InventTransId, projItemTransCost.ProjAdjustRefId).TransactionOrigin;
                break;
            default :
                throw error("@SYS50155");
        }

        projPost.parmEnterCost(true);
        projPost.parmLedgerStatusCost(_projLedgerStatusCost);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmUpdateTrans(true);

        projPost.parmElimination(_elimination);

        projPost.parmLedgerOrigin(_ledgerOrigin);
        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterCost_ProposalDetail</Name>
				<Source><![CDATA[
    public static ProjPost newEnterCost_ProposalDetail(
    Common          _proposalBuffer,
    Common          _proposalDetailBuffer,
    Common          _transBuffer,
    Common          _transAmountBuffer,
    LedgerVoucher   _ledgerVoucher,
    ProjTransStatus _saleProjTransStatus)
    {
        ProjPost                    projPost;

        ProjProposalEmpl            projProposalEmpl;
        ProjProposalEmplDetail      projProposalEmplDetail;
        ProjEmplTrans               projEmplTrans;
        ProjEmplTransCost           projEmplTransCost;

        ProjProposalCost            projProposalCost;
        ProjProposalCostDetail      projProposalCostDetail;
        ProjCostTrans               projCostTrans;
        ProjCostTransCost           projCostTransCost;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjEmplTransCost):
                projProposalEmpl = _proposalBuffer;
                projProposalEmplDetail = _proposalDetailBuffer;
                projEmplTrans = _transBuffer;
                projEmplTransCost = _transAmountBuffer;

                projPost = new ProjPostEmplProposalCost(projProposalEmpl, projProposalEmplDetail, projEmplTransCost, _saleProjTransStatus);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                projPost.parmTransactionOrigin(projEmplTrans.TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransCost.FundingSource ));
                projPost.parmSplitTransQtyCon( ProjFundingEngine::distributeQty(projEmplTrans.fundingSourceList(), projEmplTrans.Qty).pack() );
                break;

            case tableNum(ProjCostTransCost):
                projProposalCost = _proposalBuffer;
                projProposalCostDetail = _proposalDetailBuffer;
                projCostTrans = _transBuffer;
                projCostTransCost = _transAmountBuffer;

                projPost = new ProjPostCostProposalCost(projProposalCost, projProposalCostDetail, projCostTransCost, _saleProjTransStatus);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                projPost.parmTransactionOrigin(projCostTrans.TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransCost.FundingSource ));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmNotEnterNoneLedger(true);
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterCost_TrxDetail</Name>
				<Source><![CDATA[
    public static ProjPost newEnterCost_TrxDetail(
    Common              _transBuffer,
    Common              _transAmountBuffer,
    LedgerVoucher       _ledgerVoucher,
    ProjLedgerStatus    _projLedgerStatusCost,
    ProjLedgerOrigin    _ledgerOrigin,
    boolean             _elimination            = false,
    boolean             _checkCreditNoteItem    = false,
    PSAIndirectComponentTrans   _psaIndirectComponentTrans = null)

    {
        ProjPost                    projPost;
        ProjTransactionOrigin       transactionOrigin;

        ProjEmplTrans               projEmplTrans;
        ProjEmplTransCost           projEmplTransCost;

        ProjCostTrans               projCostTrans;
        ProjCostTransCost           projCostTransCost;

        ProjItemTrans               projItemTrans;
        ProjItemTransCost           projItemTransCost;

        PSAIndirectComponentTrans   psaIndirectComponentTrans;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjEmplTransCost)             :
                projEmplTrans = _transBuffer;
                projEmplTransCost = _transAmountBuffer;
                if (_psaIndirectComponentTrans)
                {
                    psaIndirectComponentTrans = _psaIndirectComponentTrans;
                    projPost = new ProjPostEmplTransIndirectCost(projEmplTrans, projEmplTransCost, psaIndirectComponentTrans);
                }
                else
                {
                    projPost = new ProjPostEmplTransCost(projEmplTrans, projEmplTransCost);
                }
                transactionOrigin = projEmplTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransCost.FundingSource ) );
                projPost.parmSplitTransQtyCon( ProjFundingEngine::distributeQty(projEmplTrans.fundingSourceList(), projEmplTrans.Qty).pack() );
                break;

            case tableNum(ProjCostTransCost)             :
                projCostTrans = _transBuffer;
                projCostTransCost = _transAmountBuffer;
                projPost = new ProjPostCostTransCost(projCostTrans, projCostTransCost);
                transactionOrigin = projCostTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransCost.FundingSource ) );
                break;

            case tableNum(ProjItemTransCost):
                projItemTrans = _transBuffer;
                projItemTransCost = _transAmountBuffer;
                projPost = new ProjPostItemTransCost(projItemTransCost);
                projPost.parmcheckCreditNoteItem(_checkCreditNoteItem);
                transactionOrigin = projItemTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projItemTransCost.FundingSource ) );
                break;

            default :
                var eventHandlerResult = new EventHandlerResult();
                ProjPost::projPostCreating(_transBuffer, 
                    _transAmountBuffer, 
                    _ledgerVoucher, 
                    _projLedgerStatusCost, 
                    _ledgerOrigin, 
                    _elimination, 
                    _checkCreditNoteItem,
                    _psaIndirectComponentTrans, 
                    eventHandlerResult);
                
                if (eventHandlerResult.hasResult())
                {
                    projPost = eventHandlerResult.result();
                }
                else
                {
                    throw error("@SYS50155");
                }
        }

        projPost.parmEnterCost(true);
        projPost.parmLedgerStatusCost(_projLedgerStatusCost);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmUpdateTrans(true);

        projPost.parmElimination(_elimination);

        projPost.parmLedgerOrigin(_ledgerOrigin);
        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterOnAcc</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting on-account ledger entries.
    /// </summary>
    /// <param name="_buffer">
    ///    The table for transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger items for posting.
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for posting on-account ledger entries for proposals.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the table ProjProposalOnAcc. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error: Project posting is not implemented for
    ///    this type.
    /// </remarks>
    public static ProjPost newEnterOnAcc(Common                 _buffer,
                                     LedgerVoucher      _ledgerVoucher)
    {
        ProjPost                projPost;
        ProjProposalOnAcc       projProposalOnAcc;

        switch (_buffer.TableId)
        {
            case tableNum(ProjProposalOnAcc)         :
                projPost = new ProjPostOnAccProposal       (_buffer);
                projProposalOnAcc = _buffer;
                projPost.parmTransactionOrigin(ProjOnAccTrans::find(projProposalOnAcc.TransId).TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterOnAccEstimate</Name>
				<Source><![CDATA[
    public static ProjPost newEnterOnAccEstimate(
    Common              _buffer,
    Common              _bufferDetail,
    LedgerVoucher       _ledgerVoucher,
    ProjPeriodTo        _periodWIP,
    boolean             _postAccrued,
    boolean             _reverse        = false,
    boolean             _eliminate      = false)
    {
        ProjPost                projPost;
        ProjInvoiceOnAcc        projInvoiceOnAcc;
        ProjInvoiceOnAccDetail  projInvoiceOnAccDetail;
        ProjOnAccTrans          projOnAccTrans;
        ProjOnAccTransSale      projOnAccTransSale;

        switch (_buffer.TableId)
        {
            case tableNum(ProjOnAccTrans)    :
                projOnAccTrans  = _buffer;
                projOnAccTransSale = _bufferDetail;
                projPost        = new ProjPostOnAccEstimate(projOnAccTrans, projOnAccTransSale);
                projPost.parmTransactionOrigin(projOnAccTrans.TransactionOrigin);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projOnAccTransSale.FundingSource ) );
                break;

            case tableNum(ProjInvoiceOnAcc)    :
                projInvoiceOnAcc = _buffer;
                projInvoiceOnAccDetail = _bufferDetail;
                projPost        = new ProjPostOnAccEstimate(projInvoiceOnAcc, projInvoiceOnAccDetail);
                projPost.parmTransactionOrigin(ProjOrigin::Milestone);
                projPost.parmFundingSourceList( ProjPost::createSplitList( ProjOnAccTransSale::find(projInvoiceOnAccDetail.SaleRefRecId).FundingSource ) );
                break;

            default                            :
                throw error("@SYS50155");
        }

        projPost.parmReverseAccrued(_reverse);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmPeriodWIP(_periodWIP);

        projPost.parmUpdateTrans(true);
        projPost.parmEnterAccruedOnAcc(_postAccrued);
        projPost.parmElimination(_eliminate);
        projPost.initIsContractLineUsed();

        if (_reverse && _eliminate)
        {
            projPost.parmLedgerOrigin(ProjOrigin::ReverseElimination);
        }
        else
        {
            if (_eliminate)
            {
                projPost.parmLedgerOrigin(ProjOrigin::EliminateEstimate);
            }
            else
            {
                if (_reverse)
                {
                    projPost.parmLedgerOrigin(ProjOrigin::ReverseEstimate);
                }
                else
                {
                    projPost.parmLedgerOrigin(ProjOrigin::PostEstimate);
                }
            }
        }

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterOnAccEstimateInvoice</Name>
				<Source><![CDATA[
    public static ProjPost newEnterOnAccEstimateInvoice(
    Common                  _tableBuffer,
    ProjInvoiceOnAccDetail  _projInvoiceOnAccDetail,
    ProjPeriodTo            _periodWIP)
    {
        ProjPost        projPost;

        switch (_tableBuffer.TableId)
        {
            case tableNum(ProjInvoiceOnAcc)    :
                projPost = new ProjPostOnAccEstimateInvoice(_tableBuffer, _projInvoiceOnAccDetail);
                projPost.parmTransactionOrigin(ProjOrigin::Milestone);
                projPost.parmLedgerOrigin(ProjOrigin::PostEstimate);
                projPost.parmFundingSourceList( ProjPost::createSplitList( ProjOnAccTransSale::find(_projInvoiceOnAccDetail.SaleRefRecId).FundingSource ) );
                break;

            default                            :
                throw error("@SYS50155");
        }

        projPost.parmPeriodWIP(_periodWIP);
        projPost.parmUpdateTrans(true);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterOnAccSale</Name>
				<Source><![CDATA[
    public static ProjPost newEnterOnAccSale(
    ProjProposalOnAcc       _projProposalOnAcc,
    ProjProposalOnAccDetail _projProposalOnAccDetail,
    ProjOnAccTrans          _projOnAccTrans,
    ProjOnAccTransSale      _projOnAccTransSale,
    LedgerVoucher           _ledgerVoucher
)
    {
        ProjPost    projPost;

        projPost = new ProjPostOnAccProposalSale(_projProposalOnAcc, _projProposalOnAccDetail, _projOnAccTransSale);
        projPost.parmTransactionOrigin(_projOnAccTrans.TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Invoice);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _projOnAccTransSale.FundingSource ) );
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterRevenueEstimate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a new instance of <c>ProjPost</c> for posting revenue estimates to ledger entries.
    /// </summary>
    /// <param name="_buffer">
    /// The table for the transaction type.
    /// </param>
    /// <param name="_bufferSale">
    /// The transaction sale amount table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger items for posting.
    /// </param>
    /// <param name="_reverse">
    /// Indicates if it is a reversing transaction; optional. The default value is false.
    /// </param>
    /// <param name="_eliminate">
    /// Indicates if it is an elimination transaction; optional. The default value is false.
    /// </param>
    /// <param name="_updateTrans">
    /// Indicates whether to call the <c>projUpdateTrans</c> method; optional.
    /// </param>
    /// <returns>
    /// A new <c>ProjPost</c> object for revenue estimates.
    /// </returns>
    /// <remarks>
    /// This method is only valid for the <c>ProjControlPeriodTrans</c> and <c>ProjRevenueTrans</c> tables.
    /// Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error:
    /// Project posting is not implemented for this type.
    /// </remarks>
    public static ProjPost newEnterRevenueEstimate(
    Common          _buffer,
    Common          _bufferSale,
    LedgerVoucher   _ledgerVoucher,
    boolean         _reverse     = false,
    boolean         _eliminate   = false,
    boolean         _updateTrans = false)

    {
        ProjId                  projId;
        ProjPost                projPost;
        ProjControlPeriodTrans  projControlPeriodTrans;
        ProjRevenueTrans        projRevenueTrans;
        ProjRevenueTransSale    projRevenueTransSale;
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransSale       projEmplTransSale;
        ProjCostTrans           projCostTrans;
        ProjCostTransSale       projCostTransSale;
        ProjItemTrans           projItemTrans;
        ProjItemTransSale       projItemTransSale;
        ProjWIPType             projWIPType;
        ProjOrigin              transactionOrigin;
        ProjWipTable            wipProject;
        ProjTable               projTable;

        switch (_buffer.TableId)
        {
            case tableNum(ProjControlPeriodTrans):
                projControlPeriodTrans  = _buffer;
                projId                  = projControlPeriodTrans.ProjId;
                projWIPType             = projControlPeriodTrans.wipType;
                transactionOrigin       = ProjOrigin::EstimateFee;
                break;

            case tableNum(ProjRevenueTrans):
                projRevenueTrans        = _buffer;
                projRevenueTransSale    = _bufferSale;
                projId                  = projRevenueTrans.ProjId;
                projWIPType             = projRevenueTransSale.wipType;
                transactionOrigin       = projRevenueTrans.TransactionOrigin;
                projTable = ProjTable::find(projId);

                break;

            case tableNum(ProjEmplTrans):
                projEmplTrans           = _buffer;
                projEmplTransSale       = _bufferSale;
                projId                  = projEmplTrans.ProjId;
                projWIPType             = projEmplTransSale.wipType;
                transactionOrigin       = projEmplTrans.TransactionOrigin;
                break;

            case tableNum(ProjCostTrans):
                projCostTrans           = _buffer;
                projCostTransSale       = _bufferSale;
                projId                  = projCostTrans.ProjId;
                projWIPType             = projCostTransSale.wipType;
                transactionOrigin       = projCostTrans.TransactionOrigin;
                break;

            case tableNum(ProjItemTrans):
                projItemTrans           = _buffer;
                projItemTransSale       = _bufferSale;
                projId                  = projItemTrans.ProjId;
                projWIPType             = projItemTransSale.wipType;
                transactionOrigin       = projItemTrans.TransactionOrigin;
                break;

            default :
                throw error("@SYS50155");
        }

        switch (projWIPType)
        {
            case ProjWIPType::AccruedTurnover      :
                projPost   = new ProjPostRevenueEstimate_Turnover(_buffer, _bufferSale);
                break;

            case ProjWIPType::AccruedTurnoverProd  :
                projPost   = new ProjPostRevenueEstimate_Prod(_buffer, _bufferSale);
                break;

            case ProjWIPType::AccruedTurnoverProfit:
                projPost   = new ProjPostRevenueEstimate_Profit(_buffer, _bufferSale);
                break;
            case ProjWIPType::Cost:
                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    projPost   = new ProjPostRevenueEstimate_Cost(_buffer, _bufferSale);
                }
                break;

            default:
                throw error("@SYS50155");
        }

        if (_reverse)
        {
            projPost.parmReverseAccrued(true);
        }

        projPost.parmTransactionOrigin(transactionOrigin);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmUpdateTrans(_reverse);
        projPost.parmEnterSalesAccrued(true);
        projPost.parmElimination(_eliminate);
        projPost.parmCreateTrans(!_reverse);
        projPost.parmUpdateTrans(_updateTrans);


        wipProject = projPost.parmProjTrans().getWIPProject();

        if (projPost.parmCreateTrans() && _eliminate)
        {
            if ((wipProject.IsContractLineUsed && ProjRevRecHelper::getCompletePrincipleContractLine(wipProject) == ProjCompletePrincip::CompletedPercentage )
                || ProjRevRecHelper::getCompletePrincipleForProject(projId) == ProjCompletePrincip::CompletedPercentage)
            {
                projPost.parmCreateTrans(false);
            }
        }

        if (_reverse && _eliminate)
        {
            projPost.parmLedgerOrigin(ProjOrigin::ReverseElimination);
        }
        else
        {
            if (_eliminate)
            {
                projPost.parmLedgerOrigin(ProjOrigin::EliminateEstimate);
            }
            else
            {
                if (_reverse)
                {
                    projPost.parmLedgerOrigin(ProjOrigin::ReverseEstimate);
                }
                else
                {
                    projPost.parmLedgerOrigin(ProjOrigin::PostEstimate);
                }
            }
        }
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterSalesAccrued_Proposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a new instance of the <c>ProjPost</c> object to use to post accrued revenue amounts to
    /// ledgers.
    /// </summary>
    /// <param name="_buffer">
    /// The table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger items to use to post.
    /// </param>
    /// <returns>
    /// A new <c>ProjPost</c> object for accrued revenue.
    /// </returns>
    /// <remarks>
    /// This method is only valid for the <c>ProjCostTrans</c> table, the <c>ProjEmplTrans</c> table, the
    /// <c>ProjRevenueTrans</c> table, the <c>ProjItemTrans</c> table, the <c>ProjPostEmplProposal</c>
    /// table, the <c>ProjProposalCost</c> table, the <c>ProjProposalRevenue</c> table, and the
    /// <c>ProjProposalItem</c> table. Any other table that is passed in the <paramref name="_buffer" />
    /// parameter will cause an exception: project posting is not implemented for this type.
    /// </remarks>
    public static ProjPost newEnterSalesAccrued_Proposal(
    Common          _buffer,
    LedgerVoucher   _ledgerVoucher)
    {
        ProjPost                    projPost;
        ProjProposalEmpl            projProposalEmpl;
        ProjProposalCost            projProposalCost;
        ProjProposalItem            projProposalItem;
        ProjProposalRevenue         projProposalRevenue;

        switch (_buffer.TableId)
        {
            case tableNum(ProjProposalEmpl)          :
                projPost = new ProjPostEmplProposal         (_buffer);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                projProposalEmpl = _buffer;
                projPost.parmTransactionOrigin(ProjEmplTrans::find(projProposalEmpl.TransId).TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                break;

            case tableNum(ProjProposalCost)          :
                projPost = new ProjPostCostProposal         (_buffer);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                projProposalCost = _buffer;
                projPost.parmTransactionOrigin(ProjCostTrans::find(projProposalCost.TransId).TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                break;

            case tableNum(ProjProposalRevenue)       :
                projPost = new ProjPostRevenueProposal      (_buffer);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                projProposalRevenue = _buffer;
                projPost.parmTransactionOrigin(ProjRevenueTrans::find(projProposalRevenue.TransId).TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                break;
            case tableNum(ProjProposalItem)          :
                projPost = new ProjPostItemProposal         (_buffer);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);
                projProposalItem = _buffer;
                projPost.parmTransactionOrigin(ProjItemTrans::find(projProposalItem.ProjTransId).TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmReverseAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterSalesAccrued_ProposalDetail</Name>
				<Source><![CDATA[
    public static ProjPost newEnterSalesAccrued_ProposalDetail(
    Common          _proposalBuffer,
    Common          _proposalDetailBuffer,
    Common          _transBuffer,
    Common          _transAmountBuffer,
    LedgerVoucher   _ledgerVoucher,
    boolean         _reverseAccrued)
    {
        ProjPost                    projPost;

        ProjProposalEmpl            projProposalEmpl;
        ProjProposalEmplDetail      projProposalEmplDetail;
        ProjEmplTrans               projEmplTrans;
        ProjEmplTransSale           projEmplTransSale;

        ProjProposalCost            projProposalCost;
        ProjProposalCostDetail      projProposalCostDetail;
        ProjCostTrans               projCostTrans;
        ProjCostTransSale           projCostTransSale;

        ProjProposalItem            projProposalItem;
        ProjProposalItemDetail      projProposalItemDetail;
        ProjItemTrans               projItemTrans;
        ProjItemTransSale           projItemTransSale;

        ProjProposalRevenue         projProposalRevenue;
        ProjProposalRevenueDetail   projProposalRevenueDetail;
        ProjRevenueTrans            projRevenueTrans;
        ProjRevenueTransSale        projRevenueTransSale;
        boolean                     accruedSubscription;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjEmplTransSale):
                projProposalEmpl = _proposalBuffer;
                projProposalEmplDetail = _proposalDetailBuffer;
                projEmplTrans = _transBuffer;
                projEmplTransSale = _transAmountBuffer;

                projPost = new ProjPostEmplProposalSale(projProposalEmpl, projProposalEmplDetail, projEmplTransSale);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);

                if (_reverseAccrued)
                {
                    projPost.parmEnterSalesAccrued(true);
                    projPost.parmAdjustmentLedgerSalesAmount(projEmplTransSale.LedgerSalesPosted ? projEmplTransSale.LineAmount : 0);
                }

                projPost.parmTransactionOrigin(projEmplTrans.TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                projPost.parmReverseAccrued(_reverseAccrued);
                projPost.parmUseTransCurrReverseAccrued(_reverseAccrued);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransSale.FundingSource ) );
                projPost.parmSplitTransQtyCon( ProjFundingEngine::distributeQty(projEmplTrans.fundingSourceList(), projEmplTrans.Qty).pack() );
                break;

            case tableNum(ProjCostTransSale):
                projProposalCost = _proposalBuffer;
                projProposalCostDetail = _proposalDetailBuffer;
                projCostTrans = _transBuffer;
                projCostTransSale = _transAmountBuffer;

                projPost = new ProjPostCostProposalSale(projProposalCost, projProposalCostDetail, projCostTransSale);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);

                if (_reverseAccrued)
                {
                    projPost.parmEnterSalesAccrued(true);
                    projPost.parmAdjustmentLedgerSalesAmount(projCostTransSale.LedgerSalesPosted ? projCostTransSale.LineAmount : 0);
                }

                projPost.parmTransactionOrigin(projCostTrans.TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                projPost.parmReverseAccrued(_reverseAccrued);
                projPost.parmUseTransCurrReverseAccrued(_reverseAccrued);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransSale.FundingSource ) );
                break;

            case tableNum(ProjItemTransSale):
                projProposalItem = _proposalBuffer;
                projProposalItemDetail = _proposalDetailBuffer;
                projItemTrans = _transBuffer;
                projItemTransSale = _transAmountBuffer;

                projPost = new ProjPostItemProposalSale(projProposalItem, projProposalItemDetail, projItemTrans, projItemTransSale);
                projPost.parmCreateTrans(true);
                projPost.parmUpdateTrans(true);

                if (_reverseAccrued)
                {
                    projPost.parmEnterSalesAccrued(true);
                    projPost.parmAdjustmentLedgerSalesAmount(projItemTransSale.LedgerSalesPosted ? projItemTransSale.LineAmount : 0);
                }

                projPost.parmTransactionOrigin(projItemTrans.TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                projPost.parmReverseAccrued(_reverseAccrued);
                projPost.parmUseTransCurrReverseAccrued(_reverseAccrued);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projItemTransSale.FundingSource ) );
                break;

            case tableNum(ProjRevenueTransSale):
                projProposalRevenue = _proposalBuffer;
                projProposalRevenueDetail = _proposalDetailBuffer;
                projRevenueTrans = _transBuffer;
                projRevenueTransSale = _transAmountBuffer;

                projPost = new ProjPostRevenueProposalSale(projProposalRevenue, projProposalRevenueDetail, projRevenueTransSale);
                projPost.parmCreateTrans(true);

                if (projRevenueTrans.smaSubscriptionId)
                {
                    if (SMASubscriptionTable::find(projRevenueTrans.smaSubscriptionId).canBeAccrued())
                    {
                        accruedSubscription = true;
                    }
                }

                projPost.parmUpdateTrans(true);

                if (_reverseAccrued || accruedSubscription)
                {
                    projPost.parmEnterSalesAccrued(true);
                }

                projPost.parmTransactionOrigin(projRevenueTrans.TransactionOrigin);
                projPost.parmLedgerOrigin(ProjOrigin::Invoice);
                projPost.parmReverseAccrued(_reverseAccrued);
                if (_reverseAccrued)
                {
                    if (!accruedSubscription)
                    {
                        projPost.parmAdjustmentLedgerSalesAmount(projRevenueTransSale.LedgerSalesPosted ? projRevenueTransSale.LineAmount : 0);
                    }
                    projPost.parmUseTransCurrReverseAccrued(_reverseAccrued);
                }
                projPost.parmFundingSourceList( ProjPost::createSplitList( projRevenueTransSale.FundingSource ) );

                if (projPost.parmTransactionOrigin() == ProjOrigin::FreeTextInvoice)
                {
                    projPost.parmEnterSalesAccrued(false);
                }
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterSalesAccrued_TrxDetail</Name>
				<Source><![CDATA[
    public static ProjPost newEnterSalesAccrued_TrxDetail(
    Common          _transBuffer,
    Common          _transAmountBuffer,
    LedgerVoucher   _ledgerVoucher,
    boolean         _reverseAccrued)
    {
        ProjPost                    projPost;
        ProjTransactionOrigin       transactionOrigin;

        ProjEmplTrans               projEmplTrans;
        ProjEmplTransSale           projEmplTransSale;

        ProjCostTrans               projCostTrans;
        ProjCostTransSale           projCostTransSale;

        ProjItemTrans               projItemTrans;
        ProjItemTransSale           projItemTransSale;

        ProjRevenueTrans            projRevenueTrans;
        ProjRevenueTransSale        projRevenueTransSale;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjEmplTransSale)             :
                projEmplTrans = _transBuffer;
                projEmplTransSale = _transAmountBuffer;
                projPost = new ProjPostEmplTransSale(projEmplTrans, projEmplTransSale);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                transactionOrigin = projEmplTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransSale.FundingSource ) );
                projPost.parmSplitTransQtyCon( ProjFundingEngine::distributeQty(projEmplTrans.fundingSourceList(), projEmplTrans.Qty).pack() );
                break;

            case tableNum(ProjCostTransSale)             :
                projCostTrans = _transBuffer;
                projCostTransSale = _transAmountBuffer;
                projPost = new ProjPostCostTransSale(projCostTrans, projCostTransSale);
                transactionOrigin = projCostTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransSale.FundingSource ) );
                break;

            case tableNum(ProjItemTransSale)             :
                projItemTrans = _transBuffer;
                projItemTransSale = _transAmountBuffer;
                projPost = new ProjPostItemTransSale(projItemTrans, projItemTransSale);
                transactionOrigin = projItemTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projItemTransSale.FundingSource ) );
                break;

            case tableNum(ProjRevenueTransSale)          :
                projRevenueTrans = _transBuffer;
                projRevenueTransSale = _transAmountBuffer;
                projPost = new ProjPostRevenueTransSale(projRevenueTrans, projRevenueTransSale);
                transactionOrigin = projRevenueTrans.TransactionOrigin;
                projPost.parmFundingSourceList( ProjPost::createSplitList( projRevenueTransSale.FundingSource ) );
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);
        
        // Allow to post accrued revenue transactions when journal transactions are posted from accrued revenue with project group where accrue revenue is not marked.
        if (_reverseAccrued
            && projRevenueTrans.PSAContractLineNum
            && projRevenueTransSale
            && projRevenueTransSale.TransStatus == ProjTransStatus::InvoiceProposal)
        {
            projPost.parmEnterSalesAccrued(projRevenueTransSale.LedgerSalesPosted);
        }
        else
        {
            projPost.parmEnterSalesAccrued(true);
        }
        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::AccrueRevenue);
        projPost.parmReverseAccrued(_reverseAccrued);
        projPost.parmUseTransCurrReverseAccrued(_reverseAccrued);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newEnterSMAAccrued</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting service agreement amounts to ledgers.
    /// </summary>
    /// <param name="_buffer">
    ///    The table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    The ledger items for posting.
    /// </param>
    /// <param name="_reverseAccrued">
    ///    The reverse accrued revenue.
    /// </param>
    /// <param name="_postingDate">
    ///    The posting date of the transaction.
    /// </param>
    /// <param name="_updateTrans">
    ///    Indicates whether to call the <c>projTransUpdate</c> method; optional.
    /// </param>
    /// <param name="_accrueAmount">
    ///    The accrued revenue amount in the originating currency; optional.
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for the service agreement.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the table SMAAccruePeriodLine. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the error: Project posting is not implemented for
    ///    this type.
    /// </remarks>
    public static ProjPost newEnterSMAAccrued(
    Common          _buffer,
    LedgerVoucher   _ledgerVoucher,
    boolean         _reverseAccrued,
    TransDate       _postingDate,
    boolean         _updateTrans     = true,
    AmountMST       _accrueAmount    = 0)
    {
        ProjPostRevenueSMAAccrueLines           projPost;
        SMAAccruePeriodLine                     smaAccruePeriodLine;
        ProjFundingSourceRefId                  fundingSource;

        switch (_buffer.TableId)
        {
            case tableNum(SMAAccruePeriodLine) :
                smaAccruePeriodLine = _buffer as SMAAccruePeriodLine;
                projPost = new ProjPostRevenueSMAAccrueLines(_buffer);

                fundingSource = ProjTable::find(smaAccruePeriodLine.projId()).defaultFundingSource();
                projPost.parmFundingSourceList( ProjPost::createSplitList( fundingSource ));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(_updateTrans);
        projPost.parmEnterSalesAccrued(true);
        projPost.parmReverseAccrued(_reverseAccrued);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSMAPostingDate(_postingDate);
        projPost.parmAccrueAmount(_accrueAmount);

        projPost.parmTransactionOrigin(ProjOrigin::Subscription);
        projPost.parmLedgerOrigin(ProjOrigin::AccrueSubscriptionRev);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventNeverLedger</Name>
				<Source><![CDATA[
    public static ProjPost newInventNeverLedger(
    InventTrans inventTrans,
    TransDate   transDate,
    Voucher     voucher,
    AmountMST   amountMST,
    boolean     inventAdj   = false,
    ProjItemTransCostType   projItemTransCostType = ProjItemTransCostType::Cost)
    {
        ProjPostItemInventNoLedger   projPost;

        projPost                = new ProjPostItemInventNoLedger(inventTrans);

        projPost.parmNeverLedgerCostAmount(-amountMST);
        projPost.parmNeverLedgerTransDate(transDate);
        projPost.parmNeverLedgerVoucher(voucher);
        projPost.parmCreateTrans(true);
        projPost.parminventAdjust(inventAdj);
        projPost.parmProjItemTransCostType(projItemTransCostType);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventNeverLedger2</Name>
				<Source><![CDATA[
    public static ProjPost newInventNeverLedger2(
    InventTransId           inventTransId,
    ProjAdjustRefId         projAdjustRefId,
    ProjId                  projId,
    TransDate               transDate,
    Voucher                 voucher,
    AmountMST               amountMST,
    boolean                 inventAdj   = false,
    ProjItemTransCostType   projItemTransCostType = ProjItemTransCostType::Cost)
    {
        ProjPostItemInventNoLedger   projPost;
        InventTrans                  inventTrans;

        projPost                = new ProjPostItemInventNoLedger(inventTrans);

        projPost.parmInventTransId(inventTransId);
        projPost.parmProjAdjustRefId(projAdjustRefId);
        projPost.parmProjId(projId);

        projPost.parmNeverLedgerCostAmount(-amountMST);
        projPost.parmNeverLedgerTransDate(transDate);
        projPost.parmNeverLedgerVoucher(voucher);

        projPost.parmCreateTrans(true);
        projPost.parminventAdjust(inventAdj);
        projPost.parmProjItemTransCostType(projItemTransCostType);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventUpd_Financial</Name>
				<Source><![CDATA[
    public static ProjPost newInventUpd_Financial(
    InventUpd_Financial _financial,
    LedgerVoucher       _ledgerVoucher,
    ProjAdjustRefId     _projAdjustRefId = '',
    boolean             _negRec             = false,
    InventTransId       _inventTransId      = '',
    NoYes               _notReduceForecast  = false
    )
    {
        ProjPost projPost = ProjPostItemInventUpd_Financial::newProjPostItemInventUpd_Financial(_financial, _projAdjustRefId);
        ProjTrans projtrans = ProjTrans::newInventUpd_Financial(_financial, _projAdjustRefId);

        ProjActivateTrans itemTransTurnover;
        ProjLedgerStatus itemLedgerStatus;
        
        ProjTable projTable = ProjTable::find(_financial.movement().projId());
        if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            if (!projTable.ProjInvoiceProjId)
            {
                // Internal project, post cost to P/L accounts.
                itemTransTurnover = NoYes::No;
                itemLedgerStatus = ProjLedgerStatus::Operations;
            }
            else
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Item);
                itemTransTurnover = revProfile.PostWIPItem;
                itemLedgerStatus = ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
            }
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
            itemTransTurnover = projGroup.ItemTransTurnover;
            itemLedgerStatus = projGroup.ItemTransCost;
        }


        if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
        {
            projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
        }

        projPost.parmInventTransId(_inventTransId);
        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(itemTransTurnover);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCommittedCostReverse(true);
        projPost.parmNotForecastReduction(_notReduceForecast);
        projPost.parmCreateTrans(true);
        projPost.parmUpdateTrans(true);
        projPost.parmTransactionOrigin(_financial.movement().projTransactionOrigin());
        projPost.parmLedgerOrigin(_financial.movement().projLedgerOrigin());

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventUpd_Physical</Name>
				<Source><![CDATA[
    public static ProjPost newInventUpd_Physical(
    InventUpd_Physical  _physical,
    LedgerVoucher       _ledgerVoucher,
    ProjAdjustRefId     _projAdjustRefId = '',
    boolean             _negRec             = false,
    InventTransId       _inventTransId      = ''
    )
    {
        ProjPost projPost = ProjPostItemInventUpd_Physical::newProjPostItemInventUpd_Physical(_physical, _ledgerVoucher);
        ProjTrans projTrans = ProjTrans::newInventUpd_Physical(_physical, _ledgerVoucher);

        ProjActivateTrans itemTransTurnover;
        ProjLedgerStatus itemLedgerStatus;
        
        ProjTable projTable = ProjTable::find(_physical.movement().projId());
        ProjWIPTable wipProject = projPost.parmProjTrans().getWIPProject();
        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                itemTransTurnover = revProfile.PostWIPItem;
                itemLedgerStatus =  ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
            }

        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Item);
            itemTransTurnover = revProfile.PostWIPItem;
            itemLedgerStatus = ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
            itemTransTurnover = projGroup.ItemTransTurnover;
            itemLedgerStatus = projGroup.ItemTransCost;
        }

        if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
        {
            projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
        }

        projPost.parmInventTransId(_inventTransId);
        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(itemTransTurnover);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmTransactionOrigin(_physical.movement().projTransactionOrigin());
        projPost.parmLedgerOrigin(_physical.movement().projLedgerOrigin());

        projPost.parmCommittedCostReverse(true);
        projPost.parmUpdateTrans(true);
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventUpd_PhysicalAdjust</Name>
				<Source><![CDATA[
    public static ProjPost newInventUpd_PhysicalAdjust(
    InventMovement      _movement,
    LedgerVoucher       _ledgerVoucher,
    Qty                 _qty,
    Amount              _transCost,
    ProjAdjustRefId     _projAdjustRefId = '',
    boolean             _negRec             = false,
    InventTransId       _inventTransId      = ''
    )
    {
        ProjPost projPost = ProjPostItemInventUpd_PhysicalAdjust::newProjPostItemInventUpd_PhyAdjust(_movement, _ledgerVoucher, _qty, _transCost);
        ProjTrans projTrans  = ProjTrans::newInventMovement(_movement, _ledgerVoucher, _qty, _transCost);
        
        ProjActivateTrans itemTransTurnover;
        ProjLedgerStatus itemLedgerStatus;
        
        ProjTable projTable = ProjTable::find(_movement.projId());
        ProjWIPTable wipProject = projTrans.getWIPProject();
        if(wipProject.IsContractLineUsed)
        {
            if(PSAContractLineItems::find(projTrans.psaContractLineNum()).IncludeItemTrans)
            {
                ProjRevenueProfile revProfile = ProjRevRecHelper::getProfileForRevRecProjectContractLine(wipProject);
                itemTransTurnover = revProfile.PostWIPItem;
                itemLedgerStatus =  ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
            }

        }
        else if (ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled())
        {
            ProjRevenueProfile revProfile = ProjRevRecHelper::getRevProfileForTransactionType(projTable, ProjTransType::Item);
            itemTransTurnover = revProfile.PostWIPItem;
            itemLedgerStatus = ProjRevRecHelper::item2LedgerStatus(revProfile.ItemLedgerStatus);
        }
        else
        {
            ProjGroup projGroup = ProjGroup::find(projTable.ProjGroupId);
            itemTransTurnover = projGroup.ItemTransTurnover;
            itemLedgerStatus = projGroup.ItemTransCost;
        }

        if (itemLedgerStatus == ProjLedgerStatus::BalanceSheet)
        {
            projPost.initializeLedgerStatusCostAndEnterCost(projTrans);
        }

        projPost.parmInventTransId(_inventTransId);
        projPost.parmAdjustRefId(_projAdjustRefId);
        projPost.parmEnterSalesAccrued(itemTransTurnover);
        projPost.parmCreateTrans(false);
        projPost.parmCommittedCostReverse(false);

        projPost.parmTransactionOrigin(ProjOrigin::ProductionConsumed);
        projPost.parmLedgerOrigin(ProjOrigin::ProductionConsumed);

        if (_inventTransId && _projAdjustRefId && _ledgerVoucher)
        {
            projPost.parmFundingSourceList(ProjItemTrans::findInvent(_inventTransId, _projAdjustRefId).fundingSourceList(_ledgerVoucher.lastVoucher()));
        }

        projPost.parmUpdateTrans(true);
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdCheckTrans</Name>
				<Source><![CDATA[
    public static ProjPost newProdCheckTrans(ProdJournalRoute     _prodJournalRoute,
                                         ProdJournalRouteProj _prodJournalRouteProj)
    {
        ProjPostEmplJournal projPost;

        projPost = new ProjPostEmplJournal(_prodJournalRouteProj);

        projPost.parmCreateTrans(false);
        projPost.parmUpdateTrans(false);

        projPost.parmProdJournalRoute(_prodJournalRoute);
        projPost.initUpdate();
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjPostItemSalesLine</Name>
				<Source><![CDATA[
    static ProjPost newProjPostItemSalesLine(
    SalesLine _salesLine)
    {
        ProjPost projPost;

        projPost = new ProjPost(_salesLine);
        projPost.parmSalesLine(_salesLine);
        projPost.initSalesLine();
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjTrans_TrxDetail</Name>
				<Source><![CDATA[
    public static ProjPost newProjTrans_TrxDetail(
    Common              _transBuffer,
    Common              _transAmountBuffer,
    ProjLedgerStatus    _projLedgerStatus
)
    {
        ProjPost                projPost;
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransCost       projEmplTransCost;
        ProjCostTrans           projCostTrans;
        ProjCostTransCost       projCostTransCost;
        ProjItemTrans           projItemTrans;
        ProjItemTransCost       projItemTransCost;

        switch (_transAmountBuffer.TableId)
        {
            case tableNum(ProjEmplTransCost)             :
                projEmplTrans = _transBuffer;
                projEmplTransCost = _transAmountBuffer;
                projPost = new ProjPostEmplTransCost(projEmplTrans, projEmplTransCost);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransCost.FundingSource ) );
                break;

            case tableNum(ProjCostTransCost)        :
                projCostTrans = _transBuffer;
                projCostTransCost = _transAmountBuffer;
                projPost = new ProjPostCostTransCost(projCostTrans, projCostTransCost);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projCostTransCost.FundingSource ) );
                break;

            case tableNum(ProjItemTransCost)    :
                projItemTrans = _transBuffer;
                projItemTransCost = _transAmountBuffer;
                projPost = new ProjPostItemTransCost(projItemTransCost);
                projPost.parmFundingSourceList( ProjPost::createSplitList( projItemTransCost.FundingSource ) );
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmLedgerStatusCost(_projLedgerStatus);
        projPost.parmUpdateTrans(true);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdj</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a new instance of <c>ProjPost</c> for posting adjustment transactions to ledger entries.
    /// </summary>
    /// <param name="_buffer">
    ///    The table for the transaction type.
    /// </param>
    /// <param name="_adjDate">
    ///    Date of the adjusted transaction
    /// </param>
    /// <returns>
    ///    A new <c>ProjPost</c> object for adjustment transactions.
    /// </returns>
    /// <remarks>
    ///    This method is only valid for the tables ProjCostTrans, ProjEmplTrans, ProjRevenueTrans, and ProjItemTrans. Any other table that is passed in the <paramref name="_buffer" /> parameter will throw the
    ///    error: Project posting is not implemented for this type.
    /// </remarks>
    public static ProjPost newTransAdj(Common _buffer,
                                   TransDate _adjDate=DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))

    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;

        switch (_buffer.TableId)
        {
            case tableNum(ProjCostTrans):
                projPost = new ProjPostCostTrans_Adj(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                break;

            case tableNum(ProjEmplTrans):
                projPost = new ProjPostEmplTrans_Adj(_buffer);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                break;

            case tableNum(ProjRevenueTrans):
                projPost = new ProjPostRevenueTrans_Adj(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjRevenueTrans,TransactionOrigin)));
                break;

            case tableNum(ProjItemTrans):
                projPost = new ProjPostItemTrans_Adj(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjItemTrans,TransactionOrigin)));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);
        projPost.parmAdjustmentDate(_adjDate);
        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjCost</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjCost(Common _buffer, Common _bufferDetail, ProjTrans _projTrans=null)

    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;
        ProjFundingSourceRefId  fundingSourceId;

        switch (_bufferDetail.TableId)
        {
            case tableNum(ProjCostTransCost):
                projPost = new ProjPostCostTransCost_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjCostTransCost,FundingSource)));
                break;

            case tableNum(ProjEmplTransCost):
                projPost = new ProjPostEmplTransCost_Adj(_buffer, _bufferDetail);
                projPost.parmNotEnterNoneLedger(true);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjEmplTransCost,FundingSource)));
                break;

            case tableNum(ProjItemTransCost):
                projPost = new ProjPostItemTransCost_Adj(_bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjItemTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjItemTransCost,FundingSource)));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);

        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        if (_projTrans)
        {
            projPost.parmTransStatus(_projTrans.parmAdjustmentStatus());
        }

        projPost.parmFundingSourceList( ProjPost::createSplitList( fundingSourceId ));
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeJournalDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Delegate for getting a new instance of <c>ProjPost</c> for posting negative adjustment journal.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///     The ledger items for posting.
    /// </param>
    /// <param name = "_transId">
    ///     Identifier for the transaction that is being adjusted.
    /// </param>
    /// <param name = "_transactionOriginOrig">
    ///     The value of transaction origin.
    /// </param>
    /// <param name = "_adjustmentDate">
    ///     The value of adjustment date.
    /// </param>
    /// <param name = "_eventHandlerResult">
    ///     An <c>EventHandlerResult</c> instance, where subscribers can provide default <c>ProjPost</c> object for posting negative adjustment journal.
    /// </param>
    static delegate void newTransAdjNegativeJournalDelegate(
        Common _buffer,
        LedgerVoucher _ledgerVoucher,
        ProjTransIdBase _transId,
        ProjTransactionOrigin _transactionOriginOrig,
        TransDate _adjustmentDate,
        EventHandlerResult _eventHandlerResult)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns a new instance of <c>ProjPost</c> for posting negative adjustment journal.
    /// </summary>
    /// <param name = "_buffer">
    ///     The table for the transaction type.
    /// </param>
    /// <param name = "_ledgerVoucher">
    ///     The ledger items for posting.
    /// </param>
    /// <param name = "_transId">
    ///     Identifier for the transaction that is being adjusted.
    /// </param>
    /// <param name = "_transactionOrigin">
    ///     The value of transaction origin.
    /// </param>
    /// <param name = "adjustmentDate">
    ///     The value of adjustment date.
    /// </param>
    /// <returns>
    ///     A new <c>ProjPost</c> object for negative adjustment journal.
    /// </returns>
    public static ProjPost newTransAdjNegativeJournal(
        Common                  _buffer,
        LedgerVoucher           _ledgerVoucher,
        ProjTransIdBase         _transId,
        ProjTransactionOrigin   _transactionOrigin,
        TransDate               adjustmentDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))

    {
        ProjPost                projPost;
        ProjJournalTrans        projJournalTrans;
        ProjJournalType         journalType;
        ProjEmplTrans           projEmplTrans;
        ProjEmplTransCost       projEmplTransCost;
        ProjRevenueTrans        projRevenueTrans;
        ProjRevenueTransSale    projRevenueTransSale;

        projJournalTrans   = _buffer;
        journalType        = ProjJournalTable::find(projJournalTrans.JournalId).JournalType;

        switch (journalType)
        {
            case ProjJournalType::Hour:
                projPost = new ProjPostEmplJournal(_buffer);
                break;

            case ProjJournalType::Revenue:
                projPost = new ProjPostRevenueJournal(_buffer, _transId ? ProjRevenueTrans::find(_transId).PSAContractLineNum : '');
                break;

            default:
                EventHandlerResult result = new EventHandlerResult();
                ProjPost::newTransAdjNegativeJournalDelegate(_buffer, _ledgerVoucher, _transId, _transactionOrigin, adjustmentDate, result);
                if(result.hasResult())
                {
                    projPost = result.result() as ProjPost;
                }
                else
                {
                    throw error("@SYS50155");
                }
        }

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(false);
        projPost.parmsalesUseOrig(false);
        projPost.parmEnterSalesAccrued(false);
        projPost.parmReverseAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(0);
        projPost.parmNotEnterNoneLedger(true);
        projPost.parmNotEnterNeverLedger(true);
        projPost.parmEnterCost(false);

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);

            projEmplTrans = ProjEmplTrans::find(_transId);
            select firstonly TransStatus from projEmplTransCost where projEmplTransCost.TransId == projEmplTrans.TransId;
            if (projEmplTrans)
            {
                if (projEmplTransCost.TransStatus == ProjTransStatus::Posted &&
                projEmplTrans.TransDate == adjustmentDate)
                {
                    projPost.parmTransStatus(ProjTransStatus::Adjusted);
                }
                else
                {
                    projPost.parmTransStatus(ProjTransStatus::Posted);
                }
            }
            projRevenueTrans = ProjRevenueTrans::find(_transId);
            select firstonly TransStatus from projRevenueTransSale where projRevenueTransSale.TransId == projRevenueTrans.TransId;
            if (projRevenueTrans)
            {
                if (projRevenueTransSale.TransStatus == ProjTransStatus::Posted &&
                projRevenueTrans.TransDate == adjustmentDate)
                {
                    projPost.parmTransStatus(ProjTransStatus::Adjusted);
                }
                else
                {
                    projPost.parmTransStatus(ProjTransStatus::Posted);
                }
            }
        }
        else
        {
            projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
            projPost.parmTransStatus(ProjTransStatus::Adjusted);
        }
        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmTransactionOrigin(_transactionOrigin);
        projPost.parmTransactionOriginOrig(_transactionOrigin);
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeJournalCost</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNegativeJournalCost(
    Common                      _buffer,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    boolean                     _enterCost,
    ProjLedgerStatus            _ledgerStatusCost,
    ProjTransIdBase             _transId,
    ProjTransactionOrigin       _transactionOrigin)

    {
        ProjPost                projPost;
        boolean                 costUseOrig;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                projPost    = new ProjPostEmplJournalCostAdj(_buffer, _tmpProjAdjustmentCreateCost);
                break;

            default:
                throw error("@SYS50155");
        }

        costUseOrig = _ledgerStatusCost == ProjLedgerStatus::BalanceSheet ? true : false;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(costUseOrig);
        projPost.parmsalesUseOrig(false);
        projPost.parmEnterSalesAccrued(false);
        projPost.parmReverseAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(0);
        projPost.parmEnterCost(_enterCost);
        projPost.parmLedgerStatusCost(_ledgerStatusCost);
        projPost.parmTransStatus(ProjTransStatus::Adjusted);
        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmTransactionOrigin(_transactionOrigin);
        projPost.parmTransactionOriginOrig(_transactionOrigin);
        projPost.parmFundingSourceList( ProjPost::createSplitList(_tmpProjAdjustmentCreateCost.FundingSource ));
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeJournalSale</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNegativeJournalSale(
    Common                      _buffer,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale,
    LedgerVoucher               _ledgerVoucher,
    boolean                     _enterSalesAccrued,
    AmountMST                   _salesAmountMST,
    AmountCur                   _adjustmentLedgerSalesAmount,
    ProjTransIdBase             _transId,
    ProjTransactionOrigin       _transactionOrigin)

    {
        ProjPost                projPost;
        boolean                 salesUseOrig;

        switch (_buffer.TableId)
        {
            case tableNum(ProjEmplTrans):
                projPost    = new ProjPostEmplJournalSaleAdj(_buffer, _tmpProjAdjustmentCreateSale);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                break;

            case tableNum(ProjRevenueTrans):
                projPost    = new ProjPostRevenueJournalSaleAdj(_buffer, _tmpProjAdjustmentCreateSale);
                break;

            default:
                throw error("@SYS50155");
        }

        salesUseOrig = _enterSalesAccrued;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(false);
        projPost.parmsalesUseOrig(salesUseOrig);
        projPost.parmEnterSalesAccrued(_enterSalesAccrued);
        projPost.parmReverseAccrued(_enterSalesAccrued);
        projPost.parmUseTransCurrReverseAccrued(_enterSalesAccrued);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(_salesAmountMST);
        projPost.parmAdjustmentLedgerSalesAmount(_adjustmentLedgerSalesAmount);
        projPost.parmEnterCost(false);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmTransStatus(ProjTransStatus::Adjusted);
        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmTransactionOrigin(_transactionOrigin);
        projPost.parmTransactionOriginOrig(_transactionOrigin);
        projPost.parmFundingSourceList( ProjPost::createSplitList(_tmpProjAdjustmentCreateSale.FundingSource ));
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeNotStockedCost</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNegativeNotStockedCost(
    Common                      _buffer,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    ProjLedgerStatus            _ledgerStatusCost,
    ProjTransIdBase             _transId,
    ProjTransactionOrigin       _transactionOrigin)

    {
        ProjPost                projPost;
        boolean                 costUseOrig;

        switch (_buffer.TableId)
        {
            case tableNum(ProjItemTrans):
                projPost    = new ProjPostItemTransCost_AdjNotStocked(_buffer, _tmpProjAdjustmentCreateCost);
                break;

            default:
                throw error("@SYS50155");
        }

        costUseOrig = _ledgerStatusCost == ProjLedgerStatus::BalanceSheet ? true : false;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(costUseOrig);
        projPost.parmsalesUseOrig(false);
        projPost.parmEnterSalesAccrued(false);
        projPost.parmReverseAccrued(false);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(0);
        projPost.parmEnterCost(true);
        projPost.parmLedgerStatusCost(_ledgerStatusCost);
        projPost.parmTransStatus(ProjTransStatus::Adjusted);
        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmTransactionOrigin(_transactionOrigin);
        projPost.parmTransactionOriginOrig(_transactionOrigin);
        projPost.parmFundingSourceList( ProjPost::createSplitList(_tmpProjAdjustmentCreateCost.FundingSource ));
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a new instance of the <c>ProjPost</c> object to use to post negative adjustment ledger
    /// entries.
    /// </summary>
    /// <param name="_projCostTrans">
    /// The table for the transaction type.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger items to use to post.
    /// </param>
    /// <param name="_transId">
    /// The transaction identifier for the original transaction.
    /// </param>
    /// <returns>
    /// A new <c>ProjPost</c> object for the adjustment posting.
    /// </returns>
    /// <remarks>
    /// This method is only valid for the <c>ProjCostTrans</c> table and the <c>ProjItemTrans</c> table.
    /// Any other table that is passed in the <paramref name="_buffer" /> parameter will cause an
    /// exception: project posting is not implemented for this type.
    /// </remarks>
    public static ProjPost newTransAdjNegativeTrans(
    ProjCostTrans    _projCostTrans,
    LedgerVoucher    _ledgerVoucher,
    ProjTransIdBase  _transId)

    {
        ProjPost    projPost;

        projPost = new ProjPostCostTrans_AdjNeg(_projCostTrans);
        projPost.parmCommittedCostReverse(false);
        projPost.parmTransactionOrigin(_projCostTrans.TransactionOrigin);

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(false);
        projPost.parmsalesUseOrig(false);

        projPost.parmEnterSalesAccrued(false);
        projPost.parmReverseAccrued(false);
        projPost.parmEnterCost(false);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(0);

        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeTransCost</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNegativeTransCost(
    ProjCostTrans       _projCostTransNew,
    ProjCostTrans       _projCostTransOrig,
    ProjCostTransCost   _projCostTransCostOrig,
    LedgerVoucher       _ledgerVoucher,
    boolean             _enterCost,
    ProjLedgerStatus    _ledgerStatusCost,
    ProjTransIdBase     _transId
)
    {
        ProjPost    projPost;
        boolean     costUseOrig;

        projPost = new ProjPostCostTransCost_AdjNeg(_projCostTransNew, _projCostTransOrig, _projCostTransCostOrig);
        projPost.parmCommittedCostReverse(false);
        projPost.parmTransactionOrigin(_projCostTransOrig.TransactionOrigin);

        costUseOrig = _ledgerStatusCost == ProjLedgerStatus::BalanceSheet ? true : false;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(costUseOrig);
        projPost.parmsalesUseOrig(false);

        projPost.parmEnterSalesAccrued(false);
        projPost.parmReverseAccrued(false);
        projPost.parmEnterCost(_enterCost);
        projPost.parmLedgerStatusCost(_ledgerStatusCost);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(0);

        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList(_projCostTransCostOrig.FundingSource ));
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNegativeTransSale</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNegativeTransSale(
    ProjCostTrans       _projCostTransNew,
    ProjCostTrans       _projCostTransOrig,
    ProjCostTransSale   _projCostTransSaleOrig,
    LedgerVoucher       _ledgerVoucher,
    boolean             _enterSalesAccrued,
    AmountMST           _salesAmountMST,
    AmountCur           _adjustmentLedgerSalesAmount,
    ProjTransIdBase     _transId)

    {
        ProjPost    projPost;
        boolean     salesUseOrig;

        projPost = new ProjPostCostTransSale_AdjNeg(_projCostTransNew, _projCostTransOrig, _projCostTransSaleOrig);
        projPost.parmCommittedCostReverse(false);
        projPost.parmTransactionOrigin(_projCostTransOrig.TransactionOrigin);

        salesUseOrig = _enterSalesAccrued;

        projPost.parmTransIdOrig(_transId);
        projPost.parmCostUseOrig(false);
        projPost.parmsalesUseOrig(salesUseOrig);

        projPost.parmEnterSalesAccrued(_enterSalesAccrued);
        projPost.parmReverseAccrued(_enterSalesAccrued);
        projPost.parmUseTransCurrReverseAccrued(_enterSalesAccrued);
        projPost.parmEnterCost(false);
        projPost.parmLedgerStatusCost(ProjLedgerStatus::None);
        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmSalesAmountMST(_salesAmountMST);
        projPost.parmAdjustmentLedgerSalesAmount(_adjustmentLedgerSalesAmount);

        projPost.parmCreateTrans(true);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList(_projCostTransSaleOrig.FundingSource ));
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNoLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a new instance of <c>ProjPost</c> for posting adjustments without ledger entries.
    /// </summary>
    /// <param name="_buffer">
    /// The table for transaction type.
    /// </param>
    /// <param name="_tmpProjAdjustmentCreate">
    /// The table that contains the transactions to create ledger from; optional.
    /// </param>
    /// <returns>
    /// A new <c>ProjPost</c> object for adjustment posting.
    /// </returns>
    /// <remarks>
    /// This method is only valid for the tables ProjCostTrans, ProjEmplTrans, ProjRevenueTrans, and
    /// ProjItemTrans. Any other table that is passed in the <paramref name="_buffer" /> parameter will
    /// throw the error: Project posting is not implemented for this type.
    /// </remarks>
    public static ProjPost newTransAdjNoLedger(Common                   _buffer,
                                           TmpProjAdjustmentCreate  _tmpProjAdjustmentCreate = null)

    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;

        switch (_buffer.TableId)
        {
            case tableNum(ProjCostTrans):
                projPost = new ProjPostCostTrans_Adj(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                break;

            case tableNum(ProjEmplTrans):
                projPost = new ProjPostEmplTrans_Adj(_buffer);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                break;

            case tableNum(ProjRevenueTrans):
                projPost = new ProjPostRevenueTrans_Adj(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjRevenueTrans,TransactionOrigin)));
                break;

            case tableNum(ProjItemTrans):
                projPost = new ProjPostItemTrans_Adj(_buffer);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjItemTrans,TransactionOrigin)));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);
        projPost.parmAdjustBuffer(_tmpProjAdjustmentCreate);

        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNoLedgerCost</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNoLedgerCost(
    Common                      _buffer,
    Common                      _bufferDetail,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost = null
)
    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;
        ProjFundingSourceRefId  fundingSourceId;

        switch (_bufferDetail.TableId)
        {
            case tableNum(ProjCostTransCost):
                projPost = new ProjPostCostTransCost_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjCostTransCost,FundingSource)));
                break;

            case tableNum(ProjEmplTransCost):
                projPost = new ProjPostEmplTransCost_Adj(_buffer, _bufferDetail);
                projPost.parmNotEnterNoneLedger(true);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjEmplTransCost,FundingSource)));
                break;

            case tableNum(ProjItemTransCost):
                projPost = new ProjPostItemTransCost_Adj(_bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjItemTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjItemTransCost,FundingSource)));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);
        projPost.parmadjustBufferCost(_tmpProjAdjustmentCreateCost);

        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( fundingSourceId ));
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNoLedgerSale</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNoLedgerSale(
    Common                      _buffer,
    Common                      _bufferDetail,
    TmpProjAdjustmentCreateSale _tmpProjAdjustmentCreateSale = null
)
    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;
        ProjFundingSourceRefId  fundingSourceId;

        switch (_bufferDetail.TableId)
        {
            case tableNum(ProjCostTransSale):
                projPost = new ProjPostCostTransSale_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjCostTransSale,FundingSource)));
                break;

            case tableNum(ProjEmplTransSale):
                projPost = new ProjPostEmplTransSale_Adj(_buffer, _bufferDetail);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjEmplTransSale,FundingSource)));
                break;

            case tableNum(ProjRevenueTransSale):
                projPost = new ProjPostRevenueTransSale_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjRevenueTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjRevenueTransSale,FundingSource)));
                break;

            case tableNum(ProjItemTransSale):
                projPost = new ProjPostItemTransSale_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjItemTrans,TransactionOrigin)));
                fundingSourceId = _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjItemTransSale,FundingSource)));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);
        projPost.parmadjustBufferSale(_tmpProjAdjustmentCreateSale);

        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        projPost.parmFundingSourceList( ProjPost::createSplitList( fundingSourceId ));
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNotStockedCostWithSameLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method creates an instance of <c>ProjPost</c> for posting
    /// a negative  non-stocked item transaction.
    /// </summary>
    /// <param name = "_buffer"><c>ProjItemTrans</c> table buffer.</param>
    /// <param name = "_tmpProjAdjustmentCreateCost"><c>TmpProjAdjustmentCreateCost</c> table buffer.</param>
    /// <param name = "_ledgerVoucher"><c>LedgerVoucher</c> instance.</param>
    /// <param name = "_transactionOriginOrig"> Transaction origin of this transaction.</param>
    /// <param name = "_ledgerStatusCost"><c>ProjLedgerStatus</c> value of the original transaction.</param>
    /// <param name = "_reverseCommittedCost">A boolean value indicating whether committed cost needs to be reversed</param>
    /// <returns>A <c>ProjPostItemTransCost_AdjNotStocked</c> instance.</returns>
    /// <remarks>
    /// This method should be used only when the negative transaction created
    /// should honor the original transaction's ledger status and does not depend on
    /// the ledger posting setup for the project.
    /// </remarks>
    public static ProjPost newTransAdjNotStockedCostWithSameLedger(
    Common                      _buffer,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    ProjTransactionOrigin       _transactionOriginOrig,
    projLedgerStatus            _ledgerStatusCost,
    boolean                     _reverseCommittedCost = true)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;
        
        switch (_buffer.TableId)
        {
            case tableNum(ProjItemTrans):
                projPost    = new ProjPostItemTransCost_AdjNotStocked(_buffer, _tmpProjAdjustmentCreateCost);
                projTrans = ProjTrans::newProjTransItemTransCostAdj(_buffer, _tmpProjAdjustmentCreateCost);
                break;

            default:
                throw error("@SYS50155");
        }

        ProjItemTransCost projItemTransCostorig = ProjItemTransCost::findRecId(_tmpProjAdjustmentCreateCost.CostRefRecId);
        projPost.parmLedgerStatusCost(_ledgerStatusCost);
        ProjWIPTable wipProject = projTrans.getWIPProject();

        if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::None)
        {
            if ((wipProject.IsContractLineUsed && ProjPost::isPLPostingRequiredForTransType(wipProject,projTrans)) ||
                ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
            {
                projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
            }
        }

        if (projPost.isLedgerStatusPostingCost(projPost.parmLedgerStatusCost()))
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmCommittedCostReverse(_reverseCommittedCost);

        projPost.parmEnterSalesAccrued(false);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);

        projPost.parmTransactionOrigin(_transactionOriginOrig);
        projPost.parmTransactionOriginOrig(_transactionOriginOrig);
        projPost.parmFundingSourceList(ProjPost::createSplitList(_tmpProjAdjustmentCreateCost.FundingSource));
        projPost.initIsContractLineUsed(projTrans);

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjNotStockedCost</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjNotStockedCost(
    Common                      _buffer,
    TmpProjAdjustmentCreateCost _tmpProjAdjustmentCreateCost,
    LedgerVoucher               _ledgerVoucher,
    ProjTransactionOrigin       _transactionOriginOrig,
    boolean                     _reverseCommittedCost = true
)
    {
        ProjPost                projPost;
        ProjTrans               projTrans;

        switch (_buffer.TableId)
        {
            case tableNum(ProjItemTrans):
                projPost    = new ProjPostItemTransCost_AdjNotStocked(_buffer, _tmpProjAdjustmentCreateCost);
                projTrans = ProjTrans::newProjTransItemTransCostAdj(_buffer, _tmpProjAdjustmentCreateCost);
                break;

            default:
                throw error("@SYS50155");
        }

		projPost.parmLedgerStatusCost(ProjRevRecHelper::getItemLedgerStatus(ProjTable::find(projTrans.projId())));
        ProjWIPTable wipProject = projTrans.getWIPProject();

		if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::BalanceSheet)
		{
			if (projTrans.projLineProperty().ToBeCapitalize)
			{
                if ((wipProject.IsContractLineUsed && ProjPost::isPLPostingRequiredForTransType(wipProject,projTrans)) ||
                    ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
				{
					projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
				}
			}
			else
			{
				projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
			}
		}

		if ( projPost.parmLedgerStatusCost() == ProjLedgerStatus::None)
		{
            if ((wipProject.IsContractLineUsed && ProjPost::isPLPostingRequiredForTransType(wipProject,projTrans)) ||
                ProjTable::isPLPostingRequiredForTransType(projTrans.projTable().ProjId, projTrans.transType()))
			{
				projPost.parmLedgerStatusCost(ProjLedgerStatus::Operations);
			}
		}

        if (projPost.isLedgerStatusPostingCost(projPost.parmLedgerStatusCost()))
        {
            projPost.parmEnterCost(true);
        }

        projPost.parmCommittedCostReverse(_reverseCommittedCost);

        projPost.parmEnterSalesAccrued(false);

        projPost.parmLedgerVoucher(_ledgerVoucher);
        projPost.parmCreateTrans(true);

        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);

        projPost.parmTransactionOrigin(_transactionOriginOrig);
        projPost.parmTransactionOriginOrig(_transactionOriginOrig);
        projPost.parmFundingSourceList( ProjPost::createSplitList( _tmpProjAdjustmentCreateCost.FundingSource ) );
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newTransAdjSale</Name>
				<Source><![CDATA[
    public static ProjPost newTransAdjSale(Common _buffer, Common _bufferDetail, ProjTrans _projTrans=null)

    {
        ProjPost                projPost;
        ProjTransactionOrigin   transactionOrigin;
        ProjFundingSourceRefId  fundingSourceId;

        switch (_bufferDetail.TableId)
        {
            case tableNum(ProjCostTransSale):
                projPost = new ProjPostCostTransSale_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjCostTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjCostTransSale,FundingSource)));
                break;

            case tableNum(ProjEmplTransSale):
                projPost = new ProjPostEmplTransSale_Adj(_buffer, _bufferDetail);
                projPost.parmNotEnterNoneLedger(true);
                projPost.parmNotEnterNeverLedger(true);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjEmplTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjEmplTransSale,FundingSource)));
                break;

            case tableNum(ProjRevenueTransSale):
                projPost = new ProjPostRevenueTransSale_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjRevenueTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjRevenueTransSale,FundingSource)));
                break;

            case tableNum(ProjItemTransSale):
                projPost = new ProjPostItemTransSale_Adj(_buffer, _bufferDetail);
                transactionOrigin = _buffer.(fieldName2id(_buffer.TableId,fieldStr(ProjItemTrans,TransactionOrigin)));
                fundingSourceId =  _bufferDetail.(fieldName2id(_bufferDetail.TableId,fieldStr(ProjItemTransSale,FundingSource)));
                break;

            default :
                throw error("@SYS50155");
        }

        projPost.parmUpdateTrans(true);

        projPost.parmTransactionOrigin(transactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Adjustment);
        if (_projTrans)
        {
            projPost.parmTransStatus(_projTrans.parmAdjustmentStatus());
        }
        projPost.parmFundingSourceList( ProjPost::createSplitList( fundingSourceId ));
        projPost.initIsContractLineUsed();
        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>physicalInventPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the transaction project item and post project ledger transactions.
    /// </summary>
    /// <param name="_physical">
    /// The inventory update physical object.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher that is used for inventory physical booking.
    /// </param>
    public static void physicalInventPost(InventUpd_Physical  _physical, LedgerVoucher _ledgerVoucher)
    {
        InventTrans                     inventTrans;
        ProjItemTrans                   projItemTrans;
        ProjItemTransCost               projItemTransCost;
        ProjItemTransSale               projItemTransSale;
        InventMovement                  movement;
        ProdBOMTransProj                prodBOMTransProj;
        ProjPost                        projPost;
        ProjTrans                       projTrans;

        if (_physical.movement().mustDoProjPhysicalAdjust())
        {
            while select forupdate inventTrans
            order by InventTransOrigin  // Force RecordViewCache to only return records existing at selection time
            where inventTrans.InventTransOrigin == _physical.movement().inventTransOriginId()  &&
                  inventTrans.DateFinancial     == _ledgerVoucher.lastTransDate()              &&
                  inventTrans.Voucher           == _ledgerVoucher.lastVoucher()                &&
                  inventTrans.ProjAdjustRefId
            {
                projItemTrans = ProjItemTrans::findInvent(_physical.movement().transId(), inventTrans.ProjAdjustRefId, true);
                if (projItemTrans)
                {
                    select firstonly projItemTransCost
                    where projItemTransCost.InventTransId == projItemTrans.InventTransId &&
                        projItemTransCost.ProjAdjustRefId == projItemTrans.ProjAdjustRefId &&
                        projItemTransCost.TransStatus != ProjTransStatus::Posted;

                    select firstonly projItemTransSale
                    where projItemTransSale.ProjTransId == projItemTrans.ProjTransId &&
                        projItemTransSale.TransStatus != ProjTransStatus::Posted;
                    
                    ProjTable projTableLocal = projItemTrans.projTable();
                    
                    if (ProjMultipleContractLinesForProjectFeatureHelper::isTimeMaterialBillingMethod(projTableLocal, ProjTransType::Item) &&
                        (projItemTransCost || projItemTransSale) &&
                        projItemTrans.Qty != 0)
                    {
                        throw error(strFmt("@SYS112472", _physical.movement().transRefId()));
                    }

                    select prodBOMTransProj
                    where prodBOMTransProj.InventTransId == projItemTrans.InventTransId &&
                        prodBOMTransProj.ProjTransId == projItemTrans.ProjTransId;

                    if (!prodBOMTransProj)
                    {
                        throw error(Error::missingOverload(funcName()));
                    }

                    movement = InventMovement::construct(prodBOMTransProj);

                    //Post project ledger transactions for the packing slip return
                    projPost = ProjPost::newInventUpd_PhysicalAdjust(movement,
                                                _ledgerVoucher,
                                                inventTrans.Qty,
                                                inventTrans.CostAmountPhysical,
                                                inventTrans.ProjAdjustRefId,
                                                false,
                                                _physical.movement().transId());

                    projPost.postTrans();
                    ProjPost::postItemReverseTransaction(projPost);

                    //Adjust project item quantity
                    projItemTrans.reread();
                    projItemTrans.Qty += inventTrans.Qty;
                    projItemTrans.doUpdate();

                    while select forupdate projItemTransSale
                    where projItemTransSale.ProjTransId == projItemTrans.ProjTransId
                    {
                        if (projItemTrans.Qty == 0)
                        {
                            projItemTransSale.SalesPrice = 0;
                        }

                        projItemTransSale.LineAmount = PriceDisc::price2Amount(projItemTransSale.SalesPrice,
                                                                            InventTable::find(projItemTrans.ItemId).salesPriceUnit(),
                                                                            0,projItemTrans.Qty,0,0,0,projItemTrans.CurrencyId,0,false);

                        if (projItemTransSale.LedgerSalesPosted)
                        {
                            projTrans = ProjTrans::newProjItemTransSale(projItemTrans, projItemTransSale);
                            projItemTransSale.LedgerSalesAmount = projTrans.transTurnoverMST();
                        }

                        projItemTransSale.update();
                    }
                }
            }
        }
        else
        {
            //Create project item transaction and post project ledger transactions
            ProjPost::newInventUpd_Physical(_physical,
                                        _ledgerVoucher,
                                        _physical.movement().projAdjustRefId(),
                                        false,
                                        _physical.movement().transId()).postTrans();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postItemReverseTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes the Ledger Voucher that was added in from the Inventory and splits it.
    /// </summary>
    /// <param name="projPost">
    /// The <c>projPost</c> object to use that contains information about the transaction that is being
    /// posted.
    /// </param>
    /// <param name="ledgerDistributionMap">
    /// The <c>LedgerDistributionMap</c> object to be used by this ledger voucher; optional.
    /// </param>
    public static void postItemReverseTransaction(ProjPost projPost, Map ledgerDistributionMap = null )
    {
        ListEnumerator                  listEnumerator;
        LedgerVoucherTransObject        ledgerVoucherTransObject;
        MapEnumerator                   fundingAllocationEnumerator;
        LedgerVoucherTransObject        ledgerVoucherTransObjectNew;
        AmountCur                       amountCur;
        ProjLedger                      tmpProjLedger;
        boolean                         removeTrans;
        LedgerDimensionDefaultAccount   defaultLedgerDimension;
        LedgerDimensionAccount          mergedLedgerDimension;
        CurrencyExchangeHelper          exchangeRateHelper;
        ProjFundingSource               projFundingSourceLocal;
        // <GEERU>
        container                       oldBondedTransactions_RU;
        container                       addedTransactions_RU;
        LedgerBondClient_RU             bondClient_RU;
        boolean                         isCredit_RU;
        boolean                         isSecCur_RU;
        // </GEERU>

        exchangeRateHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), projPost.parmLedgerVoucher().findLedgerVoucherObject().parmAccountingDate());
        exchangeRateHelper.parmExchangeRate1(projPost.exchRate());
        exchangeRateHelper.parmExchangeRate2(projPost.exchRateSecondary());

        listEnumerator = projPost.parmLedgerVoucher().findLedgerVoucherObject().getTransactionsForPostingType( LedgerPostingType::ProjCost ).getEnumerator();

        while (listEnumerator.moveNext())
        {
            ledgerVoucherTransObject = listEnumerator.current();
 
            if (ProjPost::shouldSplitItemTransaction(projPost, ledgerVoucherTransObject))
            {
                removeTrans = false;
                amountCur= ledgerVoucherTransObject.parmAmountCur();
                // <GEERU>
                isSecCur_RU = !amountCur &&
                projPost.parmLedgerVoucher().findLedgerVoucherObject().parmPostingLayer() == CurrentOperationsTax::WarehouseCur_RU;
                if (isSecCur_RU)
                {
                    amountCur = ledgerVoucherTransObject.parmReportingCurrencyAmount();
                }
                // </GEERU>
                if ( !ledgerDistributionMap )
                {
                    if (!projPost.parmFundingSourceList())
                    {
                        throw error(strFmt("@SYS22828", funcName()));
                    }
                    fundingAllocationEnumerator = ProjFundingEngine::ledgerDistributions( projPost.parmFundingSourceList(), amountCur,projPost.currencyIdCost()).getEnumerator();
                }
                else
                {
                    fundingAllocationEnumerator = ledgerDistributionMap.getEnumerator();
                }
                // <GEERU>
                // since trans object will be removed, it is need to remember bonding to restore
                bondClient_RU = projPost.parmLedgerVoucher().findLedgerVoucherObject().ledgerBondClient_RU();
                if (bondClient_RU)
                {
                    oldBondedTransactions_RU    = bondClient_RU.getBondedVrefIDs(
                    projPost.parmLedgerVoucher().findLedgerVoucherObject().vrefIDByTrans_RU(ledgerVoucherTransObject));
                    addedTransactions_RU        = conNull();
                    isCredit_RU                 = false;
                }
                // </GEERU>
                while ( fundingAllocationEnumerator.moveNext() )
                {
                    if (fundingAllocationEnumerator.currentKey())
                    {
                        removeTrans = true;
                        tmpProjLedger = ledgerVoucherTransObject.parmProjLedger().clone();
                        tmpProjLedger.parmfundingSourceID( fundingAllocationEnumerator.currentKey() );
                        tmpProjLedger.parmLedgerStatusCostOrig(projPost.parmLedgerStatusCostOrig());

                        projFundingSourceLocal = ProjFundingSource::find(fundingAllocationEnumerator.currentKey());
                        defaultLedgerDimension = projPost.parmLedgerDimension(projPost.parmProjTrans().costAccountLedgerDimension(fundingAllocationEnumerator.currentKey()));

                        if (projPost.parmAdjustment() && projPost.parmTransStatus() == ProjTransStatus::Adjusted && FeatureStateProvider::isFeatureEnabled(ProjAdjustmentKeepOrigFinDimOnReversingTransFeature::instance()))
                        {
                            // For adjusted reverting transaction, directly take default dimension from original transaction
                            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, projPost.defaultDimension());
                        }
                        else
                        {
                            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(defaultLedgerDimension, projPost.defaultDimension(), projFundingSourceLocal.DefaultDimension);
                        }

                        // <GEERU>
                        if (isSecCur_RU)
                        {
                            ledgerVoucherTransObjectNew = LedgerVoucherTransObject::newBasicSecondary_RU(
                                projPost.parmLedgerVoucher().findLedgerVoucherObject(),
                                ledgerVoucherTransObject.parmLedgerPostingType(),
                                mergedLedgerDimension,
                                ledgerVoucherTransObject.parmTransactionCurrencyCode(),
                                fundingAllocationEnumerator.currentValue(),
                                ledgerVoucherTransObject.parmCorrect());
                        }
                        else
                        {
                            // </GEERU>
                            ledgerVoucherTransObjectNew = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                        projPost.parmLedgerVoucher().findLedgerVoucherObject(),
                                                        ledgerVoucherTransObject.parmLedgerPostingType(),
                                                        mergedLedgerDimension,
                                                        ledgerVoucherTransObject.parmTransactionCurrencyCode(),
                                                        fundingAllocationEnumerator.currentValue(),
                                                        exchangeRateHelper);
                            // <GEERU>
                        }
                        // </GEERU>
                        ledgerVoucherTransObjectNew.parmSourceTableId(ledgerVoucherTransObject.parmSourceTableId());
                        ledgerVoucherTransObjectNew.parmSourceRecId(ledgerVoucherTransObject.parmSourceRecId());
                        ledgerVoucherTransObjectNew.parmQuantity(ledgerVoucherTransObject.parmQuantity());
                        ledgerVoucherTransObjectNew.parmProjLedger(ledgerVoucherTransObject.parmProjLedger(tmpProjLedger));
                        // <GEEU>
                        if (LedgerParameters::isStornoEnabledEE())
                        {
                            ledgerVoucherTransObjectNew.parmIsCorrection(ledgerVoucherTransObject.parmIsCorrection());
                        }
                        // </GEEU>
                        projPost.parmLedgerVoucher().addTrans( ledgerVoucherTransObjectNew );
                        // <GEERU>
                        if (bondClient_RU)
                        {
                            addedTransactions_RU += bondClient_RU.lastVrefId();
                            isCredit_RU = isCredit_RU || bondClient_RU.lastBondTransObject().remainCrediting();
                        }
                        // </GEERU>
                    }
                }
                if (removeTrans)
                {
                    projPost.parmLedgerVoucher().findLedgerVoucherObject().removeTrans( ledgerVoucherTransObject );
                    // <GEERU>
                    if (bondClient_RU)
                    {
                        bondClient_RU.bondLog2Log(
                        projPost.parmLedgerVoucher().findLedgerVoucherObject().parmAccountingDate(),
                        isCredit_RU ? oldBondedTransactions_RU : addedTransactions_RU,
                        !isCredit_RU ? oldBondedTransactions_RU : addedTransactions_RU);
                    }
                    // </GEERU>
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldSplitItemTransaction</Name>
				<Source><![CDATA[
    private static boolean shouldSplitItemTransaction(ProjPost _projPost,
        LedgerVoucherTransObject _ledgerVoucherTransObject)
    {
        ProjId projId =  _ledgerVoucherTransObject.parmProjLedger().parmProjId();

        // Item transaction should be split if funding source is not defined.
        // To prevent accidentally updating transactions from a different project
        // e.g. during reversal of an original transaction when using project adjustment
        // and specifying a different project(with a different project type) for adjustment
        boolean shouldReverseItemTransaction =
            !_ledgerVoucherTransObject.parmProjLedger().parmfundingSourceID()
            && projId == _projPost.parmProjTrans().projId();

        // For the case of ProjLedger funding source flight is enabled, even when funding source is defined,
        // split item transaction may still need to be executed.
        if (!shouldReverseItemTransaction)
        {
            // If ProjPost default dimension is not defined, then execute the
            // item transaction process as it will set the default dimension value.
            shouldReverseItemTransaction = _projPost.defaultDimension() ? false : true;

            if (shouldReverseItemTransaction)
            {
                shouldReverseItemTransaction = ProjTable::find(projId).DefaultDimension ? false : true;
            }
            
            // For adjustment scenario, when posting costs from P&L to Balance sheet,
            // then adjust the balance sheet transaction, even only changing financial dimensions,
            // the transactions should execute split item transaction process to set LedgerStatusCostOrig.
            // Else ProjItemTransCost.LedgerStatusCost will not be set correctly
            // in ProjLedgerUpdate when inserting ProjItemTransCost is inserted.
            if (!shouldReverseItemTransaction)
            {
                boolean ledgerVoucherTransObjectLedgerStatusCostOrig
                    = _ledgerVoucherTransObject.parmProjLedger().parmLedgerStatusCostOrig();
                boolean projPostLedgerStatusCostOrig = _projPost.parmLedgerStatusCostOrig();

                shouldReverseItemTransaction = ledgerVoucherTransObjectLedgerStatusCostOrig != projPostLedgerStatusCostOrig;
            }
        }

        // To skip reverse transaction processing when <c>ProjPost</c> instance does not matched with <c>ProjLedger</c> buffer
        // as list enumerator in <c>postItemReverseTransaction</c> method contains multiple transactions of posting type <c>ProjCost</c>.
        if (shouldReverseItemTransaction)
        {
            if (_projPost.parmLedgerOrigin() == ProjOrigin::PurchaseOrder && ProjSetFundingSourceForPOWithMFSFlightVendInvoice::instance().isEnabled())
            {
                shouldReverseItemTransaction = _ledgerVoucherTransObject.parmProjLedger().parmInventTransId() == _projPost.parmProjTrans().markedInventTransId()? true: false;
            }
            else
            {
                shouldReverseItemTransaction = _ledgerVoucherTransObject.parmProjLedger().parmInventTransId() == _projPost.parmProjTrans().inventTransId()? true: false;
            }
        }

        return shouldReverseItemTransaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaNewCreateProjIndirectCostAndRevenue</Name>
				<Source><![CDATA[
    // Description    : post indirect journal
    public static ProjPost psaNewCreateProjIndirectCostAndRevenue(Common _buffer, LedgerVoucher _ledgerVoucher)
    {
        ProjPost         oProjPost;
        ProjJournalTrans tProjJournalTrans;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            if (_buffer.TableId != tableNum(ProjJournalTrans))
            {
                throw error("@SYS50155");
            }

            tProjJournalTrans = _buffer;

            oProjPost = new PSAProjPostEmplIndirectJournal(_buffer);

            // Set the values of <c>LedgerStatusCost</c> and <c>EnterSalesAccrued</c> if <c>ProjId</c> exists for non-intercompany timesheet scenario
            // whereas for intercompany timesheet these values are set in <c>TSTimesheetsPost</c> <c>postIndirectCostComponentLedgerUpdates</c> method.
            if (tProjJournalTrans.ProjId)
            {
                oProjPost.parmLedgerStatusCost(ProjPost::getEmplLedgerStatusCost(tProjJournalTrans, ProjTrans::newProjJournalTrans(tprojJournalTrans)));
            
                if (oProjPost.isLedgerStatusPostingCost(oProjPost.parmLedgerStatusCost()))
                {
                    oProjPost.parmEnterCost(true);
                }

                oProjPost.parmEnterSalesAccrued(ProjRevRecHelper::postWIPEmplForProject(ProjTable::find(tProjJournalTrans.ProjId)));
            }

            oProjPost.parmCreateTrans(true);
            oProjPost.parmLedgerVoucher(_ledgerVoucher);
        }

        return oProjPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getEmplLedgerStatusCost</Name>
				<Source><![CDATA[
    private static ProjLedgerStatus getEmplLedgerStatusCost(ProjJournalTrans _projJournalTrans, ProjTrans _projTrans)
    {
        ProjLedgerStatus ledgerStatusCost = ProjRevRecHelper::getEmplLedgerStatus(ProjTable::find(_projJournalTrans.ProjId));
        ProjWIPTable wipProject = _projTrans.getWIPProject();

        if ( ledgerStatusCost == ProjLedgerStatus::BalanceSheet)
        {
            if (_projTrans.projLineProperty().ToBeCapitalize)
            {
                if ((wipProject.IsContractLineUsed && ProjPost::isPLPostingRequiredForTransType(wipProject,_projTrans)) ||
                    ProjTable::isPLPostingRequiredForTransType(_projTrans.projTable().ProjId, _projTrans.transType()))
                {
                    ledgerStatusCost = ProjLedgerStatus::Operations;
                }
            }
            else
            {
                ledgerStatusCost = ProjLedgerStatus::Operations;
            }
        }
        else if ( ledgerStatusCost == ProjLedgerStatus::None)
        {
            if ((wipProject.IsContractLineUsed && ProjPost::isPLPostingRequiredForTransType(wipProject,_projTrans)) ||
                ProjTable::isPLPostingRequiredForTransType(_projTrans.projTable().ProjId, _projTrans.transType()))
            {
                ledgerStatusCost = ProjLedgerStatus::Operations;
            }
        }

        return ledgerStatusCost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaNewEnterIndirectSalesAccrued</Name>
				<Source><![CDATA[
    // Description    : post indirect accrued revenue
    public static ProjPost psaNewEnterIndirectSalesAccrued(Common          _buffer,
                                                           LedgerVoucher   _ledgerVoucher,
                                                           boolean         _reverseAccrued,
                                                           boolean         _adjustment = false,
                                                           boolean         _isCreditNote = false)

    {
        ProjPost            oProjPost;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            switch (_buffer.TableId)
            {
                case(tableNum(ProjEmplTrans)):
                oProjPost = new PSAProjPostEmplIndirect(_buffer);
                    oProjPost.parmEnterSalesAccrued(true);
                    break;

                case(tableNum(ProjProposalEmpl)):
                oProjPost = new PSAProjPostEmplIndirectProposal(_buffer);

                    if (_reverseAccrued)
                    {
                        oProjPost.parmEnterSalesAccrued(true);
                    }
                    break;
            }

            oProjPost.parmReverseAccrued(_reverseAccrued);
            oProjPost.parmLedgerVoucher(_ledgerVoucher);
            oProjPost.parmIsCreditNote(_isCreditNote);
            oprojPost.parmUseTransCurrReverseAccrued(_reverseAccrued);
            oprojPost.initIsContractLineUsed();
        }

        return oProjPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaNewIndirectComponentPost</Name>
				<Source><![CDATA[
    // Description:     create a new indirect component post object
    public static ProjPost psaNewIndirectComponentPost(ProjProposalEmpl _tProjProposalEmpl, LedgerVoucher _oLedgerVoucher)
    {
        PSAProjPost_IndirectComponentInvoice oProjIndirectComponentInvoicePost;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            oProjIndirectComponentInvoicePost = new PSAProjPost_IndirectComponentInvoice(_tProjProposalEmpl);
            oProjIndirectComponentInvoicePost.parmLedgerVoucher(_oLedgerVoucher);
        }
        oProjIndirectComponentInvoicePost.initIsContractLineUsed();

        return oProjIndirectComponentInvoicePost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaNewRetainagePost</Name>
				<Source><![CDATA[
    // Description: create a new ARRetainage post object
    public static ProjPost psaNewRetainagePost(ProjJournalTrans _projJournalTrans, LedgerVoucher _ledgerVoucher)
    {
        ProjPostARRetention projPostARRetention;

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            projPostARRetention = new ProjPostARRetention(_projJournalTrans);
            projPostARRetention.parmEnterSalesAccrued(false);
            projPostARRetention.parmLedgerVoucher(_ledgerVoucher);
            projPostARRetention.parmCreateTrans(true);
        }
        projPostARRetention.initIsContractLineUsed();

        return projPostARRetention;
    }

]]></Source>
			</Method>
			<Method>
				<Name>psaReverseProjIndirectRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a new instance of the <c>ProjPost</c> class.
    /// </summary>
    /// <param name="projProposalEmpl">
    ///     A <c>projProposalEmpl</c> table instance.
    /// </param>
    /// <param name="projProposalEmplDetail">
    ///     A <c>projProposalEmplDetail</c> table instance.
    /// </param>
    /// <param name="projEmplTrans">
    ///     A <c>projEmplTrans</c> table instance.
    /// </param>
    /// <param name="projEmplTransSale">
    ///     A <c>projEmplTransSale</c> table instance.
    /// </param>
    /// <param name="ledgerVoucher">
    ///     A <c>ledgerVoucher</c> class instance.
    /// </param>
    /// <returns>
    ///    Instance of ProjPost Class.
    /// </returns>
    /// <remarks>
    ///     ProjPost instance consists of value of <c>NotEnterNoneLedger</c>, boolean value of parmCreateTrans,transactionOrigin,reverseAccrued.
    /// </remarks>
    public static ProjPost psaReverseProjIndirectRevenue(ProjProposalEmpl  projProposalEmpl,
                                                         ProjProposalEmplDetail projProposalEmplDetail,
                                                         ProjEmplTrans     projEmplTrans,
                                                         ProjEmplTransSale projEmplTransSale,
                                                         LedgerVoucher     ledgerVoucher)
    {
        ProjPost                    projPost;

        projPost = new PSAProjPostEmplIndirectSalesAccrued(projProposalEmpl, projProposalEmplDetail, projEmplTrans, projEmplTransSale);
        projPost.parmNotEnterNoneLedger(true);
        projPost.parmNotEnterNeverLedger(true);
        projPost.parmCreateTrans(false);
        projPost.parmUpdateTrans(false);

        projPost.parmEnterSalesAccrued(true);
        projPost.parmAdjustmentLedgerSalesAmount(projEmplTransSale.LedgerSalesPosted ? projEmplTransSale.psaIndirectRevenue : 0);

        projPost.parmTransactionOrigin(projEmplTrans.TransactionOrigin);
        projPost.parmLedgerOrigin(ProjOrigin::Invoice);
        projPost.parmReverseAccrued(true);
        projPost.parmUseTransCurrReverseAccrued(true);
        projPost.parmFundingSourceList( ProjPost::createSplitList( projEmplTransSale.FundingSource ) );
        projPost.parmSplitTransQtyCon( ProjFundingEngine::distributeQty(projEmplTrans.fundingSourceList(), projEmplTrans.Qty).pack() );
        projPost.parmIsCreditNote(projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ? true : false);

        projPost.parmLedgerVoucher(ledgerVoucher);
        projPost.initIsContractLineUsed();

        return projPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventAdjustPostBudgetUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Project Budget on inventory adjustment.
    /// </summary>
    /// <param name="_voucher">
    /// Voucher ID.
    /// </param>
    /// <remarks>
    /// Handles the posting of adjusted amount on to the project budgets.
    /// </remarks>
    public static void inventAdjustPostBudgetUpdate(Voucher _voucher)
    {
        ProjTable                       projTable;
        ProjTrans                       projTrans;
        ProjItemTrans                   projItemTrans;
        ProjItemTransCost               projItemTransCost;
        ProjBudgetTransaction           projBudgetTransaction;
        ProjBudgetTransactionLine       projBudgetTransactionLine;
        ProjBudgetTransactionManager    projBudgetTransactionManager;

        while select projItemTransCost
            where projItemTransCost.ProjInventAdjust == true &&
                  projItemTransCost.Voucher == _voucher
        exists join projItemTrans
            where projItemTrans.InventTransId == projItemTransCost.InventTransId &&
                  projItemTrans.ProjAdjustRefId == projItemTransCost.ProjAdjustRefId
        exists join projTable
            where projTable.ProjId == projItemTrans.ProjId &&
                  projTable.Status != ProjStatus::Completed &&
                  projTable.UseBudgeting == true
        {
            projTrans = ProjTrans::newProjItemTransCost(projItemTransCost);

            projBudgetTransactionLine = ProjBudgetTransactionLine::construct(projTrans.buffer());
            projBudgetTransactionLine.parmCostAmount(projTrans.transCost());
            projBudgetTransactionLine.parmTransIdRef(projTrans.transId());

            projBudgetTransaction = new ProjBudgetTransaction();
            projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

            projBudgetTransactionManager =  ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
            projBudgetTransactionManager.parmAllowOverBudget(false);

            if (projBudgetTransactionLine.parmCostAmount() > 0)
            {
                if (!projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement))
                {
                    throw Exception::Error;
                }
            }
            else
            {
                projBudgetTransactionManager.inventAdjustIncreaseBudget(projBudgetTransactionLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoicePostStockedItemReqBudgetUpdateCost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Project Cost Budget on posting invoice proposal when packing slip cancellation feature is on
    /// </summary>
    /// <param name = "_projItemTransCost">Item cost transaction for which budget needs to be updated</param>
    [Hookable(false)]
    public static void invoicePostStockedItemReqBudgetUpdateCost(ProjItemTransCost _projItemTransCost)
    {
        ProjTrans projTrans = ProjTrans::newProjItemTransCost(_projItemTransCost);
        
        ProjBudgetTransactionLine projBudgetTransactionLine = ProjBudgetTransactionLine::construct(projTrans.buffer());
        projBudgetTransactionLine.parmQty(abs(projTrans.qty())); //Always keeping this positive. For negative qty, if cost/sales amount is positive, budget decrement method adjustBudgetDecrement() considers it as 0
        projBudgetTransactionLine.parmCostAmount(projTrans.transCost());
        projBudgetTransactionLine.parmTransIdRef(projTrans.transId());
        
        ProjBudgetTransaction projBudgetTransaction = new ProjBudgetTransaction();
        projBudgetTransaction.addBudgetTransactionLine(projBudgetTransactionLine);

        ProjBudgetTransactionManager projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);
        projBudgetTransactionManager.parmAllowOverBudget(false);

        if (!projBudgetTransactionManager.adjustBudget(ProjBudgetAdjustmentType::Decrement))
        {
            throw Exception::Error;
        }

        ProjPost::invoiceStockedItemReqPostBudgetUpdate(_projItemTransCost, 0); //Obsolete method call
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceStockedItemReqPostBudgetUpdate</Name>
				<Source><![CDATA[
    [SysObsolete('Please use ProjPost::invoicePostStockedItemReqBudgetUpdateCost()', false, 03\02\2024)]
    public static void invoiceStockedItemReqPostBudgetUpdate(ProjItemTransCost _projItemTransCost, AmountCur _salesAmt = 0)
    {

    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBudget</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the project budget for the project journals.
    /// </summary>
    /// <param name="_buffer">
    /// The <c>Common</c> table that holds the project journal.
    /// </param>
    /// <returns>
    /// true if the journal is validated; otherwise, false.
    /// </returns>
    public static boolean validateBudget(Common _buffer)
    {
        ProjBudgetTransaction           projBudgetTransaction;
        ProjBudgetTransactionManager    projBudgetTransactionManager;
        boolean ok = true;

        projBudgetTransaction = ProjBudgetTransaction::construct(_buffer, false);
        projBudgetTransactionManager = ProjBudgetTransactionManager::newProjBudgetTransactionManager(projBudgetTransaction);

        ok = projBudgetTransactionManager.validateBudget();
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate(ExchRate   _exchangeRate = exchangeRate)
    {
        exchangeRate   = _exchangeRate;

        return exchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingExchangeRate</Name>
				<Source><![CDATA[
    public ExchRate parmReportingExchangeRate(ExchRate _reportingExchangeRate = reportingExchangeRate)
    {
        reportingExchangeRate = _reportingExchangeRate;

        return reportingExchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a transaction date based on an open period from the Fiscal Calendar and user's module level access to the period.
    /// </summary>
    /// <returns>
    /// A date from an open period and user has module level access for that same period.
    /// </returns>
    protected TransDate getLedgerJournalTransDate()
    {
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        TransDate               transDate;
        RecId                   calendarRecId;

        if (ledgerVoucher && ledgerVoucher.findLedgerVoucherObject())
        {
            transDate = ledgerVoucher.lastTransDate();
            fiscalCalendarPeriod = FiscalCalendarPeriod::find(
                ledgerVoucher.findLedgerVoucherObject().parmFiscalCalendarPeriodRecId());
        }
        else if (projTrans)
        {
            transDate = (projTrans is ProjTransCostJournal || projTrans is ProjTransItemProdTable) ? projTrans.ledgerTransDate() : projTrans.transDate();

            calendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());

            fiscalCalendarPeriod =
                LedgerFiscalCalendar::findPeriodByPeriodCodeDate(calendarRecId, transDate, FiscalPeriodType::Operating);
        }

        if (! fiscalCalendarPeriod)
        {
            throw error (strFmt("@SYS17614",date2StrUsr(transDate, DateFlags::FormatAll)));
        }

        if (transDate)
        {
            transDate = ProjPost::findNextAvailableAccountingDate(transDate);
        }

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findNextAvailableAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the next available valid accounting date on an open Ledger calendard period based on a given transaction date.
    /// </summary>
    /// <param name = "_accountingDate">
    /// The transactions target accounting date
    /// </param>
    /// <returns>
    /// An accounting date that is valid for the current or next open period .
    /// </returns>
    public static AccountingDate findNextAvailableAccountingDate(date _accountingDate)
    {
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        RecId                   calendarRecId;
        AccountingDate          updatedAccountingDate;

        updatedAccountingDate = _accountingDate;

        calendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());

        fiscalCalendarPeriod = LedgerFiscalCalendar::findPeriodByPeriodCodeDate(calendarRecId, _accountingDate, FiscalPeriodType::Operating);

        if (fiscalCalendarPeriod.currentLedgerPeriodStatus() !=  FiscalPeriodStatus::Open)
        {
            updatedAccountingDate = LedgerFiscalCalendar::findFirstOpenStartDateInYear(calendarRecId, _accountingDate);
        }

        if (!LedgerFiscalCalendar::existDateWithOpenStatus(calendarRecId, updatedAccountingDate, FiscalPeriodType::Operating, SysModule::Project))
        {
            updatedAccountingDate = LedgerFiscalCalendar::findFirstOpenStartDateModule(calendarRecId, updatedAccountingDate, SysModule::Project);
        }

        return updatedAccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVendInvoiceTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Fetches the related vendor invoice transaction.
    /// </summary>
    /// <param name = "_projItemTrans">
    /// The item transaction for which the related vendor invoice transaction should be fetched.
    /// </param>
    /// <returns>
    /// The vendor invoice transaction related with the project item transaction.
    /// </returns>
    public VendInvoiceTrans getVendInvoiceTrans(ProjItemTrans _projItemTrans)
    {
        VendInvoiceTrans    vendInvoiceTrans;
        VendInvoiceJour     vendInvoiceJour;
        PurchLine           purchLine;
        InventTransOrigin   inventTransOrigin_Project;
        InventTransOrigin   inventTransOrigin_PO;
        InventTrans         inventTrans_Project;
        InventTrans         inventTrans_PO;

        select firstonly StockedProduct from purchLine
            exists join inventTransOrigin_PO
                where inventTransOrigin_PO.InventTransId == purchLine.InventTransId
            exists join inventTrans_Project
                where inventTransOrigin_PO.RecId == inventTrans_Project.MarkingRefInventTransOrigin
            exists join inventTransOrigin_Project
                where inventTransOrigin_Project.RecId == inventTrans_Project.InventTransOrigin
                    && inventTransOrigin_Project.InventTransId == _projItemTrans.InventTransId;

        if (purchLine.StockedProduct)
        {
            select firstonly RecId from vendInvoiceTrans
                    where vendInvoiceTrans.InventRefTransId == _projItemTrans.InventTransId
                exists join inventTrans_PO
                    where inventTrans_PO.InvoiceId == vendInvoiceTrans.InvoiceId
                        && inventTrans_PO.DateFinancial == vendInvoiceTrans.InvoiceDate
                exists join inventTransOrigin_PO
                    where inventTransOrigin_PO.RecId == inventTrans_PO.InventTransOrigin
                exists join inventTrans_Project
                    where inventTransOrigin_PO.RecId == inventTrans_Project.MarkingRefInventTransOrigin
                exists join inventTransOrigin_Project
                    where inventTransOrigin_Project.RecId == inventTrans_Project.InventTransOrigin
                        && inventTransOrigin_Project.InventTransId == _projItemTrans.InventTransId;
        }
        else
        {
            select firstonly RecId from vendInvoiceTrans
                where vendInvoiceTrans.InventTransId == _projItemTrans.InventTransId
                    exists join vendInvoiceJour
                        where vendInvoiceJour.PurchId == vendInvoiceTrans.PurchID &&
                            vendInvoiceJour.InvoiceId == vendInvoiceTrans.InvoiceId &&
                            vendInvoiceJour.InvoiceDate == vendInvoiceTrans.InvoiceDate &&
                            vendInvoiceJour.NumberSequenceGroup == vendInvoiceTrans.NumberSequenceGroup &&
                            vendInvoiceJour.InternalInvoiceId == vendInvoiceTrans.InternalInvoiceId &&
                            vendInvoiceJour.LedgerVoucher == _projItemTrans.VoucherPackingSlip;
        }

        return vendInvoiceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkProjTransStatusIsCreditNoteProposal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     To check if project transaction status enum value is credit note proposal.
    /// </summary>
    /// <param name = "_projTransStatus">
    ///     Project transaction status enum value.
    /// </param>
    /// <returns>
    ///     true if project transaction status enum value is credit note proposal; otherwise, false.
    /// </returns>
    protected boolean checkProjTransStatusIsCreditNoteProposal(ProjTransStatus _projTransStatus)
    {
        return _projTransStatus == ProjTransStatus::CreditnoteProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExchangeRateHelperWithRates</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Update the exchange rate helper object when the user has set a manual exchange rate.
    /// </summary>
    /// <param name = "_exchangeRateHelper">
    ///     The exchange rate helper object use in posting transactions
    /// </param>
	private void updateExchangeRateHelperWithRates(CurrencyExchangeHelper _exchangeRateHelper)
	{
		if (this.parmProjTrans().buffer().TableId == tableNum(LedgerJournalTrans))
		{
			LedgerJournalTrans ledgerJournalTrans = this.parmProjTrans().buffer() as LedgerJournalTrans;
			if (ledgerJournalTrans != null)
			{
				_exchangeRateHelper.parmReportingExchangeRate1(ledgerJournalTrans.ReportingCurrencyExchRate);
				_exchangeRateHelper.parmReportingExchangeRate2(ledgerJournalTrans.ReportingCurrencyExchRateSecondary);
			}
		}
	}

]]></Source>
			</Method>
			<Method>
				<Name>getCreditNoteOrigTransInvoiceDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Getting original transaction invoice date to be considered during exchange rate retrieval for project credit note invoice posting.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    ///    The value of LedgerVoucherObject instance.
    /// </param>
    /// <returns>
    /// Returns invoice date of original transaction posted.
    /// </returns>
    private TransDate getCreditNoteOrigTransInvoiceDate(LedgerVoucherObject _ledgerVoucherObject)
    {
        InvoiceDate invoiceDate;
        boolean omitInvoiceDateCriteria = ProjCreditNoteOmitDateCriteriaForOriginalInvoiceFlight::instance().isEnabled();

        switch (projTrans.transType())
        {
            case ProjTransType::Hour:
                ProjEmplTransSale projEmplTransSale;
                ProjInvoiceEmpl projInvoiceEmpl;

                if (ProjPostOriginalInvoiceDateFlight::instance().isEnabled())
                {
                    ProjInvoiceEmplDetail projInvoiceEmplDetail;

                    select firstonly InvoiceDate from projInvoiceEmpl
                        order by projInvoiceEmpl.InvoiceDate desc
                        where projInvoiceEmpl.TransId == projTrans.transId()
                            && projInvoiceEmpl.Qty == -projTrans.qty()
                            && (omitInvoiceDateCriteria || projInvoiceEmpl.InvoiceDate != _ledgerVoucherObject.parmAccountingDate())
                        exists join projInvoiceEmplDetail
                            where projInvoiceEmplDetail.InvoiceRefRecId == projInvoiceEmpl.RecId
                        exists join projEmplTransSale
                            where projEmplTransSale.RecId == projInvoiceEmplDetail.SaleRefRecId
                                && projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projEmplTransSale.FundingSource == projTrans.fundingSource();
                }
                else
                {
                    select firstonly InvoiceDate from projInvoiceEmpl
                        order by projInvoiceEmpl.TransId desc
                        exists join projEmplTransSale
                            where projEmplTransSale.TransId == projTrans.transId()
                        && projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projInvoiceEmpl.TransId == projEmplTransSale.TransId
                                && projInvoiceEmpl.Qty == -projTrans.qty()
                                && (omitInvoiceDateCriteria || projInvoiceEmpl.InvoiceDate != _ledgerVoucherObject.parmAccountingDate());
                }

                if (projInvoiceEmpl.InvoiceDate)
                {
                    invoiceDate = projInvoiceEmpl.InvoiceDate;
                }
                break;

            case ProjTransType::Item:
                ProjItemTransSale projItemTransSale;
                ProjInvoiceItem projInvoiceItem;

                if (ProjPostOriginalInvoiceDateFlight::instance().isEnabled())
                {
                    ProjInvoiceItemDetail projInvoiceItemDetail;

                    select firstonly InvoiceDate from projInvoiceItem
                        order by projInvoiceItem.InvoiceDate desc
                        where projInvoiceItem.ProjTransId == projTrans.transId()
                            && projInvoiceItem.Qty == -projTrans.qty()
                            && (omitInvoiceDateCriteria || projInvoiceItem.InvoiceDate != _ledgerVoucherObject.parmAccountingDate())
                        exists join ProjInvoiceItemDetail
                            where projInvoiceItemDetail.InvoiceRefRecId == projInvoiceItem.RecId
                        exists join projItemTransSale
                            where projItemTransSale.RecId == projInvoiceItemDetail.SaleRefRecId
                                && projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projItemTransSale.FundingSource == projTrans.fundingSource();
                }
                else
                {
                    select firstonly InvoiceDate from projInvoiceItem
                        order by projInvoiceItem.ProjTransId desc
                        exists join projItemTransSale
                            where projItemTransSale.ProjTransId == projTrans.transId()
                                && projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projInvoiceItem.ProjTransId == projItemTransSale.ProjTransId
                                && projInvoiceItem.Qty == -projTrans.qty()
                                && (omitInvoiceDateCriteria || projInvoiceItem.InvoiceDate != _ledgerVoucherObject.parmAccountingDate());
                }

                if (projInvoiceItem.InvoiceDate)
                {
                    invoiceDate = projInvoiceItem.InvoiceDate;
                }
                break;

            case ProjTransType::Revenue:
                ProjRevenueTransSale projRevenueTransSale;
                ProjInvoiceRevenue projInvoiceRevenue;


                if (ProjPostOriginalInvoiceDateFlight::instance().isEnabled())
                {
                    ProjInvoiceRevenueDetail projInvoiceRevenueDetail;

                    select firstonly InvoiceDate from projInvoiceRevenue
                        order by projInvoiceRevenue.InvoiceDate desc
                        where projInvoiceRevenue.TransId ==  projTrans.transId()
                            && projInvoiceRevenue.Qty == -projTrans.qty()
                            && (omitInvoiceDateCriteria || projInvoiceRevenue.InvoiceDate != _ledgerVoucherObject.parmAccountingDate())
                        exists join ProjInvoiceRevenueDetail
                            where projInvoiceRevenueDetail.InvoiceRefRecId == projInvoiceRevenue.RecId
                        exists join projRevenueTransSale
                            where projRevenueTransSale.RecId == projInvoiceRevenueDetail.SaleRefRecId
                                && projRevenueTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projRevenueTransSale.FundingSource == projTrans.fundingSource();
                }
                else
                {
                    select firstonly InvoiceDate from projInvoiceRevenue
                        order by projInvoiceRevenue.TransId desc
                        exists join projRevenueTransSale
                            where projRevenueTransSale.TransId == projTrans.transId()
                                && projRevenueTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projInvoiceRevenue.TransId == projRevenueTransSale.TransId
                                && projInvoiceRevenue.Qty == -projTrans.qty()
                                && (omitInvoiceDateCriteria || projInvoiceRevenue.InvoiceDate != _ledgerVoucherObject.parmAccountingDate());
                }

                if (projInvoiceRevenue.InvoiceDate)
                {
                    invoiceDate = projInvoiceRevenue.InvoiceDate;
                }
                break;

            case ProjTransType::Cost:
                ProjCostTransSale projCostTransSale;
                ProjInvoiceCost projInvoiceCost;

                if (ProjPostOriginalInvoiceDateFlight::instance().isEnabled())
                {
                    ProjInvoiceCostDetail projInvoiceCostDetail;

                    select firstonly InvoiceDate from projInvoiceCost
                        order by projInvoiceCost.InvoiceDate desc
                        where projInvoiceCost.TransId == projTrans.transId()
                            && projInvoiceCost.Qty == -projTrans.qty()
                            && (omitInvoiceDateCriteria || projInvoiceCost.InvoiceDate != _ledgerVoucherObject.parmAccountingDate())
                        exists join ProjInvoiceCostDetail
                            where projInvoiceCostDetail.InvoiceRefRecId == projInvoiceCost.RecId
                        exists join projCostTransSale
                            where projCostTransSale.RecId == projInvoiceCostDetail.SaleRefRecId
                                && projCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projCostTransSale.FundingSource == projTrans.fundingSource();
                }
                else
                {
                    select firstonly InvoiceDate from projInvoiceCost
                        order by projInvoiceCost.TransId desc
                        exists join projCostTransSale
                            where projCostTransSale.TransId == projTrans.transId()
                                && projCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal
                                && projInvoiceCost.TransId == projCostTransSale.TransId
                                && projInvoiceCost.Qty == -projTrans.qty()
                                && (omitInvoiceDateCriteria || projInvoiceCost.InvoiceDate != _ledgerVoucherObject.parmAccountingDate());
                }

                if (projInvoiceCost.InvoiceDate)
                {
                    invoiceDate = projInvoiceCost.InvoiceDate;
                }
                break;

            case ProjTransType::OnAccount:

                if (ProjPostOriginalInvoiceDateFlight::instance().isEnabled())
                {
                    ProjOnAccTransSale projOnAccTransSale;
                    ProjInvoiceOnAcc projInvoiceOnAcc;
                    ProjInvoiceOnAccDetail projInvoiceOnAccDetail;
                    
                    select firstonly InvoiceDate from projInvoiceOnAcc
                        order by projInvoiceOnAcc.InvoiceDate desc
                        where projInvoiceOnAcc.TransId == projTrans.transId()
                            && projInvoiceOnAcc.Qty == projTrans.qty()
                        exists join projInvoiceOnAccDetail
                            where projInvoiceOnAccDetail.InvoiceRefRecId == projInvoiceOnAcc.RecId
                        exists join projOnAccTransSale
                            where projOnAccTransSale.RecId == projInvoiceOnAccDetail.SaleRefRecId
                                && projOnAccTransSale.TransStatus == ProjTransStatus::Registered
                                && projOnAccTransSale.FundingSource == projTrans.fundingSource();

                    if (projInvoiceOnAcc.InvoiceDate)
                    {
                        invoiceDate = projInvoiceOnAcc.InvoiceDate;
                    }
                }
                break;
        }

        return invoiceDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLedgerStatusPostingCost</Name>
				<Source><![CDATA[
    protected boolean isLedgerStatusPostingCost(ProjLedgerStatus _projLedgerStatus)
    {
        boolean ret = false;

        if (_projLedgerStatus == ProjLedgerStatus::BalanceSheet
            || _projLedgerStatus == ProjLedgerStatus::Operations)
        {
            ret = true;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>turnoverLedgerPostingType</Name>
				<Source><![CDATA[
    protected LedgerPostingType turnoverLedgerPostingType()
    {
        return this.postingType();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>