<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendCorrFactureCalc_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Class <c>CustVendCorrFactureCalc_RU</c> performs calculation of correcting facture data.
/// </summary>
class CustVendCorrFactureCalc_RU
{
    FactureJour_RU          factureJour;
    FactureJour_RU          factureCorrSource;
    FactureJour_RU          factureJourRev;
    FactureTrans_RU         factureTrans;
    FactureTrans_RU         factureTransOrig;
    FactureTrans_RU         factureTransCorr;
    Map                     mapFactureTransGroup;
    List                    listFactureTrans;
    FactureHeaderData_RU    headerData;

    container               origFactureNums;
    container               origFactureDates;
    container               origFactureSepDivIds;
    container               origFactureRevisionNums;
    container               origFactureRevisionDates;
    FactureExternalId_RU    factureNum;
    FactureDate_External_RU factureDate;
    SeparateDivisionId_RU   factureSepDivId;
    Amount                  totalAmountWTaxPlus;
    Amount                  totalAmountWTaxMinus;
    TaxAmount               totalTaxAmountPlus;
    TaxAmount               totalTaxAmountMinus;
    Amount                  totalLineAmountPlus;
    Amount                  totalLineAmountMinus;
    boolean                 headerOnlyMode;
    Map                     mapFactureCustomUnionMemberSale;

    boolean                isCustomUnionSaleAfter;
    boolean                isCustomUnionSaleBefore;
    TransDate              dateForFEACCBefore;

    #FactureHeader_RU
    #CustVendCorrFactureReport_RU
    #isoCountryRegionCodes

    protected const str russian = 'ru';


}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildTransMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates map holding corrections by lines.
    /// </summary>
    protected void buildTransMap()
    {
        container                   key;
        Struct                      factureTransData;
        MapEnumerator               mapEnumerator;
        ListEnumerator              listEnumerator;
        UnitOKEI                    unitOKEI;

        UnitOfMeasure               unitOfMeasure;
        UnitOfMeasureTranslation    unitOfMeasureTranslation;

        void setIncreaseDecrease(str _fieldNameBefore, str _fieldNameAfter, str _fieldNameIncrease, str _fieldNameDecrease)
        {
            Amount  amount = factureTransData.value(_fieldNameAfter) - factureTransData.value(_fieldNameBefore);

            if (amount > 0)
            {
                factureTransData.value(_fieldNameIncrease, amount);
            }
            else
            {
                factureTransData.value(_fieldNameDecrease, -amount);
            }
        }

        void addAmount(str _fieldName, real _amount)
        {
            factureTransData.value(_fieldName, factureTransData.value(_fieldName) + _amount);
        }

        listEnumerator = listFactureTrans.getEnumerator();
        while (listEnumerator.moveNext())
        {
            factureTransOrig.clear();
            [factureTransOrig, factureTrans] = listEnumerator.current();

            factureTrans.FactureLineType = FactureTrans_RU::find(factureTrans.FactureId,
                                                                 factureTrans.Module,
                                                                 factureTrans.LineNum).FactureLineType;
            key = [factureTrans.FactureId,
                   factureTrans.Price,
                   factureTrans.FactureLineType,
                   factureTrans.Module,
                   factureTrans.ItemName,
                   factureTrans.Unit,
                   factureTrans.vatType,
                   factureTrans.vatValue,
                   factureTrans.CountryRegionName,
                   factureTrans.ItemId,
                   factureTrans.InventGTDId,
                   factureTrans.InventDimId,
                   factureTrans.ExchRate];

            if (mapFactureTransGroup.exists(key))
            {
                factureTransData = mapFactureTransGroup.lookup(key);
            }
            else
            {
                factureTransData = CustVendCorrFactureCalc_RU::createFactureTransData();

                unitOfMeasure            = UnitOfMeasure::findBySymbol(factureTrans.Unit);
                unitOfMeasureTranslation = UnitOfMeasureTranslation::findByTranslation(unitOfMeasure.RecId, russian);
                unitOKEI                 = UnitOfMeasure_RU::unitOfMeasure_W(unitOfMeasure).NationalCode;

                factureTransData.value(#LineNumber              , this.getLineNumber());
                factureTransData.value(#Description             , this.getExternalName());
                factureTransData.value(#FEACCIdBefore           , this.getFEACCId(factureTransOrig, isCustomUnionSaleBefore, dateForFEACCBefore));
                factureTransData.value(#FEACCIdAfter            , this.getFEACCId(factureTrans, isCustomUnionSaleAfter, factureJour.FactureDate));
                factureTransData.value(#UnitCodeBefore          , unitOKEI);
                factureTransData.value(#UnitCodeAfter           , unitOKEI);
                factureTransData.value(#UnitIdBefore            , unitOfMeasureTranslation.Description);
                factureTransData.value(#UnitIdAfter             , unitOfMeasureTranslation.Description);
                factureTransData.value(#QtyBefore               , 0);
                factureTransData.value(#QtyAfter                , 0);
                factureTransData.value(#PriceBefore             , 0);
                factureTransData.value(#PriceAfter              , this.getPrice(factureJour, factureTrans));
                factureTransData.value(#VATValueBefore          , factureTrans.vatValue);
                factureTransData.value(#VATValueAfter           , factureTrans.vatValue);
                factureTransData.value(#LineAmountBefore        , 0);
                factureTransData.value(#LineAmountAfter         , 0);
                factureTransData.value(#LineAmountIncrease      , 0);
                factureTransData.value(#LineAmountDecrease      , 0);
                factureTransData.value(#ExciseBefore            , 0);
                factureTransData.value(#ExciseAfter             , 0);
                factureTransData.value(#ExciseIncrease          , 0);
                factureTransData.value(#ExciseDecrease          , 0);
                factureTransData.value(#TaxAmountBefore         , 0);
                factureTransData.value(#TaxAmountAfter          , 0);
                factureTransData.value(#TaxAmountIncrease       , 0);
                factureTransData.value(#TaxAmountDecrease       , 0);
                factureTransData.value(#AmountInclTaxBefore     , 0);
                factureTransData.value(#AmountInclTaxAfter      , 0);
                factureTransData.value(#AmountInclTaxIncrease   , 0);
                factureTransData.value(#AmountInclTaxDecrease   , 0);
                factureTransData.value(#CountryCodeBefore       , this.getCountryCode(factureTransOrig));
                factureTransData.value(#CountryBefore           , this.getCountryName(factureTransOrig));
                factureTransData.value(#CountryCodeAfter        , this.getCountryCode(factureTrans));
                factureTransData.value(#CountryAfter            , this.getCountryName(factureTrans));
            }

            if (factureTransOrig)
            {
                factureTransData.value(#PriceBefore, this.getPrice(factureJour, factureTransOrig));
                factureTransData.value(#VATValueBefore, factureTransOrig.vatValue);
            }

            addAmount(#QtyBefore            , factureTransOrig.Qty);
            addAmount(#LineAmountBefore     , this.getLineAmountWithExcise(factureJour, factureTransOrig));
            addAmount(#ExciseBefore         , this.getExcise(factureJour, factureTransOrig));
            addAmount(#TaxAmountBefore      , this.getVATAmount(factureJour, factureTransOrig));
            addAmount(#AmountInclTaxBefore  , this.getLineAmountWithVAT(factureJour, factureTransOrig));

            addAmount(#QtyAfter             , factureTrans.Qty);
            addAmount(#LineAmountAfter      , this.getLineAmountWithExcise(factureJour, factureTrans));
            addAmount(#ExciseAfter          , this.getExcise(factureJour, factureTrans));
            addAmount(#TaxAmountAfter       , this.getVATAmount(factureJour, factureTrans));
            addAmount(#AmountInclTaxAfter   , this.getLineAmountWithVAT(factureJour, factureTrans));

            mapFactureTransGroup.insert(key, factureTransData);
        }

        mapEnumerator = mapFactureTransGroup.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            factureTransData = mapEnumerator.currentValue();

            setIncreaseDecrease(
                #LineAmountBefore,
                #LineAmountAfter,
                #LineAmountIncrease,
                #LineAmountDecrease);

            setIncreaseDecrease(
                #ExciseBefore,
                #ExciseAfter,
                #ExciseIncrease,
                #ExciseDecrease);

            setIncreaseDecrease(
                #TaxAmountBefore,
                #TaxAmountAfter,
                #TaxAmountIncrease,
                #TaxAmountDecrease);

            setIncreaseDecrease(
                #AmountInclTaxBefore,
                #AmountInclTaxAfter,
                #AmountInclTaxIncrease,
                #AmountInclTaxDecrease);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates correction facture data.
    /// </summary>
    public void calc()
    {
        this.getCorrOrigTrans();

        if (!headerOnlyMode)
        {
            this.calcEACUData();
            this.buildTransMap();
        }

        this.calcHeader();

        if (!headerOnlyMode)
        {
            this.calcBody();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcEACUData</Name>
				<Source><![CDATA[
    private void calcEACUData()
    {
        FactureJour_RU  previousFacture;

        if (!factureJour.RefOriginalFacture)
        {
            previousFacture = FactureJour_RU::findRecId(factureJour.RecId);
        }
        else
        {
            select previousFacture
            order by CreatedDateTime desc, SeqNumber desc
            where previousFacture.RefOriginalFacture == factureJour.RefOriginalFacture &&
                  previousFacture.CreatedDateTime < factureJour.CreatedDateTime;

            if (!previousFacture)
            {
                previousFacture = FactureJour_RU::findRecId(factureJour.RefOriginalFacture);
            }
        }

        isCustomUnionSaleAfter = this.isCustomUnionSale(factureJour);
        isCustomUnionSaleBefore = this.isCustomUnionSale(previousFacture);
        dateForFEACCBefore = previousFacture.FactureDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates totals data.
    /// </summary>
    private void calcBody()
    {
        MapEnumerator   mapEnumerator;
        Struct          factureTransData;

        mapEnumerator = mapFactureTransGroup.getEnumerator();
        while (mapEnumerator.moveNext())
        {
            factureTransData = mapEnumerator.currentValue();

            totalTaxAmountPlus   += factureTransData.value(#TaxAmountIncrease);
            totalTaxAmountMinus  += factureTransData.value(#TaxAmountDecrease);
            totalAmountWTaxPlus  += factureTransData.value(#AmountInclTaxIncrease);
            totalAmountWTaxMinus += factureTransData.value(#AmountInclTaxDecrease);
            totalLineAmountPlus  += factureTransData.value(#LineAmountIncrease);
            totalLineAmountMinus += factureTransData.value(#LineAmountDecrease);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcHeader</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates facture header data.
    /// </summary>
    public void calcHeader()
    {
        FactureJour_RU          factureJourOrig;
        FactureJourParm_RU      factureJourParm;
        FactureHeaderData_RU    headerDataOrig;
        SeparateDivisionId_RU   separateDivId;

        factureJourParm = FactureJourParm_RU::newParameters(factureJour, true);
        headerData      = FactureHeaderData_RU::newFromCaller(factureJourParm);

        factureNum = factureCorrSource.FactureExternalId;
        factureSepDivId = headerData.getHeaderAttribute(#SeparateDivisionId);

        factureDate = factureCorrSource.FactureDate_External ?
                      factureCorrSource.FactureDate_External :
                      factureCorrSource.FactureDate;

        factureJourOrig = factureJour.getCorrectedFacture(true);
        while (factureJourOrig)
        {
            select firstonly factureJourRev
                order by CreatedDateTime desc, SeqNumber desc
                    where  factureJourRev.RefRevisedFacture == factureJourOrig.RecId       &&
                          (factureJourRev.CreatedDateTime   <  factureJour.CreatedDateTime ||
                          (factureJourRev.CreatedDateTime   == factureJour.CreatedDateTime &&
                           factureJourRev.SeqNumber         <  factureJour.SeqNumber));

            if (factureJourRev)
            {
                origFactureRevisionNums  += factureJourRev.RevisionNum;
                origFactureRevisionDates += strFmt("@GLS106007", factureJourRev.FactureDate_External ?
                                                                factureJourRev.FactureDate_External :
                                                                factureJourRev.FactureDate);
            }

            factureJourParm = FactureJourParm_RU::newParameters(factureJourRev ? factureJourRev : factureJourOrig);
            headerDataOrig  = FactureHeaderData_RU::newFromCaller(factureJourParm);

            separateDivId = headerDataOrig.getHeaderAttribute(#SeparateDivisionId);

            origFactureNums      += separateDivId                                                         ?
                                   strfmt("@GLS111217", factureJourOrig.FactureExternalId, separateDivId) : factureJourOrig.FactureExternalId;
            origFactureSepDivIds += separateDivId;

            origFactureDates += strFmt("@GLS106007", factureJourOrig.FactureDate_External  ?
                                                    factureJourOrig.FactureDate_External  :
                                                    factureJourOrig.FactureDate);
            next factureJourOrig;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCorrOrigTrans</Name>
				<Source><![CDATA[
    private void getCorrOrigTrans()
    {
        int                             idx;
        fieldId                         fieldId;
        boolean                         isLineCorrected;
        RefRecId                        factureCorrRecId;
        FactureTaxCorrectionEngine_RU   factureTaxCorrectionEngine;
        FactureTrans_RU                 tmpFactureTrans;
        FactureJour_RU                  factureJourOrig;
        FactureJour_RU                  factureJourLocal = factureJour.data();

        tmpFactureTrans.setTmp();

        factureCorrSource = factureJour.data();
        if (factureJour.CorrectionType == FactureCorrectionType_RU::Revision)
        {
            factureCorrSource = FactureJour_RU::findRecId(factureJour.RefRevisedFacture);

            factureJourOrig  = factureCorrSource.getCorrectedFacture();
            while (factureJourOrig)
            {
                factureCorrRecId = factureJourOrig.RecId;

                select firstonly factureJourLocal
                    order by CreatedDateTime desc, SeqNumber desc
                    where  factureJourLocal.RecId             == factureCorrRecId            ||
                          (factureJourLocal.RefRevisedFacture == factureCorrRecId            &&
                          (factureJourLocal.CreatedDateTime   <  factureJour.CreatedDateTime ||
                          (factureJourLocal.CreatedDateTime   == factureJour.CreatedDateTime &&
                           factureJourLocal.SeqNumber         <  factureJour.SeqNumber)));

                factureTaxCorrectionEngine = FactureTaxCorrectionEngine_RU::newParameters(factureJourLocal, false, false, false, true);
                tmpFactureTrans.setTmpData(factureTaxCorrectionEngine.getFactureTransOrig());

                while select tmpFactureTrans
                {
                    buf2Buf(tmpFactureTrans, factureTransOrig);
                    factureTransOrig.doInsert();
                }

                next factureJourOrig;
            }
        }
        else
        {
            factureTaxCorrectionEngine = FactureTaxCorrectionEngine_RU::newParameters(factureJourLocal);
            factureTransOrig.setTmpData(factureTaxCorrectionEngine.getFactureTransOrig());
        }

        factureJourLocal = factureJour.data();
        factureTaxCorrectionEngine = FactureTaxCorrectionEngine_RU::newParameters(factureJourLocal, false, false, false, true);
        factureTransCorr.setTmpData(factureTaxCorrectionEngine.getFactureTransOrig());

        while select factureTransCorr
            order by FactureId, LineNum
        {
            select firstonly factureTransOrig
                where factureTransOrig.FactureId == factureTransCorr.FactureId &&
                      factureTransOrig.Module    == factureTransCorr.Module    &&
                      factureTransOrig.LineNum   == factureTransCorr.LineNum;

            isLineCorrected = false;
            if (factureTransOrig)
            {
                if (factureTransOrig.Qty != factureTransCorr.Qty)
                {
                    isLineCorrected = true;
                }
                else
                {
                    for (idx = 1; idx <= conlen(FactureTaxCorrectionEngine_RU::amountFields()); idx++)
                    {
                        fieldId = conpeek(FactureTaxCorrectionEngine_RU::amountFields(), idx);
                        if (factureTransOrig.(fieldId) != factureTransCorr.(fieldId))
                        {
                            isLineCorrected = true;
                        }
                    }
                }
            }

            if (! factureTransOrig || isLineCorrected)
            {
                listFactureTrans.addEnd([factureTransOrig, factureTransCorr]);
            }
        }

        if (! listFactureTrans.elements())
        {
            while select factureTransCorr
                order by FactureId, LineNum
            {
                listFactureTrans.addEnd([factureTransCorr, factureTransCorr]);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExcise</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns excise amount for facture line.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being processed.
    /// </param>
    /// <param name="_factureTrans">
    /// <c>FactureTrans_RU</c> record being processed.
    /// </param>
    /// <returns>
    /// Excise amount for facture line.
    /// </returns>
    protected TaxAmountExcise_RU getExcise(FactureJour_RU _factureJour, FactureTrans_RU _factureTrans)
    {
        return _factureJour.PrintInMST ? _factureTrans.ExciseAmountMST : _factureTrans.Excise;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExternalName</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns external name for item.
    /// </summary>
    /// <returns>
    /// External name for item.
    /// </returns>
    protected ExternalItemFreeTxt getExternalName()
    {
        return factureTrans.ItemName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns external facture date.
    /// </summary>
    /// <returns>
    /// External facture date.
    /// </returns>
    public FactureDate_External_RU getFactureDate()
    {
        return factureDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureJourRev</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns revising facture journal.
    /// </summary>
    /// <returns>
    /// Revising facture journal.
    /// </returns>
    public FactureJour_RU getFactureJourRev()
    {
        return factureJourRev;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns facture number.
    /// </summary>
    /// <returns>
    /// Facture number.
    /// </returns>
    public FactureExternalId_RU getFactureNum()
    {
        return factureNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFactureSepDivId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns facture separate division id.
    /// </summary>
    /// <returns>
    /// Facture separate division id.
    /// </returns>
    public SeparateDivisionId_RU getFactureSepDivId()
    {
        return factureSepDivId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHeaderData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns calculated <c>FactureHeaderData_RU</c> object.
    /// </summary>
    /// <returns>
    /// Calculated <c>FactureHeaderData_RU</c> object.
    /// </returns>
    public FactureHeaderData_RU getHeaderData()
    {
        return headerData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineAmountWithExcise</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns line amount with excise for facture line.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being processed.
    /// </param>
    /// <param name="_factureTrans">
    /// <c>FactureTrans_RU</c> record being processed.
    /// </param>
    /// <returns>
    /// Line amount with excise for facture line.
    /// </returns>
    protected TaxAmount getLineAmountWithExcise(FactureJour_RU _factureJour, FactureTrans_RU _factureTrans)
    {
        return this.getLineAmountWithVAT(_factureJour, _factureTrans) - this.getVATAmount(_factureJour, _factureTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineAmountWithVAT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns line amount with VAT for facture line.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being processed.
    /// </param>
    /// <param name="_factureTrans">
    /// <c>FactureTrans_RU</c> record being processed.
    /// </param>
    /// <returns>
    /// Line amount with VAT for facture line.
    /// </returns>
    protected TaxAmount getLineAmountWithVAT(FactureJour_RU _factureJour, FactureTrans_RU _factureTrans)
    {
        return _factureJour.PrintInMST                                  ?
               _factureTrans.LineAmountMST + _factureTrans.TaxAmountMST :
               _factureTrans.LineAmount    + _factureTrans.TaxAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMapFactureTransGroup</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns map containing facture trans data.
    /// </summary>
    /// <returns>
    /// Map containing facture trans data.
    /// </returns>
    public Map getMapFactureTransGroup()
    {
        return mapFactureTransGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigFactureDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns original facture dates.
    /// </summary>
    /// <returns>
    /// Original facture dates.
    /// </returns>
    public container getOrigFactureDates()
    {
        return origFactureDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigFactureNums</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns original facture numbers.
    /// </summary>
    /// <returns>
    /// Original facture numbers.
    /// </returns>
    public container getOrigFactureNums()
    {
        return origFactureNums;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigFactureRevisionDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns original facture revision dates.
    /// </summary>
    /// <returns>
    /// Original facture revision dates.
    /// </returns>
    public container getOrigFactureRevisionDate()
    {
        return origFactureRevisionDates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigFactureRevisionNum</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns original facture revision numbers.
    /// </summary>
    /// <returns>
    /// Original facture revision numbers.
    /// </returns>
    public container getOrigFactureRevisionNum()
    {
        return origFactureRevisionNums;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrigFactureSepDivIds</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns original facture separate division ids.
    /// </summary>
    /// <returns>
    /// Original facture separate division ids.
    /// </returns>
    public container getOrigFactureSepDivIds()
    {
        return origFactureSepDivIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns price for facture line.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being processed.
    /// </param>
    /// <param name="_factureTrans">
    /// <c>FactureTrans_RU</c> record being processed.
    /// </param>
    /// <returns>
    /// Price for facture line.
    /// </returns>
    protected Price getPrice(FactureJour_RU _factureJour, FactureTrans_RU _factureTrans)
    {
        Price ret;
        Qty   qty = _factureTrans.Qty;

        if (! qty)
        {
            return 0;
        }

        if (_factureTrans.Price)
        {
            if (_factureJour.PrintInMST &&
                abs(CurrencyExchangeHelper::amountCur2MST(_factureTrans.Price * qty, _factureJour.CurrencyCode, _factureTrans.ExchRate)) == abs(_factureTrans.LineAmountMST))
            {
                ret = CurrencyExchangeHelper::amountCur2MST(_factureTrans.Price, _factureJour.CurrencyCode, _factureTrans.ExchRate);
            }
            else
            {
                ret = CurrencyExchangeHelper::amount(abs(this.getLineAmountWithExcise(_factureJour, _factureTrans) / qty));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalAmountWTaxMinus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns total deducted line amount with tax after corrections.
    /// </summary>
    /// <returns>
    /// Total deducted line amount with tax after corrections.
    /// </returns>
    public Amount getTotalAmountWTaxMinus()
    {
        return totalAmountWTaxMinus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalAmountWTaxPlus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns total additional line amount with tax after corrections.
    /// </summary>
    /// <returns>
    /// Total additional line amount with tax after corrections.
    /// </returns>
    public Amount getTotalAmountWTaxPlus()
    {
        return totalAmountWTaxPlus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalLineAmountMinus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns total deducted line amount after corrections.
    /// </summary>
    /// <returns>
    /// Total deducted line amount after corrections.
    /// </returns>
    public Amount getTotalLineAmountMinus()
    {
        return totalLineAmountMinus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalLineAmountPlus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns total additional line amount after corrections.
    /// </summary>
    /// <returns>
    /// Total additional line amount after corrections.
    /// </returns>
    public Amount getTotalLineAmountPlus()
    {
        return totalLineAmountPlus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalTaxAmountMinus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns decreased tax amount after corrections.
    /// </summary>
    /// <returns>
    /// Decreased tax amount after corrections.
    /// </returns>
    public TaxAmount getTotalTaxAmountMinus()
    {
        return totalTaxAmountMinus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalTaxAmountPlus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns additional tax amount after corrections.
    /// </summary>
    /// <returns>
    /// Additional tax amount after corrections.
    /// </returns>
    public TaxAmount getTotalTaxAmountPlus()
    {
        return totalTaxAmountPlus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitDescription</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns description of unit for facture line.
    /// </summary>
    /// <returns>
    /// Description of unit for facture line.
    /// </returns>
    protected Description getUnitDescription()
    {
        Description ret = UnitOfMeasureTranslation::findByTranslation(
            UnitOfMeasure::findBySymbol(factureTrans.Unit).RecId,
            factureJour.languageId()).Description;

        if (! ret)
        {
            ret = factureTrans.Unit;
        }

        return ret ? ret : "@SYS77038";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVATAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns amount of VAT for facture line.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being processed.
    /// </param>
    /// <param name="_factureTrans">
    /// <c>FactureTrans_RU</c> record being processed.
    /// </param>
    /// <returns>
    /// Amount of VAT for facture line.
    /// </returns>
    protected TaxAmount getVATAmount(FactureJour_RU _factureJour, FactureTrans_RU _factureTrans)
    {
        return _factureJour.PrintInMST ? _factureTrans.vatAmountMST : _factureTrans.vat;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFEACCInventTableSearchParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the search parameters for finding the <c>FEACCInventTable_RU</c> table.
    /// </summary>
    /// <param name="_factureTrans">
    /// <c>FactureTrans_RU</c> record being processed.
    /// </param>
    /// <param name="_date">
    /// The date to which the FEACCId should relate.
    /// </param>
    /// <returns>The search parameters.</returns>
    protected FEACCInventTable_RU initializeFEACCInventTableSearchParameters(FactureTrans_RU _factureTrans, TransDate _date)
    {
        FEACCInventTable_RU searchParameters;
        searchParameters.initValue();

        searchParameters.ItemId = _factureTrans.ItemId;
        searchParameters.ActivationDate = _date;

        return searchParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFEACCId</Name>
				<Source><![CDATA[
    private FEACCId_RU getFEACCId(FactureTrans_RU _factureTrans, boolean _isCustomUnionSale, TransDate _date)
    {
        FEACCId_RU feaccId;

        if (_isCustomUnionSale)
        {
            feaccId = FEACCInventTable_RU::findFEACCIdByNaturalKeyAndInventGTD(this.initializeFEACCInventTableSearchParameters(_factureTrans, _date), _factureTrans.InventGTDId);
        }

        return feaccId ? feaccId : #ScorecardMissing;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isCustomUnionSale</Name>
				<Source><![CDATA[
    private boolean isCustomUnionSale(FactureJour_RU _factureJour)
    {
        FactureJourHeader_RU locFactureHeader = _factureJour.factureHeader();

        LogisticsAddressCountryRegion countryRegion = LogisticsAddressCountryRegion::find(DirParty::primaryPostalAddress(locFactureHeader.ConsigneeParty).CountryRegionId);

        return countryRegion.MemberOfCustomsUnion_RU && countryRegion.ISOcode != #isoRU;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()

    {
        mapFactureTransGroup = new Map(Types::Container, Types::Class);
        listFactureTrans     = new List(Types::Container);

        mapFactureCustomUnionMemberSale = new Map(Types::Int64, Types::Enum);

        factureTransOrig.setTmp();
        factureTransCorr.setTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [
            origFactureNums,
            origFactureDates,
            origFactureSepDivIds,
            origFactureRevisionNums,
            origFactureRevisionDates,
            factureNum,
            factureDate,
            factureSepDivId,
            totalAmountWTaxPlus,
            totalAmountWTaxMinus,
            totalTaxAmountPlus,
            totalTaxAmountMinus,
            totalLineAmountPlus,
            totalLineAmountMinus,
            factureJourRev, 
            mapFactureTransGroup.pack(), 
            listFactureTrans.pack(), 
            headerData.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFactureJour</Name>
				<Source><![CDATA[
    public FactureJour_RU parmFactureJour(FactureJour_RU _factureJour)
    {
        factureJour = _factureJour;
        return factureJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmHeaderOnlyMode</Name>
				<Source><![CDATA[
    public boolean parmHeaderOnlyMode(boolean _headerOnlyMode = headerOnlyMode)
    {
        headerOnlyMode = _headerOnlyMode;

        return headerOnlyMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        boolean     ret     = true;
        container   packedMap,
                    packedList,
                    packedHeaderData;

        [   origFactureNums,
            origFactureDates,
            origFactureSepDivIds,
            origFactureRevisionNums,
            origFactureRevisionDates,
            factureNum,
            factureDate,
            factureSepDivId,
            totalAmountWTaxPlus,
            totalAmountWTaxMinus,
            totalTaxAmountPlus,
            totalTaxAmountMinus,
            totalLineAmountPlus,
            totalLineAmountMinus,
            factureJourRev, 
            packedMap, 
            packedList, 
            packedHeaderData] = _packedClass;

        mapFactureTransGroup = Map::create(packedMap);
        listFactureTrans = List::create(packedList);

        headerData       = FactureHeaderData_RU::construct();
        headerData.unpack(packedHeaderData);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcOnServer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs calculation of facture data on server.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being calculated.
    /// </param>
    /// <param name="_headerOnlyMode">
    /// Determines if only header should be calculated.
    /// </param>
    /// <returns>
    /// Container with packed results of calculation.
    /// </returns>
    protected static container calcOnServer(FactureJour_RU _factureJour, boolean _headerOnlyMode = false)
    {
        CustVendCorrFactureCalc_RU custVendCorrFactureCalc = CustVendCorrFactureCalc_RU::newCalc(_factureJour, _headerOnlyMode);

        custVendCorrFactureCalc.calc();

        return custVendCorrFactureCalc.pack();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method calculates correcting facture data on server and then transfers it to client.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being calculated.
    /// </param>
    /// <param name="_headerOnlyMode">
    /// Determines if only header should be calculated.
    /// </param>
    /// <returns>
    /// Calculated instance of <c>CustVendCorrFactureCalc_RU</c>
    /// </returns>
    public static CustVendCorrFactureCalc_RU calculate(FactureJour_RU _factureJour, boolean _headerOnlyMode = false)
    {
        CustVendCorrFactureCalc_RU custVendCorrFactureCalc = CustVendCorrFactureCalc_RU::construct();

        custVendCorrFactureCalc.unpack(CustVendCorrFactureCalc_RU::calcOnServer(_factureJour, _headerOnlyMode));

        return custVendCorrFactureCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendCorrFactureCalc_RU construct()
    {
        return new CustVendCorrFactureCalc_RU();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFactureTransData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes <c>Struct</c> object holding correcting facture data.
    /// </summary>
    /// <returns>
    /// New empty instance of <c>Struct</c> object.
    /// </returns>
    protected static Struct createFactureTransData()
    {
        Struct factureTransData;

        factureTransData = new Struct(
            Types::Integer,#LineNumber,
            Types::String, #Description,
            Types::String, #FEACCIdBefore,
            Types::String, #FEACCIdAfter,
            Types::String, #UnitCodeBefore,
            Types::String, #UnitCodeAfter,
            Types::String, #UnitIdBefore,
            Types::String, #UnitIdAfter,
            Types::Real  , #QtyBefore,
            Types::Real  , #QtyAfter,
            Types::Real  , #PriceBefore,
            Types::Real  , #PriceAfter,
            Types::Real  , #LineAmountBefore,
            Types::Real  , #LineAmountAfter,
            Types::Real  , #LineAmountIncrease,
            Types::Real  , #LineAmountDecrease,
            Types::Real  , #ExciseBefore,
            Types::Real  , #ExciseAfter,
            Types::Real  , #ExciseIncrease,
            Types::Real  , #ExciseDecrease,
            Types::Real  , #VATValueBefore,
            Types::Real  , #VATValueAfter,
            Types::Real  , #TaxAmountBefore,
            Types::Real  , #TaxAmountAfter,
            Types::Real  , #TaxAmountIncrease,
            Types::Real  , #TaxAmountDecrease,
            Types::Real  , #AmountInclTaxBefore,
            Types::Real  , #AmountInclTaxAfter,
            Types::Real  , #AmountInclTaxIncrease,
            Types::Real  , #AmountInclTaxDecrease,
            Types::String, #CountryCodeBefore,
            Types::String, #CountryBefore,
            Types::String, #CountryCodeAfter,
            Types::String, #CountryAfter);

        return factureTransData;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newCalc</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new instance of <c>CustVendCorrFactureCalc_RU</c> class.
    /// </summary>
    /// <param name="_factureJour">
    /// <c>FactureJour_RU</c> record being calculated.
    /// </param>
    /// <param name="_headerOnlyMode">
    /// Determines if only header should be calculated.
    /// </param>
    /// <returns>
    /// New instance of <c>CustVendCorrFactureCalc_RU</c> class.
    /// </returns>
    static public CustVendCorrFactureCalc_RU newCalc(FactureJour_RU      _factureJour,
                                                     boolean             _headerOnlyMode = false)
    {
        CustVendCorrFactureCalc_RU custVendCorrFactureCalc;

        custVendCorrFactureCalc = CustVendCorrFactureCalc_RU::construct();

        custVendCorrFactureCalc.parmFactureJour(_factureJour);
        custVendCorrFactureCalc.parmHeaderOnlyMode(_headerOnlyMode);

        return custVendCorrFactureCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCountryCode</Name>
				<Source><![CDATA[
    private CountryOKSMCode_RU getCountryCode(FactureTrans_RU _factureTrans)
    {
        CountryOKSMCode_RU countryOKSMCode;

        if (_factureTrans.InventGTDId && _factureTrans.ItemId)
        {
            AddressCountryRegionId          addressCountryRegionId;
            addressCountryRegionId        = InventGTD_RU::find(_factureTrans.InventGTDId, _factureTrans.ItemId).ItemOrigCountryRegionId;

            countryOKSMCode = LogisticsAddressCountryRegion::find(addressCountryRegionId).OKSMCode_RU;
        }

        return countryOKSMCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCountryName</Name>
				<Source><![CDATA[
    private AddressCountryRegionName getCountryName(FactureTrans_RU _factureTrans)
    {
        AddressCountryRegionName countryName;

        if (_factureTrans.InventGTDId && _factureTrans.ItemId)
        {
            AddressCountryRegionId addressCountryRegionId;
            addressCountryRegionId = InventGTD_RU::find(_factureTrans.InventGTDId, _factureTrans.ItemId).ItemOrigCountryRegionId;
            countryName = LogisticsAddressCountryRegionTranslation::find(addressCountryRegionId, factureJour.LanguageId).ShortName;
        }
        else if (_factureTrans.CountryRegionName)
        {
            countryName = _factureTrans.CountryRegionName;
        }

        return countryName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLineNumber</Name>
				<Source><![CDATA[
    private int getLineNumber()
    {
        return any2Int(factureTransOrig.LineNum);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>