<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvExpTransSourceDocLineItem</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>TrvExpTransSourceDocLineItem</c> class provides the information to handle the distributions
///    and sub-ledger journal account entries for an expense report line.
/// </summary>
[SourceDocumentEnumExtensionAttribute(enumStr(SourceDocumentLine_ExpenseReport), SourceDocumentLine_ExpenseReport::ExpenseReportLine)]
class TrvExpTransSourceDocLineItem extends SourceDocumentLineItem
            implements SourceDocumentLineItemIProjectTransDate,
               SourceDocumentLineItemIExpenseReport,
               SourceDocumentLineItemIProductQuantity,
               SourceDocumentLineItemIAccDateUpdateable,
               SourceDocumentLineItemIDescription,
               SourceDocumentLineItemIAccountingDateGroupable
{
    TrvExpTrans                 trvExpTrans;
    ProjTransIdBase             projTransId;
    TrvParameters               trvParameters;
    ProjId                      projId;
    ProjCategoryId              projCategoryId;
    ProjTaxItemGroup            projTaxItemGroup;
    ProjSalesCurrencyCode       projSalesCurrencyCode;
    SalesPrice                  salesPrice;
    ProjTaxGroup                projTaxGroup;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>calculateDefaultDimension</Name>
				<Source><![CDATA[
    protected DimensionDefault calculateDefaultDimension()
    {
        return trvExpTrans.DefaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLegalEntityRecId</Name>
				<Source><![CDATA[
    protected LegalEntityRecId calculateLegalEntityRecId()
    {
        return trvExpTrans.LegalEntity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSourceDocumentAmountMap</Name>
				<Source><![CDATA[
    protected SourceDocumentAmountMap calculateSourceDocumentAmountMap()
    {
        SourceDocumentAmountMap         sourceDocumentAmountMap = SourceDocumentAmountMap::construct();
        SourceDocumentAmount            sourceDocumentAmount;
        AmountCur                       amountCur;
        TrvCurrencyCode                 exchangeCode = trvExpTrans.isCreditCardTransaction() ? trvExpTrans.CreditCardTransactionCurrency : trvExpTrans.ExchangeCode;

        if (trvExpTrans.ExpType == TrvExpType::Personal && trvParameters.PersonalPaidBy == TrvPersonalPaidBy::Employee)
        {
            amountCur = 0;
        }
        else if (trvExpTrans.LineType == TrvExpLineType::ItemizedHeader)
        {
            amountCur = 0;
        }
        else
        {
            amountCur = CurrencyExchangeHelper::amount(trvExpTrans.NetTransactionAmount, exchangeCode);
        }

        sourceDocumentAmount = SourceDocumentAmount::newFromParameters(this.parmSourceDocumentLine(),
                                    amountCur,
                                    MonetaryAmount::ExtendedPrice,
                                    false);

        sourceDocumentAmountMap.insert(sourceDocumentAmount);

        return sourceDocumentAmountMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLineMatchAmountExceedReferenceDist</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the total line match amount can exceed the reference distribution amount.
    /// </summary>
    /// <returns>
    /// true if the total line match amount can exceed the reference distribution; otherwise, false.
    /// </returns>
    public boolean canLineMatchAmountExceedReferenceDist()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the accounting date can be updated when it lies in a closed period. Date changes
    /// will only occur during posting.
    /// </summary>
    /// <returns>
    /// true if the document is in an approved state and the accounting date can be updated; otherwise, false.
    /// </returns>
    public boolean canUpdateAccountingDate()
    {
        // The posting date should be same as the date on which the expense report is posted instead of transaction date when allow
        // grouping of transactions parameter is marked as true. Also this scenario is possible only for header level posting.
        return (trvParameters.IsAllowUpdateAccountingDate || (trvParameters.AllowGroupingForPostTransactions && trvExpTrans.LineLevelPosting == NoYes::No))
               && trvExpTrans.ApprovalStatus == TrvAppStatus::Approved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentsBusinessEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>SourceDocumentLineItem</c> class documents a business event.
    /// </summary>
    /// <returns>
    /// true if the <c>SourceDocumentLineItem</c> class documents a business event; otherwise, false.
    /// </returns>
    public BusinessEvent documentsBusinessEvent()
    {
        BusinessEvent       businessEvent;

        businessEvent = new BusinessEvent(enumNum(BusinessEvent_ExpenseReport), BusinessEvent_ExpenseReport::PurchaseOfExpensedProducts);

        return businessEvent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentsInterCompanyBusinessEvent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether the <c>SourceDocumentLineItem</c> documents an intercompany business event.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    public boolean documentsInterCompanyBusinessEvent()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultAccountFromExpenseCategory</Name>
				<Source><![CDATA[
    protected LedgerDimensionAccount getDefaultAccountFromExpenseCategory()
    {
        LedgerDimensionAccount ledgerDimension = 0;
        TrvPartyEmployeeRelationship trvEmpSetup;
        TrvCashAdvance  trvCashAdvance;
        TrvExchSetup    trvExchSetup;
        boolean isFromTransaction = false;

        TrvInstrumentationHelper::logExpenseOperationsInformation(strFmt('Getting the default ledger dimension for expCategory or expSubcategory for expense: %1' , trvExpTrans.RecId) , classStr(TrvExpTransSourceDocLineItem));
        if (trvExpTrans.ExpType == TrvExpType::Personal)
        {
            //Get ledgerDimension from Worker
            trvEmpSetup = TrvPartyEmployeeRelationship::find(trvExpTrans.CreatingWorker);
            if (trvEmpSetup && trvEmpSetup.parmLedgerDimension())
            {
                if (trvExpTrans.InterCompanyLE &&
                    trvExpTrans.InterCompanyLE != trvExpTrans.ReferenceDataAreaId &&
                    trvExpTrans.ProjId == '' &&
                    !(trvExpTrans.doesSplitLineHasParentExpWithProj(trvExpTrans)))
                {
                    // Non project-related expenses go to the other LE. Project-based ones are posted in the
                    // employee's company and later transfered to the other LE with an intercompany invoice
                    changecompany(trvExpTrans.InterCompanyLE)
                    {
                        ledgerDimension = TrvExpTransSourceDocLineItem::convertToLedgerDimension(trvEmpSetup.AccountType,trvEmpSetup.LedgerDimension);
                    }
                }
                else
                {
                    ledgerDimension = TrvExpTransSourceDocLineItem::convertToLedgerDimension(trvEmpSetup.AccountType,trvEmpSetup.LedgerDimension);
                }
            }
        }
        else if (trvExpTrans.ExpType == TrvExpType::Advance)
        {
            // Get ledgerDimension from cash advance transaction or setup
            trvCashAdvance = TrvCashAdvance::findRecId(trvExpTrans.CashAdvanceRecId);
            if (trvCashAdvance)
            {
                if (trvCashAdvance.AdvanceLedgerDimension)
                {
                    ledgerDimension = TrvExpTransSourceDocLineItem::convertToLedgerDimension(trvCashAdvance.AccountType,trvCashAdvance.AdvanceLedgerDimension);
                }
                else
                {
                    trvExchSetup = TrvExchSetup::find(trvCashAdvance.CurrencyCode);
                    if (trvExchSetup)
                    {
                        ledgerDimension = TrvExpTransSourceDocLineItem::convertToLedgerDimension(trvExchSetup.AccountType,trvExchSetup.AdvanceAccountLedgerDimension);
                    }
                }
            }
        }
        else
        {
            // Get ledgerDimension from expense sub category
            if (trvExpTrans.SubCategoryRecId)
            {
                if (trvExpTrans.InterCompanyLE &&
                    trvExpTrans.ReferenceDataAreaId &&
                    trvExpTrans.InterCompanyLE != trvExpTrans.ReferenceDataAreaId &&
                    trvExpTrans.ProjId == '')
                {
                    ledgerDimension = this.initializeICSubCategoryLedgerDimension();
                }
                else
                {
                    ledgerDimension = TrvExpSubCategory::findByRecId(trvExpTrans.SubCategoryRecId).LedgerDimension;
                }
            }

            // Get ledgerDimension from expense category
            if (ledgerDimension == 0 &&
                trvExpTrans.InterCompanyLE &&
                trvExpTrans.ReferenceDataAreaId &&
                trvExpTrans.InterCompanyLE != trvExpTrans.ReferenceDataAreaId &&
                trvExpTrans.ProjId == '')
            {
                ledgerDimension = this.initializeInterCompanyLedgerDimension();
            }
            else if (ledgerDimension == 0)
            {
                ledgerDimension = TrvCostType::find(trvExpTrans.CostType).LedgerDimension;
            }
        }

        TrvInstrumentationHelper::logExpenseOperationsInformation(strFmt('Ledger Dimension calculated for expense: %1' , ledgerDimension) , classStr(TrvExpTransSourceDocLineItem));
        
        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasMainAccDerivationInputChanged</Name>
				<Source><![CDATA[
    public boolean hasMainAccDerivationInputChanged()
    {
        // For following conditions treat legal entity change similar to main account change 
		// so that accounting distributions would get re created.
        if (this.hasLegalEntityChanged() ||
			trvExpTrans.isDimensionModified())
        {
            return true;
        }

        if (this.parmOriginSourceDocumentLineItem())
        {
            return false;
        }

        if (trvExpTrans.ExpType == TrvExpType::Transport && trvExpTrans.ApprovalStatus == TrvAppStatus::Approved && trvExpTrans.Voucher != '')
        {
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLegalEntityChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies whether legal entity on expense line has been different from the accountingDistribution.
    /// </summary>
    /// <returns>true if the legal entity has changed; otherwise, false.</returns>
    private boolean hasLegalEntityChanged()
    {
        AccountingDistribution      accountingDistributionLegalEntity;

        select firstonly AccountingLegalEntity from accountingDistributionLegalEntity
            where accountingDistributionLegalEntity.SourceDocumentLine == trvExpTrans.SourceDocumentLine;

        if (accountingDistributionLegalEntity.AccountingLegalEntity != 0 && CompanyInfo::findDataArea(trvExpTrans.InterCompanyLE).RecId != accountingDistributionLegalEntity.AccountingLegalEntity)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeImplementation</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the instance variables.
    /// </summary>
    /// <param name="_sourceDocumentLineImplementation">
    ///    A source document line implementation table.
    /// </param>
    /// <param name="_additionalInformation">
    /// A map to hold buffers of pre initiliazed objects needed by the framework to the source document.
    /// </param>
    protected void initializeImplementation(SourceDocumentLineImplementation _sourceDocumentLineImplementation, Map _additionalInformation = null)
    {
        trvExpTrans = _sourceDocumentLineImplementation;
        trvParameters = TrvParameters::find();
        this.initProject();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInterCompanyLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ledger dimension when intercompany is enabled and the project is not attached to the expense report.
    /// </summary>
    /// <returns>
    /// The ledger dimension value of the expense category.
    /// </returns>
    /// <remarks>
    /// This method initializes the ledger dimension when intercompany is enabled.
    /// </remarks>
    private LedgerDimensionAccount initializeInterCompanyLedgerDimension()
    {
        TrvCostType             trvCostType;
        CategoryTable           categoryTable;
        SharedCategory          sharedCategory;
        LedgerDimensionAccount  ledgerDimension = 0;

        categoryTable = CategoryTable::find(trvExpTrans.CostType);
        sharedCategory = SharedCategory::findRecId(categoryTable.SharedCategory);

        if (trvExpTrans.InterCompanyLE)
        {
            changecompany(trvExpTrans.InterCompanyLE)
            {
                categoryTable.clear();
                select CategoryId from categoryTable where categoryTable.SharedCategory == sharedCategory.RecId;

                trvCostType = TrvCostType::find(categoryTable.CategoryId);

                if (trvCostType)
                {
                    ledgerDimension = trvCostType.LedgerDimension;
                }
            }
        }

        return ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOriginSourceDocumentLineItem</Name>
				<Source><![CDATA[
    protected void initOriginSourceDocumentLineItem()
    {
        SourceDocumentLine originSourceDocumentLine;

        TrvExpTrans trvExpTransParent;

        // Support mileage multiple tier posting
        // That is new expense line is created during posting, and it should be distributed the same way it's original expense line
        if (trvExpTrans.ExpType == TrvExpType::Transport && trvExpTrans.ApprovalStatus == TrvAppStatus::Approved)
        {
            if (trvExpTrans.ParentRecId)
            {
                select SourceDocumentLine from trvExpTransParent where trvExpTransParent.RecId == trvExpTrans.ParentRecId;

                select originSourceDocumentLine  where originSourceDocumentLine.RecId == trvExpTransParent.SourceDocumentLine;

                originSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(originSourceDocumentLine);
            }
        }
        else if (trvExpTrans.OriginalSourceDocumentLine)
        {
            originSourceDocumentLineItem = SourceDocumentLineItem::newFromSourceDocumentLine(SourceDocumentLine::find(trvExpTrans.OriginalSourceDocumentLine));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeProjectPriceParametersForCostSalesPrice</Name>
				<Source><![CDATA[
    protected ProjPriceParameters initializeProjectPriceParametersForCostSalesPrice(
		ProjId _projId,
        ProjCategoryId _projCategoryId,
		CostPrice _costPrice,
		TrvCurrencyCode _costCurrencyID,
        ProjSalesCurrencyCode _projSalesCurrencyId,
		TrvExpTrans _trvExpTrans) 
	{ 
        // when exchrate = 0, the system would calculate price based on what's defined in GL setup. When any other value is passed,
        // it calculates based on the exchange rate based on the value passed. One of such scenario will be, when 2 currencies are involved,
        // it will be expecting exchange rate should be same specified in expense line, when sales currency and the accounting currency are same.
        ExchRate exchRate = (_projSalesCurrencyId == Ledger::accountingCurrency(trvExpTrans.LegalEntity)) ? trvExpTrans.ExchangeRate : 0;

        ProjPriceParameters priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                _projId,
                ResourceFacade::findByWorker(_trvExpTrans.CreatingWorker, _trvExpTrans.LegalEntity),
                _projCategoryId,
                _costPrice,
                _costCurrencyID,
                _projSalesCurrencyId,
                _trvExpTrans.TransDate,
                '',
                '',
                '',
                exchRate);

        return priceParams;

	}

]]></Source>
			</Method>
			<Method>
				<Name>initProject</Name>
				<Source><![CDATA[
    private void initProject()
    {
        ProjTable               projTableLocal;
        ProjCategoryId          projCategoryIdLocal;
        ProjTaxItemGroup        projTaxItemGroupLocal;
        ProjSalesCurrencyCode   projSalesCurrencyCodeLocal;
        SalesPrice              salesPriceLocal;
        ProjTaxGroup            projTaxGroupLocal;
        ProjCategory            projCategoryLELocal;
        boolean                 isInterCompanyLE;

        ProjTable getProjTableLocal()
        {
            projTableLocal = ProjTable::find(trvExpTrans.ProjId);

            return projTableLocal;
        }

        ProjCategoryId  getProjCategoryId()
        {
            if (isInterCompanyLE && trvExpTrans.InterCompanyCategory != '')
            {
                projCategoryLELocal = ProjCategory::find(trvExpTrans.InterCompanyCategory);
                projCategoryIdLocal = projCategoryLELocal.CategoryId;
            }
            else
            {
                projCategoryIdLocal = trvExpTrans.CostType;
            }

            return projCategoryIdLocal;
        }

        ProjTaxItemGroup getProjTaxItemGroup()
        {
            if (isInterCompanyLE)
            {
                projTaxItemGroupLocal = projCategoryLELocal.TaxItemGroupId;
            }
            else
            {
                projTaxItemGroupLocal = ProjCategory::find(projCategoryId).TaxItemGroupId;
            }

            return projTaxItemGroupLocal;
        }

        ProjSalesCurrencyCode getProjSalesCurrencyCode()
        {
            ProjInvoiceTable        projInvoiceTable;
            CustTable               custTable;

            if (projTableLocal.ProjInvoiceProjId)
            {
                if (isInterCompanyLE)
                {
                    changecompany(trvExpTrans.InterCompanyLE)
                    {
                        projInvoiceTable = ProjInvoiceTable::find(projTableLocal.ProjInvoiceProjId);
                        projSalesCurrencyCodeLocal = projInvoiceTable.CurrencyId;
                    }
                }
                else
                {
                    projInvoiceTable = ProjInvoiceTable::find(projTableLocal.ProjInvoiceProjId);
                    projSalesCurrencyCodeLocal = projInvoiceTable.CurrencyId;
                }
            }

            if (!projSalesCurrencyCodeLocal)
            {
                if (projTableLocal.CustAccount)
                {
                    if (isInterCompanyLE)
                    {
                        changecompany(trvExpTrans.InterCompanyLE)
                        {
                            custTable = CustTable::find(projTableLocal.CustAccount);
                            projSalesCurrencyCodeLocal = custTable.Currency;
                        }
                    }
                    else
                    {
                        custTable = CustTable::find(projTableLocal.CustAccount);
                        projSalesCurrencyCodeLocal = custTable.Currency;
                    }
                }
                else
                {
                    projSalesCurrencyCodeLocal = Ledger::accountingCurrency(trvExpTrans.LegalEntity);
                }
            }

            return projSalesCurrencyCodeLocal;
        }

        SalesPrice getSalesPrice()
        {
            CostPrice   costPrice;

            if (trvExpTrans.InvoiceAmt == 0)
            {
                if (trvExpTrans.ReimburseAmt == 0)
                {
                    costPrice = trvExpTrans.NetTransactionAmount;
                }
                else
                {
                    costPrice = trvExpTrans.ReimburseAmt;
                }

                // for mileage transaction, Quantity is equal to the actual mileage entered in Trx
                // other category, it's always 1
                boolean dontRoundOffSalesPrice;

                if (trvExpTrans.ExpType == TrvExpType::Transport && trvExpTrans.kmOwnCar != 0)
                {
                    costPrice = costPrice / trvExpTrans.kmOwnCar;
                    dontRoundOffSalesPrice = true;
                }

                boolean correctCCTransSalesPrice = TrvExpenseHelper::isTrvCCTransSalesPriceCorrectionEnabled();

                TrvCurrencyCode costCurrency = trvExpTrans.isCreditCardTransanctionInLocalCurrency() ?
                    trvExpTrans.CreditCardTransactionCurrency : (correctCCTransSalesPrice ?
                        trvExpTrans.ExchangeCode : CompanyInfoHelper::standardCurrency());

                CurrencyCode ledgerCurrency = Ledger::accountingCurrency(trvExpTrans.LegalEntity);

                //Use the cost in company currency as the basis for the sales price
                if (trvExpTrans.ExchangeRate && (correctCCTransSalesPrice ? (costCurrency != ledgerCurrency) : (trvExpTrans.ExchangeCode != ledgerCurrency)))
                {
                    costPrice = ExchangeRateHelper::mstPrice(costPrice, correctCCTransSalesPrice ? costCurrency : trvExpTrans.ExchangeCode,
                                                             DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()), UnknownNoYes::No, trvExpTrans.ExchangeRate, 0);

                    //Since cost is based on company currency, hence cost currency should be changed to accounting currency.
                    costCurrency = ledgerCurrency;

                }

                ProjPriceParameters priceParams = this.initializeProjectPriceParametersForCostSalesPrice(
                    projId,
                    projCategoryId,
                    costPrice,
                    costCurrency,
                    projSalesCurrencyCode,
                    trvExpTrans);
                boolean priceFound;

                [salesPriceLocal, priceFound] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams, false, dontRoundOffSalesPrice);
            }
            else
            {
                salesPriceLocal = trvExpTrans.InvoiceAmt;
            }

            return salesPriceLocal;
        }

        ProjTaxGroup getProjTaxGroup()
        {
            projTaxGroupLocal = ProjParameters::taxGroupInvoice(projId);

            return projTaxGroupLocal;
        }

        if (trvExpTrans.ProjId)
        {
            isInterCompanyLE = trvExpTrans.InterCompanyLE && trvExpTrans.ReferenceDataAreaId != trvExpTrans.InterCompanyLE;

            if (isInterCompanyLE)
            {
                changecompany(trvExpTrans.InterCompanyLE)
                {
                    projId = getProjTableLocal().ProjId;
                    projCategoryId = getProjCategoryId();
                }
            }
            else
            {
                projId = getProjTableLocal().ProjId;
                projCategoryId = getProjCategoryId();
            }

            projTaxItemGroup = getProjTaxItemGroup();
            projSalesCurrencyCode = getProjSalesCurrencyCode();
            salesPrice = getSalesPrice();
            projTaxGroup = getProjTaxGroup();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSourceDocumentLineMatchingList</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a <c>SourceDocumentLineMatchingList</c> object that contains the source document line of
    /// the travel requisition line to which the expense line is mapped.
    /// </summary>
    protected void initSourceDocumentLineMatchingList()
    {
        RefRecId                    trvRequisitionLineRecId = this.parmMappedToRequisitionLineRecId();
        TrvRequisitionLine          trvRequisitionLine;

        if (trvRequisitionLineRecId)
        {
            trvRequisitionLine = TrvRequisitionLine::find(trvRequisitionLineRecId);

            if (trvExpTrans.ProjId == '' || (trvRequisitionLine.ProjTable &&
                 trvRequisitionLine.ProjTable == ProjTable::find(trvExpTrans.ProjId).RecId))
            {
                sourceDocumentLineMatchingList = SourceDocumentLineMatchingFacade::addSourceDocLineItemToList(this,
                                                                                            trvRequisitionLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNonPrimaryItemizedLine</Name>
				<Source><![CDATA[
    private boolean isNonPrimaryItemizedLine()
    {
        if (trvExpTrans.LineType == TrvExpLineType::ItemizedLine && trvExpTrans.SubCategoryRecId)
        {
            return true;
        }

        return false ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUpdatedAccountingDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the updated accounting date which can be used for grouped expense lines.
    /// </summary>
    /// <param name="_accountingDate">
    /// Accounting date
    /// </param>
    /// <returns>
    /// Accounting date for grouped expense lines, then adjusted for on-hold or closed
    /// accounting periods.
    /// </returns>
    public AccountingDate getUpdatedAccountingDate(AccountingDate _accountingDate)
    {
        AccountingDate          updatedAccountingDate;

        const str cacheScope = 'datesInClosedPeriod';
        const str cacheScopeMaxDate = 'maxDateForGrouped';

        AccountingDate originalAccountingDate = _accountingDate;

        // first adjust the date for grouping
        if (trvParameters.AllowGroupingForPostTransactions && trvExpTrans.LineLevelPosting == NoYes::No)
        {
            if (SysTransactionScopeCache::get(cacheScopeMaxDate, true))
            {
                originalAccountingDate = SysTransactionScopeCache::get(cacheScopeMaxDate, true);
            }
            else
            {
                // Use the last date of any line on the document for grouping transactions
                TrvExpTrans expTransLine;

                select maxof(TransDate) from expTransLine
                    where expTransLine.TrvExpTable == trvExpTrans.TrvExpTable;
                
                originalAccountingDate = expTransLine.TransDate;

                SysTransactionScopeCache::set(cacheScopeMaxDate, true, originalAccountingDate);
            }
        }

        // Use the calculated grouping date for the accounting date
        updatedAccountingDate = originalAccountingDate;

        if (SysTransactionScopeCache::get(cacheScope, originalAccountingDate))
        {
            updatedAccountingDate = SysTransactionScopeCache::get(cacheScope, originalAccountingDate);
        }
        else
        {
            // See if further date adjustment is allowed and needed due to on-hold or closed fiscal periods.
            // If a multi-company transaction, only check the target company if the current company allows
            // date adjustments.
            if (trvParameters.IsAllowUpdateAccountingDate)
            {
                updatedAccountingDate = this.accountingDateInOpenPeriod(this.parmLegalEntityRecId(), updatedAccountingDate);

                if (updatedAccountingDate != dateNull() && trvExpTrans.isIntercompany())
                {
                    // make sure the accounting date is in an open period in the target company
                    changecompany (trvExpTrans.InterCompanyLE)
                    {
                        // only change the date if the company allows it
                        if (TrvParameters::find().IsAllowUpdateAccountingDate)
                        {
                            updatedAccountingDate = this.accountingDateInOpenPeriod(CompanyInfo::current(), updatedAccountingDate);
                        }
                        else
                        {
                            // dates in intercompany company cannot be adjusted, reset to original adjustment for grouping
                            updatedAccountingDate = originalAccountingDate;
                        }
                    }
                }
            }
                
            SysTransactionScopeCache::set(cacheScope, originalAccountingDate, updatedAccountingDate);
        }

        // When there is no available accounting date with status open then take the original _accountingDate
        if (!updatedAccountingDate)
        {
            updatedAccountingDate = originalAccountingDate;
        }

        return updatedAccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountingDateInOpenPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the posting date against the fiscal calendar, returning the next open
    /// period start date if the current one is on hold or closed.
    /// </summary>
    /// <param name = "_legalEntity">Legal entity for the fiscal calendar</param>
    /// <param name = "_accountingDate">The date to check</param>
    /// <returns>A date passed in if the period is open, the start date of the next open period, or dateNull if adjusting AccountingDate is not allowed.</returns>
    private AccountingDate accountingDateInOpenPeriod(LegalEntityRecId _legalEntity, AccountingDate _accountingDate)
    {
        FiscalCalendarRecId     fiscalCalendar;
        FiscalCalendarPeriod    fiscalCalendarPeriod;
        AccountingDate          updatedAccountingDate = _accountingDate;
        boolean                 periodIsOpen;

        fiscalCalendar = Ledger::fiscalCalendar(_legalEntity);

        if (!LedgerFiscalCalendar::existDateWithOpenStatus(fiscalCalendar, _accountingDate, FiscalPeriodType::Operating, SysModule::Expense))
        {
            fiscalCalendarPeriod = LedgerFiscalCalendar::findFirstOpenPeriodInYear(fiscalCalendar, _accountingDate, SysModule::Expense);
            if (fiscalCalendarPeriod)
            {
                updatedAccountingDate = fiscalCalendarPeriod.StartDate;
            }
            else
            {
                // If there are no open periods in the current fiscal year, it gets the first date of the open period in the next fiscal year.
                AccountingDate nextFiscalYearStartDate = FiscalCalendars::findNextYearStart(fiscalCalendar, _accountingDate);
                AccountingDate nextYearAccountingDate;
                while (nextFiscalYearStartDate)
                {
                    nextYearAccountingDate = LedgerFiscalCalendar::findFirstOpenPeriodInYear(fiscalCalendar, nextFiscalYearStartDate, SysModule::Expense).StartDate;
                    if (nextYearAccountingDate)
                    {
                        // we found the first available open period, terminate loop
                        updatedAccountingDate = nextYearAccountingDate;
                        break;
                    }
                    nextFiscalYearStartDate = FiscalCalendars::findNextYearStart(fiscalCalendar, nextFiscalYearStartDate);
                }
            }
        }
        return updatedAccountingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAccountingDate</Name>
				<Source><![CDATA[
    public AccountingDate parmAccountingDate()
    {
        AccountingDistribution      accountingDistribution;
        TrvExpTable                 trvExpTable;

        if (this.canUpdateAccountingDate())
        {
            select firstOnly AccountingDate,SourceDocumentHeader from accountingDistribution
                where accountingDistribution.SourceDocumentLine == trvExpTrans.SourceDocumentLine;

            trvExpTable = TrvExpTable::findBySourceDocumentHeader(accountingDistribution.SourceDocumentHeader);

            if (accountingDistribution.AccountingDate && trvExpTable.ApprovalStatus == TrvAppStatus::Approved)
            {
                return accountingDistribution.AccountingDate;
            }
        }
        return trvExpTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurrentStateDataMainAccDerivation</Name>
				<Source><![CDATA[
    protected SourceDocumentLineStateContainer parmCurrentStateDataMainAccDerivation()
    {
        SourceDocumentLineStateContainer ret;

        ret = super();

        ret += this.parmMappedToRequisitionLineRecId();

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDescription</Name>
				<Source><![CDATA[
    public Description parmDescription()
    {
        return trvExpTrans.categoryOrSubCategoryName();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributeAmountsToLegalEntities</Name>
				<Source><![CDATA[
    public boolean parmDistributeAmountsToLegalEntities()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDistributionTemplate</Name>
				<Source><![CDATA[
    public AccountingDistributionTemplate parmDistributionTemplate()
    {
        AccountingDistributionTemplate accountingDistributionTemplate;

        return accountingDistributionTemplate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExchangeRate1</Name>
				<Source><![CDATA[
    public ExchRate parmExchangeRate1()
    {
        return trvExpTrans.ExchangeRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReportingCurrencyExchangeRate1</Name>
				<Source><![CDATA[
    public ExchRate parmReportingCurrencyExchangeRate1()
    {
        if (trvExpTrans.ExchangeRate > 0 &&
            Ledger::accountingCurrency(trvExpTrans.LegalEntity) == Ledger::reportingCurrency(trvExpTrans.LegalEntity))
        {
            return trvExpTrans.ExchangeRate;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExpenseLine</Name>
				<Source><![CDATA[
    public Common parmExpenseLine()
    {
        return trvExpTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsDocumentLineEditable</Name>
				<Source><![CDATA[
    public boolean parmIsDocumentLineEditable()
    {
        boolean isDistributionEditable = false;

        if (trvExpTrans.isEditable())
        {
            isDistributionEditable = true;
        }
        else if (trvExpTrans.ApprovalStatus == TrvAppStatus::Approved && trvParameters.AllowEditDistributions)
        {
            isDistributionEditable = true;
        }

        return isDistributionEditable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerDimensionDefaultAccount</Name>
				<Source><![CDATA[
    public LedgerDimensionDefaultAccount parmLedgerDimensionDefaultAccount(LegalEntityRecId _legalEntityRecId = this.parmLegalEntityRecId())
    {
        LedgerDimensionDefaultAccount   ledgerDimensionId;
        TrvRequisitionLine              trvRequisitionLine;
        AccountingDistribution          requisitionSourceDocumentDistribution;
        TrvExpTrans                     headerTrvExpTrans;

        TrvInstrumentationHelper::logExpenseOperationsInformation(strFmt('Get ledger dimension from requisition distribution or else from expense category or subcategory'), classStr(TrvExpTransSourceDocLineItem));

        if (trvExpTrans.LineType == TrvExpLineType::ItemizedLine)
        {
            headerTrvExpTrans = TrvExpTrans::find(trvExpTrans.ParentRecId);
        }

        // if mapped, get ledger dimension from requisition distribution
        // there should be only one
        select firstonly SourceDocumentLine from trvRequisitionLine
                where trvRequisitionLine.RecId == trvExpTrans.MappedToRequisitionLine;

        if (trvRequisitionLine)
        {
            select firstonly LedgerDimension from requisitionSourceDocumentDistribution where
                    requisitionSourceDocumentDistribution.SourceDocumentLine == trvRequisitionLine.SourceDocumentLine;

            ledgerDimensionId = requisitionSourceDocumentDistribution.LedgerDimension;
        }
        else
        {
            changecompany(CompanyInfo::findRecId(_legalEntityRecId).DataArea)
            {
                ledgerDimensionId = this.getDefaultAccountFromExpenseCategory();
            }
        }

        return ledgerDimensionId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMappedToRequisitionLineRecId</Name>
				<Source><![CDATA[
    public RefRecId parmMappedToRequisitionLineRecId()
    {
        RefRecId        mappedToTrvRequisitionLineRecId;
        TrvExpTrans     itemizedHeaderTrvExpTrans;

        if (trvExpTrans.LineType != TrvExpLineType::ItemizedLine)
        {
            mappedToTrvRequisitionLineRecId = trvExpTrans.MappedToRequisitionLine;
        }
        else
        {
            // for itemized lines, get the itemized header
            select MappedToRequisitionLine from itemizedHeaderTrvExpTrans
                where itemizedHeaderTrvExpTrans.RecId == trvExpTrans.ParentRecId;

            mappedToTrvRequisitionLineRecId = itemizedHeaderTrvExpTrans.MappedToRequisitionLine;
        }

        return mappedToTrvRequisitionLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectActivityNumber</Name>
				<Source><![CDATA[
    public ProjActivityNumber parmProjectActivityNumber()
    {
        return trvExpTrans.ProjActivityNumber;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectCategoryId</Name>
				<Source><![CDATA[
    public ProjCategoryId parmProjectCategoryId()
    {
        return projCategoryId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectFundingSourceRecId</Name>
				<Source><![CDATA[
    public ProjFundingSourceRefId parmProjectFundingSourceRecId()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectId</Name>
				<Source><![CDATA[
    public ProjId parmProjectId()
    {
        if (!projId && trvExpTrans.ProjId)
        {
            return trvExpTrans.ProjId;
        }

        return projId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectItemSalesTaxGroup</Name>
				<Source><![CDATA[
    public ProjTaxItemGroup parmProjectItemSalesTaxGroup()
    {
        return projTaxItemGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectLineProperty</Name>
				<Source><![CDATA[
    public ProjLinePropertyId parmProjectLineProperty()
    {
        return trvExpTrans.ProjStatusId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesCurrencyCode</Name>
				<Source><![CDATA[
    public ProjSalesCurrencyCode parmProjectSalesCurrencyCode()
    {
        return projSalesCurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesPrice</Name>
				<Source><![CDATA[
    public SalesPrice parmProjectSalesPrice()
    {
        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesTaxGroup</Name>
				<Source><![CDATA[
    public ProjTaxGroup parmProjectSalesTaxGroup()
    {
        return projTaxGroup;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectSalesUnit</Name>
				<Source><![CDATA[
    public SalesUnit parmProjectSalesUnit()
    {
        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectTransactionId</Name>
				<Source><![CDATA[
    public ProjTransIdBase parmProjectTransactionId()
    {
        CostControlTransCommittedCost   costControlTransCommittedCost;

        if (!projTransId)
        {
            projTransId = trvExpTrans.ProjTransId;
        }

        if (!projTransId)
        {
            select firstonly ProjTransId from costControlTransCommittedCost
                where costControlTransCommittedCost.SourceDocumentLine == this.parmSourceDocumentLine().RecId;

            projTransId = costControlTransCommittedCost.ProjTransId;
            if (!projTransId)
            {
                changecompany (CompanyInfo::findRecId(this.parmLegalEntityRecId()).DataArea)
                {
                    projTransId = ProjCostTrans::newTransId();
                }
            }
        }

        return projTransId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectWorkerRecId</Name>
				<Source><![CDATA[
    public HcmWorkerRecId parmProjectWorkerRecId()
    {
        return trvExpTrans.CreatingWorker;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantity</Name>
				<Source><![CDATA[
    public Qty parmQuantity()
    {
        Qty qty;

        if (trvExpTrans.ExpType == TrvExpType::Transport)
        {
            qty = trvExpTrans.kmOwnCar;
        }
        else
        {
            // 0 as default, to disable distribute by quantity in client distribution control
            qty = 0;
        }

        return qty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmQuantityDecimalPlaces</Name>
				<Source><![CDATA[
    public Decimals parmQuantityDecimalPlaces()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransactionCurrencyCode</Name>
				<Source><![CDATA[
    public CurrencyCode parmTransactionCurrencyCode()
    {
        return trvExpTrans.CreditCardTransactionCurrency ? trvExpTrans.CreditCardTransactionCurrency : trvExpTrans.ExchangeCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertToLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gives the ledger dimension for a specified accounting type and account.
    /// </summary>
    /// <param name="_accountType">
    /// An account type enumeration.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The account number for the specified account type.
    /// </param>
    /// <returns>
    /// The ledger dimension record ID.
    /// </returns>
    /// <remarks>
    /// The supported account types are bank, customer, vendor, and ledger
    /// </remarks>
    public static LedgerDimensionDefaultAccount convertToLedgerDimension(LedgerJournalACType _accountType, LedgerDimensionAccount _ledgerDimension)
    {
        LedgerDimensionDefaultAccount glLedgerDimension;
        LedgerJournalAC account;

        if (_ledgerDimension)
        {
            account = LedgerDynamicAccountHelper::getAccountNumberFromDynamicAccount(_ledgerDimension);

            switch (_accountType)
            {
                case LedgerJournalACType::Bank :
                    glLedgerDimension = TrvExpenseBankHelper::findBankLedgerDimension(account);
                    break;

                case LedgerJournalACType::Cust :
                    glLedgerDimension = CustLedgerAccounts::summaryLedgerDimension(account, '', false);
                    break;

                case LedgerJournalACType::Ledger :
                    glLedgerDimension = _ledgerDimension;
                    break;

                case LedgerJournalACType::Vend:
                    glLedgerDimension = VendLedgerAccounts::summaryLedgerDimension(account, '', false);
                    break;
            }
        }

        return glLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjTransDate</Name>
				<Source><![CDATA[
    public ProjTransDate parmProjTransDate()
    {
        return trvExpTrans.TransDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectResourceCategoryRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the <c>TrvExpTrans</c> table CreatingWorker property default resource category.
    /// </summary>
    /// <returns>The <c>TrvExpTrans</c> table CreatingWorker property default resource category.</returns>
    public ResourceCategoryRecId parmProjectResourceCategoryRecId()
    {
        return  ResourceFacade::getResourceCategory(this.parmProjectResourceRecId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProjectResourceRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Return the <c>TrvExpTrans</c> table CreatingWorker property resource rec Id.
    /// </summary>
    /// <returns>the <c>TrvExpTrans</c> table CreatingWorker property resource rec Id.</returns>
    public ResourceRecId parmProjectResourceRecId()
    {
        return ResourceFacade::findByWorker(trvExpTrans.CreatingWorker, trvExpTrans.LegalEntity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeICSubCategoryLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the ledger dimension when intercompany is enabled and the project is not attached to the expense report Itemized line.
    /// </summary>
    /// <returns>
    /// The ledger dimension value of the expense sub-category
    /// </returns>
    /// <remarks>
    /// This method initializes the ledger dimension when intercompany is enabled.
    /// </remarks>
    private LedgerDimensionAccount initializeICSubCategoryLedgerDimension()
    {
        TrvExpSubCategory       trvExpSubCategory;
        TrvSharedSubCategory    trvSharedSubCategory;
        TrvExpSubCategory       tmptrvExpSubCategory;
        LedgerDimensionAccount  ledgerDimension = 0;

        trvExpSubCategory = TrvExpSubCategory::findByRecId(trvExpTrans.SubCategoryRecId);

        if (trvExpTrans.InterCompanyLE)
        {
            select firstOnly RecId from trvSharedSubCategory
                    where trvSharedSubCategory.RecId == trvExpSubCategory.TrvSharedSubCategory;

            changecompany(trvExpTrans.InterCompanyLE)
            {
                select firstOnly ledgerDimension from tmptrvExpSubCategory
                    where tmptrvExpSubCategory.TrvSharedSubCategory == trvSharedSubCategory.RecId;

                ledgerDimension = tmptrvExpSubCategory.LedgerDimension;
            }
        }

        return    ledgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInterCompanyWithProject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the related expense is intercompany and with project.
    /// </summary>
    /// <returns>
    /// true if the related expense is an intercompany transaction with project; false otherwise.
    /// </returns>
    public boolean isInterCompanyWithProject()
    {
        return trvExpTrans.isIntercompanyWithProject();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>