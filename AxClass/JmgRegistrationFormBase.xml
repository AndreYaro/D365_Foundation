<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>JmgRegistrationFormBase</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class JmgRegistrationFormBase extends Object
{
    Object              form;
    JmgJobBundle        currentBundle;
    boolean             enableBundleInteraction;
    [SysObsolete('This class member is deprecated because it is not used in this class anymore.', false, 30\06\2020)]
    Qty                 scannerStartQty;
    [SysObsolete('This class member is deprecated because it is not used in this class anymore.', false, 30\06\2020)]
    PdsCWQty            scannerCWStartQty;


    JmgWorkerRecId      markedAssistant;
    JmgProfileDate      emplFlexDate;
    JmgLabelFlexBalance emplFlexBalance;
    DirPartyName        name;
    JmgWorkerRecId      currentWorker;

    JmgWrkCtrIdPilot    wrkCtrIdPilot;

    JmgMESDocuHandling          docHand;

    JmgCurrentActivitiesCount   currActCount;

    // Latest used registration setup
    JmgRegistrationSetup        lastRegSetup;
    private  JmgInstrumentationLogger jmgInstrumentationLogger;
    boolean noButtonsOnConfiguration;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>enableDisableButtons</Name>
				<Source><![CDATA[
    void enableDisableButtons(boolean _isFeedbackEnabled){}

]]></Source>
			</Method>
			<Method>
				<Name>setupActionPane</Name>
				<Source><![CDATA[
    void setupActionPane(JmgRegistrationSetup _jmgRegistrationSetup){}

]]></Source>
			</Method>
			<Method>
				<Name>signInStartPage</Name>
				<Source><![CDATA[
    void signInStartPage(JmgRegistrationSetup _jmgRegistrationSetup){}

]]></Source>
			</Method>
			<Method>
				<Name>setupPreviewPanes</Name>
				<Source><![CDATA[
    void setupPreviewPanes(){}

]]></Source>
			</Method>
			<Method>
				<Name>showAttachments</Name>
				<Source><![CDATA[
    void showAttachments(){}

]]></Source>
			</Method>
			<Method>
				<Name>approveMarkedPost</Name>
				<Source><![CDATA[
    // Post Actions
    void approveMarkedPost(JmgJobBundle _localCurrentBundle){}

]]></Source>
			</Method>
			<Method>
				<Name>endBreakPost</Name>
				<Source><![CDATA[
    void endBreakPost(){}

]]></Source>
			</Method>
			<Method>
				<Name>haveBreakPost</Name>
				<Source><![CDATA[
    void haveBreakPost(JmgJobId _jobId){}

]]></Source>
			</Method>
			<Method>
				<Name>startAssistancePost</Name>
				<Source><![CDATA[
    public void startAssistancePost(){}

]]></Source>
			</Method>
			<Method>
				<Name>reportFeedbackPost</Name>
				<Source><![CDATA[
    protected void reportFeedbackPost(){}

]]></Source>
			</Method>
			<Method>
				<Name>approveAndRequestLogin</Name>
				<Source><![CDATA[
    /// <summary>
    /// Approves registrations on the selected jobs, and returns the form to the Welcome screen.
    /// </summary>
    public void approveAndRequestLogin()
    {
        if (this.approveMarked(true))
        {
            this.requestLogin();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveMarked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates registrations on marked jobs.
    /// </summary>
    /// <param name="_skipPreApprove">
    ///    A Boolean value that specifies whether the pre-approval checks must be skipped.
    /// </param>
    /// <returns>
    ///    true if the registrations are approved successfully; otherwise, false.
    /// </returns>
    boolean approveMarked(boolean _skipPreApprove = false)
    {
        JmgRegistrationParameters   parm;
        JmgRegistrationSetup        jmgRegistrationSetup;
        boolean                     commitOk;
        boolean                     continueBundle;
        JmgJobTable                 assistanceJob;
        JmgJobBundle                localCurrentBundle = currentBundle;
        boolean                     JmgRegistrationForceScanBundleCheckFlightEnabled = JmgRegistrationForceScanBundleCheckFlight::instance().isEnabled();


        if (localCurrentBundle)
        {
            if (!_skipPreApprove)
            {
                if (!this.preApprove())
                {
                    return false;
                }
            }
            continueBundle = localCurrentBundle.continueBundle();
            if (markedAssistant || wrkCtrIdPilot)
            {
                // Bundle should not be continued when changing assistant:
                localCurrentBundle.continueBundle(false);

                parm = new JmgRegistrationParameters();
                parm.jobPilot(markedAssistant);
                parm.parmWrkCtrIdPilot(wrkCtrIdPilot);

                if ((select firstonly RecId from jmgTermReg
                        where jmgTermReg.WorkerPilot  == localCurrentBundle.worker() &&
                              jmgTermReg.JobActive    == NoYes::Yes).RecId)
                {
                    assistanceJob   = this.findAssistanceJob(JmgSignInOut::SubmitPilote);
                }
                else
                {
                    assistanceJob   = this.findAssistanceJob(JmgSignInOut::StartTeam);
                }

                localCurrentBundle.addJob(assistanceJob, parm);
            }

            jmgRegistrationSetup = form.getRegistrationSetup();

            if (jmgRegistrationSetup.LockEmployee   == NoYes::Yes || jmgRegistrationSetup.UseActualTimeOfRegistration == NoYes::Yes)
            {
                commitOk = localCurrentBundle.makeRegistrations(JmgProfileSeconds::getSysDate(), JmgProfileSeconds::getSysTime());
            }
            else
            {
                commitOk = localCurrentBundle.makeRegistrations();
            }

            if (localCurrentBundle.registrationsCancelledByUser())
            {
                return false;
            }            

            if (commitOk && continueBundle && jmgRegistrationSetup.Scanner && JmgRegistrationForceScanBundleCheckFlightEnabled && !localCurrentBundle.isBundleCommitted())
            {
                localCurrentBundle.continueBundle(false);

                if (localCurrentBundle.bundleSize() == 0)
                {
                    commitOk = false;
                    localCurrentBundle.continueBundle(continueBundle);
                }
            }

            if (commitOk)
            {
                this.approveMarkedPost(localCurrentBundle);
                currentBundle   = null;
                markedAssistant = 0;
                wrkCtrIdPilot   = '';
                return true;
            }
            else
            {
                if (assistanceJob)
                {
                    localCurrentBundle.removeJob(assistanceJob);
                }
                localCurrentBundle.continueBundle(continueBundle);
            }
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findAssistanceJob</Name>
				<Source><![CDATA[
    private JmgJobTable findAssistanceJob(JmgSignInOut _signInOut)
    {
        JmgJobId ipcActivityJobId = JmgIpcActivity::findSignTypeJobId(_signInOut);
        if (!ipcActivityJobId)
        {
            throw error(strFmt("@SCM:JmgIpcActivityMissing", enum2Str(_signInOut)));
        }

        JmgJobTable assistanceJob = JmgJobTable::find(ipcActivityJobId);
        if (!assistanceJob)
        {
            throw error(strFmt("@SCM:JmgIpcActivityIsNotRegistered", enum2Str(_signInOut)));
        }

        return assistanceJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>assistanceRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>JmgEmployee</c> temporary buffer, which contains a record
    /// for each possible job pilot.
    /// </summary>
    /// <returns>
    /// Retrieves a <c>JmgEmployee</c> temporary buffer, which contains a record
    /// for each possible job pilot.
    /// </returns>
    JmgEmployee assistanceRecords()
    {
        JmgEmployee ret;
        JmgEmployee jmgEmployee;
        JmgTermReg  jmgTermReg;

        if (currentBundle)
        {
            jmgEmployee.recordLevelSecurity(true);
            ret.setTmp();

            if (this.isPilot())
            {
                while select jmgEmployee
                    where jmgEmployee.Worker != currentBundle.worker()
                exists join jmgTermReg
                    where jmgTermReg.Worker         == jmgEmployee.Worker           &&
                          jmgTermReg.WorkerPilot    == currentBundle.worker()       &&
                          jmgTermReg.RegType        == JmgTermRegType::TeamStart    &&
                          jmgTermReg.JobActive      == NoYes::Yes
                {
                    ret.data(jmgEmployee);
                    ret.insert();
                }
            }
            else
            {
                while select jmgEmployee
                    where jmgEmployee.Worker != currentBundle.worker()
                notexists join jmgTermReg
                    where jmgTermReg.Worker         == jmgEmployee.Worker           &&
                          jmgTermReg.RegType        == JmgTermRegType::TeamStart    &&
                          jmgTermReg.JobActive      == NoYes::Yes
                {
                    if (JmgTermReg::getCurSignInTime(jmgEmployee.Worker))
                    {
                        ret.data(jmgEmployee);
                        ret.insert();
                    }
                }
            }
            return ret;
        }
        else
        {
            ret.setTmp();
            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginMarkedJobs</Name>
				<Source><![CDATA[
    /// <summary>
    /// Approves registrations on the selected jobs, and returns the form to the Welcome screen.
    /// </summary>
    void beginMarkedJobs()
    {
        if (currentBundle.bundleSize() > 0 && this.approveMarked())
        {
            this.requestLogin();
            this.updateFormLayout();
        }
        else if (this.shouldRemoveNewJobsFromBundle())
        {
            this.removeNewJobsFromBundle();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFormLayout</Name>
				<Source><![CDATA[
	/// <summary>
    /// Updates the form layout. 
    /// </summary>
    [Hookable(false)]
	protected void updateFormLayout()
    {
        if (enableBundleInteraction)
        {
            form.updateLayout();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldRemoveNewJobsFromBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Decides whether the bundle should be cleared if the jobs are not started.
    /// </summary>
    /// <returns>false</returns>
    [Hookable(false)]
    protected boolean shouldRemoveNewJobsFromBundle()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beginResourceRegistration</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Starts a resource registration on the jobs added to the <c>JmgJobBundle</c> class.
    /// </summary>
    /// <remarks>
    ///    Instead of creating registrations on the selected worker, registrations are created on the selected
    ///    resource instead.
    /// </remarks>
    public void beginResourceRegistration()
    {
        if (currentBundle)
        {
            currentBundle.parmResourceRegistration(true);
        }
        if (this.approveMarked())
        {
            this.requestLogin();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Switches bundle modes.
    /// </summary>
    public void bundle()
    {
        if (currentBundle)
        {
            currentBundle.continueBundle(true);
            this.beginMarkedJobs();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearBundle</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the jobs that are selected by the user.
    /// </summary>
    public void clearBundle()
    {
        if (currentBundle)
        {
            currentBundle.clearActiveJobs();
            currentBundle.removeAllJobs();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeNewJobsFromBundleAndForceEmptyBundleType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes new jobs from the bundle (i.e. the jobs selected in the grid but not acted on yet),
    /// keeping the already active jobs.
    /// BundleType is also set to Empty disregarding the number of active jobs.
    /// </summary>
    public void removeNewJobsFromBundleAndForceEmptyBundleType()
    {
        if (currentBundle)
        {
            currentBundle.removeNewJobsAndSetEmptyBundleType(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeNewJobsFromBundle</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes new jobs from the bundle (i.e. the jobs selected in the grid but not acted on yet),
    /// keeping the already active jobs
    /// </summary>
    public void removeNewJobsFromBundle()
    {
        if (currentBundle)
        {
            currentBundle.removeAllJobs();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockUserOut</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a clock-out registration for the worker and returns to the welcome screen.
    /// </summary>
    public void clockUserOut()
    {
        JmgWorkerRecId workerRecId = currentBundle.worker();
        
        using(var activityContext = JmgRegistrationInstrumentationActivities::initFormParms(this.getOrCreateLogger().registration().clockOut(workerRecId), form.name()))
        {
            currentBundle.resetRegistrationTime();
            if (this.signInOutUser(workerRecId, false))
            {
                this.requestLogin(true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>continueBundle</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the current continue bundle setting.
    /// </summary>
    /// <returns>
    ///    true if the continue bundle setting is enabled; otherwise, false.
    /// </returns>
    boolean continueBundle()
    {
        if (currentBundle)
        {
            return currentBundle.continueBundle();
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentActivitiesCount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the number of current activities.
    /// </summary>
    /// <returns>
    /// The number of current activities.
    /// </returns>
    public JmgCurrentActivitiesCount currentActivitiesCount()
    {
        return currActCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>emplStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the current clock in status for the worker.
    /// </summary>
    /// <returns>
    ///    The current clock in status for the worker.
    /// </returns>
    JmgProfileSpecTypeEnum emplStatus()
    {
        if (!currentBundle)
        {
            return JmgProfileSpecTypeEnum::Blank;
        }

        if (currentBundle.emplClockedIn())
        {
            return JmgProfileSpecTypeEnum::SignIn;
        }
        return JmgProfileSpecTypeEnum::SignOut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workerHasActiveBreak</Name>
				<Source><![CDATA[
    internal boolean workerHasActiveBreak()
    {
        JmgTermReg      termReg;

        select firstonly RecId
            from termReg
            where termReg.RegType == JmgTermRegType::BrkFlowStart   &&
                  termReg.Worker  == form.curWorker()               &&
                  termReg.JobActive == NoYes::Yes;

        return termReg.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>autoEndBreak</Name>
				<Source><![CDATA[
	/// <summary>
    /// Creates a stop break registration for the worker, if the worker is currently active on a break.
    /// </summary>
    /// <param name = "_jmgRegistrationSetup">A reference to the <c>JmgRegistrationSetup</c> record, which is used on the registration form.</param>
    /// <param name = "_autoEndBreakWhenLockEmployee">If auto end the break when lock employee.</param>
    internal void autoEndBreak(JmgRegistrationSetup _jmgRegistrationSetup, boolean _autoEndBreakWhenLockEmployee = false)
    {
        using(var activityContext = JmgRegistrationInstrumentationActivities::initFormParms(this.getOrCreateLogger().registration().endBreak(), form.name()))
        {
            if (this.workerHasActiveBreak())
            {
                JmgJobBundle jmgJobBundle = new JmgJobBundle(form.curWorker(), false, false, false);
                jmgJobBundle.parmCallerForm(form);
                jmgJobBundle.addJob(JmgJobTable::find(JmgIpcActivity::findSignTypeJobId(JmgSignInOut::StopBreak)));
                jmgJobBundle.makeRegistrations();
                if (currentBundle)
                {
                    var newjobs = currentBundle.getNewJobsIterator();
                    currentBundle = new JmgJobBundle(form.curWorker(), currentBundle.continueBundle(), true, enableBundleInteraction, _jmgRegistrationSetup);
                    currentBundle.parmCallerForm(form);
                    
                    if (_autoEndBreakWhenLockEmployee) // Should keep new jobs when lock employee.
                    {
                        while (newjobs.more())
                        {
                            var newJob  = JmgJobTable::find(newjobs.value().jobId());
                            currentBundle.addJob(newJob);
                            newjobs.next();
                        }
                    } 
                }
                this.endBreakPost();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a stop break registration for the worker, if the worker is currently active on a break.
    /// </summary>
    /// <param name="_jmgRegistrationSetup">
    /// A reference to the <c>JmgRegistrationSetup</c> record, which is used on the registration form.
    /// </param>
    public void endBreak(JmgRegistrationSetup _jmgRegistrationSetup)
    {
        this.autoEndBreak(_jmgRegistrationSetup, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>stopBreak</Name>
				<Source><![CDATA[
    internal void stopBreak(JmgRegistrationSetup _jmgRegistrationSetup)
    {
        this.autoEndBreak(_jmgRegistrationSetup, false);
        this.enableDisableButtons(this.isFeedbackEnabled());
    }

]]></Source>
			</Method>
			<Method>
				<Name>flexBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the current flex balance for the worker
    /// </summary>
    /// <returns>
    /// The current flex balance for the worker
    /// </returns>
    JmgLabelFlexBalance flexBalance()
    {
        return emplFlexBalance;
    }

]]></Source>
			</Method>
			<Method>
				<Name>flexDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the last calculated flex-date for the current worker.
    /// </summary>
    /// <returns>
    ///    The last calculated flex-date for the current worker.
    /// </returns>
    JmgLabelFlexDate flexDate()
    {
        return emplFlexDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAbsenceGroups</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a temporary buffer of <c>HRMAbsenceCodeGroup</c> records, which contains a record for
    ///    each absence code group that the worker can create registrations on.
    /// </summary>
    /// <returns>
    ///    A temporary buffer of <c>HRMAbsenceCodeGroup</c> records
    /// </returns>
    public HRMAbsenceCodeGroup getAbsenceGroups()
    {
        HRMAbsenceCodeGroup ret;
        HRMAbsenceCodeGroup hrmAbsenceCodeGroup;
        HRMAbsenceCode      hrmAbsenceCode;
        JmgJobTable         jmgJobTable;
        // TwC: Record level security ensured on temporary data.
        ret.setTmp();

        hrmAbsenceCodeGroup.recordLevelSecurity(true);
        hrmAbsenceCode.recordLevelSecurity(true);

        // Add all absence groups, which can be registered directly on, and exists in the job table:
        while select jmgJobTable where jmgJobTable.Type          == JmgJobTableType::HRMAbsenceCodeGroup join  hrmAbsenceCodeGroup where jmgJobTable.ModuleRefId   == hrmAbsenceCodeGroup.HrmAbsenceCodeGroupId
        {
            ret.data(hrmAbsenceCodeGroup);
            ret.doInsert();
        }

        // Add all absence groups, which cannot be registered on, but
        // contains an absence code, which can be registered on:
        while select hrmAbsenceCodeGroup
            where hrmAbsenceCodeGroup.JmgSignIn         == NoYes::No
            exists join jmgJobTable
            where jmgJobTable.ModuleRefId               == hrmAbsenceCodeGroup.HrmAbsenceCodeGroupId    &&
                  jmgJobTable.Type                      == JmgJobTableType::HRMAbsenceCode
        {
            ret.data(hrmAbsenceCodeGroup);
            ret.doInsert();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrJobIdsCon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the job IDs of jobs on which the worker is currently working.
    /// </summary>
    /// <returns>
    ///    A container that has the job IDs of jobs on which the worker is currently working.
    /// </returns>
    container getCurrJobIdsCon()
    {
        MapIterator     mi;
        JmgTermJob      job;
        container       jobIds = conNull();

        if (!currentBundle)
            return jobIds;

        mi = currentBundle.getActiveJobsIterator();
        while (mi.more())
        {
            job = mi.value();
            jobIds += job.jobId();
            mi.next();
        }
        return jobIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstActiveJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find first active job which is assigned to the current user.
    /// </summary>
    /// <param name="_jobIds">
    /// An instance of <c>container</c> class, which contains all active jobs.
    /// </param>
    /// <returns>
    /// An instance of <c>JmgTermJob</c> class.
    /// </returns>
    public JmgTermJob getFirstActiveJob(container _jobIds = this.getCurrJobIdsCon())
    {
        JmgTermJob  jobTemp;

        if (conLen(_jobIds) > 0)
        {
            jobTemp = JmgTermJob::construct(conPeek(_jobIds, 1));
        }
        else
        {
            jobTemp = new JmgTermJob_illegal();
        }

        return jobTemp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getJobIdsCon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the job IDs that the worker has currently selected.
    /// </summary>
    /// <param name="_currentBundle">
    ///    The current <c>JmgJobBundle</c> of the worker.
    /// </param>
    /// <returns>
    ///    A container that has job IDs that the worker has currently selected.
    /// </returns>
    container getJobIdsCon(JmgJobBundle _currentBundle = currentBundle)
    {
        MapIterator     mi;
        JmgTermJob      job;
        container       jobIds = conNull();
        if (_currentBundle)
        {
            mi = _currentBundle.getNewJobsIterator();
            while (mi.more())
            {
                job = mi.value();
                if (job.signType() == JmgSignInOut::Job)
                {
                    jobIds += job.jobId();
                }
                mi.next();
            }
        }
        return jobIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>haveBreak</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a start break registration on the specified break job ID.
    /// </summary>
    /// <param name="_jobId">
    /// The job ID of the break to start a registration on.
    /// </param>
    public void haveBreak(JmgJobId _jobId)
    {
        using(var activityContext =  JmgRegistrationInstrumentationActivities::initFormParms(this.getOrCreateLogger().registration().startBreak(), form.name()))
        {
            this.clearBundle();
            this.registerOnJob(_jobId,true);
            this.haveBreakPost(_jobId);
            this.enableDisableButtons(this.isFeedbackEnabled());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBundleActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a worker is currently logged on the registration form.
    /// </summary>
    /// <returns>
    ///    true if a worker has logged on the registration form; otherwise, false.
    /// </returns>
    private boolean isBundleActive()
    {
        return currentBundle != null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isFeedbackEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether feedback buttons must be enabled.
    /// </summary>
    /// <returns>
    ///    true if feedback buttons must be enabled; otherwise, false.
    /// </returns>
    private boolean isFeedbackEnabled()
    {
        MapIterator     mi;
        JmgTermJob      job;

        if (!currentBundle)
            return false;

        mi = currentBundle.getActiveJobsIterator();
        while (mi.more())
        {
            job = mi.value();

            if (job.requireFeedbackInfo())
            {
                return true;
            }

            mi.next();
        }

        // In case that selected jobs are started by a ressource, all workers must be able to make feedback on them.
        return this.isResourceJobs();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPilot</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the current worker is a pilot.
    /// </summary>
    /// <returns>
    ///    true if the current worker is a job pilot; otherwise, false.
    /// </returns>
    public boolean isPilot()
    {
        boolean ret = false;
        if (currentBundle && (select firstonly RecId from jmgTermReg
                    where jmgTermReg.WorkerPilot  == currentBundle.worker() &&
                          jmgTermReg.JobActive    == NoYes::Yes).RecId)
        {
            ret = true;
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isResourceJobs</Name>
				<Source><![CDATA[
    private boolean isResourceJobs()
    {
        container       jobIds;
        int             jobIdsLength;
        int             i;
        JmgJobId        jobId;
        JmgTermReg      jmgTermReg;
        JmgJobBundle    localbundle = currentBundle;

        if (!localbundle)
        {
            return false;
        }

        if (!localbundle.wrkCtrIdPilot())
        {
            return false;
        }

        // Determine if worker is assisting a resource
        select firstonly RecId
            from  jmgTermReg
                where jmgTermReg.Worker        == localbundle.worker()
                   && jmgTermReg.RegType       == JmgTermRegType::TeamStart
                   && jmgTermReg.JobActive     == NoYes::Yes
                   && jmgTermReg.WrkCtrIdPilot == localbundle.wrkCtrIdPilot();

        if (!jmgTermReg.RecId)
        {
            return false;
        }

        jobIds = this.getJobIdsCon(localbundle);
        jobIdsLength = conLen(jobIds);

        for (i =1; i <= jobIdsLength; i+=1)
        {
            jobId = conPeek(jobIds, i);

            // Determine if job is started by the resource the worker is assisting
            if ((select firstonly RecId from jmgTermReg
                where jmgTermReg.JobId          == jobId
                   && jmgTermReg.WrkCtrIdPilot  == localbundle.wrkCtrIdPilot()
                   && jmgTermReg.JobActive      == NoYes::Yes).RecId)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>jobMarked</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets whether a job is currently marked in the job list.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that indicates whether the value must be set.
    /// </param>
    /// <param name="_jmgJobTable">
    ///    A <c>JmgJobTable</c> record, which references the job being marked.
    /// </param>
    /// <param name="_value">
    ///    A <c>NoYes</c> enumeration value that indicates whether the job must be marked in the list.
    /// </param>
    /// <param name="_fromScannerField">
    ///    A <c>NoYes</c> enumeration value that indicates whether this method is called from scanner field.
    /// </param>
    /// <returns>
    ///    A <c>NoYes::Yes</c> enumeration value if the job is currently marked; otherwise, a <c>NoYes::No</c>
    ///    enumeration value.
    /// </returns>
    public NoYes jobMarked(boolean _set, JmgJobTable _jmgJobTable, NoYes _value, boolean _fromScannerField)
    {
        JmgRegistrationSetup    jmgRegistrationSetup;
        JmgTermJob              jmgTermJob;
        JmgJobBundle            localCurrentBundle = currentBundle;

        if (_set && localCurrentBundle && markedAssistant)
        {
            warning("@SYS39132");
        }
        else if (_set && localCurrentBundle)
        {
            jmgTermJob = JmgTermJob::constructJobTable(_jmgJobTable);
            // Check for system commands:
            if (jmgTermJob.signType()       == JmgSignInOut::Clear)
            {
                this.requestLogin();
            }
            else if (jmgTermJob.signType()  == JmgSignInOut::Submit)
            {
                this.approveMarked();
            }
            else if (jmgTermJob.signType()  == JmgSignInOut::SwitchBundleMode)
            {
                this.bundle();
            }
            else if (jmgTermJob.module()    != JmgModuleEnum::PROD)
            {
                if (jmgTermJob.module()     == JmgModuleEnum::PROJ)
                {
                    this.projJobQueueCheck(_jmgJobTable, localCurrentBundle.worker());
                }

                if (_value == NoYes::Yes)
                {
                    // Continue bundle should always be switched to false
                    localCurrentBundle.continueBundle(false);
                    localCurrentBundle.removeAllJobs();
                    localCurrentBundle.addJob(_jmgJobTable);
                }
                else
                {
                    localCurrentBundle.removeJob(_jmgJobTable);
                }
                jmgRegistrationSetup    = form.getRegistrationSetup();
            }
            else
            {
                // Job is a production job.
                jmgRegistrationSetup    = form.getRegistrationSetup();

                // Perform mandatory check
                this.mandatoryCheck(_jmgJobTable);

                // Perform job queue check
                if (jmgRegistrationSetup.WrkCtrValidation)
                {
                    this.prodAreaCheck(_jmgJobTable);
                }

                if (_value == NoYes::Yes)
                {
                    if (_fromScannerField)
                    {
                        // If called from scanner field - only add this job and clear other selections
                        localCurrentBundle.removeAllJobs();
                    }
                    localCurrentBundle.addJob(_jmgJobTable);
                }
                else
                {
                    localCurrentBundle.removeJob(_jmgJobTable);
                }
            }
            this.maintainDocumentHandling();
        }

        if (localCurrentBundle)
        {
            this.enableDisableButtons(this.isFeedbackEnabled());
            return localCurrentBundle.containsJob(_jmgJobTable.JobId);
        }
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectedJobIdsSet</Name>
				<Source><![CDATA[
    public Set getSelectedJobIdsSet()
    {
        JmgJobTable jobTable = this.selectedJobs();
        Set res = new Set(Types::String);
        while select jobTable
        {
            res.add(jobTable.JobId);
        }

        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSelectedJobIdsCon</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the selected job IDs.
    /// </summary>
    /// <returns>
    ///    A container that has selected job IDs on job registration form.
    /// </returns>
    public container getSelectedJobIdsCon()
    {
        MapIterator mi;
        JmgTermJob  job;
        container   jobIds = this.getJobIdsCon();

        // When new bundle is marked on employee setup, active jobs will be removed from new job map.
        // All active jobs will be selected on Job registration form consistently.
        if (currentBundle && currentBundle.continueBundle())
        {
            mi = currentBundle.getActiveJobsIterator();
            while (mi.more())
            {
                job = mi.value();
                if (job.signType() == JmgSignInOut::Job)
                {
                    jobIds += job.jobId();
                }
                mi.next();
            }
        }
        return jobIds;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maintainDocumentHandling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the document handling part on the registration form.
    /// </summary>
    private void maintainDocumentHandling()
    {
        if (docHand && currentBundle)
        {
            docHand.updateDocs(currentBundle.worker(),this.getSelectedJobIdsCon());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mandatoryCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a job marked as high priority must be started before the specified job.
    /// </summary>
    /// <param name="_jmgJobTable">
    ///    The job to check to see whether any high priority jobs exist.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    A high-priority job must be started before the specified job.
    /// </exception>
    protected void mandatoryCheck(JmgJobTable _jmgJobTable)
    {
        JmgJobTable jmgJobTable;
        JmgTermReg  jmgTermReg;

        if (_jmgJobTable.Locked == NoYes::No)
        {
            select firstonly jmgJobTable
                where jmgJobTable.WrkCtrId  == _jmgJobTable.WrkCtrId    &&
                      jmgJobTable.JobId     != _jmgJobTable.JobId       &&
                      jmgJobTable.Locked    == NoYes::Yes
                notexists join jmgTermReg
                where jmgTermReg.JobId      == jmgJobTable.JobId;

            if (jmgJobTable)
            {
                throw error("@SYS304385");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>markedAssistant</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the ID of the worker, which is used to create a start assistance registration.
    /// </summary>
    /// <param name="_worker">
    ///    The ID of the worker to use on a start assistance registration.
    /// </param>
    /// <returns>
    ///    The ID of the worker, which is used to create a start assistance registration.
    /// </returns>
    public JmgWorkerRecId markedAssistant(JmgWorkerRecId _worker = markedAssistant)
    {
        if (_worker && currentBundle && currentBundle.jobsAdded())
            warning("@SYS39132");
        else
            markedAssistant = _worker;

        return markedAssistant;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes a new instance of the <c>JmgRegistrationForm</c> class.
    /// </summary>
    /// <param name="_form">
    ///    A reference to the <c>FormRun</c> object of the <c>JmgRegistration</c>.
    /// </param>
    /// <param name="_enableBundleInteraction">
    ///    Enable bundle to communicate via Infologs
    /// </param>
    protected void new(FormRun _form, boolean _enableBundleInteraction = true)
    {
        super();
        form = _form;
        enableBundleInteraction = _enableBundleInteraction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWrkCtrIdPilot</Name>
				<Source><![CDATA[
    public JmgWrkCtrIdPilot parmWrkCtrIdPilot(WrkCtrId _wrkCtrId = wrkCtrIdPilot)
    {
        wrkCtrIdPilot = _wrkCtrId;
        return wrkCtrIdPilot;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCurrentBundle</Name>
				<Source><![CDATA[
    public JmgJobBundle getCurrentBundle()
    {
        return currentBundle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWStartQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets and sets the start quantity, that the worker enters on a selected job.
    /// </summary>
    /// <param name="_set">
    /// true, if the worker has set a new value.
    /// </param>
    /// <param name="_jmgJobTable">
    /// A <c>JmgJobTable</c> record, which refers to the job to set a start quantity for.
    /// </param>
    /// <param name="_value">
    /// The new value of the start quantity for the specified job.
    /// </param>
    /// <returns>
    /// the start quantity currently associated to the specified job.
    /// </returns>
    public PdsCWInventQty pdsCWStartQty(boolean _set, JmgJobTable _jmgJobTable, PdsCWInventQty _value)
    {
        PdsCWInventQty            ret = 0;
        JmgRegistrationParameters rp;

        if (currentBundle)
        {
            rp = currentBundle.getStartupParameters(_jmgJobTable.JobId);

            if (_set)
            {
                rp.pdsCWStartQuantity(_value);
                if (_jmgJobTable.ItemId && !rp.startQuantity())
                {
                    rp.startQuantity(PdsCatchWeight::inventQty(_jmgJobTable.ItemId, _value));
                }
                currentBundle.setStartupParameters(_jmgJobTable.JobId, rp);
            }

            ret = rp.pdsCWStartQuantity();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>preApprove</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Shows any mandatory documents to the worker, which must be read before approving job registrations.
    /// </summary>
    /// <returns>
    ///    true if the worker reads the documents; otherwise, false.
    /// </returns>
    boolean preApprove()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>prodAreaCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified job is part of the displayed job list.
    /// </summary>
    /// <param name="_jmgJobTable">
    ///    A <c>JmgJobTable</c> record that references the job to check for job list membership.
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The worker is not able to create registrations on the job from the displayed job list.
    /// </exception>
    protected void prodAreaCheck(JmgJobTable _jmgJobTable)
    {
        WrkCtrTable         wrkCtrTable;
        WrkCtrResourceGroup wrkCtrResourceGroup;

        InventSiteId        selectedInventSiteId;
        ProdUnitId          selectedProdUnitId;
        WrkCtrId            selectedWrkCtrId;

        selectedInventSiteId    = form.emplInventSiteId();
        selectedProdUnitId      = form.emplProdUnitId();
        selectedWrkCtrId        = form.emplWrkCtrId();

        if (selectedWrkCtrId || selectedProdUnitId || selectedInventSiteId)
        {
            wrkCtrTable         = WrkCtrTable::find(_jmgJobTable.WrkCtrId);
            wrkCtrResourceGroup = WrkCtrTable::resourceGroup(_jmgJobTable.WrkCtrId, _jmgJobTable.FromDate, _jmgJobTable.ToDate);

            if (selectedWrkCtrId)
            {
                if (!wrkCtrTable || (_jmgJobTable.WrkCtrId != selectedWrkCtrId && wrkCtrResourceGroup.WrkCtrId != selectedWrkCtrId))
                {
                    throw error(strFmt("@SYS39813", _jmgJobTable.JobId));
                }
            }
            else if (selectedProdUnitId)
            {
                if (!wrkCtrTable || wrkCtrResourceGroup.ProdUnitId != selectedProdUnitId)
                {
                    throw error(strFmt("@SYS39813", _jmgJobTable.JobId));
                }
            }
            else if (selectedInventSiteId)
            {
                if (!wrkCtrTable || wrkCtrResourceGroup.SiteId != selectedInventSiteId)
                {
                    throw error(strFmt("@SYS39813", _jmgJobTable.JobId));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>projJobQueueCheck</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the worker can create registrations on the specified project job.
    /// </summary>
    /// <param name="_jmgJobTable">
    ///    The <c>JmgJobTable</c> record, which refers to the project job to check.
    /// </param>
    /// <param name="_worker">
    ///    The ID of the worker to check
    /// </param>
    /// <exception cref="M:Exception::Error">
    ///    The worker is not allowed to create a registration on the specified project job.
    /// </exception>
    protected void projJobQueueCheck(JmgJobTable _jmgJobTable, JmgWorkerRecId _worker)
    {
        ProjValCheckTrans       projValCheckTrans;
        boolean                 result;
        JmgRegistrationSetup    jmgRegistrationSetup;
        projValCheckTrans = new ProjValCheckTrans();
        projValCheckTrans.parmProjId(_jmgJobTable.ModuleRefId);
        projValCheckTrans.parmResource(ResourceFacade::findOrCreateByWorker(_worker));
        projValCheckTrans.checkResourceProj(true);
        result = projValCheckTrans.validateMandatory(null);

        if (!result)
        {
            throw error(strFmt("@SYS39813", _jmgJobTable.JobId));
        }

        jmgRegistrationSetup    = form.getRegistrationSetup();
        // If job is a project budget line, and is scheduled on a work center,
        // then perform wrk ctr validation.
        if (jmgRegistrationSetup.WrkCtrValidation               &&
            _jmgJobTable.Type   == JmgJobTableType::ProjBudget  &&
            _jmgJobTable.WrkCtrId)
        {
            this.prodAreaCheck(_jmgJobTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>registerOnJob</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a start job registration on the specified job ID.
    /// </summary>
    /// <param name="_jobId">
    ///    The job ID on which to create start job registration.
    /// </param>
    /// <param name="_reqLogIn">
    ///    A Boolean value that specifies whether the registration form must return to the welcome screen
    ///    after the registration has been made.
    /// </param>
    void registerOnJob(JmgJobId _jobId, boolean _reqLogIn = false)
    {
        JmgJobTable jobTable;
        jobTable = JmgJobTable::find(_jobId);
        this.jobMarked(true,jobTable,1,0);
        this.approveMarked();
        if (_reqLogIn)
        {
            this.requestLogin();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>rememberButton</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Stores the button that is used to perform certain operations.
    /// </summary>
    /// <param name="_fc">
    ///    The <c>FormControl</c> object, which is used to start the function.
    /// </param>
    /// <param name="_buttonFunction">
    ///    The function that is started by the button.
    /// </param>
    public void rememberButton(FormControl _fc, JmgSignInButtonFunction _buttonFunction)
    {
        if (_buttonFunction == JmgSignInButtonFunction::Attachment)
        {
            docHand.parmMenuButton(_fc);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>requestLogin</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Logs out the current user and presents a log on screen on the client.
    /// </summary>
    /// <param name="_forceSwitch">
    ///    A Boolean value that indicates whether to force logon even though user has locked client; optional.
    /// </param>
    public void requestLogin(boolean _forceSwitch = false)
    {
        JmgRegistrationSetup    jmgRegistrationSetup = form.getRegistrationSetup();
        JmgEmployee             jmgEmployee;
        //Change view to login, and clear user Vars
        if (jmgRegistrationSetup.LockEmployee && !_forceSwitch)
        {
            if (currentWorker)
            {
                jmgEmployee = JmgEmployee::find(currentWorker);
                currentBundle = new JmgJobBundle(jmgEmployee.Worker,this.isBundleJobsSupported(jmgEmployee), true, enableBundleInteraction, lastRegSetup);
                currentBundle.parmCallerForm(form);
                currActCount = conLen(this.getCurrJobIdsCon());
                form.enableScreen(true);
            }
            return;
        }
        form.scrSwitch(true,false);
        currentBundle = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Resets the <c>JmgRegistrationForm</c> object to its initial state.
    /// </summary>
    void reset()
    {
        currentBundle      = null;
        markedAssistant    = 0;
        form.unblockUserLogin();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveSignInJob</Name>
				<Source><![CDATA[
    public JmgJobTable retrieveSignInJob()
    {
        JmgJobTable jobTable = JmgJobTable::find(JmgIpcActivity::findSignInJobId());

        if (!jobTable.RecId)
        {
            this.reset();
            throw error("@SYS4006004");
        }

        return jobTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectedJobs</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves a temporary buffer of <c>JmgJobTable</c> records, which contains a record for each job
    ///    that is currently selected by the worker.
    /// </summary>
    /// <returns>
    ///    A temporary buffer of <c>JmgJobTable</c> records
    /// </returns>
    public JmgJobTable selectedJobs()
    {
        JmgJobTable ret;
        JmgTermJob  job;
        MapIterator mi;
        JmgJobBundle localCurrentBundle = currentBundle;

        // TwC: All jobs can be added to selected jobs.
        ret.setTmp();
        if (localCurrentBundle)
        {
            mi = localCurrentBundle.getNewJobsIterator();
            while (mi.more())
            {
                job = mi.value();

                ret.data(JmgJobTable::find(job.jobId()));
                ret.insert();

                mi.next();
            }

            if (localCurrentBundle.continueBundle())
            {
                mi = localCurrentBundle.getActiveJobsIterator();
                while (mi.more())
                {
                    job = mi.value();

                    ret.data(JmgJobTable::find(job.jobId()));
                    ret.insert();

                    mi.next();
                }
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupRegistrationForm</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Set up registration form for the current worker.
    /// </summary>
    /// <param name="_worker">
    ///     The worker id to set.
    /// </param>
    /// <param name="_jmgRegistrationSetup">
    ///     The registration setup, which should be used for the specified worker.
    /// </param>
    /// <param name="_onlyClockIn">
    ///     True if a clock in registration is the only thing which should be created for the worker.
    ///     False if the worker can interact further with the registration form.
    /// </param>
    /// </param>
    /// <param name="_loginDateTime">
    ///     The login date and time; optional.
    /// </param>
    /// <returns>
    ///     The current worker id.
    /// </returns>
    /// <exception cref="Exception::Error">
    ///     Throws an error if it is attempted to set a new worker, while another worker is currently creating registrations.
    /// </exception>
    public JmgWorkerRecId setupRegistrationForm(JmgWorkerRecId _worker, JmgRegistrationSetup _jmgRegistrationSetup, boolean _onlyClockIn = false, utcDateTime _loginDateTime = utcDateTimeNull())
    {
        JmgEmployee             jmgEmployee;
        boolean                 taEnabled;
        boolean                 okToClockIn;
        JmgJobBundle            jmgJobBundle;
        HcmWorker               hcmWorker;
        boolean                 clockUserOutAutomatically = false;
        boolean                 returnToWelcomeScreenAutomatically = false;
        boolean                 hasCancelledEmployeeClockOutDialog;

        if (_worker)
        {
            if (currentBundle && _worker != currentBundle.worker())
            throw error("@SYS86990");

            jmgEmployee = JmgEmployee::find(_worker);
            hcmWorker   = HcmWorker::find(_worker);

            taEnabled = isConfigurationkeyEnabled(configurationKeyNum(Jmg));

            if (!currentBundle)
            {
                currentBundle = new JmgJobBundle(_worker, this.isBundleJobsSupported(jmgEmployee), true, enableBundleInteraction, _jmgRegistrationSetup, _loginDateTime);
                currentBundle.parmCallerForm(form);
                currentBundle.checkEmployeeForgotClockOut();
                hasCancelledEmployeeClockOutDialog = currentBundle.parmHasCancelledEmployeeClockOutDialog();
                okToClockIn = _onlyClockIn ? !JmgEmployee::signedIn(_worker) : true;
                if (taEnabled && okToClockIn)
                {
                    jmgJobBundle = new JmgJobBundle(currentBundle.worker(), this.isBundleJobsSupported(jmgEmployee), true, enableBundleInteraction, _jmgRegistrationSetup, _loginDateTime);
                    jmgJobBundle.addJob(this.retrieveSignInJob());
                    jmgJobBundle.parmCallerForm(form);
                    form.blockUserLogin();
                    try
                    {
                        if (!jmgJobBundle.makeRegistrations())
                        {
                            this.reset();
                            return 0;
                        }
                    }
                    catch(Exception::Error)
                    {
                        this.reset();
                        throw Exception::Error;
                    }

                    form.unblockUserLogin();
                    currentBundle = new JmgJobBundle(_worker, this.isBundleJobsSupported(jmgEmployee), true, enableBundleInteraction, _jmgRegistrationSetup, _loginDateTime);
                    currentBundle.parmCallerForm(form);
                }

                emplFlexDate    = jmgEmployee.flexDate();
                emplFlexBalance = jmgEmployee.flexBalance();
                name            = HcmWorker::worker2Name(currentBundle.worker());
            }
            docHand = JmgMESDocuHandling::construct(null);

            noButtonsOnConfiguration = this.clockInClockOutModeOnly(_jmgRegistrationSetup);

            if (noButtonsOnConfiguration || hasCancelledEmployeeClockOutDialog)
            {
                returnToWelcomeScreenAutomatically = true;
            }

            // Clock out employee automatically if employee is already clocked in, configuration is clock in and out mode and if applicable, if employee did not cancel missing clock-out job dialog.
            clockUserOutAutomatically = !okToClockIn && noButtonsOnConfiguration && !hasCancelledEmployeeClockOutDialog;

            lastRegSetup = _jmgRegistrationSetup;

            this.setupActionPane(_jmgRegistrationSetup);
            this.signInStartPage(_jmgRegistrationSetup);
            this.setupPreviewPanes();

            this.maintainDocumentHandling();
            currentWorker = _worker;
        }

        if (clockUserOutAutomatically)
        {
            this.clockUserOut();
        }
        else if (returnToWelcomeScreenAutomatically)
        {
            form.setRegistrationSetup(_jmgRegistrationSetup);
            this.requestLogin(hasCancelledEmployeeClockOutDialog);
        }

        if (currentBundle)
        {
            currActCount = conLen(this.getCurrJobIdsCon());
            return currentBundle.worker();
        }
        else
        {
            emplFlexDate    = dateNull();
            emplFlexBalance = '';
            name            = '';
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clockInClockOutModeOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if this is a clock in and out mode only.
    /// </summary>
    /// <param name = "_jmgRegistrationSetup"> The current configuration setup.</param>
    /// <returns>true if this is a clock in and out mode only; otherwise false.</returns>
    [Hookable(false)]
    protected boolean clockInClockOutModeOnly(JmgRegistrationSetup _jmgRegistrationSetup)
    {
        return _jmgRegistrationSetup.EnableDevice == NoYes::No &&
               !JmgRegistrationFormBase::doesConfigurationContainButtons(_jmgRegistrationSetup);
    }

]]></Source>
			</Method>
			<Method>
				<Name>showLossProfit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a profit and loss inventory journal and then displays it to the user.
    /// </summary>
    void showLossProfit()
    {
        JmgPostStandardSystem jmgPostStandardSystem;
        if (currentBundle)
        {
            jmgPostStandardSystem = JmgPostStandardSystem::constructJobBundle(currentBundle, true);
            jmgPostStandardSystem.showProfitLossInventJournal();
            this.requestLogin();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjectFee</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a project fee journal and then displays it to the user.
    /// </summary>
    void showProjectFee()
    {
        JmgPostStandardSystem jmgPostStandardSystem;
        if (currentBundle)
        {
            jmgPostStandardSystem = JmgPostStandardSystem::constructJobBundle(currentBundle, false, true);
            jmgPostStandardSystem.showProjectFeeJournal();
            this.requestLogin();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>showProjectItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a project item journal and then displays it to the user.
    /// </summary>
    void showProjectItem()
    {
        JmgPostStandardSystem jmgPostStandardSystem;
        if (currentBundle)
        {
            jmgPostStandardSystem = JmgPostStandardSystem::constructJobBundle(currentBundle, false, true);
            jmgPostStandardSystem.showProjectItemJournal();
            this.requestLogin();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>signInOut</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a clock in or clock out registration for the worker.
    /// </summary>
    /// <remarks>
    ///    A Boolean value that indicates whether a clock in registration or a clock out registration is made,
    ///    depending on the workers current clock in status.
    /// </remarks>
    void signInOut()
    {
        JmgJobTable     signInOutJob;
        Set             jobsInBundle;
        MapIterator     jobsIterator;
        SetEnumerator   setEnumerator;
        JmgTermJob      jmgTermJob;
        boolean         continueBundle;
        JmgJobBundle    localCurrentBundle = currentBundle;

        if (localCurrentBundle)
        {
            // Clear all jobs added in bundle:
            jobsInBundle = new Set(Types::Class);
            jobsIterator = localCurrentBundle.getNewJobsIterator();
            while (jobsIterator.more())
            {
                jobsInBundle.add(jobsIterator.value());
                jobsIterator.next();
            }
            setEnumerator = jobsInBundle.getEnumerator();
            while (setEnumerator.moveNext())
            {
                jmgTermJob  = setEnumerator.current();
                localCurrentBundle.removeJob(jmgTermJob.jmgJobTable());
            }

            continueBundle  = localCurrentBundle.continueBundle();
            localCurrentBundle.continueBundle(false);
            if (JmgEmployee::signedIn(localCurrentBundle.worker()))
            {
                signInOutJob = JmgJobTable::find(JmgIpcActivity::findSignTypeJobId(JmgSignInOut::SignOut));
            }
            else
            {
                signInOutJob = JmgJobTable::find(JmgIpcActivity::findSignTypeJobId(JmgSignInOut::SignIn));
            }
            try
            {
                localCurrentBundle.addJob(signInOutJob);
                this.approveMarked(true);
            }
            catch (Exception::Error)
            {
                // Clear bundle:
                localCurrentBundle.removeJob(signInOutJob);

                // Add jobs again:
                localCurrentBundle.continueBundle(continueBundle);
                setEnumerator = jobsInBundle.getEnumerator();
                while (setEnumerator.moveNext())
                {
                    localCurrentBundle.addTermJob(setEnumerator.current());
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>signInOutUser</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a clock in or clock out registration for the specified worker.
    /// </summary>
    /// <param name="_worker">
    ///    The ID of the worker for which to create a clock in or a clock out registration.
    /// </param>
    /// <param name="_signInUser">
    ///    A Boolean value that specifies whether the worker must be clocked in.
    /// </param>
    /// <returns>
    ///    true if the worker has the requested clock in status; otherwise, false.
    /// </returns>
    boolean signInOutUser(JmgWorkerRecId _worker, boolean _signInUser)
    {
        JmgJobTable     signInOutJob;
        Set             jobsInBundle;
        MapIterator     jobsIterator;
        SetEnumerator   setEnumerator;
        JmgTermJob      jmgTermJob;
        boolean         continueBundle;
        boolean         userSignedIn;
        boolean         ret = false;
        JmgJobBundle    localCurrentBundle = currentBundle;

        userSignedIn = JmgEmployee::signedIn(_worker);

        if (_signInUser == userSignedIn)
        {
            ret = true;
        }

        if (!ret && localCurrentBundle)
        {
            // Clear all jobs added in bundle:
            jobsInBundle = new Set(Types::Class);
            jobsIterator = localCurrentBundle.getNewJobsIterator();
            while (jobsIterator.more())
            {
                jobsInBundle.add(jobsIterator.value());
                jobsIterator.next();
            }
            setEnumerator = jobsInBundle.getEnumerator();
            while (setEnumerator.moveNext())
            {
                jmgTermJob  = setEnumerator.current();
                localCurrentBundle.removeJob(jmgTermJob.jmgJobTable());
            }

            continueBundle  = localCurrentBundle.continueBundle();
            localCurrentBundle.continueBundle(false);
            signInOutJob = JmgJobTable::find(JmgIpcActivity::findSignTypeJobId((_signInUser ? JmgSignInOut::SignIn : JmgSignInOut::SignOut)));

            try
            {
                localCurrentBundle.addJob(signInOutJob);
                ret = this.approveMarked(true); 
            }
            catch (Exception::Error)
            {
                // Clear bundle:
                localCurrentBundle.removeJob(signInOutJob);

                // Add jobs again:
                localCurrentBundle.continueBundle(continueBundle);
                setEnumerator = jobsInBundle.getEnumerator();
                while (setEnumerator.moveNext())
                {
                    localCurrentBundle.addTermJob(setEnumerator.current());
                }
            }
        }

        JmgInstrumentationClockInOut::registerDailyActiveUsage(_worker);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startAssistance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a start assistance registration.
    /// </summary>
    public void startAssistance()
    {
        JmgRegistrationSetup jmgRegistrationSetup = form.getRegistrationSetup();
        if (jmgRegistrationSetup.LockEmployee == NoYes::Yes)
        {
            this.autoEndBreak(jmgRegistrationSetup, true);
        }
        if (this.markedAssistant() || this.parmWrkCtrIdPilot())
        {
            if (this.approveMarked())
            {
                this.startAssistancePost();
                this.requestLogin();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>startFeedback</Name>
				<Source><![CDATA[
    /// <summary>
    /// Start feedback with a preset feedback status.
    /// </summary>
    /// <param name="_feedback">
    /// The preset feedback status the feedback form should open up with.
    /// </param>
    /// <param name="_presetStatus">
    /// boolean value, denoting if the preset value should be used.
    /// </param>
    public void startFeedback(JmgFeedbackStatus _feedback = JmgFeedbackStatus::InProgress, boolean _presetStatus = false)
    {
        JmgEmployee             jmgEmployee;
        JmgJobBundle            localCurrentBundle = currentBundle;
        JmgRegistrationSetup    jmgRegistrationSetup;
        boolean                 makeFeedback;
        container               jobIds = conNull();
        boolean                 usedResourceJob = this.isResourceJobs();

        if (!localCurrentBundle)
        {
            return;
        }

        if (usedResourceJob)
        {
            localCurrentBundle.parmResourceRegistration(true);
        }

        form.enableScreen(false);
        localCurrentBundle.parmCallerForm(form);

        if (!_presetStatus)
        {
            localCurrentBundle.setFeedbackStatusOnActiveJobs(JmgParameters::find().DefaultReportAsFinish);
        }
        else
        {
            localCurrentBundle.setFeedbackStatusOnActiveJobs(_feedback);
        }

        jmgRegistrationSetup = form.getRegistrationSetup();
        if (jmgRegistrationSetup.LockEmployee == NoYes::Yes || jmgRegistrationSetup.UseActualTimeOfRegistration == NoYes::Yes)
        {
            makeFeedback = localCurrentBundle.makeFeedbackOnActiveJobs(JmgProfileSeconds::getSysDate(), JmgProfileSeconds::getSysTime());
        }
        else
        {
            makeFeedback = localCurrentBundle.makeFeedbackOnActiveJobs();
        }

        boolean loginRequested = false;

        if (makeFeedback)
        {
            jmgEmployee = JmgEmployee::find(localCurrentBundle.worker());
            currentBundle = new JmgJobBundle(jmgEmployee.Worker,this.isBundleJobsSupported(jmgEmployee), true, enableBundleInteraction, lastRegSetup);
            currentBundle.parmCallerForm(form);
            currActCount = conLen(this.getCurrJobIdsCon());

            if (this.isFeedbackEnabled())
            {
                loginRequested = true;
                this.requestLogin();
            }

            this.reportFeedbackPost();
        }

        if (usedResourceJob)
        {
            localCurrentBundle.parmResourceRegistration(false);
        }

        form.redraw();
        if (enableBundleInteraction)
        {
            form.updateLayout();
        }

        if (!loginRequested)
        {
            form.enableScreen(true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>startFeedbackCompleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Start feedback with a feedback status preset to the <c>Completed</c> enumeration value of the <c>JmgFeedbackStatus</c> enumeration type.
    /// </summary>
    public void startFeedbackCompleted()
    {
        this.startFeedbackPreset(JmgFeedbackStatus::Completed);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startFeedbackPreset</Name>
				<Source><![CDATA[
    /// <summary>
    /// Start feedback with a preset feedback status.
    /// </summary>
    /// <param name="_feedback">
    /// The preset feedback status the feedback form should open up with.
    /// </param>
    public void startFeedbackPreset(JmgFeedbackStatus _feedback = JmgFeedbackStatus::InProgress)
    {
        this.startFeedback(_feedback,true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startFeedbackStopped</Name>
				<Source><![CDATA[
    /// <summary>
    /// Start feedback with a feedback status preset to the <c>Stopped</c> enumeration value of the <c>JmgFeedbackStatus</c> enumeration type.
    /// </summary>
    public void startFeedbackStopped()
    {
        this.startFeedbackPreset(JmgFeedbackStatus::Stopped);
    }

]]></Source>
			</Method>
			<Method>
				<Name>startQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets and sets the start quantity, that the worker enters on a selected job.
    /// </summary>
    /// <param name="_set">
    ///    A Boolean value that specifies whether the worker has set a new value.
    /// </param>
    /// <param name="_jmgJobTable">
    ///    A <c>JmgJobTable</c> record, which refers to the job to set a start quantity for.
    /// </param>
    /// <param name="_value">
    ///    The new value of the start quantity for the specified job.
    /// </param>
    /// <returns>
    ///    The start quantity that is currently associated to the specified job.
    /// </returns>
    public Qty startQty(boolean _set, JmgJobTable _jmgJobTable, Qty _value)
    {
        Qty ret = 0;
        JmgRegistrationParameters rp;
        JmgJobBundle localCurrentBundle = currentBundle;

        if (localCurrentBundle)
        {
            rp = localcurrentBundle.getStartupParameters(_jmgJobTable.JobId);

            if (_set)
            {
                rp.startQuantity(_value);
                if (_jmgJobTable.ItemId && !rp.pdsCWStartQuantity())
                {
                    rp.pdsCWStartQuantity(PdsCatchWeight::cwQty(_jmgJobTable.ItemId, _value));
                }
                localcurrentBundle.setStartupParameters(_jmgJobTable.JobId, rp);
            }

            ret = rp.startQuantity();
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>switchUser</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears any information entered by a worker and then returns the registration form to the Welcome
    ///    screen.
    /// </summary>
    public void switchUser()
    {
        this.clearBundle();
        currentBundle = null;
        this.requestLogin(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>worker</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns current worker
    /// </summary>
    /// <returns>The worker rec id.</returns>
    public JmgWorkerRecId worker()
    {
        JmgJobBundle localCurrentBundle = currentBundle;
        if (localCurrentBundle)
        {
            currActCount = conLen(this.getCurrJobIdsCon());
            return localCurrentBundle.worker();
        }
        else
        {
            emplFlexDate    = dateNull();
            emplFlexBalance = '';
            name            = '';
        }

        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workerName</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Returns the name of the Worker who is currently using the registration form.
    /// </summary>
    /// <returns>
    ///     The name of the current active worker.
    /// </returns>
    public DirPartyName workerName()
    {
        JmgJobBundle localCurrentBundle = currentBundle;
        if (!localCurrentBundle)
            return '';

        return HcmWorker::worker2Name(localCurrentBundle.worker());
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesConfigurationContainButtons</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the specified configuration has any buttons assigned in its action pane
    ///    configuration.
    /// </summary>
    /// <param name="_registrationSetup">
    ///    The <c>JmgRegistrationSetup</c> record to check for assigned buttons.
    /// </param>
    /// <returns>
    ///    true if configuration contains buttons; otherwise, false.
    /// </returns>
    private static boolean doesConfigurationContainButtons(JmgRegistrationSetup _registrationSetup)
    {
        JmgRegistrationButtonTable buttonTable;

        select firstonly RecId from buttonTable where buttonTable.ActionPaneSetupID == _registrationSetup.ActionPaneSetupID && buttonTable.ButtonSetupType == JmgButtonSetupType::Button;
        return buttonTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startJobQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Set start quantity for the specified job.
    /// </summary>
    /// <param name = "_jmgJobTable">
    ///  The job record.
    /// </param>
    /// <param name = "_qtyToStart">
    ///  The inventory quantity to start.
    /// </param>
    /// <param name = "_cwQtyToStart">
    ///  The catch weight quantity to start, default is zero.
    /// </param>
    public void startJobQuantity(JmgJobTable _jmgJobTable, InventQty _qtyToStart, PdsCWQty _cwQtyToStart = 0)
    {
        this.startQty(true, _jmgJobTable, _qtyToStart);
        this.pdsCWStartQty(true, _jmgJobTable, _cwQtyToStart);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBundleJobsSupported</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Determines if the current configuration supports bundling of jobs for a given employee.
    /// </summary>
    /// <param name = "_jmgEmployee">
    ///  The employee record.
    /// </param>
    /// <returns>
    /// True if the current configuration supports job bundling for the specified employee.
    /// </returns>
    protected internal boolean isBundleJobsSupported(JmgEmployee _jmgEmployee)
    {
        return _jmgEmployee.StopJobs == NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRegistrationSetup</Name>
				<Source><![CDATA[
	internal JmgRegistrationSetup parmRegistrationSetup()
    {
        return form.getRegistrationSetup();
	}

]]></Source>
			</Method>
			<Method>
				<Name>getOrCreateLogger</Name>
				<Source><![CDATA[
    private JmgInstrumentationLogger getOrCreateLogger()
    {
        if(!jmgInstrumentationLogger)
        {
            jmgInstrumentationLogger = JmgInstrumentationLogger::createLogger(classStr(JmgRegistrationFormBase));
        }
        return jmgInstrumentationLogger;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>