<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PurchInvoiceJournalPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class PurchInvoiceJournalPost extends FormletterJournalPost
{
    VendInvoiceInfoTable vendInvoiceInfoTable;
    VendInvoiceInfoLine vendInvoiceInfoLine;
    PurchParmUpdate purchParmUpdate;
    PurchLine purchLine;
    PurchTable purchTable;

    VendInvoiceJour vendInvoiceJour;
    VendInvoiceTrans vendInvoiceTrans;
    PurchTotals purchTotals;
    PurchCalcTax purchCalcTax;
    boolean useInternalNumber;

    PurchQty invoiceUpdatedOnly;

    PurchQty qtyDeliveredNoInvoice;
    PurchQty salesUpdateQty;

    SysQueryRun updateSalesLinesQuery;

    boolean updateSalesLines;
    boolean useQualityManagement;
    TaxParameters taxParameters;
    RefRecId activeAccountingEventId;

    MainAccount postingMainAccount;

    AmountCur purchValue;

    AmountMSTSecondary purchValueSecCur;
    CostAmountSecCur_RU costAmountMSTSecCur;
    NoYes printFacture;
    NoYes printAcceptanceReport;
    AmountCur cashDiscountAmount;
    AmountCur discValue;

    VendInvoiceInfoLine_Asset vendInvoiceInfoLine_Asset;
    AmountCur tmpTax1099Amount;
    Tax1099Amount totalTax1099Amount;
    Tax1099StateAmount totalTax1099StateAmount;
    Tax1099FieldsRecId firstTax1099Fields;
    Tax1099State firstTax1099State;

    Map purchValueMap;

    boolean saveChanges;

    InventMovement inventMovement;

    MarkupAmount markupCustVendCopy;
    container purchLineRec;
    container vendInvoiceTransRec;
    AmountCur withholdingTax;
    boolean loadOnInventoryExisted;
    boolean isCustomsImportOrder;
    Voucher chargeAsExpenseDocumentVoucher;
    LedgerVoucherObject ledgerVoucherObjectForChargeAsExpense;
    TransDate lastTransDateLoc;
    Voucher lastVoucherLoc;
    CurrentOperationsTax lastPostingLayerLoc;
    #ISOCountryRegionCodes

    LeanCostingFacadeBase leanCostingFacade;
    LeanConversionCostUpd leanConversionCostUpd;
    NoYes printSalesFormLetter;
    NoYes printEuVatInvoice;

    boolean distributionsExist;
    AmountCur totalRetainedAmount;

    RecordSortedList journalLines_BR;

    Voucher costVoucher;
    Map lateMatchingPackingSlipsPerInvoiceLine; // key = Invoice Line RecId, value = List of packing slip records
    SourceDocumentCompletionRule sourceDocumentCompletionRule;
    
    boolean sourceDocumentLinesDistributed;
    boolean isExecutingPaymentAuthorizationTask;
    private PurchInstrumentationLogger  instrumentationLogger;
    private ProdJournalPostVendorProdBOM postVendorProdBOM;
    private ProdJournalPostVendorProdBOMHelper postVendorProdBOMHelper;

    private boolean isPostVendorProdBOMInOrderFeatureEnabled;
    private int sourceDocumentLineCount;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addToInventReportDimHistory</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds the <c>InventReportDimHistory</c> records to a sorted list.
    /// </summary>
    /// <param name="_journalLine">
    ///    The vendor invoice transaction for which to create the <c>InventReportDimHistory</c> records.
    /// </param>
    protected void addToInventReportDimHistory(Common _journalLine)
    {
        InventTransOrigin inventTransOrigin;
        InventTrans inventTrans;
        VendInvoiceTrans localVendInvoiceTrans = _journalLine as VendInvoiceTrans;
        InventQty qtyRemain = localVendInvoiceTrans.InventQty;

        if (!localVendInvoiceTrans.isNonPO() && purchLine.isStocked())
        {
            Debug::assert(costVoucher != '');

            while select TableId from inventTransOrigin
                where inventTransOrigin.InventTransId == localVendInvoiceTrans.InventTransId
                   && inventTransOrigin.ReferenceCategory == InventTransType::Purch
                join InventDimId, sum(Qty) from inventTrans
                group by InventDimId
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                   && inventTrans.InvoiceId == localVendInvoiceTrans.InvoiceId
                   && inventTrans.DateFinancial == localVendInvoiceTrans.InvoiceDate
                   && inventTrans.Voucher == costVoucher
            {
                if (qtyRemain)
                {
                    qtyRemain = this.createInventReportDimHistory(localVendInvoiceTrans.InventTransId,
                                                                  inventTrans.InventDimId,
                                                                  localVendInvoiceTrans.InternalInvoiceId,
                                                                  inventTrans.Qty,
                                                                  qtyRemain);
                }
                else
                    break;
            }
        }
        else
        {
            qtyRemain = this.createInventReportDimHistory(localVendInvoiceTrans.InventTransId,
                                                          localVendInvoiceTrans.InventDimId,
                                                          localVendInvoiceTrans.InternalInvoiceId,
                                                          localVendInvoiceTrans.Qty,
                                                          localVendInvoiceTrans.Qty);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustAmountsMST_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts accounting amounts of vendor invoice.
    /// </summary>
    protected void adjustAmountsMST_W()
    {
        AmountAdjustEngineVendInvoice_W::adjustInvoiceJour(vendInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>approval</Name>
				<Source><![CDATA[
    protected NoYes approval()
    {
        return NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>approveVendTrans</Name>
				<Source><![CDATA[
    protected void approveVendTrans()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        instrumentationLogger = PurchInstrumentationLogger::createLogger(classStr(PurchInvoiceJournalPost));
        isPostVendorProdBOMInOrderFeatureEnabled = FeatureStateProvider::isFeatureEnabled(ProdJournalPostVendorProdBOMInOrderFeature::instance());
    }

]]></Source>
			</Method>
			<Method>
				<Name>bondBalanceToLog_RU</Name>
				<Source><![CDATA[
    private void bondBalanceToLog_RU()
    {
        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher ? ledgerVoucher.findLedgerVoucherObject() : null;
        LedgerBondClient_RU ledgerBondClient = ledgerVoucherObject ? ledgerVoucherObject.ledgerBondClient_RU() : null;
        TmpLedgerBondLogTable_RU logTable;

        LedgerBondId_RU vendBalanceVRefId;
        CurrencyCode currencyCode;
        Amount amountToBond;

        if (! ledgerBondClient)
            return;

        logTable = ledgerBondClient.log2Table(ledgerBondClient.currentLog(ledgerVoucher.lastTransDate()));

        select firstonly logTable
            where ! logTable.AmountMST &&
                    logTable.AmountMSTSecondary &&
                   (logTable.Posting == LedgerPostingType::VendBalance ||
                    logTable.Posting == LedgerPostingType::EmplPayment_RU ||
                    logTable.Posting == LedgerPostingType::EmplBalance_RU);
        vendBalanceVRefId = logTable.BondId;
        currencyCode = logTable.CurrencyCode;

        // 'Dual warehouse' transactions
        if (vendBalanceVRefId != 0)
        {
            while select logTable
                where ! logTable.AmountMST &&
                        logTable.AmountMSTSecondary &&
                        logTable.CurrencyCode == currencyCode &&
                        logTable.BondId != vendBalanceVRefId
            {
                ledgerBondClient.bondVRef2VRef(vendBalanceVRefId,
                                               logTable.BondId,
                                               logTable.AmountMSTSecondary,
                                               LedgerBondAmountType_RU::MSTSecondary,
                                               ! logTable.Crediting ?
                                               LedgerBondOrder_RU::CreditToDebit :
                                               LedgerBondOrder_RU::DebitToCredit);
            }
        }

        // Normal transactions
        select firstonly logTable
            where logTable.AmountMST &&
                 (logTable.Posting == LedgerPostingType::VendBalance ||
                  logTable.Posting == LedgerPostingType::EmplPayment_RU ||
                  logTable.Posting == LedgerPostingType::EmplBalance_RU);
        vendBalanceVRefId = logTable.BondId;
        currencyCode = logTable.CurrencyCode;

        while select logTable
            where logTable.AmountMST &&
                  logTable.CurrencyCode == currencyCode &&
                  logTable.BondId != vendBalanceVRefId
        {
            amountToBond = ledgerBondClient.bondTransObject(logTable.BondId).remainAmountCur();
            if (amountToBond)
            {
                ledgerBondClient.bondVRef2VRef(vendBalanceVRefId,
                                               logTable.BondId,
                                               amountToBond,
                                               LedgerBondAmountType_RU::Currency,
                                               ! logTable.Crediting ?
                                               LedgerBondOrder_RU::CreditToDebit :
                                               LedgerBondOrder_RU::DebitToCredit);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateLastPurchPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the last purchase price should be updated.
    /// </summary>
    /// <param name = "_vendInvoiceInfoLine">
    /// An instance of <c>VendInvoiceInfoLine</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the purchase price should be updated; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean shouldUpdateLastPurchPrice(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcLastPurchPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the last purchase price.
    /// </summary>
    protected void calcLastPurchPrice()
    {
        Debug::assert(!vendInvoiceInfoLine.isNonPO());

        if (!vendInvoiceInfoLine.PurchPrice)
        {
            vendInvoiceInfoLine.PurchPrice = PriceDisc::amount2Price(vendInvoiceInfoLine.LineAmount,
                                                               vendInvoiceInfoLine.discPercent(),
                                                               vendInvoiceInfoLine.PurchMarkup,
                                                               vendInvoiceInfoLine.ReceiveNow,
                                                               vendInvoiceInfoLine.discAmount(),
                                                               vendInvoiceInfoLine.PriceUnit,
                                                               vendInvoiceInfoLine.purchLine().CurrencyCode,
                                                               vendInvoiceInfoLine.PurchPrice);
        }

        if (this.shouldUpdateLastPurchPrice(vendInvoiceInfoLine))
        {
            vendInvoiceInfoLine.inventTable().updateLastPurchPrice(vendInvoiceInfoTable.TransDate,
                                                             vendInvoiceInfoTable.CurrencyCode,
                                                             vendInvoiceInfoLine.PurchPrice,
                                                             vendInvoiceInfoLine.PriceUnit,
                                                             vendInvoiceInfoLine.PurchMarkup,
                                                             purchLine.PurchUnit,
                                                             purchLine.inventDim());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateVATDefermentTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and calculate the taxes with required condition.
    /// </summary>
    public void calculateVATDefermentTax_IN()
    {
        VendInvoiceTrans vendInvoiceTransLoc;
        DefermentScheduleTrans_IN defermentSchedule;
        TaxOnItem taxOnItem;
        TaxUncommitted taxUncommitted;
        TaxTable taxTable;
        TransTaxInformation transTaxInformation;

        transTaxInformation = TransTaxInformationHelper::findOrCreateTransTaxInformationByRecord(vendInvoiceInfoLine);

        //For VATGoodsType = Capital goods
        if (transTaxInformation.VATGoodsType == VATGoodsType_IN::CapitalGoods)
        {
            select sum(TaxAmountCur), sum(TaxInCostPriceCur) from taxUncommitted
                where taxUncommitted.SourceTableId == tableNum(VendInvoiceInfoLine)
                && taxUncommitted.SourceRecId == vendInvoiceInfoLine.RecId
            exists join TaxCode from taxOnItem
                where taxOnItem.TaxItemGroup == taxUncommitted.TaxItemGroup
                && taxOnItem.TaxCode == taxUncommitted.TaxCode
            exists join TaxType_IN from taxTable
                where taxTable.TaxCode == taxOnItem.TaxCode
                && taxTable.TaxType_IN == TaxType_IN::VAT;

            vendInvoiceTrans.vatAmount_IN = taxUncommitted.TaxAmountCur;
            vendInvoiceTrans.vatExpense_IN = taxUncommitted.TaxInCostPriceCur;

            // for credit note
            if (purchLine.LineAmount < 0 && purchLine.InventRefId)
            {
                // purchLine.TaxWithholdLineNum_IN field is used instead of purchLine.LineNumber field, since TaxWithholdLineNum_IN whill have the original lineNum of VendInvocieTrans table
                // later code will be modified to use purchLine.LineNumber, since sys dosent have relation to NOO-PO credit note line and original VendInvoieTrans line.

                select firstonly vendInvoiceTransLoc
                    where vendInvoiceTransLoc.PurchID == purchLine.InventRefId
                        && vendInvoiceTransLoc.LineNum == purchLine.purchLine_IN().TaxWithholdLineNum;

                if (vendInvoiceTransLoc)
                {
                    defermentSchedule = DefermentScheduleTrans_IN::findExtRecId(vendInvoiceTransLoc.RecId);
                    vendInvoiceTrans.vatDeferred_IN = this.tax().vatDeferredAmountPerLine_IN(purchLine);
                    if (vendInvoiceTrans.vatDeferred_IN != 0)
                    {
                        DefermentScheduleTransLines_IN::updateCredit(defermentSchedule, false, vendInvoiceTrans.vatDeferred_IN);
                    }
                }
            }
            else
            {
                // Normal PO with VAT deferred amount
                vendInvoiceTrans.vatDeferred_IN = vendInvoiceTrans.vatAmount_IN - vendInvoiceTrans.vatExpense_IN;
                if (vendInvoiceTrans.vatDeferred_IN > 0)
                {
                    DefermentScheduleTrans_IN::createDefermentScheduleTrans(vendInvoiceTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostEndDisc</Name>
				<Source><![CDATA[
    protected boolean canPostEndDisc()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostLedger</Name>
				<Source><![CDATA[
    protected boolean canPostLedger()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostRoundOff</Name>
				<Source><![CDATA[
    protected boolean canPostRoundOff()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostTax</Name>
				<Source><![CDATA[
    protected boolean canPostTax()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPostToInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether an invoice line can be inventory posted.
    /// </summary>
    /// <returns>
    /// true if the line can be inventory posted; otherwise, false.
    /// </returns>
    protected boolean canPostToInventory()
    {
        if (vendInvoiceInfoLine.isNonPO())
        {
            // Non-PO lines are non-inventory
            return false;
        }

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscountAmount</Name>
				<Source><![CDATA[
    protected AmountCur cashDiscountAmount()
    {
        return cashDiscountAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cashDiscPercent</Name>
				<Source><![CDATA[
    protected DiscPct cashDiscPercent()
    {
        return vendInvoiceJour.CashDiscPercent;
    }

]]></Source>
			</Method>
			<Method>
				<Name>beforeLinePost</Name>
				<Source><![CDATA[
    protected void beforeLinePost()
    {
        PurchQuantity           purchQuantity = PurchQuantity::construct(DocumentStatus::Invoice, false);
        VendInvoiceInfoLine     localVendInvoiceInfoLine;
        InventQty               unusedQty;
        
        super();
        
        if (this.parmPostingInBatch())
        {
            if (!vendInvoiceInfoLine.isNonPO())
            {
                vendInvoiceInfoLine.RemainBeforeInventPhysical = purchLine.RemainInventPhysical;
                
                if (vendInvoiceInfoLine.Closed == NoYes::No)
                {
                    [unusedQty, vendInvoiceInfoLine.RemainBeforeInvent, vendInvoiceInfoLine.RemainAfterInvent] = purchQuantity.qtyInvent(purchLine, PurchUpdate::ReceiveNow, vendInvoiceInfoLine.InventNow, purchParmUpdate.CreditRemaining);
                    [unusedQty, vendInvoiceInfoLine.RemainBefore, vendInvoiceInfoLine.RemainAfter]             = purchQuantity.qtyPurch(purchLine, PurchUpdate::ReceiveNow, vendInvoiceInfoLine.ReceiveNow, purchParmUpdate.CreditRemaining);
                    
                }
                
                update_recordSet localVendInvoiceInfoLine
                        setting RemainBeforeInventPhysical = vendInvoiceInfoLine.RemainBeforeInventPhysical,
                        RemainBeforeInvent = vendInvoiceInfoLine.RemainBeforeInvent,
                        RemainBefore = vendInvoiceInfoLine.RemainBefore,
                        RemainAfterInvent = vendInvoiceInfoLine.RemainAfterInvent,
                        RemainAfter = vendInvoiceInfoLine.RemainAfter
                            where localVendInvoiceInfoLine.RecId == vendInvoiceInfoLine.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBeforePostingLine</Name>
				<Source><![CDATA[
    protected void checkBeforePostingLine()
    {
        InventTransIdSum inventTransIdSum;
        PurchQty remainPurchQty;
        VendInvoiceInfoSubTable vendInvoiceInfoSubTable;
        PurchTable localPurchTable;
        AccountingEvent localAccountingEvent;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && vendInvoiceInfoLine.AgreementLine_PSN)
        {
            vendInvoiceInfoLine.validateAmountByAgreement();
        }

        if (PublicSectorUtils::isFrenchRegulatoryEnabled() && !this.checkPurchCommitmentBalance())
        {
            throw error("@PublicSector:PurchCommitmentLineOverConsumedError");
        }

        if (vendInvoiceInfoLine.BudgetReservationLine_PSN && PublicSectorUtils::isBudgetReservationEnabled())
        {
            this.checkBudgetReservationBalance();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            (InventTable::find(vendInvoiceInfoLine.ItemId).AssetGroupId_RU ||
             vendInvoiceInfoLine.ProcurementCategory && RAssetPurchTrans::exist(vendInvoiceInfoLine)))
        {
            if (! RAssetPurchTrans::checkBeforePost(vendInvoiceInfoLine))
                throw error("@SYS93289");
        }

        if (vendInvoiceInfoLine.isNonPO())
        {
            if (PublicSectorUtils::isFrenchRegulatoryEnabled())
            {
                if (PurchAgreementFinDimensionAccess_PSN::isFinDimensionAmountAuthorized(vendInvoiceInfoLine.AgreementLine_PSN, vendInvoiceInfoLine.SourceDocumentLine))
                {
                    return;
                }
            }
            else
            {
                return;
            }
        }
        if (vendInvoiceInfoLine.isAdvance())
        {
            if (!this.checkAvailablePrePayment())
            {
                throw error(strFmt("@SYS329364", vendInvoiceInfoTable.PurchId));
            }
            else if (vendInvoiceInfoLine.LineAmount == 0)
            {
                throw error("@AccountsPayable:ErrorMessageWhenVendorPrepaymentAmountIsInvalid");
            }

            return;
        }

        inventTransIdSum = InventTransIdSum::newTransOriginId(InventTransOriginPurchLine::findInventTransOriginId(purchLine.DataAreaId, purchLine.InventTransId));

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) &&
            TaxParameters::find().Customs_IN &&
            PurchTable::find(purchLine.PurchId).purchTable_W().CustomsImportOrder_IN == NoYes::Yes)
        {
            return;
        }
        else
        {
            if ((vendInvoiceInfoLine.RemainBefore != (purchLine.RemainPurchFinancial + purchLine.RemainPurchPhysical)) ||
                (vendInvoiceInfoLine.RemainBeforeInvent != purchLine.RemainInventPhysical + inventTransIdSum.physical()) ||
                (vendInvoiceInfoLine.RemainBeforeInventPhysical != purchLine.RemainInventPhysical) )
            {
                throw error("@SYS23025");
            }
        }

        remainPurchQty = purchLine.RemainPurchFinancial;

        if (!VendInvoiceInfoSubLine::existForLine(vendInvoiceInfoLine.RecId))
        {
            // Only let them invoice the full amount if they haven't matched any packing slips,
            //  otherwise they can only invoice what's been shipped (RemainPurchFinancial)
            remainPurchQty += purchLine.RemainPurchPhysical;
        }
        else if (abs(vendInvoiceInfoLine.purchQtyMatched()) < abs(vendInvoiceInfoLine.ReceiveNow))
        {
            // If they have matched any packing slips, they must match the full invoice quantity
            throw error("@SYS4001514");
        }

        vendInvoiceInfoSubTable = vendInvoiceInfoLine.vendInvoiceInfoSubTable();
        localPurchTable = purchLine.purchTable();
        localAccountingEvent = AccountingEvent::getLastEvent(localPurchTable.SourceDocumentHeader);

        if (vendInvoiceInfoSubTable.SourceAccountingEvent != localAccountingEvent.RecId)
        {
            vendInvoiceInfoTable.ErrorInvalidDistribution = NoYes::Yes;
            throw error("@SYS326999");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkAvailablePrePayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if sufficient pre payment balance is available.
    /// </summary>
    /// <returns>
    /// true if available pre payment amount for the purchase order is greated than <c>LineAmount</c> field on <c>VendInvoiceInfoLine</c> table; otherwise, false.
    /// </returns>
    protected boolean checkAvailablePrePayment()
    {
        return (PurchPrepayTable::findPurchId(vendInvoiceInfoTable.PurchId).PrepayAvailable >= purchTotals.purchTotalAmount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLineAfterPosting</Name>
				<Source><![CDATA[
    protected boolean checkLineAfterPosting()
    {
        boolean ok = true;
        InventTrans inventTrans;
        InventTransOriginPurchLine inventTransOriginPurchLine;
        RAssetPurchTrans rAssetPurchTrans;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            (purchLine && purchLine.isInvoiced() ||
             vendInvoiceInfoLine.isNonPO()))
        {
            if (vendInvoiceInfoLine.isNonPO())
            {
                select firstonly RecId from rAssetPurchTrans
                    where rAssetPurchTrans.TableRecId == vendInvoiceInfoLine.RecId &&
                          rAssetPurchTrans.TableTableId == vendInvoiceInfoLine.TableId &&
                          rAssetPurchTrans.Posted == NoYes::No &&
                          rAssetPurchTrans.ReceiveNow;
            }
            else
            {
                select firstonly RecId from rAssetPurchTrans
                    where rAssetPurchTrans.TableRecId == purchLine.RecId &&
                          rAssetPurchTrans.TableTableId == purchLine.TableId &&
                          rAssetPurchTrans.Posted == NoYes::No;
            }
            if (rAssetPurchTrans.RecId)
                return checkFailed("@GLS63382");
        }

        if (vendInvoiceInfoLine.isNonPO())
        {
            return true;
        }

        if (vendInvoiceInfoLine.isAdvance())
        {
            return true;
        }

        if (purchLine.RemainPurchFinancial == 0 && purchLine.RemainPurchPhysical == 0)
        {
            if (purchLine.isInvoiced())
            {
                var logger = InventInstrumentationLogger::createLogger('PurchInvoiceJournalPost');
                using (var activityContext = logger.purchInvoiceJournalPost().logMeasure(funcName()))
                {
                    ttsbegin;
                    while select forupdate inventTrans
                        where ((purchLine.PurchQty >= 0 && inventTrans.StatusReceipt >= StatusReceipt::Registered && inventTrans.StatusIssue == StatusIssue::None)
                             || (purchLine.PurchQty < 0 && inventTrans.StatusIssue >= StatusIssue::Picked && inventTrans.StatusReceipt == StatusReceipt::None))
                          exists join inventTransOriginPurchLine
                                where inventTransOriginPurchLine.InventTransOrigin == inventTrans.InventTransOrigin
                                   && inventTransOriginPurchLine.PurchLineDataAreaId == purchLine.DataAreaId
                                   && inventTransOriginPurchLine.PurchLineInventTransId == purchLine.InventTransId
                    {
                        logger.purchInvoiceJournalPost().logInventTrans(activityContext, inventTrans.RecId, inventTrans.InventTransOrigin);
                        inventTrans.delete(NoYes::No, NoYes::No);
                    }
                    ttscommit;
                }
            }

            select firstonly RecId from inventTrans
            where ((purchLine.PurchQty >= 0 && inventTrans.StatusReceipt != StatusReceipt::Purchased && inventTrans.StatusReceipt != StatusReceipt::None)
                || (purchLine.PurchQty < 0 && inventTrans.StatusIssue != StatusIssue::Sold && inventTrans.StatusIssue != StatusIssue::None))
            exists join inventTransOriginPurchLine
                where inventTransOriginPurchLine.InventTransOrigin == inventTrans.InventTransOrigin
                    && inventTransOriginPurchLine.PurchLineDataAreaId == purchLine.DataAreaId
                    && inventTransOriginPurchLine.PurchLineInventTransId == purchLine.InventTransId;

            if (inventTrans.RecId)
            {
                if (purchLine.PurchQty < 0)
                {
                    ok = checkFailed(strFmt("@SYS54028", StatusIssue::Sold));
                }
                else
                {
                    ok = checkFailed(strFmt("@SYS54028", StatusReceipt::Purchased));
                }

                ok = checkFailed("@SCM:PurchOrderAdjustInventoryQuantityAfterReceivingError");
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotStockedLineAfterPosting</Name>
				<Source><![CDATA[
    protected boolean checkNotStockedLineAfterPosting(TradeNotStockedPostCheck _notStockedPostCheck)
    {
        _notStockedPostCheck.parmQtyPhysicalToBeJournalUpdated(invoiceUpdatedOnly);

        return super(_notStockedPostCheck) 
            && _notStockedPostCheck.checkUpdateFinancialAfterPosting()
            && this.checkNotOverDeliveryForNotStockedWithMatchedPR(_notStockedPostCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPurchCommitmentBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the balance of the commitment referred to by the current invoice line.
    /// </summary>
    /// <returns>
    /// true if the balance check passes; otherwise, false.
    /// </returns>
    public boolean checkPurchCommitmentBalance()
    {
        if (PublicSectorUtils::isFrenchRegulatoryEnabled()
            && vendInvoiceInfoLine.PurchCommitmentLine_PSN != 0)
        {
            return PurchCommitmentLine_PSN::performBalanceCheck(vendInvoiceInfoLine.SourceDocumentLine);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultNonPOInventAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    /// The default <c>InventAccountType</c> for non purchase orders.
    /// </summary>
    /// <returns>
    /// An <c>InventAccountType</c>.
    /// </returns>
    protected InventAccountType defaultNonPOInventAccountType()
    {
        return InventAccountType::PurchExpense;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSourceLine</Name>
				<Source><![CDATA[
    protected void checkSourceLine()
    {
        #ISOCountryRegionCodes

        // Italian functionality of VAT books and VAT book sections
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
                && !(VendPrepaymentApplicationWithoutTaxGroup_IT_Flight::instance().isEnabled() && this is PurchAdvanceApplicationJournalPost)
                && !TaxGroupData::checkTaxGroups(vendInvoiceInfoLine.TaxGroup, vendInvoiceInfoLine.TaxItemGroup))
        {
            throw error("@SYS21533");
        }

        if (!this.checkTaxGroupsCompleteness())
        {
            throw error("@SYS21533");
        }

        if (vendInvoiceInfoLine.isNonPO())
        {
            // If the tax codes are to be verified, check if sales tax id and Item tax id
            // are defined per line. If the ledger account requires a tax code, and tax code
            // is not provided, the posting will be stopped.
            if (taxParameters.ValidateTaxCode)
            {
                postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(vendInvoiceInfoLine.accountItemLedgerDimension(this.defaultNonPOInventAccountType()));

                if (!Tax::checkNoTax(postingMainAccount,
                                     vendInvoiceInfoLine.TaxGroup,
                                     vendInvoiceInfoLine.TaxItemGroup))
                {
                    throw error("@SYS21533");
                }
            }

            // Additional checks are only for PO-based lines
            return;
        }

        // If the tax codes are to be verified, check if sales tax id and Item tax id
        // are defined per line. If the ledger account requires a tax code, and tax code
        // is not provided, the posting will be stopped.
        if (taxParameters.ValidateTaxCode)
        {
            if (InventPostingExtendParm_CN::checkExtendParmEnabled())
            {
                postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(
                    InventPosting::accountItemExtendParmFromParameter_CN(
                        this.buildAccountItemLedgerDimensionParameter(
                            InventAccountType::PurchReceipt,
                            null,
                            InventPostingExtendParm_CN::constructInventDim(purchLine.inventDim()).parmInventSiteId())));
            }
            else
            {
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
                {
                    postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(InventPosting::accountItemLedgerDimensionFromParameters(
                        this.buildAccountItemLedgerDimensionParameter(InventAccountType::PurchReceipt, purchLine.inventDim())));
                }
                else
                {
                    postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(InventPosting::accountItemLedgerDimensionFromParameters(
                        this.buildAccountItemLedgerDimensionParameter(InventAccountType::PurchReceipt)));
                }
                if (!Tax::checkNoTax(postingMainAccount,
                             purchLine.TaxGroup,
                             purchLine.TaxItemGroup))
                {
                    throw error("@SYS21533");
                }
                postingMainAccount = LedgerDimensionFacade::getMainAccountFromLedgerDimension(InventPosting::accountItemLedgerDimensionFromParameters(
                    this.buildAccountItemLedgerDimensionParameter(InventAccountType::PurchConsump)));
            }

            if (!Tax::checkNoTax(postingMainAccount,
                                 purchLine.TaxGroup,
                                 purchLine.TaxItemGroup))
            {
                throw error("@SYS21533");
            }
        }

        if (TaxParameters::isServiceTaxEnable_IN() && !this.validateProjTaxGroups_IN())
        {
            throw error("@SYS21533");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRoundingQuantity</Name>
				<Source><![CDATA[
    protected void checkRoundingQuantity()
    {
        PurchUnit baseUnit;

        if (vendInvoiceInfoLine.isNonPO())
        {
            baseUnit = vendInvoiceInfoLine.PurchUnit;
        }
        else
        {
            baseUnit = purchLine.PurchUnit;
        }

        if (baseUnit && !VendInvoiceUnitOfMeasureRounding::isRoundedQuantityBasedOnUnitOfMeasure(vendInvoiceInfoLine.ReceiveNow, baseUnit))
        {
            throw error(strFmt("@SYS19589", baseUnit));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTaxGroupsCompleteness</Name>
				<Source><![CDATA[
    protected boolean checkTaxGroupsCompleteness()
    {
        boolean ret = true;

        if (VendParameters::find().ValidateTaxGroupCompleteness)
        {
            ret = TaxGroupData::validateTaxGroupsCompleteness(vendInvoiceInfoLine.TaxGroup, vendInvoiceInfoLine.TaxItemGroup);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildAccountItemLedgerDimensionParameter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a parameter for searching an inventory posting account ledger dimension for an item.
    /// </summary>
    /// <param name = "_inventAccountType">An inventory account type.</param>
    /// <param name = "_inventDim">An inventory dimension.</param>
    /// <param name = "_siteRelation">An inventory site relation.</param>
    /// <returns>The built parameter instance.</returns>
    protected InventPostingAccountItemLedgerDimensionParameters buildAccountItemLedgerDimensionParameter(InventAccountType _inventAccountType, InventDim _inventDim = null, InventSiteRelation_CN _siteRelation = '')
    {
        return InventPostingAccountItemLedgerDimensionParameters::newFromPurchLine(
            purchLine,
            _inventAccountType,
            purchLine.inventTable().itemGroupId(),
            _inventDim,
            _siteRelation);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkVendInvoiceTrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns true if VendInvoiceTrans exist.
    /// </summary>
    /// <returns>
    /// The value of the <c>boolean</c> parameter.
    /// </returns>
    protected boolean checkVendInvoiceTrans_IN()
    {
        return VendInvoiceTrans::exist(purchLine.InventTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefCopy</Name>
				<Source><![CDATA[
    protected void docuRefCopy(Common _from, Common _to)
    {
        DocuRef fromDocuRef;
        DocuRef toDocuRef;

        while select forUpdate toDocuRef
            join fromDocuRef
            index RefIdx
            where fromDocuRef.RefCompanyId == _from.DataAreaId
                && fromDocuRef.RefTableId == _from.TableId
                && fromDocuRef.RefRecId == _from.RecId
                && toDocuRef.RefCompanyId == _to.DataAreaId
                && toDocuRef.RefTableId == _to.TableId
                && toDocuRef.RefRecId == _to.RecId
                && toDocuRef.Name == fromDocuRef.Name
                && toDocuRef.TypeId == fromDocuRef.TypeId
                && toDocuRef.ValueRecId == fromDocuRef.ValueRecId
        {
            if (fromDocuRef.Notes == toDocuRef.Notes)
            {
                toDocuRef.delete();
            }
        }

        super(_from, _to);
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDocuRefLine</Name>
				<Source><![CDATA[
    protected void copyDocuRefLine()
    {
        // Copy any attachments from the invoice line to the journal line
        this.docuRefCopy(vendInvoiceInfoLine, this.journalLine());

        if (!vendInvoiceInfoLine.isNonPO())
        {
            // Copy any attachments from the PO line to the journal line
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyDocuRefTable</Name>
				<Source><![CDATA[
    protected void copyDocuRefTable()
    {
        // Copy any attachments from the invoice to the journal
        this.docuRefCopy(vendInvoiceInfoTable, this.parmJournalTable());

        if (!vendInvoiceInfoTable.isNonPO())
        {
            // Copy any attachments from the PO to the journal
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendLedgerVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>LedgerVoucher</c> for posting customer and vendor transactions to.
    /// </summary>
    /// <returns>
    /// An instance of the <c>LedgerVoucher</c> that uses the same voucher number as the one used for the invoice posting.
    /// </returns>
    protected LedgerVoucher createCustVendLedgerVoucher()
    {
        LedgerVoucher custVendLedgerVoucher;
        LedgerVoucherObject custVendLedgerVoucherObject;
        LedgerVoucherObject invoiceLedgerVoucherObject;
        LedgerVoucherList ledgerVoucherList;

        custVendLedgerVoucher = LedgerVoucher::newLedgerPost(ledgerVoucher.parmDetailSummary(), ledgerVoucher.parmSysModuleDefault(), ledgerVoucher.parmVoucherSeriesCode());
        ledgerVoucherList = ledgerVoucher.getInternalCollection();

        if (ledgerVoucherList && ledgerVoucherList.find(ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), ledgerVoucher.lastPostingLayer()))
        {
            invoiceLedgerVoucherObject = ledgerVoucherList.item();
            custVendLedgerVoucherObject = this.createCustVendLedgerVoucherObject(invoiceLedgerVoucherObject);
            custVendLedgerVoucher.addVoucher(custVendLedgerVoucherObject);
        }
        else
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        return custVendLedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createCustVendLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the <c>LedgerVoucherObject</c> for posting customer and vendor transactions.
    /// </summary>
    /// <param name="_invoiceLedgerVoucherObject">
    /// The posted ledger voucher object used for invoice transaction.
    /// </param>
    /// <returns>
    /// An instance of the <c>LedgerVoucherObject</c> that uses the same voucher number as the one used for the invoice posting.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// An exception is thrown if the posted invoice ledger voucher object is null.
    /// </exception>
    protected LedgerVoucherObject createCustVendLedgerVoucherObject(ledgerVoucherObject _invoiceLedgerVoucherObject)
    {
        LedgerVoucherObject custVendLedgerVoucherObject;

        if (_invoiceLedgerVoucherObject == null)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        custVendLedgerVoucherObject = LedgerVoucherObject::newReference(_invoiceLedgerVoucherObject.parmVoucher(), _invoiceLedgerVoucherObject.parmAccountingDate());
        custVendLedgerVoucherObject.parmVoucherCheck(false);

        // AccountingDate and SubledgerVoucher are already set in ctor
        custVendLedgerVoucherObject.parmAcknowledgementDate(_invoiceLedgerVoucherObject.parmAcknowledgementDate());
        custVendLedgerVoucherObject.parmDocument(_invoiceLedgerVoucherObject.parmDocumentDate(), _invoiceLedgerVoucherObject.parmDocumentNumber());
        custVendLedgerVoucherObject.parmFiscalCalendarPeriod(_invoiceLedgerVoucherObject.parmFiscalCalendarPeriod());
        custVendLedgerVoucherObject.parmIsCorrectionDefault(_invoiceLedgerVoucherObject.parmIsCorrectionDefault());
        custVendLedgerVoucherObject.parmIsExplicitBudgetCheckRequired(_invoiceLedgerVoucherObject.parmIsExplicitBudgetCheckRequired());
        // <GIN>
        custVendLedgerVoucherObject.parmIsTaxWithholdParametersEnabled_IN(_invoiceLedgerVoucherObject.parmIsTaxWithholdParametersEnabled_IN());
        // </GIN>
        custVendLedgerVoucherObject.parmJournalCategory(_invoiceLedgerVoucherObject.parmJournalCategory());
        custVendLedgerVoucherObject.parmLedgerPostingJournal(_invoiceLedgerVoucherObject.parmLedgerPostingJournal());
        // <GCN>
        custVendLedgerVoucherObject.parmLedgerVoucherType_CN(_invoiceLedgerVoucherObject.parmLedgerVoucherType_CN());
        // </GCN>
        custVendLedgerVoucherObject.parmPaymentReferenceDefault(_invoiceLedgerVoucherObject.parmPaymentReferenceDefault());
        custVendLedgerVoucherObject.parmPostingLayer(_invoiceLedgerVoucherObject.parmPostingLayer());
        // <GSA>
        custVendLedgerVoucherObject.parmProjIdDefault_SA(_invoiceLedgerVoucherObject.parmProjIdDefault_SA());
        // </GSA>
        custVendLedgerVoucherObject.parmSkipPeriodStatusValidation(_invoiceLedgerVoucherObject.parmSkipPeriodStatusValidation());
        custVendLedgerVoucherObject.parmSkipPeriodTypeValidation(_invoiceLedgerVoucherObject.parmSkipPeriodTypeValidation());
        custVendLedgerVoucherObject.parmSourceRecIdDefault(_invoiceLedgerVoucherObject.parmSourceRecIdDefault());
        custVendLedgerVoucherObject.parmSourceTableIdDefault(_invoiceLedgerVoucherObject.parmSourceTableIdDefault());
        custVendLedgerVoucherObject.parmSubledgerVoucherDataAreaId(_invoiceLedgerVoucherObject.parmSubledgerVoucherDataAreaId());
        custVendLedgerVoucherObject.parmSysModule(_invoiceLedgerVoucherObject.parmSysModule());
        custVendLedgerVoucherObject.parmTrackTransactionAmountsByCurrency(_invoiceLedgerVoucherObject.parmTrackTransactionAmountsByCurrency());
        custVendLedgerVoucherObject.parmTransactionTypeDefault(_invoiceLedgerVoucherObject.parmTransactionTypeDefault());
        custVendLedgerVoucherObject.parmUseBalanceDifference(_invoiceLedgerVoucherObject.parmUseBalanceDifference());
        // <GCN>
        custVendLedgerVoucherObject.parmVoucher_CN(_invoiceLedgerVoucherObject.parmVoucher_CN());
        // </GCN>
        custVendLedgerVoucherObject.parmVoucherSeriesCode(_invoiceLedgerVoucherObject.parmVoucherSeriesCode());

        return custVendLedgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDeferredTaxTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create additional transactions for Hungarian Deferred Tax
    /// </summary>
    private void createDeferredTaxTransactions()
    {
        TaxUncommitted taxUncommitted;
        SourceDocumentLine sourceDocumentLine;
        List taxUncommittedHUList;
        boolean isContinuous = false;

        taxUncommittedHUList = new List(Types::Int64);

        ttsbegin;
        select firstonly RecId from taxUncommitted
            join sourceDocumentLine
                where sourceDocumentLine.RecId == taxUncommitted.SourceDocumentLine
                    && sourceDocumentLine.SourceDocumentHeader == vendInvoiceInfoTable.SourceDocumentHeader;

        if (!taxUncommitted.RecId)
        {
            TaxTrans taxTrans;
            while select forupdate taxTrans
                // The tax transaction for bank exchange rate is created during tax posting, which should be filtered out when processing deferred tax.
                where taxTrans.ExchRateDiffOrigRecId == 0
                join sourceDocumentLine
                where sourceDocumentLine.RecId == taxTrans.SourceDocumentLine
                    && sourceDocumentLine.SourceDocumentHeader == vendInvoiceInfoTable.SourceDocumentHeader
            {
                if (TaxContinuousHUHelper::isTransactionContinuousHU(taxTrans.TaxItemGroup))
                {
                    TaxUncommitted_HU::insertTaxUncommittedHU(sourceDocumentLine.RecId);
                    taxUncommittedHUList.addEnd(sourceDocumentLine.RecId);
                    // For hungarian deferred taxes, the tax has to be posted to a deferred tax account until the vat due date
                    // when it is reversed out of the deferred tax account and posted to the sales tax account
                    // The source document tax lines for which Hungarian Subscription is enabled is submitted to the Source Document
                    // Processor Facade for fully distributed state processing. The change in state from Completed to FullyDistributed
                    // causes the reversal on the VAT due date to occur
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(taxTrans, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                    isContinuous = true;
                }
            }
        }
        else
        {
            while select forupdate taxUncommitted
                join sourceDocumentLine
                where sourceDocumentLine.RecId == taxUncommitted.SourceDocumentLine
                    && sourceDocumentLine.SourceDocumentHeader == vendInvoiceInfoTable.SourceDocumentHeader
            {
                if (TaxContinuousHUHelper::isTransactionContinuousHU(taxUncommitted.TaxItemGroup))
                {
                    TaxUncommitted_HU::insertTaxUncommittedHU(sourceDocumentLine.RecId);
                    taxUncommittedHUList.addEnd(sourceDocumentLine.RecId);
                    // For hungarian deferred taxes, the tax has to be posted to a deferred tax account until the vat due date
                    // when it is reversed out of the deferred tax account and posted to the sales tax account
                    // The source document tax lines for which Hungarian Subscription is enabled is submitted to the Source Document
                    // Processor Facade for fully distributed state processing. The change in state from Completed to FullyDistributed
                    // causes the reversal on the VAT due date to occur
                    SourceDocumentProcessorFacade::submitSourceDocumentLineImplementation(taxUncommitted, false, SourceDocumentLineAccountingStatus::FullyDistributed);
                    isContinuous = true;
                }
            }
        }

        if (isContinuous)
        {
            GlobalizationInstrumentationHelper::featureRun(GlobalizationConstants::FeatureReferenceHU00008, funcName());

            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(vendInvoiceInfoTable, false, SourceDocumentAccountingStatus::Completed);
            TaxContinuousHUHelper::deleteTaxUncommittedHURecords(taxUncommittedHUList);
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDocuRef</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies attachments from source document to destination document.
    /// </summary>
    /// <param name="_vendTrans">
    /// A record representing destination document for attachements are copied.
    /// </param>
    private void createDocuRef(VendTrans _vendTrans)
    {
        VendInvoiceInfoLine vendInvoiceInfoLineDocCopy;
        DocuRef docuRef;

        this.docuRefCopy(vendInvoiceInfoTable, _vendTrans);
        if (!vendInvoiceInfoTable.isNonPO())
        {
            this.docuRefFindAndCopyMultiple(_vendTrans);
        }

        while select vendInvoiceInfoLineDocCopy
            where vendInvoiceInfoLineDocCopy.ParmId == vendInvoiceInfoTable.ParmId
                && vendInvoiceInfoLineDocCopy.TableRefId == vendInvoiceInfoTable.TableRefId
        exists join docuRef
            where docuRef.RefCompanyId == vendInvoiceInfoLineDocCopy.DataAreaId
                && docuRef.RefTableId == vendInvoiceInfoLineDocCopy.TableId
                && docuRef.RefRecId == vendInvoiceInfoLineDocCopy.RecId
        {
            this.docuRefCopy(vendInvoiceInfoLineDocCopy, _vendTrans);
        }

        recordInsertListDocuref.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFixedAsset</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a record in the <c>AssetTable</c> table.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    ///    A <c>VendInvoiceInfoLine</c> table buffer.
    /// </param>
    /// <param name="_vendInvoiceInfoLine_Asset">
    ///    A <c>VendInvoiceInfoLine_Asset</c> table buffer.
    /// </param>
    /// <returns>
    ///    The <c>AssetId</c> value from the created asset record.
    /// </returns>
    protected AssetId createFixedAsset(VendInvoiceInfoLine _vendInvoiceInfoLine, VendInvoiceInfoLine_Asset _vendInvoiceInfoLine_Asset)
    {
        AssetTable assetTable;
        NumberSequenceTable numberSequenceTable;
        AssetParameters assetParameters = AssetParameters::find();

        AssetGroup assetGroup;
        select firstonly AssetType, PropertyType, MajorType, Location, AutoNumberSequenceTable from assetGroup
            where assetGroup.GroupId == _vendInvoiceInfoLine_Asset.AssetGroup;

        // It is only possible create fixed assets when the number sequence is marked as continuous
        if (assetGroup.AutoNumberSequenceTable)
        {
            select firstonly Continuous from numberSequenceTable
                where numberSequenceTable.RecId == assetGroup.AutoNumberSequenceTable;
        }

        if (numberSequenceTable.Continuous == NoYes::No)
        {
            if (assetGroup.AutoNumberSequenceTable)
            {
                throw error("@SYS116327");
            }
            else
            {
                if (assetParameters.AutoNumber)
                {
                    NumberSequenceReference numberSequenceReference = AssetParameters::numRefAssetId();

                    select Continuous from numberSequenceTable where
                        numberSequenceTable.RecId == numberSequenceReference.NumberSequenceId;
                    if (numberSequenceTable.Continuous == NoYes::No)
                    {
                        throw error("@SYS116327");
                    }
                }
                else
                {
                    throw error("@SYS122736");
                }
            }
        }

        ttsbegin; //Save asset record.

        assetTable = this.createFixedAssetRecord(_vendInvoiceInfoLine, _vendInvoiceInfoLine_Asset, assetGroup, assetParameters);

        ttscommit;

        _vendInvoiceInfoLine_Asset.CreateFixedAsset = NoYes::No;
        _vendInvoiceInfoLine_Asset.AssetId = assetTable.AssetId;
        _vendInvoiceInfoLine_Asset.modifyAssetId();
        _vendInvoiceInfoLine_Asset.doUpdate();

        return assetTable.AssetId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createFixedAssetRecord</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Creates a record in the <c>AssetTable</c> table.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    ///    A <c>VendInvoiceInfoLine</c> table buffer.
    /// </param>
    /// <param name="_vendInvoiceInfoLine_Asset">
    ///    A <c>VendInvoiceInfoLine_Asset</c> table buffer.
    /// </param>
    /// <param name="_assetGroup">
    ///    A <c>AssetGroup</c> table buffer.
    /// </param>
    /// <param name="_assetParameters">
    ///    A <c>AssetParameters</c> table buffer.
    /// </param>
    /// <returns>
    ///    The <c>AssetTable</c> record that is created.
    /// </returns>
    protected AssetTable createFixedAssetRecord(VendInvoiceInfoLine _vendInvoiceInfoLine, VendInvoiceInfoLine_Asset _vendInvoiceInfoLine_Asset, AssetGroup _assetGroup, AssetParameters _assetParameters)
    {
        AssetTable assetTable;
        assetTable.selectForUpdate(true);
        assetTable.clear();
        assetTable.AssetGroup = _vendInvoiceInfoLine_Asset.AssetGroup;
        assetTable.Location = _assetGroup.Location;
        assetTable.AssetType = _assetGroup.AssetType;
        assetTable.PropertyType = _assetGroup.PropertyType;
        assetTable.MajorType = _assetGroup.MajorType;

        if (_vendInvoiceInfoLine.isNonPO())
        {
            if (_vendInvoiceInfoLine.ItemId)
            {
                assetTable.Name = _vendInvoiceInfoLine.itemName();
            }
            else if (_vendInvoiceInfoLine.ProcurementCategory)
            {
                assetTable.Name = EcoResCategory::find(_vendInvoiceInfoLine.ProcurementCategory).Name;
            }
        }
        else
        {
            assetTable.Name = _vendInvoiceInfoLine.purchLine().itemName();
            assetTable.PurchLineRecId = _vendInvoiceInfoLine.PurchLineRecId;
        }

        NumberSeq assetIdNumberSeq = assetTable.initAssetNumberSeq();
        if (assetIdNumberSeq)
        {
            assetTable.AssetId = assetIdNumberSeq.num();
            assetIdNumberSeq.used();
        }

        if (BrazilParameters::isEnabled())
        {
            assetTable.FiscalEstablishment_BR = _vendInvoiceInfoLine.inventDim().inventSite().fiscalEstablishment().RecId;
            assetTable.initFromAssetGroupId(assetTable.AssetGroup);
        }

        if (_assetParameters.BarcodeEqualsAssetNumber == NoYes::Yes)
        {
            assetTable.Barcode = assetTable.AssetId;
        }
        else
        {
            NumberSeq barcodeNumberSeq = assetTable.initBarcodeNumberSeq();
            if (barcodeNumberSeq)
            {
                assetTable.Barcode = barcodeNumberSeq.num();
                barcodeNumberSeq.used();
            }
        }

        assetTable.insert();

        if ((_assetParameters.ConsiderCapitalizationThreshold)
            && (_vendInvoiceInfoLine.LineAmount <= AssetGroup::find(assetTable.AssetGroup).CapitalizationThreshold))
        {
            AssetBook assetBook;
            update_recordset assetBook setting Depreciation = NoYes::No
                where assetBook.AssetId == assetTable.AssetId;
        }

        return assetTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNotStockedPostCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves a <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during
    /// posting.
    /// </summary>
    /// <returns>
    /// A <c>TradeNotStockedPostCheck</c> object that is used to verify order lines during posting.
    /// </returns>
    /// <remarks>
    /// Can return null if no verification should be performed.
    /// </remarks>
    protected TradeNotStockedPostCheck createNotStockedPostCheck()
    {
        if (vendInvoiceInfoLine.isNonPO() || vendInvoiceInfoLine.isAdvance())
        {
            return null;
        }

        return TradeNotStockedPostCheck::newPurchLine(purchLine, vendInvoiceTrans.Qty, vendInvoiceInfoLine.RemainAfter);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentDisbursement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the Payment disbursement calculations for the invoices only if the payment disbursement
    /// is defined; otherwise, default invoice creation.
    /// </summary>
    protected void createPaymentDisbursement()
    {
        int countPaymDisbursement;
        CustVendPaymentDisbursementCalc paymDisbursementCalc;

        // get count of payment disbursement transactions
        countPaymDisbursement = VendInvoiceInfo_PaymentDisbursement::getCountOfPurchPaymDisbursement(
                                    vendInvoiceInfoTable.ParmId,
                                    vendInvoiceInfoTable.TableRefId);

        if (countPaymDisbursement == 0)
            return;

        if (countPaymDisbursement != 0 && (!VendPaymentDisbursement::exist(vendInvoiceInfoTable.RecId)))
        {
            paymDisbursementCalc = CustVendPaymentDisbursementCalc::construct(vendInvoiceInfoTable);
            paymDisbursementCalc.initFromPurchTotals(purchTotals);
            paymDisbursementCalc.createTransaction(vendInvoiceJour);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentSched</Name>
				<Source><![CDATA[
    protected void createPaymentSched()
    {
        if (!purchTable.createVendTrans_BR())
        {
            return;
        }

        // When the payment schedule was opened on the invoice form then copy the
        // payment schedule from the invoice
        if (VendPaymSched::exist(vendInvoiceInfoTable.TableId, vendInvoiceInfoTable.RecId))
        {
            vendInvoiceInfoTable.copyPaymentSched(vendInvoiceJour);
        }
        else if (vendInvoiceInfoTable.PaymentSched || purchTable.PaymentSched)
        {
            VendPaymSched vendPaymSched;

            // If generated from a PO then find the payment schedule from the PO
            if (!vendInvoiceInfoTable.isNonPO())
            {
                vendPaymSched = VendPaymSched::find(purchTable.TableId, purchTable.RecId);
            }

            // If the PO has a payment schedule created and has the field CopyPreciselyToInvoice marked
            // then copy the payment schedule from the PO other wise recalculate the payment schedule
            if (vendPaymSched && vendPaymSched.CopyPreciselyToInvoice)
            {
                purchTable.copyPaymentSched(vendInvoiceJour);
            }
            else
            {
                vendInvoiceJour.createPaymentSchedule();
            }
        }

        // check that schedule amount matches invoice amount
        if (!vendInvoiceJour.validatePaymentSched())
            throw error("@SYS18447");
        
        if (CFMParameters::isModuleEnabled())
        {
            CFMPlannedPaymentCalc cfmPlannedPaymentCalc = CFMPlannedPaymentCalc::construct(purchTable);

            if (cfmPlannedPaymentCalc)
            {
                cfmPlannedPaymentCalc.calc();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createReportData</Name>
				<Source><![CDATA[
    public boolean createReportData(FormletterJournalPrint _formletterJournalPrint)
    {
        VendInvoiceDocumentContract vendInvoiceDocumentContract;
        VendInvoiceDocumentDP vendInvoiceDocumentDP;
        SRSTmpDataStore srsTmpDataStore;
        boolean purchTableAlreadyExists;
        VendPaymSched vendPaymSched;
        #ISOCountryRegionCodes
        
        // <GTE><GIN>
        TaxDocument             taxDocument;
        TaxDocumentExtension_IN taxDocumentExtension;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            taxDocument = TaxDocumentUtils::getTaxDocumentBySource(vendInvoiceJour.TableId, vendInvoiceJour.RecId);

            if (taxDocument)
            {
                taxDocumentExtension = taxDocumentExtension_in::findByTaxDocument(taxDocument.TaxDocumentGuid);
            }

            // When print GTE report, we will process printing proforma by another way.
            if (taxDocumentExtension.TaxInvReferenceType != GSTReference_IN::None)
            {
                return false;
            }
        }
        // </GTE></GIN>

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) || BrazilParameters::isEnabled())
        {
            //other reports are printed in this case. they do not support new way of printing proforma yet.
            return false;
        }

        // If we create a vendPaymSched on purchTable, clean it up now, skipping overridden delete method.
        // vendPaymSched on vendInvoiceJour is cleaned up by the calling method formLetterService.run()
        if ((this.isProforma() || this.isOnHold()) && (purchTable.PaymentSched || vendInvoiceInfoTable.PaymentSched))
        {
            purchTableAlreadyExists = VendPaymSched::exist(purchTable.TableId, purchTable.RecId);
            this.createPaymentSched();

            if (!purchTableAlreadyExists && VendPaymSched::exist(purchTable.TableId, purchTable.RecId))
            {
                ttsbegin;

                vendPaymSched = VendPaymSched::find(purchTable.TableId, purchTable.RecId, true);
                vendPaymSched.doDelete();

                ttscommit;
            }
        }

        vendInvoiceDocumentContract = new VendInvoiceDocumentContract();

        // Set PrintCopyOriginal value
        vendInvoiceDocumentContract.parmPrintCopyOriginal(PrintCopyOriginal::OriginalPrint);

        // Set Record Id
        vendInvoiceDocumentContract.parmRecordId(formletterJournal.RecId);

        if (_formletterJournalPrint)
        {
            // Pack the class and insert into the temporary store.
            srsTmpDataStore.Value = _formletterJournalPrint.pack();
            srsTmpDataStore.insert();

            // Set the rec id to contract parameter
            vendInvoiceDocumentContract.parmFormLetterRecordId(srsTmpDataStore.RecId);
        }

        vendInvoiceDocumentDP = new VendInvoiceDocumentDP();
        vendInvoiceDocumentDP.createData(vendInvoiceDocumentContract);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditDiscount</Name>
				<Source><![CDATA[
    protected boolean creditDiscount()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>creditNote</Name>
				<Source><![CDATA[
    protected NoYes creditNote()
    {
        NoYes creditNote;

        if (purchTotals.isCreditNote())
        {
            creditNote = NoYes::Yes;
        }
        else
        {
            creditNote = NoYes::No;
        }

        return creditNote;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currencyCode</Name>
				<Source><![CDATA[
    protected CurrencyCode currencyCode()
    {
        return vendInvoiceInfoTable.CurrencyCode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cwPreUpdateJournalLine_SetCW</Name>
				<Source><![CDATA[
    protected void cwPreUpdateJournalLine_SetCW()
    {
        vendInvoiceTrans.PdsCWQty = cwUpdateNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dealQualityOrderLine_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deals the quality order line.
    /// </summary>
    protected void dealQualityOrderLine_IN()
    {
        InventQualityOrderTable             inventQualityOrderTable;
        VendInvoiceTrans                    vendInvoiceTransLoc;
        
        inventQualityOrderTable = InventQualityOrderTable::findSalesPurchRefTransId_IN(purchLine.InventTransId, InventTestReferenceType::Purch);
        if (inventQualityOrderTable)
        {
            TaxEngineQualityOrder taxEngineQualityOrderPurch = TaxEngineQualityOrder_Purch::construct(inventQualityOrderTable, purchTable, purchLine);
            
            select firstOnly RecId from vendInvoiceTransLoc
                where vendInvoiceTransLoc.InventTransId == purchLine.InventTransId
                    && vendInvoiceTransLoc.RecId != vendInvoiceTrans.RecId;
            
            if (!vendInvoiceTransLoc.RecId && taxEngineQualityOrderPurch.shouldPostTax())
            {
                taxEngineQualityOrderPurch.postTax(ledgerVoucher, transactionTxt, taxDocumentLedgerVoucherMap);
            }
            else
            {
                if (TaxParameters::checkVatExciseParameters_IN()
                    && useQualityManagement
                    && purchLine.AssetId == ''
                    && InventQualityOrderTable::findSalesPurchRefTransId_IN(
                    purchLine.InventTransId,
                    InventTestReferenceType::Purch).ApplyIndiaTaxes_IN != ApplyIndiaTaxes_IN::None)
                {
                    this.postQualityOrderTaxes_IN(ledgerVoucher, transactionTxt);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultLedgerTransactionText</Name>
				<Source><![CDATA[
    protected LedgerTransTxt defaultLedgerTransactionText()
    {
        return (this.creditNote() ? LedgerTransTxt::PurchCreditNoteLedger : LedgerTransTxt::PurchInvoiceLedger);
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    protected DocumentStatus documentStatus()
    {
        return DocumentStatus::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>docuRefFindAndCopyMultiple</Name>
				<Source><![CDATA[
    protected void docuRefFindAndCopyMultiple(Common _to)
    {
        SetEnumerator se;

        se = ordersPosted.getEnumerator();

        while (se.moveNext())
        {
            this.docuRefCopy(PurchTable::find(se.current()), _to);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>logUnableSplitPost</Name>
				<Source><![CDATA[
    private boolean logUnableSplitPost(boolean needToLog, str unsupportedFuncName)
    {
        if (needToLog)
        {
            if (!sourceDocumentLineCount)
            {
                SourceDocumentLine localSourceDocumentLine;
                select count(RecId) from localSourceDocumentLine
                    where localSourceDocumentLine.SourceDocumentHeader == vendInvoiceInfoTable.SourceDocumentHeader;

                if (localSourceDocumentLine.RecId > 0)
                {
                    sourceDocumentLineCount = localSourceDocumentLine.RecId;
                }
                else    // Although there should not be such case where pending invoice has no sourceDocumentLine, add this case here for completeness
                {
                    return false;
                }
            }

            int sourceDocuementLineCountLogarithm = any2Int(log10(sourceDocumentLineCount));
            VendInvoiceLogarithmSize invoiceSize = sourceDocuementLineCountLogarithm <= VendInvoiceLogarithmSize::XL ?
                any2Enum(sourceDocuementLineCountLogarithm) :
                VendInvoiceLogarithmSize::XL;

            using (SysInstrumentationActivityContext activityContext = VendInstrumentation::getActivityContext(
                VendInvoicePostingConstants::InstrumentationNamespaceForUnableToSplitPost,
                classStr(PurchInvoiceJournalPost),
                funcName()))
            {
                activityContext.addCustomProperty(
                    VendInvoicePostingConstants::UnsupportedFunctionName,
                    unsupportedFuncName);
                activityContext.addCustomProperty(
                    VendInvoicePostingConstants::VendInvoiceSizeCategoryInSourceDocumentLine,
                    enum2Str(invoiceSize));
            }
        }
        return needToLog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceIncludeProjectPOLine</Name>
				<Source><![CDATA[
    private boolean isInvoiceIncludeProjectPOLine()
    {
        VendInvoiceInfoLine invoiceLine;
        VendInvoiceInfoLine_Project lineProject;
        PurchTable poFromProject;
        
        select firstonly RecId from invoiceLine
            where invoiceLine.ParmId == vendInvoiceInfoTable.ParmId 
                && invoiceLine.TableRefId == vendInvoiceInfoTable.TableRefId
            join poFromProject
                where poFromProject.PurchId == invoiceLine.OrigPurchId 
                    && poFromProject.ProjId != '';

        if (invoiceLine.RecId != 0)
        {
            return true;
        }

        invoiceLine.clear();
        select firstonly RecId from invoiceLine
            where invoiceLine.ParmId == vendInvoiceInfoTable.ParmId 
                && invoiceLine.TableRefId == vendInvoiceInfoTable.TableRefId
            join lineProject
                where invoiceLine.RecId == lineProject.VendInvoiceInfoLineRefRecId;

        return this.logUnableSplitPost((invoiceLine.RecId != 0), funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBudgetEnabled</Name>
				<Source><![CDATA[
    private boolean isBudgetEnabled()
    {
        return this.logUnableSplitPost(Ledger::isLedgerBudgetControlEnabled(), funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInvoiceWithPrepaymentApplication</Name>
				<Source><![CDATA[
    private boolean isInvoiceWithPrepaymentApplication()
    {
        return this.logUnableSplitPost(VendInvoiceInfoTable.hasPrepaymentApplicationLines(), funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPrepaymentInvoice</Name>
				<Source><![CDATA[
    private boolean isPrepaymentInvoice()
    {
        return this.logUnableSplitPost((vendInvoiceJour.InvoiceType == PurchInvoiceType::VendorAdvance), funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAutoSettlementNeededForPosting</Name>
				<Source><![CDATA[
    private boolean isAutoSettlementNeededForPosting()
    {
        boolean shouldSettleCashPayment = PaymTerm::isCashAccount(vendInvoiceJour.Payment);
        boolean isAutoSettlementEnabled = VendParameters::find().AutoSettle == NoYes::Yes;
        return this.logUnableSplitPost((shouldSettleCashPayment || isAutoSettlementEnabled), funcName());
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSplitPost</Name>
				<Source><![CDATA[
    private boolean canSplitPost()
    {
        // If any of the following conditions is true, we cannot split post.
        // To evaluate which factor blocks customers most, we need to evaluate all factors.
        boolean isAutoSettlementNeeded = !SourceDocumentDetermineDistributionFactorsForSettlementFlight::instance().isEnabled() 
            && this.isAutoSettlementNeededForPosting();
        boolean isInvoiceIncludeProjectPOLine = this.isInvoiceIncludeProjectPOLine();
        boolean isBudgetEnabled = this.isBudgetEnabled();
        boolean isInvoiceWithPrepaymentApplication = this.isInvoiceWithPrepaymentApplication();
        boolean isPrepaymentInvoice = this.isPrepaymentInvoice();

        return !(isAutoSettlementNeeded
                || isInvoiceIncludeProjectPOLine
                || isBudgetEnabled
                || isInvoiceWithPrepaymentApplication
                || isPrePaymentInvoice);
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLedgerVoucher</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void endLedgerVoucher()
    {
        PurchInvoiceJournalPostCaller caller;
        boolean skipAccountsFullyQualifiedValidation;

        if (!isPrePaymentJournalPost)
        {
            if (SourceDocumentCompletionRule::useSingleVoucher())
            {
                if (EnableEnhancedDelaySDAFJournalizerForSourceDocuments::isEnabled() 
                    && VendInvoiceSplitPostingFeature::isEnabled()
                        && this.canSplitPost())
                {
                    CostEventProcessor::process();
                    CostJournalizer::journalize(ledgerVoucher);

                    AccountingEventRecId accountingEventRecid = SourceDocumentAccountingEventForDelayedJournalizationProcessor::createAccountingEventForDelayedJournalizationOfSourceDocument
                    (
                        vendInvoiceInfoTable,
                        AccountingEventType::Original,
                        vendInvoiceInfoTable.DataAreaId
                    );

                    if (accountingEventRecid != 0)
                    {
                        LedgerVoucherObject ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(
                            ledgerVoucher.lastVoucher(), ledgerVoucher.lastTransDate(), CurrentOperationsTax::Current);

                        if (ledgerVoucherObject != null)
                        {
                            LedgerVoucherObject.parmAccountingEventRecId(accountingEventRecid);
                        }

                        ledgerVoucher.parmAccountingEventRecId(accountingEventRecid);
                        ledgerVoucher.end();
                    }
                    else
                    {
                        throw Error("@SYS21533");
                    }
                }
                else
                {
                    caller = this.createSourceDocumentProcessorCaller(ledgerVoucher);
                    const SourceDocumentLineImplementationList nullSourceDocumentLineList = null;
                
                    // Degrade to synchronous processing if we have already distributed amounts
                    boolean doAsynchronousLineTransition = !sourceDocumentLinesDistributed;
                    // degrade to async if invoice was initiated automated payment authorization
                    if (isExecutingPaymentAuthorizationTask)
                    {
                        doAsynchronousLineTransition = false;
                    }

                    skipAccountsFullyQualifiedValidation = this.parmSourceDocumentCompletionRule().doTransferToCompleteStateAccValidation(vendInvoiceInfoTable.SourceDocumentHeader);

                    // Transition document to completed with inventory voucher.
                    SourceDocumentProcessorFacade::submitSourceDocumentImplementation(
                        vendInvoiceInfoTable,
                        false,
                        SourceDocumentAccountingStatus::Completed,
                        caller,
                        curUserId(),
                        skipAccountsFullyQualifiedValidation,
                        nullSourceDocumentLineList,
                        doAsynchronousLineTransition);
                }

                if (this.requirePostCustVendAfterLedgerVoucherEnd())
                {
                    // Vendor transactions must be posted after the source document has transitioned to Completed state because automatic settlement for the vendor
                    // transaction needs the subledger journal account entries to create settlement voucher.
                    this.postCustVendPostLedgerVoucherEnd();

                    // Prepayment must be handled after the vendor transactions are posted.
                    this.updateSourcePrepayment();
                }

                if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
                {
                    this.postProjWipRevenue();
                }
            }
            else
            {
                CostEventProcessor::process();
                CostJournalizer::journalize(ledgerVoucher);

                super();
            }
        }
        else
        {
            super();
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.createTransLink_RU();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPost</Name>
				<Source><![CDATA[
    protected void endPost()
    {
        TableId tableId;
        VendInvoiceHoldHistory vendInvoiceHoldHistory;

        super();

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.bondBalanceToLog_RU();
        }
        VendInvoiceInfoMarkupMatchingTolerance::removeUnusedInvoiceMiscChargeCodes(vendInvoiceInfoTable);
        this.updateBankLC();

        if (PublicSectorUtils::isFrenchRegulatoryEnabled() && vendInvoiceJour.RecId)
        {
            tableId = tableNum(VendInvoiceJour);

            // Move the history to newly posted Invoice
            update_recordset vendInvoiceHoldHistory
            setting VendInvoiceJour_PSN = vendInvoiceJour.RecId,
                    RefTableId_PSN = tableId
            where vendInvoiceHoldHistory.VendInvoiceJour_PSN == vendInvoiceInfoTable.RecId
               && vendInvoiceHoldHistory.RefTableId_PSN == tableNum(VendInvoiceInfoTable);
        }

        if (leanConversionCostUpd)
        {
            leanConversionCostUpd.endLeanSubcontractingPosting();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLine</Name>
				<Source><![CDATA[
    protected void endPostLine()
    {
        inventMovement = null; //Ensures that the internal recordViewCache in inventMovement is deactivated again.

        if (!this.checkLineAfterPosting())
        {
            throw error("@SYS18738");
        }

        if (purchLine.RemainPurchPhysical != 0.0
            || purchLine.RemainInventPhysical != 0.0)
        {
            this.endPostLineUpdateRelatedLines();
        }

        this.interCompanyTransferBatchSerial(StatusIssue::Sold);
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPostLineUpdateRelatedLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates invoice lines related to the same purchase order line as the current invoice line.
    /// </summary>
    protected void endPostLineUpdateRelatedLines()
    {
        VendInvoiceInfoLine postedInvoiceLine = vendInvoiceInfoLine;
        VendInvoiceInfoLine relatedInvoiceLine;
        VendInvoiceInfoTable relatedInvoiceHeader;

        // For BOE Transaction the related Invoices need not be updated as they are already updated.
        if (TaxParameters::isCustomsEnable_IN()
            && vendInvoiceInfoLine.purchTable().purchTable_W().CustomsImportOrder_IN == NoYes::Yes)
        {
            return;
        }

        ttsbegin;

        while select forupdate relatedInvoiceLine
            exists join relatedInvoiceHeader
            where relatedInvoiceLine.TableRefId == relatedInvoiceHeader.TableRefId
            && relatedInvoiceHeader.ParmJobStatus == ParmJobStatus::Waiting
            && relatedInvoiceLine.InventTransId == purchLine.InventTransId
            && relatedInvoiceLine.RecId != postedInvoiceLine.RecId
        {
            // Update the related lines decrementing by the appropriate qty value for PO and Inventory
            relatedInvoiceLine.setQty(this.documentStatus(), purchParmUpdate.CreditRemaining);

            relatedInvoiceLine.doUpdate();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Ends the update of selected records.
    /// </summary>
    /// <remarks>
    /// The <c>endUpdate</c> method in the derived classes contains the code for ending the posting of the
    /// selected records posted by the derived <c>FormLetter</c> class. For example the <c>endUpdate</c>
    /// method in the <c>SalesFormLetter</c> class ends the update for the selected sales orders. The
    /// <c>endUpdate</c> method is added to the <c>FormLetter</c> class so that you can run the
    /// <c>endUpdate</c> method when you post in batch. The <c>endUpdate</c> method is called from the
    /// <c>run</c> method in the abstract classes derived from the <c>FormLetter</c> class, and from the
    /// <c>run</c> method in the <c>FormLetterEndMultiThread</c> class.
    /// </remarks>
    [HookableAttribute(true)]
    protected void endUpdate()
    {
        Num parmNum;

        super();

        this.interCompanyPost();

        if (updateSalesLines && updateSalesLinesQuery)
        {
            this.updateSalesTable(updateSalesLinesQuery);
        }

        if (this.isProforma() || this.isOnHold())
        {
            if (this.parmPrintFormLetter() || this.parmPrintEuVatInvoice()
                || this.parmPrintFacture()
                || this.parmPrintAcceptanceReport()
            )
            {
                // Print
                parmNum = vendInvoiceInfoTable.Num;
                // When printing proforma or on-hold always save invoice.
                vendInvoiceInfoTable.VendInvoiceSaveStatus = VendInvoiceSaveStatus::Pending;
                vendInvoiceInfoTable.Num = parmNum;
                this.moveFromActiveToSaved();
            }
            else
            {
                // Not posting or printing - save any pending documents
                if (vendInvoiceInfoTable.VendInvoiceSaveStatus == VendInvoiceSaveStatus::Pending)
                {
                    // Save draft invoice
                    this.moveFromActiveToSaved();
                }
            }
        }
        else
        {
            SubledgerJournalizerProjectExtension::processStocked(vendInvoiceInfoTable);
            if (vendInvoiceInfoTable.hasPrepaymentApplicationLines())
            {
                vendInvoiceInfoTable.updateProcessingAdvanced(NoYes::Yes);

                VendAdvanceInvoice_Application vendAdvanceInvoice_Application = VendAdvanceInvoice::construct(true);
                vendAdvanceInvoice_Application.parmCallerTable(vendInvoiceInfoTable);
                vendAdvanceInvoice_Application.parmVendInvoiceInfoTable(vendInvoiceInfoTable);
                vendAdvanceInvoice_Application.parmVendInvoiceJour(vendInvoiceJour);
                vendAdvanceInvoice_Application.parmIsInvoicePosted(false);
                VendAdvanceInvoice_Application.parmPurchTotals(this.parmTotals());
                vendAdvanceInvoice_Application.init();
                vendAdvanceInvoice_Application.processAdvances();

                vendInvoiceInfoTable.updateProcessingAdvanced(NoYes::No);
            }
        }

        TaxWorkRegulation::deleteTaxRegulation(vendInvoiceInfoTable.TableId, vendInvoiceInfoTable.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRate_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns exchange rate of vendor invoice.
    /// </summary>
    /// <returns>
    /// Returns exchange rate of vendor invoice.
    /// </returns>
    protected ExchRate exchRate_W()
    {
        return vendInvoiceJour.ExchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchRateSec_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns exchange rate of vendor invoice.
    /// </summary>
    /// <returns>
    /// Returns exchange rate of vendor invoice.
    /// </returns>
    protected ExchrateSecondary exchRateSec_W()
    {
        return vendInvoiceJour.ExchRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedEuroTriangulation</Name>
				<Source><![CDATA[
    protected UnknownNoYes fixedEuroTriangulation()
    {
        if (vendInvoiceInfoTable.FixedExchRate)
            return Currency::noYes2UnknownNoYes(vendInvoiceInfoTable.euroTriangulation);

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedExchRate</Name>
				<Source><![CDATA[
    protected VendExchRate fixedExchRate()
    {
        VendExchRate exchRate;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL, #isoIT]))
        {
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                return vendInvoiceInfoTable.ExchRate;
            }
            return super();
        }
        else
        {
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                exchRate = vendInvoiceInfoTable.ExchRate;
            }
            if (!exchRate && PurchParameters::find().DateOfExchRate_W != DateOfExchRate_W::PostingDate)
            {
                exchRate = vendInvoiceJour.ExchRate;
            }
            else
            {
                exchRate = super();
            }

            return exchRate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fixedExchRateSecondary</Name>
				<Source><![CDATA[
    protected ExchrateSecondary fixedExchRateSecondary()
    {
        VendExchRate exchRate;

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoCZ, #isoHU, #isoPL, #isoIT]))
        {
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                return vendInvoiceInfoTable.ExchRateSecondary;
            }
            return super();
        }
        else
        {
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                exchRate = vendInvoiceInfoTable.ExchRateSecondary;
            }

            if (!exchRate && PurchParameters::find().DateOfExchRate_W != DateOfExchRate_W::PostingDate)
            {
                exchRate = vendInvoiceJour.ExchRateSecondary;
            }
            else
            {
                exchRate = super();
            }

            return exchRate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reportingCurrencyFixedExchangeRate</Name>
				<Source><![CDATA[
    internal ReportingCurrencyExchRate reportingCurrencyFixedExchangeRate()
    {
        return vendInvoiceInfoTable.FixedExchRate == NoYes::Yes ? vendInvoiceInfoTable.ReportingCurrencyExchangeRate : super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerVoucherObject</Name>
				<Source><![CDATA[
    protected LedgerVoucherObject getLedgerVoucherObject()
    {
        boolean isCorrectionDefault;

        isCorrectionDefault = LedgerParameters::findByCompany(curext()).TransactionReversalCorrection && this.parmStorno();

        return LedgerVoucherObject::newVoucher(voucher,
                                               this.updateDate(),
                                               formletterProvider.postingModule(),
                                               formletterProvider.ledgerTransType(),
                                               isCorrectionDefault);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessUser</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the user performing the process.
    /// </summary>
    /// <returns>
    /// The user ID of the user performing the process.
    /// </returns>
    /// <remarks>
    /// Gets the user that submitted the batch job for posting; otherwise, gets the current user.
    /// </remarks>
    protected UserId getProcessUser()
    {
        UserId processUserId;

        if (this.parmChainFormletterContract())
        {
            processUserId = this.parmChainFormletterContract().parmBatchCreatedBy();
        }

        if (!processUserId)
        {
            processUserId = curUserId();
        }

        return processUserId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    protected Num getVoucher()
    {
        return vendInvoiceJour.LedgerVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasQualityOrder_IN</Name>
				<Source><![CDATA[
    protected boolean hasQualityOrder_IN()
    {
        InventQualityOrderTable inventQualityOrderTable;

        if (!purchTable.RecId)
        {
            return false;
        }

        inventQualityOrderTable = InventQualityOrderTable::findLastQualityOrder(InventTestReferenceType::Purch, purchTable.PurchId);

        if (inventQualityOrderTable.RecId)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    public void init()
    {
        purchParmUpdate = vendInvoiceInfoTable.purchParmUpdate();
        purchTable = vendInvoiceJour.purchTable();

        if (this.parmTotals())
        {
            purchTotals = this.parmTotals() as PurchTotals;
        }
        else
        {
            purchTotals = PurchTotals::newParmTable(vendInvoiceInfoTable, any2Enum(this.parmSpecQty()), vendInvoiceInfoTable.ParmId, this.parmSumOrderId(), this.documentStatus());
            purchTotals.calc(true);
        }

        this.tax(purchTotals.tax());

        if (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            this.parmStorno(vendInvoiceInfoTable.creditCorrection());
        }

        if (TaxWithholdParameters_IN::checkTaxParameters() &&
            (purchTable.vendTable_InvoiceAccount().TaxWithholdCalculate || (!purchTable && vendInvoiceInfoTable.vendTable_InvoiceAccount().TaxWithholdCalculate)))
        {
            this.taxWithholdCalculation_IN(purchTotals.taxWithholdCalculation_IN());
        }

        if (TaxParameters::canApplyCashDiscOnInvoice_ES())
        {
            cashDiscountAmount = purchTotals.cashDiscAmount();
        }

        super();

        taxParameters = TaxParameters::find();
        useQualityManagement = InventParameters::find().UseQualityManagement;
        onlyOneCashDiscOnInvoice = true;
        purchValueMap = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Real);
        updateSalesLinesQuery = new SysQueryRun(queryStr(SalesUpdate));

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            isCustomsImportOrder = purchTable.isCustomsImportOrder_IN();
        }

        lateMatchingPackingSlipsPerInvoiceLine = new Map(Types::Int64, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFormletterProvider</Name>
				<Source><![CDATA[
    protected void initFormletterProvider()
    {
        formletterProvider = FormletterProvider::newFormletterType(FormletterType::Purchase, purchTable);
        formletterProvider.parmParmTable(vendInvoiceInfoTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRelatedLineTables</Name>
				<Source><![CDATA[
    protected void initRelatedLineTables()
    {
        // <GIN>
        NoYes taxParameter = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]) && TaxParameters::checkTaxParameters_IN();
        // </GIN>
        TmpTaxWorkTrans tmpTaxWorkTrans;
        TaxOnItem taxOnItem;
        TaxType_IN taxType;

        RecId tmpTaxSourceRecId;
        super();

        purchLine = PurchLine::findInventTransId(vendInvoiceTrans.InventTransId);

        salesPurchLine = purchLine;

        vendInvoiceInfoLine = VendInvoiceInfoLine::findSourceDocumentLine(vendInvoiceTrans.SourceDocumentLine);

        discValue = vendInvoiceInfoLine.lineDiscExclTax(vendInvoiceJour.InvoiceDate);
        purchValue = vendInvoiceTrans.LineAmount;

        // <GIN>
        if (taxParameter
           && FormulaDesigner_IN::isPriceInclTaxOnLineAmount(purchLine.TaxItemGroup))
        {
            if (vendInvoiceInfoLine.RecId != 0)
            {
                purchValue = purchValue - PurchTotals_ParmTrans::getInclTaxAmountForPosting_IN(vendInvoiceInfoLine,this.tax());
            }
            else
            {
                purchValue = purchValue - PurchTotals_ParmTrans::getInclTaxAmountForPosting_IN(purchLine,this.tax());
            }
        }
        // </GIN>

        if (formletterProvider.lineDiscountLedgerDimension())
            purchValue += discValue; // discvalue is aleady subtracted from the value in invoicetrans

        tmpTax1099Amount = purchValue;

        // <GIN>
        if (taxParameter)
        {
            loadOnInventoryExisted = false;
            this.tax();
            tmpTaxWorkTrans = this.tax().tmpTaxWorkTrans();
            if (this.tax().sourceTableId() == tableNum(VendInvoiceInfoLine))
            {
                tmpTaxSourceRecId = vendInvoiceInfoLine.RecId;
            }
            else if (this.tax().sourceTableId() == tableNum(PurchLine))
            {
                tmpTaxSourceRecId = purchLine.RecId;
            }

            while select tmpTaxWorkTrans
                where tmpTaxWorkTrans.SourceRecId == tmpTaxSourceRecId
            {
                taxOnItem = TaxOnItem::find(tmpTaxWorkTrans.TaxItemGroup, tmpTaxWorkTrans.TaxCode);
                taxType = TaxTable::find(taxOnItem.TaxCode).TaxType_IN;

                if (taxType != TaxType_IN::None)
                {
                    if (!loadOnInventoryExisted
                        && taxOnItem.LoadOnInventory_IN)
                    {
                        loadOnInventoryExisted = true;
                    }
                }
            }
        }
        // </GIN>

        purchValue += this.tax().taxInCostPrice(vendInvoiceInfoLine.TableId, vendInvoiceInfoLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxt</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected TransactionTxt initTransactionTxt(LedgerTransTxt _ledgerTransTxt)
    {
        transactionTxt = TransactionTxt::construct();
        transactionTxt.setType (_ledgerTransTxt);
        transactionTxt.setVoucher (vendInvoiceJour.LedgerVoucher);
        transactionTxt.setFormLetter (vendInvoiceJour.InvoiceId);
        transactionTxt.setKey1 (vendInvoiceJour.PurchId);
        transactionTxt.setKey2 (vendInvoiceJour.InvoiceAccount);
        transactionTxt.setKey3 (VendTable::groupId(vendInvoiceJour.InvoiceAccount));

        if (TransactionTextContext::isTypeSupported(_ledgerTransTxt))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(_ledgerTransTxt);
            transactionTextContext.setTableBuffer(vendInvoiceJour);
            transactionTextContext.setTableBuffer(vendInvoiceJour.purchTable());
            transactionTxt.setTransactionTextContext(transactionTextContext);
        }
        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditInvoicingJour</Name>
				<Source><![CDATA[
    protected void insertCreditInvoicingJour(PurchTable _purchTable)
    {
        CustVendCreditInvoicingTable custVendCreditInvoicingTable;
        CustVendCreditInvoicingJour custVendCreditInvoicingJour;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL, #isoTH, #isoIT])
            || FeatureStateProvider::isFeatureEnabled(CreditInvoicingForVendorInvoicesFeature::instance()))
        {
            if (_purchTable)
            {
                custVendCreditInvoicingTable = CustVendCreditInvoicingTable::findRefId(_purchTable.TableId,
                                                                                       _purchTable.RecId,
                                                                                       true);
                if (custVendCreditInvoicingTable)
                {
                    custVendCreditInvoicingJour.insertFromCustVendCreditInvoicingTable(custVendCreditInvoicingTable,
                                                                                       vendInvoiceJour);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertCreditInvoicingTrans</Name>
				<Source><![CDATA[
    protected void insertCreditInvoicingTrans(PurchLine _purchLine)
    {
        CustVendCreditInvoicingLine custVendCreditInvoicingLine;
        CustVendCreditInvoicingTrans custVendCreditInvoicingTrans;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES, #isoSE, #isoPL]))
        {
            if (_purchLine)
            {
                custVendCreditInvoicingLine = CustVendCreditInvoicingLine::findRefId(_purchLine.TableId,
                                                                                     _purchLine.RecId,
                                                                                     true);
                if (custVendCreditInvoicingLine)
                {
                    custVendCreditInvoicingTrans.insertFromCustVendCreditInvoicingLine(custVendCreditInvoicingLine,
                                                                                       vendInvoiceTrans);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertMatchingSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a <c>VendInvoicePackingSlipQuantityMatch</c> table buffer and add the table buffer to the <c>RecordInsertList</c> for matching packing slips and invoices.
    /// </summary>
    /// <param name="_invoiceSourceDocumentLine">
    /// The <c>RecId</c> for the <c>SourceDocumentLine</c> relating to the invoice line.
    /// </param>
    /// <param name="_packingSlipSourceDocumentLine">
    /// The RecId for the <c>SourceDocumentLine</c> relating to the packing slip record being matched with the invoice line.
    /// </param>
    /// <param name="_purchQuantity">
    /// The purchase quantity for the invoice line that is being matched against the packing slip line.
    /// </param>
    /// <param name="_inventQuantity">
    /// The inventory quantity for the invoice line that is being matched against the packing slip line; optional.
    /// </param>
    /// <param name="_cwQuantity">
    /// The catch weight quantity for the invoice line that is being matched against the packing slip line; optional.
    /// </param>
    protected void insertMatchingSourceDocumentLine(SourceDocumentLineRecId _invoiceSourceDocumentLine,
                                                    SourceDocumentLineRecId _packingSlipSourceDocumentLine,
                                                    PurchQty _purchQuantity,
                                                    InventQty _inventQuantity = 0
                                                    , PdsCWInventQty _cwQuantity = 0
                                                    )
    {
        VendInvoicePackingSlipQuantityMatch vendInvoicePackingSlipQuantityMatch;

        vendInvoicePackingSlipQuantityMatch = VendInvoicePackingSlipQuantityMatch::find(_invoiceSourceDocumentLine, _packingSlipSourceDocumentLine, true);
        if (vendInvoicePackingSlipQuantityMatch.RecId == 0)
        {
            vendInvoicePackingSlipQuantityMatch.InvoiceSourceDocumentLIne = _invoiceSourceDocumentLine;
            vendInvoicePackingSlipQuantityMatch.PackingSlipSourceDocumentLine = _packingSlipSourceDocumentLine;
            vendInvoicePackingSlipQuantityMatch.Quantity = _purchQuantity;
            vendInvoicePackingSlipQuantityMatch.PdsCWQuantity = _cwQuantity;
            vendInvoicePackingSlipQuantityMatch.InventQuantity = _inventQuantity;
            vendInvoicePackingSlipQuantityMatch.insert();
        }
        else
        {
            vendInvoicePackingSlipQuantityMatch.Quantity += _purchQuantity;
            vendInvoicePackingSlipQuantityMatch.PdsCWQuantity += _cwQuantity;
            vendInvoicePackingSlipQuantityMatch.InventQuantity += _inventQuantity;
            vendInvoicePackingSlipQuantityMatch.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyPost</Name>
				<Source><![CDATA[
    protected void interCompanyPost()
    {
        RecordSortedList journalList;
        PurchInvoiceJournalPrint journalPrint;

        if (vendInvoiceJour.interCompanyDoInternalPosting()
        || (vendInvoiceJour.InterCompanyCompanyId && vendInvoiceJour.interCompanyDoExternalPosting()))
        {
            journalPrint = PurchInvoiceJournalPrint::construct();
            journalList = journalPrint.newJournalList();
            journalList.ins(vendInvoiceJour);

            if (InterCompanyPostStackOverflowPreventionFlight::instance().isEnabled())
            {
                InterCompanyPost::postContextQueue(
                    InterCompanyPostContractSales_Invoice::newFromJournal(this.parmChainFormletterContract(), vendInvoiceJour, journalList));
            }
            else
            {
                InterCompanyPostSales::post(this.parmChainFormletterContract(), vendInvoiceJour, journalList);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>interCompanyTransferBatchSerial</Name>
				<Source><![CDATA[
    protected void interCompanyTransferBatchSerial(StatusIssue _statusIssue = StatusIssue::OnOrder)
    {
        InterCompanyEndpointActionPolicyTransfer actionPolicyTransfer;
        SalesTable interCompanySalesTableOriginal;
        SalesTable interCompanySalesTable;

        if (purchLine
        && purchLine.InterCompanyInventTransId
        && purchLine.purchTable().isInterCompanyOrder())
        {
            if (vendInvoiceTrans.Qty < 0)
            {
                interCompanySalesTableOriginal = purchLine.purchTable().interCompanySalesTableOriginal();

                if (interCompanySalesTableOriginal.InterCompanyDirectDelivery)
                {
                    interCompanySalesTable = purchLine.purchTable().interCompanySalesTable();
                    actionPolicyTransfer = interCompanySalesTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
                    InterCompanyTransferInventDim::doTransferReturn(purchLine.purchTable().InterCompanyCompanyId,
                                                              purchLine.InterCompanyInventTransId,
                                                              purchLine.DataAreaId,
                                                              purchLine.InventTransId,
                                                              actionPolicyTransfer,
                                                              StatusReceipt::Purchased);
                }
                else
                {
                    actionPolicyTransfer = purchLine.purchTable().interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
                    InterCompanyTransferInventDim::doTransfer(purchLine.DataAreaId,
                                                                purchLine.InventTransId,
                                                                purchLine.purchTable().InterCompanyCompanyId,
                                                                purchLine.InterCompanyInventTransId,
                                                                actionPolicyTransfer,
                                                                _statusIssue,
                                                              vendInvoiceInfoTable.Num);
                }
            }
            else if (vendInvoiceTrans.Qty > 0 && purchLine.OverDeliveryPct > 0 && vendInvoiceTrans.Qty > vendInvoiceInfoLine.RemainBefore)
            {
                interCompanySalesTableOriginal = purchLine.purchTable().interCompanySalesTableOriginal();

                if (interCompanySalesTableOriginal.InterCompanyDirectDelivery)
                {
                    interCompanySalesTable = purchLine.purchTable().interCompanySalesTable();
                    actionPolicyTransfer = interCompanySalesTable.interCompanyEndpointActionPolicy().getOrCreateInterCompanyPolicyTransfer(InterCompanyFieldTransferType::External);
                    InterCompanyTransferInventDim::doTransfer(purchLine.purchTable().InterCompanyCompanyId,
                                                              purchLine.InterCompanyInventTransId,
                                                              purchLine.DataAreaId,
                                                              purchLine.InventTransId,
                                                              actionPolicyTransfer,
                                                              _statusIssue,
                                                              vendInvoiceInfoTable.Num,
                                                              false,
                                                              false,
                                                              true);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventReportDimHistoryLogType</Name>
				<Source><![CDATA[
    protected InventReportDimHistoryLogType inventReportDimHistoryLogType()
    {
        return InventReportDimHistoryLogType::PurchInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invoiceDate</Name>
				<Source><![CDATA[
    protected TransDate invoiceDate()
    {
        return this.updateDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOnHold</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines, whether journal is on hold.
    /// </summary>
    /// <returns>
    /// true if journal is on hold; otherwise, false.
    /// </returns>
    public boolean isOnHold()
    {
        return vendInvoiceInfoTable.Hold == NoYes::Yes;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLine</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected Common journalLine(Common _journalLine = vendInvoiceTrans)
    {
        vendInvoiceTrans = _journalLine as VendInvoiceTrans;
        return vendInvoiceTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>journalLineTableId</Name>
				<Source><![CDATA[
    protected TableId journalLineTableId()
    {
        return tableNum(VendInvoiceTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isThreeWayMatchEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a line has matching policy of three-way matching.
    /// </summary>
    /// <param name = "_vendInvoiceInfoLine">
    /// A <c>VendInvoiceInfoLine</c> record.
    /// </param>
    /// <param name = "_purchLine">
    /// A <c>PurchLine</c> record.
    /// </param>
    /// <returns>
    /// true if a line has matching policy of three-way matching; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Additional parameters provided for extensibility.
    /// </remarks>
    protected boolean isThreeWayMatchEnabled(VendInvoiceInfoLine _vendInvoiceInfoLine, PurchLine _purchLine)
    {
        return _purchLine.isThreeWayMatchEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLateMatchPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>VendInvoiceInfoLine</c> line is non-PO or an advance application.
    /// </summary>
    /// <param name = "_vendInvoiceInfoLine">
    /// An invoice line that is not matched to any product receipt lines.
    /// </param>
    /// <returns>
    /// true if all the criteria are met; otherwise, false.
    /// </returns>
    protected boolean skipLateMatchPackingSlip(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        return (_vendInvoiceInfoLine.ReceiveNow == 0.0
            || _vendInvoiceInfoLine.isNonPO()
            || _vendInvoiceInfoLine.isAdvance()
            || _vendInvoiceInfoLine.isAdvanceApplication()
            || _vendInvoiceInfoLine.isReverseAdvanceApplication());
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateMatchPackingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    /// Match the given invoice line to available product receipt lines.
    /// </summary>
    /// <param name = "_vendInvoiceInfoLine">
    /// An invoice line that is not matched to any product receipt lines.
    /// </param>
    protected void lateMatchPackingSlip(VendInvoiceInfoLine _vendInvoiceInfoLine)
    {
        int sign;
        PurchQty remainPurchFinancial;
        InventQty remainInventoryFinancial;
        PurchQty purchQuantityToMatch;
        PurchQty purchQuantityMatched;
        InventQty inventoryQuantityToMatch;
        InventQty nominalInventQty;
        InventQty delta;
        VendPackingSlipTrans vendPackingSlipTrans;
        List matchedPackingSlips; // matched packing slip records in sequence

        if (this.skipLateMatchPackingSlip(_vendInvoiceInfoLine))
        {
            return;
        }

        PurchLine localPurchLine = _vendInvoiceInfoLine.purchLine();

        if (this.isThreeWayMatchEnabled(_vendInvoiceInfoLine, localPurchLine))

        {
            throw error(strFmt("@AccountsPayable:ThreewayLineNoProductReceipt", localPurchLine.ItemId));
        }

        matchedPackingSlips = new List(Types::Record);

        // Are there more vendPackingSlipTrans that could be matched?
        sign = _vendInvoiceInfoLine.ReceiveNow > 0 ? 1 : -1;
        
        using (var activityContext = instrumentationLogger.purchFormLetterInstrumentationActivities().lateMatchPackingSlip())
        {
            activityContext.addCustomProperty(PurchPurchaseOrderInstrumentationActivities::VendInvoicePurchQty, any2Str(_vendInvoiceInfoLine.ReceiveNow));
            activityContext.addCustomProperty(PurchPurchaseOrderInstrumentationActivities::InventTransId, any2Str(_vendInvoiceInfoLine.InventTransId));

            while select forupdate vendPackingSlipTrans
                order by vendPackingSlipTrans.PackingSlipId, vendPackingSlipTrans.DeliveryDate asc
                where vendPackingSlipTrans.InventTransId == _vendInvoiceInfoLine.InventTransId
                    && vendPackingSlipTrans.FullyMatched == NoYes::No
                    && vendPackingSlipTrans.Qty * _vendInvoiceInfoLine.ReceiveNow > 0.0
            {
                matchedPackingSlips.addEnd(vendPackingSlipTrans);

                remainPurchFinancial = vendPackingSlipTrans.remainPurchFinancial();
                remainInventoryFinancial = vendPackingSlipTrans.remainInventFinancial();

                if (remainInventoryFinancial)
                {
                    nominalInventQty = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_vendInvoiceInfoLine.ItemId,
                                                                                                                _vendInvoiceInfoLine.InventDimId,
                                                                                                                remainPurchFinancial,
                                                                                                                localPurchLine.PurchUnit,
                                                                                                                _vendInvoiceInfoLine.inventTable().inventUnitId(),
                                                                                                                NoYes::Yes);

                    delta = remainInventoryFinancial - nominalInventQty;
                }

                purchQuantityToMatch = sign * min(abs(remainPurchFinancial), abs(_vendInvoiceInfoLine.ReceiveNow) - purchQuantityMatched);
                purchQuantityMatched += abs(purchQuantityToMatch);

                if (localPurchLine.isStocked())
                {
                    inventoryQuantityToMatch = EcoResProductUnitConverter::convertGivenUnitSymbolsForReleasedProduct(_vendInvoiceInfoLine.ItemId,
                                                                                                                        _vendInvoiceInfoLine.InventDimId,
                                                                                                                        purchQuantityToMatch,
                                                                                                                        localPurchLine.PurchUnit,
                                                                                                                        _vendInvoiceInfoLine.inventTable().inventUnitId(),
                                                                                                                        NoYes::Yes);

                    inventoryQuantityToMatch = inventoryQuantityToMatch + delta;
                }

                if (purchQuantityToMatch == 0 && (!_vendInvoiceInfoLine.isNonPO() && inventoryQuantityToMatch == 0))
                {
                    continue;
                }

                this.matchPackingSlipTransSourceDocumentLine(
                    _vendInvoiceInfoLine,
                    vendPackingSlipTrans,
                    purchQuantityToMatch,
                    inventoryQuantityToMatch,
                    PdsCatchWeight::cwQty(_vendInvoiceInfoLine.ItemId, inventoryQuantityToMatch),
                    _vendInvoiceInfoLine.ParmId);

                if (purchQuantityMatched == abs(_vendInvoiceInfoLine.ReceiveNow))
                {
                    break;
                }
            }
        }

        lateMatchingPackingSlipsPerInvoiceLine.insert(_vendInvoiceInfoLine.RecId, matchedPackingSlips);
    }

]]></Source>
			</Method>
			<Method>
				<Name>lateMatchPackingSlips</Name>
				<Source><![CDATA[
    private void lateMatchPackingSlips(VendInvoiceInfoTable _vendInvoiceInfoTable)
    {
        VendInvoiceInfoLine vendInvoiceInfoLineLocal;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;

        if (_vendInvoiceInfoTable.ProcessingAdvanced)
        {
            return;
        }

        while select vendInvoiceInfoLineLocal
            where vendInvoiceInfoLineLocal.ParmId == _vendInvoiceInfoTable.ParmId &&
                vendInvoiceInfoLineLocal.TableRefId == _vendInvoiceInfoTable.TableRefId
        notexists join vendInvoiceInfoSubLine
            where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLineLocal.RecId
        {
            this.lateMatchPackingSlip(vendInvoiceInfoLineLocal);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerVoucherObjectDocument</Name>
				<Source><![CDATA[
    protected container ledgerVoucherObjectDocument(LedgerVoucherObject _ledgerVoucherObject)
    {
        return vendInvoiceJour.DocumentDate ? [vendInvoiceJour.DocumentDate] : [vendInvoiceJour.InvoiceDate, vendInvoiceJour.InvoiceId];
    }

]]></Source>
			</Method>
			<Method>
				<Name>lineDiscountAmount</Name>
				<Source><![CDATA[
    protected AmountCur lineDiscountAmount(AmountCur _lineDiscount = discValue)
    {
        discValue = _lineDiscount;
        return discValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchInvoicePackingSlipNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Matches packing slip lines and invoice lines for not stocked purchase order lines.
    /// </summary>
    protected void matchInvoicePackingSlipNotStocked()
    {
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendPackingSlipTrans vendPackingSlipTrans;

        if (vendInvoiceInfoLine.isNonPO())
        {
            return;
        }

        if (VendBOEInvoiceCreateMatchPackingSlipTrans_INFlight::instance().isEnabled())
        {
            while select vendInvoiceInfoSubLine
                where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
                    && vendInvoiceInfoSubLine.JournalRefRecId != 0
                    && vendInvoiceInfoSubLine.JournalRefTableId != 0
            {
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                    && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(CustomsVendBOETrans_IN))
                {
                    CustomsVendBOETrans_IN customsVendBOETrans_IN;
                    CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink_IN;

                    select firstonly forupdate vendPackingSlipTrans
                        join RecId from customsVendPackingSlipBOETransLink_IN
                            where customsVendPackingSlipBOETransLink_IN.VendPackingSlipTrans == vendPackingSlipTrans.RecId
                                && vendPackingSlipTrans.FullyMatched == NoYes::No
                        join RecId from customsVendBOETrans_IN
                            where customsVendBOETrans_IN.RecId == customsVendPackingSlipBOETransLink_IN.CustomsVendBOETrans_IN
                                && customsVendBOETrans_IN.RecId == vendInvoiceInfoSubLine.JournalRefRecId;
                }
                else if (vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans))
                {
                    select firstonly forupdate vendPackingSlipTrans
                        where vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId
                            && vendPackingSlipTrans.FullyMatched == NoYes::No;
                }

                ttsbegin;
                this.matchPackingSlipTransSourceDocumentLine(vendInvoiceInfoLine, vendPackingSlipTrans, vendInvoiceInfoSubLine.ReceiveNow);
                ttscommit;
            }
        }
        else
        {
            while select vendInvoiceInfoSubLine
                where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
                    && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans)
                join forupdate vendPackingSlipTrans
                    where vendPackingSlipTrans.RecId == vendInvoiceInfoSubLine.JournalRefRecId
            {
                ttsbegin;
                this.matchPackingSlipTransSourceDocumentLine(vendInvoiceInfoLine, vendPackingSlipTrans, vendInvoiceInfoSubLine.ReceiveNow);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>matchPackingSlipTransSourceDocumentLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Matches a packing slip line against the invoice line being posted and updates packing slip line to fully matched if the packing slip line is fully invoice updated.
    /// </summary>
    /// <param name="_vendInvoiceInfoLine">
    /// The <c>VendInvoiceInfoLine</c> record being posted.
    /// </param>
    /// <param name="_vendPackingSlipTrans">
    /// The <c>VendPackingSlipTrans</c> record being matched against the invoice line being posted.
    /// </param>
    /// <param name="_purchQuantity">
    /// The purchase quantity for the invoice line that is being matched against the packing slip line.
    /// </param>
    /// <param name="_inventQuantity">
    /// The inventory quantity for the invoice line that is being matched against the packing slip line; optional.
    /// </param>
    /// <param name="_cwQuantity">
    /// The catch weight quantity for the invoice line that is being matched against the packing slip line; optional.
    /// </param>
    /// <param name="_excludeParmId">
    /// A <c>ParmId</c> value that indicates records that will be left out of the calculation; optional.
    /// </param>
    protected void matchPackingSlipTransSourceDocumentLine(
        VendInvoiceInfoLine _vendInvoiceInfoLine,
        VendPackingSlipTrans _vendPackingSlipTrans,
        PurchQty _purchQuantity,
        InventQty _inventQuantity = 0.0,
        PdsCWInventQty _cwQuantity = 0,
        ParmId _excludeParmId = '')
    {
        if (_vendInvoiceInfoLine.isNonPO())
        {
            return;
        }

        // If the current invoice quantity is for the remaining packing slip quantity, mark the packing slip as fully matched
        if (_vendPackingSlipTrans.remainPurchFinancialPosted() == _purchQuantity)
        {
            _vendPackingSlipTrans.FullyMatched = NoYes::Yes;
            _vendPackingSlipTrans.update();
        }

        if (VendInvoicePackingSlipQuantityMatchTelemetryFlight::instance().isEnabled())
        {
            var logger = SysInstrumentationLoggerFactory::CreateLogger('PurchInvoiceJournalPost::matchPackingSlipTransSourceDocumentLine');
            
            SysInstrumentationEventDataJsonSerializer logInformationSerializer = new SysInstrumentationEventDataJsonSerializer();
            logInformationSerializer.setValue(PurchPurchaseOrderInstrumentationActivities::VendInvoiceSourceDocumentLine, any2Str(_vendInvoiceInfoLine.SourceDocumentLine));
            logInformationSerializer.setValue(PurchPurchaseOrderInstrumentationActivities::VendPackingSourceDocumentLine, any2Str(_vendPackingSlipTrans.SourceDocumentLine));
            logInformationSerializer.setValue(PurchPurchaseOrderInstrumentationActivities::RemainingReceiptQty, any2Str(_vendPackingSlipTrans.remainPurchFinancialPosted()));
            logInformationSerializer.setValue(PurchPurchaseOrderInstrumentationActivities::VendInvoicePurchQty, any2Str(_purchQuantity));
            logInformationSerializer.setValue(PurchPurchaseOrderInstrumentationActivities::VendInvoiceInventQty, any2Str(_inventQuantity));
            logInformationSerializer.setValue(PurchPurchaseOrderInstrumentationActivities::FullyMatched, enum2Str(_vendPackingSlipTrans.FullyMatched));
            logger.logInformation(logInformationSerializer.toString());
        }

        this.insertMatchingSourceDocumentLine(_vendInvoiceInfoLine.SourceDocumentLine,
                                              _vendPackingSlipTrans.SourceDocumentLine,
                                              _purchQuantity,
                                              _inventQuantity,
                                              _cwQuantity
                                              );
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveFromActiveToSaved</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs the deep copy of the active invoice and performs budget processing.
    /// </summary>
    protected void moveFromActiveToSaved()
    {
        VendInvoiceInfoTable::moveFromActiveToSaved(vendInvoiceInfoTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventoryFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the specified inventory transaction must be updated.
    /// </summary>
    /// <param name = "_inventUpd_Financial">The inventory transaction to update.</param>
    /// <returns>true if the specified inventory transaction must be updated; otherwise, false.</returns>
    protected boolean mustUpdateInventoryFinancial(InventUpd_Financial _inventUpd_Financial)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmJournalTable</Name>
				<Source><![CDATA[
    public Common parmJournalTable(Common _journalTable = vendInvoiceJour)
    {
        vendInvoiceJour = _journalTable as VendInvoiceJour;

        return vendInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLeanCostingFacade</Name>
				<Source><![CDATA[
    public LeanCostingFacadeBase parmLeanCostingFacade(LeanCostingFacadeBase _leanCostingFacade = leanCostingFacade)
    {
        leanCostingFacade = _leanCostingFacade;

        return leanCostingFacade;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmParmTable</Name>
				<Source><![CDATA[
    public Common parmParmTable(Common _parmTable = vendInvoiceInfoTable)
    {
        vendInvoiceInfoTable = _parmTable;

        return vendInvoiceInfoTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintAcceptanceReport</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>printAcceptanceReport</c> parameter.
    /// </summary>
    /// <param name="_printAcceptanceReport">
    /// The value to set.
    /// </param>
    /// <returns>
    /// The value of the <c>printAcceptanceReport</c> parameter.
    /// </returns>
    public NoYes parmPrintAcceptanceReport(NoYes _printAcceptanceReport = printAcceptanceReport)
    {
        printAcceptanceReport = _printAcceptanceReport;
        return printAcceptanceReport;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintEuVatInvoice</Name>
				<Source><![CDATA[
    public NoYes parmPrintEuVatInvoice(NoYes _printEuVatInvoice = printEuVatInvoice)
    {
        printEuVatInvoice = _printEuVatInvoice;
        return printEuVatInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintFacture</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>printFacture</c> parameter.
    /// </summary>
    /// <param name="_printFacture">
    /// The value to set.
    /// </param>
    /// <returns>
    /// The value of the <c>printFacture</c> parameter.
    /// </returns>
    public NoYes parmPrintFacture(NoYes _printFacture = printFacture)
    {
        printFacture = _printFacture;
        return printFacture;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrintSalesFormLetter</Name>
				<Source><![CDATA[
    public NoYes parmPrintSalesFormLetter(NoYes _printSalesFormLetter = printSalesFormLetter)
    {
        printSalesFormLetter = _printSalesFormLetter;
        return printSalesFormLetter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPurchParmUpdate</Name>
				<Source><![CDATA[
    public PurchParmUpdate parmPurchParmUpdate(Common _purchParmUpdate = purchParmUpdate)
    {
        purchParmUpdate = _purchParmUpdate;

        return purchParmUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveChanges</Name>
				<Source><![CDATA[
    public boolean parmSaveChanges(boolean _saveChanges = saveChanges)
    {
        saveChanges = _saveChanges;
        return saveChanges;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSourceDocumentCompletionRule</Name>
				<Source><![CDATA[
    private SourceDocumentCompletionRule parmSourceDocumentCompletionRule(SourceDocumentCompletionRule _sourceDocumentCompletionRule = sourceDocumentCompletionRule)
    {
        sourceDocumentCompletionRule = _sourceDocumentCompletionRule;

        if (!sourceDocumentCompletionRule)
        {
            sourceDocumentCompletionRule = SourceDocumentCompletionRule::construct();
        }

        return sourceDocumentCompletionRule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxableDocumentDescriptor</Name>
				<Source><![CDATA[
    public TaxableDocumentDescriptor parmTaxableDocumentDescriptor()
    {
        return TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(vendInvoiceJour);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExecutingPaymentAuthorizationTask</Name>
				<Source><![CDATA[
    internal boolean parmExecutingPaymentAuthorizationTask(boolean _isExecutingPaymentAuthorizationTask = isExecutingPaymentAuthorizationTask)
    {
        isExecutingPaymentAuthorizationTask = _isExecutingPaymentAuthorizationTask;
        return isExecutingPaymentAuthorizationTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsSplitToSublines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Splits the <c>VendInvoiceInfoLine</c> to separate batches to assign actual calculated prices to each.
    /// </summary>
    /// <param name="_purchLine">
    /// The purchase order line.
    /// </param>
    /// <param name="_infoLine">
    /// The vendor invoice information line to split.
    /// </param>
    /// <returns>
    /// A list of <see cref="PDSPurchInvoiceLineSplit"/> objects, one for each batch associated with <paramref name="_infoLine"/>.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Thrown if there are any advanced pricing errors.
    /// </exception>
    private List pdsSplitToSublines(PurchLine _purchLine, VendInvoiceInfoLine _infoLine)
    {
        List lines = new List(Types::Class);

        InventTransOrigin inventTransOrigin;
        InventTrans inventTrans;
        InventDim inventDim;

        PDSAdvancedPricing advancedPricing;
        Price price;

        if (!_purchLine.pdsCalculationId || PDSCalculationTable::find(_purchLine.pdsCalculationId).actualAttributes().elements() == 0)
        {
            return lines;
        }

        advancedPricing = PDSAdvancedPricing::newRecord(_infoLine);
        advancedPricing.validateEquation();

        select firstonly RecId
            from inventTransOrigin
            where inventTransOrigin.InventTransId == _purchLine.InventTransId;

        while select inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                && inventTrans.StatusReceipt > StatusReceipt::Purchased
                && inventTrans.StatusReceipt <= StatusReceipt::Registered
                && inventTrans.StatusIssue == StatusIssue::None
            join inventDim
                where inventDim.InventDimId == inventTrans.InventDimId
        {
            advancedPricing.parmInventTrans(inventTrans);
            price = advancedPricing.calEquation();
            if (advancedPricing.isError())
            {
                throw error("@PSC762");
            }
            lines.addEnd(PDSPurchInvoiceLineSplit::newPurchLine(_purchLine, inventTrans, inventDim, price));
        }

        return lines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustPostAssetForVendorInvoiceInfoLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the asset transaction and documents must be posted.
    /// </summary>
    /// <returns>
    /// true if it must be posted; otherwise false.
    /// </returns>
    protected boolean mustPostAssetForVendorInvoiceInfoLine()
    {
        return vendInvoiceInfoLine_Asset.AssetId && AssetParameters::canUserCreateAssetAcquisition();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAsset_RU</Name>
				<Source><![CDATA[
    protected void postAsset_RU()
    {
        if (RAssetPurchTrans::exist(vendInvoiceInfoLine))
        {
            RAssetPurchTrans::post(vendInvoiceInfoLine, vendInvoiceJour, RAssetTable::acquisitionPriceFromPurchLine(vendInvoiceInfoLine, false));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postAssetByDocument_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts related asset documents.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// A <c>ledgervoucher</c> object.
    /// </param>
    /// <param name="_inventMovement">
    /// A <c>InventMovement</c> object; Optional.
    /// </param>
    /// <param name="_vendInvoiceInfoLineAsset">
    /// A <c>VendInvoiceInfoLine_Asset</c> record; Optional.
    /// </param>
    /// <param name="_vendInvoiceJour">
    /// A <c>VendInvoiceJour</c> record; Optional.
    /// </param>
    /// <param name="_vendInvoiceTrans">
    /// A <c>VendInvoiceTrans</c> record; Optional.
    /// </param>
    protected void postAssetByDocument_JP(
        LedgerVoucher _ledgerVoucher,
        InventMovement _inventMovement = null,
        VendInvoiceInfoLine_Asset _vendInvoiceInfoLineAsset = null,
        VendInvoiceJour _vendInvoiceJour = null,
        VendInvoiceTrans _vendInvoiceTrans = null)
    {
        InventTransOrigin inventTransOrigin;
        VendInvoiceInfoLine_Asset vendInvoiceInfoLineAsset;
        AssetDocumentLinkTable_JP linkTable;
        AssetDocumentEntry_JP entryTable;
        AssetDocumentTable_JP documentTable;
        AssetDocumentPostInvoiceAdapter_JP adapter;

        if (_vendInvoiceInfoLineAsset)
        {
            // cases with vend invoice info line, like non-stocked item.
            vendInvoiceInfoLineAsset = _vendInvoiceInfoLineAsset;
        }
        else if (_inventMovement)
        {
            // cases with invent movement, like PO with stocked item.
            inventTransOrigin = InventTransOrigin::find(_inventMovement.inventTransOriginId());
            vendInvoiceInfoLineAsset = VendInvoiceInfoLine_Asset::findByVendInvoiceInfoLineRecId(vendInvoiceInfoLine.RecId);
        }

        if (vendInvoiceInfoLineAsset)
        {
            while select linkTable
                where linkTable.RefTableId == vendInvoiceInfoLineAsset.TableId
                    && linkTable.RefRecId == vendInvoiceInfoLineAsset.RecId
                join entryTable
                where entryTable.RecId == linkTable.AssetDocumentEntry_JP
                join documentTable
                where documentTable.RecId == entryTable.AssetDocumentTable_JP
            {
                adapter = AssetDocumentPostAdapter_JP::construct(
                    AssetDocumentLinkType_JP::Invoice,
                    documentTable.MainType,
                    documentTable.Type);
                adapter.parmLinkTable(linkTable);
                adapter.parmAssetDocumentEntry(entryTable);
                adapter.parmAssetDocumentTable(documentTable);
                adapter.parmLedgerVoucher(_ledgerVoucher);
                adapter.parmInventMovement(_inventMovement);
                adapter.parmVendInvoiceInfoLine(vendInvoiceInfoLine);
                adapter.parmVendInvoiceInfoLineAsset(vendInvoiceInfoLineAsset);
                adapter.parmInventTransOrigin(inventTransOrigin);
                adapter.parmVendInvoiceJour(_vendInvoiceJour);
                adapter.parmVendInvoiceTrans(_vendInvoiceTrans);
                adapter.init();
                adapter.post();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeVendVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>VendVoucher</c> instance.
    /// </summary>
    /// <returns>A newly initialized <c>VendVoucher</c> instance.</returns>
    protected VendVoucher initializeVendVoucher()
    {
        LedgerTransTxt ledgerTransTxt;

        if (this.creditNote())
        {
            ledgerTransTxt = LedgerTransTxt::PurchCreditNoteVend;
        }
        else
        {
            ledgerTransTxt = LedgerTransTxt::PurchInvoiceVend;
        }

        return VendVoucher::newVendVoucherPurch(ledgerTransTxt, vendInvoiceJour, vendInvoiceInfoTable, purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventMovement</c> instance.
    /// </summary>
    /// <param name = "_inventMovement">
    /// The <c>InventMovement</c> instance to be initialized.
    /// </param>
    protected void initializeInventMovement(InventMovement _inventMovement)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateVendVoucherVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates values into the given <c>VendVoucher</c> instance and associated <c>VendTrans</c> record for processing during postCustVend();
    /// </summary>
    /// <param name = "_vendVoucher">The <c>VendVoucher</c> instance to populate.</param>
    /// <returns>A populated <c>VendTrans</c> buffer.</returns>
    protected VendTrans populateVendVoucherVendTrans(VendVoucher _vendVoucher)
    {
        TransDate exchangeRateDate;
        VendTrans vendTrans;
        boolean isBillOfEntry = false;

        _vendVoucher.parmExchRate(vendInvoiceJour.ExchRate);
        _vendVoucher.parmExchRateSecondary(vendInvoiceJour.ExchRateSecondary);
        _vendVoucher.parmReportingCurrencyExchRate(vendInvoiceJour.ReportingCurrencyExchangeRate);

        if (vendInvoiceInfoLine.isNonPO() || !purchLine.isStocked())
        {
            if (vendInvoiceInfoLine_Asset.AssetId && AssetParameters::canUserCreateAssetAcquisition())
            {
                exchangeRateDate = AssetBook::find(vendInvoiceInfoLine_Asset.AssetId, vendInvoiceInfoLine_Asset.AssetBookId).exchangeRateDate();
                _vendVoucher.parmExchangeRateDate(exchangeRateDate? exchangeRateDate : vendInvoiceTrans.InvoiceDate);
            }
        }

        if (ProjBlockReversalWithProjAndNoProjLineFlightVendInvoice::instance().isEnabled())
        {
            // Find if vender invoice contains project line vendInvoiceInfoLine_project
            boolean projectLineExist = VendInvoiceInfoLine_Project::existsForInvoice(vendInvoiceInfoTable);

            // We set the flag to indicate if the transaction is of the type project. The projectLineExist flag is only going to true if the VendInvoiceInfoLine is linked to a project.
            // Set the project bit
            vendTrans.InvoiceProject = projectLineExist ? NoYes::Yes : NoYes::No;
        }
        else
        {
            VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvoiceInfoLine.RecId);
            
            // We set the flag to indicate if the transaction is of the type project. The VendInvoiceInfoLine_Project record is only going to exist if the VendInvoiceInfoLine is linked to a project.
            // Set the project bit
            vendTrans.InvoiceProject = vendInvoiceInfoLine_Project ? NoYes::Yes : NoYes::No;
        }  

        vendTrans.Tax1099Amount = -totalTax1099Amount;
        vendTrans.Tax1099StateAmount = -totalTax1099StateAmount;
        vendTrans.Tax1099Fields = firstTax1099Fields;
        vendTrans.Tax1099State = firstTax1099State;

        if (isConfigurationkeyEnabled(configurationKeyNum(Tax1099S)) || isConfigurationkeyEnabled(configurationKeyNum(Tax1099G)))
        {
            vendTrans.Tax1099RecId = vendInvoiceInfoLine.Tax1099BoxDetail;
        }

        vendTrans.InvoiceReleaseDate = vendInvoiceInfoTable.InvoiceReleaseDate;
        vendTrans.ReleaseDateComment = vendInvoiceInfoTable.ReleaseDateComment;

        // provide the active AccountingEvent's ID to the voucher class
        activeAccountingEventId = AccountingEvent::getCurrentEvent(vendInvoiceInfoTable.SourceDocumentHeader).RecId;
        _vendVoucher.parmAccountingEventReference(activeAccountingEventId);

        if (BrazilParameters::isEnabled())
        {
            _vendVoucher.parmAmountCur(-purchTotals.vendTransAmount_BR());
        }

        if (TaxParameters::isCustomsEnable_IN() && purchParmUpdate.SpecQty == PurchUpdate::BillOfEntryQuantity_IN)
        {
            isBillOfEntry = true;
        }
        // this boolean variable Controls the complete logic Of withholding tax for the Invoice when the Quantity is Bill Of Entry
        if (TaxWithholdParameters_IN::checkTaxParameters() && !isBillOfEntry)
        {
            VendInvoiceInfoLineTaxExtension_IN vendInvoiceInfoLineTaxExt;
            VendInvoiceInfoLine vendInvoiceInfoLineloc;
            Sign taxSign;

            select firstonly tdsGroup, tcsGroup from vendInvoiceInfoLineTaxExt
                where vendInvoiceInfoLineTaxExt.tdsGroup != ''
                    || vendInvoiceInfoLineTaxExt.tcsGroup != ''
                exists join vendInvoiceInfoLineloc
                    where vendInvoiceInfoLineloc.RecId == vendInvoiceInfoLineTaxExt.VendInvoiceInfoLine
                        && vendInvoiceInfoLineloc.ParmId == vendInvoiceInfoLine.ParmId
                        && vendInvoiceInfoLineloc.TableRefId == vendInvoiceInfoLine.TableRefId;

            _vendVoucher.parmIsTDSApplicable_IN(vendInvoiceInfoLineTaxExt.tdsGroup !='');
            _vendVoucher.parmIsTCSApplicable_IN(vendInvoiceInfoLineTaxExt.tcsGroup !='');

            if (vendInvoiceInfoLineTaxExt.tcsGroup != '')
            {
                _vendVoucher.parmTaxWithholdAmount_IN(purchTotals.parmTaxWithholdAmount_IN() * -1);
            }
            else
            {
                _vendVoucher.parmTaxWithholdAmount_IN(purchTotals.parmTaxWithholdAmount_IN());
            }

            _vendVoucher.parmTaxWithholdAmountOriginCur_IN(purchTotals.taxWithholdCalculation_IN().totalTaxAmountOriginCur());
        }
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && TaxParameters::isCustomsEnable_IN())
        {
            vendInvoiceJour.SumTax -= purchTotals.tax().getCustomsDuty_IN();
        }

        return vendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVend</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void postCustVend()
    {
        VendTrans_W vendTrans_W;

        if (BrazilParameters::isEnabled() && !vendInvoiceJour.createVendTrans_BR())
        {
            return;
        }

        VendVoucher vendVoucher = this.initializeVendVoucher();
        VendTrans vendTrans = this.populateVendVoucherVendTrans(vendVoucher);

        vendVoucher.post(ledgerVoucher,
                         vendTrans,
                         this.approval(),
                         Currency::noYes2UnknownNoYes(vendInvoiceJour.Triangulation),
                         false,
                         true);

        this.createDocuRef(vendTrans);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && purchValueSecCur)
        {
            vendVoucher.postSecCur_RU(ledgerVoucher, purchValueSecCur);
        }

        this.updateVendTransServiceTax_IN(vendTrans);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoGB]))
        {
            vendTrans_W = vendTrans.vendTrans_W();
            vendTrans_W.PurchReceiptDate_W = vendInvoiceJour.PurchReceiptDate_W;
            vendTrans_W.update();
        }

        this.approveVendTrans();

        this.updateProjectLedgerUpdates(vendTrans);

        this.updateVendTransOpen1099Data(vendTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendTransOpen1099Data</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>VendTransOpen</c> 1099 data to match the <c>VendTrans</c> values.
    /// </summary>
    /// <param name = "_vendTrans">The current <c>VendTrans</c> record.</param>
    protected void updateVendTransOpen1099Data(VendTrans _vendTrans)
    {
        if (firstTax1099Fields || firstTax1099State)
        {
            if (_vendTrans)
            {
                VendTransOpen tmpVendTransOpen;

                select forupdate firstonly tmpVendTransOpen
                    where tmpVendTransOpen.RefRecId == _vendTrans.RecId;

                if (tmpVendTransOpen)
                {
                    tmpVendTransOpen.Tax1099Amount = _vendTrans.Tax1099Amount;
                    tmpVendTransOpen.Tax1099StateAmount = _vendTrans.Tax1099StateAmount;
                    tmpVendTransOpen.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateVendTransServiceTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>VendTrans_W</c> table for service taxes related to the given <c>VendTrans</c> record.
    /// </summary>
    /// <param name = "_vendTrans">The current <c>VendTrans</c> record.</param>
    protected void updateVendTransServiceTax_IN(VendTrans _vendTrans)
    {
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && TaxParameters::isServiceTaxEnable_IN())
        {
            TaxItemGroupHeading taxItemGroupHeading;
            TaxTable taxTableLoc;

            TmpTaxWorkTrans tmpTaxWorkTransLocForPOTBasis = this.tax().tmpTaxWorkTrans();
            select firstonly tmpTaxWorkTransLocForPOTBasis
                where tmpTaxWorkTransLocForPOTBasis.HeadingRecId == vendInvoiceInfoTable.RecId
                    && tmpTaxWorkTransLocForPOTBasis.HeadingTableId == vendInvoiceInfoTable.TableId
                    join RecId, ServiceTaxBasis_IN from taxItemGroupHeading
                    where taxItemGroupHeading.TaxItemGroup == tmpTaxWorkTransLocForPOTBasis.TaxItemGroup
                        && taxItemGroupHeading.ServiceTaxBasis_IN == ServiceTaxBasis_IN::POTBasis
                    exists join taxTableLoc
                        where taxTableLoc.TaxCode == tmpTaxWorkTransLocForPOTBasis.TaxCode
                        && taxTableLoc.TaxType_IN == TaxType_IN::ServiceTax;

            if (tmpTaxWorkTransLocForPOTBasis && _vendTrans.Invoice)
            {
                VendTrans_W vendTransServiceTaxExtensionLoc = VendTrans_W::findByVendTrans(_vendTrans.RecId, true);
                vendTransServiceTaxExtensionLoc.ServiceTaxPOTStatus_IN = ServiceTaxPOTStatus_IN::Original;
                vendTransServiceTaxExtensionLoc.VendTrans = _vendTrans.RecId;
                vendTransServiceTaxExtensionLoc.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVendPostLedgerVoucherEnd</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the customer and vendor transactions to a new ledger voucher that uses the same voucher as the invoice posting.
    /// </summary>
    /// <remarks>
    /// This method updates the current ledger voucher instance.
    /// </remarks>
    protected void postCustVendPostLedgerVoucherEnd()
    {
        // create new ledger voucher for posting cust vend transactions
        ledgerVoucher = this.createCustVendLedgerVoucher();

        this.postCustVend();

        ledgerVoucher.end();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndDiscount</Name>
				<Source><![CDATA[
    protected void postEndDiscount()
    {
        // Note, don't let base class method run, all discounts are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPost_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Brazilian localization logic after the <c>endPost</c> method.
    /// </summary>
    protected void postEndPost_BR()
    {
        this.postFiscalDocument_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFailed</Name>
				<Source><![CDATA[
    public void postFailed(LogText _logText = '')
    {
        VendInvoiceInfoTable localVendInvoiceInfoTable;

        super();

        if (vendInvoiceInfoTable.ErrorInvalidDistribution == NoYes::Yes)
        {
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(vendInvoiceInfoTable, true, SourceDocumentAccountingStatus::None);
        }

        vendInvoiceInfoTable.VendInvoiceSaveStatus = VendInvoiceSaveStatus::Pending;
        vendInvoiceInfoTable.Log = _logText;
        this.moveFromActiveToSaved();

        VendInvoiceInfoTable::deleteParmUpdate(purchParmUpdate);

        if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
        {
            localVendInvoiceInfoTable = VendInvoiceInfoTable::find('', vendInvoiceInfoTable.TableRefId);
            if (localVendInvoiceInfoTable)
            {
                ProjFundingLimitTrackingManager::updateUsingSourceDocument(localVendInvoiceInfoTable.SourceDocumentHeader, ProjFundingLimitTrackingAction::Release, false, false, true);
                ProjFundingLimitTrackingManager::updateUsingSourceDocument(localVendInvoiceInfoTable.SourceDocumentHeader, ProjFundingLimitTrackingAction::Allocate, false, false, true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postFiscalDocument_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the fiscal document.
    /// </summary>
    protected void postFiscalDocument_BR()
    {
        FiscalDocumentPost_BR fiscalDocumentPost;
        PurchTable_BR purchTable_BR;

        if (vendInvoiceJour.isProforma())
        {
            fiscalDocumentPost = new FiscalDocumentPost_BR(
                FiscalDocumentParmDataCreator_BR::fromVendProFormaInvoice(vendInvoiceJour,
                                                                          vendInvoiceInfoTable,
                                                                          purchTotals,
                                                                          purchParmUpdate,
                                                                          purchTable,
                                                                          journalLines_BR));
            fiscalDocumentPost.run();
        }
        else
        {
            purchTable_BR = purchTable.purchTable_BR();

            if ((this.creditNote() == false && purchTable.isCancellingPurchaseReturn_BR() == false) || vendInvoiceJour.PurchaseType == PurchaseType::ReturnItem)
            {
                fiscalDocumentPost = new FiscalDocumentPost_BR(
                    FiscalDocumentParmDataCreator_BR::fromVendInvoice(vendInvoiceJour,
                                                                      vendInvoiceInfoTable,
                                                                      purchTotals,
                                                                      purchParmUpdate,
                                                                      purchTable,
                                                                      journalLines_BR));
                fiscalDocumentPost.run();
            }
            else if (purchTable_BR.InvoiceRefRecId_BR)
            {
                FiscalDocumentPost_BR::cancelFiscalDocument(VendInvoiceJour::findRecId(purchTable_BR.InvoiceRefRecId_BR).fiscalDocument_BR(),
                                                            vendInvoiceJour.LedgerVoucher,
                                                            vendInvoiceJour.InvoiceDate,
                                                            vendInvoiceJour.CostLedgerVoucher,
                                                            ReasonTableRef::find(vendInvoiceJour.ReasonTableRef_BR).ReasonComment);

                purchTable_BR.selectForUpdate(true);
                purchTable_BR.InvoiceRefRecId_BR = 0;
                purchTable_BR.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInit_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes Brazilian localization logic after the <c>init</c> method.
    /// </summary>
    public void postInit_BR()
    {
        journalLines_BR = new RecordSortedList(tableNum(VendInvoiceTrans));
        journalLines_BR.sortOrder(fieldNum(VendInvoiceTrans, RecId));
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInitTransactionTxt_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the name placeholder in the transaction text.
    /// </summary>
    /// <param name="_ledgerTransTxt">
    /// The transaction text type.
    /// </param>
    /// <param name="_transactionTxt">
    /// The ledger transaction text <c>TransactionTxt</c> record.
    /// </param>
    /// <returns>
    /// The ledger transaction text <c>TransactionTxt</c> record.
    /// </returns>
    protected TransactionTxt postInitTransactionTxt_BR(LedgerTransTxt _ledgerTransTxt,
                                                       TransactionTxt _transactionTxt)
    {
        _transactionTxt.setCustVendName (vendInvoiceJour.vendTable_InvoiceAccount().customerAccountName());

        return _transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeLedgerVoucherObject</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>LedgerVoucherObject</c> class.
    /// </summary>
    /// <param name = "_lastVoucher">The last voucher.</param>
    /// <param name = "_skipPurchConsumpAccount_RU">Indicates whether or not to skip the purch consumption account for RU.</param>
    /// <returns>A newly initializes <c>LedgerVoucherObject</c> instance.</returns>
    protected LedgerVoucherObject initializeLedgerVoucherObject(Voucher _lastVoucher, boolean _skipPurchConsumpAccount_RU)
    {
        LedgerVoucherObject ledgerVoucherObject = this.findOrCreateLedgerVoucherObject(
            _skipPurchConsumpAccount_RU ? _lastVoucher : vendInvoiceJour.CostLedgerVoucher,
            vendInvoiceInfoTable.updateDate());
        ledgerVoucherObject.parmTransDate(vendInvoiceInfoTable.updateDate());

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventoryForLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts inventory financial for the sales parm line/sub line.
    /// </summary>
    /// <param name = "_parameters">The parameters necessary for the inventory update of the line.</param>
    /// <param name = "_postInventoryState">The inventory posting state for the purchase order line.</param>
    protected void postInventoryForLine(PurchInvoiceJournalPostPostInventoryLineParameters _parameters, PurchInvoiceJournalPostPostInventoryState _postInventoryState)
    {
        boolean countryRegion_BR = BrazilParameters::isEnabled();
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean isDocAutoNumbering = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoLT, #isoLV]) && vendInvoiceInfoTable.vendInvoiceInfoTable_W().DocAutoNumbering_LT;

        InvoiceId invoiceNum = vendInvoiceInfoTable.Num;

        if (countryRegion_BR
            || (countryRegion_RU && vendInvoiceInfoTable.correctionType_RU() == FactureCorrectionType_RU::Revision)
            || isDocAutoNumbering)
        {
            invoiceNum = vendInvoiceJour.InvoiceId;
        }

        InventUpd_Financial inventUpd_Financial = InventUpd_Financial::newPurchInvoice(inventMovement,
                                                                        ledgerVoucher,
                                                                        invoiceNum,
                                                                        _parameters.purchValue,
                                                                        CompanyInfoHelper::standardCurrency(),
                                                                        0,
                                                                        0,
                                                                        0,
                                                                        _parameters.vendInvoiceInfoLine,
                                                                        _parameters.vendInvoiceInfoSubLine);

        if (vendInvoiceInfoLine_Asset.AssetId && AssetParameters::canUserCreateAssetAcquisition())
        {
            TransDate acquisitionDate = AssetBook::find(vendInvoiceInfoLine_Asset.AssetId, vendInvoiceInfoLine_Asset.AssetBookId).exchangeRateDate();
            inventUpd_Financial.parmExchangeRateDate(acquisitionDate? acquisitionDate : vendInvoiceTrans.InvoiceDate);
        }

        if (lateMatchingPackingSlipsPerInvoiceLine.exists(_parameters.vendInvoiceInfoLine.RecId))
        {
            List packingSlipList = lateMatchingPackingSlipsPerInvoiceLine.lookup(_parameters.vendInvoiceInfoLine.RecId);
            inventUpd_Financial.parmPackingSlipList(packingSlipList);
        }

        if (_parameters.vendInvoiceInfoLine.ReceiveNow < 0)
        {
            if (purchTable.InterCompanyDirectDelivery && purchTable.interCompanyEndpointActionPolicy().PostSalesInvoice)
                    inventUpd_Financial.parmAllowNegativePhysical(true);

            if (purchTable.ProjId && !purchTable.isProjectSalesItemReqPO()
                    && !purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO() && purchLine.Scrap)
            {
                inventUpd_Financial.parmAllowNegativePhysical(true);
                inventUpd_Financial.parmAllowNegativeFinancial(true);
            }
        }

        inventUpd_Financial.parmPDSUpdatePhysicalOnly(_parameters.physicalOnly);

        if (this.mustUpdateInventoryFinancial(inventUpd_Financial))
        {
            if (countryRegion_RU)
            {
                costAmountMSTSecCur += inventUpd_Financial.updateNow();
            }
            else
            {
                inventUpd_Financial.updateNow();
            }
        }

        if (_parameters.physicalOnly)
        {
            return;
        }

        this.updatePostInventoryState(_postInventoryState, inventUpd_Financial);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePostInventoryState</Name>
				<Source><![CDATA[
    private void updatePostInventoryState(PurchInvoiceJournalPostPostInventoryState _postInventoryState, InventUpd_Financial _inventUpd_Financial)
    {
        _postInventoryState.receiveNow += _inventUpd_Financial.updFinancialUnit();
        _postInventoryState.inventNow += _inventUpd_Financial.updPhysical();
        _postInventoryState.purchUpdateNow += _inventUpd_Financial.updPhysicalUnit();
        _postInventoryState.inventUpdateNow += _inventUpd_Financial.updFinancial();
        _postInventoryState.cwReceiveNow += _inventUpd_Financial.pdsCWUpdPhysical();
        _postInventoryState.cwUpdateNow += _inventUpd_Financial.pdsCWUpdFinancial();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializePostInventorySubLineParameters</Name>
				<Source><![CDATA[
    private PurchInvoiceJournalPostPostInventoryLineParameters initializePostInventorySubLineParameters(
        boolean _physicalOnly, 
        AmountCur _purchValue, 
        VendInvoiceInfoLine _vendInvoiceInfoLine, 
        VendInvoiceInfoSubLine _vendInvoiceInfoSubLine)
    {
        PurchInvoiceJournalPostPostInventoryLineParameters postInventoryLineParameters = PurchInvoiceJournalPostPostInventoryLineParameters::construct();
        postInventoryLineParameters.physicalOnly = _physicalOnly;
        postInventoryLineParameters.purchValue = _purchValue;
        postInventoryLineParameters.vendInvoiceInfoLine = _vendInvoiceInfoLine;
        postInventoryLineParameters.vendInvoiceInfoSubLine = _vendInvoiceInfoSubLine;

        return postInventoryLineParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventory</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts inventory financial for a purchase order line.
    /// </summary>
    protected void postInventory()
    {
        AmountCur localPurchValue;
        VendInvoiceInfoLine localVendInvoiceInfoLine;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;

        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        boolean skipPurchConsumpAccount_RU = countryRegion_RU && !VendParameters::find().UsePurchConsumpAccount_RU;
        boolean countryRegion_BR = BrazilParameters::isEnabled();

        if (vendInvoiceInfoLine.isNonPO())
        {
            // Non-PO lines are non-inventory
            return;
        }
        if (vendInvoiceInfoLine.isAdvance())
        {
            return;
        }
        if (vendInvoiceInfoLine.PSAIsFinal)
        {
            return;
        }
        
        if (!VendInvoiceUnitOfMeasureRounding::isRoundedQuantityBasedOnUnitOfMeasure(vendInvoiceInfoLine.ReceiveNow, purchLine.PurchUnit))
        {
            throw error(strFmt("@SYS19589", purchLine.PurchUnit));
        }

        // Read the PO line for update as Inventory posting will update it
        Debug::assert(purchLine.RecId != 0);
        purchLine = PurchLine::findRecId(purchLine.RecId, true);

        PurchQty remainPurchPhysicalBefore = purchLine.RemainPurchPhysical;
        InventQty remainInventPhysicalBefore = purchLine.RemainInventPhysical;
        PdsCWInventQty cwRemainPhysicalBefore = purchLine.PdsCWRemainInventPhysical;

        boolean isTransactionRelatedToBOE;

        if (isCustomsImportOrder && TaxParameters::isCustomsEnable_IN())
        {
            if (VendDocumentLineMap::getCustomsVendBOETrans_IN(vendInvoiceInfoLine.RecId, vendInvoiceInfoLine.ParmId, vendInvoiceInfoLine.TableId))
            {
                isTransactionRelatedToBOE = true;
            }
        }
        inventMovement = InventMovement::construct(purchLine);

        this.initializeInventMovement(inventMovement);

        // Store last voucher and date used before inventory posting
        Voucher lastVoucher = ledgerVoucher.lastVoucher();
        TransDate lastTransDate = ledgerVoucher.lastTransDate();

        LedgerVoucherObject ledgerVoucherObject = this.initializeLedgerVoucherObject(lastVoucher, skipPurchConsumpAccount_RU);

        if (InventoryReportingCurrencyTriangulationFeature::instance().IsEnabled())
        {
            ledgerVoucherObject.parmTransactionCurrencyCode(vendInvoiceInfoTable.CurrencyCode);
            if (vendInvoiceInfoTable.FixedExchRate)
            {
                ledgerVoucherObject.parmFixedRateCurrencyExchangeHelper(InventoryReportingCurrencyTriangulationHelper::createFixedRateCurrencyExchangeHelper(ledgerVoucher, vendInvoiceInfoTable.ExchRate, vendInvoiceInfoTable.ReportingCurrencyExchangeRate));
            }
        }

        ledgerVoucher.lastTransDate(ledgerVoucherObject.parmTransDate());
        costVoucher = ledgerVoucher.lastVoucher();

        Amount inputAmount = InventCostInputAmount::getInputAmountFromDistribution(VendInvoiceInfoLine::findRecId(vendInvoiceInfoLine.RecId).SourceDocumentLine, inventMovement, AccountingDistributionReferenceRole::Matching) +
            InventCostInputAmount::getInputAmountFromDistribution(VendInvoiceInfoLine::findRecId(vendInvoiceInfoLine.RecId).SourceDocumentLine, inventMovement, AccountingDistributionReferenceRole::None);
	
        if (!TaxSolutionScopeIntegrationUtil::isCompanyEnabled() && TaxParameters::isCustomsEnable_IN())
        {
            TaxTable taxTable;
            TaxOnItem taxOnItem;

            select firstonly taxOnItem
                where taxOnItem.TaxItemGroup == vendInvoiceInfoLine.TaxItemGroup
                exists join TaxType_IN from taxTable
                where taxTable.TaxCode == taxOnItem.TaxCode
                && taxTable.TaxType_IN == TaxType_IN::Customs;
            if (taxOnItem.RecId)
            {
                inputAmount += TaxUncommitted_IN::getCustomsDuty_IN(vendInvoiceInfoLine.TableId, vendInvoiceInfoLine.RecId);
            }
        }

        if (BrazilParameters::isEnabled())
        {
            inputAmount -= tax.taxInCostPrice_BR(vendInvoiceInfoLine.TableId, vendInvoiceInfoLine.RecId);
            
            MarkupTrans markupTrans;
            
            while select RecId from markupTrans
                where markupTrans.TransTableId == vendInvoiceInfoLine.TableId
                    && markupTrans.TransRecId == vendInvoiceInfoLine.RecId
            {
                inputAmount -= tax.taxInCostPrice_BR(markupTrans.TableId, markupTrans.RecId);
            }
        }
        inputAmount += this.postInventorySADCost_PL();
        AmountCur orgPurchValue = inputAmount;

        List list = new List(Types::Record);
        PurchQty purchQtySubTotal;

        while select vendInvoiceInfoSubLine
            where vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLine.RecId
        {
            list.addEnd(vendInvoiceInfoSubLine);
            purchQtySubTotal += vendInvoiceInfoSubLine.ReceiveNow;
        }

        Counter subLinesCount = list.elements();
        PurchQty purchQtyLeft = vendInvoiceInfoLine.ReceiveNow;
        InventQty inventQtyLeft = vendInvoiceInfoLine.InventNow;
        PdsCWInventQty cwQtyLeft = vendInvoiceInfoLine.PdsCWReceiveNow;
        
        List pdsSplitLines;
        if (purchLine.pdsCalculationId && subLinesCount == 0)
        {
            pdsSplitLines = this.pdsSplitToSublines(purchLine, vendInvoiceInfoLine);
        }

        if (AssetDocumentUtility_JP::isAssetDocumentEnabled())
        {
            this.postAssetByDocument_JP(ledgerVoucher, inventMovement);
        }

        if (isTransactionRelatedToBOE)
        {
            if (vendInvoiceInfoLine.RemainAfterInvent == 0)
            {
                vendInvoiceInfoLine.RemainAfter = 0;
            }
        }
        PurchInvoiceJournalPostPostInventoryState postInventoryState = PurchInvoiceJournalPostPostInventoryState::construct();
        PurchQty factor;

        if (subLinesCount > 0)
        {
            factor = vendInvoiceInfoLine.ReceiveNow/purchQtySubTotal < 1 ? vendInvoiceInfoLine.ReceiveNow/purchQtySubTotal : 1;

            ListEnumerator le = list.getEnumerator();
            while (le.moveNext())
            {
                vendInvoiceInfoSubLine = le.current();
                localVendInvoiceInfoLine = vendInvoiceInfoLine.data();

                if (subLinesCount == 1)
                {
                    localVendInvoiceInfoLine.ReceiveNow = purchQtyLeft;
                    localVendInvoiceInfoLine.InventNow = inventQtyLeft;
                    localVendInvoiceInfoLine.PdsCWReceiveNow = cwQtyLeft;
                    localPurchValue = orgPurchValue;
                }
                else
                {
                    localVendInvoiceInfoLine.ReceiveNow = vendInvoiceInfoSubLine.ReceiveNow * factor;
                    localVendInvoiceInfoLine.InventNow = vendInvoiceInfoSubLine.InventNow;
                    localVendInvoiceInfoLine.PdsCWReceiveNow = vendInvoiceInfoSubLine.PdsCWInventNow;
                    localPurchValue = CurrencyExchangeHelper::amount(inputAmount * localVendInvoiceInfoLine.ReceiveNow / vendInvoiceInfoLine.ReceiveNow);
                    if (orgPurchValue == 0 || (orgPurchValue - localPurchValue) * orgPurchValue < 0)
                    {
                        localPurchValue = orgPurchValue;
                    }
                }

                this.postInventoryForLine(this.initializePostInventorySubLineParameters(false, localPurchValue, localVendInvoiceInfoLine, vendInvoiceInfoSubLine), postInventoryState);
                
                subLinesCount--;

                VendPackingSlipTrans vendPackingSlipTrans;
                if (vendInvoiceInfoSubLine.JournalRefTableId == tableNum(VendPackingSlipTrans))
                {
                    vendPackingSlipTrans = VendPackingSlipTrans::findRecId(vendInvoiceInfoSubLine.JournalRefRecId,true);
                }
                else if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
                    && vendInvoiceInfoSubLine.JournalRefTableId == tableNum(CustomsVendBOETrans_IN))
                {
                    CustomsVendBOETrans_IN customsVendBOETrans_IN;
                    CustomsVendPackingSlipBOETransLink_IN customsVendPackingSlipBOETransLink_IN;

                    if (VendBOEInvoiceCreateMatchPackingSlipTrans_INFlight::instance().isEnabled())
                    {
                        select firstonly forupdate vendPackingSlipTrans
                            join RecId from customsVendPackingSlipBOETransLink_IN
                                where customsVendPackingSlipBOETransLink_IN.VendPackingSlipTrans == vendPackingSlipTrans.RecId
                                    && vendPackingSlipTrans.FullyMatched == NoYes::No
                            join RecId from customsVendBOETrans_IN
                                where customsVendBOETrans_IN.RecId == customsVendPackingSlipBOETransLink_IN.CustomsVendBOETrans_IN
                                    && customsVendBOETrans_IN.RecId == vendInvoiceInfoSubLine.JournalRefRecId;
                    }
                    else
                    {
                        select firstonly forupdate vendPackingSlipTrans
                            join RecId from customsVendPackingSlipBOETransLink_IN
                                where customsVendPackingSlipBOETransLink_IN.VendPackingSlipTrans == vendPackingSlipTrans.RecId
                            join RecId from customsVendBOETrans_IN
                                where customsVendBOETrans_IN.RecId == customsVendPackingSlipBOETransLink_IN.CustomsVendBOETrans_IN
                                    && customsVendBOETrans_IN.RecId == vendInvoiceInfoSubLine.JournalRefRecId;
                    }
                }

                this.matchPackingSlipTransSourceDocumentLine(
                    localVendInvoiceInfoLine,
                    vendPackingSlipTrans,
                    vendInvoiceInfoSubLine.ReceiveNow,
                    vendInvoiceInfoSubLine.InventNow,
                    vendInvoiceInfoSubLine.PdsCWInventNow,
                    localVendInvoiceInfoLine.ParmId);

                purchQtyLeft -= vendInvoiceInfoSubLine.ReceiveNow * factor;

                inventQtyLeft -= vendInvoiceInfoSubLine.InventNow;
                cwQtyLeft -= vendInvoiceInfoSubLine.PdsCWInventNow;
                orgPurchValue -= localPurchValue;
            }
        }
        else if (pdsSplitLines && pdsSplitLines.elements() > 1)
        {
            localPurchValue = orgPurchValue;
            localVendInvoiceInfoLine = vendInvoiceInfoLine.data();
            vendInvoiceInfoSubLine = null;
            this.postInventoryForLine(this.initializePostInventorySubLineParameters(true, localPurchValue, localVendInvoiceInfoLine, vendInvoiceInfoSubLine), postInventoryState);

            ListEnumerator le = pdsSplitLines.getEnumerator();
            Amount pdsTotalAmount = 0;
            while (le.moveNext())
            {
                PDSPurchInvoiceLineSplit pdsPurchInvoiceLineSplit = le.current();
                pdsTotalAmount += pdsPurchInvoiceLineSplit.lineAmount();
            }
            factor = inputAmount / pdsTotalAmount;

            subLinesCount = pdsSplitLines.elements();
            le = pdsSplitLines.getEnumerator();
            while (le.moveNext())
            {
                PDSPurchInvoiceLineSplit pdsPurchInvoiceLineSplit = le.current();
                localVendInvoiceInfoLine = vendInvoiceInfoLine.data();

                if (subLinesCount == 1)
                {
                    localVendInvoiceInfoLine.ReceiveNow = purchQtyLeft;
                    localVendInvoiceInfoLine.InventNow = inventQtyLeft;
                    localVendInvoiceInfoLine.PdsCWReceiveNow = cwQtyLeft;
                    localPurchValue = orgPurchValue;
                }
                else
                {
                    localVendInvoiceInfoLine.ReceiveNow = pdsPurchInvoiceLineSplit.parmPurchQty();
                    localVendInvoiceInfoLine.InventNow = pdsPurchInvoiceLineSplit.parmInventQty();
                    localVendInvoiceInfoLine.PdsCWReceiveNow = pdsPurchInvoiceLineSplit.parmCWQty();
                    localPurchValue = CurrencyExchangeHelper::amount(pdsPurchInvoiceLineSplit.lineAmount() * factor);
                    if (orgPurchValue == 0 || (orgPurchValue - localPurchValue) * orgPurchValue < 0)
                    {
                        localPurchValue = orgPurchValue;
                    }
                }
                localVendInvoiceInfoLine.InventDimId = pdsPurchInvoiceLineSplit.parmInventDim().InventDimId;

                this.postInventoryForLine(this.initializePostInventorySubLineParameters(false, localPurchValue, localVendInvoiceInfoLine, vendInvoiceInfoSubLine), postInventoryState);
                subLinesCount--;

                purchQtyLeft -= pdsPurchInvoiceLineSplit.parmPurchQty();
                inventQtyLeft -= pdsPurchInvoiceLineSplit.parmInventQty();
                cwQtyLeft -= pdsPurchInvoiceLineSplit.parmCWQty();              
                orgPurchValue -= localPurchValue;
            }
        }
        else
        {
            localPurchValue = orgPurchValue;
            localVendInvoiceInfoLine = vendInvoiceInfoLine.data();
            vendInvoiceInfoSubLine = null;

            this.postInventoryForLine(this.initializePostInventorySubLineParameters(false, localPurchValue, localVendInvoiceInfoLine, vendInvoiceInfoSubLine), postInventoryState);
        }

        /* Quantity actual updated is collected */
        vendInvoiceInfoLine.ReceiveNow = postInventoryState.receiveNow;
        vendInvoiceInfoLine.PdsCWReceiveNow = postInventoryState.cwReceiveNow;
        vendInvoiceInfoLine.InventNow = postInventoryState.inventNow;
        invoiceUpdatedOnly = postInventoryState.purchUpdateNow;
        updateNowInvent = postInventoryState.inventUpdateNow;
        cwUpdateNow = postInventoryState.cwUpdateNow;

        // Reset last voucher and date used before inventory posting
        ledgerVoucher.lastVoucher(lastVoucher);
        ledgerVoucher.lastTransDate(lastTransDate);

        /* Calculating purchprice and update InventTable */
        this.calcLastPurchPrice();

        if (countryRegion_RU)
        {
            purchValueSecCur = costAmountMSTSecCur;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInventorySADCost_PL</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates extra cost that should be allocated to inventory due to SAD
    /// </summary>
    /// <returns>
    /// Extra cost that should be allocated to inventory due to SAD
    /// </returns>
    protected Amount postInventorySADCost_PL()
    {
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postJournalPost</Name>
				<Source><![CDATA[
    public void postJournalPost()
    {
        super();

        if (TAMVendRebateParameters::find().AtInvoicing)
        {
            TAMVendRebateFindAndCreate::newFromVendInvoiceTrans(vendInvoiceJour, vendInvoiceTrans).run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLeanSubcontracting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Record lean subcontracting cost if the posted line is related to a production flow.
    /// </summary>
    protected void postLeanSubcontracting()
    {
        RefRecId productionFlowReferenceRecId;

        if (!purchLine)
        {
            return;
        }

        if (!leanCostingFacade)
        {
            this.parmLeanCostingFacade(LeanCostingFacade::construct());
        }

        productionFlowReferenceRecId = leanCostingFacade.getProductionFlowFromPurchLine(purchLine);
        if (productionFlowReferenceRecId)
        {
            if (!leanConversionCostUpd)
            {
                leanConversionCostUpd = LeanConversionCostUpd::constructForVoucher(
                    ledgerVoucher,
                    leanCostingFacade);
            }

            leanConversionCostUpd.addDirectOutsourcing(
                productionFlowReferenceRecId,
                vendInvoiceInfoLine.ItemId,
                vendInvoiceInfoLine.InventDimId,
                vendInvoiceInfoLine.ReceiveNow,
                vendInvoiceInfoLine.PurchPrice,
                tableNum(VendInvoiceInfoLine),
                vendInvoiceInfoLine.RecId,
                purchLine.DefaultDimension,
                vendInvoiceInfoLine.SourceDocumentLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLine</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void postLine()
    {
        // Note, don't let base class method run, lines are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postLineDiscount</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void postLineDiscount()
    {
        // Note, don't let base class method run, line level discounts are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupLine</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void postMarkupLine()
    {
        NoYes miscellaneouscharges = LedgerParameters::isMiscellaneouscharges_IN();

        if (miscellaneouscharges)
        {
            markup.parmCreditNote_IN(this.creditNote());
        }
        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU) && this.isProforma())
        {
            markup.postJournal(
                        vendInvoiceInfoLine.ReceiveNow,
                        vendInvoiceInfoLine.lineAmountExclTax(vendInvoiceJour.InvoiceDate),
                        vendInvoiceInfoLine,
                        purchLine.LedgerDimension,
                        vendInvoiceTrans
                    );
        }
        else
        {
            if (vendInvoiceInfoLine.isNonPO() || vendInvoiceInfoLine.isAdvance())
            {
                markup.postInvoice(
                    vendInvoiceInfoLine.ReceiveNow,
                    vendInvoiceInfoLine.lineAmountExclTax(vendInvoiceJour.InvoiceDate, purchTotals.tax()),
                    vendInvoiceInfoLine,
                    ledgerVoucher,
                    vendInvoiceInfoLine.DefaultDimension,
                    vendInvoiceTrans,
                    0, // Intercompany amount
                    '', // Intercompany invoice id
                    true);
            }
            else
            {
                markup.postInvoice(
                    vendInvoiceInfoLine.ReceiveNow,
                    vendInvoiceInfoLine.lineAmountExclTax(vendInvoiceJour.InvoiceDate, purchTotals.tax()),
                    vendInvoiceInfoLine,
                    ledgerVoucher,
                    purchLine.DefaultDimension,
                    vendInvoiceTrans,
                    purchLine.interCompanyLineAmount(vendInvoiceInfoLine.ReceiveNow,vendInvoiceJour.InvoiceDate, purchTotals.tax()),
                    purchLine.purchTable().isInterCompanyOrder() ? vendInvoiceInfoTable.Num : '',
                    true);
            }
        }

        if (miscellaneouscharges)
        {
            if ((purchTotals && this.creditNote() && purchTotals.purchBalance() < 0 ) ||
                (this.creditNote() && purchTotals.purchTotalAmount() < 0))
            {
                markupCustVendCopy += markup.markupCustVend();
            }
        }
        purchValue += markup.markupItem();
        tmpTax1099Amount -= markup.markupCustVend();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupLineBeforeInventory</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected boolean postMarkupLineBeforeInventory()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnParmSubTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the <c>MarkupTrans</c> records that are associated with a record in the
    ///    <c>VendInvoiceInfoSubTable</c> table.
    /// </summary>
    /// <param name="_vendInvoiceInfoSubTable">
    ///    A <c>VendInvoiceInfoSubTable</c> record.
    /// </param>
    [HookableAttribute(true)]
    protected void postMarkupOnParmSubTable(VendInvoiceInfoSubTable _vendInvoiceInfoSubTable)
    {
        PurchTable purchTableMarkup;

        Debug::assert(_vendInvoiceInfoSubTable.TableId == tableNum(VendInvoiceInfoSubTable));

        if (LedgerParameters::isMiscellaneouscharges_IN())
        {
            markup.parmCreditNote_IN(this.creditNote());
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) &&
            _vendInvoiceInfoSubTable && this.isProforma())
        {
            if (_vendInvoiceInfoSubTable.isNonPO() || vendInvoiceInfoTable.isAdvance())
            {
                markup.postJournal(
                        1,
                        purchTotals.purchOrderBalance(_vendInvoiceInfoSubTable.TableId, _vendInvoiceInfoSubTable.RecId),
                        _vendInvoiceInfoSubTable,
                        vendInvoiceInfoTable.DefaultDimension,
                        vendInvoiceJour,
                        ledgerVoucher);
            }
            else
            {
                purchTableMarkup = _vendInvoiceInfoSubTable.purchTable();
                markup.postJournal(
                        1,
                        purchTotals.purchOrderBalance(_vendInvoiceInfoSubTable.TableId, _vendInvoiceInfoSubTable.RecId),
                        _vendInvoiceInfoSubTable,
                        purchTableMarkup.DefaultDimension,
                        vendInvoiceJour,
                        ledgerVoucher);
            }
        }

        if (_vendInvoiceInfoSubTable && !this.isProforma() && !this.isOnHold())
        {
            if (_vendInvoiceInfoSubTable.isNonPO() || vendInvoiceInfoTable.isAdvance())
            {
                markup.postInvoice(
                        1,
                        purchTotals.purchOrderBalance(_vendInvoiceInfoSubTable.TableId, _vendInvoiceInfoSubTable.RecId),
                        _vendInvoiceInfoSubTable,
                        ledgerVoucher,
                        vendInvoiceInfoTable.DefaultDimension,
                        vendInvoiceJour,
                        0, // Intercompany amount
                        '', // Intercompany invoice id
                        true);
            }
            else
            {
                purchTableMarkup = _vendInvoiceInfoSubTable.purchTable();
                markup.postInvoice(
                        1,
                        purchTotals.purchOrderBalance(_vendInvoiceInfoSubTable.TableId, _vendInvoiceInfoSubTable.RecId),
                        _vendInvoiceInfoSubTable,
                        ledgerVoucher,
                        purchTableMarkup.DefaultDimension,
                        vendInvoiceJour,
                        0,
                        purchTableMarkup.isInterCompanyOrder() ? vendInvoiceInfoTable.Num : '',
                        true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupOnParmTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the <c>MarkupTrans</c> records that are associated with the current record in the
    ///    <c>VendInvoiceInfoTable</c> table.
    /// </summary>
    [HookableAttribute(true)]
    protected void postMarkupOnParmTable()
    {
        PurchTable purchTableMarkup;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]) && this.isProforma())
        {
            if (vendInvoiceInfoTable.isNonPO() || vendInvoiceInfoTable.isAdvance())
            {
                markup.postJournal(
                            1,
                            purchTotals.purchBalance(),
                            vendInvoiceInfoTable,
                            vendInvoiceInfoTable.DefaultDimension,
                            vendInvoiceJour,
                            ledgerVoucher);
            }
            else
            {
                purchTableMarkup = vendInvoiceInfoTable.purchTable();
                if (purchTableMarkup)
                {
                    markup.postJournal(
                                1,
                                purchTotals.purchBalance(),
                                vendInvoiceInfoTable,
                                purchTableMarkup.DefaultDimension,
                                vendInvoiceJour,
                                ledgerVoucher);
                }
            }
        }

        if (this.isProforma() || this.isOnHold())
        {
            return;
        }

        if (vendInvoiceInfoTable.isNonPO() || vendInvoiceInfoTable.isAdvance())
        {
            markup.postInvoice(
                        1,
                        purchTotals.purchBalance(),
                        vendInvoiceInfoTable,
                        ledgerVoucher,
                        vendInvoiceInfoTable.DefaultDimension,
                        vendInvoiceJour,
                        0, // Intercompany amount
                        '', // Intercompany invoice id
                        true);
        }
        else
        {
            purchTableMarkup = vendInvoiceInfoTable.purchTable();
            if (purchTableMarkup)
            {
                markup.postInvoice(
                            1,
                            purchTotals.purchBalance(),
                            vendInvoiceInfoTable,
                            ledgerVoucher,
                            purchTableMarkup.DefaultDimension,
                            vendInvoiceJour,
                            0,
                            purchTableMarkup.isInterCompanyOrder() ? vendInvoiceInfoTable.Num : '',
                            true);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postMarkupTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the <c>MarkupTrans</c> records that are associated with the records in the
    ///    <c>VendInvoiceInfoTable</c> and <c>VendInvoiceInfoSubTable</c> tables.
    /// </summary>
    [HookableAttribute(true)]
    protected void postMarkupTable()
    {
        QueryRun queryRun = new QueryRun(vendInvoiceInfoTable.querySubTable());

        while (queryRun.next())
        {
            if (queryRun.changed(tableNum(VendInvoiceInfoSubTable)))
            {
                this.postMarkupOnParmSubTable(queryRun.get(tableNum(VendInvoiceInfoSubTable)));
            }
        }

        this.postMarkupOnParmTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postNotStocked</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs posting routines for not stocked purchase order lines.
    /// </summary>
    [HookableAttribute(true)]
    protected void postNotStocked()
    {
        TradeNonStockedRegistrationHelper tradeNonStockedRegistrationHelper;
        PurchQty registerQty;

        updateNowInvent = 0;
        cwUpdateNow = 0;
        invoiceUpdatedOnly = this.qtyPhysicalNow();
        registerQty = purchLine.RemainPurchPhysical - vendInvoiceInfoLine.RemainAfter;

        MarkupAdjustment::adjustInvoice(
            vendInvoiceInfoLine.ReceiveNow,
            vendInvoiceInfoLine.lineAmountExclTax(vendInvoiceJour.InvoiceDate),
            ledgerVoucher,
            vendInvoiceTrans,
            vendInvoiceInfoLine,
            vendInvoiceTrans,
            true); // true indicates that this call should not result in anything being posted

        if (vendInvoiceInfoLine.isNonPO())
        {
            // Non-PO distributions are posted separately
            return;
        }
        if (vendInvoiceInfoLine.isAdvance())
        {
            return;
        }

        this.matchInvoicePackingSlipNotStocked();

        //Delete the pending receipt and pending registration records for the quantity being posted.
        tradeNonStockedRegistrationHelper = TradeNonStockedRegistrationHelper::newFromSalesPurchLine(purchLine);

        if (registerQty < 0 && purchLine.PurchQty > 0)
        {
            if (purchLine.isTangible())
            {
                tradeNonStockedRegistrationHelper.synchronizePendingRegistration(-registerQty,false);
            }
        }
        else
        {
            tradeNonStockedRegistrationHelper.updatePendingQuantityOnPosting(registerQty);
        }

        this.postLeanSubcontracting();

        // Calculating purchprice and update InventTable
        this.calcLastPurchPrice();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPostCustVend_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Associates the vendor invoice to the fiscal establishment.
    /// </summary>
    protected void postPostCustVend_BR()
    {
        FiscalEstablishmentVendInvoiceJour_BR fiscalEstablishmentVendInvoiceJour;
        VendTrans vendTrans;

        select RecId from vendTrans
            where vendTrans.AccountNum == vendInvoiceJour.InvoiceAccount
                && vendTrans.TransDate == vendInvoiceJour.InvoiceDate
                && vendTrans.Voucher == vendInvoiceJour.LedgerVoucher;

        fiscalEstablishmentVendInvoiceJour.VendInvoiceJour = vendInvoiceJour.RecId;
        fiscalEstablishmentVendInvoiceJour.FiscalEstablishment_BR = conPeek(vendInvoiceInfoTable.getFiscalEstablishment(),1 );
        fiscalEstablishmentVendInvoiceJour.VendTrans = vendTrans.RecId;
        fiscalEstablishmentVendInvoiceJour.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPostLine_BR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the line to the inventory journal lines.
    /// </summary>
    protected void postPostLine_BR()
    {
        LedgerDimensionAccount ledgerDimension;

        ledgerDimension = VendLedgerAccounts::summaryLedgerDimension(vendInvoiceTrans.vendInvoiceJour().InvoiceAccount, vendInvoiceJour.PostingProfile);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postProjWipRevenue</Name>
				<Source><![CDATA[
    /// <summary>
    /// If this vendor invoice has lines related to projects in another legal entity, we may
    /// have to WIP the revenue if the system is configured for doing so.
    /// </summary>
    private void postProjWipRevenue()
    {
        ProjIntercompanyParameters params;
        VendInvoiceInfoLine_Project projLine;
        VendInvoiceInfoLine lineLocal;
        ProjectRevenueHeader revenueHeader;
        ProjectRevenueLine revenueLine;
        TaxAmountCur intercompanyExemptTax;

        while select sum(TransferPrice), VendInvoiceInfoLineRefRecId from projLine
            group by projLine.TransferCurrency, projLine.VendInvoiceInfoLineRefRecId
            where projLine.TransferPrice != 0
            join RecId from lineLocal
                where lineLocal.RecId == projLine.VendInvoiceInfoLineRefRecId &&
                    lineLocal.ParmId == vendInvoiceInfoTable.ParmId &&
                    lineLocal.TableRefId == vendInvoiceInfoTable.TableRefId
            exists join params
                where params.BorrowingLegalEntity == projLine.ProjDataAreaId &&
                params.wipRevenue == true
        {
            if (!revenueHeader)
            {
                revenueHeader.ReferenceSourceDocumentHeader = vendInvoiceInfoTable.SourceDocumentHeader;
                revenueHeader.IsIntercompany = true;
                revenueHeader.insert();
            }

            VendInvoiceInfoLine vendInvoiceInfoLineLocal = VendInvoiceInfoLine::findRecId(projLine.VendInvoiceInfoLineRefRecId);
            intercompanyExemptTax = VendInvoiceInfoLine_Project::intercompanyExemptTax(vendInvoiceInfoLineLocal, projLine.TransferCurrency);

            revenueLine.clear();
            revenueLine.ProjectRevenueHeader = revenueHeader.RecId;
            revenueLine.RefTableId = vendInvoiceInfoLineLocal.TableId;
            revenueLine.RefRecId = vendInvoiceInfoLineLocal.RecId;
            revenueLine.Currency = Currency::find(projLine.TransferCurrency).RecId;
            revenueLine.AccountingLegalEntity = CompanyInfo::current();
            revenueLine.TransactionCurrencyAmount = (projLine.TransferPrice + intercompanyExemptTax) * (vendInvoiceInfoLineLocal.ReceiveNow ? vendInvoiceInfoLineLocal.ReceiveNow : 1);
            revenueLine.AccountingDate = vendInvoiceInfoTable.TransDate;
            revenueLine.insert();
        }

        if (revenueHeader)
        {
            SourceDocumentProcessorFacade::submitSourceDocumentImplementation(revenueHeader, false, SourceDocumentAccountingStatus::Completed);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postQualityOrderTaxes_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reads the table buffer and calculate and post the taxes with required condition for Quality orders.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// The value to set.
    /// </param>
    /// <param name="_transactionTxt">
    /// The value to set.
    /// </param>
    public void postQualityOrderTaxes_IN(
        LedgerVoucher _ledgerVoucher,
        TransactionTxt _transactionTxt)
    {
        InventQualityOrderTable inventQualityOrderTable;
        TaxPurchQualityOrder_IN qualityOrderTax;
        NumberSequenceReference numberSeqRef;
        LedgerVoucherObject ledgerVoucherObject;
        LedgerVoucherGroup ledgerVoucherGroup;
        LedgerVoucher taxTransLedgerVoucher;
        LedgerVoucher settlementLedgerVoucher;
        NumberSeq numberSequence;
        TaxTrans taxTrans;

        inventQualityOrderTable = InventQualityOrderTable::findSalesPurchRefTransId_IN(purchLine.InventTransId, InventTestReferenceType::Purch);

        select firstonly RecId from taxTrans
            where taxTrans.SourceTableId == tableNum(InventQualityOrderTable)
                && taxTrans.SourceRecId == inventQualityOrderTable.RecId;

        if (taxTrans.RecId != 0)
        {
            return;
        }

        ledgerVoucherGroup = LedgerVoucherGroup::construct();
        numberSeqRef = VendParameters::numRefVendPaymentVoucher();

        numberSequence = NumberSeq::newGetVoucher(numberSeqRef);

        taxTransLedgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Detail,
                                                             SysModule::Vend,
                                                             NumberSequenceTable::find(numberSeqRef.NumberSequenceId).NumberSequence);

        taxTransLedgerVoucher.parmCompanyId(curext());

        ledgerVoucherGroup.addLedgerVoucher(taxTransLedgerVoucher);

        ledgerVoucherObject = taxTransLedgerVoucher.findLedgerVoucherObject();

        if (ledgerVoucherObject == null
            || ledgerVoucherObject.transElements() != 0)
        {
            taxTransLedgerVoucher.addVoucher(LedgerVoucherObject::newVoucher(numberSequence.voucher(),
                                                                              this.invoiceDate()));
        }

        voucher = taxTransLedgerVoucher.lastVoucher();

        taxTransLedgerVoucher.findLedgerVoucherObject(voucher).lastTransTxt(_transactionTxt.txt());

        qualityOrderTax = TaxPurchQualityOrder_IN::construct(inventQualityOrderTable,vendInvoiceInfoLine);
        qualityOrderTax.setRelatedVoucherObject(taxTransLedgerVoucher);
        qualityOrderTax.inventLossAccount(purchLine.ItemId);

        qualityOrderTax.calc();
        qualityOrderTax.setVoucherId(voucher);
        qualityOrderTax.saveAndPost(LedgerPostingController::newForLedgerPostingJournal(taxTransLedgerVoucher),
                                    inventQualityOrderTable);
        ledgerVoucherGroup.end();

        settlementLedgerVoucher = ledgerVoucherGroup.findLedgerVoucher(curext(),
                                                                       taxTransLedgerVoucher.parmVoucherSeriesCode());

        if (settlementLedgerVoucher != null)
        {
            settlementLedgerVoucher.createVoucherLinks(_ledgerVoucher.lastVoucher(),
                                                       _ledgerVoucher.lastTransDate());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postRoundOff</Name>
				<Source><![CDATA[
    protected void postRoundOff()
    {
        // Note, don't let base class method run, roundoff are posted in this.journalizeSourceDocument().
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxesBeforeSourceDocument</Name>
				<Source><![CDATA[
    protected boolean postTaxesBeforeSourceDocument()
    {
        return true && (!SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])); // do not flip the posting sequence of SD and taxTrans for India
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnProforma</Name>
				<Source><![CDATA[
    protected boolean postTaxOnProforma()
    {
        boolean ret;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoCZ, #isoEE, #isoHU, #isoLT, #isoLV, #isoPL, #isoRU ]))
        {
            ret = true;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxOnUpdate</Name>
				<Source><![CDATA[
    protected boolean postTaxOnUpdate()
    {
        #ISOCountryRegionCodes
        boolean ret;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]) &&
           (vendInvoiceJour.InventProfileType_RU == InventProfileType_RU::CommissionAgent ||
            vendInvoiceJour.InventProfileType_RU == InventProfileType_RU::CommissionPrincipalAgent ||
            vendInvoiceJour.InventProfileType_RU == InventProfileType_RU::Bailee))
        {
            return false;
        }
        else
        {
            ret = super();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToCustomsExpenseAccount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method overrides in the child classes.
    /// </summary>
    protected void postToCustomsExpenseAccount_IN()
    {
        TaxTable taxTable;
        TaxOnItem taxOnItem;
        VendInvoiceJour_IN vendInvoiceJourIn;

        // Read the VendInvoiceJour line for update as Inventory posting will update it
        Debug::assert(vendInvoiceJour.RecId != 0);

        // If you have Charge as Expense defined on any of the custom tax code, only then create NumberSequense.
        select firstonly RecId from taxOnItem
            where taxOnItem.TaxItemGroup == vendInvoiceInfoLine.TaxItemGroup
                && taxOnItem.CustomsChargeAsExpensePercent_IN != 0
                exists join TaxType_IN from taxTable
                    where taxTable.TaxCode == taxOnItem.TaxCode
                        && taxTable.TaxType_IN == TaxType_IN::Customs;

        if (taxOnItem.RecId && !chargeAsExpenseDocumentVoucher)
        {
            chargeAsExpenseDocumentVoucher = NumberSeq::newGetVoucher(TaxParameters::numRefChargeAsExpenseDocumentVoucher_IN()).voucher();
            ledgerVoucherObjectForChargeAsExpense = LedgerVoucherObject::newVoucher(chargeAsExpenseDocumentVoucher, vendInvoiceInfoLine.vendInvoiceInfoTable().TransDate, SysModule::Ledger);
            // last voucher, Transdate & posting layer are stoder in local variable and are being set after the add voucher to manage the New voucher creation.
            if (!lastTransDateLoc && !lastVoucherLoc)
            {
                lastVoucherLoc = ledgerVoucher.lastVoucher();
                lastTransDateLoc = ledgerVoucher.lastTransDate();
                lastPostingLayerLoc = ledgerVoucher.lastPostingLayer();
            }
            ledgerVoucher.addVoucher(ledgerVoucherObjectForChargeAsExpense);
            if (lastTransDateLoc && lastVoucherLoc)
            {
                ledgerVoucher.lastVoucher(lastVoucherLoc);
                ledgerVoucher.lastTransDate(lastTransDateLoc);
                ledgerVoucher.lastPostingLayer(lastPostingLayerLoc);
            }
        }

        if (taxOnItem.RecId && chargeAsExpenseDocumentVoucher && ledgerVoucherObjectForChargeAsExpense)
        {
            // THis method is called to pass the Vendinvoice Line and LedgerVoucher object which will post the Expense Accounts as per the Charges defined on the TaxItemGroup.
            TaxUncommitted_IN::getCustomsDuty_IN(vendInvoiceInfoLine.TableId, vendInvoiceInfoLine.RecId, ledgerVoucherObjectForChargeAsExpense);
            // Only if Voucher is Generated update the Invoice Jour table.
            if (chargeAsExpenseDocumentVoucher)
            {
                vendInvoiceJourIn = VendInvoiceJour_IN::findByVendInvoiceJour(vendInvoiceJour.RecId, true);
                if (!vendInvoiceJourIn && vendInvoiceJour.RecId != 0)
                {
                    vendInvoiceJourIn.VendInvoiceJour = vendInvoiceJour.RecId;
                    vendInvoiceJourIn.ChargeAsExpenseDocumentVoucher_IN = chargeAsExpenseDocumentVoucher;
                    vendInvoiceJourIn.insert();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>preJournalLine_BR</Name>
				<Source><![CDATA[
    private void preJournalLine_BR(Common _journalLine)
    {
        vendInvoiceTrans = _journalLine as VendInvoiceTrans;

        if (vendInvoiceTrans && !journalLines_BR.find(vendInvoiceTrans))
        {
            journalLines_BR.ins(vendInvoiceTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBudgetForSavedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs budget processing for the saved invoice copy.
    /// </summary>
    /// <param name="_savedVendInvoiceInfoTable">
    /// The saved <c>VendInvoiceInfoTable</c> record created.
    /// </param>
    protected void processBudgetForSavedInvoice(VendInvoiceInfoTable _savedVendInvoiceInfoTable)
    {
        SourceDocumentLine sourceDocumentLine;

        if (Ledger::isLedgerBudgetControlEnabled())
        {
            // Perform budget processing on the saved vendor invoice to maintain budget data for the saved version
            // Only process source document lines with no parent source document line specified to check all lines
            // and amounts associated with the header
            sourceDocumentLine = SourceDocumentLine::findBySourceDocumentHeader(_savedVendInvoiceInfoTable.SourceDocumentHeader, 0);

            while (sourceDocumentLine)
            {
                // Check budget with suppress messages option
                BudgetControlSourceDocumentProcessor::submitSourceDocumentLineToCheckBudget(
                    sourceDocumentLine,
                    true,
                    null,
                    true,
                    this.getProcessUser(),
                    false,
                    true);

                next sourceDocumentLine;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processSourceDocument</Name>
				<Source><![CDATA[
    protected void processSourceDocument()
    {
        Set sourceDocumentLines;
        SetEnumerator setEnumerator;
        RefRecId sourceDocumentLineRecId;
        ProjectAccountingDistribution projectAccountingDistribution;
        ProjectAccountingDistribution checkProjectAccountingDistribution;
        ProjTable projTable,checkProjTable;
        ProjGroup checkProjGroup;
        ProjLineProperty projLineProperty,checkProjLineProperty;
        SourceDocumentLine sourceDocumentline;
        AccountingDistribution accountingDistribution;
        AccountingDistribution checkAccountingDistribution;
        #SubledgerJournal

        Set getSourceDocumentLinesSet(RefRecId _sourceDocumentLine)
        {
            Set set;
            SourceDocumentLine childSourceDocumentLine;
            Stack stack;
            RefRecId currenSourceDocumentLine;

            set = new Set(Types::Int64);

            if (_sourceDocumentLine)
            {
                stack = new Stack();
                stack.push([_sourceDocumentLine]);

                while (stack.qty())
                {
                    [currenSourceDocumentLine] = stack.pop();

                    set.add(currenSourceDocumentLine);

                    if (AccountsPayableAddHeaderClauseInSourceDocumentLineQueryFlight::instance().isEnabled())
                    {
                        childSourceDocumentLine.allowIndexHint(true);

                        while select RecId
                            from childSourceDocumentLine
                            index hint ParentSourceDocumentLineIdx
                            where childSourceDocumentLine.ParentSourceDocumentLine == currenSourceDocumentLine
                        {
                            stack.push([childSourceDocumentLine.RecId]);
                        }
                    }
                    else
                    {
                        while select ParentSourceDocumentLine, RecId
                            from childSourceDocumentLine
                            where childSourceDocumentLine.ParentSourceDocumentLine == currenSourceDocumentLine
                        {
                            stack.push([childSourceDocumentLine.RecId]);
                        }
                    }
                }
            }

            return set;
        }

        boolean enableMultipleContractLinesForProjectFeature = ProjMultipleContractLinesForProjectFeatureHelper::isFeatureEnabled();

        while select vendInvoiceInfoLine
            where vendInvoiceInfoTable.ParmId == vendInvoiceInfoLine.ParmId &&
                vendInvoiceInfoTable.TableRefId == vendInvoiceInfoLine.TableRefId
            join purchLine
                where purchLine.RecId == vendInvoiceInfoLine.PurchLineRecId &&
                    purchLine.StockedProduct == NoYes::No
            exists join sourceDocumentLine
                where sourceDocumentLine.RecId == vendInvoiceInfoLine.SourceDocumentLine
            exists join checkAccountingDistribution
                where checkAccountingDistribution.SourceDocumentLine == sourceDocumentLine.RecId
            exists join checkProjectAccountingDistribution
                where checkProjectAccountingDistribution.AccountingDistribution == checkAccountingDistribution.RecId
            exists join checkProjTable
                where checkProjTable.RecId == checkProjectAccountingDistribution.ProjTable
            exists join checkProjGroup
                where enableMultipleContractLinesForProjectFeature || checkProjGroup.ProjGroupId == checkProjTable.ProjGroupId
            exists join checkProjLineProperty
                where checkProjLineProperty.RecId == checkProjectAccountingDistribution.ProjLineProperty &&
                    checkProjLineProperty.ToBeCapitalize
        {
            sourceDocumentLines = getSourceDocumentLinesSet(vendInvoiceInfoLine.SourceDocumentLine);
            if (sourceDocumentLines)
            {
                setEnumerator = sourceDocumentLines.getEnumerator();
                while (setEnumerator.moveNext())
                {
                    sourceDocumentLineRecId = setEnumerator.current();

                    while select forUpdate accountingDistribution
                        where accountingDistribution.SourceDocumentLine == sourceDocumentLineRecId
                    join projectAccountingDistribution
                        where projectAccountingDistribution.AccountingDistribution == accountingDistribution.RecId
                    join projTable
                        where projTable.RecId == projectAccountingDistribution.ProjTable
                    join projLineProperty
                        where projLineProperty.RecId == projectAccountingDistribution.ProjLineProperty &&
                            projLineProperty.ToBeCapitalize
                    {
                        ProjLedgerStatus itemProjLedgerStatus = this.getProjLedgerStatus(enableMultipleContractLinesForProjectFeature, projTable);
                        if (itemProjLedgerStatus != ProjLedgerStatus::BalanceSheet)
                        {
                            continue;
                        }

                        if (ProjTable::isPLPostingRequiredForTransType(projTable.ProjId, ProjTransType::Item))
                        {
                            projectAccountingDistribution.setLedgerDimension(accountingDistribution, false);
                            accountingDistribution.update();
                        }
                    }
                }
            }
        }

        this.lateMatchPackingSlips(vendInvoiceInfoTable);

        if (!isPrePaymentJournalPost && SourceDocumentCompletionRule::isTransferToFullyDistRequired())
        {
            // Determines whether the account validation is needed when the vendor invoice source document will be transitioned to
            // completed state. This check MUST be done prior to submitting the source document to transition to fully distributed state in code.
            this.parmSourceDocumentCompletionRule().doTransferToCompleteStateAccValidation(vendInvoiceInfoTable.SourceDocumentHeader);

            var caller = PurchInvoiceJournalPostCaller::newFromLedgerVoucher(ledgerVoucher);
            
            boolean doAsynchronousLineTransition = true;
            if (isExecutingPaymentAuthorizationTask || (chainFormletterContract && chainFormletterContract.parmIntercompanyPosted() == NoYes::Yes))
            {
                // Degrade to synchronous processing for intercompany orders and posting initiated through workflow
                // to avoid database locks
                doAsynchronousLineTransition = false;
            }

            if (VendInvoiceSplitDistributionPostFeature::isEnabled())
            {
                Batch batchTask;
                // Check whether the distribution task has finished successfully in the same batch job as this posting job.
                RefRecId batchJobId = this.parmChainFormletterContract().parmBatchJobId();
                if (batchJobId != 0)
                {
                    select firstonly RecId from batchTask
                        where batchTask.BatchJobId == batchJobId && 
                            batchTask.Status == BatchStatus::Finished &&
                            batchTask.ClassNumber == classNum(SourceDocumentDistributionTaskProcessor);
                }
                // If the distribution task is not found in the same batch job, need to do distribution here.
                if (batchTask.RecId == 0)
                {
                    SourceDocumentProcessorFacade::submitSourceDocumentLinesForHeader(vendInvoiceInfoTable,
                        SourceDocumentLineAccountingStatus::FullyDistributed, caller, curUserId(), doAsynchronousLineTransition);
                }
            }
            else
            {
                // Transition lines now. Defer transitioning document to completed until the inventory voucher has been processed.
                SourceDocumentProcessorFacade::submitSourceDocumentLinesForHeader(vendInvoiceInfoTable, 
                    SourceDocumentLineAccountingStatus::FullyDistributed, caller, curUserId(), doAsynchronousLineTransition);
            }
        }
        else
        {
            const boolean updateImplementationTrue = true;
            sourceDocumentProcessorFacade::submitSourceDocumentImplementation(vendInvoiceInfoTable, updateImplementationTrue, SourceDocumentAccountingStatus::Completed);
        }

        sourceDocumentLinesDistributed = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoHU]))
        {
            this.createDeferredTaxTransactions();
        }
        
        SysTransactionScopeCache::remove(classStr(SourceDocumentLineItem), [#distributionListForDocument, vendInvoiceInfoTable.SourceDocumentHeader]);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProjLedgerStatus</Name>
				<Source><![CDATA[
    protected ProjLedgerStatus getProjLedgerStatus(boolean _multipleContractLinesForProjectFeature, ProjTable _projTable)
    {
        ProjLedgerStatus itemProjLedgerStatus;
        if (_multipleContractLinesForProjectFeature)
        {
            if (!_projTable.ProjInvoiceProjId && ProjPostVendInvoiceWithWFDefLedgerStatusFlight::instance().isEnabled())
            {
                // Internal project, post cost to P/L accounts.
                itemProjLedgerStatus = ProjLedgerStatus::Operations;
            }
            else
            {
                ProjRevenueProfile projRevProfile = ProjRevRecHelper::getRevProfileForTransactionType(_projTable, ProjTransType::Item);
                itemProjLedgerStatus = ProjRevRecHelper::item2LedgerStatus(projRevProfile.ItemLedgerStatus);
            }
        }
        else
        {
            itemProjLedgerStatus = ProjGroup::find(_projTable.ProjGroupId).ItemTransCost;
        }
        return itemProjLedgerStatus;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projLedger</Name>
				<Source><![CDATA[
    protected ProjLedger projLedger(ItemId _itemId = '')
    {
        if (!vendInvoiceInfoLine.isNonPO() && purchLine.isStocked()) //No inventMovement for not stocked
        {
            if (_itemId)
            {
                return ProjLedger::newProjectPurch(purchLine.ProjId,
                                                   purchLine.ProjCategoryId,
                                                   purchLine.InventTransId,
                                                   vendInvoiceJour.InternalInvoiceId,
                                                   inventMovement.projAdjustRefId(),_itemId);
            }
            else
            {
                return ProjLedger::newProjectPurch(purchLine.ProjId,
                                                    purchLine.ProjCategoryId,
                                                    purchLine.InventTransId,
                                                    vendInvoiceJour.InternalInvoiceId,
                                                    inventMovement.projAdjustRefId());
            }
        }
        else
        {
            return null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPhysicalNow</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Calculates the quantity that is being physically updated for the invoiced purchase order line.
    /// </summary>
    /// <returns>
    ///    The quantity that is being physically updated for the invoiced purchase order line.
    /// </returns>
    /// <remarks>
    ///    This method is used for the not stocked order lines.
    /// </remarks>
    protected PurchQty qtyPhysicalNow()
    {
        PurchQty qtyPhysicalNow;
        PurchQty physicalQtyBefore;
        PurchQty financialQtyPosted;

        if (vendInvoiceInfoLine.isNonPO())
        {
            return 0.0;
        }

        physicalQtyBefore = purchLine.receivedInTotal();
        financialQtyPosted = purchLine.invoicedInTotal();

        if (physicalQtyBefore)
        {
            if (vendInvoiceTrans.Qty * purchLine.PurchQty > 0)
            {
                //Not packing slip posted enough if financialQtyPosted is greater than physicalQtyBefore and hence a packing slip update is needed for the difference qty
                //Otherwise no physical updates are needed
                if (vendInvoiceTrans.Qty > 0)
                {
                    qtyPhysicalNow = max(financialQtyPosted - physicalQtyBefore,0);
                }
                else
                {
                    qtyPhysicalNow = min(financialQtyPosted - physicalQtyBefore,0);
                }
            }
            else
            {
                //Not packing slip posted enough if financialQtyPosted exceeds the physicalQtyBefore and hence a negative packing slip is needed for the difference qty
                //Otherwise no physical updates are needed
                qtyPhysicalNow = min(financialQtyPosted - physicalQtyBefore,0);
            }
        }
        else
        {
            qtyPhysicalNow = vendInvoiceTrans.Qty;
        }

        return qtyPhysicalNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>requirePostCustVendAfterLedgerVoucherEnd</Name>
				<Source><![CDATA[
    protected boolean requirePostCustVendAfterLedgerVoucherEnd()
    {
        boolean requirePostCustVendAfterLedgerVoucherEnd;

        if (SourceDocumentCompletionRule::useSingleVoucher() && !isPrePaymentJournalPost)
        {
            requirePostCustVendAfterLedgerVoucherEnd = true;
        }
        else
        {
            requirePostCustVendAfterLedgerVoucherEnd = false;
        }

        return requirePostCustVendAfterLedgerVoucherEnd;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldCopyMultipleDocuRef</Name>
				<Source><![CDATA[
    protected boolean shouldCopyMultipleDocuRef()
    {
        return !ordersPosted.empty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUpdateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether or not the source line should be updated.
    /// </summary>
    /// <returns>true if the source line should be updated; otherwise, false.</returns>
    protected boolean shouldUpdateSourceLine()
    {
        return !vendInvoiceInfoLine.isAdvance();
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceLine</Name>
				<Source><![CDATA[
    protected Common sourceLine()
    {
        if (vendInvoiceInfoLine.isNonPO())
        {
            return vendInvoiceInfoLine;
        }

        return purchLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceTable</Name>
				<Source><![CDATA[
    protected Common sourceTable()
    {
        if (vendInvoiceInfoTable.isNonPO())
        {
            return vendInvoiceInfoTable;
        }

        return purchTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>tax1099</Name>
				<Source><![CDATA[
    protected void tax1099()
    {
        Tax1099Fields tax1099Fields;
        Tax1099FieldsRecId tax1099FieldsId;
        Tax1099Amount tax1099Amount;
        Tax1099State tax1099State;
        Tax1099StateAmount tax1099StateAmount;
        Tax1099BoxDetail tax1099Detail;

        if (isConfigurationkeyEnabled(configurationKeyNum(Tax1099S)) || isConfigurationkeyEnabled(configurationKeyNum(Tax1099G)))
        {
            tax1099Detail = Tax1099BoxDetail::findRecId(purchLine.Tax1099RecId);
            vendInvoiceTrans.Tax1099RecId = vendInvoiceInfoLine.Tax1099BoxDetail;
        }

        tax1099FieldsId = vendInvoiceInfoLine.Tax1099Fields;
        tax1099Amount = vendInvoiceInfoLine.Tax1099Amount;
        tax1099State = vendInvoiceInfoLine.Tax1099State;
        tax1099StateAmount = vendInvoiceInfoLine.Tax1099StateAmount;

        if (tax1099FieldsId || tax1099State)
        {
            if (tax.tmpTaxWorkTrans().TaxDirection == TaxDirection::IncomingTax)
            {
                // The Tax1099Amount needs to include taxes always because this is the amount being paid. Taxes should be included in the Tax1099Amount
                // regardless of whether 'Apply U.S. sales tax and use tax rules' is checked on GL > Setup > Parameters > Sales tax tab.
                tmpTax1099Amount = vendInvoiceTrans.LineAmount
                    - markup.markupCustVend()
                    + tax.totalRegulatedTaxAmountSingleLine(vendInvoiceInfoLine.TableId, vendInvoiceInfoLine.RecId, false,
                        !TaxParameters::find().PurchTaxOnOperations)
                    - vendInvoiceTrans.PSARetainageAmount + vendInvoiceTrans.PSAReleaseAmount;
            }

            tax1099Fields = Tax1099Fields::find(tax1099FieldsId);

            if (tax1099FieldsId)
            {
                //Leave 1099 Amount as zero when S-2 and S-4 is checked (state amount always defaults)
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && tax1099FieldsId == Tax1099Base::findTax1099FieldsRecId(Tax1099S::grossProceeds())
                    && Tax1099BoxDetail::findRecId(purchLine.Tax1099RecId).Tax1099PropertyOrServices == NoYes::Yes)
                {
                    tmpTax1099Amount = 0;
                }
                else
                {
                    tmpTax1099Amount = tax1099Amount == 0 ? tmpTax1099Amount : tax1099Amount;
                }

                if (tax1099FieldsId == Tax1099Base::findTax1099FieldsRecId(Tax1099MISC::stateTaxWithheld())
                    && tmpTax1099Amount != 0)
                {
                    tmpTax1099Amount = 0;
                }

                tax1099Amount = tmpTax1099Amount;
                vendInvoiceTrans.Tax1099Amount = tax1099Amount;
                vendInvoiceTrans.Tax1099Fields = tax1099FieldsId;
                totalTax1099Amount += tax1099Amount;
                firstTax1099Fields = firstTax1099Fields == 0 ? tax1099FieldsId : firstTax1099Fields;
            }

            if (tax1099State)
            {
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector))
                    && tax1099FieldsId == Tax1099Base::findTax1099FieldsRecId(Tax1099G::federalIncomeTaxWithheld()) || ((tax1099Fields.Tax1099Type == Tax1099Type::F1099S) && tax1099Detail.Tax1099PropertyOrServices == NoYes::Yes))
                //Do not default Tax1099Amount on 1099S (zero is an allowed value) or 1099G
                {
                    //leave amount as zero
                    tmpTax1099Amount = tax1099StateAmount;
                }
                else
                {
                    tmpTax1099Amount = tax1099StateAmount == 0 ? tmpTax1099Amount : tax1099StateAmount;
                }

                if (tax1099State == Tax1099MISC::federalIncomeTaxWithheld().tax1099Box && tax1099StateAmount != 0)
                {
                    tax1099StateAmount = 0;
                }

                tax1099StateAmount = tmpTax1099Amount;
                vendInvoiceTrans.Tax1099StateAmount = tax1099StateAmount;
                vendInvoiceTrans.Tax1099State = tax1099State;
                totalTax1099StateAmount += tax1099StateAmount;
                firstTax1099State = firstTax1099State == '' ? tax1099State : firstTax1099State;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tradeCalcTax</Name>
				<Source><![CDATA[
    protected Object tradeCalcTax()
    {
        return PurchCalcTax::construct(this.parmJournalTable(), vendInvoiceInfoTable.ParmId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogTxt</Name>
				<Source><![CDATA[
    protected TransTxt transactionLogTxt()
    {
        return "@SYS25471";
    }

]]></Source>
			</Method>
			<Method>
				<Name>transactionLogType</Name>
				<Source><![CDATA[
    protected TransactionLogType transactionLogType()
    {
        return TransactionLogType::PurchInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetAcquisitionPrice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the value of the <c>AcquisitionPrice</c> field on the related <c>AssetBook</c> table
    /// </summary>
    /// <param name="_assetId">
    ///    The value of the <c>AssetId</c> field of the <c>AssetBook</c> record and the <c>AssetDepBook</c>
    ///    record to update
    /// </param>
    /// <param name="_assetBookId">
    ///    The value of the <c>BookId</c> field of the <c>AssetBook</c> record to update
    /// </param>
    /// <param name="_lineAmount">
    ///    The value to which to update the <c>AcquisitionPrice</c> field.
    /// </param>
    protected void updateAssetAcquisitionPrice(AssetId _assetId, AssetBookIdPurchSalesInvent _assetBookId,
        PurchLineAmount _lineAmount)
    {
        AssetBook assetBook;
        boolean isAutomaticPostingToFA = AssetParameters::find().AssetAllowAcqPostingPO;

        // Update the asset book
        update_recordset assetBook
            setting AcquisitionPrice = assetBook.AcquisitionPrice + _lineAmount, // Price is incremented to support multi-invoice scenario.
            VendAccount = vendInvoiceJour.InvoiceAccount
            where assetBook.AssetId == _assetId
            && (assetBook.Status == AssetStatus::NoAcquisition
            || (!isAutomaticPostingToFA && assetBook.Status == AssetStatus::Open))
            && assetBook.BookId == _assetBookId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetFiscalEstablishment_BR</Name>
				<Source><![CDATA[
    private void updateAssetFiscalEstablishment_BR()
    {
        AssetTable assetTable;

        FiscalEstablishmentRecId_BR fiscalEstablishmentRecId;

        if (vendInvoiceInfoLine_Asset.AssetId)
        {
            fiscalEstablishmentRecId = vendInvoiceInfoLine.inventDim().inventSite().fiscalEstablishment().RecId;

            update_recordset assetTable setting FiscalEstablishment_BR = fiscalEstablishmentRecId
                where assetTable.AssetId == vendInvoiceInfoLine_Asset.AssetId
                    && assetTable.FiscalEstablishment_BR == 0;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAssetPurchLineRecId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>PurchLineRecID</c> field.
    /// </summary>
    /// <param name="_purchLineRecId">
    ///    The ID to which to set the <c>PurchLineRecId</c> field.
    /// </param>
    /// <param name="_assetId">
    ///    The ID of the asset to update.
    /// </param>
    protected void updateAssetPurchLineRecId(PurchLineRefRecId _purchLineRecId, AssetId _assetId)
    {
        AssetTable assetTable;

        if ((_purchLineRecId) && (_assetId))
        {
            update_recordset assetTable setting PurchLineRecId = _purchLineRecId
                where assetTable.AssetId == _assetId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBankLC</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the Letter of Credit after the journal is posted.
    /// </summary>
    private void updateBankLC()
    {
        BankLCImportType bankLCImportType;

        if (!vendInvoiceInfoTable.isNonPO()
            && BankLCImportFeatureChecker::checkBankLCImportEnabled()
            && vendInvoiceInfoTable.BankLCImportLine != 0)
        {
            bankLCImportType = BankLCImportType::constructByPurchId(vendInvoiceInfoTable.PurchId, true, true);
            bankLCImportType.updateInvoicePosted(vendInvoiceInfoTable.BankLCImportLine);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCrossdocking</Name>
				<Source><![CDATA[
    protected void updateCrossdocking()
    {
        // Transfer orders, sales orders and intercompany purchase orders may be created during updating cross docking.
        RetailReplenishmentTransferOrder::checkOrCreateTransferOrder(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustomsVendBOETrans_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///Updates the remaining qty field of CustomsVendBOETrans_IN table once invoicing is done.
    /// </summary>
    /// <param name="_customsVendBOETransRecID">
    /// The value to set.
    /// </param>
    /// <param name="_receiveNow">
    /// The value to set.
    /// </param>
    public void updateCustomsVendBOETrans_IN(RecId _customsVendBOETransRecID, PurchQty _receiveNow)
    {
        CustomsVendBOETrans_IN customsVendBOETrans;
        boolean moreLines;
        PurchQty qty, receiveNowLoc;
        boolean needTweakStatus = false;

        receiveNowLoc = _receiveNow;

        ttsbegin;
        select forupdate customsVendBOETrans
            order by BillOfEntryDate
            where customsVendBOETrans.RecId == _customsVendBOETransRecID;

        if (customsVendBOETrans)
        {
            if (receiveNowLoc != 0)
            {
                qty = customsVendBOETrans.RemainingQty - receiveNowLoc;
                if (customsVendBOETrans.RemainingQty == customsVendBOETrans.BillOfEntryQty
                || qty <= 0)
                    needTweakStatus = true;

                if (qty >= 0 && !moreLines)
                {
                    customsVendBOETrans.RemainingQty = customsVendBOETrans.RemainingQty - receiveNowLoc;
                    customsVendBOETrans.update();
                }
                else //Invoiced qty is more than the current Trans qty.
                {
                    moreLines = true;
                    qty = customsVendBOETrans.RemainingQty - receiveNowLoc;
                    if (qty < 0)
                    {
                        receiveNowLoc = receiveNowLoc - customsVendBOETrans.RemainingQty;
                        customsVendBOETrans.RemainingQty = 0;
                        customsVendBOETrans.update();
                    }
                    else if (qty == 0)
                    {
                        customsVendBOETrans.RemainingQty = 0;
                        customsVendBOETrans.update();
                        receiveNowLoc = 0;
                    }
                    else
                    {
                        customsVendBOETrans.RemainingQty = customsVendBOETrans.RemainingQty - receiveNowLoc;
                        customsVendBOETrans.update();
                        receiveNowLoc = 0;
                    }
                }
                // check and tweak related BOE journal status
                if (needTweakStatus)
                    CustomsBOEJournalFacade_IN::tweakBOEJourInvoiceStatus(customsVendBOETrans.CustomsBillOfEntryJournal_IN);
            }
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDate</Name>
				<Source><![CDATA[
    protected TransDate updateDate()
    {
        return vendInvoiceInfoTable.updateDate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalLine</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected void updateJournalLine()
    {
        CustomsVendInvoiceBOETransLink_IN customsVendInvoiceBOETransLink;
        VendInvoiceInfoLine vendInvoiceInfoLineCopy;
        boolean isMatchedPackingSlipInquiryEnabled;
        VendPackingSlipTrans vendPackingSlipTransLoc;
        VendInvoiceInfoSubLine vendInvoiceInfoSubLineLoc;

        vendInvoiceTrans.QtyPhysical = invoiceUpdatedOnly;
        vendInvoiceTrans.InventQty = updateNowInvent;

        vendInvoiceTrans.PartDelivery = !(purchLine.isInvoiced() && purchLine.PurchQty == vendInvoiceTrans.Qty);
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]))
        {
            if (purchLine.RecId != 0)
            {
                if (TaxWithholdParameters_IN::find().tdsActivate
                    || TaxWithholdParameters_IN::find().tcsActivate)
                {
                    vendInvoiceTrans.TaxAmount = tax.totalTaxAmountSingleLine(vendInvoiceInfoLine.TableId,vendInvoiceInfoLine.RecId);
                }
            }
        }

        if (TaxGSTProjAdvancedJournalUtils::isTaxSolutionEnabledForProjOps_IN())
        {
            vendInvoiceTrans.TaxAmount = this.getTaxAmountGTE();
        }

        isMatchedPackingSlipInquiryEnabled = TaxParameters::checkTaxParameters_IN()
                                             && isConfigurationkeyEnabled(configurationKeyNum(LedgerBasic))
                                             && VendParameters::find().MatchedPackingSlipsInquiry;

        boolean isTransactionRelatedToBOE_IN;

        if (TaxParameters::isCustomsEnable_IN() && VendDocumentLineMap::isTransactionRelatedToBOE_IN(purchLine.purchTable(), this.parmPurchParmUpdate()))
        {
            isTransactionRelatedToBOE_IN = true;
        }

        boolean isProjectConfigurationEnabled = isConfigurationkeyEnabled(configurationKeyNum(Project));

        if (isTransactionRelatedToBOE_IN ||
            isMatchedPackingSlipInquiryEnabled ||
            isProjectConfigurationEnabled)
        {
            vendInvoiceInfoLineCopy = VendInvoiceInfoLine::findSourceDocumentLine(vendInvoiceTrans.SourceDocumentLine);
        }

        // Populate the <c>VendInvoiceTransLinkTable</c>
        if (isTransactionRelatedToBOE_IN &&
            vendInvoiceInfoLineCopy)
        {
            customsVendInvoiceBOETransLink.CustomsVendBOETrans_IN =
                VendDocumentLineMap::getCustomsVendBOETrans_IN(vendInvoiceInfoLineCopy.RecId,
                                                               vendInvoiceInfoLineCopy.ParmId,
                                                               vendInvoiceInfoLineCopy.TableId).RecId;

            customsVendInvoiceBOETransLink.VendInvoiceTrans = vendInvoiceTrans.RecId;
            customsVendInvoiceBOETransLink.InvoiceId = vendInvoiceJour.InvoiceId;
            customsVendInvoiceBOETransLink.PurchTable = vendInvoiceJour.PurchId;
            customsVendInvoiceBOETransLink.InvoiceDate = vendInvoiceJour.InvoiceDate;
            customsVendInvoiceBOETransLink.VendTable = purchLine.orderAccount();
            customsVendInvoiceBOETransLink.insert();

            this.updateCustomsVendBOETrans_IN(customsVendInvoiceBOETransLink.CustomsVendBOETrans_IN, vendInvoiceTrans.Qty);
        }

        if (isMatchedPackingSlipInquiryEnabled)
        {
            update_recordset vendPackingSlipTransLoc
                setting InvoiceTransRefRecId = vendInvoiceTrans.RecId
                    join vendPackingSlipTransLoc
                    join JournalRefTableId, JournalRefRecId from vendInvoiceInfoSubLineLoc
                        where vendPackingSlipTransLoc.TableId == vendInvoiceInfoSubLineLoc.JournalRefTableId
                        && vendPackingSlipTransLoc.RecId == vendInvoiceInfoSubLineLoc.JournalRefRecId
                        && vendInvoiceInfoSubLineLoc.LineRefRecId == vendInvoiceInfoLineCopy.RecId;
        }

        if (vendInvoiceJour.Proforma)
        {
            // proforma documents will be deleted after printing the report, we do not want the delete action to
            // remove SourceDocument* and associated records from the VendInvoiceInfo* records.
            vendInvoiceTrans.SourceDocumentLine = 0;
        }

        if (isProjectConfigurationEnabled)
        {
            vendInvoiceTrans.psaReleaseAmount = vendInvoiceInfoLine.psaReleaseAmount;
            vendInvoiceTrans.psaRetainageAmount = vendInvoiceInfoLine.psaRetainageAmount;

            totalRetainedAmount += vendInvoiceInfoLine.psaRetainageAmount;

            if (vendInvoiceInfoLine.psaReleaseAmount)
            {
                totalRetainedAmount -= vendInvoiceInfoLine.psaReleaseAmount;
            }
        }

        vendInvoiceTrans.write();

        if (isProjectConfigurationEnabled)
        {
            if (purchLine.ProjId)
            {
                // Update the references for ProjItemTrans created out of packing slips
                // from item requirements
                ProjItemTrans projItemTrans;
                SalesLine salesLine;
                PurchLine purchLine_ItemReq;

                ttsbegin;
                while select forupdate projItemTrans
                    where projItemTrans.VendInvoiceTransRecId == 0
                    exists join salesLine
                        where salesLine.InventTransId == projItemTrans.InventTransId
                    exists join purchLine_ItemReq
                        where purchLine_ItemReq.InventRefTransId == projItemTrans.InventTransId
                           && purchLine_ItemReq.InventTransId == vendInvoiceTrans.InventTransId
                           && (purchLine_ItemReq.PurchId == vendInvoiceTrans.PurchId
                           || purchLine_ItemReq.PurchId == vendInvoiceTrans.OrigPurchId)
                {
                    // If packing slip reference is present in <c>projItemTrans</c> table with respect to the vendor packing slip,
                    // update should only be done to related record.
                    if (projItemTrans.PackingSlipId)
                    {
                        select firstonly PackingSlipId from vendPackingSlipTransLoc
                            exists join vendInvoiceInfoSubLineLoc
                                 where vendInvoiceInfoSubLineLoc.JournalRefTableId == vendPackingSlipTransLoc.TableId
                                   && vendInvoiceInfoSubLineLoc.JournalRefRecId == vendPackingSlipTransLoc.RecId
                                   && vendInvoiceInfoSubLineLoc.LineRefRecId == vendInvoiceInfoLineCopy.RecId;
                    }

                    if (!projItemTrans.PackingSlipId || (vendPackingSlipTransLoc.PackingSlipId && projItemTrans.PackingSlipId == vendPackingSlipTransLoc.PackingSlipId))
                    {
                        projItemTrans.VendInvoiceTransRecId = vendInvoiceTrans.RecId;
                        projItemTrans.update();
                    }
                }
                ttscommit;
            }
        }

        this.insertCreditInvoicingTrans(purchLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNoteTypeForInvoiceJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks for the vendor invoice journal note type.
    /// </summary>
    /// <returns>
    /// true if not blank; otherwise, false.
    /// </returns>
    protected boolean checkNoteTypeForInvoiceJournal()
    {
        return vendInvoiceJour.vendInvoiceJour_W().NoteType_MY != NoteType_MY::Blank;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>VendInvoiceJour</c> buffer with post invoice information.
    /// </summary>
    protected void updateJournalTable()
    {
        CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::construct();

        boolean checkStatus = false;

        vendInvoiceJour.initFromPurchTotals(purchTotals);

        // <GMY>
        if (TaxGSTFeatureChecker_MY::isCountryRegionMY())
        {
            if (this.checkNoteTypeForInvoiceJournal())
            {
                if (purchTable && !purchTable.ReasonTableRef)
                {
                    throw error("@SYP4860740");
                }
                else if (!purchTable)
                {
                    VendInvoiceInfoLine vendInvoiceInfoLineLocal;
                    select firstonly RecId from vendInvoiceInfoLineLocal
                        where vendInvoiceInfoLineLocal.TableRefId == vendInvoiceInfoTable.TableRefId
                            && vendInvoiceInfoLineLocal.parmid == vendInvoiceInfoTable.parmid
                            && !vendInvoiceInfoLineLocal.ReasonTableRef;

                    if (vendInvoiceInfoLineLocal)
                    {
                        throw error("@SYP4860740");
                    }
                }
            }
        }
        // </GMY>

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            while select purchLine
                where purchLine.PurchId == purchTable.PurchId
            {
                if (purchLine.purchLine_IN().tdsGroup && !checkStatus)
                {
                    checkStatus = true;
                }
            }
            if (checkStatus)
            {
                withholdingTax = - withholdingTax;
            }
            vendInvoiceJour.TaxWithholdAmount_IN = withholdingTax;
        }

        if (vendInvoiceJour.Proforma)
        {
            // proforma documents will be deleted after printing the report, we do not want the delete action to
            // remove SourceDocument* and associated records from the VendInvoiceInfo* records.
            vendInvoiceJour.SourceDocumentHeader = 0;
            vendInvoiceJour.SourceDocumentLine = 0;
        }

        if (isConfigurationkeyEnabled(configurationKeyNum(Project))
           && totalRetainedAmount)
        {
            currencyExchangeHelper.parmLedgerRecId(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId));
            vendInvoiceJour.InvoiceAmount -= totalRetainedAmount;
            vendInvoiceJour.InvoiceAmountMST -= currencyExchangeHelper.calculateTransactionCurrencyToReportingCurrency(vendInvoiceJour.purchTable().CurrencyCode,totalRetainedAmount);
        }
        vendInvoiceJour.write();

        this.insertCreditInvoicingJour(purchTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProduction</Name>
				<Source><![CDATA[
    protected void updateProduction(InventQty _qtyUpdateNow)
    {
        if (purchLine.InventRefId && purchLine.ItemRefType == InventRefType::ProdLine)
        {
            ProdBOM prodBOM = ProdBOM::findTransId(purchLine.InventRefTransId);

            if (prodBOM)
            {
                if (isPostVendorProdBOMInOrderFeatureEnabled)
                {
                    postVendorProdBOMHelper.addProdBOM(prodBOM, this.updateDate(), _qtyUpdateNow, purchLine);
                }
                else
                {
                    prodBOM.postVendorProdBOM(this.updateDate(), _qtyUpdateNow, purchLine);
                    prodBOM.postVendorProdRoute(this.updateDate(), _qtyUpdateNow, purchLine);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>endLines</Name>
				<Source><![CDATA[
    protected void endLines()
    {
        if (isPostVendorProdBOMInOrderFeatureEnabled)
        {
            postVendorProdBOMHelper.postProdBOM();
            postVendorProdBOMHelper.postProdRoute();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectJournal</Name>
				<Source><![CDATA[
    protected void updateProjectJournal(InventQty _inventQtyUpdateNow)
    {
        InventJournalTrans inventJournalTrans;

        if (purchLine.ProjId 
            && purchLine.InventRefTransId
            && !purchLine.purchTable().isProjectSalesItemReqPO()
            && !purchLine.getProjCreditNoteSource().purchTable().isProjectSalesItemReqPO())
        {
            select firstonly forupdate inventJournalTrans
                index hint TransIdIdx
                where inventJournalTrans.InventTransId == purchLine.InventRefTransId;

            if (inventJournalTrans && !inventJournalTrans.inventJournalTable().Posted && inventJournalTrans.Qty <= _inventQtyUpdateNow + purchLine.receivedInventInTotal())
            {
                inventJournalTrans.TransDate = this.updateDate();
                inventJournalTrans.update();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjectLedgerUpdates</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>PaymentDate</c> field in the <c>ProjTransPosting</c> record for never ledger
    ///    postings.
    /// </summary>
    /// <param name="_vendTrans">
    ///    A <c>VendTrans</c> table buffer.
    /// </param>
    /// <remarks>
    ///    The <c>PaymentDate</c> field is used to calculate project cash flow.
    /// </remarks>
    protected void updateProjectLedgerUpdates(VendTrans _vendTrans)
    {
        ProjTransPosting projTransPosting;

        if (purchTable.ProjId && !purchTable.isProjectSalesItemReqPO() && _vendTrans.TransType == LedgerTransType::Purch)
        {
            update_recordset projTransPosting
                setting PaymentDate = _vendTrans.DueDate
                    where projTransPosting.PostingType == LedgerPostingType::ProjNeverLedger &&
                            projTransPosting.Voucher == _vendTrans.Voucher &&
                            projTransPosting.LedgerTransDate == _vendTrans.TransDate;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesLine</Name>
				<Source><![CDATA[
    protected void updateSalesLine(PurchLine _purchLine, PurchQty _salesUpdateQty)
    {
        SalesLine salesLine;

        if (!_salesUpdateQty)
            return;

        if (!purchLine)
            return;

        salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId, true);

        if (!salesLine)
            return;

        updateSalesLinesQuery.query().dataSourceTable(tableNum(SalesLine)).addRange(fieldNum(SalesLine,InventTransId)).value(queryValue(purchLine.InventRefTransId));

        salesLine.SalesDeliverNow += _salesUpdateQty;
        salesLine.setInventDeliverNow();
        salesLine.doUpdate();

        updateSalesLines = true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSalesTable</Name>
				<Source><![CDATA[
    protected void updateSalesTable(SysQueryRun _updateSalesLinesQuery)
    {
        SalesFormLetter salesFormLetter;
        salesFormLetter = SalesFormLetter::construct(DocumentStatus::PackingSlip);

        salesFormLetter.parmIdSynched(purchParmUpdate.ParmId);
        salesFormLetter.chooseLinesQuery(_updateSalesLinesQuery);
        salesFormLetter.transDate(this.updateDate());
        salesFormLetter.specQty(SalesUpdate::DeliverNow);
        salesFormLetter.creditRemaining(true);
        salesFormLetter.printFormLetter (this.parmPrintSalesFormLetter());
        salesFormLetter.createParmUpdateFromParmUpdateRecord(SalesFormletterParmData::initSalesParmUpdateFormletter(DocumentStatus::PackingSlip,salesFormLetter.pack()));
        salesFormLetter.chooseLines(false,true);
        salesFormLetter.reArrangeNow(false);

        salesFormLetter.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatePurchLineRemainingAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the <c>PurchLine</c> remaining quantities, based on the values of the current invoice line.
    /// </summary>
    protected void populatePurchLineRemainingAmounts()
    {
        purchLine.RemainPurchPhysical = vendInvoiceInfoLine.RemainAfter;
        purchLine.RemainPurchFinancial += invoiceUpdatedOnly;

        PurchQty subLineQty = vendInvoiceInfoLine.purchQtyMatched();

        if (abs(vendInvoiceTrans.Qty) < abs(subLineQty))
        {
            purchLine.RemainPurchFinancial -= subLineQty;
        }
        else
        {
            purchLine.RemainPurchFinancial -= vendInvoiceTrans.Qty;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the source line.
    /// </summary>
    protected void updateSourceLine()
    {
        #ISOCountryRegionCodes
        SalesLine salesLine;
        PurchLineType purchLineType;
        PurchLine purchLineOrderLine;
        PurchLineAmount lineAmount;

        if (!this.shouldUpdateSourceLine())
        {
            return;
        }

        if (vendInvoiceInfoLine.isNonPO())
        {
            lineAmount = vendInvoiceInfoLine.LineAmount;
        }
        else
        {
            // Read the PO line for update as it is updated at the end of this method
            Debug::assert(purchLine.RecId != 0);
            purchLine = PurchLine::findRecId(purchLine.RecId, true);

            if (purchLine.isDropShipment())
            {
                salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId);

                qtyDeliveredNoInvoice = salesLine.deliveredInTotal() - purchLine.invoicedInTotal() + vendInvoiceInfoLine.ReceiveNow;

                // if more has already been delivered than invoiced, adjust the sales update quantity,
                // that is discount with items already delivered but not yet invoiced
                if (vendInvoiceInfoLine.ReceiveNow > 0)
                {
                    salesUpdateQty = vendInvoiceInfoLine.ReceiveNow - qtyDeliveredNoInvoice > 0 ? vendInvoiceInfoLine.ReceiveNow - qtyDeliveredNoInvoice : 0 ;
                }
                else
                {
                    salesUpdateQty = vendInvoiceInfoLine.ReceiveNow - qtyDeliveredNoInvoice < 0 ? vendInvoiceInfoLine.ReceiveNow - qtyDeliveredNoInvoice : 0 ;
                }

                this.updateSalesLine(purchLine, salesUpdateQty);
            }

            this.updateProjectJournal(updateNowInvent);

            if (vendInvoiceInfoLine.InventNow)
                this.updateProduction(vendInvoiceInfoLine.InventNow);

            purchValueMap.insert(purchLine.RecId, purchLine.Tax1099Amount);

            if (vendInvoiceInfoTable.PurchId != vendInvoiceInfoLine.OrigPurchId)
            {
                this.updateSpecTransForNewPurchId();
                this.updateSumPurchId();
            }

            purchLineType = purchLine.type();

            if (!purchLine.isStocked())
            {
                this.populatePurchLineRemainingAmounts();
            }

            if (purchLine.isDropShipment() && vendInvoiceInfoLine.Closed)
            {
                this.syncSalesLineRemPhysicalQty(purchLine);
            }

            purchLineType.updatePurchLine(inventMovement ? inventMovement.transIdSum() : null);

            switch (purchLineType.parmStatusUpdateResults())
            {
                case PurchStatus::Invoiced:
                    checkFailed("@SYS113195"); //Status was not changed to Invoiced because one or more pending invoices exist.
                    break;
                case PurchStatus::Canceled:
                    checkFailed("@SYS113196"); //Status was not changed to Canceled because one or more pending invoices exist.
                    break;
            }

            lineAmount = purchLine.LineAmount;

            vendInvoiceInfoLine_Asset = VendInvoiceInfoLine_Asset::findByVendInvoiceInfoLineRecId(vendInvoiceInfoLine.RecId);
            
            if (vendInvoiceInfoLine_Asset.AssetId != "")
            {
                this.updateAssetPurchLineRecId(purchLine.RecId, vendInvoiceInfoLine_Asset.AssetId);
            }

            // The 1099 amount on the purchLine should be set to zero after each invoice.
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoUS]))
            {
                purchLine.Tax1099Amount = 0;
                purchLine.Tax1099StateAmount = 0;
            }

            purchLine.IsInvoiceMatched = NoYes::Yes;
            if (isConfigurationkeyEnabled(configurationKeyNum(Project)))
            {
                purchLine.psaTotalRetainAmount += vendInvoiceInfoLine.psaRetainageAmount;

                if (vendInvoiceInfoLine.psaReleaseAmount)
                {
                    purchLine.psaTotalRetainAmount -= vendInvoiceInfoLine.psaReleaseAmount;
                }
            }

            if (PurchUpdateFromJournalPostFlight::instance().isEnabled())
            {
                using (var purchLineSkipBusinessLogicContext = PurchLineSkipBusinessLogicContext::construct())
                {
                    purchLineSkipBusinessLogicContext.parmSkipUpdate(true);
                    purchLine.update();
                }
            }
            else
            {
                purchLine.doUpdate();
            }
        }

        this.processFixedAssetTransaction();

        if (purchLine.LineDeliveryType == LineDeliveryType::DeliveryLine)
        {
            purchLineOrderLine = PurchDeliverySchedule::findOrderLineForDeliveryLine(purchLine.InventTransId, true);
            purchLineOrderLine.setPurchStatus();
            purchLineOrderLine.doUpdate();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>processFixedAssetTransaction</Name>
				<Source><![CDATA[
    private void processFixedAssetTransaction()
    {
        RecId assetTransRecId;

        // Update asset acquisition price and post asset for either non-PO or PO-based line; if not already posted to
        if ((vendInvoiceInfoLine_Asset.AssetId != "") &&
            (vendInvoiceInfoLine_Asset.AssetTransTypePurch == AssetTransTypePurch::Acquisition
            || vendInvoiceInfoLine_Asset.AssetTransTypePurch == AssetTransTypePurch::AcquisitionAdj))
        {
            if (BrazilParameters::isEnabled())
            {
                this.updateAssetFiscalEstablishment_BR();
            }

            // <GIN>
            if (loadOnInventoryExisted
                && TaxParameters::checkTaxParameters_IN())
            {
                this.updateAssetAcquisitionPrice(
                    vendInvoiceInfoLine_Asset.AssetId,
                    vendInvoiceInfoLine_Asset.AssetBookId,
                    purchValue);
            }
            // </GIN>
            else
            {
                // If the acquisition posting into FA is disabled with the AP posting, update the acquisition price.
                if (!AssetParameters::find().AssetAllowAcqPostingPO
                    // <GTE>
                    || TaxSolutionScopeIntegrationUtil::isCompanyEnabled()
                    // </GTE>
                    )
                {
                    AssetAcquisitionPrice acquisitionPrice = this.calcAssetAcquisitionPrice(vendInvoiceInfoLine.LineAmount);

                    this.updateAssetAcquisitionPrice(
                        vendInvoiceInfoLine_Asset.AssetId,
                        vendInvoiceInfoLine_Asset.AssetBookId,
                        acquisitionPrice);
                }
            }
        }
        
        if (vendInvoiceInfoLine.isNonPO() || !purchLine.isStocked())
        {
            if (this.mustPostAssetForVendorInvoiceInfoLine())
            {
                AssetPost assetPost = AssetPost::newVendInvoiceTrans(ledgerVoucher, vendInvoiceTrans, vendInvoiceJour, vendInvoiceInfoLine_Asset, this.tax());
                if (!assetPost.check())
                {
                    throw error("@SYS21628");
                }
                assetPost.post();

                // Post attached asset document
                if (AssetDocumentUtility_JP::isAssetDocumentEnabled())
                {
                    this.postAssetByDocument_JP(ledgerVoucher, null, vendInvoiceInfoLine_Asset, vendInvoiceJour, vendInvoiceTrans);
                }

                assetTransRecId = assetPost.parmMainBookAssetTransRecId();
            }
        }
        
        if (vendInvoiceInfoLine_Asset.RecId != 0)
        {
            AssetTransVendInvoiceTrans::createAssetTransVendInvoiceTrans(
                vendInvoiceInfoLine_Asset,
                vendInvoiceJour.LedgerVoucher,
                vendInvoiceJour,
                vendInvoiceTrans);

            // Fixed asset transactions originated from stocked items are generated by InventMov_Purch.postFixedAsset()
            // which is executed before this method is called. Find the RecId of the AssetTrans record.
            if (assetTransRecId == 0 
                && purchLine.isStocked()
                && !vendInvoiceInfoLine.isNonPO())
            {
                AssetTrans assetTransPosted;
                select firstonly RecId from assetTransPosted
                order by RecId desc
                where assetTransPosted.AssetId == vendInvoiceInfoLine_Asset.AssetId
                    && assetTransPosted.BookId == vendInvoiceInfoLine_Asset.AssetBookId
                    && assetTransPosted.Voucher == vendInvoiceJour.LedgerVoucher
                    && assetTransPosted.TransDate == vendInvoiceJour.InvoiceDate
                    && assetTransPosted.TransType ==
                        AssetPost::assetTransTypePurch2AssetTransType(vendInvoiceInfoLine_Asset.AssetTransTypePurch);
                assetTransRecId = assetTransPosted.RecId;
            }

            if (assetTransRecId)
            {
                AssetTransVendInvoiceTrans assetTransVendInvoiceTrans;
                update_recordset assetTransVendInvoiceTrans
                    setting AssetTrans = assetTransRecId
                    where assetTransVendInvoiceTrans.VendInvoiceTrans == vendInvoiceTrans.RecId;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceLineBeforePosting</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs updates that are to be done before posting, on the <c>PurchLine</c> table.
    /// </summary>
    /// <remarks>
    /// Creates the fixed asset, if asset is to be created for the line; and updates the line with asset
    /// details.
    /// </remarks>
    protected void updateSourceLineBeforePosting()
    {
        //Exit the method if there is an Advance
        if (vendInvoiceInfoLine.isAdvance())
        {
            return;
        }

        //Create the fixed asset and update the VendInvoiceInfoLine.
        vendInvoiceInfoLine_Asset = VendInvoiceInfoLine_Asset::findByVendInvoiceInfoLineRecId(vendInvoiceInfoLine.RecId, true);

        if ((vendInvoiceInfoLine_Asset.CreateFixedAsset == NoYes::Yes)
            && (AssetParameters::find().AssetAllowCreate == NoYes::Yes)
            && (vendInvoiceInfoLine.ReceiveNow > 0))
        {
            this.createFixedAsset(vendInvoiceInfoLine, vendInvoiceInfoLine_Asset);
        }
        else if (purchLine.AssetId != strMin())
        {
            PurchLine::updateFixedAssetWithPurchRecId(purchLine.RecId, purchLine.AssetId);
        }

        if (vendInvoiceInfoLine.isNonPO())
        {
            return;
        }

        // Read the PO line for update as it is updated at the end of this method
        Debug::assert(purchLine.RecId != 0);
        purchLine = PurchLine::findRecId(purchLine.RecId, true);

        purchLine.initFromPurchParmLine_Asset(vendInvoiceInfoLine_Asset);

        if (purchLine.orig().AssetId != purchLine.AssetId)
        {
            purchLine.assetUpdateInventTrans();
        }

        purchLine.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourcePrepayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates source vendor invoice prepayment.
    /// </summary>
    protected void updateSourcePrepayment()
    {
        SetEnumerator se = ordersPosted.getEnumerator();
        VendInvoiceInfoTable prepayVendInvoiceInfoTable;
        VendInvoiceInfoLine prepayApplVendInvoiceInfoLine;

        ttsbegin;
        while (se.moveNext())
        {
            purchTable = PurchTable::find(se.current(),true);
            if (purchTable)
            {
                purchTable.updateDocumentStatus(this.documentStatus());
                purchTable.updateBackStatus();
                purchTable.updatePurchaseType();

                prepayVendInvoiceInfoTable = VendInvoiceInfoTable::findPurchId(purchTable.PurchId, vendInvoiceInfoTable.ParmId);

                if (prepayVendInvoiceInfoTable.isAdvance())
                {
                    PurchPrepayTable::updateAmounts(prepayVendInvoiceInfoTable.PurchId, false);
                }
                else
                {
                    VendInvoiceInfoTable::deletePendingPrepayments(purchTable.PurchId);

                    PurchPrepayTable::reverseUnpaidPostedAdvances(purchTable.PurchId, true);

                    //prepayment application line amount if any in current invoice
                    select sum(LineAmount) from prepayApplVendInvoiceInfoLine
                        where prepayApplVendInvoiceInfoLine.ParmId == prepayVendInvoiceInfoTable.ParmId &&
                        prepayApplVendInvoiceInfoLine.TableRefId == prepayVendInvoiceInfoTable.TableRefId &&
                        prepayApplVendInvoiceInfoLine.LineType == PurchInvoiceLineType::AdvanceApplication;

                    if (purchTable.isInvoiced())
                    {
                        PurchPrepayTable::checkApplicationRemaining(prepayVendInvoiceInfoTable.PurchId, prepayVendInvoiceInfoTable.InvoiceAccount, abs(prepayApplVendInvoiceInfoLine.LineAmount));
                    }
                }
                sourceTableRecIdSet.add(purchTable.RecId);
            }
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSourceTable</Name>
				<Source><![CDATA[
    protected void updateSourceTable()
    {
        if (this.requirePostCustVendAfterLedgerVoucherEnd())
        {
            // Do not update prepayment because it requires VendTrans to be created
            return;
        }
        else
        {
            this.updateSourcePrepayment();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSpecTransForNewPurchId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates a <c>SpecTrans</c> table record to reference the purchase order.
    /// </summary>
    protected void updateSpecTransForNewPurchId()
    {
        PurchTable origPurchTable;
        SpecTrans updateSpecTrans;

        origPurchTable = vendInvoiceTrans.purchLine().purchTable();

        if (origPurchTable.RecId != 0 &&
            this.checkSettlementVoucher(origPurchTable) &&
            origPurchTable.RecId != purchTable.RecId)
        {
            // SpecTrans records exist and point to the original purch table. Update SpecTrans records to reference
            // the new purch table for the Spec reference so they will be settled when this new purch invoice is posted.
            update_recordset updateSpecTrans
                setting SpecRecId = purchTable.RecId
                where updateSpecTrans.SpecCompany == origPurchTable.company() &&
                    updateSpecTrans.SpecTableId == tableNum(PurchTable) &&
                    updateSpecTrans.SpecRecId == origPurchTable.RecId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSettlementVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks the settlement voucher type.
    /// </summary>
    /// <param name = "_origPurchTable">
    ///     A <c>PurchTable</c> table buffer.
    /// </param>
    /// <returns>
    ///     true if the settlement voucher type is selectedTransact; otherwise, false.
    /// </returns>
    protected boolean checkSettlementVoucher(PurchTable _origPurchTable)
    {
        return (_origPurchTable.SettleVoucher == SettlementType::SelectedTransact);
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSumPurchId</Name>
				<Source><![CDATA[
    protected void updateSumPurchId()
    {
        PurchTable localPurchTable;

        if (!vendInvoiceInfoLine.isNonPO() && PurchTable::exist(vendInvoiceInfoLine.OrigPurchId))
        {
            ttsbegin;

            localPurchTable = PurchTable::find(vendInvoiceInfoLine.OrigPurchId, true);

            if (localPurchTable)
            {
                localPurchTable.updateBackStatus();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateProjTaxGroups_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates project tax groups.
    /// </summary>
    /// <returns>
    /// Returns true if valid, otherwise false.
    /// </returns>
    protected boolean validateProjTaxGroups_IN()
    {
        boolean ret = true;

        VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project;
        vendInvoiceInfoLine_Project = VendInvoiceInfoLine_Project::findByVendInvoiceInfoLineRefRecId(vendInvoiceInfoLine.RecId);
        if (vendInvoiceInfoLine_Project.ProjTaxGroupId && vendInvoiceInfoLine_Project.ProjTaxItemGroupId)
        {
            if (TaxItemGroupHeading::find(vendInvoiceInfoLine_Project.ProjTaxItemGroupId).ReverseChargePercentage_IN)
            {
                ret = checkFailed("@SYS4002410");
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>writeTaxAmount_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates and writes tax amount fields of vendor invoice trans.
    /// </summary>
    protected void writeTaxAmount_W()
    {
        VendInvoiceTrans trans;
        FormletterProformaPrint formletterProformaPrint;
        VendInvoiceInfoLine sourceVendInvoiceInfoLine;

        if (! SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            return;

        if (! TaxParameters::find().TaxSpecifyLine)
            return;

        formletterProformaPrint = FormletterProformaPrint::construct();
        formletterProformaPrint.parmTax (this.tax());
        formletterProformaPrint.parmExchRate_W (this.exchRate_W());
        formletterProformaPrint.parmExchRateSec_W (this.exchRateSec_W());
        //    formletterProformaPrint.writeTmpTaxWorkTrans(vendInvoiceJour.RecId);
        formletterProformaPrint.parmJournalTmpTaxWorkTrans(journalTmpTaxWorkTrans);

        TmpTaxWorkTrans tmpTaxWorkTransLocal;
        tmpTaxWorkTransLocal = formletterProformaPrint.tmpTaxWorkTrans(vendInvoiceJour.RecId);

        while select forupdate trans
            where trans.PurchID == vendInvoiceJour.PurchId &&
                  trans.InvoiceId == vendInvoiceJour.InvoiceId &&
                  trans.InvoiceDate == vendInvoiceJour.InvoiceDate &&
                  trans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId &&
                  trans.NumberSequenceGroup == vendInvoiceJour.NumberSequenceGroup
        {
            select RecId from sourceVendInvoiceInfoLine
                where sourceVendInvoiceInfoLine.SourceDocumentLine == trans.SourceDocumentLine;

            trans.initFromTaxWorkTrans_RU(
                tmpTaxWorkTransLocal,
                tableNum(VendInvoiceInfoLine),
                sourceVendInvoiceInfoLine.RecId,
                trans.InventTransId);
            trans.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static PurchInvoiceJournalPost construct()
    {
        return new PurchInvoiceJournalPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initTransactionTxtHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, initTransactionTxt))]
    /// <summary>
    /// Calls the <c>PurchInvoiceJournalPost.postInitTransactionTxt_BR</c> method, if Brazilian context is enabled.
    /// </summary>
    /// <param name="_args">
    /// The arguments passed by the event handler.
    /// </param>
    public static void initTransactionTxtHandler(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost purchInvoiceJournalPost = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        purchInvoiceJournalPost.postInitTransactionTxt_BR(
                _args.getArg('_ledgerTransTxt'),
                _args.getReturnValue());
    }

]]></Source>
			</Method>
			<Method>
				<Name>postEndPostHandler_BR</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, endUpdate))]
    /// <summary>
    /// Executes after the <c>endPost</c> method.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object.
    /// </param>
    /// <remarks>
    /// This method is called by an event handler.
    /// </remarks>
    public static void postEndPostHandler_BR(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost purchInvoiceJournalPost = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        purchInvoiceJournalPost.postEndPost_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInitHandler_BR</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, init))]
    /// <summary>
    /// Executes after the <c>init</c> method.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object.
    /// </param>
    /// <remarks>
    /// This method is called by an event handler.
    /// </remarks>
    public static void postInitHandler_BR(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost purchInvoiceJournalPost = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        purchInvoiceJournalPost.postInit_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPostCustVendHandler</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, postCustVend))]
    /// <summary>
    /// Calls the <c>PurchInvoiceJournalPost.postPostCustVend_BR</c> method, if Brazilian context is enabled.
    /// </summary>
    /// <param name="_args">
    /// The arguments passed by the event handler.
    /// </param>
    public static void postPostCustVendHandler(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost purchInvoiceJournalPost = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        purchInvoiceJournalPost.postPostCustVend_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postPostLineHandler_BR</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, postLine))]
    /// <summary>
    /// Executes after the <c>postLine</c> method.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object.
    /// </param>
    /// <remarks>
    /// This method is called by an event handler.
    /// </remarks>
    public static void postPostLineHandler_BR(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost purchInvoiceJournalPost = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        purchInvoiceJournalPost.postPostLine_BR();
    }

]]></Source>
			</Method>
			<Method>
				<Name>preJournalLineHandler_BR</Name>
				<Source><![CDATA[
    [PreHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, journalLine))]
    /// <summary>
    /// Executes before the <c>journalLine</c> method.
    /// </summary>
    /// <param name="_args">
    /// The <c>XppPrePostArgs</c> object.
    /// </param>
    /// <remarks>
    /// This method is called by an event handler.
    /// </remarks>
    public static void preJournalLineHandler_BR(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost purchInvoiceJournalPost = _args.getThis();

        if (!BrazilParameters::isEnabled())
        {
            return;
        }

        purchInvoiceJournalPost.preJournalLine_BR(_args.getArg('_journalLine'));
    }

]]></Source>
			</Method>
			<Method>
				<Name>preUpdateJournalLine_PMF</Name>
				<Source><![CDATA[
    [PreHandlerFor(classStr(PurchInvoiceJournalPost), methodStr(PurchInvoiceJournalPost, updateJournalLine))]
    /// <summary>
    ///     Updates the catch-weight fields on the current posting.
    /// </summary>
    /// <param name="_args">
    ///     The Xpp event arguments.
    /// </param>
    /// <remarks>
    ///     The customization is located here to minimize conflicts with other industries solutions.
    /// </remarks>
    public static void preUpdateJournalLine_PMF(XppPrePostArgs _args)
    {
        PurchInvoiceJournalPost objThis = _args.getThis();

        if (#PDSCatchWeightEnabled)
        {
            objThis.cwPreUpdateJournalLine_SetCW();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcAssetAcquisitionPrice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the asset acquisition price for a purchase order line.
    /// </summary>
    /// <param name="_lineAmount">
    /// The amount from the purchase order line.
    /// </param>
    /// <returns>
    /// The acquisition price for the line.
    /// </returns>
    /// <remarks>
    /// Takes into consideration whether the line amount already includes sales tax and whether U.S. taxation rules
    /// are being applied.
    /// </remarks>
    protected AssetAcquisitionPrice calcAssetAcquisitionPrice(AmountCur _lineAmount)
    {
        // <GBR>
        MarkupTrans markupTrans;
        // </GBR>

        AssetAcquisitionPrice acquisitionPrice;
        AmountMST totalTaxAmount;
        AmountMST totalTaxInCostAmount;

        CurrencyExchangeHelper transExchRateHelper = CurrencyExchangeHelper::newExchangeDate(
                                                                Ledger::current(),
                                                                vendInvoiceTrans.InvoiceDate);

        acquisitionPrice = transExchRateHelper.calculateTransactionToAccounting(vendInvoiceTrans.CurrencyCode, _lineAmount, true);

        // getItemMiscChargesAmount returns any charges on the line plus taxes on those charges
        // (nonrecoverable taxes if US taxation is turned off)
        acquisitionPrice += MarkupTrans::getItemMiscChargesAmount(vendInvoiceTrans.TableId, vendInvoiceTrans.RecId);

        //If amounts do not include tax, it needs to be added in
        if (!(purchTable.InclTax || vendInvoiceInfoTable.InclTax))
        {
            totalTaxInCostAmount = tax.taxInCostPrice(tableNum(VendInvoiceInfoLine), vendInvoiceInfoLine.RecId);
            acquisitionPrice += transExchRateHelper.calculateTransactionToAccounting(
                vendInvoiceTrans.CurrencyCode, totalTaxInCostAmount, true);
        }
        else
        {
            // If Apply U.S. taxation rules is turned off and amounts include tax, recoverable tax needs to be
            // subtracted from the acquisition price
            if (!taxParameters.PurchTaxOnOperations)
            {
                totalTaxAmount = tax.totalRegulatedTaxAmountSingleLine(tableNum(VendInvoiceInfoLine), vendInvoiceInfoLine.RecId, false, false);
                totalTaxAmount = transExchRateHelper.calculateTransactionToAccounting(
                    vendInvoiceTrans.CurrencyCode, totalTaxAmount, true);

                // taxInCostPrice returns nonrecoverable tax amounts. This is subtracted from total tax to get the recoverable amount
                totalTaxInCostAmount = tax.taxInCostPrice(tableNum(VendInvoiceInfoLine), vendInvoiceInfoLine.RecId);
                totalTaxInCostAmount = transExchRateHelper.calculateTransactionToAccounting(vendInvoiceTrans.CurrencyCode, totalTaxInCostAmount, true);

                acquisitionPrice -= totalTaxAmount - totalTaxInCostAmount;
            }
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            acquisitionPrice -= tax.taxInCostPrice_BR(vendInvoiceInfoLine.TableId, vendInvoiceInfoLine.RecId);

            while select RecId from markupTrans
                where markupTrans.TransTableId == vendInvoiceInfoLine.TableId
                    && markupTrans.TransRecId == vendInvoiceInfoLine.RecId
            {
                acquisitionPrice -= tax.taxInCostPrice_BR(markupTrans.TableId, markupTrans.RecId);
            }
        }
        // </GBR>

        // <GTE>
        if (TaxSolutionScopeIntegrationUtil::isCompanyEnabled())
        {
            acquisitionPrice += this.getLoadOnInventoryTaxAmount();
        }
        // </GTE>

        return acquisitionPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSourceDocumentProcessorCaller</Name>
				<Source><![CDATA[
    protected PurchInvoiceJournalPostCaller createSourceDocumentProcessorCaller(LedgerVoucher _ledgerVoucher)
    {
        return PurchInvoiceJournalPostCaller::newFromLedgerVoucher(ledgerVoucher);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransLink_RU</Name>
				<Source><![CDATA[
    private void createTransLink_RU()
    {
        LedgerTransLink_RU ledgerTransLink;
        VendInvoiceJour correctedInvoiceJour;
        VendInvoiceTrans invoiceTrans;
        InventTrans inventTrans;
        InventTransOrigin inventTransOrigin;
        InventTrans inventTransOrig;
        TransLink_RU transLink;

        if (vendInvoiceJour.CorrectedInvoiceId_RU)
        {
            correctedInvoiceJour = VendInvoiceJour::findFromVendTrans(vendInvoiceJour.CorrectedInvoiceId_RU,
                                                                      vendInvoiceJour.CorrectedInvoiceDate_RU,
                                                                      vendInvoiceJour.InvoiceAccount);

            ledgerTransLink = LedgerTransLink_RU::newTrans(vendInvoiceJour, correctedInvoiceJour);
            ledgerTransLink.parmReportingDate(vendInvoiceJour.CorrectedInvoiceDate_RU);
            ledgerTransLink.parmVoucherField(fieldnum(VendInvoiceJour, LedgerVoucher));
            ledgerTransLink.parmAccountingDateField(fieldnum(VendInvoiceJour, InvoiceDate));
            ledgerTransLink.run();
        }

        while select inventTrans
            join RefPri from transLink
                where transLink.RefTableId == tablenum(InventTrans)
                   && transLink.RefSec == inventTrans.RecId
            exists join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join invoiceTrans
                where invoiceTrans.InventTransId == inventTransOrigin.InventTransId
                   && invoiceTrans.PurchId == vendInvoiceJour.PurchId
                   && invoiceTrans.InvoiceId == vendInvoiceJour.InvoiceId
                   && invoiceTrans.InvoiceDate == vendInvoiceJour.InvoiceDate
                   && invoiceTrans.numberSequenceGroup == vendInvoiceJour.numberSequenceGroup
                   && invoiceTrans.InternalInvoiceId == vendInvoiceJour.InternalInvoiceId
        {
            inventTransOrig = InventTrans::findRecId(transLink.RefPri);
            ledgerTransLink = LedgerTransLink_RU::newTrans(inventTrans, inventTransOrig);
            ledgerTransLink.parmVoucherField(fieldnum(InventTrans, Voucher));
            ledgerTransLink.parmAccountingDateField(fieldnum(InventTrans, DateFinancial));
            ledgerTransLink.parmReportingDate(inventTransOrig.DateFinancial);
            ledgerTransLink.run();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>startLines</Name>
				<Source><![CDATA[
    protected void startLines()
    {
        VendInvoiceInfoLine vendInvoiceInfoLineLocal;
        PurchLine purchLineLocal;
        
        super();
        
        // If the invoice is in a batch, we will allow packing slips to be posted prior to posting the invoice lines
        if (this.parmPostingInBatch())
        {
            update_recordset vendInvoiceInfoLineLocal
                setting RemainBeforeInventPhysical = purchLineLocal.RemainInventPhysical
                    join RemainInventPhysical from purchLineLocal
                        where vendInvoiceInfoLineLocal.ParmId == vendInvoiceInfoTable.ParmId
                           && vendInvoiceInfoLineLocal.TableRefId == vendInvoiceInfoTable.TableRefId
                           && purchLineLocal.RecId == vendInvoiceInfoLineLocal.PurchLineRecId;
            
        }
        
        postVendorProdBOMHelper = new ProdJournalPostVendorProdBOMHelper();
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncSalesLineRemPhysicalQty</Name>
				<Source><![CDATA[
    private void syncSalesLineRemPhysicalQty(PurchLine _purchLine)
    {
        if (!purchLine)
        {
            return;
        }

        SalesLine salesLine = SalesLine::findInventTransId(purchLine.InventRefTransId, true);

        if (!salesLine)
        {
            return;
        }

        salesLine.RemainSalesPhysical = 0;
        if (salesLine.isStocked())
        {
            salesLine.RemainInventPhysical = 0;
            salesLine.PdsCWRemainInventPhysical = 0;
            salesLine.SkipUpdate = InterCompanySkipUpdate::Internal;
            salesLine.update();
        }
        else
        {
            salesLine.doUpdate();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBudgetReservationBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the budget reservation line referenced by the vendor invoice line has enough balance.
    /// </summary>
    /// <remarks>
    /// If the referenced budget reservation line does not have sufficient balance, halt vendor invoice posting.
    /// </remarks>
    protected void checkBudgetReservationBalance()
    {
        BudgetReservation_PSN::checkBudgetReservationBalance(vendInvoiceInfoLine.BudgetReservationLine_PSN, vendInvoiceInfoTable.SourceDocumentHeader);   
    }

]]></Source>
			</Method>
			<Method>
				<Name>postTaxGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post tax calculated by GTE
    /// </summary>
    protected void postTaxGTE()
    {
        // <GTE>
        ITaxableDocument                        taxableDocument;
        ITaxDocument                            taxDocumentObject;
        TaxEngineTaxJournalPackSlipConstructor  taxJournalConstructor;
        TaxEngineTaxJournal                     taxJournal;

        VendInvoiceInfoSubLine                  vendInvoiceInfoSubLine;
        VendInvoiceInfoLine                     vendInvoiceInfoLineLoc;
        VendPackingSlipJour                     vendPackingSlipJour;

        super();

        if (InventParameters::find().PostPhysicalTax)
        {
            while select vendPackingSlipJour
            where vendPackingSlipJour.PurchId == vendInvoiceInfoTable.PurchId
            {
                select firstOnly RecId, DocumentId, LineRefRecId from vendInvoiceInfoSubLine
                where vendInvoiceInfoSubLine.DocumentId == vendPackingSlipJour.PackingSlipId
                join TableRefId, ParmId, RecId from vendInvoiceInfoLineLoc
                    where vendInvoiceInfoLineLoc.TableRefId == vendInvoiceInfoTable.TableRefId
                    && vendInvoiceInfoLineLoc.ParmId == vendInvoiceInfoTable.ParmId
                    && vendInvoiceInfoSubLine.LineRefRecId == vendInvoiceInfoLineLoc.RecId;
                if (vendInvoiceInfoSubLine.RecId == 0)
                {
                    continue;
                }

                taxableDocument = TaxableDocumentObject::construct(
                TaxableDocumentDescriptorFactory::getTaxableDocumentDescriptor(vendPackingSlipJour));
                taxDocumentObject = TaxBusinessService::calculateTax(taxableDocument);

                taxJournalConstructor = TaxEngineTaxJournalConstructor::construct(TaxEngineTaxJournalType::ProductReceiptReverse);
                taxJournalConstructor.parmVendInvoiceInfoTableRecId(vendInvoiceInfoTable.RecId);
                taxJournalConstructor.createTaxJourLineFromTaxDoc_Post += eventhandler(TaxEngineTaxJournalConstructor::reverseTaxJournalLineEventHandler);
                taxJournal = taxJournalConstructor.createTaxJournalFromTaxDocument(taxDocumentObject);

                TaxEngineTaxJournalUtil::postTaxJournalWithLedgerVoucher(taxJournal, ledgerVoucher, NoYes::No, taxDocumentLedgerVoucherMap);
            }
        }
        // </GTE>
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLoadOnInventoryTaxAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the tax amount that needs to be loaded to asset acquisition price.
    /// </summary>
    /// <returns>The tax amount that should be loaded to inventory.</returns>
    private AmountMST getLoadOnInventoryTaxAmount()
    {
        AmountMST   loadOnInventoryAmount;
        ITaxDocument taxDocumentObject = TaxBusinessService::getTaxDocumentBySource(vendInvoiceJour.TableId, vendInvoiceJour.RecId);
        if (taxDocumentObject)
        {
            ITaxDocumentLine taxDocumentLineObject = taxDocumentObject.findLineBySource(vendInvoiceTrans.TableId, vendInvoiceTrans.RecId);
            if (taxDocumentLineObject)
            {
                //Consider price incl. tax
                loadOnInventoryAmount -= taxDocumentLineObject.getInclTax().amountAccountingCurrency();

                //Load on inventory amount
                loadOnInventoryAmount += taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Debit).amountAccountingCurrency();
                loadOnInventoryAmount -= taxDocumentLineObject.sumByTaxAccountingProvider(TaxAccountingProvider::Inventory, TaxAccountingPostingProfileDistributionSide::Credit).amountAccountingCurrency();
            }
        }

        return loadOnInventoryAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postSingleLine</Name>
				<Source><![CDATA[
    protected void postSingleLine(boolean _countryRegion_RU,
                                  boolean _hasQualityOrder,
                                  boolean _isExciseEnableIN,
                                  boolean _isVATEnableIN,
                                  boolean _isCustomsEnableIN,
                                  boolean _isConfigurationkeyRetailEnabled)
    {
        using (var activityContext = instrumentationLogger.purchFormLetterInstrumentationActivities().purchPostInvoiceSingleLine())
        {
            super(_countryRegion_RU,
                  _hasQualityOrder,
                  _isExciseEnableIN,
                  _isVATEnableIN,
                  _isCustomsEnableIN,
                  _isConfigurationkeyRetailEnabled);

            activityContext.getActivity().addCustomProperty(PurchPurchaseOrderInstrumentationActivities::PurchTableRecId, any2Str(this.purchTable.RecId));
            activityContext.getActivity().addCustomProperty(PurchPurchaseOrderInstrumentationActivities::SourceDocumentLine, any2Str(this.purchLine.SourceDocumentLine));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    public void run()
    {
        using (var activityContext = instrumentationLogger.purchFormLetterInstrumentationActivities().purchPostInvoiceSingleOrder())
        {
            super();

            activityContext.getActivity().addCustomProperty(PurchPurchaseOrderInstrumentationActivities::PurchTableRecId, any2Str(this.purchTable.RecId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNotOverDeliveryForNotStockedWithMatchedPR</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the posted and matched quantity does not cause unauthorized over delivery of the not stocked
    /// order line with invoices matched product receipts.
    /// </summary>
    /// <param name="_notStockedPostCheck">
    /// The <c>TradeNotStockedPostCheck</c> object to use for verification.
    /// </param>
    /// <returns>
    /// true if the posted quantity does not cause unauthorized over delivery of the not stocked order
    /// line with invoices matched product receipts; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean checkNotOverDeliveryForNotStockedWithMatchedPR(TradeNotStockedPostCheck _notStockedPostCheck)
    {
        boolean ret = true;

        UnitQty qtyPre = abs(purchLine.PurchQty);
        UnitQty qtyPost = abs(this.qtyReceivedInTotal() +
            this.qtyPendingInvoiceMatchedPR() +
            vendInvoiceInfoLine.ReceiveNow);

        Percent overDeliveryPercent = (qtyPost - qtyPre) / (qtyPre ? qtyPre : 1) * 100;

        if (overDeliveryPercent > purchLine.overDeliveryPct())
        {
            ret = checkFailed(strFmt("@SYS24920", overDeliveryPercent, purchLine.overDeliveryPct()));
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyPendingInvoiceMatchedPR</Name>
				<Source><![CDATA[
    private UnitQty qtyPendingInvoiceMatchedPR()
    {
        VendInvoiceInfoSubLine vendInvoiceInfoSubLine;
        VendInvoiceInfoLine localVendInvoiceInfoLine;

        select sum(ReceiveNow) from vendInvoiceInfoSubLine
            join localVendInvoiceInfoLine
                where localVendInvoiceInfoLine.RecId == vendInvoiceInfoSubLine.LineRefRecId
                    && localVendInvoiceInfoLine.PurchLineRecId == purchLine.RecId
                    && localVendInvoiceInfoLine.RecId != vendInvoiceInfoLine.RecId;

        return vendInvoiceInfoSubLine.ReceiveNow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>qtyReceivedInTotal</Name>
				<Source><![CDATA[
    private PurchQty qtyReceivedInTotal()
    {
        PurchQty qtyPurch;

        if (purchLine.InventTransId)
        {
            qtyPurch = (select sum(QtyPhysical) from vendInvoiceTrans
                        index hint TransIdIdx
                        where vendInvoiceTrans.InventTransId == purchLine.InventTransId).QtyPhysical;
        }

        return qtyPurch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxAmountGTE</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the GTE tax amount.
    /// </summary>
    /// <returns>The GTE tax amount.</returns>
    private AmountCur getTaxAmountGTE()
    {
        AmountCur taxAmountGTE;
        ITaxDocument taxDocumentObject = TaxBusinessService::getTaxDocumentBySource(vendInvoiceJour.TableId, vendInvoiceJour.RecId);
        if (taxDocumentObject)
        {
            ITaxDocumentLine taxDocumentLineObject = taxDocumentObject.findLineBySource(vendInvoiceTrans.TableId, vendInvoiceTrans.RecId);
            if (taxDocumentLineObject)
            {
                taxAmountGTE = taxDocumentLineObject.getLineTax().amountTransactionCurrency();
            }
        }

        return taxAmountGTE;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>