<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>MCRCustPaym</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Commerce.Headquarters.Instrumentation;
/// <summary>
///     The <c>MCRCustPaym</c> abstract class to handle customer payments.
/// </summary>
/// <remarks>
///     This class defines a common interface for payments of all types, and
///     implements common functionality.  Extending classes provide specialized
///     functionality for each payment type.
///     The factory method "construct" should be used to construct an instance of
///     the appropriate extending class.
///     An instance of this class acts as a wrapper around a "MCRCustPaymTable" table
///     buffer -- not around the table record.  This means that the data that is
///     passed to the constructor is never re-loaded from the database.  Changes made
///     to the record after the wrapper is constructed will not be reflected in
///     subsequent calls to methods of the wrapper.  It is expected that an instance
///     of this class will be constructed, used immediately, and then discarded; it
///     is not recommended that an instance of this class be stored and reused.
/// </remarks>
abstract class mcrCustPaym
{
    // payment for which this instance is a wrapper
    MCRCustPaymTable        mcrCustPaymTable;
    // is user interaction allowed?
    boolean                 allowUserInput;
    CreditCardAuthTrans     creditCardAuthTrans_Reversal;
    LedgerJournalTable      ledgerJournalTable;
    MCRLedgerJournal        mcrLedgerJournal;
    boolean                 skipJournalPost;
    CustInvoiceJour         custInvoiceJour;
    SalesInvoiceId          salesInvoiceId;
    CustInvoiceId           custInvoiceId;
    CustInvoiceTable        custInvoiceTable;
    CustPaymSchedLine       custPaymSchedLine;
    LedgerJournalTrans      ledgerJournalTransPaym;
    DimensionDefault        defaultDimension;
    str                     paymReference;
    RetailExternalGiftCard  retailExternalGiftCard;
    internal CreditCardCVV creditCardCvv;
    internal boolean getCardVerificationValue;
    internal McrCustCreditTable mcrCustCreditTable;

    #ISOCountryRegionCodes
    #EECountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>allowEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if a payment field should be editable by the user.
    /// </summary>
    /// <param name="_fieldID">
    ///     The ID of a field from the <c>MCRCustPaymTable</c> table.
    /// </param>
    /// <returns>
    ///     true if editing should be allowed; otherwise, false.
    /// </returns>
    public boolean allowEdit(fieldID _fieldID)
    {
        switch (_fieldID)
        {
            // the following fields should never be allowed to be directly edited
            //  by the user
            case fieldnum(MCRCustPaymTable, CustAccount):
            case fieldnum(MCRCustPaymTable, CustPaymType):
            case fieldnum(MCRCustPaymTable, LineNum):
            case fieldnum(MCRCustPaymTable, PostedAmount):
            case fieldnum(MCRCustPaymTable, RefTableId):
            case fieldnum(MCRCustPaymTable, RefRecId):
            case fieldnum(MCRCustPaymTable, Status):
            case fieldnum(MCRCustPaymTable, CurrencyCode):
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the currency should be allowed to be modified for this
    ///     payment.
    /// </summary>
    /// <returns>
    ///     true if any amount has not been posted for the payment; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     The currency for all payments is always the same as the currency for
    ///     the entity associated with the payments.  The currency must not change if,
    ///     for example, financial transactions exist for one or more payments.
    /// </remarks>
    boolean allowEditCurrency()
    {
        boolean allowEdit = true;

        if (mcrCustPaymTable.PostedAmount != 0)
        {
            allowEdit = false;
        }

        return allowEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowEditInvoiceAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the invoice account should be allowed to be modified for this
    ///     payment.
    /// </summary>
    /// <returns>
    ///     true if any amount has not been posted for the payment; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     The invoice account for all payments must always be the same as the
    ///     invoice account for the entity associated with the payments.  The invoice
    ///     account must not change if, for example, financial transactions exist for
    ///     one or more payments.  The invoice account is stored in the payment table
    ///     (for efficient table joins), but is not allowed to be directly edited by
    ///     the user.  The invoice account must be updated on each payment if changed
    ///     on the entity associated with the payments.
    /// </remarks>
    boolean allowEditInvoiceAccount()
    {
        boolean allowEdit = true;

        if (mcrCustPaymTable.PostedAmount != 0)
        {
            allowEdit = false;
        }

        return allowEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowUserInput</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if this payment instance is allowed to
    ///     prompt the user for input during payment operations.
    /// </summary>
    /// <param name="_allowUserInput">
    ///     A boolean that determines whether or not to prompt user for input during
    ///     operations on the payment; optional.
    /// </param>
    /// <returns>
    ///     true if the operations are allowed to prompt user for input; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     If the _allowUserInput value is false, then user interaction is not permitted.
    ///     Each payment operation (i.e., public method) must support
    ///     non-interactive processing, meaning that each operation must be able
    ///     to execute successfully without user interaction.
    /// </remarks>
    boolean allowUserInput(boolean _allowUserInput = allowUserInput)
    {
        allowUserInput = _allowUserInput;

        return allowUserInput;
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizeChargeManually</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Authorizes the payment.
    /// </summary>
    /// <param name="_creditCardAuthorization">
    ///     The reason to authorize the payment
    /// </param>
    /// <returns>
    ///     The payment stats of 'Authorized'.
    /// </returns>
    MCRCustPaymStatus authorizeChargeManually(CreditCardAuthorization _creditCardAuthorization)
    {
        return MCRCustPaymStatus::Authorized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>authorizeRefundManually</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Authorizes the refund.
    /// </summary>
    /// <param name="_code">
    ///     The reason to authroize the refund.
    /// </param>
    /// <returns>
    ///     The authorization stats of 'Authorized'.
    /// </returns>
    MCRCustPaymStatus authorizeRefundManually(str _code)
    {
        return MCRCustPaymStatus::Authorized;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAuthorize</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the payment can be authorized.
    /// </summary>
    /// <returns>
    ///     true if the status is not submitted; otherwise, false.
    /// </returns>
    boolean canAuthorize()
    {
        if (mcrCustPaymTable.Status == MCRCustPaymStatus::NotSubmitted)
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if the payment can be posted.
    /// </summary>
    /// <param name="_postAmount">
    ///     The amount that determines if the payment can be posted.
    /// </param>
    /// <returns>
    ///     true if the status is paid or posted and the amount passed does not
    ///     equal zero; otherwise, false.
    /// </returns>
    boolean canPost(AmountCur _postAmount)
    {
        CommerceHQEventSource eventSource = CommerceHQEventSource::Log;
        if (_postAmount != 0
            && (mcrCustPaymTable.Status == MCRCustPaymStatus::Paid
            || mcrCustPaymTable.Status == MCRCustPaymStatus::Posted))
        {
            return true;
        }

        RecId salesTableRecId = SalesTable::find(mcrCustPaymTable.salesTable().mcrReturnSalesTable().OriginalSalesId).RecId;

        eventSource.EventWritePaymentsLogCanNotPostPayment(salesTableRecId, enum2Str(mcrCustPaymTable.Status));
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>declineChargeManually</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Declines the payment manually.
    /// </summary>
    /// <param name="_code">
    ///     The response code used to justify the manual decline.
    /// </param>
    /// <returns>
    ///     A payment status of declined.
    /// </returns>
    MCRCustPaymStatus declineChargeManually(str _code)
    {
        return MCRCustPaymStatus::Declined;
    }

]]></Source>
			</Method>
			<Method>
				<Name>declineRefundManually</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Declines the refund manually.
    /// </summary>
    /// <param name="_authCode">
    ///     The response code used to justify the manual decline.
    /// </param>
    /// <returns>
    ///     A payment status of declined.
    /// </returns>
    MCRCustPaymStatus declineRefundManually(str _authCode)
    {
        return MCRCustPaymStatus::Declined;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineStatus</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates parent method so it can be called without
    ///     specifically creating an <c>MCRCustPaym_CreditCard</c> object.
    /// </summary>
    /// <returns>
    ///     The current status of the <c>MCRCustPaymTable</c> record.
    /// </returns>
    MCRCustPaymStatus determineStatus()
    {
        return mcrCustPaymTable.Status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultValue</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the default value for the specified field.
    ///     The type of the value returned must match the type of the field to be set.
    /// </summary>
    /// <param name="_fieldID">
    ///     The ID of a field from the <c>MCRCustPaymTable</c> table.
    /// </param>
    /// <returns>
    ///     The value to set in the field, or <c>null</c> to indicate that a default is not defined for the field; meaning that the
    ///     system default or the current value for the field is okay.
    /// </returns>
    anyType getDefaultValue(fieldID _fieldID)
    {
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymAccount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the payment account and account type.
    /// </summary>
    /// <returns>
    /// The account type <c>LedgerJournalACType</c> and the account <c>LedgerJournalAC</c>
    /// </returns>
    /// <remarks>
    /// By default, the account type and account are determined by the payment method.
    /// </remarks>
    public container getPaymAccount()
    {
        RetailStoreTenderTypeTable      retailStoreTenderTypeTable;
        LedgerJournalACType             offsetType;
        LedgerDimensionDefaultAccount   offsetAccount;

        retailStoreTenderTypeTable = RetailStoreTenderTypeTable::find(mcrCustPaymTable.Channel, mcrCustPaymTable.TenderTypeId);

        if (retailStoreTenderTypeTable)
        {
            switch (retailStoreTenderTypeTable.AccountType)
            {
                case RetailLedgerBank::Bank:
                    offsetType = LedgerJournalACType::Bank;
                    break;
                case RetailLedgerBank::Ledger:
                    offsetType = LedgerJournalACType::Ledger;
                    break;
                // <GEERU>
                case RetailLedgerBank::RCash:
                    offsetType = LedgerJournalACType::RCash;
                    break;
                // </GEERU>
            }
            offsetAccount = retailStoreTenderTypeTable.LedgerDimension;
        }
        else
        {
            throw error(strFmt("@MCR40426",enum2str(mcrCustPaymTable.CustPaymType)));
        }

        return [offsetType, offsetAccount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasPaymTypeData</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines if all required data that is specific to the payment
    ///     type has been provided.
    /// </summary>
    /// <returns>
    ///     Nothing; the child method is the only one called.
    /// </returns>
    /// <remarks>
    ///     A payment of type "check" requires a check number.
    ///     This method should return true if a check number has been provided;
    ///     otherwise, this method should return false.
    /// </remarks>
    abstract boolean hasPaymTypeData()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a new instance.
    /// </summary>
    /// <param name="_custPaymTable">
    ///      Customer payment record for which this instance is a wrapper.
    /// </param>
    /// <param name="_allowUserInput">
    ///     Specifies whether user interaction is allowed during operations on this
    ///     payment.  If true, the user might be prompted for input.  If false, all
    ///     operations will complete without requesting user input.
    /// </param>
    /// <param name="_creditCardAuthTrans">
    ///     A <c>CreditCardAuthTrans</c> record applied to a class variable; optional.
    /// </param>
    void new(MCRCustPaymTable    _custPaymTable,
             boolean             _allowUserInput,
             CreditCardAuthTrans _creditCardAuthTrans = NULL)
    {
        // Always set class variable.
        mcrCustPaymTable = _custPaymTable;

        allowUserInput = _allowUserInput;

        creditCardAuthTrans_Reversal = _creditCardAuthTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <c>CustInvoiceJour</c> table buffer.
    /// </summary>
    /// <param name="_custInvoiceJour">
    /// The <c>CustInvoiceJour</c> table buffer to set on the object.
    /// </param>
    /// <returns>
    /// The <c>CustInvoiceJour</c> table buffer on the object.
    /// </returns>
    public CustInvoiceJour parmCustInvoiceJour(CustInvoiceJour _custInvoiceJour = custInvoiceJour)
    {
        custInvoiceJour = _custInvoiceJour;
        return custInvoiceJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInvoiceTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <c>CustInvoiceId</c> to hande free text invoices.
    /// </summary>
    /// <param name="_custInvoiceTable">
    /// The <c>CustInvoiceTable</c> to set on the object.
    /// </param>
    /// <returns>
    /// The <c>CustInvoiceId</c> table buffer on the object.
    /// </returns>
    public CustInvoiceTable parmCustInvoiceTable(CustInvoiceTable _custInvoiceTable = custInvoiceTable)
    {
        custInvoiceTable = _custInvoiceTable;
        return custInvoiceTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustPaymSchedLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <c>CustPaymSchedLine</c> table buffer.
    /// </summary>
    /// <param name="_custPaymSchedLine">
    /// The <c>CustPaymSchedLine</c> table buffer to set on the object.
    /// </param>
    /// <returns>
    /// The <c>CustPaymSchedLine</c> table buffer on the object.
    /// </returns>
    public CustPaymSchedLine parmCustPaymSchedLine(CustPaymSchedLine _custPaymSchedLine = custPaymSchedLine)
    {
        custPaymSchedLine = _custPaymSchedLine;
        return custPaymSchedLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFreeTextInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <c>CustInvoiceId</c> to hande free text invoices.
    /// </summary>
    /// <param name="_custInvoiceId">
    /// The <c>CustInvoiceId</c> to set on the object.
    /// </param>
    /// <returns>
    /// The <c>CustInvoiceId</c> table buffer on the object.
    /// </returns>
    public CustInvoiceId parmFreeTextInvoiceId(CustInvoiceId _custInvoiceId = custInvoiceId)
    {
        custInvoiceId = _custInvoiceId;
        return custInvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets and return the <c>LedgerJournalTable</c> class variable.
    /// </summary>
    /// <param name="_ledgerJournalTable">
    ///     The class variable being set; optional.
    /// </param>
    /// <returns>
    ///     The newly set <c>LedgerJouranlTable</c> record.
    /// </returns>
    LedgerJournalTable parmLedgerJournalTable(LedgerJournalTable _ledgerJournalTable = ledgerJournalTable)
    {
        ledgerJournalTable = _ledgerJournalTable;
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <c>LedgerJournalTrans</c> table buffer.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTable</c> table buffer to set on the object.
    /// </param>
    /// <returns>
    /// The <c>LedgerJournalTrans</c> table buffer on the object.
    /// </returns>
    public LedgerJournalTrans parmLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans = ledgerJournalTransPaym)
    {
        ledgerJournalTransPaym = _ledgerJournalTrans;
        return ledgerJournalTransPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreditCardCvv</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the credit card verification value.
    /// </summary>
    /// <param name = "_creditCardCvv">
    /// The <c>_creditCardCvv</c> credit card verification value
    /// </param>
    /// <returns>
    /// The credit card verification value.
    /// </returns>
    internal CreditCardCVV parmCreditCardCvv(CreditCardCVV _creditCardCvv = creditCardCvv)
    {
        creditCardCvv = _creditCardCvv;
        return creditCardCvv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMCRLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets and return the <c>MCRLedgerJournal</c> class variable.
    /// </summary>
    /// <param name="_mcrLedgerJournal">
    ///     The <c>MCRLedgerJournal</c> being set and returned; optional.
    /// </param>
    /// <returns>
    ///     The <c>MCRLedgerJournal</c> record.
    /// </returns>
    MCRLedgerJournal parmMCRLedgerJournal(MCRLedgerJournal _mcrLedgerJournal = mcrLedgerJournal)
    {
        MCRLedgerJournal = _mcrLedgerJournal;
        return MCRLedgerJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paramRetailExternalGiftCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and returns the <c>RetailExternalGiftCard</c> class variable.
    /// </summary>
    /// <param name = "_retailExternalGiftCard">The <c>RetailExternalGiftCard</c> being set and returned; optional.</param>
    /// <returns>The <c>RetailExternalGiftCard</c> record.</returns>
    [Hookable(false)]
    RetailExternalGiftCard paramRetailExternalGiftCard(RetailExternalGiftCard _retailExternalGiftCard = retailExternalGiftCard)
    {
        RetailExternalGiftCard = _retailExternalGiftCard;
        return RetailExternalGiftCard;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the voucher of ledger journal.
    /// </summary>
    /// <returns>
    /// The voucher of ledger journal.
    /// </returns>
    public Voucher getVoucher()
    {
        return mcrLedgerJournal != null ? mcrLedgerJournal.getVoucher() : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSalesInvoiceId</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets the <c>SalesInvoiceId</c>.
    /// </summary>
    /// <param name="_salesInvoiceId">
    /// The <c>SalesInvoiceId</c> to set on the object.
    /// </param>
    /// <returns>
    /// The <c>SalesInvoiceId</c> table buffer on the object.
    /// </returns>
    public CustInvoiceId parmSalesInvoiceId(SalesInvoiceId _salesInvoiceId = salesInvoiceId)
    {
        SalesInvoiceId = _salesInvoiceId;
        return salesInvoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipJournalPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether or not the LedgerJournalCheckPost's run
    ///     method will be run in postToLedgerJournal.
    /// </summary>
    /// <param name="_skipJournalPost">
    ///     A boolean determining whether or not to skip posting; optional.
    /// </param>
    /// <returns>
    ///     true if posting should be skipped; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Primarily used when wanting to use payment processing
    ///     to validate/create payments and journal lines but not post
    ///     right away.  So they can be posted later in batch. Used in
    ///     conjunction with parmLedgerJournalTable.
    /// </remarks>
    boolean parmSkipJournalPost(boolean _skipJournalPost = skipJournalPost)
    {
        skipJournalPost = _skipJournalPost;
        return skipJournalPost;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMcrCustomerCredit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the order credit record.
    /// </summary>
    /// <param name = "_mcrCustCreditTable">The order credit.</param>
    /// <returns>The <c>McrCustCreditTable</c> table buffer.</returns>
    internal McrCustCreditTable parmMcrCustomerCredit(McrCustCreditTable _mcrCustCreditTable = mcrCustCreditTable)
    {
        mcrCustCreditTable = _mcrCustCreditTable;
        return mcrCustCreditTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentChanged</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Alters a payment.
    /// </summary>
    /// <param name="_mcrCustPaymTable_Old">
    ///     The <c>MCRCustPaymTable</c> record being altered.
    /// </param>
    void paymentChanged(MCRCustPaymTable _mcrCustPaymTable_Old)
    {
        boolean loggedChange = false;
        if (mcrCustPaymTable.Status != _mcrCustPaymTable_Old.Status)
        {
            switch (mcrCustPaymTable.Status)
            {
                case MCRCustPaymStatus::Declined:
                    // Log a status change to declined
                    MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::Declined, mcrCustPaymTable);
                    break;
                case MCRCustPaymStatus::Authorized:
                    // Log a Authorized change
                    MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::Authorized, mcrCustPaymTable);
                    break;
                case MCRCustPaymStatus::Paid:
                    // Log a Paid change
                    MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::Settled, mcrCustPaymTable);
                    break;
                case MCRCustPaymStatus::Posted:
                    // Log a Posted change
                    MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::Posted, mcrCustPaymTable);
                    break;
                case MCRCustPaymStatus::NotSubmitted:
                    // Log a void Authorization
                    MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::AuthReversed, mcrCustPaymTable);
                    break;
                default:
                    MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::StatusChange, mcrCustPaymTable);
                    break;
            }
            loggedChange = True;
        }

        if (mcrCustPaymTable.Amount != _mcrCustPaymTable_Old.Amount)
        {
            // Log the payment amount change event.
            MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::AmountChange, mcrCustPaymTable);
            loggedChange = True;
        }

        // Log other changes
        if (!loggedChange)
        {
            // Log other change
            MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::Change, mcrCustPaymTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>performBalanceCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the balance for the payment method.
    /// </summary>
    /// <returns>The balance on the card.</returns>
    protected real performBalanceCheck()
    {
        return 0.0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>processBalance</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process balance for the payment method.
    /// </summary>
    /// <returns>The balance on the card.</returns>
    [Hookable(false)]
    public real processBalance()
    {
        return this.performBalanceCheck();
    }

]]></Source>
			</Method>
			<Method>
				<Name>performAuth</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs authorization on this payment.
    /// </summary>
    /// <returns>
    ///     The resulting payment status.
    /// </returns>
    /// <remarks>
    ///     Authorization should be for the non-posted payment amount, not for the
    ///     payment amount.
    ///     Extending classes should implement this method to do the following:
    ///     1) Perform any applicable authorization procedures.  These procedures
    ///     might consist only of placing the payment into some authorization
    ///     queue, or they might consist of completing the entire authorization
    ///     process.
    ///     2) Determine and return the resulting payment status.
    ///     This method should not make updates to the payment record -- neither to
    ///     the table buffer that is stored as a member variable, nor to the record in
    ///     the database.
    ///
    ///     The status must be one of the following:
    ///     * MCRCustPaymStatus::PendingAuth.
    ///     * MCRCustPaymStatus::Authorized.
    ///     * MCRCustPaymStatus::Declined.
    ///     * MCRCustPaymStatus::OnHold.
    /// </remarks>
    abstract protected MCRCustPaymStatus performAuth()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>performPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Performs posting operations after posting records to the
    ///     ledger journal.
    /// </summary>
    /// <param name="_amount">
    ///     The amount to be posted.
    /// </param>
    protected abstract void performPost(Amount _amount)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Posts the payment for the amount passed.
    /// </summary>
    /// <param name="_amount">
    ///     The amount of the payment being postd.
    /// </param>
    /// <param name="_isPrepay">
    ///     A boolean determining if they payment is a prepay or not.
    /// </param>
    public void post(Amount _amount, boolean _isPrepay)
    {
        setprefix(strfmt("@MCR10793",
                         enum2str(mcrCustPaymTable.CustPaymType),
                         num2str(_amount, 1, 2, 1, 2)));

        if (!this.validatePost(_amount, true))
        {
            throw error("@MCR10794");
        }

        ttsBegin;

        // create ledger journal records
        this.postToLedgerJournal(_amount, _isPrepay);

        mcrCustPaymTable.updatePostedAmount(_amount);

        mcrCustPaymTable.reread();

        // perform any posting operations for specific payment types
        this.performPost(_amount);

        ttsCommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postToLedgerJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Creates a ledger journal entry to post payment for the specified amount
    ///     and retrieves the user setup for customer payment journal name from
    ///     cust parameters table.
    /// </summary>
    /// <param name="_amount">
    ///     The amount to be posted to the <c>LedgerJournalTable</c> record.
    /// </param>
    /// <param name="_isPrepay">
    ///     A boolean determining if the amount paid is a prepay or not.
    /// </param>
    /// <remarks>
    ///     If a journal name has not been set up then
    ///     the journalname that is of type Cust_P will be pulled in.
    /// </remarks>
    void postToLedgerJournal(Amount _amount, boolean _isPrepay)
    {
        //  Need to retrieve more than one piece of information from totals
        //  so instantiating the object here rather than calling methods
        //  on MCRCustPaymTable

        Amount                          postAmount  = _amount;
        AmountCurCredit                 amtCredit;
        AmountCurDebit                  amtDebit;
        LedgerJournalACType             offsetType;
        LedgerDimensionDefaultAccount   offsetAccount;
        LedgerJournalTrans              ledgerJournalTransOut;

        // <GEERU>
        boolean                         isReturn    = _amount < 0;
        boolean                         isRCash;
        // </GEERU>

        [offsetType, offsetAccount] = this.getPaymAccount();
        // <GEERU>
        isRCash = offsetType == LedgerJournalACType::RCash;
        // </GEERU>

        ttsbegin;

        if (!mcrLedgerJournal)
        {
            // <GEERU>
            if (isRCash)
            {
                mcrLedgerJournal = MCRLedgerJournal::construct(LedgerJournalType::RCash);
            }
            else
            {
                // </GEERU>
                mcrLedgerJournal = MCRLedgerJournal::construct(LedgerJournalType::CustPayment);
                // <GEERU>
            }
            // </GEERU>
        }

        mcrLedgerJournal.parmDefaultDimension(this.parmDefaultDimension());

        if (SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU))
        {
            mcrLedgerJournal.parmPrePayment(_isPrepay && !isReturn);
        }
        else
        {
            mcrLedgerJournal.parmPrePayment(_isPrepay);
        }

        if (!ledgerJournalTable)
        {
            ledgerJournalTable = mcrLedgerJournal.createLedgerJournalTable();
        }
        if (ledgerJournalTable)
        {
            mcrLedgerJournal.parmLedgerJournalTable(ledgerJournalTable);
            // <GEERU>
            if (isRCash)
            {
                // have to swap account and offset account data for RCash lines
                postAmount = -postAmount;

                this.initMCRLedgerJournalDataRCash(_isPrepay, offsetType, offsetAccount);
            }
            else
            {
                // </GEERU>
                this.initMCRLedgerJournalDataCustPayment(_isPrepay, offsetType, offsetAccount);
                // <GEERU>
            }
            // </GEERU>
            this.initCommonMCRLedgerJournalData(_isPrepay, isReturn);

            if (postAmount > 0.0)
            {
                amtCredit = postAmount;
            }
            else
            {
                amtDebit = abs(postAmount);
            }

            ledgerJournalTransOut = mcrLedgerJournal.createLedgerJournalTrans(amtCredit, amtDebit);
        }

        ttscommit;

        // post the payment journal
        ledgerJournalTable.reread();
        ledgerJournalTransOut.reread();

        if (!skipJournalPost)
        {
            mcrLedgerJournal.post();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPaym</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a payment for posted amount.
    /// </summary>
    /// <param name="_postAmount">
    /// The amount to post.
    /// </param>
    /// <returns>
    /// The payment status.
    /// </returns>
    MCRCustPaymStatus processPaym(AmountCur _postAmount)
    {
        if (this.canAuthorize())
        {
            this.performAuth();
        }

        this.wrapReRead(mcrCustPaymTable);

        if (this.canPost(_postAmount))
        {
            this.post(_postAmount, mcrCustPaymTable.IsPrepay);

            // Check if the flight is enabled and the sales order is an omni-channel commerce order.
            if (RetailPaymentsJournalMethodOfPaymentToggle::instance().isEnabled()
                && mcrCustPaymTable.RefTableId == tableNum(SalesTable)
                && RetailCommercePaymentsFeatureHelper::commercePaymentsEnabledForOrder(SalesTable::findRecId(mcrCustPaymTable.RefRecId), funcName()))
            {
                // Set the method of payment on the posted journal line.
                this.setMethodOfPaymentInPostedLedger();
            }
        }

        // In case of Auth reversals an amount of zero is passedto this method
        //   - the payment status to be returned here would be not submitted.
        if (_postAmount == 0)
        {
            mcrCustPaymTable.Status = MCRCustPaymStatus::NotSubmitted;
        }

        return mcrCustPaymTable.Status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>wrapReRead</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allow reread to be mockable from unit test
    /// </summary>
    /// <param name = "_mcrCustPaymTable">The <c>MCRCustPaymTable</c> record being reread.</param>
    protected void wrapReRead(MCRCustPaymTable _mcrCustPaymTable)
    {
        _mcrCustPaymTable.reread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>processPaymManually</Name>
				<Source><![CDATA[
    /// <summary>
    /// Processes a payment manually.
    /// </summary>
    /// <param name="_code">
    /// The credit card authorization code.
    /// </param>
    /// <param name="Authorize">
    /// A Boolean value to either authorize or decline the payment.
    /// </param>
    /// <returns>
    /// The status of payment.
    /// </returns>
    MCRCustPaymStatus processPaymManually(str _code = '', boolean Authorize = true)
    {
        MCRCustPaymTotals   mcrCustPaymTotals;
        AmountCur           postAmount = 0;
        SalesTable          salesTable;

        ttsBegin;
        if (Authorize)
        {
            if (mcrCustPaymTable.Amount > 0)
            {
                mcrCustPaymTable.Status = this.authorizeChargeManually(_code);
            }
            else if (mcrCustPaymTable.Amount < 0)
            {
                mcrCustpaymTable.Status = this.authorizeRefundManually(_code);
            }
            else
            {
                ttsabort;
                return mcrCustPaymTable.Status;
            }
            // Write manual authorize event.
            MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::ManualAuthorize,
                        mcrCustPaymTable, CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId));

            mcrCustPaymTable.update();
            mcrCustPaymTotals = mcrCustPaymTotals::construct(mcrCustPaymTable.RefTableId, mcrCustPaymTable.RefRecId);

            // Only want to post pre-pays
            if (mcrCustPaymTable.IsPrepay)
            {
                postAmount = mcrCustPaymtable.getUnpostedAmount();
            }
            if (this.canPost(postAmount))
            {
                this.post(postAmount, mcrCustPaymTable.IsPrepay);
                mcrCustPaymTotals.settlePayments();
            }
        }
        else
        {
            if (mcrCustPaymTable.Amount > 0)
            {
                mcrCustPaymTable.Status = this.declineChargeManually(_code);
            }
            else if (mcrCustPaymTable.Amount < 0)
            {
                mcrCustPaymTable.Status = this.declineRefundManually(_code);
            }
            else
            {
                mcrCustPaymTable.Status = MCRCustPaymStatus::Declined;
            }

            // Write manual decline event.
            MCRCustPaymEvent::insertPaymEvent(MCRPaymentEventType::ManualDecline,
                        mcrCustPaymTable,CreditCardAuthTrans::mcrFindLatest(mcrCustPaymTable.RecId));

            mcrCustPaymTable.update();
        }
        ttsCommit;

        if (!mcrCustPaymTotals)
        {
            mcrCustPaymTotals = mcrCustPaymTotals::construct(mcrCustPaymTable.RefTableId, mcrCustPaymTable.RefRecId);
        }
        mcrCustPaymTotals.setTransStatus();

        if (mcrCustPaymTable.RefTableId == tablenum(SalesTable))
        {
            salesTable = SalesTable::findRecId(mcrCustPaymTable.RefRecId, true);
        }
        if (mcrCustPaymTable.RefTableId == tablenum(CustPaymSchedLine))
        {
            salesTable = mcrCustPaymTable.salesTable();
        }
        if (salesTable)
        {
            salesTable.updateBackStatus();
        }
        return mcrCustPaymTable.Status;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateAuthorize</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates this payment for authorization.
    /// </summary>
    /// <param name="_showErrors">
    ///     A boolean determing whether to write errors to the infolog; optional.
    /// </param>
    /// <returns>
    ///     true if all data for this payment is valid and the payment should
    ///     be allowed to be submitted for authorization; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     If the return value is false, then this payment is not allowed to be
    ///     submitted for authorization.
    ///     When extending this method, do the following:
    ///     1) Provide an infolog prefix ("setPrefix") indicating the payment
    ///     method and amount of the payment.
    ///     2) Invoke "super".
    ///     3) Perform additional validations, writing errors to the infolog
    ///     only if _showErrors is true.
    /// </remarks>
    boolean validateAuthorize(boolean _showErrors = true)
    {
        MCRCustPaymTotals mcrCustPaymTotals;

        boolean isValid = true;

        setPrefix(strfmt("@MCR32270", mcrCustPaymTable.TenderTypeId,
                         mcrCustPaymTable.Amount));

        mcrCustPaymTotals = MCRCustPaymTotals::construct(mcrCustPaymTable.RefTableId,
                                                      mcrCustPaymTable.RefRecId);

        // The account on this payment must be the same as the invoice account
        //  for the related entity (sales order or free-text invoice).
        // Note that this error should not occur in production.  This check will
        //  catch programming errors.
        if (mcrCustPaymTotals
            && mcrCustPaymTable.CustAccount != mcrCustPaymTotals.getInvoiceAccount())
        {
            isValid = false;

            if (_showErrors)
            {
                error("@MCR11251");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateDelete</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Determines whether the record is allowed to be deleted.
    /// </summary>
    /// <param name="_showErrors">
    ///     A boolean determing whether to write errors to the infolog; optional.
    /// </param>
    /// <returns>
    ///     true if the record is allowed to be deleted; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     Don't allow deletion if the payment is posted at all.
    /// </remarks>
    boolean validateDelete(boolean _showErrors = true)
    {
        boolean isValid = true;

        // do not allow deletion of payments that have been posted in any amount
        if (mcrCustPaymTable.PostedAmount != 0)
        {
            isValid = false;

            if (_showErrors)
            {
                error("@MCR10674");
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates that the specified amount may be posted.
    /// </summary>
    /// <param name="_amount">
    ///     The amount to be posted if validated.
    /// </param>
    /// <param name="_showErrors">
    ///     A boolean determing whether to write errors to the infolog; optional.
    /// </param>
    /// <returns>
    ///     true if it is allowed to post the specified amount for this
    ///     payment; otherwise false.
    /// </returns>
    boolean validatePost(Amount _amount, boolean _showErrors = true)
    {
        boolean isValid = true;

        Amount unpostedAmount = mcrCustPaymTable.getUnpostedAmount();

        // this payment must be Posted/Paid
        if (mcrCustPaymTable.Status != MCRCustPaymStatus::Posted
            && mcrCustPaymTable.Status != MCRCustPaymStatus::Paid)
        {
            isValid = false;

            if (_showErrors)
            {
                error(strfmt("@MCR30348", enum2str(mcrCustPaymTable.Status)));
            }
        }

        // must be a non-zero amount
        if (_amount == 0.0)
        {
            isValid = false;

            if (_showErrors)
            {
                error(strfmt("@MCR10796", num2str(_amount, 1, 2, -1, -1)));
            }
        }

        // the amount must have the same sign as the unposted payment amount
        if (isValid && sign(_amount) != sign(unpostedAmount))
        {
            isValid = false;

            if (_showErrors)
            {
                error(strfmt("@MCR10796", num2str(_amount, 1, 2, -1, -1)));
            }
        }

        // the amount may not be greater than the unposted payment amount
        if (isValid && abs(_amount) > abs(unpostedAmount))
        {
            isValid = false;

            if (_showErrors)
            {
                error(strfmt("@MCR10796", num2str(_amount, 1, 2, -1, -1)));
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateWrite</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Validates this payment for an insert or update.
    /// </summary>
    /// <param name="_showErrors">
    ///     A boolean determing whether to write errors to the infolog; optional.
    /// </param>
    /// <param name="_validateAccountSetup">
    ///     A boolean determing whether to validate if an account is
    ///     setup on the <c>RetailStoreTenderTypeTable</c>; optional.
    /// </param>
    /// <returns>
    ///     true if all data for this payment is valid and should be allowed
    ///     to be saved to the database; otherwise, false.
    /// </returns>
    /// <remarks>
    ///     If the return value is false, then this payment should not be saved to
    ///     the database.
    /// </remarks>
    boolean validateWrite(boolean _showErrors = true,
                          boolean _validateAccountSetup = true)
    {
        boolean isValid = true;
        RetailStoreTenderTypeTable retailStoreTenderTypeTable;
        SalesTable salesTable;
        SalesLine salesLine;
        boolean paymentsEnabled;

        // The payments enabled has to be determined either by the channel if user is in the channel
        // in case of SalesTable, and by user if the payment is applied to a free text or the payment journal.
        switch (mcrCustPaymTable.RefTableId)
        {
            case tableNum(SalesTable) :
                paymentsEnabled = true;
                break;
            default:
                paymentsEnabled = RetailMCRChannelTable::mcrEnableOrderCompletionFindByUser();
                break;
        }
        // If the order parameters to enable order completion is off
        // then MCR payments are disabled and no record should be created in
        // the MCRCustPaymTable
        if (!paymentsEnabled)
        {
            throw error("@MCR40424");
        }
        // The Payment SDK does not support free standing refunds
        // coming from Freetextinvoices or from payment journals so validate that these
        // refunds cannot be created.
        if (this.isRefundAllowed(mcrCustPaymTable))
        {
            throw error("@MCR40444");
        }
        // percent amount must be within the range 0 to 100
        if (this.isPercentAmountBetweenZeroAndHundred(mcrCustPaymTable))
        {
            isValid = false;

            if (_showErrors)
            {
                error("@MCR32248");
            }
        }

        // Prevent amount from being reduced more than the posted amount to avoid financial implications and changing of existing capture to a refund and vice-versa.
        // If reqd, customer must create a new payment line.
        if( (mcrCustPaymTable.PostedAmount > 0 && mcrCustPaymTable.PostedAmount - mcrCustPaymTable.Amount > 0) ||
            (mcrCustPaymTable.PostedAmount < 0 && mcrCustPaymTable.PostedAmount - mcrCustPaymTable.Amount < 0))
        {
            isValid = false;

            if (_showErrors)
            {
                error(strFmt("@MCR:PaymentAmountUpdatedBeyondPostedPaymentAmount", mcrCustPaymTable.PostedAmount));
            }
        }

        retailStoreTenderTypeTable = RetailStoreTenderTypeTable::find(mcrCustPaymTable.Channel,
                                                                        mcrCustPaymTable.TenderTypeId);

        if (!retailStoreTenderTypeTable)
        {
            isValid = false;
            if (_showErrors)
            {
                error(strFmt("@MCR40425",
                    mcrCustPaymTable.TenderTypeId,
                    RetailChannelTable::findByRecId(mcrCustPaymTable.Channel).name()));
            }
        }
        // payment account is required if parameter is true
        else if (this.isPaymentAccountNeeded(retailStoreTenderTypeTable, _validateAccountSetup))
        {
            isValid = false;
            if (_showErrors)
            {
                error(strFmt("@MCR10845", mcrCustPaymTable.TenderTypeId));
            }
        }

        isValid = this.hasPaymTypeData() && isValid;

        // If this payment is a refund and the Payment Type is Credit Card, we validate if this credit card
        // was previously used to pay the order, blocking refunds to credit cards not used in the original trx
        // unless the user has the permissions to refund to an alternate payment method.

        if (this.checkTableId())
        {
            select firstonly RecId from salesLine
                where salesLine.SalesId == mcrCustPaymTable.salesTable().SalesId &&
                    (salesLine.InventTransIdReturn || salesLine.SalesQty < 0);

            if (this.isSalesLineAndCustPaymTypeCreditCard(salesLine, mcrCustPaymTable))
            {
                RecId originalSalesTableRecId = MCRCustPaym::findOriginalCreditCardPayment(mcrCustPaymTable);

                if (originalSalesTableRecId == 0)
                {
                    isValid = false;
                    if (_showErrors)
                    {
                        error("@Retail:InvalidRefundCreditCard");
                    }
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOriginalCreditCardPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the credit card payment used on the original order, returns 0 if not found.
    /// </summary>
    /// <param name = "_mcrCustPaymTable">The refund MCRCustPaymTable row.</param>
    /// <returns></returns>
    private static RecId findOriginalCreditCardPayment(MCRCustPaymTable _mcrCustPaymTable)
    {
        MCRCustPaymTable originalCCPayments;
        RecId originalSalesTableRecId = SalesTable::find(_mcrCustPaymTable.salesTable().mcrReturnSalesTable().OriginalSalesId).RecId;

        select firstonly RecId
                    from originalCCPayments
                        where originalCCPayments.RefTableId == _mcrCustPaymTable.RefTableId &&
                              (originalCCPayments.RefRecId == _mcrCustPaymTable.RefRecId || originalCCPayments.RefRecId == originalSalesTableRecId) &&
                              originalCCPayments.PaymInfoTableId == _mcrCustPaymTable.PaymInfoTableId &&
                              originalCCPayments.PaymInfoRecId == _mcrCustPaymTable.PaymInfoRecId &&
                              originalCCPayments.Amount > 0 &&
                              (originalCCPayments.Status == MCRCustPaymStatus::Paid ||
                               originalCCPayments.Status == MCRCustPaymStatus::Posted);

        if (!originalCCPayments)
        {
            // Incremental capture leave status as authorized if funds are still available to be captured.
            select firstonly RecId
                    from originalCCPayments
                        where originalCCPayments.RefTableId == _mcrCustPaymTable.RefTableId &&
                              (originalCCPayments.RefRecId == _mcrCustPaymTable.RefRecId || originalCCPayments.RefRecId == originalSalesTableRecId) &&
                              originalCCPayments.PaymInfoTableId == _mcrCustPaymTable.PaymInfoTableId &&
                              originalCCPayments.PaymInfoRecId == _mcrCustPaymTable.PaymInfoRecId &&
                              originalCCPayments.Amount > 0 &&
                              originalCCPayments.Status == MCRCustPaymStatus::Authorized;

            if (originalCCPayments.RecId != 0 && !CreditCardAuthTrans::existsIncrementalCaptureAmount(originalCCPayments.RecId))
            {
                originalCCPayments.clear();
            }
        }

        return originalCCPayments.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTableId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the reference table ID of <c>MCRCustPaymTable</c> record is matched with the <c>SalesTable</c> ID
    /// to check if the credit card was previously used to pay the order to process the payment.
    /// </summary>
    /// <returns>
    /// Returns true if the table ID matches; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean checkTableId()
    {
        return (mcrCustPaymTable.RefTableId == tableNum(SalesTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRefundAllowed</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if a refund can be created from freetextinvoices or payment journals.
    /// </summary>
    /// <param name= "_mcrCustPaymTable">
    /// The record buffer of <c>MCRCustPaymTable</c> table.
    /// </param>
    /// <returns>
    /// True if a refund can be created from freetextinvoices or payment journals; otherwise false.
    /// </returns>
    protected boolean isRefundAllowed(MCRCustPaymTable _mcrCustPaymTable)
    {
        return ((_mcrCustPaymTable.RefTableId == tableNum(custInvoiceTable)
                || _mcrCustPaymTable.RefTableId == tableNum(LedgerJournalTrans))
                && _mcrCustPaymTable.Amount < 0.0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPercentAmountBetweenZeroAndHundred</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the <c>PercentAmount</c> field of <c>MCRCustPaymTable</c> is between zero and hundred.
    /// </summary>
    /// <param name = "_mcrCustPaymTable">
    /// The record buffer of <c>MCRCustPaymTable</c> table.
    /// </param>
    /// <returns>
    /// True if <c>PercentAmount</c> field of <c>MCRCustPaymTable</c> is between zero and hundred; otherwise, false.
    /// </returns>
    protected boolean isPercentAmountBetweenZeroAndHundred(MCRCustPaymTable _mcrCustPaymTable)
    {
        return (_mcrCustPaymTable.PercentAmount < 0.0
            || _mcrCustPaymTable.PercentAmount > 100.0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPaymentAccountNeeded</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the payment account is required.
    /// </summary>
    /// <param name = "_retailStoreTenderTypeTable">
    /// The record buffer of <c>RetailStoreTenderTypeTable</c> table.
    /// </param>
    /// <param name = "_validateAccountSetup">
    /// A boolean value.
    /// </param>
    /// <returns>
    /// True if payment account is not required; otherwise, false.
    /// </returns>
    protected boolean isPaymentAccountNeeded(RetailStoreTenderTypeTable _retailStoreTenderTypeTable, boolean _validateAccountSetup)
    {
        return (_validateAccountSetup
            && _retailStoreTenderTypeTable.LedgerDimension == 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSalesLineAndCustPaymTypeCreditCard</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if salesLine has recId and field <c>CustPaymType</c> of <c>MCRCustPaymTable</c> is credit card.
    /// </summary>
    /// <param name = "_salesLine">
    /// The record buffer of <c>SalesLine</c> table.
    /// </param>
    /// <param name = "_mcrCustPaymTable">
    /// The record buffer of <c>MCRCustPaymTable</c> table.
    /// </param>
    /// <returns>
    /// True if payment account is not required; otherwise, false.
    /// </returns>
    protected boolean isSalesLineAndCustPaymTypeCreditCard(SalesLine _salesLine, MCRCustPaymTable _mcrCustPaymTable)
    {
        return (_salesLine && _mcrCustPaymTable.CustPaymType == MCRCustPaymType::CreditCard && !_mcrCustPaymTable.allowAlternatePaymentMethod());
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a new customer payment instance.
    /// </summary>
    /// <param name="_custPaymTable">
    ///     The <c>MCRCustPaymTable</c> record for which this class is constructed.
    /// </param>
    /// <param name="_allowUserInput">
    ///     Specifies whether user interaction is allowed during operations on the payment; optional.
    /// </param>
    /// <param name="_creditCardCustReversal">
    ///     An <c>CreditCardAuthTrans</c> record that denotes reversal; optional.
    /// </param>
    /// <returns>
    ///     A new instance of this class if it is possible; otherwise, null.
    /// </returns>
    /// <remarks>
    ///     The actual type of the instance is determined by the payment type.
    ///     Whenever a new class extends this class, this method should be modified
    ///     to instantiate the new class when appropriate.
    /// </remarks>
    public static MCRCustPaym construct(MCRCustPaymTable    _custPaymTable,
                                    boolean                 _allowUserInput      = false,
                                    CreditCardAuthTrans     _creditCardCustReversal = NULL)
    {
        MCRCustPaym custPaym;
        switch (_custPaymTable.CustPaymType)
        {
            case MCRCustPaymType::Cash:
                custPaym = new MCRCustPaym_Cash(_custPaymTable, _allowUserInput);
                break;

            case MCRCustPaymType::LoyaltyCard:
                custPaym = new MCRCustPaym_LoyaltyCard(_custPaymTable, _allowUserInput);
                break;

            case MCRCustPaymType::Check:
                custPaym = new MCRCustPaym_Check(_custPaymTable, _allowUserInput);
                break;

            case MCRCustPaymType::CreditCard:
                custPaym = new MCRCustPaym_CreditCard(_custPaymTable, _allowUserInput, _creditCardCustReversal);
                break;
            // Add gift card to the gift cert logic as
            // underneath the covers these two behave the same way.
            case MCRCustPaymType::GiftCard:
                if (_custPaymTable.PaymInfoTableId == tableNum(RetailExternalGiftCardTable))
                {
                    custPaym = new MCRCustPaym_ExternalGiftCard(_custPaymTable, _allowUserInput, _creditCardCustReversal);
                }
                else
                {
                    custPaym = new MCRCustPaym_GiftCard(_custPaymTable, _allowUserInput);
                }
                break;

            case MCRCustPaymType::OnAccount:
                custPaym = new MCRCustPaym_OnAccount(_custPaymTable, _allowUserInput);
                break;
            // Returns
            case MCRCustPaymType::RefundCheck:
                custPaym = new MCRCustPaym_RefundCheck(_custPaymTable, _allowUserInput);
                break;

            default:    // unhandled case
                custPaym = MCRCustPaym::mcrCustPaym_Default(_custPaymTable, _allowUserInput, _creditCardCustReversal);
        }

        return custPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrCustPaym_Default</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Constructs a new customer payment instance in defult block otherwise returns null.
    /// </summary>
    /// <param name = "_custPaymTable">
    ///     The <c>MCRCustPaymTable</c> record for which this class is constructed.
    /// </param>
    /// <param name = "_allowUserInput">
    ///     Specifies whether user interaction is allowed during operations on the payment.
    /// </param>
    /// <param name = "_creditCardCustReversal">
    ///     An <c>CreditCardAuthTrans</c> record that denotes reversal
    /// </param>
    /// <returns>
    ///     A new instance of this class if it is possible; otherwise, null.
    /// </returns>
    [Replaceable]
    protected static MCRCustPaym mcrCustPaym_Default(MCRCustPaymTable _custPaymTable,
                                              boolean _allowUserInput,
                                              CreditCardAuthTrans _creditCardCustReversal)
    {
        // Rather than allowing a stack trace error, throw an error message
        throw error(strfmt("@MCR30889", _custPaymTable.CustPaymType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default dimension of the <c>LedgerJournalTrans</c> table record.
    /// </summary>
    /// <param name="_defaultDimension">
    /// The <c>DimensionDefault</c> to be set on the <c>LedgerJournalTrans</c> table record.
    /// </param>
    /// <returns>
    /// The default dimension set on the <c>LedgerJournalTrans</c> table record.
    /// </returns>
    public DimensionDefault parmDefaultDimension(DimensionDefault _defaultDimension = defaultDimension)
    {
        defaultDimension = _defaultDimension;
        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymReference</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets or sets an identifier for this payment.
    /// </summary>
    /// <param name="_paymReference">
    /// The <c>string</c> identifier for this payment.
    /// </param>
    /// <returns>
    ///     An <c>string</c> of an identifier for this payment..
    /// </returns>
    /// <remarks>
    ///     The payment reference iswritten to the ledger
    ///     journal during posting, and is intended to
    ///     identify this payment on a bank deposit slip
    ///     or for other financial records.
    /// </remarks>
    public str parmPaymReference(str _paymReference = paymReference)
    {
        paymReference = _paymReference;
        return paymReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the customer posting profile.
    /// </summary>
    /// <param name = "_isPrepay">
    /// A boolean value determining if the amount paid is a prepay or not.
    /// </param>
    /// <returns>
    /// The posting profile that is associated with the <c>MCRCustPaymTotals</c> instance if the payment
    /// total is non-zero; otherwise, the posting profile that is associated with the <c>CustParameters</c> table.
    /// </returns>
    [Replaceable]
    protected CustPostingProfile getCustomerPostingProfile(boolean _isPrepay)
    {
        //  Need to retrieve more than one piece of information from totals
        //  so instantiating the object here rather than calling methods
        //  on MCRCustPaymTable
        CustPostingProfile  postingProfileVal;
        MCRCustPaymTotals   mcrCustPaymTotals;

        mcrCustPaymTotals = MCRCustPaymTotals::construct(mcrCustPaymTable.RefTableId, mcrCustPaymTable.RefRecId);

        if (mcrCustPaymTotals)
        {
            // If posting a prepay, need to determine the profile rather than using the related
            //      records profile. This only applies to sales orders.
            postingProfileVal = mcrCustPaymTotals.getPostingProfile(_isPrepay);
        }
        else
        {
            postingProfileVal = CustParameters::find().PostingProfile;
        }

        return postingProfileVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCommonMCRLedgerJournalData</Name>
				<Source><![CDATA[
    private void initCommonMCRLedgerJournalData(boolean _isPrepay, boolean _isReturn)
    {
        ExchRate        exchRate;
        Num             paymOrderId;
        CurrencyCode    currency;

        // <GEERU>
        CustParameters  custParms;

        boolean countryRegion_W  = SysCountryRegionCode::isLegalEntityInCountryRegion(#easternEuropeAllandRU);
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        // </GEERU>

        paymOrderId = mcrCustPaymTable.displayOrderID();
        // Get the current exchange rate.
        currency    = mcrCustPaymTable.getCurrency();
        // Retrieve the exchange rate from the exchange rates table.
        exchRate    = ExchangeRateHelper::exchRate(currency);

        if (_isPrepay)
        {
            // <GEERU>
            if (countryRegion_W)
            {
                if (!_isReturn)
                {
                    custParms = CustParameters::find();

                    mcrLedgerJournal.parmTaxGroup(custParms.TaxGroup_RU);
                    mcrLedgerJournal.parmTaxItemGroup(custParms.TaxItemGroup_RU);

                    if (countryRegion_RU)
                    {
                        mcrLedgerJournal.parmCustFactureAutoCreate_RU(custParms.PrepaymentFactureAutoCreate_RU);
                    }
                }
            }
            // </GEERU>
            else if (CustParameters::find().TaxOnPrepayment)
            {
                mcrLedgerJournal.parmTaxGroup(SalesTable::find(paymOrderId).TaxGroup);
                mcrLedgerJournal.parmTaxItemGroup(TaxParameters::find().TaxItemGroup);
            }
        }

        mcrLedgerJournal.parmExchRate(exchRate);
        mcrLedgerJournal.parmCurrencyCode(currency);
        mcrLedgerJournal.parmTransDate(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        mcrLedgerJournal.parmTransTxt(strFmt("@MCR10835",
                                        paymOrderId, enum2str(mcrCustPaymTable.CustPaymType)));
        mcrLedgerJournal.parmPaymReference(this.parmPaymReference());
        mcrLedgerJournal.parmMCRPaymOrderID(paymOrderId);
        mcrLedgerJournal.parmMCRRefPaymID(mcrCustPaymTable.RecId);
        mcrLedgerJournal.parmTransactionType(LedgerTransType::Payment);
        mcrLedgerJournal.parmBankTransType(RetailStoreTenderTypeTable::find(mcrCustPaymTable.Channel, mcrCustPaymTable.TenderTypeId).bankTransactionType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMCRLedgerJournalDataCustPayment</Name>
				<Source><![CDATA[
    private void initMCRLedgerJournalDataCustPayment(boolean _isPrepay, LedgerJournalACType _offsetType, LedgerDimensionDefaultAccount _offsetAccount)
    {
        PostingProfile                  postingProfileVal;

        postingProfileVal = this.getCustomerPostingProfile(_isPrepay);

        mcrLedgerJournal.parmPostingProfile(postingProfileVal);
        if (_offsetType == LedgerJournalACType::Ledger)
        {
            mcrLedgerJournal.parmledgerOffsetAccount(
                MCRAssistantLedgerDimension::mergeAccountAndDimension(
                    LedgerDimensionFacade::getMainAccountRecIdFromLedgerDimension(_offsetAccount), this.parmDefaultDimension()));
        }
        else
        {
            mcrLedgerJournal.parmledgerOffsetAccount(_offsetAccount);
        }
        mcrLedgerJournal.parmLedgerOffsetAccountType(_offsetType);
        mcrLedgerJournal.parmDefaultDimension(ledgerJournalTable.DefaultDimension);
        mcrLedgerJournal.parmOffsetDefaultDimension(this.parmDefaultDimension());
        mcrLedgerJournal.parmAccountNum(mcrCustPaymTable.CustAccount);
        mcrLedgerJournal.parmBankTransType(RetailStoreTenderTypeTable::find(mcrCustPaymTable.Channel, mcrCustPaymTable.TenderTypeId).bankTransactionType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMCRLedgerJournalDataRCash</Name>
				<Source><![CDATA[
    private void initMCRLedgerJournalDataRCash(boolean _isPrepay, LedgerJournalACType _accountType, LedgerDimensionDefaultAccount _account)
    {
        PostingProfile                  postingProfileVal;
        PostingProfile                  offsetPostingProfileVal;

        offsetPostingProfileVal = this.getCustomerPostingProfile(_isPrepay);
        postingProfileVal       = RCashParameters::find().PostingProfile;

        mcrLedgerJournal.parmPostingProfile(postingProfileVal);
        mcrLedgerJournal.parmOffsetPostingProfile_RU(offsetPostingProfileVal);
        mcrLedgerJournal.parmLedgerAccountType(_accountType);
        mcrLedgerJournal.parmLedgerAccount(_account);
        mcrLedgerJournal.parmLedgerOffsetAccountType(LedgerJournalACType::Cust);
        mcrLedgerJournal.parmLedgerOffsetAccount(LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(mcrCustPaymTable.CustAccount, LedgerJournalACType::Cust));
        mcrLedgerJournal.parmDefaultDimension(this.parmDefaultDimension());
        mcrLedgerJournal.parmOffsetDefaultDimension(ledgerJournalTable.DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setMethodOfPaymentInPostedLedger</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set the method of payment on the customer payment journal line.
    /// </summary>
    private void setMethodOfPaymentInPostedLedger()
    {
        if (mcrCustPaymTable.RecId == 0)
        {
            return;
        }

        LedgerJournalTrans ledgerJournalTransLocal;

        select firstonly forupdate ledgerJournalTransLocal
            order by ledgerJournalTransLocal.RecId desc
            where ledgerJournalTransLocal.MCRRefPaymID == mcrCustPaymTable.RecId;

        if (ledgerJournalTransLocal.RecId != 0
            && ledgerJournalTransLocal.PaymMode == strMin())
        {
            ledgerJournalTransLocal.PaymMode = mcrCustPaymTable.getMethodOfPayment();

            ttsbegin;
            ledgerJournalTransLocal.update();
            ttscommit;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>