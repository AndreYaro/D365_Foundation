<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustInterestPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class CustInterestPost extends RunBaseBatch implements BatchRetryable
{
    CustInterestJour parmCustInterestJour;

    QueryRun queryRun;

    DialogField dialogPostingDate;
    DialogField dialogInterestByTrans;

    TransDate postingDate;
    NoYes interestPerTrans;
    // <GEEPL>
    NoYes printNote_PL;
    DialogField dialogPrintNote;
    // </GEEPL>

    Counter progressCounter;

    int dialogBillingClassificationNamesId;
    FormStringControl dialogBillingClassificationIds;
    DialogField dialogInclTransWithNoBillingClassifications;
    DialogField dialogBillingClassification;
    BillingClassification billingClassification;
    CustInterestJour billingClassCustInterestJour;

    str billingClassificationIds;
    NoYes inclTransWithNoBillingClassifications;
    SysLookupMultiSelectCtrl custBillingClassificationLookup;
    boolean isBillingClassificationEnabled;
    container printInterestReport;
    const int CurrentVersion = 10;

    #define.CustBillingClassificatiionLookup('CustBillingClassificationLookup')
    #define.BillingCalssificationSelected(',0')
    #define.NoBillingClassificationSelected('0')
    // <GEEPL>

    #DEFINE.CurrentVersion(CurrentVersion)
    #LOCALMACRO.CurrentList
        PostingDate,
        InterestPerTrans,
        billingClassificationIds,
        billingClassCustInterestJour,
        printNote_PL,
        isBillingClassificationEnabled,
        printInterestReport
    #ENDMACRO
    // </GEEPL>

    #LOCALMACRO.CurrentList_v4
            PostingDate,
            InterestPerTrans
    #ENDMACRO

    // <GEEPL>
    #define.Version7(7)
    #LOCALMACRO.CurrentList_v7
        PostingDate,
        InterestPerTrans,
        billingClassificationIds,
        billingClassCustInterestJour
    #ENDMACRO
    // </GEEPL>

    #LOCALMACRO.CurrentList_v8
        PostingDate,
        InterestPerTrans,
        billingClassificationIds,
        billingClassCustInterestJour,
        printNote_PL
    #ENDMACRO

    #ISOCountryRegionCodes
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addLedgerTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the transactions to the ledger voucher.
    /// </summary>
    /// <param name="_ledgerVoucher">
    /// A ledger voucher.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The posting type of the general journal entry.
    /// </param>
    /// <param name="_postingLedgerDimension">
    /// The ledger dimension that is used for posting.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code that is associated with the interest note.
    /// </param>
    /// <param name="_postingAmount">
    /// The interest amount.
    /// </param>
    /// <param name="_currencyExchangeHelper">
    /// The accounting currency amount and reporting currency amount exchange rates.
    /// </param>
    /// <param name="_tableId">
    /// The table ID of the transaction table.
    /// </param>
    /// <param name="_interestRecId">
    /// The record ID of the interest transaction.
    /// </param>
    private void addLedgerTrans(LedgerVoucher _ledgerVoucher,
                                LedgerPostingType _ledgerPostingType,
                                LedgerDimensionAccount _postingLedgerDimension,
                                CurrencyCode _currencyCode,
                                AmountCur _postingAmount,
                                CurrencyExchangeHelper _currencyExchangeHelper,
                                TableId _tableId,
                                RefRecId _interestRecId)
    {
        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
        LedgerVoucherTransObject ledgerVoucherTransObject;

        ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(
                                                                ledgerVoucherObject,
                                                                _ledgerPostingType,
                                                                _postingLedgerDimension,
                                                                _currencyCode,
                                                                _postingAmount,
                                                                _currencyExchangeHelper);

        ledgerVoucherTransObject.parmTaxParentReferenceTableId(_tableId);
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(_interestRecId);
        _ledgerVoucher.addTrans(ledgerVoucherTransObject);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerTransByPostingDefinition</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds the transactions in a ledger voucher with regard to the posting definition.
    /// </summary>
    /// <param name="_ledgerDimension">
    /// The ledger dimension that is associated with the interest transaction.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher.
    /// </param>
    /// <param name="_postingAmount">
    /// The interest amount.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code that is associated with the interest note.
    /// </param>
    /// <param name="_currencyExchangeHelper">
    /// The currency exchange criteria that belongs to the interest note.
    /// </param>
    /// <param name="_billingCodeRecId">
    /// The record ID of the billing code that is associated with the interest line.
    /// </param>
    /// <param name="_billingClassRefRecId">
    /// The record ID of the billing class that is associated with the interest note.
    /// </param>
    /// <param name="_transDate">
    /// The transaction date.
    /// </param>
    /// <param name="_tableId">
    /// The table ID of the interest transaction.
    /// </param>
    /// <param name="_interestRecId">
    /// The record ID of the interest transaction.
    /// </param>
    /// <param name="_revenuePostingType">
    /// The posting type for the transaction
    /// </param>
    private void addLedgerTransByPostingDefinition(
        LedgerDimensionAccount          _ledgerDimension,
        LedgerVoucher                   _ledgerVoucher,
        AmountCur                       _postingAmount,
        CurrencyCode                    _currencyCode,
        CurrencyExchangeHelper          _currencyExchangeHelper,
        BillingCodeRefRecId             _billingCodeRecId,
        BillingClassificationRefRecId   _billingClassRefRecId,
        TransDate                       _transDate,
        TableId                         _tableId,
        RecId                           _interestRecId,
        LedgerPostingType               _revenuePostingType = LedgerPostingType::CustInterest)
    {
        JournalizingDefinitionManager   journalizingDefinitionManager =  JournalizingDefinitionManager::newJournalizingDefinitionManagerCustomer(_billingCodeRecId, _billingClassRefRecId, _transDate, LedgerPostingType::CustInterest);
        List                            journalizingDefinitionLedgerDimensions;
        ListEnumerator                  journalizingDefListEnumerator;
        LedgerDimensionAccount          ledgerDimensionAccount;
        JournalizingDefinitionEntry     generatedOutput;
        InterestAmountCur               interestAmountCur;
        JournalizingDefinitionId        journalizingDefinitionId;
        LedgerPostingType               postingType;

        journalizingDefinitionManager.parmTransactionType(LedgerPostingType::CustInterest);

        journalizingDefinitionId = journalizingDefinitionManager.getDefaultJournalizingDefinition();

        if (!journalizingDefinitionId)
        {
            throw error(strFmt("@SPS1133",journalizingDefinitionManager.parmTransactionType()));
        }

        journalizingDefinitionManager.parmJournalizingDefinition(journalizingDefinitionId);

        journalizingDefinitionLedgerDimensions = journalizingDefinitionManager.getSystemGeneratedEntries(DebitCredit::Debit, _ledgerDimension);

        if (journalizingDefinitionLedgerDimensions.elements() == 0)
        {
            throw error(strFmt("@SPS668", JournalizingDefinition::findByRecId(journalizingDefinitionId).JournalizingDefinitionCode));
        }

        journalizingDefListEnumerator = journalizingDefinitionLedgerDimensions.getEnumerator();

        //Posting the originating entry
        if (_revenuePostingType != LedgerPostingType::Tax)
        {
            this.addLedgerTrans(_ledgerVoucher,
                                _revenuePostingType,
                                _ledgerDimension,
                                _currencyCode,
                                - _postingAmount,
                                _currencyExchangeHelper,
                                _tableId,
                                _interestRecId);
        }

        //Posting the generated entries that found with the help of posting definition
        while (journalizingDefListEnumerator.moveNext())
        {
            generatedOutput = journalizingDefListEnumerator.current();
            postingType     = LedgerPostingType::CustBalance;

            if (generatedOutput.parmJournalizingDefinitionDebitCredit() == DebitCredit::Debit)
            {
                interestAmountCur = _postingAmount * -1;
            }
            else
            {
                interestAmountCur = _postingAmount;
            }

            ledgerDimensionAccount = generatedOutput.parmLedgerDimension();

            this.addLedgerTrans(
                    _ledgerVoucher,
                    postingType,
                    ledgerDimensionAccount,
                    _currencyCode,
                    interestAmountCur,
                    _currencyExchangeHelper,
                    _tableId,
                    _interestRecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canGoBatchJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the class is shown in the list of <c>Journal</c> types.
    /// </summary>
    /// <returns>
    /// true if the class is shown in the list of <c>Journal</c> types; otherwise, false.
    /// </returns>
    /// <remarks>
    /// A class that can be used in a batch journal is a class where the same parameters can be used
    /// repeatedly. The dialog box can be shown and the parameters can be changed. However, parameters of
    /// some classes might build on data that is only valid for a short time. Running a class two times
    /// with the same parameters is not always possible. If the <see cref="M:RunBaseBatch.canGoBatch" />
    /// method returns false, this method will not have any effect.
    /// </remarks>
    public boolean canGoBatchJournal()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </summary>
    /// <returns>
    /// A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    /// A dialog box can be either built by using the <c>Dialog</c> class or by using a class that is
    /// created in the Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog;

        FormBuildGroupControl currGroup;
        FormBuildStringControl dialogBillingClassificationNames;

        isBillingClassificationEnabled = CustParameters::isBillingClassificationEnabled();

        dialog = super();

        if (isBillingClassificationEnabled)
        {
            inclTransWithNoBillingClassifications = NoYes::Yes;

            dialog.addGroup().frameType(FormFrameType::None);
            currGroup = dialog.formBuildDesign().control(dialog.curFormGroup().name());

            dialogBillingClassificationNames = currGroup.addControl(FormControlType::String, #CustBillingClassificatiionLookup);
            dialogBillingClassificationNames.helpText("@SPS677");
            dialogBillingClassificationNamesId = dialogBillingClassificationNames.id();

            dialogInclTransWithNoBillingClassifications = dialog.addFieldValue(enumStr(NoYes), inclTransWithNoBillingClassifications, "@SPS691", "@SPS1009");
        }

        dialogPostingDate = dialog.addFieldValue(extendedTypeStr(TransDate), this.postingDate(), "@SYS14475");
        dialogInterestByTrans = dialog.addFieldValue(enumStr(NoYes), interestPerTrans, "@SYS15729");

        // <GEEPL>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            dialogPrintNote = dialog.addFieldValue(enumStr(NoYes), printNote_PL, "@GLS113034");
        }
        // </GEEPL>

        if ((this.parmCustInterestJour().InterestCalcAccountChoice == this.getInterestCalcAccountChoiceTransaction()))

        {
            dialogInterestByTrans.value(NoYes::Yes);
            dialogInterestByTrans.enabled(false);
        }

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialogPostRun</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method is called after dialog() is called, making is possible to add controls after the main dialog()
    /// </summary>
    /// <param name="dialog">
    /// Object for the <c>Dialog</c> form.
    /// </param>
    /// <remarks>
    ///  Adding Mutli-Select lookup for Billing classification.
    /// </remarks>
    public void dialogPostRun(DialogRunbase dialog)
    {
        FormStringControl dialogBillingClassificationNames;

        super(dialog);

        if (isBillingClassificationEnabled)
        {
            dialogBillingClassificationNames = dialog.formRun().design().control(dialogBillingClassificationNamesId);
            dialogBillingClassificationNames.label("@SPS371");

            custBillingClassificationLookup = SysLookupMultiSelectCtrl::construct(dialog.formRun(),
                dialogBillingClassificationNames, queryStr(CustBillingClassificationLookup));

            if (billingClassCustInterestJour.CustBillingClassification)
            {
                custBillingClassificationLookup.set(CustBillingClassification::getCustBillingClassificationContainer(billingClassCustInterestJour.CustBillingClassification));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeRateDate</Name>
				<Source><![CDATA[
    private TransDate getExchangeRateDate(CustInterestJour _custInterestJour)
    {
        TransDate exchangeRateDate;

        if (_custInterestJour.NoteIssueDate_PL)
        {
            exchangeRateDate = _custInterestJour.NoteIssueDate_PL;
        }
        else
        {
            exchangeRateDate = this.postingDate();

            if (exchangeRateDate > _custInterestJour.ToDate)
            {
                exchangeRateDate = _custInterestJour.ToDate;
            }
        }

        return exchangeRateDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFromDialog</Name>
				<Source><![CDATA[
    public boolean getFromDialog()
    {
        if (isBillingClassificationEnabled)
        {
            inclTransWithNoBillingClassifications = dialogInclTransWithNoBillingClassifications.value();
            billingClassificationIds = con2Str(custBillingClassificationLookup.get());

            this.queryBuild();
        }

        postingDate = dialogPostingDate.value();
        interestPerTrans = dialogInterestByTrans.value();
        // <GEEPL>
        if (dialogPrintNote)
        {
            printNote_PL = dialogPrintNote.value();
        }
        // </GEEPL>

        return super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingProfile</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the posting profile that is associated with the interest note or with the interest note
    ///    transaction.
    /// </summary>
    /// <param name="_custInterestJour">
    ///    The interest note buffer.
    /// </param>
    /// <param name="_custTransId">
    ///    The customer transaction record ID; optional.
    /// </param>
    /// <returns>
    ///    The posting profile that is associated with the <c>CustInterestJour</c> buffer if the customer
    ///    transaction ID is zero; otherwise, the posting profile that is associated with the <c>CustTrans</c>
    ///    table.
    /// </returns>
    protected CustPostingProfile getPostingProfile(CustInterestJour _custInterestJour,
                                                   RecId _custTransId = 0)
    {
        CustPostingProfile localPostingProfile;

        if (_custInterestJour.InterestCalcAccountChoice == this.getInterestCalcAccountChoiceTransaction())
        {
            if (_custTransId != 0)
            {
                localPostingProfile = CustTrans::find(_custTransId).PostingProfile;
            }
        }
        else
        {
            localPostingProfile = _custInterestJour.PostingProfile;
        }

        return localPostingProfile;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the internal variables.
    /// </summary>
    /// <remarks>
    /// This method is called when no <c>SysLastValue</c> record can be found when the SysLastValue.GetLast
    /// method is called. Remember to call the <c>super</c> method.
    /// </remarks>
    public void initParmDefault()
    {
        super();

        this.queryBuild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of the <c>CustInterestPost</c> class.
    /// </summary>
    /// <returns>A new instance of the <c>CustInterestPost</c> class.</returns>
    public static CustInterestPost construct()
    {
        return new CustInterestPost();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a new instance of the <c>CustInterestPost</c> class.
    /// </summary>
    /// <remarks>
    /// This method is protected and accessible only from this class or any classes that inherit from it.
    /// Use the construct() method for external instantiation of this class.
    /// </remarks>
    protected void new()
    {
        super();

        queryRun = new QueryRun(queryStr(CustInterestJob));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion, #CurrentList, queryRun.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustInterestJour</Name>
				<Source><![CDATA[
    protected CustInterestJour parmCustInterestJour(CustInterestJour _custInterestJour = parmCustInterestJour)
    {
        parmCustInterestJour = _custInterestJour;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            billingClassCustInterestJour = parmCustInterestJour.data();
        }

        return parmCustInterestJour;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInterestPerTrans</Name>
				<Source><![CDATA[
    protected NoYes parmInterestPerTrans(NoYes _interestPerTrans = interestPerTrans)
    {
        interestPerTrans = _interestPerTrans;
        return interestPerTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingDate</Name>
				<Source><![CDATA[
    protected TransDate postingDate(TransDate _postingDate = postingDate)
    {
        postingDate = _postingDate;
        return postingDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustInterest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Find the current <c>CustInterest</c> record for the current customer and posting profile.
    /// </summary>
    /// <param name = "_custTable">The current <c>CustTable</c> buffer.</param>
    /// <param name = "_postingProfile">The posting profile.</param>
    /// <returns>The current <c>CustInterest</c> record for the current customer and posting profile.</returns>
    protected CustInterest findCustInterest(CustTable _custTable, CustPostingProfile _postingProfile)
    {
        return CustInterest::find(CustLedgerAccounts::custInterest(_custTable.AccountNum, _postingProfile));
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSourceDocumentLineForCustInterestTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>RefRecId</c> for the source document line associated with the <c>CustInterestTransLineIdRef</c> record
    /// </summary>
    /// <param name = "_custInterestTransLineIdRef">The <c>CustInterestTransLineIdRef</c> table buffer.</param>
    /// <returns>The <c>RefRecId</c> for the related <c>SourceDocumentLine</c> record.</returns>
    protected RefRecId getSourceDocumentLineForCustInterestTrans(CustInterestTransLineIdRef _custInterestTransLineIdRef)
    {
        RefRecId transLineSourceDocLineRecId;

        if (_custInterestTransLineIdRef.CustInterestLineType == CustInterestLineType::Customer)
        {
            CustInvoiceLine custInvoiceLine = CustInvoiceLine::findByCustnterestTransLineIdRef(_custInterestTransLineIdRef.RecId);
            transLineSourceDocLineRecId = custInvoiceLine.SourceDocumentLine;
        }
        else
        {
            transLineSourceDocLineRecId = MarkupTrans::findByCustnterestTransLineIdRef(_custInterestTransLineIdRef.RecId).SourceDocumentLine;
        }

        return transLineSourceDocLineRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInterestLedgerAccount_PS</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the interest ledger account for when posting definitions are enabled for Public Sector.
    /// </summary>
    /// <param name = "_ledgerVoucher">The ledger voucher object.</param>
    /// <param name = "_tableId">The tableId of the table to be processed.</param>
    /// <param name = "_custInterestTrans">The <c>CustInterestTrans</c> record.</param>
    /// <param name = "_custInterestTransLine">The <c>CustInterestTransLine</c> record.</param>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_currencyExchangeHelper">The <c>CurrencyExchangeHelper</c> instance.</param>
    /// <param name = "_interestLineAmount">The interest amount for the line.</param>
    /// <remarks>This method is only meant to be consumed when Posting Definitions are enabled for Public Sector.</remarks>
    protected void postInterestLedgerAccount_PS(
        LedgerVoucher _ledgerVoucher,
        TableId _tableId,
        CustInterestTrans _custInterestTrans,
        CustInterestTransLine _custInterestTransLine,
        CustInterestJour _custInterestJour,
        CustCurrencyCode _currencyCode,
        CurrencyExchangeHelper _currencyExchangeHelper,
        InterestAmountCur _interestLineAmount)
    {
        LedgerDimensionAccount mergedLedgerDimension;
        AccountingDistribution accountingDistribution;

        LedgerVoucherObject ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        BillingClassificationRefRecId billingClassificationRecId = CustBillingClassification::find(_custInterestJour.CustBillingClassification).RecId;

        if (_tableId == tableNum(CustInterestTransLine))
        {
            InterestAmountCur distributedAmount = 0; // The sum of the interest line amount that is distributed with respect to the accounting distribution
            Counter accountingDistributionLineCounter = 0;
            InterestAmountCur postingAmount; // The amount of an interest line that will be posted in the voucher.

            CustInterestTransLineIdRef custInterestTransLineIdRef = CustInterestTransLineIdRef::find(_custInterestTransLine.CustInterestTransLineIdRef);
            
            RefRecId transLineSourceDocLineRecId = this.getSourceDocumentLineForCustInterestTrans(custInterestTransLineIdRef);
            
            NumberOfRecords numOFdistributons = AccountingDistribution::numOFDistrubitionsBySDL(transLineSourceDocLineRecId);

            while select AllocationFactor, TransactionCurrencyAmount, LedgerDimension
                from accountingDistribution
                where accountingDistribution.SourceDocumentLine == transLineSourceDocLineRecId
            {
                //Merging interest code ledger dimension with the default dimension of the invoice line
                mergedLedgerDimension = LedgerDimensionFacade::serviceLedgerDimensionFromLedgerDims(
                    CustInterestHelper::getInterestTransLedgerAccount(CustInterestLedgerDimensionsOptions_PSN::InterestLinesLedgerDimension, _custInterestTransLine),
                    accountingDistribution.LedgerDimension);

                postingAmount = CurrencyExchange::round(_interestLineAmount * accountingDistribution.AllocationFactor, _custInterestJour.CurrencyCode);

                distributedAmount = distributedAmount + postingAmount;
                accountingDistributionLineCounter = accountingDistributionLineCounter + 1;

                //Adjusting penny difference
                if (numOFdistributons == accountingDistributionLineCounter && distributedAmount != _interestLineAmount)
                {
                    postingAmount = postingAmount + (_interestLineAmount - distributedAmount);
                }

                this.addLedgerTransByPostingDefinition(mergedLedgerDimension, _ledgerVoucher, postingAmount, _currencyCode, _currencyExchangeHelper,
                     _custInterestTransLine.CustBillingCode, billingClassificationRecId, _custInterestTrans.TransDate, tableNum(CustInterestTrans),
                    _custInterestTrans.RecId);
            }
        }
        else
        {
            mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(
                CustInterestHelper::getInterestTransLedgerAccount(CustInterestLedgerDimensionsOptions_PSN::InterestTransactionLedgerDimension, _custInterestTrans),
                _custInterestJour.DefaultDimension);

            this.addLedgerTransByPostingDefinition(mergedLedgerDimension, _ledgerVoucher, _custInterestTrans.InterestAmount, _currencyCode, 
                _currencyExchangeHelper, 0, billingClassificationRecId, _custInterestTrans.TransDate, tableNum(CustInterestTrans),
                _custInterestTrans.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postInterestWhenPostingDefinitionsAreEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Post interest transactions when posting definitions are enabled.
    /// </summary>
    /// <param name = "_ledgerVoucher">The ledger voucher object.</param>
    /// <param name = "_custInterest">The <c>CustInterest</c> record.</param>
    /// <param name = "_custInterestTrans">The <c>CustInterestTrans</c> record.</param>
    /// <param name = "_custInterestTransLine">The <c>CustInterestTransLine</c> record.</param>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_currencyExchangeHelper">The <c>CurrencyExchangeHelper</c> instance.</param>
    /// <param name = "_interestLineAmount">The interest amount for the line.</param>
    /// <returns>
    /// A container holding the values set during method execution that are needed by the calling methods.
    /// Elements include the <c>CustInterest</c> buffer, the <c>CustInterestTransLine</c> buffer, and the interest line amount.
    /// </returns>
    protected container postInterestWhenPostingDefinitionsAreEnabled(
        LedgerVoucher _ledgerVoucher,
        CustInterest _custInterest,
        CustInterestTrans _custInterestTrans,
        CustInterestTransLine _custInterestTransLine,
        CustInterestJour _custInterestJour,
        CustCurrencyCode _currencyCode,
        CurrencyExchangeHelper _currencyExchangeHelper,
        InterestAmountCur _interestLineAmount)
    {
        // Checks the type of interest transaction before posting its lines, as Free Text invoice can only have interest lines.
        if (CustTrans::find(_custInterestTrans.CustTransId).TransType == LedgerTransType::Cust)
        {
            CustInterestTransLine custInterestTransLineLocal;
            while select custInterestTransLineLocal
                where custInterestTransLineLocal.CustInterestTrans == _custInterestTrans.RecId
            {
                _custInterest = CustInterest::find(custInterestTransLineLocal.CustInterest);
                _interestLineAmount = custInterestTransLineLocal.InterestAmount;

                this.postInterestLedgerAccount_PS(_ledgerVoucher, tableNum(CustInterestTransLine), _custInterestTrans, custInterestTransLineLocal,
                    _custInterestJour, _currencyCode, _currencyExchangeHelper, _interestLineAmount);

                _custInterestTransLine = custInterestTransLineLocal;
            }
        }
        else
        {
            //Do not post the interest line, if the interest transaction is not of Free Text invoice type.
            this.postInterestLedgerAccount_PS(_ledgerVoucher, tableNum(CustInterestTrans), _custInterestTrans, _custInterestTransLine,
                _custInterestJour, _currencyCode, _currencyExchangeHelper, _interestLineAmount);
        }

        return [_custInterest, _custInterestTransLine, _interestLineAmount];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getExchangeRateHelper</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a new instance of the <c>ExchangeRateHelper</c> class.
    /// </summary>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <returns>A new instance of the <c>ExchangeRateHelper</c> class.</returns>
    protected ExchangeRateHelper getExchangeRateHelper(CustCurrencyCode _currencyCode)
    {
        ExchangeRateHelper exchangeRateHelper = ExchangeRateHelper::newCurrency(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            _currencyCode);

        return exchangeRateHelper;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVoucherForPostVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>CustVoucher</c> object.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_custTable">The <c>CustTable</c> recod.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_exchangeRateHelper">The <c>ExchangeRateHelper</c> class instance.</param>
    /// <param name = "_interestAmount">The interest amount.</param>
    /// <param name = "_postingProfile">The posting profile.</param>
    /// <param name = "_custVoucherInterestSet">The set that contains the record ID of the interest note transactions.</param>
    /// <returns>A new instance of the <c>CustVoucher</c> class.</returns>
    protected CustVoucher initCustVoucherForPostVoucher(
        CustInterestJour _custInterestJour,
        CustTable _custTable,
        CustCurrencyCode _currencyCode,
        ExchangeRateHelper _exchangeRateHelper,
        InterestAmountCur _interestAmount,
        CustPostingProfile _postingProfile,
        Set _custVoucherInterestSet)
    {
        CustVoucherInterest custVoucher = CustVoucher::newCustVoucherInterest(_custInterestJour.AccountNum, _interestAmount, _currencyCode,
            LedgerTransTxt::CustInterestLedger, _custInterestJour.DefaultDimension, _postingProfile, LedgerPostingType::CustBalance, _custVoucherInterestSet);

        custVoucher.parmInvoiceId(_custInterestJour.InterestNote);
        custVoucher.parmFormLetter(_custInterestJour.InterestNote);
        custVoucher.parmTypeOfCreditmaxCheck(TypeOfCreditmaxCheck::None);
        custVoucher.parmPaymMode(_custTable.PaymMode);
        custVoucher.parmPaymSpec(_custTable.PaymSpec);
        custVoucher.parmLanguageId(_custInterestJour.LanguageId);
                
        // <GEEPL>
        TransDate exchangeRateDate = this.getExchangeRateDate(_custInterestJour);
        // </GEEPL>

        _exchangeRateHelper.parmExchangeDate(exchangeRateDate);

        custVoucher.parmExchRate(_exchangeRateHelper.getExchangeRate1());
        custVoucher.parmExchRateSecondary(_exchangeRateHelper.getExchangeRate2());
        custVoucher.parmTransRefType(CustTransRefType::InterestNote);
        custVoucher.parmTransRefId(_custInterestJour.InterestNote);
        custVoucher.parmThirdPartyBankAccountId(_custTable.BankAccount);

        if (CustConfigurablePaymentIdFeature_CH::isEnabled() || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            custVoucher.parmPaymId(_custInterestJour.PaymId);
        }

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherObjectForPostVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>LedgerVoucherObject</c> instance.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_interestVoucher">The <c>InterestVoucher</c> record.</param>
    /// <returns>A new <c>LedgerVoucherObject</c> instance.</returns>
    protected LedgerVoucherObject initLedgerVoucherObjectForPostVoucher(CustInterestJour _custInterestJour, Voucher _interestVoucher)
    {
        TransactionTxt transactionTxt = TransactionTxt::construct(LedgerTransTxt::CustInterestLedger, CompanyInfo::languageId(), this.postingDate(),
            _custInterestJour.InterestNote, _interestVoucher);

        LedgerVoucherObject ledgerVoucherObject = LedgerVoucherObject::newVoucher(_interestVoucher, this.postingDate(), SysModule::Cust, LedgerTransType::Interest);

        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForPostVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>LedgerVoucherTransObject</c> instance.
    /// </summary>
    /// <param name = "_ledgerVoucherObject">A <c>LedgerVoucherObject</c> instance.</param>
    /// <param name = "_mergedLedgerDimension">The <c>LedgerDimensionAccount</c>.</param>
    /// <param name = "_currencyCode">The currency code.</param>
    /// <param name = "_custInterestTrans">The <c>CustInterestTrans</c> record.</param>
    /// <param name = "_currencyExchangeHelper">The <c>CurrencyExchangeHelper</c> instance.</param>
    /// <returns>A new <c>LedgerVoucherTransObject</c> instance.</returns>
    protected LedgerVoucherTransObject initLedgerVoucherTransObjectForPostVoucher(
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerDimensionAccount _mergedLedgerDimension,
        CustCurrencyCode _currencyCode,
        CustInterestTrans _custInterestTrans,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = 
            LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObject, LedgerPostingType::CustInterest, _mergedLedgerDimension,
                 _currencyCode, - _custInterestTrans.InterestAmount, _currencyExchangeHelper);

        ledgerVoucherTransObject.parmTaxParentReferenceTableId(_custInterestTrans.TableId);
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(_custInterestTrans.RecId);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMergedLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the <c>LedgerDimensionAccount</c> for the current interest transaction.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_custInterestTrans">The <c>CustInterestTrans</c> record.</param>
    /// <param name = "_custInterest">The <c>CustInterest</c> record.</param>
    /// <returns>The <c>LedgerDimensionAccount</c> for the current interest transaction</returns>
    protected LedgerDimensionAccount getMergedLedgerDimension(CustInterestJour _custInterestJour, CustInterestTrans _custInterestTrans, CustInterest _custInterest)
    {
        MainAccount mainAccount = MainAccount::findByLedgerDimension(CustInterestPost::ledgerDimension(_custInterestTrans.InterestAmount, _custInterest, _custInterestJour, _custInterestTrans.RecId));
        
        return LedgerDimensionFacade::serviceCreateLedgerDimension(
            CustInterestPost::ledgerDimension(_custInterestTrans.InterestAmount, _custInterest, _custInterestJour, _custInterestTrans.RecId),
            _custInterestJour.DefaultDimension, MainAccountLegalEntity::findByMainAccountLegalEntity(mainAccount.RecId,CompanyInfo::current()).DefaultDimension);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCustVoucherInterest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the current <c>CustVoucherInterest</c> object.
    /// </summary>
    /// <param name = "_custVoucherInterest">The current <c>CustVoucherInterest</c> object.</param>
    /// <param name = "_ledgerVoucher">The ledger voucher object.</param>
    /// <param name = "_custTrans">The customer transaction.</param>
    protected void postCustVoucherInterest(CustVoucherInterest _custVoucherInterest, LedgerVoucher _ledgerVoucher, CustTrans _custTrans)
    {
        _custVoucherInterest.post(_ledgerVoucher, _custTrans, NoYes::No, UnknownNoYes::Unknown);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the vouchers that are associated with the interest note transactions.
    /// </summary>
    /// <param name="_custInterestJour">
    /// The interest note buffer.
    /// </param>
    /// <param name="_custTable">
    /// The customer who is associated with the interest note.
    /// </param>
    /// <param name="_numberSeq">
    /// The number sequence of the ledger voucher.
    /// </param>
    /// <param name="_ledgerVoucher">
    /// The ledger voucher object.
    /// </param>
    /// <param name="_currencyCode">
    /// The currency code that is associated with the interest note transaction.
    /// </param>
    /// <param name="_interestAmount">
    /// The interest amount of the interest note transaction.
    /// </param>
    /// <param name="_custInterestTransRecId">
    /// The record ID of the interest note transaction.
    /// </param>
    /// <param name="_postingProfile">
    /// The posting profile that is associated with the interest note or the interest note transaction.
    /// </param>
    /// <param name="custVoucherInterestSet">
    /// The set that contains the record ID of the interest note transactions.
    /// </param>
    /// <returns>
    /// The voucher number.
    /// </returns>
    protected Voucher postVoucher(
            CustInterestJour _custInterestJour,
            CustTable _custTable,
            NumberSeq _numberSeq,
            LedgerVoucher _ledgerVoucher,
            CustCurrencyCode _currencyCode,
            InterestAmountCur _interestAmount,
            RefRecId _custInterestTransRecId,
            CustPostingProfile _postingProfile,
            Set custVoucherInterestSet)
    {
        LedgerDimensionAccount mergedLedgerDimension;
        CustInterestTransLine custInterestTransLine;
        InterestAmountCur interestLineAmount;
        CustInterestTrans custInterestTrans;
        CustTrans custTrans;
        custTrans.selectForUpdate(true);

        CustInterest custInterest = this.findCustInterest(_custTable, _postingProfile);
        Voucher interestVoucher = _numberSeq.voucher();
        
        LedgerVoucherObject ledgerVoucherObject = this.initLedgerVoucherObjectForPostVoucher(_custInterestJour, interestVoucher);

        _ledgerVoucher.addVoucher(ledgerVoucherObject);

        // <GEERU>
        LedgerBondClient_RU bondClient_RU = ledgerVoucherObject.ledgerBondClient_RU();
        if (bondClient_RU)
        {
            bondClient_RU.addNewLogObject();
        }
        // </GEERU>
        
        ExchangeRateHelper exchangeRateHelper = this.getExchangeRateHelper(_currencyCode);

        CustVoucherInterest custVoucher = this.initCustVoucherForPostVoucher(_custInterestJour, _custTable, _currencyCode, exchangeRateHelper,
            _interestAmount, _postingProfile, custVoucherInterestSet);

        this.postCustVoucherInterest(custVoucher, _ledgerVoucher, custTrans);

        ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();

        if (PublicSectorUtils::arePostingDefinitionsEnabledForPubSect())
        {
            this.removeTransactionFromVoucher_PSN(ledgerVoucherObject, _custTable.AccountNum, _postingProfile, _custInterestJour.DefaultDimension,
                _interestAmount, LedgerPostingType::CustBalance);
        }

        SetEnumerator custVoucherInterestSetEnumerator = custVoucherInterestSet.getEnumerator();
        while (custVoucherInterestSetEnumerator.moveNext())
        {
            custInterestTrans = CustInterestTrans::find(_custInterestJour.InterestNote,custVoucherInterestSetEnumerator.current());
            ledgerVoucherObject = _ledgerVoucher.findLedgerVoucherObject();
            mergedLedgerDimension = this.getMergedLedgerDimension(_custInterestJour, custInterestTrans, custInterest);

            CurrencyExchangeHelper currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                ledgerVoucherObject.parmAccountingDate());

            // <GEEPL>
            TransDate exchangeRateDate = this.getExchangeRateDate(_custInterestJour);
            // </GEEPL>

            currencyExchangeHelper.parmExchangeDate(exchangeRateDate);

            if (PublicSectorUtils::arePostingDefinitionsEnabledForPubSect())
            {
                [custInterest, custInterestTransLine, interestLineAmount] =
                    this.postInterestWhenPostingDefinitionsAreEnabled(_ledgerVoucher, custInterest, custInterestTrans, custInterestTransLine,
                        _custInterestJour, _currencyCode, currencyExchangeHelper, interestLineAmount);
            }
            else
            {
                LedgerVoucherTransObject ledgerVoucherTransObject =
                    this.initLedgerVoucherTransObjectForPostVoucher(ledgerVoucherObject, mergedLedgerDimension, _currencyCode, custInterestTrans, currencyExchangeHelper);
                
                _ledgerVoucher.addTrans(ledgerVoucherTransObject);
            }
        }

        custTrans.Txt = this.getCustomerTransactionText(LedgerTransTxt::CustInterestCust, CompanyInfo::languageId(), this.postingDate(),
            _custInterestJour.InterestNote, interestVoucher, _custTable.AccountNum);

        custTrans.euroTriangulation = Currency::euroTriangulation(_custInterestJour.CurrencyCode);

        if (isBillingClassificationEnabled)
        {
            custTrans.CustBillingClassification = _custInterestJour.CustBillingClassification;
        }
        custTrans.update();

        // <GEERU>
        if (bondClient_RU)
        {
            bondClient_RU.bondLog2Log();
        }
        // </GEERU>

        return interestVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustomerTransactionText</Name>
				<Source><![CDATA[
    private TransactionTextLarge getCustomerTransactionText(
        LedgerTransTxt _transTxtType,
        LanguageId _languageId,
        TransDate _postingDate,
        InterestNote _interestNote,
        Voucher _interestVoucher,
        CustAccount _accountNum)
    {
        TransactionTxt transactionTxt = TransactionTxt::construct(_transTxtType, _languageId, _postingDate, _interestNote, _interestVoucher);
        transactionTxt.setKey1(_accountNum);

        return transactionTxt.txt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucherPerCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the vouchers using the currency that is associated with interest note transactions.
    /// </summary>
    /// <param name="_custInterestJour">
    ///    The interest note buffer.
    /// </param>
    /// <param name="_custTable">
    ///    The customer who is associated with the interest note.
    /// </param>
    /// <param name="_numberSeq">
    ///    The number sequence of the ledger voucher.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    A ledger voucher object.
    /// </param>
    /// <param name="_custInterestTransMap">
    ///    A map that holds the <c>CustInterestTrans</c> records and the associated vouchers.
    /// </param>
    protected void postVoucherPerCurrency(
            CustInterestJour _custInterestJour,
            CustTable _custTable,
            NumberSeq _numberSeq,
            LedgerVoucher _ledgerVoucher,
            Map _custInterestTransMap)
    {
        CustInterestTrans custInterestTrans;
        CustCurrencyCode currencyCode = '';
        InterestAmountCur interestAmount;
        Voucher interestVoucher;
        Set custVoucherInterestSet;

        void postForCurrency()
        {
            SetEnumerator custVoucherInterestSetEnumerator = custVoucherInterestSet.getEnumerator();

            interestVoucher = this.postVoucher(
                    _custInterestJour,
                    _custTable,
                    _numberSeq,
                    _ledgerVoucher,
                    currencyCode,
                    interestAmount,
                    0, // summarizing CustInterestTrans by currency so we don't have a RecId
                    this.getPostingProfile(_custInterestJour),
                    custVoucherInterestSet);

            while (custVoucherInterestSetEnumerator.moveNext())
            {
                _custInterestTransMap.insert(custVoucherInterestSetEnumerator.current(), interestVoucher);
            }
        }

        // Since multiple CustInterestTrans lines can exist for a single CustTransOpen / CustSettlement record, order by
        // CustTransId and LineNum to ensure the last trans record is used when updating the last interest date.

        while select CurrencyCode, InterestNote, InterestCalculate, CustTransId, DueDate, CalcFrom, InterestDays, RecId, InterestAmount from custInterestTrans
            order by custInterestTrans.CurrencyCode, custInterestTrans.CustTransId, custInterestTrans.LineNum
                where custInterestTrans.InterestNote == _custInterestJour.InterestNote &&
                    custInterestTrans.InterestCalculate == NoYes::Yes &&
                    custInterestTrans.InterestAmount != 0
        {
            this.updateLastInterestDate(
                custInterestTrans.CustTransId,
                custInterestTrans.DueDate,
                custInterestTrans.CalcFrom + custInterestTrans.InterestDays - 1);

            if (currencyCode != custInterestTrans.CurrencyCode) // CurrencyCode changed, post a Voucher
            {
                if (currencyCode) // First time the currency code is empty
                {
                    postForCurrency();
                }

                custVoucherInterestSet = new Set(typeName2Type(extendedTypeStr(RecId)));
                currencyCode = custInterestTrans.CurrencyCode;
                interestAmount = 0;
            }

            custVoucherInterestSet.add(custInterestTrans.RecId);
            interestAmount += custInterestTrans.InterestAmount;
        }
        //Posting transactions that do not have currency difference
        if (currencyCode)
        {
            postForCurrency();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucherPerTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the vouchers for every transaction in the interest note.
    /// </summary>
    /// <param name="_custInterestJour">
    ///    The interest note buffer.
    /// </param>
    /// <param name="_custTable">
    ///    The customer who is associated with the interest note.
    /// </param>
    /// <param name="_numberSeq">
    ///    The number sequence of a ledger voucher.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    A ledger voucher object.
    /// </param>
    /// <param name="_custInterestTransMap">
    ///    A map that holds the <c>CustInterestTrans</c> records and associated vouchers.
    /// </param>
    protected void postVoucherPerTransaction(
            CustInterestJour _custInterestJour,
            CustTable _custTable,
            NumberSeq _numberSeq,
            LedgerVoucher _ledgerVoucher,
            Map _custInterestTransMap)
    {
        CustInterestTrans custInterestTrans;

        // Since multiple CustInterestTrans lines can exist for a single CustTransOpen / CustSettlement record, order by
        // CustTransId and LineNum to ensure the last trans record is used when updating the last interest date.

        while select custInterestTrans
            order by custInterestTrans.CustTransId, custInterestTrans.LineNum
            where custInterestTrans.InterestNote == _custInterestJour.InterestNote &&
                  custInterestTrans.InterestCalculate == NoYes::Yes &&
                  custInterestTrans.InterestAmount != 0
        {
            this.postVoucherPerTransactionLine(_custInterestJour, _custTable, _numberSeq, _ledgerVoucher, _custInterestTransMap, custInterestTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucherPerTransactionLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts the vouchers for a specific transaction in the interest note.
    /// </summary>
    /// <param name="_custInterestJour">
    ///    The interest note buffer.
    /// </param>
    /// <param name="_custTable">
    ///    The customer who is associated with the interest note.
    /// </param>
    /// <param name="_numberSeq">
    ///    The number sequence of a ledger voucher.
    /// </param>
    /// <param name="_ledgerVoucher">
    ///    A ledger voucher object.
    /// </param>
    /// <param name="_custInterestTransMap">
    ///    A map that holds the <c>CustInterestTrans</c> records and associated vouchers.
    /// </param>
    /// <param name="_custInterestTrans">
    ///    The <c>CustInterestTrans</c> record in the interest note.
    /// </param>
    protected void postVoucherPerTransactionLine(
            CustInterestJour    _custInterestJour,
            CustTable           _custTable,
            NumberSeq           _numberSeq,
            LedgerVoucher       _ledgerVoucher,
            Map                 _custInterestTransMap,
            CustInterestTrans   _custInterestTrans
        )
    {
        CustPostingProfile postingProfile = this.getPostingProfile(_custInterestJour, _custInterestTrans.CustTransId);

        if (postingProfile)
        {
            this.updateLastInterestDate(
                _custInterestTrans.CustTransId,
                _custInterestTrans.DueDate,
                _custInterestTrans.CalcFrom + _custInterestTrans.InterestDays - 1);

            Set custVoucherInterestSet = new Set(typeName2Type(extendedTypeStr(RecId)));
            custVoucherInterestSet.add(_custInterestTrans.RecId);
            Voucher interestVoucher = this.postVoucher(_custInterestJour,
                                                _custTable,
                                                _numberSeq,
                                                _ledgerVoucher,
                                                _custInterestTrans.CurrencyCode,
                                                _custInterestTrans.InterestAmount,
                                                _custInterestTrans.RecId,
                                                postingProfile,
                                                custVoucherInterestSet);

            _custInterestTransMap.insert(_custInterestTrans.RecId, interestVoucher);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>progressUpdate</Name>
				<Source><![CDATA[
    protected void progressUpdate(str _text)
    {
        progressCounter++;
        progress.setCount(progressCounter);
        progress.setText(_text);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryBuild</Name>
				<Source><![CDATA[
    protected void queryBuild()
    {
        QueryBuildDataSource queryBuildDataSource = queryRun.query().dataSourceTable(tableNum(CustInterestJour));

        queryBuildDataSource.findRange(fieldNum(CustInterestJour, Status)).status(RangeStatus::Hidden);
        queryBuildDataSource.findRange(fieldNum(CustInterestJour, Printed)).status(RangeStatus::Hidden);

        //appending 0 to the Billing classfication value if include transaction without billing class checkedbox is marked
        if (isBillingClassificationEnabled && (inclTransWithNoBillingClassifications == NoYes::Yes))
        {
            if (billingClassificationIds != '')
            {
                billingClassificationIds = billingClassificationIds + #BillingCalssificationSelected;
            }
            else
            {
                billingClassificationIds = billingClassificationIds + #NoBillingClassificationSelected;
            }
        }

        queryRun.query().dataSourceTable(tableNum(CustInterestJour)).update(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryRun</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </summary>
    /// <returns>
    ///    The instance of the <c>QueryRun</c> class, which is used by the <c>queryPrompt</c> method.
    /// </returns>
    /// <remarks>
    ///    This method is used if a query prompt is the dialog, and if a Select menu item is added to a
    ///    dialog. Do not create the instance of the <c>QueryRun</c> class when this method is called. Do it
    ///    in the <c>unpack</c> method and the <c>initParmDefault</c> method, or in the <c>init</c> method.
    /// </remarks>
    public QueryRun queryRun()
    {
        return queryRun;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBlockedStatusForBlockedCustInterestJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the appropriate blocked status for a blocked <c>CustInterestJour</c> record.
    /// </summary>
    /// <returns>A <c>CustVendorBlocked</c> value for a blocked <c>CustInterestJour</c> record.</returns>
    protected CustVendorBlocked getBlockedStatusForBlockedCustInterestJour()
    {
        return CustVendorBlocked::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modifyCustInterestJourQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Modifies the <c>CustInterestJour</c> portion of the query to be executed.
    /// </summary>
    protected void modifyCustInterestJourQuery()
    {
        if (isBillingClassificationEnabled)
        {
            SysQuery::findOrCreateRange(queryRun.query().dataSourceTable(tableNum(CustInterestJour)), fieldNum(CustInterestJour, CustBillingClassification));
            queryRun.query().dataSourceTable(tableNum(CustInterestJour)).findRange(fieldNum(CustInterestJour, CustBillingClassification)).value(billingClassificationIds);
        }

        queryRun.query().dataSourceTable(tableNum(CustInterestJour)).update(true);
        queryRun.query().dataSourceTable(tableNum(CustInterestJour)).concurrencyModel(ConcurrencyModel::Optimistic);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustInterestVersionDetail</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a <c>CustInterestVersionDetail</c> record.
    /// </summary>
    /// <param name="_custInterest">The <c>CustInterest</c> buffer that is used for the interest calculation.</param>
    /// <param name="_custInterestJour">The <c>CustInterestJour</c> buffer that is used for the interest calculation.</param>
    /// <returns>An initialized <c>CustInterestVersionDetail</c> record.</returns>
    protected CustInterestVersionDetail initCustInterestVersionDetail(CustInterest _custInterest, CustInterestJour _custInterestJour)
    {
        CustInterestVersion custInterestVersion;
        
        // Get the interest posting information using the From date
        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            custInterestVersion = CustInterestVersion::findByDate(_custInterest.RecId, _custInterestJour.ToDate);
        }
        else
        {
            custInterestVersion = CustInterestVersion::findByDate(_custInterest.RecId, _custInterestJour.FromDate);
        }

        return CustInterestVersionDetail::findByFeeType(custInterestVersion.RecId, CustInterestFeeType::Earning);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymIdForCustInterestJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the payment id for the <c>CustInterestJour</c> record.
    /// </summary>
    /// <param name="_custInterestJour">The <c>CustInterestJour</c> buffer that is used for the interest calculation.</param>
    /// <param name = "_custTable">The current customer record.</param>
    /// <param name = "_numberSeq">The <c>NumberSeq</c> to be used to setup the <c>PaymMoneyTransferSlip</c> instance.</param>
    /// <returns>The payment id for the <c>CustInterestJour</c> record.</returns>
    protected PaymId getPaymIdForCustInterestJour(CustInterestJour _custInterestJour, CustTable _custTable, NumberSeq _numberSeq)
    {
        PaymMoneyTransferSlip moneyTransferSlip = new PaymMoneyTransferSlip();
        moneyTransferSlip.init(_custTable.GiroType);
        moneyTransferSlip.parmNumSeqCode(_numberSeq.parmNumberSequenceCode());
        PaymId paymId = moneyTransferSlip.ocrField(_custInterestJour.AccountNum, _custInterestJour.InterestNote, strLen(int2str(NumberSeq::highest(_custInterestJour.NumberSequenceTable))));

        return strLTrim(paymId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postVoucherForExecuteCustInterestPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Posts the voucher for the executeCustInterestPost() process.
    /// </summary>
    /// <param name="_custInterestJour">The <c>CustInterestJour</c> buffer that is used for the interest calculation.</param>
    /// <param name = "_custTable">The current customer record.</param>
    /// <param name = "_numberSeq">The <c>NumberSeq</c> to be used to setup the <c>PaymMoneyTransferSlip</c> instance.</param>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> record.</param>
    /// <param name = "_custInterestTransMap">The <c>Map</c> containing customer interest transactions.</param>
    /// <param name = "_mixedProfileSource">Indicates whether or not the interest transaction is from a mixed profile source.</param>
    /// <returns>true if the interest transaction is from a mixed profile source; otherwise, false.</returns>
    protected boolean postVoucherForExecuteCustInterestPost(
        CustInterestJour _custInterestJour,
        CustTable _custTable,
        NumberSeq _numberSeq,
        LedgerVoucher _ledgerVoucher,
        Map _custInterestTransMap,
        boolean _mixedProfileSource)
    {
        if (this.parmInterestPerTrans() || _custInterestJour.InterestCalcAccountChoice == this.getInterestCalcAccountChoiceTransaction())
        {
            _mixedProfileSource = _mixedProfileSource || this.parmInterestPerTrans() != (_custInterestJour.InterestCalcAccountChoice == this.getInterestCalcAccountChoiceTransaction());
            this.postVoucherPerTransaction(_custInterestJour, _custTable, _numberSeq, _ledgerVoucher, _custInterestTransMap);
        }
        else
        {
            this.postVoucherPerCurrency(_custInterestJour, _custTable, _numberSeq, _ledgerVoucher, _custInterestTransMap);
        }

        return _mixedProfileSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterestCalcAccountChoiceTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction enum value of <c>InterestCalcAccountChoice</c>.
    /// </summary>
    /// <returns>
    /// Enum value of transaction of enum <c>InterestCalcAccountChoice</c>.
    /// </returns>
    protected InterestCalcAccountChoice getInterestCalcAccountChoiceTransaction()
    {
        return InterestCalcAccountChoice::Transaction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>executeCustInterestPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the <c>CustInterestPost</c> run process.
    /// </summary>
    /// <param name = "_mixedProfileSource">Indicates whether or not the interest transaction is from a mixed profile source.</param>
    /// <returns>A <c>container</c> with a boolean for mixedProfileSource and a boolean result of whether or not the interest notes were posted.</returns>
    protected container executeCustInterestPost(boolean _mixedProfileSource)
    {
        #OCCRetryCount
        
        LedgerVoucher ledgerVoucher;
        CustInterest custInterest;
        Map custInterestTransMap;
        PaymId paymId;
        boolean interestNotesPosted;
        
        CustInterestJour custInterestJour = queryRun.get(tableNum(CustInterestJour));

        // <GEEPL>
        if (printNote_PL && custInterestJour.Status == PrintPostCancel::Created)
        {
            printInterestReport += custInterestJour.InterestNote;
        }
        // </GEEPL>
        try
        {
            ttsbegin;

            this.progressUpdate(strFmt("@SYS27235", custInterestJour.AccountNum, custInterestJour.InterestNote));

            setPrefix(strFmt("@AccountsReceivable:InterestNoteProcessInterestNoteNum",custInterestJour.InterestNote));

            CustTable custTable = CustTable::find(custInterestJour.AccountNum, true);
            
            custInterest = this.findCustInterest(custTable, custInterestJour.PostingProfile);

            CustInterestVersionDetail custInterestVersionDetail = this.initCustInterestVersionDetail(custInterest, custInterestJour);

            // Get the fee ledger dimension based on the To date
            LedgerDimensionDefaultAccount feeLedgerDimension = custInterestJour.feeLedgerDimension();

            if (!this.validateInterestJour(custInterestJour, custInterest, custTable, feeLedgerDimension))
            {
                info(strFmt("@SYS66292", custInterestJour.InterestNote, custInterestJour.AccountNum));
            }
            else
            {
                this.prePostCustInterest(custInterestJour);

                NumberSeq numberSeq = this.allocateVoucher(custInterestJour);

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]) && !custInterestJour.PaymId)
                {
                    custInterestJour.PaymId = this.getPaymIdForCustInterestJour(custInterestJour, custTable, numberseq);
                }

                ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary, SysModule::Cust, numberSeq.parmVoucherSequenceCode());
                ledgerVoucher.parmCheckBlockedDimensions(false);

                custInterestTransMap = new Map(Types::Int64, Types::String);

                _mixedProfileSource =
                    this.postVoucherForExecuteCustInterestPost(custInterestJour, custTable, numberSeq, ledgerVoucher, custInterestTransMap, _mixedProfileSource);

                if (custInterestJour.Fee)
                {
                    this.updateFee(ledgerVoucher, custInterestJour, feeLedgerDimension, numberSeq);
                }

                if (custInterestJour.Block)
                {
                    custTable.Blocked = this.getBlockedStatusForBlockedCustInterestJour();
                    custTable.update();
                }

                // <GEEPL>
                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                {
                    NumberSequenceReference numberSequenceReference_PL = CustParameters::numRefInterestNoteDocument_PL();
                    NumberSeq docNumberSeq = NumberSeq::newGetNum(numberSequenceReference_PL);
                    custInterestJour.InterestNoteDocument_PL = docNumberSeq.num();
                }
                // </GEEPL>

                custInterestJour.setUpdated(this.postingDate());
                custInterestJour.update();

                ledgerVoucher.end();

                info(strFmt("@AccountsReceivable:InterestNoteProcessPostedToCust", custInterestJour.AccountNum));

                this.updateCustInterestTransVoucherRef(custInterestTransMap, custInterestJour);
                TransactionLog::create(TransactionLogType::CustInterestNote, "@SYS21519");
                interestNotesPosted = true;

                CustInterestNotePostedBusinessEvent::newFromCustInterestJour(custInterestJour).send();
           }

            ttscommit;
        }
        catch (Exception::Deadlock)
        {
            custInterestJour = CustInterestJour::find(custInterestJour.InterestNote, true, ConcurrencyModel::Optimistic);
            retry;
        }
        catch (Exception::UpdateConflict)
        {
            if (appl.ttsLevel() == 0)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    custInterestJour = CustInterestJour::find(custInterestJour.InterestNote, true, ConcurrencyModel::Optimistic);
                    retry;
                }
            }
            else
            {
                throw Exception::UpdateConflict;
            }
        }
        catch (Exception::Error)
        {
            exceptionTextFallThrough();
        }

        return [_mixedProfileSource, interestNotesPosted];
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Contains the code that performs the actual job of the class.
    /// </summary>
    public void run()
    {
        #macrolib.AviFiles
        
        boolean mixedProfileSource;
        boolean interestNotesPosted;

        Counter progressTotal = QueryRun::getQueryRowCount(queryRun.query(), intMax());
        this.progressInit("@SYS21519", progressTotal, #AviFindFile);

        this.modifyCustInterestJourQuery();

        setPrefix("@AccountsReceivable:InterestNotePostingProcessIsComplete");

        while (queryRun.next())
        {
            [mixedProfileSource, interestNotesPosted] = this.executeCustInterestPost(mixedProfileSource);
        }

        if (!interestNotesPosted)
        {
            info("@SYS4009833");
        }

        if (mixedProfileSource && !this.parmInterestPerTrans())
        {
            info("@SYS300160");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>runsImpersonated</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the batch task is run on the server or on a client.
    /// </summary>
    /// <returns>
    ///    true if the task is run on the server; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Your classes that extend the <c>RunBaseBatch</c> class must override the <c>runsImpersonated</c>
    ///    method and return false if you want those tasks to run on a client.
    /// </remarks>
    public boolean runsImpersonated()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>showQueryValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether to add a Select button to the dialog box.
    /// </summary>
    /// <returns>
    /// Always returns true.
    /// </returns>
    /// <remarks>
    /// If you click this button, it will show the query form. Therefore, the <c>queryRun</c> method has to
    /// return a valid <c>queryRun</c> object.If you change the return value to false the button will no
    /// longer be added.
    /// </remarks>
    public boolean showQueryValues()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Version version = RunBase::getVersion(_packedClass);
        container packedQuery;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            // <GEEPL>
            case #Version7:
                [version, #CurrentList_v7, packedQuery] = _packedClass;
                if (packedQuery)
                {
                    queryRun = new QueryRun(packedQuery);
                }
                break;
            // </GEEPL>

            case 8:
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    [version, #CurrentList_v8, packedQuery] = _packedClass;
                    if (packedQuery)
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                break;

            case 4:
                if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
                {
                    [version, #CurrentList_v4, packedQuery] = _packedClass;
                    if (packedQuery)
                    {
                        queryRun = new QueryRun(packedQuery);
                    }
                }
                break;

            default:
                return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustInterestTransFieldValues</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates field values on the given <c>CustInterestTrans</c> buffer.
    /// </summary>
    /// <param name = "_custInterestTrans">The <c>CustInterestTrans</c> buffer.</param>
    /// <param name = "_voucher">The voucher used to find the <c>GeneralJournalEntry</c> record reference for the customer interest transaction.</param>
    protected void updateCustInterestTransFieldValues(CustInterestTrans _custInterestTrans, Voucher _voucher)
    {
        _custInterestTrans.GeneralJournalEntry = 
            GeneralLedgerExtension::findBySubledgerVoucherAccountingDate(_voucher, this.postingDate()).RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCustInterestTransVoucherRef</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>GeneralJournalEntry</c> field of the <c>CustInterestTrans</c> table.
    /// </summary>
    /// <param name="_custInterestTransMap">
    ///    A map that holds <c>CustInterestTrans</c> records and the associated vouchers.
    /// </param>
    /// <param name="_custInterestJour">
    ///    The interest note buffer.
    /// </param>
    protected void updateCustInterestTransVoucherRef(Map _custInterestTransMap, CustInterestJour _custInterestJour)
    {
        MapIterator custInterestTransMapIterator;
        CustInterestTrans custInterestTrans;

        if (_custInterestTransMap)
        {
            Voucher custInterestVoucher;

            custInterestTransMapIterator = new MapIterator(_custInterestTransMap);

            ttsbegin;

            while (custInterestTransMapIterator.more())
            {
                custInterestTrans = CustInterestTrans::find(_custInterestJour.InterestNote, custInterestTransMapIterator.key(),true);
                
                custInterestVoucher = custInterestTransMapIterator.value();
                this.updateCustInterestTransFieldValues(custInterestTrans, custInterestVoucher);

                custInterestTrans.update();

                custInterestTransMapIterator.next();
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherObjectForUpdateFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>LedgerVoucherObject</c> instance for the updateFee() method.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <returns>A new <c>LedgerVoucherObject</c> instance.</returns>
    protected LedgerVoucherObject initLedgerVoucherObjectForUpdateFee(CustInterestJour _custInterestJour)
    {
        LedgerVoucherObject ledgerVoucherObject = 
            LedgerVoucherObject::newVoucher(_custInterestJour.FeeVoucher, this.postingDate(), SysModule::Cust, LedgerTransType::Interest);

        TransactionTxt transactionTxt = TransactionTxt::construct(LedgerTransTxt::CustInterestLedger, CompanyInfo::languageId(), 
            this.postingDate(), _custInterestJour.InterestNote, _custInterestJour.FeeVoucher);

        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerVoucherTransObjectForUpdateFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>LedgerVoucherTransObject</c> instance for the updateFee() method.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_ledgerVoucherObject">A <c>LedgerVoucherObject</c> instance.</param>
    /// <param name = "_mergedLedgerDimension">The <c>LedgerDimensionAccount</c>.</param>
    /// <param name = "_currencyExchangeHelper">The <c>CurrencyExchangeHelper</c> instance.</param>
    /// <returns>A new <c>LedgerVoucherTransObject</c> instance.</returns>
    protected LedgerVoucherTransObject initLedgerVoucherTransObjectForUpdateFee(
        CustInterestJour _custInterestJour,
        LedgerVoucherObject _ledgerVoucherObject,
        LedgerDimensionAccount _mergedLedgerDimension,
        CurrencyExchangeHelper _currencyExchangeHelper)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject = LedgerVoucherTransObject::newTransactionAmountDefault(_ledgerVoucherObject,
            LedgerPostingType::CustInterestFee, _mergedLedgerDimension, _custInterestJour.CurrencyCode, - _custInterestJour.Fee, _currencyExchangeHelper);

        ledgerVoucherTransObject.parmTaxParentReferenceTableId(_custInterestJour.TableId);
        ledgerVoucherTransObject.parmTaxParentReferenceRecId(_custInterestJour.RecId);

        return ledgerVoucherTransObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerPostingControllerForUpdateFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>LedgerPostingController</c> instance for the updateFee() method.
    /// </summary>
    /// <param name = "_ledgerVoucher">The <c>LedgerVoucher</c> record.</param>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <returns>A new <c>LedgerPostingController</c> instance.</returns>
    protected LedgerPostingController initLedgerPostingControllerForUpdateFee(LedgerVoucher _ledgerVoucher, CustInterestJour _custInterestJour)
    {
        LedgerPostingController ledgerPostingController = LedgerPostingController::newForLedgerPostingJournal(_ledgerVoucher);

        TransactionTxt transactionTxt = TransactionTxt::construct(LedgerTransTxt::CustInterestFeeLedger, CompanyInfo::languageId(),
            ledgerPostingController.getJournal().lastTransDate(),_custInterestJour.InterestNote, _custInterestJour.FeeVoucher, _custInterestJour.AccountNum);

        ledgerPostingController.getReference().lastTransTxt(transactionTxt.txt());

        return ledgerPostingController;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCustVoucherForUpdateFee</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new <c>CustVoucher</c> record for the updateFee() method.
    /// </summary>
    /// <param name = "_custInterestJour">The <c>CustInterestJour</c> record.</param>
    /// <param name = "_custTable">The current customer.</param>
    /// <returns>An initialized <c>CustVoucher</c> instance.</returns>
    protected CustVoucher initCustVoucherForUpdateFee(CustInterestJour _custInterestJour, CustTable _custTable)
    {
        CustVoucher custVoucher = CustVoucher::newCustVoucherInterestFee(_custInterestJour.AccountNum, 
            _custInterestJour.Fee + _custInterestJour.TaxAmount, _custInterestJour.CurrencyCode, LedgerTransTxt::CustInterestFeeCust,
            _custInterestJour.DefaultDimension, _custInterestJour.PostingProfile, LedgerPostingType::CustBalance);

        custVoucher.parmInvoiceId(_custInterestJour.InterestNote);
        custVoucher.parmFormLetter(_custInterestJour.InterestNote);
        custVoucher.parmTypeOfCreditmaxCheck(TypeOfCreditmaxCheck::None);
        custVoucher.parmPaymMode(_custTable.PaymMode);
        custVoucher.parmPaymSpec(_custTable.PaymSpec);
        custVoucher.parmLanguageId(_custInterestJour.LanguageId);

        if (isBillingClassificationEnabled)
        {
            custVoucher.parmBillingClassification(_custInterestJour.CustBillingClassification);
        }

        custVoucher.parmExchRate(
            ExchangeRateHelper::getExchangeRate1_Static(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _custInterestJour.CurrencyCode, this.postingDate()));

        custVoucher.parmExchRateSecondary(
            ExchangeRateHelper::getExchangeRate2_Static(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), _custInterestJour.CurrencyCode, this.postingDate()));

        custVoucher.parmTransRefType(CustTransRefType::InterestNote);
        custVoucher.parmTransRefId(_custInterestJour.InterestNote);
        custVoucher.parmThirdPartyBankAccountId(_custTable.BankAccount);

        return custVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFee</Name>
				<Source><![CDATA[
    protected void updateFee(
        LedgerVoucher _ledgerVoucher,
        CustInterestJour _custInterestJour,
        LedgerDimensionDefaultAccount _feeLedgerDimension,
        NumberSeq _numberSeq)
    {
        CustTrans custTrans;
        CustTable custTable = CustTable::find(_custInterestJour.AccountNum);
        
        // <GEERU>
        LedgerBondClient_RU bondClient_RU;
        // </GEERU>
        
        LedgerDimensionAccount mergedLedgerDimension;
        CurrencyExchangeHelper currencyExchangeHelper;

        _custInterestJour.FeeVoucher = _numberSeq.voucher();

        LedgerVoucherObject ledgerVoucherObject = this.initLedgerVoucherObjectForUpdateFee(_custInterestJour);
        
        _ledgerVoucher.addVoucher(ledgerVoucherObject);

        LedgerPostingController ledgerPostingController = this.initLedgerPostingControllerForUpdateFee(_ledgerVoucher, _custInterestJour);

        CustInterestNote custInterestNote = new CustInterestNote(_custInterestJour);
        TaxCustInterestNote taxCustInterestNote = new TaxCustInterestNote(NoYes::Yes, custInterestNote, this.postingDate());

        // <GEERU>
        bondClient_RU = _ledgerVoucher.findLedgerVoucherObject().ledgerBondClient_RU();
        if (bondClient_RU)
        {
            bondClient_RU.addNewLogObject();
        }
        // </GEERU>

        _custInterestJour.TaxAmount = -taxCustInterestNote.calcAndPost(ledgerPostingController);

        ledgerVoucherObject = ledgerPostingController.getReference();
        mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(_feeLedgerDimension, _custInterestJour.DefaultDimension);

        currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
            Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
            ledgerVoucherObject.parmAccountingDate());

        if (PublicSectorUtils::arePostingDefinitionsEnabledForPubSect())
        {
            this.addLedgerTransByPostingDefinition(mergedLedgerDimension, _ledgerVoucher, _custInterestJour.Fee, _custInterestJour.CurrencyCode,
                currencyExchangeHelper, 0, _custInterestJour.CustBillingClassification, this.postingDate(), _custInterestJour.TableId,
                _custInterestJour.RecId, LedgerPostingType::CustInterestFee);

            if (_custInterestJour.TaxAmount > 0)
            {
                mergedLedgerDimension = TaxLedgerAccountGroup::find(TaxTable::findAccountGroup(TaxTrans::find(ledgerVoucherObject.parmVoucher(), this.postingDate()).TaxCode)).TaxOutgoingLedgerDimension;
                mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(mergedLedgerDimension, _custInterestJour.DefaultDimension);

                this.addLedgerTransByPostingDefinition(mergedLedgerDimension, _ledgerVoucher, _custInterestJour.TaxAmount, _custInterestJour.CurrencyCode,
                    currencyExchangeHelper, 0, _custInterestJour.CustBillingClassification, this.postingDate(), _custInterestJour.TableId,
                    _custInterestJour.RecId, LedgerPostingType::Tax);
            }
        }
        else
        {

            LedgerVoucherTransObject ledgerVoucherTransObject =
                this.initLedgerVoucherTransObjectForUpdateFee(_custInterestJour, ledgerVoucherObject, mergedLedgerDimension, currencyExchangeHelper);
                
            _ledgerVoucher.addTrans(ledgerVoucherTransObject);
        }

        CustVoucher custVoucher = this.initCustVoucherForUpdateFee(_custInterestJour, custTable);

        custVoucher.post(ledgerPostingController.getJournal(), custTrans, NoYes::No, UnknownNoYes::Unknown);

        if (PublicSectorUtils::arePostingDefinitionsEnabledForPubSect())
        {
            this.removeTransactionFromVoucher_PSN(ledgerVoucherObject, _custInterestJour.AccountNum, _custInterestJour.PostingProfile,
                _custInterestJour.DefaultDimension, _custInterestJour.Fee + _custInterestJour.TaxAmount, LedgerPostingType::CustBalance);
        }

        if (CustConfigurablePaymentIdFeature_CH::isEnabled() || SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            custTrans.PaymId = _custInterestJour.PaymId;
        }

        custTrans.update();

        // <GEERU>
        if (bondClient_RU)
        {
            bondClient_RU.bondLog2Log();
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateLastInterestDate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the <c>LastInterestDate</c> field of the <c>CustTransOpen</c> and <c>CustSettlement</c>
    ///    tables.
    /// </summary>
    /// <param name="_custTransId">
    ///    The customer transaction record ID.
    /// </param>
    /// <param name="_dueDate">
    ///    The due date of the transaction that forms the basis of an interest note.
    /// </param>
    /// <param name="_lastInterestDate">
    ///    The date of the most recent interest calculation for the transaction.
    /// </param>
    protected void updateLastInterestDate(RefRecId _custTransId, date _dueDate, date _lastInterestDate)
    {
        CustTransOpen custTransOpen;
        CustSettlement custSettlement;

        while select forupdate custTransOpen
            where custTransOpen.RefRecId == _custTransId &&
                  custTransOpen.DueDate == _dueDate
        {
            custTransOpen.LastInterestDate = _lastInterestDate;
            custTransOpen.update();
        }

        while select forupdate custSettlement
            where custSettlement.TransRecId == _custTransId &&
                  custSettlement.DueDate == _dueDate
        {
            custSettlement.LastInterestDate = _lastInterestDate;
            custSettlement.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateQuery</Name>
				<Source><![CDATA[
    protected void updateQuery()
    {
        QueryBuildDataSource qbds = queryRun.query().dataSourceTable(tableNum(CustInterestJour));

        void setRangeValue(QueryBuildRange _range, str _value)
        {
            if (_range)
            {
                _range.value(_value);
            }
        }

        setRangevalue(qbds.findRange(fieldNum(CustInterestJour, AccountNum)), parmCustInterestJour.AccountNum);

        setRangevalue(qbds.findRange(fieldNum(CustInterestJour, InterestNote)), parmCustInterestJour.InterestNote);

        setRangevalue(qbds.findRange(fieldNum(CustInterestJour, Status)), queryValue(this.parmCustInterestJour().Status));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ok = true;

        if (! postingDate)
        {
            ok = checkFailed("@SYS16668");
        }

        if (isBillingClassificationEnabled && ok && inclTransWithNoBillingClassifications == NoYes::No && billingClassificationIds == '')
        {
            ok = checkFailed("@SPS686");
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInterestJour</Name>
				<Source><![CDATA[
    protected boolean validateInterestJour(CustInterestJour _custInterestJour,
                                           CustInterest _custInterest,
                                           CustTable _custTable,
                                           LedgerDimensionDefaultAccount _feeLedgerDimension)
    {
        boolean ok = true;

        if (! _custInterestJour.InterestNote)
        {
            ok = checkFailed("@SYS21660") && ok;
        }

        if (_custInterestJour.Status == PrintPostCancel::Posted || _custInterestJour.FeeVoucher)
        {
            ok = checkFailed(strFmt("@SYS21522",_custInterestJour.InterestNote)) && ok;
        }

        if (_custInterestJour.Status == PrintPostCancel::Canceled)
        {
            ok = checkFailed(strFmt("@SYS26573",_custInterestJour.InterestNote)) && ok;
        }

        if (! this.postingDate())
        {
            ok = checkFailed("@SYS16668") && ok;
        }

        ok = CustTable::checkExist(_custInterestJour.AccountNum) && ok;

        if (_custInterestJour.Fee)
        {
            if (_feeLedgerDimension)
            {
                ok = MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_feeLedgerDimension)) && ok;
            }
            else
            {
                ok = checkFailed(strFmt("@SYS308467",_custInterest.InterestCode)) && ok;
            }
        }

        ok = this.validateInterestTrans(_custInterestJour,_custTable.AccountNum) && ok;

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCustInterestForValidateInterestTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>CustInterest</c> record for the validateInterestTrans() method.
    /// </summary>
    /// <param name = "_custInterestJour">The interest note buffer.</param>
    /// <param name = "_custAccount">The customer account number that is associated with the interest note.</param>
    /// <param name = "_custInterestTrans">The current <c>CustInterestTrans record.</c></param>
    /// <returns>A <c>CustInterest</c> record.</returns>
    protected CustInterest findCustInterestForValidateInterestTrans(
        CustInterestJour _custInterestJour,
        CustAccount _custAccount,
        CustInterestTrans _custInterestTrans)
    {
        return CustInterest::find(CustLedgerAccounts::custInterest(_custAccount, this.getPostingProfile(_custInterestJour, _custInterestTrans.CustTransId)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInterestTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates the transactions that are associated with the interest note.
    /// </summary>
    /// <param name="_custInterestJour">
    ///    The interest note buffer.
    /// </param>
    /// <param name="_custAccount">
    ///    The customer account number that is associated with the interest note.
    /// </param>
    /// <returns>
    ///    true if all the transactions have a valid interest code; otherwise, false.
    /// </returns>
    protected boolean validateInterestTrans(CustInterestJour _custInterestJour, CustAccount _custAccount)
    {
        CustInterestTrans custInterestTrans;
        CustInterest custInterest;
        boolean isValid = true;
        LedgerDimensionDefaultAccount ledgerDimension;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)))
        {
            while select CustTransId, InterestAmount, CalcFrom, TransDate, InterestNote from custInterestTrans
                where custInterestTrans.InterestNote == _custInterestJour.InterestNote &&
                        custInterestTrans.InterestCalculate == NoYes::Yes
            {
                if (CustTrans::find(custInterestTrans.CustTransId).TransType != LedgerTransType::Cust)
                {
                    custInterest = this.findCustInterestForValidateInterestTrans(_custInterestJour, _custAccount, custInterestTrans);

                    ledgerDimension = CustInterestPost::ledgerDimension(custInterestTrans.InterestAmount, custInterest, _custInterestJour, custInterestTrans.RecId);

                    if (!ledgerDimension)
                    {
                        isValid = checkFailed("@SYS53440");
                        break;
                    }
                    if (!MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).MainAccountId))
                    {
                        isValid = false;
                        break;
                    }
                }
                else
                {
                    //If the interest transaction is associated with the Free text invoice, validate interest code associated with the
                    //interest lines
                    if (!this.validateInterestTransLine(_custInterestJour))
                    {
                        isValid = false;
                        break;
                    }
                }
            }
        }
        else
        {
            while select CustTransId, InterestAmount from custInterestTrans
                where custInterestTrans.InterestNote == _custInterestJour.InterestNote &&
                        custInterestTrans.InterestCalculate == NoYes::Yes
            {
                custInterest = this.findCustInterestForValidateInterestTrans(_custInterestJour, _custAccount, custInterestTrans);
                ledgerDimension = CustInterestPost::ledgerDimension(custInterestTrans.InterestAmount, custInterest, _custInterestJour, custInterestTrans.RecId);
                
                if (!ledgerDimension)
                {
                    isValid = checkFailed("@SYS53440");
                    break;
                }

                if (!MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).MainAccountId))
                {
                    isValid = false;
                    break;
                }
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateInterestTransLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the interest lines that are associated with the interest note.
    /// </summary>
    /// <param name="_custInterestJour">
    /// The interest note buffer.
    /// </param>
    /// <returns>
    /// true if all the interest lines have valid interest code; otherwise, false.
    /// </returns>
    protected boolean validateInterestTransLine(CustInterestJour _custInterestJour)
    {
        boolean isValid = true;
        CustInterestTransLine custInterestTransLine;
        CustInterestTrans custInterestTrans;
        CustInterest custInterest;
        LedgerDimensionDefaultAccount ledgerDimension;

        while select CustInterest, InterestAmount, CalcFrom, InterestNote, CustInterestTrans, RecId from custInterestTransLine
            where
                custInterestTransLine.InterestNote == _custInterestJour.InterestNote
            join RecId, InterestCalculate, TransDate from custInterestTrans
            where
                custInterestTrans.InterestCalculate == NoYes::Yes &&
                custInterestTrans.RecId == custInterestTransLine.CustInterestTrans
        {
            custInterest = CustInterest::find(custInterestTransLine.CustInterest);

            ledgerDimension = CustInterestHelper::getInterestTransLedgerAccount(CustInterestLedgerDimensionsOptions_PSN::InterestLinesLedgerDimension, custInterestTransLine);

            if (!ledgerDimension)
            {
                isValid = checkFailed("@SYS53440");
                break;
            }
            if (!MainAccount::checkAllowPosting(LedgerDimensionFacade::getMainAccountFromLedgerDimension(ledgerDimension).MainAccountId))
            {
                isValid = false;
                break;
            }
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS21519";
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the ledger dimension that is associated with the <c>CustInterestVersionDetail</c> record.
    /// </summary>
    /// <param name="_amount">
    /// The interest amount.
    /// </param>
    /// <param name="_custInterest">
    /// The <c>CustInterest</c> buffer that is used for the interest calculation.
    /// </param>
    /// <param name="_custInterestJour">
    /// The <c>CustInterestJour</c> buffer that is used for the interest calculation.
    /// </param>
    /// <param name="_custInterestTransRecId">
    /// The ID of the transaction record that is associated with the interest calculation.
    /// </param>
    /// <returns>
    /// The ledger dimension.
    /// </returns>
    public static LedgerDimensionDefaultAccount ledgerDimension(
        Amount _amount,
        CustInterest _custInterest,
        CustInterestJour _custInterestJour,
        RefRecId _custInterestTransRecId)
    {
        CustInterestVersion custInterestVersion;
        CustInterestVersionDetail custInterestVersionDetail;
        CustInterestTrans custInterestTrans;

        custInterestTrans = CustInterestTrans::find(_custInterestJour.InterestNote, _custInterestTransRecId);
        custInterestVersion = CustInterestVersion::findByDate(_custInterest.RecId, custInterestTrans.CalcFrom);

        if (_amount > 0)
        {
            custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(
                custInterestVersion.RecId,
                CustInterestFeeType::Earning);
        }
        else
        {
            custInterestVersionDetail = CustInterestVersionDetail::findByFeeType(
                custInterestVersion.RecId,
                CustInterestFeeType::Payment);
        }

        return custInterestVersionDetail.LedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides an entry point for the <c>CustPostInvoice</c> class when it is called from a menu item.
    /// </summary>
    /// <param name="_args">
    /// An <c>Args</c> instance with the <c>CustInterestJour</c> record to be processed.
    /// </param>
    public static void main(Args args)
    {
        CustInterestPost custInterestPost;
        CustInterestJour custInterestJour;

        custInterestPost = CustInterestPost::construct();

        if (args.record().TableId == tableNum(CustInterestJour))
        {
            custInterestJour = args.record();
        }

        if (custInterestJour)
        {
            custInterestPost.parmCustInterestJour(custInterestJour);
        }

        custInterestPost.getLast();
        // <GEEPL>
        if (custInterestJour && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            custInterestPost.postingDate(custInterestJour.NoteIssueDate_PL);
        }
        // </GEEPL>
        custInterestPost.updateQuery();

        if (custInterestPost.prompt())
        {
            custInterestPost.runOperation();
            custInterestPost.printout_PL();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransFromVoucher_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a <c>LedgerVoucherTransObject</c> class object from the list of transactions
    /// maintained by the parent <c>LedgerVoucherObject</c> object.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> class object from which to find a
    /// transaction.
    /// </param>
    /// <param name="_ledgerDimension">
    /// The <c>LedgerDimensionAccount</c> field value of the transaction to find.
    /// </param>
    /// <param name="_transactionAmount">
    /// The <c>transactionAmountCur</c> field value of the transaction to find.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The <c>LedgerPostingType</c> enum value of the transaction to find.
    /// </param>
    /// <returns>
    /// A <c>LedgerVoucherTransObject</c> class object from the <c>LedgerVoucherObject</c> class
    /// object if the transaction is found; otherwise, null.
    /// </returns>
    protected LedgerVoucherTransObject findTransFromVoucher_PSN(LedgerVoucherObject _ledgerVoucherObject,
                                                                LedgerDimensionAccount _ledgerDimension,
                                                                AmountCur _transactionAmount,
                                                                LedgerPostingType _ledgerPostingType)
    {
        LedgerVoucherTransObject ledgerVoucherTransObject;
        LedgerVoucherTransObject ledgerVoucherTransObjectToFind;

        LedgerVoucherTransList ledgerVoucherTransList = _ledgerVoucherObject.getInternalCollection();
        boolean doMore = ledgerVoucherTransList.first();

        while (doMore && !ledgerVoucherTransObjectToFind)
        {
            ledgerVoucherTransObject = ledgerVoucherTransList.item();

            if (ledgerVoucherTransObject.parmLedgerDimensionId() == _ledgerDimension
                && ledgerVoucherTransObject.parmTransactionCurrencyAmount() == _transactionAmount
                && ledgerVoucherTransObject.parmPostingType() == _ledgerPostingType)
            {
                ledgerVoucherTransObjectToFind = ledgerVoucherTransObject;
            }
            else
            {
                doMore = ledgerVoucherTransList.next();
            }
        }

        return ledgerVoucherTransObjectToFind;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeTransactionFromVoucher_PSN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Removes a transaction from the <c>LedgerVoucherObject</c> class object
    /// parameter based on the other parameter values.
    /// </summary>
    /// <param name="_ledgerVoucherObject">
    /// The <c>LedgerVoucherObject</c> class object that contains the current
    /// interest related transactions.
    /// </param>
    /// <param name="_accountNumber">
    /// Account number of the Customer for which to remove the transaction.
    /// </param>
    /// <param name="_custPostingProfile">
    /// The customer posting profile for which to use to create
    /// the account to lookup.
    /// </param>
    /// <param name="_defaultDimension">
    /// The default dimension for which to use to create
    /// the account to lookup.
    /// </param>
    /// <param name="_transactionAmount">
    /// The amount of the transaction to find.
    /// </param>
    /// <param name="_ledgerPostingType">
    /// The <c>LedgerPostingType</c> field value of the transaction to find.
    /// </param>
    protected void removeTransactionFromVoucher_PSN(LedgerVoucherObject _ledgerVoucherObject,
                                                    CustAccount _accountNumber,
                                                    CustPostingProfile _custPostingProfile,
                                                    DimensionDefault _defaultDimension,
                                                    AmountCur _transactionAmount,
                                                    LedgerPostingType _ledgerPostingType)
    {
        LedgerDimensionAccount mergedLedgerDimension = LedgerDimensionFacade::serviceCreateLedgerDimension(CustLedgerAccounts::summaryLedgerDimension(_accountNumber, _custPostingProfile),
                                                                                                           _defaultDimension);

        LedgerVoucherTransObject ledgerVoucherTransObject = this.findTransFromVoucher_PSN(_ledgerVoucherObject,
                                                                                          mergedLedgerDimension,
                                                                                          _transactionAmount,
                                                                                          _ledgerPostingType);

        if (ledgerVoucherTransObject)
        {
            _ledgerVoucherObject.removeTrans(ledgerVoucherTransObject);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printout_PL</Name>
				<Source><![CDATA[
    protected void printout_PL()
    {
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            int lenConPrintInterestReport = conLen(printInterestReport), i;
            Args args = new Args();
            args.parmEnum(NoYes::Yes);
            args.parmEnumType(enumNum(NoYes));
            args.caller(this);
            for (i = 1; i <= lenConPrintInterestReport; i++)
            {
                args.record(custInterestJour::find(conPeek(printInterestReport, i)));
                new MenuFunction(menuitemOutputStr(CustReport_interestNote), MenuItemType::Output).run(args);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allocates voucher number sequence.
    /// </summary>
    /// <param name = "_custInterestJour">The buffer of the <c>CustInterestJour</c> table.</param>
    /// <returns>An instance of the <c>NumberSeq</c> class.</returns>
    protected NumberSeq allocateVoucher(CustInterestJour _custInterestJour)
    {
        return NumberSeq::newGetVoucher(CustParameters::numRefInterestNoteVoucher());
    }

]]></Source>
			</Method>
			<Method>
				<Name>prePostCustInterest</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the pre posting logic for the Interest journal.
    /// </summary>
    protected void prePostCustInterest(CustInterestJour _custInterestJour)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>