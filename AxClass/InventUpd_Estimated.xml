<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventUpd_Estimated</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventUpd_Estimated</c> class brings inventory transactions to an estimated status.
/// </summary>
/// <remarks>
///    See the <c>SalesLineType.insert </c>method for an example of how the <c>InventUpd_Estimated</c>
///    class is used.
/// </remarks>
class InventUpd_Estimated extends InventUpdate
{
    // new parameters
    InventMovement  movement_Orig;
    boolean         skipUpdateDimensionFieldChange;

    // internal init
    InventQty       preEstimated;
    InventQty       transEstimated;
    InventQty       estimated;    

    UnitQty         preEstimatedUnit;
    UnitQty         transEstimatedUnit;
    UnitQty         estimatedUnit;

    // update result
    InventQty       updEstimated;

    PdsCWInventQty  cwPreEstimated;
    PdsCWInventQty  cwTransEstimated;
    PdsCWInventQty  cwEstimated;
    PdsCWInventQty  cwUpdEstimated;
    private InventUpdateReservationParameters reservationParameters;

    // if a warehouse enabled catch weight item actuals may be required during reservation
    private boolean cwForceActualsReservationUpdate;
    private boolean mustReread = true;

    //selection criteria
    InventDim               inventDimCriteria;
    InventDimParm           inventDimParm;
    boolean                 useInventDimCriteriaForNewTransactions;

    InventQty               estimatedBlockQty;
    PdsCWQty                estimatedBlockCWQty;

    private boolean isInventTrackingDimensionOwnerAutoActiveFlightEnabled = InventTrackingDimensionOwnerAutoActiveFlight::instance().isEnabled();

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>parmReservationParameters</Name>
				<Source><![CDATA[
    public InventUpdateReservationParameters parmReservationParameters(InventUpdateReservationParameters _reservationParameters = reservationParameters)
    {
        reservationParameters = _reservationParameters;
        return reservationParameters;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowChangeConsistentDim</Name>
				<Source><![CDATA[
    protected boolean allowChangeConsistentDim()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCWForceActualsReservationUpdate</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmCWForceActualsReservationUpdate(boolean _cwForceActualsReservationUpdate = cwForceActualsReservationUpdate)
    {
        cwForceActualsReservationUpdate = _cwForceActualsReservationUpdate;

        return cwForceActualsReservationUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNonChangeableTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether any non-changeable inventory transactions exists.
    /// </summary>
    /// <param name="_newInventDim">
    /// InventDim record referencing the new inventory dimensions; optional, defaulted to the movements new inventory dimensions.
    /// </param>
    /// <param name="_origInventDim">
    /// InventDim record referencing the previous inventory dimension; optional, defaulted to the movements previous inventory dimensions.
    /// </param>
    /// <returns>
    /// true if no non-changeable inventory transactions exist; otherwise, false
    /// </returns>
    public boolean checkNonChangeableTrans(
        InventDim   _newInventDim   = movement.inventdim(),
        InventDim   _origInventDim  = movement_Orig.inventdim())
    {
        boolean ok = true;

        if (_newInventDim.InventDimId != _origInventDim.InventDimId)
        {
            if (!InventDim::isInventDimEqualConsistent(movement.inventDimGroupSetup(), _newInventDim, _origInventDim))
            {
                if (!movement.canChangeConsistentDim(movement.onlyCheckStorageDimInConsistentCheck(_origInventDim)))
                {
                    ok = InventDim::checkUpdateConsistent(movement.inventDimGroupSetup(), _newInventDim, _origInventDim);
                }
            }
        }
        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateUpdateMovement</Name>
				<Source><![CDATA[
    internal boolean validateUpdateMovement()
    {
        return this.checkUpdateMovement();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUpdateMovement</Name>
				<Source><![CDATA[
    protected boolean checkUpdateMovement()
    {
        boolean ok = true;

        if (!movement_Orig && !movement.inventModelGroup().isStocked())
        {
            return checkFailed("@SYS190622");
        }

        if (!movement.inventTableInvent().UnitId)
        {
            return checkFailed("@SYS329027");
        }

        if (!movement.inventDimId())
        {
            return checkFailed("@SYS54831");
        }

        if (!movement.checkUpdateEstimatedMovement(movement_Orig))
        {
            ok = false;
        }

        if (WHSInventEnabled::exist(movement.itemId()) && !movement.inventTable().whsReservationHierarchy())
        {
            return checkFailed("@WAX4794");
        }

        if (movement_Orig)
        {
            if (movement.itemId() != movement_Orig.itemId())
            {
                ok = checkFailed("@SYS23375");
            }

            if (!this.checkNonChangeableTrans())
            {
                ok = false;
            }
        }

        if (!movement_Orig ||  (movement.inventDimId()      != movement_Orig.inventDimId() &&
                               (movement.inventLocationId() != movement_Orig.inventLocationId() ||
                                movement.inventSiteId()     != movement_Orig.inventSiteId())))
        {
            InventItemOrderSetupMap inventItemOrderSetupMap = movement.inventItemOrderSetupMap();
            if (!inventItemOrderSetupMap.checkInventSiteId(movement.inventSiteId(), !movement.canBeOnAllInventSites()))
            {
                ok = false;
            }

            if (ok && !inventItemOrderSetupMap.checkInventLocationId(movement.inventLocationId(), !movement.canBeOnAllInventLocations()))
            {
                ok = false;
            }
        }

        ok = ok && movement.checkWMSLocation();

        if (ok && #PdsCatchWeightEnabled)
        {
            ok = movement.inventTable().pdsCheckCWItemSetup();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createEstimatedInventTrans</Name>
				<Source><![CDATA[
    protected void createEstimatedInventTrans(
        InventQty       _qty,
        PdsCWInventQty  _cwQty = 0
        )
    {
        if (_qty != 0)
        {
            // create references like asset, project etc.
            this.createInventTransOriginAndReferences();

            using (var cache = movement.constructRecordViewCache())
            {
                StatusReceipt statusReceipt = this.retrieveEstimatedInventTransReceiptStatus(_qty);
                StatusIssue statusIssue = this.retrieveEstimatedInventTransIssueStatus(_qty);
                InventTrans inventTrans = this.initInventTransFromInventMovement(movement);
                inventTrans.updateQty(movement.mustAggregateExpectedTransactions(), _qty, _cwQty);

                movement.transIdSum().setInventTransStatus(inventTrans,statusReceipt,statusIssue);

                // Modified to check to see if inventory dimensions need adjusted
                // for WHS items only
                inventTrans.InventDimId = this.retrieveInventTransInventDimId(movement);
                
                if (movement.isItemWHSEnabled())
                {
                    WHSParameters::validateLicensePlateTracking(inventTrans.InventDimId);
                    inventTrans.InventDimId = this.whsAdjustInventDimFromMovementTransaction(inventTrans.InventDimId);
                }

                if (inventTrans.StatusReceipt == StatusReceipt::Ordered)
                {
                    inventTrans.ReturnInventTransOrigin = movement.returnInventTransOrigin();
                }

                this.writeInventTransAutoDim(inventTrans,null,false);

                if (transLinkCache_RU)
                {
                    transLinkCache_RU.restore(tableNum(InventTrans), inventTrans.RecId);
                }

                updEstimated += _qty;
                cwUpdEstimated += _cwQty;

                this.updateInventTransMarking(inventTrans, movement, _qty, _cwQty);

                if (movement_Orig && !this.parmSkipInventTransSumUp())
                {
                    // Sync the buffer record to the latest value as it may be changed in other place
                    if (mustReread)
                    {
                        inventTrans.reread();
                    }
                    inventTrans.updateSumUp();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransMarking</Name>
				<Source><![CDATA[
    private void updateInventTransMarking(InventTrans _inventTrans, InventMovement _inventMovement, InventQty _qty, PdsCWInventQty  _cwQty)
    {
        #ISOCountryRegionCodes

        if (_inventTrans.ProjId && FeatureStateProvider::isFeatureEnabled(ProjEnableInventoryMarkingTelemetryFlight::instance()))
        {
            ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(InventUpd_Estimated));
            using (var activityContext = logger.projOpsManagementActivity().projInventTransMarkingUpdateContext())
            {
                logger.logInformation(strFmt("Before update InventTransOrigin: %1, MarkingRefInventTransOrigin: %2", int642str(_inventTrans.InventTransOrigin), int642str(_inventTrans.MarkingRefInventTransOrigin)));
            }
        }

        InventTransOriginId markingRefInventTransOriginId = _inventMovement.markingRefInventTransOrigin();
        if (markingRefInventTransOriginId) // Marking for entire lotId exists => additional should also be marked
        {
            InventDim inventDimMovement             = _inventMovement.inventdim();
            InventDimParm markingInventDimParmFixed = _inventMovement.markingInventDimParmFixed();
            Voucher voucherToMarkAgainst            = _inventMovement.relatedVoucher();
            PmfQtyDataCarrier outQuantities         = new PmfQtyDataCarrier();;

            InventQty markNow = InventTransOrigin::updateMarking(
                markingRefInventTransOriginId,
                _inventMovement.inventTransOriginId(),
                -_qty,
                voucherToMarkAgainst,
                SortOrder::Descending,
                _inventMovement.markingPreferPhysical(),
                inventDimMovement,
                markingInventDimParmFixed,
                -_cwQty,
                outQuantities);
            PdsCWInventQty cwMarkNow = outQuantities.parmCwQty();

            if (markNow)
            {
                if (abs(markNow) < abs(_inventTrans.Qty) || abs(cwMarkNow) < abs(_inventTrans.PdsCWQty) )
                {
                    _inventMovement.informAboutIncompleteMarking(_inventTrans.Qty, markNow, voucherToMarkAgainst);

                    _inventTrans.clearMarking();
                    _inventTrans.update();
                    _inventTrans.updateSplit(
                        _inventTrans.Qty > 0 ? abs(markNow) : - abs(markNow),
                        _inventTrans.PdsCWQty > 0 ? abs(cwMarkNow) : - abs(cwMarkNow));
                }
                _inventTrans.setMarking(markingRefInventTransOriginId);
                _inventTrans.update();

                InventTrans::findByInventTransOrigin(_inventTrans.MarkingRefInventTransOrigin, true).updateSumUp();
            }

            Query queryMarked = this.buildMarkedInventTransQuery(
                _qty,
                inventDimMovement, 
                markingInventDimParmFixed, 
                markingRefInventTransOriginId);
            QueryRun queryRunMarked = new QueryRun(queryMarked);
            InventTrans inventTransMovement;

            if (!queryRunMarked.next())
            {
                // try to give an idea of which dimensions could wrong
                if (_qty > 0)
                {
                    // this is a receipt which is marked against an issue
                    select firstonly inventTransMovement
                        where inventTransMovement.PackingSlipReturned == NoYes::No
                            &&  inventTransMovement.InventTransOrigin == markingRefInventTransOriginId
                            &&  inventTransMovement.Qty < 0;
                }
                else
                {
                    // this is an issue which is marked against a receipt
                    select firstonly inventTransMovement
                        where inventTransMovement.PackingSlipReturned == NoYes::No
                            &&  inventTransMovement.InventTransOrigin == markingRefInventTransOriginId
                            &&  inventTransMovement.Qty > 0;
                }
                InventDim inventDimMarked = inventTransMovement.inventDim();
                InventDimParm inventDimParmMarked;
                inventDimParmMarked.initFromInventDim(inventDimMarked);
                inventDimParmMarked = InventDimParm::andParms(inventDimParmMarked, markingInventDimParmFixed);

                if (!InventDim::isInventDimParmEqual(inventDimMarked, inventDimMovement, inventDimParmMarked))
                {
                    throw error("@SYS18738");
                }
            }
            else
            {
                inventTransMovement = InventTrans::findRecId(queryRunMarked.get(tableNum(InventTrans)).RecId);
            }

            if (_qty < 0) // issue
            {
                if (_inventMovement.mustReserveBasedOnMarkingOnCreation())
                {
                    InventUpd_Reservation::updateReserveRefTransId(_inventMovement);   // try to make reservation according to marking - 
                    if (markNow && _inventTrans.MarkingRefInventTransOrigin)
                    {
                        _inventTrans.reread();
                        mustReread = false;
                    }
                }
            }
            else
            {
                InventMovement movementIssue = inventTransMovement.inventMovement(true);
                if (_inventMovement.isVirtuel() && !movementIssue)  // if the referenced movement not exist yet
                {
                    InventMov_Virtuel movementVirtuel = _inventMovement;
                    // <GEEU>
                    if (! SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]) 
                        || movementVirtuel.parmInventMovReference())
                    {
                        movementIssue = InventMovement::constructNoThrow(movementVirtuel.parmInventMovReference().buffer());// no Throw if not initiated
                    }
                    // </GEEU>
                }
                if (movementIssue && markNow)
                {
                    InventUpd_Reservation::updateReserveRefTransId(movementIssue);  // try to make reservation according to marking -
                }
            }

            if (!markNow && _inventTrans.MarkingRefInventTransOrigin) // reset marking if no marking could be made
            {
                _inventTrans.reread();
                if (_inventTrans.RecId)
                {
                    _inventTrans.clearMarking();
                    _inventTrans.update();
                }

                mustReread = false;
            }
        }
        if (_inventTrans.ProjId && FeatureStateProvider::isFeatureEnabled(ProjEnableInventoryMarkingTelemetryFlight::instance()))
        {
            ProjOpsManagementLogger logger = ProjOpsManagementLogger::createLogger(classStr(InventUpd_Estimated));
            using (var activityContext = logger.projOpsManagementActivity().projInventTransMarkingUpdateContext())
            {
                logger.logInformation(strFmt("After update InventTransOrigin: %1, MarkingRefInventTransOrigin: %2", int642str(_inventTrans.InventTransOrigin), int642str(_inventTrans.MarkingRefInventTransOrigin)));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildMarkedInventTransQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a query to extract marked inventory transaction records.
    /// </summary>
    /// <param name = "_qty">An inventory quantity.</param>
    /// <param name = "_inventDimMovement">An inventory movement.</param>
    /// <param name = "_markingInventDimParmFixed">Dimension parameters that contain info on which dimensions were fixed when marking was applied.</param>
    /// <param name = "_markingRefInventTransOriginId">The ID of a marked transaction origin.</param>
    /// <returns>A query that extracts marked inventory transactions.</returns>
    protected Query buildMarkedInventTransQuery(InventQty _qty, InventDim _inventDimMovement, InventDimParm _markingInventDimParmFixed, InventTransOriginId _markingRefInventTransOriginId)
    {
        Query queryMarked = new Query();
        QueryBuildDataSource queryBuildDataSourceTrans = queryMarked.addDataSource(tableNum(InventTrans));
        queryBuildDataSourceTrans.firstOnly(true);
        queryBuildDataSourceTrans.addSelectionField(fieldNum(InventTrans, RecId));
        queryBuildDataSourceTrans.addRange(fieldNum(InventTrans, InventTransOrigin)).value(queryValue(_markingRefInventTransOriginId));
        QueryBuildRange queryBuildRangeQty = queryBuildDataSourceTrans.addRange(fieldNum(InventTrans, Qty));
        if (_qty > 0)
        {
            // this is a receipt which must be marked against an issue
            queryBuildRangeQty.value('..0.00');
        }
        else
        {
            // this is an issue which must be marked against a receipt
            queryBuildRangeQty.value('0.00..');
        }
        QueryBuildDataSource queryBuildDataSourceDim = queryBuildDataSourceTrans.addDataSource(tableNum(InventDim));
        queryBuildDataSourceDim.relations(true);
        queryBuildDataSourceDim.addSelectionField(fieldNum(InventDim, RecId));

        // Specified fixed marking dimensions must match for marked movements - so either blank or same value
        _markingInventDimParmFixed.queryAddRangeValue(queryBuildDataSourceDim, _inventDimMovement);   // allow same value
        InventDim inventDimEmpty;
        _markingInventDimParmFixed.queryAddRange(queryBuildDataSourceDim, inventDimEmpty);           // or blank value

        return queryMarked;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveInventTransInventDimId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an inventory dimension ID for an inventory transaction instance.
    /// </summary>
    /// <param name = "_inventMovement">An inventory movement.</param>
    /// <returns>An inventory dimension ID.</returns>
    protected InventDimId retrieveInventTransInventDimId(InventMovement _inventMovement)
    {
        if (_inventMovement.isItemWHSEnabled() && !useInventDimCriteriaForNewTransactions)
        {
            return _inventMovement.adjustTransactionInventDimEstimated().InventDimId;
        }
        else
        {
            return this.estimatedInventDimId();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initInventTransFromInventMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes an inventory transaction from the <c>InventMovement</c> instance.
    /// </summary>
    /// <param name = "_inventMovement">An inventory movement.</param>
    /// <returns>The initialized inventory transaction instance.</returns>
    protected InventTrans initInventTransFromInventMovement(InventMovement _inventMovement)
    {
        return _inventMovement.initInventTrans();
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveEstimatedInventTransReceiptStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an estimated inventory transaction receipt status.
    /// </summary>
    /// <param name = "_inventQty">An inventory quantity.</param>
    /// <returns>An estimated inventory transaction receipt status.</returns>
    protected StatusReceipt retrieveEstimatedInventTransReceiptStatus(InventQty _inventQty)
    {
        StatusReceipt statusReceipt;

        if (_inventQty > 0)
        {
            if (movement.mustBeQuotationControlled())
            {
                statusReceipt = StatusReceipt::QuotationReceipt;
            }
            else
            {
                statusReceipt = StatusReceipt::Ordered;
            }
        }
        else
        {
            statusReceipt = StatusReceipt::None;
        }

        return statusReceipt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveEstimatedInventTransIssueStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves an estimated inventory transaction issue status.
    /// </summary>
    /// <param name = "_inventQty">An inventory quantity.</param>
    /// <returns>An estimated inventory transaction issue status.</returns>
    protected StatusIssue retrieveEstimatedInventTransIssueStatus(InventQty _inventQty)
    {
        StatusIssue statusIssue;

        if (_inventQty > 0)
        {
            statusIssue   = StatusIssue::None;
        }
        else if (movement.mustBeQuotationControlled())
        {
            statusIssue  = StatusIssue::QuotationIssue;
        }
        else
        {
            statusIssue  = StatusIssue::OnOrder;
        }

        return statusIssue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cwUpdEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the pre-calculated estimated catch weight quantity.
    /// </summary>
    /// <returns>
    /// The catch weight quantity value.
    /// </returns>
    public PdsCWInventQty cwUpdEstimated()
    {
        return cwUpdEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteInvalidMarking</Name>
				<Source><![CDATA[
    protected void deleteInvalidMarking()
    {
        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;
        boolean             alreadyPrinted;

        boolean deleteMarking = !InventDim::checkUpdateEstimatedMarked(movement,movement_Orig); // financial inventory is changed -> delete marking
        if (!deleteMarking)
        {
            return;
        }

        while select TableId from inventTransOrigin
            where inventTransOrigin.RecId == movement.inventTransOriginId()             &&
                  inventTransOrigin.ReferenceId
            join forupdate inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                  && (inventTrans.StatusReceipt     == StatusReceipt::Ordered
                  ||  inventTrans.StatusReceipt     == StatusReceipt::QuotationReceipt
                  ||  inventTrans.StatusIssue       == StatusIssue::OnOrder
                  ||  inventTrans.StatusIssue       == StatusIssue::ReservPhysical
                  ||  inventTrans.StatusIssue       == StatusIssue::ReservOrdered
                  ||  inventTrans.StatusIssue       == StatusIssue::QuotationIssue)
        {
            if (inventTrans.deleteInvalidMarking(movement) && !alreadyPrinted )
            {
                if (movement && movement.buffer() && FormDataUtil::isFormDataSource(movement.buffer()))
                {
                    info("@SYS79365");
                }
                alreadyPrinted = true;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initUpdate</Name>
				<Source><![CDATA[
    protected void initUpdate()
    {
        super();

        this.setParmAllowDefault();
        this.parmAllowReserveReduction(true);
        this.parmSkipUpdateDimensionFieldChange(false);

        if (movement.newMovement_TransferIssueReceive())
        {
            this.parmAllowNegativePhysical(true);
        }

        movement_Orig = movement.newMovement_Orig();

        if (movement_Orig && !movement_Orig.transId())
        {
            movement_Orig.logUnexpectedLotIdNotSpecified(funcName());
            throw error("@SYS17272");
        }

        if (movement.mustBeQuotationControlled())
        {
            // Project virtuel inventTrans forbidden
            movement.parmMustDoAutoLossProfitForbid(true);
        }

        this.initEstimatedQty();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initEstimatedQty</Name>
				<Source><![CDATA[
    private void initEstimatedQty()
    {
        movement.setPreTransEstimated(movement_Orig,this);

        estimated = transEstimated- preEstimated;

        estimatedBlockQty = estimated;

        cwEstimated = cwTransEstimated - cwPreEstimated;

        estimatedBlockCWQty = cwEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateInventoryTransactionDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the inventory transaction dimension must be updated.
    /// </summary>
    /// <param name = "_inventTransToCheck">The inventory transaction to check.</param>
    /// <returns>true if the inventory transaction dimension must be updated; otherwise, false.</returns>
    protected boolean mustUpdateInventoryTransactionDimension(InventTrans _inventTransToCheck)
    {
        return (!movement.mustBeSameTransSign() || _inventTransToCheck.Qty * movement.transQty() > 0);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(InventMovement  _inventMovement)
    {
        super(_inventMovement);

        this.initUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCWPreEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets or sets the cwPreEstimated parameter.
    /// </summary>
    /// <param name="_cwPreEstimated">
    /// Values to be set.
    /// </param>
    /// <returns>
    /// The cwPreEstimated parameter.
    /// </returns>
    public PdsCWInventQty parmCWPreEstimated(
        PdsCWInventQty _cwPreEstimated = cwPreEstimated)
    {
        cwPreEstimated = _cwPreEstimated;
        return cwPreEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCWTransEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets or sets the cwTransEstimated parameter.
    /// </summary>
    /// <param name="_cwTransEstimated">
    /// Value to be set.
    /// </param>
    /// <returns>
    /// The cwTransEstimated parameter.</returns>
    public PdsCWInventQty parmCWTransEstimated(
        PdsCWInventQty _cwTransEstimated = cwTransEstimated)
    {
        cwTransEstimated = _cwTransEstimated;
        return cwTransEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEstimated</Name>
				<Source><![CDATA[
    public InventQty parmEstimated(InventQty _estimated = estimated)
    {
        estimated = _estimated;
        return estimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDim</Name>
				<Source><![CDATA[
    public InventDim parmInventDim(InventDim _inventDimCriteria  = inventDimCriteria)
    {
        inventDimCriteria = _inventDimCriteria;
        return inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimParm</Name>
				<Source><![CDATA[
    public InventDimParm parmInventDimParm(InventDimParm _inventDimParm = inventDimParm)
    {
        inventDimParm = _inventDimParm;
        return inventDimParm;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPdsCWEstimated</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method gets or sets the cwEstimated parameter.
    /// </summary>
    /// <param name="_cwEstimated">Value to be set.</param>
    /// <returns>
    /// The cwEstimated parameter.
    /// </returns>
    public PdsCWInventQty parmPdsCWEstimated(
        PdsCWInventQty _cwEstimated = cwEstimated)
    {
        cwEstimated = _cwEstimated;
        return cwEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPreEstimated</Name>
				<Source><![CDATA[
    public InventQty parmPreEstimated(InventQty _preEstimated = preEstimated)
    {
        preEstimated = _preEstimated;
        return preEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTransEstimated</Name>
				<Source><![CDATA[
    public InventQty parmTransEstimated(InventQty _transEstimated = transEstimated)
    {
        transEstimated = _transEstimated;
        return transEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsAdjustTransactionQty</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adjusts the inventory quantity for a transaction related to a catch weight item.
    /// </summary>
    /// <param name="_direction">
    ///    Specifies whether an issue or a receipt is to be updated.
    /// </param>
    /// <param name="_qty">
    ///    The quantity to add to the current quantity.
    /// </param>
    /// <param name="_inventDimId">
    ///    The inventory dimensions of the transaction to update.
    /// </param>
    /// <exception cref="Exception::Error">
    ///    Function pdsAdjustInventQty has been called incorrectly.
    /// </exception>
    /// <exception cref="Exception::Error">
    ///    Insufficient inventory transactions with status OnOrder/Ordered.
    /// </exception>

    public void pdsAdjustTransactionQty(
        InventDirection     _direction,
        InventQty           _qty,
        InventDimId         _inventDimId
        )
    {
        InventTrans             inventTrans;
        InventQty               qtyRemaining = _qty;
        StatusReceipt           statusReceipt;
        StatusIssue             statusIssue;
        PdsCatchWeightItem      pdsCatchWeightItem;

        InventQty adjustInventTrans(inventTrans _inventTrans, InventQty _qtyRemaining)
        {
            InventQty           remaining   = _qtyRemaining;
            InventQty           qtyThis;
            InventQty           minValue;
            InventQty           maxValue;
            boolean             isAbsoluteIncrease = false; // is this an increase in absolute total quantity

            if (!pdsCatchWeightItem.RecId)
            {
                pdsCatchWeightItem = PdsCatchWeightItem::find(_inventTrans.ItemId);
            }

            if (_inventTrans.StatusIssue == StatusIssue::None)
            {
                // A receipt, so validate positive quantities
                minValue = pdsCatchWeightItem.PdsCWMin;
                maxValue = pdsCatchWeightItem.PdsCWMax;
            }
            else
            {
                // An issue, so validate negative quantities
                minValue = -pdsCatchWeightItem.PdsCWMax;
                maxValue = -pdsCatchWeightItem.PdsCWMin;
            }

            if (_inventTrans.Qty * remaining > 0)
            {
                // If same sign we are increasing total quantity
                isAbsoluteIncrease = true;
            }

            if (_inventTrans.Qty + remaining >= minValue
            &&  _inventTrans.Qty + remaining <= maxValue)
            {
                // 1. All can be assigned to this record
                qtyThis = remaining;
            }
            else if (isAbsoluteIncrease && abs(_inventTrans.Qty) >= pdsCatchWeightItem.PdsCWMax)
            {
                // 2. Increasing absolute quantity and transaction is already at or above max
                qtyThis = 0;
            }
            else if (!isAbsoluteIncrease && abs(_inventTrans.Qty) <= pdsCatchWeightItem.PdsCWMin)
            {
                // 3. Reducing absolute quantity and transaction is already at or below min
                qtyThis = 0;
            }
            else if (isAbsoluteIncrease)
            {
                // 4. Increasing absolute quantity. Ensure we don't go above max
                qtyThis = min(pdsCatchWeightItem.PdsCWMax, abs(inventTrans.Qty + remaining)) - abs(inventTrans.Qty); // Change in positive values
                if (remaining < 0)
                {
                    qtyThis = -1 * qtyThis; // set the right sign.
                }
            }
            else
            {
                // 5. Reducing absolute quantity. Ensure we don't go below min
                qtyThis = abs(inventTrans.Qty) - max(pdsCatchWeightItem.PdsCWMin, abs(inventTrans.Qty + remaining)); // Change in positive values
                if (remaining < 0)
                {
                    qtyThis = -1 * qtyThis; // set the right sign.
                }
            }

            if (qtyThis != 0)
            {
                _inventTrans.Qty += qtyThis;
                _inventTrans.update();
                remaining -= qtyThis;
            }
            return remaining;
        }

        if (!movement.pdsCWItem())
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        switch (_direction)
        {
            case InventDirection::Issue:
                statusReceipt   = StatusReceipt::None;
                statusIssue     = StatusIssue::OnOrder;
                break;
            case InventDirection::Receipt:
                statusReceipt   = StatusReceipt::Ordered;
                statusIssue     = StatusIssue::None;
                break;
            default:
                throw error(Error::wrongUseOfFunction(funcName()));
        }

        while select forupdate inventTrans
            where inventTrans.InventTransOrigin == movement.inventTransOriginId()
                && inventTrans.TransChildType    == movement.transChildType()
                && inventTrans.TransChildRefId   == movement.transChildRefId()
                && inventTrans.StatusReceipt     == statusReceipt
                && inventTrans.StatusIssue       == statusIssue
                && inventTrans.InventDimId       == _inventDimId
                && ((_direction == InventDirection::Receipt && inventTrans.PdsCWQty > 0)
                ||  (_direction == InventDirection::Issue   && inventTrans.PdsCWQty < 0))
        {
            qtyRemaining = adjustInventTrans(inventTrans, qtyRemaining);
            if (qtyRemaining == 0)
            {
                break;
            }
        }
        if (qtyRemaining != 0)
        {
            if (statusIssue == StatusIssue::None)
            {
                // Receipts
                Info("@SCM:InventOrderShouldIncreaseOrderedQuantity");
                throw error(strFmt("@SYS54028", StatusReceipt::Ordered));
            }
            // Issues
            Info("@SCM:InventOrderShouldIncreaseOnOrderQuantity");
            throw error(strFmt("@SYS54028", StatusIssue::OnOrder));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustBuildBatchId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if a Batch Id must be build for a given inventory number group.
    /// </summary>
    /// <param name = "_inventNumGroup">The inventory number group.</param>
    /// <returns>true if Batch Id must be build; otherwise, false.</returns>
    protected boolean mustBuildBatchId(InventNumGroup _inventNumGroup)
    {
        if (_inventNumGroup.ManualAllocation                                 ||
            _inventNumGroup.OnlyInventTransaction                            ||
            _inventNumGroup.PhysicalUpdate                                   ||
            !_inventNumGroup.isTransTypeActivated(movement.transType()))
        {
            return false;
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimBatchId</Name>
				<Source><![CDATA[
    protected boolean updateAutoDimBatchId()
    {
        if (!movement.inventTable().BatchNumGroupId
         || !movement.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim,InventBatchId)))
        {
            return false;
        }

        InventDim inventDim = movement.inventdim();
        if (inventDim.InventBatchId)
        {
            return false;
        }

        InventNumGroup inventNumGroup = InventNumGroup::find(movement.inventTable().BatchNumGroupId);
        if (!inventNumGroup)
        {
            throw error(strFmt("@SYS3312",inventNumGroup.NumGroupId));
        }

        if (!this.mustBuildBatchId(inventNumGroup))
        {
            return false;
        }

        inventDim.InventBatchId = inventNumGroup.buildNumber(movement, extendedTypeNum(InventBatchId));
        if (!inventDim.InventBatchId)
        {
            throw error(strFmt("@SYS54023",inventNumGroup.NumGroupId));
        }

        if (!InventBatch::exist(inventDim.InventBatchId, movement.itemId()))
        {
            InventBatch  inventBatch;

            inventBatch.InventBatchId = inventDim.InventBatchId;
            inventBatch.initFromInventMovement(movement);
            inventBatch.insert();
        }

        movement.inventdim(inventDim);
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimMovement</Name>
				<Source><![CDATA[
    protected void updateAutoDimMovement()
    {
        boolean     updateDim;

        InventDimParm activeAutoDimensionMovementFields = this.activeAutoDimensionMovementFields();

        if (activeAutoDimensionMovementFields.InventBatchIdFlag)
        {
            updateDim = this.updateAutoDimBatchId();
        }

        if (activeAutoDimensionMovementFields.InventSerialIdFlag)
        {
            updateDim = this.updateAutoDimSerialId() || updateDim;
        }
        
        if (activeAutoDimensionMovementFields.InventLocationIdFlag)
        {
            updateDim = movement.updateAutoDimLocationId() || updateDim;
        }

        if (activeAutoDimensionMovementFields.InventStatusFlag)
        {
            // Default status if needed
            updateDim = movement.whsUpdateAutoDimStatusId() || updateDim;
        }
        
        if (activeAutoDimensionMovementFields.InventOwnerIdFlag_RU)
        {
            // Default owner if needed
            updateDim = movement.updateAutoDimOwnerId() || updateDim;
        }

        if (updateDim)
        {
            InventDim inventDim = InventDim::findOrCreate(movement.inventdim());
            movement.setInventDimId(inventDim.InventDimId);
            movement.inventdim(inventDim);

            // Estimated qty is changed, need to re-initialize estimated qty
            if (movement.needInitUpdateEstimationQty() && 
                movement.mustBeUpdatedExpected() &&
                transEstimated != movement.remainPhysical())
            {
                this.initEstimatedQty();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>activeAutoDimensionMovementFields</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the active inventory dimension parameters for which to update auto dimension movement.
    /// </summary>
    /// <returns>An initialized inventory dimension parameters record.</returns>
    protected InventDimParm activeAutoDimensionMovementFields()
    {
        InventDimParm inventDimParameters;

        if ((!movement_Orig && movement.transQty() > 0)
            || (movement_Orig && movement_Orig.transQty() <= 0 && movement.transQty() > 0))
        {
            inventDimParameters.InventBatchIdFlag = NoYes::Yes;
            inventDimParameters.InventSerialIdFlag = NoYes::Yes;
        }

        inventDimParameters.InventLocationIdFlag = NoYes::Yes;
        inventDimParameters.InventStatusFlag = NoYes::Yes;

        if (movement.inventTable().isItemOwnerIdActivated() && isInventTrackingDimensionOwnerAutoActiveFlightEnabled)
        {
            inventDimParameters.InventOwnerIdFlag_RU = NoYes::Yes;
        }
        return inventDimParameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAutoDimSerialId</Name>
				<Source><![CDATA[
    protected boolean updateAutoDimSerialId()
    {
        if (!movement.inventTable().SerialNumGroupId
         || !movement.inventDimGroupSetup().isDimensionActive(fieldNum(InventDim,InventSerialId)))
        {
            return false;
        }

        InventDim inventDim = movement.inventdim();
        if (inventDim.InventSerialId)
        {
            return false;
        }

        InventNumGroup inventNumGroup = InventNumGroup::find(movement.inventTable().SerialNumGroupId);
        if (!inventNumGroup)
        {
            throw error(strFmt("@SYS3312",inventNumGroup.NumGroupId));
        }

        if (inventNumGroup.ManualAllocation                                 ||
            inventNumGroup.OnlyInventTransaction                            ||
            inventNumGroup.PhysicalUpdate                                   ||
            !inventNumGroup.isTransTypeActivated(movement.transType()))
        {
            return false;
        }

        inventDim.InventSerialId = inventNumGroup.buildNumber(movement,extendedTypeNum(InventSerialId));
        if (!inventDim.InventSerialId)
        {
            throw error(strFmt("@SYS54023",inventNumGroup.NumGroupId));
        }

        movement.inventdim(inventDim);
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDepreciateIssue</Name>
				<Source><![CDATA[
    protected void updateDepreciateIssue()
    {
        #define.CounterpartsCheck(0)   // if we have movement we check counterpart transactions first two loops
        #define.NoCounterpartsCheck(2) // last two loops we do not check counterparts transactions
        #define.MaxLoopCount(4)        // the loop is executed 4 times at most

        boolean                 selectMarkedTrans;
        InventQty               qtyToDelete = estimated; //  keeps absolute value of quantity to be deleted
        PdsCWInventQty          cwQtyToDelete = cwEstimated;

        if (!movement.inventTransOriginId() && movement.mustPostingCreateInventTrans())
        {
            movement.logUnexpectedLotIdNotSpecified(funcName());
            throw error("@SYS17272");
        }

        using (var cache = movement.constructRecordViewCache())
        {
            InventMovement movementReceiptShip = movement.newMovement_TransferReceiptShip();

            boolean selectMarkedTransFirst = false;
            WHSDeprTransactionsForRMPickBasedOnInventTransContext context = WHSDeprTransactionsForRMPickBasedOnInventTransContext::current();
            if (context && context.parmSelectMarkedTransFirst())
            {
                selectMarkedTransFirst = true;
            }

            Integer loopCount = (movementReceiptShip ? #CounterpartsCheck : #NoCounterpartsCheck);

            for (selectMarkedTrans = selectMarkedTransFirst; loopCount < #MaxLoopCount; ++loopCount) // first select unmarked transactions
            {
                // try to delete extra quantity from transactions selected on this step
                [qtyToDelete, cwQtyToDelete] = this.updateDepreciateTransactions(
                    InventTransRepository::construct().getTransactionsForDepreciation(
                        InventDirection::Issue,
                        movement,
                        inventDimCriteria,
                        inventDimParm,
                        selectMarkedTrans),
                    qtyToDelete,
                    (loopCount < #NoCounterpartsCheck) ? movementReceiptShip : null,
                        cwQtyToDelete);

                if (qtyToDelete == 0)
                {
                    // quantity has been already reduced as required
                    break;
                }

                selectMarkedTrans = !selectMarkedTrans;
            }

            if (qtyToDelete != 0 && movement.mustPostingCreateInventTrans())
            {
                this.displayWrongReduceQuantityMessage();
                throw error(strFmt("@SCM:DepreciateIssueErrorMessage", movement.itemId(), movement.transId()));
            }

            if (!InventTransOrigin::transactionsExist(movement.inventTransOriginId()))
            {
                this.deleteInventTransOriginAndReferences();
            }

            WHSOrderCommittedReservationFacade::afterMovementUpdateDepreciateIssue(this);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>displayWrongReduceQuantityMessage</Name>
				<Source><![CDATA[
    private void displayWrongReduceQuantityMessage()
    {
        QueryRun queryRun = new QueryRun(movement.buildQueryInventTransTransChild());
        Set orphanChildReferences = new Set(Types::Container);

        while (queryRun.next())
        {
            InventTrans inventTrans = QueryRun.get(tableNum(InventTrans));

            if (inventTrans.Qty == 0)
            {
                continue;
            }

            if (InventTrans.TransChildType == InventTransChildType::None)
            {
                if (inventTrans.StatusIssue == StatusIssue::Picked)
                {
                    this.throwErrorWithUnpickMenuAction(inventTrans);
                }
                else
                {
                    error(strFmt("@SYS66069", abs(inventTrans.Qty), movement.transType(), movement.transRefId()));
                }
            }
            else
            {
                if (inventTrans.hasOrphanChildReference())
                {
                    orphanChildReferences.add([inventTrans.InventTransOrigin, inventTrans.TransChildRefId, inventTrans.TransChildType]);
                }
                else
                {
                    this.throwErrorWithProductionOrderMenuAction(inventTrans);
                }
            }
        }
        
        InventCleanOrphanChildReference::addToCache(InventTransOrigin::find(movement.inventTransOriginId()), orphanChildReferences);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwErrorWithUnpickMenuAction</Name>
				<Source><![CDATA[
    private void throwErrorWithUnpickMenuAction(InventTrans _inventTrans)
    {
        MenuItemMessageAction actionData = new MenuItemMessageAction();
        InventTransOrigin inventTransOrigin;
        select firstonly inventTransOrigin
            where inventTransOrigin.RecId == _inventTrans.InventTransOrigin
                && inventTransOrigin.DataAreaId == _inventTrans.DataAreaId;

        actionData.MenuItemName(menuItemDisplayStr(WMSPickingRegistration));
        actionData.TableName(tableStr(WMSPickingRoute));

        WMSPickingRoute pickingRoute;
        WMSOrderTrans orderTrans;

        switch (inventTransOrigin.ReferenceCategory)
        {
            case InventTransType::Sales:
                SalesTable salesOrder = SalesTable::find(movement.transRefId());
                select firstonly pickingRoute join orderTrans
                    where pickingRoute.transRefId == salesOrder.SalesId && pickingRoute.pickingRouteId == orderTrans.routeId;
                actionData.RecId(pickingRoute.RecId);
                break;
            case InventTransType::TransferOrderShip:
                InventTransferTable transferOrder = InventTransferTable::find(movement.transRefId());
                select firstonly pickingRoute join orderTrans
                    where pickingRoute.transRefId == transferOrder.TransferId && pickingRoute.pickingRouteId == orderTrans.routeId;
                actionData.RecId(pickingRoute.RecId);
                break;
            // For default case, actionData will not be assigned RecId, will go to picking table directly.
        }

        str jsonData = FormJsonSerializer::serializeClass(actionData);
        Message::AddAction(MessageSeverity::Warning, strFmt("@SCM:PickedItemCannotReduceQuantity", abs(_inventTrans.qty), movement.transType(), movement.transRefId()), "@SCM:InventUpd_GoToPickingListLabel", MessageActionType::DisplayMenuItem, jsonData);
    }

]]></Source>
			</Method>
			<Method>
				<Name>throwErrorWithProductionOrderMenuAction</Name>
				<Source><![CDATA[
    private void throwErrorWithProductionOrderMenuAction(InventTrans _inventTrans)
    {
        var message = InventUpd_EstimatedWrongReduceQuantityMessage::newFromInventTrans(_inventTrans);

        Message::AddAction(message.messageSeverity(), message.messageText(), message.actionText(), message.actionType(), message.actionData());
    }

]]></Source>
			</Method>
			<Method>
				<Name>movementCaseStatusToFrom</Name>
				<Source><![CDATA[
    private container movementCaseStatusToFrom()
    {
        return [StatusIssue::OnOrder, StatusIssue::Picked];
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQueryForReduceQuantityErrorMessages</Name>
				<Source><![CDATA[
    protected Query buildQueryForReduceQuantityErrorMessages()
    {
        return movement.buildQueryInventTransTransChild();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDepreciateReceipt</Name>
				<Source><![CDATA[
    protected  void updateDepreciateReceipt()
    {
        #define.CounterpartsCheck(0)   // if we have movement we check counterpart transactions first two loops
        #define.NoCounterpartsCheck(2) // last two loops we do not check counterparts transactions
        #define.MaxLoopCount(4)        // the loop is executed 4 times at most

        boolean                 selectMarkedTrans;
        InventQty               qtyToDelete = -estimated; //  keeps absolute value of quantity to be deleted
        PdsCWInventQty          cwQtyToDelete = -cwEstimated;
        Integer                 loopDepreciateMovmentCount = 2;

        if (! movement.inventTransOriginId())
        {
            movement.logUnexpectedLotIdNotSpecified(funcName());
            throw error("@SYS17272");
        }

        using (var cache = movement.constructRecordViewCache())
        {
            InventMovement movementIssue = movement.newMovement_TransferIssue();

            InventMovement depreciateMovment = movement;

            while (loopDepreciateMovmentCount)
            {
                Integer loopCount = (movementIssue ? #CounterpartsCheck : #NoCounterpartsCheck);

                for (selectMarkedTrans = false; loopCount < #MaxLoopCount; ++loopCount) // first select unmarked transactions
                {
                    // try to delete extra quantity from transactions selected on this step
                    [qtyToDelete, cwQtyToDelete] = this.updateDepreciateTransactions(
                    InventTransRepository::construct().getTransactionsForDepreciation(
                        InventDirection::Receipt,
                            depreciateMovment,
                        inventDimCriteria,
                        inventDimParm,
                        selectMarkedTrans),
                    qtyToDelete,
                    (loopCount < #NoCounterpartsCheck) ? movementIssue : null,
                    cwQtyToDelete);

                    if (qtyToDelete == 0)
                    {
                        // quantity has been already reduced as required
                        break;
                    }

                    selectMarkedTrans = !selectMarkedTrans;
                }
                depreciateMovment = movement.parentDepreciateMovement();
                if (depreciateMovment == movement)
                {
                    break;
                }

                loopDepreciateMovmentCount--;
            }

            if (qtyToDelete != 0)
            {
                this.displayWrongReduceQuantityMessage();

                error(strFmt("@SCM:DepreciateReceiptErrorMessage", movement.itemId(), movement.transId()));
                throw error(strFmt("@SYS56628",StatusReceipt::Purchased,StatusReceipt::Received,StatusReceipt::Registered));
            }

            if (!InventTransOrigin::transactionsExist(movement.inventTransOriginId()))
            {
                this.deleteInventTransOriginAndReferences();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateDepreciateTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the deprecated transactions.
    /// </summary>
    /// <param name="_inventTransEnumerable">
    ///    The transactions to be updated.
    /// </param>
    /// <param name="_qtyToDelete">
    ///    The amount to depreciate.
    /// </param>
    /// <param name="_counterpartMovement">
    ///    The transfer counterpart movement.
    /// </param>
    /// <param name="_cwQtyToDelete">
    ///    The catch weight amount to depreciate.
    /// </param>
    /// <returns>
    ///    A container with the rest of quantity to depreciate after the execution of the method.
    /// </returns>
    /// <remarks>
    ///    When an amount is depreciated, it is always represented as a positive value.The method deletes the
    ///    transactions or reduces the quantity of the transaction to the required quantity.
    /// </remarks>
    protected container updateDepreciateTransactions(
        InventTransEnumerable   _inventTransEnumerable,
        InventQty               _qtyToDelete,
        InventMovement          _counterpartMovement,
        PdsCWInventQty          _cwQtyToDelete)
    {
        InventQty               qtyToDelete     = _qtyToDelete;
        PdsCWInventQty          cwQtyToDelete   = _cwQtyToDelete;
        InventTrans             inventTransSamepart;
        InventTrans             inventTransCounterpart;
        InventDim               inventDimJoinCounterpart;
        InventDim               inventDimJoinSamepart;
        InventMovement          movementRefCounterpart;
        InventDimParm           inventDimParmRefCounterpart;
        PmfQtyDataCarrier       outQuantities = new PmfQtyDataCarrier();
        InventDimParm           inventDimParmAll;
        InventDimParm           inventDimParmMatchTransferTrans;

        //initialize outside of loop since it is constant
        inventDimParmAll.setAllInventDim();

        //we need to look for matching transactions so we need the current movement to tell us what dimensions to include in the search
        if (_counterpartMovement)
        {
            inventDimParmMatchTransferTrans = movement.inventDimParmMatchTransferTrans();
        }

        InventTransEnumerator inventTransEnumerator = _inventTransEnumerable.getEnumerator() as InventTransEnumerator;

        while (inventTransEnumerator.moveNext())
        {
            InventTrans inventTrans = inventTransEnumerator.current();

            InventQty qtyCanBeDeleted = abs(inventTrans.Qty);
            PdsCWInventQty cwQtyCanBeDeleted = abs(inventTrans.PdsCWQty);

            //we must check the related transfer quantities
            if (_counterpartMovement)
            {
                InventDim inventDimTrans = InventDim::find(inventTrans.InventDimId);
                boolean origLicensePlateFlag = inventDimParmMatchTransferTrans.LicensePlateFlag;
                // Clear license plate flag when using license plate tracking is disabled in location profile.
                if (InventTransferSyncDimensionsConsiderCatchWeightQtyToggle::instance().isEnabled() &&
                    inventDimParmMatchTransferTrans.LicensePlateFlag &&
                    inventDimTrans.wMSLocationId && 
                    movement.isItemWHSEnabled())
                {
                    WMSLocation wmsLocation = inventDimTrans.wmsLocation();
                    if (!wmsLocation.LocProfileId || 
                        !wmsLocation.whsLocationIsLPControlled())
                    {
                        inventDimParmMatchTransferTrans.LicensePlateFlag = NoYes::No;
                    }
                }

                select sum(Qty), sum(PdsCWQty)
                    from inventTransCounterpart
                         where inventTransCounterpart.InventTransOrigin == _counterpartMovement.inventTransOriginId()
                         &&    ((inventTrans.StatusIssue   == StatusIssue::None   && inventTransCounterpart.StatusIssue   > StatusIssue::None)
                         ||    (inventTrans.StatusReceipt == StatusReceipt::None && inventTransCounterpart.StatusReceipt > StatusReceipt::None))
                     #inventDimExistsJoin(inventTransCounterpart.InventDimId,inventDimJoinCounterpart,inventDimTrans,inventDimParmMatchTransferTrans);
                
                // Reset license plate flag back
                inventDimParmMatchTransferTrans.LicensePlateFlag = origLicensePlateFlag;
                
                if (inventTransCounterpart.Qty != 0)
                {
                    select sum(Qty), sum(PdsCWQty)
                           from inventTransSamepart
                                where inventTransSamepart.InventTransOrigin == inventTrans.InventTransOrigin
                                &&    ((inventTrans.StatusIssue   > StatusIssue::None   && inventTransSamepart.StatusIssue   > StatusIssue::None)
                                ||    (inventTrans.StatusReceipt > StatusReceipt::None && inventTransSamepart.StatusReceipt > StatusReceipt::None))
                            #inventDimExistsJoin(inventTransSamepart.InventDimId,inventDimJoinSamepart,inventDimTrans,inventDimParmMatchTransferTrans);

                    // we can delete up to difference between issues and receipts, but not more then on the transaction itself
                    qtyCanBeDeleted = min(qtyCanBeDeleted, max(abs(inventTransSamepart.Qty) - abs(inventTransCounterpart.Qty), 0));
                    cwQtyCanBeDeleted = min(cwQtyCanBeDeleted, max(abs(inventTransSamepart.PdsCWQty) - abs(inventTransCounterpart.PdsCWQty), 0));
                }
            }

            if (qtyCanBeDeleted > 0 || cwQtyCanBeDeleted > 0)
            {
                if (cwQtyToDelete)
                {
                    InventQty requestedSplitQuantity = (cwQtyCanBeDeleted < cwQtyToDelete) ? qtyCanBeDeleted : qtyToDelete;

                    qtyCanBeDeleted = PdsCatchWeight::adjustSplitInventQty(
                        inventTrans.ItemId,
                        cwQtyCanBeDeleted,
                        qtyCanBeDeleted,
                        min(cwQtyCanBeDeleted, cwQtyToDelete),
                        requestedSplitQuantity);

                    // Check if there is anything allowed to delete after adjusting quantity for CW constraints.
                    if (qtyCanBeDeleted <= 0)
                    {
                        // Skip current transaction and go back to the beginning of the while block.
                        continue;
                    }

                    InventQty adjustmentQuantity = qtyCanBeDeleted - requestedSplitQuantity;

                    if (adjustmentQuantity)
                    { 
                        Integer qtyAdjustmentSign = InterCompanySynchronizeCloseLineDeliveryRemainderFromSalesToPurchaseSingleton::instance().pdsCalcSignOnInventQtyAdjustmentInDepreciateTrans(movement);
                        movement.pdsAdjustInventoryQuantity(adjustmentQuantity * qtyAdjustmentSign);
                    }
                    qtyToDelete += adjustmentQuantity;
                }
                else
                {
                    qtyCanBeDeleted = min(qtyCanBeDeleted, qtyToDelete);
                }
                cwQtyCanBeDeleted = min(cwQtyCanBeDeleted, cwQtyToDelete);

                // the adjustment may have already split the transaction
                if ((qtyCanBeDeleted == 0.0) && movement.pdsCWItem())
                {
                    // loop out here if there is nothing to reduce or allowed to be reduced
                    break;
                }

                if (abs(inventTrans.Qty) > qtyCanBeDeleted || abs(inventTrans.PdsCWQty) > cwQtyCanBeDeleted)
                {
                    if (inventTrans.StatusIssue > StatusIssue::None)
                    {
                        inventTrans.updateSplit(-qtyCanBeDeleted, -cwQtyCanBeDeleted);
                    }
                    else
                    {
                        inventTrans.updateSplit(qtyCanBeDeleted, cwQtyCanBeDeleted);
                    }
                }

                // check physical on hand for depreciate receipt transactions
                if (inventTrans.StatusReceipt == StatusReceipt::Ordered)
                {
                    InventOnHandQty inventOnHandQty = InventOnHandQty::newPhysicalInvent(movement, inventTrans.inventDim());
                    inventOnHandQty.addDepreciateOrderedCheck(allowNegativePhysical);
                }

                inventTrans.delete(NoYes::No, NoYes::No); // do not delete the origin

                qtyToDelete     -= abs(inventTrans.Qty);
                updEstimated    -= inventTrans.Qty;

                cwQtyToDelete   -= abs(inventTrans.PdsCWQty);
                cwUpdEstimated  -= inventTrans.PdsCWQty;

                movement.transIdSum().setInventTransStatus(inventTrans,0,0);

                //if the transaction was marked we need to remove marking on related transactions
                if (inventTrans.MarkingRefInventTransOrigin)
                {
                    movement.validateCanDepreciateMarkedTransactionUpdate(inventTrans);

                    this.setVirtuelProjReferenceTransOriginId(inventTrans.MarkingRefInventTransOrigin);

                    InventTrans inventTransRefCounterpart = InventTrans::findByInventTransOrigin(inventTrans.MarkingRefInventTransOrigin);

                    if (inventTransRefCounterpart)
                    {
                        movementRefCounterpart = inventTransRefCounterpart.inventMovement(true);

                        if (movementRefCounterpart)
                        {
                            //if true reference fields should be cleared
                            boolean clearItemReference = (transEstimated == 0
                                                          && movement.remainFinancial() == 0
                                                          && movementRefCounterpart.transIdSum().physicalInvent() == 0);

                            //first try and delete marking for dimensions that match exactly for the merged dimensions of the _inventtrans
                            InventDim inventDimRefCounterpart;
                            InventDimId selectedQualityOrderInventDimId = InventBlockingRelatedTransactionInfoSingleton::instance().getSelectedQualityOrderInventDimId();
                            if (selectedQualityOrderInventDimId && movement.transType() == InventTransType::Blocking)
                            {
                                inventDimRefCounterpart = movementRefCounterpart.inventDimMerged(InventDim::find(selectedQualityOrderInventDimId));
                            }
                            else
                            {
                                inventDimRefCounterpart = movementRefCounterpart.inventDimMerged(InventDim::find(inventTrans.InventDimId));
                            } 

                            InventQty qtyMarkedDeleted;
                            using (var context = new WHSInventUpdRemoveReservePhysicalForCWContext())
                            {
                                context.removeReservationOnReservePhysicalTrans = movementRefCounterpart.whsShouldRemoveReservationOnReservePhysicalTransIssue()
                                                                                        && movement.whsShouldRemoveReservationOnReservePhysicalTransReceipt()
                                                                                        && movementRefCounterpart.isItemWHSEnabled()
                                                                                        && movementRefCounterpart.pdsCWItem()
                                                                                        && inventTransRefCounterpart.StatusIssue == StatusIssue::ReservPhysical;

                                qtyMarkedDeleted = InventTransOrigin::deleteMarking(inventTrans.MarkingRefInventTransOrigin,
                                                                                          inventTrans.InventTransOrigin,
                                                                                          -inventTrans.Qty, //quantity to try to un-mark
                                                                                          clearItemReference,
                                                                                          inventDimRefCounterpart,
                                                                                          inventDimParmAll
                                                                                          , false
                                                                                          , false
                                                                                          , -inventTrans.PdsCWQty //CW quantity to try to un-mark
                                                                                          , outQuantities
                                                                                          );
                            }

                            PdsCWInventQty cwQtyMarkedDeleted = outQuantities.parmCwQty();

                            //if we did not delete marking for as much as we asked for on the exact dimensions, we try and delete marking for the rest on a less strict dimensions
                            if (qtyMarkedDeleted != inventTrans.Qty || cwQtyMarkedDeleted != inventTrans.PdsCWQty)
                            {
                                inventDimParmRefCounterpart.clear();
                                inventDimParmRefCounterpart.initFromInventDim(inventDimRefCounterpart, movement.inventDimGroupSetup().activeFinancialInventoryFields());

                                InventTransOrigin::deleteMarking(inventTrans.MarkingRefInventTransOrigin,
                                                                 inventTrans.InventTransOrigin,
                                                                 -(inventTrans.Qty - qtyMarkedDeleted), //the remainder of what should be marked and what was marked with the previous call
                                                                 clearItemReference,
                                                                 inventDimRefCounterpart,
                                                                 inventDimParmRefCounterpart,
                                                                 false,
                                                                 false,
                                                                 -(inventTrans.PdsCWQty - cwQtyMarkedDeleted)//the remainder of what should be marked and what was marked with the previous call
                                                                 );
                            }
                        }
                        else
                        {
                            InventTransOrigin::deleteMarking(inventTrans.MarkingRefInventTransOrigin,
                                                            inventTrans.InventTransOrigin,
                                                            -inventTrans.Qty, //quantity to try to un-mark
                                                            (transEstimated == 0 && movement.remainFinancial() == 0 ? true : false), //if true reference fields should be cleared
                                                            inventDimCriteria,
                                                            inventDimParm,
                                                            false,
                                                            false,
                                                            -inventTrans.PdsCWQty //CW quantity to try to un-mark
                                                            );
                        }
                    }

                    if (!movement.transIdSum().receipt() && !movement.transIdSum().issue())
                    {
                        if (movement.interCompanyMarkingAllowed())
                        {
                            // clear reference fields.
                            movement.clearInventRefFields();
                        }
                    }

                    // Update reservation on the issue
                    if (inventTrans.StatusReceipt > StatusReceipt::None && movementRefCounterpart && movementRefCounterpart)
                    {
                        InventUpd_Estimated estimatedRefIssue = InventUpd_Estimated::newInventMovement(movementRefCounterpart);
                        if (estimatedRefIssue)
                        {
                            estimatedRefIssue.updateReservation();
                        }
                    }
                }
                if (!movement.pdsCWItem() ? (qtyToDelete == 0) : (cwQtyToDelete == 0))
                {
                    break;
                }
            }
        }

        return [qtyToDelete, cwQtyToDelete];
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateFieldsOnChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the field changes must be updated.
    /// </summary>
    /// <returns>true if the changes must be updated; otherwise, false.</returns>
    protected boolean mustUpdateFieldsOnChange()
    {
        return (!this.parmSkipUpdateDimensionFieldChange()
                && (movement.inventDimId() != movement_Orig.inventDimId() || movement.mustUpdateInventTransFields(movement_Orig)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateFieldsChange</Name>
				<Source><![CDATA[
    protected void updateFieldsChange()
    {
        if (!movement_Orig)
        {
            return;
        }

        if (movement.mustUpdateInventTransOriginFields(movement_Orig))
        {
            this.updateInventTransOriginFromMovement(movement.inventTransOriginId(), movement_Orig);
        }

        if (this.mustUpdateFieldsOnChange())
        {
            using (var cache = movement.constructRecordViewCache())
            {
                if (movement.assetId() != movement_Orig.assetId())
                {
                    AssetInventTrans::changeAssetId(
                        movement.inventTransOriginId(),
                        movement_Orig.assetId(),
                        movement.assetId(),
                        movement.assetBookId());
                }

                if (movement.isItemWHSEnabled())
                {
                    WHSParameters::validateLicensePlateTracking(movement.inventdim().inventDimId);
                }

                RecordLinkList rllInventTrans = new RecordLinkList();

                // If this query is changed then the query in the inventMovement.canChangeConsistentDim method
                //   should also be changed
                InventTrans inventTrans;
                while select forupdate inventTrans
                    where inventTrans.InventTransOrigin == movement.inventTransOriginId()
                       &&
                         (inventTrans.StatusReceipt     == StatusReceipt::Ordered
                       || inventTrans.StatusReceipt     == StatusReceipt::QuotationReceipt
                       || inventTrans.StatusIssue       == StatusIssue::OnOrder
                       || inventTrans.StatusIssue       == StatusIssue::ReservPhysical
                       || inventTrans.StatusIssue       == StatusIssue::ReservOrdered
                       || inventTrans.StatusIssue       == StatusIssue::QuotationIssue)
                {
                    rllInventTrans.ins(inventTrans);
                }

                boolean shouldFillLicensePlateForTransferReceipt = movement is InventMov_TransferTo && movement.isItemWHSEnabled();

                //  If transactions are split in the loop we will have new transaction matching
                //  the above selection criteria.
                //  Because we are using RecordViewCache we will read these newly inserted transaction,
                //  so to avoid an uncontrolled loop a list is used.
                while (rllInventTrans.next(inventTrans))
                {
                    if (this.mustUpdateInventoryTransactionDimension(inventTrans))
                    {
                        var origMarking = inventTrans.MarkingRefInventTransOrigin;

                        movement.initInventTransFromBuffer(inventTrans,movement_Orig);

                        if (inventTrans.TransChildType != InventTransChildType::None
                            && inventTrans.DateExpected != inventTrans.orig().DateExpected)
                        {
                            InventTransChildReference::newFromInventTrans(inventTrans).updateReferenceExpectedDate();
                        }

                        if (movement is InventMov_Sales && inventTrans.MarkingRefInventTransOrigin != origMarking)
                        {
                            this.updateInventTransMarking(inventTrans, movement, inventTrans.Qty, inventTrans.PdsCWQty);
                        }

                        InventDim fromInventDim = InventDim::find(inventTrans.InventDimId);
                        InventDim toInventDim;
                        toInventDim.data(fromInventDim);

                        if (this.mustMergeUsedDim(inventTrans))
                        {
                            toInventDim.mergeUsedDim(
                                movement.inventDimGroupSetup(),
                                movement.inventdim(),
                                movement_Orig.inventdim());

                            toInventDim = InventDim::findOrCreate(toInventDim);

                            if (shouldFillLicensePlateForTransferReceipt)
                            {
                                toInventDim = WhsInvent::fillLicensePlateForTransferReceipt(toInventDim, movement.inventTable());
                            }
                        }

                        if (inventTrans.StatusReceipt == StatusReceipt::Ordered
                            && movement.returnInventTransOrigin()!= movement_Orig.returnInventTransOrigin())
                        {
                            inventTrans.ReturnInventTransOrigin = movement.returnInventTransOrigin();
                        }

                        if (inventTrans.Qty > 0)
                        {
                            this.updateTransDimReceipt(
                                                inventTrans,
                                                fromInventDim,
                                                toInventDim,
                                                inventTrans.Qty,
                                                true,
                                                false,
                                                inventTrans.PdsCWQty);
                        }
                        else
                        {
                            this.updateTransDimIssue(
                                                inventTrans,
                                                fromInventDim,
                                                toInventDim,
                                                inventTrans.Qty,
                                                true,
                                                inventTrans.PdsCWQty);
                        }
                    }
                }

                if (this.whsMustUpdateOrderCommittedReservation())
                {
                    this.whsUpdateOrderCommittedReservation();
                }

                // Report about quantity which the system cannot reserve, in case the dimension has been changed on the movement.
                // If reserve again is skipped due to item is catch weight and warehouse enabled, delay the warning message until later reservation is done.
                if (movement.parmReleasedReservationQty() != 0 && !skipReserveAgainstAvailableOnhandForCWItem)
                {
                    checkFailed(strFmt("@SYS311930", movement.parmReleasedReservationQty()));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustMergeUsedDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the inventory dimensions must be merged.
    /// </summary>
    /// <param name = "_inventTrans">The relevant inventory transaction.</param>
    /// <returns>true if the inventory dimensions must be merged; otherwise, false.</returns>
    protected boolean mustMergeUsedDim(InventTrans _inventTrans)
    {
        return (_inventTrans.TransChildType     == movement.transChildType()
                && _inventTrans.TransChildRefId == movement.transChildRefId()
                && _inventTrans.InventDimId     != movement.inventDimId()
                && movement.inventDimId()       != movement_Orig.inventDimId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInventTransOriginFromMovement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the inventory transaction originator based on the movement.
    /// </summary>
    /// <param name="_inventTransOriginId">
    ///    The ID of inventory transaction originator to update.
    /// </param>
    /// <param name="_movement">
    ///    The movement class that contains recent data.
    /// </param>
    protected void updateInventTransOriginFromMovement(
        InventTransOriginId     _inventTransOriginId,
        InventMovement          _movement)
    {
        if (!_movement)
        {
            throw error("@SYS18738");
        }

        InventTransOrigin inventTransOrigin = InventTransOrigin::find(_inventTransOriginId, true);

        if (!inventTransOrigin)
        {
            throw error("@SYS18738");
        }

        InventDim itemInventDim = movement.inventdim().data();
        itemInventDim.clearNotProductDim(movement.inventDimGroupSetup());

        inventTransOrigin.Party             =   movement.dirParty();
        inventTransOrigin.ItemInventDimId   =   InventDim::findOrCreate(itemInventDim).InventDimId;

        inventTransOrigin.doUpdate();
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructAndInitializeDeleteMovement</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>InventUpd_DeleteMovement</c>
    /// </summary>
    /// <returns>A <c>InventUpd_DeleteMovement</c> instance.</returns>
    protected InventUpd_DeleteMovement constructAndInitializeDeleteMovement()
    {
        InventUpd_DeleteMovement deleteMovement = InventUpd_DeleteMovement::newMovement(movement);
        deleteMovement.parmOriginReferenceRemains(true);

        return deleteMovement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateNow</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    public void updateNow()
    {
        using (var telemetryTask = new InventUpdateInstrumentationTask(this))
        {
			ttsbegin;

			if (! this.checkUpdateMovement())
			{
				throw error("@SYS18447");
			}

			this.updateAutoDimMovement();

			if (! this.updateTransact())
			{
				throw error("@SYS18447");
			}

            if (estimated != 0)
			{
				if (! movement.checkUpdateEstimated(this,movement_Orig))
				{
					throw error("@SYS18447");
				}

				if (preEstimated * transEstimated < 0)
				{
                    InventUpd_DeleteMovement deleteMovement = this.constructAndInitializeDeleteMovement();
					deleteMovement.updateNow();

					// <GEERU>
					if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
					{
						this.parmTransLinkCache_RU(deleteMovement.parmTransLinkCache_RU());
					}
					// </GEERU>

					updEstimated -= preEstimated;
					cwUpdEstimated -= cwPreEstimated;

					// If the pre-estimated value was positive (receipt), blocking reservations will have already been removed.
					if (preEstimated > 0)
					{
						estimatedBlockQty = 0;
                        estimatedBlockCWQty = 0;
					}
					// If the pre-estimated value was negative (issue), we need to reduce the estimated blocking quantity by this amount.
					else
					{
						estimatedBlockQty += preEstimated;
                        estimatedBlockCWQty += cwPreEstimated;
					}

					this.createEstimatedInventTrans(transEstimated, cwTransEstimated);
				}

				else if (preEstimated > 0 && estimated < 0)
				{
					this.updateDepreciateReceipt();
				}
				else if (preEstimated < 0 && estimated > 0)
				{
					this.updateDepreciateIssue();
					if (movement.isItemWHSEnabled())
					{
						movement.checkWHSLoadLineInventTransConsistency(true);
					}
				}
				else if (estimated)
				{
					this.createEstimatedInventTrans(estimated, cwEstimated);
				}

                if (estimatedBlockQty != 0 && movement.canPerformInventBlockingInventStatusSyncPostSyncDuringEstimation())
				{
                    InventBlockingInventStatusSync::newStandardHandlingQuantities(movement, estimatedBlockQty, estimatedBlockCWQty).postSync();
				}
			}
			else if (cwEstimated != 0)
			{
				InventUpd_Estimated::pdsCWQtyModified(movement);
			}

            this.updateCostCommitments();

			if (movement.mustDoAutoLossProfitEstimate() && !movement.parmMustDoAutoLossProfitForbid())
			{
				movement.updateAutoEstimate(this);
			}
			ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostCommitments</Name>
				<Source><![CDATA[
    internal void updateCostCommitments()
    {
        if (movement.mustBeCostControlled() && movement.canCommittedCostBeReversed())
        {
            CostControlPostingItem costControlPostingItem = CostControlPosting::newCostControlPostingItem(movement);
            costControlPostingItem.parmMovementOrig(movement_Orig);
            costControlPostingItem.run(ProjCommittedCostUpdateAction::Unknown);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateOwnerRelationship</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates or creates the relationship between the inventory transactions originator and the owner.
    /// </summary>
    public void updateOwnerRelationship()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReservation</Name>
				<Source><![CDATA[
    public void updateReservation()
    {
        InventUpd_Reservation   reservation;
        InventQty               reservQty;
        PdsCWInventQty          cwReservQty = 0;

        if (movement.canBeReserved() && movement.mustBeAutoReserved())
        {
            if (! movement.updateReqExplodeReservation())
            {
                if (movement_Orig)
                {
                    if (allowReserveReversed && (movement_Orig.transDate() != movement.transDate() || preEstimated * estimated < 0))
                    {
                        reservation =
                            InventUpd_Reservation::newParameters(
                                    movement,
                                    inventDimCriteria,
                                    inventDimParm,
                                    0,
                                    -movement.transIdSum().reserved(),
                                    true,
                                    false,
                                    -movement.transIdSum().pdsCWReserved());

                        reservation.parmPdsCWForceActual(this.parmCWForceActualsReservationUpdate());
                        reservation.parmReservationParameters(this.parmReservationParameters());
                        reservation.updateNow();
                    }
                }

                [reservQty, cwReservQty] = this.getReservQtyAndCWReservQty();

                if ((!movement.pdsCWItem() ? reservQty : cwReservQty) && movement.mustReserveBasedOnMarkingOnUpdate())
                {
                    InventUpd_Reservation::updateReserveRefTransId(movement);
                    [reservQty, cwReservQty] = this.getReservQtyAndCWReservQty(true);
                }

                if (!movement.pdsCWItem() ? reservQty : cwReservQty)
                {                   
                    reservation = InventUpd_Reservation::newMovement(
                                                            movement,
                                                            reservQty,
                                                            true,
                                                            false,
                                                            false,
                                                            cwReservQty);
                    // <GEEPL>
                    if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
                    {
                        this.initCorrectionReference_PL(reservation);
                    }
                    // </GEEPL>

                    reservation.parmPdsCWForceActual(this.parmCWForceActualsReservationUpdate());
                    reservation.parmReservationParameters(this.parmReservationParameters());
                    reservation.updateNow();
                }
            }
        }

        if (skipReserveAgainstAvailableOnhandForCWItem && movement.parmReleasedReservationQty() != 0)
        {
            InventQty onOrderQuantity = movement.transIdSum().onOrder();
            if (onOrderQuantity != 0)
            {
                checkFailed(strFmt("@SYS311930", -onOrderQuantity));
            }
            skipReserveAgainstAvailableOnhandForCWItem = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReservQtyAndCWReservQty</Name>
				<Source><![CDATA[
    private container getReservQtyAndCWReservQty(boolean _reRead = false)
    {
        InventQty reservQty = movement.reserveQty() - movement.transIdSum(_reRead).reserved();
        PdsCWInventQty cwReservQty = 0;

        if (movement.pdsCWItem())
        {
            if (!movement.isItemWHSEnabled())
            {
                cwReservQty = movement.pdsCWReserveQty() - movement.transIdSum(_reRead).pdsCWReserved();
            }
            else
            {
                // Check to see if we need to reserve any qty.
                if (movement.pdsCWReserveQty())
                {
                    // The quantity we need to reserve in addition should be equal to on order transactions.
                    cwReservQty = movement.transIdSum(_reRead).pdsCWOnOrder();
                }
            }

            // if autoreservation is on and multiple transactions are on Order,
            // reservation may overreserve

            if (cwReservQty && !PdsCatchWeightItem::pdsCWIsValidQty(movement.itemId(), reservQty, cwReservQty))
            {
                // allow expanding the reservation quantity
                reservQty = PdsCatchWeight::minInventQty(movement.itemId(), cwReservQty);
            }
        }

        return [reservQty, cwReservQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransact</Name>
				<Source><![CDATA[
    protected  boolean updateTransact()
    {
        if (!movement_Orig || !movement.inventTransOriginId())
        {
            return true;
        }

        if (movement.transChildType() && !movement.childBuffer().RecId)
        {
            return true;
        }

        this.updateFieldsChange();
        this.deleteInvalidMarking(); // invalid marking must be called after updating and potential splitting of inventTrans (it isn't possible to delete invalid marking in connection to update of inventDim)

        if ((movement.mustBeQuotationControlled() && !movement_Orig.mustBeQuotationControlled())    ||
            (movement.mustBeUpdatedExpected()     && !movement_Orig.mustBeUpdatedExpected()))
        {
            if (movement.remainPhysicalUnit()     != movement.transQtyUnit() ||
                movement.remainFinancialUnit()    != 0)
            {
                return checkFailed("@SYS10895");
            }

            if (movement.mustBeQuotationControlled() && !movement_Orig.mustBeQuotationControlled())
            {
                InventTrans::updateChangeToQuotation(this);
                if (movement.mustDoAutoLossProfitEstimate())
                {
                    InventTransOrigin::deleteMarking(movement.markingRefInventTransOrigin(), movement.inventTransOriginId(), -movement.transQty());
                }
            }
        }
        else
        if ((!movement.mustBeQuotationControlled() && movement_Orig.mustBeQuotationControlled()) ||
            (!movement.mustBeUpdatedExpected()     && movement_Orig.mustBeUpdatedExpected()))
        {
            if (movement.remainPhysicalUnit()      != movement.transQtyUnit() ||
                movement.remainFinancialUnit()     != 0)
            {
                return checkFailed("@SYS10895");
            }

            if (!movement.mustBeQuotationControlled() && movement_Orig.mustBeQuotationControlled())
            {
                InventTrans::updateChangeToEstimated(this);
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updEstimated</Name>
				<Source><![CDATA[
    public InventQty updEstimated()
    {
        return updEstimated;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves the specified quantities.
    /// </summary>
    /// <param name="_qtyToReserve">
    /// The quantity to reserve.
    /// </param>
    /// <param name="_cwQtyToReserve">
    /// The catch weight quantity to reserve.
    /// </param>
    /// <param name="_reserveUsingInventDimEstimated">
    /// If the values is true the inventory dimensions from the <c>InventUpd_Estimated</c> instance will be used; Otherwise, those from movement will be used.
    /// </param>
    [Hookable(false)]
    final public void reserveQuantities(
        InventQty       _qtyToReserve,
        PdsCWInventQty  _cwQtyToReserve,
        boolean         _reserveUsingInventDimEstimated)
    {
        if (WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightQuantityLogic(funcName(), movement.itemId(), _cwQtyToReserve))
        {
            WHSCatchWeightConfigurationKeyManager::instance().executingNonCatchWeightItemLogic(funcName(), movement.itemId());

            this.reserveQuantitiesFromEstimation(_qtyToReserve, 0, _reserveUsingInventDimEstimated);
        }
        else
        {
            this.reserveQuantitiesFromEstimation(_qtyToReserve, _cwQtyToReserve, _reserveUsingInventDimEstimated);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveEstimatedQuantities</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reserves the estimated quantities.
    /// </summary>
    [Hookable(false)]
    internal void reserveEstimatedQuantities()
    {
        this.reserveQuantities(estimated, cwEstimated, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reserveQuantitiesFromEstimation</Name>
				<Source><![CDATA[
    private void reserveQuantitiesFromEstimation(
        InventQty       _qtyToReserve,
        PdsCWInventQty  _cwQtyToReserve,
        boolean         _reserveUsingInventDimEstimated)
    {
        InventDimParm           inventDimParmFixed;
        InventDim               inventDimReserve;

        if (_reserveUsingInventDimEstimated)
        {
            inventDimReserve = this.parmInventDim();
        }
        else
        {
            inventDimReserve = movement.inventdim();
        }

        inventDimParm.initFromInventDim(inventDimReserve);
        inventDimParmFixed.initFromInventDim(inventDimReserve);

        InventUpd_Reservation reservation = InventUpd_Reservation::newParameters(movement,
                                                    inventDimReserve,
                                                    inventDimParm,
                                                    InventDimFixedClass::inventDimParm2InventDimFixed(inventDimParmFixed),
                                                    _qtyToReserve,
                                                    false,
                                                    false,
                                                    _cwQtyToReserve,
                                                    true);
        
        reservation.updateNow();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInventMovement</Name>
				<Source><![CDATA[
    public static InventUpd_Estimated newInventMovement(InventMovement _inventMovement)
    {
        return new InventUpd_Estimated(_inventMovement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>newPmfProdCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventUpd_Estimated</c> class.
    /// </summary>
    /// <param name="_pmfProdCoBy">
    /// A <c>PmfProdCoBy</c> record.
    /// </param>
    /// <param name="_childBuffer">
    /// A <c>Common</c> child buffer record.
    /// </param>
    /// <param name="_prodCoByType">
    /// A <c>PmfProdCoByType</c> object.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Estimated</c> class.
    /// </returns>
    public static InventUpd_Estimated newPmfProdCoBy(
        PmfProdCoBy         _pmfProdCoBy,
        Common              _childBuffer,
        PmfProdCoByType     _prodCoByType)
    {
        if (_childBuffer.TableId)
        {
            if (_childBuffer.TableId == tableNum(ProdJournalProd))
            {
                return InventUpd_Estimated::newInventMovement(
                    InventMov_Prod_JournalProd_CoBy::construct(
                        _pmfProdCoBy,
                        _childBuffer));
            }

            return InventUpd_Estimated::newInventMovement(
                    InventMovement::construct(
                        _pmfProdCoBy,
                        InventMovSubType::None,
                        _childBuffer));
        }

        return InventUpd_Estimated::newInventMovement(
            InventMov_ProdCoBy::construct(_pmfProdCoBy,_prodCoByType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProcess</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new instance of the <c>InventUpd_Estimated</c> class for a batch order.
    /// </summary>
    /// <param name="_prodTable">
    /// A <c>ProdTable</c> record.
    /// </param>
    /// <param name="_prodTableType">
    /// An instance of the <c>ProdTableType</c> class for the production order.
    /// </param>
    /// <param name="_childBuffer">
    /// The related production order child buffer; optional.
    /// </param>
    /// <returns>
    /// A new instance of the <c>InventUpd_Estimated</c> class.
    /// </returns>
    public static InventUpd_Estimated newProcess(
        ProdTable       _prodTable,
        ProdTableType   _prodTableType,
        Common          _childBuffer = null
        )
    {
        if (_childBuffer is ProdJournalProd)
        {
            return new InventUpd_Estimated(InventMov_Prod_JournalProd_Process::construct(_prodTable, _childBuffer as ProdJournalProd, _prodTableType));
        }

        return new InventUpd_Estimated(InventMov_Process::construct(_prodTable, _prodTableType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdBOM</Name>
				<Source><![CDATA[
    public static InventUpd_Estimated newProdBOM(
        ProdBOM         _prodBOM,
        Common          _childBuffer,
        ProdBOMType     _prodBOMType)
    {
        if (_childBuffer.TableId == tableNum(ProdJournalBOM))
        {
            return InventUpd_Estimated::newInventMovement(InventMov_ProdLine_JournalBOM::newFromProdTable(_prodBOM, _childBuffer as ProdJournalBOM, _prodBOMType));
        }

        return InventUpd_Estimated::newInventMovement(InventMov_ProdLine::newFromProdBOM(_prodBOM,_prodBOMType as InventType));
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdTable</Name>
				<Source><![CDATA[
    public static InventUpd_Estimated newProdTable(
        ProdTable       _prodTable,
        Common          _childBuffer,
        ProdTableType   _prodTableType)
    {
        if (_childBuffer.TableId == tableNum(ProdJournalProd))
        {
            return InventUpd_Estimated::newInventMovement(InventMov_Prod_JournalProd::newFromProdTableProdJournalProd(_prodTable, _childBuffer as ProdJournalProd, _prodTableType));
        }

        return InventUpd_Estimated::newInventMovement(InventMov_Prod::newFromProdTable(_prodTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>pdsCWQtyModified</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the catch weight quantities.
    /// </summary>
    /// <param name="_movement">
    /// An <c>InventMovement</c> object that contains the quantities to be updated.
    /// </param>
    public static void pdsCWQtyModified(InventMovement _movement)
    {
        InventQty           remain   = _movement.remainPhysical();
        PdsCWInventQty      cwRemain = _movement.pdsCWRemainPhysical();
        PdsCatchWeightItem  cwItem   = PdsCatchWeightItem::find(_movement.itemId());

        if (!cwItem.PdsCWUnitId || !cwItem.PdsCWMin || !cwItem.PdsCWMax)
        {
            throw error("@PDS1502");
        }

        if (remain == 0 && cwRemain != 0)
        {
            throw error(strFmt("@PDS629", cwRemain, _movement.itemId()));
        }

        InventUpd_Estimated estimated = new InventUpd_Estimated(_movement);
        InventQty preEstimatedQty = estimated.parmPreEstimated();
        PdsCWInventQty cwPreEstimatedQty = estimated.parmCWPreEstimated();

        if (preEstimatedQty == 0 && cwPreEstimatedQty != 0)
        {
            throw error(strFmt("@PDS629", cwPreEstimatedQty, _movement.itemId()));
        }

        estimated.parmEstimated(-preEstimatedQty);
        estimated.parmPdsCWEstimated(-cwPreEstimatedQty);
        estimated.updateNow();

        estimated = new InventUpd_Estimated(_movement);
        estimated.parmEstimated(remain);
        estimated.parmPdsCWEstimated(cwRemain);
        estimated.updateNow();

        estimated.parmCWForceActualsReservationUpdate(_movement.canForceActualCatchWeightQuantityReservation());
        estimated.updateReservation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>estimatedInventDimId</Name>
				<Source><![CDATA[
    private InventDimId estimatedInventDimId()
    {
        return useInventDimCriteriaForNewTransactions ?
                    InventDim::findOrCreate(this.parmInventDim()).inventDimId :
                    movement.inventDimId();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initCorrectionReference_PL</Name>
				<Source><![CDATA[
    private void initCorrectionReference_PL(InventUpd_Reservation _reservation)
    {
        if (movement.buffer().TableId == tablenum(SalesLine))
        {
            SalesLine salesLine = movement.buffer();
            if (salesLine.CreditNoteInternalRef_PL &&
                ! salesLine.InventTransIdReturn)
            {
                _reservation.parmRefInventTransId(SalesLine::findRecId(salesLine.CreditNoteInternalRef_PL).InventTransId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipUpdateDimensionFieldChange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>SkipUpdateDimensionFieldChange</c> parameter.
    /// </summary>
    /// <param name="_skipUpdateDimensionFieldChange">
    /// The value to set.
    /// </param>
    /// <returns>
    /// The value of the <c>SkipUpdateDimensionFieldChange</c> parameter.
    /// </returns>
    /// <remarks>
    /// When set to true, the previously estimated transactions with the same lot ID
    /// will not get updated with new dimensions.
    /// </remarks>
    public boolean parmSkipUpdateDimensionFieldChange(boolean _skipUpdateDimensionFieldChange = skipUpdateDimensionFieldChange)
    {
        skipUpdateDimensionFieldChange = _skipUpdateDimensionFieldChange;

        return skipUpdateDimensionFieldChange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUseInventDimForNewTransactions</Name>
				<Source><![CDATA[
    public boolean parmUseInventDimForNewTransactions(boolean _useInventDimCriteriaForNewTransactions = useInventDimCriteriaForNewTransactions)
    {
        useInventDimCriteriaForNewTransactions = _useInventDimCriteriaForNewTransactions;

        return useInventDimCriteriaForNewTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsMustUpdateOrderCommittedReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the order committed reservation must be updated.
    /// </summary>
    /// <returns>true if the changes must be updated; otherwise, false.</returns>
    private boolean whsMustUpdateOrderCommittedReservation()
    {
        if (movement_Orig
            && (movement.inventDimId() != movement_Orig.inventDimId() || movement.itemId() != movement_Orig.itemId())
            && movement.canUseFlexibleWarehouseLevelDimensionReservation())
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>whsUpdateOrderCommittedReservation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates the order committed reservation based on the movement.
    /// </summary>
    private void whsUpdateOrderCommittedReservation()
    {
        WHSOrderCommittedReservation orderCommittedReservation = WHSOrderCommittedReservation::findByCommittingOriginInventTransId(movement.transId(), true);

        if (orderCommittedReservation)
        {
            orderCommittedReservation.initDataFromInventMovement(movement);
            orderCommittedReservation.update();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>