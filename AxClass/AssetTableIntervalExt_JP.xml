<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>AssetTableIntervalExt_JP</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// It combines muliti <C>AssetTableInterval</C> to build a new type of <C>AssetTableInterval</C>.
/// Each inside <C>AssetTableInterval</C> is effective in an non-overlapping date range.
/// </summary>
/// <remarks>
/// When there is calendar change, the alst period before the calendar change ends up on
/// the calendar change date - 1.
/// </remarks>
class AssetTableIntervalExt_JP extends AssetTableInterval
{
    AssetDepreciationProfile            assetDepreciationProfile;

    // The inside intervals and their start working dates. It is similar to the date-effective.
    // The <Key, Value> is <Start date, Interval>
    // Note:
    // 1. Each "Start date" should be the next day of one period end in the previous inerval.
    // This is used to make sure all periods are not broken at the period end. And the "period" mentioned here is
    // not only related to the period defined in calendar, but also related to the "Period frequency"
    // defined in depreciation profile. This concept is the same as other intervals.
    // 2. When never switch to a new interval, it means a new year is started.
    Map                                 intervals;

    // Cache the info about current in used interval to improve performance, as in most cases,
    // code will continuously use interval for the same date range.
    // It should only be directly used by method getInterval and getIntervalInDateRange.
    AssetTableIntervalInDateRange_JP    curIntervalInDateRange;

    // With same set of calculation args, some of methods in this class has static return value with same parameter.
    // To aviod duplicated caclulation, use this map to cache the result for such methods.
    Map methodsResultCache;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>addResultToCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a result to cache. It is used for method result cache.
    /// </summary>
    /// <param name="_owner">
    /// The owner of the cached value.
    /// </param>
    /// <param name="_key">
    /// The key of the cache value.
    /// </param>
    /// <param name="_value">
    /// The value to cache.
    /// </param>
    /// <returns>
    /// true if success; otherwise, return false.
    /// </returns>
    private boolean addResultToCache(str _owner, container _key, anytype _value)
    {
        boolean keyExists = false;
        Map oneMethodCache;

        if (methodsResultCache.exists(_owner))
        {
            oneMethodCache = methodsResultCache.lookup(_owner);
        }
        else
        {
            oneMethodCache = new Map(Types::Container, typeOf(_value));
            methodsResultCache.insert(_owner, oneMethodCache);
        }

        return oneMethodCache.insert(_key, _value);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isResultCached</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether there is a expected result been cached.
    /// </summary>
    /// <param name="_owner">
    /// The owner of the cached value.
    /// </param>
    /// <param name="_key">
    /// The key of the cache value.
    /// </param>
    /// <returns>
    /// true if it is cached; otherwise, return false.
    /// </returns>
    private boolean isResultCached(str _owner, container _key)
    {
        boolean ret;
        Map oneMethodCache;

        if (methodsResultCache.exists(_owner))
        {
            oneMethodCache = methodsResultCache.lookup(_owner);
            if (oneMethodCache.exists(_key))
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getResultFromCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a result from method result cache.
    /// </summary>
    /// <param name="_owner">
    /// The owner of the cached value.
    /// </param>
    /// <param name="_key">
    /// The key of the cache value.
    /// </param>
    /// <returns>
    /// The value.
    /// </returns>
    private anytype getResultFromCache(str _owner, container _key)
    {
        return methodsResultCache.lookup(_owner).lookup(_key);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addIntervalForCalendar</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an new calendar to be a part of the combined calendar.
    /// </summary>
    /// <param name="_calendar">
    /// The calendar to add.
    /// </param>
    /// <param name="_startDate">
    /// The start date when the new added calendar effective.
    /// </param>
    /// <param name="_autoAdjustBrokenPeriod">
    /// A boolean value that indicates whether to adjust the start date to avoid broking the last period in previous calendar; optional.
    /// </param>
    /// <param name="_isCacheTable">
    /// If true, cache fiscal calendar tables to avoid multiple database call; optional.
    /// </param>
    public void addIntervalForCalendar(
        RefRecId        _calendar,
        AssetTransDate  _startDate,
        boolean         _autoAdjustBrokenPeriod = true,
        boolean         _isCacheTable = false)
    {
        AssetTableInterval  curIntervalLoc;
        AssetTableInterval  newIntervalLoc;
        AssetTransDate      prePeriodEnd;

        newIntervalLoc  = AssetTableInterval::construct(assetDepreciationProfile, _calendar, _isCacheTable);

        if (_autoAdjustBrokenPeriod)
        {
            curIntervalLoc  = this.getInterval(_startDate);
            prePeriodEnd    = curIntervalLoc.endPeriod(_startDate - 1);

            // Only adjust the _startDate when (_startDate - 1) is inside one period in prevoius calendar but not the period end.
            if (prePeriodEnd + 1 > _startDate)
            {
                _startDate = prePeriodEnd + 1;
            }
        }

        intervals.insert(_startDate, newIntervalLoc);
    }

]]></Source>
			</Method>
			<Method>
				<Name>assetDepreciationTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the depreciation period number in current fiscal year during the calendar interval.
    /// </summary>
    /// <param name="_assetTransDate">
    /// The transaction date.
    /// </param>
    /// <returns>
    /// Number of fiscal periods.
    /// </returns>
    public AssetDepreciationTime assetDepreciationTime(AssetTransDate _assetTransDate)
    {
        container key = [_assetTransDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        AssetDepreciationTime               ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_assetTransDate);

        ret = intervalInDateRange.interval().assetDepreciationTime(_assetTransDate);
        if (intervalInDateRange.interval().findLastDayOfYear(_assetTransDate) > intervalInDateRange.endDate())
        {
            Debug::assert(intervalInDateRange.endDate() >= _assetTransDate);

            ret = ret - (intervalInDateRange.interval().numOfPeriodsLeftInYear(intervalInDateRange.endDate()) - 1);
        }
        if (intervalInDateRange.interval().findFirstDayOfYear(_assetTransDate) < intervalInDateRange.startDate())
        {
            Debug::assert(intervalInDateRange.startDate() <= _assetTransDate);

            ret = ret - (intervalInDateRange.interval().numberOfPeriodsInYear(intervalInDateRange.startDate()) - 1);
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endDayOfServiceLife</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the end day of sevice life.
    /// </summary>
    /// <param name="_depStart">
    /// The depreciation start day.
    /// </param>
    /// <param name="_serviceLife">
    /// Service life.
    /// </param>
    /// <returns>
    /// The end day of service life.
    /// </returns>
    /// <remarks>
    /// 1. No matter _depStart is a period start date or not, the period which include _depStart
    ///    will be consider as a part of service life.
    /// 2. The expected end day of service life is always a period end date. This period must
    ///    be fully as part of service life. Otherwise, the expected end day will be the last day
    ///    of previous period.
    /// </remarks>
    public TransDate endDayOfServiceLife(TransDate _depStart, AssetServiceLife _serviceLife)
    {
        container key = [_depStart, _serviceLife];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate                           ret;
        TransDate                           curDate                 = _depStart;
        AssetServiceLife                    remainingServiceLife    = _serviceLife;
        real                                serviceLifeInCurYear;
        TransDate                           lastDayOfYear;
        int                                 indexOfPeriodInYear;

        while (remainingServiceLife > 0)
        {
            lastDayOfYear  = this.findLastDayOfYear(curDate);
            if (!lastDayOfYear)
            {
                // If the calendar is not long enough, this case will happen.
                break;
            }

            // The remaining service life is more than one year, directly run to next year.
            serviceLifeInCurYear = this.yearRatio_JP(curDate, curDate);

            // The remaining service life is not less than one year, a period in current year may be the expected end day.
            // But it is still possible that there is a calendar change at the end or this year, then the expected end day may be in next year.
            if (remainingServiceLife <= serviceLifeInCurYear)
            {
                if (remainingServiceLife == serviceLifeInCurYear)
                {
                    // The expected end day is in the last day of current year
                    ret = lastDayOfYear;
                }
                else if (remainingServiceLife < serviceLifeInCurYear)
                {
                    // The expected end day is in the middle of current year.
                    // Note, due to rounding issue, cannot use roundDown here.
                    // E.g. service life = 1, 11 months in first year (12 months), then the remainingServiceLife=0.083333333. If roundDown, the below result will be 0.
                    indexOfPeriodInYear = real2UnsignedInt(round(this.numOfPeriodsLeftInYear(curDate) * remainingServiceLife / serviceLifeInCurYear, 1));

                    while (indexOfPeriodInYear > 0)
                    {
                        indexOfPeriodInYear--;
                        ret = this.findLastDayOfMonth(curDate);
                        curDate = ret + 1;
                    }
                }
                break;
            }

            Debug::assert(serviceLifeInCurYear > 0);
            // Avoid dead loop
            if (serviceLifeInCurYear == 0)
            {
                ret = lastDayOfYear;
                break;
            }

            // Go to next year
            curDate = lastDayOfYear + 1;
            remainingServiceLife -= serviceLifeInCurYear;
            ret = lastDayOfYear;
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the end date of the period for specified date.
    /// </summary>
    /// <param name="_assetTransDate">
    /// The spcified date to find period end.
    /// </param>
    /// <returns>
    /// The end date of the period for specified date.
    /// </returns>
    public AssetTransDate endPeriod(AssetTransDate _assetTransDate)
    {
        container key = [_assetTransDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        AssetTransDate                      ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_assetTransDate);

        ret = min(intervalInDateRange.endDate(), intervalInDateRange.interval().endPeriod(_assetTransDate));

        if (ret == dateNull() && intervalInDateRange.endDate() != dateMax())
        {
            ret = intervalInDateRange.endDate();
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstDayOfMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first date of a fiscal month for a specified date.
    /// </summary>
    /// <param name="_date">
    /// The date for which to find the first date of the month.
    /// </param>
    /// <returns>
    /// The first date of the fiscal month.
    /// </returns>
    public TransDate findFirstDayOfMonth(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate                           ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = max(intervalInDateRange.startDate(), intervalInDateRange.interval().findFirstDayOfMonth(_date));

        Debug::assert(ret <= _date);

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstDayOfQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the first date of a fiscal quarter for a specified date.
    /// </summary>
    /// <param name="_date">
    /// The date for which to find the first date of the quarter.
    /// </param>
    /// <returns>
    /// The first date of the fiscal quarter.
    /// </returns>
    public TransDate findFirstDayOfQuarter(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = max(intervalInDateRange.startDate(), intervalInDateRange.interval().findFirstDayOfQuarter(_date));

        Debug::assert(ret <= _date);

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findFirstDayOfYear</Name>
				<Source><![CDATA[
    public TransDate findFirstDayOfYear(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate                           ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = max(intervalInDateRange.startDate(), intervalInDateRange.interval().findFirstDayOfYear(_date));

        Debug::assert(ret <= _date);

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastDayOfMonth</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last date of a fiscal month for a specified date.
    /// </summary>
    /// <param name="_date">
    /// The date for which to find the last date of the month.
    /// </param>
    /// <returns>
    /// The last date of the fiscal month.
    /// </returns>
    public TransDate findLastDayOfMonth(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate                           ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = intervalInDateRange.interval().findLastDayOfMonth(_date);

        if ((ret == dateNull() && intervalInDateRange.endDate() != dateMax()) || ret > intervalInDateRange.endDate())
        {
            ret = intervalInDateRange.endDate();
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastDayOfQuarter</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the last date of a fiscal quarter for a specified date.
    /// </summary>
    /// <param name="_date">
    /// The date for which to find the last date of the quarter.
    /// </param>
    /// <returns>
    /// The last date of the fiscal quarter.
    /// </returns>
    public TransDate findLastDayOfQuarter(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = intervalInDateRange.interval().findLastDayOfQuarter(_date);

        if ((ret == dateNull() && intervalInDateRange.endDate() != dateMax()) || ret > intervalInDateRange.endDate())
        {
            ret = intervalInDateRange.endDate();
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLastDayOfYear</Name>
				<Source><![CDATA[
    public TransDate findLastDayOfYear(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate                           ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = intervalInDateRange.interval().findLastDayOfYear(_date);

        if ((ret == dateNull() && intervalInDateRange.endDate() != dateMax()) || ret > intervalInDateRange.endDate())
        {
            ret = intervalInDateRange.endDate();
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBasicIntervalOnDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the standard interval on specified date which the interval is composed of.
    /// </summary>
    /// <param name="_date">
    /// The specified date.
    /// </param>
    /// <returns>
    /// An standard interval.
    /// </returns>
    public AssetTableInterval getBasicIntervalOnDate(AssetTransDate _date)
    {
        return this.getIntervalInDateRange(_date).interval();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInterval</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inside <C>AssetTableInterval</C> for sepcified date.
    /// </summary>
    /// <param name="_date">
    /// The specified date.
    /// </param>
    /// <returns>
    /// The inside <C>AssetTableInterval</C> for sepcified date.
    /// </returns>
    /// <remarks>
    /// The result will be cached.
    /// </remarks>
    protected AssetTableInterval getInterval(AssetTransDate _date)
    {
        AssetTableInterval      assetTableIntervalLoc;
        MapEnumerator           enumerator;
        AssetTransDate          curIntervalStartDate;
        AssetTransDate          curIntervalEndDate;

        // Check if the current cached interval is the result.
        if (curIntervalInDateRange)
        {
            if (_date       >= curIntervalInDateRange.startDate()
                && _date    <= curIntervalInDateRange.endDate())
            {
                assetTableIntervalLoc = curIntervalInDateRange.interval();
            }
        }

        if (assetTableIntervalLoc == null)
        {
            enumerator = intervals.getEnumerator();
            while (enumerator.moveNext())
            {
                if (enumerator.currentKey() <= _date)
                {
                    assetTableIntervalLoc   = enumerator.currentValue();

                    curIntervalStartDate    = enumerator.currentKey();
                    curIntervalEndDate      = dateMax();
                }
                else
                {
                    curIntervalEndDate      = enumerator.currentKey() - 1;

                    break;
                }
            }

            // Update the cache
            curIntervalInDateRange = AssetTableIntervalInDateRange_JP::construct(
                assetTableIntervalLoc,
                curIntervalStartDate,
                curIntervalEndDate);
        }

        return assetTableIntervalLoc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIntervalInDateRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the inside <C>AssetTableInterval</C> with date range for sepcified date.
    /// </summary>
    /// <param name="_date">
    /// The specified date.
    /// </param>
    /// <returns>
    /// An instance of <C>AssetTableIntervalInDateRange_JP</C> with <C>AssetTableInterval</C> with date range.
    /// </returns>
    protected AssetTableIntervalInDateRange_JP getIntervalInDateRange(AssetTransDate _date)
    {
        this.getInterval(_date);

        return curIntervalInDateRange;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasYearChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the two sepcified dates are not in the same year.
    /// </summary>
    /// <param name="_oldDate">
    /// The old date.
    /// </param>
    /// <param name="_newDate">
    /// The new date.
    /// </param>
    /// <returns>
    /// true if the two dates are not in the same year; otherwise, return false.
    /// </returns>
    public boolean hasYearChanged(AssetTransDate _oldDate, AssetTransDate _newDate)
    {
        container key = [_oldDate, _newDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        int                                 ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_oldDate);

        if (intervalInDateRange.startDate() > _newDate || intervalInDateRange.endDate() < _newDate)
        {
            ret = true;
        }
        else
        {
            ret = intervalInDateRange.interval().hasYearChanged(_oldDate, _newDate);
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>indexofPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the index of the period for specified date in current year.
    /// </summary>
    /// <param name="_assetTransDate">
    /// The specified date.
    /// </param>
    /// <returns>
    /// The index of the period for specified date in current year.
    /// </returns>
    public int indexofPeriod(AssetTransDate _assetTransDate)
    {
        container key = [_assetTransDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        int                                 ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_assetTransDate);

        ret = intervalInDateRange.interval().indexofPeriod(_assetTransDate);

        if (intervalInDateRange.interval().findFirstDayOfYear(_assetTransDate) < intervalInDateRange.startDate())
        {
            ret -= max(0, intervalInDateRange.interval().indexofPeriod(intervalInDateRange.startDate()) - 1);
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <C>AssetTableIntervalExt_JP</C> for specified depreciation profile.
    /// </summary>
    /// <param name="_assetDepreciationProfile">
    /// The specified depreciation profile.
    /// </param>
    protected void new(AssetDepreciationProfile _assetDepreciationProfile)
    {
        if (_assetDepreciationProfile.RecId == 0)
        {
            throw error("@SYS122751");
        }
        assetDepreciationProfile = _assetDepreciationProfile;
        assetAccrual = _assetDepreciationProfile.Accrual;

        // Init the intervals map
        intervals = new Map(Types::Date, Types::Class);

        methodsResultCache = new Map(Types::String, Types::Class);
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Finds the number of periods for a supplied date range.
    /// </summary>
    /// <param name="_fromDate">
    ///     The from date.
    /// </param>
    /// <param name="_toDate">
    ///     The to date.
    /// </param>
    /// <returns>
    ///     Number of periods for a supplied date range.
    /// </returns>
    public int numOfPeriods(TransDate _fromDate, TransDate _toDate)
    {
        container key = [_fromDate, _toDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        int ret = this.getNumberOfPeriods(_fromDate, _toDate);
        boolean isKnownAccrual = this.checkKnownAssetAccrual();

        if (!isKnownAccrual)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        this.addResultToCache(funcName(), key, ret);

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getNumberOfPeriods</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the number of periods.
    /// </summary>
    /// <param name = "_fromDate">
    /// Transaction from date.
    /// </param>
    /// <param name = "_toDate">
    /// Transaction to date.
    /// </param>
    /// <returns>
    /// The number of periods.
    /// </returns>
    protected int getNumberOfPeriods(TransDate _fromDate, TransDate _toDate)
    {
        int numberOfPeriods;

        switch (assetAccrual)
        {
            case AssetAccrual::FiscalPeriod:
            case AssetAccrual::Quarterly:
                while (_fromDate <= _toDate)
                {
                    AssetTableIntervalInDateRange_JP intervalInDateRange = this.getIntervalInDateRange(_fromDate);
                    if (intervalInDateRange.endDate() < _toDate)
                    {
                        numberOfPeriods += intervalInDateRange.interval().numOfPeriods(_fromDate, intervalInDateRange.endDate());
                        _fromDate = intervalInDateRange.endDate()+1;
                    }
                    else
                    {
                        numberOfPeriods += intervalInDateRange.interval().numOfPeriods(_fromDate, _toDate);
                        break;
                    }
                }
                break;
            case AssetAccrual::Yearly:
                while (_fromDate <= _toDate)
                {
                    _fromDate = this.findLastDayOfYear(_fromDate)+1;
                    numberOfPeriods++;
                }
                break;
            default:
                break;
        }

        return numberOfPeriods;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkKnownAssetAccrual</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the given asset accrual is a known accrual.
    /// </summary>
    /// <returns>
    /// true if the <c>AssetAccrual</c> enumeration value is of known type; otherwise, false.
    /// </returns>
    protected boolean checkKnownAssetAccrual()
    {
        boolean isKnownAccrual = true;

        switch (assetAccrual)
        {
            case AssetAccrual::FiscalPeriod:
            case AssetAccrual::Quarterly:
            case AssetAccrual::Yearly:
                break;
            default:
                isKnownAccrual = false;
        }

        return isKnownAccrual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfPeriodsLeftInYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of periods left in current year for the specified date. The period for the sepcified date is included.
    /// </summary>
    /// <param name="_date">
    /// The specified date.
    /// </param>
    /// <returns>
    /// The number of periods left in current year.
    /// </returns>
    public int numOfPeriodsLeftInYear(TransDate _date)
    {
        container key = [_date];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        int                                 ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_date);

        ret = intervalInDateRange.interval().numOfPeriodsLeftInYear(_date);
        if (intervalInDateRange.interval().findLastDayOfYear(_date) > intervalInDateRange.endDate())
        {
            Debug::assert(intervalInDateRange.endDate() >= _date);

            ret = ret - (intervalInDateRange.interval().numOfPeriodsLeftInYear(intervalInDateRange.endDate()) - 1);
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfPeriodsPerYear</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the number of periods per year.
    /// </summary>
    /// <returns>
    /// The number of periods per year.
    /// </returns>
    /// <remarks>
    /// Every year can have different number of period. Use the first inside <C>AssetTableInterval</C> to get the result.
    /// </remarks>
    public int numOfPeriodsPerYear()
    {
        container key = conNull();
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        int ret;

        // Each year/interval may have different period, just use the current interval here.
        ret = this.getInterval(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone())).numOfPeriodsPerYear();

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>numOfYearsBetweenDates</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines number of years beween from date and to date, including the periods for from date and to date
    /// </summary>
    /// <param name="_fromDate">
    /// From date
    /// </param>
    /// <param name="_toDate">
    /// To date
    /// </param>
    /// <returns>
    /// Number of years
    /// </returns>
    public real numOfYearsBetweenDates(AssetTransDate _fromDate, AssetTransDate _toDate)
    {
        container key = [_fromDate, _toDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        AssetTableIntervalInDateRange_JP    intervalInDateRange;
        AssetTransDate                      currentFromDate;
        real                                periodsInFiscalYear;
        real                                numOfYears;

        currentFromDate = _fromDate;
        while (currentFromDate <= _toDate)
        {
            intervalInDateRange = this.getIntervalInDateRange(currentFromDate);
            periodsInFiscalYear = any2int(intervalInDateRange.interval().assetDepreciationTime(currentFromDate));
            if (this.findLastDayOfYear(currentFromDate) < _toDate)
            {
                numOfYears += this.numOfPeriodsLeftInYear(currentFromDate) / periodsInFiscalYear;
                currentFromDate = this.findLastDayOfYear(currentFromDate) + 1;
            }
            else
            {
                numOfYears += (this.numOfPeriodsLeftInYear(currentFromDate) - this.numOfPeriodsLeftInYear(_toDate) + 1) / periodsInFiscalYear;
                break;
            }
        }

        this.addResultToCache(funcName(), key, numOfYears);
        return numOfYears;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startDatePeriodFwd</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Adds the given number of years to the given date.
    /// </summary>
    /// <param name="_date">
    ///     The given date.
    /// </param>
    /// <param name="_periodsToMove">
    ///     Number of periods by which the given date is moved.The unit is years.
    /// </param>
    /// <returns>
    ///     Date after adding the number of years to the given date.
    /// </returns>
    public TransDate startDatePeriodFwd(TransDate _date, int _periodsToMove)
    {
        container key = [_date, _periodsToMove];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        TransDate                           ret = _date;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(ret);
        int                                 numOfPeriodsLeftInInterval;

        while (_periodsToMove > 0)
        {
            numOfPeriodsLeftInInterval = this.numOfPeriods(ret, intervalInDateRange.endDate());
            if (intervalInDateRange.endDate() == dateMax()
                || numOfPeriodsLeftInInterval >= _periodsToMove
                || numOfPeriodsLeftInInterval == 0)
            {
                ret = intervalInDateRange.interval().startDatePeriodFwd(ret, _periodsToMove);
                break;
            }
            else
            {
                ret = intervalInDateRange.endDate()+1;
                _periodsToMove -= numOfPeriodsLeftInInterval;
                intervalInDateRange = this.getIntervalInDateRange(ret);
            }
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>startOfPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the start date of the period for specified date.
    /// </summary>
    /// <param name="_startDate">
    /// The spcified date to find period start.
    /// </param>
    /// <returns>
    /// The start date of the period for specified date.
    /// </returns>
    public AssetTransDate startOfPeriod(AssetTransDate _startDate)
    {
        container key = [_startDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        AssetTransDate                      ret;
        AssetTableIntervalInDateRange_JP    intervalInDateRange = this.getIntervalInDateRange(_startDate);

        ret = max(intervalInDateRange.startDate(), intervalInDateRange.interval().startOfPeriod(_startDate));

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>yearRatio_JP</Name>
				<Source><![CDATA[
    /// <summary>
    /// The ratio of current year (consider the calendar change and the specified start date) compare to the full year defined in calendar.
    /// </summary>
    /// <param name="_dateInYear">
    /// The data used to identify the year.
    /// </param>
    /// <param name="_startDate">
    /// The start date of current year to calculate the ratio. Optional.
    /// </param>
    /// <returns>
    /// The ratio of current year compare to the full year defined in calendar.
    /// </returns>
    public real yearRatio_JP(
        TransDate   _dateInYear,
        TransDate   _startDate = dateNull())
    {
        container key = [_dateInYear, _startDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        real                                ret = 0;
        AssetTableIntervalInDateRange_JP    intervalInDateRange;
        TransDate                           firstDayOfYear;
        TransDate                           lastDayOfYear;
        TransDate                           validFirstDayOfYear;
        TransDate                           validLastDayOfYear;
        int                                 numOfPeriodInYear;

        intervalInDateRange = this.getIntervalInDateRange(_dateInYear);
        firstDayOfYear = intervalInDateRange.interval().findFirstDayOfYear(_dateInYear);
        lastDayOfYear  = intervalInDateRange.interval().findLastDayOfYear(_dateInYear);

        if (firstDayOfYear      >= _startDate
            && firstDayOfYear   >= intervalInDateRange.startDate()
            && lastDayOfYear    <= intervalInDateRange.endDate())
        {
            // No calendar change happened in current year.
            ret = 1;
        }
        else
        {
            // Calendar change happened in current year.
            validFirstDayOfYear = max(firstDayOfYear, intervalInDateRange.startDate(), _startDate);
            validLastDayOfYear  = min(lastDayOfYear, intervalInDateRange.endDate());

            if (validFirstDayOfYear <= validLastDayOfYear)
            {
                numOfPeriodInYear   = intervalInDateRange.interval().numOfPeriods(firstDayOfYear, lastDayOfYear);
                Debug::assert(numOfPeriodInYear > 0);

                if (numOfPeriodInYear)
                {
                    ret = intervalInDateRange.interval().numOfPeriods(validFirstDayOfYear, validLastDayOfYear) / numOfPeriodInYear;
                }
            }
        }

        this.addResultToCache(funcName(), key, ret);
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>yearToPeriod</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines the number of periods in the asset service life.
    /// </summary>
    /// <param name="_assetServiceLife">
    ///    The service life of the asset.
    /// </param>
    /// <param name="_depreciationStartDate">
    ///    The depreciation start date of an asset.
    /// </param>
    /// <returns>
    ///    The Total number of periods during the service life of the asset.
    /// </returns>
    public AssetLifeTime yearToPeriod(AssetServiceLife _assetServiceLife,
                                      AssetTransDate   _depreciationStartDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()))
    {
        container key = [_assetServiceLife, _depreciationStartDate];
        if (this.isResultCached(funcName(), key))
        {
            return this.getResultFromCache(funcName(), key);
        }

        AssetLifeTime                       assetLifeTime;
        AssetTableIntervalInDateRange_JP    intervalInDateRange;
        AssetTransDate                      currentYearDate;
        real                                remainingServiceLife, totalPeriods;
        real                                periodsInFiscalYear, periodsInIntervalYear;

        currentYearDate = _depreciationStartDate;
        remainingServiceLife = _assetServiceLife;
        while (remainingServiceLife > 0)
        {
            intervalInDateRange = this.getIntervalInDateRange(currentYearDate);
            periodsInFiscalYear = any2int(intervalInDateRange.interval().assetDepreciationTime(currentYearDate));
            periodsInIntervalYear = any2int(this.assetDepreciationTime(currentYearDate));
            if (periodsInIntervalYear / periodsInFiscalYear <= remainingServiceLife)
            {
                totalPeriods += periodsInIntervalYear;
                remainingServiceLife -= periodsInIntervalYear / periodsInFiscalYear;
                if (intervalInDateRange.interval().findLastDayOfYear(currentYearDate) > intervalInDateRange.endDate())
                {
                    currentYearDate = intervalInDateRange.endDate() + 1;
                }
                else
                {
                    currentYearDate = intervalInDateRange.interval().findLastDayOfYear(currentYearDate) + 1;
                }
            }
            else
            {
                totalPeriods += remainingServiceLife * periodsInFiscalYear;
                break;
            }
        }

        assetLifeTime = real2int(round(totalPeriods, 0));

        this.addResultToCache(funcName(), key, assetLifeTime);
        return assetLifeTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructFromCalendarSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new instance of <C>AssetTableIntervalExt_JP</C> for specified depreciation profile based on
    /// the calendar schedule settings in specified source table record.
    /// </summary>
    /// <param name="_assetDepreciationProfile">
    /// The specified depreciation profile.
    /// </param>
    /// <param name="_sourceTableId">
    /// The table ID of the source.
    /// </param>
    /// <param name="_sourceRecId">
    /// The record ID of the source.
    /// </param>
    /// <param name="_isCacheTable">
    /// If true, cache fiscal calendar tables to avoid multiple database call; optional.
    /// </param>
    /// <returns>
    /// A new instance of <C>AssetTableIntervalExt_JP</C>.
    /// </returns>
    public static AssetTableIntervalExt_JP constructFromCalendarSchedule(
        AssetDepreciationProfile    _assetDepreciationProfile,
        TableId                     _sourceTableId,
        RefRecId                    _sourceRecId,
        boolean                     _isCacheTable = false)
    {
        // Cache the object per session to let it able to be reused in the same session.
        AssetTableIntervalExt_JP assetTableIntervalExt;
        str ownerId = classStr(AssetTableIntervalExt_JP);
        container key = [_assetDepreciationProfile.buf2con(), _sourceTableId, _sourceRecId];
        assetTableIntervalExt = classFactory.globalCache().get(ownerId, key, null);
        if (assetTableIntervalExt)
        {
            return assetTableIntervalExt;
        }

        AssetDepBookTableMap_JP             assetDepBookTableMap;
        AssetDepBookCalendarSchedule_JP     assetDepBookCalendarSchedule;
        boolean                             isTheFirstInterval  = true;
        AssetTransDate                      fromDate    = dateNull();
        AssetTransDate                      toDate      = dateMax();

        assetTableIntervalExt = new AssetTableIntervalExt_JP(_assetDepreciationProfile);

        if (SysDictTable::isTableMapped(tableNum(AssetDepBookTableMap_JP), _sourceTableId))
        {
            // And add a defualt interval
            assetDepBookTableMap = AssetDepBookTableMap_JP::findByRecId(
                AssetDepCalculationHelper_JP::determineAssetBookType(_sourceTableId),
                _sourceRecId);

            assetTableIntervalExt.addIntervalForCalendar(
                assetDepBookTableMap.FiscalCalendar,
                dateNull(),
                false,
                _isCacheTable);
        }

        if (_sourceTableId && _sourceRecId)
        {
            while select validtimestate(fromDate, toDate) ValidFrom, ValidTo, FiscalCalendar
                from assetDepBookCalendarSchedule
                order by ValidFrom asc
                where assetDepBookCalendarSchedule.SourceTableId    == _sourceTableId
                    && assetDepBookCalendarSchedule.SourceRecId     == _sourceRecId
            {
                assetTableIntervalExt.addIntervalForCalendar(
                    assetDepBookCalendarSchedule.FiscalCalendar,
                    assetDepBookCalendarSchedule.ValidFrom,
                    false,
                    _isCacheTable);
            }

            if (assetDepBookCalendarSchedule.ValidTo && assetDepBookCalendarSchedule.ValidTo != dateMax())
            {
                assetTableIntervalExt.addIntervalForCalendar(
                    0,
                    assetDepBookCalendarSchedule.ValidTo + 1,
                    false,
                    _isCacheTable);
            }
        }

        classFactory.globalCache().set(ownerId, key, assetTableIntervalExt);
        return assetTableIntervalExt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearOnSysGlobalCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the cache on <C>SysGlobalCache</C>
    /// </summary>
    public static void clearOnSysGlobalCache()
    {
        classFactory.globalCache().clear(classStr(AssetTableIntervalExt_JP));
    }

]]></Source>
			</Method>
			<Method>
				<Name>AssetDepBookCalendarSchedule_JP_onInsertedUpdatedDeleted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Clears the cache on <C>SysGlobalCache</C> whenever <C>AssetDepBookCalendarSchedule_JP</C> has any change.
    /// </summary>
    /// <param name="_sender">The seonder of the event.</param>
    /// <param name="_e">The event arguments.</param>
    [
        DataEventHandler(tableStr(AssetDepBookCalendarSchedule_JP), DataEventType::Deleted),
        DataEventHandler(tableStr(AssetDepBookCalendarSchedule_JP), DataEventType::Inserted),
        DataEventHandler(tableStr(AssetDepBookCalendarSchedule_JP), DataEventType::Updated)
    ]
    public static void AssetDepBookCalendarSchedule_JP_onInsertedUpdatedDeleted(Common _sender, DataEventArgs _e)
    {
        AssetTableIntervalExt_JP::clearOnSysGlobalCache();
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>