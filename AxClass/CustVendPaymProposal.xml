<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPaymProposal</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>CustVendPaymProposal</c> class represents a payment proposal by relating open transactions
/// selected for payment into grouped payment suggestions.
/// </summary>
/// <remarks>
/// You must select transactions to pay and calculation of payment days before adding a transaction to
/// the proposal.
/// </remarks>
public class CustVendPaymProposal implements SysPackable
{
    boolean includeInvoicesFromOtherCompanies;
    boolean createPaymPerInvoiceCompany;
    boolean limitPaymCreationToLedgerCompanyOnly;
    LedgerJournalACType defaultOffsetAccountType;
    LedgerJournalAC defaultOffsetAccount;
    LedgerDimensionAccount defaultOffsetLedgerDimension;
    boolean changePaymMode;
    boolean changeCompanyBankAccount;
    boolean changePaymentDistributionMode;
    boolean canUseSpecTransSetBasedInsert;
    boolean canUseCustVendPaymProposalLineSetBasedInsert;
    CustVendPaymProposalCalcPaym paymProposalCalcPaym;

    CustVendTable presetCustVendTableForPayments;
    LedgerJournalTable ledgerJournalTable;
    CustVendTransStatic custVendTransStatic;
    CustVendPaymProposalOrg paymProposalOrg;
    CustVendPaymProposalUserInteraction userInteraction;
    Map partyIdsByDirectory;
    Map paymentProposalLineMap;
    SpecTransInsertSetManager specTransInsertSetManager;
    CustVendPaymProposalLineInsertSetManager custVendPaymProposalLineInsertSetManager;
    int64 custVendPaymProposalLineTmpRecId;
    boolean isPaymentRequestsEnabled;
    boolean isGeneratedFromPaymentSchedule;
    VendRoutingSlipId_PSN PSNVendRoutingSlipId;
    CustVendAC fromCustVendAccountNum;
    CustVendAC toCustVendAccountNum;

    // <GCN>
    LedgerVoucherTypeId_CN voucherType_CN;
    // </GCN>
    // <GEERU>
    #ISOCountryRegionCodes
    // </GEERU>

    #DEFINE.CrossCompanyCacheKeyValue('SUMMARY')

    #DEFINE.CurrentVersion(4)
    #LOCALMACRO.CurrentList
        includeInvoicesFromOtherCompanies,
        createPaymPerInvoiceCompany,
        limitPaymCreationToLedgerCompanyOnly,
        defaultOffsetAccountType,
        defaultOffsetAccount,
        defaultOffsetLedgerDimension,
        changePaymMode,
        canUseSpecTransSetBasedInsert,
        canUseCustVendPaymProposalLineSetBasedInsert,
        ledgerJournalTable,
        custVendPaymProposalLineTmpRecId,
        PSNVendRoutingSlipId,
        fromCustVendAccountNum,
        toCustVendAccountNum
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>clear</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the payment proposal of transactions and payment lines.
    /// </summary>
    /// <remarks>
    /// Deletes payment proposal related records for the current
    /// LedgerJournalTable.JournalNum value.
    /// </remarks>
    public void clear()
    {
        // This method should be invoked within the company context of the ledgerJournalTable record
        Debug::assert(curext() == ledgerJournalTable.company());

        RefTableId custVendPaymProposalLineTableId = tableNum(CustVendPaymProposalLine);

        ttsbegin;
        CustVendPaymProposalLine custVendPaymProposalLine;
        TmpDataAreaRecIdFilter paymentProposalFilter;
        insert_recordset paymentProposalFilter (RefDataAreaId, RefTableId, RefRecId)
            select DataAreaId, custVendPaymProposalLineTableId, RecId from custVendPaymProposalLine
                group by DataAreaId, RecId
                where custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum;

        SpecTrans::deleteSet(paymentProposalFilter);

        // Remove all payment proposals of a specific payment journal
        // These payment proposal records will all be in the same company (single dataAreaId value)
        custVendPaymProposalLine.skipDeleteActions(true);
        custVendPaymProposalLine.skipDeleteMethod(true);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            CustVendPaymProposalLine custVendPaymProposalLine_Base;

            delete_from custVendPaymProposalLine
                exists join custVendPaymProposalLine_Base
                    where custVendPaymProposalLine.vatPaymRefRecId_RU == custVendPaymProposalLine_Base.RecId
                       && custVendPaymProposalLine_Base.JournalId == ledgerJournalTable.JournalNum;
        }

        if (isPaymentRequestsEnabled)
        {
            CFMPaymentRequestPaymentLink paymentRequestLink;

            paymentRequestLink.skipDeleteMethod(true);
            paymentRequestLink.skipDeleteActions(true);

            delete_from paymentRequestLink
                where paymentRequestLink.RefTableId == custVendPaymProposalLineTableId
                exists join custVendPaymProposalLine
                    where custVendPaymProposalLine.RecId == paymentRequestLink.RefRecId
                        && custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum;
        }

        delete_from custVendPaymProposalLine
            where custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a transaction to the payment proposal.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    The record buffer of the open transaction to pay.
    /// </param>
    /// <param name="_paymDate">
    ///    The date of payment.
    /// </param>
    /// <param name="_paymCurrency">
    ///    The currency code of the payment.
    /// </param>
    /// <param name="_paymAmountInvoiceCur">
    ///    The payment amount in the currency of the open transaction.
    /// </param>
    /// <param name="_cashDiscountToTake">
    ///    The cash discount to take amount in the currency of the open transaction; optional.
    /// </param>
    /// <remarks>
    ///    The payment proposal eventually converts the payment amount into an amount in the requested payment currency.
    /// </remarks>
    public void addCustVendTransOpen(
        CustVendTransOpen               _custVendTransOpen,
        TransDate                       _paymDate,
        CurrencyCode                    _paymCurrency,
        AmountCur                       _paymAmountInvoiceCur,
        AmountCur                       _cashDiscountToTake = 0)
    {
        CustVendPaymProposalLine    paymProposalLine;
        CustVendTransOpenData       custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);
        CustVendTrans               custVendTrans         = custVendTransOpenData.custVendTrans();
        AmountCur                   cashDiscToTake;
        DiscGraceDays               graceDays;
        CustVendCashDiscountHelper  cashDiscountHelper;

        paymProposalLine = this.buildPaymProposalLine(_custVendTransOpen,
                                                      _paymDate,
                                                      _paymCurrency);

        // if the proposal line does not have a cust/vend account assigned then the current transaction will not be included
        if (paymProposalLine.AccountNum != '')
        {
            // verify the proposal record is created in the same company as the associated Payment Journal.
            Debug::assert(paymProposalLine.company() == this.parmLedgerJournalTableCompany());

            // <GCN>
            if (LedgerParameters::isChineseVoucher_CN())
            {
                if (voucherType_CN)
                {
                    paymProposalLine.VoucherTypeId_CN = this.parmVoucherType_CN();
                }
                else
                {
                    paymProposalLine.VoucherTypeId_CN = LedgerVoucherType_CN::findDefault().Id;
                }
            }
            // </GCN>

            int hashKey = paymProposalLine.generateHashKey();
            if (paymentProposalLineMap.exists(hashKey))
            {
                paymProposalLine.RecId = paymentProposalLineMap.lookup(hashKey);

                if (canUseCustVendPaymProposalLineSetBasedInsert)
                {
                    paymProposalLine.TmpRecId = paymProposalLine.RecId;
                }
            }
            else
            {
                if (canUseCustVendPaymProposalLineSetBasedInsert)
                {
                    custVendPaymProposalLineTmpRecId++;
                    paymProposalLine.TmpRecId = custVendPaymProposalLineTmpRecId;

                    paymProposalLine = this.createProposalLine(paymProposalLine);

                    paymProposalLine.RecId = paymProposalLine.TmpRecId;
                }
                else
                {
                    paymProposalLine = this.findOrCreate(paymProposalLine);
                }

                paymentProposalLineMap.insert(hashKey, paymProposalLine.RecId);
            }

            changecompany(_custVendTransOpen.company())
            {
                if (_cashDiscountToTake != 0)
                {
                    cashDiscToTake = _cashDiscountToTake;
                }
                else
                {
                    cashDiscountHelper = CustVendCashDiscountHelper::construct(_custVendTransOpen);
                    cashDiscountHelper.parmDiscountDate(paymProposalLine.PaymDate);
                    graceDays = custVendTransOpenData.findPaymModeTable(false).DiscGraceDays;
                    cashDiscountHelper.parmGraceDays(graceDays);

                    cashDiscountHelper.parmCashDiscountTaken(
                        cashDiscountHelper.parmCashDiscountTaken() + custVendTransOpenData.findCashDiscountMarkedToBeTaken());

                    // Calculate the discount amount to take based the the payment date of the proposal
                    cashDiscToTake = cashDiscountHelper.determineCashDiscForOpenAmount();
                }
            }

            this.insertSpecTrans(custVendTrans, _custVendTransOpen, paymProposalLine, _paymAmountInvoiceCur, cashDiscToTake);

            // <GEERU>
            if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
            {
                if (custVendTrans.TableId == tableNum(VendTrans) &&
                VendTable::find(custVendTrans.AccountNum).vatTaxAgent_RU)
                {
                    this.addCustVendTransOpenVAT_RU(_custVendTransOpen, _paymDate, _paymCurrency, _paymAmountInvoiceCur, paymProposalLine.RecId);
                }

                if (isPaymentRequestsEnabled)
                {
                    this.createPaymentRequestLinkToPaymProposal(paymProposalLine, CFMPaymentRequestTable::findPaymentRequestOnCustVendTransOpen(_custVendTransOpen));
                }
            }
            // </GEERU>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCustVendPaymProposalLineTmpRecId</Name>
				<Source><![CDATA[
    public boolean parmCustVendPaymProposalLineTmpRecId(int64 _custVendPaymProposalLineTmpRecId = custVendPaymProposalLineTmpRecId)
    {
        custVendPaymProposalLineTmpRecId = _custVendPaymProposalLineTmpRecId;

        return custVendPaymProposalLineTmpRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertSpecTrans</Name>
				<Source><![CDATA[
    private void insertSpecTrans(
        CustVendTrans _custVendTrans,
        CustVendTransOpen _custVendTransOpen,
        CustVendPaymProposalLine _paymProposalLine,
        AmountCur _paymAmountInvoiceCur,
        AmountCur _cashDiscToTake)
    {
        SpecTransManager specTransManager;

        if (canUseSpecTransSetBasedInsert)
        {
            specTransInsertSetManager.insert(_paymProposalLine.DataAreaId,
                _paymProposalLine.TableId,
                _paymProposalLine.RecId,
                _custVendTransOpen.DataAreaId,
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId,
                _paymAmountInvoiceCur,
                _custVendTrans.CurrencyCode,
                NoYes::No,
                _cashDiscToTake,
                _paymProposalLine.PaymDate);
        }
        else
        {
            specTransManager = SpecTransManager::constructServer(_paymProposalLine, false);

            specTransManager.insert(
                _custVendTransOpen.company(),
                _custVendTransOpen.TableId,
                _custVendTransOpen.RecId,
                _paymAmountInvoiceCur,
                _custVendTrans.CurrencyCode,
                NoYes::No,
                _cashDiscToTake,
                _paymProposalLine.PaymDate);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addCustVendTransOpenVAT_RU</Name>
				<Source><![CDATA[
    public void addCustVendTransOpenVAT_RU(CustVendTransOpen    _custVendTransOpen,
                                           TransDate            _paymDate,
                                           CurrencyCode         _paymCurrency,
                                           AmountCur            _paymAmountInvoiceCur,
                                           RefRecId             _paymRefRecId)
    {
        CustVendPaymProposalLine     paymProposalLine;
        CustVendTransOpenData        custVendTransOpenData = CustVendTransOpenData::construct(_custVendTransOpen);
        CustVendTrans                custVendTrans         = custVendTransOpenData.custVendTrans();
        CustVendPaymModeTable        custVendPaymModeTable;
        VATTaxAgentPaymentAmounts_RU paymentAmounts;
        MapIterator                  tax;

        boolean isPosted()
        {
            if ((select firstonly RecId from custVendTransPostingLog_RU
                 where custVendTransPostingLog_RU.TaxCode        == paymProposalLine.InvoiceTaxCode_RU         &&
                       (custVendTransPostingLog_RU.TransRecId    == custVendTrans.RecId                        ||
                        custVendTransPostingLog_RU.OffSetRecId   == custVendTrans.RecId)                       &&
                       custVendTransPostingLog_RU.PostingLogType == CustVendTransPostingLogType_RU::VATTransit &&
                       custVendTransPostingLog_RU.RefTableId     == custVendTrans.TableId).RecId)
            {
                return true;
            }

            return false;
        }

        paymProposalLine = paymProposalOrg.buildPaymProposalLine(_custVendTransOpen, _paymDate, _paymCurrency);

        paymentAmounts = VATTaxAgentPaymentAmounts_RU::construct(custVendTrans);
        paymentAmounts.calc(0, 0, 0, paymProposalLine.PaymDate);

        tax = new MapIterator(paymentAmounts.mapTaxAmounts());

        ttsbegin;
        while (tax.more())
        {
            paymProposalLine.AccountNum = TaxAuthorityAddress::find(TaxPeriodHead::find(TaxTable::find(tax.key()).TaxPeriod).TaxAuthority).AccountNum;
            paymProposalLine.InvoiceTaxCode_RU = tax.key();
            if (paymProposalLine.AccountNum && conPeek(tax.value(), 2) && ! isPosted())
            {
                VendTable vendtable = VendTable::find(paymProposalLine.AccountNum);
                paymProposalLine.CurrencyCode      = CompanyInfoHelper::standardCurrency();
                paymProposalLine.ThirdPartyBankAccountID = vendtable.BankAccount;
                if (vendtable.PaymMode)
                {
                    paymProposalLine.PaymMode = vendtable.PaymMode;
                    custVendPaymModeTable = CustVendPaymModeTable::findModule(ModuleCustVend::Vend,
                                                                              vendtable.PaymMode);
                    paymProposalLine.PaymAccountType = custVendPaymModeTable.paymACType();
                    paymProposalLine.LedgerDimension = custVendPaymModeTable.offsetLedgerDimension();
                }

                paymProposalLine = this.findOrCreate(paymProposalLine);
                paymProposalLine.selectForUpdate(true);
                paymProposalLine.PaymVATAmount_RU  += conPeek(tax.value(), 2);
                paymProposalLine.vatPaymRefRecId_RU = _paymRefRecId;
                paymProposalLine.update();
            }
            tax.next();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLedgerJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds an existing ledger journal line to the payment proposal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    A <c>LedgerJournalTrans</c> record.
    /// </param>
    /// <remarks>
    ///    This method is used to reload a journal into payment proposal mode.
    /// </remarks>
    public void addLedgerJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        paymProposalOrg.addLedgerJournalTrans(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustRemoveCreditLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove credit note records.
    /// </summary>
    private void adjustRemoveCreditLines()
    {
        SpecTrans    specTrans;
        CustVendPaymProposalLine    custVendPaymProposalLine;
        if (this.custVendTransStatic().moduleCustVend() ==  ModuleCustVend::Vend)
        {
            delete_from specTrans
                exists join  custVendPaymProposalLine
                where custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum
                    && specTrans.SpecCompany == custVendPaymProposalLine.DataAreaId
                    && specTrans.SpecTableId == custVendPaymProposalLine.TableId
                    && specTrans.SpecRecId == custVendPaymProposalLine.RecId
                    && specTrans.Balance01 > 0.00;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustToMaxTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts the payment propsal to a maximum amount.
    /// </summary>
    /// <param name="_maxAmountMST">
    /// The maximum amount, in company currency, to pay out.
    /// </param>
    /// <remarks>
    /// Setting the parameter as 0 implies that there is no maximum limit for the parameter. The
    /// transactions with the least payment amounts are removed first.
    /// </remarks>
    public void adjustToMaxTotals(AmountMST _maxAmountMST)
    {
        CustVendPaymProposalLine    custVendPaymProposalLineGrouped;
        CustVendPaymProposalLine    custVendPaymProposalLine;
        CustVendTransOpen           custVendTransOpen;
        SpecTrans                   specTrans;
        boolean                     found;
        RecordSortedList            specTransList;
        AmountMST                   paymTransactionAmountMst;
        AmountCur                   paymTransactionAmountCur;
        AmountMST                   totalProposalAmountMst;
        CurrencyExchangeHelper      currencyExchangeHelper;

        // this method should be invoked in the same company context as the Ledger Journal
        Debug::assert(this.parmLedgerJournalTableCompany() == curext());

        if (_maxAmountMST > 0)
        {
            this.adjustRemoveCreditLines();
            // an upper limit on the total value of the payment proposals has been specified
            // cache the total amount of all proposed payments (unrounded value)
            totalProposalAmountMst = this.totalPaymAmountMST(false);
        }

        if (!this.maxedOut(_maxAmountMST, totalProposalAmountMst))
        {
            return;
        }

        // Keep transactions that are due first and have the smallest payment amounts.
        while select custVendPaymProposalLineGrouped
            group by JournalId, PaymDate desc
            where custVendPaymProposalLineGrouped.JournalId == ledgerJournalTable.JournalNum
        {
            specTransList = new RecordSortedList(tableNum(SpecTrans));
            specTransList.sortOrder(fieldNum(SpecTrans, Balance01), fieldNum(SpecTrans, RecId));

            while select custVendPaymProposalLine
                where custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum
                   && custVendPaymProposalLine.PaymDate == custVendPaymProposalLineGrouped.PaymDate
                join specTrans
                    where specTrans.SpecCompany == custVendPaymProposalLine.DataAreaId
                       && specTrans.SpecTableId == custVendPaymProposalLine.TableId
                       && specTrans.SpecRecId == custVendPaymProposalLine.RecId
            {
                paymTransactionAmountMst = custVendPaymProposalLine.paymTransactionAmountMST(specTrans);
                specTrans.Balance01 = -this.paymAmountToCompareAsPositive(paymTransactionAmountMst);
                specTransList.ins(specTrans);
            }

            specTrans.clear();
            found = specTransList.first(specTrans);
            while (found && this.maxedOut(_maxAmountMST, totalProposalAmountMst))
            {
                if (_maxAmountMST > 0)
                {
                    // total proposal amount is being limited, update the cache total amount of all proposed payments
                    custVendPaymProposalLine = CustVendPaymProposalLine::find(specTrans.SpecRecId);

                    // The specTransList record's Balance01 value is currently represented in the MST currency of the payment company
                    // Convert the value to the currency of the payment
                    currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(custVendPaymProposalLine.AccountNumCompany).RecId),
                        custVendPaymProposalLine.PaymDate);

                    // Note the specTrans.Balance01 value is passed to the PaymAmountCompareAsPositive method and then negated when added to the record sorted list, must undo that negation prior to use here
                    paymTransactionAmountCur = currencyExchangeHelper.calculateAccountingToTransaction(custVendPaymProposalLine.CurrencyCode,-this.paymAmountToCompareAsPositive(specTrans.Balance01), false);

                    // Convert to the MST currency of the journal company & update the total, note the use of an unrounded
                    // amount to minimize rounding effects
                    currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(this.parmLedgerJournalTableCompany()).RecId),
                        custVendPaymProposalLine.PaymDate);
                    totalProposalAmountMst -= currencyExchangeHelper.calculateTransactionToAccounting( custVendPaymProposalLine.CurrencyCode, paymTransactionAmountCur, false);
                }

                // remove the current transaction from the payment proposal
                switch (this.custVendTransStatic().moduleCustVend())
                {
                    case ModuleCustVend::Cust :
                        custVendTransOpen = specTrans.custTransOpen();
                        break;

                    case ModuleCustVend::Vend :
                        custVendTransOpen = specTrans.vendTransOpen();
                        break;
                }
                this.removeCustVendTransOpen(custVendTransOpen);

                found = specTransList.next(specTrans);
            }

            if (!this.maxedOut(_maxAmountMST, totalProposalAmountMst))
            {
                return;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildPaymProposalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Fills a payment proposal line record buffer based on an open transaction and payment parameters.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    The transaction to use as input.
    /// </param>
    /// <param name="_paymDate">
    ///    The payment date.
    /// </param>
    /// <param name="_paymCurrency">
    ///    The currency code of the payment.
    /// </param>
    /// <returns>
    ///    A <c>CustVendPaymProposalLine </c>record buffer.
    /// </returns>
    /// <remarks>
    ///    This method does not insert the CustVendPaymProposalLine record buffer into the database.
    /// </remarks>
    public CustVendPaymProposalLine buildPaymProposalLine(
        CustVendTransOpen   _custVendTransOpen,
        TransDate           _paymDate,
        CurrencyCode        _paymCurrency)
    {
        return paymProposalOrg.buildPaymProposalLine(_custVendTransOpen, _paymDate, _paymCurrency);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the payment proposal of transactions and payment lines.
    /// </summary>
    //
    // Deletes payment proposal related records for the current
    // LedgerJournalTable.JournalNum value.
    //
    public void deleteLines()
    {
        // This method should be invoked within the company context of the ledgerJournalTable record
        Debug::assert(curext() == ledgerJournalTable.company());

        CustVendPaymProposalLine::deleteByJournalId(ledgerJournalTable.JournalNum);

        this.clearPaymentProposalLineCache();
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteLinesStatic</Name>
				<Source><![CDATA[
    /// <summary>
    /// Static version of deleteLines() method that clears the payment proposal of
    /// payment lines.
    /// </summary>
    /// <param name = "_parameters">A packed list of parameters for deleting lines in a payment proposal.</param>
    /// <returns>Packed <c>CustVendPaymProposal</c> instance after delete lines has been executed.</returns>
    public static container deleteLinesStatic(container _parameters)
    {
        ClassId custVendPaymProposalClassId;
        container custVendPaymProposalPack;
        [custVendPaymProposalClassId, custVendPaymProposalPack] = _parameters;

        CustVendPaymProposal custVendPaymProposal = new SysDictClass(custVendPaymProposalClassId).makeObject();
        custVendPaymProposal.unpack(custVendPaymProposalPack);
        custVendPaymProposal.deleteLines();

        return [custVendPaymProposal.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPaymCustVendTable</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Clears the <c>CustVendTable</c> record that was used as the customer or vendor for the payment
    ///    proposals generated.
    /// </summary>
    /// <remarks>
    ///    With no preset customer or vendor record specified, the customer or vendor for which to generate a
    ///    payment proposal record will be determined dynamically. See the <c>getPaymCustVendTale</c> method.
    /// </remarks>
    public void clearPaymCustVendTable()
    {
        presetCustVendTableForPayments = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>custVendTransStatic</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the <c>CustVendTransStatic </c>object associated with the current instance of the payment
    ///    proposal.
    /// </summary>
    /// <returns>
    ///    The <c>CustVendTransStatic </c>object associated with the current instance of the payment proposal.
    /// </returns>
    public CustVendTransStatic custVendTransStatic()
    {
        return custVendTransStatic;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrCreate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the specified payment proposal line.
    /// </summary>
    /// <param name="_paymProposalLine">
    ///    A record in the <c>CustVendPaymProposalLine</c> table.
    /// </param>
    /// <returns>
    ///    A record in the <c>CustVendPaymProposalLine</c> table.
    /// </returns>
    /// <remarks>
    ///    If a payment proposal line is not found, it creates one.
    /// </remarks>
    public CustVendPaymProposalLine findOrCreate(CustVendPaymProposalLine    _paymProposalLine)
    {
        CustVendPaymProposalLine    paymProposalLine;

        paymProposalLine = this.findProposalLine(_paymProposalLine);

        if (paymProposalLine)
        {
            return paymProposalLine;
        }

        return this.createProposalLine(_paymProposalLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProposalLine</Name>
				<Source><![CDATA[
    protected CustVendPaymProposalLine findProposalLine(
        CustVendPaymProposalLine _paymProposalLine,
        boolean _forUpdate = false)
    {
        return paymProposalOrg.findProposalLine(_paymProposalLine, _forUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProposalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create payment proposal line.
    /// </summary>
    /// <param name = "_paymProposalLine">The payment proposal line.</param>
    /// <returns>The created payment proposal line.</returns>
    protected CustVendPaymProposalLine createProposalLine(CustVendPaymProposalLine _paymProposalLine)
    {
        CustVendPaymProposalLine paymProposalLine;
        #ISOCountryRegionCodes

        changecompany(this.parmLedgerJournalTableCompany())
        {
            paymProposalLine = null;

            ttsbegin;

            paymProposalLine = this.populateProposalLine(_paymProposalLine);

            if (isPaymentRequestsEnabled)
            {
                paymProposalLine.cfmPaymentRequestRecId = _paymProposalLine.cfmPaymentRequestRecId;
                paymProposalLine.cfmPrepayment = _paymProposalLine.cfmPrepayment;
                paymProposalLine.cfmTaxGroup = _paymProposalLine.cfmTaxGroup;
                paymProposalLine.cfmTaxItemGroup = _paymProposalLine.cfmTaxItemGroup;
                paymProposalLine.cfmPaymentOrderHash = _paymProposalLine.cfmPaymentOrderHash;
            }

            if (canUseCustVendPaymProposalLineSetBasedInsert)
            {
                custVendPaymProposalLineInsertSetManager.insert(paymProposalLine);
            }
            else
            {
                paymProposalLine.insert();
            }

            ttscommit;
        }

        return paymProposalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateProposalLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populate payment proposal line.
    /// </summary>
    /// <param name = "_paymProposalLine">The payment proposal line.</param>
    /// <returns>The populated payment proposal line.</returns>
    protected CustVendPaymProposalLine populateProposalLine(CustVendPaymProposalLine _paymProposalLine)
    {
        CustVendPaymProposalLine paymProposalLine;
        #ISOCountryRegionCodes

        paymProposalLine.JournalId = _paymProposalLine.JournalId;
        paymProposalLine.AccountNum = _paymProposalLine.AccountNum;
        paymProposalLine.AccountNumCompany = _paymProposalLine.AccountNumCompany;
        paymProposalLine.AccountType = _paymProposalLine.AccountType;
        paymProposalLine.PaymMode = _paymProposalLine.PaymMode;
        paymProposalLine.PaymSpec = _paymProposalLine.PaymSpec;
        paymProposalLine.PostingProfile = _paymProposalLine.PostingProfile;
        paymProposalLine.PaymId = _paymProposalLine.PaymId;
        paymProposalLine.NegInstID = _paymProposalLine.NegInstID;
        paymProposalLine.NegInstSeqNum = _paymProposalLine.NegInstSeqNum;
        paymProposalLine.NegInstStatus = _paymProposalLine.NegInstStatus;
        paymProposalLine.PaymDate = _paymProposalLine.PaymDate;
        paymProposalLine.CurrencyCode = _paymProposalLine.CurrencyCode;
        paymProposalLine.TransOpenRecId = _paymProposalLine.TransOpenRecId;
        if (_paymProposalLine.PaymAccountType == LedgerJournalACType::Ledger)
        {
            paymProposalLine.PaymAccountType = LedgerJournalACType::Ledger;
            paymProposalLine.parmLedgerDimension(_paymProposalLine.parmLedgerDimension());
        }
        else
        {
            paymProposalLine.parmPaymAccount(_paymProposalLine.parmPaymAccount(), _paymProposalLine.PaymAccountType);
        }
        paymProposalLine.ThirdPartyBankAccountID = _paymProposalLine.ThirdPartyBankAccountID;
        paymProposalLine.BankRemittanceType = _paymProposalLine.BankRemittanceType;
        paymProposalLine.CompanyBankAccountIdNegInst = _paymProposalLine.CompanyBankAccountIdNegInst;
        paymProposalLine.LedgerJournalTransRecId = _paymProposalLine.LedgerJournalTransRecId;
        paymProposalLine.Invoice = _paymProposalLine.Invoice;    // Confirming invoices

        paymProposalLine.TmpRecId = _paymProposalLine.TmpRecId;

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            paymProposalLine.InvoiceTaxCode_RU = _paymProposalLine.InvoiceTaxCode_RU;
            // note that parameter validation is on CustVendPaymProposalOrgPropose\buildPaymProposalLine() only
            paymProposalLine.DefaultDimension = _paymProposalLine.DefaultDimension;
        }
        // </GEERU>
        paymProposalLine.BankCentralBankPurposeCode = _paymProposalLine.BankCentralBankPurposeCode;
        paymProposalLine.BankCentralBankPurposeText = _paymProposalLine.BankCentralBankPurposeText;
        paymProposalLine.VendPaymentGroup = _paymProposalLine.VendPaymentGroup;
        paymProposalLine.RemittanceLocation = _paymProposalLine.RemittanceLocation;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
        {
            paymProposalLine.DefaultDimension = _paymProposalLine.DefaultDimension;
            if (!FeatureStateProvider::isFeatureEnabled(SkipOffsetLedgerDimensionInPaymenProposalFeature_NO::instance()))
            {
                paymProposalLine.OffsetLedgerDimension = _paymProposalLine.OffsetLedgerDimension;
            }
        }

        if (TaxThaiGovCertificationFeatureChecker::isTaxBranchEnabled())
        {
            paymProposalLine.DefaultDimension = _paymProposalLine.DefaultDimension;
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            paymProposalLine.epRemitOccCode_BR = _paymProposalLine.epRemitOccCode_BR;
            paymProposalLine.epBankFolder_BR = _paymProposalLine.epBankFolder_BR;
            paymProposalLine.epInstruction_1_BR = _paymProposalLine.epInstruction_1_BR;
            paymProposalLine.epInstruction_2_BR = _paymProposalLine.epInstruction_2_BR;
            paymProposalLine.epDocumentType_BR = _paymProposalLine.epDocumentType_BR;
            paymProposalLine.epPaymentType_BR = _paymProposalLine.epPaymentType_BR;
            paymProposalLine.epPaymentWay_BR = _paymProposalLine.epPaymentWay_BR;
            paymProposalLine.epTypedLine_BR = _paymProposalLine.epTypedLine_BR;
            paymProposalLine.epBarCodeInfo_BR = _paymProposalLine.epBarCodeInfo_BR;
        }
        // </GBR>

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            paymProposalLine.VoucherTypeId_CN = _paymProposalLine.VoucherTypeId_CN;
        }
        // </GCN>

        if (PublicSectorUtils::isFrenchRegulatoryEnabled())
        {
            paymProposalLine.PSNVendRoutingSlipId = _paymProposalLine.PSNVendRoutingSlipId;
        }

        return paymProposalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the default dimension that is associated to the payment proposal line.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    /// A <c>CustVendPaymProposalLine</c> record.
    /// </param>
    /// <returns>
    /// The ID of the <c>DimensionAttributeValueSet</c> record that represents the default dimension.
    /// </returns>
    public DimensionDefault getCustVendDefaultDimension(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        CustTable           custTable;
        VendTable           vendTable;
        DimensionDefault    defaultDimension;

        if (_custVendPaymProposalLine.AccountType == ModuleCustVend::Cust)
        {
            custTable = CustTable::find(_custVendPaymProposalLine.AccountNum);
            defaultDimension = custTable.DefaultDimension;
        }
        else
        {
            vendTable = VendTable::find(_custVendPaymProposalLine.AccountNum);
            defaultDimension = vendTable.DefaultDimension;
        }

        return defaultDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultOffsetAccountAndType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the default offset account information.
    /// </summary>
    /// <returns>
    ///    A <c>LedgerJournalAccountAndType</c> that contains the default offset account information if a
    ///    default offset account type was specified; otherwise, null.
    /// </returns>
    private LedgerJournalAccountAndType getDefaultOffsetAccountAndType()
    {
        LedgerJournalAccountAndType accountAndType;

        if (this.parmDefaultOffsetAccountType() == LedgerJournalACType::Ledger &&
            this.parmDefaultOffsetLedgerDimension() == 0)
        {
            // no default offset account was specified return null
            accountAndType = null;
        }
        else
        {
            accountAndType = LedgerJournalAccountAndType::newAccountAndType(this.parmDefaultOffsetAccount(), this.parmDefaultOffsetAccountType(), this.parmDefaultOffsetLedgerDimension());
        }

        return accountAndType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTable</Name>
				<Source><![CDATA[
    public LedgerJournalTable getLedgerJournalTable()
    {
        return ledgerJournalTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>init</Name>
				<Source><![CDATA[
    protected void init()
    {
        paymentProposalLineMap = new Map(Types::Integer, Types::Int64);
        specTransInsertSetManager = new SpecTransInsertSetManager();
        custVendPaymProposalLineInsertSetManager = new CustVendPaymProposalLineInsertSetManager();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearPaymentProposalLineCache</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a new payment proposal line cache.
    /// </summary>
    public void clearPaymentProposalLineCache()
    {
        paymentProposalLineMap = new Map(Types::Integer, Types::Int64);
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns the ID of the ledger journal to which the payment proposal is attached.
    /// </summary>
    /// <returns>
    ///    The ID of the ledger journal to which the payment proposal is attached.
    /// </returns>
    public LedgerJournalId ledgerJournalId()
    {
        return ledgerJournalTable.JournalNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerJournalType</Name>
				<Source><![CDATA[
    public LedgerJournalType ledgerJournalType()
    {
        return ledgerJournalTable.JournalType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxedOut</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the payment proposal exceeds the limits on the number of transactions to be paid
    ///    of the total amount to pay.
    /// </summary>
    /// <param name="_maxProposalAmountMST">
    ///    The maximum amount, in company currency, to pay out.
    /// </param>
    /// <param name="_currentProposalAmountMST">
    ///    The current total amount of all proposed payments, in company currency.
    /// </param>
    /// <returns>
    ///    true if the payment proposal number of transaction or amount is above the supplied values;
    ///    otherwise, false.
    /// </returns>
    /// <remarks>
    ///    Setting the max parameters as 0 implies that there is no maximum limit for the parameter.
    /// </remarks>
    protected boolean maxedOut(AmountMST _maxProposalAmountMST, AmountMST _currentProposalAmountMST)
    {
        boolean amountMaxedOut = _maxProposalAmountMST > 0 &&
            _maxProposalAmountMST < this.paymAmountToCompareAsPositive(_currentProposalAmountMST);

        return amountMaxedOut;
    }

]]></Source>
			</Method>
			<Method>
				<Name>moduleCustVend</Name>
				<Source><![CDATA[
    public ModuleCustVend moduleCustVend()
    {
        return custVendTransStatic.moduleCustVend();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        partyIdsByDirectory = new Map(Types::String, Types::Class);         // CompanyId, paymCompaniesByPartyId
        isPaymentRequestsEnabled = CFMParameters::isPaymentRequestsEnabled();
        this.init();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChangePaymMode</Name>
				<Source><![CDATA[
    public boolean parmChangePaymMode(boolean _changePaymMode = changePaymMode)
    {
        changePaymMode = _changePaymMode;

        return changePaymMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChangePaymentDistributionMode</Name>
				<Source><![CDATA[
    internal boolean parmChangePaymentDistributionMode(boolean _changePaymentDistributionMode = changePaymentDistributionMode)
    {
        changePaymentDistributionMode = _changePaymentDistributionMode;

        return changePaymentDistributionMode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmChangeCompanyBankAccount</Name>
				<Source><![CDATA[
    internal boolean parmChangeCompanyBankAccount(boolean _changeCompanyBankAccount = changeCompanyBankAccount)
    {
        changeCompanyBankAccount = _changeCompanyBankAccount;

        return changeCompanyBankAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanUseSpecTransSetBasedInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets a value that delays the inserts of <c>SpecTrans</c> table records.
    /// </summary>
    /// <param name = "_canUseSpecTransSetBasedInsert">
    /// A Boolean value that indicates whether to delay the inserts of <c>SpecTrans</c>; optional.
    /// </param>
    /// <returns>
    /// true if the <c>SpecTrans</c> inserts should be delayed; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If this option is enabled, then the caller is responsible to call invokeSpecTransSetBasedInsert on this
    /// class before the transaction commit.
    /// </remarks>
    public boolean parmCanUseSpecTransSetBasedInsert(boolean _canUseSpecTransSetBasedInsert = canUseSpecTransSetBasedInsert)
    {
        canUseSpecTransSetBasedInsert = _canUseSpecTransSetBasedInsert;

        return canUseSpecTransSetBasedInsert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCanUseCustVendPaymProposalLineSetBasedInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets a value that delays the inserts of <c>CustVendPaymProposalLine</c> table records.
    /// </summary>
    /// <param name = "_canUseCustVendPaymProposalLineSetBasedInsert">
    /// A Boolean value that indicates whether to delay the inserts of <c>CustVendPaymProposalLine</c>; optional.
    /// </param>
    /// <returns>
    /// true if the <c>CustVendPaymProposalLine</c> inserts should be delayed; otherwise, false.
    /// </returns>
    /// <remarks>
    /// If this option is enabled, then the caller is responsible to call invokeCustVendPaymProposalLineSetBasedInsert on this
    /// class before the transaction commit.
    /// </remarks>
    public boolean parmCanUseCustVendPaymProposalLineSetBasedInsert(boolean _canUseCustVendPaymProposalLineSetBasedInsert = canUseCustVendPaymProposalLineSetBasedInsert)
    {
        canUseCustVendPaymProposalLineSetBasedInsert = _canUseCustVendPaymProposalLineSetBasedInsert;

        return canUseCustVendPaymProposalLineSetBasedInsert;
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeSpecTransSetBasedInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts all the delayed <c>SpecTrans</c> inserts.
    /// </summary>
    /// <param name = "_journalId">
    /// The journal that indicates <c>SpecTrans.SpecRecId</c> values that need be be updated from the <c>CustVendPaymProposalLine.TmpRecId</c> rows; optional.
    /// </param>
    public void invokeSpecTransSetBasedInsert(LedgerJournalId _journalId = '')
    {
        Debug::assert(canUseSpecTransSetBasedInsert);

        specTransInsertSetManager.insertDatabase(_journalId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>invokeCustVendPaymProposalLineSetBasedInsert</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts all the delayed <c>CustVendPaymProposalLine</c> inserts.
    /// </summary>
    public void invokeCustVendPaymProposalLineSetBasedInsert()
    {
        Debug::assert(canUseCustVendPaymProposalLineSetBasedInsert);

        custVendPaymProposalLineInsertSetManager.insertDatabase();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCreatePaymPerInvoiceCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets a value that controls whether to create payments that settle transactions from other
    ///    companies than the payment itself.
    /// </summary>
    /// <param name="_createPaymPerInvoiceCompany">
    ///    A Boolean value that indicates whether to create separate payments for transactions from multiple
    ///    companies; optional.
    /// </param>
    /// <returns>
    ///    true if transactions can only be paid by a payment in the same company; otherwise, false.
    /// </returns>
    public boolean parmCreatePaymPerInvoiceCompany(boolean _createPaymPerInvoiceCompany = createPaymPerInvoiceCompany)
    {
        createPaymPerInvoiceCompany = _createPaymPerInvoiceCompany;
        return createPaymPerInvoiceCompany;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultOffsetAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the default offset account that is used for the payment proposals that are being
    ///    created.
    /// </summary>
    /// <param name="_defaultOffsetAccount">
    ///    A <c>LedgerJournalAC</c> value that represents the offset account that will be used; optional.
    /// </param>
    /// <returns>
    ///    The default offset account for the payment proposals being created.
    /// </returns>
    /// <remarks>
    ///    This value corresponds to the <c>parmDefaultOffsetAccountType</c> value. This value may be blank.
    /// </remarks>
    public LedgerJournalAC parmDefaultOffsetAccount(LedgerJournalAC _defaultOffsetAccount = defaultOffsetAccount)
    {
        defaultOffsetAccount = _defaultOffsetAccount;
        return defaultOffsetAccount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultOffsetAccountType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the default offset account type that is used for the payment proposals being created.
    /// </summary>
    /// <param name="_defaultOffsetAccountType">
    ///    A <c>LedgerJournalACType</c> value that represents the offset account type that must be used;
    ///    optional.
    /// </param>
    /// <returns>
    ///    The default offset account type for the payment proposals being created.
    /// </returns>
    /// <remarks>
    ///    This value corresponds with the <c>parmDefaultOffsetAccount</c> value.
    /// </remarks>
    public LedgerJournalACType parmDefaultOffsetAccountType(
            LedgerJournalACType _defaultOffsetAccountType = defaultOffsetAccountType)
    {
        defaultOffsetAccountType = _defaultOffsetAccountType;
        return defaultOffsetAccountType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDefaultOffsetLedgerDimension</Name>
				<Source><![CDATA[
    public LedgerDimensionAccount parmDefaultOffsetLedgerDimension(LedgerDimensionAccount _defaultOffsetLedgerDimension = defaultOffsetLedgerDimension)
    {
        defaultOffsetLedgerDimension = _defaultOffsetLedgerDimension;
        return defaultOffsetLedgerDimension;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIncludeInvoicesFromOtherCompanies</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets a flag that indicates whether invoices from other companies are being included.
    /// </summary>
    /// <param name="_includeInvoicesFromOtherCompanies">
    ///    A Boolean value that specifies whether invoices from other companies should be included; optional.
    /// </param>
    /// <returns>
    ///    true if including invoices from other companies; otherwise, false.
    /// </returns>
    public boolean parmIncludeInvoicesFromOtherCompanies(boolean _includeInvoicesFromOtherCompanies = includeInvoicesFromOtherCompanies)
    {
        includeInvoicesFromOtherCompanies = _includeInvoicesFromOtherCompanies;
        return includeInvoicesFromOtherCompanies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the ledger journal for which payments are being processed.
    /// </summary>
    /// <param name = "_ledgerJournalId">The <c>LedgerJournalId</c> of the ledger journal.</param>
    protected void parmLedgerJournalId(LedgerJournalId _ledgerJournalId)
    {
        ledgerJournalTable      = LedgerJournalTable::find(_ledgerJournalId);
        custVendTransStatic     = CustVendTransStatic::newModuleCustVend(LedgerJournalName::journalType2ModuleCustVend(ledgerJournalTable.JournalType));
        paymProposalCalcPaym    = CustVendPaymProposalCalcPaym::construct(ledgerJournalTable.JournalType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLedgerJournalTableCompany</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the company of the <c>LedgerJournalTable</c> for which payments are being proposed.
    /// </summary>
    /// <returns>
    ///    The <c>CompanyId</c> of the Ledger Journal.
    /// </returns>
    public CompanyId parmLedgerJournalTableCompany()
    {
        return ledgerJournalTable.company();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLimitPaymCreationToLedgerCompanyOnly</Name>
				<Source><![CDATA[
    public boolean parmLimitPaymCreationToLedgerCompanyOnly(boolean _limitPaymCreationToLedgerCompanyOnly = limitPaymCreationToLedgerCompanyOnly)
    {
        limitPaymCreationToLedgerCompanyOnly = _limitPaymCreationToLedgerCompanyOnly;
        return limitPaymCreationToLedgerCompanyOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymProposalCalcPaym</Name>
				<Source><![CDATA[
    public CustVendPaymProposalCalcPaym parmPaymProposalCalcPaym(CustVendPaymProposalCalcPaym _paymProposalCalcPaym = paymProposalCalcPaym)
    {
        paymProposalCalcPaym = _paymProposalCalcPaym;

        return paymProposalCalcPaym;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmVoucherType_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the voucher type used for the payment proposals being created.
    /// </summary>
    /// <param name="_voucherType_CN">
    /// A <c>LedgerVoucherTypeId_CN</c> value representing the voucher type to be used.
    /// </param>
    /// <returns>
    /// The voucher type for the payment proposals being created.
    /// </returns>
    public LedgerVoucherTypeId_CN parmVoucherType_CN(LedgerVoucherTypeId_CN _voucherType_CN = voucherType_CN)
    {
        voucherType_CN = _voucherType_CN;
        return voucherType_CN;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymAmountToCompareAsPositive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Converts a payment amount to a positive amount according to the accounts payable or account
    ///    receivable context.
    /// </summary>
    /// <param name="_amount">
    ///    The amount to convert.
    /// </param>
    /// <returns>
    ///    A positive Amount.
    /// </returns>
    protected Amount paymAmountToCompareAsPositive(
        Amount  _amount)
    {
        Amount  amount = _amount;

        if (custVendTransStatic.moduleCustVend() == ModuleCustVend::Vend)
        {
            amount = -amount;
        }

        return amount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes a transaction from the payment proposal.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    A <c>TmpCustVendTransOpen </c>record buffer.
    /// </param>
    public void removeCustVendTransOpen(CustVendTransOpen _custVendTransOpen)
    {
        SpecTrans                   specTrans;
        CustVendPaymProposalLine    custVendPaymProposalLine;

        changecompany(this.parmLedgerJournalTableCompany())
        {
            ttsbegin;

            select firstonly RecId from custVendPaymProposalLine
                where custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum
            join forupdate specTrans
                where specTrans.SpecCompany == custVendPaymProposalLine.DataAreaId
                   && specTrans.SpecTableId == custVendPaymProposalLine.TableId
                   && specTrans.SpecRecId   == custVendPaymProposalLine.RecId
                   && specTrans.RefCompany  == _custVendTransOpen.DataAreaId
                   && specTrans.RefTableId  == _custVendTransOpen.TableId
                   && specTrans.RefRecId    == _custVendTransOpen.RecId;

            specTrans.delete();

            if (isPaymentRequestsEnabled)
            {
                this.removePaymentRequestLink(custVendPaymProposalLine, _custVendTransOpen);
            }

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeNegativePayments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes payment lines that, with their current collection of transactions to pay, end up being
    ///    negative.
    /// </summary>
    /// <remarks>
    ///    "Negative" is meant as if the system would remit money to a customer or collect money from a vendor.
    /// </remarks>
    public void removeNegativePayments()
    {
        CustVendPaymProposalLine    custVendPayProposalLine;
        AmountMST                   paymAmountMST;

        while select custVendPayProposalLine
            where custVendPayProposalLine.JournalId == ledgerJournalTable.JournalNum
            && ((fromCustVendAccountNum == '' && toCustVendAccountNum == '') || 
            (custVendPayProposalLine.AccountNum >= fromCustVendAccountNum && custVendPayProposalLine.AccountNum <= toCustVendAccountNum)
            )
        {
            paymAmountMST = this.paymAmountToCompareAsPositive(custVendPayProposalLine.paymAmountMST());

            if (paymAmountMST <= 0)
            {
                this.removePaymentLine(custVendPayProposalLine);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePaymentLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Removes a payment line and the matching transactions from the payment proposal.
    /// </summary>
    /// <param name="_paymProposalLine">
    ///    The <c>CustVendPaymProposalLine </c>record buffer to remove from the payment proposal.
    /// </param>
    // Modifications to his method must also be reflected in the clear method.
    // The clear method is factored out due to performance reasons.
    public void removePaymentLine(CustVendPaymProposalLine _paymProposalLine)
    {
        SpecTrans   specTrans;

        ttsbegin;

        delete_from specTrans
            where specTrans.SpecCompany == _paymProposalLine.DataAreaId
               && specTrans.SpecTableId == _paymProposalLine.TableId
               && specTrans.SpecRecId   == _paymProposalLine.RecId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reorganize</Name>
				<Source><![CDATA[
    /// <summary>
    /// Reorganizes the whole payment proposal by recalculating payment dates for the transaction already
    /// in the proposal.
    /// </summary>
    public void reorganize()
    {
        paymProposalOrg.reorganize(paymProposalCalcPaym);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reorgCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Reorganizes the transaction and matches it with a new payment if it is required.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    The <c>TmpCustVendTransOpen </c>record buffer to reorganize.
    /// </param>
    /// <param name="_paymDate">
    ///    The eventual new payment date; optional.
    /// </param>
    /// <param name="_paymCurrency">
    ///     ; optional.
    /// </param>
    /// <param name="_bankAccount">
    ///     The bank account for payment; optional.
    /// </param>
    /// <param name="_paymentAmount">
    ///    The payment amount in the currency of the open transaction; optional
    /// </param>
    /// <param name="_cashDiscToTake">
    ///    The cash discount to take amount in the currency of the open transaction; optional.
    /// </param>
    /// <remarks>
    ///    This method should be used when any payment attribute of the transaction is changed; for example,
    ///    the method of payment.
    /// </remarks>
    public void reorgCustVendTransOpen(
        CustVendTransOpen   _custVendTransOpen,
        TransDate           _paymDate           = dateNull(),
        CurrencyCode        _paymCurrency       = '',
        LedgerJournalAC     _bankAccount        = '',
        AmountCur           _paymentAmount      = 0,
        AmountCur           _cashDiscToTake     = 0)
    {
        TransDate                   paymDate;
        CustVendPaymProposalLine    custVendPaymProposalLine;
        SpecTrans                   specTransFieldList;
        AmountCur                   paymentAmount;
        AmountCur                   cashDiscToTake;

        changecompany(this.parmLedgerJournalTableCompany())
        {
            select firstonly Balance01, Code, CashDiscToTake from specTransFieldList
                where specTransFieldList.RefCompany == _custVendTransOpen.DataAreaId
                   && specTransFieldList.RefTableId == _custVendTransOpen.TableId
                   && specTransFieldList.RefRecId   == _custVendTransOpen.RecId
            join custVendPaymProposalLine
                where custVendPaymProposalLine.JournalId == this.ledgerJournalId()
                   && custVendPaymProposalLine.DataAreaId == specTransFieldList.SpecCompany
                   && custVendPaymProposalLine.TableId == specTransFieldList.SpecTableId
                   && custVendPaymProposalLine.RecId   == specTransFieldList.SpecRecId;
        }

        if (!prmisDefault(_paymDate))
        {
            paymDate = _paymDate;
        }
        else
        {
            paymDate = custVendPaymProposalLine.PaymDate;
        }

        if (_bankAccount != '')
        {
            custVendPaymProposalLine.parmPaymAccount(_bankAccount);
        }

        if (!prmisDefault(_paymentAmount))
        {
            paymentAmount = _paymentAmount;
        }
        else
        {
            paymentAmount = specTransFieldList.Balance01;
        }

        if (!prmisDefault(_cashDiscToTake))
        {
            cashDiscToTake = _cashDiscToTake;
        }
        else
        {
            cashDiscToTake = specTransFieldList.CashDiscToTake;
        }

        // specify the CustVend record to be used as the customer or vendor of the payment proposal records that will be
        // generated by the reorganization
        this.setPaymCustVendTableFromPaymProposalLine(custVendPaymProposalLine);
        this.setOffsetAccountAndTypeFromPaymPropLine(custVendPaymProposalLine);

        if (!this.transMatchesProposalLine(_custVendTransOpen, paymDate))
        {
            this.removeCustVendTransOpen(_custVendTransOpen);

            this.addCustVendTransOpen(_custVendTransOpen,
                                      paymDate,
                                      _paymCurrency ? _paymCurrency : specTransFieldList.Code,
                                      paymentAmount,
                                      cashDiscToTake);
        }

        // clear the preset CustVendTable that was used as the customer or vendor for the payment proposal records that were generated
        this.clearPaymCustVendTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveBankRemittanceType</Name>
				<Source><![CDATA[
    public BankRemittanceType resolveBankRemittanceType(
        CustVendPaymProposalLine    _custVendPaymProposalLine,
        CustVendTransOpenData       _custVendTransOpenData = null)
    {
        CustBillOfExchangeTrans custBillOfExchangeTrans;
        BankRemittanceType      bankRemittanceType;

        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustPaymRemittance:
                bankRemittanceType  = ledgerJournalTable.BankRemittanceType;
                break;

            case LedgerJournalType::VendPaymRemittance:
                if (_custVendTransOpenData.custVendTrans().NegInstStatus == CustVendNegInstStatus::Invoiced)
                {
                    bankRemittanceType = BankRemittanceType::Collection;
                }
                else
                {
                    bankRemittanceType = BankRemittanceType::None;
                }
                break;

            case LedgerJournalType::CustBillOfExchangeAccept,
                 LedgerJournalType::CustBillOfExchangeProtest,
                 LedgerJournalType::CustBillOfExchangeRedraw,
                 LedgerJournalType::CustBillOfExchangeSettle :

                select firstonly BankRemittanceType from custBillOfExchangeTrans
                    where custBillOfExchangeTrans.BillOfExchangeId  == _custVendPaymProposalLine.NegInstID
                       && custBillOfExchangeTrans.SeqNum            == _custVendPaymProposalLine.NegInstSeqNum
                       && custBillOfExchangeTrans.Status            == _custVendPaymProposalLine.NegInstStatus;

                bankRemittanceType = custBillOfExchangeTrans.BankRemittanceType;
                break;

            default :
        }

        return bankRemittanceType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolveCompanyBankAccountIdNegInst</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resolves the company bank account of the payment for bill of exchange or promissory note journals.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    ///    The <c>CustVendPaymProposalLine </c>record buffer for which to resolve the company bank account.
    /// </param>
    /// <returns>
    ///    The company bank account ID.
    /// </returns>
    public CompanyBankAccountId resolveCompanyBankAccountIdNegInst(
        CustVendPaymProposalLine    _custVendPaymProposalLine)
    {
        CustBillOfExchangeTrans custBillOfExchangeTrans;
        VendPromissoryNoteTrans vendPromissoryNoteTrans;
        CompanyBankAccountId    companyBankAccountIdNegInst;
        CustVendPaymModeTable   custVendPaymModeTable;

        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustPaymRemittance,
                 LedgerJournalType::VendPaymRemittance :
                companyBankAccountIdNegInst = ledgerJournalTable.BankAccountId;
                break;

            case LedgerJournalType::CustBillOfExchangeDraw,
                 LedgerJournalType::VendPromissoryNoteDraw:
                // the payment mode record used to determine the payment account will come from the journal company
                custVendPaymModeTable = _custVendPaymProposalLine.paymModeTableByCompany(_custVendPaymProposalLine.company());
                if (custVendPaymModeTable.AccountType == LedgerJournalACType::Bank)
                {
                    companyBankAccountIdNegInst = custVendPaymModeTable.parmPaymAccount();
                }

                if (!companyBankAccountIdNegInst)
                {
                    // payment mode record was not found or did not have a payment account assigned, use the
                    // bank account from the journal table - Dynamics Ax41 bug#71584
                    companyBankAccountIdNegInst = ledgerJournalTable.BankAccountId;
                }
                break;

            case LedgerJournalType::CustBillOfExchangeAccept:
            case LedgerJournalType::CustBillOfExchangeProtest:
            case LedgerJournalType::CustBillOfExchangeRedraw:
            case LedgerJournalType::CustBillOfExchangeSettle:
                select firstonly RemittedToBankAccountId from custBillOfExchangeTrans
                    where custBillOfExchangeTrans.BillOfExchangeId  == _custVendPaymProposalLine.NegInstID
                       && custBillOfExchangeTrans.SeqNum            == _custVendPaymProposalLine.NegInstSeqNum
                       && custBillOfExchangeTrans.Status            == _custVendPaymProposalLine.NegInstStatus;

                companyBankAccountIdNegInst = custBillOfExchangeTrans.RemittedToBankAccountId;
                break;

            case LedgerJournalType::VendPromissoryNoteRedraw:
            case LedgerJournalType::VendPromissoryNoteSettle:
                select firstonly RemittedtoBankAccountId from vendPromissoryNoteTrans
                 where vendPromissoryNoteTrans.PromissoryNoteId  == _custVendPaymProposalLine.NegInstID
                    && vendPromissoryNoteTrans.SeqNum            == _custVendPaymProposalLine.NegInstSeqNum
                    && vendPromissoryNoteTrans.Status            == _custVendPaymProposalLine.NegInstStatus;

                companyBankAccountIdNegInst = vendPromissoryNoteTrans.RemittedtoBankAccountId;
                break;
            default:
        }
        return companyBankAccountIdNegInst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolvePaymAccountAndType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Resolves the payment account and account type for an existing payment proposal line.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    ///    A <c>CustVendPaymProposalLine </c>record.
    /// </param>
    /// <param name="_defaultType">
    ///    A default account type to use as the fallback if nothing else is found; optional.
    /// </param>
    /// <param name="_defaultAccount">
    ///    A default account number to use as the fallback if nothing else is found; optional.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    ///    A default ledger dimension to use as the fallback if nothing else is found; optional.
    /// </param>
    /// <returns>
    ///    An object that holds both an account type and an account number.
    /// </returns>
    public LedgerJournalAccountAndType resolvePaymAccountAndType(
        CustVendPaymProposalLine    _custVendPaymProposalLine,
        LedgerJournalACType         _defaultType                = LedgerJournalACType::Ledger,
        LedgerJournalAC             _defaultAccount             = '',
        LedgerDimensionAccount      _defaultLedgerDimension     = 0
        )
    {
        LedgerJournalAccountAndType ledgerJournalAccountAndType;
        CustVendPaymModeTable       custVendPaymModeTable;
        LedgerDimensionDefaultAccount defaultLedgerDimension;

        if (_custVendPaymProposalLine.parmLedgerDimension())
        {
            ledgerJournalAccountAndType = LedgerJournalAccountAndType::newAccountAndType(_custVendPaymProposalLine.parmPaymAccount(),
                                                                                         _custVendPaymProposalLine.PaymAccountType,
                                                                                         _custVendPaymProposalLine.parmLedgerDimension());
            return ledgerJournalAccountAndType;
        }

        // use the default offset account if specified
        ledgerJournalAccountAndType = this.getDefaultOffsetAccountAndType();

        if (ledgerJournalAccountAndType != null && !changePaymMode && !changePaymentDistributionMode && !changeCompanyBankAccount)
        {
            return ledgerJournalAccountAndType;
        }

        ledgerJournalAccountAndType = LedgerJournalAccountAndType::construct();
        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw,
                 LedgerJournalType::CustPaymRemittance,
                 LedgerJournalType::CustBillOfExchangeRedraw :
                ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Cust);
                ledgerJournalAccountAndType.parmAccountNum(_custVendPaymProposalLine.AccountNum);
                break;

            case LedgerJournalType::CustBillOfExchangeSettle :
                if (_custVendPaymProposalLine.BankRemittanceType == BankRemittanceType::Discount)
                {
                    ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Ledger);
                    defaultLedgerDimension = this.getPostingProfileBillsRemitLedgerDimension(_custVendPaymProposalLine.AccountNum);
                    if (defaultLedgerDimension)
                    {
                        ledgerJournalAccountAndType.parmLedgerDimension(CustVendPaymProposalLine::createLedgerDimension(defaultLedgerDimension, ledgerJournalTable, this.getCustVendDefaultDimension(_custVendPaymProposalLine)));
                    }
                }
                else
                {
                    ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Bank);
                    ledgerJournalAccountAndType.parmAccountNum(_custVendPaymProposalLine.CompanyBankAccountIdNegInst ?
                                                               _custVendPaymProposalLine.CompanyBankAccountIdNegInst :
                                                               ledgerJournalTable.BankAccountId);
                }
                break;

            case LedgerJournalType::CustBillOfExchangeProtest :
                if (LedgerJournalTable::find(_custVendPaymProposalLine.JournalId).ProtestSettledBill == NoYes::Yes)
                {
                    ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Bank);
                }
                else
                {
                    ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Cust);
                    ledgerJournalAccountAndType.parmAccountNum(_custVendPaymProposalLine.AccountNum);
                }
                break;

            case LedgerJournalType::VendPromissoryNoteDraw,
                 LedgerJournalType::VendPromissoryNoteRedraw,
                 LedgerJournalType::VendPaymRemittance :
                ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Vend);
                ledgerJournalAccountAndType.parmAccountNum(_custVendPaymProposalLine.AccountNum);
                break;

            case LedgerJournalType::VendPromissoryNoteSettle:
                ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Bank);
                ledgerJournalAccountAndType.parmAccountNum(_custVendPaymProposalLine.CompanyBankAccountIdNegInst ?
                                                           _custVendPaymProposalLine.CompanyBankAccountIdNegInst :
                                                           ledgerJournalTable.BankAccountId);
                break;

            default :
                ledgerJournalAccountAndType.parmAccountType(_defaultType);
                ledgerJournalAccountAndType.parmAccountNum(_defaultAccount);
                ledgerJournalAccountAndType.parmLedgerDimension(_defaultLedgerDimension);
        }

        if (ledgerJournalAccountAndType.parmAccountNum() == '' && ledgerJournalAccountAndType.parmLedgerDimension() == 0)
        {
            custVendPaymModeTable = _custVendPaymProposalLine.paymModeTableByCompany(this.parmLedgerJournalTableCompany());

            if (custVendPaymModeTable != null)
            {
                defaultLedgerDimension = 0;
                if (custVendPaymModeTable.FurtherPosting)
                {
                    ledgerJournalAccountAndType.parmAccountType(LedgerJournalACType::Ledger);
                    defaultLedgerDimension = custVendPaymModeTable.InterCompanyLedgerDimension;
                    if (defaultLedgerDimension)
                    {
                        ledgerJournalAccountAndType.parmLedgerDimension(
                            CustVendPaymProposalLine::createLedgerDimension(defaultLedgerDimension, ledgerJournalTable, this.getCustVendDefaultDimension(_custVendPaymProposalLine)));
                    }
                }
                else
                {
                    ledgerJournalAccountAndType.parmAccountType(custVendPaymModeTable.paymACType());
                    if (ledgerJournalAccountAndType.parmAccountType() == LedgerJournalACType::Ledger)
                    {
                        defaultLedgerDimension = custVendPaymModeTable.offsetLedgerDimension();
                        if (defaultLedgerDimension)
                        {
                            ledgerJournalAccountAndType.parmLedgerDimension(
                                CustVendPaymProposalLine::createLedgerDimension(defaultLedgerDimension, ledgerJournalTable, this.getCustVendDefaultDimension(_custVendPaymProposalLine)));
                        }
                    }
                    else
                    {
                        ledgerJournalAccountAndType.parmAccountNum(custVendPaymModeTable.parmPaymAccount());
                    }
                }
            }
        }

        if (ledgerJournalAccountAndType.parmAccountNum() == '' && ledgerJournalAccountAndType.parmLedgerDimension() == 0)
        {
            ledgerJournalAccountAndType.parmAccountType(ledgerJournalTable.OffsetAccountType);
            if (ledgerJournalAccountAndType.parmAccountType() == LedgerJournalACType::Ledger)
            {
                defaultLedgerDimension = ledgerJournalTable.parmOffsetLedgerDimension();
                if (defaultLedgerDimension)
                {
                    ledgerJournalAccountAndType.parmLedgerDimension(CustVendPaymProposalLine::createLedgerDimension(defaultLedgerDimension, ledgerJournalTable, this.getCustVendDefaultDimension(_custVendPaymProposalLine)));
                }
            }
            else
            {
                ledgerJournalAccountAndType.parmAccountNum(ledgerJournalTable.parmOffsetAccount());
            }
        }

        return ledgerJournalAccountAndType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPostingProfileBillsRemitLedgerDimension</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Retrieves the bills remittance ledger dimension for the account.
    /// </summary>
    /// <param name = "_accountNum">
    ///     The account number.
    /// </param>
    /// <returns>
    ///     The bills remittance ledger dimension for the account.
    /// </returns>
    [Wrappable(true)]
    protected final LedgerDimensionDefaultAccount getPostingProfileBillsRemitLedgerDimension(CustVendAc _accountNum)
    {
        return CustLedgerAccounts::liabilitiesLedgerDimension(_accountNum, CustParameters::find().PostingProfileBillsRemitDiscount);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolvePaymCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the customer or vendor and company for which a proposal should be created.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    The transaction for which a payment is being proposed.
    /// </param>
    /// <returns>
    ///    A <c>container</c> object where the first element is the customer or vendor account number and the
    ///    second element is the company, if a valid customer or vendor and company could be identified;
    ///    otherwise, empty.
    /// </returns>
    /// <remarks>
    ///    If a preset customer or vendor record has been supplied, that preset record will be used. Otherwise
    ///    the customer or vendor account is determined dynamically as follows:If you are combining
    ///    transactions from multiple companies, the proposal should be created in the same company as the
    ///    ledger journal that contains the proposal. If the customer or vendor is not represented in the
    ///    ledger company, the proposal will be created in the company of the transaction. The identified
    ///    customer or vendor and company will be used as the payment customer or vendor and company for
    ///    subsequent transactions.If you are not combining invoices from multiple companies, the proposal
    ///    will always be created in the same company as the invoice.If the system is limited to creating
    ///    payments in the same company as the journal, the returned customer or vendor will be in the same
    ///    company as the journal.
    /// </remarks>
    public container resolvePaymCustVend(CustVendTrans _custVendTrans)
    {
        CustVendTable       transactionCustVendTable;
        CustVendTable       ledgerCompanyCustVendTable;
        container           serviceBoundaryCompanies;
        container           ret;
        DirPartyRecId          party;
        CompanyId           dirCompanyId;
        Map                 paymCustVendByParty;

        Debug::assert(_custVendTrans != null);
        Debug::assert(_custVendTrans.company() == curext());

        // if object setup to use a pre-determined cust/vend & company, then use it
        if (presetCustVendTableForPayments)
        {
            ret = [presetCustVendTableForPayments.AccountNum, presetCustVendTableForPayments.company()];
            return ret;
        }

        // if invoices are not being selected from multiple companies OR we are creating all payments in the same company as
        // their associated transactions then use the cust/vend and company from the transaction
        if (! this.parmIncludeInvoicesFromOtherCompanies() ||
            this.parmCreatePaymPerInvoiceCompany())
        {
            ret = this.resolvePaymCustVendToTransactionCustVend(_custVendTrans);
            return ret;
        }

        //
        // If we have not returned a value yet, then we will use Party of the transaction's cust/vend to to find an associated
        // cust/vend in the appropriate company.
        //

        // retrieve the Party for the cust/vend of the transaction
        transactionCustVendTable = CustVendTable::findModule(this.custVendTransStatic().moduleCustVend(),
                                                             _custVendTrans.AccountNum);
        party = transactionCustVendTable.Party;

        dirCompanyId = #CrossCompanyCacheKeyValue; // summarization for all companies

        // look in the map to see if we previously identified which cust/vend and company to use for this Party
        if (partyIdsByDirectory.exists(dirCompanyId))
        {
            paymCustVendByParty = partyIdsByDirectory.lookup(dirCompanyId);
            if (paymCustVendByParty.exists(party))
            {
                // return the previously used cust/vend and company
                ret = paymCustVendByParty.lookup(party);
                return ret;
            }
        }

        //
        // Attempt to find the cust/vend and company that should be used for the payment that will include the supplied transaction
        // The cust/vend and company must be from the the CentralizedPayments shared service boundaries
        // First attempt to find the cust/vend in the ledger company, if not found then we will use the cust/vend from the transaction company
        //

        // if transaction cust/vend is in same company as ledger then use the invoice cust/vend
        if (_custVendTrans.company() == this.parmLedgerJournalTableCompany())
        {
            ret = this.resolvePaymCustVendToTransactionCustVend(_custVendTrans);
        }
        else
        {
            // attempt to find a cust/vend in the ledger company associated with the Party of the cust/vend of the transaction company
            // ledger company
            serviceBoundaryCompanies = CustVendOpenTransManager::findSharedServiceCompanies(_custVendTrans.company());

            ledgerCompanyCustVendTable.clear();
            if (conFind(serviceBoundaryCompanies, this.parmLedgerJournalTableCompany()) != 0)
            {
                // the ParyId is applicable to the cust/vend records of the journal company
                // see if an associated cust/vend is present
                changecompany(this.parmLedgerJournalTableCompany())
                {
                    ledgerCompanyCustVendTable = null;
                    switch (this.custVendTransStatic().moduleCustVend())
                    {
                        case ModuleCustVend::Cust :
                            ledgerCompanyCustVendTable = CustTable::findByPartyRecId(party);
                            break;

                        case ModuleCustVend::Vend :
                            ledgerCompanyCustVendTable = VendTable::findByPartyRecId(party);
                            break;

                        default:
                            Debug::assert(false);
                            break;
                    }
                }
            }

            if (ledgerCompanyCustVendTable.RecId != 0)
            {
                // use the cust/vend record retrieved from the journal company
                ret = [ledgerCompanyCustVendTable.AccountNum, ledgerCompanyCustVendTable.company()];
            }
            else
            {
                // no associated cust/vend found in the journal company
                // use the cust/vend of the transaction company
                ret = this.resolvePaymCustVendToTransactionCustVend(_custVendTrans);
            }
        }

        // Add the identified cust/vend and company to the cache so other transactions for this same Party will use the
        // same cust/vend and company
        if (!partyIdsByDirectory.exists(dirCompanyId))
        {
            paymCustVendByParty = new Map(Types::Int64, Types::Container);
            partyIdsByDirectory.insert(dirCompanyId, paymCustVendByParty);
        }

        paymCustVendByParty = partyIdsByDirectory.lookup(dirCompanyId);
        if (! paymCustVendByParty.exists(party))
        {
            paymCustVendByParty.insert(party, ret);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resolvePaymCustVendToTransactionCustVend</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the customer or vendor and company for a payment from a <c>CustVendTrans</c> record.
    /// </summary>
    /// <param name="_custVendTrans">
    ///    The transaction for which a payment is being proposed.
    /// </param>
    /// <returns>
    ///    A <c>container</c> object where the first element is the customer or vendor account number and the
    ///    second element is the company if a valid customer or vendor and company could be identified;
    ///    otherwise, empty.
    /// </returns>
    private container resolvePaymCustVendToTransactionCustVend(CustVendTrans _custVendTrans)
    {
        container ret;

        if (! this.parmLimitPaymCreationToLedgerCompanyOnly() ||
            _custVendTrans.company() == this.parmLedgerJournalTableCompany())
        {
            // return cust/vend from and company from the transaction
            ret = [_custVendTrans.AccountNum, _custVendTrans.company()];
            return ret;
        }
        else
        {
            // only allowing payments to be created in the journal company, however the invoice is from the journal company so
            // there is no cust/vend to resolve to
            ret = ['',''];
            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOffsetAccountAndTypeFromPaymPropLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the default ledger dimension, account type and account values from the
    /// <c>CustVendPaymProposalLine</c> record.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    /// The current <c>CustVendPaymProposalLine</c> record to use as defaults.
    /// </param>
    /// <remarks>
    /// This method is typically called during an edit to the payment proposal to keep the offset values
    /// currently used.
    /// </remarks>
    private void setOffsetAccountAndTypeFromPaymPropLine(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        if (! _custVendPaymProposalLine)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }
        //set the accounts from the
        this.parmDefaultOffsetLedgerDimension(_custVendPaymProposalLine.LedgerDimension);
        this.parmDefaultOffsetAccountType(_custVendPaymProposalLine.PaymAccountType);
        this.parmDefaultOffsetAccount(_custVendPaymProposalLine.parmPaymAccount());
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOrgStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialization of the <c>CustVendPaymProposalOrg</c> instance.
    /// </summary>
    public void initOrgStrategy()
    {
        paymProposalOrg = CustVendPaymProposalOrg::construct();
        paymProposalOrg.parmPaymProposal(this);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymCustVendTableFromJournalTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>CustVendTable</c> record for which the payment proposals will be generated.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The <c>LedgerJournalTrans</c> record that references the customer or vendor for which to generate
    ///    payments. This value must be supplied.
    /// </param>
    /// <remarks>
    ///    All payment proposals generated when this value is set will use the customer or vendor specified as
    ///    the payment customer or vendor. See the <c>getPaymCustVendTable</c> method. The customer or vendor
    ///    record found will be retained for use by this object until it is set to another record or until it
    ///    is cleared. If a customer or vendor record cannot be retrieved, this object will retain an empty
    ///    value.
    /// </remarks>
    public void setPaymCustVendTableFromJournalTrans(LedgerJournalTrans _ledgerJournalTrans)
    {
        if (! _ledgerJournalTrans)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        changecompany(_ledgerJournalTrans.Company)
        {
            switch (_ledgerJournalTrans.AccountType)
            {
                case LedgerJournalACType::Cust :
                    presetCustVendTableForPayments = CustTable::findByCompany(_ledgerJournalTrans.Company, _ledgerJournalTrans.parmAccount());
                    break;

                case LedgerJournalACType::Vend :
                    presetCustVendTableForPayments = VendTable::findByCompany(_ledgerJournalTrans.Company, _ledgerJournalTrans.parmAccount());
                    break;

                default :
                    presetCustVendTableForPayments = null;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymCustVendTableFromPaymProposalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Sets the <c>CustVendTable</c> record for which the payment proposals will be generated.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    ///    The <c>CustVendPaymProposalLine</c> record that references the customer or vendor for which to
    ///    generate additional proposal lines.
    /// </param>
    /// <remarks>
    ///    All additional payment proposals generated when this value is set will use the customer or vendor
    ///    specified as the payment customer or vendor. See method <c>getPaymCustVendTable</c>. The customer
    ///    or vendor record found will be retained for use by this object until it is set to another record or
    ///    until it is cleared. If a customer or vendor record cannot be retrieved this object will retain an
    ///    empty value.
    /// </remarks>
    public void setPaymCustVendTableFromPaymProposalLine(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        if (! _custVendPaymProposalLine)
        {
            throw error(Error::wrongUseOfFunction(funcName()));
        }

        presetCustVendTableForPayments = _custVendPaymProposalLine.custVendTable();
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesJournalContainAnyPaymentProposalLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the journal contains any related payment proposal lines.
    /// </summary>
    /// <param name="_journalNum">
    /// The journal number of the journal to find payment proposal lines for.
    /// </param>
    /// <returns>
    /// true if the journal contains any payment proposal lines; otherwise, false.
    /// </returns>
    public static boolean doesJournalContainAnyPaymentProposalLines(LedgerJournalId _journalNum)
    {
        CustVendPaymProposalLine    custVendPaymProposalLine;
        SpecTrans                   specTrans;

        select firstonly custVendPaymProposalLine
            where custVendPaymProposalLine.JournalId == _journalNum
            join RecId from specTrans
                where specTrans.SpecCompany == custVendPaymProposalLine.DataAreaId &&
                    specTrans.SpecTableId == custVendPaymProposalLine.TableId &&
                    specTrans.SpecRecId == custVendPaymProposalLine.RecId;

        return custVendPaymProposalLine.RecId != 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>totalPaymAmountMST</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the total value of the current set of payment proposals in the monetary standard (MST) currency
    /// of the associated journal's company.
    /// </summary>
    /// <param name="_roundResult">
    /// true if the result should be rounded; otherwise false.
    /// </param>
    /// <returns>
    /// The total value of the current set of payment proposals.
    /// </returns>
    public AmountMST totalPaymAmountMST(boolean _roundResult = true)
    {
        CustVendPaymProposalLine    custVendPaymProposalLine;
        AmountCur                   paymAmountCur;
        AmountMST                   paymAmountMST;
        AmountMST                   totalPaymAmountMst;
        CurrencyExchangeHelper      currencyExchangeHelper;

        Debug::assert(this.parmLedgerJournalTableCompany() == curext());

        while select custVendPaymProposalLine
            where custVendPaymProposalLine.JournalId == ledgerJournalTable.JournalNum
        {
            paymAmountCur = custVendPaymProposalLine.paymAmountCur();

            // The payment currency in the payment company is the same currency as the when viewed from the ledger company thus no exchnage needed
            // to move from payment company to journal company. Convert the value directly to the MST currency of the journal company.
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(this.parmLedgerJournalTableCompany()).RecId),
                                                                 custVendPaymProposalLine.PaymDate);
            paymAmountMST = currencyExchangeHelper.calculateTransactionToAccounting(custVendPaymProposalLine.CurrencyCode, paymAmountCur, _roundResult);

            totalPaymAmountMst += paymAmountMST;
        }

        return totalPaymAmountMst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trans2PaymLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the payment proposal line already associated with a specific open transaction.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    A <c>CustVendTransOpen</c> record.
    /// </param>
    /// <returns>
    ///    A <c>CustVendPaymProposalLine </c>record.
    /// </returns>
    public CustVendPaymProposalLine trans2PaymLine(
        CustVendTransOpen _custVendTransOpen)
    {
        CustVendPaymProposalLine    custVendPaymProposalLine;
        SpecTrans                   specTrans;

        Debug::assert(this.parmLedgerJournalTableCompany() == curext());

        select firstonly custVendPaymProposalLine
            where custVendPaymProposalLine.JournalId == this.ledgerJournalId()
        join RecId from specTrans
            where specTrans.SpecCompany == custVendPaymProposalLine.DataAreaId
               && specTrans.SpecTableId == custVendPaymProposalLine.TableId
               && specTrans.SpecRecId   == custVendPaymProposalLine.RecId
               && specTrans.RefCompany  == _custVendTransOpen.DataAreaId
               && specTrans.RefTableId  == _custVendTransOpen.TableId
               && specTrans.RefRecId    == _custVendTransOpen.RecId;

        return custVendPaymProposalLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transMatchesProposalLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether a transaction is matched with the correct payment.
    /// </summary>
    /// <param name="_custVendTransOpen">
    ///    The <c>CustVendTransOpen</c> record buffer to investigate.
    /// </param>
    /// <param name="_paymDate">
    ///    An eventual new payment date; optional.
    /// </param>
    /// <returns>
    ///    true if the <c>CustVendTransOpen</c> record buffer is matched with the correct payment; otherwise,
    ///    false.
    /// </returns>
    /// <remarks>
    ///    The match could be wrong if any payment attribute of the transaction is changed after you add the
    ///    transaction to the payment proposal.
    /// </remarks>
    public boolean transMatchesProposalLine(
        CustVendTransOpen   _custVendTransOpen,
        TransDate           _paymDate = dateNull())
    {
        boolean                         ret = false;
        TransDate                       paymDate;
        CustVendPaymProposalLine        custVendPaymProposalLineFieldList;
        CustVendPaymProposalLine        custVendPaymProposalLineTest;
        SpecTrans                       specTrans;

        changecompany(this.parmLedgerJournalTableCompany())
        {
            select firstonly Code from specTrans
                where specTrans.RefCompany  == _custVendTransOpen.DataAreaId
                   && specTrans.RefTableId  == _custVendTransOpen.TableId
                   && specTrans.RefRecId    == _custVendTransOpen.RecId
            join RecId, PaymDate from custVendPaymProposalLineFieldList
                where custVendPaymProposalLineFieldList.DataAreaId  == specTrans.SpecCompany
                   && custVendPaymProposalLineFieldList.TableId  == specTrans.SpecTableId
                   && custVendPaymProposalLineFieldList.RecId    == specTrans.SpecRecId;
        }

        if (!prmisDefault(_paymDate))
        {
            paymDate = _paymDate;
        }
        else
        {
            paymDate = custVendPaymProposalLineFieldList.PaymDate;
        }

        custVendPaymProposalLineTest = this.buildPaymProposalLine(_custVendTransOpen,
                                                                  paymDate,
                                                                  specTrans.Code);

        // if the proposal line does not have a cust/vend account assigned then the current transaction will not be included
        if (custVendPaymProposalLineTest.AccountNum != '')
        {
            custVendPaymProposalLineTest = this.findProposalLine(custVendPaymProposalLineTest);

            if (custVendPaymProposalLineTest.RecId == custVendPaymProposalLineFieldList.RecId)
            {
                ret = true;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validatePaymentCurrency</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether currencies that are required to generate payment values exist in the companies
    /// associated with the payment.
    /// </summary>
    /// <param name="_paymCurrency">
    /// The currency to be verified.
    /// </param>
    /// <param name="_paymCompany">
    /// The company in which the currency will be used.
    /// </param>
    /// <param name="_transactionCompany">
    /// The company from which values must be converted to generate the payment value.
    /// </param>
    /// <returns>
    /// true if the required monetary conversions can be completed for the provided currency and companies;
    /// otherwise, false.
    /// </returns>
    /// <remarks>
    /// To be valid, the payment currency must exist in the payment company in addition to the ledger
    /// journal company.The MST currency of the payment company must exist in the transaction company. The
    /// payment currency is either the currency of the invoice or a user selected currency from the ledger
    /// journal company.
    /// </remarks>
    public boolean validatePaymentCurrency(CurrencyCode _paymCurrency, CompanyId _paymCompany, CompanyId _transactionCompany)
    {
        boolean isValidCurrency;
        CurrencyCode paymCompanyMstCurrency;

        Debug::assert(_paymCompany != '');
        Debug::assert(_transactionCompany != '');

        isValidCurrency = true;

        // verify the currency of the payment is valid in the journal company
        if (this.parmLedgerJournalTableCompany() != _transactionCompany)
        {
            changecompany(this.parmLedgerJournalTableCompany())
            {
                isValidCurrency = (Currency::find(_paymCurrency).RecId != 0);
            }
        }

        if (isValidCurrency &&
           (_paymCompany != _transactionCompany))
        {
            // verify the currency of the payment is valid in the payment company
            changecompany(_paymCompany)
            {
                paymCompanyMstCurrency = CompanyInfoHelper::standardCurrency();
                isValidCurrency = (Currency::find(_paymCurrency).RecId != 0);
            }

            if (isValidCurrency)
            {
                // verify the MST currency of the payment company is represented in the transaction company
                changecompany(_transactionCompany)
                {
                    isValidCurrency = (Currency::find(paymCompanyMstCurrency).RecId != 0);
                }
            }
        }

        return isValidCurrency;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendPaymProposal construct()
    {
        CustVendPaymProposal    custVendPaymProposal;

        custVendPaymProposal = new CustVendPaymProposal();

        return custVendPaymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newLedgerJournal</Name>
				<Source><![CDATA[
    public static CustVendPaymProposal newLedgerJournal(LedgerJournalId _ledgerJournalId)
    {
        CustVendPaymProposal custVendPaymProposal = CustVendPaymProposal::construct();
        custVendPaymProposal.parmLedgerJournalId(_ledgerJournalId);
        custVendPaymProposal.initOrgStrategy();
        return custVendPaymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUserInteraction</Name>
				<Source><![CDATA[
    public CustVendPaymProposalUserInteraction parmUserInteraction(CustVendPaymProposalUserInteraction _userInteraction = userInteraction)
    {
        userInteraction = _userInteraction;

        return userInteraction;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeAlreadySettledTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Remove transactions that have been settled by another user since payment proposal started.
    /// </summary>
    public void removeAlreadySettledTransactions()
    {
        CustVendPaymProposalLine paymProposalLine;
        SpecTrans specTrans, specTransToDelete;
        CustVendTransOpen custVendTransOpen = custVendTransStatic.custVendTransOpen();

        if (this.parmIncludeInvoicesFromOtherCompanies() == NoYes::No)
        {
            while select RecId from specTrans
                join RecId from paymProposalLine
                where paymProposalLine.JournalId == ledgerJournalTable.JournalNum
                    && specTrans.SpecCompany == paymProposalLine.DataAreaId
                    && specTrans.SpecTableId == paymProposalLine.TableId
                    && specTrans.SpecRecId == paymProposalLine.RecId
                    && ((fromCustVendAccountNum == '' && toCustVendAccountNum == '') ||
                        (paymProposalLine.AccountNum >= fromCustVendAccountNum
                         && paymProposalLine.AccountNum <= toCustVendAccountNum))
                notExists join custVendTransOpen
                where spectrans.RefCompany == custVendTransOpen.DataAreaId
                    && spectrans.RefTableId == custVendTransOpen.TableId
                    && spectrans.RefRecId == custVendTransOpen.RecId

            {
                if (paymProposalLine)
                {
                    delete_from specTransToDelete
                        where specTransToDelete.RecId == specTrans.RecId;
                }
            }
        }
        else
        {
            while select crossCompany RecId from specTrans
                join RecId from paymProposalLine
                where paymProposalLine.JournalId == ledgerJournalTable.JournalNum
                    && specTrans.SpecCompany == paymProposalLine.DataAreaId
                    && specTrans.SpecTableId == paymProposalLine.TableId
                    && specTrans.SpecRecId == paymProposalLine.RecId
                    && ((fromCustVendAccountNum == '' && toCustVendAccountNum == '') ||
                         (paymProposalLine.AccountNum >= fromCustVendAccountNum
                          && paymProposalLine.AccountNum <= toCustVendAccountNum))
                notExists join custVendTransOpen
                where spectrans.RefCompany == custVendTransOpen.DataAreaId
                    && spectrans.RefTableId == custVendTransOpen.TableId
                    && spectrans.RefRecId == custVendTransOpen.RecId
            {
                if (paymProposalLine)
                {
                    delete_from specTransToDelete
                        where specTransToDelete.RecId == specTrans.RecId;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, #CurrentList, paymProposalCalcPaym.pack(), paymentProposalLineMap.pack(), partyIdsByDirectory.pack()];
        packed = this.appendVariableToPack(packed, varStr(voucherType_CN), voucherType_CN);
        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>appendVariableToPack</Name>
				<Source><![CDATA[
    private container appendVariableToPack(container _pack, str _variableName, anytype _value)
    {
        XppPrePostArgs packArgs = this.createXppPrePostArgsWithPack(_pack);
        SysPackExtensions::pack(packArgs, this.getVariablePackKey(_variableName), [_value]);
        return packArgs.getReturnValue();
    }

]]></Source>
			</Method>
			<Method>
				<Name>createXppPrePostArgsWithPack</Name>
				<Source><![CDATA[
    private XppPrePostArgs createXppPrePostArgsWithPack(container _pack)
    {
        XppPrePostArgs prePostArgs = new XppPrePostArgs(_pack, '',  XppEventHandlerCalledWhen::Post);
        prePostArgs.setReturnValue(_pack);
        return prePostArgs;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVariablePackKey</Name>
				<Source><![CDATA[
    private ClassName getVariablePackKey(str _variableName)
    {
        return classStr(CustVendPaymProposal) + '.' + _variableName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        int version = conPeek(_packedClass,1);
        container packedPaymProposalCalcPaym;
        container packedPaymentProposalLineMap;
        container packedPartyIdsByDirectory;

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList, packedPaymProposalCalcPaym, packedPaymentProposalLineMap, packedPartyIdsByDirectory] = _packedClass;

                if (!paymProposalCalcPaym)
                {
                    paymProposalCalcPaym = CustVendPaymProposalCalcPaym::construct(ledgerJournalTable.JournalType);
                }

                paymProposalCalcPaym.unpack(packedPaymProposalCalcPaym);

                paymentProposalLineMap = Map::create(packedPaymentProposalLineMap);
                partyIdsByDirectory = Map::create(packedPartyIdsByDirectory);

                voucherType_CN = this.extractPackedVariable(_packedClass, varStr(voucherType_CN));

                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>extractPackedVariable</Name>
				<Source><![CDATA[
    private anytype extractPackedVariable(container _pack, str _variableName)
    {
        anytype value;
        [value] = SysPackExtensions::unpack(this.createXppPrePostArgsWithPack(_pack), this.getVariablePackKey(_variableName));
        return value;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeBatchProcessTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>CustVendPaymProposalBatchProcess</c> with information from the payment proposal.
    /// </summary>
    /// <param name = "_proposal">
    /// The payment proposal.
    /// </param>
    /// <returns>
    /// The initialized <c>CustVendPaymProposalBatchProcess</c> buffer.
    /// </returns>
    internal static CustVendPaymProposalBatchProcess initializeBatchProcessTable(CustVendPaymProposal _proposal)
    {
        CustVendPaymProposalBatchProcess paymentProposalBatchProcess = CustVendPaymProposalBatchProcess::find(_proposal.ledgerJournalId(), true);

        paymentProposalBatchProcess.JournalId = _proposal.ledgerJournalId();
        paymentProposalBatchProcess.LedgerJournalType = _proposal.ledgerJournalType();
        paymentProposalBatchProcess.ModuleCustVend = _proposal.moduleCustVend();

        paymentProposalBatchProcess.IncludeInvoicesFromOtherCompanies = _proposal.parmIncludeInvoicesFromOtherCompanies();
        paymentProposalBatchProcess.CreatePaymPerInvoiceCompany = _proposal.parmCreatePaymPerInvoiceCompany();
        paymentProposalBatchProcess.LimitPaymCreationToLedgerCompanyOnly = _proposal.parmLimitPaymCreationToLedgerCompanyOnly();
        paymentProposalBatchProcess.DefaultOffsetAccountType = _proposal.parmDefaultOffsetAccountType();
        paymentProposalBatchProcess.DefaultOffsetAccount = _proposal.parmDefaultOffsetAccount();
        paymentProposalBatchProcess.DefaultOffsetLedgerDimension = _proposal.parmDefaultOffsetLedgerDimension();
        paymentProposalBatchProcess.ChangePaymMode = _proposal.parmChangePaymMode();
        paymentProposalBatchProcess.CanUseSpecTransSetBasedInsert = _proposal.parmCanUseSpecTransSetBasedInsert();
        paymentProposalBatchProcess.CanUseCustVendPaymProposalLineSetBasedInsert = _proposal.parmCanUseCustVendPaymProposalLineSetBasedInsert();

        return paymentProposalBatchProcess;

    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeFromBatchProcessTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the payment proposal from the payment journal.
    /// </summary>
    /// <param name = "_ledgerJournalId">
    /// Identifies the payment journal.
    /// </param>
    /// <returns>
    /// The payment proposal.
    /// </returns>
    internal static CustVendPaymProposal initializeFromBatchProcessTable(LedgerJournalId _ledgerJournalId)
    {
        CustVendPaymProposal proposal;

        CustVendPaymProposalBatchProcess paymentProposalBatchProcess = CustVendPaymProposalBatchProcess::find(_ledgerJournalId);
        if (paymentProposalBatchProcess)
        {
            proposal = CustVendPaymProposal::newLedgerJournal(_ledgerJournalId);

            proposal.parmIncludeInvoicesFromOtherCompanies(paymentProposalBatchProcess.IncludeInvoicesFromOtherCompanies);
            proposal.parmCreatePaymPerInvoiceCompany(paymentProposalBatchProcess.CreatePaymPerInvoiceCompany);
            proposal.parmLimitPaymCreationToLedgerCompanyOnly(paymentProposalBatchProcess.LimitPaymCreationToLedgerCompanyOnly);
            proposal.parmDefaultOffsetAccountType(paymentProposalBatchProcess.DefaultOffsetAccountType);
            proposal.parmDefaultOffsetAccount(paymentProposalBatchProcess.DefaultOffsetAccount);
            proposal.parmDefaultOffsetLedgerDimension(paymentProposalBatchProcess.DefaultOffsetLedgerDimension);
            proposal.parmChangePaymMode(paymentProposalBatchProcess.ChangePaymMode);
            proposal.parmCanUseSpecTransSetBasedInsert(paymentProposalBatchProcess.CanUseSpecTransSetBasedInsert);
            proposal.parmCanUseCustVendPaymProposalLineSetBasedInsert(paymentProposalBatchProcess.CanUseCustVendPaymProposalLineSetBasedInsert);

        }

        return proposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPaymentRequestLinkToPaymProposal</Name>
				<Source><![CDATA[
    protected void createPaymentRequestLinkToPaymProposal(CustVendPaymProposalLine _paymProposalLine, CFMPaymentRequestTable _paymentRequest)
    {
        if (_paymProposalLine && _paymentRequest)
        {
            CFMPaymentRequestPaymentLink::createReference(_paymentRequest.RecId, _paymProposalLine, this.parmIsGeneretedFromPaymentSchedule());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addPaymentRequest</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a payment request to the payment proposal.
    /// </summary>
    /// <param name="_paymentRequest">
    ///    The record buffer of the payment request to pay.
    /// </param>
    public void addPaymentRequest(CFMPaymentRequestTable _paymentRequest)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsGeneretedFromPaymentSchedule</Name>
				<Source><![CDATA[
    public boolean parmIsGeneretedFromPaymentSchedule(boolean _isGeneratedFromPaymentSchedule = isGeneratedFromPaymentSchedule)
    {
        isGeneratedFromPaymentSchedule = _isGeneratedFromPaymentSchedule;

        return isGeneratedFromPaymentSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removePaymentRequestLink</Name>
				<Source><![CDATA[
    protected void removePaymentRequestLink(CustVendPaymProposalLine _paymProposalLine, CustVendTransOpen _custVendTransOpen)
    {
        CFMPaymentRequestPaymentLink paymentRequestLink;
        CFMPaymentRequestTable paymentRequest;

        paymentRequest = CFMPaymentRequestTable::findPaymentRequestOnCustVendTransOpen(_custVendTransOpen);

        delete_from paymentRequestLink
            where paymentRequestLink.PaymentRequest == paymentRequest.RecId
               && paymentRequestLink.RefTableId == _paymProposalLine.TableId
               && paymentRequestLink.RefRecId == _paymProposalLine.RecId;

    }

]]></Source>
			</Method>
			<Method>
				<Name>PSNParmVendRoutingSlip</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>VendRoutingSlipId_PSN</c> parameter.
    /// </summary>
    /// <param name="_PSNVendRoutingSlipId">
    ///    The value to set; optional.
    /// </param>
    /// <returns>
    ///    The value of the <c>VendRoutingSlipId_PSN</c> parameter.
    /// </returns>
    public VendRoutingSlipId_PSN PSNParmVendRoutingSlip(VendRoutingSlipId_PSN _PSNVendRoutingSlipId = PSNVendRoutingSlipId)
    {
        PSNVendRoutingSlipId = _PSNVendRoutingSlipId;

        return PSNVendRoutingSlipId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToCustVendAccountNum</Name>
				<Source><![CDATA[
    public CustVendAC parmToCustVendAccountNum(CustVendAC _toCustVendAccountNum = toCustVendAccountNum)
    {
        toCustVendAccountNum = _toCustVendAccountNum;

        return toCustVendAccountNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromCustVendAccountNum</Name>
				<Source><![CDATA[
    public CustVendAC parmFromCustVendAccountNum(CustVendAC _fromCustVendAccountNum = fromCustVendAccountNum)
    {
        fromCustVendAccountNum = _fromCustVendAccountNum;

        return fromCustVendAccountNum;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>