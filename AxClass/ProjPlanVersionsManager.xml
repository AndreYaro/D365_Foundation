<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjPlanVersionsManager</Name>
	<SourceCode>
		<Declaration><![CDATA[
class ProjPlanVersionsManager
{
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>copyTaskSetActivityNumberDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate to set the activity number when a task is being copied.
    /// </summary>
    /// <param name = "_projPlanVersion">
    /// A <c>ProjPlanVersion</c> table buffer.
    /// </param>
    /// <param name = "_smmActivities">
    /// An empty <c>SmmActivities</c> table buffer.
    /// </param>
    /// <param name = "_psaActivitySetup">
    /// An empty <c>PsaActivitySetup</c> table buffer.
    /// </param>
    /// <param name = "_resultActivity">
    /// An <c>EventHandlerResult</c> class instance to provide a result if setting the activity number was handled. Respond with a value if it was handled.
    /// </param>
    static delegate void copyTaskSetActivityNumberDelegate(ProjPlanVersion _projPlanVersion,
        SmmActivities _smmActivities,
        PsaActivitySetup _psaActivitySetup,
        EventHandlerResult _resultActivity)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>publishVersionAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides wrapper for <c>ProjPlanVersionsManager</c> publishVersion method.
    /// </summary>
    /// <param name = "_params">Packed project id and version id for passing</param>
    /// <param name = "_cancellationToken">Cancellation token</param>
    public static void publishVersionAsync(container _params, System.Threading.CancellationToken _cancellationToken)
    {
        ProjId projId;
        ProjVersionId projVersionId;
        [projId, projVersionId] = _params;
        ProjPlanVersionsManager::publishVersion(projId, projVersionId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWBSRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delete <c>ProjPlanVersion</c> table record related WBS records.
    /// </summary>
    /// <param name = "_hierarchyTreeTable"><c>HierarchyTreeTable</c> forupdate table buffer.</param>
    /// <param name = "_smmActivities"><c>smmActivities</c> forupdate table buffer.</param>
    /// <param name = "_psaActivitySetup"><c>PSAActivitySetup</c> forupdate table buffer.</param>
    /// <param name = "_smmActivityParentType">smmActivity parent type.</param>
    /// <param name = "_refRecId">Table reference rec Id according to the smmActivity parent type.</param>
    private static void deleteWBSRecord(HierarchyTreeTable _hierarchyTreeTable, smmActivities _smmActivities,
        PSAActivitySetup _psaActivitySetup, smmActivityParentType _smmActivityParentType, RefRecId _refRecId)
    {
        _hierarchyTreeTable.delete();

        // remove this activity parent link from smmActivityParentLinkTable
        smmActivityParentLinkTable smmActivityParentLinkTable;
        delete_from smmActivityParentLinkTable
            where smmActivityParentLinkTable.ActivityNumber == _smmActivities.ActivityNumber
                && smmActivityParentLinkTable.ParentType == _smmActivityParentType
                && smmActivityParentLinkTable.RefRecId == _refRecId;

        // only remove this smmActivities record if it is only being used for this project
        smmActivityParentLinkTable.clear();
        smmActivities smmActivities;
        delete_from smmActivities
            where smmActivities.RecId == _smmActivities.RecId
            notexists join smmActivityParentLinkTable
                where smmActivityParentLinkTable.ActivityNumber == smmActivities.ActivityNumber;

        ProjDependency projDependency;
        // Use multiple delete calls to take advanages of indexes defined
        delete_from projDependency
                        where projDependency.Predecessor == _psaActivitySetup.ActivityNumber;
        delete_from projDependency
                        where projDependency.Successor == _psaActivitySetup.ActivityNumber;

        _psaActivitySetup.delete();
    }

]]></Source>
			</Method>
			<Method>
				<Name>cleanupPublishedHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes tasks from published hierarchy that were deleted in newer version.
    /// </summary>
    /// <param name = "_projPlanPublishedHierarchy">New published version hierarhcy id</param>
    /// <param name = "_publishedHierarchy">Published hierarchy id in the old data model</param>
    private static void cleanupPublishedHierarchy(HierarchyIdBase _projPlanPublishedHierarchy, HierarchyIdBase _publishedHierarchy)
    {
        HierarchyTreeTable hierarchyTreeTable;
        ProjPlanVersion projPlanVersion;
        smmActivities smmActivities;
        PSAActivitySetup psaActivitySetup;

        ProjTable project = ProjPlanVersionDetail::getProjTableByHierarchyId(_publishedHierarchy);

        while select forupdate hierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == _publishedHierarchy
            join forupdate ActivityNumber from smmActivities
                where hierarchyTreeTable.RefRecId == smmActivities.RecId
            join forupdate ActivityNumber from psaActivitySetup
                where psaActivitySetup.ActivityNumber == smmActivities.ActivityNumber
            notexists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                && projPlanVersion.HierarchyId == _projPlanPublishedHierarchy
        {
            ProjPlanVersionsManager::deleteWBSRecord(hierarchyTreeTable, smmActivities, psaActivitySetup,
                smmActivityParentType::Project, project.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelResourceAssignment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Cancel resource assignment from the tasks being deleted in the newer version.
    /// </summary>
    /// <param name = "_projPlanPublishedHierarchy">New published version hierarhcy id</param>
    /// <param name = "_publishedHierarchy">Published hierarchy id in the old data model</param>
    private static void cancelResourceAssignment(HierarchyIdBase _projPlanPublishedHierarchy, HierarchyIdBase _publishedHierarchy)
    {
        HierarchyTreeTable hierarchyTreeTable;
        ProjPlanVersion projPlanVersion;
        smmActivities smmActivities;
        ResAssignment resAssignment;
        
        while select hierarchyTreeTable
            where hierarchyTreeTable.HierarchyId == _publishedHierarchy
            join RecId from smmActivities
                where hierarchyTreeTable.RefRecId == smmActivities.RecId
            exists join resAssignment
                where smmActivities.RecId == resAssignment.Activity
            notexists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                && projPlanVersion.HierarchyId == _projPlanPublishedHierarchy
        {
            // Remove all scheduling assignment for this activity.
            ProjTask::cancelActivityAssignment(smmActivities.RecId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>publishVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Publishes the latest draft version for project work breakdown strucutre.
    /// </summary>
    /// <param name = "_projId">
    /// Project identifier.
    /// </param>
    /// <param name = "_projVersionId">
    /// Project work breakdown structure version identifier.
    /// Currently this field is no longer being used as it will always publish the latest draft version.
    /// This is done to avoid the system attmepts to published the same version multiple times.
    /// </param>
    /// <remarks>
    /// WBS publishing will not be executed if the latest draft version is not higher than the latest published version.
    /// </remarks>
    public static void publishVersion(ProjId _projId, ProjVersionId _projVersionId)
    {
        Hierarchy targetHierarchy = ProjPlanVersionsManager::getPublishedPlanHierarchy(_projId);
        ProjVersionId latestDraftVersion = ProjPlanVersionDetail::findLatestByProjId(_projId, false, false, ProjPlanVersionType::Draft).VersionId;
        ProjVersionId latestPublishedVersion = ProjPlanVersionDetail::findLatestByProjId(_projId, false, false, ProjPlanVersionType::PublishedCurrent).VersionId;
        if (latestDraftVersion > latestPublishedVersion
            && ProjPlanVersionsManager::allowPublishVersion(_projId))
        {
            ProjVersionId thisDraftVersion = latestDraftVersion;
            HierarchyIdBase versionHierarchyId = ProjPlanVersionDetail::getProjectVersionHierarchy(_projId, thisDraftVersion);

            ttsbegin;

            ProjPlanVersionDetail projPlanVersionDetail;

            ProjPlanVersionsManager::clearActivityNumbersFromEstimates(_projId);

            ProjPlanVersionsManager::cancelResourceAssignment(versionHierarchyId, targetHierarchy.HierarchyId);
            ProjPlanVersionsManager::cleanupPublishedHierarchy(versionHierarchyId, targetHierarchy.HierarchyId);
            ProjPlanVersionsManager::copyTasks(versionHierarchyId, targetHierarchy);
            
            // If there is other batch process which has published this version already, then abort this transaction.
            latestPublishedVersion = ProjPlanVersionDetail::findLatestByProjId(_projId, false, false, ProjPlanVersionType::PublishedCurrent).VersionId;
            if (latestPublishedVersion >= thisDraftVersion)
            {
                ttsabort;
            }
            else
            {
                ProjPlanVersionsManager::updateProjVersionDetailForPublishVersion(_projId, thisDraftVersion);
                
                boolean wbsFormLaunchEnhanceFlight = ProjWBSFormLaunchEnhancementFlight::instance().isEnabled();

                if (wbsFormLaunchEnhanceFlight)
                {
                    ProjPlanVersionsManager::deleteRecordsAssociateToPublishedOld(_projId);
                }

                ProjPlanVersionsManager::updateProjTeamData(versionHierarchyId);
                ProjPlanVersionSyncCopy::clearSyncTasksOnPublished(versionHierarchyId);
                ProjectWbsLockBox::clearOutCheckOutInfoOnPublish(versionHierarchyId);
                ttscommit;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowPublishVersion</Name>
				<Source><![CDATA[
    protected static boolean allowPublishVersion(ProjId _projId)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteRecordsAssociateToPublishedOld</Name>
				<Source><![CDATA[
    private static void deleteRecordsAssociateToPublishedOld(ProjId _projId)
    {
        ProjHierarchySorting hierarchySorting;
        ProjPlanVersionDetail planVersionDetail;

        // Remove outdated ProjHierarchySorting table records.
        delete_from hierarchySorting
            where hierarchySorting.Type == ProjHierarchySortingType::ProjWBS
        exists join planVersionDetail
            where planVersionDetail.HierarchyId == hierarchySorting.RefId
                && planVersionDetail.ProjId == _projId
                && planVersionDetail.VersionType == ProjPlanVersionType::PublishedOld;

        ProjWBSUserExpand wbsUserExpand;

        // Remove outdated ProjWBSUserExpand table records which will
        // also remove the associated ProjWBSUserExpandLine table records
        // because of the on delete cascade relation.
        delete_from wbsUserExpand
        exists join planVersionDetail
            where planVersionDetail.HierarchyId == wbsUserExpand.HierarchyId
                && planVersionDetail.ProjId == _projId
                && planVersionDetail.VersionType == ProjPlanVersionType::PublishedOld;

        // Remove outdated ProjPlanVersionAssignment table records.
        ProjPlanVersionAssignment planVersionAssignment;
        ProjPlanVersion planVersion;
        delete_from planVersionAssignment
            exists join planVersion
                where planVersion.RecId == planVersionAssignment.ProjPlanVersion
            exists join planVersionDetail
                where planVersionDetail.HierarchyId == planVersion.HierarchyId
                    && planVersionDetail.ProjId == _projId
                    && planVersionDetail.VersionType == ProjPlanVersionType::PublishedOld;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjVersionDetailForPublishVersion</Name>
				<Source><![CDATA[
    private static void updateProjVersionDetailForPublishVersion(ProjId _projId, ProjVersionId _projVersionId)
    {
        // Update the latest draft version to become the currently published version.

        ProjPlanVersionDetail ProjPlanVersionDetail;

        ttsbegin;
        update_recordset projPlanVersionDetail
            setting VersionType = ProjPlanVersionType::PublishedOld
            where projPlanVersionDetail.ProjId == _projId
                && projPlanVersionDetail.VersionType == ProjPlanVersionType::PublishedCurrent;

        projPlanVersionDetail.clear();

        select forupdate firstonly projPlanVersionDetail
            where projPlanVersionDetail.versionId == _projVersionId
               && projPlanVersionDetail.ProjId == _projId;
        
        if (projPlanVersionDetail)
        {
            projPlanVersionDetail.VersionType = ProjPlanVersionType::PublishedCurrent;
            projPlanVersionDetail.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearActivityNumbersFromEstimates</Name>
				<Source><![CDATA[
    private static void clearActivityNumbersFromEstimates(ProjId _projId)
    {
        #OCCRetryCount
        
        ProjPlanVersionDetail projPlanVersionDetail;
        select firstonly HierarchyId from projPlanVersionDetail
            where projPlanVersionDetail.ProjId == _projId
                && projPlanVersionDetail.VersionType == ProjPlanVersionType::PublishedCurrent;

        //
        // Update is being degraded to row by row due to code for quotations which is not relevent
        // in this code path. Set skipDataMethods() to improve performance.
        //
        PSAActivityEstimates psaActivityEstimates;
        psaActivityEstimates.skipDataMethods(true);
        psaActivityEstimates.skipDatabaseLog(true);
        psaActivityEstimates.skipEvents(true);

        try
        {
            update_recordset psaActivityEstimates
                setting ActivityNumber = ''
            where psaActivityEstimates.ProjPlanHierarchyId == projPlanVersionDetail.HierarchyId;
        }
        catch (Exception::Deadlock)
        {
            if (xSession::currentRetryCount() >= #RetryNum)
            {
                throw Exception::Deadlock;
            }
            else
            {
                retry;
            }
        }
        catch (Exception::Error)
        {
            throw Exception::Error;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canInsertActivitiesRecordsForCopyTaskOperation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether we can set <c>smmActivities</c> when a task is being copied.
    /// </summary>
    /// <param name = "_projPlanVersion">
    /// A <c>ProjPlanVersion</c> table buffer.
    /// </param>
    /// <param name = "_smmActivities">
    /// An empty <c>SmmActivities</c> table buffer.
    /// </param>
    /// <param name = "_psaActivitySetup">
    /// An empty <c>PsaActivitySetup</c> table buffer.
    /// </param>
    /// <returns>
    /// true to allow <c>smmActivities</c> and <c>PSAActivitySetup</c> records insertion during the copy task operation; otherwise, false.
    /// </returns>
    /// /// <remarks>
    /// This method is added for extensibility purpose. By default, it should always return true.
    /// </remarks>
    protected static boolean canInsertActivitiesRecordsForCopyTaskOperation(
        ProjPlanVersion _projPlanVersion,
        smmActivities _smmActivities,
        PSAActivitySetup _psaActivitySetup)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyTasks</Name>
				<Source><![CDATA[
    [HookableAttribute(true)]
    protected static void copyTasks(HierarchyIdBase _versionHierarchyId, Hierarchy _targetHierarchy)
    {
        var tasksQueue = new List(Types::Int64);
        var tasksSecondaryQueue = new List(Types::Int64);
        var parentMapping = ProjPlanVersionsManager::getParentMapping(_versionHierarchyId);

        ProjPlanVersion rootTask = ProjPlanVersion::getRootTask(_versionHierarchyId);
        tasksQueue.addEnd(rootTask.HierarchyTaskId);
        var tasksIterator = tasksQueue.getEnumerator();

        ProjTable projTable = ProjPlanVersionDetail::getProjTableByHierarchyId(_versionHierarchyId);

        while (true)
        {
            ttsbegin;

            while (tasksIterator.moveNext())
            {
                boolean smmActivitiesInsertion = true;
                EventHandlerResult eventHandlerResult = new EventHandlerResult();

                ProjPlanVersion projPlanVersion;
                select forupdate projPlanVersion
                    where projPlanVersion.HierarchyId == _versionHierarchyId
                       && projPlanVersion.HierarchyTaskId == tasksIterator.current();

                HierarchyTreeTable      hierarchyTreeTable;
                smmActivities           smmActivities;
                PSAActivitySetup        psaActivitySetup;

                if (parentMapping.exists(projPlanVersion.HierarchyTaskId))
                {
                    tasksSecondaryQueue.appendList(parentMapping.lookup(projPlanVersion.HierarchyTaskId));
                }

                if (projPlanVersion.HierarchyTreeTableRefRecId)
                {
                    select firstonly forupdate hierarchyTreeTable
                        where hierarchyTreeTable.RecId == projPlanVersion.HierarchyTreeTableRefRecId
                        join forupdate smmActivities
                            where smmActivities.RecId == hierarchyTreeTable.RefRecId
                            join forupdate psaActivitySetup
                            where psaActivitySetup.ActivityNumber == smmActivities.ActivityNumber;
                }

                boolean createNewRecord = hierarchyTreeTable && smmActivities && psaActivitySetup ? false : true;
                
                if (createNewRecord)
                {
                    hierarchyTreeTable.clear();
                    smmActivities.clear();
                    psaActivitySetup.clear();

                    hierarchyTreeTable.ElementNumber = NumberSeq::newGetNum(CompanyInfo::numRefElementNumber()).num();
                    hierarchyTreeTable.HierarchyId = _targetHierarchy.HierarchyId;
                    
                    ProjPlanVersionsManager::copyTaskSetActivityNumberDelegate(projPlanVersion, smmActivities, psaActivitySetup, eventHandlerResult);
                    smmActivitiesInsertion = !eventHandlerResult.hasResult() && ProjPlanVersionsManager::canInsertActivitiesRecordsForCopyTaskOperation(projPlanVersion, smmActivities, psaActivitySetup); // Call the function only if the delagate is not being used.

                    if (smmActivitiesInsertion)
                    {
                        smmActivities.initValue(smmActivityCategory::Task);
                        smmActivities.setActivityNum();
                    }

                    psaActivitySetup.ActivityNumber = smmActivities.ActivityNumber;
                    psaActivitySetup.HierarchyId = _targetHierarchy.HierarchyId;
                }

                ProjPlanVersionsManager::copyActivityData(projPlanVersion, hierarchyTreeTable, smmActivities, psaActivitySetup);
                ProjPlanVersionsManager::copyActivityNumberToEstimates(projPlanVersion.HierarchyId ,projPlanVersion.HierarchyTaskId , smmActivities.ActivityNumber);
                ProjPlanVersionsManager::copyHierarchyData(projPlanVersion, hierarchyTreeTable);

                boolean hasDraftAssignmentCancelRecord = ProjPlanVersionAssignment::hasCancelation(projPlanVersion.RecId);

                if (createNewRecord)
                {
                    if (smmActivitiesInsertion)
                    {
                        smmActivities.insert();
                    }

                    if (!smmActivityParentLinkTable::existsByActivityAndParent(smmActivities.ActivityNumber, smmActivityParentType::Project, projTable.RecId, projTable.TableId))
                    {
                        smmActivityParentLink::insertLink(smmActivities.ActivityNumber, smmActivityParentType::Project, projTable.RecId, true);
                    }

                    if (smmActivitiesInsertion)
                    {
                        psaActivitySetup.insert();
                    }

                    ProjPlanVersionsManager::updateProjPlanVersionFromNewHierarchyTree(smmActivities,
                                                                                       projPlanVersion,
                                                                                       hierarchyTreeTable);
                }
                else
                {
                    hierarchyTreeTable.update();
                    smmActivities.update();

                    //Do not perform move assignment if it this task has draft cancelation scheduling assignment.
                    psaActivitySetup.update(hasDraftAssignmentCancelRecord);
                }

                boolean draftAssignmentExists = ProjPlanVersionAssignment::hasProjPlanVersion(projPlanVersion.RecId);

                // Remove task assignment if task effort is zero or cancel draft records exists.
                if (!psaActivitySetup.Effort || (draftAssignmentExists && hasDraftAssignmentCancelRecord))
                {
                    ProjTask::cancelActivityAssignment(smmActivities.RecId);
                }

                // Reserve WBS draft task resource assignment.
                if (draftAssignmentExists)
                {
                    if (psaActivitySetup.Effort)
                    {
                        str assignedResourceNames, assignedResourceRecIds;
                        [assignedResourceNames, assignedResourceRecIds] = ProjTask::getAssignedResourcesPerDraftActivity(projPlanVersion.RecId);
                        ProjTask::reserveResourceActivity(smmActivities.RecId, assignedResourceRecIds,
                            psaActivitySetup.PSASchedStart, PSAActivitySetup.PSASchedEnd, PSAActivitySetup.Effort, true);
                    }

                    ProjPlanVersionAssignment::deleteByProjPlanVersion(projPlanVersion.RecId);
                }

                ProjPlanVersionsManager::updateProjActivityCategory(smmActivities.ActivityNumber, projPlanVersion.TaskCategory, projPlanVersion.IsCategoryMandatory);
            }
    
            ttscommit;

            if (tasksSecondaryQueue.elements() > 0)
            {
                tasksQueue = tasksSecondaryQueue;
                tasksSecondaryQueue = new List(Types::Int64);
                tasksIterator = tasksQueue.getEnumerator();
            }
            else
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjActivityCategory</Name>
				<Source><![CDATA[
    private static void updateProjActivityCategory(ProjActivityId _projActivityId, ProjCategoryId _projCategoryId, NoYesId _projCategoryMandatory)
    {
        ProjActivity projActivityLocal = ProjActivity::find(_projActivityId, true);
        if (projActivityLocal)
        {
            //
            // Update is running code for Shop floor control which is not relevent to this code path.
            // Set skipDataMethods() to improve performance.
            //
            projActivityLocal.skipDataMethods(true);
            projActivityLocal.CategoryDefault = _projCategoryId;
            projActivityLocal.Mandatory = _projCategoryMandatory;
            projActivityLocal.update();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildTask</Name>
				<Source><![CDATA[
    private static boolean hasChildTask(HierarchyIdBase _hierarchyId)
    {
        boolean hasChildTask = false;
        ProjPlanVersion projPlanVersion;

        select count(RecId) from projPlanVersion
            where projPlanVersion.HierarchyId == _hierarchyId;

        if ((projPlanVersion) && (projPlanVersion.RecId > 1))
        {
            hasChildTask = true;
        }

        return hasChildTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTeamData</Name>
				<Source><![CDATA[
    private static void updateProjTeamData(HierarchyIdBase _versionHierarchyId)
    {
        ProjTable projTable = ProjTable::find(ProjPlanVersionDetail::getProjTableByHierarchyId(_versionHierarchyId).ProjId, true);
        ProjPlanVersion projPlanVersion = ProjPlanVersion::getRootTask(_versionHierarchyId);

        if (projTable &&  projPlanVersion)
        {
            ttsbegin;
            //If this WBS has child task, then update ProjTable scheduling properties according
            //to the root task properties. Else updates ProjTable scheduling properties according
            //to the reservation records booking records.
            if (ProjPlanVersionsManager::hasChildTask(_versionHierarchyId))
            {
                projTable.PSASchedStartDate = projPlanVersion.TaskStartDate;
                projTable.PSASchedEndDate = projPlanVersion.TaskFinishDate;
                projTable.PSASchedEffort = projPlanVersion.TaskEffort;
                projTable.PSASchedDuration = projPlanVersion.TaskDuration;
                projTable.updateSchedulingStatus(true);
            }
            else
            {
                projTable = ProjTable::setProjectSchedulingProperties(projTable, projPlanVersion.TaskStartDate, projPlanVersion.TaskFinishDate);
                projTable.update();
                projTable.updateSchedulingStatus(false);
            }
            
            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyActivityData</Name>
				<Source><![CDATA[
    protected static void copyActivityData(   ProjPlanVersion     _projPlanVersion,
                                            HierarchyTreeTable  _hierarchyTreeTable,
                                            smmActivities       _smmActivities,
                                            PSAActivitySetup    _psaActivitySetup)
    {
        _hierarchyTreeTable.Name            = _projPlanVersion.TaskName;
        _hierarchyTreeTable.SiblingNumber   = _projPlanVersion.TaskSiblingNumber;
        _hierarchyTreeTable.ElementNodeType = ElementNodeType::Activity;
        _smmActivities.Purpose              = _projPlanVersion.TaskName;
        _smmActivities.UserMemo             = _projPlanVersion.UserMemo;
        _smmActivities.TaskPriority         = _projPlanVersion.TaskPriority;
        _smmActivities.ActivityTaskTimeType = _projPlanVersion.ActivityTaskTimeType;
        _smmActivities.PSAMandatory         = _projPlanVersion.IsCategoryMandatory;
        _smmActivities.StartDateTime        = DateTimeUtil::newDateTime(_projPlanVersion.TaskStartDate, 0, DateTimeUtil::getUserPreferredTimeZone());
        _smmActivities.EndDateTime          = DateTimeUtil::newDateTime(_projPlanVersion.TaskFinishDate, timeMax(), DateTimeUtil::getUserPreferredTimeZone());
        _psaActivitySetup.Effort            = _projPlanVersion.TaskEffort;
        _psaActivitySetup.ActivityDuration  = _projPlanVersion.TaskDuration;
        _psaActivitySetup.PSASchedStart     = _projPlanVersion.TaskStartDate;
        _psaActivitySetup.PSASchedEnd       = _projPlanVersion.TaskFinishDate;
        _psaActivitySetup.CategoryDefault   = _projPlanVersion.TaskCategory;
        _psaActivitySetup.EffortAtComplete  = _projplanversion.TaskEffortAtComplete;
        _psaActivitySetup.CostAtComplete    = _projPlanVersion.TaskCostAtComplete;
        _psaActivitySetup.NumberOfResources = _projPlanVersion.NumberOfResources;
        _psaActivitySetup.ResourceCategory  = _projPlanVersion.ResourceCategory;
        _psaActivitySetup.HierarchyId       = _hierarchyTreeTable.HierarchyId;
        _psaActivitySetup.Mandatory         = _projPlanVersion.IsCategoryMandatory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyHierarchyData</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set hierarchy data according to the specified <c>ProjPlanVersion</c> record data.
    /// </summary>
    /// <param name = "_projPlanVersion">The sepcified <c>ProjPlanVersion</c> table buffer to setup the hierarchy data from.</param>
    /// <param name = "_hierarchyTreeTable">The specified <c>HierarchyTreeTable</c> table buffer to seupt the hierarchy data to.</param>
    private static void copyHierarchyData(ProjPlanVersion _projPlanVersion, HierarchyTreeTable _hierarchyTreeTable)
    {
        if (_projPlanVersion.ParentHierarchyTaskId)
        {
            ProjPlanVersion parentProjPlanVersion;
            select firstonly HierarchyTreeTableRefRecId from parentProjPlanVersion
                where parentProjPlanVersion.HierarchyTaskId == _projPlanVersion.ParentHierarchyTaskId
                    && parentProjPlanVersion.HierarchyId == _projPlanVersion.HierarchyId;

            HierarchyTreeTable parentHierarchyTreeTable;
            select firstonly ElementNumber, Level, Path from parentHierarchyTreeTable
                where parentHierarchyTreeTable.RecId == parentProjPlanVersion.HierarchyTreeTableRefRecId;

            _hierarchyTreeTable.ParentElementNumber = parentHierarchyTreeTable.ElementNumber;
            _hierarchyTreeTable.Path = parentHierarchyTreeTable.Path + _hierarchyTreeTable.ElementNumber + "#";
            _hierarchyTreeTable.Level = _projPlanVersion.HierarchyLevel;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentMapping</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a map associating the HierarchyTaskId of a summary task with a list of the HierarchyTaskIds of its children.
    /// </summary>
    /// <param name = "_versionHierarchyId">HierarchyId to construct the mapping for.</param>
    /// <returns>The mapping between parent and children.</returns>
    private static Map getParentMapping(HierarchyIdBase _versionHierarchyId)
    {
        var parentMapping = new Map(Types::Int64, Types::Class);

        ProjPlanVersion projPlanVersion;
        while select HierarchyTreeTableRefRecId, HierarchyTaskId, ParentHierarchyTaskId from projPlanVersion
            where projPlanVersion.HierarchyId == _versionHierarchyId
        {
            var parentTaskId = projPlanVersion.ParentHierarchyTaskId;
            if (!parentMapping.exists(parentTaskId))
            {
                parentMapping.insert(parentTaskId, new List(Types::Int64));
            }

            List children = parentMapping.lookup(parentTaskId);
            children.addEnd(projPlanVersion.HierarchyTaskId);
        }
        return parentMapping;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPublishedPlanHierarchy</Name>
				<Source><![CDATA[
    private static Hierarchy getPublishedPlanHierarchy(ProjId _projId)
    {
        Hierarchy hierarchy;

        ProjTable projTable = ProjTable::find(_projId);
        HierarchyLinkTable hierarchyLinkTable = HierarchyLinkTable::findRefTableRecId(tableNum(ProjTable), projTable.RecId);
        if (hierarchyLinkTable == null)
        {
            HierarchyCreate hierarchyCreate = HierarchyCreate::construct(HierarchyType::Project);
            hierarchyCreate.parmSourceCommon(projTable);
            hierarchyCreate.run();
            hierarchy = hierarchyCreate.parmHierarchy();
        }
        else
        {
            hierarchy = Hierarchy::find(hierarchyLinkTable.HierarchyId);
        }
        return hierarchy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDraft</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a draft version for the newly created project.
    /// </summary>
    /// <param name = "_hierarchyId">The Hierarchy id of the newly creted draft version.</param>
    /// <param name = "_rootName">Root task name.</param>
    /// <param name = "_startDate">Start date.</param>
    /// <param name = "_endDate">End date.</param>
    /// <param name = "_projId">Project ID.</param>
    public static void createDraft( HierarchyIdBase _hierarchyId,
                                    ProjTaskName    _rootName,
                                    SchedFromDate   _startDate = ProjPlanVersionsManager::defaultDate(),
                                    SchedToDate     _endDate   = ProjPlanVersionsManager::defaultDate(),
                                    ProjId          _projId    = '')
    {
        ProjPlanVersionsManager::createDraftVersion(_hierarchyId, _rootName, false, _startDate, _endDate, _projId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>discardDraft</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes draft project plan for the specified project.
    /// </summary>
    /// <param name = "_projId">Project id</param>
    public static void discardDraft(ProjId _projId)
    {
        ProjPlanVersionDetail draftProjPlanVersionDetail = ProjPlanVersionDetail::findProjectDraftVersion(_projId);
        ProjPlanVersionAssignment::deleteByHierarchyId(draftProjPlanVersionDetail.HierarchyId);
        ProjPlanVersionsManager::deleteVersion(draftProjPlanVersionDetail);
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteWBSByHierarchyId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all work breakdown structure (WBS) related records by the specified hierarchy identifier.
    /// </summary>
    /// <param name = "_hierarchyId">The ID of the hierarchy for which all WBS should be deleted.</param>
    public static void deleteWBSByHierarchyId(HierarchyIdBase _hierarchyId)
    {
        ProjPlanVersionDetail projPlanVersionDetail = ProjPlanVersionDetail::findByHierarchyId(_hierarchyId);

        if (projPlanVersionDetail)
        {
            ProjPlanVersionsManager::deleteVersion(projPlanVersionDetail);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteVersion</Name>
				<Source><![CDATA[
    private static void deleteVersion(ProjPlanVersionDetail _versionDetail)
    {
        ttsbegin;

        ProjPlanVersion projPlanVersion;
        delete_from projPlanVersion
            where projPlanVersion.HierarchyId == _versionDetail.HierarchyId;

        ProjDependency projDependency;
        delete_from projDependency
            where projDependency.ProjPlanHierarchyId == _versionDetail.HierarchyId;

        PSAActivityEstimates psaActivityEstimates;
        delete_from psaActivityEstimates
            where psaActivityEstimates.ProjPlanHierarchyId == _versionDetail.HierarchyId;

        _versionDetail.selectForUpdate(true);
        _versionDetail.delete();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteAllProjWBSVersions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Deletes all versions of a project work breakdown structure (WBS).
    /// </summary>
    /// <param name = "_projId">The ID of the project for which all WBS versions should be deleted.</param>
    public static void deleteAllProjWBSVersions(ProjId _projId)
    {
        ttsbegin;

        ProjPlanVersionDetail projPlanVersionDetail;

        // Delete all task records associated with this project
        ProjPlanVersion projPlanVersion;
        delete_from projPlanVersion
            exists join projPlanVersionDetail
            where projPlanVersionDetail.ProjId == _projId
                && projPlanVersion.HierarchyId == projPlanVersionDetail.HierarchyId;
  
        // Delete dependency edges associated with this project
        ProjDependency projDependency;
        delete_from projDependency
            exists join projPlanVersionDetail
            where projPlanVersionDetail.ProjId == _projId
                && projDependency.ProjPlanHierarchyId == projPlanVersionDetail.HierarchyId;

        // Delete all estimate records associated with this project
        PSAActivityEstimates psaActivityEstimates;
        delete_from psaActivityEstimates
            exists join projPlanVersionDetail
            where projPlanVersionDetail.ProjId == _projId
                && psaActivityEstimates.ProjPlanHierarchyId == projPlanVersionDetail.HierarchyId;

        delete_from projPlanVersionDetail
                where projPlanVersionDetail.ProjId == _projId;

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTemplateHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates template hierarchy.
    /// </summary>
    /// <param name = "_hierarchyId">HierarchyId</param>
    /// <param name = "_rootName">Root task name</param>
    public static void createTemplateHierarchy( HierarchyIdBase _hierarchyId, ProjTaskName _rootName)
    {
        ProjPlanVersionsManager::createDraftVersion(_hierarchyId, _rootName, true, ProjPlanVersionsManager::defaultDate(), ProjPlanVersionsManager::defaultDate(), "");
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDraftVersion</Name>
				<Source><![CDATA[
    protected static void createDraftVersion( HierarchyIdBase _hierarchyId,
                                    ProjTaskName    _rootName,
                                    boolean         _isTemplate,
                                    SchedFromDate   _startDate = ProjPlanVersionsManager::defaultDate(),
                                    SchedToDate     _endDate   = ProjPlanVersionsManager::defaultDate(),
                                    ProjId          _projId    = "")
    {
        if (!_hierarchyId)
        {
            return;
        }

        ttsbegin;

        ProjPlanVersionDetail projPlanVersionDetail;
        projPlanVersionDetail.HierarchyId = _hierarchyId;
        projPlanVersionDetail.VersionType = ProjPlanVersionType::Draft;
        projPlanVersionDetail.VersionId = 1.0;
        projPlanVersionDetail.ProjId = _projId;
        projPlanVersionDetail.IsTemplate = _isTemplate ? NoYes::Yes : NoYes::No;
        if (projPlanVersionDetail.validateWrite())
        {
            projPlanVersionDetail.insert();
        }
        
        // Get calendar ID.
        ProjWBSType wbsType = projPlanVersionDetail.getWBSType();

        CalendarId calendarId;
        if (wbsType == ProjWBSType::Project)
        {
            calendarId = ProjTable::find(_projId).PSASchedCalendarId;
        }
        else if (wbsType == ProjWBSType::ProjectQuotation)
        {
            SalesQuotationTable quotationTable;
            HierarchyLinkTable hierarchyLinkTable;

            select firstonly PSASchedCalendarId from quotationTable
                exists join hierarchyLinkTable
                    where hierarchyLinkTable.RefRecId == quotationTable.RecId
                        && hierarchyLinkTable.RefTableId == quotationTable.TableId;

            calendarId = quotationTable.PSASchedCalendarId;
        }

        ProjPlanVersion projPlanVersion = ProjPlanVersionsManager::initializeRootTask(_hierarchyId,
                                                                                      _rootName,
                                                                                      _startDate,
                                                                                      _endDate,
                                                                                      calendarId);

        if (projPlanVersion.validateWrite())
        {
            projPlanVersion.insert();
        }

        ProjHierarchySorting projHierarchySorting;
        projHierarchySorting.Type = ProjHierarchySortingType::ProjWBS;
        projHierarchySorting.RefId = ProjPlanVersionDetail.HierarchyId;
        projHierarchySorting.RefNodeId = ProjPlanVersionDetail::rootTaskId();
        projHierarchySorting.zeroAllHierarchyLevels();
        if (projHierarchySorting.validateWrite())
        {
            projHierarchySorting.insert();
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeRootTask</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the root <c>ProjPlanVersion</c> record.
    /// </summary>
    /// <param name = "_hierarchyId">Hierarchy Id of the Wbs</param>
    /// <param name = "_rootName">Task name of the root task</param>
    /// <param name = "_isTemplate">true if hierarchy is a Wbs template, otherwise false</param>
    /// <param name = "_startDate">Start date of the Wbs</param>
    /// <param name = "_endDate">Start date of the Wbs</param>
    /// <param name = "_calendarId">Calendar Id used in Project or Quotation</param>
    /// <returns>A <c>ProjPlanVersion</c> buffer.</returns>
    protected static ProjPlanVersion initializeRootTask(HierarchyIdBase _hierarchyId,
                                                        ProjTaskName    _rootName,
                                                        SchedFromDate   _startDate,
                                                        SchedToDate     _endDate,
                                                        CalendarId      _calendarId)
    {
        ProjPlanVersion projPlanVersion;

        projPlanVersion.TaskName = _rootName;
        projPlanVersion.TaskSiblingNumber = 0;
        projPlanVersion.PathId = '';
        projPlanVersion.HierarchyLevel = 0;
        projPlanVersion.EndNode = FalseTrue::True;
        projPlanVersion.HierarchyId = _hierarchyId;
        projPlanVersion.HierarchyTaskId = ProjPlanVersionDetail::rootTaskId();
        projPlanVersion.TaskStartDate = _startDate;
        projPlanVersion.TaskFinishDate = _endDate;
        projPlanVersion.ParentHierarchyTaskId = 0;

        if (_calendarId)
        {
            projPlanVersion.TaskDuration = WorkCalendarCalculator::calcDuration(_startDate, _endDate, _calendarId);
        }
        else
        {
            projPlanVersion.TaskDuration = _endDate - _startDate + 1;
        }

        projPlanVersion.NumberOfResources = 1;
        projPlanVersion.HierarchyTreeTableRefRecId = HierarchyTreeTable::findRootLevelNode(_hierarchyId).RecId;

        return projPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDraftFromPublishedVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a draft version from the specified published version.
    /// </summary>
    /// <param name = "_projId">Project ID.</param>
    /// <param name = "_projVersionId">Published version ID.</param>
    /// <returns>The Hierarchy ID of the new version.</returns>
    public static HierarchyIdBase createDraftFromPublishedVersion(ProjId _projId, ProjVersionId _projVersionId)
    {
        HierarchyIdBase destHierarchyId;
        ProjVersionId latestPublishedVersion = ProjPlanVersionDetail::findLatestByProjId(_projId, false, false, ProjPlanVersionType::PublishedCurrent).VersionId;

        if (latestPublishedVersion > _projVersionId)
        {
            checkFailed(strFmt("@Proj:WBSAlreadyPublished"));
            return destHierarchyId;
        }

        destHierarchyId = NumberSeq::newGetNum(CompanyInfo::numRefHierarchyId()).num();

        HierarchyIdBase sourceHierarhyId = ProjPlanVersionDetail::getProjectVersionHierarchy(_projId, _projVersionId);

        ttsbegin;

        ProjPlanVersionDetail projPlanVersionDetail;
        projPlanVersionDetail.HierarchyId = destHierarchyId;
        projPlanVersionDetail.VersionType = ProjPlanVersionType::Draft;
        projPlanVersionDetail.VersionId = _projVersionId + 1;
        projPlanVersionDetail.ProjId = _projId;
        projPlanVersionDetail.insert();

        ProjPlanVersionsManager::copyHierarchy(sourceHierarhyId, destHierarchyId);

        ttscommit;

        return destHierarchyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>defaultDate</Name>
				<Source><![CDATA[
    private static SchedDate defaultDate()
    {
        ProjPlanVersion projPlanVersion;
        return projPlanVersion.TaskStartDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Copies tasks from hierarchy to hierarchy.
    /// </summary>
    /// <param name = "_sourceHierarhyId">Source hierarchy ID.</param>
    /// <param name = "_destHierarchyId">Destinantion hierarchy ID.</param>
    /// <param name = "_copyRoot">Specifies if hierarchy root task should be copied. Default is set to true; optional.</param>
    /// <param name = "_copySmmActivityLinks">Specifies if links to <c>smmActivities</c>should be copied. Default is set to true; optional.</param>
    public static void copyHierarchy(HierarchyIdBase _sourceHierarhyId, HierarchyIdBase _destHierarchyId, boolean _copyRoot = true, boolean _copySmmActivityLinks = true)
    {
        ProjPlanVersionsManagerDataContract versionsDataContract = new ProjPlanVersionsManagerDataContract();
        versionsDataContract.parmHierarchyId(_sourceHierarhyId);

        ProjPlanVersionsManagerInstance versionsInstance = new ProjPlanVersionsManagerInstance();
        versionsInstance.copyHierarchyByDataContract(versionsDataContract, _destHierarchyId, _copyRoot, _copySmmActivityLinks);
    }

]]></Source>
			</Method>
			<Method>
				<Name>preImportHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs setup and validation required before importing the given hierarchy into the other.
    /// </summary>
    /// <param name = "_sourceHierarchyId">Id of the hierarchy to be imported.</param>
    /// <param name = "_destHierarchyId">Id of the hierarchy to import into.</param>
    /// <param name = "_parentTaskId">Id of the task under which to import the hierarchy.</param>
    /// <returns>true if the import operation will succeed, otherwise, false.</returns>
    public static boolean preImportHierarchy(
        HierarchyIdBase _sourceHierarchyId,
        HierarchyIdBase _destHierarchyId,
        ProjHierarchyTaskId _parentTaskId)
    {
        // Perform migration on hierarchies if necessary
        if (ProjPlanVersionDataMigration::hierarchyRequiresMigration(_sourceHierarchyId))
        {
            ProjPlanVersionDataMigration::performMigrationForHierarchy(_sourceHierarchyId);
        }
        if (ProjPlanVersionDataMigration::hierarchyRequiresMigration(_destHierarchyId))
        {
            ProjPlanVersionDataMigration::performMigrationForHierarchy(_destHierarchyId);
        }

        // Get the task we're importing under
        ProjPlanVersion parentTask = ProjPlanVersion::findByHierarchyAndTaskId(_destHierarchyId, _parentTaskId, true);

        // Make sure that this import operation doesn't break the built-in ProjHierarchySorting depth limit
        int sourceHierarchyMaxDepth = ProjPlanVersion::getMaxHierarchyLevel(_sourceHierarchyId);
        if (parentTask.HierarchyLevel + sourceHierarchyMaxDepth + 1 > ProjHierarchySorting::getSchemaMaxHierarchyLevel())
        {
            checkFailed(strFmt("@ProjPlan:ErrorImportHierarchyTooDeep", ProjHierarchySorting::getSchemaMaxHierarchyLevel(), sourceHierarchyMaxDepth + 1, parentTask.PathId, parentTask.TaskName));
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getImportedTaskId</Name>
				<Source><![CDATA[
    private static ProjHierarchyTaskId getImportedTaskId(
        ProjHierarchyTaskId _sourceTaskId,
        ProjHierarchyTaskId _taskIdOffset)
    {
        return _sourceTaskId - ProjPlanVersionDetail::rootTaskId() + _taskIdOffset;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importProjHierarchySortingRecords</Name>
				<Source><![CDATA[
    private static void importProjHierarchySortingRecords(
        HierarchyIdBase _sourceHierarchyId,
        HierarchyIdBase _destHierarchyId,
        ProjHierarchySorting _importRootSortingRecord,
        ProjHierarchyTaskId _sourceRootTaskId,
        ProjHierarchyTaskId _taskIdOffset,
        int _rootSiblingNumberOffset,
        int _hierarchyLevelOffset,
        int _maxSourceHierarchyDepth)
    {
        RecordInsertList projHierarchySortingInsertList = new RecordInsertList(tableNum(ProjHierarchySorting), true, true, true, true, true);
        ProjHierarchySorting sourceSorting;

        while select sourceSorting where
            sourceSorting.Type == ProjHierarchySortingType::ProjWBS
            && sourceSorting.RefId == _sourceHierarchyId
            && sourceSorting.RefNodeId != _sourceRootTaskId
        {
            ProjHierarchySorting destSorting;
            destSorting.data(sourceSorting);
            destSorting.RefId = _destHierarchyId;
            destSorting.RefNodeId = ProjPlanVersionsManager::getImportedTaskId(sourceSorting.RefNodeId, _taskIdOffset);
            destSorting.HierarchyLevel1 += _rootSiblingNumberOffset;
            destSorting.insertSortLevelsFront(_hierarchyLevelOffset, _maxSourceHierarchyDepth, _importRootSortingRecord);

            projHierarchySortingInsertList.add(destSorting);
        }

        ttsbegin;
        projHierarchySortingInsertList.insertDatabase();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allowOrderByHierarchyLevelForImportingQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Allow order by hierarchy level field for the <c>ProjPlanVersion</c> table query for importing.
    /// </summary>
    /// <returns>true to allow order by hierarchy level field for <c>ProjPlanVersion</c> query; otherwise, false.</returns>
    protected static boolean allowOrderByHierarchyLevelForImportingQuery()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProjPlanVersionQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialization fo query object for <c>ProjPlanVersion</c> table buffer.
    /// </summary>
    /// <param name = "_sourcePublishedHierarchyId">
    /// Id of the source published hierarchy.
    /// </param>
    /// <returns>
    /// An initialized query object.
    /// </returns>
    protected static Query initProjPlanVersionQuery(HierarchyIdBase _sourcePublishedHierarchyId)
    {
        Query query = new Query();
        QueryBuildDataSource qbdsProjPlanVersion = query.addDataSource(tableNum(ProjPlanVersion));
        qbdsProjPlanVersion.addRange(fieldNum(ProjPlanVersion, HierarchyId)).value(queryValue(_sourcePublishedHierarchyId));
        qbdsProjPlanVersion.addRange(fieldNum(ProjPlanVersion, ParentHierarchyTaskId)).value(SysQuery::valueNotEmptyString());

        if (ProjPlanVersionsManager::allowOrderByHierarchyLevelForImportingQuery())
        {
            qbdsProjPlanVersion.addOrderByField(fieldNum(ProjPlanVersion, HierarchyLevel), SortOrder::Descending);
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjPlanVersionIntoDestination</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports a hierarchy into another one under the specified node.
    /// </summary>
    /// <param name = "_destinationRecord">
    /// An instance of <c>ProjPlanVersion</c>.
    /// </param>
    protected static void insertProjPlanVersionIntoDestination(ProjPlanVersion _destinationRecord)
    {
        _destinationRecord.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>importProjPlanVersionRecords</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports a hierarchy into another one under the specified node.
    /// </summary>
    /// <param name = "_sourcePublishedHierarchyId">
    /// Id of the source published hierarchy.
    /// </param>
    /// <param name = "_destHierarchyId">
    /// Id of the destination hierarchy.
    /// </param>
    /// <param name = "_sourceHierarchy">
    /// Id of the hierarchy to be imported
    /// </param>
    /// <param name = "_destCalendarId">
    /// Id of the destination calender.
    /// </param>
    /// <param name = "_destSalesQuotationTable">
    /// An instance of <c>SalesQuotationTable</c> table buffer.
    /// </param>
    /// <param name = "_importRoot">
    /// An instance of <c>ProjPlanVersion</c> table buffer.
    /// </param>
    /// <param name = "_taskIdOffset">
    /// ID of the project hierarchy task.
    /// </param>
    /// <param name = "_rootSiblingNumberOffset">
    /// a root sibiling offset number.
    /// </param>
    /// <returns>
    /// A list of all HierarchyTaskIds for the newly created tasks.
    /// </returns>
    private static List importProjPlanVersionRecords(
        HierarchyIdBase _sourcePublishedHierarchyId,
        HierarchyIdBase _destHierarchyId,
        Hierarchy _sourceHierarchy,
        CalendarId _destCalendarId,
        SalesQuotationTable _destSalesQuotationTable,
        ProjPlanVersion _importRoot,
        ProjHierarchyTaskId _taskIdOffset,
        int _rootSiblingNumberOffset)
    {
        List newTasks = new List(Types::Int64);
        ProjTable destProjTable     = HierarchyLinkTable::findAssociation(ProjPlanVersionDetail::getOldDataModelPublishedHierarchyId(_destHierarchyId), tableNum(ProjTable));

        ttsbegin;
        Query query = ProjPlanVersionsManager::initProjPlanVersionQuery(_sourcePublishedHierarchyId);
        QueryRun queryRun = new queryRun(query);

        while (queryRun.next())
        {
            ProjPlanVersion sourceProjPlanVersion = queryRun.get(tableNum(ProjPlanVersion));
            
            ProjPlanVersion destProjPlanVersion = ProjPlanVersionsManager::initProjPlanFromSourceVersion(
                sourceProjPlanVersion,
                _destHierarchyId,
                _sourceHierarchy,
                _destCalendarId,
                _destSalesQuotationTable,
                _importRoot,
                _taskIdOffset,
                _rootSiblingNumberOffset);

            ProjPlanVersionsManager::insertProjPlanVersion(destProjPlanVersion,
                                                          sourceProjPlanVersion,
                                                          _destSalesQuotationTable,
                                                          destProjTable,
                                                          _importRoot,
                                                          _taskIdOffset);

            newTasks.addEnd(destProjPlanVersion.HierarchyTaskId);
        }
        ttscommit;

        return newTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertProjPlanVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts <c>ProjPlanVersion</c> table records.
    /// </summary>
    /// <param name = "_destProjPlanVersion">An instance of <c>ProjPlanVersion</c> as the destination project plan.</param>
    /// <param name = "_sourceProjPlanVersion">An instance of <c>ProjPlanVersion</c> as the source project plan.</param>
    /// <param name = "_destSalesQuotationTable">An instance of <c>SalesQuotationTable</c> table buffer.</param>
    /// <param name = "_destProjTable">An instance of <c>ProjTable</c> table buffer.</param>
    /// <param name = "_importRoot">An instance of <c>ProjPlanVersion</c> table buffer.</param>
    /// <param name = "_taskIdOffset">ID of the project hierarchy task.</param>
    protected static void insertProjPlanVersion(ProjPlanVersion        _destProjPlanVersion,
                                                ProjPlanVersion        _sourceProjPlanVersion,
                                                SalesQuotationTable    _destSalesQuotationTable,
                                                ProjTable              _destProjTable,
                                                ProjPlanVersion        _importRoot,
                                                ProjHierarchyTaskId    _taskIdOffset )
    {
        ProjPlanVersionsManager::insertProjPlanVersionIntoDestination(_destProjPlanVersion);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initProjPlanFromSourceVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes a project plan version based on a source project plan
    /// </summary>
    /// <param name = "_sourceProjPlanVersion">
    /// An instance of <c>ProjPlanVersion</c> as the source project plan.
    /// </param>
    /// <param name = "_destHierarchyId">
    /// Id of the destination hierarchy.
    /// </param>
    /// <param name = "_sourceHierarchy">
    /// Id of the hierarchy to be imported
    /// </param>
    /// <param name = "_destCalendarId">
    /// Id of the destination calender.
    /// </param>
    /// <param name = "_destSalesQuotationTable">
    /// An instance of <c>SalesQuotationTable</c> table buffer.
    /// </param>
    /// <param name = "_importRoot">
    /// An instance of <c>ProjPlanVersion</c> table buffer.
    /// </param>
    /// <param name = "_taskIdOffset">
    /// ID of the project hierarchy task.
    /// </param>
    /// <param name = "_rootSiblingNumberOffset">
    /// A root sibiling offset number.
    /// </param>
    /// <returns>
    /// Initialized <c>ProjPlanVersion</c> Instance.
    /// </returns>
    protected static ProjPlanVersion initProjPlanFromSourceVersion(
        ProjPlanVersion _sourceProjPlanVersion,
        HierarchyIdBase _destHierarchyId,
        Hierarchy _sourceHierarchy,
        CalendarId _destCalendarId,
        SalesQuotationTable _destSalesQuotationTable,
        ProjPlanVersion _importRoot,
        ProjHierarchyTaskId _taskIdOffset,
        int _rootSiblingNumberOffset)
    {
        ProjHierarchyPathId pathIdPrefix = _importRoot.isRoot() ? '' : _importRoot.PathId + '.';
        
        ProjPlanVersion destProjPlanVersion;
        destProjPlanVersion.data(_sourceProjPlanVersion);
        destProjPlanVersion.HierarchyId = _destHierarchyId;
        destProjPlanVersion.HierarchyTaskId = ProjPlanVersionsManager::getImportedTaskId(_sourceProjPlanVersion.HierarchyTaskId, _taskIdOffset);
        destProjPlanVersion.HierarchyLevel += _importRoot.HierarchyLevel;
        destProjPlanVersion.TaskSchedulingStatus = PSAScheduled::NotScheduled;
        destProjPlanVersion.TaskEffortAtComplete = destProjPlanVersion.TaskEffort;
        // Need to increment first element of PathId by rootSiblingNumberOffset and add prefix
        if (destProjPlanVersion.PathId != "")
        {
            container pathId = str2con(destProjPlanVersion.PathId, '.', true);
            pathId = conPoke(pathId, 1, conPeek(pathId, 1) + _rootSiblingNumberOffset);
            destProjPlanVersion.PathId = pathIdPrefix + con2Str(pathId, '.');
        }

        // If the task was directly parented to the old root, make it a child of the new root
        if (_sourceProjPlanVersion.ParentHierarchyTaskId == ProjPlanVersionDetail::rootTaskId())
        {
            destProjPlanVersion.ParentHierarchyTaskId = _importRoot.HierarchyTaskId;
            destProjPlanVersion.TaskSiblingNumber += _rootSiblingNumberOffset;
        }
        // Otherwise, map the parent id to the new task id of the original parent
        else
        {
            destProjPlanVersion.ParentHierarchyTaskId = ProjPlanVersionsManager::getImportedTaskId(_sourceProjPlanVersion.ParentHierarchyTaskId, _taskIdOffset);
        }

        destProjPlanVersion.HierarchyTreeTableRefRecId = 0;

        if (destProjPlanVersion.EndNode == FalseTrue::True && !ProjPlanVersionDetail::isQuotationHierarchy(_sourceProjPlanVersion.HierarchyId))
        {
            destProjPlanVersion.NumberOfResources = decRound(max(destProjPlanVersion.NumberOfResources, 1.0), 0);
            destProjPlanVersion.TaskDuration = ProjPlanVersion::calcTaskDurationDays(
                    destProjPlanVersion,
                    ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(_destCalendarId));
                
            // Set the start date for import, and recalculate end date
            if (_sourceHierarchy.IsTemplate || ProjPlanVersionsManager::sourceIsAssociatedWithProject(_sourceHierarchy))
            {
                destProjPlanVersion.TaskStartDate = _importRoot.TaskStartDate;
            }
            else if (_destSalesQuotationTable)
            {
                destProjPlanVersion.TaskStartDate = _destSalesQuotationTable.PSAEstProjStartDate;
            }

            destProjPlanVersion.TaskFinishDate = WorkCalendarCalculator::findEndDateForStartDateAndDuration(
                    destProjPlanVersion.TaskStartDate,
                    destProjPlanVersion.TaskDuration,
                    _destCalendarId);
        }

        return destProjPlanVersion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importPSAActivityEstimateRecords</Name>
				<Source><![CDATA[
    private static void importPSAActivityEstimateRecords(
        HierarchyIdBase _sourcePublishedHierarchyId,
        HierarchyIdBase _destHierarchyId,
        Hierarchy _sourceHierarchy,
        Hierarchy _destHierarchy,
        ProjTable _destProjTable,
        SalesQuotationTable _destSalesQuotationTable,
        ProjPlanVersion _importRoot,
        boolean _useRateCards,
        ProjHierarchyTaskId _taskIdOffset)
    {
        SalesQuotationTable srcSalesQuotationTable = HierarchyLinkTable::findAssociation(_sourceHierarchy.HierarchyId, tableNum(SalesQuotationTable));

        if (!_useRateCards &&
            srcSalesQuotationTable &&
            _destProjTable &&
            ProjPlanVersionsManager::applyRateCardForSrcProjQuotation(_sourceHierarchy, srcSalesQuotationTable))
        {
            _useRateCards = Box::yesNo("@PSA11095", DialogButton::Yes) == DialogButton::Yes;
        }

        boolean currencyExchange = false;
        CurrencyExchangeHelper currencyExchangeHelper;
        CurrencyCode currencyCode = _destSalesQuotationTable ? _destSalesQuotationTable.CurrencyCode : CompanyInfoHelper::standardCurrency();

        if (CompanyInfoHelper::standardCurrency() != currencyCode)
        {
            currencyExchange = true;
            currencyExchangeHelper = CurrencyExchangeHelper::newExchangeDate(
                Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId),
                DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        }

        ttsbegin;
        PSAActivityEstimates srcPSAActivityEstimates;

        Query query = ProjPlanVersionsManager::initPSAActivityEstimatesQuery(_sourcePublishedHierarchyId);

        QueryRun queryRun = new queryRun(query);

        while (queryRun.next())
        {
            srcPSAActivityEstimates = queryRun.get(tableNum(PSAActivityEstimates));
            PSAActivityEstimates destPSAActivityEstimates = ProjPlanVersionsManager::initDestActivityEstimateBySrcActivityEstimate(srcPSAActivityEstimates, _destHierarchyId, _taskIdOffset);

            if (_useRateCards)
            {
                ProjEstimateDataContract estimate = ProjEstimateDataContract::construct();
                estimate.updateEstimates(
                    'projCategoryId',
                    _destHierarchyId,
                    destPSAActivityEstimates.ProjPlanHierarchyTaskId,
                    _importRoot.TaskStartDate,
                    0,
                    destPSAActivityEstimates.ProjTransType,
                    destPSAActivityEstimates.ProjCategoryId,
                    destPSAActivityEstimates.ResourceCategory,
                    destPSAActivityEstimates.Resource,
                    destPSAActivityEstimates.ItemId,
                    destPSAActivityEstimates.Description,
                    destPSAActivityEstimates.LinePropertyId,
                    destPSAActivityEstimates.Quantity,
                    0, 0,
                    EcoResCategory::find(destPSAActivityEstimates.SalesCategory).Name);

                destPSAActivityEstimates.UnitCostPrice = estimate.parmUnitCostPrice();
                destPSAActivityEstimates.UnitSalesPrice = estimate.parmUnitSalesPrice();
                destPSAActivityEstimates.TotalCostPrice = estimate.parmTotalCostPrice();
                destPSAActivityEstimates.TotalSalesPrice = estimate.parmTotalSalesPrice();

                if (destPSAActivityEstimates.ItemId)
                {
                    boolean usePriceDisc = ProjEstimateImportPriceGroupBasedPricingFlight::instance().isEnabled();

                    ProjPlanVersion projPlanVersion = ProjPlanVersion::findByHierarchyAndTaskId(_destHierarchyId, _taskIdOffset);

                    // Look for item price based on customer and price group.
                    if (usePriceDisc)
                    {
                        destPSAActivityEstimates.UnitSalesPrice = ProjPlanVersionsManager::getUnitSalesPrice(destPSAActivityEstimates,
                                                                                                        currencyCode,
                                                                                                        projPlanVersion.TaskStartDate);
                    }

                    // When customer or price group is not available look for available price.
                    if (!usePriceDisc || !destPSAActivityEstimates.UnitSalesPrice)
                    {
                        PriceDiscAdmTrans priceDiscAdmTrans;
                        select firstonly Amount from priceDiscAdmTrans
                        where priceDiscAdmTrans.ItemRelation == srcPSAActivityEstimates.ItemId
                            && priceDiscAdmTrans.relation == PriceType::PriceSales
                            && priceDiscAdmTrans.Currency == srcPSAActivityEstimates.currencyCode()
                            && ((priceDiscAdmTrans.FromDate <= projPlanVersion.TaskStartDate
                                && priceDiscAdmTrans.ToDate >= projPlanVersion.TaskStartDate)
                                || priceDiscAdmTrans.FromDate == dateNull());

                        destPSAActivityEstimates.UnitSalesPrice = priceDiscAdmTrans.Amount;
                    }

                    destPSAActivityEstimates.TotalSalesPrice = destPSAActivityEstimates.UnitSalesPrice * destPSAActivityEstimates.Quantity;
                }
            }
            else if (currencyExchange)
            {
                // calculate UnitSalesPrice with exchange rate provided when standard currency and transaction currency are different.
                if (_destHierarchy.IsTemplate || !_sourceHierarchy.IsTemplate)
                {
                    destPSAActivityEstimates.UnitSalesPrice = currencyExchangeHelper.calculateTransactionToAccounting(currencyCode, srcPSAActivityEstimates.UnitSalesPrice, true);
                }
                else
                {
                    destPSAActivityEstimates.UnitSalesPrice = currencyExchangeHelper.calculateAccountingToTransaction(currencyCode, srcPSAActivityEstimates.UnitSalesPrice, true);
                }
                destPSAActivityEstimates.TotalSalesPrice = destPSAActivityEstimates.UnitSalesPrice * destPSAActivityEstimates.Quantity;
            }
            
            destPSAActivityEstimates.insert();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDestActivityEstimateBySrcActivityEstimate</Name>
				<Source><![CDATA[
    protected static PSAActivityEstimates initDestActivityEstimateBySrcActivityEstimate(PSAActivityEstimates _srcPSAActivityEstimates, HierarchyIdBase _destHierarchyId, ProjHierarchyTaskId _taskIdOffset)
    {
        PSAActivityEstimates destPSAActivityEstimates;
        destPSAActivityEstimates.data(_srcPSAActivityEstimates);
        destPSAActivityEstimates.ActivityNumber = "";
        destPSAActivityEstimates.ProjPlanHierarchyId = _destHierarchyId;
        destPSAActivityEstimates.ProjPlanHierarchyTaskId = ProjPlanVersionsManager::getImportedTaskId(_srcPSAActivityEstimates.ProjPlanHierarchyTaskId, _taskIdOffset);

        return destPSAActivityEstimates;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPSAActivityEstimatesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialization for query object for <c>PSAActivityEstimates</c> table buffer.
    /// </summary>
    /// <param name = "_sourcePublishedHierarchyId">
    /// Id of the source WBS published hierarchy.
    /// </param>
    /// <returns>
    /// An initialized query object.
    /// </returns>
    protected static Query initPSAActivityEstimatesQuery(HierarchyIdBase _sourcePublishedHierarchyId)
    {
        Query query = new Query();

        QueryBuildDataSource qbdsPSAActivityEstimates = query.addDataSource(tableNum(PSAActivityEstimates));

        qbdsPSAActivityEstimates.addRange(fieldNum(PSAActivityEstimates, ProjPlanHierarchyId)).value(queryValue(_sourcePublishedHierarchyId));

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importProjDependencyRecords</Name>
				<Source><![CDATA[
    private static void importProjDependencyRecords(
        HierarchyIdBase _sourceHierarchyId,
        HierarchyIdBase _destHierarchyId,
        ProjHierarchyTaskId _taskIdOffset)
    {
        RecordInsertList projDependencyInsertList = new RecordInsertList(tablenum(ProjDependency), true, true, true, true, true);
        ProjDependency sourceProjDependency;

        while select sourceProjDependency where
            sourceProjDependency.ProjPlanHierarchyId == _sourceHierarchyId
        {
            ProjDependency destProjDependency;
            destProjDependency.ProjPlanHierarchyId = _destHierarchyId;
            destProjDependency.PredecessorHierarchyTaskId = ProjPlanVersionsManager::getImportedTaskId(sourceProjDependency.PredecessorHierarchyTaskId, _taskIdOffset);
            destProjDependency.SuccessorHierarchyTaskId = ProjPlanVersionsManager::getImportedTaskId(sourceProjDependency.SuccessorHierarchyTaskId, _taskIdOffset);
            projDependencyInsertList.add(destProjDependency);
        }

        ttsbegin;
        projDependencyInsertList.insertDatabase();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostAtComplete</Name>
				<Source><![CDATA[
    private static void updateCostAtComplete(HierarchyIdBase _destHierarchyId, CalendarId _destCalendarId)
    {
        ProjPlanVersion destProjPlanVersion;

        while select forupdate destProjPlanVersion
            order by destProjPlanVersion.HierarchyLevel desc
            where destProjPlanVersion.HierarchyId == _destHierarchyId
        {
            ProjPlanVersion::updateCostAtCompleteV2(destProjPlanVersion);
            ProjPlanVersion::updateFromChildren(_destCalendarId, destProjPlanVersion);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>importHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports a hierarchy into another one under the specified node. The caller should verify with 'preImportHierarchy' before calling this function.
    /// </summary>
    /// <param name = "_sourceHierarchyId">Id of the hierarchy to be imported</param>
    /// <param name = "_destHierarchyId">Id of the destination hierarchy</param>
    /// <param name = "_parentTaskId">Id of the destination node under which import is performed</param>
    /// <param name = "_useRateCards">true to use current project contract rates; false otherwise. This parameter is optional.</param>
    /// <returns>A list of all HierarchyTaskIds for the newly created tasks.</returns>
    public static List importHierarchy(
        HierarchyIdBase _sourceHierarchyId,
        HierarchyIdBase _destHierarchyId,
        ProjHierarchyTaskId _parentTaskId,
        boolean _useRateCards = true)
    {
        ProjPlanVersion parentTask						= ProjPlanVersion::findByHierarchyAndTaskId(_destHierarchyId, _parentTaskId, true);
        ProjHierarchySorting parentTaskSortingRecord	= ProjHierarchySorting::findByReferenceV2(ProjHierarchySortingType::ProjWBS, _destHierarchyId, _parentTaskId);
        int rootSiblingNumberOffset						= real2Int(ProjPlanVersion::getNextSiblingNumber(_destHierarchyId, _parentTaskId)) - 1;
        ProjTable destProjTable                         = HierarchyLinkTable::findAssociation(ProjPlanVersionDetail::getOldDataModelPublishedHierarchyId(_destHierarchyId), tableNum(ProjTable));
        ProjHierarchyTaskId taskIdOffset				= ProjPlanVersion::getMaxTaskId(_destHierarchyId, destProjTable.RecId != 0);
        SalesQuotationTable destSalesQuotationTable     = HierarchyLinkTable::findAssociation(_destHierarchyId, tableNum(SalesQuotationTable));
        Hierarchy sourceHierarchy                       = Hierarchy::find(_sourceHierarchyId);
        Hierarchy destHierarchy                         = Hierarchy::find(_destHierarchyId);
        ProjPlanVersionDetail destHierarchyDetail		= ProjPlanVersionDetail::findByHierarchyId(_destHierarchyId);
        int sourceHierarchyMaxDepth						= ProjPlanVersion::getMaxHierarchyLevel(_sourceHierarchyId);
        CalendarId destCalendarId							= destProjTable ? destProjTable.PSASchedCalendarId : destSalesQuotationTable.PSASchedCalendarId;

        HierarchyIdBase publishedHierarchyId = ProjPlanVersionDetail::getNewDataModelPublishedHierarchyId(_sourceHierarchyId);
        if (publishedHierarchyId == '')
        {
            publishedHierarchyId = _sourceHierarchyId;
        }

        ttsbegin;
        // Import all ProjPlanVersion records into the destination hierarchy
        List newTasks = ProjPlanVersionsManager::importProjPlanVersionRecords(
            publishedHierarchyId,
            _destHierarchyId,
            sourceHierarchy,
            destCalendarId,
            destSalesQuotationTable,
            parentTask,
            taskIdOffset,
            rootSiblingNumberOffset);

        // Import all ProjHierarchySorting records into the destination hierarchy
        ProjPlanVersionsManager::importProjHierarchySortingRecords(
            publishedHierarchyId,
            _destHierarchyId,
            parentTaskSortingRecord,
            ProjPlanVersion::getRootTaskId(publishedHierarchyId),
            taskIdOffset,
            rootSiblingNumberOffset,
            parentTask.HierarchyLevel,
            sourceHierarchyMaxDepth);

        // Import all PSAActivityEstimate records into the destination hierarchy
        ProjPlanVersionsManager::importPSAActivityEstimateRecords(
            publishedHierarchyId,
            _destHierarchyId,
            sourceHierarchy,
            destHierarchy,
            destProjTable,
            destSalesQuotationTable,
            parentTask,
            _useRateCards,
            taskIdOffset);

        // Update cost price at complete
        ProjPlanVersionsManager::updateCostAtComplete(_destHierarchyId, destCalendarId);

        // Import all ProjDependency records into the destination hierarchy
        ProjPlanVersionsManager::importProjDependencyRecords(
            publishedHierarchyId,
            _destHierarchyId,
            taskIdOffset);

        // Update predecessor dates for new tasks
        for (ListEnumerator e = newTasks.getEnumerator(); e.moveNext(); e = e)
        {
            ProjPlanVersion newTask = ProjPlanVersion::findByHierarchyAndTaskId(_destHierarchyId, e.current());
            ProjPlanVersion::updateStartDateForSuccessors(destCalendarId, newTask);
        }

        // If the parent task has become a summary task (actually check for children)
        if (ProjPlanVersion::isSummaryTask(_destHierarchyId, _parentTaskId))
        {
            Hours workDayHours = ProjWorkBreakdownStructureV2FormHelper::getCalendarStandardWorkDayHours(destCalendarId);

            parentTask.reread();
            ProjPlanVersion::setEndNodeStateV2(destCalendarId, destHierarchyDetail.getWBSType(), parentTask, FalseTrue::False, workDayHours);
            ProjPlanVersion::updateFromChildren(destCalendarId, parentTask);
        }
        else
        {
            ProjEstimate::updateTaskFromEstimatesV2(_destHierarchyId, parentTask.HierarchyTaskId);
        }
        ttscommit;

        return newTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyRateCardForSrcProjQuotation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Identifies whether the decision to apply rate card needs to be taken or not for the estimates being copied.
    /// </summary>
    /// <param name="_srcHierarchy">
    /// The source PSAActivityEstimates associated with the source <c>Heirarchy</c> table.
    /// </param>
    /// <param name = "_srcSalesQuotationTable">
    /// The source quotation.
    /// </param>
    public static boolean applyRateCardForSrcProjQuotation(Hierarchy _srcHierarchy, SalesQuotationTable _srcSalesQuotationTable)
    {
        CostPrice                       costPrice;
        SalesPrice                      salesPrice;
        PSAActivityEstimates            srcEstimates;
        PSAActivitySetup                psaSrcActivitySetup;
        boolean                         isRateCard = false;
        HierarchyTreeTable              srcHierarchyTreeTable;
        smmActivities                   srcActivities;
        StartDate                       desStartDate;

        CurrencyCode currencyCode = _srcSalesQuotationTable ? _srcSalesQuotationTable.CurrencyCode : CompanyInfoHelper::standardCurrency();

        while select srcEstimates
            join RefRecId from  srcHierarchyTreeTable
            join ActivityNumber from srcActivities
                where srcEstimates.ActivityNumber == srcActivities.ActivityNumber &&
                    srcHierarchyTreeTable.HierarchyId == _srcHierarchy.HierarchyId &&
                    srcHierarchyTreeTable.ParentElementNumber &&
                    srcActivities.RecId == srcHierarchyTreeTable.RefRecId
        {
            if (srcEstimates && srcActivities && _srcSalesQuotationTable)
            {
                psaSrcActivitySetup = PSAActivitySetup::findActivityNumber(srcActivities.ActivityNumber,false);
                
                desStartDate = psaSrcActivitySetup.psaSchedStart;
                
                if (!desStartDate)
                {
                    desStartDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
                }
                
                costPrice   = 0;
                salesPrice  = 0;
                    
                switch(srcEstimates.ProjTransType)
                {
                    case QuotationProjTransType::Hour :
                        costPrice   = ProjPlanVersionsManager::findCostPriceByType(QuotationProjTransType::Hour, srcEstimates, desStartDate, _srcSalesQuotationTable);
                        salesPrice  = ProjPlanVersionsManager::findSalesPriceByType(QuotationProjTransType::Hour, srcEstimates, currencyCode, desStartDate, _srcSalesQuotationTable);
                        
                        if ((costPrice != 0 && costPrice != srcEstimates.UnitCostPrice) || (salesPrice != 0 && salesPrice != srcEstimates.UnitSalesPrice))
                        {
                            isRateCard = true;
                        }
                        break;
                        
                    case QuotationProjTransType::Expense :
                        costPrice   = ProjPlanVersionsManager::findCostPriceByType(QuotationProjTransType::Expense, srcEstimates, desStartDate, _srcSalesQuotationTable);
                        salesPrice  = ProjPlanVersionsManager::findSalesPriceByType(QuotationProjTransType::Expense, srcEstimates, currencyCode, desStartDate, _srcSalesQuotationTable);
                                                
                        if ((costPrice != 0 && costPrice != srcEstimates.UnitCostPrice) || (salesPrice != 0 && salesPrice != srcEstimates.UnitSalesPrice))
                        {
                            isRateCard = true;
                        }
                        break;
                        
                    case QuotationProjTransType::Fee :
                        salesPrice = ProjPlanVersionsManager::findSalesPriceByType(QuotationProjTransType::Fee, srcEstimates, currencyCode, desStartDate, _srcSalesQuotationTable);
                        
                        if (salesPrice != 0 && salesPrice != srcEstimates.UnitSalesPrice)
                        {
                            isRateCard = true;
                        }
                        break;
                }
            }
            
            if (isRateCard)
            {
                break;
            }
        }

        return isRateCard;
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>findCostPriceByType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the cost price for an activity estimate.
    /// </summary>
    /// <param name = "_transType">The transaction type of the estimate.</param>
    /// <param name = "_srcEstimates">The estimate record in <c>PSAActivityEstimates</c>.</param>
    /// <param name = "_desStartDate">The start date of the quotation task.</param>
    /// <param name = "_srcSalesQuotationTable">The source quotation.</param>
    /// <returns>The cost price.</returns>
    protected static CostPrice findCostPriceByType(QuotationProjTransType _transType, PSAActivityEstimates _srcEstimates, StartDate _desStartDate, SalesQuotationTable _srcSalesQuotationTable)
    {
        CostPrice   costPrice;
        ProjPriceParameters priceParams;
        switch (_transType)
        {
            case QuotationProjTransType::Hour :
                costPrice = ProjHourCostPrice::findProjCostPrice('', _srcEstimates.Resource, _srcEstimates.ProjCategoryId, _desStartDate, '', _srcSalesQuotationTable.CustAccount).CostPrice;
                break;

            case QuotationProjTransType::Expense :
                priceParams = ProjCostPriceExpense::constructPriceParametersForFindCostPrice('', _srcEstimates.Resource, _srcEstimates.ProjCategoryId, _desStartDate, '', _srcSalesQuotationTable.CustAccount);
                costPrice = ProjCostPriceExpense::findCostPriceByPriceParameters(priceParams);
                break;

            case QuotationProjTransType::Fee :
                costPrice = 0;
                break;
        }
        return costPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findSalesPriceByType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns the sales price for an activity estimate.
    /// </summary>
    /// <param name = "_transType">The transaction type of the estimate.</param>
    /// <param name = "_srcEstimates">The <c>PSAActivityEstimates</c> record for the estimate.</param>
    /// <param name = "_currencyCode">The currency code for the estimate.</param>
    /// <param name = "_desStartDate">The start date of the quotation task.</param>
    /// <param name = "_srcSalesQuotationTable">The source quotation.</param>
    /// <returns>The sales price.</returns>
    protected static SalesPrice findSalesPriceByType(QuotationProjTransType _transType, PSAActivityEstimates _srcEstimates, CurrencyCode _currencyCode, Startdate _desStartDate, SalesQuotationTable _srcSalesQuotationTable)
    {
        SalesPrice   salesPrice;
        ProjPriceParameters priceParams;
        switch (_transType)
        {
            case QuotationProjTransType::Hour :
                priceParams = ProjHourSalesPrice::constructPriceParametersForFindHourSalesPrice(
                    '',
                    _srcEstimates.Resource,
                    _srcEstimates.ProjCategoryId,
                    _srcEstimates.LinePropertyId,
                    0,
                    _currencyCode,
                    _desStartDate,
                    '',
                    '',
                    _srcSalesQuotationTable.CustAccount);
                [salesPrice] = ProjHourSalesPrice::findHourSalesPriceByPriceParameters(priceParams, false);
                break;

            case QuotationProjTransType::Expense :
                priceParams = ProjCostSalesPrice::constructPriceParametersForFindCostSalesPrice(
                    '',
                    _srcEstimates.Resource,
                    _srcEstimates.ProjCategoryId,
                    0,
                    CompanyInfoHelper::standardCurrency(),
                    _currencyCode,
                    _desStartDate,
                    '',
                    '',
                    _srcSalesQuotationTable.CustAccount);
                [salesPrice] = ProjCostSalesPrice::findCostSalesPriceByPriceParameters(priceParams, false);
                break;

            case QuotationProjTransType::Fee :
                salesPrice = ProjRevenueSalesPrice::psaFindCustSalesPrice('', _srcSalesQuotationTable.CustAccount, _srcEstimates.Resource, _srcEstimates.ProjCategoryId, _currencyCode, _desStartDate);
                break;
        }
        return salesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>publishQuotationSubHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Publish the imported hierarchy for the quotation template import scenario.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the hierarchy to be published</param>
    /// <param name = "_rootTaskId">Id of the root task.</param>
    public static void publishQuotationSubHierarchy(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _rootTaskId = ProjPlanVersionDetail::rootTaskId())
    {
        List tasksQueue = new List(Types::Int64);
        List tasksSecondaryQueue = new List(Types::Int64);
        Map parentMapping = ProjPlanVersionsManager::getParentMapping(_hierarchyId);

        ProjPlanVersion projectPlanVersion = ProjPlanVersion::findByHierarchyAndTaskId(_hierarchyId, _rootTaskId);
        tasksQueue.appendList(parentMapping.lookup(projectPlanVersion.HierarchyTaskId));
        ListEnumerator tasksIterator = tasksQueue.getEnumerator();

        SalesQuotationTable destSalesQuotationTable = HierarchyLinkTable::findAssociation(_hierarchyId, tableNum(SalesQuotationTable));

        while (true)
        {
            while (tasksIterator.moveNext())
            {
                ProjHierarchyTaskId currentHierarchyTaskId = tasksIterator.current();

                ProjPlanVersion projPlanVersion;
                select forupdate projPlanVersion
                    where projPlanVersion.HierarchyId == _hierarchyId
                        && projPlanVersion.HierarchyTaskId == currentHierarchyTaskId;

                HierarchyTreeTable      hierarchyTreeTable;
                smmActivities           smmActivities;
                PSAActivitySetup        psaActivitySetup;

                if (parentMapping.exists(projPlanVersion.HierarchyTaskId))
                {
                    tasksSecondaryQueue.appendList(parentMapping.lookup(projPlanVersion.HierarchyTaskId));
                }

                hierarchyTreeTable.ElementNumber = NumberSeq::newGetNum(CompanyInfo::numRefElementNumber()).num();
                hierarchyTreeTable.HierarchyId = _hierarchyId;
                hierarchyTreeTable.ElementNodeType = ElementNodeType::Activity;

                ttsbegin;

                ProjPlanVersionsManager::createActivityFromQuoteTemplate(smmActivities, destSalesQuotationTable);

                ProjPlanVersionsManager::createActivitySetupFromQuoteTemplate(psaActivitySetup, smmActivities, projPlanVersion, hierarchyTreeTable);

                ProjPlanVersionsManager::updateActivityEstimatesFromQuoteTemplate(smmActivities, projPlanVersion);

                if (projPlanVersion.ParentHierarchyTaskId)
                {
                    ProjPlanVersion parentProjPlanVersion;
                    select firstonly HierarchyTreeTableRefRecId from parentProjPlanVersion
                        where parentProjPlanVersion.HierarchyTaskId == projPlanVersion.ParentHierarchyTaskId
                            && parentProjPlanVersion.HierarchyId == projPlanVersion.HierarchyId;

                    HierarchyTreeTable parentHierarchyTreeTable;
                    select firstonly ElementNumber, Level, Path from parentHierarchyTreeTable
                        where parentHierarchyTreeTable.RecId == parentProjPlanVersion.HierarchyTreeTableRefRecId;

                    hierarchyTreeTable.ParentElementNumber = parentHierarchyTreeTable.ElementNumber;
                    hierarchyTreeTable.Level = parentHierarchyTreeTable.Level + 1;
                    HierarchyTreeTable.Path = parentHierarchyTreeTable.Path + hierarchyTreeTable.ElementNumber + "#";
                }

                ProjPlanVersionsManager::updateProjPlanVersionFromNewHierarchyTree(smmActivities,
                                                                                  projPlanVersion,
                                                                                  hierarchyTreeTable);


                ttscommit;
            }

            if (tasksSecondaryQueue.elements() > 0)
            {
                tasksQueue = tasksSecondaryQueue;
                tasksSecondaryQueue = new List(Types::Int64);
                tasksIterator = tasksQueue.getEnumerator();
            }
            else
            {
                break;
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createActivityFromQuoteTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new <c>smmActivities</c> and <c>smmActivityParentLink</c> for the task in imported quote template.
    /// </summary>
    /// <param name = "_smmActivities"><c>smmActivities</c> buffer</param>
    /// <param name = "_destSalesQuotationTable"><c>SalesQuotationTable</c> buffer</param>
    protected static void createActivityFromQuoteTemplate(smmActivities _smmActivities, SalesQuotationTable _destSalesQuotationTable)
    {
        _smmActivities.setActivityNum();
        _smmActivities.Category = smmActivityCategory::Task;
        _smmActivities.ResponsibleWorker = HcmEmployment::findByWorkerLegalEntity(HcmWorkerLookup::currentWorker(), CompanyInfo::current()).Worker;
        _smmActivities.insert();

        if (!smmActivityParentLinkTable::existsByActivityAndParent(_smmActivities.ActivityNumber, smmActivityParentType::Quotation, _destSalesQuotationTable.RecId, _destSalesQuotationTable.TableId) && _destSalesQuotationTable)
        {
            smmActivityParentLink::insertLink(_smmActivities.ActivityNumber, smmActivityParentType::Quotation, _destSalesQuotationTable.RecId, true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createActivitySetupFromQuoteTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates new <c>PSAActivitySetup</c> record from a given activity.
    /// </summary>
    /// <param name = "_psaActivitySetup"><c>PSAActivitySetup</c> buffer</param>
    /// <param name = "_smmActivities"><c>smmActivities</c> buffer</param>
    /// <param name = "_projPlanVersion"><c>ProjPlanVersion</c> buffer</param>
    /// <param name = "_hierarchyTreeTable"><c>HierarchyTreeTable</c> buffer</param>
    protected static void createActivitySetupFromQuoteTemplate(PSAActivitySetup _psaActivitySetup,
                                                               smmActivities _smmActivities,
                                                               ProjPlanVersion _projPlanVersion,
                                                               HierarchyTreeTable _hierarchyTreeTable)
    {
        _smmActivities.reread();
        _psaActivitySetup.ActivityNumber = _smmActivities.ActivityNumber;

        ProjPlanVersionsManager::copyActivityData(_projPlanVersion, _hierarchyTreeTable, _smmActivities, _psaActivitySetup);

        _smmActivities.update();
        _psaActivitySetup.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateActivityEstimatesFromQuoteTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the activity number of all <c>PSAActivityEstimates</c> records for a given task in hierarchy.
    /// </summary>
    /// <param name = "_smmActivities"><c>smmActivities</c> buffer</param>
    /// <param name = "_projPlanVersion"><c>ProjPlanVersion</c> buffer</param>
    protected static void updateActivityEstimatesFromQuoteTemplate(smmActivities _smmActivities,
                                                                   ProjPlanVersion _projPlanVersion)
    {
        PSAActivityEstimates psaActivityEstimates;
        psaActivityEstimates.skipDataMethods(true);

        update_recordset psaActivityEstimates
                setting
                    ActivityNumber = _smmActivities.ActivityNumber
                where
                    psaActivityEstimates.ProjPlanHierarchyTaskId == _projPlanVersion.HierarchyTaskId
                        && psaActivityEstimates.ProjPlanHierarchyId == _projPlanVersion.HierarchyId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjPlanVersionFromNewHierarchyTree</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts new record to <c>HierarchyTreeTable</c> and updates <c>ProjPlanVersion</c>
    /// </summary>
    /// <param name = "_smmActivities"><c>smmActivities</c> buffer</param>
    /// <param name = "_projPlanVersion"><c>ProjPlanVersion</c> buffer</param>
    /// <param name = "_hierarchyTreeTable"><c>HierarchyTreeTable</c> buffer</param>
    protected static void updateProjPlanVersionFromNewHierarchyTree(smmActivities _smmActivities,
                                                                    ProjPlanVersion _projPlanVersion,
                                                                    HierarchyTreeTable _hierarchyTreeTable)
    {
        _hierarchyTreeTable.RefRecId = _smmActivities.RecId;
        _hierarchyTreeTable.insert();

        _projPlanVersion.HierarchyTreeTableRefRecId = _hierarchyTreeTable.RecId;
        _projPlanVersion.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyActivityNumberToEstimates</Name>
				<Source><![CDATA[
    private static void copyActivityNumberToEstimates(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _taskId, smmActivityNumber _activityNumber)
    {
        PSAActivityEstimates psaActivityEstimates;

        ttsbegin;
        //
        // Update is being degraded to row by row due to code for quotations which is not relevent
        // in this code path. Set skipDataMethods() to improve performance.
        //
        psaActivityEstimates.skipDataMethods(true);
        update_recordset psaActivityEstimates
            setting
                ActivityNumber = _activityNumber
            where psaActivityEstimates.ProjPlanHierarchyId == _hierarchyId &&
                  psaActivityEstimates.ProjPlanHierarchyTaskId == _taskId;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>importTemplateHierarchy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Imports a hierarchy into another one under the specified node for the template import scenario. The caller should validate with 'preImportHierarchy' before calling this function.
    /// </summary>
    /// <param name = "_sourceHierarchyId">Id of the hierarchy to be imported</param>
    /// <param name = "_destHierarchyId">Id of the destination hierarchy</param>
    /// <param name = "_parentTaskId">Id of the destination node under which import is performed</param>
    /// <param name = "_useRateCards">true to use current project contract rates; false otherwise. This parameter is optional.</param>
    public static void importTemplateHierarchy(HierarchyIdBase      _sourceHierarchyId,
                                                HierarchyIdBase     _destHierarchyId,
                                                ProjHierarchyTaskId _parentTaskId,
                                                boolean             _useRateCards = true)
    {
        ProjPlanVersionsManager::importHierarchy(_sourceHierarchyId,
                                                _destHierarchyId,
                                                _parentTaskId,
                                                _useRateCards);
  
        if (ProjPlanVersionDetail::isQuotationHierarchy(_destHierarchyId))
        {
            ProjPlanVersionsManager::publishQuotationSubHierarchy(_destHierarchyId, _parentTaskId);
        }

        ProjPlanVersionsManager::syncActivityNumberForRoot(_destHierarchyId, _parentTaskId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTaskWithActualUsingUnpostedview</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the unposted transaction view should be used to when checking if there
    /// deleted WBS tasks with actuals associated to them.
    /// </summary>
    /// <returns>
    /// True if the unposted transactions view should be used to check for actuals, otherwise false.
    /// </returns>
    public static boolean checkForDeletedTaskWithActualUsingUnpostedview()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkHasDeletedTasksWithActuals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the current version of the WBS has any tasks which are deleted and has actuals reported.
    /// </summary>
    /// <param name = "_currentHierarchyId">
    /// The current hiearachy id of the WBS.
    /// </param>
    /// <returns>
    /// True if any deleted tasks has actuals, otherwise false.
    /// </returns>
    public static boolean checkHasDeletedTasksWithActuals(HierarchyIdBase _currentHierarchyId)
    {
        boolean hasDeletedTaskWithActual;

        HierarchyIdBase publishedHierarchyId = ProjPlanVersionDetail::getNewDataModelPublishedHierarchyId(_currentHierarchyId);

        // Early escape from method
        if (!publishedHierarchyId)
        {
            return false;
        }

        // If there is no task deleted in the current WBS then return false.
        ProjPlanVersion draftProjPlanVersion, publishedProjPlanVersion;
        select firstonly RecId from publishedProjPlanVersion
            where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
        notexists join draftProjPlanVersion
            where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (!publishedProjPlanVersion.RecId)
        {
            return false;
        }
 
        //
        // The order of checks it setup to exit the checking as soon as possible to minimize
        // impact on the system.
        //
        //  Posted transactions
        //  Pending transactions within the same LE
        //  Pending transctions accross LEs
        //

        // 1. Check for deleted tasks within posted transations
        hasDeletedTaskWithActual = ProjPlanversionsManager::checkForDeletedTasksInPostedTransactions(_currentHierarchyId, publishedHierarchyId);

        // 2. Check deleted tasks within unposted transactions
        if (!hasDeletedTaskWithActual)
        {
            hasDeletedTaskWithActual = ProjPlanversionsManager::checkForDeletedTasksInPendingTransactions(_currentHierarchyId, publishedHierarchyId);
        }


        HierarchyTreeTable  hierarchyTreeTable;
        smmActivities       smmActivities;
        // 3. Pending documents within LE that don't show as unposted transactions
        if (!hasDeletedTaskWithActual)
        {
            PurchReqLine purchReqLine;
            select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from purchReqLine
                where purchReqLine.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

            if (publishedProjPlanVersion)
            {
                hasDeletedTaskWithActual = true;
            }
        }

        // 4. Cross company transactions
        if (!hasDeletedTaskWithActual)
        {
            container borrowingLEs = ProjIntercompanyParameters::getBorrowingLegalEntitiesContainer();
            
            select firstonly ActivityNumber, DataAreaId from smmActivities
                    exists join RecId from publishedProjPlanVersion
                        where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
                    exists join RecId from hierarchyTreeTable
                        where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
                        && smmActivities.RecId == hierarchyTreeTable.RefRecId
                    notexists join draftProjPlanVersion
                        where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                        && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

            if (ProjParameters::find().EnableIntercompanyTimesheet == NoYes::Yes)
            {
                TSTimesheetLine timesheetLine;
                select crosscompany:borrowingLEs RecId from timesheetLine
                        where timesheetLine.ActivityNumber == smmActivities.ActivityNumber
                        && timesheetLine.ProjectDataAreaId == smmActivities.DataAreaId;

                if (timesheetLine.RecId)
                {
                    hasDeletedTaskWithActual = true;
                }
            }

            if (!hasDeletedTaskWithActual)
            {
                TrvExpTrans trvExpTransCrossCompany;
                select firstonly crosscompany:borrowingLEs RecId from trvExpTransCrossCompany
                    where trvExpTransCrossCompany.ProjActivityNumber == smmActivities.ActivityNumber
                    && trvExpTransCrossCompany.InterCompanyLE == smmActivities.DataAreaId;

                if (trvExpTransCrossCompany.RecId)
                {
                    hasDeletedTaskWithActual = true;
                }
            }

            if (!hasDeletedTaskWithActual)
            {
                VendInvoiceInfoLine_Project projInvoiceLine;
                select firstonly crosscompany:borrowingLEs RecId from projInvoiceLine
                    where projInvoiceLine.ProjActivityNumber == smmActivities.ActivityNumber
                    && projInvoiceLine.ProjDataAreaId == smmActivities.DataAreaId;

                if (projInvoiceLine.RecId)
                {
                    hasDeletedTaskWithActual = true;
                }
            }

            if (!hasDeletedTaskWithActual)
            {
                ProjAdvancedJournalLine projAdvancedJournalLine;
                select firstonly crosscompany:borrowingLEs RecId from projAdvancedJournalLine
                                where projAdvancedJournalLine.ActivityNumber == smmActivities.ActivityNumber
                                && projAdvancedJournalLine.ProjDataAreaId == smmActivities.DataAreaId;

                if (projAdvancedJournalLine.RecId)
                {
                    hasDeletedTaskWithActual = true;
                }
            }
        }

        //
        // 5. Check all unposted transactions related to the project within LE
        //    The view is expensive to compute, but Partners/Customers may have added table to it.
        //
        if (!hasDeletedTaskWithActual)
        {
            // The default is not to use the view as all the tables have been directly checked.
            // CoC and be use to execute this logic. It would be better to use CoC on
            // The exposed methods for ProjPlanVersion::checkForDeletedTasksInPendingTransactions
            // to check for unposted transactions.
            //
            if (ProjPlanVersionsManager::checkForDeletedTaskWithActualUsingUnpostedview())
            {
                ProjUnpostedTransView projUnpostedTransView;
                select firstonly RecId from publishedProjPlanVersion
                    where publishedProjPlanVersion.HierarchyId == publishedHierarchyId
                exists join RecId from hierarchyTreeTable
                    where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
                exists join RecId from smmActivities
                    where smmActivities.RecId == hierarchyTreeTable.RefRecId
                exists join RecId from projUnpostedTransView
                    where projUnpostedTransView.ActivityNumber == smmActivities.ActivityNumber &&
                    projUnpostedTransView.TransDataAreaId == smmActivities.DataAreaId
                notexists join draftProjPlanVersion
                    where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                        && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

                if (publishedProjPlanVersion)
                {
                    hasDeletedTaskWithActual = true;
                }
            }
        }

        return hasDeletedTaskWithActual;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPostedHourTransactions</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInPostedHourTransactions(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasPostedHourTransactions;

        ProjEmplTrans projEmplTrans;
        select firstonly RecId from publishedProjPlanVersion
            where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
        exists join RecId from hierarchyTreeTable
            where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
        exists join RecId from smmActivities
            where smmActivities.RecId == hierarchyTreeTable.RefRecId
        exists join RecId from projEmplTrans
            where projEmplTrans.ActivityNumber == smmActivities.ActivityNumber
        notexists join draftProjPlanVersion
            where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasPostedHourTransactions =  true;
        }

        return hasPostedHourTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPostedExpenseTransactions</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInPostedExpenseTransactions(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasPostedExpenseTransactions;
        
        ProjCostTrans projCostTrans;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from projCostTrans
                where projCostTrans.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasPostedExpenseTransactions =  true;
        }

        return hasPostedExpenseTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPostedItemTransactions</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInPostedItemTransactions(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasPostedItemTransactions;

        ProjItemTrans projItemTrans;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from projItemTrans
                where projItemTrans.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasPostedItemTransactions =  true;
        }

        return hasPostedItemTransactions;
        
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPostedOnAccountTransactions</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInPostedOnAccountTransactions(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasPostedOnAccountTransactions;

        if (publishedProjPlanVersion)
        {
            hasPostedOnAccountTransactions =  true;
        }

        ProjOnAccTrans projOnAccTrans;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from projOnAccTrans
                where projOnAccTrans.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        return hasPostedOnAccountTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPostedTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the current version of the WBS has any tasks which are deleted in posted transactions.
    /// </summary>
    /// <param name = "_currentHierarchyId">
    /// The current hiearachy id of the WBS.
    /// </param>
    /// <param name = "_publishedHierarchyId">
    /// The published WBS hierarchy id.
    /// </param>
    /// <returns>
    /// True if the tasks contain posted transactions, otherwise false.
    /// </returns>
    private static boolean checkForDeletedTasksInPostedTransactions(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        boolean hasPostedTransactions;

        //
        //  The order of checking posted Transactions within the LE is based on which
        //  set of business documents would have created entries into the subledger tables
        //  for project management and accounting.
        //
        //    ProjEmplTrans
        //    ProjCostTrans
        //    ProjOnAccTrans
        //    ProjItemTrans
        //    ProjRevenueTrans (No ActivityNumber on this transaction type)
        //

        hasPostedTransactions = ProjPlanVersionsManager::checkForDeletedTasksInPostedHourTransactions(_currentHierarchyId, _publishedHierarchyId);

        if (!hasPostedTransactions)
        {
            hasPostedTransactions = ProjPlanVersionsManager::checkForDeletedTasksInPostedExpenseTransactions(_currentHierarchyId, _publishedHierarchyId);
        }

        if (!hasPostedTransactions)
        {
            hasPostedTransactions = ProjPlanVersionsManager::checkForDeletedTasksInPostedOnAccountTransactions(_currentHierarchyId, _publishedHierarchyId);
        }

        if (!hasPostedTransactions)
        {
            hasPostedTransactions = ProjPlanVersionsManager::checkForDeletedTasksInPostedItemTransactions(_currentHierarchyId, _publishedHierarchyId);
        }

        return hasPostedTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInUnpostedTimesheets</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInUnpostedTimesheets(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasUnpostedTimesheetTransactions;

        TSTimesheetLine tsTimesheetLine;
        select firstonly RecId from publishedProjPlanVersion
            where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
        exists join RecId from hierarchyTreeTable
            where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
        exists join RecId from smmActivities
            where smmActivities.RecId == hierarchyTreeTable.RefRecId
        exists join RecId from tsTimesheetLine
            where tsTimesheetLine.ActivityNumber == smmActivities.ActivityNumber &&
                  tsTimesheetLine.ApprovalStatus != TSAppStatus::Create &&
                  tsTimesheetLine.ProjectDataAreaId == curExt()
        notexists join draftProjPlanVersion
            where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if(publishedProjPlanVersion)
        {
            hasUnpostedTimesheetTransactions = true;
        }

        return hasUnpostedTimesheetTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInUnpostedExpenseReports</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInUnpostedExpenseReports(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasUnpostedExpenseReports;

        TrvExpTrans trvExpTrans;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from trvExpTrans
                where trvExpTrans.ProjActivityNumber == smmActivities.ActivityNumber &&
                      trvExpTrans.InterCompanyLE == curExt()
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        return hasUnpostedExpenseReports;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInUnpostedExpenseJournals</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInUnpostedExpenseJournals(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasUnpostedExpenseJournals;

        LedgerJournalTrans_Project ledgerJournalTrans_Project;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from ledgerJournalTrans_Project
                where ledgerJournalTrans_Project.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;
 
        return hasUnpostedExpenseJournals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInUnpostedProjectJournals</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInUnpostedProjectJournals(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasUnpostedProjectJournals;

        ProjJournalTrans projJournalTrans;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from projJournalTrans
                where projJournalTrans.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;
        
        return hasUnpostedProjectJournals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInUnpostedItemJournals</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInUnpostedItemJournals(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasUnpostedItemJournals;

        InventJournalTrans inventJournalTrans;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from inventJournalTrans
                where inventJournalTrans.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;
        
        return hasUnpostedItemJournals;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPendingVendorInvoices</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInPendingVendorInvoices(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasPendingVendorInvoiceLines;

        VendInvoiceInfoLine_Project vendInvoiceInfoLine_Project;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from vendInvoiceInfoLine_Project
                where vendInvoiceInfoLine_Project.ProjActivityNumber == smmActivities.ActivityNumber &&
                    vendInvoiceInfoLine_Project.ProjDataAreaId == curExt()
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasPendingVendorInvoiceLines = true;
        }

        return hasPendingVendorInvoiceLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInProductionBOM</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInProductionBOM(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasProductionBOMEntry;

        ProdJournalBOM prodJournalBOM;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from prodJournalBOM
                where prodJournalBOM.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasProductionBOMEntry = true;
        }

        return hasProductionBOMEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInProductionRoute</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInProductionRoute(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasProductionRouteEntry;

        ProdJournalRouteProj prodJournalRouteProj;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from prodJournalRouteProj
                where prodJournalRouteProj.ActivityNumber == smmActivities.ActivityNumber
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasProductionRouteEntry = true;
        }

        return hasProductionRouteEntry;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInAdvancedJournalLines</Name>
				<Source><![CDATA[
    private static boolean checkForDeletedTasksInAdvancedJournalLines(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasAdvancedJournalLines;

        ProjAdvancedJournalLine ProjAdvancedJournalLine;
        select firstonly RecId from publishedProjPlanVersion
                where publishedProjPlanVersion.HierarchyId == _publishedHierarchyId
            exists join RecId from hierarchyTreeTable
                where hierarchyTreeTable.RecId == publishedProjPlanVersion.HierarchyTreeTableRefRecId
            exists join RecId from smmActivities
                where smmActivities.RecId == hierarchyTreeTable.RefRecId
            exists join RecId from ProjAdvancedJournalLine
                where ProjAdvancedJournalLine.ActivityNumber == smmActivities.ActivityNumber &&
                        ProjAdvancedJournalLine.ProjDataAreaId == curExt()
            notexists join draftProjPlanVersion
                where draftProjPlanVersion.HierarchyId == _currentHierarchyId
                    && draftProjPlanVersion.HierarchyTaskId == publishedProjPlanVersion.HierarchyTaskId;

        if (publishedProjPlanVersion)
        {
            hasAdvancedJournalLines = true;
        }

        return hasAdvancedJournalLines;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForDeletedTasksInPendingTransactions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check whether the current version of the WBS has any tasks which are deleted in pending transactions.
    /// </summary>
    /// <param name = "_currentHierarchyId">
    /// The current hiearachy id of the WBS.
    /// </param>
    /// <param name = "_publishedHierarchyId">
    /// The published WBS hierarchy id.
    /// </param>
    /// <returns>
    /// True if any deleted tasks in draft has pending transactions, otherwise false.
    /// </returns>
    private static boolean checkForDeletedTasksInPendingTransactions(HierarchyIdBase _currentHierarchyId, HierarchyIdBase _publishedHierarchyId)
    {
        ProjPlanVersion draftProjPlanVersion;
        ProjPlanVersion publishedProjPlanVersion;
        HierarchyTreeTable hierarchyTreeTable;
        smmActivities smmActivities;

        boolean hasPendingTransactions;

        //
        // The order of checking business document for pending transactions is based on which
        // docouments are mostlikely to contain data for standard customers
        //
        
        hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInUnpostedTimesheets(_currentHierarchyId, _publishedHierarchyId);;

        // Unposted expense reports
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInUnpostedExpenseReports(_currentHierarchyId, _publishedHierarchyId);;
        }

        // Unposted hour or fee journals
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInUnpostedProjectJournals(_currentHierarchyId, _publishedHierarchyId);;
        }

        // Unposted expense journals
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInUnpostedExpenseJournals(_currentHierarchyId, _publishedHierarchyId);;
        }
        
        // Unposted item journals
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInUnpostedItemJournals(_currentHierarchyId, _publishedHierarchyId);;
        }
        
        // Vendor Invoice
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInPendingVendorInvoices(_currentHierarchyId, _publishedHierarchyId);;
        }

        // Production - BOMs
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInProductionBOM(_currentHierarchyId, _publishedHierarchyId);;
        }

        // Production Routes
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInProductionRoute(_currentHierarchyId, _publishedHierarchyId);;
        }

        // Project Advanced Journal
        if (!hasPendingTransactions)
        {
            hasPendingTransactions = ProjPlanVersionsManager::checkForDeletedTasksInAdvancedJournalLines(_currentHierarchyId, _publishedHierarchyId);;
        }

        return hasPendingTransactions;
    }

]]></Source>
			</Method>
			<Method>
				<Name>syncActivityNumberForRoot</Name>
				<Source><![CDATA[
    /// <summary>
    /// Publish the imported hierarchy for the quotation template import scenario.
    /// </summary>
    /// <param name = "_hierarchyId">Id of the hierarchy to be published</param>
    /// <param name = "_rootTaskId">Id of the root task.</param>
    public static void syncActivityNumberForRoot(HierarchyIdBase _hierarchyId, ProjHierarchyTaskId _rootTaskId = ProjPlanVersionDetail::rootTaskId())
    {
        HierarchyTreeTable      hierarchyTreeTable;
        ProjPlanVersion         projPlanVersion;
        smmActivities           smmActivities;

        select firstonly ActivityNumber from smmActivities
            exists join hierarchyTreeTable
            where hierarchyTreeTable.RefRecId == smmActivities.RecId
            exists join projPlanVersion
                where projPlanVersion.HierarchyTreeTableRefRecId == hierarchyTreeTable.RecId
                    && projPlanVersion.HierarchyId == _hierarchyId
                    && projPlanVersion.HierarchyTaskId == _rootTaskId;

        ProjPlanVersionsManager::copyActivityNumberToEstimates(_hierarchyId, _rootTaskId, smmActivities.ActivityNumber);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateSalesPrice</Name>
				<Source><![CDATA[
    private static NonNegativeSalesPrice calculateSalesPrice(PriceDiscParameters _params, PriceGroupId _priceGroup)
    {
        PriceDisc priceDisc = PriceDisc::newFromPriceDiscParameters(_params);
        priceDisc.findPrice(_priceGroup, false);
        NonNegativeSalesPrice defaultSalesPrice = priceDisc.price();

        return defaultSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getUnitSalesPrice</Name>
				<Source><![CDATA[
    private static NonNegativeSalesPrice getUnitSalesPrice(PSAActivityEstimates _destPSAActivityEstimates,
                                                           CurrencyCode _currency, 
                                                           DiscDate _priceDate = dateNull())
    {
        PriceGroupId priceGroup;
        CustAccount custAccount;

        SalesQuotationTable salesQuotation = _destPSAActivityEstimates.salesQuotationTable();

        if (salesQuotation)
        {
            custAccount = salesQuotation.CustAccount;
            priceGroup = salesQuotation.PriceGroupId;
        }
        else
        {
            ProjTable projTable = ProjPlanVersionDetail::getProjTableByHierarchyId(_destPSAActivityEstimates.ProjPlanHierarchyId);

            if (projTable)
            {
                custAccount = projTable.CustAccount;
                priceGroup = projTable.ProjPriceGroup;
            }
        }

        PriceDiscParameters parameters =  PriceDiscParameters::construct();

        parameters.parmModuleType(ModuleInventPurchSales::Sales);
        parameters.parmItemId(_destPSAActivityEstimates.itemId);
        parameters.parmInventDim(InventDim::findInLegalEntity(_destPSAActivityEstimates.InventDimId, curExt()));
        parameters.parmUnitID(InventTableModule::getUnitIdByModuleType(_destPSAActivityEstimates.itemId, ModuleInventPurchSales::Sales));
        DiscDate priceDate = (_priceDate == dateNull() || _priceDate == dateMax())?
            DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()):
            _priceDate;
        parameters.parmPriceDiscDate(priceDate);
        parameters.parmQty(_destPSAActivityEstimates.quantity);
        parameters.parmAccountNum(custAccount);
        parameters.parmCurrencyCode(_currency);

        NonNegativeSalesPrice unitSalesPrice = ProjPlanVersionsManager::calculateSalesPrice(parameters, priceGroup);

        return unitSalesPrice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>skipLogAndDataMethods</Name>
				<Source><![CDATA[
    private static void skipLogAndDataMethods(
        Common _record)
    {
        _record.skipDatabaseLog(true);
        _record.skipDataMethods(true);
        _record.skipEvents(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sourceIsAssociatedWithProject</Name>
				<Source><![CDATA[
    private static boolean sourceIsAssociatedWithProject(Hierarchy _sourceHierarchy)
    {
        ProjTable projTable = ProjTable::findByHierarchyId(_sourceHierarchy.HierarchyId);
        return projTable.ProjId != '';
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>