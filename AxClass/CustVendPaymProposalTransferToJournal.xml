<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>CustVendPaymProposalTransferToJournal</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>CustVendPaymProposalTransferToJournal</c> class transfers a payment proposal to a ledger
///    journal.
/// </summary>
public class CustVendPaymProposalTransferToJournal extends RunBaseBatch implements BatchRetryable
{
    protected LedgerJournalId ledgerJournalId;
    protected ModuleCustVend moduleCustVend;
    private const int BundleSize = 2000;
    private NoYes includeInvoicesFromOtherCompanies;
    private TransDate paymDate_IT;
    private NoYes paymOnDateFixed_IT;
    private boolean hasBatchBeenSplit;
    private boolean isAutomation;
    private boolean isFirstBatch;
    private boolean isFinalBatch;
    private RefRecId processExecutionSourceLinkRecId;
    private CustVendAC fromCustVendAccountNum;
    private CustVendAC toCustVendAccountNum;
    private RecId fromProposalRecId;
    private RecId toProposalRecId;
    private boolean isInTopPicking;
    private RecId sourceExecutionRecId;

    // Variables that do not need to be packed/unpacked
    protected CustVendPaymProposal paymProposal;
    protected LedgerJournalTable ledgerJournalTable;
    protected NewVoucher newVoucher;
    protected LedgerJournalTableData ledgerJournalTableData;
    protected SpecTransUpdateTmp specTransUpdateTmp;
    private HcmWorkerRecId hcmWorkerRecId;

    // <GEERU>
    private Map vatOperationCodeMap;
    // </GEERU>

    private boolean atLeastOneLineIsNotEligibleForTransfer;
    boolean isPaymentRequestsKeyEnabled;

    #define.CurrentVersion(4)

    #localmacro.CurrentList
        ledgerJournalId,
        moduleCustVend,
        includeInvoicesFromOtherCompanies,
        paymDate_IT,
        paymOnDateFixed_IT,
        hasBatchBeenSplit,
        isFinalBatch,
        fromCustVendAccountNum,
        toCustVendAccountNum,
        isAutomation,
        isFirstBatch,
        processExecutionSourceLinkRecId
    #endmacro

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>setHasBatchBeenSplit</Name>
				<Source><![CDATA[
    private void setHasBatchBeenSplit(boolean _hasBatchBeenSplit)
    {
        hasBatchBeenSplit = _hasBatchBeenSplit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getHasBatchBeenSplit</Name>
				<Source><![CDATA[
    protected boolean getHasBatchBeenSplit()
    {
        return hasBatchBeenSplit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsAutomation</Name>
				<Source><![CDATA[
    internal boolean parmIsAutomation(boolean _isAutomation = isAutomation)
    {
        isAutomation = _isAutomation;
        return isAutomation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsAutomation</Name>
				<Source><![CDATA[
    public boolean getIsAutomation()
    {
        return isAutomation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFirstBatch</Name>
				<Source><![CDATA[
    private boolean parmIsFirstBatch(boolean _isFirstBatch = isFirstBatch)
    {
        isFirstBatch = _isFirstBatch;
        return isFirstBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIsFinalBatch</Name>
				<Source><![CDATA[
    private void setIsFinalBatch(boolean _isFinalBatch)
    {
        isFinalBatch = _isFinalBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getIsFinalBatch</Name>
				<Source><![CDATA[
    protected boolean getIsFinalBatch()
    {
        return isFinalBatch;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProcessExecutionSourceLinkRecId</Name>
				<Source><![CDATA[
    internal RefRecId parmProcessExecutionSourceLinkRecId(RefRecId _processExecutionSourceLinkRecId = processExecutionSourceLinkRecId)
    {
        processExecutionSourceLinkRecId = _processExecutionSourceLinkRecId;
        return processExecutionSourceLinkRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getProcessExecutionSourceLinkRecId</Name>
				<Source><![CDATA[
    public RefRecId getProcessExecutionSourceLinkRecId()
    {
        return processExecutionSourceLinkRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>atLeastOneLineIsNotEligibleForTransfer</Name>
				<Source><![CDATA[
    private boolean atLeastOneLineIsNotEligibleForTransfer(boolean _atLeastOneLineIsNotEligibleForTransfer = atLeastOneLineIsNotEligibleForTransfer)
    {
        atLeastOneLineIsNotEligibleForTransfer = _atLeastOneLineIsNotEligibleForTransfer;
        return atLeastOneLineIsNotEligibleForTransfer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFromProposalRecId</Name>
				<Source><![CDATA[
    internal RecId parmFromProposalRecId(RecId _fromProposalRecId = fromProposalRecId)
    {
        fromProposalRecId = _fromProposalRecId;
        return fromProposalRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmToProposalRecId</Name>
				<Source><![CDATA[
    internal RecId parmToProposalRecId(RecId _toProposalRecId = toProposalRecId)
    {
        toProposalRecId = _toProposalRecId;
        return toProposalRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsInTopPicking</Name>
				<Source><![CDATA[
    internal RecId parmIsInTopPicking(RecId _isInTopPicking = isInTopPicking)
    {
        isInTopPicking = _isInTopPicking;
        return isInTopPicking;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dialog</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Returns a class that contains the methods that are described by the <c>RunBaseDialogable</c>
    ///    interface.
    /// </summary>
    /// <returns>
    ///    A class that contains the methods that are described by the <c>RunBaseDialogable</c> interface.
    /// </returns>
    /// <remarks>
    ///    A dialog can be built by using the <c>Dialog</c> class or by using a class that is created in the
    ///    Application Object Tree (AOT).
    /// </remarks>
    public Object dialog()
    {
        DialogRunbase dialog = super();

        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);

        dialog.addText("@SYS88952");

        if (ledgerJournalTable)
        {
            dialog.addText(strFmt("@SYS28641", ledgerJournalTable.JournalName, ledgerJournalTable.JournalNum));
        }

        return dialog;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransCurrency</Name>
				<Source><![CDATA[
    protected container getLedgerJournalTransCurrency(CustVendPaymProposalLine _custVendPaymProposalLine, TransDate _transDate)
    {
        CurrencyCode currencyCode;
        ExchRate exchRate;
        ExchRate exchRateSecond;
        NoYes triangulation;
        LedgerJournalTrans ledgerJournalTrans;
        UnknownNoYes triangulationResult;
        ExchRateSecondTxt exchRateSecondTxt;

        if (InvoiceCurrenyCodetoPaymentEnableFlight::instance().isEnabled())
        {
            currencyCode = _custVendPaymProposalLine.CurrencyCode;
            ledgerJournalTrans.TransDate = _transDate;
            ledgerJournalTrans.CurrencyCode = currencyCode;

            // The exchange rates for the journal line from the company of the line, which in this case is the payment company
            changecompany(_custVendPaymProposalLine.AccountNumCompany)
            {
                [triangulationResult,
                 exchRate,
                 exchRateSecond,
                 exchRateSecondTxt] = LedgerJournalEngine_Server::currencyModified(ledgerJournalTrans);

                triangulation = Currency::unknownNoYes2Noyes(triangulationResult);
            }
        }
        else
        {
            if (ledgerJournalTable.CurrencyCode)
            {
                currencyCode = ledgerJournalTable.CurrencyCode;
                if (ledgerJournalTable.FixedExchRate)
                {
                    exchRate = ledgerJournalTable.ExchRate;
                    exchRateSecond = ledgerJournalTable.ExchrateSecondary;
                    triangulation = ledgerJournalTable.euroTriangulation;
                }
                else
                {
                    ledgerJournalTrans.TransDate = _transDate;
                    ledgerJournalTrans.CurrencyCode = currencyCode;

                    [triangulationResult,
                    exchRate,
                    exchRateSecond,
                    exchRateSecondTxt] = LedgerJournalEngine_Server::currencyModified(ledgerJournalTrans);

                    triangulation = Currency::unknownNoYes2Noyes(triangulationResult);
                }
            }
            else
            {
                currencyCode = _custVendPaymProposalLine.CurrencyCode;
                ledgerJournalTrans.TransDate = _transDate;
                ledgerJournalTrans.CurrencyCode = currencyCode;

                // The exchange rates for the journal line from the company of the line, which in this case is the payment company
                changecompany(_custVendPaymProposalLine.AccountNumCompany)
                {
                    [triangulationResult,
                    exchRate,
                    exchRateSecond,
                    exchRateSecondTxt] = LedgerJournalEngine_Server::currencyModified(ledgerJournalTrans);

                    triangulation = Currency::unknownNoYes2Noyes(triangulationResult);
                }
            }
        }

        return [currencyCode, triangulation, exchRate, exchRateSecond];
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerJournalTransReportingCurrency</Name>
				<Source><![CDATA[
    private void setLedgerJournalTransReportingCurrency(LedgerJournalTrans _ledgerJournalTrans, DataAreaId _accountCompany)
    {
        ReportingCurrencyExchRate reportingExchangeRate;
        ReportingCurrencyExchRate reportingExchangeRateSecondary;
        ExchRateSecondTxt exchRateTxt;

        if (ledgerJournalTable.CurrencyCode)
        {
            if (ledgerJournalTable.ReportingCurrencyFixedExchRate)
            {
                reportingExchangeRate = ledgerJournalTable.ReportingCurrencyExchRate;
                reportingExchangeRateSecondary = ledgerJournalTable.ReportingCurrencyExchRateSecondary;
            }
            else
            {
                [reportingExchangeRate,
                 reportingExchangeRateSecondary,
                 exchRateTxt] = LedgerJournalEngine_Server::reportingCurrencyModified(_ledgerJournalTrans);
            }
        }
        else
        {
            changecompany(_accountCompany)
            {
                [reportingExchangeRate,
                 reportingExchangeRateSecondary,
                 exchRateTxt] = LedgerJournalEngine_Server::reportingCurrencyModified(_ledgerJournalTrans);
            }
        }

        _ledgerJournalTrans.ReportingCurrencyExchRate = reportingExchangeRate;
        _ledgerJournalTrans.ReportingCurrencyExchRateSecondary = reportingExchangeRateSecondary;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransInvoice</Name>
				<Source><![CDATA[
    protected InvoiceId getLedgerJournalTransInvoice(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        InvoiceId invoiceId;

        if (ledgerJournalTable.JournalType == LedgerJournalType::VendPaymRemittance
            || ledgerJournalTable.JournalType == LedgerJournalType::VendPromissoryNoteSettle)
        {
            invoiceId = _custVendPaymProposalLine.Invoice;
        }

        return invoiceId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransThirdPartyBankId</Name>
				<Source><![CDATA[
    protected BankAccountID getLedgerJournalTransThirdPartyBankId(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        BankAccountID bankAccountID = _custVendPaymProposalLine.ThirdPartyBankAccountID;

        if (!bankAccountID)
        {
            changecompany(_custVendPaymProposalLine.AccountNumCompany)
            {
                switch (_custVendPaymProposalLine.AccountType)
                {
                    case ModuleCustVend::Cust:
                        if (CustPaymModeTable::find(_custVendPaymProposalLine.PaymMode).IsSEPA)
                        {
                            // Get the bank account from the mandate of the invoice being included in the payment proposal
                            CustDirectDebitMandate mandate = CustDirectDebitMandate::find(CustTrans::find(CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId).DirectDebitMandate);
                            bankAccountID = mandate.BankAccount;
                        }
                        else
                        {
                            bankAccountID = CustTable::find(_custVendPaymProposalLine.AccountNum).BankAccount;
                        }
                        break;

                    case ModuleCustVend::Vend:
                        bankAccountID = VendTable::find(_custVendPaymProposalLine.AccountNum).BankAccount;
                        break;
                }
            }
        }

        return bankAccountID;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransTransDate</Name>
				<Source><![CDATA[
    protected TransDate getLedgerJournalTransTransDate(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        TransDate transDate;
        #ISOCountryRegionCodes

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && paymOnDateFixed_IT
            && (ledgerJournalTable.JournalType == LedgerJournalType::CustBillOfExchangeDraw
                || ledgerJournalTable.JournalType  == LedgerJournalType::VendPromissoryNoteDraw))
        {
            transDate = paymDate_IT;
        }
        else
        {
            transDate = _custVendPaymProposalLine.PaymDate;
        }

        return transDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymId</Name>
				<Source><![CDATA[
    protected PaymId getPaymId(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        PaymId paymId = _custVendPaymProposalLine.PaymId;

        if (!paymId)
        {
            paymId = CustVendPaymIdCalc::construct(_custVendPaymProposalLine).calcPaymId();
        }

        return paymId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransactionText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the transaction text for currently processed payment proposal line.
    /// </summary>
    /// <param name="_voucher">
    /// The voucher.
    /// </param>
    /// <param name="_custVendPaymProposalLine">
    /// Currently processed payment proposal line.
    /// </param>
    /// <param name="_custVendTrans">
    /// Customer or vendor transaction line related to currently processed payment proposal line; optional.
    /// </param>
    /// <returns>
    /// The transaction text.
    /// </returns>
    protected TransactionTxt getTransactionText(
        Voucher _voucher,
        CustVendPaymProposalLine _custVendPaymProposalLine,
        CustVendTrans _custVendTrans = this.retrieveCustVendTrans(_custVendPaymProposalLine))
    {
        CustVendTrans custVendTrans = _custVendTrans;
        LedgerTransTxt ledgerTransTxt;

        switch (ledgerJournalTable.JournalType)
        {
            case LedgerJournalType::CustPayment:
                ledgerTransTxt = LedgerTransTxt::CustPaymentCust;
                break;

            case LedgerJournalType::CustPaymRemittance:
            case LedgerJournalType::CustBillOfExchangeAccept:
            case LedgerJournalType::CustBillOfExchangeDraw:
            case LedgerJournalType::CustBillOfExchangeProtest:
            case LedgerJournalType::CustBillOfExchangeRedraw:
            case LedgerJournalType::CustBillOfExchangeSettle:
                ledgerTransTxt = LedgerTransTxt::CustBillOfExchangeCust;
                break;

            case LedgerJournalType::Payment:
                ledgerTransTxt = LedgerTransTxt::VendPaymentVend;
                break;

            case LedgerJournalType::VendPaymRemittance:
            case LedgerJournalType::VendPromissoryNoteDraw:
            case LedgerJournalType::VendPromissoryNoteRedraw:
            case LedgerJournalType::VendPromissoryNoteSettle:
                ledgerTransTxt = LedgerTransTxt::VendPromissoryNoteVend;
                break;

            default:
                CustVendTransStatic custVendTransStatic = _custVendPaymProposalLine.custVendTransStatic();
                switch (custVendTransStatic.moduleCustVend())
                {
                    case ModuleCustVend::Cust:
                        ledgerTransTxt = LedgerTransTxt::CustPaymentCust;
                        break;

                    case ModuleCustVend::Vend:
                        ledgerTransTxt = LedgerTransTxt::VendPaymentVend;
                        break;

                    default:
                        this.logMessage(Exception::Error, Error::wrongUseOfFunction(funcName()));
                }
                break;
        }

        TransactionTxt transactionTxt = TransactionTxt::construct(ledgerTransTxt);
        transactionTxt.setDate(_custVendPaymProposalLine.PaymDate);
        transactionTxt.setVoucher(_voucher);
        transactionTxt.setKey1(_custVendPaymProposalLine.AccountNum);
        transactionTxt.setFormLetter(custVendTrans.DocumentNum ? custVendTrans.DocumentNum : custVendTrans.Invoice);

        if (TransactionTextContext::isTypeSupported(ledgerTransTxt))
        {
            TransactionTextContext transactionTextContext = TransactionTextContext::newForTransactionType(ledgerTransTxt);

            if (ledgerTransTxt == LedgerTransTxt::CustPaymentCust)
            {
                transactionTextContext.setTableBuffer(CustTrans::find(CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId));
            }
            else if (ledgerTransTxt == LedgerTransTxt::VendPaymentVend)
            {
                transactionTextContext.setTableBuffer(VendTrans::findCrossCompany(VendTransOpen::findCrossCompany(_custVendPaymProposalLine.TransOpenRecId).RefRecId));
            }

            transactionTxt.setTransactionTextContext(transactionTextContext);
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            if (ledgerTransTxt == LedgerTransTxt::CustPaymentCust)
            {
                transactionTxt.setCustVendName(CustTrans::find(CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId).custTableName());
            }
            else if (ledgerTransTxt == LedgerTransTxt::VendPaymentVend)
            {
                transactionTxt.setCustVendName(VendTrans::find(VendTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId).vendTableName());
            }
        }
        // </GBR>
        return transactionTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVoucherNum</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Gets the voucher number for journal lines.
    /// </summary>
    /// <returns>
    ///     The voucher number.
    /// </returns>
    protected Voucher getVoucherNum()
    {
        Voucher voucher;

        if (this.isNewVoucherOneVoucher())
        {
            LedgerJournalTrans ledgerJournalTrans;

            select firstonly Voucher from ledgerJournalTrans
                where ledgerJournalTrans.JournalNum == ledgerJournalTable.JournalNum;

            if (ledgerJournalTrans)
            {
                voucher = ledgerJournalTrans.Voucher;
            }
        }

        if (voucher == '')
        {
            voucher = new JournalVoucherNum(ledgerJournalTableData).getNew(false);
        }

        return voucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalId</Name>
				<Source><![CDATA[
    internal LedgerJournalId getLedgerJournalId()
    {
        return ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNewVoucherOneVoucher</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Checks whether the new voucher is of type one voucher.
    /// </summary>
    /// <returns>
    ///     true if the new voucher is of type one voucher; otherwise, false.
    /// </returns>
    protected boolean isNewVoucherOneVoucher()
    {
        return newVoucher == NewVoucher::OneVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustVendTrans_W</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes from customer and vendor transactions map.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">
    ///     The record in the <c>LedgerJournalTrans</c> table to initialize.
    /// </param>
    /// <param name = "_custVendPaymProposalLine">
    ///     The record in the <c>LedgerJournalTrans</c> table to which to copy values to the record to initialize.
    /// </param>
    protected void initFromCustVendTrans_W(LedgerJournalTrans _ledgerJournalTrans, CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        VendTable vendTable;

        if (_custVendPaymProposalLine.vatPaymRefRecId_RU)
        {
            vendTable = VendTable::find(CustVendPaymProposalLine::find(_custVendPaymProposalLine.vatPaymRefRecId_RU).AccountNum);
        }
        else
        {
            CustVendPaymProposalLine custVendPaymProposalLineTaxAuthority;
            select firstonly custVendPaymProposalLineTaxAuthority
                where custVendPaymProposalLineTaxAuthority.vatPaymRefRecId_RU == _custVendPaymProposalLine.RecId;

            if (custVendPaymProposalLineTaxAuthority)
            {
                CustVendTrans custVendTrans;
                SpecTrans specTrans;
                TaxTrans taxTrans;
                TaxTrans_RU taxTrans_RU;
                while select crossCompany specTrans
                    where specTrans.SpecCompany == _custVendPaymProposalLine.DataAreaId
                        && specTrans.SpecTableId == _custVendPaymProposalLine.TableId
                        && specTrans.SpecRecId == _custVendPaymProposalLine.RecId
                {
                    switch (_custVendPaymProposalLine.custVendTransStatic().moduleCustVend())
                    {
                        case ModuleCustVend::Cust:
                            custVendTrans = specTrans.custTrans();
                            break;

                        case ModuleCustVend::Vend:
                            custVendTrans = specTrans.vendTrans();
                            break;

                        default:
                            this.logMessage(Exception::Error, Error::wrongUseOfFunction(funcName()));
                    }

                    select firstonly vatOperationCode_RU from taxTrans_RU
                        exists join taxTrans
                        where taxTrans_RU.TaxTrans == taxTrans.RecId
                            && taxTrans.Voucher   == custVendTrans.Voucher
                            && taxTrans.TransDate == custVendTrans.TransDate
                            && taxTrans.TaxCode   == custVendPaymProposalLineTaxAuthority.InvoiceTaxCode_RU;

                    if (taxTrans_RU)
                    {
                        if (!vatOperationCodeMap)
                        {
                            vatOperationCodeMap = new Map(Types::Int64, Types::String);
                        }

                        if (vatOperationCodeMap.exists(_custVendPaymProposalLine.RecId)
                            && vatOperationCodeMap.lookup(_custVendPaymProposalLine.RecId) != taxTrans_RU.vatOperationCode_RU)
                        {
                            vatOperationCodeMap.insert(_custVendPaymProposalLine.RecId, '');
                        }
                        else
                        {
                            vatOperationCodeMap.insert(_custVendPaymProposalLine.RecId, taxTrans_RU.vatOperationCode_RU);
                        }
                    }
                }
            }
        }

        AgreementHeaderExt_RU agreementHeaderExt = AgreementHeaderExt_RU::findByDefaultDimension(_custVendPaymProposalLine.DefaultDimension);
        if (agreementHeaderExt)
        {
            _ledgerJournalTrans.AccountAgreementId_RU = agreementHeaderExt.AgreementId;
            _ledgerJournalTrans.initAgreementDimension_RU(agreementHeaderExt, AccountOffsetaccount::Account, true);
        }

        if ((_custVendPaymProposalLine.AccountType == ModuleCustVend::Cust
                && (CustParameters::find().CopyInvoiceDimension_RU
                    || CustParameters::find().DimSettlementCtrlType_RU != DimSettlementCtrlType_RU::None))
            || (_custVendPaymProposalLine.AccountType == ModuleCustVend::Vend
                && (VendParameters::find().CopyInvoiceDimension_RU
                    || VendParameters::find().DimSettlementCtrlType_RU != DimSettlementCtrlType_RU::None)))
        {
            _ledgerJournalTrans.DefaultDimension = _custVendPaymProposalLine.DefaultDimension;
        }

        if (_custVendPaymProposalLine.vatPaymRefRecId_RU)
        {
            _ledgerJournalTrans.AmountCurDebit = _custVendPaymProposalLine.PaymVATAmount_RU;
            _ledgerJournalTrans.SettleVoucher = SettlementType::None;
            _ledgerJournalTrans.TaxCode = _custVendPaymProposalLine.InvoiceTaxCode_RU;
            _ledgerJournalTrans.CurrencyCode = CompanyInfoHelper::standardCurrency();

            UnknownNoYes triangulationResult;
            ExchRateSecondTxt exchRateSecondTxt;
            [triangulationResult,
             _ledgerJournalTrans.ExchRate,
             _ledgerJournalTrans.ExchRateSecond,
             exchRateSecondTxt] = LedgerJournalEngine_Server::currencyModified(_ledgerJournalTrans);
            _ledgerJournalTrans.Triangulation = Currency::unknownNoYes2Noyes(triangulationResult);

            VendName vendName = vendTable.name();
            _ledgerJournalTrans.BankCentralBankPurposeText = strFmt(
                "@GLS112886",
                vendName ? vendName : vendTable.AccountNum,
                vendTable.postalAddress().Address);

            _ledgerJournalTrans.vatTaxAgentVendAccount_RU  = vendTable.AccountNum;
            if (vatOperationCodeMap && vatOperationCodeMap.exists(_custVendPaymProposalLine.vatPaymRefRecId_RU))
            {
                _ledgerJournalTrans.vatOperationCode_RU = vatOperationCodeMap.lookup(_custVendPaymProposalLine.vatPaymRefRecId_RU);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initLedgerJournalTransFromPaymLine</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the current record in the <c>LedgerJournalTrans</c> table, depending on the data in the
    ///    specified record in the <c>CustVendPaymProposalLine</c> table.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    ///    The record in the <c>LedgerJournalTrans</c> table to initialize.
    /// </param>
    /// <param name="_custVendPaymProposalLine">
    ///    The record in the <c>LedgerJournalTrans</c> table to which to copy values to the record to
    ///    initialize.
    /// </param>
    /// <returns>
    ///    The record in the <c>LedgerJournalTrans</c> table that is initialized.
    /// </returns>
    protected LedgerJournalTrans initLedgerJournalTransFromPaymLine(LedgerJournalTrans _ledgerJournalTrans, CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        #ISOCountryRegionCodes

        if (!ledgerJournalTable)
        {
            this.logMessage(Exception::Error, "@SYS26538");
        }

        CustVendTrans custVendTrans = this.retrieveCustVendTrans(_custVendPaymProposalLine);

        LedgerJournalTrans ledgerJournalTrans = _ledgerJournalTrans;
        ledgerJournalTrans.initValue();

        ledgerJournalTrans.TransDate = this.getLedgerJournalTransTransDate(_custVendPaymProposalLine);

        if (custVendTrans.TableId == tableNum(VendTrans))
        {
            VendTrans vendTrans = custVendTrans;
            changecompany(vendTrans.DataAreaId)
            {
                if (!vendTrans.isVendPaymEligibleForTransfer(ledgerJournalTrans.TransDate))
                {
                    this.atLeastOneLineIsNotEligibleForTransfer(true);
                    return null;
                }
            }
        }

        CustVendPaymModeTable custVendPaymModeTable =_custVendPaymProposalLine.paymModeTable();
        CustVendTable custVendTable = _custVendPaymProposalLine.custVendTable();

        ledgerJournalTrans.JournalNum = _custVendPaymProposalLine.JournalId;
        ledgerJournalTrans.Approved = NoYes::Yes;
        ledgerJournalTrans.Approver = hcmWorkerRecId;
        ledgerJournalTrans.SettleVoucher = SettlementType::SelectedTransact;
        ledgerJournalTrans.Due = _custVendPaymProposalLine.maxDueDate();
        ledgerJournalTrans.BankRemittanceType = _custVendPaymProposalLine.BankRemittanceType;
        ledgerJournalTrans.BankAccountId = _custVendPaymProposalLine.CompanyBankAccountIdNegInst;
        ledgerJournalTrans.CustVendBankAccountId = this.getLedgerJournalTransThirdPartyBankId(_custVendPaymProposalLine);
        ledgerJournalTrans.BankCentralBankPurposeCode = custVendTable.BankCentralBankPurposeCode;
        ledgerJournalTrans.BankCentralBankPurposeText = custVendTable.BankCentralBankPurposeText;
        ledgerJournalTrans.BankTransType = custVendPaymModeTable.BankTransType;
        ledgerJournalTrans.PaymId = this.getPaymId(_custVendPaymProposalLine);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoFR])
            && CustPaymModeTable::find(custVendPaymModeTable.PaymMode).PaymentType == CustPaymentType::BillOfExchange)
        {
            ledgerJournalTrans.DocumentNum = custVendTrans.DocumentNum;
            ledgerJournalTrans.DocumentDate = custVendTrans.DocumentDate;
        }
        else
        {
            ledgerJournalTrans.DocumentNum = ledgerJournalTable.DocumentNum;

            if (!DrawBOEWithPaymProposalSkipSetDocumentDateFlight::instance().isEnabled()
                || !SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
                || ledgerJournalTable.JournalType != LedgerJournalType::CustBillOfExchangeDraw)
            {
                ledgerJournalTrans.DocumentDate = ledgerJournalTrans.TransDate;
            }
        }

        if (includeInvoicesFromOtherCompanies)
        {
            // Posting profile is intentionally transferred as empty when combining invoices from multiple companies
            _custVendPaymProposalLine.PostingProfile = '';
        }
        else
        {
            ledgerJournalTrans.PostingProfile = _custVendPaymProposalLine.PostingProfile;
        }

        if (VendParameters::find().ConfirmingInvoices)
        {
            ledgerJournalTrans.Invoice = this.getLedgerJournalTransInvoice(_custVendPaymProposalLine);
        }

        ledgerJournalTrans.TransactionType = LedgerTransType::Payment;
        ledgerJournalTrans.Company = _custVendPaymProposalLine.AccountNumCompany;

        switch (_custVendPaymProposalLine.AccountType)
        {
            case ModuleCustVend::Cust:
                ledgerJournalTrans.AccountType = LedgerJournalACType::Cust;

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
                {
                    ledgerJournalTrans.BankCentralBankPurposeCode = _custVendPaymProposalLine.BankCentralBankPurposeCode;
                    ledgerJournalTrans.BankCentralBankPurposeText = _custVendPaymProposalLine.BankCentralBankPurposeText;
                }

                if (ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance)
                {
                    if (!ledgerJournalTrans.DocumentNum)
                    {
                        ledgerJournalTrans.DocumentNum = CustTrans::find(CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId).DocumentNum;
                    }
                    if (!ledgerJournalTrans.CustVendBankAccountId)
                    {
                        ledgerJournalTrans.CustVendBankAccountId = CustTrans::find(CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId).ThirdPartyBankAccountId;
                    }
                }

                if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled() || BrazilParameters::isEnabled())
                {
                    ledgerJournalTrans.TaxWithholdCalculate_TH = NoYes::Yes;
                    ledgerJournalTrans.TaxWithholdGroup = CustTable::find(custVendTable.AccountNum).TaxWithholdGroup_TH;
                }

                this.initMarkedInvoice(ledgerJournalTrans, _custVendPaymProposalLine);

                break;

            case ModuleCustVend::Vend:
                ledgerJournalTrans.AccountType = LedgerJournalACType::Vend;
                ledgerJournalTrans.TaxWithholdGroup = VendTable::findByDataAreaId(custVendTable.AccountNum, ledgerJournalTrans.Company).TaxWithholdGroup;
                ledgerJournalTrans.RemittanceLocation = _custVendPaymProposalLine.RemittanceLocation;
                LogisticsPostalAddress logisticsPostalAddress = LogisticsLocationEntity::location2PostalAddress(ledgerJournalTrans.RemittanceLocation, DateTimeUtil::getSystemDateTime(), true);
                ledgerJournalTrans.RemittanceAddress = logisticsPostalAddress.RecId;

                if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]))
                {
                    ledgerJournalTrans.BankCentralBankPurposeCode = _custVendPaymProposalLine.BankCentralBankPurposeCode;
                    ledgerJournalTrans.BankCentralBankPurposeText = _custVendPaymProposalLine.BankCentralBankPurposeText;
                }
                // <GTH>
                if (TaxThaiGovCertificationFeatureChecker::isTaxWithholdEnabled())
                {
                    ledgerJournalTrans.TaxWithholdCalculate_TH = VendTable::find(custVendTable.AccountNum).TaxWithholdCalculate;
                }
                // </GTH>
                // <GJP>
                if (VendPaymFeeUtil_JP::isVendorPaymFeeEnabled())
                {
                    ledgerJournalTrans.VendPaymFeeGroup_JP = VendTable::find(custVendTable.AccountNum).VendPaymFeeGroup_JP;
                }
                // </GJP>

                break;
        }

        if (custVendPaymModeTable)
        {
            ledgerJournalTrans.PaymMode = _custVendPaymProposalLine.PaymMode;

            if (_custVendPaymProposalLine.PaymSpec != '')
            {
                if (_custVendPaymProposalLine.AccountNumCompany == ledgerJournalTrans.company()
                    || this.doesPaymModeSpecExistInPaymentCompany(_custVendPaymProposalLine))
                {
                    ledgerJournalTrans.PaymSpec = _custVendPaymProposalLine.PaymSpec;
                }
                else
                {
                    ledgerJournalTrans.PaymModeMap::modifiedPaymMode();
                }
            }
        }

        ledgerJournalTrans.parmAccount(_custVendPaymProposalLine.AccountNum);

        if (_custVendPaymProposalLine.PaymAccountType == LedgerJournalACType::Ledger)
        {
            ledgerJournalTrans.OffsetAccountType = LedgerJournalACType::Ledger;
            ledgerJournalTrans.parmOffsetLedgerDimension(_custVendPaymProposalLine.parmLedgerDimension());
        }
        else
        {
            ledgerJournalTrans.parmOffsetAccount(_custVendPaymProposalLine.parmPaymAccount(), _custVendPaymProposalLine.PaymAccountType);
        }

        // <GIN>
        boolean countryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);
        if (countryRegion_IN && TaxWithholdParameters_IN::checkTaxParameters())
        {
            changeCompany(_custVendPaymProposalLine.AccountNumCompany)
            {
                ledgerJournalTrans = this.initWithholdingTaxGroup_IN(
                    _custVendPaymProposalLine.AccountNum,
                    _custVendPaymProposalLine.AccountNumCompany,
                    ledgerJournalTrans,
                    _custVendPaymProposalLine.AccountType);
            }
        }
        // </GIN>

        [ledgerJournalTrans.CurrencyCode,
         ledgerJournalTrans.Triangulation,
         ledgerJournalTrans.ExchRate,
         ledgerJournalTrans.ExchRateSecond] = this.getLedgerJournalTransCurrency(_custVendPaymProposalLine, ledgerJournalTrans.TransDate);

        this.setLedgerJournalTransReportingCurrency(ledgerJournalTrans, _custVendPaymProposalLine.AccountNumCompany);

        if (!ledgerJournalTrans.Voucher)
        {
            ledgerJournalTrans.Voucher = this.getVoucherNum();
        }

        ledgerJournalTrans.Txt = this.getTransactionText(ledgerJournalTrans.Voucher, _custVendPaymProposalLine, custVendTrans).txt();
        
        if (!ledgerJournalTrans.Txt && ledgerJournalTable.JournalType == LedgerJournalType::CustPaymRemittance)
        {
            ledgerJournalTrans.Txt = CustTrans::find(CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId).Txt;
        }

        ledgerJournalTrans.PaymentNotes = _custVendPaymProposalLine.paymNote();

        this.setLedgerJournalTransAmount(ledgerJournalTrans, _custVendPaymProposalLine);

        // Set the default dimension
        LedgerJournalEngine ledgerJournalEngine = this.constructLedgerJournalEngine();
        this.initDefaultDimension(ledgerJournalEngine, ledgerJournalTrans);

        // <GEERU>
        boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);
        if (countryRegion_RU)
        {
            this.initFromCustVendTrans_W(ledgerJournalTrans, _custVendPaymProposalLine);
        }
        // </GEERU>

        // For norwegian features, the dimension field is taken from paym proposal line
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoNO]) || TaxThaiGovCertificationFeatureChecker::isTaxBranchEnabled())
        {
            ledgerJournalTrans.DefaultDimension = _custVendPaymProposalLine.DefaultDimension;
        }

        this.initOffsetDefaultDimension(ledgerJournalEngine, ledgerJournalTrans);

        // <GCN>
        if (LedgerParameters::isChineseVoucher_CN())
        {
            ledgerJournalTrans.LedgerVoucherType_CN = LedgerVoucherType_CN::findByNaturalKey(_custVendPaymProposalLine.VoucherTypeId_CN).RecId;
            ledgerJournalTrans = this.setVoucher_CN(ledgerJournalTrans);
        }
        // </GCN>

        boolean enableLedgerTrans_W = LedgerJournalTrans_W::isLegalEntitySupported();

        if (enableLedgerTrans_W)
        {
            LedgerJournalTrans_W ledgerJournalTrans_W = ledgerJournalTrans.ledgerJournalTrans_W();
            if (ledgerJournalTrans.PaymSpec)
            {
                CustVendPaymModeSpec custVendPaymModeSpec = CustVendPaymModeSpec::findCommon(ledgerJournalTrans);
                ledgerJournalTrans_W.initFromProvidedLedgerJournalTable_W(ledgerJournalTable);
                ledgerJournalTrans_W.initFromPaymSpec_generic(custVendPaymModeSpec);
                ledgerJournalTrans_W.initFromPaymModeTable_generic(custVendPaymModeTable);
            }
            else
            {
                ledgerJournalTrans_W.initFromProvidedLedgerJournalTable_W(ledgerJournalTable);
                ledgerJournalTrans_W.initFromPaymModeTable_generic(custVendPaymModeTable);
            }
            ledgerJournalTrans.packLedgerJournalTrans_W(ledgerJournalTrans_W);
        }

        if (isPaymentRequestsKeyEnabled)
        {
            ledgerJournalTrans.Prepayment = _custVendPaymProposalLine.CFMPrepayment;
            ledgerJournalTrans.TaxGroup = _custVendPaymProposalLine.CFMTaxGroup;
            ledgerJournalTrans.TaxItemGroup = _custVendPaymProposalLine.CFMTaxItemGroup;

            if (countryRegion_RU
                && custVendTrans.TableId == tableNum(VendTrans)
                && ledgerJournalTrans.Prepayment)
            {
                VendParameters vendParameters = VendParameters::find();
                ledgerJournalTrans.TaxGroup = vendParameters.TaxGroup_W;
                ledgerJournalTrans.TaxItemGroup = vendParameters.TaxItemGroup_W;
            }
        }

        ledgerJournalTrans.LineNum = _custVendPaymProposalLine.TmpRecId;

        if (isPaymentRequestsKeyEnabled && countryRegion_RU)
        {
            ledgerJournalTrans.BankCentralBankPurposeText += this.paymentRequestTaxPurposeText(_custVendPaymProposalLine, ledgerJournalTrans);
        }

        ledgerJournalTrans.write();

        boolean canPostponeSpecTransUpdate = (ledgerJournalTrans.TaxWithholdGroup == '');

        if (canPostponeSpecTransUpdate)
        {
            this.trackSpecTransForUpdate(_custVendPaymProposalLine, ledgerJournalTrans);
        }
        else
        {
            this.updateSpecTransSingle(_custVendPaymProposalLine, ledgerJournalTrans);
        }

        if (isPaymentRequestsKeyEnabled)
        {
            this.movePaymentRequestLink(_custVendPaymProposalLine, ledgerJournalTrans);
            if (countryRegion_RU)
            {
                this.initPaymentOrderBudgetTransFromPR(ledgerJournalTrans, _custVendPaymProposalLine);
            }
        }
        else if (countryRegion_RU)
        {
            LedgerJournalEngine::initPaymentOrderBudgetTrans(ledgerJournalTrans);
        }

        // <GIN>
        if (countryRegion_IN)
        {
            LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionIN = LedgerJournalTransTaxExtensionIN::findByLedgerJournalTrans(ledgerJournalTrans.RecId, true);
            if (ledgerJournalTransTaxExtensionIN.RecId == 0)
            {
                ledgerJournalTransTaxExtensionIN.LedgerJournalTrans = ledgerJournalTrans.RecId;
                ledgerJournalTransTaxExtensionIN.write();
            }
        }
        // </GIN>

        if (TaxIntegrationPaymProposalInitOverrideSalesTaxFlight::instance().isEnabled()
            && _ledgerJournalTrans.isTaxIntegrationEnabled())
        {
            LedgerJournalTransTaxExtension ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtension();
            ledgerJournalTransTaxExt.OverrideSalesTax = ledgerJournalTransTaxExt.determineDefaultOverrideSalesTax();
            ledgerJournalTransTaxExt.write();
        }

        // <GTH>
        if (TaxThaiGovCertificationFeatureChecker::isCountryRegionTH())
        {
            LedgerJournalTransExtensionTH ledgerJournalTransExtensionTH = LedgerJournalTransExtensionTH::findByLedgerJournalTrans(ledgerJournalTrans.RecId, true);
            if (ledgerJournalTransExtensionTH.RecId == 0)
            {
                ledgerJournalTransExtensionTH.updateTaxBranchFromCustVendTable(custVendTable);
                ledgerJournalTransExtensionTH.LedgerJournalTrans = ledgerJournalTrans.RecId;
                ledgerJournalTransExtensionTH.write();
            }
        }
        // </GTH>

        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Bank
            && (!BankAccountTable::isActive(ledgerJournalTrans.parmAccount(), ledgerJournalTrans.TransDate)))
        {
            ledgerJournalTrans.parmAccount('', LedgerJournalACType::Bank);
        }

        if (ledgerJournalTrans.OffsetAccountType == LedgerJournalACType::Bank
            && (!BankAccountTable::isActive(ledgerJournalTrans.parmOffsetAccount(), ledgerJournalTrans.TransDate)))
        {
            ledgerJournalTrans.parmOffsetAccount('', LedgerJournalACType::Bank);
        }

        // <GBR>
        if (BrazilParameters::isEnabled())
        {
            LedgerJournalTransPayment_BR ledgerJournalTransPayment_BR = ledgerJournalTrans.getPaymentExtension_BR();
            ledgerJournalTransPayment_BR.epPaymentType_BR = _custVendPaymProposalLine.epPaymentType_BR;
            ledgerJournalTransPayment_BR.epPaymentWay_BR  = _custVendPaymProposalLine.epPaymentWay_BR;
            ledgerJournalTrans.packExtensionTable(ledgerJournalTransPayment_BR);

            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend)
            {
                ttsbegin;
                VendEPRemitInfo_BR vendEPRemitInfo = VendEPRemitInfo_BR::find(ledgerJournalTrans.RecId, true);
                if (vendEPRemitInfo)
                {
                    vendEPRemitInfo.TypedLine   = _custVendPaymProposalLine.epTypedLine_BR;
                    vendEPRemitInfo.BarCodeInfo = _custVendPaymProposalLine.epBarCodeInfo_BR;
                    vendEPRemitInfo.update();
                }
                ttscommit;
            }
            if (ledgerJournalTrans.AccountType == LedgerJournalACType::Cust)
            {
                ttsbegin;
                CustEPRemitInfo_BR custEPRemitInfo = CustEPRemitInfo_BR::find(ledgerJournalTrans.RecId, true);
                if (custEPRemitInfo)
                {
                    custEPRemitInfo.BankFolder      = _custVendPaymProposalLine.epBankFolder_BR;
                    custEPRemitInfo.DocumentType    = _custVendPaymProposalLine.epDocumentType_BR;
                    custEPRemitInfo.Instruction_1   = _custVendPaymProposalLine.epInstruction_1_BR;
                    custEPRemitInfo.Instruction_2   = _custVendPaymProposalLine.epInstruction_2_BR;
                    custEPRemitInfo.update();
                }
                ttscommit;
            }
            ledgerJournalTrans.handleWriteTaxWithholdEditStatus_BR();
        }
        // </GBR>

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructLedgerJournalEngine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Construct the ledger journal engine.
    /// </summary>
    /// <returns>The ledger journal engine.</returns>
    protected LedgerJournalEngine constructLedgerJournalEngine()
    {
        return LedgerJournalEngine::construct(ledgerJournalTable.JournalType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the default dimension.
    /// </summary>
    /// <param name = "_ledgerJournalEngine">The ledger journal engine.</param>
    /// <param name = "_ledgerJournalTrans">The payment journal line.</param>
    protected void initDefaultDimension(LedgerJournalEngine _ledgerJournalEngine, LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalEngine.initDefaultDimension(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initOffsetDefaultDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the offset default dimension.
    /// </summary>
    /// <param name = "_ledgerJournalEngine">The ledger journal engine.</param>
    /// <param name = "_ledgerJournalTrans">The payment journal line.</param>
    protected void initOffsetDefaultDimension(LedgerJournalEngine _ledgerJournalEngine, LedgerJournalTrans _ledgerJournalTrans)
    {
        _ledgerJournalEngine.initOffsetDefaultDimension(_ledgerJournalTrans);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWithholdingTaxGroup_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize withholding tax group data.
    /// </summary>
    /// <param name="_account">
    /// The account number.
    /// </param>
    /// <param name="_companyId">
    /// The current company id.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// A <c>LedgerJournalTrans</c> buffer.
    /// </param>
    /// <param name="_accountType">
    /// The account type.
    /// </param>
    /// <returns>
    /// A <c>LedgerJournalTrans</c> buffer.
    /// </returns>
    protected LedgerJournalTrans initWithholdingTaxGroup_IN(
        AccountNum _account,
        CompanyId _companyId,
        LedgerJournalTrans _ledgerJournalTrans,
        ModuleCustVend _accountType)
    {
        LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExt = _ledgerJournalTrans.ledgerJournalTransTaxExtensionIN();

        switch (_accountType)
        {
            case ModuleCustVend::Cust:
                CustTable custTable = CustTable::findByCompany(_companyId, _account, false);
                TaxInformationCustTable_IN taxInformationCustTableLoc = custTable.getTaxInformationCustTable_IN();
                ledgerJournalTransTaxExt.tdsGroup = taxInformationCustTableLoc.tdsGroup;
                ledgerJournalTransTaxExt.tcsGroup = taxInformationCustTableLoc.tcsGroup;
                break;

            case ModuleCustVend::Vend:
                VendTable vendTable = VendTable::findByCompany(_companyId, _account, false);
                TaxInformationVendTable_IN taxInformationVendTableLoc = vendTable.getTaxInformationVendTable_IN();
                ledgerJournalTransTaxExt.tdsGroup = taxInformationVendTableLoc.tdsGroup;
                ledgerJournalTransTaxExt.tcsGroup = taxInformationVendTableLoc.tcsGroup;
                break;

            default:
                break;
        }
        // When propose seperate vendor payment per company is marked then filled tax information based on company selected at journal line level.
        _ledgerJournalTrans.SalesPurchJournalLine::initFromCompanyInformation(_ledgerJournalTrans.Company);

        return _ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logMessage</Name>
				<Source><![CDATA[
    [Hookable(false)]
    protected void logMessage(Exception _exceptionType, SysInfoLogStr _message, URL _helpUrl = '', SysInfoAction _sysInfoAction = null)
    {
        if (this.parmIsAutomation() && this.parmProcessExecutionSourceLinkRecId() != 0)
        {
            ProcessExecutionMessageLogItem messageLogItem = ProcessExecutionMessageLogItem::construct();
            messageLogItem.parmProcessExecutionSourceLink(this.parmProcessExecutionSourceLinkRecId());
            messageLogItem.parmException(_exceptionType);
            messageLogItem.parmMessage(_message);

            ProcessExecutionMessageLog::insertMessage(messageLogItem);
        }
        else
        {
            if (_exceptionType != Exception::Error)
            {
                infolog.add(_exceptionType, getPrefix() + _message, _helpUrl, _sysInfoAction, false);
            }
        }

        if (_exceptionType == Exception::Error)
        {
            throw error(_message, _helpUrl, _sysInfoAction);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mixedPaymMode</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the journal associated with the payment proposal holds lines with different
    ///    payment methods.
    /// </summary>
    /// <returns>
    ///    false if the journal only holds lines with the same unique payment method; otherwise, true.
    /// </returns>
    protected boolean mixedPaymMode()
    {
        Counter counter;
        LedgerJournalTrans ledgerJournalTrans;

        while select PaymMode from ledgerJournalTrans group by PaymMode
            where ledgerJournalTrans.JournalNum == ledgerJournalId
        {
            counter++;
            if (counter > 1)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>trackSpecTransForUpdate</Name>
				<Source><![CDATA[
    protected void trackSpecTransForUpdate(CustVendPaymProposalLine _custVendPaymProposalLine, LedgerJournalTrans _ledgerJournalTrans)
    {
        specTransUpdateTmp.FromSpecCompany = _custVendPaymProposalLine.DataAreaId;
        specTransUpdateTmp.FromSpecTableId = _custVendPaymProposalLine.TableId;
        specTransUpdateTmp.FromSpecRecId = _custVendPaymProposalLine.RecId;
        specTransUpdateTmp.ToSpecCompany = _ledgerJournalTrans.DataAreaId;
        specTransUpdateTmp.ToSpecTableId = _ledgerJournalTrans.TableId;
        specTransUpdateTmp.ToSpecRecId = _ledgerJournalTrans.RecId;
        specTransUpdateTmp.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSpecTransSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the <c>SpecTrans</c> table buffer.
    /// </summary>
    protected void updateSpecTransSet()
    {
        SpecTrans specTrans;

        specTrans.skipDataMethods(true);
        specTrans.skipDatabaseLog(true);
        specTrans.skipEvents(true);

        update_recordset specTrans
            setting SpecCompany = specTransUpdateTmp.ToSpecCompany,
                SpecTableId = specTransUpdateTmp.ToSpecTableId,
                SpecRecId = specTransUpdateTmp.ToSpecRecId
            join specTransUpdateTmp
                where specTrans.SpecCompany == specTransUpdateTmp.FromSpecCompany
                    && specTrans.SpecTableId == specTransUpdateTmp.FromSpecTableId
                    && specTrans.SpecRecId == specTransUpdateTmp.FromSpecRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSpecTransSingle</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Updates the <c>SpecTrans</c> table buffer based on the given data for <c>LedgerJournalTrans</c> and <c>CustVendPaymProposalLine</c> table buffer.
    /// </summary>
    /// <param name = "_custVendPaymProposalLine">
    ///     An instance of <c>CustVendPaymProposalLine</c> table buffer.
    /// </param>
    /// <param name = "_ledgerJournalTrans">
    ///     An instatnce of <c>LedgerJournalTrans</c> table buffer.
    /// </param>
    protected void updateSpecTransSingle(CustVendPaymProposalLine _custVendPaymProposalLine, LedgerJournalTrans _ledgerJournalTrans)
    {
        SpecTrans specTrans;

        specTrans.skipDataMethods(true);
        specTrans.skipDatabaseLog(true);
        specTrans.skipEvents(true);

        update_recordset specTrans
            setting SpecCompany = _ledgerJournalTrans.DataAreaId,
                SpecTableId = tableNum(LedgerJournalTrans),
                SpecRecId = _ledgerJournalTrans.RecId
            where specTrans.SpecCompany == _custVendPaymProposalLine.DataAreaId
                && specTrans.SpecTableId == _custVendPaymProposalLine.TableId
                && specTrans.SpecRecId == _custVendPaymProposalLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
        isPaymentRequestsKeyEnabled = CFMParameters::isPaymentRequestsEnabled();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        container packed = [#CurrentVersion, #CurrentList];

        if (FeatureStateProvider::isFeatureEnabled(CustVendPaymProposalTopPickingFeature::instance()))
        {
            packed = SysPackExtensions::appendVariableToPack(packed, this.name(), varStr(fromProposalRecId), fromProposalRecId);
            packed = SysPackExtensions::appendVariableToPack(packed, this.name(), varStr(toProposalRecId), toProposalRecId);
            packed = SysPackExtensions::appendVariableToPack(packed, this.name(), varStr(isInTopPicking), isInTopPicking);
        }

        return packed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerJournalId</Name>
				<Source><![CDATA[
    protected void setLedgerJournalId(LedgerJournalId _ledgerJournalId)
    {
        ledgerJournalId = _ledgerJournalId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setModuleCustVend</Name>
				<Source><![CDATA[
    public void setModuleCustVend(ModuleCustVend _moduleCustVend)
    {
        moduleCustVend = _moduleCustVend;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setIncludeInvoicesFromOtherCompanies</Name>
				<Source><![CDATA[
    public void setIncludeInvoicesFromOtherCompanies(NoYes _includeInvoicesFromOtherCompanies)
    {
        includeInvoicesFromOtherCompanies = _includeInvoicesFromOtherCompanies;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymDate_IT</Name>
				<Source><![CDATA[
    public void setPaymDate_IT(TransDate _paymDate_IT)
    {
        paymDate_IT = _paymDate_IT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymOnDateFixed_IT</Name>
				<Source><![CDATA[
    public void setPaymOnDateFixed_IT(NoYes _paymOnDateFixed_IT)
    {
        paymOnDateFixed_IT = _paymOnDateFixed_IT;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeUnmarkedJournalLines</Name>
				<Source><![CDATA[
    protected void removeUnmarkedJournalLines()
    {
        CustVendPaymProposalLine paymProposalLine;
        SpecTrans specTrans;
        LedgerJournalTrans ledgerJournalTrans;

        ttsbegin;

        while select LedgerJournalTransRecId from paymProposalLine
            where paymProposalLine.JournalId == ledgerJournalId
                && paymProposalLine.LedgerJournalTransRecId != 0
        notexists join specTrans
            where specTrans.SpecCompany == paymProposalLine.DataAreaId
                && specTrans.SpecTableId == paymProposalLine.TableId
                && specTrans.SpecRecId == paymProposalLine.RecId
        {
            // <GCN>
            if (LedgerParameters::isChineseVoucher_CN())
            {
                ledgerJournalTrans = LedgerJournalTrans::findRecId(paymProposalLine.LedgerJournalTransRecId, true);

                NumberSeq_Voucher_CN::release(
                    LedgerVoucherType_CN::find(ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable,
                    ledgerJournalTrans.Voucher_CN,
                    ledgerJournalTrans.TransDate);
            }
            // </GCN>

            delete_from ledgerJournalTrans
                where ledgerJournalTrans.RecId == paymProposalLine.LedgerJournalTransRecId;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeUnwantedJournalLines</Name>
				<Source><![CDATA[
    public void removeUnwantedJournalLines()
    {
        using (SysInstrumentationActivityContext activityContext = this.createProgressLogger().activityContextForStage(CustVendInstrumentationConstants::PaymentProposalRemoveJournalLines))
        {
            ttsbegin;

            this.removeUnmarkedJournalLines();

            ttscommit;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>retrieveCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves customer or vendor transaction line for currently processed payment proposal line.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    /// Currently processed payment proposal line.
    /// </param>
    /// <returns>
    /// Customer or vendor transaction line related to currently processed payment proposal line.
    /// </returns>
    protected CustVendTrans retrieveCustVendTrans(CustVendPaymProposalLine  _custVendPaymProposalLine)
    {
        CustVendTransStatic custVendTransStatic = _custVendPaymProposalLine.custVendTransStatic();
        CustVendTrans custVendTrans = custVendTransStatic.custVendTrans();
        CustVendTransOpen custVendTransOpen = custVendTransStatic.custVendTransOpen();

        SpecTrans specTrans;
        select firstonly crossCompany RecId from specTrans
            where specTrans.SpecTableId == _custVendPaymProposalLine.TableId
               && specTrans.SpecRecId == _custVendPaymProposalLine.RecId
            join RecId from custVendTransOpen
                where custVendTransOpen.TableId == specTrans.RefTableId
                   && custVendTransOpen.RecId == specTrans.RefRecId
            join AccountNum, DocumentNum, DocumentDate, Invoice, InvoiceReleaseDate from custVendTrans
                where custVendTrans.RecId == custVendTransOpen.RefRecId;

        return custVendTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Contains the code that does the actual job of the class.
    /// </summary>
    public void run()
    {
        if (!this.validate())
        {
            this.logMessage(Exception::Error, "@SYS319214");
        }
        else
        {
            this.ensurePaymentNotDeletedOrPosted(ledgerJournalId);
        }

        if (this.isInBatch())
        {
            if (FeatureStateProvider::isFeatureEnabled(CustVendPaymProposalTopPickingFeature::instance()))
            {
                this.runTopPicking();
            }
            else if (this.parmIsAutomation())
            {
                this.runAutomation();
            }
            else
            {
                this.runInBatch();
            }
        }
        else
        {
            this.runIteractive();
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>runInBatch</Name>
				<Source><![CDATA[
    private void runInBatch()
    {
        if (!hasBatchBeenSplit)
        {
            ttsbegin;

            BatchHeader batchHeader = BatchHeader::construct(this.parmCurrentBatch().BatchJobId);
            if (batchHeader == null)
            {
                batchHeader = batchHeader::construct();
            }

            //Add final batch task to copy payment proposal lines back to the payment journal
            ClassId classId = classIdGet(this);
            DictClass dictClass = new DictClass(classId);

            CustVendPaymProposalTransferToJournal custVendPaymProposalTransferToJournalFinal = dictClass.makeObject();
            custVendPaymProposalTransferToJournalFinal.unpack(this.pack());
            custVendPaymProposalTransferToJournalFinal.setHasBatchBeenSplit(true);
            custVendPaymProposalTransferToJournalFinal.setIsFinalBatch(true);
            custVendPaymProposalTransferToJournalFinal.batchInfo().parmCaption(strFmt("@SYS4080918", this.parmCurrentBatch().Caption));
            
            batchHeader.addRuntimeTask(custVendPaymProposalTransferToJournalFinal, this.parmCurrentBatch().RecId);

            this.splitBatch(batchHeader, custVendPaymProposalTransferToJournalFinal);

            batchHeader.save();

            this.removeUnwantedJournalLines();

            CustVendPaymProposalBatchProcess custVendPaymProposalBatchProcess = CustVendPaymProposalBatchProcess::find(ledgerJournalId, true);
            custVendPaymProposalBatchProcess.State = CustVendPaymProposalBatchProcessState::CreatingPaymentLines;
            custVendPaymProposalBatchProcess.BatchJobId = this.batchInfo().parmBatch().BatchJobId;
            custVendPaymProposalBatchProcess.update();

            ttscommit;

            return;

        }

        if (this.isFinalBatch)
        {
            CustVendPaymProposalBatchProcess::changeState(ledgerJournalId, CustVendPaymProposalBatchProcessState::CreatedPaymentLines);

            this.notifyUserAfterTransferProposal();

            CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);

            return;
        }

        ttsbegin;
        this.execute();
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runTopPicking</Name>
				<Source><![CDATA[
    private void runTopPicking()
    {
        if (this.parmIsAutomation() && isFinalBatch)
        {
            return;
        }

        ttsbegin;

        container inputParameters = [classIdGet(this), this.pack()];
        CustVendPaymentProposalTransferTopPickingRun runner = new CustVendPaymentProposalTransferTopPickingRun(inputParameters, classIdGet(this), this.pack());
        RecId batchRecId = CustVendGeneralTopPickingSubmitFacade::submitToTPPool(classIdGet(runner), inputParameters, runner.pack(), this.constructParentJobInfo());

        CustVendPaymProposalBatchProcess custVendPaymProposalBatchProcess = CustVendPaymProposalBatchProcess::find(ledgerJournalId, true);
        custVendPaymProposalBatchProcess.State = CustVendPaymProposalBatchProcessState::CreatingPaymentLines;
        custVendPaymProposalBatchProcess.BatchJobId = batchRecId;
        custVendPaymProposalBatchProcess.update();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructParentJobInfo</Name>
				<Source><![CDATA[
    private CustVendGeneralTopPickingBatchInfo constructParentJobInfo()
    {
        BatchHeader header = BatchHeader::getCurrentBatchHeader();
        return CustVendGeneralTopPickingBatchInfo::construct(header, this.parmCurrentBatch().BatchJobId, this.parmIsAutomation());
    }

]]></Source>
			</Method>
			<Method>
				<Name>runAutomation</Name>
				<Source><![CDATA[
    private void runAutomation()
    {
        Microsoft.Dynamics.Ax.Xpp.ErrorException errorEx;
                
        try
        {
            ttsbegin;

            if (isFirstBatch)
            {
                this.removeUnwantedJournalLines();

                CustVendPaymProposalBatchProcess custVendPaymProposalBatchProcess = CustVendPaymProposalBatchProcess::find(ledgerJournalId, true);
                custVendPaymProposalBatchProcess.State = CustVendPaymProposalBatchProcessState::CreatingPaymentLines;
                custVendPaymProposalBatchProcess.BatchJobId = this.batchInfo().parmBatch().BatchJobId;
                custVendPaymProposalBatchProcess.update();

                this.splitBatchAutomation();
            }
            else if (isFinalBatch)
            {
                CustVendPaymProposalBatchProcess::changeState(ledgerJournalId , CustVendPaymProposalBatchProcessState::CreatedPaymentLines);

                this.notifyUserAfterTransferProposal();

                CustVendPaymProposalLine::deleteByJournalId(ledgerJournalId);
            }
            else
            {
                this.execute();
            }

            ttscommit;
        }
        catch (errorEx)
        {
            this.logMessage(Exception::Error, errorEx.Message);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getCustVendTotalPaymentCount</Name>
				<Source><![CDATA[
    private int getCustVendTotalPaymentCount()
    {
        CustVendPaymProposalLine custVendPaymProposalLine;

        select count(RecId)
            from custVendPaymProposalLine
            where custVendPaymProposalLine.JournalId == ledgerJournalId;

        return int642int(custVendPaymProposalLine.RecId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitBatch</Name>
				<Source><![CDATA[
    private void splitBatch(BatchHeader _batchHeader, CustVendPaymProposalTransferToJournal _custVendPaymProposalTransferToJournalFinal)
    {
        List batchTasks = this.getSplitBatchList();

        ListEnumerator listEnumerator = batchTasks.getEnumerator();

        while (listEnumerator.moveNext())
        {
            CustVendPaymProposalTransferToJournal currentTask = listEnumerator.current() as CustVendPaymProposalTransferToJournal;

            _batchHeader.addRuntimeTask(currentTask, this.parmCurrentBatch().RecId);
            _batchHeader.addDependency(_custVendPaymProposalTransferToJournalFinal, currentTask);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitBatchAutomation</Name>
				<Source><![CDATA[
    private void splitBatchAutomation()
    {
        BatchHeader batchHeader = BatchHeader::construct(this.parmCurrentBatch().BatchJobId);

        if (batchHeader == null)
        {
            batchHeader = batchHeader::construct();
        }

        List batchTasks = this.getSplitBatchList();

        ListEnumerator listEnumerator = batchTasks.getEnumerator();

        while (listEnumerator.moveNext())
        {
            Batchable currentTask = listEnumerator.current();

            batchHeader.addRuntimeTask(currentTask, this.parmCurrentBatch().RecId);
        }

        batchHeader.save();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSplitBatchQuery</Name>
				<Source><![CDATA[
    private Query initSplitBatchQuery()
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tablenum(CustVendPaymProposalLine));

        qbds.addSelectionField(fieldNum(CustVendPaymProposalLine, AccountNum));
        qbds.addSelectionField(fieldNum(CustVendPaymProposalLine, RecId), SelectionField::Count);
        qbds.addGroupByField(fieldNum(CustVendPaymProposalLine, AccountNum));
        qbds.addOrderByField(fieldNum(CustVendPaymProposalLine, AccountNum), SortOrder::Ascending);
        qbds.addRange(fieldNum(CustVendPaymProposalLine, AccountNum)).value(sysquery::valueNotEmptyString());

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>splitBatchToList</Name>
				<Source><![CDATA[
    private List splitBatchToList()
    {
        List batchTasks = new List(Types::Class);

        int i;
        int64 accountNumCount;
        int64 nextBundleSize;
        AccountNum lastAccountNum;

        Query query = this.initSplitBatchQuery();
        QueryRun queryRun = new QueryRun(query);
        while (queryRun.next())
        {
            i++;

            CustVendPaymProposalLine custVendPaymProposalLine = queryRun.get(tableNum(CustVendPaymProposalLine));

            AccountNum accountNum = custVendPaymProposalLine.AccountNum;
            accountNumCount = custVendPaymProposalLine.RecId;

            if (i == 1)
            {
                this.fromCustVendAccountNum = accountNum;
            }

            nextBundleSize += accountNumCount;
            if (nextBundleSize >= BundleSize)
            {
                this.toCustVendAccountNum = accountNum;

                batchTasks.addEnd(this.getSplitBatchTask());

                i = 0;
                nextBundleSize = 0;
                this.fromCustVendAccountNum = '';
                this.toCustVendAccountNum = '';
            }

            lastAccountNum = accountNum;

        }

        // The last bundle is smaller than BundleSize
        if (i > 0)
        {
            this.toCustVendAccountNum = lastAccountNum;

            batchTasks.addEnd(this.getSplitBatchTask());
        }

        return batchTasks;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitBatchList</Name>
				<Source><![CDATA[
    private List getSplitBatchList()
    {
        return this.splitBatchToList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSplitBatchTask</Name>
				<Source><![CDATA[
    private CustVendPaymProposalTransferToJournal getSplitBatchTask()
    {
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        CustVendPaymProposalTransferToJournal custVendPaymProposalTransferToJournal = dictClass.makeObject();
    
        custVendPaymProposalTransferToJournal.unpack(this.pack());
        custVendPaymProposalTransferToJournal.parmIsFirstBatch(false);
        custVendPaymProposalTransferToJournal.setIsFinalBatch(false);
        custVendPaymProposalTransferToJournal.setHasBatchBeenSplit(true);

        batchInfo = custVendPaymProposalTransferToJournal.batchInfo();
        batchInfo.parmCaption(strFmt('%1 : %2 : %3', ledgerJournalId, this.fromCustVendAccountNum, this.toCustVendAccountNum));

        return custVendPaymProposalTransferToJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFirstAutomationBatchTask</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CustVendPaymProposalTransferToJournal getFirstAutomationBatchTask()
    {
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        CustVendPaymProposalTransferToJournal transferFirst = dictClass.makeObject();
        transferFirst.unpack(this.pack());
        transferFirst.parmIsAutomation(true);
        transferFirst.setHasBatchBeenSplit(true);
        transferFirst.parmIsFirstBatch(true);
        transferFirst.setIsFinalBatch(false);

        return transferFirst;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinalAutomationBatchTask</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public CustVendPaymProposalTransferToJournal getFinalAutomationBatchTask()
    {
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        CustVendPaymProposalTransferToJournal transferFinal = dictClass.makeObject();
        transferFinal.unpack(this.pack());
        transferFinal.parmIsAutomation(true);
        transferFinal.setHasBatchBeenSplit(true);
        transferFinal.parmIsFirstBatch(false);
        transferFinal.setIsFinalBatch(true);

        return transferFinal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runIteractive</Name>
				<Source><![CDATA[
    private void runIteractive()
    {
        CustVendPaymProposalLine custVendPaymProposalLine;
        SpecTrans specTrans;

        select count(RecId) from custVendPaymProposalLine
            where custVendPaymProposalLine.JournalId == ledgerJournalId
        exists join specTrans
            where specTrans.SpecCompany == custVendPaymProposalLine.DataAreaId
                && specTrans.SpecTableId == custVendPaymProposalLine.TableId
                && specTrans.SpecRecId == custVendPaymProposalLine.RecId;

        this.progressInit("@SYS88952", custVendPaymProposalLine.RecId, #AviUpdate);
        progress.setText("@SYS68312");
        progress.updateInterval(15);

        using (SysInstrumentationActivityContext activityContext = this.createProgressLogger().activityContextForStage(CustVendInstrumentationConstants::PaymentProposalRunInteractive))
        {
            // Must be outside the tts below, otherwise deadlocks will occur in the NumberSequence.
            this.removeUnwantedJournalLines();

            this.execute();

            this.notifyUserAfterTransferProposal();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>execute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Execute
    /// </summary>
    protected void execute()
    {
        #OCCRetryCount
        const int WaitTimeAfterDeadlockInMiliseconds = 500;
        int line;

        SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstants::PaymentProposalTransferToJournal))
        {
            try
            {
                line = Global::infologLine();

                this.transferProposal();
            }
            catch (Exception::Deadlock)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::Deadlock;
                }
                else
                {
                    progressLogger.logRetryOnDeadlock();

                    sleep(WaitTimeAfterDeadlockInMiliseconds);
                    infolog.clear(line);
                    retry;
                }
            }
            catch (Exception::UpdateConflict)
            {
                if (xSession::currentRetryCount() >= #RetryNum)
                {
                    throw Exception::UpdateConflictNotRecovered;
                }
                else
                {
                    progressLogger.logRetryOnUpdateConflict();

                    infolog.clear(line);
                    retry;
                }
            }
            catch (Exception::Error)
            {
                this.logMessage(Exception::Error, "@SYS21628");
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createProgressLogger</Name>
				<Source><![CDATA[
    private SysInstrumentationProgressLogger createProgressLogger()
    {
        str sourceName = CustVendInstrumentationFormatter::sourceNameWithModule(CustVendInstrumentationConstants::SourceNamePaymentProposalTransfer, moduleCustVend);

        return SysInstrumentationProgressLogger::createLogger(sourceName, CustVendInstrumentationConstants::InstrumentationNamespace);
    }

]]></Source>
			</Method>
			<Method>
				<Name>notifyUserAfterTransferProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Notify user after transfer proposal.
    /// </summary>
    public void notifyUserAfterTransferProposal()
    {
        if (((moduleCustVend == ModuleCustVend::Cust && CustParameters::find().MixedPayment)
                || (moduleCustVend == ModuleCustVend::Vend && VendParameters::find().MixedPayment))
            && this.mixedPaymMode())
        {
            this.logMessage(Exception::Info, "@SYS73904");
        }

        if (this.atLeastOneLineIsNotEligibleForTransfer())
        {
            this.logMessage(Exception::Warning, "@SYS128417");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setLedgerJournalTransAmount</Name>
				<Source><![CDATA[
    protected void setLedgerJournalTransAmount(LedgerJournalTrans _ledgerJournalTrans, CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        // Note: Previously the currency code and exchange rate date came from _ledgerJournalTrans.CurrencyCode
        // and _ledgerJournalTrans.TransDate. Modified this process to use all information from the proposal line to
        // ensure any changes made to the proposal line are honored.
        LedgerJournalName ledgerJournalName = LedgerJournalName::find(ledgerJournalTable.JournalName);
        CurrencyCode currencyCode = ledgerJournalName.CurrencyCode ? ledgerJournalName.CurrencyCode : _custVendPaymProposalLine.CurrencyCode;
 
        // <GBR>
        FinInterestAmount_BR finInterestAmountCur;
        FineAmount_BR fineAmountCur;
        LedgerJournalTransPayment_BR payment_BR;
        if (BrazilParameters::isEnabled())
        {
            finInterestAmountCur = SpecTransManager::getTotalInterestAmountForSpecRef_BR(
                _custVendPaymProposalLine.DataAreaId,
                _custVendPaymProposalLine.TableId,
                _custVendPaymProposalLine.RecId,
                currencyCode,
                _custVendPaymProposalLine.AccountNumCompany,
                _custVendPaymProposalLine.PaymDate);
            fineAmountCur = SpecTransManager::getTotalFineAmountForSpecRef_BR(
                _custVendPaymProposalLine.DataAreaId,
                _custVendPaymProposalLine.TableId,
                _custVendPaymProposalLine.RecId,
                currencyCode,
                _custVendPaymProposalLine.AccountNumCompany,
                _custVendPaymProposalLine.PaymDate);
        }
        // </GBR>

        AmountCur specAmountCur = SpecTransManager::getTotalSettleAmountForSpecReference(
            _custVendPaymProposalLine.DataAreaId,
            _custVendPaymProposalLine.TableId,
            _custVendPaymProposalLine.RecId,
            _ledgerJournalTrans.CurrencyCode,
            _custVendPaymProposalLine.AccountNumCompany,
            _custVendPaymProposalLine.PaymDate);
        if (specAmountCur > 0)
        {
            _ledgerJournalTrans.AmountCurCredit = specAmountCur;
            _ledgerJournalTrans.AmountCurDebit = 0;
            // <GBR>
            if (BrazilParameters::isEnabled()
                && _custVendPaymProposalLine.AccountType == ModuleCustVend::Cust)
            {
                payment_BR = _ledgerJournalTrans.getPaymentExtension_BR();
                payment_BR.FinInterestAmountCur_BR = abs(finInterestAmountCur);
                payment_BR.FineAmountCur_BR = abs(fineAmountCur);
                _ledgerJournalTrans.packExtensionTable(payment_BR);
            }
            // </GBR>
        }
        else
        {
            _ledgerJournalTrans.AmountCurDebit = abs(specAmountCur);
            _ledgerJournalTrans.AmountCurCredit = 0;
            // <GBR>
            if (BrazilParameters::isEnabled()
                && _custVendPaymProposalLine.AccountType == ModuleCustVend::Vend)
            {
                payment_BR = _ledgerJournalTrans.getPaymentExtension_BR();
                payment_BR.FinInterestAmountCur_BR = abs(finInterestAmountCur);
                payment_BR.FineAmountCur_BR = abs(fineAmountCur);
                _ledgerJournalTrans.packExtensionTable(payment_BR);
            }
            // </GBR>
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setVoucher_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets voucher of the cust vend paym proposal transfer to journal.
    /// </summary>
    /// <param name="_ledgerJournalTrans">
    /// The instance of the <c>LedgerJournalTrans</c> class.
    /// </param>
    /// <returns>
    /// The instance of the <c>LedgerJournalTrans</c> class.
    /// </returns>
    protected LedgerJournalTrans setVoucher_CN(LedgerJournalTrans _ledgerJournalTrans)
    {
        LedgerJournalTrans findJournalTrans;

        select firstonly Voucher_CN, RecId from findJournalTrans
            where findJournalTrans.JournalNum == _ledgerJournalTrans.JournalNum
                && findJournalTrans.Voucher == _ledgerJournalTrans.Voucher
                && findJournalTrans.LedgerVoucherType_CN == _ledgerJournalTrans.LedgerVoucherType_CN;
        if (findJournalTrans.RecId)
        {
            _ledgerJournalTrans.Voucher_CN = findJournalTrans.Voucher_CN;
        }
        else
        {
            Voucher_CN voucher_CN;
            if (_ledgerJournalTrans.LedgerVoucherType_CN)
            {
                RefRecId numberSequenceTable = LedgerVoucherType_CN::find(_ledgerJournalTrans.LedgerVoucherType_CN).NumberSequenceTable;

                voucher_CN = NumberSeq_Voucher_CN::newGetVoucherFromCode(numberSequenceTable, _ledgerJournalTrans.TransDate).voucher();
            }

            _ledgerJournalTrans.Voucher_CN = voucher_CN;
        }

        return _ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferProposal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs the actual transfer.
    /// </summary>
    public void transferProposal()
    {
        #AviFiles
        #ISOCountryRegionCodes

        ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);
        newVoucher = ledgerJournalTable.ledgerJournalName().NewVoucher;
        ledgerJournalTableData = JournalTableData::newTable(ledgerJournalTable);
        hcmWorkerRecId = HcmWorker::userId2Worker(curUserId());

        ttsbegin;

        Query query = this.initQueryForTransferProposal();
        QueryRun queryRun = new QueryRun(query);

        int64 numberOfRecords = QueryRun::getQueryRowCount(query, intMax());
        int64 numberOfRecordsProcessed;

        SysInstrumentationProgressLogger progressLogger = this.createProgressLogger();
        SysInstrumentationProgressStage progressStage = progressLogger.createStage(CustVendInstrumentationConstants::PaymentProposalTransferLinesToJournal, numberOfRecords);

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextWithProgressMonitor(progressStage))
        {
            activityContext.addCustomProperty(CustVendInstrumentationConstants::PaymentProposalJournalRecId, int642Str(ledgerJournalTable.RecId));
            activityContext.addCustomProperty(CustVendInstrumentationConstants::BatchJobId, int642Str(this.parmCurrentBatch().BatchJobId));

            CustVendPaymProposalLine custVendPaymProposalLine;
            LedgerJournalTrans ledgerJournalTransPaym;
            LedgerJournalTrans ledgerJournalTransVAT;
            VendTrans vendTransInvoice;
            VATTaxAgentPaymentAmounts_RU paymentAmounts;
            boolean countryRegion_RU = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]);

            while (queryRun.next())
            {
                custVendPaymProposalLine = queryRun.get(tableNum(CustVendPaymProposalLine));

                if (!this.isInBatch())
                {
                    progress.incCount();
                }

                // <GEERU>
                if (countryRegion_RU)
                {
                    ledgerJournalTransPaym = this.transferProposalLineToJournal(custVendPaymProposalLine);

                    if (!ledgerJournalTransPaym)
                    {
                        continue;
                    }

                    CustVendPaymProposalLine custVendPaymVatLine;
                    while select custVendPaymVatLine
                        where custVendPaymVatLine.vatPaymRefRecId_RU == custVendPaymProposalLine.RecId
                    {
                        ledgerJournalTransVAT = this.transferProposalLineToJournal(custVendPaymVatLine);
                        if (!ledgerJournalTransVAT)
                        {
                            continue;
                        }
                        ledgerJournalTransVAT.vatPaymRefRecId_RU = ledgerJournalTransPaym.RecId;
                        vendTransInvoice = VendTrans::find(VendTransOpen::find(custVendPaymVatLine.TransOpenRecId).RefRecId);

                        paymentAmounts = VATTaxAgentPaymentAmounts_RU::construct(vendTransInvoice);
                        paymentAmounts.calc(0, 0, 0, custVendPaymVatLine.PaymDate);
                        ledgerJournalTransVAT.TaxBase_W = paymentAmounts.taxAgentBaseAmountMST(custVendPaymVatLine.InvoiceTaxCode_RU);

                        ledgerJournalTransVAT.update();

                        ledgerJournalTransPaym.vatOperationCode_RU = ledgerJournalTransVAT.vatOperationCode_RU;
                        ledgerJournalTransPaym.update();
                    }
                }
                else
                {
                    this.transferProposalLineToJournal(custVendPaymProposalLine);

                    numberOfRecordsProcessed++;
                    progressLogger.trackProgress(numberOfRecordsProcessed);
                }
            }
        }

        using (SysInstrumentationActivityContext activityContext = progressLogger.activityContextForStage(CustVendInstrumentationConstants::PaymentProposalTransferLinesUpdateSpecTrans))
        {
            this.updateSpecTransSet();
        }

        this.updateMarkedInvoice();
        this.updateWithholdingTaxGroup_IN();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryForTransferProposal</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Initializes query for transfer proposal.
    /// </summary>
    /// <returns>
    ///     Query for use in transfer proposal.
    /// </returns>
    protected Query initQueryForTransferProposal()
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(CustVendPaymProposalLine));
        qbds.addRange(fieldNum(CustVendPaymProposalLine, JournalId)).value(queryValue(ledgerJournalTable.JournalNum));

        if (FeatureStateProvider::isFeatureEnabled(CustVendPaymProposalTopPickingFeature::instance())
            && isInTopPicking)
        {
            QueryBuildRange qbr = qbds.addRange(fieldNum(CustVendPaymProposalLine, RecId));
            qbr.value(SysQuery::range(fromProposalRecId, toProposalRecId));
        }
        else
        {
            if (this.isInBatch() && this.fromCustVendAccountNum != '' && this.toCustVendAccountNum != '')
            {
                QueryBuildRange qbr = qbds.addRange(fieldNum(CustVendPaymProposalLine, AccountNum));
                qbr.value(this.fromCustVendAccountNum + '..' + this.toCustVendAccountNum);
            }
        }
        qbds = qbds.addDataSource(tableNum(SpecTrans));
        qbds.relations(true);
        qbds.joinMode(JoinMode::ExistsJoin);

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferProposalLineToJournal</Name>
				<Source><![CDATA[
    protected LedgerJournalTrans transferProposalLineToJournal(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        #ISOCountryRegionCodes

        LedgerJournalTrans ledgerJournalTrans;
        ledgerJournalTrans = this.initLedgerJournalTransFromPaymLine(ledgerJournalTrans, _custVendPaymProposalLine);

        if (!ledgerJournalTrans)
        {
            return null;
        }

        if (ledgerJournalTrans.TaxWithholdGroup)
        {
            TaxWithhold taxWithhold;
            if (TaxWithholdingGlobalFeature::isExtendedWHTSupportedInCountryRegionOrParamEnabled() || BrazilParameters::isEnabled())
            {
                taxWithhold = TaxWithhold::construct(ledgerJournalTrans);
            }
            else
            {
                taxWithhold = new TaxWithhold(ledgerJournalTrans);
            }

            taxWithhold.createAllTaxWithholdTrans();

            TaxWithhold::clearCache();

            AmountCur specAmountCur = SpecTransManager::getTotalSettleAmountForSpecReference(
                ledgerJournalTrans.DataAreaId,
                ledgerJournalTrans.TableId,
                ledgerJournalTrans.RecId,
                ledgerJournalTrans.CurrencyCode,
                ledgerJournalTrans.Company,
                ledgerJournalTrans.TransDate);

            // <GBR>
            FinInterestAmount_BR finInterestAmountCur;
            FineAmount_BR fineAmountCur;
            LedgerJournalTransPayment_BR payment_BR;
            if (BrazilParameters::isEnabled())
            {
                finInterestAmountCur = SpecTransManager::getTotalInterestAmountForSpecRef_BR(
                    ledgerJournalTrans.DataAreaId,
                    ledgerJournalTrans.TableId,
                    ledgerJournalTrans.RecId,
                    ledgerJournalTrans.CurrencyCode,
                    ledgerJournalTrans.Company,
                    ledgerJournalTrans.TransDate);

                fineAmountCur = SpecTransManager::getTotalFineAmountForSpecRef_BR(
                    ledgerJournalTrans.DataAreaId,
                    ledgerJournalTrans.TableId,
                    ledgerJournalTrans.RecId,
                    ledgerJournalTrans.CurrencyCode,
                    ledgerJournalTrans.Company,
                    ledgerJournalTrans.TransDate);
            }
            // </GBR>

            if (specAmountCur > 0)
            {
                ledgerJournalTrans.AmountCurCredit = specAmountCur;
                ledgerJournalTrans.AmountCurDebit = 0;
                // <GBR>
                if (BrazilParameters::isEnabled()
                    && _custVendPaymProposalLine.AccountType == ModuleCustVend::Cust)
                {
                    payment_BR = ledgerJournalTrans.getPaymentExtension_BR();
                    payment_BR.FinInterestAmountCur_BR = abs(finInterestAmountCur);
                    payment_BR.FineAmountCur_BR = abs(fineAmountCur);
                    ledgerJournalTrans.packExtensionTable(payment_BR);
                }
                // </GBR>
            }
            else
            {
                ledgerJournalTrans.AmountCurDebit = abs(specAmountCur);
                ledgerJournalTrans.AmountCurCredit = 0;
                // <GBR>
                if (BrazilParameters::isEnabled()
                    && _custVendPaymProposalLine.AccountType == ModuleCustVend::Vend)
                {
                    payment_BR = ledgerJournalTrans.getPaymentExtension_BR();
                    payment_BR.FinInterestAmountCur_BR = abs(finInterestAmountCur);
                    payment_BR.FineAmountCur_BR = abs(fineAmountCur);
                    ledgerJournalTrans.packExtensionTable(payment_BR);
                }
                // </GBR>
            }

            // <GBR>
            if (BrazilParameters::isEnabled())
            {
                ledgerJournalTrans.closeTaxWithholdEditStatus_BR();

                LedgerJournalTrans_BR_Extension::populateIncomeCodeFromSettledInvoice(ledgerJournalTrans);
            }
            // </GBR>

            ledgerJournalTrans.update();
        }

        if (ledgerJournalTrans.AccountType == LedgerJournalACType::Vend && !(ledgerJournalTrans.Tax1099Fields))
        {
            VendTable vendTable = VendTable::findByCompany(_custVendPaymProposalLine.AccountNumCompany, _custVendPaymProposalLine.AccountNum);

            Debug::assert(vendTable.RecId != 0);

            if (vendTable.Tax1099Reports)
            {
                ledgerJournalTrans.Tax1099Fields = vendTable.Tax1099Fields;
                ledgerJournalTrans.update();
            }
        }

        switch (ledgerJournalTrans.AccountType)
        {
            case LedgerJournalACType::Cust:
                CustVendPaymJournalFee::createJournalFeeCust(ledgerJournalTrans);
                break;

            case LedgerJournalACType::Vend:
                CustVendPaymJournalFee::createJournalFeeVend(ledgerJournalTrans);
                break;
        }

        ledgerJournalTrans.markedForSettlementWarnMixedDueDate();

        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container packedClass)
    {
        #define.CurrentVersionV3(3)

        #localmacro.CurrentListV3
        ledgerJournalId,
        moduleCustVend,
        includeInvoicesFromOtherCompanies,
        paymDate_IT,
        paymOnDateFixed_IT,
        hasBatchBeenSplit,
        isFinalBatch,
        fromCustVendAccountNum,
        toCustVendAccountNum
        #endmacro

        Version version = RunBase::getVersion(packedClass);

        switch (version)
        {
            case #CurrentVersion:
                [version, #CurrentList] = packedClass;
                break;
            case #CurrentVersionV3:
                [version, #CurrentListV3] = packedClass;
                break;
            default:
                return false;
        }

        if (FeatureStateProvider::isFeatureEnabled(CustVendPaymProposalTopPickingFeature::instance()))
        {
            fromProposalRecId = SysPackExtensions::extractPackedVariable(packedClass, this.name(), varStr(fromProposalRecId));
            toProposalRecId = SysPackExtensions::extractPackedVariable(packedClass, this.name(), varStr(toProposalRecId));
            isInTopPicking = SysPackExtensions::extractPackedVariable(packedClass, this.name(), varStr(isInTopPicking));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateMarkedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates the marked invoice of the transferred payment.
    /// </summary>
    /// <remarks>
    ///    The marked invoice is updated during payment proposal creation or edit. The marked invoice is
    ///    updated with the invoice number, a blank, or a special indicator when there are multiple
    ///    transactions or a non-invoice transaction is being paid.
    /// </remarks>
    [SysObsoleteAttribute('Performance. Use initMarkedInvoice instead.', false, 30\6\2020)]
    protected void updateMarkedInvoice()
    {
        return;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initMarkedInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the payment for the marked invoice.
    /// </summary>
    /// <param name = "_ledgerJournalTrans">The payment.</param>
    /// <param name = "_custVendPaymProposalLine">The payment proposal line.</param>
    protected void initMarkedInvoice(LedgerJournalTrans _ledgerJournalTrans, CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        int specCount = SpecTrans::getSpecTransCount(
            _custVendPaymProposalLine.DataAreaId,
            tableNum(CustVendPaymProposalLine),
            _custVendPaymProposalLine.RecId);

        switch (specCount)
        {
            case 0:
                _ledgerJournalTrans.MarkedInvoice = '';
                _ledgerJournalTrans.MarkedInvoiceCompany = '';
                _ledgerJournalTrans.MarkedInvoiceRecId = 0;
                break;

            case 1:
                SpecTrans specTrans = SpecTrans::findBySpec(
                    _custVendPaymProposalLine.DataAreaId,
                    tableNum(CustVendPaymProposalLine),
                    _custVendPaymProposalLine.RecId);
                CustTrans custTrans = specTrans.custTrans();
                _ledgerJournalTrans.MarkedInvoice = custTrans.Invoice;
                _ledgerJournalTrans.MarkedInvoiceCompany = SpecTrans.RefCompany;
                _ledgerJournalTrans.MarkedInvoiceRecId = SpecTrans.RefRecId;
                break;

            default:
                _ledgerJournalTrans.MarkedInvoice = LedgerJournalEngine_CustPayment::getMarkedInvoiceSettlementIndicator();
                _ledgerJournalTrans.MarkedInvoiceCompany = '';
                _ledgerJournalTrans.MarkedInvoiceRecId = 0;
                break;
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    public boolean validate(Object _calledFrom = null)
    {
        boolean ret = super();

        if (!ledgerJournalId)
        {
            ret = checkFailed("@SYS19282");
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initForPaymProposal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize this class for the payment proposal.
    /// </summary>
    /// <param name = "_custVendPaymProposal">The payment proposal.</param>
    protected void initForPaymProposal(CustVendPaymProposal _custVendPaymProposal)
    {
        this.setLedgerJournalId(_custVendPaymProposal.ledgerJournalId());
        this.setModuleCustVend(_custVendPaymProposal.moduleCustVend());
        this.setIncludeInvoicesFromOtherCompanies(_custVendPaymProposal.parmIncludeInvoicesFromOtherCompanies());
        this.setPaymDate_IT(_custVendPaymProposal.parmPaymProposalCalcPaym().parmPaymDate_IT());
        this.setPaymOnDateFixed_IT(_custVendPaymProposal.parmPaymProposalCalcPaym().parmPaymOnDateFixed_IT());
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForPaymProposal</Name>
				<Source><![CDATA[
    public static CustVendPaymProposalTransferToJournal constructForPaymProposal(CustVendPaymProposal _custVendPaymProposal)
    {
        CustVendPaymProposalTransferToJournal custVendPaymProposalTransferToJournal = new CustVendPaymProposalTransferToJournal();
        custVendPaymProposalTransferToJournal.initForPaymProposal(_custVendPaymProposal);
        return custVendPaymProposalTransferToJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>constructForPaymProposalAutomation</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public static CustVendPaymProposalTransferToJournal constructForPaymProposalAutomation(
        CustVendPaymProposal _custVendPaymProposal,
        RefRecId _processExecutionSourceLinkRecId)
    {
        CustVendPaymProposalTransferToJournal custVendPaymProposalTransferToJournal =
            CustVendPaymProposalTransferToJournal::constructForPaymProposal(_custVendPaymProposal);
        custVendPaymProposalTransferToJournal.parmIsAutomation(true);
        custVendPaymProposalTransferToJournal.parmProcessExecutionSourceLinkRecId(_processExecutionSourceLinkRecId);

        return custVendPaymProposalTransferToJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS88952";
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        CustVendPaymProposal paymProposal = args.parmObject();
        CustVendPaymProposalTransferToJournal custVendPaymProposalTransferToJournal = CustVendPaymProposalTransferToJournal::constructForPaymProposal(paymProposal);
        custVendPaymProposalTransferToJournal.getLast();
        custVendPaymProposalTransferToJournal.runOperation();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    /// <summary>
    /// Describes whether the class is designed for execution in a new session.
    /// </summary>
    /// <returns>
    /// true if the class is designed for executing the operation in a new session; otherwise, false.
    /// </returns>
    protected boolean canRunInNewSession()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesPaymModeSpecExistInPaymentCompany</Name>
				<Source><![CDATA[
    private boolean doesPaymModeSpecExistInPaymentCompany(CustVendPaymProposalLine _proposalLine)
    {
        boolean doesExist;

        switch (_proposalLine.AccountType)
        {
            case ModuleCustVend::Cust:
                doesExist = CustPaymModeSpec::existForPaymMode(_proposalLine.PaymSpec, _proposalLine.PaymMode);
                break;

            case ModuleCustVend::Vend:
                doesExist = VendPaymModeSpec::existForPaymMode(_proposalLine.PaymSpec, _proposalLine.PaymMode);
                break;

            default:
                this.logMessage(Exception::Error, Error::wrongUseOfFunction(funcName()));
        }

        return doesExist;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPaymProposal</Name>
				<Source><![CDATA[
    public CustVendPaymProposal parmPaymProposal(CustVendPaymProposal _paymProposal = paymProposal)
    {
        paymProposal = _paymProposal;

        if (!prmisDefault(_paymProposal))
        {
            ledgerJournalId = paymProposal.ledgerJournalId();
        }

        return paymProposal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static CustVendPaymProposalTransferToJournal construct()
    {
        return new CustVendPaymProposalTransferToJournal();
    }

]]></Source>
			</Method>
			<Method>
				<Name>movePaymentRequestLink</Name>
				<Source><![CDATA[
    protected void movePaymentRequestLink(CustVendPaymProposalLine _custVendPaymProposalLine, LedgerJournalTrans _ledgerJournalTrans)
    {
        CFMPaymentRequestPaymentLink paymentRequestLink;

        update_recordset paymentRequestLink
            setting RefTableId = _ledgerJournalTrans.TableId,
                    RefRecId = _ledgerJournalTrans.RecId
            where paymentRequestLink.RefTableId == _custVendPaymProposalLine.TableId
               && paymentRequestLink.RefRecId == _custVendPaymProposalLine.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initPaymentOrderBudgetTransFromPR</Name>
				<Source><![CDATA[
    private void initPaymentOrderBudgetTransFromPR(LedgerJournalTrans _ledgerJournalTrans, CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        CFMPaymentRequestPaymentOrder paymentOrderPR = CFMPaymentRequestPaymentOrder::findByHash(_custVendPaymProposalLine.CFMPaymentOrderHash);

        if (paymentOrderPR)
        {
            PaymentOrderBudgetTrans_RU paymentOrderBudgetTrans;

            paymentOrderBudgetTrans.BaseCode = paymentOrderPR.BaseCode;
            paymentOrderBudgetTrans.BudgetReceiptClassCode = paymentOrderPR.BudgetReceiptClassCode;
            paymentOrderBudgetTrans.DocDate = paymentOrderPR.DocDate;
            paymentOrderBudgetTrans.DocNum = paymentOrderPR.DocNum;
            paymentOrderBudgetTrans.OrderOfPayment = paymentOrderPR.OrderOfPayment;
            paymentOrderBudgetTrans.PeriodCode = paymentOrderPR.PeriodCode;
            paymentOrderBudgetTrans.PeriodNumber = paymentOrderPR.PeriodNumber;
            paymentOrderBudgetTrans.PrintKPP = paymentOrderPR.PrintKPP;
            paymentOrderBudgetTrans.RecipientRCOAD = paymentOrderPR.RecipientRCOAD;
            paymentOrderBudgetTrans.StatusCode = paymentOrderPR.StatusCode;
            paymentOrderBudgetTrans.TaxPeriodDate = paymentOrderPR.TaxPeriodDate;
            paymentOrderBudgetTrans.TypeCode = paymentOrderPR.TypeCode;
            paymentOrderBudgetTrans.UIN = paymentOrderPR.UIN;
            paymentOrderBudgetTrans.Year = paymentOrderPR.year;

            paymentOrderBudgetTrans.JournalNum = _ledgerJournalTrans.JournalNum;
            paymentOrderBudgetTrans.JournalTransDate = _ledgerJournalTrans.TransDate;
            paymentOrderBudgetTrans.LedgerJournalACType = _ledgerJournalTrans.AccountType;
            paymentOrderBudgetTrans.Voucher = _ledgerJournalTrans.Voucher;
            paymentOrderBudgetTrans.LineNum = _ledgerJournalTrans.LineNum;

            paymentOrderBudgetTrans.insert();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    final boolean isRetryable()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>paymentRequestTaxPurposeText</Name>
				<Source><![CDATA[
    /// <summary>
    /// Makes text description of VAT values and VAT amounts included into journal line created on payment request.
    /// </summary>
    /// <param name="_custVendPaymProposalLine">
    /// The <c>CustVendPaymProposalLine</c> record created on payment request.
    /// </param>
    /// <param name="_ledgerJournalTrans">
    /// The <c>LedgerJournalTrans</c> record created on proposal line.
    /// </param>
    /// <returns>
    /// Text that contains information about VAT values and VAT amounts per value.
    /// </returns>
    protected BankCentralBankPurposeText paymentRequestTaxPurposeText(CustVendPaymProposalLine _custVendPaymProposalLine, LedgerJournalTrans _ledgerJournalTrans)
    {
        CFMPaymentRequestTable paymentRequest;
        CFMPaymentRequestPaymentLink paymentLink;
        Map taxGroupInfoMap;
        MapEnumerator mapEnum;
        container packedMap, taxCodeInfo;
        TaxGroup taxGroup;
        TaxItemGroup taxItemGroup;
        TaxBaseCur taxBaseCur;
        Tax tax;
        TmpTaxWorkTrans tmpTaxWorkTrans;
        CalcTaxes_RU calcTaxes;
        TaxAmount amountVAT;
        TaxValue valueVAT;
        Map taxPercentMap = new Map(Types::Real, Types::Real); // VAT tax amounts for each percent value

        while select paymentRequest
            order by paymentRequest.SourceDataAreaId
        exists join paymentLink
            where paymentLink.PaymentRequest == paymentRequest.RecId
                && paymentLink.RefTableId == _custVendPaymProposalLine.TableId
                && paymentLink.RefRecId == _custVendPaymProposalLine.RecId
        {
            changeCompany(paymentRequest.SourceDataAreaId)
            {
                packedMap = paymentRequest.custVendTaxGroupBaseAmountMap(_ledgerJournalTrans.TransDate, _ledgerJournalTrans.CurrencyCode);

                taxGroupInfoMap = Map::create(packedMap);
                mapEnum = taxGroupInfoMap.getEnumerator();

                while (mapEnum.moveNext())
                {
                    taxCodeInfo = mapEnum.currentKey();
                    taxBaseCur  = mapEnum.currentValue();
                    taxGroup = conPeek(taxCodeInfo, 1);
                    taxItemGroup = conPeek(taxCodeInfo, 2);

                    tax = Tax::construct();
                    tax.taxCalcWithoutSource(
                        taxGroup,
                        taxItemGroup,
                        _ledgerJournalTrans.TransDate,
                        _ledgerJournalTrans.CurrencyCode,
                        0,
                        paymentRequest.AccountType == CFMAccountType::Vend ? TaxModuleType::Purch : TaxModuleType::Sales);

                    taxBaseCur = tax.amountExclTax(taxBaseCur);

                    tax = Tax::construct();
                    tax.taxCalcWithoutSource(
                        taxGroup,
                        taxItemGroup,
                        _ledgerJournalTrans.TransDate,
                        _ledgerJournalTrans.CurrencyCode,
                        taxBaseCur,
                        paymentRequest.AccountType == CFMAccountType::Vend ? TaxModuleType::Purch : TaxModuleType::Sales);

                    tmpTaxWorkTrans.setTmpData(tax.tmpTaxWorkTrans());

                    select tmpTaxWorkTrans;

                    calcTaxes = CalcTaxes_RU::construct(tmpTaxWorkTrans);
                    calcTaxes.calc();

                    amountVAT = CurrencyExchangeHelper::amount(
                        calcTaxes.taxAmountCur_VAT() + calcTaxes.taxAmountCur_VATReduced() + calcTaxes.taxAmountCur_VATZero(),
                        _ledgerJournalTrans.CurrencyCode);

                    valueVAT = calcTaxes.taxValue_VAT();

                    if (valueVAT && amountVAT)
                    {
                        if (taxPercentMap.exists(valueVAT))
                        {
                            amountVAT += taxPercentMap.lookup(valueVAT);
                        }

                        taxPercentMap.insert(valueVAT, amountVAT);
                    }
                }
            }
        }

        mapEnum = taxPercentMap.getEnumerator();

        BankCentralBankPurposeText result;
        CurrencyNameDeclension_RU currencyNameDeclension;
        int amountVATPenny;
        while (mapEnum.moveNext())
        {
            amountVAT = mapEnum.currentValue();
            valueVAT = mapEnum.currentKey();

            currencyNameDeclension = CurrencyNameDeclension_RU::find(_ledgerJournalTrans.CurrencyCode, CompanyInfo::languageId());

            if (currencyNameDeclension.ShortNamePenny)
            {
                amountVATPenny = (decRound(frac(amountVAT), 2) * 100);
                amountVAT = trunc(amountVAT);

                result += strFmt(
                    "@GLS111818",
                    valueVAT,
                    num2str(amountVAT, 0, 0, 0, 0),
                    strLwr(currencyNameDeclension.ShortName)) + ' ' + num2Str0(amountVATPenny, 2) + ' ' + strLwr(currencyNameDeclension.ShortNamePenny) + '\n';
            }
            else
            {
                result += strFmt("@GLS111818", valueVAT, amountVAT, strLwr(currencyNameDeclension.ShortName)) + '\n';
            }
        }

        select firstonly paymentRequest
        exists join paymentLink
            where paymentLink.PaymentRequest == paymentRequest.RecId
                && paymentLink.RefTableId == _custVendPaymProposalLine.TableId
                && paymentLink.RefRecId == _custVendPaymProposalLine.RecId;

        CFMAgreementPaymentOrder agreementPaymentOrder;
        changeCompany(paymentRequest.SourceDataAreaId)
        {
            if (paymentRequest.paymModeTable().PaymSumBy == PaymSumBy::Invoice && paymentRequest.BankPurposeText)
            {
                result += paymentRequest.BankPurposeText + '\n';
            }
            else
            {
                switch (paymentRequest.AccountType)
                {
                    case CFMAccountType::Cust:
                        agreementPaymentOrder = CFMAgreementPaymentOrder::findByAgreement(SalesAgreementHeader::findAgreementId(paymentRequest.AgreementID).RecId, SalesPurch::Sales);
                        break;

                    case CFMAccountType::Vend:
                        agreementPaymentOrder = CFMAgreementPaymentOrder::findByAgreement(PurchAgreementHeader::findAgreementId(paymentRequest.AgreementID).RecId, SalesPurch::Purch);
                        break;
                }

                if (agreementPaymentOrder.BankPurposeText)
                {
                    result += agreementPaymentOrder.BankPurposeText + '\n';
                }
            }
        }

        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateWithholdingTaxGroup_IN</Name>
				<Source><![CDATA[
    private void updateWithholdingTaxGroup_IN()
    {
        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            CustVendPaymProposalLine custVendPaymProposalLine;
            // Updates TDS/TCS for payment proposal from invoice journal.
            while select AccountType, TransOpenRecId from custVendPaymProposalLine
                join ToSpecRecId from specTransUpdateTmp
                    where specTransUpdateTmp.FromSpecRecId == custVendPaymProposalLine.RecId
            {
                LedgerJournalTransTaxExtensionIN ledgerJournalTransTaxExtensionINInvJour;
                LedgerJournalTrans ledgerJournalTransInvJour;

                if (custVendPaymProposalLine.AccountType ==  ModuleCustVend::Vend)
                {
                    VendTrans vendTransInvJour;
                    VendTransOpen vendTransOpenInvJour;

                    select firstonly RecId, TDSGroup, TCSGroup from ledgerJournalTransTaxExtensionINInvJour
                        exists join ledgerJournalTransInvJour
                            where ledgerJournalTransTaxExtensionINInvJour.LedgerJournalTrans == ledgerJournalTransInvJour.RecId
                        exists join vendTransInvJour
                            where vendTransInvJour.RecId == ledgerJournalTransInvJour.VendTransId
                        exists join vendTransOpenInvJour
                            where vendTransOpenInvJour.RefRecId == vendTransInvJour.RecId
                                && vendTransOpenInvJour.RecId == custVendPaymProposalLine.TransOpenRecId;
                }
                else
                {
                    CustTrans custTransInvJour;
                    CustTransOpen custTransOpenInvJour;

                    select firstonly RecId, TDSGroup, TCSGroup from ledgerJournalTransTaxExtensionINInvJour
                        exists join ledgerJournalTransInvJour
                            where ledgerJournalTransTaxExtensionINInvJour.LedgerJournalTrans == ledgerJournalTransInvJour.RecId
                        exists join custTransInvJour
                            where custTransInvJour.RecId == ledgerJournalTransInvJour.CustTransId
                        exists join custTransOpenInvJour
                            where custTransOpenInvJour.RefRecId == custTransInvJour.RecId
                                && custTransOpenInvJour.RecId == custVendPaymProposalLine.TransOpenRecId;
                }

                if (ledgerJournalTransTaxExtensionINInvJour.RecId)
                {
                    ttsbegin;
                    LedgerJournalTransTaxExtensionIN LedgerJournalTransTaxExtensionIN = LedgerJournalTrans::findRecId(specTransUpdateTmp.ToSpecRecId, false).ledgerJournalTransTaxExtensionIN();
                    LedgerJournalTransTaxExtensionIN.selectForUpdate(true);
                    ledgerJournalTransTaxExtensionIN.TDSGroup = ledgerJournalTransTaxExtensionINInvJour.TDSGroup;
                    ledgerJournalTransTaxExtensionIN.TCSGroup = ledgerJournalTransTaxExtensionINInvJour.TCSGroup;
                    ledgerJournalTransTaxExtensionIN.Update();
                    ttscommit;
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>ensurePaymentNotDeletedOrPosted</Name>
				<Source><![CDATA[
    private void ensurePaymentNotDeletedOrPosted(LedgerJournalId _ledgerJournalId)
    {
        LedgerJournalTable ledgerJournalTableFound = LedgerJournalTable::find(_ledgerJournalId);
        if (!ledgerJournalTableFound)
        {
            CustVendPaymProposalLine::deleteByJournalId(_ledgerJournalId);
            throw error("@CashManagement:CannotCreatePaymentsInDeletedJournal");
        }
        else if (ledgerJournalTableFound.Posted)
        {
            CustVendPaymProposalLine::deleteByJournalId(_ledgerJournalId);
            throw error("@CashManagement:CannotCreatePaymentsInPostedJournal");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchPaymIdFromCustVendTrans</Name>
				<Source><![CDATA[
    private PaymId fetchPaymIdFromCustVendTrans(CustVendPaymProposalLine _custVendPaymProposalLine)
    {
        PaymId paymId = '';

        if (_custVendPaymProposalLine.AccountType == ModuleCustVend::Cust)
        {
            RefRecId custTransRecId = CustTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId;
            paymId = CustTrans::find(custTransRecId).PaymId;
        }
        else if (_custVendPaymProposalLine.AccountType == ModuleCustVend::Vend)
        {
            RefRecId vendTransRecId = VendTransOpen::find(_custVendPaymProposalLine.TransOpenRecId).RefRecId;
            paymId = VendTrans::find(vendTransRecId).PaymId;
        }

        return paymId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTopPickingList</Name>
				<Source><![CDATA[
    internal static List generateTopPickingList(container _packedInformation, int _bundleSize = 0)
    {
        ClassId classId;
        container packedInformation;
        [classId, packedInformation] = _packedInformation;
        DictClass dictClass = new DictClass(classId);
        CustVendPaymProposalTransferToJournal custVendTransferPaymJournal = dictClass.makeObject();
        custVendTransferPaymJournal.unpack(packedInformation);
        return custVendTransferPaymJournal.generateTopPickingTaskList(_bundleSize);
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTopPickingTaskList</Name>
				<Source><![CDATA[
    internal List generateTopPickingTaskList(int _bundleSize = 0)
    {
        List subTaskList = this.generateTopPickingListInternal(_bundleSize);
        ListEnumerator rangeListEnumerator = subTaskList.getEnumerator();
        ClassId classId = classIdGet(this);
        DictClass dictClass = new DictClass(classId);
        List res = new List(Types::Container);
        while (rangeListEnumerator.moveNext())
        {
            CustVendPaymProposalTransferToJournal subCustVendPaymProposalTransferToJournal = dictClass.makeObject();
            subCustVendPaymProposalTransferToJournal.unpack(this.pack());
            RecId start = conPeek(rangeListEnumerator.current(), 1);
            RecId end = conPeek(rangeListEnumerator.current(), 2);
            subCustVendPaymProposalTransferToJournal.parmFromProposalRecId(start);
            subCustVendPaymProposalTransferToJournal.parmToProposalRecId(end);
            subCustVendPaymProposalTransferToJournal.parmIsInTopPicking(true);
            res.addEnd([classIdGet(subCustVendPaymProposalTransferToJournal), subCustVendPaymProposalTransferToJournal.pack()]);
        }
        return res;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initQueryForTPspliting</Name>
				<Source><![CDATA[
    private Query initQueryForTPspliting()
    {
        Query query = new Query();
        QueryBuildDataSource qbds = query.addDataSource(tableNum(CustVendPaymProposalLine));
        if (!ledgerJournalTable)
        {
            ledgerJournalTable = LedgerJournalTable::find(ledgerJournalId);
        }
        qbds.addRange(fieldNum(CustVendPaymProposalLine, JournalId)).value(queryValue(ledgerJournalTable.JournalNum));
        qbds.addSortField(fieldNum(CustVendPaymProposalLine, RecId));
        qbds = qbds.addDataSource(tableNum(SpecTrans));
        qbds.relations(true);
        qbds.joinMode(JoinMode::ExistsJoin);
        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateTopPickingListInternal</Name>
				<Source><![CDATA[
    private List generateTopPickingListInternal(int _bundleSize = 0)
    {
        List subTaskList = new List(Types::container);
        Query tpSplitQuery = this.initQueryForTPspliting();
        QueryRun queryRun = new QueryRun(tpSplitQuery);
        int counter = 0;
        RecId start, end;

        int runningBundleSize = _bundleSize ? _bundleSize : BundleSize;

        while (queryRun.next())
        {
            CustVendPaymProposalLine custVendPaymProposalLine = queryRun.get(tableNum(CustVendPaymProposalLine));
            if (!start)
            {
                start = custVendPaymProposalLine.RecId;
                counter ++;
            }
            else if (counter < runningBundleSize)
            {
                counter ++;
            }
            else if (counter == runningBundleSize)
            {
                subTaskList.addEnd([start, end]);
                start = custVendPaymProposalLine.RecId;
                counter = 1;
            }
            end = custVendPaymProposalLine.RecId;
        }
        subTaskList.addEnd([start, end]);
        return subTaskList;
    }

]]></Source>
			</Method>
			<Method>
				<Name>triggerTopPickingRun</Name>
				<Source><![CDATA[
    internal static boolean triggerTopPickingRun(container _payload)
    {
        ClassId classId;
        container payload;
        [classId, payload] = _payload;
        DictClass dictClass = new DictClass(classId);
        CustVendPaymProposalTransferToJournal custVendTransferPaymJournal = dictClass.makeObject();
        custVendTransferPaymJournal.parmInBatch(true);
        custVendTransferPaymJournal.unpack(payload);
        custVendTransferPaymJournal.execute();
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postOperationsInTopPicking</Name>
				<Source><![CDATA[
    internal static void postOperationsInTopPicking(container _payLoad)
    {
        ClassId classId;
        container payload;
        [classId, payload] = _payload;
        DictClass dictClass = new DictClass(classId);
        CustVendPaymProposalTransferToJournal custVendTransferPaymJournal = dictClass.makeObject();
        custVendTransferPaymJournal.unpack(payload);
        LedgerJournalId journalNum = custVendTransferPaymJournal.getLedgerJournalId();

        ttsbegin;
        CustVendPaymProposalBatchProcess::changeState(journalNum, CustVendPaymProposalBatchProcessState::CreatedPaymentLines);
        ttscommit;

        custVendTransferPaymJournal.notifyUserAfterTransferProposal();

        CustVendPaymProposalLine::deleteByJournalId(journalNum);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>