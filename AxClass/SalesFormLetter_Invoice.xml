<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>SalesFormLetter_Invoice</Name>
	<SourceCode>
		<Declaration><![CDATA[
[DocumentStatusFactoryAttribute(DocumentStatus::Invoice)]
[SysOperationJournaledParametersAttribute(true)]
class SalesFormLetter_Invoice extends SalesFormLetter implements BatchRetryable
{
    SalesFormLetterInvoiceContract salesFormLetterInvoiceContract;

    // <GEERU>
    boolean markupOfTypeCustVendExists;
    boolean extraPrintoutLineExists;
    // </GEERU>

    private const Version currentVersion = 10;

    #define.lastVersion9(9)
    #LOCALMACRO.ParmList9
        printerSettingsBillOfExchange,
        readyCashReceipts
    #ENDMACRO
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>afterOperationBody</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the main logic after an operation, before cleanup.
    /// </summary>
    protected void afterOperationBody()
    {
        this.sendToCashRegister_W();
        super();
        this.createPayment();
    }

]]></Source>
			</Method>
			<Method>
				<Name>caption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Microsoft internal use only.
    /// </summary>
    /// <returns>
    /// A <c>ClassDescription</c> value.
    /// </returns>
    public ClassDescription caption()
    {
        return SalesFormLetter_Invoice::description();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDuplicateNum_W</Name>
				<Source><![CDATA[
    public boolean checkDuplicateNum_W(Num _num, SalesIdBase _salesId, TransDate _transDate)
    {
        boolean isValid = super(_num, _salesId, _transDate);

        if (isValid && _num)
        {
            isValid = CustInvoiceJour::checkDuplicateNum_W(_num, _salesId, _transDate);
        }

        return isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoiceAmounts</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if at least one of invoice lines being posted have zero line amount. Prompts for confirmation to proceed if any found.
    /// </summary>
    /// <returns>
    /// false if user does not allow posting for lines without line amount.
    /// </returns>
    private boolean checkInvoiceAmounts()
    {
        SalesParmLine localSalesParmLine;
        boolean ok = true;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
        {
            select firstonly RecId from localSalesParmLine
                where localSalesParmLine.ParmId == this.parmId() &&
                     !localSalesParmLine.LineAmount;

            if (localSalesParmLine)
            {
                ok = false;
            }
        }

        if (! ok)
        {
            ok = (Box::yesNo("@SYS4082018", DialogButton::Yes, "@SYS866") == DialogButton::No) ?
                             checkFailed("@SYS21533") :
                             true;
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoicePostingType_RU</Name>
				<Source><![CDATA[
    private boolean checkInvoicePostingType_RU()
    {
        SalesParmTable salesParmTableLocal;
        SalesParmLine salesParmLine;
        SalesLine salesLine;

        boolean ret = true;

        if (this.documentStatus() == DocumentStatus::Invoice)
        {
            select firstonly RecId from salesParmTableLocal
                where salesParmTableLocal.ParmId == this.parmId() &&
                      salesParmTableLocal.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute
            join TableId from salesParmLine
                where salesParmLine.ParmId == salesParmTableLocal.ParmId &&
                      salesParmLine.TableRefId == salesParmTableLocal.TableRefId
            join TableId from salesLine
                where salesLine.RecId == salesParmLine.SalesLineRecId &&
                     (salesLine.StockedProduct == NoYes::No ||
                     (salesLine.SalesCategory && !salesLine.ItemId));

            if (salesParmTableLocal.RecId)
            {
                ret = checkFailed("@GLS220090");
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildCheckInvoicePricesQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a <c>SalesParmTable</c> query
    /// </summary>
    /// <returns>
    /// A query having SalesParmTable table data.
    ///</returns>
    protected Query buildCheckInvoicePricesQuery()
    {
        Query query = new Query();

        QueryBuildDataSource qbdsSalesParmTableLocal = query.addDataSource(tableNum(SalesParmTable));
        qbdsSalesParmTableLocal.firstOnly(true);
        qbdsSalesParmTableLocal.addSelectionField(fieldNum(SalesParmTable, RecId));
        qbdsSalesParmTableLocal.addRange(fieldNum(SalesParmTable, ParmId)).value(queryValue(this.parmId()));

        QueryBuildDataSource qbdsSalesParmLine = qbdsSalesParmTableLocal.addDataSource(tableNum(SalesParmLine));
        qbdsSalesParmLine.joinMode(JoinMode::ExistsJoin);
        qbdsSalesParmLine.addLink(fieldNum(SalesParmLine, TableRefId), fieldNum(SalesParmTable, TableRefId));
        qbdsSalesParmLine.addLink(fieldNum(SalesParmTable, ParmId), fieldNum(SalesParmLine, ParmId));

        QueryBuildDataSource qbdsSalesLine = qbdsSalesParmLine.addDataSource(tableNum(SalesLine));
        qbdsSalesLine.joinMode(JoinMode::ExistsJoin);
        qbdsSalesLine.addLink(fieldNum(SalesParmLine, SalesLineRecId), fieldNum(SalesLine, RecId));
        qbdsSalesLine.addRange(fieldNum(SalesLine, SalesPrice)).value(queryValue(0));

        return query;
   
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkInvoicePrices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if at least one of sales order lines being processed does not have item price specified. Prompts for confirmation to proceed if any found.
    /// </summary>
    /// <returns>
    /// false if user does not allow posting for lines without item price.
    /// </returns>
    private boolean checkInvoicePrices()
    {
        boolean pricesAreValid = true;

        if (isConfigurationkeyEnabled(configurationKeyNum(TradeDates_W)) && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            QueryRun qr = new QueryRun(this.buildCheckInvoicePricesQuery());

            qr.next();
            SalesParmTable salesParmTableLocal = qr.get(tableNum(salesParmTable));

            if (salesParmTableLocal)
            {
                pricesAreValid = false;
            }
        }

        if (! pricesAreValid)
        {
            pricesAreValid = (Box::yesNo("@GLS110181", DialogButton::Yes, "@SYS866") == DialogButton::No) ?
                             checkFailed("@SYS21533") :
                             true;
        }

        return pricesAreValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentExportFormat</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that none of the sales orders being processed has a payment method with an export file format. If one does exist,
    /// the invoices cannot be processed in a batch.
    /// </summary>
    /// <returns>
    /// true if the validation is successful; otherwise, false.
    /// </returns>
    private boolean checkPaymentExportFormat()
    {
        SalesParmTable salesParmTableLocal;
        SalesTable salesTable;
        CustPaymModeTable custPaymModeTable;
        boolean isPaymentExportFormatValid = true;

        if (this.batchInfo().parmBatchExecute())
        {
            select firstonly RecId, SalesId from salesParmTableLocal
                where salesParmTableLocal.ParmId == this.parmId()
            exists join salesTable
                where salesTable.SalesId == salesParmTableLocal.SalesId
            exists join custPaymModeTable
                where custPaymModeTable.PaymMode == salesTable.PaymMode &&
                      custPaymModeTable.ExportOnInvoice;

            if (salesParmTableLocal)
            {
                isPaymentExportFormatValid = false;
            }
        }

        if (!isPaymentExportFormatValid)
        {
            checkFailed(strFmt("@SYS4010220", salesParmTableLocal.SalesId));
        }

        return isPaymentExportFormatValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPrintout_RU</Name>
				<Source><![CDATA[
    final protected boolean checkPrintout_RU()
    {
        SalesParmLine tmpSalesParmLine;
        Set warningSet = new Set(Types::String);
        SalesTable salesTable = this.salesTable();
        SalesParmUpdate salesParmUpdate = this.salesParmUpdate();

        boolean ret = super();

        if (this.parmCustInvoicePrintoutType_RU() == CustInvoicePrintoutType_RU::M_15)
        {
            if (MarkupTrans::existOfTypeCustVend_RU(salesTable.TableId, salesTable.RecId))
            {
                warningSet.add(strFmt("@GLS107023", salesTable.SalesId, MarkupType::CustVend));
                markupOfTypeCustVendExists = true;
            }

            SalesTotals salesTotals = SalesTotals::construct(salesTable,
                                                             salesParmUpdate.SpecQty,
                                                             salesParmUpdate.SumBy,
                                                             salesParmUpdate.ParmId,
                                                             salesParmUpdate.SumSalesId,
                                                             this.documentStatus());
            salesTotals.calc();

            RecordSortedList recordListSalesParmLine = salesTotals.recordSortedListLine();
            recordListSalesParmLine.first(tmpSalesParmLine);
            while (tmpSalesParmLine)
            {
                SalesLine tmpSalesLine = tmpSalesParmLine.salesLine();

                if (MarkupTrans::existOfTypeCustVend_RU(tmpSalesLine.TableId, tmpSalesLine.RecId))
                {
                    warningSet.add(strFmt("@GLS107025", tmpSalesLine.SalesId, tmpSalesLine.LineNum, MarkupType::CustVend));
                    markupOfTypeCustVendExists = true;
                }

                if (!recordListSalesParmLine.next(tmpSalesParmLine))
                    break;
            }

            if (salesTotals.totalEndDisc())
            {
                warningSet.add("@GLS107055");
                extraPrintoutLineExists = true;
            }

            if (salesTotals.totalRoundOff())
            {
                warningSet.add("@GLS107056");
                extraPrintoutLineExists = true;
            }

            if ((markupOfTypeCustVendExists ||
                 extraPrintoutLineExists) &&
                Box::okCancel(strFmt("@GLS107057", MarkupType::CustVend),
                              DialogButton::Cancel,
                              "@GLS106990") == DialogButton::Cancel)
            {
                ret = false;

                SetIterator it = new SetIterator(warningSet);
                while (it.more())
                {
                    warning(it.value());
                    it.next();
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkPaymentSchedule</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks payment schedule in the current invoice for adjusted payment.
    /// </summary>
    /// <returns>
    /// returns true if the payment schedules are adjusted correctly, otherwise false
    /// </returns>
    public boolean checkPaymentSchedule()
    {
        boolean         ret = true;
        CustPaymSched   custPaymSched;
        SalesParmTable  localSalesParmTable;
        SalesParmUpdate salesParmUpdate = this.salesParmUpdate();

        if (salesParmUpdate.numberOfSubTables() <= 1)
        {
            // If there is only one subtable, arrange will have no effect. Allow adjusted payments in that case.
            return true;
        }

        // Check all documents in the current session for adjusted payments
        setPrefix("@AccountsReceivable:SalesFormLetterPaymentSchedulePrefix");

        while select localSalesParmTable
            where localSalesParmTable.ParmId == this.parmId()
            exists join custPaymSched
                where custPaymSched.ExtTableId == localSalesParmTable.TableId &&
                        custPaymSched.ExtRecId == localSalesParmTable.RecId
        {
            ret = false;
            str errorText = strFmt("@AccountsReceivable:SalesFormLetterPaymentScheduleFoundOnSO", localSalesParmTable.SalesId);
            error(errorText);

            salesParmTable = localSalesParmTable;
            int infologNum = infolog.num();
            ttsbegin;
            this.updateParmTableWithErrors(Info::infoCon2Str(infolog.copy(infologNum,infologNum)));
            ttscommit;
        }

        if (!ret)
            info("@AccountsReceivable:SalesFormLetterInvoicesCannotBeArranged" + '\n' + "@AccountsReceivable:SalesFormLetterPaymentScheduleInstructions");

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateParmTableWithErrors</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Updates a <c>salesParmTable</c> record with the specified log text.
    /// </summary>
    /// <param name="_logText">
    ///    The log text to assign to the <c>salesParmTable</c> record.
    /// </param>
    public void updateParmTableWithErrors(LogText _logText)
    {
        salesParmTable = SalesParmTable::find(salesParmTable.ParmId, salesParmTable.TableRefId, true);
        salesParmTable.Log = _logText;
        salesParmTable.updateParmJobStatusContainErrors();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSalesLineChanged</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the specified <c>SalesParmLine</c> record.
    /// </summary>
    /// <param name="_salesParmLine">
    /// The <c>SalesParmLine</c> record to verify.
    /// </param>
    /// <param name="_salesLine">
    /// The source <c>SalesLine</c> table record.
    /// </param>
    /// <returns>
    /// true if the <c>SalesParmLine</c> record is valid; otherwise, false.
    /// </returns>
    /// <remarks>
    /// An Infolog message can be shown if a correction is being made for a line with active tracking
    /// dimensions, but no specific dimension is specified.
    /// </remarks>
    protected boolean checkSalesLineChanged(SalesParmLine _salesParmLine, SalesLine _salesLine)
    {
        boolean ok = super(_salesParmLine, _salesLine);

        // Validates the length of sales order line names are valid.
        if (ok 
            && this.needValidateLineName_PL())
        {
            ok = this.validateLineName_PL(_salesParmLine);
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkServiceTariffNumber</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a service tariff number.
    /// </summary>
    /// <returns>
    /// true if the service tariff number is valid; otherwise, false.
    /// </returns>
    protected boolean checkServiceTariffNumber()
    {
        SalesParmTable salesParmTableLocal;
        SalesParmLine salesParmLineLocal;
        SalesLine salesLineLocal;
        TaxGroupHeading taxGroupHeading;
        boolean ret = super();
        TaxServiceTariff taxServiceTariff;

        if (ret && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoPL]))
        {
            while select TableRefId, ParmId from salesParmTableLocal
                    where salesParmTableLocal.ParmId == this.salesParmUpdate().ParmId
                join SalesId, ItemId, TaxGroup from salesLineLocal
                exists join salesParmLineLocal
                    where salesParmLineLocal.TableRefId == salesParmTableLocal.TableRefId &&
                          salesParmLineLocal.ParmId == salesParmTableLocal.ParmId &&
                          salesParmLineLocal.InventTransId == salesLineLocal.InventTransId
                exists join taxGroupHeading
                    where taxGroupHeading.TaxGroup == salesLineLocal.TaxGroup &&
                          taxGroupHeading.IsMandatoryServiceTariff_PL == 1
                notexists join taxServiceTariff
                    where taxServiceTariff.ParentTableId == salesLineLocal.TableId &&
                          taxServiceTariff.ParentRecId == salesLineLocal.RecId
            {
                ret = ret & checkFailed(
                    strFmt("@GLS115888", salesLineLocal.SalesId, salesLineLocal.ItemId, salesLineLocal.TaxGroup));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkSumBy</Name>
				<Source><![CDATA[
    protected boolean checkSumBy()
    {
        SalesParmTable salesParmTableLocal;
        SalesParmUpdate salesParmUpdate = this.salesParmUpdate();

        boolean ret = super();

        if (ret && salesParmUpdate.SumBy != AccountOrder::None)
        {
            select firstonly salesParmTableLocal
                    where salesParmTableLocal.ParmId == salesParmUpdate.ParmId &&
                          salesParmTableLocal.InvoicePostingType_RU == SalesInvoicePostingType_RU::GoodsInRoute;

            if (salesParmTableLocal)
            {
                ret = checkFailed(strFmt("@GLS114814", SalesInvoicePostingType_RU::GoodsInRoute));
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createPayment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates payments and prints payment proposals if it is needed.
    /// </summary>
    protected void createPayment()
    {
        Set journalSet = Set::create(formletterOutputContract.parmAllJournalsPacked());
        SetEnumerator se = journalSet.getEnumerator();

        while (se.moveNext())
        {
            CustInvoiceJour custInvoiceJour = se.current();
            CustTrans custTrans = custInvoiceJour.custTrans();

            if (CustPaymModeTable::find(custTrans.PaymMode).PaymOnInvoice)
            {
                CustVendPaymInvoiceWithJournal::construct(custInvoiceJour).run();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>documentStatus</Name>
				<Source><![CDATA[
    public DocumentStatus documentStatus()
    {
        return DocumentStatus::Invoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endUpdate</Name>
				<Source><![CDATA[
    public void endUpdate()
    {
        SalesParmUpdate salesParmUpdate = this.salesParmUpdate();
        if (salesParmUpdate.Proforma)
        {
            ttsbegin;
            salesParmUpdate = SalesParmUpdate::find(salesParmUpdate.ParmId, true);
            salesParmUpdate.delete();
            ttscommit;
        }

        if (SalesParmUpdate::exist(this.parmId()))
        {
            ttsbegin;

            salesParmUpdate = SalesParmUpdate::find(this.parmId(), true);

            salesParmUpdate.EndDateTime = DateTimeUtil::newDateTime(DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()),DateTimeUtil::getTimeNow(DateTimeUtil::getUserPreferredTimeZone()),DateTimeUtil::getUserPreferredTimeZone());
            salesParmUpdate.update();

            ttscommit;
        }
        this.salesParmUpdate(salesParmUpdate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getInvoiceContract</Name>
				<Source><![CDATA[
    public SalesFormLetterInvoiceContract getInvoiceContract()
    {
        return salesFormLetterInvoiceContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSalesDocumentTimezonePreference</Name>
				<Source><![CDATA[
    protected SalesDocumentTimezonePreference getSalesDocumentTimezonePreference()
    {
        return SalesParameters::find().InvoiceTimezonePreference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValuesFormletterParmData</Name>
				<Source><![CDATA[
    protected void getValuesFormletterParmData(FormLetterParmDataOutputContract _outputContract)
    {
        super(_outputContract);

        giroAllSame = _outputContract.parmGiroAllSame();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckIntrastat</Name>
				<Source><![CDATA[
    protected boolean mustCheckIntrastat()
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new service controller object.
    /// </summary>
    /// <param name="_className">
    /// The class name of the service class.
    /// </param>
    /// <param name="_methodName">
    /// The method name of the service operation.
    /// </param>
    /// <param name="_executionMode">
    /// The execution mode to use when executing the service operation.
    /// </param>
    /// <remarks>
    /// parm methods exist for each constructor parameter. The <c>initializeFromArgs</c> method can also be
    /// used to initialize a controller. If those options for initialization are used, the default values
    /// can be used in the constructor.
    /// </remarks>
    public void new(
        IdentifierName _className = classStr(FormletterService),
        IdentifierName _methodName = methodStr(FormletterService, postSalesOrderInvoice),
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::Synchronous)
    {
        super(_className, _methodName, _executionMode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    container pack()
    {
        return [currentVersion, printerSettingsBillOfExchange, readyCashReceipts] + [super()]
            + [this.pdsPack()]
        ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmExtraPrintoutLineExists_RU</Name>
				<Source><![CDATA[
    public boolean parmExtraPrintoutLineExists_RU(boolean _extraPrintoutLineExists = salesFormLetterContract.parmExtraPrintoutLineExists_RU())
    {
        return salesFormLetterContract.parmExtraPrintoutLineExists_RU(_extraPrintoutLineExists);
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMarkupOfTypeCustVendExists_RU</Name>
				<Source><![CDATA[
    public boolean parmMarkupOfTypeCustVendExists_RU(boolean _markupOfTypeCustVendExists = markupOfTypeCustVendExists)
    {
        markupOfTypeCustVendExists = _markupOfTypeCustVendExists;
        return markupOfTypeCustVendExists;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printExtraDocuments</Name>
				<Source><![CDATA[
    protected boolean printExtraDocuments()
    {
        return this.printEntryCertificate_W();
    }

]]></Source>
			</Method>
			<Method>
				<Name>printMgmtDocumentType</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Identifies the print management document type.
    /// </summary>
    /// <returns>
    ///    The print management document type for a sales order invoice.
    /// </returns>
    protected PrintMgmtDocumentType printMgmtDocumentType()
    {
        return PrintMgmtDocumentType::SalesOrderInvoice;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the event handler subscription.
    /// </summary>
    public void run()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectFromJournal</Name>
				<Source><![CDATA[
    public void selectFromJournal(container _packedTmpFrmVirtualList)
    {
        SalesFormletterParmDataInvoice salesFormletterParmData = SalesFormletterParmData::newChooseLines(this.packDataContract(salesFormLetterContract), true);

        salesFormletterParmData.selectFromJournal(_packedTmpFrmVirtualList);
        FormLetterParmDataOutputContract outputContract = salesFormletterParmData.getOutputContract();
        this.getValuesFormletterParmData(outputContract);

        this.reArrangeNow(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>sendToCashRegister_W</Name>
				<Source><![CDATA[
    /// <summary>
    /// Prepares container of documents for which Cash Receipts should be printed.
    /// Container has next structure : [[Voucher1, TransDate1], [Voucher2, TransDate2], ...].
    /// </summary>
    protected void sendToCashRegister_W()
    {
        Set journalSet = Set::create(formletterOutputContract.parmAllJournalsPacked());
        SetEnumerator se = journalSet.getEnumerator();

        while (se.moveNext())
        {
            CustInvoiceJour custInvoiceJour = se.current();
            CashRegisterProcessingBase::sendFromCustInvoiceJournal(custInvoiceJour);

            CustTrans custTransPayment;
            CustTrans custTrans = custInvoiceJour.custTrans();
            CustSettlement custSettlement;

            select firstonly Voucher, TransDate from custTransPayment
                exists join custSettlement
                where custSettlement.OffsetRecid == custTransPayment.RecId
                    && custSettlement.TransRecId == custTrans.RecId
                    && custSettlement.TransCompany == custTrans.dataAreaId
                    && custSettlement.AccountNum == custTrans.AccountNum;

            container receipts = this.parmReadyCODCashReceipts();
            receipts += [[custTransPayment.Voucher, custTransPayment.TransDate]];
            this.parmReadyCODCashReceipts(receipts);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setInvoiceNumbering_LT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the numbering code and sets invoice numbering.
    /// </summary>
    /// <exception cref="Exception::Error">
    /// Throws error message when numbering code can't be found.
    /// </exception>
    protected void setInvoiceNumbering_LT()
    {
        LtDocNumberingCode docNumberingCode;

        docNumberingCode = LtInvoiceAutoNumberingTable::findDocNumberingCodeForRetail();
        if (!docNumberingCode)
        {
            throw error(strFmt("@SYS4002053", curuserid()));
        }

        this.getSalesFormLetterContract().parmLtDocNumberingCode(docNumberingCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNewContract</Name>
				<Source><![CDATA[
    protected void setNewContract(FormLetterContract _contract)
    {
        super(_contract);
        if (!contractIsFromPreviousVersion)
        {
            salesFormLetterInvoiceContract = _contract;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    boolean unpack(container _packedClass)
    {
        Version version = conPeek(_packedClass,1);
        container packedBase;

        container pdsPackedClass;

        ParmId parmId;
        SalesParmUpdate salesParmUpdate;
        NoYes backorder;
        NoYes queryCriteria;
        NoYes editing;
        Printout printout;
        NoYes printFormletter;
        NoYes printCODLabel;
        NoYes printFreightSlip;
        container printerSettingsFormLetter;
        container printerSettingsFreightSlip;
        container printerSettingsCODLabel;
        NoYes printShippingLabel;
        container printerSettingsShippingLabel;
        container printerSettingsFormLetterCopy;
        boolean usePrintManagement;

        #LOCALMACRO.ParmList_v5
            parmId,
            salesParmUpdate,
            backorder,
            queryCriteria,
            editing,
            printOut,
            printFormletter,
            printCODLabel,
            printFreightSlip,
            printerSettingsFormLetter,
            printerSettingsFreightSlip,
            printerSettingsCODLabel,
            printShippingLabel,
            printerSettingsShippingLabel,
            printerSettingsBillOfExchange,
            printerSettingsFormLetterCopy,
            usePrintManagement
        #ENDMACRO

        switch (version)
        {
            case currentVersion :
                [version, printerSettingsBillOfExchange, readyCashReceipts, packedBase
                , pdsPackedClass
                ] = _packedClass;
                this.pdsUnpack(pdsPackedClass);
                return super(packedBase);

            case #LastVersion9 :
                [version, #ParmList9, packedBase
                , pdsPackedClass
                ] = _packedClass;
                this.pdsUnpack(pdsPackedClass);
                return super(packedBase);

            case 7+1 /*case is old currentversion + old parentversion*/ :
                [version, #parmList_v5] = _packedClass;
                this.setNewContract(SalesFormLetterContract::construct(DocumentStatus::Invoice));

                contractIsFromPreviousVersion = true;
                this.parmId(parmId);
                this.salesParmUpdate(salesParmUpdate);
                this.printout(printout);
                this.printFormLetter(printFormletter);
                this.printCODLabel(printCODLabel);
                this.updatePrinterSettingsFormLetter(printerSettingsFormletter, PrintSetupOriginalCopy::Original);
                this.updatePrinterSettingsFormLetter(printerSettingsFormletterCopy, PrintSetupOriginalCopy::Copy);
                this.updatePrinterSettingsCODLabel(printerSettingsCODLabel);
                this.printShippingLabel(printShippingLabel);
                this.updatePrinterSettingsShippingLabel(printerSettingsShippingLabel);
                this.usePrintManagement(usePrintManagement);
                break;

            default :
                return super(_packedClass);
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates whether it is all right to continue.
    /// </summary>
    /// <param name="_calledFrom">
    /// Identifies the object from which this method is called. The default value is null.
    /// </param>
    /// <returns>
    /// true if it is all right to continue; otherwise, false.
    /// </returns>
    /// <remarks>
    /// The validate method is used for validating if it is all right to close the sales posting form when
    /// you post sales orders.
    /// </remarks>
    boolean validate(Object _calledFrom = null)
    {
        boolean ok = super();

        if (ok)
        {
            ok = this.validateBankLC();
        }

        if (ok && ! giroAllSame && !this.salesParmUpdate().LateSelection)
        {
            if (Box::okCancel("@SYS58570", DialogButton::Cancel) == DialogButton::Cancel)
                ok = checkFailed("@SYS21533");
        }

        //<GMX>
        if (EInvoiceCFDIParameters_MX::isElectronicInvoiceEnabled())
        {
            if (!CertificateHelper_MX::isCurrentCFDIPACPrivateKeyReadable() || !CertificateHelper_MX::isCurrentCFDIPrivateKeyReadable())
            {
                ok = checkFailed("@SYS341994");
            }

            if (EInvoiceCFDIParameters_MX::find().EnabledXsdValidation && !EInvoiceCFDIParameters_MX::schemaFileExists())
            {
                ok = checkFailed(strFmt("@SYS109820", EInvoiceCFDIParameters_MX::find().cfdiXsdFile));
            }
        }
        //</GMX>

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            ok = this.checkInvoicePostingType_RU() && ok;
            ok = AlcoholLicenseTable_RU::checkAlcoholLicenseSeriesNumInInvoice(this.salesTable().custTable_InvoiceAccount(),
                                                                               this.salesParmUpdate().ParmId) && ok;
        }
        // </GEERU>

        // <GEEPL>
        ok = ok && this.checkInvoicePrices();
        // </GEEPL>

        // <GEERU>
        ok = this.checkInvoiceAmounts() && ok;
        // </GEERU>

        ok = ok && this.checkPaymentExportFormat();

        ok = ok && this.validateIssueEntryCertificate();

        if (BrazilParameters::isEnabled())
        {
            ok = ok && this.validateLinesOnlyNegativeOrPositive();
        }

        if (isConfigurationkeyEnabled(configurationkeynum(Retail)) && RetailStatementFeatureControl::isRestrictInvoicingEnabled())
        {
            ok = ok && this.checkRetailCashAndCarrySales();
        }
        
        SalesTable salesTableLocal = this.salesTable();

        if (ok 
            && salesTableLocal
            && InterCompanyValidateInvoiceJourCreationAccessFlight::instance().isEnabled())
        {
            ok = salesTableLocal.hasRightsPostInterCompanyPurchaseOrder();
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRetailCashAndCarrySales</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks the following conditions during invoicing
    /// 1. All or none are Retail cash and carry sales which can be invoiced with modification
    /// 2. Summary update is not used
    /// 3. All lines are selected to be invoiced
    /// 4. Invoice date is that of the transaction
    /// </summary>
    /// <returns>
    /// true if all checks passed; otherwise, false.
    /// </returns>
    private boolean  checkRetailCashAndCarrySales()
    {
        SalesParmTable salesParmTableLocal;
        SalesTable     salesTableLocal;
        SalesIdBase    lastStrictRetailSalesId;

        boolean         ok                = true;
        boolean         foundStrictRetail = false;
        boolean         foundNonStrict    = false;
        SalesParmUpdate salesParmUpdate   = this.salesParmUpdate();

        while select salesParmTableLocal
            where salesParmTableLocal.ParmId == salesParmUpdate.ParmId
                join salesTableLocal
                where salesTableLocal.SalesId == salesParmTableLocal.SalesId
        {
            // There is a Retail Cash and Carry sales order and another sales order to be invoiced.
            if (foundStrictRetail)
            {
                ok = checkFailed(strFmt("@Retail:SalesOrderInvoiceIndividually", lastStrictRetailSalesId));
                break;
            }

            if (salesTableLocal.isRetailCashAndCarrySalesWithStrictInvoicing())
            {
                lastStrictRetailSalesId = salesTableLocal.SalesId;
    
                // There is a non-Retail Cash and Carry sales order and a Retail Cash and Carry sales order to be invoiced.
                if (foundNonStrict)
                {
                    ok = checkFailed(strFmt("@Retail:SalesOrderInvoiceIndividually", lastStrictRetailSalesId));
                    break;
                }

                // Verify there is no summary update
                if (!foundStrictRetail && salesParmUpdate.SumBy != AccountOrder::None)
                {
                    ok = checkFailed(strFmt("@Retail:SalesOrderInvoiceNotAllowed", "@SYS57755"));
                    break;
                }

                // Verify all lines are being invoiced
                if (!foundStrictRetail && salesParmUpdate.SpecQty != SalesUpdate::All)
                {
                    ok = checkFailed("@Retail:SalesOrderInvoiceAllLines");
                    break;
                }

                RetailBusinessDate cashAndCarryBusinessDate = this.getRetailCashAndCarryBusinessDate(salesTableLocal);
                // Verify invoice date is that of the transaction
                if (salesParmTableLocal.Transdate != cashAndCarryBusinessDate)
                {
                    ok = checkFailed(strFmt("@Retail:SalesOrderInvoiceOnTrxDate", cashAndCarryBusinessDate));
                    break;
                }

                foundStrictRetail = true;
            }
            else
            {
                foundNonStrict = true;
            }
        }

        return ok;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRetailCashAndCarryBusinessDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the business date for the Retail Cash and Carry sales order.
    /// This is just a stub since real implementation lives inside the RetailEod model since we need acccess to <c>RetailEodTransactionAggregationHeader</c>.
    /// </summary>
    /// <param name = "_salesTable">The sales order being invoiced.</param>
    /// <returns>The business date of the Retail cash and carry sales order.</returns>
    /// <seealso>SalesFormLetter_Invoice_RetailEod_Extension</seealso>
    [Replaceable(true)]
    public RetailBusinessDate getRetailCashAndCarryBusinessDate(SalesTable _salesTable)
    {
        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLinesOnlyNegativeOrPositive</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if all lines of each invoice are all only negative or positive
    /// </summary>
    /// <returns>
    /// True if all lines of each invoice are only positive or negative
    /// </returns>
    private boolean validateLinesOnlyNegativeOrPositive()
    {
        SalesParmLine  localSalesParmLinePositive;
        SalesParmLine  localSalesParmLineNegative;

        SalesParmTable localSalesParmTable;

        while select TableRefId
            from localSalesParmTable
                where localSalesParmTable.ParmId == this.parmId()
        {
            select firstonly RecId
                from localSalesParmLineNegative
                    where localSalesParmLineNegative.ParmId == this.parmId() &&
                          localSalesParmLineNegative.TableRefId == localSalesParmTable.TableRefId &&
                          localSalesParmLineNegative.LineAmount < 0;

            select firstonly RecId
                from localSalesParmLinePositive
                    where localSalesParmLinePositive.ParmId == this.parmId() &&
                          localSalesParmLinePositive.TableRefId == localSalesParmTable.TableRefId &&
                          localSalesParmLinePositive.LineAmount > 0;

            if (localSalesParmLinePositive.RecId && localSalesParmLineNegative.RecId)
            {
                return checkFailed("@Brazil:PostNegativeAndPositiveLinesAreNotAllowed");
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIssueEntryCertificate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that if all the entry certificate has been issued at packing slip posting.
    /// </summary>
    /// <returns>True when Issue Entry Certificaste is validated, otherwise false.</returns>
    private boolean validateIssueEntryCertificate()
    {
        boolean ret = true;
        Qty availPhysicalQty;

        SalesParmTable salesParmTableLoc;

        select firstonly salesParmTableLoc
            where salesParmTableLoc.ParmId == this.parmId();

        if (salesParmTableLoc.IssueOwnEntryCertificate_W == NoYes::Yes)
        {
            SalesLine salesLineLoc;

            while select RecId, SalesId, LineNum, InventTransId from salesLineLoc
                where salesLineLoc.SalesId == salesParmTableLoc.SalesId
            {
                CustPackingSlipTrans custPackingSlipTrans;

                select sum(Qty) from custPackingSlipTrans
                    where custPackingSlipTrans.InventTransId == salesLineLoc.InventTransId;

                CustInvoiceTrans custInvoiceTrans;

                select sum(Qty), sum(QtyPhysical) from custInvoiceTrans
                    where custInvoiceTrans.InventTransId == salesLineLoc.InventTransId;

                CustEntryCertificateTrans_W custEntryCertificateTrans;
                CustEntryCertificateJour_W custEntryCertificateJour;

                if (CustSalesOrderIssueEntryCertificateFlight::instance().isEnabled())
                {
                    select sum(Qty) from custEntryCertificateTrans
                        exists join custEntryCertificateJour
                            where custEntryCertificateJour.RecId == custEntryCertificateTrans.EntryCertificateJourRefRecId
                                && custEntryCertificateTrans.InventTransId == salesLineLoc.InventTransId
                                && custEntryCertificateJour.Status != EntryCertificateStatus_W::Cancelled;
                }
                else
                {
                    select sum(Qty) from custEntryCertificateTrans
                        where custEntryCertificateTrans.InventTransId == salesLineLoc.InventTransId;
                }
                
                SalesParmLine salesParmLineLoc;

                select firstonly DeliverNow from salesParmLineLoc
                    where salesParmLineLoc.SalesLineRecId == salesLineLoc.RecId
                        && salesParmLineLoc.LineNum == salesLineLoc.LineNum
                        && salesParmLineLoc.OrigSalesId == salesLineLoc.SalesId
                        && salesParmLineLoc.TableRefId == salesParmTableLoc.TableRefId
                        && salesParmLineLoc.ParmId == this.parmId();

                Qty currentPhysicalQty = salesParmLineLoc.DeliverNow + custInvoiceTrans.Qty - custInvoiceTrans.QtyPhysical - custPackingSlipTrans.Qty;
                
                if ((salesParmLineLoc.DeliverNow < 0 && currentPhysicalQty > 0) || (salesParmLineLoc.DeliverNow > 0 && currentPhysicalQty < 0))
                {
                    currentPhysicalQty = 0;
                }

                availPhysicalQty += min(currentPhysicalQty + 
                    custInvoiceTrans.QtyPhysical + 
                    custPackingSlipTrans.Qty - 
                    custEntryCertificateTrans.Qty,
                    salesParmLineLoc.DeliverNow);
            }

            if (availPhysicalQty == 0)
            {
                ret = checkFailed("@AccountsReceivable:EntryCertificateIssuedByPackingSlip");
            }
        }
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBankLC</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates that the letter of credit required information is attached with the invoice.
    /// </summary>
    /// <returns>
    ///    true if the validation is successful; otherwise, false.
    /// </returns>
    private boolean validateBankLC()
    {
        boolean ret = true;
        SalesParmUpdate salesParmUpdate = this.salesParmUpdate();
        if (BankLCExportFeatureChecker::checkBankLCExportEnabled()
            && !this.proforma())
        {
            ret = BankLCExportType::validateDocuments(salesParmUpdate.ParmId, salesParmUpdate.DocumentStatus);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateTaxIntegration_CN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Event Handler after Validate method.
    /// </summary>
    /// <returns>
    /// True when tax integration is validated, otherwise false.
    /// </returns>
    public boolean validateTaxIntegration_CN()
    {
        SalesParmTable localSalesParmTable;
        boolean returnValue = true;

        if (CustParameters::isTaxIntegrationSystem_CN())
        {
            Map map = new Map(Types::Container, Types::Container);

            while select localSalesParmTable
                    where localSalesParmTable.ParmId == this.parmId()
            {
                TaxValidateForTaxIntegration_CN taxValidateForTaxIntegration = TaxValidateForTaxIntegration_CN::construct(localSalesParmTable);

                returnValue = taxValidateForTaxIntegration.validate();

                if (!returnValue)
                {
                    break;
                }

                if (map.insert([localSalesParmTable.SalesId, localSalesParmTable.ParmId],[taxValidateForTaxIntegration.parmTaxprofileTable()]))
                {
                    this.parmTaxProfileMap(map);
                }
            }
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    private static ClassDescription description()
    {
        return "@SYS23177";
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTaxProfileMap_CN</Name>
				<Source><![CDATA[
    private static Map getTaxProfileMap_CN(SalesFormLetter_Invoice _salesFormLetter)
    {
        Map taxProfileMap = new Map(Types::Container, Types::Container);

        taxProfileMap = _salesFormLetter.parmTaxProfileMap();
        if (taxProfileMap)
        {
            Set postJournalSet = Set::create(_salesFormLetter.getOutputContract().parmAllJournalsPacked());
            SetEnumerator postJournalSetEnumerator = postJournalSet.getEnumerator();

            while (postJournalSetEnumerator.moveNext())
            {
                CustInvoiceJour postedCustInvoiceJour = postJournalSetEnumerator.current();

                container currentKeyCon = [postedCustInvoiceJour.SalesId, postedCustInvoiceJour.ParmId];
                // get value form taxProfileMap
                if (!taxProfileMap.empty() && taxProfileMap.exists(currentKeyCon))
                {
                    container currentValueCon = taxProfileMap.lookup(currentKeyCon);
                    currentValueCon = conIns(currentValueCon, 2, postedCustInvoiceJour.RecId);
                    taxProfileMap.insert(currentKeyCon, currentValueCon);
                }
            }
        }
        return taxProfileMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newInvoice</Name>
				<Source><![CDATA[
    [SysObsolete('Use SalesFormLetter::construct() instead.', false, 30\6\2020)]
    static public SalesFormLetter_Invoice newInvoice(
        IdentifierName _className = classStr(FormletterService),
        IdentifierName _methodName = methodStr(FormletterService, postSalesOrderInvoice),
        SysOperationExecutionMode _executionMode = SysOperationExecutionMode::Synchronous)
    {
        return SalesFormLetter::construct(DocumentStatus::Invoice, _className, _methodName, _executionMode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return this.checkRunInNewSession() && !this.salesTable().isInterCompanyOrder();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunAsRealAsync</Name>
				<Source><![CDATA[
    public boolean canRunAsRealAsync()
    {
        return SalesFormLetterInvoiceRealAsyncFlight::instance().isEnabled()
            && !this.proforma();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getSysRealAsyncOperationId</Name>
				<Source><![CDATA[
    public SysRealAsyncOperationId getSysRealAsyncOperationId()
    {
        Common sourceTable = this.parmSourceTable();
        str operationId;

        if (sourceTable && sourceTable is SalesTable)
        {
            SalesTable salesTable = sourceTable;
            operationId = salesTable.SalesId;
        }
        else
        {
            operationId = this.parmId();
        }

        return operationId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShowDialog</Name>
				<Source><![CDATA[
    public boolean parmShowDialog(boolean _showDialog = showDialog)
    {
        return super(_showDialog);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDeferredJournalPost</Name>
				<Source><![CDATA[
    [Hookable(false),
     SysObsolete('Method is obsoleted to support fast print feature. Please file an extensibility request if other access is required.', false, 25\5\2023)]
    protected boolean isDeferredJournalPost()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRetryable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if the batch task is retryable for transient exceptions or not.
    /// </summary>
    /// <returns>
    /// If true is returned, the batch task is retryable, otherwise it is not.
    /// </returns>
    [Hookable(false)]
    public boolean isRetryable() 
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>errorMessageHelpScopeShowLink</Name>
				<Source><![CDATA[
    [Hookable(false)]
    public boolean errorMessageHelpScopeShowLink()
    {
        if (SalesFormLetterErrorMessageHelpScopeInvoiceFlight::instance().isEnabled())
        {
            return super();
        }

        return false;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>