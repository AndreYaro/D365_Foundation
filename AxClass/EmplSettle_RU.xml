<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>EmplSettle_RU</Name>
	<SourceCode>
		<Declaration><![CDATA[
class EmplSettle_RU
{
    ToDate                      toDate;
    EmplTrans_RU                transDebit, transCredit;

    QueryRun                    queryRunDebit, queryRunCredit, queryRunInnerCredit;
    Query                       queryDebit, queryCredit, queryInnerCredit;
    TransDate                   queryCreditLastTransDate;
    int                         queryCreditState;

    EmplSettlement_RU           transSettle;
    EmplTrans_RU                exchAdjUnrealizedTrans;
    LedgerVoucher               ledgerVoucher;
    LedgerVoucherObject         ledgerVoucherObject;
    Voucher                     voucher;
    CurrencyCode                accountingCurrency;
    RefRecId                    tmpRecId;
    boolean                     profileSettlement;
    ManualCreated_RU            manualCreated;

    Set                         exchAdjCrossAccountSet;

    EmplExchAdjustmentCalc_RU   emplExchAdjustment;
    DimSettlementCtrlType_RU    dimSettlementCtrlType;

    EmplVoucher_RU              emplVoucher;
    RTax25ExchAdjDimension      exchAdjDimension;
    boolean                     skipAdvanceTableUpdate;

    #define.CreditStateNone(0)
    #define.CreditStateAOSelected(1)
    #define.CreditStateEmptySelected(2)
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>buildQueries</Name>
				<Source><![CDATA[
    public void buildQueries()
    {
        QueryBuildDataSource    qbds;

        queryDebit = new Query();
        qbds = queryDebit.addDataSource(tableNum(EmplTrans_RU));
        qbds.update(true);
        qbds.orderMode(OrderMode::OrderBy);
        qbds.addSortField(fieldNum(EmplTrans_RU, TransDate));

        qbds.addSortField(fieldNum(EmplTrans_RU, SettleAmountCur), SortOrder::Descending);

        qbds.addRange(fieldNum(EmplTrans_RU, EmplAccount));
        qbds.addRange(fieldNum(EmplTrans_RU, PostingProfile));

        qbds.addRange(fieldNum(EmplTrans_RU, Closed)).value(SysQuery::valueEmptyString());
        qbds.addRange(fieldNum(EmplTrans_RU, TransDate)).value(queryRange(dateNull(), toDate));
        qbds.addRange(fieldNum(EmplTrans_RU, AmountCur)).value('0..');
        qbds.addRange(fieldNum(EmplTrans_RU, Reversed)).value(queryValue(NoYes::No));
        qbds.addRange(fieldNum(EmplTrans_RU, TransType)).value(SysQuery::valueNot(queryValue(EmplTransSourceType_RU::CrossAccountSettle)));

        queryCredit = new Query();
        qbds = queryCredit.addDataSource(tableNum(EmplTrans_RU));

        qbds.orderMode(OrderMode::GroupBy);
        qbds.addSortField(fieldNum(EmplTrans_RU, TransDate), SortOrder::Ascending);
        qbds.addSortField(fieldNum(EmplTrans_RU, AdvanceId), SortOrder::Descending);

        qbds.addRange(fieldNum(EmplTrans_RU, EmplAccount));
        qbds.addRange(fieldNum(EmplTrans_RU, PostingProfile));
        qbds.addRange(fieldNum(EmplTrans_RU, Closed)).value(SysQuery::valueEmptyString());
        qbds.addRange(fieldNum(EmplTrans_RU, TransDate)).value(queryRange(dateNull(), toDate));
        qbds.addRange(fieldNum(EmplTrans_RU, AmountCur)).value('..0');
        qbds.addRange(fieldNum(EmplTrans_RU, Reversed)).value(queryValue(NoYes::No));
        qbds.addRange(fieldNum(EmplTrans_RU, TransType)).value(SysQuery::valueNot(queryValue(EmplTransSourceType_RU::CrossAccountSettle)));

        queryInnerCredit = new Query(queryCredit);
        qbds = queryInnerCredit.dataSourceTable(tableNum(EmplTrans_RU));
        qbds.update(true);
        qbds.orderMode(OrderMode::OrderBy);
        qbds.sortClear();
        qbds.addSortField(fieldNum(EmplTrans_RU, AdvanceId), SortOrder::Ascending);

        qbds.addRange(fieldNum(EmplTrans_RU, AdvanceId));
        qbds.addRange(fieldNum(EmplTrans_RU, TransType)).value(SysQuery::valueNot(queryValue(EmplTransSourceType_RU::CrossAccountSettle)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>check</Name>
				<Source><![CDATA[
    protected boolean check()
    {
        boolean ret = true;

        if (! this.checkDimension())
        {
            ret = checkFailed("@GLS113716");
        }

        RefRecId calendarRecId = Ledger::fiscalCalendar(CompanyInfo::current());

        if (!LedgerFiscalCalendar::checkModuleIsOpen(
            SysModule::Purch,
            transDebit.TransDate,
            LedgerFiscalCalendar::findPeriodByPeriodCodeDate(
                calendarRecId,
                transDebit.TransDate,
                FiscalPeriodType::Operating)))
        {
            ret = false;
        }

        if (!LedgerFiscalCalendar::checkModuleIsOpen(
            SysModule::Purch,
            transCredit.TransDate,
            LedgerFiscalCalendar::findPeriodByPeriodCodeDate(
                calendarRecId,
                transCredit.TransDate,
                FiscalPeriodType::Operating)))
        {
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkDimension</Name>
				<Source><![CDATA[
    protected boolean checkDimension()
    {
        if (this.fetchWithCheckDimension())
        {
            return true;
        }

        return this.checkTransDimension();
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransDimension</Name>
				<Source><![CDATA[
    private boolean checkTransDimension(boolean _showMessage = true)
    {
        DimensionAttributeValueSetStorage  emplTransDimStorage,
                                           emplOffsetTransDimStorage;

        boolean failMessage(EmplTrans_RU    _emplTrans,
                            Name            _dimensionAttrName)
        {
            if (! _showMessage)
            {
                return false;
            }

            return checkFailed(strFmt("@GLS113717", _emplTrans.EmplAccount, _dimensionAttrName));
        }

        boolean checkTransDimension(EmplTrans_RU   _emplTrans,
                                    EmplTrans_RU   _emplTransOffset)
        {
            boolean         ret = true;

            EmplLedger_RU   emplLedger;
            Set             dimAttrNames;
            RecId           dimAttrRecId;
            Name            dimAttrName;

            SetEnumerator   setEnumerator;
            ;

            emplLedger   = EmplLedger_RU::find(_emplTrans.PostingProfile);
            dimAttrNames = EmplLedgerAccounts_RU::dimensionAttrNamesForCheck(_emplTrans.EmplAccount, _emplTrans.PostingProfile);

            if (dimAttrNames.elements())
            {
                emplTransDimStorage       = DimensionAttributeValueSetStorage::find(
                    LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_emplTrans.LedgerDimension));
                emplOffsetTransDimStorage = DimensionAttributeValueSetStorage::find(
                    LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_emplTransOffset.LedgerDimension));

                setEnumerator = dimAttrNames.getEnumerator();

                while (setEnumerator.moveNext())
                {
                    dimAttrName  = setEnumerator.current();
                    dimAttrRecId = DimensionAttribute::findByName(dimAttrName).RecId;

                    if (emplTransDimStorage.getValueByDimensionAttribute(dimAttrRecId) !=
                        emplOffsetTransDimStorage.getValueByDimensionAttribute(dimAttrRecId))
                    {
                        if (!emplTransDimStorage.getValueByDimensionAttribute(dimAttrRecId) ||
                            !emplOffsetTransDimStorage.getValueByDimensionAttribute(dimAttrRecId))
                        {
                            switch (emplLedger.DimSettlementCtrlType)
                            {
                                case DimSettlementCtrlType_RU::None:
                                    ret = failMessage(_emplTrans, dimAttrName);
                                    break;

                                case DimSettlementCtrlType_RU::Manual:
                                    if (this.dimSettlementType() == DimSettlementType_RU::Auto)
                                    {
                                        ret = failMessage(_emplTrans, dimAttrName);
                                    }
                                    break;

                                case DimSettlementCtrlType_RU::Auto:
                                    if (this.dimSettlementType() == DimSettlementType_RU::Manual)
                                    {
                                        ret = failMessage(_emplTrans, dimAttrName);
                                    }
                                    break;
                            }
                        }
                        else
                        {
                            ret = failMessage(_emplTrans, dimAttrName);
                        }
                    }
                }
            }

            return ret;
        }
        ;

        if (this.dimSettlementType() == DimSettlementType_RU::None                                                               ||
            dimSettlementCtrlType    == DimSettlementCtrlType_RU::None                                                           ||
           (this.dimSettlementType() == DimSettlementType_RU::Manual && dimSettlementCtrlType == DimSettlementCtrlType_RU::Auto) ||
           (this.dimSettlementType() == DimSettlementType_RU::Auto   && dimSettlementCtrlType == DimSettlementCtrlType_RU::Manual))
        {
            return true;
        }

        return (checkTransDimension(transDebit, transCredit) &&
                checkTransDimension(transCredit, transDebit));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createVoucherTrans</Name>
				<Source><![CDATA[
    protected LedgerVoucherObject createVoucherTrans(TransDate         _transDate,
                                                     LedgerTransTxt    _ledgerTransTxt)
    {
        TransactionTxt      transactionTxt;

        if (ledgerVoucherObject && voucher)
            return ledgerVoucherObject;

        if (! ledgerVoucher)
        {
            ledgerVoucher = LedgerVoucher::newLedgerPost(DetailSummary::Summary,
                                                         SysModule::Employee_RU,
                                                         EmplParameters_RU::numRefEmplPaymentVoucher().numberSequenceTable().NumberSequence);
        }

        if (! voucher)
        {
            voucher = NumberSeq::newGetVoucher(EmplParameters_RU::numRefEmplPaymentVoucher()).voucher();
        }

        transactionTxt = TransactionTxt::construct(_ledgerTransTxt,
                                            CompanyInfo::languageId(),
                                            _transDate,
                                            "",
                                            voucher,
                                            transDebit.EmplAccount);

        ledgerVoucherObject = ledgerVoucher.findLedgerVoucherObject(voucher, _transDate);

        if (! ledgerVoucherObject)
        {
            ledgerVoucherObject = LedgerVoucherObject::newVoucher(voucher, _transDate);
            ledgerVoucher.addVoucher(ledgerVoucherObject);
        }
        ledgerVoucherObject.lastTransTxt(transactionTxt.txt());

        return ledgerVoucherObject;
    }

]]></Source>
			</Method>
			<Method>
				<Name>crossRate</Name>
				<Source><![CDATA[
    private ExchRate crossRate(EmplTrans_RU _emplTransCredit,
                               EmplTrans_RU _emplTransDebit)
    {
        EmplTrans_RU earlyEmplTrans, lateEmplTrans;
        ExchRate     exchRate, secondaryExchRate;

        if (_emplTransDebit.CurrencyCode == _emplTransCredit.CurrencyCode)
        {
            return 1;
        }

        if (_emplTransCredit.TransDate <= _emplTransDebit.TransDate || emplExchAdjustment.isAdvanceAdjustment(transDebit, transCredit))
        {
            earlyEmplTrans = _emplTransCredit;
            lateEmplTrans  = _emplTransDebit;
        }
        else
        {
            earlyEmplTrans = _emplTransDebit;
            lateEmplTrans  = _emplTransCredit;
        }

        if (earlyEmplTrans.CurrencyCode == accountingCurrency)
        {
            exchRate = ExchangeRateHelper::exchRate(earlyEmplTrans.CurrencyCode, earlyEmplTrans.TransDate);
        }
        else
        {
            exchRate = ExchangeRateHelper::exchRate(earlyEmplTrans.CurrencyCode, lateEmplTrans.TransDate);
        }

        if (Currency::euroTriangulation(earlyEmplTrans.CurrencyCode, lateEmplTrans.TransDate) ||
            Currency::euroTriangulation(Ledger::accountingCurrency(CompanyInfo::current()), lateEmplTrans.TransDate))
        {
            if (earlyEmplTrans.CurrencyCode == accountingCurrency)
            {
                secondaryExchRate = ExchangeRateHelper::exchRateSecond(earlyEmplTrans.CurrencyCode, earlyEmplTrans.TransDate, Currency::noYes2UnknownNoYes(NoYes::Yes));
            }
            else
            {
                secondaryExchRate = ExchangeRateHelper::exchRateSecond(earlyEmplTrans.CurrencyCode, lateEmplTrans.TransDate, Currency::noYes2UnknownNoYes(NoYes::Yes));
            }

            exchRate = secondaryExchRate / exchRate * 100;
        }

        exchRate = exchRate / 100;

        if (exchRate)
        {
            if (_emplTransCredit.TransDate <= _emplTransDebit.TransDate || emplExchAdjustment.isAdvanceAdjustment(transDebit, transCredit))
            {
                exchRate = exchRate / (lateEmplTrans.AmountMST / lateEmplTrans.AmountCur) ;
            }
            else
            {
                exchRate = lateEmplTrans.AmountMST / lateEmplTrans.AmountCur /exchRate ;
            }
        }
        else
        {
            exchRate  = 1;
        }

        return exchRate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>dimSettlementType</Name>
				<Source><![CDATA[
    protected DimSettlementType_RU dimSettlementType()
    {
        return DimSettlementType_RU::Auto;
    }

]]></Source>
			</Method>
			<Method>
				<Name>endVoucherTrans</Name>
				<Source><![CDATA[
    protected void endVoucherTrans()
    {
        voucher = "";
    }

]]></Source>
			</Method>
			<Method>
				<Name>exchAdjUnrealizedTrans</Name>
				<Source><![CDATA[
    public EmplTrans_RU exchAdjUnrealizedTrans()
    {
        select exchAdjUnrealizedTrans;

        return exchAdjUnrealizedTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchNextCredit</Name>
				<Source><![CDATA[
    private void fetchNextCredit()
    {
        QueryBuildDataSource qbds;

        queryRunInnerCredit.next();
        transCredit = queryRunInnerCredit.get(tableNum(EmplTrans_RU));

        if (transCredit)
            return;

        qbds = queryRunInnerCredit.query().dataSourceTable(tableNum(EmplTrans_RU));

        while (queryRunCredit.next())
        {
            transCredit = queryRunCredit.get(tableNum(EmplTrans_RU));
            if (transCredit.TransDate != queryCreditLastTransDate)
            {
                queryCreditLastTransDate = transCredit.TransDate;
                queryCreditState = #CreditStateNone;
            }

            if (! transCredit.AdvanceId)
            {
                queryCreditState = #CreditStateEmptySelected;
            }
            if (queryCreditState == #CreditStateAOSelected)
                continue;

            qbds.findRange(fieldNum(EmplTrans_RU, TransDate)).value(queryValue(queryCreditLastTransDate));
            if (transCredit.AdvanceId)
            {
                qbds.findRange(fieldNum(EmplTrans_RU, AdvanceId)).value(SysQuery::valueNotEmptyString());
                queryCreditState = #CreditStateAOSelected;
            }
            else
            {
                qbds.findRange(fieldNum(EmplTrans_RU, AdvanceId)).value(SysQuery::valueEmptyString());
            }
            queryRunInnerCredit.reset();
            queryRunInnerCredit.next();
            transCredit = queryRunInnerCredit.get(tableNum(EmplTrans_RU));
            break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchNextDebit</Name>
				<Source><![CDATA[
    private void fetchNextDebit()
    {
        queryRunDebit.next();
        transDebit = queryRunDebit.get(tableNum(EmplTrans_RU));
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchNextDebitCheckDimension</Name>
				<Source><![CDATA[
    private void fetchNextDebitCheckDimension(Map _debitSettledAmounts)
    {
        queryRunDebit = new QueryRun(queryRunDebit.query());

        while (queryRunDebit.next())
        {
            transDebit = queryRunDebit.get(tableNum(EmplTrans_RU));

            if (!this.updateTables() && _debitSettledAmounts.exists(transDebit.RecId))
            {
                transDebit.SettleAmountCur += _debitSettledAmounts.lookup(transDebit.RecId);
            }

            if (transDebit.AmountCur - transDebit.SettleAmountCur != 0)
            {
                if (this.checkTransDimension(false))
                {
                    return;
                }
            }
        }

        transDebit = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>fetchWithCheckDimension</Name>
				<Source><![CDATA[
    private boolean fetchWithCheckDimension()
    {
        return this.dimSettlementType() == DimSettlementType_RU::Auto &&
               (dimSettlementCtrlType == DimSettlementCtrlType_RU::Always ||
                dimSettlementCtrlType == DimSettlementCtrlType_RU::Auto);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDistributions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns enumerator of distributions that were created.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmplTrans_RU</c> record which is the distributed transaction.
    /// </param>
    /// <param name="_defaultLedgerDimension">
    /// The <c>LedgerDimensionAccount</c> to distribute the amounts to when the original distributions cannot be identified.
    /// </param>
    /// <param name="_defaultDimension">
    /// The ID of the provides the default value for the ledger dimension.
    /// </param>
    /// <param name="_accountingAmount">
    /// The amount to distribute in the accounting currency.
    /// </param>
    /// <param name="_reportingAmount">
    /// The amount to distribute in the reporting currency.
    /// </param>
    /// <returns>
    /// A <c>Enumerator</c> of a list containing the collection of <c>CustVendTransDistribution</c> instances that were created.
    /// </returns>
    protected Enumerator getDistributions(EmplTrans_RU _emplTrans, LedgerDimensionAccount _defaultLedgerDimension,  DimensionDefault _defaultDimension, Amount _accountingAmount, Amount _reportingAmount)
    {
        CustVendTransExchAdjDistController_RU   controller          = CustVendTransExchAdjDistController_RU::construct();
        controller.parmDefaultOffsetLedgerDimension(
            LedgerDimensionFacade::serviceCreateLedgerDimension(exchAdjDimension.getLedgerDimension(), _defaultDimension));
        controller.ledgerDimensionObtained += eventhandler(this.ledgerDimensionObtainedEventHandler);
        return controller.generateDistributions(
            this.getVirtualCustVendTrans(_emplTrans),
            LedgerPostingType::EmplBalance_RU,
            _accountingAmount,
            _accountingAmount,
            _reportingAmount,
            _defaultLedgerDimension).getEnumerator();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTransForDistributionController</Name>
				<Source><![CDATA[
    /// <summary>
    /// Searches for <c>CustVendTrans</c> cursor for distribution controller.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmplTrans_RU</c> record which is the distributed transaction.
    /// </param>
    /// <returns>
    /// <c>VendTrans</c> record
    /// </returns>
    protected CustVendTrans getTransForDistributionController(EmplTrans_RU _emplTrans)
    {
        if (_emplTrans.RefTableId == tableNum(VendTrans))
        {
            return VendTrans::find(_emplTrans.RefRecId);
        }
        else
        {
            return this.getVirtualCustVendTrans(_emplTrans);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getVirtualCustVendTrans</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates virtual VendTrans cursor.
    /// </summary>
    /// <param name="_emplTrans">
    /// <c>EmplTrans_RU</c> which is the source for advance report line.
    /// </param>
    /// <returns>
    /// Virtual <c>CustVendTrans</c> record.
    /// </returns>
    protected CustVendTrans getVirtualCustVendTrans(EmplTrans_RU _emplTrans)
    {
        EmplAdvLine_RU                          emplAdvLine         = EmplAdvLine_RU::findTransEmplRecId(_emplTrans.RecId, true);
        SourceDocumentLine                      sourceDocumentLine  = SourceDocumentLine::find(emplAdvLine.SourceDocumentLine);
        AccountingEvent                         accountingEvent     = AccountingDistribution::getLastSourceDocumentLineEvent(sourceDocumentLine.RecId);
        VendTrans ret;
        ret.CurrencyCode    = _emplTrans.CurrencyCode;
        ret.AccountingEvent = accountingEvent.RecId;
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initSettleTrans</Name>
				<Source><![CDATA[
    public void initSettleTrans()
    {
        transSettle.setTmp();
        exchAdjUnrealizedTrans.setTmp();
    }

]]></Source>
			</Method>
			<Method>
				<Name>ledgerDimensionObtainedEventHandler</Name>
				<Source><![CDATA[
    /// <summary>
    ///   Overrides account to profitLoss if _isOffset, dimension to RTax25
    /// </summary>
    /// <param name="_isOffset">
    ///  is the LedgerDimensionAccount refers to offset
    /// </param>
    /// <param name="_anyType">
    ///    reference to LedgerDimensionAcount
    /// </param>
    public void ledgerDimensionObtainedEventHandler(boolean _isOffset, SysAnyType _anyType)
    {
        LedgerDimensionAccount          ledgerDimension         = _anyType.value();
        DimensionDefault                ledgerDefaultDimension;
        LedgerDimensionDefaultAccount   defaultAccount          = _isOffset ? exchAdjDimension.getLedgerDimension() :
                                                                              LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(ledgerDimension);
        ledgerDefaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(ledgerDimension);
        ledgerDefaultDimension = exchAdjDimension.getDefaultDimension(ledgerDefaultDimension);
        _anyType.value(LedgerDimensionFacade::serviceCreateLedgerDimension(defaultAccount, ledgerDefaultDimension));
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new(ToDate _toDate)
    {
        EmplParameters_RU emplParameters = EmplParameters_RU::find();

        toDate                = _toDate;
        accountingCurrency    = Ledger::accountingCurrency();

        profileSettlement     = emplParameters.ProfileSettlement;
        dimSettlementCtrlType = emplParameters.DimSettlementCtrlType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmEmplVoucher</Name>
				<Source><![CDATA[
    public EmplVoucher_RU parmEmplVoucher(EmplVoucher_RU _emplVoucher = emplVoucher)
    {
        emplVoucher = _emplVoucher;

        return emplVoucher;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmProfileSettlement</Name>
				<Source><![CDATA[
    public NoYesId parmProfileSettlement(NoYesId _profileSettlement = profileSettlement)
    {
        profileSettlement = _profileSettlement;

        return profileSettlement;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipAdvanceTableUpdate</Name>
				<Source><![CDATA[
    public boolean parmSkipAdvanceTableUpdate(boolean _value = skipAdvanceTableUpdate)
    {
        skipAdvanceTableUpdate = _value;
        return skipAdvanceTableUpdate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postCrossAccount</Name>
				<Source><![CDATA[
    private void postCrossAccount(AmountCur          _amountCurDebit,
                                  AmountCur          _amountCurCredit,
                                  AmountMST          _accountingAmount,
                                  AmountMSTSecondary _reportingAmount,
                                  TransDate          _transDate)
    {
        LedgerBondClient_RU         ledgerBondClient;
        CurrencyCode                baseCurrency;
        AmountCur                   amountCurDebit     = _amountCurDebit;
        AmountCur                   amountCurCredit    = _amountCurCredit;
        AmountMST                   lastAmountMST;
        AmountMSTSecondary          lastAmountMSTSecondary;

        EmplTrans_RU                distributedTrans;
        Enumerator                  i;
        CustVendTransDistribution   distribution;

        LedgerVoucherTransObject            ledgerVoucherTransObject;
        CustVendTransDistributionController distributionController = CustVendTransDistributionController::construct();

        void createEmplTrans(EmplTrans_RU _trans, AmountCur _lastAmountCur, AmountMST _lastAmountMST, AmountMSTSecondary _lastAmountMSTSecondary)
        {
            EmplTrans_RU trans;

            trans.data(_trans);

            trans.Txt                       = ledgerVoucher.findLedgerVoucherObject().lastTransTxt();
            trans.Voucher                   = ledgerVoucher.lastVoucher();
            trans.TransDate                 = ledgerVoucher.lastTransDate();
            trans.AmountCur                 = _lastAmountCur;
            trans.AmountMST                 = _lastAmountMST;
            trans.ReportingCurrencyAmount   = _lastAmountMSTSecondary;
            trans.CurrencyCode              = baseCurrency;
            trans.AdvanceId                 = "";
            trans.Closed                    = trans.TransDate;
            trans.TransType                 = EmplTransSourceType_RU::CrossAccountSettle;
            trans.SettleAmountCur           = trans.AmountCur;
            trans.SettleAmountMST           = trans.AmountMST;
            trans.ReportingSettleAmount     = trans.ReportingCurrencyAmount;
            trans.insert();

            exchAdjCrossAccountSet.add(trans.RecId);
        }

        if (! (amountCurCredit && amountCurDebit) || ! this.updateTables())
        {
            return;
        }

        if (transCredit.CurrencyCode != transDebit.CurrencyCode)
        {
            amountCurCredit = - _accountingAmount;
            amountCurDebit  = - amountCurCredit;
            baseCurrency    = accountingCurrency;
        }
        else
        {
            baseCurrency     = transDebit.CurrencyCode;
        }

        this.createVoucherTrans(_transDate, LedgerTransTxt::LedgerClosing);

        ledgerBondClient = ledgerVoucherObject.ledgerBondClient_RU();

        distributedTrans = (transDebit.AdvanceId || transDebit.RefTableId == tableNum(VendTrans)) ? transDebit : transCredit;
        i = distributionController.generateDistributions(
            this.getTransForDistributionController(distributedTrans),
            LedgerPostingType::EmplBalance_RU,
            - amountCurCredit,
            - abs(_accountingAmount) * sign(amountCurCredit),
            - abs(_reportingAmount) * sign(amountCurCredit),
            distributedTrans.LedgerDimension).getEnumerator();

        while (i.moveNext())
        {
            distribution = i.current();
            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                 LedgerPostingType::EmplBalance_RU,
                                                                                 distributedTrans.RecId == transCredit.RecId ?
                                                                                    distribution.ledgerDimension() :
                                                                                    transCredit.LedgerDimension,
                                                                                 baseCurrency,
                                                                                 distribution.transactionAmount(),
                                                                                 distribution.accountingAmount(),
                                                                                 distribution.reportingAmount());

            ledgerVoucherTransObject.parmSourceTableId(transCredit.TableId);
            ledgerVoucherTransObject.parmSourceRecId(transCredit.RecId);
            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);
            lastAmountMST           += ledgerVoucher.lastAmountMST();
            lastAmountMSTSecondary  += ledgerVoucher.findLedgerVoucherObject().lastAmountMSTSecondary_RU();

            ledgerVoucherTransObject = LedgerVoucherTransObject::newBasicDefault(ledgerVoucher.findLedgerVoucherObject(),
                                                                                             LedgerPostingType::EmplBalance_RU,
                                                                                             distributedTrans.RecId == transDebit.RecId ?
                                                                                                distribution.ledgerDimension() :
                                                                                                transDebit.LedgerDimension,
                                                                                             baseCurrency,
                                                                                             - distribution.transactionAmount(),
                                                                                             - distribution.accountingAmount(),
                                                                                             - distribution.reportingAmount());

            ledgerVoucherTransObject.parmSourceTableId(transDebit.TableId);
            ledgerVoucherTransObject.parmSourceRecId(transDebit.RecId);
            ledgerVoucherObject.addTrans(ledgerVoucherTransObject);

            if (ledgerBondClient)
            {
                ledgerBondClient.bondLast2();
            }
        }
        createEmplTrans(transCredit,    - amountCurCredit, lastAmountMST, lastAmountMSTSecondary);
        createEmplTrans(transDebit,     - amountCurDebit,  -lastAmountMST, -lastAmountMSTSecondary);
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExchAdjTrans</Name>
				<Source><![CDATA[
    private void postExchAdjTrans(EmplTrans_RU              _mainEmplTrans,
                                  AmountMSTExchAdjustment   _accountingExchAdjAmount,
                                  AmountMSTSecondary        _reportingExchAdjAmount,
                                  TransDate                 _transDate,
                                  DimensionDefault          _defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_mainEmplTrans.LedgerDimension))
    {
        EmplTrans_RU                exchAdjTrans;
        LedgerBondClient_RU         ledgerBondClient;
        EmplTrans_RU                tmpDebitTrans,
                                    tmpCreditTrans;
        DimensionDefault            defaultDimension          = _defaultDimension ? _defaultDimension : LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(_mainEmplTrans.LedgerDimension);
        DimensionDefault            reportingDefaultDimension = defaultDimension;

        CustVendExchAdjParm_W       emplExchAdjParm = CustVendExchAdjParm_W::newFromParmEmpl(_mainEmplTrans, false, false, LedgerTransType::ExchAdjustment);

        Enumerator                              e;
        CustVendTransCorrespondentDistribution  distribution;

        exchAdjDimension = emplExchAdjParm.rTax25ExchAdjDimension();

        exchAdjDimension.setLedgerDimensions(emplExchAdjParm.ledgerDimension(LedgerPostingType::ExchRateGain),
                                             emplExchAdjParm.ledgerDimension(LedgerPostingType::ExchRateLoss));

        exchAdjDimension.parmExchAdjType(_reportingExchAdjAmount < 0 ? RTax25ExchAdjType::Loss : RTax25ExchAdjType::Gain);
        reportingDefaultDimension = exchAdjDimension.getDefaultDimension(reportingDefaultDimension);

        if (_accountingExchAdjAmount < 0    ||
            (_accountingExchAdjAmount == 0  &&
             _reportingExchAdjAmount < 0))
        {
            tmpDebitTrans       = _mainEmplTrans;
            tmpCreditTrans      = exchAdjTrans;
            exchAdjDimension.parmExchAdjType(RTax25ExchAdjType::Loss);
        }
        else
        {
            tmpDebitTrans       = exchAdjTrans;
            tmpCreditTrans      = _mainEmplTrans;
            exchAdjDimension.parmExchAdjType(RTax25ExchAdjType::Gain);
        }

        defaultDimension = exchAdjDimension.getDefaultDimension(defaultDimension);

        exchAdjTrans.EmplAccount                     = _mainEmplTrans.EmplAccount;
        exchAdjTrans.CurrencyCode                    = _mainEmplTrans.CurrencyCode;
        exchAdjTrans.TransDate                       = _transDate;
        exchAdjTrans.AmountCur                       = 0.0;
        exchAdjTrans.AmountMST                       = _accountingExchAdjAmount;
        exchAdjTrans.ReportingCurrencyAmount         = _reportingExchAdjAmount;
        exchAdjTrans.ExchAdjustmentRealized          = - _accountingExchAdjAmount;
        exchAdjTrans.ReportingExchAdjustmentRealized = - _reportingExchAdjAmount;
        exchAdjTrans.ExchAdjustment                  = - _accountingExchAdjAmount;
        exchAdjTrans.ReportingExchAdjustment         = - _reportingExchAdjAmount;
        exchAdjTrans.PostingProfile                  = _mainEmplTrans.PostingProfile;
        exchAdjTrans.Txt                             = ledgerVoucher ? ledgerVoucher.findLedgerVoucherObject().lastTransTxt() : "";
        exchAdjTrans.TransType                       = EmplTransSourceType_RU::ExchAdj;
        exchAdjTrans.LedgerDimension                 = LedgerDimensionFacade::serviceCreateLedgerDimension(LedgerDefaultAccountHelper::getDefaultAccountFromLedgerDimension(_mainEmplTrans.LedgerDimension), defaultDimension);
        exchAdjTrans.ReportingDefaultDimension       = reportingDefaultDimension;

        if (this.updateTables())
        {
            ledgerVoucherObject  = this.createVoucherTrans(_transDate, LedgerTransTxt::LedgerExchAdj);
            ledgerVoucherObject.parmLedgerTransType(LedgerTransType::ExchAdjustment);

            exchAdjTrans.Voucher = ledgerVoucherObject.parmVoucher();

            ledgerBondClient    = ledgerVoucherObject.ledgerBondClient_RU();
            if (_accountingExchAdjAmount)
            {
                exchAdjDimension.parmExchAdjType(_accountingExchAdjAmount < 0 ? RTax25ExchAdjType::Loss : RTax25ExchAdjType::Gain);

                e = this.getDistributions(_mainEmplTrans, exchAdjTrans.LedgerDimension, defaultDimension, _accountingExchAdjAmount, 0);
                while (e.moveNext())
                {
                    distribution = e.current();

                    ledgerVoucherObject.addTrans(
                        LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucherObject,
                                                                    LedgerPostingType::EmplBalance_RU,
                                                                    distribution.ledgerDimension(),
                                                                    _mainEmplTrans.CurrencyCode,
                                                                    distribution.accountingAmount()));
                    ledgerVoucherObject.addTrans(
                        LedgerVoucherTransObject::newBasicMST_RU(ledgerVoucherObject,
                                                                    exchAdjDimension.getPostingType(),
                                                                    distribution.offsetLedgerDimension(),
                                                                    _mainEmplTrans.CurrencyCode,
                                                                    - distribution.accountingAmount()));
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                }
            }

            if (_reportingExchAdjAmount)
            {
                exchAdjDimension.parmExchAdjType(_reportingExchAdjAmount < 0 ? RTax25ExchAdjType::Loss : RTax25ExchAdjType::Gain);

                e = this.getDistributions(_mainEmplTrans, exchAdjTrans.LedgerDimension, reportingDefaultDimension, 0, _reportingExchAdjAmount);
                while (e.moveNext())
                {
                    distribution = e.current();
                    ledgerVoucherObject.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU( ledgerVoucherObject,
                                                                        LedgerPostingType::EmplBalance_RU,
                                                                        distribution.ledgerDimension(),
                                                                        _mainEmplTrans.CurrencyCode,
                                                                        distribution.reportingAmount()));
                    ledgerVoucherObject.addTrans(
                        LedgerVoucherTransObject::newBasicSecondary_RU( ledgerVoucherObject,
                                                                        exchAdjDimension.getPostingType(),
                                                                        distribution.offsetLedgerDimension(),
                                                                        _mainEmplTrans.CurrencyCode,
                                                                        - distribution.reportingAmount()));
                    if (ledgerBondClient)
                    {
                        ledgerBondClient.bondLast2();
                    }
                }
            }

            exchAdjTrans.insert();

            exchAdjCrossAccountSet.add(exchAdjTrans.RecId);

            _mainEmplTrans.ExchAdjustment                  += _accountingExchAdjAmount;
            _mainEmplTrans.ReportingExchAdjustment         += _reportingExchAdjAmount;
            _mainEmplTrans.ExchAdjustmentRealized          += _accountingExchAdjAmount;
            _mainEmplTrans.ReportingExchAdjustmentRealized += _reportingExchAdjAmount;
            _mainEmplTrans.update();
        }

        if (! tmpDebitTrans.RecId)
        {
            tmpRecId++;
            tmpDebitTrans.RecId = tmpRecId;
        }

        if (! tmpCreditTrans.RecId)
        {
            tmpRecId++;
            tmpCreditTrans.RecId = tmpRecId;
        }

        this.updateTransactions(tmpDebitTrans,
                                tmpCreditTrans,
                                0,
                                0,
                                abs(_accountingExchAdjAmount),
                                abs(_reportingExchAdjAmount),
                                0,
                                0,
                                _transDate);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setEmplQueries</Name>
				<Source><![CDATA[
    private void setEmplQueries(EmplAccount_RU  _emplAccount,
                                PostingProfile  _postingProfile = '')
    {
        QueryRun newEmplQueryRun(Query _query)
        {
            _query.dataSourceTable(tableNum(EmplTrans_RU)).findRange(
                fieldNum(EmplTrans_RU, EmplAccount)).value(_emplAccount);

            if (_postingProfile)
            {
                _query.dataSourceTable(tableNum(EmplTrans_RU)).findRange(
                    fieldNum(EmplTrans_RU, PostingProfile)).value(_postingProfile);
            }

            return new QueryRun(_query);
        }

        queryRunDebit   = newEmplQueryRun(queryDebit);
        queryRunCredit  = newEmplQueryRun(queryCredit);

        queryCreditLastTransDate = dateNull();
        queryCreditState = #CreditStateNone;
        queryInnerCredit.dataSourceTable(tableNum(EmplTrans_RU)).findRange(
                fieldNum(EmplTrans_RU, TransDate)).value(queryValue(dateNull()));
        queryRunInnerCredit = newEmplQueryRun(queryInnerCredit);

        transDebit      = null;
        transCredit     = null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleEmployee</Name>
				<Source><![CDATA[
    public void settleEmployee(EmplAccount_RU  _emplAccount)
    {
        AmountCur               settleDebitCur, settleCreditCur, debitCurDiff, creditCurDiff;
        AmountMST               settleDebitMST, settleCreditMST;
        AmountMSTSecondary      reportingSettleDebit, reportingSettleCredit;

        AmountCur               remainDebitCur, remainCreditCur;

        AmountMST               settleAmountMST, crossAmountMST;
        AmountMSTSecondary      reportingSettleAmount, reportingCrossAmount;

        AmountMSTExchAdjustment exchAdjAmountMST;
        AmountMSTSecondary      reportingExchAdjAmount;

        ExchRate                credit2debit;
        EmplLedger_RU           emplLedger;
        EmplTrans_RU            emplTrans;
        DimensionDefault        defaultDimension;
        EmplTrans_RU            exchAdjTrans;
        TransDate               transDate;
        EmplTrans_RU            mainEmplTrans;

        Map                     debitSettledAmounts = new Map(extendedTypeId2Type(extendedTypeNum(RecID)), extendedTypeId2Type(extendedTypeNum(AmountCur)));
        AmountCur               tmpAmount;

        void exhaustment(PostingProfile _postingProfile = '')
        {
            remainDebitCur  = 0;
            remainCreditCur = 0;

            this.setEmplQueries(_emplAccount, _postingProfile);

            do
            {
                exchAdjCrossAccountSet = new Set(Types::Int64);

                if (! remainCreditCur)
                {
                    this.fetchNextCredit();
                    remainCreditCur = transCredit.AmountCur - transCredit.SettleAmountCur;

                    if (this.fetchWithCheckDimension())
                    {
                        queryRunDebit.reset();
                        remainDebitCur = 0;
                    }
                }

                if (! transCredit)
                {
                    transDebit          = null;
                    transCredit         = null;
                    queryRunDebit       = null;
                    queryRunCredit      = null;
                    queryRunInnerCredit = null;

                    break;
                }

                if (! remainDebitCur)
                {
                    if (this.fetchWithCheckDimension())
                    {
                        this.fetchNextDebitCheckDimension(debitSettledAmounts);
                    }
                    else
                    {
                        this.fetchNextDebit();
                    }

                    remainDebitCur  = transDebit.AmountCur - transDebit.SettleAmountCur;
                }

                if (! transDebit)
                {
                    // force fetching next transCredit
                    remainCreditCur = 0;

                    continue;
                }

                if (! this.check())
                {
                    throw error("@SYS18447");
                }

                transDate = max(transDebit.TransDate, transCredit.TransDate);
                ledgerVoucherObject     = this.createVoucherTrans(transDate, LedgerTransTxt::LedgerExchAdj);
                emplExchAdjustment      = EmplExchAdjustmentCalc_RU::newFromSettlement(ledgerVoucher);

                credit2debit = this.crossRate(transCredit, transDebit);

                if (remainDebitCur <= -remainCreditCur * credit2debit)
                {
                    settleDebitCur  = remainDebitCur;
                    settleCreditCur = -settleDebitCur / credit2debit;
                }
                else
                {
                    settleCreditCur = remainCreditCur;
                    settleDebitCur = -settleCreditCur * credit2debit;
                }

                debitCurDiff  += settleCreditCur;
                creditCurDiff += settleDebitCur;

                if (transDebit.AmountCur == transDebit.SettleAmountCur + CurrencyExchangeHelper::amount(settleDebitCur, transDebit.CurrencyCode))
                {
                    settleDebitMST = transDebit.AmountMST - transDebit.SettleAmountMST;
                    reportingSettleDebit = transDebit.ReportingCurrencyAmount - transDebit.ReportingSettleAmount;
                }
                else
                {
                    settleDebitMST = CurrencyExchangeHelper::amount(settleDebitCur * transDebit.AmountMST / (transDebit.AmountCur ? transDebit.AmountCur : 1));
                    reportingSettleDebit = CurrencyExchangeHelper::amount(settleDebitCur * transDebit.ReportingCurrencyAmount / (transDebit.AmountCur ? transDebit.AmountCur : 1));
                }

                if (transCredit.AmountCur == transCredit.SettleAmountCur + CurrencyExchangeHelper::amount(settleCreditCur, transCredit.CurrencyCode))
                {
                    settleCreditMST = transCredit.AmountMST - transCredit.SettleAmountMST;
                    reportingSettleCredit = transCredit.ReportingCurrencyAmount - transCredit.ReportingSettleAmount;
                }
                else
                {
                    settleCreditMST = CurrencyExchangeHelper::amount(settleCreditCur * transCredit.AmountMST / (transCredit.AmountCur ? transCredit.AmountCur : 1));
                    reportingSettleCredit = CurrencyExchangeHelper::amount(settleCreditCur * transCredit.ReportingCurrencyAmount / (transCredit.AmountCur ? transCredit.AmountCur : 1));
                }

                settleDebitCur   = CurrencyExchangeHelper::amount(settleDebitCur, transDebit.CurrencyCode);
                settleCreditCur  = CurrencyExchangeHelper::amount(settleCreditCur, transCredit.CurrencyCode);

                if (transCredit.CurrencyCode != accountingCurrency)
                {
                    exchAdjAmountMST = settleDebitMST + settleCreditMST;
                }
                else
                {
                    exchAdjAmountMST = 0;
                }

                if (transCredit.CurrencyCode != Ledger::reportingCurrency())
                {
                    reportingExchAdjAmount = reportingSettleDebit + reportingSettleCredit;
                }
                else
                {
                    reportingExchAdjAmount = 0;
                }

                settleAmountMST       = min(settleDebitMST, - settleCreditMST);
                reportingSettleAmount = min(reportingSettleDebit, - reportingSettleCredit);

                [exchAdjAmountMST, reportingExchAdjAmount] = emplExchAdjustment.processRealizedExchAdj( exchAdjAmountMST,
                                                                                                        reportingExchAdjAmount,
                                                                                                        transDebit,
                                                                                                        transCredit,
                                                                                                        null,
                                                                                                        settleDebitCur,
                                                                                                        settleCreditCur,
                                                                                                        transDate,
                                                                                                        '',
                                                                                                        this.updateTables(),
                                                                                                        exchAdjUnrealizedTrans,
                                                                                                        true);

                mainEmplTrans = (transCredit.AdvanceId || (transCredit.TransDate >= transDebit.TransDate && ! transDebit.AdvanceId)) ? transCredit : transDebit;
                defaultDimension = LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(mainEmplTrans.LedgerDimension);

                if (exchAdjAmountMST || reportingExchAdjAmount)
                {
                    if (transDebit.CurrencyCode  == accountingCurrency ||
                        transCredit.CurrencyCode == accountingCurrency)
                    {
                        defaultDimension = transDebit.CurrencyCode  == accountingCurrency ? LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(transCredit.LedgerDimension) :
                                          (transCredit.CurrencyCode == accountingCurrency ? LedgerDimensionFacade::getDefaultDimensionFromLedgerDimension(transDebit.LedgerDimension)  :
                                           defaultDimension);
                    }

                    if (emplExchAdjustment.isAdvanceAdjustment(transDebit, transCredit))
                    {
                        settleAmountMST       = settleDebitMST;
                        reportingSettleAmount = reportingSettleDebit;

                        if (this.updateTables())
                        {
                            emplExchAdjustment.parmSkipAdvanceTableUpdate(this.parmSkipAdvanceTableUpdate());
                            exchAdjTrans = emplExchAdjustment.postAdvanceAdjTrans(transCredit,
                                                                                  - exchAdjAmountMST,
                                                                                  - reportingExchAdjAmount,
                                                                                  transDate,
                                                                                  ledgerVoucherObject,
                                                                                  defaultDimension,
                                                                                  this.parmEmplVoucher() ? this.parmEmplVoucher().sourceTable() : null);

                            exchAdjCrossAccountSet.add(exchAdjTrans.RecId);
                        }

                        this.endVoucherTrans();
                    }
                    else
                    {
                        this.postExchAdjTrans(mainEmplTrans,
                                              - exchAdjAmountMST,
                                              - reportingExchAdjAmount,
                                              transDate,
                                              defaultDimension);
                    }
                }

                if (LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(transDebit.LedgerDimension) !=
                    LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(transCredit.LedgerDimension))
                {
                    if (mainEmplTrans == transCredit)
                    {
                        crossAmountMST       = min(settleDebitMST, - settleCreditMST + exchAdjAmountMST);
                        reportingCrossAmount = min(reportingSettleDebit, - reportingSettleCredit + reportingExchAdjAmount);
                    }
                    else
                    {
                        crossAmountMST       = min(settleDebitMST - exchAdjAmountMST, - settleCreditMST);
                        reportingCrossAmount = min(reportingSettleDebit - reportingExchAdjAmount, - reportingSettleCredit);
                    }

                    this.postCrossAccount(settleDebitCur,
                                          settleCreditCur,
                                          crossAmountMST,
                                          reportingCrossAmount,
                                          transDate);
                }

                tmpAmount = debitSettledAmounts.exists(transDebit.RecId) ? any2real(debitSettledAmounts.lookup(transDebit.RecId)) : 0.;
                debitSettledAmounts.insert(transDebit.RecId, settleDebitCur + tmpAmount);

                remainDebitCur  -= settleDebitCur;
                remainCreditCur -= settleCreditCur;

                debitCurDiff  -= settleCreditCur;
                creditCurDiff -= settleDebitCur;

                this.updateExchAdjCrossAccountTrans(this.updateTransactions(transDebit,
                                                                            transCredit,
                                                                            settleDebitCur,
                                                                            settleCreditCur,
                                                                            settleAmountMST,
                                                                            reportingSettleAmount,
                                                                            - exchAdjAmountMST,
                                                                            - reportingExchAdjAmount,
                                                                            transDate,
                                                                            settleDebitMST,
                                                                            reportingSettleDebit,
                                                                            settleCreditMST,
                                                                            reportingSettleCredit));
                this.endVoucherTrans();

                if (transDebit.LastExchAdj && this.updateTables())
                {
                    emplExchAdjustment.recalcFutureUnrealizedExchAdj(transDebit);
                }

                if (transCredit.LastExchAdj && this.updateTables())
                {
                    emplExchAdjustment.recalcFutureUnrealizedExchAdj(transCredit);
                }
            }
            while (true);
        }

        if (profileSettlement)
        {
            while select PostingProfile from emplLedger
            exists join emplTrans
                where emplLedger.PostingProfile == emplTrans.PostingProfile
                   && emplTrans.EmplAccount     == _emplAccount
            {
                exhaustment(emplLedger.PostingProfile);
            }
        }
        else
        {
           exhaustment();
        }

        if (ledgerVoucher)
        {
            ledgerVoucher.end();
            ledgerVoucher = null;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>settleNow</Name>
				<Source><![CDATA[
    public void settleNow(EmplAccount_RU _onlyEmplAccount = '')
    {
        EmplTrans_RU            tmpEmplTrans;
        Query                   tmpQuery;
        QueryBuildDataSource    tmpQbds;
        QueryRun                tmpQr;
        RunbaseProgress         progress;

        this.initSettleTrans();
        this.buildQueries();

        if (_onlyEmplAccount)
        {
            ttsbegin;
            this.settleEmployee(_onlyEmplAccount);
            ttscommit;

            return;
        }

        ttsbegin;
        tmpQuery = new Query(queryDebit);
        tmpQbds = tmpQuery.dataSourceTable(tableNum(EmplTrans_RU));
        tmpQbds.update(false);
        tmpQbds.sortClear();
        tmpQbds.addSortField(fieldNum(EmplTrans_RU, EmplAccount));
        tmpQbds.orderMode(OrderMode::GroupBy);

        tmpQr = new QueryRun(tmpQuery);

        progress = RunbaseProgress::construct(1);
        progress.setCaption("@GLS104538");
        progress.setTotal(SysQuery::countLoops(tmpQr));

        while (tmpQr.next())
        {
            tmpEmplTrans = tmpQr.get(tableNum(EmplTrans_RU));
            progress.setText(tmpEmplTrans.EmplAccount);

            this.settleEmployee(tmpEmplTrans.EmplAccount);

            progress.incCount();
        }
        progress.kill();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>transSettle</Name>
				<Source><![CDATA[
    public EmplSettlement_RU transSettle()
    {
        select transSettle;
        return transSettle;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateExchAdjCrossAccountTrans</Name>
				<Source><![CDATA[
    protected void updateExchAdjCrossAccountTrans(EmplSettlement_RU _emplSettlement)
    {
        EmplTrans_RU    emplTrans;
        SetEnumerator   se;

        Debug::assert(exchAdjCrossAccountSet != null);
        if (exchAdjCrossAccountSet)
        {
            se = exchAdjCrossAccountSet.getEnumerator();
            while (se.moveNext())
            {
                emplTrans = EmplTrans_RU::findRecId(se.current(), true);
                Debug::assert(emplTrans != null);
                if (emplTrans)
                {
                    emplTrans.RefRecId      = _emplSettlement.RecId;
                    emplTrans.RefTableId    = _emplSettlement.TableId;
                    emplTrans.update();
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTables</Name>
				<Source><![CDATA[
    protected boolean updateTables()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTransactions</Name>
				<Source><![CDATA[
    protected EmplSettlement_RU updateTransactions(EmplTrans_RU             _transDebit,
                                                   EmplTrans_RU             _transCredit,
                                                   EmplSettleAmountCur_RU   _settleDebitCur,
                                                   EmplSettleAmountCur_RU   _settleCreditCur,
                                                   EmplSettleAmountMST_RU   _accountingSettleAmount,
                                                   AmountMSTSecondary       _reportingSettleAmount,
                                                   AmountMST                _accountingExchAdjAmount,
                                                   AmountMSTSecondary       _reportingExchAdjAmount,
                                                   TransDate                _transDate,
                                                   EmplSettleAmountMST_RU   _accountingSettleDebit   = 0,
                                                   AmountMSTSecondary       _reportingSettleDebit    = 0,
                                                   EmplSettleAmountMST_RU   _accountingSettleCredit  = 0,
                                                   AmountMSTSecondary       _reportingSettleCredit   = 0)
    {
        transSettle.TransDate                   = _transDate;
        transSettle.DebitTransDate              = _transDebit.TransDate;
        transSettle.CreditTransDate             = _transCredit.TransDate;
        transSettle.DebitRecId                  = _transDebit.RecId;
        transSettle.CreditRecId                 = _transCredit.RecId;
        transSettle.SettleAmountCurDebit        = _settleDebitCur;
        transSettle.SettleAmountCurCredit       = _settleCreditCur;
        transSettle.SettleAmountMSTDebit        = _accountingSettleDebit;
        transSettle.ReportingSettleAmountDebit  = _reportingSettleDebit;
        transSettle.SettleAmountMSTCredit       = _accountingSettleCredit;
        transSettle.ReportingSettleAmountCredit = _reportingSettleCredit;
        transSettle.SettleAmountMST             = _accountingSettleAmount;
        transSettle.ReportingSettleAmount       = _reportingSettleAmount;
        transSettle.ExchAdjustment              = _accountingExchAdjAmount;
        transSettle.ReportingExchAdjustment     = _reportingExchAdjAmount;
        transSettle.Voucher                     = voucher;
        transSettle.ManualCreated               = manualCreated;
        transSettle.insert();

        if (this.updateTables())
        {
            _transDebit.updateSettleAmount(_settleDebitCur,   _accountingSettleDebit,  _reportingSettleDebit,  _transDate);
            _transCredit.updateSettleAmount(_settleCreditCur, _accountingSettleCredit, _reportingSettleCredit, _transDate);
        }

        return transSettle;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>