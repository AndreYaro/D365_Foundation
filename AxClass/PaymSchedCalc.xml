<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>PaymSchedCalc</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// Abstract class for payment schedule calculation.
/// </summary>
public abstract class PaymSchedCalc
{
    CustVendPaymentSched custVendPaymSched;
    CustVendPaymentSchedLine custVendPaymSchedLine;
    CustPaymSchedLine custPaymSchedLine;
    VendPaymSchedLine vendPaymSchedLine;
    PaymSched paymSched;
    PaymSchedLine paymSchedLine;

    AmountCur paymentAmountCur;
    CashDiscAmount cashDiscAmount;

    AmountCur invoiceAmount;
    AmountCur invoiceTaxAmount;

    AmountCur invoiceMarkUpAmount;
    boolean installmentPlanInvoice;
    TransDate invoiceDate;
    private DueDate baseDueDate;
    DueDate dueDate;
    DiscDate cashDiscDate;
    InvoiceId invoiceId;
    PaymTermId paymTermId;
    PaymDayId paymDayId;
    CurrencyCode currencyCode;
    CashDiscCode cashDiscCode;
    Days cashDiscNumOfDays;

    Futures futures;
    Futures discPeriod;
    PaymDueDateLimit_ES dueDateLimit;

    AmountCur taxWithholdAmount;
    AmountCur totalTaxWithholdAmount;
    private AmountCur withholdTaxPaidAmount;
        
    TaxWithholdCodeType_IN taxWithholdType;

    PaymCalendarProcessor paymCalendarProcessor;
    PaymentDueDateUpdatePolicy dueDateUpdatePolicy;
    PaymCalendarFindCalendarResults paymCalendarResults;

    boolean skipVersionChangeCheck;

    AmountCur totaltaxAmountRetained;

    TaxAmountCur splitPaymSumTax_IT;

    #isoCountryRegionCodes

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createCustVendTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates customer vendor transactions.
    /// </summary>
    /// <param name = "custVendTrans">The customer or vendor transactions.</param>
    /// <param name = "exchRate">The exchange rate.</param>
    public void createCustVendTransaction(CustVendTrans custVendTrans, ExchRate exchRate)
    {
        CustTransCashDisc custTransCashDisc;
        VendTransCashDisc vendTransCashDisc;
        CustVendTransOpen custVendTransOpen = custVendTrans.transOpen();
        AmountCur remainAmountCur;
        AmountCur baseAmountCashDisc;
        AmountMST remainAmountMST;
        AmountMSTSecondary remainAmountReporting;
        CashDisc cashDisc;
        boolean firstTransOpen = true;
        CustVendPaymSchedReorg custVendPaymSchedReorg;

        AmountCur paymentAmount;
        CustVendTransPayment_BR custVendTransPaym_BR;

        CurrencyExchangeHelper currencyHelper;

        LineNum lineNum = 1;
        boolean custTransOpenOrVendTransOpen = CustVendTransOpen::isCustTransOpenOrVendTransOpen(custVendTransOpen);

        Debug::assert(custVendTrans.company() == curext());

        custVendPaymSchedReorg = CustVendPaymSchedReorg::construct(custVendTrans);

        currencyHelper = CurrencyExchangeHelper::newExchangeDate(Ledger::primaryLedger(CompanyInfo::findDataArea(curext()).RecId), invoiceDate);
        // the exchange rate passed in is a cross rate so only set exchange rate 1
        currencyHelper.parmExchangeRate1(exchRate);

        remainAmountCur = CurrencyExchange::round(invoiceAmount * custVendPaymSched.factor(), currencyCode);
        remainAmountMST = currencyHelper.calculateTransactionToAccounting(currencyCode, remainAmountCur, true);
        remainAmountReporting = currencyHelper.calculateTransactionCurrencyToReportingCurrency(currencyCode, remainAmountCur);
        paymentAmountCur = remainAmountCur;

        ttsbegin;

        if (!custVendTrans.RecId)
        {
            custVendTrans.insert();
        }

        if (custVendTrans.CashDiscCode)
        {
            cashDisc = CashDisc::find(custVendTrans.CashDiscCode);
        }

        custVendTransOpen.RefRecId = custVendTrans.RecId;
        custVendTransOpen.AccountNum = custVendTrans.AccountNum;
        custVendTransOpen.TransDate = custVendTrans.TransDate;

        if (isConfigurationkeyEnabled(configurationKeyNum(PublicSector)) && custVendTransOpen.TableId == tableNum(VendTransOpen))
        {
            custVendTransOpen.ThirdPartyBankAccountId = custVendTrans.ThirdPartyBankAccountId;
        }

        if (BrazilParameters::isEnabled())
        {
            custVendTransPaym_BR = custVendTrans.getPaymentExtension_BR();
            custVendTransOpen.FineCode_BR = custVendTransPaym_BR.FineCode;
            custVendTransOpen.InterestCode_BR = custVendTransPaym_BR.InterestCode;
        }

        if (TaxWithholdParameters_IN::checkTaxParameters() &&
            custVendPaymSched.PaymBy == PaymSchedBy::AmountByPayment)
        {
            remainAmountCur += this.adjustedWithholdAmount(taxWithholdAmount);
            paymentAmount = this.adjustedWithholdAmount(taxWithholdAmount);
        }

        withholdTaxPaidAmount = 0;

        while (custVendPaymSchedLine)
        {
            if (remainAmountCur || firstTransOpen)
            {
                this.populateCustVendTransOpen(custVendTransOpen);

                if (TaxWithholdParameters_IN::checkTaxParameters() && taxWithholdAmount)
                {
                    PaymSchedCalcAdjustCustVendTransOpenForWithholdingTaxParams inoutAmounts = new PaymSchedCalcAdjustCustVendTransOpenForWithholdingTaxParams();

                    inoutAmounts.paymentAmount = paymentAmount;
                    inoutAmounts.remainAmountCur = remainAmountCur;

                    inoutAmounts = this.adjustCustVendTransOpenForWithholdingTax_IN(custVendTrans, custVendTransOpen, inoutAmounts);

                    remainAmountCur = inoutAmounts.remainAmountCur;
                    paymentAmount = inoutAmounts.paymentAmount;
                }
                else
                {
                    remainAmountCur -= custVendTransOpen.AmountCur;
                }

                remainAmountCur = this.allocateRemainingAmountCur(custVendTransOpen, remainAmountCur);

                custVendTransOpen.AmountMST = currencyHelper.calculateTransactionToAccounting(currencyCode, custVendTransOpen.AmountCur, true);
                custVendTransOpen.ReportingCurrencyAmount = currencyHelper.calculateTransactionCurrencyToReportingCurrency(currencyCode, custVendTransOpen.AmountCur);
                remainAmountMST -= custVendTransOpen.AmountMST;
                remainAmountReporting -= custVendTransOpen.ReportingCurrencyAmount;

                if (custTransOpenOrVendTransOpen)
                {
                    if (firstTransOpen && custVendPaymSched.TaxDistribution == PaymSchedTaxDistribution::FirstRate)
                    {
                        custVendTransOpen.TaxDistribution = PaymSchedTaxDistribution::FirstRate;
                    }
                    else
                    {
                        custVendTransOpen.TaxDistribution = PaymSchedTaxDistribution::Proportional;
                    }
                }

                custVendTransOpen.insert();

                if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
                {
                    // Insert to the link table for installments
                    if (custVendPaymSched.TableId == tableNum(CustPaymSched)
                        && custVendPaymSched.ExtTableId == tableNum(CustInvoiceJour))
                    {
                        MCRPaymSchedLink::insertFromCustTransOpen(custVendPaymSched, custVendPaymSchedLine, custVendTransOpen.RecId, lineNum);
                        lineNum++;
                    }
                }

                custVendPaymSchedReorg.createPaymSchedTransLine(custVendTransOpen);

                if (cashDisc)
                {
                    switch (custVendTransOpen.TableId)
                    {
                        case tableNum(CustTransOpen) :
                            baseAmountCashDisc = LedgerJournalCashDiscService::baseAmountCashDisc(
                                ModuleCustVend::Cust,
                                CustVendTransCashDisc::amountExclTax(custVendTransOpen.AmountCur, invoiceTaxAmount),
                                invoiceTaxAmount,
                                cashDisc.Percent);

                            custTransCashDisc.calcCashDisc(
                                custVendTransOpen.company(),
                                currencyCode,
                                baseAmountCashDisc,
                                dueDate,
                                invoiceDate,
                                cashDiscCode,
                                custVendTransOpen.TableId,
                                custVendTransOpen.RecId,
                                NoYes::Yes,
                                custVendTransOpen.PossibleCashDisc,
                                custVendTransOpen.CashDiscDate,
                                cashDisc.Percent);

                            break;

                        case tableNum(VendTransOpen) :
                            baseAmountCashDisc = LedgerJournalCashDiscService::baseAmountCashDisc(
                                ModuleCustVend::Vend,
                                CustVendTransCashDisc::amountExclTax(custVendTransOpen.AmountCur, invoiceTaxAmount),
                                invoiceTaxAmount,
                                cashDisc.Percent);

                            vendTransCashDisc.calcCashDisc(
                                custVendTransOpen.company(),
                                currencyCode,
                                baseAmountCashDisc,
                                dueDate,
                                invoiceDate,
                                cashDiscCode,
                                custVendTransOpen.TableId,
                                custVendTransOpen.RecId,
                                NoYes::Yes,
                                custVendTransOpen.PossibleCashDisc,
                                custVendTransOpen.CashDiscDate,
                                cashDisc.Percent);

                            break;
                    }
                }
            }

            // Set custVendTrans.DueDate to the first custVendTransOpen.DueDate,
            // but it should not consider split payment lines in Italy localization.
            if (firstTransOpen && !custPaymSchedLine.SplitPayment_IT)
            {
                if (custVendTrans.DueDate != custVendTransOpen.DueDate)
                {
                    this.setCustVendTransDueDate(custVendTrans, custVendTransOpen);
                    custVendTrans.update();
                }
                firstTransOpen = false;
            }

            next custVendPaymSchedLine;
        }

        if (custTransOpenOrVendTransOpen && custVendTransOpen.RecId && custVendPaymSched.TaxDistribution == PaymSchedTaxDistribution::LastRate)
        {
            custVendTransOpen.TaxDistribution = PaymSchedTaxDistribution::LastRate;
            custVendTransOpen.update();
        }

        if (TaxWithholdVendBalanceDeductWHTWithPaymSched_INFlight::instance().isEnabled()
            && SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN])
            && withholdTaxPaidAmount)
        {
            remainAmountMST += currencyHelper.calculateTransactionToAccounting(currencyCode, withholdTaxPaidAmount, true);
            remainAmountReporting += currencyHelper.calculateTransactionCurrencyToReportingCurrency(currencyCode, withholdTaxPaidAmount);
        }

        // there is rounding amount difference so need to add this to the maximum installment
        // or if all amounts are the same add this to the latest installment
        this.adjustRoundingDifferencePostCreateCustVendTransaction(custVendTrans, custVendTransOpen, remainAmountMST, remainAmountReporting);

        if (remainAmountCur)
        {
            throw error(strFmt("@SYS23952", custVendPaymSched.Name, remainAmountCur));
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustRoundingDifferencePostCreateCustVendTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// There is rounding amount difference so need to add this to the maximum installment or if all amounts are the same add this to the latest installment.
    /// </summary>
    /// <param name = "_custVendTrans">
    /// <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <param name = "_custVendTransOpen">
    /// <c>CustVendTransOpen</c> table buffer.
    /// </param>
    /// <param name = "_remainAmountMST">
    /// Remaining amount value of type <c>AmountMST</c>
    /// </param>
    /// <param name = "_remainAmountReporting">
    /// Remaining amount value in reporting currency.
    /// </param>
    protected void adjustRoundingDifferencePostCreateCustVendTransaction(CustVendTrans _custVendTrans, CustVendTransOpen _custVendTransOpen, AmountMST _remainAmountMST, AmountMSTSecondary _remainAmountReporting)
    {
        if (_remainAmountMST || _remainAmountReporting)
        {
            select forupdate firstonly _custVendTransOpen
                order by AmountMST desc,
                         DueDate desc
                where _custVendTransOpen.RefRecId == _custVendTrans.RecId &&
                      _custVendTransOpen.AccountNum == _custVendTrans.AccountNum;

            if (_custVendTransOpen.RecId)
            {
                _custVendTransOpen.AmountMST += _remainAmountMST;
                _custVendTransOpen.ReportingCurrencyAmount += _remainAmountReporting;
                _custVendTransOpen.update();
            }
            // This should never happen, but added just in case
            else
            {
                throw error(strFmt("@SYS23952", custVendPaymSched.Name, _remainAmountMST));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCustVendTransDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the <c>DueDate</c> field value of <c>CustVendTrans</c> from <c>DueDate</c> field of <c>CustVendTransOpen</c>
    /// </summary>
    /// <param name = "_custVendTrans">
    /// <c>CustVendTrans</c> table buffer.
    /// </param>
    /// <param name = "_custVendTransOpen">
    /// <c>CustVendTransOpen</c> table buffer.
    /// </param>
    protected void setCustVendTransDueDate(CustVendTrans _custVendTrans, CustVendTransOpen _custVendTransOpen)
    {
        _custVendTrans.DueDate = _custVendTransOpen.DueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>allocateRemainingAmountCur</Name>
				<Source><![CDATA[
    protected AmountCur allocateRemainingAmountCur(CustVendTransOpen _custVendTransOpen, AmountCur _remainAmountCur)
    {
        AmountCur remainAmountCur = _remainAmountCur;

        if (this.isRemainingAmountBelowThreshold(remainAmountCur))
        {
            _custVendTransOpen.AmountCur += _remainAmountCur;
            remainAmountCur = 0;
        }

        return remainAmountCur;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isRemainingAmountBelowThreshold</Name>
				<Source><![CDATA[
    private boolean isRemainingAmountBelowThreshold(AmountCur _remainAmountCur)
    {
        return abs(_remainAmountCur) <= custVendPaymSched.LowestAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateCustVendTransOpen</Name>
				<Source><![CDATA[
    /// <summary>
    /// Populates the <c>CustVendTransOpen</c> table buffer.
    /// </summary>
    /// <param name = "_custVendTransOpen">
    /// <c>CustVendTransOpen</c> table buffer to be populated.
    /// </param>
    protected void populateCustVendTransOpen(CustVendTransOpen _custVendTransOpen)
    {
        _custVendTransOpen.AmountCur = CurrencyExchangeHelper::amount(custVendPaymSchedLine.DueAmount * custVendPaymSched.factor(), currencyCode);
        _custVendTransOpen.PossibleCashDisc = CurrencyExchangeHelper::amount(custVendPaymSchedLine.DiscAmount * custVendPaymSched.factor(), currencyCode);
        _custVendTransOpen.CashDiscDate = custVendPaymSchedLine.DiscDate;
        _custVendTransOpen.DueDate = custVendPaymSchedLine.DueDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustCustVendTransOpenForWithholdingTax_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjusts <c>CustVendTransOpen</c> table record according to calculated withholding tax.
    /// </summary>
    /// <param name = "_custTrans">
    /// <c>CustTrans</c> table buffer.
    /// </param>
    /// <param name = "_custVendTransOpen">
    /// <c>CustVendTransOpen</c> table buffer.
    /// </param>
    /// <param name = "_inoutAmountContainer">
    /// Class instance for input/output amounts container.
    /// </param>
    /// <returns> <c>PaymSchedCalcAdjustCustVendTransOpenForWithholdingTaxParams</c> class instance.</returns>
    protected PaymSchedCalcAdjustCustVendTransOpenForWithholdingTaxParams  adjustCustVendTransOpenForWithholdingTax_IN(CustVendTrans _custVendTrans, CustVendTransOpen _custVendTransOpen, PaymSchedCalcAdjustCustVendTransOpenForWithholdingTaxParams _inoutAmountContainer)
    {
        real withholdTaxAmount;

        AmountCur whtAmountAdjusted = this.adjustedWithholdAmount(taxWithholdAmount);

        if (paymentAmountCur)
        {
            withholdTaxAmount = CurrencyExchangeHelper::amount((whtAmountAdjusted * _custVendTransOpen.AmountCur)/ paymentAmountCur);
            withholdTaxPaidAmount += withholdTaxAmount;
        }
        if (custVendPaymSched.PaymBy == PaymSchedBy::AmountByPayment)
        {
            _inoutAmountContainer.remainAmountCur -= _custVendTransOpen.AmountCur;
        }
        else
        {
            _inoutAmountContainer.remainAmountCur -= _custVendTransOpen.AmountCur;
            _custVendTransOpen.AmountCur = _custVendTransOpen.AmountCur + withholdTaxAmount;
            if (_inoutAmountContainer.remainAmountCur == 0 && withholdTaxPaidAmount != whtAmountAdjusted)
            {
                if (_custVendTransOpen.TableId == tableNum(VendTransOpen))
                {
                    _custVendTransOpen.AmountCur += abs(withholdTaxPaidAmount) - abs(whtAmountAdjusted);
                }
                else
                {
                    _custVendTransOpen.AmountCur -= abs(withholdTaxPaidAmount) - abs(whtAmountAdjusted);
                }
            }
        }

        CustVendTrans_W custVendTrans_W = _custVendTrans.CustVendTrans::getCustVendTrans_W();
        _custVendTransOpen.TaxWithholdAmountOrigin_IN = custVendTrans_W.TaxWithholdAmountOrigin_IN;

        if (custVendTrans_W.tdsAmount_IN)
        {
            _custVendTransOpen.tdsAmount_IN = taxWithholdAmount;
        }
        if (custVendTrans_W.tcsAmount_IN)
        {
            if (abs(_inoutAmountContainer.paymentAmount) <= abs(_custVendTransOpen.AmountCur))
            {
                _custVendTransOpen.tcsAmount_IN = _inoutAmountContainer.paymentAmount;
                _inoutAmountContainer.paymentAmount = 0;
            }
            if (abs(_inoutAmountContainer.paymentAmount) > abs(_custVendTransOpen.AmountCur))
            {
                _custVendTransOpen.tcsAmount_IN = _custVendTransOpen.AmountCur;
                _inoutAmountContainer.paymentAmount -= _custVendTransOpen.AmountCur;
            }
        }

        return _inoutAmountContainer;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates transactions.
    /// </summary>
    /// <param name = "_custVendPaymentSchedLine">The customer vendor payment schedule line.</param>
    public void createTransaction(CustVendPaymentSchedLine _custVendPaymentSchedLine)
    {
        throw error(Error::missingOverload(funcName()));
    }

]]></Source>
			</Method>
			<Method>
				<Name>createTransactionSplitPaym_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the SplitPayment transaction.
    /// </summary>
    protected void createTransactionSplitPaym_IT()
    {
        CustPaymSchedLine custPaymSchedLineLoc;

        custPaymSchedLineLoc.initFromCustVendPaymSched(custVendPaymSched);
        custPaymSchedLineLoc.SplitPayment_IT = NoYes::Yes;
        custPaymSchedLineLoc.DueAmount = splitPaymSumTax_IT;
        custPaymSchedLineLoc.DueDate = invoiceDate;
        custPaymSchedLineLoc.insert();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFutures</Name>
				<Source><![CDATA[
    private void initFutures()
    {
        futures = Futures::construct(baseDueDate,
            custVendPaymSched.QtyUnit,
            custVendPaymSched.PeriodUnit);

        discPeriod = Futures::construct(cashDiscDate,
            custVendPaymSched.QtyUnit,
            custVendPaymSched.PeriodUnit);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustFreeInvoiceCalcTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>PaymSchedCalc</c> from customer free invoice calculation totals.
    /// </summary>
    /// <param name = "custFreeInvoiceCalcTotals">The customer free invoice calculation totals.</param>
    public void initFromCustFreeInvoiceCalcTotals(CustFreeInvoiceCalcTotals custFreeInvoiceCalcTotals)
    {
        invoiceAmount = custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount();
        invoiceTaxAmount = custFreeInvoiceCalcTotals.custFreeInvoiceTaxTotal();
        cashDiscAmount = custFreeInvoiceCalcTotals.custFreeInvoiceCashDisc();
        invoiceDate = custFreeInvoiceCalcTotals.documentDate();
        paymTermId = custFreeInvoiceCalcTotals.paymCode();
        paymDayId = custFreeInvoiceCalcTotals.paymDayId();
        cashDiscDate = custFreeInvoiceCalcTotals.cashDiscDate();
        invoiceId = '';
        cashDiscCode = custFreeInvoiceCalcTotals.cashDiscCode();
        currencyCode = custFreeInvoiceCalcTotals.custFreeInvoiceCurrency();

        PaymTerm paymTerm = this.setPaymTerm(paymTermId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            if (paymTerm.UseDeliveryDateForDueDate_ES)
            {
                invoiceDate = custFreeInvoiceCalcTotals.deliveryDate_ES();
                if (!invoiceDate)
                {
                    throw error("@SYS4001056");
                }
            }

            dueDateLimit = PaymDueDateLimit_ES::getCurrentValues(paymTerm.DueDateLimitGroupId_ES);
        }

        baseDueDate = paymTerm.due(invoiceDate, paymDayId, false, dueDateLimit);

        this.initDueDatefromInvoice(custFreeInvoiceCalcTotals, baseDueDate);

        if (paymTerm.CustomerUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
            {
                this.updatePaymCalendarAndDueDatePolicy(
                    custFreeInvoiceCalcTotals,
                    paymTerm.CustomerUpdateDueDate);

                dueDate = paymCalendarProcessor.adjustDateForCalendar(dueDate, paymTerm.CustomerUpdateDueDate, paymCalendarResults);
            }
        }

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            totalTaxWithholdAmount = (taxWithholdType == TaxWithholdCodeType_IN::TDS) ? -totalTaxWithholdAmount : totalTaxWithholdAmount;
            invoiceAmount = custFreeInvoiceCalcTotals.custFreeInvoiceInvoiceAmount() + this.adjustedWithholdAmount(totalTaxWithholdAmount);
        }

        if (BrazilParameters::isEnabled())
        {
            totalTaxAmountRetained = custFreeInvoiceCalcTotals.tax().totalTaxAmountRetained_BR();
            invoiceAmount -= totalTaxAmountRetained;
        }

        if (MultipleTaxIdReportingHelper::isLegalEntityOrAddressInCountryRegion([#isoIT], MultipleTaxIdScope::VATDeclaration)
            && custVendPaymSched.TableId == tableNum(CustPaymSched))
        {
            splitPaymSumTax_IT = TaxSplitPaymentPost_IT::getSplitPaymTaxAmount_IT(custFreeInvoiceCalcTotals.tax());
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromCustVendInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>PaymSchedCalc</c> from customer vendor invoice journal.
    /// </summary>
    /// <param name = "custVendInvoiceJour">The customer vendor invoice journal.</param>
    public void initFromCustVendInvoiceJour(CustVendInvoiceJour custVendInvoiceJour)
    {
        invoiceAmount = custVendInvoiceJour.InvoiceAmount;
        invoiceTaxAmount = custVendInvoiceJour.SumTax;
        cashDiscAmount = custVendInvoiceJour.CashDisc;
        invoiceDate = custVendInvoiceJour.InvoiceDate;
        paymTermId = custVendInvoiceJour.Payment;
        paymDayId = custVendInvoiceJour.PaymDayId;
        cashDiscDate = custVendInvoiceJour.CashDiscDate;
        invoiceId = custVendInvoiceJour.InvoiceId;
        cashDiscCode = custVendInvoiceJour.CashDiscCode;
        currencyCode = custVendInvoiceJour.CurrencyCode;

        CustVendInvoiceJourDueDateCalculator custVendInvoiceJourDueDateCalculator = CustVendInvoiceJourDueDateCalculator::construct(custVendInvoiceJour);
        baseDueDate = custVendInvoiceJourDueDateCalculator.calcOriginalDueDate();
        dueDate = custVendInvoiceJourDueDateCalculator.calcDueDate();

        PaymTerm paymTerm = PaymTerm::find(paymTermId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            if (paymTerm.UseDeliveryDateForDueDate_ES &&
               (custVendInvoiceJour.TableId == tableNum(CustInvoiceJour) ||
                custVendInvoiceJour.TableId == tableNum(VendInvoiceJour)))
            {
                invoiceDate = custVendInvoiceJour.DeliveryDate_ES;
                if (!invoiceDate)
                {
                    throw error(custVendInvoiceJour.TableId == tableNum(VendInvoiceJour) ? "@SYS4001056" : "@SYS4001057");
                }
            }

            dueDateLimit = custVendInvoiceJour.calcDueDateLimit_ES(paymTerm, invoiceDate);
        }

        // Only need to set some class-level variables and parm methods here. Any DueDate offsets for holidays/business days have already occurred at this point.
        if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
        {
            switch (custVendInvoiceJour.TableId)
            {
                case tableNum(CustInvoiceJour) :
                    if (paymTerm.CustomerUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
                    {
                        PaymCalendarSourceCustInvoiceJournal paymCalendarSourceCustInvoiceJournal = PaymCalendarSourceCustInvoiceJournal::newCalendarSource(custVendInvoiceJour);

                        this.updatePaymCalendarAndDueDatePolicy(
                            paymCalendarSourceCustInvoiceJournal,
                            paymTerm.CustomerUpdateDueDate);
                    }
                    break;

                case tableNum(VendInvoiceJour) :
                    if (paymTerm.VendorUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
                    {
                        PaymCalendarSourceVendInvoiceJournal paymCalendarSourceVendInvoiceJournal = PaymCalendarSourceVendInvoiceJournal::newCalendarSource(custVendInvoiceJour);

                        this.updatePaymCalendarAndDueDatePolicy(
                            paymCalendarSourceVendInvoiceJournal,
                            paymTerm.VendorUpdateDueDate);
                    }
                    break;

                // This is a safety valve after accidentally breaking project related functionality with the fixes in #277791.
                // These tables should eventually route through their respective initFrom______ methods instead of this one though.
                case tableNum(ProjProposalJour), tableNum(ProjInvoiceJour), tableNum(CustInvoice4PaymJour_RU) :
                    break;
            }
        }

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            if (TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled()
                && taxWithholdType == TaxWithholdCodeType_IN::None)
            {
                // Gets the tax withholding tax type if it is missing here.
                taxWithholdType = TaxWithholdTrans_IN::taxWithholdTransType(custVendInvoiceJour.LedgerVoucher, custVendInvoiceJour.InvoiceDate);
            }
            invoiceAmount = custVendInvoiceJour.InvoiceAmount + this.adjustedWithholdAmount(totalTaxWithholdAmount);
        }

        VendInvoiceJour vendInvoiceJournalLoc;

        if (custVendInvoiceJour.TableId == tableNum(VendInvoiceJour))
        {
            vendInvoiceJournalLoc = custVendInvoiceJour;
            invoiceAmount += vendInvoiceJournalLoc.totalAdvanceApplicationAmount();
        }

        if (BrazilParameters::isEnabled())
        {
            totaltaxAmountRetained = custVendInvoiceJour.totaltaxAmountRetained_BR();
            invoiceAmount += totaltaxAmountRetained;

            if (vendInvoiceJournalLoc && vendInvoiceJournalLoc.purchTable().isDirectImport_BR())
            {
                invoiceAmount -= vendInvoiceJournalLoc.SumTax + vendInvoiceJournalLoc.SumMarkup;
            }
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && custVendInvoiceJour.TableId == tableNum(CustInvoiceJour))
        {
            splitPaymSumTax_IT = TaxSplitPaymentPost_IT::getSplitPaymTaxAmount_IT(null, custVendInvoiceJour.LedgerVoucher, custVendInvoiceJour.InvoiceDate);
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>updatePaymCalendarAndDueDatePolicy</Name>
				<Source><![CDATA[
    private void updatePaymCalendarAndDueDatePolicy(
        PaymCalendarIDerivationSource _paymCalendarDerivationSource,
        PaymentDueDateUpdatePolicy _dueDateUpdatePolicy)
    {
        paymCalendarProcessor = PaymCalendarProcessor::construct();
        paymCalendarResults = paymCalendarProcessor.findPaymCalendar(_paymCalendarDerivationSource);
        this.parmDueDateUpdatePolicy(_dueDateUpdatePolicy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjInvoiceJour</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>PaymSchedCalc</c> from project invoice journal.
    /// </summary>
    /// <param name = "projInvoiceJour">The project invoice journal.</param>
    public void initFromProjInvoiceJour(ProjInvoiceJour projInvoiceJour)
    {
        invoiceAmount = projInvoiceJour.InvoiceAmount;
        invoiceTaxAmount = projInvoiceJour.SumTax;
        cashDiscAmount = projInvoiceJour.CashDisc;
        invoiceDate = projInvoiceJour.InvoiceDate;
        paymTermId = projInvoiceJour.Payment;
        paymDayId = projInvoiceJour.PaymDayId;
        cashDiscDate = projInvoiceJour.CashDiscDate;
        invoiceId = projInvoiceJour.ProjInvoiceId;
        cashDiscCode = projInvoiceJour.CashDiscCode;
        currencyCode = projInvoiceJour.CurrencyId;

        baseDueDate = projInvoiceJour.DueDate;
        dueDate = baseDueDate;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            dueDateLimit = projInvoiceJour.calcDueDateLimit_ES(PaymTerm::find(paymTermId), invoiceDate);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT]))
        {
            splitPaymSumTax_IT = TaxSplitPaymentPost_IT::getSplitPaymTaxAmount_IT(null, projInvoiceJour.LedgerVoucher, projInvoiceJour.InvoiceDate);
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromProjProprosalTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initialize the <c>PaymSchedCalc</c> from project proprosal totals.
    /// </summary>
    /// <param name = "projProposalTotals">The project proprosal totals.</param>
    public void initFromProjProprosalTotals(ProjProposalTotals projProposalTotals)
    {
        invoiceAmount = projProposalTotals.projInvoiceTotalAmount();
        invoiceTaxAmount = projProposalTotals.projInvoiceTaxTotal();
        cashDiscAmount = projProposalTotals.projcashDiscAmount();
        invoiceDate = projProposalTotals.projInvoiceDate();
        paymTermId = projProposalTotals.paymCode();
        paymDayId = projProposalTotals.projInvoicePaymDayId();
        cashDiscDate = projProposalTotals.cashDiscDate();
        invoiceId = '';
        cashDiscCode = projProposalTotals.projInvoiceCashDiscCode();
        currencyCode = projProposalTotals.projInvoiceCurrency();

        baseDueDate = PaymTerm::find(paymTermId).due(invoiceDate, paymDayId);
        dueDate = baseDueDate;

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && custVendPaymSched.TableId == tableNum(CustPaymSched))
        {
            splitPaymSumTax_IT = TaxSplitPaymentPost_IT::getSplitPaymTaxAmount_IT(projProposalTotals.tax());
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchComplInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> class from a given purchase complementary invoice.
    /// </summary>
    /// <param name="_purchComplInvoiceHeader">
    /// The <c>PurchComplementaryInvoiceHeader</c> table buffer of the given purchase complementary invoice header.
    /// </param>
    public void initFromPurchComplInvoice(PurchComplementaryInvoiceHeader _purchComplInvoiceHeader)
    {
        PurchComplInvCalcTotals calcTotals = new PurchComplInvCalcTotals(_purchComplInvoiceHeader);
        calcTotals.calc();

        invoiceAmount = calcTotals.totalAmount();
        invoiceTaxAmount = calcTotals.sumTax();
        cashDiscAmount = calcTotals.cashDiscAmount();
        invoiceDate = _purchComplInvoiceHeader.TransDate;
        paymTermId = _purchComplInvoiceHeader.Payment;
        paymDayId = _purchComplInvoiceHeader.paymDayId();
        cashDiscDate = _purchComplInvoiceHeader.CashDiscDate;
        invoiceId = '';
        cashDiscCode = _purchComplInvoiceHeader.CashDisc;
        currencyCode = _purchComplInvoiceHeader.Currency;

        PaymTerm paymTerm = PaymTerm::find(paymTermId);
        baseDueDate = paymTerm.due(invoiceDate, paymDayId);
        dueDate = baseDueDate;

        if (paymTerm.VendorUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            PaymCalendarSourcePurchComplInvoice calendarDerivation = new PaymCalendarSourcePurchComplInvoice(_purchComplInvoiceHeader);

            this.updatePaymCalendarAndDueDatePolicy(
                calendarDerivation,
                paymTerm.VendorUpdateDueDate);

            dueDate = paymCalendarProcessor.adjustDateForCalendar(dueDate, paymTerm.VendorUpdateDueDate, paymCalendarResults);
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromPurchTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> class from purchase totals.
    /// </summary>
    /// <param name = "purchTotals">The purchase totals.</param>
    public void initFromPurchTotals(PurchTotals purchTotals)
    {
        invoiceAmount = purchTotals.purchNewTotalAmount();
        invoiceTaxAmount = purchTotals.purchTaxTotal();
        cashDiscAmount = purchTotals.purchCashDiscAmount();
        invoiceDate = purchTotals.documentDate();
        paymTermId = purchTotals.paymCode();
        paymDayId = purchTotals.paymDayId();
        cashDiscDate = purchTotals.purchCashDiscDate();
        invoiceId = '';
        cashDiscCode = purchTotals.purchCashDiscCode();
        currencyCode = purchTotals.purchCurrency();

        PaymTerm paymTerm = this.getPaymTermFromPurchTotals(paymTermId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            if (paymTerm.UseDeliveryDateForDueDate_ES)
            {
                invoiceDate = purchTotals.deliveryDate_ES();

                if (!invoiceDate)
                {
                    throw error("@SYS4001056");
                }
            }

            dueDateLimit = PaymDueDateLimit_ES::getCurrentValues(paymTerm.DueDateLimitGroupId_ES);
        }

        baseDueDate = paymTerm.due(invoiceDate, paymDayId, false, dueDateLimit);
        dueDate = baseDueDate;

        if (paymTerm.VendorUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar)))
            {
                this.updatePaymCalendarAndDueDatePolicy(
                    purchTotals,
                    paymTerm.VendorUpdateDueDate);

                dueDate = paymCalendarProcessor.adjustDateForCalendar(dueDate, paymTerm.VendorUpdateDueDate, paymCalendarResults);
            }
        }

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            totalTaxWithholdAmount = (taxWithholdType == TaxWithholdCodeType_IN::TDS) ? -totalTaxWithholdAmount : totalTaxWithholdAmount;
            invoiceAmount = purchTotals.purchNewTotalAmount() + this.adjustedWithholdAmount(totalTaxWithholdAmount);
        }

        if (BrazilParameters::isEnabled())
        {
            invoiceAmount = purchTotals.vendTransAmount_BR();
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesComplInvoice</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> class from a given sales complementary invoice.
    /// </summary>
    /// <param name="_salesComplInvoiceHeader">
    /// The <c>SalesComplementaryInvoiceHeader</c> table buffer of the given sales complementary invoice header.
    /// </param>
    public void initFromSalesComplInvoice(SalesComplementaryInvoiceHeader _salesComplInvoiceHeader)
    {
        SalesComplInvCalcTotals calcTotals = new SalesComplInvCalcTotals(_salesComplInvoiceHeader);
        calcTotals.calc();

        invoiceAmount = calcTotals.totalAmount();
        invoiceTaxAmount = calcTotals.sumTax();
        cashDiscAmount = calcTotals.cashDiscAmount();
        invoiceDate = _salesComplInvoiceHeader.DocumentDate;
        paymTermId = _salesComplInvoiceHeader.PaymTerm;
        paymDayId = _salesComplInvoiceHeader.paymDayId();
        cashDiscDate = _salesComplInvoiceHeader.CashDiscDate;
        invoiceId = _salesComplInvoiceHeader.FiscalDocumentNumber;
        cashDiscCode = _salesComplInvoiceHeader.CashDisc;
        currencyCode = _salesComplInvoiceHeader.Currency;

        PaymTerm paymTerm = PaymTerm::find(paymTermId);
        baseDueDate = paymTerm.due(invoiceDate, paymDayId);
        dueDate = baseDueDate;

        if (paymTerm.CustomerUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            PaymCalendarSourceSalesComplInvoice calendarDerivation = new PaymCalendarSourceSalesComplInvoice(_salesComplInvoiceHeader);

            this.updatePaymCalendarAndDueDatePolicy(
                    calendarDerivation,
                    paymTerm.CustomerUpdateDueDate);

            dueDate = paymCalendarProcessor.adjustDateForCalendar(dueDate, paymTerm.CustomerUpdateDueDate, paymCalendarResults);
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFromSalesTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> class from a given sales totals.
    /// </summary>
    /// <param name = "salesTotals">The sales totals.</param>
    public void initFromSalesTotals(SalesTotals salesTotals)
    {
        invoiceAmount = salesTotals.totalAmount();
        invoiceTaxAmount = salesTotals.totalTaxAmount();
        cashDiscAmount = salesTotals.cashDiscAmount();
        invoiceDate = salesTotals.documentDate();
        paymTermId = salesTotals.paymCode();
        paymDayId = salesTotals.paymDayId();
        cashDiscDate = salesTotals.cashDiscDate();
        invoiceId = '';
        cashDiscCode = salesTotals.cashDiscCode();
        currencyCode = salesTotals.currencyCode();

        PaymTerm paymTerm = this.getPaymTermFromSalesTotals(paymTermId);

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoES]))
        {
            if (paymTerm.UseDeliveryDateForDueDate_ES)
            {
                invoiceDate = salesTotals.deliveryDate_ES();

                if (!invoiceDate)
                {
                    throw error("@SYS4001057");
                }
            }

            dueDateLimit = PaymDueDateLimit_ES::getCurrentValues(paymTerm.DueDateLimitGroupId_ES);
        }

        baseDueDate = paymTerm.due(invoiceDate, paymDayId, false, dueDateLimit);
        dueDate = baseDueDate;

        if (paymTerm.CustomerUpdateDueDate != PaymentDueDateUpdatePolicy::NoUpdate)
        {
            if (isConfigurationkeyEnabled(configurationKeyNum(PaymCalendar))
                && salesTotals is SalesTotals_Sales)
            {
                SalesTotals_Sales salesTotals_Sales = salesTotals as SalesTotals_Sales;

                this.updatePaymCalendarAndDueDatePolicy(
                    salesTotals_Sales,
                    paymTerm.CustomerUpdateDueDate);

                dueDate = paymCalendarProcessor.adjustDateForCalendar(dueDate, paymTerm.CustomerUpdateDueDate, paymCalendarResults);
            }
        }

        if (TaxWithholdParameters_IN::checkTaxParameters())
        {
            totalTaxWithholdAmount = (taxWithholdType == TaxWithholdCodeType_IN::TDS) ? -totalTaxWithholdAmount : totalTaxWithholdAmount;
            invoiceAmount = salesTotals.totalAmount() + this.adjustedWithholdAmount(totalTaxWithholdAmount);
        }

        if (BrazilParameters::isEnabled())
        {
            totaltaxAmountRetained = salesTotals.tax().totalTaxAmountRetained_BR();
            invoiceAmount -= totaltaxAmountRetained;
        }

        if (TaxParameters::find().CashDiscOnInvoice)
        {
            invoiceAmount = invoiceAmount - cashDiscAmount;
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIT])
            && custVendPaymSched.TableId == tableNum(CustPaymSched))
        {
            splitPaymSumTax_IT = TaxSplitPaymentPost_IT::getSplitPaymTaxAmount_IT(salesTotals.tax());
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitFromContinuityCustHdrTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> object from
    /// the related <c>MCRContinuityCustHeader</c> record.
    /// </summary>
    public void mcrInitFromContinuityCustHdrTotals()
    {
        MCRContinuityCustHeader continuityCustHeader = MCRContinuityCustHeader::findRecId(custVendPaymSched.ExtRecId, false);
        SalesLine salesLine = SalesLine::findInventTransId(continuityCustHeader.InventTransId);
        // Find the customer by the invoice account, rather than the cust account
        CustTable custTable = CustTable::find(salesLine.invoiceAccount(), false);

        invoiceAmount = salesLine.calcLineAmount();
        invoiceTaxAmount = 0;
        cashDiscAmount = salesLine.calcLineDisc();
        invoiceDate = continuityCustHeader.StartDate;
        paymTermId = custTable.PaymTermId;
        paymDayId = custTable.PaymDayId;
        cashDiscDate = dateNull();
        invoiceId = '';
        cashDiscCode = '';
        currencyCode = salesLine.CurrencyCode;

        baseDueDate = PaymTerm::find(paymTermId).due(invoiceDate, paymDayId);
        dueDate = baseDueDate;

        // add tax amount to the invoice amount
        TaxAmountCur continuityLineTax = SalesLine::mcrCalcContinuityLineTax(salesLine);
        invoiceAmount = invoiceAmount + continuityLineTax;

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitFromContinuityCustLineTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> object from
    /// the related <c>MCRContinuityCustLine</c> record.
    /// </summary>
    public void mcrInitFromContinuityCustLineTotals()
    {
        // Retrieve information from the continuity tables, sales line and customer table
        // to calculate the due dates and payment amounts if the sales order has been created.
        MCRContinuityCustLine continuityCustLine = MCRContinuityCustLine::findRecId(custVendPaymSched.ExtRecId, false);
        SalesLine salesLine = SalesLine::findRecId(custVendPaymSched.ExtRecId, false);
        // Find the customer by the invoice account, rather than the cust account
        CustTable custTable = CustTable::find(salesLine.invoiceAccount(), false);

        // The amount to be used for calculation should come from the price on the MCRContinuityCustLine
        // where information has been recorded for the children orders.
        invoiceAmount = continuityCustLine.Price;
        invoiceTaxAmount = 0;
        cashDiscAmount = salesLine.calcLineDisc();
        invoiceDate = continuityCustLine.StartDate;
        paymTermId = custTable.PaymTermId;
        paymDayId = custTable.PaymDayId;
        cashDiscDate = dateNull();
        invoiceId = '';
        cashDiscCode = '';
        currencyCode = salesLine.CurrencyCode;

        baseDueDate = PaymTerm::find(paymTermId).due(invoiceDate, paymDayId);
        dueDate = baseDueDate;

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitFromCustInvoice_Continuity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> object from
    /// the related <c>CustInvoiceJour</c> record for
    /// continuity bill up front schedules.
    /// </summary>
    /// <param name="_custVendInvoiceJour">
    /// Invoice header record to generate the payment schedule records.
    /// </param>
    /// <returns>
    /// The due amount for the continuity payment schedule.
    /// </returns>
    public AmountCur mcrInitFromCustInvoice_Continuity(CustVendInvoiceJour _custVendInvoiceJour)
    {
        CustPaymSchedLine custPaymSchedLineContinuity;

        if (isConfigurationkeyEnabled(configurationKeyNum(MCRCallCenter)))
        {
            select sum (DueAmount) from custPaymSchedLineContinuity
                where custPaymSchedLineContinuity.ParentRecID == custVendPaymSched.RecId;

            invoiceAmount = custPaymSchedLineContinuity.DueAmount;
            invoiceTaxAmount = 0;
            cashDiscAmount = _custVendInvoiceJour.CashDisc;
            invoiceDate = _custVendInvoiceJour.InvoiceDate;
            paymTermId = _custVendInvoiceJour.Payment;
            paymDayId = _custVendInvoiceJour.PaymDayId;
            cashDiscDate = _custVendInvoiceJour.CashDiscDate;
            invoiceId = _custVendInvoiceJour.InvoiceId;
            cashDiscCode = _custVendInvoiceJour.CashDiscCode;
            currencyCode = _custVendInvoiceJour.CurrencyCode;

            baseDueDate = _custVendInvoiceJour.DueDate;
            dueDate = baseDueDate;

            this.initFutures();
            this.setAmount();
        }

        return invoiceAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mcrInitFromInstallmentBillingTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the <c>PaymSchedCalc</c> object from
    /// the related <c>MCRInstallmentPlanSalesTable</c> record.
    /// </summary>
    public void mcrInitFromInstallmentBillingTotals()
    {
        SalesTable salesTable = SalesTable::findRecId(custVendPaymSched.ExtRecId);
        MCRSalesOrderTotals mcrSalesOrderTotals = new MCRSalesOrderTotals(salesTable);
        SalesTotals salesTotals = SalesTotals::construct(salesTable);
        CustTable custTable = CustTable::find(salesTable.InvoiceAccount, false);

        invoiceAmount = mcrSalesOrderTotals.getInstallmentEligibleTotal();
        invoiceTaxAmount = mcrSalesOrderTotals.getInvoicedInstallTax(); // Tax amount
        cashDiscAmount = salesTotals.cashDiscAmount();
        invoiceDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        paymTermId = custTable.PaymTermId;
        paymDayId = custTable.PaymDayId;
        cashDiscDate = salesTotals.cashDiscDate();
        invoiceId = '';
        cashDiscCode = salesTotals.cashDiscCode();
        currencyCode = salesTable.CurrencyCode;

        baseDueDate = PaymTerm::find(paymTermId).due(invoiceDate, paymDayId);
        dueDate = baseDueDate;

        invoiceMarkUpAmount = mcrSalesOrderTotals.getInvoicedMarkup(); // Misc line charges

        if (TaxParameters::find().CashDiscOnInvoice)
        {
            invoiceAmount = invoiceAmount - cashDiscAmount;
        }

        this.initFutures();
        this.setAmount();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new class.
    /// </summary>
    /// <param name = "_custVendPaymSched">The customer vendor payment schedule.</param>
    /// <param name = "_paymSched">The payment schedule.</param>
    public void new(CustVendPaymentSched _custVendPaymSched, PaymSched _paymSched = null)
    {
        custVendPaymSched = _custVendPaymSched;
        paymSched = _paymSched;

        this.setBuffer();
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextDiscDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets transaction date.
    /// </summary>
    /// <param name = "_dueDate">The dueDate.</param>
    /// <returns>The transaction date.</returns>
    public TransDate nextDiscDate(TransDate _dueDate)
    {
        if (!cashDiscDate || !_dueDate)
        {
            return dateNull();
        }

        if (!cashDiscNumOfDays)
        {
            cashDiscNumOfDays = date2Num(cashDiscDate) - date2Num(_dueDate);
        }

        return _dueDate + cashDiscNumOfDays;
    }

]]></Source>
			</Method>
			<Method>
				<Name>nextDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets transaction date from next dueDate.
    /// </summary>
    /// <returns>The next transaction date.</returns>
    protected TransDate nextDueDate()
    {
        return futures.next();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmDueDateUpdatePolicy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets dueDate update policy.
    /// </summary>
    /// <param name = "_dueDateUpdatePolicy">The dueDate update policy.</param>
    /// <returns>The dueDate update policy.</returns>
    public PaymentDueDateUpdatePolicy parmDueDateUpdatePolicy(PaymentDueDateUpdatePolicy _dueDateUpdatePolicy = dueDateUpdatePolicy)
    {
        dueDateUpdatePolicy = _dueDateUpdatePolicy;

        return dueDateUpdatePolicy;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipVersionChangeCheck</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets if it is skip version change check.
    /// </summary>
    /// <param name = "_skipVersionChangeCheck">The skip version change check.</param>
    /// <returns>True if it is skip version change check.</returns>
    public boolean parmSkipVersionChangeCheck(boolean _skipVersionChangeCheck = skipVersionChangeCheck)
    {
        skipVersionChangeCheck = _skipVersionChangeCheck;

        return skipVersionChangeCheck;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold amount for India.
    /// </summary>
    /// <param name = "_taxWithholdAmount">The tax withhold amount for India.</param>
    /// <returns>The tax withhold amount for India.</returns>
    public AmountCur parmTaxWithholdAmount_IN(AmountCur _taxWithholdAmount = taxWithholdAmount)
    {
        taxWithholdAmount = _taxWithholdAmount;

        return taxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTaxWithholdType_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold type for India.
    /// </summary>
    /// <param name = "_taxWithholdType">The tax withhold type.</param>
    /// <returns>The tax withhold type.</returns>
    public TaxWithholdCodeType_IN parmTaxWithholdType_IN(TaxWithholdCodeType_IN _taxWithholdType = taxWithholdType)
    {
        taxWithholdType = _taxWithholdType;

        return taxWithholdType;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTotalTaxWithholdAmount_IN</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets tax withhold amount for India.
    /// </summary>
    /// <param name = "_totalTaxWithholdAmount">The tax withhold amount.</param>
    /// <returns>The tax withhold amount.</returns>
    public AmountCur parmTotalTaxWithholdAmount_IN(AmountCur _totalTaxWithholdAmount = totalTaxWithholdAmount)
    {
        totalTaxWithholdAmount = _totalTaxWithholdAmount;

        return totalTaxWithholdAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>remainAmountCur</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the customer vendor payment schedule line.
    /// </summary>
    /// <param name = "_custVendPaymentSchedLine">The customer vendor payment schedule line.</param>
    /// <param name = "amountCur">The amount currencies.</param>
    public void remainAmountCur(CustVendPaymentSchedLine _custVendPaymentSchedLine, AmountCur amountCur)
    {
        _custVendPaymentSchedLine.DueAmount += amountCur;
        if (invoiceAmount > 0)
        {
            _custVendPaymentSchedLine.DiscAmount = min(_custVendPaymentSchedLine.DueAmount, _custVendPaymentSchedLine.DiscAmount);
        }
        else
        {
            _custVendPaymentSchedLine.DiscAmount = max(_custVendPaymentSchedLine.DueAmount, _custVendPaymentSchedLine.DiscAmount);
        }
        _custVendPaymentSchedLine.update();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the amount.
    /// </summary>
    public abstract void setAmount()
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBuffer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the customer vendor payment schedule table buffer.
    /// </summary>
    public void setBuffer()
    {
        switch (custVendPaymSched.TableId)
        {
            case tableNum(CustPaymSched):
                select custPaymSchedLine
                    where custPaymSchedLine.ParentRecID == custVendPaymSched.RecId;
                custVendPaymSchedLine = custPaymSchedLine;
                break;

            case tableNum(VendPaymSched):
                select vendPaymSchedLine
                    where vendPaymSchedLine.FatherRecID == custVendPaymSched.RecId
                       && !vendPaymSchedLine.IsDeleted;
                custVendPaymSchedLine = vendPaymSchedLine;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setDueDate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the due date.
    /// </summary>
    public void setDueDate()
    {
        if (!dueDate)
        {
            dueDate = PaymTerm::find(paymTermId).due(invoiceDate, '', false, dueDateLimit);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPaymTerm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the terms of payment.
    /// </summary>
    /// <param name="_paymTermId">
    /// The terms of payment Id.
    /// </param>
    /// <returns>
    /// The payment term.
    /// </returns>
    protected PaymTerm setPaymTerm(PaymTermId _paymTermId)
    {
        return PaymTerm::find(_paymTermId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymTermFromSalesTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the terms of payment for sales totals.
    /// </summary>
    /// <param name="_paymTermId">
    /// The terms of payment Id.
    /// </param>
    /// <returns>
    /// The payment term.
    /// </returns>
    protected PaymTerm getPaymTermFromSalesTotals(PaymTermId _paymTermId)
    {
        return PaymTerm::find(_paymTermId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getPaymTermFromPurchTotals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the terms of payment for purch totals.
    /// </summary>
    /// <param name="_paymTermId">
    /// The terms of payment Id.
    /// </param>
    /// <returns>
    /// The payment term.
    /// </returns>
    protected PaymTerm getPaymTermFromPurchTotals(PaymTermId _paymTermId)
    {
        return PaymTerm::find(_paymTermId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs an instance of the <c>PaymSchedCalc</c> class.
    /// </summary>
    /// <param name = "_custVendPaymentSched">The customer vendor payment schedule.</param>
    /// <param name = "_custVendPaymentSchedLine">The customer vendor payment schedule line.</param>
    /// <param name = "_paymSched">The payment schedule.</param>
    /// <param name = "_instBilling">The instance billing.</param>
    /// <returns>The <c>PaymSchedCalc</c> class.</returns>
    public static PaymSchedCalc construct(CustVendPaymentSched _custVendPaymentSched,
                                   CustVendPaymentSchedLine _custVendPaymentSchedLine = _custVendPaymentSchedLine,
                                   PaymSched _paymSched = _paymSched,
                                   NoYes _instBilling = NoYes::No)
    {
        PaymSchedCalc paymSchedCalc;

        switch (_custVendPaymentSched.PaymBy)
        {
            case PaymSchedBy::Total :
                paymSchedCalc = new PaymSchedCalc_Total(_custVendPaymentSched, _paymSched);
                break;

            case PaymSchedBy::AmountByPayment :
                paymSchedCalc = new PaymSchedCalc_Amount(_custVendPaymentSched, _paymSched);
                break;

            case PaymSchedBy::NumOfPayment :
                if (_instBilling)
                {
                    // Split the qty based on the inst billing rules
                    paymSchedCalc = new MCRPaymSchedCalc_Qty_IB(_custVendPaymentSched, _paymSched);
                }
                else
                {
                    paymSchedCalc = new PaymSchedCalc_Qty(_custVendPaymentSched, _paymSched);
                }
                break;

            case PaymSchedBy::Specified :
                if (_instBilling)
                {
                    // Split the qty based on the inst billing rules
                    paymSchedCalc = new MCRPaymSchedCalc_Line_IB(_custVendPaymentSched, _paymSched);
                }
                else
                {
                    paymSchedCalc = new PaymSchedCalc_Line(_custVendPaymentSched, _paymSched);
                }
                break;

            default :
                paymSchedCalc = new PaymSchedCalc_Total(_custVendPaymentSched, _paymSched);
        }

        return paymSchedCalc;
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustInvoiceAmountsSplitPaym_IT</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adjust the invoiceTaxAmount and invoiceAmount.
    /// </summary>
    /// <param name="_addRemove">
    /// param _addRemove decides whether we need to add or remove splitpaym tax.
    /// </param>
    protected void adjustInvoiceAmountsSplitPaym_IT(AddRemove _addRemove)
    {
        if (_addRemove == AddRemove::Add)
        {
            invoiceTaxAmount += splitPaymSumTax_IT;
            invoiceAmount += splitPaymSumTax_IT;
        }
        else
        {
            invoiceTaxAmount -= splitPaymSumTax_IT;
            invoiceAmount -= splitPaymSumTax_IT;
        }

        this.setAmount(); // re-set using adjusted amounts
    }

]]></Source>
			</Method>
			<Method>
				<Name>adjustedWithholdAmount</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the proper adjusted withholding tax amount. In some special case the withholding tax amount should be rounded off.
    /// </summary>
    /// <param name="_withholdTaxAmount">
    /// The withholding tax amount to adjust.
    /// </param>
    /// <returns>The proper withholding tax amount.</returns>
    private AmountCur adjustedWithholdAmount(AmountCur _withholdTaxAmount)
    {
        if (taxWithholdType == TaxWithholdCodeType_IN::TCS
            && TaxWithholdEnableIncludeTCSInTotalFeatureToggle::isFeatureEnabled())
        {
            return CurrencyExchange::roundWithRuleType(
                _withholdTaxAmount,
                currencyCode,
                custVendPaymSched.TableId == tableNum(CustPaymSched) ?
                    CurrencyRoundingRuleType::SalesOrder :
                    CurrencyRoundingRuleType::PurchaseOrder);
        }
        else
        {
            return _withholdTaxAmount;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initDueDatefromInvoice</Name>
				<Source><![CDATA[
    private void initDueDatefromInvoice(CustFreeInvoiceCalcTotals _custFreeInvoiceCalcTotals, DueDate _baseDueDate)
    {
        if (_custFreeInvoiceCalcTotals.getInvoiceDueDate() != datenull())
        {
            dueDate = _custFreeInvoiceCalcTotals.getInvoiceDueDate();
        }
        else
        {
            dueDate = _baseDueDate;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>