<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>LedgerJournalFormTable</Name>
	<SourceCode>
		<Declaration><![CDATA[
using Microsoft.Dynamics.Platform.Integration.Office;

/// <summary>
///    The <c>LedgerJournalFormTable</c> class is a helper class for the <c>LedgerJournalTable</c> form.
///    It helps with form initialization and managing the enabled state of controls.
/// </summary>
class LedgerJournalFormTable extends JournalFormTable
{
    FormMenuButtonControl   ctrlPostJournalMenu;
    FormMenuButtonControl   ctrlApprovalMenu;

    // This is the lines menu button shown when the journal is in an approval state.
    FormMenuButtonControl     ctrlJournalLines_WorkFlowApproved;

    // This is one of the choices under the ctrlJournalLines_WorkFlowApproved menu
    // button. This opens the journal in a read-only mode.
    FormFunctionButtonControl ctrlJournalLinesReview;

    // This is one of the choices under the ctrlJournalLines_WorkFlowApproved menu button.
    // This reverts the workflow approvals state to not submitted so the journal can be edited.
    FormFunctionButtonControl ctrlJournalLinesEdit;

    // This is one of the choices under the ctrlJournalLines_WorkFlowApproved menu button.
    // This opens the journal in a read-only mode with the ability to process payments.
    FormFunctionButtonControl ctrlJournalLinesProcessPayment;

    // Opens the CustPaymEntry form in entry mode. This is an alternate way to
    // enter new customer payments.
    FormFunctionButtonControl ctrlCustPaymEntryButton;

    // <GEERU>
    FormFunctionButtonControl ctrlAssetPackingSlip;
    // </GEERU>

    // This is the option to show user-created journals only
    FormCheckBoxControl       ctrlShowUserCreatedOnly;

    FormDropDialogButtonControl ctrlOpenLinesInExcel;

    // Query
    QueryBuildRange         criteriaJournalName;
    QueryBuildRange         criteriaShowUserCreatedOnly;

    // The user is processing payments on an approved journal if true.
    boolean                 isProcessingPaymentOnApprovedJournal;

    boolean                 isWorkflowEnabledForJournalName;
    boolean                 isWorkflowEnabledStatusChanged;

    // Set to true if isProcessingPaymentOnApprovedJournal has been
    // specified by selecting either Review or ProcessPayments.
    boolean                 isWFApprovedModeSelected;

    // Set to the WorkflowWorkItem that could be associated to the
    // currently selected LedgerJournalTable record.
    WorkflowWorkItemTable   workflowWorkItemTable;

    // RecordSortedList to be used for multi-select posting.
    RecordSortedList        ledgerJournalTableList;

    #EECountryRegionCodes
    FactureSource_RU        factureSource;
    QueryBuildRange         criteriaRecId;
    QueryBuildRange         criteriaReportPeriod;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canLinesFormGeneratePayments</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the journal type supports generate payments on the lines form.
    /// </summary>
    /// <param name="_journalType">
    ///    The type of the journal.
    /// </param>
    /// <returns>
    ///    true if the lines form supports generate payments; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    This logic is needed because the workflow approvals feature has added a new lines button, which
    ///    allows the user to open a lines form in either review, edit or generate payments mode. Generate
    ///    payments mode should only be shown as an option if the lines form supports it.
    /// </remarks>
    public boolean canLinesFormGeneratePayments(LedgerJournalType _journalType)
    {
        switch (_journalType)
        {
            case LedgerJournalType::CustBillOfExchangeDraw, LedgerJournalType::CustPaymRemittance,
                 LedgerJournalType::CustBillOfExchangeRedraw, LedgerJournalType::CustPayment,
                 LedgerJournalType::VendPromissoryNoteDraw, LedgerJournalType::VendPromissoryNoteRedraw,
                 LedgerJournalType::PayrollDisbursement,
                 LedgerJournalType::VendPaymRemittance, LedgerJournalType::Payment:
                // This journal type supports generate payments.
                return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyMenuItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Defines the delegate to be used on the Ledger journal form when accessed by the General journal entry workspace.
    /// </summary>
    /// <param name="_formElement">The journal form containing the controls.</param>
    /// <param name="_allOpenPostedCombo">The Posted dropdown control on the Ledger journal form.</param>
    /// <param name="_showUserCreatedCheck">The user created only checkbox control on the Ledger journal form.</param>
    delegate void applyMenuItem(FormRun _formElement, FormComboBoxControl _allOpenPostedCombo, FormCheckBoxControl _showUserCreatedCheck)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines the delegate to be used on the Ledger journal form when accessed by the General journal entry workspace.
    /// </summary>
    /// <param name="_formElement">The target form for the queries.</param>
    /// <param name="_query">A query on data source table LedgerJournalTable.</param>
    delegate void applyQuery(FormRun _formElement, Query _query)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyMenuItemDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Calls the delegate so the Ledger journal table form has access to it.
    /// </summary>
    /// <param name="_formElement">The journal form containing the controls.</param>
    /// <param name="_allOpenPostedCombo">The Posted dropdown control on the Ledger journal form.</param>
    /// <param name="_showUserCreatedCheck">The user created only checkbox control on the Ledger journal form.</param>
    public void applyMenuItemDelegate(FormRun _formElement, FormComboBoxControl _allOpenPostedCombo, FormCheckBoxControl _showUserCreatedCheck)
    {
        this.applyMenuItem(_formElement, _allOpenPostedCombo, _showUserCreatedCheck);
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyQueryDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calls the delegate so the Ledger journal table form has access to it.
    /// </summary>
    /// <param name="_formElement">The target form for the queries.</param>
    /// <param name="_query">A query on data source table LedgerJournalTable.</param>
    public void applyQueryDelegate(FormRun _formElement, Query _query)
    {
        this.applyQuery(_formElement, _query);
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceActivePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs any business logic that is required after the "super" call in the active method of the
    ///    data source of the <c>LedgerJournalTable</c> form.
    /// </summary>
    /// <remarks>
    ///    This method is only used in this class and called from the <c>LedgerJournalTable</c> form.
    /// </remarks>
    public void datasourceActivePost()
    {
        //
        // Set the workflowWorItemTable property to the workflow work item
        // currently associated to the selected LedgerJournalTable record using the
        // FormRun.getActiveWorkflowWorkItem(). An empty buffer is possible.
        //
        // FormRun.getActiveWorkflowWorkItem() is a Workflow Infrastructure method
        // for retrieving the current workflow work item associated to a specific
        // workflow instance.
        //
        this.parmWorkflowWorkItemTable(formRun.getActiveWorkflowWorkItem());

        this.enableButtonsActive();
        this.enableFieldsActive();
        this.refreshBlockStatus();

        if (isWorkflowEnabledStatusChanged || this.parmIsWorkflowEnabledForJournalName())
        {
            // update the workflow controls to ensure button width aligns based on the updated button group
            formRun.updateWorkflowControls();
            isWorkflowEnabledStatusChanged = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceActivePre</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Performs any business logic required before the "super" call in the active event of the data source
    ///    of the <c>LedgerJournalTable</c> form.
    /// </summary>
    /// <remarks>
    ///    This method has been overridden in order to move method calls. This minor architectural change is
    ///    required to make information needed from an active workflow work item of a journal available to the
    ///    methods that establish the enabled state of the buttons and fields of the form.
    /// </remarks>
    void datasourceActivePre()
    {
        if (journalTableData.canBeAutoUnlocked(!formRun.inViewMode()))
        {
            journalTableData.updateBlock(JournalBlockLevel::None,JournalBlockLevel::None);
            journalTable_ds.setCurrent();
            journalTable_ds.refresh();
        }

        if (! journalTypeFixed)
        {
            this.initControls(journalTable.JournalType);

            journalTypeId = journalTable.JournalType;
        }

        this.initDatasourceAllow();

        journalTable_ds.allowDelete(journalTable_ds.allowDelete() && !journalTable.Posted);
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceCreatePost</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Sets the <c>JournalTable.JournalNameId</c> from the <c>ProjParameters</c> table.
    /// </summary>
    /// <remarks>
    ///     Currently only the project journal type Id of Cost is being used to set the journal name id.
    /// </remarks>
    public void datasourceCreatePost()
    {
        super();

        if (this.journalTypeId() == LedgerJournalType::Cost)
        {
            journalTable.JournalNameId = ProjParameters::find().ExpenseJournalNameId;
        }

        if (this.isIntercompanyJournal())
        {
            journalTable.TaxObligationCompany = TaxParameters::find().TaxObligationCompany;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceExecuteQueryPre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets an additional query range value before executing the query.
    /// </summary>
    void datasourceExecuteQueryPre()
    {
        // <GEERU>
        RTax25RegisterJournalTable  registerJournalTable;
        // </GEERU>

        super();

        // If show user-created only is checked, set the range values to the current user id
        criteriaShowUserCreatedOnly.value(ctrlShowUserCreatedOnly.checked() ? ("(currentUserId())") : '');

        // <GEERU>
        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (criteriaRecId && factureSource)
            {
                criteriaRecId.value(factureSource.jourRange());
            }

            if (criteriaReportPeriod)
            {
                registerJournalTable = formRun.args().record();
                criteriaReportPeriod.value(queryValue(registerJournalTable.EndDate));
            }
        }
        // </GEERU>
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceInitPost</Name>
				<Source><![CDATA[
    void datasourceInitPost(JournalTableMap _journalTable)
    {
        this.initFactureSource_RU();

        super(_journalTable);

        this.clearJournalLinesDynalinks();
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceLinkActivePre</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds project information to the query before <c>linkActive</c> is ran.
    /// </summary>
    public void datasourceLinkActivePre()
    {
        QueryBuildDataSource    qbds;
        ProjTable               callerRecord;

        if (formRun && formRun.args().dataset() && formRun.args().dataset() == tableNum(ProjTable))
        {
            callerRecord = formRun.args().record() as ProjTable;
            qbds = journalTable_ds.query().dataSourceNo(1).addDataSource(tableNum(LedgerJournalTrans));
            qbds.joinMode(JoinMode::ExistsJoin);

            qbds.addRange(fieldNum(LedgerJournalTrans, LedgerDimension)).value(queryValue(LedgerDynamicAccountHelper::getDynamicAccountFromAccountNumber(callerRecord.ProjId, LedgerJournalACType::Project)));
            qbds.relations(true);
        }

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>datasourceMarkChangedPost</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the post and delete button state.
    /// </summary>
    public void datasourceMarkChangedPost()
    {
        this.setPostAndDeleteButtonState();
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPostAndDeleteButtonState</Name>
				<Source><![CDATA[
    private void setPostAndDeleteButtonState()
    {
        boolean changeButtonState = journalTableData.blockLevel() == JournalBlockLevel::None &&
                !formRunLines &&
                journalTable.JournalNameId;

        boolean enablePostButton, enableDeleteButton;

        if (changeButtonState)
        {
            // Check if the current record is the only record marked/selected to save iterating
            // the datasource records (perf)
            if (MultiSelectionHelper::currentRecordOnlySelected(journalTable_ds))
            {
                enablePostButton = this.canLedgerJournalTableBePosted(journalTable);

                enableDeleteButton = this.canLedgerJournalTableBeDeleted(journalTable);
            }
            else
            {
                container buttonsState = this.setPostAndDeleteButtonsStateMultiSelect();

                enablePostButton = conPeek(buttonsState, 1);
                enableDeleteButton = conPeek(buttonsState, 2);
            }
        }

        if (ctrlPostJournalMenu)
        {
            ctrlPostJournalMenu.enabled(enablePostButton);
        }

        if (ctrlPostJournal)
        {
            ctrlPostJournal.enabled(enablePostButton);
        }

        journalTable_ds.allowDelete(enableDeleteButton);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPostAndDeleteButtonsStateMultiSelect</Name>
				<Source><![CDATA[
    private container setPostAndDeleteButtonsStateMultiSelect()
    {
        boolean enablePostingButton = true;
        boolean enableDeleteButton = true;

        MultiSelectionHelper helper = MultiSelectionHelper::construct();
        helper.parmDatasource(this.journalTable_DS());

        LedgerJournalTable ledgerJournalTable = helper.getFirst();
        DataAreaId firstDataArea = ledgerJournalTable.DataAreaId;
        boolean multiCompanyFeatureEnabled = LedgerJournalMultiCompanyPostFeature::isEnabled();


        while (ledgerJournalTable)
        {
            if (ledgerJournalTable.DataAreaId != firstDataArea)
            {
                if (!multiCompanyFeatureEnabled)
                {
                    enablePostingButton = false;
                }

                enableDeleteButton = false;
            }

            if (enableDeleteButton)
            {
                enableDeleteButton = this.canLedgerJournalTableBeDeleted(ledgerJournalTable);
            }

            if (enablePostingButton)
            {
                if (multiCompanyFeatureEnabled)
                {
                    changecompany(ledgerJournalTable.DataAreaId)
                    {
                        if (this.canLedgerJournalTableBePosted(ledgerJournalTable) == false)
                        {
                            enablePostingButton = false;
                        }
                    }
                }
                else
                {
                    if (this.canLedgerJournalTableBePosted(ledgerJournalTable) == false)
                    {
                        enablePostingButton = false;
                    }
                }
            }

            if (enableDeleteButton == false && enablePostingButton == false)
            {
                break;
            }

            ledgerJournalTable = helper.getNext();
        }

        return [enablePostingButton, enableDeleteButton];
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLedgerJournalTableBePosted</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the <c>LedgerJournalTable</c> transaction can be posted.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> record.
    /// </param>
    /// <returns>
    /// Returns true if the transaction can be posted; otherwise, false.
    /// </returns>
    [Wrappable(true)]
    protected final boolean canLedgerJournalTableBePosted(LedgerJournalTable _ledgerJournalTable)
    {
        boolean canBePosted;

        if (_ledgerJournalTable.isInWFApprovalProcess())
        {
            canBePosted = !_ledgerJournalTable.Posted && _ledgerJournalTable.isWFApprovalApproved();
        }
        else
        {
            canBePosted = !_ledgerJournalTable.Posted && _ledgerJournalTable.approved();
        }

        return canBePosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLedgerJournalTableBeDeleted</Name>
				<Source><![CDATA[
    private boolean canLedgerJournalTableBeDeleted(LedgerJournalTable _ledgerJournalTable)
    {
        boolean canBeDeleted;

        if (_ledgerJournalTable.isInWFApprovalProcess())
        {
            canBeDeleted = (_ledgerJournalTable.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::NotSubmitted || _ledgerJournalTable.Posted) ? false : true ;
        }
        else
        {
            canBeDeleted = _ledgerJournalTable.Posted ? false : true;
        }

        return canBeDeleted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>designSelectionChangeShowUserCreateOnly</Name>
				<Source><![CDATA[
    /// <summary>
    /// Executes the query when the show user-created only selection changes.
    /// </summary>
    void designSelectionChangeShowUserCreateOnly()
    {
        // Don't execute the query when initalizing the form's controls
        if (journalTable_ds && journalTable_ds.queryRun())
        {
            this.datasourceApplyFilter();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableButtonsActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Enables or disables buttons on the form.
    /// </summary>
    /// <param name="_enableInfolog">
    ///    A Boolean value that indicates whether Infolog messages are enabled; optional.
    /// </param>
    /// <remarks>
    ///    Setting the <paramref name="_enableInfolog" /> parameter to true indicates that Infolog messages
    ///    are enabled
    /// </remarks>
    public void enableButtonsActive(boolean _enableInfolog = true)
    {
        LedgerJournalTable  ledgerJournalTable = journalTable;
        boolean enabled = journalTableData.blockLevel() == JournalBlockLevel::None &&
            !formRunLines &&
            journalTable.JournalNameId;

        boolean isClassicApprovalsEnabled = ledgerJournalTable.RecId != 0 &&
            ledgerJournalTable.ledgerJournalName().ApproveActive; // Flag that indicates whether or not non-workflow approvals is enabled.

        super(_enableInfolog);

        this.setPostAndDeleteButtonState();

        if (ctrlApprovalMenu)
        {
            // Enable if the approvals button if classic approvals are enabled, the journal is not in a workflow approvals
            // process and the previous conditions (enabled flag) are met.
            ctrlApprovalMenu.enabled(enabled &&
                isClassicApprovalsEnabled &&
                !ledgerJournalTable.isInWFApprovalProcess() &&
                !ledgerJournalTable.Posted);
        }

        if (ctrlJournalLines_WorkFlowApproved)
        {
            ctrlJournalLines_WorkFlowApproved.enabled(enabled);
        }

        if (ctrlCustPaymEntryButton != null)
        {
            if (ledgerJournalTable.isInWFApprovalProcess())
            {
                ctrlCustPaymEntryButton.enabled(
                    enabled &&
                    (!ledgerJournalTable.Posted) &&
                    ledgerJournalTable.isWFUserPermittedToEdit(workflowWorkItemTable));
            }
            else
            {
                ctrlCustPaymEntryButton.enabled(enabled &&
                    (!ledgerJournalTable.Posted) &&
                    (!ledgerJournalTable.Approver));
            }
        }

        if (ctrlOpenLinesInExcel)
        {
            ctrlOpenLinesInExcel.enabled(enabled && this.isOpenLinesInExcelEnabled());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>enableFieldsActive</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Manages the edit state for the data source.
    /// </summary>
    public void enableFieldsActive()
    {
        LedgerJournalTable ledgerJournalTable = journalTable;

        super();

        if (ledgerJournalTable.isInWFApprovalProcess() &&
            !ledgerJournalTable.isWFUserPermittedToEdit(this.parmWorkflowWorkItemTable()))
        {
            // The journal is not editable if it's in workflow approvals and the current
            // user does not have permission to edit it.
            journalTable_ds.allowEdit(false);
        }

        if (ledgerJournalTable.isInWFApprovalProcess() &&
            ledgerJournalTable.WorkflowApprovalStatus != LedgerJournalWFApprovalStatus::NotSubmitted)
        {
            // The journal is not deletable if it's in workflow approvals and in a state other
            // than not submitted.
            journalTable_ds.allowDelete(false);
        }

        // Payroll disbursement journals are generated through the Sumbit payments process.
        if (ledgerJournalTable.JournalType == LedgerJournalType::PayrollDisbursement)
        {
            journalTable_ds.allowCreate(false);
            journalTable_ds.allowDelete(false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initAllOpenPostedFromCaller</Name>
				<Source><![CDATA[
    protected void initAllOpenPostedFromCaller()
    {
        if (factureSource)
        {
            ctrlAllOpenPosted.selection(AllOpenPosted::All);
        }
        else
        {
            super();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initControls</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the menu items on the lines-related controls.
    /// </summary>
    /// <param name="_journalTypeId">
    ///    The journal type for which to initialize the controls.
    /// </param>
    /// <remarks>
    ///    The <paramref name="_journalTypeId" /> parameter is usually the type of the currently selected
    ///    journal on the <c>LedgerJournalTable</c> form which can be accessed through the <c>JournalType</c>
    ///    table.
    /// </remarks>
    protected void initControls(Integer _journalTypeId)
    {
        str menuItemStr;

        super(_journalTypeId);

        menuItemStr = journalTableData.journalStatic().menuItemStrLines(_journalTypeId);

        if (ctrlJournalLinesReview)
        {
            ctrlJournalLinesReview.menuItemName(journalTableData.journalStatic().menuItemStrLines(_journalTypeId));
        }

        if (ctrlJournalLinesEdit)
        {
            ctrlJournalLinesEdit.menuItemName(journalTableData.journalStatic().menuItemStrLines(_journalTypeId));
        }

        if (ctrlJournalLinesProcessPayment)
        {
            ctrlJournalLinesProcessPayment.menuItemName(journalTableData.journalStatic().menuItemStrLines(_journalTypeId));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>initFactureSource_RU</Name>
				<Source><![CDATA[
    #ISOCountryRegionCodes
    protected void initFactureSource_RU()
    {
        Object    caller;
        DictClass dict;

        if (formRun && formRun.args().caller() && !factureSource &&
            SysCountryRegionCode::isLegalEntityInCountryRegion([ #isoRU ]))
        {
            caller = formRun.args().caller();
            dict   = new DictClass(classIdGet(caller));

            while (dict && dict.id() != classNum(Object))
            {
                if (dict.id() == classNum(FactureSource_RU))
                {
                    this.parmFactureSource_RU(caller);
                    break;
                }

                dict = new DictClass(dict.extend());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isIntercompanyJournal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets a value that indicates if the journal supports intercompany transactions.
    /// </summary>
    /// <returns>
    /// true if the journal supports intercompany transactions; otherwise, false.
    /// </returns>
    protected boolean isIntercompanyJournal()
    {
        LedgerJournalTable ledgerJournalTable;

        ledgerJournalTable = journalTableData.journalTable();
        if (isConfigurationkeyEnabled(configurationKeyNum(LedgerAdvIntercompanyAccounting)) &&
            (ledgerJournalTable.JournalType == LedgerJournalType::Daily ||
            ledgerJournalTable.JournalType == LedgerJournalType::VendInvoiceRegister ||
            ledgerJournalTable.JournalType == LedgerJournalType::Approval ||
            (ledgerJournalTable.JournalType == LedgerJournalType::Periodic)))
        {
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isMultiSelection</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether there is a multiselection on the <c>LedgerJournalTable</c> form.
    /// </summary>
    /// <returns>
    ///    true if the <c>ledgerJournalTableList</c> contains <c>LedgerJournalTable</c> records; otherwise,
    ///    false.
    /// </returns>
    public boolean isMultiSelection()
    {
        boolean             isMultiSelection = false;
        LedgerJournalTable  ledgerJournalTableLocal;

        ledgerJournalTableList = new RecordSortedList(tableNum(LedgerJournalTable));
        ledgerJournalTableList.sortOrder(
            fieldNum(LedgerJournalTable, DataAreaId), 
            fieldNum(LedgerJournalTable, JournalNum));

        for (ledgerJournalTableLocal = this.journalTable_DS().getFirst(true); ledgerJournalTableLocal; ledgerJournalTableLocal = this.journalTable_DS().getNext())
        {
            if (!ledgerJournalTableLocal.Posted)
            {
                ledgerJournalTableList.ins(ledgerJournalTableLocal);
            }
        }

        if (ledgerJournalTableList.len() > 1)
        {
            isMultiSelection = true;
        }

        return isMultiSelection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOpenLinesInExcelEnabled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the OpenLinesInExcel button is enabled.
    /// </summary>
    /// <returns>True if an excel template exists for the document; otherwise, false.</returns>
    public boolean isOpenLinesInExcelEnabled()
    {
        return LedgerJournalExcelTemplate::isJournalTypeSupported(this.journalTypeId());
    }

]]></Source>
			</Method>
			<Method>
				<Name>assertSelectedJournalsNotInUse</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks all selected journals and determines if any are in use.
    /// </summary>
    public void assertSelectedJournalsNotInUse()
    {
        LedgerJournalTable ledgerJournalTableLocal;

        for (ledgerJournalTableLocal = this.journalTable_DS().getFirst(true); ledgerJournalTableLocal; ledgerJournalTableLocal = this.journalTable_DS().getNext())
        {
            LedgerJournalTable ledgerJournalTableTmp = journalTableData.journalStatic().findJournalTable(ledgerJournalTableLocal.JournalNum, true);
            if (!this.isJournalFree(ledgerJournalTableTmp))
            {
                journalTable.data(ledgerJournalTableTmp);

                if (ledgerJournalTableTmp.RecId == journalTable.RecId)
                {
                    this.journalTable_DS().setCurrent();
                    this.journalTable_DS().active();
                }

                throw error(strFmt("@SYS18418", ledgerJournalTableTmp.JournalNum, new xSession(ledgerJournalTableTmp.SessionId).userId()));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>multiSelectPost</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Starts the posting process of a multiselection of journals.
    /// </summary>
    /// <param name="_transferErrors">
    ///    A <c>NoYes</c> enumeration value that controls how journal posting errors are handled; optional.
    /// </param>
    /// <remarks>
    ///    This method will start the posting process of a multiselection of journals by using the general
    ///    ledger, periodic, and post journals functionality.
    /// </remarks>
    public void multiSelectPost(NoYes _transferErrors = NoYes::No)
    {
        LedgerJournalMultiPost::multiSelectPost(this, ledgerJournalTableList, _transferErrors);
    }

]]></Source>
			</Method>
			<Method>
				<Name>multiSelectValidate</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Validates a multiselection of journals.
    /// </summary>
    /// <remarks>
    ///    This method will validate a multiselection of journals by using the same process that is used by a
    ///    single journal validation.
    /// </remarks>
    public void multiSelectValidate()
    {
        LedgerJournalTable  ledgerJournalTable;

        Args args = new Args();
        args.caller(this.formRun());

        MenuFunction validateMenuFunction = new MenuFunction(this.parmCtrlCheckJournal().menuItemName(), MenuItemType::Action);
        boolean ledgerJournalTableFound = ledgerJournalTableList.first(ledgerJournalTable);

        //  Validate each journal in the RecordSortedList.
        while (ledgerJournalTableFound)
        {
            args.record(ledgerJournalTable);
            changecompany(ledgerJournalTable.DataAreaId)
            {
                validateMenuFunction.run(args);
            }
            ledgerJournalTableFound = ledgerJournalTableList.next(ledgerJournalTable);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new(FormRun _formRun)
    {
        isWorkflowEnabledForJournalName = false;

        super(_formRun);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    /// Constructs a new <c>LedgerJournalFormTable</c> object.
    /// </summary>
    /// <param name="_formRun">Instance of the FormRun object.</param>
    /// <returns>A new instance of the <c>LedgerJournalFormTable</c> object.</returns>
    public static LedgerJournalFormTable construct(FormRun _formRun)
    {
        switch (_formRun.args().menuItemName())
        {
            case menuitemDisplayStr(CustPaymentAssignedToMeListPage):
            case menuitemDisplayStr(VendPaymentAssignedToMeListPage):
                return new LedgerJournalFormTable_CustVendPaymListPage(_formRun);

            case menuitemDisplayStr(VendInvoiceJournalNotPostedAssignedToMe):
                return new LedgerJournalFormTable_VendInvoiceJourListPage(_formRun);

            default:
                return new LedgerJournalFormTable(_formRun);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlApprovalMenu</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ctrlApprovalMenu</c> class variable.
    /// </summary>
    /// <param name="_ctrlApprovalMenu">
    ///    The control to point the variable to; optional.
    /// </param>
    /// <returns>
    ///    The <c>ctrlApprovalMenu</c> class variable.
    /// </returns>
    public FormMenuButtonControl parmCtrlApprovalMenu(FormMenuButtonControl _ctrlApprovalMenu = ctrlApprovalMenu)
    {
        ctrlApprovalMenu = _ctrlApprovalMenu;
        return ctrlApprovalMenu;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlAssetPackingSlip_LT</Name>
				<Source><![CDATA[
    public FormFunctionButtonControl parmCtrlAssetPackingSlip_LT(FormFunctionButtonControl _assetPackingSlip = ctrlAssetPackingSlip)
    {
        ctrlAssetPackingSlip = _assetPackingSlip;
        return ctrlAssetPackingSlip;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlCustPaymEntryButton</Name>
				<Source><![CDATA[
    public FormFunctionButtonControl parmCtrlCustPaymEntryButton(
        FormFunctionButtonControl _ctrlCustPaymEntryButton = ctrlCustPaymEntryButton)
    {
        ctrlCustPaymEntryButton = _ctrlCustPaymEntryButton;

        return ctrlCustPaymEntryButton;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlJournalLines_WorkFlowApproved</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ctrlJournalLines_WorkFlowApproved</c> class variable.
    /// </summary>
    /// <param name="_ctrlJournalLines_WorkFlowApproved">
    ///    The control to point the variable to; optional.
    /// </param>
    /// <returns>
    ///    The <c>ctrlJournalLines_WorkFlowApproved</c> class variable.
    /// </returns>
    public FormMenuButtonControl parmCtrlJournalLines_WorkFlowApproved(FormMenuButtonControl _ctrlJournalLines_WorkFlowApproved = ctrlJournalLines_WorkFlowApproved)
    {
        ctrlJournalLines_WorkFlowApproved = _ctrlJournalLines_WorkFlowApproved;
        return _ctrlJournalLines_WorkFlowApproved;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlJournalLinesEdit</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ctrlJournalLinesEdit</c> class variable.
    /// </summary>
    /// <param name="_ctrlJournalLinesEdit">
    ///    The control to point the variable to; optional.
    /// </param>
    /// <returns>
    ///    The <c>ctrlJournalLinesEdit</c> class variable.
    /// </returns>
    public FormFunctionButtonControl parmCtrlJournalLinesEdit(FormFunctionButtonControl _ctrlJournalLinesEdit = ctrlJournalLinesEdit)
    {
        ctrlJournalLinesEdit = _ctrlJournalLinesEdit;
        return ctrlJournalLinesEdit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlJournalLinesGeneratePayment</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ctrlJournalLinesGeneratePayment</c> class variable.
    /// </summary>
    /// <param name="_ctrlJournalLinesProcessPayment">
    ///    The control to point the variable to; optional.
    /// </param>
    /// <returns>
    ///    The <c>ctrlJournalLinesGeneratePayment</c> class variable.
    /// </returns>
    public FormFunctionButtonControl parmCtrlJournalLinesGeneratePayment(FormFunctionButtonControl _ctrlJournalLinesProcessPayment = ctrlJournalLinesProcessPayment)
    {
        ctrlJournalLinesProcessPayment = _ctrlJournalLinesProcessPayment;
        return ctrlJournalLinesProcessPayment;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlJournalLinesReview</Name>
				<Source><![CDATA[
    //// <summary>
    //// Gets or sets the ctrlJournalLinesReview class field.
    //// </summary>
    //// <param name="_ctrlJournalLinesReview">
    //// The control to point the field to.
    //// </param>
    //// <returns>
    //// The ctrlJournalLinesReview class field.
    //// </returns>
    public FormFunctionButtonControl parmCtrlJournalLinesReview(FormFunctionButtonControl _ctrlJournalLinesReview = ctrlJournalLinesReview)
    {
        ctrlJournalLinesReview = _ctrlJournalLinesReview;
        return ctrlJournalLinesReview;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlPostJournalMenu</Name>
				<Source><![CDATA[
    FormMenuButtonControl parmCtrlPostJournalMenu(FormMenuButtonControl _postJournal = ctrlPostJournalMenu)
    {
        ctrlPostJournalMenu = _postJournal;
        return ctrlPostJournalMenu;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlShowUserCreatedOnly</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the <c>ctrlShowUserCreatedOnly</c> field.
    /// </summary>
    /// <param name="_ctrlShowUserCreatedOnly">
    ///    The control to point the field to; optional.
    /// </param>
    /// <returns>
    ///    The <c>ctrlShowUserCreatedOnly</c> field.
    /// </returns>
    public FormCheckBoxControl parmCtrlShowUserCreatedOnly(FormCheckBoxControl _ctrlShowUserCreatedOnly = ctrlShowUserCreatedOnly)
    {
        ctrlShowUserCreatedOnly = _ctrlShowUserCreatedOnly;
        return ctrlShowUserCreatedOnly;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCtrlOpenLinesInExcel</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the open lines in excel <c>FormDropDialogButtonControl</c> control.
    /// </summary>
    /// <param name = "_openLinesInExcel">The control reference.</param>
    /// <returns>The <c>FormDropDialogButtonControl</c> object.</returns>
    public FormDropDialogButtonControl parmCtrlOpenLinesInExcel(FormDropDialogButtonControl _openLinesInExcel = ctrlOpenLinesInExcel)
    {
        ctrlOpenLinesInExcel = _openLinesInExcel;
        return ctrlOpenLinesInExcel;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFactureSource_RU</Name>
				<Source><![CDATA[
    public FactureSource_RU parmFactureSource_RU(FactureSource_RU _factureSource = factureSource)
    {
        factureSource = _factureSource;

        return factureSource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsProcessingPaymentOnApprovedJounal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the user can process payments for a workflow approvals approved journal.
    /// </summary>
    /// <param name="_isProcessingPaymentOnApprovedJournal">
    ///    A Boolean value that determines whether the user can process payments for a workflow approvals
    ///    approved journal; optional.
    /// </param>
    /// <returns>
    ///    true if the journal is non-editable in a workflow approvals approved state and the user has chosen
    ///    to process payments; otherwise, false.
    /// </returns>
    public boolean parmIsProcessingPaymentOnApprovedJounal(boolean _isProcessingPaymentOnApprovedJournal = isProcessingPaymentOnApprovedJournal)
    {
        isProcessingPaymentOnApprovedJournal = _isProcessingPaymentOnApprovedJournal;
        return _isProcessingPaymentOnApprovedJournal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsWFApprovedModeSelected</Name>
				<Source><![CDATA[
    public boolean parmIsWFApprovedModeSelected(boolean _isWFApprovedModeSelected = isWFApprovedModeSelected)
    {
        isWFApprovedModeSelected = _isWFApprovedModeSelected;
        return isWFApprovedModeSelected;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsWorkflowEnabledForJournalName</Name>
				<Source><![CDATA[
    public boolean parmIsWorkflowEnabledForJournalName(
        boolean _isWorkflowEnabledForJournalName = isWorkflowEnabledForJournalName)
    {
        // Check for going between Workflow enabled and disabled records
        if (isWorkflowEnabledForJournalName != _isWorkflowEnabledForJournalName)
        {
            isWorkflowEnabledStatusChanged = true;
        }

        isWorkflowEnabledForJournalName = _isWorkflowEnabledForJournalName;
        return isWorkflowEnabledForJournalName;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmWorkflowWorkItemTable</Name>
				<Source><![CDATA[
    public WorkflowWorkItemTable parmWorkflowWorkItemTable(WorkflowWorkItemTable _workflowWorkItemTable = workflowWorkItemTable)
    {
        workflowWorkItemTable = _workflowWorkItemTable;
        return workflowWorkItemTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>queryAddRange</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds an additional query range to the query.
    /// </summary>
    void queryAddRange()
    {
        QueryBuildDataSource qbds;

        super();

        criteriaShowUserCreatedOnly = SysQuery::findOrCreateRange(rangeDataSource, fieldNum(LedgerJournalTable, CreatedBy));

        if (criteriaPosted)
        {
            // Lock posted range from the filter pane so the quick filter doesn't become out of sync
            criteriaPosted.status(RangeStatus::Locked);
        }

        if (SysCountryRegionCode::isLegalEntityInCountryRegion([#isoRU]))
        {
            if (factureSource)
            {
                criteriaRecId = journalTable_ds.query().dataSourceNo(1).addRange(fieldNum(LedgerJournalTable, RecId));
            }

            this.initJournalTypeFromCaller();

            if ((this.journalTypeId() == LedgerJournalType::RTax25TaxDiffByBalance
                    || this.journalTypeId() == LedgerJournalType::RTax25
                    || this.journalTypeId() == LedgerJournalType::RTax25AmountDifference
                    || this.journalTypeId() == LedgerJournalType::RTax25ExchDifference
                    || this.journalTypeId() == LedgerJournalType::RTax25DebtDebitReserve
                    || this.journalTypeId() == LedgerJournalType::RAssetAssessedTax
                    || this.journalTypeId() == LedgerJournalType::RAssetTransportTax
                    || this.journalTypeId() == LedgerJournalType::RAssetLandTax)
                && formRun.args().record()
                && formRun.args().dataset() == tableNum(RTax25RegisterJournalTable))
            {
                // Find the existing or add the child table link to the query, then find or apply a range
                qbds = journalTable_ds.query().dataSourceTable(tableNum(LedgerJournalTable_W));
                if (!qbds)
                {
                    qbds = LedgerJournalTable_W::addToQuery(journalTable_ds.query().dataSourceNo(1));
                }

                criteriaReportPeriod = SysQuery::findOrCreateRange(qbds, fieldNum(LedgerJournalTable_W, ReportPeriod_RU));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearJournalLinesDynalinks</Name>
				<Source><![CDATA[
    private void clearJournalLinesDynalinks()
    {
        // If navigating from the Journal lines form, the dynalink must be cleared to not filter the datasource
        // by Journal number.
        if (formRun.args().record() is LedgerJournalTrans)
        {
            QueryBuildDataSource ledgerJournalTableDS = journalTable_ds.query().dataSourceTable(tableNum(LedgerJournalTable));
            ledgerJournalTableDS.clearDynalinks();

            formRun.args().record(null);
            formRun.args().lookupRecord(null);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>openExcelTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Open the Excel template for the form
    /// </summary>
    /// <param name = "_excelTemplate">
    /// The <c>LedgerIJournalExcelTemplate</c> instance.
    /// </param>
    public void openExcelTemplate(LedgerIJournalExcelTemplate _excelTemplate)
    {
        if (_excelTemplate == null)
        {
            throw error(error::missingParameter(formRun));
        }

        LedgerJournalTable ledgerJournalTable = journalTable;

        DocuTemplate template = DocuTemplate::findTemplate(OfficeAppApplicationType::Excel, _excelTemplate.documentTemplateName());

        // Ensure the template was present
        if (template && template.TemplateID == _excelTemplate.documentTemplateName())
        {
            this.initializeOpenExcelTemplate();

            Map filtersToApply = LedgerJournalExcelTemplate::getFilterMapForTemplate(_excelTemplate, ledgerJournalTable);

            // Generate the workbook using the template and filters
            DocuTemplateRender renderer = new DocuTemplateRender();
            renderer.templateChanged  += eventhandler(this.templateChanged);
            str documentUrl = renderer.renderTemplateToStorage(template, filtersToApply, OfficeTrimmable::construct());

            // Pass the workbook to the user
            if (documentUrl)
            {
                Browser b = new Browser();
                b.navigate(documentUrl, false, false);
            }
            else
            {
                error(strFmt("@ApplicationFoundation:DocuTemplateGenerationFailed", _excelTemplate.documentTemplateName()));
            }
        }
        else
        {
            warning(strFmt("@ApplicationFoundation:DocuTemplateNotFound", _excelTemplate.documentTemplateName()));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>verifyCanDelete</Name>
				<Source><![CDATA[
    /// <summary>
    /// Verify the selected journal is able to be deleted.
    /// </summary>
    /// <param name = "_suppressPrompt">A flag to show or hide the delete journal prompt.</param>
    /// <returns>true if the journal can be deleted; false if it cannot.</returns>
    public boolean verifyCanDelete(boolean _suppressPrompt)
    {
        boolean canDelete = true;

        LedgerJournalTable ledgerJournalTable = journalTable;

        if (ledgerJournalTable.Posted || ledgerJournalTable.JournalType == LedgerJournalType::VendInvoicePool)
        {
            canDelete = checkFailed(strFmt("@SYS4004099", ledgerJournalTable.JournalNum));
        }

        if (canDelete && ledgerJournalTable.RecId)
        {
            if (!_suppressPrompt &&
                        (Box::yesNo(strFmt("@SYS71705", ledgerJournalTable.JournalNum), DialogButton::No) == DialogButton::No))
            {
                canDelete = false;
            }
        }

        canDelete = canDelete && this.checkTransactionPaymentStatus(ledgerJournalTable);

        return canDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransactionPaymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the payment status on the transaction.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> table buffer.
    /// </param>
    /// <returns>
    /// true if the transaction's payment status is None or Rejected; otherwise, false.
    /// </returns>
    protected boolean checkTransactionPaymentStatus(LedgerJournalTable _ledgerJournalTable)
    {
        boolean returnValue = true;

        LedgerJournalTrans ledgerJournalTrans = this.getLedgerJournalTransForPaymentStatus(_ledgerJournalTable);

        if (ledgerJournalTrans)
        {
            returnValue = checkFailed(this.getErrorMessageForTransactionPaymentStatus());
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLedgerJournalTransForPaymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a journal line that has a payment status that is not None or Rejected.
    /// </summary>
    /// <param name = "_ledgerJournalTable">
    /// The <c>LedgerJournalTable</c> table buffer.
    /// </param>
    /// <returns>
    /// A <c>LedgerJournalTrans</c> table buffer.
    /// </returns>
    protected LedgerJournalTrans getLedgerJournalTransForPaymentStatus(LedgerJournalTable _ledgerJournalTable)
    {
        LedgerJournalTrans ledgerJournalTrans;

        select firstonly RecId from ledgerJournalTrans
                     where ledgerJournalTrans.JournalNum == _ledgerJournalTable.JournalNum
                        && ledgerJournalTrans.PaymentStatus != CustVendPaymStatus::None
                        && ledgerJournalTrans.PaymentStatus != CustVendPaymStatus::Rejected;
        
        return ledgerJournalTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getErrorMessageForTransactionPaymentStatus</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the error message string for transaction payment status.
    /// </summary>
    /// <returns>
    /// The error message string.
    /// </returns>
    protected str getErrorMessageForTransactionPaymentStatus()
    {
        return strFmt("@SYS68189", CustVendPaymStatus::None, CustVendPaymStatus::Rejected);
    }

]]></Source>
			</Method>
			<Method>
				<Name>customizeOfficeMenuOptions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Customizes the options used to populate the Office Menu.
    /// </summary>
    /// <param name = "_menuOptions">The menu options to be customized.</param>
    public void customizeOfficeMenuOptions(OfficeMenuOptions _menuOptions)
    {
        // Clear the menu options which are driven by the root datasource of an entity, as some
        // of the of the options are valid for only certain journal types.
        ListIterator dataEntityIterator = new ListIterator(_menuOptions.dataEntityOptions());

        while (dataEntityIterator.more())
        {
            dataEntityIterator.delete();
        }

        SetEnumerator journalTemplateEnumerator = LedgerJournalExcelTemplate::getLedgerJournalExcelTemplatesForJournalType(
            this.journalTypeId()).getEnumerator();

        while (journalTemplateEnumerator.moveNext())
        {
            DocuTemplate docuTemplate = DocuTemplate::findTemplate(OfficeAppApplicationType::Excel, journalTemplateEnumerator.current());

            if (docuTemplate)
            {
                OfficeTemplateExportMenuItem menuItem = OfficeTemplateExportMenuItem::constructWithDocuTemplate(docuTemplate, docuTemplate.TemplateID, curExt());
                menuItem.onExporting += eventhandler(this.onJournalExcelTemplateExport);
                menuItem.updateTemplate += eventhandler(this.updateTemplateHandler);
                _menuOptions.customMenuItems().addEnd(menuItem);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>onJournalExcelTemplateExport</Name>
				<Source><![CDATA[
    private void onJournalExcelTemplateExport(OfficeExportMenuItem _menuItem, OfficeMenuItemCancelEventArgs _args)
    {
        LedgerIJournalExcelTemplate journalTemplate = LedgerJournalExcelTemplate::constructForTemplateName(_menuItem.id());

        if (!journalTemplate.validateJournalForTemplate(this.journalTable()))
        {
            _args.cancel(true);
            _args.cancelMessage("@GeneralLedger:JournalExcelTemplateOpenValidationFailed");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateTemplateHandler</Name>
				<Source><![CDATA[
    private void updateTemplateHandler(OfficeTemplateExportMenuItem _menuItem, FormRun _formRun, Microsoft.Dynamics.Platform.Integration.Office.ITemplateManager _templateManager)
    {
        Excel.IWorkbookManager workbookManager = _templateManager as Excel.IWorkbookManager;
        Excel.WorkbookSettingsManager settingsManager = _templateManager.SettingsManager as Excel.WorkbookSettingsManager;

        LedgerIJournalExcelTemplate template = LedgerJournalExcelTemplate::constructForTemplateName(_menuItem.templateId());
        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(journalTable.JournalId);
  
        template.applyCustomTrimming(workbookManager, settingsManager, ledgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>templateChanged</Name>
				<Source><![CDATA[
    private void templateChanged(DocuTemplate _template, Microsoft.Dynamics.Platform.Integration.Office.ITemplateManager _templateManager, object _context)
    {
        Excel.IWorkbookManager workbookManager = _templateManager as Excel.IWorkbookManager;
        Excel.WorkbookSettingsManager settingsManager = _templateManager.SettingsManager as Excel.WorkbookSettingsManager;

        LedgerIJournalExcelTemplate template = LedgerJournalExcelTemplate::constructForTemplateName(_template.TemplateID);
        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(journalTable.JournalId);

        template.applyCustomTrimming(workbookManager, settingsManager, ledgerJournalTable);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeOpenExcelTemplate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Perform initialization for opening journal excel template.
    /// </summary>
    public void initializeOpenExcelTemplate()
    {
        LedgerJournalTable ledgerJournalTable = LedgerJournalTable::find(journalTable.JournalId);

        ledgerJournalTable.updateBalances();

        if (journalTable_ds)
        {
            journalTable.reread();
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>