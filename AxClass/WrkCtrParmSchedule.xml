<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WrkCtrParmSchedule</Name>
	<SourceCode>
		<Declaration><![CDATA[
public class WrkCtrParmSchedule
{
    ReqPlanIdForecast           reqPlanId;
    RefRecId                    reqPlanVersionRefRecId;

    InventDimId                 inventDimId;
    InventTransRefId            schedNumId; 
    OprNum                      schedOprNum;
    ProdJobId                   schedJobId;
    RecId                       schedJobRecId;
    WrkCtrId                    schedFromWrkCtrId;
    WrkCtrId                    schedToWrkCtrId;

    SchedDirection              schedDirection;
    SchedTime                   schedTime; 
    TransDate                   schedDate;
    NoYes                       propertyLimited;
    NoYes                       capacityLimited;
    TransDate                   finiteCapFenceDate;
    SchedLimitBottleneck        bottleneckScheduling;
    TransDate                   bottleneckCapFenceDate;

    NoYes                       materialLimited;
    NoYes                       synchronizeReference;
    NoYes                       schedReference;
    NoYes                       cancelProcessTime;
    NoYes                       cancelSetupTime;
    NoYes                       cancelQueueTime;
    NoYes                       cancelTransportTime;
    NoYes                       cancelOverlap;

    ReqApplyReceiptMargin       applyReceiptMargin;
    ReqApplyIssueMargin         applyIssueMargin;
    ReqApplyReorderMargin       applyReorderMargin;

    private NoYes               mustSubmitPurchToWorkflow = NoYes::Yes;
    private NoYes               canUpdateExplosion = NoYes::Yes;

    NoYes                       schedOnlyOprNum;
    NoYes                       schedSingleJob;

    NoYes                       keepResourceAssignments;

    TransDate                   todaysdate;
    PositiveDays                maxJobDays;

    WrkCtrSchedulerPrimaryResourceSelection  primaryResourceSelection;

    ItemId                      itemId;

    // Masterscheduling
    ReqTrans                    reqTrans;
    ReqPO                       reqPO;
    boolean                     updateReqDateDlv;
    boolean                     updateReqFuturesDate;
    TransDate                   minimumSchedDate;
    TimeOfDay                   minimumSchedTime;

    // Project
    ForecastModelId             modelId;
    ProjSchedSort               projSchedSort;

    SchedMethod                 schedMethod;

    NoYes                       loadJobSchedulingCapacity;
    NoYes                       loadOperationSchedulingCapacity;

    KeepProductionUnit          keepProductionUnit;
    KeepWarehouseFromResource   keepWarehouseFromResource;

    boolean                     recalculateBomLevels;

    // whether the scheduling start date is allowed to be set to be before todays date (incl. dateNull)
    boolean                     allowMinimumDateBeforeToday;
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>bottleneckCapFenceDate</Name>
				<Source><![CDATA[
    public TransDate bottleneckCapFenceDate(TransDate _transDate = bottleneckCapFenceDate)
    {
        bottleneckCapFenceDate = _transDate;

        if (this.bottleneckScheduling() && this.capacityLimited())
            return bottleneckCapFenceDate;

        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>bottleneckScheduling</Name>
				<Source><![CDATA[
    NoYes bottleneckScheduling(NoYes _bottleneckScheduling = bottleneckScheduling)
    {
        bottleneckScheduling = _bottleneckScheduling;
        return bottleneckScheduling;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelOverlap</Name>
				<Source><![CDATA[
    public NoYes cancelOverlap(NoYes _cancelOverlap = cancelOverlap)
    {
        cancelOverlap = _cancelOverlap;
        return cancelOverlap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelProcessTime</Name>
				<Source><![CDATA[
    public NoYes cancelProcessTime(NoYes _cancelProcessTime = cancelProcessTime)
    {
        cancelProcessTime = _cancelProcessTime;
        return cancelProcessTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelQueueTime</Name>
				<Source><![CDATA[
    public NoYes cancelQueueTime(NoYes _cancelQueueTime = cancelQueueTime)
    {
        cancelQueueTime = _cancelQueueTime;
        return cancelQueueTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelSetupTime</Name>
				<Source><![CDATA[
    public NoYes cancelSetupTime(NoYes _cancelSetupTime = cancelSetupTime)
    {
        cancelSetupTime = _cancelSetupTime;
        return cancelSetupTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cancelTransportTime</Name>
				<Source><![CDATA[
    public NoYes cancelTransportTime(NoYes _cancelTransportTime = cancelTransportTime)
    {
        cancelTransportTime = _cancelTransportTime;
        return cancelTransportTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyReceiptMargin</Name>
				<Source><![CDATA[
    public ReqApplyReceiptMargin applyReceiptMargin(ReqApplyReceiptMargin _applyReceiptMargin = applyReceiptMargin)
    {
        applyReceiptMargin = _applyReceiptMargin;
        return applyReceiptMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyIssueMargin</Name>
				<Source><![CDATA[
    public ReqApplyIssueMargin applyIssueMargin(ReqApplyIssueMargin _applyIssueMargin = applyIssueMargin)
    {
        applyIssueMargin = _applyIssueMargin;
        return applyIssueMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>applyReorderMargin</Name>
				<Source><![CDATA[
    public ReqApplyReorderMargin applyReorderMargin(ReqApplyReorderMargin _applyReorderMargin = applyReorderMargin)
    {
        applyReorderMargin = _applyReorderMargin;
        return applyReorderMargin;
    }

]]></Source>
			</Method>
			<Method>
				<Name>capacityLimited</Name>
				<Source><![CDATA[
    public NoYes capacityLimited(NoYes _capacityLimited = capacityLimited)
    {
        capacityLimited = _capacityLimited;
        return capacityLimited;
    }

]]></Source>
			</Method>
			<Method>
				<Name>finiteCapFenceDate</Name>
				<Source><![CDATA[
    public TransDate finiteCapFenceDate(TransDate _transDate = finiteCapFenceDate)
    {
        finiteCapFenceDate = _transDate;

        if (this.capacityLimited())
        {
            return finiteCapFenceDate;
        }

        return dateNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isJobTypeCancelled</Name>
				<Source><![CDATA[
    public boolean isJobTypeCancelled(RouteJobType jobType)
    {
        switch (jobType)
        {
            case RouteJobType::QueueBefore:
                if (this.cancelQueueTime())
                {
                    return true;
                }
                break;

            case RouteJobType::QueueAfter:
                if (this.cancelQueueTime())
                {
                    return true;
                }
                break;

            case RouteJobType::Setup     :
                if (this.cancelSetupTime())
                {
                    return true;
                }
                break;

            case RouteJobType::Process:
                if (this.cancelProcessTime())
                {
                    return true;
                }
                break;

            case RouteJobType::Overlap:
                if (this.cancelOverlap())
                {
                    return true;
                }
                break;

            case RouteJobType::Transport:
                if (this.cancelTransportTime())
                {
                    return true;
                }
                break;
            default:
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    public ItemId itemId( ItemId _itemId = itemId )
    {
        itemId = _itemId;
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>materialLimited</Name>
				<Source><![CDATA[
    public NoYes materialLimited(NoYes _materialLimited = materialLimited)
    {
        materialLimited = _materialLimited;
        return materialLimited;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustSubmitPurchToWorkflow</Name>
				<Source><![CDATA[
    internal NoYes mustSubmitPurchToWorkflow(NoYes _mustSubmitPurchToWorkflow = mustSubmitPurchToWorkflow)
    {
        mustSubmitPurchToWorkflow = _mustSubmitPurchToWorkflow;
        return mustSubmitPurchToWorkflow;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canUpdateExplosion</Name>
				<Source><![CDATA[
    internal NoYes canUpdateExplosion(NoYes _canUpdateExplosion = canUpdateExplosion)
    {
        canUpdateExplosion = _canUpdateExplosion;
        return canUpdateExplosion;
    }

]]></Source>
			</Method>
			<Method>
				<Name>maxJobDays</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets or sets the nonzero value of the <c>PositiveDays</c> value.
    /// </summary>
    /// <param name="_maxJobDays">
    ///    Sets the <c>PositiveDays</c> value; optional.
    /// </param>
    /// <returns>
    ///    The <c>PositiveDays</c> value; otherwise, 100.
    /// </returns>
    /// <remarks>
    ///    The <c>PositiveDays</c> value is a positive integer that determines a limit for the lead time in
    ///    days. If the limit is exceeded, an error is thrown and the scheduling is skipped.
    /// </remarks>
    public PositiveDays maxJobDays(PositiveDays _maxJobDays = maxJobDays)
    {
        maxJobDays = _maxJobDays;

        return maxJobDays > 0 ? maxJobDays : 100;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minimumSchedDate</Name>
				<Source><![CDATA[
    public SchedDate minimumSchedDate(TransDate _minimumSchedDate = minimumSchedDate)
    {
        minimumSchedDate             = _minimumSchedDate;

        if (!allowMinimumDateBeforeToday)
        {
            if (!minimumSchedDate || minimumSchedDate < this.todaysdate())
            {
                return this.todaysdate();
            }
        }

        return minimumSchedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>minimumSchedTime</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and gets the minimum allowed scheduling time.
    /// </summary>
    /// <param name="_minimumSchedTime">
    /// The minimum allowed scheduling time; optional.
    /// </param>
    /// <returns>
    /// The minimum allowed scheduling time.
    /// </returns>
    public TimeOfDay minimumSchedTime(TimeOfDay _minimumSchedTime = minimumSchedTime)
    {
        minimumSchedTime = _minimumSchedTime;

        return minimumSchedTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>modelId</Name>
				<Source><![CDATA[
    ForecastModelId modelId(ForecastModelId  _modelId = modelId)
    {
        modelId = _modelId;
        return modelId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustKeepResourceAssignments</Name>
				<Source><![CDATA[
    /// <summary>
    ///     Computes a boolean value that indicates whether the
    ///     job resource assignments for this order must be kept
    ///     upon re-scheduling (only applicable for job scheduling).
    /// </summary>
    /// <returns>
    ///     <c>true</c> if the resource assignments must be kept;
    ///     otherwise, <c>false</c>.
    /// </returns>
    public boolean mustKeepResourceAssignments()
    {
        return keepResourceAssignments && (schedMethod == SchedMethod::Detail);
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        todaysdate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        loadJobSchedulingCapacity = true;
        loadOperationSchedulingCapacity = true;
        primaryResourceSelection = WrkCtrSchedulerPrimaryResourceSelection::Duration;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clone</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new instance of the class and sets the same value as in the current instance.
    /// </summary>
    /// <returns>A new instance with the same values.</returns>
    internal WrkCtrParmSchedule clone()
    {
        Object obj = this;
        return obj.MemberwiseClone() as WrkCtrParmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneForUnlimitedMaterialsRun</Name>
				<Source><![CDATA[
    internal WrkCtrParmSchedule cloneForUnlimitedMaterialsRun(boolean _allowSchedulingWithReferences)
    {
        var wrkCtrParmScheduleUnlimitedMaterials = this.clone();
        wrkCtrParmScheduleUnlimitedMaterials.materialLimited(false);
        wrkCtrParmScheduleUnlimitedMaterials.canUpdateExplosion(false);
        wrkCtrParmScheduleUnlimitedMaterials.mustSubmitPurchToWorkflow(false);

        if (!_allowSchedulingWithReferences)
        {
            wrkCtrParmScheduleUnlimitedMaterials.schedReference(false);
        }

        return wrkCtrParmScheduleUnlimitedMaterials;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAllowMinimumDateBeforeToday</Name>
				<Source><![CDATA[
    public boolean parmAllowMinimumDateBeforeToday(boolean _allowMinimumDateBeforeToday = allowMinimumDateBeforeToday)
    {
        allowMinimumDateBeforeToday = _allowMinimumDateBeforeToday;
        return allowMinimumDateBeforeToday;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventDimId</Name>
				<Source><![CDATA[
    public InventDimId parmInventDimId(InventDimId _inventDimId = inventDimId)
    {
        inventDimId = _inventDimId;

        return inventDimId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKeepProductionUnit</Name>
				<Source><![CDATA[
    public KeepProductionUnit parmKeepProductionUnit(KeepProductionUnit _keepProductionUnit = keepProductionUnit)
    {
        keepProductionUnit = _keepProductionUnit;
        return keepProductionUnit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKeepResourceAssignments</Name>
				<Source><![CDATA[
    public NoYes parmKeepResourceAssignments(NoYes _keepResourceAssignments = keepResourceAssignments)
    {
        keepResourceAssignments = _keepResourceAssignments;
        return keepResourceAssignments;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmRecalculateBomLevels</Name>
				<Source><![CDATA[
    public boolean parmRecalculateBomLevels(boolean _recalculateBomLevels = recalculateBomLevels)
    {
        recalculateBomLevels = _recalculateBomLevels;

        return recalculateBomLevels;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmKeepWarehouseFromResource</Name>
				<Source><![CDATA[
    public KeepWarehouseFromResource parmKeepWarehouseFromResource(KeepWarehouseFromResource _keepWarehouseFromResource = keepWarehouseFromResource)
    {
        keepWarehouseFromResource = _keepWarehouseFromResource;
        return keepWarehouseFromResource;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadJobSchedulingCapacity</Name>
				<Source><![CDATA[
    public NoYes parmLoadJobSchedulingCapacity(NoYes _loadJobSchedulingCapacity = loadJobSchedulingCapacity)
    {
        loadJobSchedulingCapacity = _loadJobSchedulingCapacity;
        return loadJobSchedulingCapacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLoadOperationSchedulingCapacity</Name>
				<Source><![CDATA[
    public NoYes parmLoadOperationSchedulingCapacity(NoYes _loadOperationSchedulingCapacity = loadOperationSchedulingCapacity)
    {
        if (!prmisDefault(_loadOperationSchedulingCapacity))
        {
            loadOperationSchedulingCapacity = _loadOperationSchedulingCapacity;
        }
        return loadOperationSchedulingCapacity;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmPrimaryResourceSelection</Name>
				<Source><![CDATA[
    public WrkCtrSchedulerPrimaryResourceSelection parmPrimaryResourceSelection(WrkCtrSchedulerPrimaryResourceSelection _primaryResourceSelection = primaryResourceSelection)
    {
        primaryResourceSelection = _primaryResourceSelection;
        return primaryResourceSelection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReqPlanVersionRefRecId</Name>
				<Source><![CDATA[
    public RefRecId parmReqPlanVersionRefRecId(RefRecId _reqPlanVersionRefRecId = reqPlanVersionRefRecId)
    {
        reqPlanVersionRefRecId = _reqPlanVersionRefRecId;
        return reqPlanVersionRefRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>projSchedSort</Name>
				<Source><![CDATA[
    public ProjSchedSort projSchedSort(ProjSchedSort _projSchedSort = projSchedSort)
    {
        projSchedSort = _projSchedSort;
        return projSchedSort;
    }

]]></Source>
			</Method>
			<Method>
				<Name>propertyLimited</Name>
				<Source><![CDATA[
    public NoYes propertyLimited(NoYes _propertyLimited = propertyLimited)
    {
        propertyLimited = _propertyLimited;
        return propertyLimited;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPlanId</Name>
				<Source><![CDATA[
    public ReqPlanId reqPlanId(ReqPlanId  _reqPlanId = reqPlanId)
    {
        reqPlanId = _reqPlanId;
        return reqPlanId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqPoExtern</Name>
				<Source><![CDATA[
    ReqPO reqPoExtern(ReqPO _reqPO = reqPO)
    {
        reqPO = _reqPO;
        return reqPO;
    }

]]></Source>
			</Method>
			<Method>
				<Name>reqTransExtern</Name>
				<Source><![CDATA[
    ReqTrans reqTransExtern(ReqTrans _reqTrans = reqTrans)
    {
        reqTrans = _reqTrans;
        return reqTrans;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedDate</Name>
				<Source><![CDATA[
    public TransDate schedDate(TransDate _schedDate = schedDate)
    {
        schedDate = _schedDate;
        return schedDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedDirection</Name>
				<Source><![CDATA[
    public SchedDirection schedDirection(SchedDirection _schedDirection = schedDirection)
    {
        schedDirection = _schedDirection;
        return schedDirection;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedFromWrkCtrId</Name>
				<Source><![CDATA[
    public WrkCtrId schedFromWrkCtrId(WrkCtrId _wrkCtrId = schedFromWrkCtrId)
    {
        schedFromWrkCtrId = _wrkCtrId;
        return schedFromWrkCtrId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedJobId</Name>
				<Source><![CDATA[
    public ProdJobId schedJobId(ProdJobId _schedJobId = schedJobId)
    {
        schedJobId = _schedJobId;
        return schedJobId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedJobRecId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets or sets the <c>RecId</c> value of the scheduled job.
    /// </summary>
    /// <param name="_schedJobRecId">
    /// The <c>RecId</c> value of the scheduled job; optional.
    /// </param>
    /// <returns>
    /// The <c>RecId</c> value of the scheduled job.
    /// </returns>
    public RecId schedJobRecId(RecId _schedJobRecId = schedJobRecId)
    {
        schedJobRecId = _schedJobRecId;
        return schedJobRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedMethod</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets or gets the scheduling method.
    /// </summary>
    /// <param name="_schedMethod">
    /// The scheduling method; optional.
    /// </param>
    /// <returns>
    /// The scheduling method.
    /// </returns>
    public SchedMethod schedMethod(SchedMethod _schedMethod = schedMethod)
    {
        if (!prmisDefault(_schedMethod))
        {
            schedMethod = _schedMethod;
            if (schedMethod == SchedMethod::Detail)
            {
                loadOperationSchedulingCapacity = false;
            }
        }
        return schedMethod;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedNumId</Name>
				<Source><![CDATA[
    public InventTransRefId schedNumId(InventTransRefId _schedNumId = schedNumId)
    {
        schedNumId = _schedNumId;
        return schedNumId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedOnlyOprNum</Name>
				<Source><![CDATA[
    boolean schedOnlyOprNum(boolean _schedOnlyOprNum = schedOnlyOprNum)
    {
        schedOnlyOprNum = _schedOnlyOprNum;
        return schedOnlyOprNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedOprNum</Name>
				<Source><![CDATA[
    OprNum schedOprNum(OprNum _schedOprNum = schedOprNum)
    {
        schedOprNum = _schedOprNum;
        return schedOprNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedReference</Name>
				<Source><![CDATA[
    NoYes  schedReference(NoYes _schedReference = schedReference)
    {
        schedReference = _schedReference;

        return schedReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedSingleJob</Name>
				<Source><![CDATA[
    /// <summary>
    /// Specifies if a single job is to be scheduled.
    /// </summary>
    /// <param name="_schedSingleJob">
    /// A <c>boolean</c> value that indicates if a single job is to be scheduled; optional.
    /// </param>
    /// <returns>
    /// True if a single job is to be scheduled; otherwise, false.
    /// </returns>
    public NoYes schedSingleJob(NoYes _schedSingleJob = schedSingleJob)
    {
        schedSingleJob = _schedSingleJob;
        return schedSingleJob;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedTime</Name>
				<Source><![CDATA[
    SchedTime schedTime(SchedTime   _schedTime = schedTime)
    {
        schedTime = _schedTime;
        return schedTime;
    }

]]></Source>
			</Method>
			<Method>
				<Name>schedToWrkCtrId</Name>
				<Source><![CDATA[
    public WrkCtrId schedToWrkCtrId(WrkCtrId _wrkCtrId = schedToWrkCtrId)
    {
        schedToWrkCtrId = _wrkCtrId;
        return schedToWrkCtrId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>synchronizeReference</Name>
				<Source><![CDATA[
    public NoYes synchronizeReference(NoYes _synchronizeReference = synchronizeReference)
    {
        synchronizeReference = _synchronizeReference;
        return synchronizeReference;
    }

]]></Source>
			</Method>
			<Method>
				<Name>todaysdate</Name>
				<Source><![CDATA[
    TransDate todaysdate(TransDate _todaysDate = todaysDate)
    {
        todaysDate = _todaysDate;
        return todaysDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unknownJobId</Name>
				<Source><![CDATA[
    public str unknownJobId()
    {
        return '*';
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqDateDlv</Name>
				<Source><![CDATA[
    public boolean updateReqDateDlv(boolean _updateReqDateDlv = updateReqDateDlv)
    {
        updateReqDateDlv = _updateReqDateDlv;
        return updateReqDateDlv;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateReqFuturesDate</Name>
				<Source><![CDATA[
    boolean updateReqFuturesDate(boolean _updateReqFuturesDate = updateReqFuturesDate)
    {
        updateReqFuturesDate = _updateReqFuturesDate;
        return updateReqFuturesDate;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static WrkCtrParmSchedule construct()
    {
        return new WrkCtrParmSchedule();
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdParmScheduling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new WrkCtrParmSchedule object.
    /// </summary>
    /// <param name="_prodParmScheduling">
    /// A <c>ProdParmScheduling</c> record which holds scheduling settings.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrParmSchedule</c> object.
    /// </returns>
    public static WrkCtrParmSchedule newProdParmScheduling(ProdParmScheduling _prodParmScheduling)
    {
        WrkCtrParmSchedule  wrkCtrParmSchedule = new WrkCtrParmSchedule();

        SchedDate           schedDate;
        SchedTime           schedTime;
        SchedDirection      schedDirection;

        ProdRouteJob        prodRouteJob;
        ProdParametersDim   prodParametersDim;
        ReqPlanVersion      dynamicPlanVersion  = ReqPlanVersion::findActiveReqPlanIdDynamic();

        prodParametersDim    = ProdParametersDim::find(wrkCtrParmSchedule.parmInventDimId());
        
        InventDim inventDimSiteOnly = InventDim::find(_prodParmScheduling.prodTable().InventDimId);
        inventDimSiteOnly.clearNotSiteDim();
        inventDimSiteOnly = InventDim::findDim(inventDimSiteOnly);

        if (inventDimSiteOnly.inventDimId && inventDimSiteOnly.inventDimId != prodParametersDim.InventDimId)
        {
            ProdParametersDim prodParametersDimSite = ProdParametersDim::find(inventDimSiteOnly.inventDimId);

            if (prodParametersDimSite)
            {
                prodParametersDim = prodParametersDimSite;
            }
        }

        [schedDate,schedTime,schedDirection] = _prodParmScheduling.calcDateTimeDirection();

        if (_prodParmScheduling.JobId)
        {
            prodRouteJob = ProdRouteJob::findJobId(_prodParmScheduling.JobId);
            wrkCtrParmSchedule.schedJobRecId(prodRouteJob.RecId);
            //default the parameter to keep the resource assigments if one resource is already assigned
            wrkCtrParmSchedule.parmKeepResourceAssignments(_prodParmScheduling.WrkCtrIdSched != '');
        }

        wrkCtrParmSchedule.schedMethod(_prodParmScheduling.SchedMethod == ProdSchedMethod::OperationScheduling ? SchedMethod::Rough : SchedMethod::Detail);
        wrkCtrParmSchedule.cancelOverlap(_prodParmScheduling.CancelOverlap);
        wrkCtrParmSchedule.cancelProcessTime(_prodParmScheduling.CancelProcessTime);
        wrkCtrParmSchedule.cancelQueueTime(_prodParmScheduling.CancelQueueTime);
        wrkCtrParmSchedule.cancelSetupTime(_prodParmScheduling.CancelSetupTime);
        wrkCtrParmSchedule.cancelTransportTime(_prodParmScheduling.CancelTransportTime);
        wrkCtrParmSchedule.capacityLimited(_prodParmScheduling.CapLimited);
        wrkCtrParmSchedule.materialLimited(_prodParmScheduling.MatLimited);
        wrkCtrParmSchedule.propertyLimited(_prodParmScheduling.PropertyLimited);
        wrkCtrParmSchedule.schedDate(schedDate);
        wrkCtrParmSchedule.schedDirection(schedDirection);
        wrkCtrParmSchedule.schedJobId(_prodParmScheduling.JobId);
        wrkCtrParmSchedule.schedSingleJob(prodRouteJob && _prodParmScheduling.ScheduleSingleJob);
        wrkCtrParmSchedule.schedNumId(_prodParmScheduling.ProdId);
        wrkCtrParmSchedule.parmInventDimId(_prodParmScheduling.prodTable().InventDimId);

        wrkCtrParmSchedule.schedOprNum(prodRouteJob.OprNum);
        wrkCtrParmSchedule.schedFromWrkCtrId(prodRouteJob.WrkCtrId);
        wrkCtrParmSchedule.schedToWrkCtrId(_prodParmScheduling.WrkCtrIdSched);
        wrkCtrParmSchedule.parmRecalculateBomLevels(_prodParmScheduling.RecalculateBomLevels);

        wrkCtrParmSchedule.schedReference(_prodParmScheduling.SchedRef);
        wrkCtrParmSchedule.schedTime(schedTime);
        wrkCtrParmSchedule.synchronizeReference(_prodParmScheduling.SyncRef);
        wrkCtrParmSchedule.reqPlanId(dynamicPlanVersion.ReqPlanId);
        wrkCtrParmSchedule.parmReqPlanVersionRefRecId(dynamicPlanVersion.RecId);

        wrkCtrParmSchedule.maxJobDays(prodParametersDim.MaxJobDays);
        wrkCtrParmSchedule.parmKeepProductionUnit(_prodParmScheduling.KeepProductionUnit);
        wrkCtrParmSchedule.parmKeepWarehouseFromResource(_prodParmScheduling.KeepWarehouseFromResource);
        wrkCtrParmSchedule.parmPrimaryResourceSelection(_prodParmScheduling.PrimaryResourceSelection);

        wrkCtrParmSchedule.applyIssueMargin(_prodParmScheduling.ApplyIssueMargin);
        wrkCtrParmSchedule.applyReceiptMargin(_prodParmScheduling.ApplyReceiptMargin);
        wrkCtrParmSchedule.applyReorderMargin(_prodParmScheduling.ApplyReorderMargin);

        return wrkCtrParmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProdRoute</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>WrkCtrParmSchedule</c> object.
    /// </summary>
    /// <param name="_prodRoute">
    /// A <c>ProdRoute</c> record which should be scheduled.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrParmSchedule</c> object.
    /// </returns>
    public static WrkCtrParmSchedule newProdRoute(ProdRoute _prodRoute)
    {
        WrkCtrParmSchedule  wrkCtrParmSchedule  = new WrkCtrParmSchedule();
        ProdParametersDim   prodParametersDim;
        ReqPlanId           reqPlanId           = ReqPlanSched::defaultDynamicId();

        wrkCtrParmSchedule.parmInventDimId(_prodRoute.prodTable().InventDimId);
        prodParametersDim   = ProdParametersDim::find(wrkCtrParmSchedule.parmInventDimId());

        wrkCtrParmSchedule.cancelOverlap(false);
        wrkCtrParmSchedule.cancelProcessTime(false);
        wrkCtrParmSchedule.cancelQueueTime(false);
        wrkCtrParmSchedule.cancelSetupTime(false);
        wrkCtrParmSchedule.cancelTransportTime(false);
        wrkCtrParmSchedule.capacityLimited(false);
        wrkCtrParmSchedule.materialLimited(false);
        wrkCtrParmSchedule.propertyLimited(false);
        wrkCtrParmSchedule.schedDate(_prodRoute.ToDate ? _prodRoute.ToDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone()));
        wrkCtrParmSchedule.schedDirection(SchedDirection::Backward);
        wrkCtrParmSchedule.schedJobId(wrkCtrParmSchedule.unknownJobId());
        wrkCtrParmSchedule.schedNumId(_prodRoute.ProdId);
        wrkCtrParmSchedule.schedOprNum(_prodRoute.OprNum);
        wrkCtrParmSchedule.parmKeepResourceAssignments(true);
        wrkCtrParmSchedule.schedReference(false);
        wrkCtrParmSchedule.schedTime(_prodRoute.ToTime ? _prodRoute.ToTime : _prodRoute.toTimeEstimated());
        wrkCtrParmSchedule.synchronizeReference(false);
        wrkCtrParmSchedule.reqPlanId(reqPlanId);
        wrkCtrParmSchedule.schedOnlyOprNum(true);
        wrkCtrParmSchedule.maxJobDays(prodParametersDim.MaxJobDays);

        return wrkCtrParmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newProjParmScheduling</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a new <c>WrkCtrParmSchedule</c> object.
    /// </summary>
    /// <param name="_projScheduling">
    /// A <c>ProjScheduling</c> record which should be scheduled.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrParmSchedule</c> object.
    /// </returns>
    public static WrkCtrParmSchedule newProjParmScheduling(ProjScheduling _projScheduling)
    {
        WrkCtrParmSchedule  wrkCtrParmSchedule = new WrkCtrParmSchedule();
        ProdParametersDim   prodParametersDim  = ProdParametersDim::findDefault();
        ReqPlanVersion      dynamicPlanVersion = ReqPlanVersion::findActiveReqPlanIdDynamic();

        wrkCtrParmSchedule.schedMethod(_projScheduling.parmSchedMethod());
        wrkCtrParmSchedule.cancelOverlap(NoYes::No);
        wrkCtrParmSchedule.cancelProcessTime(NoYes::No);
        wrkCtrParmSchedule.cancelQueueTime(NoYes::No);
        wrkCtrParmSchedule.cancelSetupTime(NoYes::No);
        wrkCtrParmSchedule.cancelTransportTime(NoYes::No);
        wrkCtrParmSchedule.capacityLimited(_projScheduling.parmSchedLimitCap());
        wrkCtrParmSchedule.materialLimited(NoYes::No);
        wrkCtrParmSchedule.propertyLimited(NoYes::No);
        wrkCtrParmSchedule.schedDate(_projScheduling.parmSchedDate());
        wrkCtrParmSchedule.schedDirection(_projScheduling.parmSchedDirection());
        wrkCtrParmSchedule.schedJobId('');
        wrkCtrParmSchedule.schedNumId(_projScheduling.parmProjId());
        wrkCtrParmSchedule.schedOprNum(0);
        wrkCtrParmSchedule.schedReference(_projScheduling.parmSchedReference());
        wrkCtrParmSchedule.schedTime(_projScheduling.parmSchedTime());
        wrkCtrParmSchedule.synchronizeReference(_projScheduling.parmSchedSyncRef());
        wrkCtrParmSchedule.reqPlanId(dynamicPlanVersion.ReqPlanId);
        wrkCtrParmSchedule.parmReqPlanVersionRefRecId(dynamicPlanVersion.RecId);
        wrkCtrParmSchedule.maxJobDays(prodParametersDim.MaxJobDays);
        wrkCtrParmSchedule.parmKeepProductionUnit(_projScheduling.parmKeepProductionUnit());
        wrkCtrParmSchedule.parmPrimaryResourceSelection(_projScheduling.parmPrimaryResourceSelection());

        // Project
        wrkCtrParmSchedule.modelId(_projScheduling.parmModelId());
        wrkCtrParmSchedule.projSchedSort(_projScheduling.parmSchedSort());

        return wrkCtrParmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqTransCoverage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WrkCtrParmSchedule</c> object in order to schedule a planned order.
    /// </summary>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> record that relates to the planned order that has to be scheduled.
    /// </param>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record that is the planned order that has to be scheduled.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds the master scheduling settings.
    /// </param>
    /// <param name="_schedReference">
    /// A Boolean value that indicates whether references should be scheduled.
    /// </param>
    /// <param name="_usingThreads">
    /// A Boolean value that indicates whether threads are used.
    /// </param>
    /// <param name="_minimumSchedDate">
    /// A date that indicates that secure scheduling is not done before this date; optional.
    /// </param>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds master scheduling settings for a specific item and coverage
    /// dimensions; optional.
    /// </param>
    /// <param name="_minimumSchedTime">
    /// The earliest time for which scheduling is done on the date given in the <paramref name="_minimumSchedDate"/> parameter; optional.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrParmSchedule</c> object that is created to schedule a planned order during the coverage
    /// calculation.
    /// </returns>
    public static WrkCtrParmSchedule newReqTransCoverage(
        ReqTrans        _reqTrans,
        ReqPO           _reqPO,
        ReqPlanData     _reqPlanData,
        boolean         _schedReference,
        boolean         _usingThreads,
        TransDate       _minimumSchedDate       = dateNull(),
        ReqSetupDim     _setupDim               = null,
        TimeOfDay       _minimumSchedTime       = 0
        )
    {
        WrkCtrParmSchedule      parmSchedule;
        ProdParametersDim       prodParametersDim   = ProdParametersDim::find(_reqPO.CovInventDimId);
        WrkCtrParametersDim     wrkCtrParametersDim = WrkCtrParametersDim::find(_reqPO.CovInventDimId);
        ReqPlanId               reqPlanId           = ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId;

        if (_reqTrans.RefType != ReqRefType::BOMPlannedOrder
            && _reqTrans.RefType != ReqRefType::PmfPlannedProdBatch
            )
        {
            throw error("@SYS69941");
        }

        if (! _reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanId(reqPlanId);
        }

        parmSchedule  = new WrkCtrParmSchedule();
        parmSchedule.schedDate(_reqTrans.reqDateSchedBackward(_reqTrans.ReqDate, _reqPlanData));

        if (!_setupDim)
        {
            _setupDim = _reqPlanData.newReqSetupDim(_reqPlanData.newReqSetup(_reqTrans.ItemId),_reqTrans.CovInventDimId);
        }

        parmSchedule.parmAllowMinimumDateBeforeToday(_reqPO.allowsSchedulingStartDateBeforeToday(_reqPlanData, _setupDim));

        date todayPlusLockingTimeFence = _reqPlanData.todaysdate() + _reqPlanData.timeFenceLocking(_setupDim);

        if ((_minimumSchedDate || parmSchedule.parmAllowMinimumDateBeforeToday()) && _reqPlanData.timeFenceLocking(_setupDim) <= 0)
        {
            parmSchedule.minimumSchedDate(_minimumSchedDate);
        }
        else
        {
            parmSchedule.minimumSchedDate(max(_minimumSchedDate, todayPlusLockingTimeFence));
        }
        parmSchedule.minimumSchedTime(_minimumSchedTime);

        parmSchedule.parmInventDimId(_reqPO.CovInventDimId);

        parmSchedule.schedTime(_reqTrans.ReqTime);

        parmSchedule.schedDirection(SchedDirection::Backward);

        parmSchedule.reqPlanId(reqPlanId);
        parmSchedule.schedNumId(_reqTrans.RefId);

        parmSchedule.reqTransExtern(_reqTrans);
        parmSchedule.reqPoExtern(_reqPO);

        parmSchedule.itemId(_reqTrans.ItemId);

        parmSchedule.schedReference(_schedReference);

        parmSchedule.capacityLimited(_reqPlanData.covCapLimited());
        parmSchedule.bottleneckScheduling(_reqPlanData.bottleneckScheduling());

        parmSchedule.finiteCapFenceDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceFiniteCap(_setupDim) - 1);
        parmSchedule.bottleneckCapFenceDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceBottleneckCap(_setupDim) - 1);

        parmSchedule.propertyLimited(_reqPlanData.covPropertyLimited());
        parmSchedule.materialLimited(false);

        parmSchedule.updateReqDateDlv(true);
        parmSchedule.updateReqFuturesDate(false);

        parmSchedule.maxJobDays(prodParametersDim.MaxJobDays);

        parmSchedule.todaysdate(_reqPlanData.todaysdate());
        parmSchedule.schedMethod(_reqPlanData.covSchedMethod() == ProdSchedMethod::OperationScheduling ? SchedMethod::Rough : SchedMethod::Detail);
        parmSchedule.parmPrimaryResourceSelection(wrkCtrParametersDim.PrimaryResourceSelection);
        parmSchedule.parmReqPlanVersionRefRecId(_reqPlanData.parmReqPlanVersionRefRecId());

        return parmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqTransFutures</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WrkCtrParmSchedule</c> object in order to schedule a planned order.
    /// </summary>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> record that relates to the planned order that has to be scheduled.
    /// </param>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record which is the planned order that has to be scheduled.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that holds master scheduling settings.
    /// </param>
    /// <param name="_setupDim">
    /// A <c>ReqSetupDim</c> object that holds master scheduling settings for a specific item and coverage
    /// dimensions.
    /// </param>
    /// <param name="_minimumSchedTime">
    /// The earliest time for which scheduling is done on todays date; optional.
    /// </param>
    /// <returns>
    /// A <c>WrkCtrParmSchedule</c> object that is created to schedule a planned order during a future
    /// calculation.
    /// </returns>
    public static WrkCtrParmSchedule newReqTransFutures(
        ReqTrans        _reqTrans,
        ReqPO           _reqPO,
        ReqPlanData     _reqPlanData,
        ReqSetupDim     _setupDim,
        TimeOfDay       _minimumSchedTime = 0
        )
    {
        WrkCtrParmSchedule      parmSchedule;
        ProdParametersDim       prodParametersDim = ProdParametersDim::find(_reqPO.CovInventDimId);
        WrkCtrParametersDim     wrkCtrParametersDim = WrkCtrParametersDim::find(_reqPO.CovInventDimId);

        SchedDate               schedDate;
        ReqPlanId               reqPlanId           = ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId;

        if (_reqTrans.RefType != ReqRefType::BOMPlannedOrder
            && _reqTrans.RefType != ReqRefType::PmfPlannedProdBatch
            )
        {
            throw error("@SYS69941");
        }

        if (!_reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanId(reqPlanId);
        }

        if (!_setupDim)
        {
            _setupDim    = _reqPlanData.newReqSetupDim(_reqPlanData.newReqSetup(_reqTrans.ItemId),_reqTrans.CovInventDimId);
        }

        parmSchedule    = new WrkCtrParmSchedule();

        schedDate       = _reqPlanData.schedMarginForward(_reqPlanData.todaysdate(),_reqPlanData.marginOrder(_setupDim), _setupDim);

        if (schedDate < _reqPO.SchedFromDate)
        {
            schedDate = _reqPO.SchedFromDate;
        }

        parmSchedule.parmInventDimId(_reqPO.CovInventDimId);
        parmSchedule.schedDate(schedDate);
        parmSchedule.schedTime(_reqPO.ReqTimeOrder);
        parmSchedule.schedDirection(SchedDirection::Forward);

        parmSchedule.reqPlanId(reqPlanId);
        parmSchedule.schedNumId(_reqTrans.RefId);

        parmSchedule.schedReference(false);

        parmSchedule.reqTransExtern(_reqTrans);
        parmSchedule.reqPoExtern(_reqPO);

        parmSchedule.itemId(_reqTrans.ItemId);

        parmSchedule.capacityLimited(_reqPlanData.covCapLimited());
        parmSchedule.bottleneckScheduling(_reqPlanData.bottleneckScheduling());

        parmSchedule.finiteCapFenceDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceFiniteCap(_setupDim) - 1);
        parmSchedule.bottleneckCapFenceDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceBottleneckCap(_setupDim) - 1);

        parmSchedule.propertyLimited(_reqPlanData.covPropertyLimited());
        parmSchedule.materialLimited(true);

        parmSchedule.updateReqDateDlv(false);
        parmSchedule.updateReqFuturesDate(true);

        parmSchedule.maxJobDays(prodParametersDim.MaxJobDays);

        parmSchedule.todaysdate(_reqPlanData.todaysdate());

        parmSchedule.minimumSchedDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceLocking(_setupDim));
        parmSchedule.minimumSchedTime(_minimumSchedTime);

        parmSchedule.schedMethod(_reqPlanData.covSchedMethod() == ProdSchedMethod::OperationScheduling ? SchedMethod::Rough : SchedMethod::Detail);
        parmSchedule.parmPrimaryResourceSelection(wrkCtrParametersDim.PrimaryResourceSelection);

        parmSchedule.parmReqPlanVersionRefRecId(_reqPlanData.parmReqPlanVersionRefRecId());
        return parmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newReqTransParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WrkCtrParmSchedule</c> object in order to schedule a planned order.
    /// </summary>
    /// <param name="_reqTrans">
    /// A <c>ReqTrans</c> record that relates to the planned order that has to be scheduled.
    /// </param>
    /// <param name="_reqPO">
    /// A <c>ReqPO</c> record which is the planned order that has to be scheduled.
    /// </param>
    /// <param name="_reqPlanData">
    /// A <c>ReqPlanData</c> object that contains master scheduling settings.
    /// </param>
    /// <param name="_reqSchedDirection">
    /// A <c>ReqSchedDirection</c> enumeration value that determines the scheduling principle.
    /// </param>
    /// <param name="_schedMethod">
    /// A <c>ProdSchedMethod</c> enumeration value that determines whether operation scheduling or job
    /// scheduling should be done.
    /// </param>
    /// <param name="_schedDate">
    /// A date that holds a scheduling date. A scheduling date applies to some outcomes of the <paramref
    /// name="_reqSchedDirection" /> parameter.
    /// </param>
    /// <param name="_schedTime">
    /// A time that holds a scheduling time. A scheduling time applies to some outcomes of the <paramref
    /// name="_reqSchedDirection" /> parameter.
    /// </param>
    /// <param name="_schedReference">
    /// A Boolean that determines if references should be scheduled.
    /// </param>
    /// <param name="_capacityLimited">
    /// true if the scheduling should be done with limited capacity; false if scheduling should be done
    /// with infinite capacity.
    /// </param>
    /// <param name="_propertyLimited">
    /// true if scheduling should be done with limited property; false if scheduling should be done without
    /// respecting property settings.
    /// </param>
    /// <param name="_materialLimited">
    /// true if the scheduling should respect material dates; false if material dates should be disregarded.
    /// </param>
    /// <param name="_keepProductionUnit">
    /// A <c>KeepProductionUnit</c> enumeration value that indicates whether the scheduling should preserve
    /// the already selected production unit.
    /// </param>
    /// <param name="_keepWarehouseFromResource">
    /// A <c>KeepWarehouseFromResource</c> enumeration value that indicates whether the scheduling should
    /// preserve the input warehouse that was already selected.
    /// </param>
    /// <param name="_primaryResourceSelection">
    /// A <c>WrkCtrSchedulerPrimaryResourceSelection</c> enumeration value that indicates how the
    /// scheduling should select resources.
    /// </param>
    /// <returns>
    /// <param name="_updateReqDateDlv">
    /// A Boolean that determines if requested date should be updated for derived requirements
    /// </param>
    /// A <c>WrkCtrScheduleJobs</c> object instantiated to schedule a planned order with specific settings.
    /// </returns>
    public static WrkCtrParmSchedule newReqTransParameters(
        ReqTrans                                _reqTrans,
        ReqPO                                   _reqPO,
        ReqPlanData                             _reqPlanData,
        ReqSchedDirection                       _reqSchedDirection,
        ProdSchedMethod                         _schedMethod,
        SchedDate                               _schedDate,
        SchedTime                               _schedTime,
        boolean                                 _schedReference,
        SchedLimitCap                           _capacityLimited,
        SchedLimitProperty                      _propertyLimited,
        SchedLimitMat                           _materialLimited,
        KeepProductionUnit                      _keepProductionUnit,
        KeepWarehouseFromResource               _keepWarehouseFromResource,
        WrkCtrSchedulerPrimaryResourceSelection _primaryResourceSelection,
        boolean                                 _updateReqDateDlv = false
        )
    {
        WrkCtrParmSchedule      parmSchedule;

        ReqSetupDim             setupDim            = _reqPlanData.newReqSetupDim(_reqPlanData.newReqSetup(_reqTrans.ItemId),_reqTrans.CovInventDimId);
        ProdParametersDim       prodParametersDim   = ProdParametersDim::find(_reqPO.CovInventDimId);
        WrkCtrParametersDim     wrkCtrParametersDim = WrkCtrParametersDim::find(_reqPO.CovInventDimId);
        ReqPlanId               reqPlanId           = ReqPlanVersion::find(_reqTrans.PlanVersion).ReqPlanId;

        if (!_reqPlanData)
        {
            _reqPlanData = ReqPlanData::newReqPlanId(reqPlanId);
        }

        parmSchedule  = new WrkCtrParmSchedule();

        switch (_reqSchedDirection)
        {
            case ReqSchedDirection::BackwardFromActionDate  :
                parmSchedule.schedDate(_reqTrans.ActionDate ? _reqTrans.ActionDate              : _reqTrans.reqDateSchedBackward(_reqTrans.ReqDate,_reqPlanData));
                parmSchedule.schedTime(_reqTrans.ActionDate ? _reqPlanData.reqTimePoDefault()   : _reqTrans.ReqTime);
                parmSchedule.schedDirection(SchedDirection::Backward);
                break;

            case ReqSchedDirection::BackwardFromFuturesDate :
                parmSchedule.schedDate(_reqTrans.FuturesDate ? _reqTrans.FuturesDate : _reqTrans.reqDateSchedBackward(_reqTrans.ReqDate,_reqPlanData));
                parmSchedule.schedTime(_reqTrans.FuturesDate ? _reqTrans.FuturesTime : _reqTrans.ReqTime);
                parmSchedule.schedDirection(SchedDirection::Backward);

                break;

            case ReqSchedDirection::BackwardFromReqDate     :
                parmSchedule.schedDate(_reqTrans.reqDateSchedBackward(_reqTrans.ReqDate,_reqPlanData));
                parmSchedule.schedTime(_reqTrans.ReqTime);
                parmSchedule.schedDirection(SchedDirection::Backward);

                break;

            case ReqSchedDirection::BackwardFromSchedDate   :
                parmSchedule.schedDate(_schedDate);
                parmSchedule.schedTime(_schedTime);
                parmSchedule.schedDirection(SchedDirection::Backward);

                break;

            case ReqSchedDirection::ForwardFromOrderDate    :
                parmSchedule.schedDate(_reqPO.ReqDateOrder);
                parmSchedule.schedTime(_reqPO.ReqTimeOrder);
                parmSchedule.schedDirection(SchedDirection::Forward);

                break;

            case ReqSchedDirection::ForwardFromSchedDate    :
                parmSchedule.schedDate(_schedDate);
                parmSchedule.schedTime(_schedTime);
                parmSchedule.schedDirection(SchedDirection::Forward);

                break;

            default :
                throw error("@SYS135718");
        }

        parmSchedule.parmInventDimId(_reqPO.CovInventDimId);
        parmSchedule.reqPlanId(reqPlanId);
        parmSchedule.schedNumId(_reqTrans.RefId);

        parmSchedule.reqTransExtern(_reqTrans);
        parmSchedule.reqPoExtern(_reqPO);

        parmSchedule.schedReference(_schedReference);

        parmSchedule.capacityLimited(_capacityLimited);
        parmSchedule.bottleneckScheduling(_reqPlanData.bottleneckScheduling());

        parmSchedule.finiteCapFenceDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceFiniteCap(setupDim) - 1);
        parmSchedule.bottleneckCapFenceDate(_reqPlanData.todaysdate() + _reqPlanData.timeFenceBottleneckCap(setupDim) - 1);

        parmSchedule.propertyLimited(_propertyLimited);
        parmSchedule.materialLimited(_materialLimited);

        parmSchedule.updateReqDateDlv(_updateReqDateDlv);
        parmSchedule.updateReqFuturesDate(false);

        parmSchedule.todaysdate(_reqPlanData.todaysdate());

        parmSchedule.maxJobDays(prodParametersDim.MaxJobDays);

        parmSchedule.schedMethod(_schedMethod == ProdSchedMethod::OperationScheduling ? SchedMethod::Rough : SchedMethod::Detail);
        parmSchedule.parmKeepProductionUnit(_keepProductionUnit);
        parmSchedule.parmKeepWarehouseFromResource(_keepWarehouseFromResource);
        parmSchedule.parmPrimaryResourceSelection(_primaryResourceSelection);
        parmSchedule.parmReqPlanVersionRefRecId(_reqPlanData.parmReqPlanVersionRefRecId());

        return parmSchedule;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParametersForTelemetry</Name>
				<Source><![CDATA[
    internal SysInstrumentationAdditionalParameters getParametersForTelemetry()
    {
        var additionalParameters = SysInstrumentationAdditionalParameters::construct()
            .add(ReqInstrumentationActivities::ParmIsFiniteCapacity, int2Str(capacityLimited))
            .add(ReqInstrumentationActivities::ParmIsFiniteMaterial, int2Str(materialLimited))
            .add(ReqInstrumentationActivities::ParmIsFiniteProperty, int2Str(propertyLimited))
            .add(ReqInstrumentationActivities::ParmIsKeepProductionUnit, int2Str(keepProductionUnit))
            .add(ReqInstrumentationActivities::ParmIsKeepWarehouseFromResource, int2Str(keepWarehouseFromResource))
            .add(ReqInstrumentationActivities::ParmIsScheduleReferences, int2Str(schedReference))
            .add(ReqInstrumentationActivities::ParmIsSynchronizeReferences, int2Str(synchronizeReference))
            .add(ReqInstrumentationActivities::ParmIsCancelQueueTime, int2Str(cancelQueueTime))
            .add(ReqInstrumentationActivities::ParmIsCancelSetup, int2Str(cancelSetupTime))
            .add(ReqInstrumentationActivities::ParmIsCancelProcess, int2Str(cancelProcessTime))
            .add(ReqInstrumentationActivities::ParmIsCancelOverlap, int2Str(cancelOverlap))
            .add(ReqInstrumentationActivities::ParmIsCancelTransport, int2Str(cancelTransportTime))
            .add(ReqInstrumentationActivities::ParmPlanVersionRefRecId, int642Str(reqPlanVersionRefRecId))
            .add(ReqInstrumentationActivities::ParmSchedJobRecId, int642Str(schedJobRecId))
            .add(ReqInstrumentationActivities::ParmSchedDirection, enum2Symbol(enumNum(SchedDirection), schedDirection))
            .add(ReqInstrumentationActivities::ParmIsBottleneckScheduling, int2Str(bottleneckScheduling))
            .add(ReqInstrumentationActivities::ParmIsSchedOnlyOprNum, int2Str(schedOnlyOprNum))
            .add(ReqInstrumentationActivities::ParmIsSchedSingleJob, int2Str(schedSingleJob))
            .add(ReqInstrumentationActivities::ParmPrimaryResourceSelection, enum2Symbol(enumNum(WrkCtrSchedulerPrimaryResourceSelection), primaryResourceSelection))
            .add(ReqInstrumentationActivities::ParmProjSchedSort, enum2Symbol(enumNum(ProjSchedSort), projSchedSort))
            .add(ReqInstrumentationActivities::ParmSchedMethod, enum2Symbol(enumNum(SchedMethod), schedMethod))
            .add(ReqInstrumentationActivities::ParmIsRecalculateBomLevels, int2Str(recalculateBomLevels));

        return additionalParameters;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>