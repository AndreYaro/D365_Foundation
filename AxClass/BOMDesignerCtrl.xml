<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>BomDesignerCtrl</Name>
	<SourceCode>
		<Declaration><![CDATA[
class BomDesignerCtrl extends RunBase
{
    #resAppl

    TmpBOMRouteTree             tmpBOMRouteTree;
    Common                      caller;
    Object                      fr;
    FormTreeControl             tree;
    FormGroupControl            bomGroup;
    FormGroupControl            routeGroup;
    FormDataSource              routeDS;
    FormDataSource              routeOprTableDS;

    ImageListAppl_BOMRouteTree  imageList;
    ImageListAppl_StateReq      imageListState;
    tableId                     callerTableId;

    Map                         node2record;
    Map                         nodeBOMStatus;
    Map                         nodeCanHaveBOM;
    Map                         nodeCanHaveRoute;
    Map                         node2BOMTable;
    Map                         node2RouteTable;
    Map                         nodeRouteStatus;
    Map                         recId2Node;

    Map                         pmfNode2CoBy;
    Map                         pmfCoByRecId2Node;
    Set                         pmfCoByNodes;
    ItemId                      itemId;
    BOMId                       bomId;
    RouteId                     routeId;

    int                         nodeIdRoute;
    int                         rootId;
    int                         lastDelayNode;
    boolean                     callerCanHaveBOM;
    boolean                     lockRoute;
    boolean                     pmfCallerCanHaveFormula;

    int                         curDropNode;
    int                         curParentNodeIdx;
    int                         curNodeIdxToInsertAfter;

    boolean                     isLoading;

    int                         saveWidth;
    int                         saveHeight;

    BOMTable                    curBOMTableInfo;
    RouteTable                  curRouteTableInfo;
    ItemId                      curBOMTableInfo_ItemId;
    ItemId                      curRouteTableInfo_ItemId;

    boolean                     forcedUpdateInfoPanelBOM;
    boolean                     forcedUpdateInfoPanelRoute;
    BOMVersion                  bomVersionCaller;

    FormStaticTextControl       bomEmptyTextControl;
    FormStaticTextControl       routeEmptyTextControl;

    const str                   EmptyValue = '--';


    #DEFINE.CurrentVersion(2)

    #LOCALMACRO.CurrentList
        tmpBOMRouteTree,
        saveWidth,
        saveHeight
    #ENDMACRO

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>canViewBomVersionInfomation</Name>
				<Source><![CDATA[
    public boolean canViewBomVersionInfomation()
    {
        AccessType bomVersionAccessType = SysDictMenu::newMenuItem(menuitemDisplayStr(BOMDesignerBOMVersion), MenuItemType::Display).rights();
        return bomVersionAccessType >= AccessType::View;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canViewRouteInfomation</Name>
				<Source><![CDATA[
    public boolean canViewRouteInfomation()
    {
        AccessType routeVersionAccessType = SysDictMenu::newMenuItem(menuitemDisplayStr(BOMDesignerRouteVersion), MenuItemType::Display).rights();
        return routeVersionAccessType >= AccessType::View;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditBomInfomation</Name>
				<Source><![CDATA[
    public boolean canEditBomInfomation()
    {
        AccessType editBomAccessType = SysDictMenu::newMenuItem(menuitemDisplayStr(BOMDesignerEditBOM), MenuItemType::Display).rights();
        return editBomAccessType >= AccessType::Edit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>siteIdContext</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the site context for a given node.
    /// </summary>
    /// <param name = "_nodeIdx">The id of the node.</param>
    /// <param name = "_findForSubBOM">Determines if the site should be found based on a sub-bom of the node.</param>
    /// <returns>The site ID.</returns>
    protected InventSiteId siteIdContext(int _nodeIdx, boolean _findForSubBOM)
    {
        InventSiteId inventSiteId = tmpBOMRouteTree.inventDim().InventSiteId;
        if (!inventSiteId)
        {
            BOMTable bomTableContext;

            if (_findForSubBOM && nodeCanHaveBOM.exists(_nodeIdx))
            {
                if (_nodeIdx == rootId)
                {
                    bomTableContext = BOMTable::find(bomId);
                }
                else
                {
                    bomTableContext = node2BOMTable.lookup(_nodeIdx);
                }
            }
            else
            {
                BOM bomForNode = this.bomRecord(_nodeIdx);
                bomTableContext = BOMTable::find(bomForNode.BOMId);
            }

            inventSiteId = bomTableContext.SiteId;
        }

        return inventSiteId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>billOfMaterialsVersionErrorMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the appropriate error message for a missing BOM version while adding a new BOM line, based on the current version selection principle.
    /// </summary>
    /// <returns>The error message for a missing BOM version</returns>
    protected str billOfMaterialsVersionErrorMessage()
    {
        switch (tmpBOMRouteTree.bomRouteVersionPrinciple)
        {
            case BOMRouteVersionSelect::Active:
                return "@SYS67032";

            default:
                return "@SYS68255";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a new BOM line.
    /// </summary>
    /// <param name = "_nodeIdx">The currently selected node.</param>
    /// <param name = "_addAfter">Determines if the new BOM line should be added as a sibling after the currently selected node; optional.</param>
    /// <param name = "_addAsComponent">Determines if the new BOM line should be added as a sub-component to the currently selected node; optional.</param>
    /// <returns>true if the BOM line was properly added; otherwise, false.</returns>
    boolean addLine(
        int _nodeIdx,
        boolean _addAfter = true,
        boolean _addAsComponent = false)
    {
        BOM         boMnew;
        BOM         bomDrop;
        BOMId       bomIdNew;

        int         parentNodeIdx;
        int         nodeIdxToInsertAfter;

        if (_nodeIdx == rootId)
        {
            bomDrop = null;
        }
        else
        {
            bomDrop = node2record.lookup(_nodeIdx);
        }

        if (_addAsComponent && nodeCanHaveBOM.exists(_nodeIdx))
        {
            parentNodeIdx = _nodeIdx;
            nodeIdxToInsertAfter = this.getLastChild(_nodeIdx);

            if (_nodeIdx == rootId)
            {
                bomIdNew =  bomId;
            }
            else
            {
                BOMTable bomTable = node2BOMTable.lookup(_nodeIdx);
                bomIdNew = bomTable.bomId;
            }
            if (!bomIdNew)
            {
                return checkFailed(strFmt(this.billOfMaterialsVersionErrorMessage(),_nodeIdx == rootId ? itemId : bomDrop.ItemId));
            }
            boMnew.bomId   = bomIdNew;
            boMnew.LineNum = BOM::nextLineNum(boMnew.bomId);
        }
        else
        {
            boMnew.bomId = bomDrop.bomId;

            parentNodeIdx = this.parentNodeId(_nodeIdx);

            if (_addAfter)
            {
                nodeIdxToInsertAfter = _nodeIdx;

                if (!boMnew.setLineNumAfter(bomDrop))
                {
                    this.reNumberBOM(bomDrop);
                    bomDrop = node2record.lookup(_nodeIdx);
                    boMnew.setLineNumAfter(bomDrop);
                }
            }
            else
            {
                nodeIdxToInsertAfter = this.prevSiblingNodeId(_nodeIdx);

                if (!boMnew.setLineNumBefore(bomDrop))
                {
                    this.reNumberBOM(bomDrop);
                    bomDrop = node2record.lookup(_nodeIdx);
                    boMnew.setLineNumBefore(bomDrop);
                }
            }
        }

        curDropNode = _nodeIdx;

        boolean inserted = BOMLineAddHelper::addLineUsingDialog(boMnew, this, this.siteIdContext(_nodeIdx, _addAsComponent), tmpBOMRouteTree.AutoEdit);
        if (inserted)
        {
            bomNew.setFromFormulaVersion(bomVersionCaller);

            try
            {
                this.insertBOM(boMnew, _nodeIdx, parentNodeIdx, nodeIdxToInsertAfter);
            }
            catch (Exception::Error)
            {
                exceptionTextFallThrough();
            }
        }

        curDropNode = 0;

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomId</Name>
				<Source><![CDATA[
    BOMId bomId(int _nodeIdx)
    {
        BOMTable    bomTable;

        bomTable = node2BOMTable.lookup(_nodeIdx);
        return bomTable.bomId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomRouteVersionPrinciple</Name>
				<Source><![CDATA[
    BOMRouteVersionSelect bomRouteVersionPrinciple()
    {
        return tmpBOMRouteTree.bomRouteVersionPrinciple;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isOperationReleatedToBOMLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if an operation is related to a given BOM line.
    /// </summary>
    /// <param name = "_route">The operation to validate for.</param>
    /// <param name = "_nodeIdx">The selected node.</param>
    /// <returns>true if the operation is related to the line selected in the tree.</returns>
    public boolean isOperationReleatedToBOMLine(Route _route, int _nodeIdx)
    {
        boolean ret = false;

        if (_route
            && _route.OprPriority == RouteOprPriority::Primary
            && _nodeIdx != rootId
            && _nodeIdx != nodeIdRoute)
        {
            BOM bom = this.bomRecord(_nodeIdx);
            ret = (bom.OprNum == _route.OprNum);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOperationReleatedToBOMLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the relationship between a route operation and a BOM line.
    /// </summary>
    /// <param name = "_route">The route operation.</param>
    /// <param name = "_nodeIdx">The BOM line node.</param>
    /// <param name = "_usedInBOM">Specifying if this BOM line should be related to this route operation.</param>
    public void setOperationReleatedToBOMLine(Route _route, int _nodeIdx, BOMDesignerOprUsedInBOM _usedInBOM)
    {
        if (_route
            && _route.OprPriority == RouteOprPriority::Primary
            && _nodeIdx != rootId
            && _nodeIdx != nodeIdRoute)
        {
            BOM bom = this.bomRecord(_nodeIdx);
            OprNumBOMLine oprNum = 0;

            if (_usedInBOM)
            {
                oprNum = _route.oprNum;
            }

            ttsbegin;

            bom = BOM::findRecID(bom.RecId, true);
            bom.OprNum = oprNum;
            bom.update();

            ttscommit;

            // Update the tree structure
            this.insertBOMRecord(_nodeIdx, bom);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomSetInventDimFinal</Name>
				<Source><![CDATA[
    void bomSetInventDimFinal(
        BOM _bom,
        int _parentNodeIdx)
    {
        BOM bomParent;
        InventDim inventDim;

        if (!_parentNodeIdx)
        {
            return;
        }

        inventDim = _bom.BOMMap::inventDimFinal('', this.inventDim(_parentNodeIdx), '');
        _bom.InventDimId = inventDim.InventDimId;
        if (_parentNodeIdx == rootId)
        {
            _bom.setConfigId(itemId,tmpBOMRouteTree.inventDim().ConfigId);
        }
        else
        {
            bomParent = node2record.lookup(_parentNodeIdx);
            _bom.setConfigId(bomParent.ItemId,this.inventDim(_parentNodeIdx).ConfigId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildOneNode</Name>
				<Source><![CDATA[
    void buildOneNode(
        int                           _parentNodeId,
        BOMId                         _bomId,
        ItemId                        _itemId,
        EcoResItemConfigurationName   _configId,
        boolean                       _recursive = false)
    {
        BOM             bom;
        BOMTable        bomTable;
        InventTable     inventTable;
        FormTreeItem    treeItem;
        container       nodeData;
        int             x,l,newId;
        boolean         skipCircularityCheck;
        container       pmfCoByData;
        RefRecId        bomVersionRecId;

        if (!_parentNodeId || nodeBOMStatus.exists(_parentNodeId) || (_itemId &&(!BOMDesignerCtrl::itemCanHaveBOM(InventTable::find(_itemId)))))
        {
            return;
        }

        if (!this.checkBOMLevel(_parentNodeId))
        {
            throw error("@SYS26729");
        }

        try
        {
            if (_bomId)
            {
                skipCircularityCheck = !BOMParameters::find().mustCheckPerLine() || _parentNodeId == rootId;
                nodeData = _configId ? BOMSearch::bomTreePackLevelConfig(_bomId,tmpBOMRouteTree.bomDateValidOnly ? this.versionDate() : dateNull(),_itemId,_configId,skipCircularityCheck,true) :
                                       BOMSearch::bomTreePackLevelConfig(_bomId,tmpBOMRouteTree.bomDateValidOnly ? this.versionDate() : dateNull(),_itemId,'',skipCircularityCheck,true);
                if (#PmfEnabled)
                {
                    bomVersionRecId = bomVersionCaller.RecId;
                    // as called from the item master
                    if  (   (!bomVersionRecId && _itemId)
                        ||  ( bomVersionRecId && _itemId && (bomVersionCaller.ItemId != _itemId)))
                    {
                        bomVersionRecId = BOMVersion::selectBomVersion(
                            _itemId,
                            this.versionDate(),
                            this.versionQty(),
                            this.inventDim(),
                            true,               //_includeActive,       default value
                            false,              //_includeInactive,     default value
                            true,               //_includeApproved,     default value
                            false,              //_includeUnapproved,   default value
                            true,               //_checkDate,           default value
                            _bomId).RecId;
                    }

                    pmfCoByData = PmfCoBySearch::coByTreePackLevelConfig(
                                    _bomId,
                                    bomVersionRecId,
                                    _itemId,
                                    skipCircularityCheck,
                                    true);
                }
            }
        }
        catch (Exception::Error)
        {
            exceptionTextFallThrough();
        }

        if (BOMTable::find(_bomId).PmfBOMFormula == PmfBOMFormula::Formula)
        {
            this.pmfBuildCoByNode(_parentNodeId, pmfCoByData);
        }

        l = conLen(nodeData);

        for (x=1;x<=l;x++)
        {
            bom         = conPeek(nodeData,x);
            inventTable = bom.inventTable();

            newId       = tree.add(_parentNodeId,0,this.nodeTxt(bom,inventTable),this.nodeImage(inventTable));
            if (BOMDesignerCtrl::itemCanHaveBOM(inventTable))
            {
                this.bomSetInventDimFinal(bom, _parentNodeId);
                bomTable = BOMTable::find(bom.itemBOMIdConstruction(this.canViewBomVersionInfomation() ?
                                                                    tmpBOMRouteTree.bomRouteVersionPrinciple :
                                                                    BOMRouteVersionSelect::Active,
                                                                    this.versionDate(),
                                                                    tmpBOMRouteTree.bomRouteFromQty,
                                                                    bom.inventDim()));
                if (inventTable.inventItemType().canHaveRoutes())
                {
                    nodeCanHaveRoute.insert(newId, 1);
                }

                this.setNodeBOM(newId);
                node2BOMTable.insert(newId,bomTable);

                if (!bomTable.RecId)
                {
                    treeItem = tree.getItem(newId);
                    treeItem.stateImage(imageListState.image(#ImageStateNotAtAllOK));
                    treeItem.stateExpanded(true);
                    tree.setItem(treeItem);
                }

                if (_recursive)
                {
                    this.buildOneNode(newId,bomTable.bomId,bom.ItemId,bom.inventDim().ConfigId);
                }
            }
            this.insertBOMRecord(newId,bom);
        }
        nodeBOMStatus.insert(_parentNodeId,1);

        if (l)
        {
            tree.expand(_parentNodeId,FormTreeExpand::Expand);
        }
        else
        {
            treeItem = tree.getItem(_parentNodeId);
            treeItem.stateExpanded(true);
            tree.setItem(treeItem);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCheckBOM</Name>
				<Source><![CDATA[
    boolean canCheckBOM(int _nodeIdx)
    {
        BOMTable bomTable;
        boolean  ret = _nodeIdx
                       && nodeCanHaveBOM.exists(_nodeIdx)
                       && node2BOMTable.exists(_nodeIdx);

        if (ret)
        {
            bomTable = node2BOMTable.lookup(_nodeIdx);
        }

        return ret && bomTable.RecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canDeleteBOM</Name>
				<Source><![CDATA[
    boolean canDeleteBOM(int _nodeIdx)
    {
        return _nodeIdx
               && _nodeIdx != rootId
               && (node2record.exists(_nodeIdx)
               || this.isPmfCoByLeaf(_nodeIdx))
               && !this.isPmfCoByNode(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canEditBOM</Name>
				<Source><![CDATA[
    boolean canEditBOM(int _nodeIdx)
    {
        return _nodeIdx
               && _nodeIdx != rootId
               && !this.isPmfCoByNode(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canAddComponent</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determnes if a new component is allowed to be added to the given node.
    /// </summary>
    /// <param name = "_nodeIdx">The Id of the node to determine the setting for.</param>
    /// <returns>true if a new component is allowed to be added to the given node; otherwise, false.</returns>
    boolean canAddComponent(int _nodeIdx)
    {
        return _nodeIdx
               && nodeCanHaveBOM.exists(_nodeidx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canLockRoute</Name>
				<Source><![CDATA[
    boolean canLockRoute(int _nodeIdx)
    {
        return _nodeIdx
               && !lockRoute
               && !this.isPmfCoByNode(_nodeIdx) && !this.isPmfCoByLeaf(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canMoveNode</Name>
				<Source><![CDATA[
    boolean canMoveNode(
        int _moveNode,
        int _dropNode)
    {
        BOMTable bomTableMove, bomTableMoveParent, bomTableDrop, bomTableDropParent;
        int      moveParent, dropParent, curParent;

        if (!nodeCanHaveBOM.exists(_moveNode))
        {
            return true;
        }

        curParent = _dropNode;

        if (!nodeCanHaveBOM.exists(curParent))
        {
            curParent = tree.getParent(curParent);
        }

        if (curParent == rootId)
        {
            return true;
        }

        if (   !node2BOMTable.exists(_moveNode)
            || !node2BOMTable.exists(curParent))
        {
            return true;
        }

        bomTableMove        = node2BOMTable.lookup(_moveNode);
        bomTableDrop        = node2BOMTable.lookup(curParent);
        moveParent          = tree.getParent(_moveNode);
        bomTableMoveParent  = node2BOMTable.lookup(moveParent);

        while (true)
        {
            if (bomTableMove.RecId == bomTableDrop.RecId)
            {
                dropParent          = tree.getParent(curParent);
                bomTableDropParent  = node2BOMTable.lookup(dropParent);
                return    bomTableMoveParent.RecId != bomTableDropParent.RecId
                       || dropParent == rootId;
            }
            else
            {
                curParent = tree.getParent(curParent);
                if (curParent == rootId)
                {
                    return true;
                }
                bomTableDrop = node2BOMTable.lookup(curParent);
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOpenBOMCalc</Name>
				<Source><![CDATA[
    boolean canOpenBOMCalc(int _nodeIdx)
    {
        return _nodeIdx
               && nodeCanHaveBOM.exists(_nodeidx)
               && (_nodeidx      != rootId
               ||  callerTableId != tableNum(BOMTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOpenBOMVers</Name>
				<Source><![CDATA[
    boolean canOpenBOMVers(int _nodeIdx)
    {
        return _nodeIdx
               && nodeCanHaveBOM.exists(_nodeidx)
               && (_nodeidx       != rootId
               ||  callerTableId != tableNum(BOMTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canCreateBOMVersion</Name>
				<Source><![CDATA[
    boolean canCreateBOMVersion(int _nodeIdx)
    {
        return  _nodeIdx
               && nodeCanHaveBOM.exists(_nodeidx)
               && (_nodeidx      != rootId
               ||  callerTableId != tableNum(BOMTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOpenConfigPartOf</Name>
				<Source><![CDATA[
    boolean canOpenConfigPartOf(int _nodeIdx)
    {
        BOM     bom;

        if (!_nodeIdx || _nodeIdx == rootId)
        {
            return false;
        }

        if (node2record.exists(_nodeIdx))
        {
            bom = node2record.lookup(_nodeIdx);
        }

        if (!bom.ConfigGroupId)
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOpenConfigTable</Name>
				<Source><![CDATA[
    boolean canOpenConfigTable(int _nodeIdx)
    {
        BOM     bom;
        ItemId  itemIdCur;

        if (!_nodeIdx)
        {
            return false;
        }

        if (   _nodeidx      == rootId
            && callerTableId == tableNum(BOMTable))
        {
            return false;
        }

        if (_nodeIdx == rootId)
        {
            itemIdCur = itemId;
        }
        else
        if (node2record.exists(_nodeIdx))
        {
            bom       = node2record.lookup(_nodeIdx);
            itemIdCur = bom.ItemId;
        }
        if (    !itemIdCur
            || !InventTable::find(itemIdCur).configActive())
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOpenInventTable</Name>
				<Source><![CDATA[
    boolean canOpenInventTable(int _nodeIdx)
    {
        return _nodeIdx
               && (_nodeidx      != rootId
               ||  callerTableId != tableNum(BOMTable))
               && !this.isPmfCoByNode(_nodeIdx)
               ;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canOpenRouteVers</Name>
				<Source><![CDATA[
    boolean canOpenRouteVers(int _nodeIdx)
    {
        return _nodeIdx
               && nodeCanHaveRoute.exists(_nodeidx)
               && (_nodeidx      != rootId
               ||  callerTableId != tableNum(BOMTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canPrintBOM</Name>
				<Source><![CDATA[
    boolean canPrintBOM(int _nodeIdx)
    {
        return  _nodeIdx
               && nodeCanHaveBOM.exists(_nodeIdx)
               && (_nodeIdx      != rootId
               ||  callerTableId != tableNum(BOMTable));
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReleaseRoute</Name>
				<Source><![CDATA[
    boolean canReleaseRoute()
    {
        return lockRoute;
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReReadBOM</Name>
				<Source><![CDATA[
    boolean canReReadBOM(int _nodeIdx)
    {
        return _nodeIdx
               && nodeCanHaveBOM.exists(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>canReReadRoute</Name>
				<Source><![CDATA[
    boolean canReReadRoute(int _nodeIdx)
    {
        return _nodeIdx
               && nodeCanHaveBOM.exists(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBOM</Name>
				<Source><![CDATA[
    void checkBOM(int _nodeIdx)
    {
        if (!this.canCheckBOM(_nodeIdx))
        {
            return;
        }

        BOMTable    bomTable = node2BOMTable.lookup(_nodeIdx);

        // construct the parameters for invoking BOMHierarchyCheckJob
        Args args = new Args();
        args.record(bomTable);
        args.caller(this);

        // invoke the BOMHierarchyCheckJob RunbaseBatch class
        BOMHierarchyCheckJob::main(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBOMLevel</Name>
				<Source><![CDATA[
    boolean checkBOMLevel(int _nodeIdx)
    {
        BOM     bomCircularCheck;
        int     parents    = this.countParentPath(_nodeIdx);
        int     checkLimit = BOMParameters::find().bomMaxLevel;

        checkLimit = (checkLimit && checkLimit < 100) ? checkLimit : 100;

        if (   node2record.exists(_nodeIdx)
            && parents > checkLimit)
        {
            bomCircularCheck = node2record.lookup(_nodeIdx);
            if (!bomCircularCheck.checkNotCircularity())
            {
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearAll</Name>
				<Source><![CDATA[
    void clearAll()
    {
        this.clearRoute();
        this.clearBOM();
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearBOM</Name>
				<Source><![CDATA[
    void clearBOM()
    {
        tree.deleteAll();

        node2record      = new Map(Types::Integer, Types::Record);
        nodeBOMStatus    = new Map(Types::Integer, Types::Integer);
        nodeCanHaveBOM   = new Map(Types::Integer, Types::Integer);
        nodeCanHaveRoute = new Map(Types::Integer, Types::Integer);
        node2BOMTable    = new Map(Types::Integer, Types::Record);
        recId2Node       = new Map(typeName2Type(extendedTypeStr(RecId)), Types::Integer);

        pmfCoByRecId2Node = new Map(typeName2Type(extendedTypeStr(RecId)),Types::Integer);
        pmfNode2CoBy      = new Map(Types::Integer,Types::Record);
        pmfCoByNodes      = new Set(Types::Integer);

        caller           = null;
        rootId           = 0;
        itemId           = '';
        bomId            = '';
        routeId          = '';
        callerCanHaveBOM = false;
        if (#PmfEnabled)
        {
            pmfCallerCanHaveFormula = false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearRoute</Name>
				<Source><![CDATA[
    void clearRoute()
    {
        if (lockRoute)
        {
            this.releaseRoute(tree.getSelection() ? tree.getSelection() : rootId);
        }
        node2RouteTable  = new Map(Types::Integer, Types::Record);
        nodeRouteStatus  = new Map(Types::Integer, Types::Integer);
        nodeIdRoute      = 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>configId</Name>
				<Source><![CDATA[
    EcoResItemConfigurationName configId(int _nodeIdx = 0)
    {
        BOM   bomCache;

        if (    _nodeIdx==rootId
            || !_nodeIdx)
        {
            return tmpBOMRouteTree.inventDim().ConfigId;
        }
        else
        {
            bomCache = node2record.lookup(_nodeIdx);
            return bomCache.inventDim().ConfigId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>controlFormatExplain</Name>
				<Source><![CDATA[
    void controlFormatExplain(
        FormStaticTextControl _formatExplain,
        TmpBOMRouteTree   _tmpBOMRouteTree = tmpBOMRouteTree)
    {
        _formatExplain.text(this.formatTxt(_tmpBOMRouteTree));
    }

]]></Source>
			</Method>
			<Method>
				<Name>copyLine</Name>
				<Source><![CDATA[
    boolean copyLine(
        int _copyNodeIdx,
        int _dropNodeIdx)
    {
        BOM         bomDrop;
        BOM         bomNew;
        BOM         bomTmp;
        BOMId       bomIdNew;
        BOMTable    bomTable;
        InventDim   inventDim;

        if (   !_copyNodeIdx
            || !_dropNodeIdx
            || _copyNodeIdx == _dropNodeIdx
            || _copyNodeIdx == rootId)
        {
            return false;
        }

        if (   _dropNodeIdx != rootId
            && (!node2record.exists(_dropNodeIdx)
            ||  !node2record.exists(_copyNodeIdx)))
        {
            return false;
        }

        if (this.isNodeChild(_copyNodeIdx,_dropNodeIdx) && nodeCanHaveBOM.exists(_copyNodeIdx))
        {
            return checkFailed("@SYS67116");
        }

        if (_dropNodeIdx != rootId)
        {
            bomDrop = node2record.lookup(_dropNodeIdx);
        }

        bomTmp  = node2record.lookup(_copyNodeIdx);

        if (   bomDrop.RecId
            && bomTmp.RecId
            && bomDrop.RecId == bomTmp.RecId)
        {
            return false;
        }

        bomNew.initFromBOM(bomTmp);

        if (bomNew.inventDim().ConfigId && bomNew.ConfigGroupId)
        {
            inventDim          = bomNew.inventDim();
            inventDim.ConfigId = '';
            bomNew.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
        }
        if (nodeCanHaveBOM.exists(_dropNodeIdx))
        {
            if (_dropNodeIdx == rootId)
            {
                bomIdNew = bomId;
            }
            else
            {
                bomTable = node2BOMTable.lookup(_dropNodeIdx);
                bomIdNew = bomTable.bomId;
            }
            if (!bomIdNew)
            {
                return checkFailed(strFmt("@SYS67032",_dropNodeIdx == rootId ? itemId : bomDrop.ItemId));
            }
            bomNew.bomId   = bomIdNew;
            bomNew.LineNum = BOM::nextLineNum(bomNew.bomId);
        }
        else
        {
            bomNew.bomId = bomDrop.bomId;
            if (!bomNew.setLineNumAfter(bomDrop))
            {
                this.reNumberBOM(bomDrop);
                bomDrop = node2record.lookup(_dropNodeIdx);
                bomNew.setLineNumAfter(bomDrop);
            }
        }
        if (!bomNew.validateWrite(false))
        {
            return false;
        }
        if (    BOMParameters::find().mustCheckPerLine()
            && !bomNew.checkNotCircularity())
        {
            return false;
        }

        ttsbegin;
        bomNew.insert();
        ttscommit;

        this.insertBOM(bomNew, _dropNodeIdx, this.parentNodeId(_dropNodeIdx), _dropNodeIdx);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countParentPath</Name>
				<Source><![CDATA[
    int countParentPath(int _nodeIdx)
    {
        int counter,i;

        if (    _nodeIdx == rootId
            || !_nodeIdx)
        {
            return 0;
        }

        counter++;

        i = tree.getParent(_nodeIdx);

        while (i != rootId)
        {
            counter++;
            i = tree.getParent(i);
        }
        return counter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteBOM</Name>
				<Source><![CDATA[
    void deleteBOM(int _nodeIdx)
    {
        MapIterator     mi;
        int             i;
        BOM             bomCache;
        BOM             bomDelete;
        recId           delRecId;
        container       deleteNodes;
        boolean         mustReleaseRoute;

        if (   !_nodeIdx
            ||  _nodeIdx == rootId
            || !node2record.exists(_nodeIdx))
        {
            return;
        }

        bomCache = node2record.lookup(_nodeIdx);
        delRecId = bomCache.RecId;

        if (!delRecId)
        {
            return;
        }

        mi = new MapIterator(node2record);

        ttsbegin;
        delete_from bomDelete
            where bomDelete.RecId == delRecId;
        ttscommit;

        while (mi.more())
        {
            bomCache = node2record.lookup(mi.key());
            if (bomCache.RecId == delRecId)
            {
                if (   lockRoute
                    && nodeIdRoute == mi.key()
                    || this.isNodeChild(mi.key(),nodeIdRoute))
                {
                    mustReleaseRoute = true;
                }
                deleteNodes += this.deleteChildrenCollect(mi.key());
                deleteNodes += mi.key();
            }
            mi.next();
        }
        for (i=1;i<=conLen(deleteNodes);i++)
        {
            this.deleteNode(conPeek(deleteNodes,i));
        }

        if (mustReleaseRoute)
        {
            this.releaseRoute(nodeIdRoute,false);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteChildrenCollect</Name>
				<Source><![CDATA[
    container deleteChildrenCollect(int _nodeIdx)
    {
        container   nodeDelete;
        int         child;

        if (   !_nodeIdx
            || !nodeCanHaveBOM.exists(_nodeIdx))
        {
            return conNull();
        }

        child = _nodeIdx ? tree.getChild(_nodeIdx) : 0;

        while (child)
        {
            nodeDelete += this.deleteChildrenCollect(child);
            nodeDelete += child;
            child       = tree.getNextSibling(child);
        }

        return nodeDelete;
    }

]]></Source>
			</Method>
			<Method>
				<Name>deleteNode</Name>
				<Source><![CDATA[
    void deleteNode(int _nodeIdx)
    {
        if (node2record.exists(_nodeIdx))
        {
            node2record.remove(_nodeIdx);
        }

        if (nodeBOMStatus.exists(_nodeIdx))
        {
            nodeBOMStatus.remove(_nodeIdx);
        }

        if (nodeCanHaveBOM.exists(_nodeIdx))
        {
            nodeCanHaveBOM.remove(_nodeIdx);
        }

        if (nodeCanHaveRoute.exists(_nodeIdx))
        {
            nodeCanHaveRoute.remove(_nodeIdx);
        }

        if (node2BOMTable.exists(_nodeIdx))
        {
            node2BOMTable.remove(_nodeIdx);
        }

        if (node2RouteTable.exists(_nodeIdx))

        {
            node2RouteTable.remove(_nodeIdx);
        }

        if (nodeRouteStatus.exists(_nodeIdx))
        {
            nodeRouteStatus.remove(_nodeIdx);
        }

        if (pmfNode2CoBy.exists(_nodeIdx))
        {
            pmfNode2CoBy.remove(_nodeIdx);
        }
        if (pmfCoByRecId2Node.exists(_nodeIdx))
        {
            pmfCoByRecId2Node.remove(_nodeIdx);
        }

        tree.delete(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandNode</Name>
				<Source><![CDATA[
    void expandNode(int _nodeIdx)
    {
        BOM         bom;
        BOMTable    bomTable;

        if (    nodeCanHaveBOM.exists(_nodeIdx)
            && !nodeBOMStatus.exists(_nodeIdx)
            && (node2record.exists(_nodeIdx)
            ||  _nodeIdx == rootId))
        {
            if (_nodeIdx == rootId)
            {
                this.buildOneNode(rootId,bomId,itemId,tmpBOMRouteTree.inventDim().ConfigId);
            }
            else
            {
                bom         = node2record.lookup(_nodeIdx);
                bomTable    = node2BOMTable.lookup(_nodeIdx);
                this.buildOneNode(_nodeIdx,bomTable.bomId,bom.ItemId,bom.inventDim().ConfigId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>formatTxt</Name>
				<Source><![CDATA[
    FormatTxt formatTxt(TmpBOMRouteTree _tmpBOMRouteTree = tmpBOMRouteTree)
    {
        FormatTxt lineTxt;

        lineTxt += (_tmpBOMRouteTree.bomShowItemId        ? ((lineTxt ? ' / ' : '') + "@SYS12836") : '');

        Enumerator enum = InventProductDimension::getEnumeratorForEnabledDimensions();
        while (enum.moveNext())
        {
            InventProductDimension productDim = enum.current();
            if (_tmpBOMRouteTree.showProductDimension(productDim))
            {
                lineTxt += lineTxt ? ' / ' : '';
                lineTxt += productDim.label();
            }
        }

        lineTxt += (_tmpBOMRouteTree.bomShowItemName      ? ((lineTxt ? ' / ' : '') + "@SYS7399")  : '');
        lineTxt += (_tmpBOMRouteTree.bomShowBOMQty        ? ((lineTxt ? ' / ' : '') + "@SYS14578") : '');
        lineTxt += (_tmpBOMRouteTree.bomShowUnitId        ? ((lineTxt ? ' / ' : '') + "@SYS11959") : '');
        lineTxt += (_tmpBOMRouteTree.bomShowConfigGroupId ? ((lineTxt ? ' / ' : '') + "@SYS6126")  : '');
        lineTxt += (_tmpBOMRouteTree.bomShowFromDate      ? ((lineTxt ? ' / ' : '') + "@SYS5209")  : '');
        lineTxt += (_tmpBOMRouteTree.bomShowToDate        ? ((lineTxt ? ' / ' : '') + "@SYS14656") : '');
        lineTxt += (_tmpBOMRouteTree.bomShowItemBOMId     ? ((lineTxt ? ' / ' : '') + "@SYS27533") : '');
        lineTxt += (_tmpBOMRouteTree.bomShowItemRouteId   ? ((lineTxt ? ' / ' : '') + "@SYS27537") : '');
        lineTxt += (_tmpBOMRouteTree.bomShowOprNum        ? ((lineTxt ? ' / ' : '') + "@SYS14357") : '');
        lineTxt += (_tmpBOMRouteTree.bomShowBOMType       ? ((lineTxt ? ' / ' : '') + "@SYS9844")  : '');

        return lineTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getBOMDesignerParams</Name>
				<Source><![CDATA[
    container getBOMDesignerParams()
    {
        return [this.canViewBomVersionInfomation(), this.bomRouteVersionPrinciple(), this.versionDate()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Gets the last choice that is stored in the last value table.
    /// </summary>
    /// <remarks>
    ///    If no record can be found or the <c>unpack</c> method returns false, the <c>initParmDefault</c>
    ///    will be called. Normally, this method should not be overridden.
    /// </remarks>
    public void getLast()
    {
        InventDim       inventDim;

        super();

        if (tmpBOMRouteTree.bomRouteInventDimId)
        {
            inventDim.InventSiteId              = InventDim::find(tmpBOMRouteTree.bomRouteInventDimId).InventSiteId;
            tmpBOMRouteTree.bomRouteInventDimId = InventDim::findOrCreate(inventDim).InventDimId;
        }

        tmpBOMRouteTree.bomRouteDate    = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        tmpBOMRouteTree.RouteShowOprNum = NoYes::Yes;
        tmpBOMRouteTree.AutoEdit        = this.canEditBomInfomation() ? tmpBOMRouteTree.AutoEdit : false;

        if (   callerTableId == tableNum(SalesLine)
            || callerTableId == tableNum(PurchLine))
        {
            tmpBOMRouteTree.bomDateValidOnly            = NoYes::Yes;
            tmpBOMRouteTree.bomRouteVersionPrinciple    = BOMRouteVersionSelect::Active;
        }

        if (!this.canViewBomVersionInfomation() && !this.canViewRouteInfomation())
        {
            tmpBOMRouteTree.bomRouteVersionPrinciple    = BOMRouteVersionSelect::Active;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLastChild</Name>
				<Source><![CDATA[
    int getLastChild(int _parentNodeIdx)
    {
        int curChild;
        int nextChild = tree.getChild(_parentNodeIdx);

        if (!nextChild)
        {
            return _parentNodeIdx;
        }

        while (nextChild)
        {
            curChild  = nextChild;
            nextChild = tree.getNextSibling(curChild);
        }

        return curChild;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentBOMItemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the item number of the parent <c>BOM</c> line record.
    /// </summary>
    /// <param name = "_bom">The current <c>BOM</c> line record.</param>
    /// <returns>Item number from parent <c>BOM</c> line record if exists; otherwise, empty item number.</returns>
    ItemId getParentBOMItemId(BOM _bom)
    {
        int parentIdx = this.recId2Node(_bom.RecId);
        if (!parentIdx)
        {
            return '';
        }

        parentIdx = tree.getParent(parentIdx);

        if (!node2record.exists(parentIdx))
        {
            return '';
        }

        BOM parentBOM = node2record.lookup(parentIdx);
        
        return parentBOM.ItemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getParentRouteId</Name>
				<Source><![CDATA[
    RouteId getParentRouteId(BOM _bom)
    {
        int     parentIdx;
        BOM     parentBOM;

        parentIdx       = this.recId2Node(_bom.RecId);
        if (!parentIdx)
        {
            return '';
        }

        parentIdx = tree.getParent(parentIdx);

        if (parentIdx == rootId)
        {
            return routeId;
        }
        else
        {
            if (!node2record.exists(parentIdx))
            {
                return routeId;
            }

            parentBOM = node2record.lookup(parentIdx);
            if (!parentBOM)
            {
                return routeId;
            }

            return parentBOM.itemRouteIdConstruction(
                this.canViewRouteInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                    this.versionDate(),
                    tmpBOMRouteTree.bomRouteFromQty,
                    tmpBOMRouteTree.inventDim());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getRouteTable</Name>
				<Source><![CDATA[
    RouteTable getRouteTable(int _nodeIdx)
    {
        RouteTable  routeTable;
        BOM         bom;

        if (_nodeIdx == rootId)
        {
            routeTable = RouteTable::find(routeId);
        }
        else if (node2record.exists(_nodeIdx))
        {
            bom = node2record.lookup(_nodeIdx);
            routeTable = RouteTable::find(bom.itemRouteIdConstruction(this.canViewRouteInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                          this.versionDate(),
                                          tmpBOMRouteTree.bomRouteFromQty,
                                          bom.inventDim()));
        }

        return routeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parentNodeId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the parent node Id for a node.
    /// </summary>
    /// <param name = "_nodeIdx">The Id of the node to get the parent for.</param>
    /// <returns>The parent node Id for a node.</returns>
    int parentNodeId(int _nodeIdx)
    {
        return tree.getParent(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>prevSiblingNodeId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the previous sibling node Id for a node.
    /// </summary>
    /// <param name = "_nodeIdx">The Id of the node to get the sibling for.</param>
    /// <returns>The previous sibling node Id for a node.</returns>
    int prevSiblingNodeId(int _nodeIdx)
    {
        return tree.getPrevSibling(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasChildren</Name>
				<Source><![CDATA[
    boolean hasChildren(int _nodeIdx)
    {
        return tree.getChild(_nodeIdx) ? true : false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageList</Name>
				<Source><![CDATA[
    Imagelist imageList()
    {
        if (!imageList)
        {
            imageList = PmfImageListAppl_FormulaRouteTree::construct();
        }

        return imageList.imageList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>imageListState</Name>
				<Source><![CDATA[
    Imagelist imageListState()
    {
        if (!imageListState)
        {
            imageListState = new ImageListAppl_StateReq();
        }

        return imageListState.imageList();
    }

]]></Source>
			</Method>
			<Method>
				<Name>initRouteView</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the route and operation data sources based on the settings.
    /// </summary>
    public void initRouteView()
    {
        routeDS.object(fieldnum(Route, OprNum)).visible(tmpBOMRouteTree.RouteShowOprNum);
        routeDS.object(fieldnum(Route, OprPriority)).visible(tmpBOMRouteTree.RouteShowOprPriority);
        routeDS.object(fieldnum(Route, OprId)).visible(tmpBOMRouteTree.RouteShowOprId);
        routeDS.object(fieldnum(Route, ErrorPct)).visible(tmpBOMRouteTree.RouteShowErrorPct);
        routeDS.object(fieldnum(Route, AccError)).visible(tmpBOMRouteTree.RouteShowAccError);
        routeDS.object(fieldnum(Route, OprNumNext)).visible(tmpBOMRouteTree.RouteShowOprNumNext);
        routeOprTableDS.object(fieldnum(RouteOprTable, Name)).visible(tmpBOMRouteTree.RouteShowOprName);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initParmDefault</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Initializes the internal variables.
    /// </summary>
    /// <remarks>
    ///    This method is called when no <c>SysLastValue</c> record can be found when calling the
    ///    <c>SysLastValue.GetLast</c> method. Remember to call the <c>super</c> method.
    /// </remarks>
    void initParmDefault()
    {
        tmpBOMRouteTree.bomShowItemId        = NoYes::Yes;
        tmpBOMRouteTree.bomShowItemName      = NoYes::Yes;
        tmpBOMRouteTree.bomShowConfigId      = NoYes::No;
        tmpBOMRouteTree.RouteShowOprNum      = NoYes::Yes;
        tmpBOMRouteTree.RouteShowOprPriority = NoYes::Yes;
        tmpBOMRouteTree.RouteShowOprName     = NoYes::Yes;
        tmpBOMRouteTree.RouteShowOprNumNext  = NoYes::Yes;
        tmpBOMRouteTree.bomDateValidOnly     = NoYes::Yes;
        tmpBOMRouteTree.MaxBOMLevel          = 10;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewBOMVersion</Name>
				<Source><![CDATA[
    /// <summary>
    /// Create a new bom and version for a node.
    /// </summary>
    /// <returns>true if a new version was created; otherwise, false.</returns>
    /// <param name = "_nodeIdx">The Id of the node to create for.</param>
    public boolean createNewBOMVersion(int _nodeIdx)
    {
        InventTable inventTable = inventTable::find(this.itemId(_nodeIdx));
        InventSiteId siteId = this.siteIdContext(_nodeIdx, false);
        bomId bomIdFrom = this.bomId(_nodeIdx);

        var createParms = BOMAndVersionCreateParms::newParms(inventTable, bomIdFrom, siteId, inventTable.isFormulaAllowed(), false);
        var args = new Args();
        args.parmObject(createParms);

        MenuFunction menuFunction = new MenuFunction(menuItemActionStr(BOMAndVersionCreate), MenuItemType::Action);
        menuFunction.run(args);

        if (createParms.parmOutCreatedBomVersion())
        {
            createParms.parmOutCreatedBomVersion().setSelected();
            if (tmpBOMRouteTree.BOMRouteVersionPrinciple != BOMRouteVersionSelect::Active)
            {
                this.resetBOM(inventTable.ItemId, false);
            }
            return true;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts the treenode for a newly created BOM.
    /// </summary>
    /// <param name = "_bomNew">The BOM record to insert the node for.</param>
    /// <param name = "_nodeIdx">The Id of the original selected node; optional.</param>
    /// <param name = "_parentNodeIdx">The Id of the parent node; optional.</param>
    /// <param name = "_nodeIdxToInsertAfter">The Id of the sibling node to insert after; optional.</param>
    /// <param name = "_doSelectNode">Determines if the inserted node should be selected; optional.</param>
    void insertBOM(
        BOM  _bomNew,
        int _nodeIdx = curDropNode,
        int _parentNodeIdx = curParentNodeIdx,
        int _nodeIdxToInsertAfter = curNodeIdxToInsertAfter,
        boolean _doSelectNode = true
        )
    {
        int selectNode;

        if (!this.isBOMDateValid(_bomNew))
        {
            info(strFmt("@SYS67128", date2StrUsr(this.versionDate(), DateFlags::FormatAll)));
            return;
        }

        FormTreeItem dropTreeItem = tree.getItem(_parentNodeIdx);

        if (_nodeIdx == _parentNodeIdx
            && this.nodeCanHaveBOM(_parentNodeIdx)
            && !dropTreeItem.stateExpandedOnce()
            && BOMTable::find(_bomNew.bomId).PmfBOMFormula != PmfBOMFormula::Formula)
        {
            if (nodeBOMStatus.exists(_parentNodeIdx) && !this.hasChildren(_parentNodeIdx))
            {
                nodeBOMStatus.remove(_parentNodeIdx);
            }
            tree.expand(_parentNodeIdx, FormTreeExpand::Expand);
            selectNode = this.getLastChild(_parentNodeIdx);
        }
        else
        {
            // Special logic is needed when inserting above the first child as the Tree API do not support adding nodes above
            boolean moveFirstChild = false;
            if (_nodeIdxToInsertAfter == 0)
            {
                int firstChild = tree.getChild(_parentNodeIdx);
                if (firstChild != 0)
                {
                    moveFirstChild = true;
                    _nodeIdxToInsertAfter = firstChild;
                }
            }

            this.bomSetInventDimFinal(_bomNew, _parentNodeIdx);
            int newIdx = tree.add(_parentNodeIdx, _nodeIdxToInsertAfter, this.nodeTxt(_bomNew,_bomNew.inventTable()),this.nodeImage(_bomNew.inventTable()));

            this.pmfAddOverlay(newIdx, _bomNew);
            selectNode  = newIdx;
            this.insertBOMRecord(newIdx,_bomNew);
            if (BOMDesignerCtrl::itemCanHaveBOM(_bomNew.inventTable()))
            {
                if (_bomNew.inventTable().inventItemType().canHaveRoutes())
                {
                    nodeCanHaveRoute.insert(newIdx,1);
                }
                this.setNodeBOM(newIdx);

                BOMTable bomTable = BOMTable::find(_bomNew.itemBOMIdConstruction(this.canViewBomVersionInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                this.versionDate(),
                                                                                tmpBOMRouteTree.bomRouteFromQty,
                                                                                _bomNew.inventDim()));
                node2BOMTable.insert(newIdx,bomTable);

                if (!bomTable.RecId)
                {
                    FormTreeItem treeItem = tree.getItem(newIdx);
                    treeItem.stateImage(imageListState.image(#ImageStateNotAtAllOK));
                    treeItem.stateExpanded(true);
                    tree.setItem(treeItem);
                }
            }

            if (moveFirstChild)
            {
                // Swap the two nodes around so the existing item becomes the lower one
                BOM bomToMove = node2record.lookup(_nodeIdxToInsertAfter);
                this.deleteNode(_nodeIdxToInsertAfter);
                this.insertBOM(bomToMove, newIdx, _parentNodeIdx, newIdx, false);
            }
        }

        if (selectNode && _doSelectNode)
        {
            tree.select(selectNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertBOMRecord</Name>
				<Source><![CDATA[
    void insertBOMRecord(
        int _id,
        BOM _bom)
    {
        node2record.insert(_id,_bom);
        recId2Node.insert(_bom.RecId,_id);
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertRoute</Name>
				<Source><![CDATA[
    void insertRoute(int _bomNodeIdx)
    {
        RouteTable      routeTable;
        int             connectedBOMNode = _bomNodeIdx;

        if (!nodeRouteStatus.exists(_bomNodeIdx))
        {
            routeTable = this.selectRoute(_bomNodeIdx);
        }
        else if (node2RouteTable.exists(_bomNodeIdx))
        {
            routeTable = node2RouteTable.lookup(_bomNodeIdx);
        }

        if (! nodeCanHaveBOM.exists(_bomNodeIdx))
        {
            connectedBOMNode = tree.getParent(_bomNodeIdx);
        }

        this.setRouteInfo(routeTable,connectedBOMNode);

        nodeIdRoute = _bomNodeIdx;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertTopNode</Name>
				<Source><![CDATA[
    int insertTopNode()
    {
        FormTreeItem    treeItem;
        int             newId;
        BOMTable        bomTable;

        if (!callerCanHaveBOM
            && !pmfCallerCanHaveFormula
            )
        {
            return 0;
        }

        newId = tree.add(0,0,this.topNodeTxt(),this.topNodeImage());
        this.setNodeBOM(newId);
        bomTable = BOMTable::find(bomId);
        node2BOMTable.insert(newId,bomTable);
        nodeCanHaveRoute.insert(newId,1);

        if (!bomTable.RecId)
        {
            treeItem = tree.getItem(newId);
            treeItem.stateImage(imageListState.image(#ImageStateNotAtAllOK));
            treeItem.stateExpanded(true);
            tree.setItem(treeItem);
        }
        rootId = newId;
        return newId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDim</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Retrieves the related <c>InventDim</c> record for a node.
    /// </summary>
    /// <param name="_nodeIdx">
    ///    An integer that holds the node ID; optional.
    /// </param>
    /// <returns>
    ///    An <c>InventDim</c> record.
    /// </returns>
    public InventDim inventDim(int _nodeIdx = rootId)
    {
        BOM   bomCache;

        if (_nodeIdx == rootId)
        {
            return InventDim::find(tmpBOMRouteTree.bomRouteInventDimId);
        }
        else
        {
            if (node2record.exists(_nodeIdx))
            {
                bomCache = node2record.lookup(_nodeIdx);
            }
            return bomCache.inventDim();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isBOMDateValid</Name>
				<Source><![CDATA[
    boolean isBOMDateValid(
        BOM     _bom,
        boolean _includeSetupFlag = true)
    {
        if (    _includeSetupFlag
            && !tmpBOMRouteTree.bomDateValidOnly)
        {
            return true;
        }

        if (   (_bom.ToDate   < tmpBOMRouteTree.bomRouteDate
            &&  _bom.ToDate)
            || (_bom.FromDate > tmpBOMRouteTree.bomRouteDate
            &&  _bom.FromDate))
        {
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isNodeChild</Name>
				<Source><![CDATA[
    boolean isNodeChild(
        int _curNode,
        int _childNode)
    {
        int tmpIdx_1,tmpIdx_2;

        if (_curNode == rootId)
        {
            return true;
        }

        if (   _curNode   == _childNode
            || _childNode == rootId)
        {
            return false;
        }

        tmpIdx_2 = _childNode;

        while (true)
        {
            tmpIdx_1 = tree.getParent(tmpIdx_2);
            if (!tmpIdx_1)
            {
                return false;
            }
            if (tmpIdx_1 == _curNode)
            {
                return true;
            }
            if (tmpIdx_1 == rootId)
            {
                return false;
            }
            tmpIdx_2 = tmpIdx_1;
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPmfCoByLeaf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if node with id _nodeIdx, is in the tree.
    /// </summary>
    /// <param name="_nodeIdx">Node Id to search for.</param>
    /// <returns>Result of search for node with Id Idx.</returns>
    public boolean isPmfCoByLeaf(int _nodeIdx)
    {
        return #PmfEnabled && pmfNode2CoBy.exists(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPmfCoByNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if node with id _nodeIdx, is in the tree.
    /// </summary>
    /// <param name="_nodeIdx">Node Id to search for.</param>
    /// <returns>result of search for node with Id Idx.</returns>
    public boolean isPmfCoByNode(int _nodeIdx)
    {
        return #PmfEnabled && pmfCoByNodes.in(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPmfIdx</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs a search of tree for a node, or leaf, with the index _dropNodeIdx.
    /// </summary>
    /// <param name="_dropNodeIdx">Index to search for.</param>
    /// <returns>Result of search for node with Id Idx.</returns>
    public boolean isPmfIdx(int _dropNodeIdx)
    {
        return #PmfEnabled
            && (this.isPmfCoByNode(_dropNodeIdx)
                || this.isPmfCoByLeaf(_dropNodeIdx));
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the Id of the item that a node represents.
    /// </summary>
    /// <param name = "_nodeIdx">The index of the node.</param>
    /// <returns>The id od the item.</returns>
    public ItemId itemId(int _nodeIdx)

    {
        if (_nodeIdx == rootId)

        {
            return itemId;
        }
        else

        {
            if (node2record.exists(_nodeIdx))
            {
                BOM bomCache = node2record.lookup(_nodeIdx);
                return bomCache.ItemId;
            }
            else if (pmfNode2CoBy.exists(_nodeIdx))
            {
                PmfFormulaCoBy coBy = pmfNode2CoBy.lookup(_nodeIdx);
                return coBy.ItemId;
            }
        }

        return '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>lastValueDesignName</Name>
				<Source><![CDATA[
    public identifierName lastValueDesignName()
    {
        return tableId2name(callerTableId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLoading</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the tree is being loaded.
    /// </summary>
    /// <returns>true if the tree is being loaded; otherwise, false.</returns>
    public boolean isLoading()
    {
        return isLoading;
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkActive</Name>
				<Source><![CDATA[
    void linkActive(
        Common          _caller,
        TmpBOMRouteTree _setup
        )
    {
        this.clearAll();
        isLoading = true;

        tmpBOMRouteTree.data(_setup);
        this.setCallerData(_caller);
        this.buildOneNode(this.insertTopNode(),bomId,itemId,tmpBOMRouteTree.inventDim().ConfigId);

        isLoading = false;
        if (rootId)
        {
            tree.select(rootid);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkOpr</Name>
				<Source><![CDATA[
    void linkOpr(
        FormListItem _listItem,
        int          _curTreeItem)
    {
        int curBOMNode  = _curTreeItem;
        int newOpr      = str2int(_listItem.text());
        BOM bom,bomUpd;

        if (   !curBOMNode
            || !newOpr
            || !node2record.exists(curBOMNode))
        {
            return;
        }

        bom = node2record.lookup(curBOMNode);

        if (!bom.RecId)
        {
            return;
        }

        ttsbegin;
        select firstonly forupdate bomUpd
            where bomUpd.RecId == bom.RecId;

        if (bomUpd)
        {
            bomUpd.OprNum = newOpr;
            bomUpd.update();
        }
        ttscommit;

        this.updateBOM(bomUpd,false);

        if (curBOMNode != tree.getSelection())
        {
            tree.select(curBOMNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>lockRoute</Name>
				<Source><![CDATA[
    void lockRoute(int _nodeIdx)
    {
        if (!this.canLockRoute(_nodeIdx))
        {
            return;
        }

        nodeIdRoute = 0;
        if (_nodeIdx)
        {
            this.setRoute(_nodeIdx);
        }

        lockRoute = true;
        FormTreeItem treeItem = tree.getItem(nodeIdRoute);
        treeItem.overlayImage(imageListState.image(#ImageOverlayRedLock));
        tree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>moveLine</Name>
				<Source><![CDATA[
    boolean moveLine(
        int _moveNodeIdx,
        int _dropNodeIdx)
    {
        BOM         bomDrop;
        BOM         bomNew;
        BOM         bomTmp;
        BOMId       bomIdNew;
        BOMTable    bomTable;
        InventDim   inventDim;

        if (   !_moveNodeIdx
            || !_dropNodeIdx
            || _moveNodeIdx == _dropNodeIdx
            || _moveNodeIdx == rootId)
        {
            return false;
        }

        if (   _dropNodeIdx != rootId
            && (!node2record.exists(_dropNodeIdx)
            ||  !node2record.exists(_moveNodeIdx)))
        {
            return false;
        }

        if (nodeCanHaveBOM.exists(_moveNodeIdx))
        {
            if (    this.isNodeChild(_moveNodeIdx,_dropNodeIdx)
                || !this.canMoveNode(_moveNodeIdx,_dropNodeIdx))
            {
                return checkFailed("@SYS67116");
            }
        }

        if (_dropNodeIdx != rootId)
        {
            bomDrop = node2record.lookup(_dropNodeIdx);
        }

        bomTmp = node2record.lookup(_moveNodeIdx);

        if (   bomDrop.RecId
            && bomTmp.RecId
            && bomDrop.RecId == bomTmp.RecId)
        {
            return false;
        }

        bomNew.initFromBOM(bomTmp);

        if (   bomNew.inventDim().ConfigId
            && bomNew.ConfigGroupId)
        {
            inventDim          = bomNew.inventDim();
            inventDim.ConfigId = '';
            bomNew.InventDimId = InventDim::findOrCreate(inventDim).InventDimId;
        }

        if (nodeCanHaveBOM.exists(_dropNodeIdx))
        {
            if (_dropNodeIdx == rootId)
            {
                bomIdNew = bomId;
            }
            else
            {
                bomTable = node2BOMTable.lookup(_dropNodeIdx);
                bomIdNew = bomTable.bomId;
            }

            if (!bomIdNew)
            {
                return checkFailed(strFmt("@SYS67032",_dropNodeIdx == rootId ? itemId : bomDrop.ItemId));
            }
            bomNew.bomId   = bomIdNew;
            bomNew.LineNum = BOM::nextLineNum(bomNew.bomId);
        }
        else
        {
            bomNew.bomId = bomDrop.bomId;
            if (!bomNew.setLineNumAfter(bomDrop))
            {
                this.reNumberBOM(bomDrop);
                bomDrop = node2record.lookup(_dropNodeIdx);
                bomNew.setLineNumAfter(bomDrop);
            }
        }
        if (    BOMParameters::find().mustCheckPerLine()
            && !bomNew.checkNotCircularity())
        {
            return false;
        }

        if (!bomNew.validateWrite(false))
        {
            return checkFailed("@SYS25904");
        }

        this.deleteBOM(_moveNodeIdx);

        ttsbegin;
        if (!bomNew.validateWrite())
        {
            throw error("@SYS25904");
        }
        bomNew.insert();
        ttscommit;

        this.insertBOM(bomNew,_dropNodeIdx,this.parentNodeId(_dropNodeIdx),_dropNodeIdx);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustDeleteChildrenBOMChange</Name>
				<Source><![CDATA[
    boolean mustDeleteChildrenBOMChange(
        BOM _bomOld,
        BOM _boMnew)
    {
        if (    _bomOld.ItemId                   != _boMnew.ItemId
            ||  _bomOld.ConfigGroupId            != _boMnew.ConfigGroupId
            ||  _bomOld.inventDim().ConfigId     != _boMnew.inventDim().ConfigId
            ||  _bomOld.FromDate                 != _boMnew.FromDate
            ||  _bomOld.ToDate                   != _boMnew.ToDate
            ||  _bomOld.ItemBOMId                != _boMnew.ItemBOMId
            ||  _bomOld.ItemRouteId              != _boMnew.ItemRouteId
            || !this.isBOMDateValid(_boMnew)
           )
        {
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustUpdateDelayedInfo</Name>
				<Source><![CDATA[
    boolean mustUpdateDelayedInfo()
    {
        int nodeIdx = tree.getSelection();

        if (   nodeIdx != lastDelayNode
            || nodeIdx == 0
            || nodeIdx == rootId)
        {
            lastDelayNode = nodeIdx;
            return true;
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    void new(
        FormRun                _fr,
        FormTreeControl        _tree,
        FormGroupControl       _bomGroup,
        FormGroupControl      _routeGroup,
        tableId                _callerTableId,
        FormDataSource         _routeDS,
        FormDataSource         _routeOprTableDS
        )
    {
        fr                      = _fr;
        tree                    = _tree;

        bomGroup                = _bomGroup;
        routeGroup              = _routeGroup;

        callerTableId           = _callerTableId;

        routeDS                 = _routeDS;
        routeOprTableDS         = _routeOprTableDS;

        this.getLast();

        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>nodeCanHaveBOM</Name>
				<Source><![CDATA[
    boolean nodeCanHaveBOM(int _nodeIdx)
    {
        return nodeCanHaveBOM.exists(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>nodeImage</Name>
				<Source><![CDATA[
    ImageRes nodeImage(InventTable _inventTable)
    {
        return imageList.image(_inventTable.inventItemType().imageRessNo());
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTextFormatCode</Name>
				<Source><![CDATA[
    protected str getTextFormatCode()
    {
        // formating the text according to LTR or RTL
        if (currentSessionLanguageRTL())
        {
            //using RLM (right-to-left mark) to define the text orientation
            //%1 - previous chunk of text (RTL)
            //%2 - separator - (ascii or LTR)
            //%3 - added chunk (RTL)
            return '%1\u200F%2\u200E%3\u200F';
        }

        // regular text
        return '%1%2%3';
    }

]]></Source>
			</Method>
			<Method>
				<Name>nodeTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the description of the individual BOM line with the requested fields that fill a node in the BOM designer control.
    /// </summary>
    /// <param name="_bom">
    /// The BOM line to create the description for.
    /// </param>
    /// <param name="_inventTable">
    /// The item associated with the BOM line.
    /// </param>
    /// <returns>
    /// The text string that describes the BOM line.
    /// </returns>
    /// <remarks>
    /// The output of the text forces the correct RTL order, if the client is running in an RTL environment.
    /// </remarks>
    str nodeTxt(
        BOM         _bom,
        InventTable _inventTable)
    {
        str         lineTxt;
        str         formatCode  = this.getTextFormatCode();
        InventDim   inventDim   = _bom.inventDim();

        if (tmpBOMRouteTree.bomShowItemId)
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.ItemId ? _bom.ItemId : EmptyValue));
        }

        Enumerator enum = InventProductDimension::getEnumeratorForEnabledDimensions();
        while (enum.moveNext())
        {
            InventProductDimension productDim = enum.current();
            if (tmpBOMRouteTree.showProductDimension(productDim))
            {
                anytype productDimFieldValue = inventDim.(productDim.parmInventDimFieldId());
                lineTxt = strFmt(formatCode, lineTxt, lineTxt ? ' / ' : '', productDimFieldValue ? productDimFieldValue : EmptyValue);
            }
        }

        if (tmpBOMRouteTree.bomShowItemName)
        {
            EcoResProductName productName = _inventTable.defaultProductName();
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (productName ? productName : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowBOMQty)
        {
            Integer qtyDecimals = _bom.UnitId ? UnitOfMeasure::unitOfMeasureDecimalPrecision(UnitOfMeasure::unitOfMeasureIdBySymbol(_bom.UnitId)) : 2;
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.bomQty ? num2str(_bom.bomQty, 0, qtyDecimals, 0, 0) : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowUnitId)
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.UnitId ? _bom.UnitId : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowConfigGroupId)
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.ConfigGroupId ? _bom.ConfigGroupId : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowFromDate)
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.FromDate ? date2str(_bom.FromDate,-1,-1,-1,-1,-1,-1, DateFlags::FormatAll) : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowToDate )
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''),  (_bom.ToDate ? date2str(_bom.ToDate,-1,-1,-1,-1,-1,-1, DateFlags::FormatAll)  : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowItemBOMId )
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.ItemBOMId ? _bom.ItemBOMId : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowItemRouteId )
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''), (_bom.ItemRouteId ? _bom.ItemRouteId : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowOprNum  )
        {
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''),  (_bom.OprNum ? int2str(_bom.OprNum) : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowBOMType)
        {
            DictEnum dictEnum = new DictEnum(enumNum(BOMType));
            lineTxt = strFmt(formatCode,  lineTxt, (lineTxt ? ' / ' : ''),  dictEnum.value2Name(_bom.bomType));
        }
        if (!tmpBOMRouteTree.bomDateValidOnly && !this.isBOMDateValid(_bom,false))
        {
            lineTxt = strFmt(formatCode,  lineTxt, '', ' <' + "@SYS67127" + '>');
        }

        return lineTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBOMCalc</Name>
				<Source><![CDATA[
    void openBOMCalc(int _nodeIdx)
    {
        if (!this.canOpenBOMCalc(_nodeIdx))
        {
            return;
        }

        BOMDesignerBOMCalc  bomDesignerBOMCalc   = new BOMDesignerBOMCalc();
        InventTable         curInventTable;
        InventQty           calcQty;

        if (_nodeIdx == rootId)
        {
            curInventTable  = InventTable::find(itemId);
            calcQty         = curInventTable.inventStandardQty(tmpBOMRouteTree.bomRouteInventDimId);
            bomDesignerBOMCalc.parmItemId(itemId);
            bomDesignerBOMCalc.parmInventDimId(tmpBOMRouteTree.bomRouteInventDimId);
            bomDesignerBOMCalc.parmBOMId(bomId);
            bomDesignerBOMCalc.parmRouteId(routeId);
        }
        else
        {
            BOM bom             = node2record.lookup(_nodeIdx);
            BOMTable bomTable   = node2BOMTable.lookup(_nodeIdx);
            curInventTable      = InventTable::find(bom.ItemId);
            calcQty             = curInventTable.inventStandardQty(bom.InventDimId);
            bomDesignerBOMCalc.parmItemId(bom.ItemId);
            bomDesignerBOMCalc.parmInventDimId(bom.InventDimId);
            bomDesignerBOMCalc.parmBOMId(bomTable.bomId);
            bomDesignerBOMCalc.parmRouteId(bom.itemRouteIdConstruction(this.canViewRouteInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                       this.versionDate(),
                                                                       tmpBOMRouteTree.bomRouteFromQty,
                                                                       tmpBOMRouteTree.inventDim()));
        }

        bomDesignerBOMCalc.parmCalcDate(this.versionDate());
        bomDesignerBOMCalc.parmCalcQty(calcQty);
        bomDesignerBOMCalc.parmBOMRouteVersionSelect(tmpBOMRouteTree.bomRouteVersionPrinciple);

        Args    args = new Args();
        args.name(formStr(InventItemPrice));
        args.caller(bomDesignerBOMCalc);

        FormRun formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.detach();
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBOMForm</Name>
				<Source><![CDATA[
    public void openBOMForm(
        BOM _bom     = null,
        int _curNode = 0
        )
    {
        BOM bom;
        if (!_curNode)
        {
            bom = _bom;
        }
        else if (node2record.exists(_curNode))
        {
            bom = node2record.lookup(_curNode);
        }
        else
        {
            if (this.isPmfCoByLeaf(_curNode))
            {
                PmfFormulaCoBy coBy = pmfNode2CoBy.lookup(_curNode);
                this.pmfOpenCoByForm(coBy);
                return;
            }
            else
            {
                throw error("@SYS59200");
            }
        }

        BOMDesignerEditBOMHelper::openDialogAndWait(this, bom);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBOMFormNodeIdx</Name>
				<Source><![CDATA[
    void openBOMFormNodeIdx(int _nodeIdx)
    {
        if (!this.canEditBOM(_nodeIdx))
        {
            return;
        }

        if (node2record.exists(_nodeIdx))
        {
            BOM bom = node2record.lookup(_nodeIdx);
            this.openBOMForm(bom);
        }
        else if (this.isPmfCoByLeaf(_nodeIdx))
        {
            PmfFormulaCoBy coBy = pmfNode2CoBy.lookup(_nodeIdx);
            this.pmfOpenCoByForm(coBy);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBOMVersions</Name>
				<Source><![CDATA[
    void openBOMVersions(int _nodeIdx)
    {
        if (!this.canOpenBOMVers(_nodeIdx))
        {
            return;
        }

        ItemId  curItemId;
        BOM     bom;
        if (_nodeIdx == rootId)
        {
            curItemId = itemId;
        }
        else
        {
            bom = node2record.lookup(_nodeIdx);
            curItemId = bom.ItemId;
        }

        Args args = new Args();
        args.caller(this);
        args.parm(int2str(_nodeIdx));
        args.parmEnumType(enumNum(PmfBOMFormula));
        args.parmEnum(bom.pmfBOMTable().PmfBOMFormula);

        MenuFunction menuFunction = new MenuFunction(menuItemDisplayStr(BOMDesignerBOMVersion), MenuItemType::Display);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openConfigPartOf</Name>
				<Source><![CDATA[
    public void openConfigPartOf(int _curNode)
    {
        if (!this.canOpenConfigPartOf(_curNode))
        {
            return;
        }

        BOM bom;
        if (node2record.exists(_curNode))
        {
            bom = node2record.lookup(_curNode);
        }

        if (!bom.RecId)
        {
            return;
        }

        Args            args = new Args();
        args.record(bom);
        args.caller(this);
        MenuFunction    menuFunction = new MenuFunction(menuitemDisplayStr(ConfigPartOf),MenuItemType::Display);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openConfigTable</Name>
				<Source><![CDATA[
    public void openConfigTable(int _curNode)
    {
        if (!this.canOpenConfigTable(_curNode))
        {
            return;
        }

        Args            args = new Args();
        InventTable     inventTable;
        if (_curNode == rootId)
        {
            inventTable = itemId ? InventTable::find(itemId) : null;
            args.record(inventTable);
        }
        else if (node2record.exists(_curNode))
        {
            BOM bom = node2record.lookup(_curNode);
            args.record(bom.inventTable());
        }

        if (!args.record())
        {
            return;
        }

        MenuFunction    menuFunction = new MenuFunction(menuitemDisplayStr(EcoResDimensionBasedConfiguration),MenuItemType::Display);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openInventTable</Name>
				<Source><![CDATA[
    public void openInventTable(int _curNode)
    {
        if (!this.canOpenInventTable(_curNode))
        {
            return;
        }

        Args            args = new Args();
        if (_curNode == rootId)
        {
            InventTable inventTable = itemId ? InventTable::find(itemId) : null;
            args.record(inventTable.RecId ? inventTable : null);
        }
        else
        {
            if (node2record.exists(_curNode))
            {
                BOM bom = node2record.lookup(_curNode);
                args.record(bom.RecId ? bom : null);
            }
            else if (this.isPmfCoByLeaf(_curNode))
            {
                PmfFormulaCoBy coBy = pmfNode2CoBy.lookup(_curNode);
                args.record(coBy);
            }
        }

        if (!args.record())
        {
            return;
        }

        MenuFunction menuFunction = new MenuFunction(menuitemDisplayStr(EcoResProductDetailsExtended),MenuItemType::Display);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>openRouteVersions</Name>
				<Source><![CDATA[
    void openRouteVersions(int _nodeIdx)
    {
        if (!this.canOpenRouteVers(_nodeIdx))
        {
            return;
        }

        ItemId   curItemId;
        if (_nodeIdx == rootId)
        {
            curItemId = itemId;
        }
        else
        {
            BOM bom     = node2record.lookup(_nodeIdx);
            curItemId   = bom.ItemId;
        }

        Args args = new Args();
        args.caller(this);
        args.parm(int2str(_nodeIdx));

        MenuFunction menuFunction = new MenuFunction(menuItemDisplayStr(BOMDesignerRouteVersion), MenuItemType::Display);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container pack()
    {
        return [#CurrentVersion,#CurrentList];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmBOMVersionCaller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets and gets the BOMVersion caller reference.
    /// </summary>
    /// <param name="_bomVersionCaller">
    /// BOMVersion caller record to be set.
    /// </param>
    /// <returns>BOMVersion caller record.</returns>
    public BOMVersion parmBOMVersionCaller(
        BOMVersion _bomVersionCaller = bomVersionCaller)
    {
        bomVersionCaller = _bomVersionCaller;
        return bomVersionCaller;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmCurDropNode</Name>
				<Source><![CDATA[
    public int parmCurDropNode(int _curDropNode = curDropNode)
    {
        curDropNode = _curDropNode;
        return curDropNode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveHeight</Name>
				<Source><![CDATA[
    public int parmSaveHeight(int _saveHeight = saveHeight)
    {
        saveHeight = _saveHeight;
        return saveHeight;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSaveWidth</Name>
				<Source><![CDATA[
    public int parmSaveWidth(int _saveWidth = saveWidth)
    {
        saveWidth = _saveWidth;
        return saveWidth;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTmpBOMRouteTree</Name>
				<Source><![CDATA[
    public TmpBOMRouteTree parmTmpBOMRouteTree(TmpBOMRouteTree _tmpBOMRouteTree = tmpBOMRouteTree)
    {
        tmpBOMRouteTree = _tmpBOMRouteTree;
        return tmpBOMRouteTree;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfAddCoByLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method adds co/by to formula
    /// </summary>
    /// <param name="_inventTable">Item</param>
    /// <param name="_dropNodeIdx">index of the node dropped</param>
    /// <returns>returns true if the Co/by was added sucessfully</returns>
    public boolean pmfAddCoByLine(
        InventTable _inventTable,
        int         _dropNodeIdx)
    {
        PmfFormulaCoBy  coByDrop;
        PmfFormulaCoBy  coByNew;
        BOMTable        bomTable;
        int             nodeIdx;

        if (_inventTable.PmfProductType != PmfProductType::By_Product
            && _inventTable.PmfProductType != PmfProductType::Co_Product)
        {
            return false;
        }

        if (this.isPmfCoByLeaf(_dropNodeIdx))
        {
            coByDrop = pmfNode2CoBy.lookup(_dropNodeIdx);
        }

        if (this.isPmfCoByNode(_dropNodeIdx))
        {
            nodeIdx = _dropNodeIdx;
        }
        else
        {
            nodeIdx = tree.getParent(_dropNodeIdx);
        }

        Debug::assert(this.isPmfCoByNode(nodeIdx));
        Debug::assert(node2BOMTable.exists(tree.getParent(nodeIdx)));

        bomTable = node2BOMTable.lookup(tree.getParent(nodeIdx));
        coByNew.bomId = bomTable.bomId;

        if (coByDrop)
        {
            if (!coByNew.setLineNumAfter(coByDrop))
            {
                this.pmfReNumberCoBy();
                coByDrop = pmfNode2CoBy.lookup(_dropNodeIdx);
                coByNew.setLineNumAfter(coByDrop);
            }
        }
        else
        {
            coByNew.LineNum = PmfFormulaCoBy::nextLineNum(bomVersionCaller.RecId);
        }

        coByNew.initValue();
        coByNew.initFromInventTable(_inventTable);
        coByNew.CoByQty = _inventTable.inventStandardQty(coByNew.InventDimId);
        coByNew.insert();

        curDropNode = 0;

        this.reReadBOM(rootId);

        if (pmfCoByRecId2Node.exists(coByNew.RecId))
        {
            tree.expand(this.pmfGetCoByNode(
                pmfCoByRecId2Node.lookup(coByNew.RecId)));
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfAddOverlay</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets the overlay image on the tree node with id _nodeId,
    /// to the overlay image from the item on the _bom record.
    /// </summary>
    /// <param name="_nodeId">Node to add overlay image to.</param>
    /// <param name="_bom">
    /// BOM record used to get item overlay image.
    /// </param>
    protected void pmfAddOverlay(int _nodeId, BOM _bom)
    {
        FormTreeItem treeItem;

        if (#PmfEnabled && _bom.bomTable().PmfBOMFormula == PmfBOMFormula::Formula)
        {
            treeItem    = tree.getItem(_nodeId);
            treeItem.overlayImage(this.pmfNodeOverlayImage(_bom.inventTable()));
            tree.setItem(treeItem);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfBuildCoByLeaf</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a leaf to the CoBy tree with the index of _coByNodeIdx,
    /// and the data from the record _coBy.
    /// </summary>
    /// <param name="_coByNodeIdx">
    /// Id of leaf (node) to be added.
    /// </param>
    /// <param name="_coBy">
    /// PmfFormulaCoBy record used to set the data on the leaf to be added to tree.
    /// </param>
    private void pmfBuildCoByLeaf(int _coByNodeIdx, PmfFormulaCoBy _coBy)
    {
        InventTable     inventTable;
        FormTreeItem    treeItem;
        int             newId;

        inventTable = _coBy.inventTable();

        newId = tree.add(
                    _coByNodeIdx,
                    0,
                    this.pmfCoByNodeTxt(_coBy,inventTable),
                    this.nodeImage(inventTable));

        treeItem = tree.getItem(newId);
        treeItem.overlayImage(this.pmfNodeOverlayImage(inventTable));
        tree.setItem(treeItem);
        this.pmfInsertCoByRecord(newId, _coBy);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfBuildCoByNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds base node for CoBy tree, then creates the leaves for the tree.
    /// </summary>
    /// <param name="_parentNodeId">Id of CoBy node to be added.</param>
    /// <param name="_coByData">
    /// Data to be added to the new CoBy base node.
    /// </param>
    private void pmfBuildCoByNode(int _parentNodeId, container _coByData)
    {
        int x,l;
        PmfFormulaCoBy coBy;
        int pmfCoByNodeId;

        l = conLen(_coByData);
        pmfCoByNodeId = tree.add(
                            _parentNodeId,
                            0,
                            "@PRO112",
                            imageList.image(#ImageBOM));

        pmfCoByNodes.add(pmfCoByNodeId);

        for (x=1;x<=l;x++)
        {
            coBy = conPeek(_coByData,x);
            this.pmfBuildCoByLeaf(pmfCoByNodeId, coBy);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfCoByNodeTxt</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds a description to be used on a co/by tree node.
    /// </summary>
    /// <param name="_coBy">
    /// A <c>PmfFormulaCoBy</c> record used to create the node text.
    /// </param>
    /// <param name="_inventTable">
    /// A inventTable record used to create node the node text.
    /// </param>
    /// <returns>A description for node.</returns>
    private str pmfCoByNodeTxt(
        PmfFormulaCoBy _coBy,
        InventTable _inventTable)
    {
        #define.decimal(2)
        str                             lineTxt;
        str                             formatCode;
        DictEnum                        dictEnum = new DictEnum(enumNum(PmfProductType));
        InventDim                       inventDim = _coBy.inventDim();
        UnitOfMeasureDecimalPrecision   qtyDecimals;
        EcoResProductName               productName;

        //formatting the text according to LTR or RTL
        if (currentSessionLanguageRTL())
        {
            //
            //using RLM (right-to-left mark) to define the text orientation
            //%1 - previous chunk of text (RTL)
            //%2 - separator - (ascii or LTR)
            //%3 - added chunk (RTL)
            //
            formatCode = '%1\u200F%2\u200E%3\u200F';
        }
        else
        {
            // regular text
            formatCode = '%1%2%3';
        }

        if (tmpBOMRouteTree.bomShowBOMType)
        {
            dictEnum = new DictEnum(enumNum(BOMType));
        }

        if (_coBy.inventUnitId())
        {
            qtyDecimals = UnitOfMeasure::findBySymbol(_coBy.inventUnitId()).DecimalPrecision;
        }
        else
        {
            qtyDecimals = #decimal;
        }

        if (tmpBOMRouteTree.bomShowItemId)
        {
            lineTxt = strFmt(formatcode, lineTxt, (lineTxt ? ' / ' : ''), (_coBy.ItemId ? _coBy.ItemId : EmptyValue));
        }

        Enumerator productDimensions = InventProductDimension::getEnumeratorForEnabledDimensions();

        while (productDimensions.moveNext())
        {
            InventProductDimension productDimension = productDimensions.current();

            if (tmpBOMRouteTree.showProductDimension(productDimension))
            {
                FieldId inventDimFieldId = productDimension.parmInventDimFieldId();
                lineTxt = strFmt(formatCode, lineTxt, (lineTxt ? ' / ' : ''), (inventDim.(inventDimFieldId) ? inventDim.(inventDimFieldId) : EmptyValue));
            }
        }

        if (tmpBOMRouteTree.bomShowItemName)
        {
            productName = _inventTable.defaultProductName();
            lineTxt = strFmt(formatCode, lineTxt, (lineTxt ? ' / ' : ''), (productName ? productName : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowBOMQty)
        {
            lineTxt = strFmt(formatCode, lineTxt, (lineTxt ? ' / ' : ''), (_coBy.CoByQty ? num2str(_coBy.CoByQty,0,qtyDecimals,0,0) : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowUnitId)
        {
            lineTxt = strFmt(formatCode, lineTxt, (lineTxt ? ' / ' : ''), (_coBy.inventUnitId() ? _coBy.inventUnitId() : EmptyValue));
        }
        if (tmpBOMRouteTree.bomShowBOMType)
        {
            lineTxt = strFmt(formatCode, lineTxt, (lineTxt ? ' / ' : ''), dictEnum.value2Name(_coBy.ProductType));
        }

        return lineTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfDeleteCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method deletes co/by from formula
    /// </summary>
    /// <param name="_nodeIdx">index of the node to delete.</param>
    private void pmfDeleteCoBy(int _nodeIdx)
    {
        MapIterator     mi;
        int             i;
        PmfFormulaCoBy  coByCache;
        PmfFormulaCoBy  coByDelete;
        RecId           delRecId;
        container       deleteNodes;

        if (!_nodeIdx || _nodeIdx == rootId
            || !this.isPmfCoByLeaf(_nodeIdx) || this.isPmfCoByNode(_nodeIdx))
        {
            return;
        }

        coByCache = pmfNode2CoBy.lookup(_nodeIdx);
        delRecId = coByCache.RecId;

        if (!delRecId)
        {
            return;
        }

        mi = new MapIterator(pmfNode2CoBy);

        ttsbegin;
        delete_from coByDelete
            where coByDelete.RecId == delRecId;
        ttscommit;

        while (mi.more())
        {
            coByCache = pmfNode2CoBy.lookup(mi.key());
            if (coByCache.RecId == delRecId)
            {
                deleteNodes += mi.key();
            }
            mi.next();
        }
        for (i=1;i<=conLen(deleteNodes);i++)
        {
            this.deleteNode(conPeek(deleteNodes,i));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfGetCoByNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets CoBy node related to _nodeIdx.
    /// </summary>
    /// <param name="_nodeIdx">Index of node to get.</param>
    /// <returns>Index of found node.</returns>
    private int pmfGetCoByNode(int _nodeIdx)
    {
        int coByNode, i;
        int tmpRoot = _nodeIdx;

        if (this.isPmfCoByNode(tmpRoot))
        {
            coByNode = tmpRoot;
        }
        else if (this.isPmfCoByLeaf(tmpRoot))
        {
            coByNode = tree.getParent(tmpRoot);
        }
        else
        {
            if (tmpRoot != rootId)
            {
                tmpRoot = tree.getParent(tmpRoot);
            }

            i = tree.getChild(tmpRoot);
            while (i && !this.isPmfCoByNode(i))
            {
                i = tree.getNextSibling(i);
            }

            if (this.isPmfCoByNode(i))
            {
                coByNode = i;
            }
        }

        Debug::assert(this.isPmfCoByNode(coByNode));

        return coByNode;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfInsertCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a CoBy record to the CoBy tree.
    /// </summary>
    /// <param name="_coByNew">
    /// New CoBy record to add to the tree.
    /// </param>
    /// <param name="_dropNodeIdx">
    /// Index of where to add node in tree.
    /// </param>
    public void pmfInsertCoBy(
        PmfFormulaCoBy _coByNew,
        int  _dropNodeIdx)
    {
        MapIterator     mi;
        FormTreeItem    dropTreeItem, treeItem;
        PmfFormulaCoBy  coByDrop, coByTest;
        int             selectNode, newIdx;

        mi = new MapIterator(pmfNode2CoBy);

        try
        {
            if (this.isPmfCoByNode(_dropNodeIdx))
            {
                dropTreeItem = tree.getItem(_dropNodeIdx);

                if (!dropTreeItem.stateExpandedOnce())
                {
                    tree.expand(_dropNodeIdx,FormTreeExpand::Expand);
                    selectNode = this.getLastChild(_dropNodeIdx);
                }
                else
                {
                    newIdx = tree.add(
                                _dropNodeIdx,
                                0,
                                this.pmfCoByNodeTxt(
                                    _coByNew,
                                    _coByNew.inventTable()),
                                this.nodeImage(_coByNew.inventTable()));
                    treeItem    = tree.getItem(newIdx);
                    treeItem.overlayImage(
                        this.pmfNodeOverlayImage(_coByNew.inventTable()));
                    tree.setItem(treeItem);
                    selectNode  = newIdx;
                    this.pmfInsertCoByRecord(newIdx,_coByNew);
                }
            }
            else
            {
                coByDrop = pmfNode2CoBy.lookup(_dropNodeIdx);

                while (mi.more())
                {
                    coByTest = pmfNode2CoBy.lookup(mi.key());

                    if (coByTest.RecId == coByDrop.RecId)
                    {
                        dropTreeItem = tree.getItem(mi.key());

                        newIdx = tree.add(
                                    tree.getParent(mi.key()),
                                    mi.key(),
                                    this.pmfCoByNodeTxt(
                                        _coByNew,
                                        _coByNew.inventTable()),
                                    this.nodeImage(_coByNew.inventTable()));
                        treeItem    = tree.getItem(newIdx);
                        treeItem.overlayImage(
                            this.pmfNodeOverlayImage(_coByNew.inventTable()));
                        tree.setItem(treeItem);
                        this.pmfInsertCoByRecord(newIdx,_coByNew);

                        if (mi.key() == _dropNodeIdx)
                        {
                            selectNode = newIdx;
                        }
                    }
                    mi.next();
                }
            }
            if (selectNode)
            {
                tree.select(selectNode);
            }
        }
        catch (Exception::Error)
        {
            throw (Exception::Error);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfInsertCoByRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds record _coBy into global maps with the id _id.
    /// </summary>
    /// <param name="_id">Id of object in map.</param>
    /// <param name="_coBy">
    /// Record to be added to map.
    /// </param>
    private void pmfInsertCoByRecord(int _id, PmfFormulaCoBy _coBy)
    {
        pmfNode2CoBy.insert(_id,_coBy);
        pmfCoByRecId2Node.insert(_coBy.RecId,_id);
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfMoveCoByLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Moves node from _dropNodeIdx to _moveNodeIdx.
    /// Deletes original if _copy is false.
    /// </summary>
    /// <param name="_moveNodeIdx">
    /// Node id to move to
    /// </param>
    /// <param name="_dropNodeIdx">
    /// Node to move.
    /// </param>
    /// <param name="_copy">
    /// Is the node being copied or moved?
    /// </param>
    /// <returns>
    /// Result of attempt to move node.
    /// </returns>
    public boolean pmfMoveCoByLine(
        int _moveNodeIdx,
        int _dropNodeIdx,
        boolean _copy = false)
    {
        PmfFormulaCoBy coByDrop;
        PmfFormulaCoBy coByNew;
        PmfFormulaCoBy coByTmp;
        BOMTable    bomTable;
        BOMTable    bomTableOld;

        if (!_moveNodeIdx || !_dropNodeIdx
            || _moveNodeIdx == _dropNodeIdx
            || _moveNodeIdx == rootId)
        {
            return false;
        }

        if (!this.isPmfCoByLeaf(_moveNodeIdx))
        {
            return false;
        }

        if (!this.isPmfCoByNode(_dropNodeIdx)
            && !this.isPmfCoByLeaf(_dropNodeIdx))
        {
            return false;
        }

        bomTable = node2BOMTable.lookup(
                        tree.getParent(this.pmfGetCoByNode(_dropNodeIdx)));
        bomTableOld = node2BOMTable.lookup(
                        tree.getParent(this.pmfGetCoByNode(_moveNodeIdx)));

        if (bomTable.bomId != bomTableOld.bomId)
        {
            return false;
        }

        if (this.isPmfCoByLeaf(_dropNodeIdx))
        {
            coByDrop = pmfNode2CoBy.lookup(_dropNodeIdx);
        }

        coByTmp = pmfNode2CoBy.lookup(_moveNodeIdx);

        if (coByDrop.RecId && coByTmp.RecId && coByDrop.RecId == coByTmp.RecId)
        {
            return false;
        }

        coByNew.initFromCoBy(coByTmp);
        coByNew.bomId = bomTable.bomId;
        if (!coByNew.setLineNumAfter(coByDrop))
        {
            this.pmfReNumberCoBy();
            coByDrop = pmfNode2CoBy.lookup(_dropNodeIdx);
            coByNew.setLineNumAfter(coByDrop);
        }

        if (!_copy)
        {
            this.pmfDeleteCoBy(_moveNodeIdx);
        }

        ttsbegin;
        coByNew.insert();
        ttscommit;

        this.pmfInsertCoBy(coByNew,_dropNodeIdx);

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfNode2BOMFormula</Name>
				<Source><![CDATA[
    ///<summary>
    ///Returns type of node (BOMor Formula)
    ///</summary>
    ///<param name="_nodeIdx">
    ///Index of node.
    ///</param>
    ///<returns>
    ///PmfBOMFormula type of node at _nodeIdx.
    ///</returns>
    public PmfBOMFormula pmfNode2BOMFormula(int _nodeIdx)
    {
        BOM             bomCur;
        InventTable     inventTable;
        int             curBOMNode = _nodeIdx;
        PmfBOMFormula   ret        = PmfBOMFormula::BOM;

        if (!_nodeIdx)
        {
            return ret;
        }
        if (!nodeCanHaveBOM.exists(_nodeIdx))
        {
            curBOMNode = tree.getParent(_nodeIdx);
        }
        if (curBOMNode != rootId && node2record.exists(curBOMNode))
        {
            bomCur = node2record.lookup(curBOMNode);
            inventTable = bomCur.inventTable();
            if (inventTable.isFormulaAllowed())
            {
                ret = PmfBOMFormula::Formula;
            }
            else if (inventTable.isBOMAllowed())
            {
                ret = PmfBOMFormula::BOM;
            }
        }
        else
        {
            if (bomId)
            {
                ret = BOMTable::find(bomId).PmfBOMFormula;
            }
            else if (itemId)
            {
                inventTable = InventTable::find(itemId);
                if (inventTable.isFormulaAllowed())
                {
                    ret = PmfBOMFormula::Formula;
                }
                else if (inventTable.isBOMAllowed())
                {
                    ret = PmfBOMFormula::BOM;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfNodeOverlayImage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the overlay image related to _inventTable parameter.
    /// </summary>
    /// <param name="_inventTable">
    /// Item to find overlay image for.
    /// </param>
    /// <returns>Overylay image for item _inventTable.</returns>
    public ImageRes pmfNodeOverlayImage(InventTable _inventTable)
    {
        return imageList.image(_inventTable.pmfImageResNo());
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfOpenCoByForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the PmfBOMDesignerEditCoBy form with a PmfFormulaCoBy record of _coBy
    /// or the PmfFormulaCoBy record on the currently selected node.
    /// </summary>
    /// <param name="_coBy">
    /// Parameter record used to launch PmfBOMDesignerEditCoBy form.
    /// </param>
    /// <param name="_curNode">
    /// Id of node whose record is used as parm to launch
    /// PmfBOMDesignerEditCoBy form.
    /// </param>
    public void pmfOpenCoByForm(
        PmfFormulaCoBy  _coBy = null,
        int             _curNode = 0)
    {
        PmfFormulaCoBy coBy;
        Args     args = new Args();
        FormRun  formRun;

        if (!_curNode)
        {
            coBy = _coBy;
        }
        else if (this.isPmfCoByLeaf(_curNode))
        {
            coBy = pmfNode2CoBy.lookup(_curNode);
        }
        else
        {
            throw error("@SYS59200");
        }

        args.name(formStr(PmfBOMDesignerEditCoBy));
        args.caller(this);
        args.record(coBy);

        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfOpenFormulaForm</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the BOMDesignerEditBOM form with a BOM record of _bom
    /// or the bom record on the currently selected node.
    /// </summary>
    /// <param name="_bom">BOM record</param>
    /// <param name="_curNode">Node</param>
    public void pmfOpenFormulaForm(
        BOM _bom     = null,
        int _curNode = 0)
    {
        BOM      bom;
        Args     args = new Args();
        FormRun  formRun;

        if (!_curNode)
        {
            bom = _bom;
        }
        else if (node2record.exists(_curNode))
        {
            bom = node2record.lookup(_curNode);
        }
        else
        {
            throw error("@SYS59200");
        }

        args.name(formStr(BOMDesignerEditBOM));
        args.caller(this);
        args.record(bom);

        args.parmEnumType(enumNum(PmfBOMFormula));
        args.parmEnum(bom.pmfBOMTable().PmfBOMFormula);

        formRun = classfactory.formRunClass(args);
        formRun.init();
        formRun.run();
        formRun.wait();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfRefreshCaller</Name>
				<Source><![CDATA[
    /// <summary>
    /// Performs refresh on caller form.
    /// </summary>
    public void pmfRefreshCaller()
    {
        if (fr)
        {
            fr.doRefresh();
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfRemoveCoByLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method removes co/by from formula
    /// </summary>
    /// <param name="_nodeIdx">index of the node dropped</param>
    public void pmfRemoveCoByLine(int _nodeIdx)
    {
        if (!this.canDeleteBOM(_nodeIdx))
        {
            return;
        }

        if (this.isPmfCoByLeaf(_nodeIdx))
        {
            PmfFormulaCoBy coBy = pmfNode2CoBy.lookup(_nodeIdx);

            if (tmpBOMRouteTree.ConfirmDelete
                && !Box::yesNo(
                        strFmt("@PRO2378",coBy.ItemId),
                        DialogButton::No,
                        "@SYS10308",
                        "@SYS10308"))
            {
                return;
            }

            this.pmfDeleteCoBy(_nodeIdx);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfReNumberCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// renumber the co/by lines on a formula
    /// </summary>
    private void pmfReNumberCoBy()
    {
        PmfFormulaCoBy  coByCache;
        PmfFormulaCoBy  coByPacked;
        container       packedList;
        MapEnumerator   mapEnum;
        int             i;

        packedList = PmfFormulaCoBy::reNumber(bomVersionCaller.RecId,true);

        for (i=1;i<=conLen(packedList);i++)
        {
            coByPacked = conPeek(packedList,i);
            mapEnum = pmfNode2CoBy.getEnumerator();
            while (mapEnum.moveNext())
            {
                coByCache = mapEnum.currentValue();
                if (coByCache.RecId == coByPacked.RecId)
                {
                    coByCache.LineNum = coByPacked.LineNum;
                    this.pmfInsertCoByRecord(mapEnum.currentKey(),coByCache);
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>pmfUpdateCoBy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Updates CoBy node in the tree object with new values.
    /// </summary>
    /// <param name="_coByChanged">
    /// Modified PmfFormulaCoBy record.
    /// </param>
    /// <param name="_reSelectNode">
    /// Should the node with modified record be selected after update.
    /// </param>
    public void pmfUpdateCoBy(
        PmfFormulaCoBy  _coByChanged,
        boolean         _reSelectNode = true)
    {
        MapIterator     mi;
        FormTreeItem    treeItem;
        PmfFormulaCoBy  coByCache;
        int             tmpSelection;

        if (!_coByChanged.RecId)
        {
            return;
        }

        mi = new MapIterator(pmfNode2CoBy);

        while (mi.more())
        {
            if (mi.key() != rootId && !this.isPmfCoByNode(mi.key()))
            {
                coByCache = pmfNode2CoBy.lookup(mi.key());
                if (coByCache.RecId == _coByChanged.RecId)
                {
                    treeItem = tree.getItem(mi.key());

                    this.pmfInsertCoByRecord(mi.key(),_coByChanged);

                    treeItem.text(this.pmfCoByNodeTxt(
                                    _coByChanged,_coByChanged.inventTable()));
                    treeItem.image(this.nodeImage(_coByChanged.inventTable()));
                    treeItem.stateImage(0);
                    treeItem.selectedImage(treeItem.image());
                    tree.setItem(treeItem);
                    this.setNodeItem(mi.key());
                }
            }
            mi.next();
        }

        if (_reSelectNode)
        {
            tmpSelection = tree.getSelection();
            tree.select(rootId);
            tree.select(tmpSelection);
            fr.setRoute(tree.getSelection(),true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>printBOM</Name>
				<Source><![CDATA[
    public void printBOM(int _nodeIdx)
    {
        if (!this.canPrintBOM(_nodeIdx))
        {
            return;
        }

        BOMTable    bomTable = node2BOMTable.lookup(_nodeIdx);
        if (bomTable.CheckBOM
            && !BOMHierarchyCheck::checkBOM(bomTable.bomId,true))
        {
            return;
        }

        Args                args = new Args();
        args.parmObject(this);
        args.parm(int2str(_nodeIdx));

        MenuFunction        menuFunction = new MenuFunction(menuitemOutputStr(BOMConsistOfReport), MenuItemType::Output);
        menuFunction.run(args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>recId2Node</Name>
				<Source><![CDATA[
    int recId2Node(recId _recId)
    {
        if (! recId2Node.exists(_recId))
        {
            return rootId;
        }

        return recId2Node.lookup(_recId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>releaseRoute</Name>
				<Source><![CDATA[
    void releaseRoute(
        int     _nodeIdx,
        boolean _setRoute = true)
    {
        if (!this.canReleaseRoute())
        {
            return;
        }

        FormTreeItem treeItem = tree.getItem(nodeIdRoute);

        if (treeItem)
        {
            treeItem.overlayImage(-1);
            tree.setItem(treeItem);
        }

        lockRoute   = false;
        nodeIdRoute = 0;
        if (   _nodeIdx
            && _setRoute)
        {
            this.setRoute(_nodeIdx);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>removeLine</Name>
				<Source><![CDATA[
    void removeLine(int _nodeIdx)
    {
        if (!this.canDeleteBOM(_nodeIdx))
        {
            return;
        }

        BOM bomCache = node2record.lookup(_nodeIdx);

        if (    tmpBOMRouteTree.ConfirmDelete
            && !Box::yesNo(strFmt("@SYS67139",bomCache.ItemId),DialogButton::No,"@SYS10308","@SYS10308"))
        {
            return;
        }

        this.deleteBOM(_nodeIdx);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reNumberBOM</Name>
				<Source><![CDATA[
    void reNumberBOM(BOM _bomDrop)
    {
        BOM         bomCache;
        BOM         bomPacked;
        container   packedList;
        MapIterator mi;
        int         i;

        packedList = BOM::reNumber(_bomDrop.bomId,true);

        for (i=1;i<=conLen(packedList);i++)
        {
            bomPacked = conPeek(packedList,i);
            mi = new MapIterator(node2record);
            while (mi.more())
            {
                bomCache = node2record.lookup(mi.key());
                if (bomCache.RecId == bomPacked.RecId)
                {
                    bomCache.LineNum = bomPacked.LineNum;
                    this.insertBOMRecord(mi.key(),bomCache);
                }
                mi.next();
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>reReadBOM</Name>
				<Source><![CDATA[
    void reReadBOM(int _nodeIdx)
    {
        BOM     bomCache;
        ItemId  localItemId;
        boolean resetRoot;

        if (!this.canReReadBOM(_nodeIdx))
        {
            return;
        }

        if (_nodeIdx == rootId)
        {
            if (callerTableId != tableNum(BOMTable))
            {
                localItemId = itemId;
            }
            else
            {
                resetRoot = true;
            }
        }
        else
        {
            bomCache    = node2record.lookup(_nodeIdx);
            localItemId = bomCache.ItemId;
        }

        this.resetBOM(localItemId,resetRoot);
    }

]]></Source>
			</Method>
			<Method>
				<Name>reReadRoute</Name>
				<Source><![CDATA[
    void reReadRoute(int _nodeIdx)
    {
        BOM     bomCache;
        ItemId  localItemId;

        if (!this.canReReadRoute(_nodeIdx))
        {
            return;
        }

        if (_nodeIdx == rootId)
        {
            localItemId = itemId;
        }
        else
        {
            bomCache    = node2record.lookup(_nodeIdx);
            localItemId = bomCache.ItemId;
        }
        this.resetRoute(localItemId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetBOM</Name>
				<Source><![CDATA[
    void resetBOM(
        ItemId  _itemId,
        boolean _forcedResetRoot = false)
    {
        MapIterator     mi;
        FormTreeItem    treeItem;
        Map             reExpandNodes;
        container       deleteNodes;
        BOM             bomCache;
        BOMTable        bomTable;
        int             tmpSelection;
        int             i;
        boolean         mustReleaseRoute;

        if (   !_itemId
            || !BOMDesignerCtrl::itemCanHaveBOM(InventTable::find(_itemId))
            && !_forcedResetRoot)
        {
            return;
        }

        reExpandNodes   = new Map(Types::Integer, Types::Integer);
        mi              = new MapIterator(node2record);

        forcedUpdateInfoPanelBOM    = true;
        forcedUpdateInfoPanelRoute  = true;

        // root must be reset;
        if (   _itemId == itemId
            || _forcedResetRoot)
        {
            this.linkActive(caller,tmpBOMRouteTree);
        }
        else
        {
            while (mi.more())
            {
                if (   mi.key() != rootId
                    && nodeCanHaveBOM.exists(mi.key()))
                {
                    bomCache = node2record.lookup(mi.key());
                    if (    bomCache.ItemId == _itemId
                        && !bomCache.ItemBOMId)
                    {
                        treeItem = tree.getItem(mi.key());
                        if (treeItem.stateExpanded())
                        {
                            reExpandNodes.insert(mi.key(),1);
                            treeItem.stateExpanded(false);
                            tree.setItem(treeItem);
                            tree.expand(mi.key(),FormTreeExpand::Collapse);
                        }

                        if (   lockRoute
                            && nodeIdRoute == mi.key()
                            || this.isNodeChild(mi.key(),nodeIdRoute))
                        {
                            mustReleaseRoute = true;
                        }

                        deleteNodes += this.deleteChildrenCollect(mi.key());

                        if (nodeCanHaveBOM.exists(mi.key()))
                        {
                            nodeCanHaveBOM.remove(mi.key());
                        }
                        if (nodeCanHaveRoute.exists(mi.key()))
                        {
                            nodeCanHaveRoute.remove(mi.key());
                        }
                        if (nodeBOMStatus.exists(mi.key()))
                        {
                            nodeBOMStatus.remove(mi.key());
                        }
                        if (node2RouteTable.exists(mi.key()))
                        {
                            node2RouteTable.remove(mi.key());
                        }
                        if (nodeRouteStatus.exists(mi.key()))
                        {
                            nodeRouteStatus.remove(mi.key());
                        }

                        bomTable = BOMTable::find(bomCache.itemBOMIdConstruction(this.canViewBomVersionInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                 this.versionDate(),
                                                                                 tmpBOMRouteTree.bomRouteFromQty,
                                                                                 bomCache.inventDim()));
                        node2BOMTable.insert(mi.key(),bomTable);

                        treeItem.stateImage(bomTable.RecId ? 0 : imageListState.image(#ImageStateNotAtAllOK));
                        treeItem.selectedImage(treeItem.image());
                        if (!bomTable.RecId)
                        {
                            treeItem.stateExpanded(true);
                        }

                        tree.setItem(treeItem);
                        if (bomCache.inventTable().inventItemType().canHaveRoutes())
                        {
                            nodeCanHaveRoute.insert(mi.key(),1);
                        }

                        this.setNodeBOM(mi.key());
                    }
                }
                mi.next();
            }
        }
        for (i=1;i<=conLen(deleteNodes);i++)
        {
            this.deleteNode(conPeek(deleteNodes,i));
        }

        mi = new MapIterator(reExpandNodes);
        while (mi.more())
        {
            try
            {
                this.expandNode(mi.key());
                mi.next();
            }
            catch (Exception::Error)
            {
                mi.next();
                // just continue!!!
            }
        }

        if (mustReleaseRoute)
        {
            this.releaseRoute(nodeIdRoute,false);
        }

        fr.setRoute(tree.getSelection(),true);
        tmpSelection = tree.getSelection();
        tree.select(rootId);
        tree.select(tmpSelection);
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetRoute</Name>
				<Source><![CDATA[
    void resetRoute(ItemId _itemId)
    {
        MapIterator     mi;
        BOM             bomCache;
        boolean         mustReleaseRoute;

        if (   !_itemId
            || !BOMDesignerCtrl::itemCanHaveBOM(InventTable::find(_itemId)))
        {
            return;
        }

        forcedUpdateInfoPanelRoute = true;

        mi = new MapIterator(node2record);

        if (_itemId == itemId)
        {
            if (nodeRouteStatus.exists(rootId))
            {
                nodeRouteStatus.remove(rootId);
            }
            if (node2RouteTable.exists(rootId))
            {
                node2RouteTable.remove(rootId);
            }
            if (nodeIdRoute == rootId)
            {
                mustReleaseRoute = true;
            }
            this.setCallerData(caller);
        }
        else
        {
            while (mi.more())
            {
                if (   mi.key() != rootId
                    && nodeCanHaveBOM.exists(mi.key()))
                {
                    bomCache = node2record.lookup(mi.key());
                    if (    bomCache.ItemId == _itemId
                        && !bomCache.ItemRouteId)
                    {
                        if (nodeRouteStatus.exists(mi.key()))
                        {
                            nodeRouteStatus.remove(mi.key());
                        }
                        if (node2RouteTable.exists(mi.key()))
                        {
                            node2RouteTable.remove(mi.key());
                        }
                        if (nodeIdRoute == mi.key())
                        {
                            mustReleaseRoute = true;
                        }
                    }
                }
                mi.next();
            }
        }
        if (mustReleaseRoute)
        {
            this.releaseRoute(tree.getSelection(),true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>routeId</Name>
				<Source><![CDATA[
    RouteId routeId()
    {
        return routeId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>saveLast</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Saves the last choice by using the <see cref="M:RunBase.pack" /> method.
    /// </summary>
    /// <remarks>
    ///    This method should not normally be overridden.
    /// </remarks>
    final public void saveLast()
    {
        FormRun callerForm = fr;

        saveWidth   = callerForm.design().widthValue();
        saveHeight  = callerForm.design().heightValue();
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectedBOMId</Name>
				<Source><![CDATA[
    public BOMId selectedBOMId()
    {
        return curBOMTableInfo.bomId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>bomRecord</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the BOM line record representing the node.
    /// </summary>
    /// <param name = "_nodeIdx">The index of the node.</param>
    /// <returns>A BOM line record.</returns>
    public BOM bomRecord(int _nodeIdx)
    {
        BOM bom;

        if (_nodeIdx != rootId && node2record.exists(_nodeIdx))
        {
            bom = node2record.lookup(_nodeIdx);
        }

        return bom;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentBomTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the BOMTable record the node is under.
    /// </summary>
    /// <returns>A BOMTable record.</returns>
    public BOMTable currentBomTable()
    {
        return curBOMTableInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>currentRouteTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Gets the RouteTable record the node is under.
    /// </summary>
    /// <returns>A RouteTable record.</returns>
    public RouteTable currentRouteTable()
    {
        return curRouteTableInfo;
    }

]]></Source>
			</Method>
			<Method>
				<Name>selectRoute</Name>
				<Source><![CDATA[
    RouteTable selectRoute(int _nodeIdx)
    {
        RouteTable routeTable;

        routeTable = this.getRouteTable(_nodeIdx);

        nodeRouteStatus.insert(_nodeIdx,1);

        if (routeTable)

        {
            node2RouteTable.insert(_nodeIdx,routeTable);
        }

        return routeTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>hideEmptyGroupAndShowMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Hides the FormGroupControl and instead adds a Static text to the parent container with the message. If the message is empty,
    /// the static text control is removed and the group control is made visible again.
    /// </summary>
    /// <param name = "_formGroupControl">The form group control to hide or show.</param>
    /// <param name = "_emptyTextControl">The empty text control to remove if it's present.</param>
    /// <param name = "_msg">The message to display in the empty text control.</param>
    /// <returns>The created empty text control or null if the empty text control removed.</returns>
    FormStaticTextControl hideEmptyGroupAndShowMessage(FormGroupControl _formGroupControl, FormStaticTextControl _emptyTextControl, Description _msg)
    {
        FormTabPageControl parentTab = _formGroupControl.parentControl() as FormTabPageControl;
        if (parentTab)
        {
            if (_msg != '')
            {
                if (!_emptyTextControl)
                {
                    str msgCtrlName = strFmt('%1_EmptyText', _formGroupControl.name());
                    _emptyTextControl = parentTab.addControl(FormControlType::StaticText, msgCtrlName) as FormStaticTextControl;
                }
                _emptyTextControl.text(_msg);
                _formGroupControl.visible(false);
            }
            else
            {
                _formGroupControl.visible(true);
                if (_emptyTextControl)
                {
                    parentTab.formRun().design().removeControl(_emptyTextControl.id());
                }
                _emptyTextControl = null;
            }
        }
        return _emptyTextControl;
    }

]]></Source>
			</Method>
			<Method>
				<Name>missingBomMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the appropriate failure message for a missing BOM version, based on the current version selection principle.
    /// </summary>
    /// <returns>The failure message for a missing BOM version</returns>
    protected Description missingBomMessage()
    {
        switch (tmpBOMRouteTree.bomRouteVersionPrinciple)
        {
            case BOMRouteVersionSelect::Active:
                if (pmfCallerCanHaveFormula)
                {
                    return "@SCM:ValidationMessage_BOMDesignerCtrl_NoActiveFormulaVersion";
                }
                else
                {
                    return "@SYS67672";
                }

            default:
                return "@SYS68234";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>missingRouteMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Provides the appropriate failure message for a missing route version, based on the current version selection principle.
    /// </summary>
    /// <returns>The failure message for a missing route version</returns>
    protected Description missingRouteMessage()
    {
        switch (tmpBOMRouteTree.bomRouteVersionPrinciple)
        {
            case BOMRouteVersionSelect::Active:
                return "@SYS67317";

            default:
                return "@SYS68234";
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setBOMInfo</Name>
				<Source><![CDATA[
    void setBOMInfo(int _nodeIdx)
    {
        BOMTable        bomTable;
        BOM             bomCur;
        int             curBOMNode = _nodeIdx;
        ItemId          curItemId;

        if (!_nodeIdx)
        {
            bomEmptyTextControl = this.hideEmptyGroupAndShowMessage(bomGroup, bomEmptyTextControl, this.missingBomMessage());

            curBOMTableInfo        = null;
            curBOMTableInfo_ItemId = '';

            return;
        }

        if (!nodeCanHaveBOM.exists(_nodeIdx))
        {
            curBOMNode = tree.getParent(_nodeIdx);
        }

        if (!curBOMNode)
        {
            return;
        }

        if (curBOMNode == rootId)
        {
            curItemId = itemId;
        }
        else
        {
            bomCur = node2record.lookup(curBOMNode);
            curItemId = bomCur.ItemId;
        }

        bomTable = node2BOMTable.lookup(curBOMNode);

        if (    bomTable.RecId == curBOMTableInfo.RecId
            &&  curItemId      == curBOMTableInfo_ItemId
            &&  bomTable.RecId
            && !forcedUpdateInfoPanelBOM)
        {
            return;
        }

        forcedUpdateInfoPanelBOM = false;

        if (bomTable.RecId)
        {
            bomEmptyTextControl = this.hideEmptyGroupAndShowMessage(bomGroup, bomEmptyTextControl, '');

            curBOMTableInfo = bomTable;
            curBOMTableInfo_ItemId = curItemId;
        }
        else
        {
            bomEmptyTextControl = this.hideEmptyGroupAndShowMessage(bomGroup, bomEmptyTextControl, this.missingBomMessage());

            curBOMTableInfo        = null;
            curBOMTableInfo_ItemId = '';
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setCallerData</Name>
				<Source><![CDATA[
    void setCallerData(Common _caller)
    {
        BOMTable            bomTable;
        InventTable         inventTable;
        SalesLine           salesLine;
        PurchLine           purchLine;

        caller = _caller;
        switch (caller.TableId)
        {
            case (tableNum(BOMTable))       :
                bomTable         = caller;
                bomId            = bomTable.bomId;
                routeId          = '';
                callerCanHaveBOM = true;
                if (#PmfEnabled)
                {
                    pmfCallerCanHaveFormula = true;
                }
                break;
            case (tableNum(InventDimCombination)):
                InventDimCombination inventDimCombination = caller;
                caller = inventDimCombination.inventTable();
                // Fallthrough
            case (tableNum(InventTable)):
                inventTable      = caller;
                callerCanHaveBOM = inventTable.inventItemType().canHaveBOM();
                pmfCallerCanHaveFormula = inventTable.isFormulaAllowed();

                bomId            = inventTable.bomIdConstruction(this.canViewBomVersionInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                 this.versionDate(),
                                                                 tmpBOMRouteTree.bomRouteFromQty,
                                                                 tmpBOMRouteTree.inventDim());
                routeId          = inventTable.routeIdConstruction(this.canViewRouteInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                   this.versionDate(),
                                                                   tmpBOMRouteTree.bomRouteFromQty,
                                                                   tmpBOMRouteTree.inventDim());
                itemId           = inventTable.ItemId;
                break;
            case (tableNum(SalesLine))      :
                salesLine        = caller;
                callerCanHaveBOM = salesLine.inventTable().inventItemType().canHaveBOM();
                pmfCallerCanHaveFormula = salesLine.inventTable().isFormulaAllowed();

                bomId            = salesLine.ItemBOMId    ? salesLine.ItemBOMId
                                                          : salesLine.inventTable().bomIdConstruction(this.canViewBomVersionInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                                      this.versionDate(),
                                                                                                      tmpBOMRouteTree.bomRouteFromQty,
                                                                                                      tmpBOMRouteTree.inventDim());
                routeId          = salesLine.ItemRouteId  ? salesLine.ItemRouteId
                                                          : salesLine.inventTable().routeIdConstruction(this.canViewRouteInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                                        this.versionDate(),
                                                                                                        tmpBOMRouteTree.bomRouteFromQty,
                                                                                                        tmpBOMRouteTree.inventDim());
                itemId           = salesLine.ItemId;
                break;
            case (tableNum(PurchLine))      :
                purchLine        = caller;
                callerCanHaveBOM = purchLine.inventTable().inventItemType().canHaveBOM();
                pmfCallerCanHaveFormula = purchLine.inventTable().isFormulaAllowed();

                bomId            = purchLine.ItemBOMId    ? purchLine.ItemBOMId
                                                          : purchLine.inventTable().bomIdConstruction(this.canViewBomVersionInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                                      this.versionDate(),
                                                                                                      tmpBOMRouteTree.bomRouteFromQty,
                                                                                                      tmpBOMRouteTree.inventDim());
                routeId          = purchLine.ItemRouteId  ? purchLine.ItemRouteId
                                                          : purchLine.inventTable().routeIdConstruction(this.canViewRouteInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                                        this.versionDate(),
                                                                                                        tmpBOMRouteTree.bomRouteFromQty,
                                                                                                        tmpBOMRouteTree.inventDim());
                itemId           = purchLine.ItemId;
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNodeBOM</Name>
				<Source><![CDATA[
    void setNodeBOM(int _nodeIdx)
    {
        FormTreeItem treeItem;

        nodeCanHaveBOM.insert(_nodeIdx,1);
        treeItem = tree.getItem(_nodeIdx);
        treeItem.stateBold(true);
        treeItem.children(true);
        tree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setNodeItem</Name>
				<Source><![CDATA[
    void setNodeItem(int _nodeIdx)
    {
        FormTreeItem treeItem;

        if (nodeCanHaveBOM.exists(_nodeIdx))
        {
            nodeCanHaveBOM.remove(_nodeIdx);
        }
        if (node2BOMTable.exists(_nodeIdx))
        {
            node2BOMTable.remove(_nodeIdx);
        }
        treeItem = tree.getItem(_nodeIdx);
        treeItem.stateBold(false);
        treeItem.children(false);
        tree.setItem(treeItem);
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRoute</Name>
				<Source><![CDATA[
    void setRoute(int _bomNodeIdx)
    {
        int connectedBOMNode = _bomNodeIdx;

        if (this.isPmfIdx(_bomNodeIdx))
        {
            return;
        }

        if (!lockRoute)
        {
            if (!nodeCanHaveBOM.exists(_bomNodeIdx))
            {
                connectedBOMNode = tree.getParent(_bomNodeIdx);
            }

            if (!connectedBOMNode)
            {
                if (!tree.getRoot())
                {
                    this.setRouteInfo(null,0);
                }

                return;
            }
            if (connectedBOMNode != nodeIdRoute)
            {
                this.insertRoute(connectedBOMNode);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setRouteInfo</Name>
				<Source><![CDATA[
    void setRouteInfo(RouteTable _routeTable, int _connectedBOMNode)
    {
        ItemId          curItemId;

        if (_connectedBOMNode)
        {
            if (_connectedBOMNode == rootId)
            {
                curItemId = itemId;
            }
            else
            {
                BOM bomCur  = node2record.lookup(_connectedBOMNode);
                curItemId   = bomCur.ItemId;
            }
        }
        if (   curRouteTableInfo.RecId  == _routeTable.RecId
            && curRouteTableInfo_ItemId == curItemId
            && curRouteTableInfo.RecId  && !forcedUpdateInfoPanelRoute)
        {
            return;
        }

        forcedUpdateInfoPanelRoute = false;

        if (_routeTable.RecId)
        {
            curRouteTableInfo           = _routeTable;
            curRouteTableInfo_ItemId    = curItemId;

            routeEmptyTextControl = this.hideEmptyGroupAndShowMessage(routeGroup, routeEmptyTextControl, '');
        }
        else
        {
            curRouteTableInfo           = null;
            curRouteTableInfo_ItemId    = '';

            routeEmptyTextControl = this.hideEmptyGroupAndShowMessage(routeGroup, routeEmptyTextControl, this.missingRouteMessage());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setupChange</Name>
				<Source><![CDATA[
    void setupChange(TmpBOMRouteTree _tmpBOMRouteTree)
    {
        boolean redrawBOM;
        int     curIdx;

        if (_tmpBOMRouteTree.equal(tmpBOMRouteTree))
        {
            return;
        }

        if (_tmpBOMRouteTree.bomRouteDate               != tmpBOMRouteTree.bomRouteDate             ||
            _tmpBOMRouteTree.bomRouteFromQty            != tmpBOMRouteTree.bomRouteFromQty          ||
            _tmpBOMRouteTree.bomDateValidOnly           != tmpBOMRouteTree.bomDateValidOnly         ||
            _tmpBOMRouteTree.bomRouteVersionPrinciple   != tmpBOMRouteTree.bomRouteVersionPrinciple ||
            _tmpBOMRouteTree.bomRouteInventDimId        != tmpBOMRouteTree.bomRouteInventDimId
           )
        {
            redrawBOM                   = true;
            forcedUpdateInfoPanelBOM    = true;
            forcedUpdateInfoPanelRoute  = true;
        }
        tmpBOMRouteTree.data(_tmpBOMRouteTree);
        this.saveLast();
        curIdx = tree.getSelection() ? tree.getSelection() : rootId;

        if (lockRoute)
        {
            this.releaseRoute(curIdx);
        }

        if (redrawBOM)
        {
            this.linkActive(caller,tmpBOMRouteTree);
        }
        else
        {
            this.updateSubNodes();
            nodeIdRoute = 0;
            this.initRouteView();
            if (curIdx)
            {
                this.setRoute(curIdx);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>topNodeBOMId</Name>
				<Source><![CDATA[
    BOMId topNodeBOMId()
    {
        return bomId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>topNodeImage</Name>
				<Source><![CDATA[
    ImageRes topNodeImage()
    {
        return imageList.image(#ImageProductionSmall);
    }

]]></Source>
			</Method>
			<Method>
				<Name>topNodeTxt</Name>
				<Source><![CDATA[
    str topNodeTxt()
    {
        str         lineTxt;
        InventDim   inventDim;

        switch (caller.TableId)
        {
            case (tableNum(BOMTable))       :
                boolean isFormula = BOMTable::find(bomId).PmfBOMFormula == PmfBOMFormula::Formula;
                lineTxt = isFormula ? 
                    "@PRO101" + ': ' + bomId : 
                    "@SYS22298" + ': ' + bomId;
                break;
            case (tableNum(InventTable))    :
            case (tableNum(InventDimCombination)):
            case (tableNum(SalesLine))      :
            case (tableNum(PurchLine))      :
                inventDim = tmpBOMRouteTree.inventDim();
                lineTxt = "@SYS12836" + ': ' + itemId + (inventDim.ConfigId ? (' - ' + "@SYS14011" + ': ' + inventDim.ConfigId) : '');
                break;
        }
        return lineTxt;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        Integer version     = conPeek(_packedClass,1);

        switch (version)
        {
            case #CurrentVersion:
                [version,#CurrentList] = _packedClass;
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateBOM</Name>
				<Source><![CDATA[
    void updateBOM(BOM _bomChanged, boolean _reSelectNode = true)
    {
        MapIterator     mi;
        FormTreeItem    treeItem;
        BOM             bomCache;
        BOMTable        bomTable;
        int             tmpSelection;
        boolean         mustReleaseRoute;
        container       deleteNodes;
        Map             reExpandNodes;
        int             i;

        if (!_bomChanged.RecId)
        {
            return;
        }

        reExpandNodes   = new Map(Types::Integer, Types::Integer);
        mi              = new MapIterator(node2record);

        while (mi.more())
        {
            if (mi.key() != rootId)
            {
                bomCache = node2record.lookup(mi.key());
                if (bomCache.RecId == _bomChanged.RecId)
                {
                    treeItem = tree.getItem(mi.key());

                    this.bomSetInventDimFinal(_bomChanged,tree.getParent(mi.key()));

                    if (this.mustDeleteChildrenBOMChange(bomCache,_bomChanged))
                    {
                        if (   nodeCanHaveBOM.exists(mi.key())
                            && treeItem.stateExpanded())
                        {
                            if (this.isBOMDateValid(_bomChanged))
                            {
                                reExpandNodes.insert(mi.key(),1);
                            }
                            treeItem.stateExpanded(false);
                            tree.setItem(treeItem);
                            tree.expand(mi.key(),FormTreeExpand::Collapse);
                        }

                        mustReleaseRoute  = true;
                        deleteNodes      += this.deleteChildrenCollect(mi.key());

                        if (nodeCanHaveBOM.exists(mi.key()))
                        {
                            nodeCanHaveBOM.remove(mi.key());
                        }
                        if (nodeCanHaveRoute.exists(mi.key()))
                        {
                            nodeCanHaveRoute.remove(mi.key());
                        }
                        if (node2BOMTable.exists(mi.key()))
                        {
                            node2BOMTable.remove(mi.key());
                        }
                        if (nodeBOMStatus.exists(mi.key()))
                        {
                            nodeBOMStatus.remove(mi.key());
                        }
                        if (node2RouteTable.exists(mi.key()))
                        {
                            node2RouteTable.remove(mi.key());
                        }
                        if (nodeRouteStatus.exists(mi.key()))
                        {
                            nodeRouteStatus.remove(mi.key());
                        }
                    }

                    if (this.isBOMDateValid(_bomChanged))
                    {
                        this.insertBOMRecord(mi.key(),_bomChanged);

                        treeItem.text(this.nodeTxt(_bomChanged,_bomChanged.inventTable()));
                        treeItem.image(this.nodeImage(_bomChanged.inventTable()));
                        treeItem.stateImage(0);
                        treeItem.selectedImage(treeItem.image());
                        tree.setItem(treeItem);
                        if (BOMDesignerCtrl::itemCanHaveBOM(_bomChanged.inventTable()))
                        {
                            bomTable = BOMTable::find(_bomChanged.itemBOMIdConstruction(this.canViewBomVersionInfomation() ? tmpBOMRouteTree.bomRouteVersionPrinciple : BOMRouteVersionSelect::Active,
                                                                                        this.versionDate(),
                                                                                        tmpBOMRouteTree.bomRouteFromQty,
                                                                                        bomCache.inventDim()));
                            node2BOMTable.insert(mi.key(),bomTable);
                            nodeCanHaveBOM.insert(mi.key(),1);
                            nodeCanHaveRoute.insert(mi.key(),1);

                            this.setNodeBOM(mi.key());
                            if (!bomTable.RecId)
                            {
                                treeItem = tree.getItem(mi.key());
                                treeItem.stateImage(imageListState.image(#ImageStateNotAtAllOK));
                                treeItem.stateExpanded(true);
                                tree.setItem(treeItem);
                            }
                        }
                        else
                        {
                            if (nodeCanHaveBOM.exists(mi.key()))
                            {
                                nodeCanHaveBOM.remove(mi.key());
                            }
                            if (nodeCanHaveRoute.exists(mi.key()))
                            {
                                nodeCanHaveRoute.remove(mi.key());
                            }
                            if (node2BOMTable.exists(mi.key()))
                            {
                                node2BOMTable.remove(mi.key());
                            }
                            if (nodeBOMStatus.exists(mi.key()))
                            {
                                nodeBOMStatus.remove(mi.key());
                            }
                            if (node2RouteTable.exists(mi.key()))
                            {
                                node2RouteTable.remove(mi.key());
                            }
                            if (nodeRouteStatus.exists(mi.key()))
                            {
                                nodeRouteStatus.remove(mi.key());
                            }
                            if (_bomChanged.inventTable().inventItemType().canHaveRoutes())
                            {
                                nodeCanHaveRoute.insert(mi.key(),1);
                            }
                            this.setNodeItem(mi.key());
                        }
                    }
                    else
                    {
                        info(strFmt("@SYS67128", date2StrUsr(tmpBOMRouteTree.bomRouteDate, DateFlags::FormatAll)));
                        deleteNodes += mi.key();
                    }
                }
            }
            mi.next();
        }
        for (i=1;i<=conLen(deleteNodes);i++)
        {
            this.deleteNode(conPeek(deleteNodes,i));
        }

        mi = new MapIterator(reExpandNodes);
        while (mi.more())
        {
            try
            {
                this.expandNode(mi.key());
                mi.next();
            }
            catch (Exception::Error)
            {
                mi.next();
                // just continue!!!
            }
        }

        if (mustReleaseRoute)
        {
            this.releaseRoute(nodeIdRoute,false);
        }

        if (_reSelectNode)
        {
            tmpSelection = tree.getSelection();
            tree.select(rootId);
            tree.select(tmpSelection);
            fr.setRoute(tree.getSelection(),true);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateSubNodes</Name>
				<Source><![CDATA[
    void updateSubNodes(int _parent = 0)
    {
        FormTreeItem    treeItem;
        BOM             bom;
        PmfFormulaCoBy  coBy;
        int             child = _parent ? tree.getChild(_parent) : tree.getRoot();

        while (child)
        {
            this.updateSubNodes(child);
            if (   _parent
                && this.isPmfCoByLeaf(child))
            {
                coBy = pmfNode2CoBy.lookup(child);
                treeItem = tree.getItem(child);
                treeItem.text(this.pmfCoByNodeTxt(coBy,coBy.inventTable()));
                tree.setItem(treeItem);
            }
            else
            if (   _parent
                && node2record.exists(child))
            {
                bom      = node2record.lookup(child);
                treeItem = tree.getItem(child);
                treeItem.text(this.nodeTxt(bom,bom.inventTable()));
                tree.setItem(treeItem);
            }
            child = tree.getNextSibling(child);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>versionDate</Name>
				<Source><![CDATA[
    TransDate versionDate()
    {
        return tmpBOMRouteTree.bomRouteDate ? tmpBOMRouteTree.bomRouteDate : DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
    }

]]></Source>
			</Method>
			<Method>
				<Name>versionQty</Name>
				<Source><![CDATA[
    FromQty versionQty()
    {
        return tmpBOMRouteTree.bomRouteFromQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>generateCaption</Name>
				<Source><![CDATA[
    /// <summary>
    /// Generates a caption for the form based on selected filter values.
    /// </summary>
    /// <param name = "_inventDimSetup">The product dimensions to include in the caption.</param>
    /// <param name = "_inventDimParm">InventDimParm indicating which dimension fields to include in the caption.</param>
    /// <param name = "_setup">TmpBOMRouteTree with the setup values to include in the caption.</param>
    /// <returns>Caption with filter values</returns>
    public static str generateCaption(
        InventDim _inventDimSetup,
        InventDimParm _inventDimParm,
        TmpBOMRouteTree _setup,
        str _baseCaption)
    {
        ListEnumerator enumerator = InventDim::dimFieldListEnumerator();
        str caption = _baseCaption;
        while (enumerator.moveNext())
        {
            FieldId dimFieldId = enumerator.current();
            if (_inventDimSetup.(dimFieldId))
            {
                FieldId dimParmFieldId  = InventDim::dim2dimParm(dimFieldId);
                if (_inventDimParm.(dimParmFieldId))
                {
                    caption = strFmt("@SYS329760", caption, any2Str(_inventDimSetup.(dimFieldId)));
                }
            }
        }

        caption = strFmt("@SYS329760", caption, enum2Str(_setup.BOMRouteVersionPrinciple));

        if (_setup.BOMRouteDate)
        {
            caption = strFmt("@SYS329760", caption, date2StrUsr(_setup.BOMRouteDate));
        }

        if (_setup.BOMRouteFromQty)
        {
            caption = strFmt("@SYS329760", caption, any2Str(_setup.BOMRouteFromQty));
        }

        return caption;
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static BOMDesignerCtrl construct(
        FormRun                  _fr,
        FormTreeControl          _tree,
        FormGroupControl         _bomGroup,
        FormGroupControl         _routeGroup,
        tableId                  _callerTableId,
        FormDataSource           _routeDS,
        FormDataSource           _routeOprTableDS
        )
    {
        return new BOMDesignerCtrl(_fr,
                                   _tree,
                                   _bomGroup,
                                   _routeGroup,
                                   _callerTableId,
                                   _routeDS,
                                   _routeOprTableDS
                                  );
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@SYS65375";
    }

]]></Source>
			</Method>
			<Method>
				<Name>itemCanHaveBOM</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns whether an item can have a bill of materials.
    /// </summary>
    /// <param name="_inventTable">The <c>InventTable</c> record buffer.</param>
    /// <returns>true if the item specified can have a bill of materials; otherwise, false.</returns>
    public static boolean itemCanHaveBOM(InventTable _inventTable)
    {
        return _inventTable.isFormulaOrBOMAllowed();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>openBOMDesigner</Name>
				<Source><![CDATA[
    /// <summary>
    /// Opens the BOM Designer form.
    /// </summary>
    /// <param name = "_record">The caller record.</param>
    /// <param name = "_caller">The caller form.</param>
    public static void openBOMDesigner(Common _record, Object _caller)
    {
        MenuFunction menuFunction = new MenuFunction(menuItemDisplayStr(BOMDesignerAction), MenuItemType::Display);

        Args args = new Args();
        args.record(_record);
        args.caller(_caller);

        FormRun formRun = menuFunction.create(args);
        formRun.run();

        // The linkActive do not get called on the BOMVersion data source automatically so need to invoke it manually
        formRun.doLinkActive(_record);
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>