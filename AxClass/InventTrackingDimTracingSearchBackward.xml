<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventTrackingDimTracingSearchBackward</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    Class for handling backward tracing for tracking dimension tracing.
/// </summary>
public class InventTrackingDimTracingSearchBackward extends InventTrackingDimTracingSearch
{
    Set inventTransKeysHandled;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>checkDateOrder</Name>
				<Source><![CDATA[
    protected boolean checkDateOrder(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {    
        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventTransTrackingTransaction inventTransTrackingTransaction =
                InventTransTrackingTransaction::newFromInventTransAndInventTransOrigin(_inventTrans, _inventTransOrigin);

            return this.dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(_currentNode, inventTransTrackingTransaction);
        }
        else
        {
            boolean                             ret = super(_currentNode, _inventTrans, _inventTransOrigin);

            if (ret)
            {
                InventDimTrackingInventTransNode childNode = InventDimTrackingInventTransNode::newFromInventTrans(_inventTrans, _inventTransOrigin);
                if (_currentNode.hasFullDateTime() && childNode.hasFullDateTime())
                {
                    // Both have full date and time information so we can compare
                    if (!_currentNode.fullTrackingDateTime() && childNode.fullTrackingDateTime())
                    {
                        ret = false;
                    }
                    else if (_currentNode.fullTrackingDateTime() < childNode.fullTrackingDateTime())
                    {
                        ret = false;
                    }
                }
                else
                {
                    if (!_currentNode.trackingDate() && childNode.trackingDate())
                    {
                        ret = false;
                    }
                    else if (_currentNode.trackingDate() < childNode.trackingDate())
                    {
                        ret = false;
                    }
                }
            }
            return ret;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean dateAllowsTrackingTransactionToBeUsedAsSubNodeOfCurrentNode(InventDimTrackingInventTransNode _currentNode, InventTrackingTransaction _trackingTransaction)
    {
        boolean ret = super(_currentNode, _trackingTransaction);

        if (ret)
        {
            InventDimTrackingInventTransNode childNode = _trackingTransaction.createTrackingNode();
            if (_currentNode.hasFullDateTime() && childNode.hasFullDateTime())
            {
                // Both have full date and time information so we can compare
                if (!_currentNode.fullTrackingDateTime() && childNode.fullTrackingDateTime())
                {
                    ret = false;
                }
                else if (_currentNode.fullTrackingDateTime() < childNode.fullTrackingDateTime())
                {
                    ret = false;
                }
            }
            else
            {
                if (!_currentNode.trackingDate() && childNode.trackingDate())
                {
                    ret = false;
                }
                else if (_currentNode.trackingDate() < childNode.trackingDate())
                {
                    ret = false;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkQuarantineOrder</Name>
				<Source><![CDATA[
    protected boolean checkQuarantineOrder(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
        InventTrackingDimTracingInventTransDTO inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();

        if (inventTransOriginDTOParent.referenceCategory() != InventTransType::QuarantineOrder)
        {
            return true;
        }

        if (inventTransParentDTO.inventDim().inventLocation().InventLocationType == InventLocationType::Quarantine)
        {
            if (inventTransParentDTO.inventQty() < 0)
            {
                // item going from quarantine issue to quarantine receipt
                if (_inventTransOrigin.ReferenceId != inventTransOriginDTOParent.referenceId())
                {
                    return false;
                }
                if (_inventTrans.inventDim().inventLocation().InventLocationType != InventLocationType::Quarantine)
                {
                    return false;
                }
            }
            else
            {
                // item going from standard warehouse to quarantine warehouse
                if (_inventTransOrigin.ReferenceId != inventTransOriginDTOParent.referenceId())
                {
                    return false;
                }
                if (_inventTrans.inventDim().inventLocation().InventLocationType != InventLocationType::Standard)
                {
                    return false;
                }
            }
        }
        else
        {
            // Parent is at standard warehouse
            if (inventTransParentDTO.inventQty() > 0)
            {
                // item going from quarantine warehouse to standard warehouse
                if (_inventTransOrigin.ReferenceId != inventTransOriginDTOParent.referenceId())
                {
                    return false;
                }
                if (_inventTrans.inventDim().inventLocation().InventLocationType != InventLocationType::Quarantine)
                {
                    return false;
                }
            }
            // else it is the original issue at standard warehouse
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTransOriginIds</Name>
				<Source><![CDATA[
    protected boolean checkTransOriginIds(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin)
    {
        InventTrackingDimTracingInventTransOriginDTO inventTransOriginParentDTO = _currentNode.parmInventTransOriginDTO();
        if (_inventTransOrigin.ReferenceId == '' && inventTransOriginParentDTO.referenceId() == '') // Both are virtual movements where inventTransOrigin is assigned at posting time.
        {
            InventTrackingDimTracingInventTransDTO inventTransParentDTO = _currentNode.parmInventTransDTO();
            if (this.isInventTransWithParametersFirst(
                inventTransParentDTO.dateFinancial(), _inventTrans.DateFinancial,
                inventTransParentDTO.voucher(), _inventTrans.Voucher,
                inventTransOriginParentDTO.recId(), _inventTrans.InventTransOrigin))
            {
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createSubNode</Name>
				<Source><![CDATA[
    protected void createSubNode(
        InventDimTrackingInventTransNode    _currentNode,
        InventTrans                         _inventTrans,
        InventTransOrigin                   _inventTransOrigin = null)
    {
        if (includeWarehouseSpecificInventoryTransactions)
        {
            InventDimTrackingInventTransNode childNode = inventTrackingDimTracingRelations.inventTransNode(_inventTrans, _inventTransOrigin);

            this.linkSubNode(_currentNode, childNode);
        }
        else
        {
            var relatedTransactionNode = inventTrackingDimTracingRelations.addBackwardRelation(_currentNode, _inventTransOrigin, _inventTrans);
            if (!relatedTransactionNode.parmIsBackwardExpanded())
            {
                transactionsToExpand.add(relatedTransactionNode.tracingNodeKey());
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>transferOrderReceiveExpandingIssueTransactionDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handler for the expansion of an issue transaction for <c>TransferOrderReceive</c>.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    [SubscribesTo(classStr(InventTrackingDimTracingSearchBackward), delegateStr(InventTrackingDimTracingSearchBackward, expandIssueTransactionDelegate))]
    public static void transferOrderReceiveExpandingIssueTransactionDelegateHandler(
        InventTrackingDimTracingSearchBackward  _inventTrackingDimTracingSearch,
        SysRecordSortedList                     _inventTransList,
        InventDimTrackingInventTransNode        _currentNode,
        InventDimParm                           _inventDimParmAll,
        EventHandlerResult                      _result)
    {
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();

        switch (inventTransOriginDTOParent.referenceCategory())
        {
            case InventTransType::TransferOrderReceive:
                InventTrackingDimTracingInventTransDTO      inventTransParentDTO = _currentNode.parmInventTransDTO();
                InventTransOrigin                           inventTransOrigin;
                InventTrans                                 inventTrans;

                while select inventTransOrigin
                    where inventTransOrigin.ItemId == inventTransOriginDTOParent.itemId()
                      &&  inventTransOrigin.ReferenceCategory   == InventTransType::TransferOrderShip
                      &&  inventTransOrigin.ReferenceId == inventTransOriginDTOParent.referenceId()
                    join inventTrans
                        where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                          &&  inventTrans.Qty > 0
                          &&  inventTrans.InventDimId == inventTransParentDTO.inventDimId()
                {
                    _inventTrackingDimTracingSearch.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                }

                _result.result(true);
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handling the expansion of an issue transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    delegate void expandIssueTransactionDelegate(
        InventTrackingDimTracingSearchBackward  _inventTrackingDimTracingSearch,
        SysRecordSortedList                     _inventTransList,
        InventDimTrackingInventTransNode        _currentNode,
        InventDimParm                           _inventDimParmAll,
        EventHandlerResult                      _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransaction</Name>
				<Source><![CDATA[
    protected void expandIssueTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        boolean isNodeExpanded = this.tryExpandIssueNode(_inventTransList, _currentNode);
        if (isNodeExpanded)
        {
            return;
        }

        InventTransOrigin   inventTransOrigin;
        InventTrans         inventTrans;

        // find RECEIPT transactions for the same item and iventDim as the current node
        while select inventTransOrigin
            where inventTransOrigin.ItemId == _currentNode.getItemId()
            join inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                && inventTrans.Qty > 0
                && inventTrans.InventDimId == _currentNode.getInventDimId()
        {
            this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>tryExpandIssueNode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Tries to expand a node by calling a delegate.
    /// When delegate returns a result (true), we are going to assume nodes are expanded.
    /// Presumably, the delagate did all the job necessary, so we do not need to proceed.
    /// </summary>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">Currently processed node.</param>
    /// <returns>true if node expand logic is done; otherwise, false.</returns>
    private boolean tryExpandIssueNode(SysRecordSortedList _inventTransList, InventDimTrackingInventTransNode _currentNode)
    {
        if (this.isEventResultEvaluated())
        {
            return globalEventResult.result();
        }

        EventHandlerResult eventResult = new EventHandlerResult();
        this.expandIssueTransactionDelegate(this, _inventTransList, _currentNode, inventDimParmAll, eventResult);

        return eventResult.result();
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandingReceiptTransactionDelegateHandler</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handler for the expansion of a receipt transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    [SubscribesTo(classStr(InventTrackingDimTracingSearchBackward), delegateStr(InventTrackingDimTracingSearchBackward, expandReceiptTransactionDelegate))]
    public static void expandingReceiptTransactionDelegateHandler(
        InventTrackingDimTracingSearchBackward  _inventTrackingDimTracingSearch,
        SysRecordSortedList                     _inventTransList,
        InventDimTrackingInventTransNode        _currentNode,
        InventDimParm                           _inventDimParmAll,
        EventHandlerResult                      _result)
    {
        InventTrackingDimTracingInventTransDTO          inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();

        switch (inventTransOriginDTOParent.referenceCategory())
        {
            case InventTransType::Production:
                _inventTrackingDimTracingSearch.findProdLines(_inventTransList, _currentNode);
                _result.result(true);
                break;
            case InventTransType::BOMMain:
                _inventTrackingDimTracingSearch.findBOMLines(_inventTransList, _currentNode);
                _result.result(true);
                break;
            case InventTransType::KanbanJobProcess:
                _inventTrackingDimTracingSearch.findKanbanJobPickingList(_inventTransList,_currentNode);
                _result.result(true);
                break;
            case InventTransType::InventTransfer:
            case InventTransType::WMSTransport:
            case InventTransType::QuarantineOrder:
            case InventTransType::TransferOrderShip:
            case InventTransType::KanbanJobTransferIssue:
            case InventTransType::KanbanJobTransferReceipt:
                InventTransOriginId transferInventTransOriginId = InventTransOriginTransfer::findTransferRefId(inventTransOriginDTOParent.recId());
                if (!transferInventTransOriginId)
                {
                    transferInventTransOriginId = inventTransOriginDTOParent.recId();
                }
                _inventTrackingDimTracingSearch.findTransIssues(_inventTransList, _currentNode, transferInventTransOriginId, inventTransParentDTO.voucher());
                _result.result(true);
                break;

            case InventTransType::TransferOrderReceive:
                InventTransferLine inventTransferLine = InventTransferLine::findTransIdReceive(inventTransOriginDTOParent.inventTransId());
                Voucher voucher = inventTransParentDTO.voucher();
                if (inventTransferLine.RecId)
                {
                    // Try to skip transit warehouse.
                    transferInventTransOriginId = InventTransOrigin::findByInventTransId(inventTransferLine.InventTransId).RecId;
                    voucher = '';
                }
                if (!transferInventTransOriginId)
                {
                    transferInventTransOriginId = InventTransOriginTransfer::findTransferRefId(inventTransOriginDTOParent.recId());
                }
                if (!transferInventTransOriginId)
                {
                    transferInventTransOriginId = inventTransOriginDTOParent.recId();
                }
                _inventTrackingDimTracingSearch.findTransIssues(_inventTransList, _currentNode, transferInventTransOriginId, voucher);
                _result.result(true);
                break;

            case InventTransType::ProdLine:
                if (#PmfEnabled)
                {
                    if (inventTransParentDTO.isReceipt() && !InventTrackingDimSkipCrossProdLineTracingFlight::instance().isEnabled())
                    {
                        _inventTrackingDimTracingSearch.findBatchIssues(_inventTransList, _currentNode);
                    }
                }
                _result.result(true);
                break;

            case InventTransType::PmfProdCoBy:
                if (inventTransParentDTO.isReceipt())
                {
                    _inventTrackingDimTracingSearch.findBatchIssues(_inventTransList, _currentNode);
                }
                _result.result(true);
                break;

            case InventTransType::WHSQuarantine:
                _inventTrackingDimTracingSearch.findTransWHSQuarantineIssues(_inventTransList, _currentNode);
                _result.result(true);
                break;

            case InventTransType::WHSWork:
                _inventTrackingDimTracingSearch.findTransWHSWorkIssues(_inventTransList, _currentNode);
                _result.result(true);
                break;

            case InventTransType::WHSContainer:                
                _inventTrackingDimTracingSearch.findTransWHSContainerIssues(_inventTransList, _currentNode);
                _result.result(true);                
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionDelegate</Name>
				<Source><![CDATA[
    /// <summary>
    /// Delegate handling the expansion of a receipt transaction.
    /// </summary>
    /// <param name = "_inventTrackingDimTracingSearch">The class receiving the expanded <c>InventTrans</c> records.</param>
    /// <param name = "_inventTransList">The list of expanded <c>InventTrans</c> records.</param>
    /// <param name = "_currentNode">The node to expand.</param>
    /// <param name = "_inventDimParmAll">The InventDimParm to filter the expansion.</param>
    /// <param name = "_result">The event result to indicate if the delegate handler handled the expansion.</param>
    delegate void expandReceiptTransactionDelegate(
        InventTrackingDimTracingSearchBackward  _inventTrackingDimTracingSearch,
        SysRecordSortedList                     _inventTransList,
        InventDimTrackingInventTransNode        _currentNode,
        InventDimParm                           _inventDimParmAll,
        EventHandlerResult                      _result)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransaction</Name>
				<Source><![CDATA[
    protected void expandReceiptTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        var eventResult = new EventHandlerResult();
        this.expandReceiptTransactionDelegate(this, _inventTransList, _currentNode, inventDimParmAll, eventResult);

        if (eventResult.result())
        {
            // When delegate returns a result, we are not going to perform the logic to find and expand child nodes.
            // Presumably, the delagate did all the job necessary, so we do not need to proceed.
            return;
        }

        this.expandReturnReceiptTransaction(_inventTransList, _currentNode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReturnReceiptTransaction</Name>
				<Source><![CDATA[
    private void expandReturnReceiptTransaction(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransDTO inventTransParentDTO = _currentNode.parmInventTransDTO();
        if (inventTransParentDTO.returnInventTransOriginRecId() && inventTransParentDTO.isReceipt())
        {
            this.findTransIssues(_inventTransList, _currentNode, inventTransParentDTO.returnInventTransOriginRecId(), '');
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBatchIssues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the batch order issues.
    /// </summary>
    /// <param name="_inventTransList">
    ///    A sorted list of the <c>InventTrans</c> records.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node which the batch receipts belong.
    /// </param>
    protected void findBatchIssues(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransDTO          inventTransParentDTO       = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();
        InventTransOrigin                               inventTransOrigin;
        InventTrans                                     inventTrans;
        ProdBOM                                         prodBOM;
        PmfProdCoBy                                     prodCoBy;

        if (inventTransOriginDTOParent.referenceCategory() == InventTransType::PmfProdCoBy
            && inventTransParentDTO.isReceipt() && inventTransParentDTO.statusReceipt() == StatusReceipt::Purchased)
        {
            while select TableId from prodBOM
                where prodBOM.ProdId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == prodBOM.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTrans.StatusIssue      == StatusIssue::Sold
                        && inventTrans.StatusReceipt    == StatusReceipt::None
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }

            while select TableId from prodCoBy
                where prodCoBy.ProdId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == prodCoBy.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTrans.StatusIssue      == StatusIssue::Sold
                        && inventTrans.StatusReceipt    == StatusReceipt::None
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
        else
        {
            while select TableId from prodBOM
                where prodBOM.ProdId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == prodBOM.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTrans.StatusReceipt != StatusReceipt::Purchased
                        && inventTrans.StatusIssue != StatusIssue::Sold
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }

            while select TableId from prodCoBy
                where prodCoBy.ProdId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == prodCoBy.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTrans.StatusReceipt != StatusReceipt::Purchased
                        && inventTrans.StatusIssue != StatusIssue::Sold
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findBOMLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds the BOM lines for the specified node, which is assumed to be the item produced on the BOM journal.
    /// </summary>
    /// <param name="_inventTransList">
    ///    A <c>SysRecordSortList</c> list of transactions.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    protected void findBOMLines(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransDTO  inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();
        InventTransOrigin                       inventTransOrigin;
        InventTrans                             inventTrans;
        InventJournalTrans                      inventJournalTrans;
        InventTransPosting                      inventTransPosting;

        if ((inventTransParentDTO.inventQty() > 0 && inventTransParentDTO.statusReceipt() == StatusReceipt::Purchased)  
            || (inventTransParentDTO.inventQty() < 0 && inventTransParentDTO.statusIssue() == StatusIssue::Sold))
        {
            while select TableId from inventTransPosting
                where inventTransPosting.TransDate == inventTransParentDTO.dateFinancial()
                   && inventTransPosting.Voucher == inventTransParentDTO.voucher()
                   && inventTransPosting.InventTransPostingType == InventTransPostingType::Financial
                join inventTrans
                    where inventTrans.Voucher == inventTransParentDTO.voucher()
                       && inventTrans.DateFinancial == inventTransParentDTO.dateFinancial()
                       && inventTrans.InventTransOrigin == inventTransPosting.InventTransOrigin
                join inventTransOrigin
                    where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            {
                if (inventTransParentDTO.inventQty() * inventTrans.Qty < 0)
                {
                    this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                }
            }
        }
        else
        {
            while select TableId from inventJournalTrans
                where inventJournalTrans.JournalId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == inventJournalTrans.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                       && inventTrans.StatusReceipt != StatusReceipt::Purchased
                       && inventTrans.StatusIssue != StatusIssue::Sold
                       && inventTrans.RecId != inventTransParentDTO.recId()
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findKanbanJobPickingList</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds the kanban job picking list transactions related to the parent transaction to the
    ///    transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <remarks>
    ///    A kanban job picking list record is related to the parent transaction, if the
    ///    <c>KanbanJobPickingList.Job</c> field represents the origin of the parent transaction.
    /// </remarks>
    protected void findKanbanJobPickingList(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();
        InventTransOrigin                               inventTransOrigin;
        InventTrans                                     inventTrans;
        KanbanJobPickingList                            kanbanJobPickingList;
        KanbanJob                                       kanbanJob;

        while select TableId from kanbanJob
            where kanbanJob.InventTransId == inventTransOriginDTOParent.inventTransId()
            join TableId from kanbanJobPickingList
                where kanbanJobPickingList.Job == kanbanJob.RecId
            join inventTransOrigin
                where inventTransOrigin.InventTransId == kanbanJobPickingList.InventTransId
            join inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
        {
            this.addInventTrans2List(_inventTransList, inventTrans, inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findProdLines</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds the production lines transactions related to the parent transaction to the
    ///    transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    protected void findProdLines(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrackingDimTracingInventTransDTO          inventTransParentDTO = _currentNode.parmInventTransDTO();
        InventTrackingDimTracingInventTransOriginDTO    inventTransOriginDTOParent = _currentNode.parmInventTransOriginDTO();
        InventTransOrigin                               inventTransOrigin;
        InventTrans                                     inventTrans;
        InventDim                                       parentDTOInventDim;
        InventTrackingDimTracingProductComponentLot     inventTrackingDimTracingProductComponentLot;

        if (isProdAsBuiltBOMFeatureEnabled)
        {
            // product node
            inventTrackingDimTracingProductComponentLot = InventTrackingDimTracingProductComponentLot::createBuilder(inventTransParentDTO,
                                                                                                                     inventTransOriginDTOParent, 
                                                                                                                     inventTransParentDTO.inventDim(),
                                                                                                                     productComponentLotSettleMap);
        }

        if ((inventTransParentDTO.inventQty() > 0 && inventTransParentDTO.statusReceipt() == StatusReceipt::Purchased)  
            || (inventTransParentDTO.inventQty() < 0 && inventTransParentDTO.statusIssue() == StatusIssue::Sold))
        {
            InventTransPosting                      inventTransPosting;

            while select TableId from inventTransPosting
                where inventTransPosting.TransDate == inventTransParentDTO.dateFinancial()
                  &&  inventTransPosting.Voucher == inventTransParentDTO.voucher()
                  &&  inventTransPosting.InventTransPostingType == InventTransPostingType::Financial
                join inventTrans
                    where inventTrans.Voucher == inventTransParentDTO.voucher()
                      &&  inventTrans.DateFinancial == inventTransParentDTO.dateFinancial()
                      &&  inventTrans.InventTransOrigin == inventTransPosting.InventTransOrigin
                join inventTransOrigin
                    where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            {
                if (inventTrackingDimTracingProductComponentLot && !inventTrackingDimTracingProductComponentLot.checkComponentLotAssociation(inventTrans, inventTransOrigin))
                {
                    continue;
                }

                if (inventTransParentDTO.inventQty() * inventTrans.Qty < 0)
                {
                    this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
                }
            }
        }
        else
        {
            ProdBOM prodBOM;

            while select TableId from prodBOM
                where prodBOM.ProdId == inventTransOriginDTOParent.referenceId()
                join inventTransOrigin
                    where inventTransOrigin.InventTransId == prodBOM.InventTransId
                join inventTrans
                    where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                        && inventTrans.StatusReceipt != StatusReceipt::Purchased
                        && inventTrans.StatusIssue != StatusIssue::Sold
            {
                if (#PmfEnabled && inventTrans.direction() != InventDirection::Issue)
                {
                    continue;
                }

                if (inventTrackingDimTracingProductComponentLot && !inventTrackingDimTracingProductComponentLot.checkComponentLotAssociation(inventTrans, inventTransOrigin))
                {
                    continue;
                }
                
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransIssues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds issue transactions related to the parent transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransOriginId">
    ///    The transaction ID for the related issue transaction.
    /// </param>
    /// <param name="_voucher">
    ///    The voucher used when posting related issues. If empty all transactions will be considered.
    /// </param>
    protected void findTransIssues(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode,
        InventTransOriginId                 _inventTransOriginId,
        Voucher                             _voucher)
    {
        InventTransOrigin       inventTransOrigin;
        InventTrans             inventTrans;
        boolean                 hasRelatedTrackingDimIssueTrans = false;
       
        // Find by tracking dimension firstly
        InventDim inventDimParent;
        inventDimParent = _currentNode.parmInventTransDTO().inventDim();
        List trackingDimList = InventDim::dimTrackingDimFieldList();
        InventDimParm dimParmTrackingDim;
        dimParmTrackingDim.initFromInventDim(inventDimParent, trackingDimList);
        InventDim inventDim;

        while select inventTransOrigin
            where inventTransOrigin.RecId       == _inventTransOriginId
            join inventTrans
            where inventTrans.InventTransOrigin == inventTransOrigin.RecId
            &&  inventTrans.StatusReceipt     == StatusReceipt::None
            &&  inventTrans.Qty                <  0
            && (inventTrans.Voucher           == _voucher || !_voucher)
        #InventDimJoin(inventTrans.inventDimId, inventDim, inventDimParent, dimParmTrackingDim)
        {
            hasRelatedTrackingDimIssueTrans = true;
            this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
        }

        if (!hasRelatedTrackingDimIssueTrans &&
            this.needQueryTransWithoutSpecifiedTrackingDim(inventDimParent, _currentNode.parmInventTransOriginDTO().referenceCategory()))
        {
            while select inventTransOrigin
                where inventTransOrigin.RecId       == _inventTransOriginId
                join inventTrans
                where inventTrans.InventTransOrigin == inventTransOrigin.RecId
                  &&  inventTrans.StatusReceipt     == StatusReceipt::None
                  &&  inventTrans.Qty                <  0
                  && (inventTrans.Voucher           == _voucher || !_voucher)
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransWHSQuarantineIssues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds WHS Quarantine issue transactions related to the parent receipt transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransOriginParent">
    ///    The transaction origin for the related receipt transaction; obsolete, the provided value is not used.
    /// </param>
    protected void findTransWHSQuarantineIssues(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode,
        InventTransOrigin                   _inventTransOriginParent = null)
    {
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        WHSWorkQuarantine       whsWorkQuarantine;

        while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join whsWorkQuarantine
                where whsWorkQuarantine.InventTransIdFrom == inventTransOrigin.InventTransId
                    && whsWorkQuarantine.InventTransIdTo == _currentNode.parmInventTransOriginDTO().inventTransId()
        {
            this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransWHSWorkIssues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds and adds WHS Work issue transactions related to the parent receipt transaction to the transaction list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    /// <param name="_inventTransOriginParent">
    ///    The transaction origin for the related receipt transaction; obsolete, the provided value is not used.
    /// </param>
    protected void findTransWHSWorkIssues(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode,
        InventTransOrigin                   _inventTransOriginParent = null)
    {
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        WHSWorkInventTrans      whsWorkInventTrans;
        InventDim               inventDim;
        InventDim               parentInventDim = _currentNode.parmInventTransDTO().inventDim();
        InventDimParm           inventDimParmNonStorage = parentInventDim.toDimParm();

        inventDimParmNonStorage.clearStorageDimensions();

        if (isInventTrackingDimTracingCorrectJoinOrderEnabled)
        {
            while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            #InventDimJoin(inventTrans.inventDimId, inventDim, parentInventDim, inventDimParmNonStorage)
            exists join whsWorkInventTrans
                where whsWorkInventTrans.InventTransIdFrom == inventTransOrigin.InventTransId
                   && whsWorkInventTrans.InventTransIdTo   == _currentNode.parmInventTransOriginDTO().inventTransId()
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
        else
        {
            while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join whsWorkInventTrans
                where whsWorkInventTrans.InventTransIdFrom == inventTransOrigin.InventTransId
                   && whsWorkInventTrans.InventTransIdTo   == _currentNode.parmInventTransOriginDTO().inventTransId()
            #InventDimJoin(inventTrans.inventDimId, inventDim, parentInventDim, inventDimParmNonStorage)
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>findTransWHSContainerIssues</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Finds WHSContainer issue transactions related to the parent receipt transaction and adds them to the transactions list.
    /// </summary>
    /// <param name="_inventTransList">
    ///    The <c>SysRecordSortedList</c> object to insert into.
    /// </param>
    /// <param name="_currentNode">
    ///    The transaction node being expanded.
    /// </param>
    private void findTransWHSContainerIssues(
        SysRecordSortedList                 _inventTransList,
        InventDimTrackingInventTransNode    _currentNode)
    {
        InventTrans             inventTrans;
        InventTransOrigin       inventTransOrigin;
        WHSContainerTrans       whsContainerTrans;
        InventDim               inventDim;
        InventDim               parentInventDim = _currentNode.parmInventTransDTO().inventDim();
        InventDimParm           inventDimParmNonStorage = parentInventDim.toDimParm();

        inventDimParmNonStorage.clearStorageDimensions();

        if (isInventTrackingDimTracingCorrectJoinOrderEnabled)
        {
            while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            #InventDimJoin(inventTrans.inventDimId, inventDim, parentInventDim, inventDimParmNonStorage)
            exists join whsContainerTrans
                where whsContainerTrans.InventTransIdFrom == inventTransOrigin.InventTransId
                   && whsContainerTrans.InventTransIdTo   == _currentNode.parmInventTransOriginDTO().inventTransId()
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
        else
        {
            while select inventTrans
            join inventTransOrigin
                where inventTransOrigin.RecId == inventTrans.InventTransOrigin
            exists join whsContainerTrans
                where whsContainerTrans.InventTransIdFrom == inventTransOrigin.InventTransId
                   && whsContainerTrans.InventTransIdTo   == _currentNode.parmInventTransOriginDTO().inventTransId()
            #InventDimJoin(inventTrans.inventDimId, inventDim, parentInventDim, inventDimParmNonStorage)
            {
                this.addChildInventTrans2List(_currentNode, _inventTransList, inventTrans, inventTransOrigin);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isChildInProdBOM</Name>
				<Source><![CDATA[
    protected boolean isChildInProdBOM(InventDimTrackingInventTransNode _currentNode, InventTransOrigin _inventTransOrigin)
    {
        return this.isTransReferenceProdBOMForProduction(
            _currentNode.parmInventTransOriginDTO().referenceCategory(), _inventTransOrigin.ReferenceCategory,
            _currentNode.parmInventTransOriginDTO().referenceId(), _inventTransOrigin.ReferenceId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isTransactionExpanded</Name>
				<Source><![CDATA[
    protected boolean isTransactionExpanded(InventDimTrackingInventTransNode _transactionNode)
    {
        return _transactionNode.parmIsBackwardExpanded();
    }

]]></Source>
			</Method>
			<Method>
				<Name>markNodeAsExpanded</Name>
				<Source><![CDATA[
    protected void markNodeAsExpanded(
        InventDimTrackingInventTransNode    _currentNode)
    {
        _currentNode.parmIsBackwardExpanded(true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>markNodeWithNoSubnodes</Name>
				<Source><![CDATA[
    protected void markNodeWithNoSubnodes(
        InventDimTrackingInventTransNode    _currentNode)
    {
        if (inventTrackingDimTracingCriteria.parmTraceDirection() == ForwardBackward::Forward)
        {
            inventTrackingDimTracingRelations.markAsRootNode(_currentNode);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Create a new instance of this class.
    /// </summary>
    /// <returns>
    ///    A new instance.
    /// </returns>
    protected static InventTrackingDimTracingSearchBackward construct()
    {
        InventTrackingDimTracingSearchBackward  inventTrackingDimTracingSearchBackward = new InventTrackingDimTracingSearchBackward();
        return inventTrackingDimTracingSearchBackward;
    }

]]></Source>
			</Method>
			<Method>
				<Name>newParameters</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Create an instance to do a full backward search.
    /// </summary>
    /// <param name="_inventTrackingDimTracingCriteria">
    ///    The search criteria to use.
    /// </param>
    /// <returns>
    ///    A new instance of the search class.
    /// </returns>
    static public InventTrackingDimTracingSearchBackward newParameters(
        InventTrackingDimTracingCriteria    _inventTrackingDimTracingCriteria)
    {
        InventTrackingDimTracingSearchBackward      inventTrackingDimTracingSearchBackward = InventTrackingDimTracingSearchBackward::construct();

        inventTrackingDimTracingSearchBackward.parmInventTrackingDimTracingCriteria(_inventTrackingDimTracingCriteria);

        return inventTrackingDimTracingSearchBackward;
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptTransactionIncludingWHSInventoryTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void expandReceiptTransactionIncludingWHSInventoryTransaction(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        if (_currentNode.getTransactionType() == InventTrackingTransactionType::InventTrans)
        {
            SysRecordSortedList tmpList = this.initInventTransList();

            this.expandReceiptTransaction(tmpList, _currentNode);

            InventTrackingDimTracingSearch::addInventTransListToInventTrackingTransactionList(_inventTransAndWHSInventoryTransactionList, tmpList, _allTransactionMap);
        }
        else if (_currentNode.getTransactionType() == InventTrackingTransactionType::WHSInventoryTransaction)
        {
            this.expandReceiptWHSInventoryTransaction(_inventTransAndWHSInventoryTransactionList, _currentNode, _allTransactionMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandReceiptWHSInventoryTransaction</Name>
				<Source><![CDATA[
    private void expandReceiptWHSInventoryTransaction(
        SysRecordSortedList                 _list,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        WHSInventoryTransactionView transactionView  = this.findWHSInventoryTransactions(WHSInventoryTransactionTypeEnum::RegisteredIssue, _currentNode);
        
        this.addTransactionViewRecordsToListAndMap(_currentNode, transactionView, _list, _allTransactionMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionIncludingWHSInventoryTransaction</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void expandIssueTransactionIncludingWHSInventoryTransaction(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        var eventResult = new EventHandlerResult();
        SysRecordSortedList tmpInventTransList = this.initInventTransList();
        this.expandIssueTransactionDelegate(this, tmpInventTransList, _currentNode, inventDimParmAll, eventResult);

        if (!eventResult.result())
        {
            globalEventResult = eventResult;

            this.expandIssueTransaction(tmpInventTransList, _currentNode);

            InventTrackingDimTracingSearch::addInventTransListToInventTrackingTransactionList(_inventTransAndWHSInventoryTransactionList, tmpInventTransList, _allTransactionMap);

            this.expandIssueTransactionsWHSTransactions(_inventTransAndWHSInventoryTransactionList, _currentNode, _allTransactionMap);

            globalEventResult = null;
        }
        else
        {
            InventTrackingDimTracingSearch::addInventTransListToInventTrackingTransactionList(_inventTransAndWHSInventoryTransactionList, tmpInventTransList, _allTransactionMap);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>expandIssueTransactionsWHSTransactions</Name>
				<Source><![CDATA[
    private void expandIssueTransactionsWHSTransactions(
        SysRecordSortedList                 _inventTransAndWHSInventoryTransactionList,
        InventDimTrackingInventTransNode    _currentNode,
        Map _allTransactionMap)
    {
        WHSWarehouseTransactionItemTracingQuery query = new WHSWarehouseTransactionItemTracingQuery();
            
        WHSInventoryTransactionView transactionView = query.findReceiptTransaction(_currentNode.getItemId(), _currentNode.getInventDim());

        this.addTransactionViewRecordsToListAndMap(_currentNode, transactionView, _inventTransAndWHSInventoryTransactionList, _allTransactionMap);
    }

]]></Source>
			</Method>
			<Method>
				<Name>linkSubNode</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void linkSubNode(
        InventDimTrackingInventTransNode  _currentNode,
        InventDimTrackingInventTransNode _relatedTransactionNode)
    {

        inventTrackingDimTracingRelations.addBackwardRelationBetweenNodes(_currentNode, _relatedTransactionNode);
        
        if (!_relatedTransactionNode.parmIsBackwardExpanded())
        {
            transactionsToExpand.add(_relatedTransactionNode.tracingNodeKey());
        }        
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>