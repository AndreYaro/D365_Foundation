<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>TrvPost</Name>
	<SourceCode>
		<Declaration><![CDATA[
class TrvPost
{
    #DEFINE.TaxTemplate('TrvTaxTemplate')
    #DEFINE.TemporaryVoucher('TemporaryVoucher')
}
]]></Declaration>
		<Methods>
			<Method>
				<Name>createTaxRecoveryItem</Name>
				<Source><![CDATA[
    public static void createTaxRecoveryItem(TrvExpTrans _trvExpTrans)
    {
        TaxAmount               taxAmount;
        TaxAmount               taxInCostPrice;
        TrvExpenseTaxRecovery   trvExpenseTaxRecovery;
        TrvTaxExpense           trvTaxExpense;
        TrvTaxDocumentExpense   trvTaxDocumentExpense;

        TrvLegalEntity taxCompany = TrvExpTrans::getLegalEntityForTax(_trvExpTrans);

        CompanyInfo foundDataArea = CompanyInfo::findDataArea(taxCompany);

        if (foundDataArea)
        {
            changecompany(taxCompany)
            {
                if (!_trvExpTrans ||
                    (_trvExpTrans.ApprovalStatus != TrvAppStatus::Approved && _trvExpTrans.ApprovalStatus != TrvAppStatus::Ready) ||
                    !_trvExpTrans.TaxGroup ||
                    !_trvExpTrans.TaxItemGroup)
                {
                    return;
                }

                trvTaxDocumentExpense = TrvTaxDocumentExpense::newTrvExpTrans(_trvExpTrans);
                trvTaxExpense = TaxCalculation::newForSourceTypeWithTaxUncommitted(TaxSourceType::Expense, trvTaxDocumentExpense, true, false);
                taxAmount = trvTaxExpense.totalRegTaxAmountSingleLineIncludeUseTax(_trvExpTrans.TableId, _trvExpTrans.RecId, false);
                taxInCostPrice = trvTaxExpense.totalTaxInCostPrice(_trvExpTrans.RecId);

                if (taxAmount && taxAmount != taxInCostPrice)
                {
                    trvExpenseTaxRecovery.TaxRecoveryNumber = NumberSeq::newGetNum(TrvParameters::numRefTaxRecoveryNumber(), true).num();
                    trvExpenseTaxRecovery.TaxRecoverableAmount = taxAmount - taxInCostPrice;
                    trvExpenseTaxRecovery.Status = TrvTaxRecoveryStatus::NotSubmitted;
                    trvExpenseTaxRecovery.TaxRecoverableCurrencyCode = _trvExpTrans.ExchangeCode;
                    trvExpenseTaxRecovery.ExpTransRecId = _trvExpTrans.RecId;
                    trvExpenseTaxRecovery.CountryRegion = _trvExpTrans.CountryRegion;
                    trvExpenseTaxRecovery.TaxGroup = _trvExpTrans.TaxGroup;
                    trvExpenseTaxRecovery.TaxItemGroup = _trvExpTrans.TaxItemGroup;
                    trvExpenseTaxRecovery.ReceiptDate = _trvExpTrans.TransDate;
                    trvExpenseTaxRecovery.ReceiptNumber = _trvExpTrans.ReceiptNumber;
                    trvExpenseTaxRecovery.insert();
                    if (trvExpenseTaxRecovery.RecId)
                    {
                        //activate Workflow
                        Workflow::activateFromWorkflowType(#TaxTemplate, trvExpenseTaxRecovery.RecId, '', NoYes::No);
                        ttsbegin;
                        trvExpenseTaxRecovery.Status = TrvTaxRecoveryStatus::Submitted;
                        trvExpenseTaxRecovery.doUpdate();
                        ttscommit;
                    }
                }
            }
        }
        else
        {
            throw error("@Expense:InvalidExpenseInterCompanyLE");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args args)
    {
        TrvLedgerJournalDialog  ledgerJournalDialog;

        // Cash advance posting
        if (args.record().TableId == tablenum(TrvCashAdvance))
        {
            ledgerJournalDialog = TrvLedgerJournalDialog::construct("@SYS117457");
            ledgerJournalDialog.run();

            if (ledgerJournalDialog.parmIsClosedOK())
            {
                TrvPost::post(args.record(),
                                ledgerJournalDialog.parmJournalName(),
                                ledgerJournalDialog.parmJournalId(),
                                ledgerJournalDialog.parmPostingDate(),
                                true);
            }
        }
        else if (args.record().TableId == tablenum(TrvExpTable) || args.record().TableId == tablenum(TrvExpTrans))
        {
            // Expense report or expense lines posting
            FormDataSource formDataSource = FormDataUtil::getFormDataSource(args.record());

            Common expenseToPost = formDataSource.getFirst(true);
            if (expenseToPost == null)
            {
                expenseToPost = formDataSource.cursor();
            }

            while (expenseToPost)
            {
                if (!expenseToPost.validatePost())
                {
                    return;
                }
                expenseToPost = formDataSource.getNext();
            }

            TrvPost::postMultiple(formDataSource,
                            '',
                            '',
                            dateNull());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>post</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Posts expense management related transactions to the general ledger.
    /// </summary>
    /// <param name="_record">
    ///    The record buffer of the expense transaction.
    /// </param>
    /// <param name="_journalName">
    ///    The journal name to be used in creating the ledger transaction; optional.
    /// </param>
    /// <param name="_journalId">
    ///    The journal number to be used in creating the ledger transaction; optional.
    /// </param>
    /// <param name="_transDate">
    ///    The posting date to be used in creating the ledger transaction; optional.
    /// </param>
    /// <param name="_calledFromUI">
    ///    Indicates if the class is called by clicking a menu item in from a client form; optional.
    /// </param>
    /// <remarks>
    ///    This posting class is used for posting cash advance requests, expense report transactions, and
    ///    expense line transactions.
    /// </remarks>
    static void post(Common _record,
                               LedgerJournalNameId _journalName = '',
                               LedgerJournalId _journalId = '',
                               TransDate _transDate = dateNull(),
                               boolean _calledFromUI = false)
    {
        LedgerJournalTable         ledgerJournalTable = null;
        LedgerJournalTable         ledgerJournalTableWTax = null;
        LedgerJournalTrans         ledgerJournalTrans;
        TrvLedgerInfo              trvLedgerInfo;
        TrvCashAdvance             trvCashAdvance;
        TrvExpTrans                trvExpTrans;
        TrvExpTable                trvExpTable;
        Name                       description;
        Args                       args;
        boolean                    ignoreParameter = false;
        boolean                    taxIncluded = false;
        TrvParameters              trvParameters = TrvParameters::find();

        int                     numberOfRecoveryTasks = 0;
        TrvExpenseTaxRecovery   trvExpenseTaxRecovery;
        TrvExpTrans             trvExpTransTmp;
        TrvExpNumber        	trvExpNumber;

        TrvPostExpenseHeader    trvPostExpenseHeader;
        TrvPostExpenseLine      trvPostExpenseLine;

        ExpenseInstrumentationLogger logger = ExpenseInstrumentationLogger::createLogger(classStr(TrvPost));
        ExpenseInstrumentationLoggerProperties properties = logger.properties();
        ExpenseInstrumentationPostActivities postActivities = ExpenseInstrumentationPostActivities::construct(logger);

        using (var trvPostContext = postActivities.trvPostContext())
        {
            //count existing number of tax recovery records
            if (TrvParametersTableHelper::isTaxRecoveryEnabled(trvParameters) && _record.TableId != tableNum(TrvCashAdvance))
            {
                if (_record.TableId == tableNum(TrvExpTable))
                {
                    trvExpTable = _record;
                    trvExpNumber = trvExpTable.ExpNumber;
                }
                else if (_record.TableId == tableNum(TrvExpTrans))
                {
                    trvExpTrans = _record;
                    trvExpNumber = trvExpTrans.ExpNumber;
                }

                if (trvExpNumber)
                {
                    select count(RecId) from trvExpenseTaxRecovery exists join trvExpTransTmp
                        where trvExpenseTaxRecovery.ExpTransRecId == trvExpTransTmp.RecId && trvExpTransTmp.ExpNumber == trvExpNumber;

                    numberOfRecoveryTasks = int642int(trvExpenseTaxRecovery.RecId);
                }
            }

            if (_transDate == dateNull())
                _transDate = DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());

            ttsbegin;

            switch (_record.TableId)
            {
                case tableNum(TrvCashAdvance):
                    using (var cashAdvanceContext = postActivities.cashAdvanceContext())
                    {
                        trvCashAdvance  = _record;

                        if (_calledFromUI)
                        {
                            // if call from UI then we need to retrive the record because the form data source may
                            // have not retrive all of the fields.
                            trvCashAdvance = TrvCashAdvance::findRecId(trvCashAdvance.RecId, true);
                        }

                        description = strFmt("@SYS117456", trvCashAdvance.CashAdvanceNumber);

                        // Create LedgerTable record
                        ledgerJournalTable = TrvCreateLedger::createLedgerJournal(_journalName,
                                                                                  _journalId,
                                                                                  description,
                                                                                  _transDate);

                        trvLedgerInfo = TrvLedgerInfo::construct(_record.TableId, _record.RecId, NumberSequenceTable::find(ledgerJournalTable.NumberSequenceTable).NumberSequence);

                        trvLedgerInfo.parmJournalId(ledgerJournalTable.JournalNum);
                        trvLedgerInfo.parmTransDate(_transDate);

                        if (trvCashAdvance.CashAdvanceStatus == TrvWorkflowCashAdvanceStatus::Approved)
                        {
                            trvLedgerInfo.parmApproved(NoYes::Yes);
                        }

                        TrvCreateLedger::createLedgerJournalTrans(trvLedgerInfo);

                        // Update TrvCashAdvance Posting Information
                        trvCashAdvance.Balance           = trvCashAdvance.PaidAmountCur;
                        trvCashAdvance.BalanceMST        = trvCashAdvance.PaidAmountMST;
                        trvCashAdvance.CashAdvanceStatus = TrvWorkflowCashAdvanceStatus::Paid;
                        trvCashAdvance.PaidDate          = _transDate;
                        trvCashAdvance.PayingWorker      = HcmWorker::userId2Worker(curUserId());

                        ttsbegin;
                        trvCashAdvance.doUpdate();
                        ttscommit;
                        postActivities.addCustomProperty(cashAdvanceContext, properties.propertyByTableRecord(trvCashAdvance));
                    }
                    break;

                case tableNum(TrvExpTable):
                    using (var expenseReportContext = postActivities.expenseReportHeaderContext())
                    {
                        trvExpTable = TrvPost::postExpenseReportHeader(_record, _calledFromUI);
                        postActivities.addCustomProperty(expenseReportContext, properties.propertyByTableRecord(trvExpTable));
                        postActivities.addCustomProperty(expenseReportContext, properties.postingLevel(ExpenseInstrumentationLoggerProperties::Header));
                    }
                    break;

                case tableNum(TrvExpTrans):
                    using (var expenseReportContext = postActivities.expenseReportHeaderContext())
                    {
                        trvExpTrans = TrvPost::postExpenseLine(_record, _calledFromUI);
                        postActivities.addCustomProperty(expenseReportContext, properties.propertyByTableRecord(trvExpTrans));
                        postActivities.addCustomProperty(expenseReportContext, properties.postingLevel(ExpenseInstrumentationLoggerProperties::Line));
                    }
                    break;
            }

            select firstonly RecId from ledgerJournalTrans where ledgerJournalTrans.JournalNum  == ledgerJournalTable.JournalNum;

            // If there are ledger vouchers created, check if ledger journal can be post immediately
            if (ledgerJournalTrans.RecId)
            {
                try
                {
                    if (trvParameters.PostImmediately == NoYes::Yes && ledgerJournalTable.RecId)
                    {
                        TrvLedgerJournalCheckPost trvLedgerJournalCheckPost = TrvLedgerJournalCheckPost::construct(ledgerJournalTable);
                        trvLedgerJournalCheckPost.parmIsCashAdvancePosting(true);
                        trvLedgerJournalCheckPost.run();
                    }

                    if (trvParameters.PostImmediately == NoYes::Yes && ledgerJournalTableWTax.RecId)
                    {
                        TrvLedgerJournalCheckPost trvLedgerJournalCheckPost = TrvLedgerJournalCheckPost::construct(ledgerJournalTableWTax);
                        trvLedgerJournalCheckPost.parmIsCashAdvancePosting(true);
                        trvLedgerJournalCheckPost.run();
                    }
                }
                catch (Exception::Error)
                {
                    // Expense report/line item has been posted to the journal, but posting to the General Ledger has failed - see General Ledger errors for details
                    error ("@SYS128884");
                }
            }

            ttscommit;

            if (TrvParametersTableHelper::isTaxRecoveryEnabled(trvParameters) && trvExpNumber)
            {
                select firstonly trvExpTrans where trvExpTrans.ExpNumber == trvExpNumber;

                TrvLegalEntity taxCompany = TrvExpTrans::getLegalEntityForTax(trvExpTrans);

                CompanyInfo foundDataArea = CompanyInfo::findDataArea(taxCompany);

                if (foundDataArea)
                {
                    changeCompany(taxCompany)
                    {
                        TrvExpenseTaxRecovery expenseTaxRecovery;

                        select count(RecId) from expenseTaxRecovery exists join trvExpTransTmp
                        where expenseTaxRecovery.ExpTransRecId == trvExpTransTmp.RecId && trvExpTransTmp.ExpNumber == trvExpNumber;

                        numberOfRecoveryTasks = int642int(expenseTaxRecovery.RecId) - numberOfRecoveryTasks;

                        if (numberOfRecoveryTasks > 0)
                        {
                            info(strFmt("@SYS138609", numberOfRecoveryTasks));
                        }
                    }
                }
                else
                {
                    throw error("@Expense:InvalidExpenseInterCompanyLE");
                }
            }
        }

    }

]]></Source>
			</Method>
			<Method>
				<Name>postMultiple</Name>
				<Source><![CDATA[
    public static void postMultiple(FormDataSource _formDataSource,
                                    LedgerJournalNameId _journalname,
                                    LedgerJournalId _journalid,
                                    TransDate _postingdate,
                                    boolean _all = false)
    {
        Common buffer;

        if (!_all)
        {
            for (buffer = _formDataSource.getFirst(true) ? _formDataSource.getFirst(true) : _formDataSource.cursor(); buffer; buffer = _formDataSource.getNext())
            {
                TrvPost::post(buffer,
                              _journalname,
                              _journalid,
                              _postingdate,
                              true);
            }
        }
        else    // Post everything that's visible in the GRID
        {
            buffer = _formDataSource.getFirst();
            while (buffer)
            {
                TrvPost::post(buffer,
                              _journalname,
                              _journalid,
                              _postingdate,
                              true);
                buffer = _formDataSource.getNext();
            }
        }

        _formDataSource.reread();
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAllMileage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates mileage amount based on used mileage and multiple mileage tieres.
    /// </summary>
    /// <param name = "_expTrans">
    /// The record buffer of the expense transaction.
    /// </param>
    /// <param name = "_returnMileageAmount">
    /// True if the caller wants this method to return map with mileage amount details, false if method need to return map with RecId's of transactions. Defaulted to false.
    /// </param>
    /// <returns>
    /// Map with mileage amount details or map with RecId's of transactions, based on "_returnMileageAmount" parameter.
    /// </returns>
    public static Map calculateAllMileage(TrvExpTrans _expTrans, boolean _returnMileageAmount = false)
    {
        TrvKmSum            kmSum, kmSumUpdate;
        List                rateTiers = new List(Types::Record);
        TrvMileage          kmTotal;
        TrvCostTypeRates    rateTier;
        TrvCostRate         passengerRate;
        Map                 skipRecId;
        Map                 mileageAmt;
        boolean             useFiscalCalendarForMileageTotals , mileageCalculationRevisedEnabled;
        FiscalCalendarYear  fiscalCalendarYear;

        useFiscalCalendarForMileageTotals = TrvParameters::find().UseFiscalCalendarForMileageTotals;
        mileageCalculationRevisedEnabled = TrvExpenseHelper::isTrvExpMileageCalculationRevisedFlightEnabled();

        if(mileageCalculationRevisedEnabled)
        {
            str logMessage = strFmt("@Expense:TrvExpMileageFlightEnabled" , _expTrans.RecId);
            TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));
        }
        else
        {
            str logMessage = strFmt("@Expense:TrvExpMileageFlightDisabled" , _expTrans.RecId);
            TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));
        }

        if (useFiscalCalendarForMileageTotals)
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(), _expTrans.TransDate);
        }

        skipRecId = new Map(Types::Int64, Types::Int64);
        mileageAmt = new Map(Types::Real, Types::Real);

        kmSum.clear();

        if (fiscalCalendarYear)
        {
            select sum(Km) from kmSum
                where kmSum.Worker == _expTrans.CreatingWorker
                    && kmSum.FiscalCalendarYear == fiscalCalendarYear.RecId
                    && kmSum.VehicleType == _expTrans.VehicleType;
        }
        else
        {
            select sum(Km) from kmSum
                where kmSum.Worker == _expTrans.CreatingWorker
                    && kmSum.Year == year(_expTrans.TransDate)
                    && kmSum.VehicleType == _expTrans.VehicleType;
        }

        kmTotal = kmSum.Km + _expTrans.kmOwnCar;
        TrvMileage qtyToPost = _expTrans.kmOwnCar;
        TrvMileage qtyToAdd = qtyToPost;// when no rate tier is setup, or no 0 rate tier
        TrvMileage qtyPosted;

        while select rateTier
            order by Qty
            where rateTier.CostType == _expTrans.CostType
                && (rateTier.FromDate <= _expTrans.TransDate || !rateTier.FromDate)
                && (rateTier.ToDate >= _expTrans.TransDate || !rateTier.ToDate)
                && rateTier.Qty <= kmTotal
                && rateTier.VehicleType == _expTrans.VehicleType
                && rateTier.RateType == TrvMileageRateType::Mileage
        {
            rateTiers.addEnd(rateTier);
        }

        TrvCostTypeRates nextRateTier;

        rateTier.clear();
        ListEnumerator rateTiersEnumerator = rateTiers.getEnumerator();
        boolean updateTrans = true;
        boolean hasNext = rateTiersEnumerator && rateTiersEnumerator.moveNext();

        ttsbegin;
        while (hasNext && qtyToPost > 0)
        {
            rateTier = rateTiersEnumerator.current();

            kmSumUpdate.clear();

            if (fiscalCalendarYear)
            {
                select forupdate kmSumUpdate
                    where kmSumUpdate.Worker == _expTrans.CreatingWorker
                        && kmSumUpdate.FiscalCalendarYear == fiscalCalendarYear.RecId
                        && kmSumUpdate.Sats   == rateTier.CostRate
                        && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }
            else
            {
                select forupdate kmSumUpdate where kmSumUpdate.Worker == _expTrans.CreatingWorker
                            && kmSumUpdate.Year   == year(_expTrans.TransDate)
                            && kmSumUpdate.Sats   == rateTier.CostRate
                            && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }

            // is there another tier - we need to calculate the qty left in the current tier
            hasNext = rateTiersEnumerator.moveNext();
            if (hasNext)
            {
                nextRateTier = rateTiersEnumerator.current();
                // get the max qty for this tier from the next tier, calculate how many miles are left in the tier
                qtyToAdd = nextRateTier.Qty - rateTier.Qty - kmSumUpdate.Km;

                // if rate tier is fully consumed, move on to the next tier
                if (kmSumUpdate && qtyToAdd <= 0)
                {
                    continue;
                }
            }
            else
            {
                // no next tier -> everything over the current tier quantity goes in it
                if(mileageCalculationRevisedEnabled)
                {
                    qtyToAdd = qtyToPost;
                }
                else
                {
                    qtyToAdd = qtyToPost - rateTier.Qty - qtyPosted;
                }

                if (qtyToAdd <= 0)
                {
                    // 0 rate tier is missing and this does not fill the missing tier - do not update the current tier
                    qtyToAdd = qtyToPost;
                }
            }

            if (kmSumUpdate && !_returnMileageAmount)
            {
                // update the year totals for the worker for the tier
                kmSumUpdate.Km = kmSumUpdate.Km + qtyToAdd;
                kmSumUpdate.update();

                qtyPosted += kmSumUpdate.Km;
            }
            else
            {
                if (_returnMileageAmount)
                {
                    mileageAmt.insert(rateTier.CostRate, qtyToAdd * rateTier.CostRate);
                }
                else if (fiscalCalendarYear)
                {
                    kmSumUpdate.createKmSumFiscalYear(_expTrans.CreatingWorker, fiscalCalendarYear.RecId, rateTier.CostRate, qtyToAdd, _expTrans.VehicleType);
                }
                else
                {
                    kmSumUpdate.createKmSum(_expTrans.CreatingWorker, year(_expTrans.TransDate), rateTier.CostRate, qtyToAdd, _expTrans.VehicleType);
                    qtyPosted += qtyToAdd;
                }
            }

            passengerRate = _expTrans.kmOwnCar * _expTrans.NumberOfPassengers * TrvCostTypeRates::getPassengerRate(_expTrans.CostType, _expTrans.TransDate, _expTrans.VehicleType);

            if (!_returnMileageAmount)
            {
                if (updateTrans)
                {
                    // for the first rate tier updated, update the rate and quantity on the current record.
                    // Since we will be updating the expense amount, let's delete project commitments, so that
                    // the costs can be committed again during posting with new amounts.

                    str logMessage = strFmt("@Expense:MileageExpenseLineUpdated", rateTier.RecId , qtyToAdd);
                    TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));

                    ProjectCommitmentFacade::deleteProjectCommitments(_expTrans.SourceDocumentLine);
                    TrvMileageHelper::updateMileageExpense(_expTrans, qtyToAdd, rateTier.CostRate, passengerRate, #TemporaryVoucher);
                    updateTrans = false;
                }
                else
                {

                    str logMessage = strFmt("@Expense:MileageExpenseNewLine", rateTier.RecId , qtyToAdd);
                    TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));

                    // add a new expense line for the rate and qty
                    RefRecId newTrans = TrvMileageHelper::insertRateTierExpense(_expTrans, qtyToAdd, rateTier.CostRate, passengerRate);
                    skipRecId.insert(newTrans, newTrans);
                }
            }

            qtyToPost = qtyToPost - qtyToAdd;
        }

        if (qtyToPost > 0)
        {
            // no rate tier exists for the qty to post, default rate from parameters
            TrvCostRate rate = TrvParameters::find().KmPrice;
            if (fiscalCalendarYear)
            {
                select forupdate Km from kmSumUpdate
                        where kmSumUpdate.Worker == _expTrans.CreatingWorker
                            && kmSumUpdate.FiscalCalendarYear == fiscalCalendarYear.RecId
                            && kmSumUpdate.Sats == rate
                            && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }
            else
            {
                select forupdate Km from kmSumUpdate
                        where kmSumUpdate.Worker == _expTrans.CreatingWorker
                            && kmSumUpdate.Year == year(_expTrans.TransDate)
                            && kmSumUpdate.Sats == rate
                            && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }

            if (kmSumUpdate && !_returnMileageAmount)
            {
                kmSumUpdate.Km += qtyToPost;
                kmSumUpdate.update();
            }
            else
            {
                if (_returnMileageAmount)
                {
                    mileageAmt.insert(rate, qtyToPost * rate);
                }
                else if (fiscalCalendarYear)
                {
                    kmSumUpdate.createKmSumFiscalYear(_expTrans.CreatingWorker, fiscalCalendarYear.RecId, rate, qtyToPost, _expTrans.VehicleType);
                }
                else
                {
                    kmSumUpdate.createKmSum(_expTrans.CreatingWorker, year(_expTrans.TransDate), rate, qtyToPost, _expTrans.VehicleType);
                }
            }

            passengerRate = _expTrans.kmOwnCar * _expTrans.NumberOfPassengers * TrvCostTypeRates::getPassengerRate(_expTrans.CostType, _expTrans.TransDate, _expTrans.VehicleType);

            if (!_returnMileageAmount)
            {
                if (updateTrans)
                {
                    if(TrvExpenseHelper::isTrvPassengerRateTypeCalculationCorrectionFlightEnabled())
                    {
                        TrvMileageHelper::updateMileageExpense(_expTrans, qtyToPost, rate, passengerRate, #TemporaryVoucher);
                    }
                    else
                    {
                        TrvMileageHelper::updateMileageExpense(_expTrans, qtyToPost, rate, 0, #TemporaryVoucher);
                    }
                }
                else
                {
                    RefRecId newTrans = TrvExpenseHelper::isTrvPassengerRateTypeCalculationCorrectionFlightEnabled() ? TrvMileageHelper::insertRateTierExpense(_expTrans, qtyToPost, rate, passengerRate) : TrvMileageHelper::insertRateTierExpense(_expTrans, qtyToPost, rate, 0);
                    skipRecId.insert(newTrans, newTrans);
                }
            }
        }
        ttscommit;

        return _returnMileageAmount ? mileageAmt : skipRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMileageInfo</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates mileage amount based on used mileage and multiple mileage tieres.
    /// </summary>
    /// <param name = "_expTrans">
    /// The record buffer of the expense transaction.
    /// </param>
    /// <param name = "_returnMileageAmount">
    /// True if the caller wants this method to return container with mileage amount details, false if method need to return container with RecId's of transactions. Defaulted to false.
    /// </param>
    /// <returns>
    /// Container with mileage amount details or container with RecId's of transactions, based on "_returnMileageAmount" parameter.
    /// </returns>
    public static container calculateMileageInfo(TrvExpTrans _expTrans, boolean _returnMileageAmount = false)
    {
        TrvKmSum            kmSum, kmSumUpdate;
        List                rateTiers = new List(Types::Record);
        TrvMileage          kmTotal;
        TrvCostTypeRates    rateTier , prevTier;
        TrvCostRate         passengerRate;
        container           skipRecId, mileageAmt;
        Qty                 prevTierQty;
        boolean             useFiscalCalendarForMileageTotals , mileageCalculationRevisedEnabled;
        FiscalCalendarYear  fiscalCalendarYear;

        useFiscalCalendarForMileageTotals = TrvParameters::find().UseFiscalCalendarForMileageTotals;
        mileageCalculationRevisedEnabled = TrvExpenseHelper::isTrvExpMileageCalculationRevisedFlightEnabled();

        if(mileageCalculationRevisedEnabled)
        {
            str logMessage = strFmt("@Expense:TrvExpMileageFlightEnabled" , _expTrans.RecId);
            TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));
        }
        else
        {
            str logMessage = strFmt("@Expense:TrvExpMileageFlightDisabled" , _expTrans.RecId);
            TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));
        }

        if (useFiscalCalendarForMileageTotals)
        {
            fiscalCalendarYear = FiscalCalendarYear::findYearByCalendarDate(Ledger::fiscalCalendar(), _expTrans.TransDate);
        }

        kmSum.clear();
        
        if (fiscalCalendarYear)
        {
            select sum(Km) from kmSum
                where kmSum.Worker == _expTrans.CreatingWorker
                    && kmSum.FiscalCalendarYear == fiscalCalendarYear.RecId
                    && kmSum.VehicleType == _expTrans.VehicleType;
        }
        else
        {
            select sum(Km) from kmSum
                where kmSum.Worker == _expTrans.CreatingWorker
                    && kmSum.Year == year(_expTrans.TransDate)
                    && kmSum.VehicleType == _expTrans.VehicleType;
        }

        kmTotal = kmSum.Km + _expTrans.kmOwnCar;
        TrvMileage qtyToPost = _expTrans.kmOwnCar;
        TrvMileage qtyToAdd = qtyToPost;// when no rate tier is setup, or no 0 rate tier
        TrvMileage qtyPosted;

        while select rateTier
            order by Qty
            where rateTier.CostType == _expTrans.CostType
                && (rateTier.FromDate <= _expTrans.TransDate || !rateTier.FromDate)
                && (rateTier.ToDate >= _expTrans.TransDate || !rateTier.ToDate)
                && rateTier.VehicleType == _expTrans.VehicleType
                && rateTier.RateType == TrvMileageRateType::Mileage
        {
            rateTiers.addEnd(rateTier);
        }

        TrvCostTypeRates nextRateTier;

        prevTier.clear();
        rateTier.clear();
        ListEnumerator rateTiersEnumerator = rateTiers.getEnumerator();
        boolean updateTrans = true;
        boolean hasNext;

        if(!mileageCalculationRevisedEnabled)
            hasNext = rateTiersEnumerator && rateTiersEnumerator.moveNext();

        ttsbegin;
        while ((mileageCalculationRevisedEnabled ? rateTiersEnumerator.moveNext() : hasNext) && qtyToPost > 0)
        {
            if (kmSum.Km > TrvCostTypeRates::getTotalQty(_expTrans.CostType, _expTrans.VehicleType, _expTrans.TransDate))
            {
                break;
            }

            prevTier = rateTier;
            rateTier = rateTiersEnumerator.current();

            kmSumUpdate.clear();
            
            if (fiscalCalendarYear)
            {
                select forupdate kmSumUpdate
                    where kmSumUpdate.Worker == _expTrans.CreatingWorker
                        && kmSumUpdate.FiscalCalendarYear == fiscalCalendarYear.RecId
                        && kmSumUpdate.Sats   == rateTier.CostRate
                        && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }
            else
            {
                select forupdate kmSumUpdate
                    where kmSumUpdate.Worker == _expTrans.CreatingWorker
                        && kmSumUpdate.Year   == year(_expTrans.TransDate)
                        && kmSumUpdate.Sats   == rateTier.CostRate
                        && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }

            if (mileageCalculationRevisedEnabled)
            {

                TrvMileage slotCapacity = rateTier.Qty - (prevTier ? prevTier.Qty : 0);

                TrvMileage leftCapacity = slotCapacity - kmSumUpdate.Km;

                // Tier slot Fully Utilized. Move to next tier rate.
                if (leftCapacity <= 0)
                {
                    str logMessage = strFmt("@Expense:MileageSlotConsumed", rateTier.RecId , _expTrans.CreatingWorker , _expTrans.RecId);
                    TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));

                    continue;
                }

                qtyToAdd = min(qtyToPost , leftCapacity);
           
            }

            else
            {

                // is there another tier - we need to calculate the qty left in the current tier
                hasNext = rateTiersEnumerator.moveNext();
                if (hasNext)
                {
                    nextRateTier = rateTiersEnumerator.current();
                    prevTierQty = rateTier.Qty;

                    //If user hasn't consumed any miles from tier setup and in current execution miles are not yet considered for posting,
                    //then selected tier qty can considered for posting which will be validated in underlaying logic
                    if (!kmSumUpdate.Km && !qtyPosted)
                    {
                        qtyToAdd = rateTier.Qty;
                    }
                    else
                    {
                        // get the max qty for this tier from the next tier, calculate how many miles are left in the tier
                        qtyToAdd = nextRateTier.Qty - rateTier.Qty - kmSumUpdate.Km;

                        if (!kmSumUpdate.Km)
                        {
                            qtyToAdd = nextRateTier.Qty - rateTier.Qty - qtyPosted;
                        }
                    }

                    if ((qtyToAdd > qtyToPost) || (qtyToAdd <= 0))
                    {
                        qtyToAdd = rateTier.Qty - kmSumUpdate.Km;

                        if (qtyToAdd > qtyToPost)
                        {
                            qtyToAdd = qtyToPost;
                        }
                    }

                    // if rate tier is fully consumed, move on to the next tier
                    if (qtyToAdd <= 0)
                    {
                        continue;
                    }
                }
                else
                {
                    // if rate tier is fully consumed, move on to default rate
                    if (kmSumUpdate && kmSumUpdate.Km >= (rateTier.Qty - prevTierQty))
                    {
                        continue;
                    }

                    // no next tier -> everything over the current tier quantity goes in it
                    qtyToAdd = qtyToPost - rateTier.Qty - qtyPosted;

                    if ((qtyToPost + qtyPosted) > rateTier.Qty)
                    {
                        qtyToAdd = rateTier.Qty - kmSumUpdate.Km;

                        if (!kmSumUpdate.km)
                        {
                            qtyToAdd = rateTier.Qty - qtyPosted;
                        }
                    }

                    if (qtyToAdd <= 0)
                    {
                        // 0 rate tier is missing and this does not fill the missing tier - do not update the current tier
                        qtyToAdd = qtyToPost;
                    }
                }
            }

            if (kmSumUpdate && !_returnMileageAmount)
            {
                // update the year totals for the worker for the tier
                kmSumUpdate.Km = kmSumUpdate.Km + qtyToAdd;
                kmSumUpdate.update();

                qtyPosted += kmSumUpdate.Km;
            }
            else
            {
                if (_returnMileageAmount)
                {
                    mileageAmt += (qtyToAdd * rateTier.CostRate);
                }
                else if (fiscalCalendarYear)
                {
                    kmSumUpdate.createKmSumFiscalYear(_expTrans.CreatingWorker, fiscalCalendarYear.RecId, rateTier.CostRate, qtyToAdd, _expTrans.VehicleType);
                }
                else
                {
                    kmSumUpdate.createKmSum(_expTrans.CreatingWorker, year(_expTrans.TransDate), rateTier.CostRate, qtyToAdd, _expTrans.VehicleType);
                }
                qtyPosted += qtyToAdd;
            }

            passengerRate = _expTrans.kmOwnCar * _expTrans.NumberOfPassengers * TrvCostTypeRates::getPassengerRate(_expTrans.CostType, _expTrans.TransDate, _expTrans.VehicleType);

            if (!_returnMileageAmount)
            {
                if (updateTrans)
                {
                    // for the first rate tier updated, update the rate and quantity on the current record.
                    // Since we will be updating the expense amount, let's delete project commitments, so that
                    // the costs can be committed again during posting with new amounts.

                    str logMessage = strFmt("@Expense:MileageExpenseLineUpdated", rateTier.RecId , qtyToAdd);
                    TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));

                    ProjectCommitmentFacade::deleteProjectCommitments(_expTrans.SourceDocumentLine);
                    TrvMileageHelper::updateMileageExpense(_expTrans, qtyToAdd, rateTier.CostRate, passengerRate, #TemporaryVoucher);
                    updateTrans = false;

                    // If their is an update in the expense line, then we need make sure
                    // that the corresponding cash advance mapping is also updated accordingly, 
                    // if we are using the cash advance mapping feature.
                    if(!TrvExpenseHelper::isTrvRebalanceMileageCashAdavanceOnPostingFlightEnabled() && TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled())
                    {
                        _expTrans.updateExpCashAdvanceMap(true);
                    }
                }
                else
                {
                    // add a new expense line for the rate and qty

                    str logMessage = strFmt("@Expense:MileageExpenseNewLine", rateTier.RecId , qtyToAdd);
                    TrvInstrumentationHelper::logExpenseOperationsInformationWithPath(logMessage , classStr(TrvPost));

                    RefRecId newTrans = TrvMileageHelper::insertRateTierExpense(_expTrans, qtyToAdd, rateTier.CostRate, passengerRate);
                    skipRecId += newTrans;

                    // If a new Expense line is created and it has the cash advance mapping feature
                    // switched on then we need to map it with the cash advance mapping table.
                    // that is create a new entry in Cash Advance Mapping table.
                    if(!TrvExpenseHelper::isTrvRebalanceMileageCashAdavanceOnPostingFlightEnabled() && TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled())
                    {
                        TrvExpTrans::find(newTrans).updateExpCashAdvanceMap(false);
                    }
                }
            }

            qtyToPost = qtyToPost - qtyToAdd;
        }

        if (qtyToPost > 0)
        {
            // no rate tier exists for the qty to post, default rate from parameters
            TrvCostRate rate = TrvParameters::find().KmPrice;

            // No default mileage price has been setup.
            if (!rate)
            {
                warning("@Expense:NoDefaultMileageRateSetupWarning");
            }

            
            if (fiscalCalendarYear)
            {
                select forupdate Km from kmSumUpdate
                        where kmSumUpdate.Worker == _expTrans.CreatingWorker
                            && kmSumUpdate.FiscalCalendarYear == fiscalCalendarYear.RecId
                            && kmSumUpdate.Sats == rate
                            && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }
            else
            {
                select forupdate Km from kmSumUpdate
                        where kmSumUpdate.Worker == _expTrans.CreatingWorker
                            && kmSumUpdate.Year == year(_expTrans.TransDate)
                            && kmSumUpdate.Sats == rate
                            && kmSumUpdate.VehicleType == _expTrans.VehicleType;
            }

            if (kmSumUpdate && !_returnMileageAmount)
            {
                kmSumUpdate.Km += qtyToPost;
                kmSumUpdate.update();
            }
            else
            {
                if (_returnMileageAmount)
                {
                    mileageAmt += (qtyToPost * rate);
                }
                else if (fiscalCalendarYear)
                {
                    kmSumUpdate.createKmSumFiscalYear(_expTrans.CreatingWorker, fiscalCalendarYear.RecId, rate, qtyToPost, _expTrans.VehicleType);
                }
                else
                {
                    kmSumUpdate.createKmSum(_expTrans.CreatingWorker, year(_expTrans.TransDate), rate, qtyToPost, _expTrans.VehicleType);
                }
            }
            
            passengerRate = _expTrans.kmOwnCar * _expTrans.NumberOfPassengers * TrvCostTypeRates::getPassengerRate(_expTrans.CostType, _expTrans.TransDate, _expTrans.VehicleType);
            
            if (!_returnMileageAmount)
            {
                if (updateTrans)
                {
                    if(TrvExpenseHelper::isTrvPassengerRateTypeCalculationCorrectionFlightEnabled())
                    {
                        TrvMileageHelper::updateMileageExpense(_expTrans, qtyToPost, rate, passengerRate, #TemporaryVoucher); 
                    }
                    else
                    {
                        TrvMileageHelper::updateMileageExpense(_expTrans, qtyToPost, rate, 0, #TemporaryVoucher);
                    }
                    if(!TrvExpenseHelper::isTrvRebalanceMileageCashAdavanceOnPostingFlightEnabled() && TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled())
                    {
                        _expTrans.updateExpCashAdvanceMap(true);
                    }
                }
                else
                {
                    RefRecId newTrans = TrvExpenseHelper::isTrvPassengerRateTypeCalculationCorrectionFlightEnabled() ? TrvMileageHelper::insertRateTierExpense(_expTrans, qtyToPost, rate, passengerRate) : TrvMileageHelper::insertRateTierExpense(_expTrans, qtyToPost, rate, 0);
                    skipRecId += newTrans;
                    if(!TrvExpenseHelper::isTrvRebalanceMileageCashAdavanceOnPostingFlightEnabled() && TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled())
                    {
                        TrvExpTrans::find(newTrans).updateExpCashAdvanceMap(false);
                    }
                }
            }
        }
        ttscommit;

        return _returnMileageAmount ? mileageAmt : skipRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateAllMileageLines</Name>
				<Source><![CDATA[
    public static void updateAllMileageLines(TableId _tableId, TrvExpNumber _trvExpNumber = '', RefRecId _recId = 0)
    {
        if (TrvMileageCalculationFeature::isEnabled())
        {
            TrvInstrumentationHelper::logExpenseOperationsInformation("@Expense:MileageContainerTelemetry", classStr(TrvPost));

            //If multiple tier exits with same mileage rate, then calculation should be based on container.
            TrvPost::mileageLinesContainer(_tableId, _trvExpNumber, _recId);
        }
        else
        {
            TrvInstrumentationHelper::logExpenseOperationsInformation("@Expense:MileageMapTelemetry", classStr(TrvPost));

            TrvPost::mileageLinesMap(_tableId, _trvExpNumber, _recId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>mileageLinesMap</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mileage amount calculation and expense line split check will be called based on Map returning logic.
    /// </summary>
    private static void mileageLinesMap(TableId _tableId, TrvExpNumber _trvExpNumber = '', RefRecId _recId = 0)
    {
        TrvExpTrans expTrans;
        Map skipRecIds;

        void postMileageLines(TrvExpTrans _expTrans)
        {
            skipRecIds = TrvPost::calculateAllMileage(_expTrans);
        }
    
        skipRecIds = new Map(Types::Int64, Types::Int64);

        ttsbegin;

        switch (_tableId)
        {
            case tableNum(TrvExpTable):
                while select forupdate expTrans where expTrans.ExpNumber == _trvExpNumber
                                                    && expTrans.ExpType == TrvExpType::Transport
                                                    && expTrans.LineType != TrvExpLineType::ItemizedHeader
                                                    && expTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                                                    && expTrans.LegalEntity == CompanyInfo::current()
                {
                    if (skipRecIds.exists(expTrans.RecId))
                    {
                        continue;
                    }
                    else
                    {
                        postMileageLines(expTrans);
                    }
                }
                if (skipRecIds.elements())
                {
                    // if mileage new lines were added, revalidate the expense report for the added lines
                    TrvPolicyEvalEngine::evaluateViolationsForHdr(expTrans.TrvExpTable, SysPolicyTypeEnum::TrvExpensePolicy);
                }
                break;

            case tableNum(TrvExpTrans):
                select forupdate expTrans where expTrans.RecId == _recId;
                postMileageLines(expTrans);

                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mileageLinesContainer</Name>
				<Source><![CDATA[
    /// <summary>
    /// Mileage amount calculation and expense line split check will be called based on Container returning logic.
    /// </summary>
    private static void mileageLinesContainer(TableId _tableId, TrvExpNumber _trvExpNumber = '', RefRecId _recId = 0)
    {
        TrvExpTrans expTrans;
        container skipRecIds;

        void postMileageLines(TrvExpTrans _expTrans)
        {
            skipRecIds = TrvPost::calculateMileageInfo(_expTrans);
        }

        ttsbegin;

        switch (_tableId)
        {
            case tableNum(TrvExpTable):
                while select forupdate expTrans where expTrans.ExpNumber == _trvExpNumber
                                                    && expTrans.ExpType == TrvExpType::Transport
                                                    && expTrans.LineType != TrvExpLineType::ItemizedHeader
                                                    && expTrans.SplitLineType != TrvExpSplitLineType::SplitHeader
                                                    && expTrans.LegalEntity == CompanyInfo::current()
                                                    && expTrans.ParentRecId == 0
                {
                    if (conFind(skipRecIds, expTrans.RecId))
                    {
                        continue;
                    }
                    else
                    {
                        postMileageLines(expTrans);
                    }
                }

                if (skipRecIds)
                {
                    // if mileage new lines were added, revalidate the expense report for the added lines
                    TrvPolicyEvalEngine::evaluateViolationsForHdr(expTrans.TrvExpTable, SysPolicyTypeEnum::TrvExpensePolicy);
                }
                break;

            case tableNum(TrvExpTrans):
                select forupdate expTrans where expTrans.RecId == _recId;
                postMileageLines(expTrans);

                break;
        }

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExpenseReportHeader</Name>
				<Source><![CDATA[
    private static TrvExpTable postExpenseReportHeader(Common _record, boolean _calledFromUI)
    {
        TrvExpTable trvExpTable  = _record;

        if (_calledFromUI)
        {
            // if call from UI then we need to retrive the record because the form data source may
            // have not retrive all of the fields.
            trvExpTable = TrvExpTable::find(trvExpTable.ExpNumber, true);
        }

        str logMessage = strFmt('Posting Expense Report %1', trvExpTable.RecId);
        TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(Trvpost));
        
        if(TrvExpenseHelper::isTrvRebalanceMileageCashAdavanceOnPostingFlightEnabled())
        {
            if (TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled() && 
                trvExpTable.existsAnyExpenseLineForGivenOwner(TrvCostOwner::Employee))
            {
                TrvExpCashAdvanceMappingHelper::createTrvAccountingDistribution(trvExpTable.RecId, tableNum(TrvExpTable));
            }
            else
            {
                TrvSubmitExpenseReportToWorkflow::updateTrvAccDisctributions(trvExpTable);
            }
        }     
        TrvPostExpenseHeader trvPostExpenseHeader = new TrvPostExpenseHeader(trvExpTable);
        if (trvPostExpenseHeader.post())
        {
            TrvExpTrans trvExpTrans;
            trvExpTrans.skipDataMethods(true);
            update_recordset trvExpTrans setting PostingErrors = '' where trvExpTrans.TrvExpTable == trvExpTable.RecId;
        }
        
        return trvExpTable;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postExpenseLine</Name>
				<Source><![CDATA[
    private static TrvExpTrans postExpenseLine(Common _record, boolean _calledFromUI)
    {
        TrvExpTrans trvExpTrans  = _record;
        TrvPostExpenseLine trvPostExpenseLine = new TrvPostExpenseLine(trvExpTrans);
        
        if (TrvExpCashAdvanceMappingHelper::isCashAdvanceMappingFeatureEnabled() &&
            trvExpTrans.CostOwner == TrvCostOwner::Employee )
        {
            TrvExpCashAdvanceMappingHelper::createTrvAccountingDistribution(trvExpTrans.RecId, tableNum(TrvExpTrans));
        }
        else
        {
            TrvSubmitExpenseReportToWorkflow::updateTrvAccDisctributions(TrvExpTable::find(trvExpTrans.ExpNumber));
        }

        str logMessage = strFmt("Posting Expense line %1", trvExpTrans.RecId);
        TrvInstrumentationHelper::logExpenseOperationsInformation(logMessage, classStr(TrvWorkflowUtilities));

        // Populate mapping records for cash advances consumed by this expense report.
        TrvExpCashAdvanceMappingHelper::populateMappingForExpenseReport(trvExpTrans.TrvExpTable);
                
        if (trvPostExpenseLine.post())
        {
            ttsbegin;
            trvExpTrans.reread();
            trvExpTrans.PostingErrors = '';
            trvExpTrans.doUpdate();

            // If posting in List Page or TrvExpTable form, check if all lines have been posted, then set the header
            // status to Posted as well
            if (_calledFromUI)
            {
                TrvWorkflowUtilities::setDocumentToPosted(trvExpTrans.TrvExpTable);
            }
            ttscommit;
        }
        return trvExpTrans;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>