<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>InventLedgerConflictInventory</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///    The <c>InventLedgerConflictInventory</c> class executes the extraction and verification of the
///    inventory transactions data, and calculates the balance for inventory.
/// </summary>
#ISOCountryRegionCodes
public class InventLedgerConflictInventory implements CostILedgerConflict, CostIAsyncRunnable
{
    private const UnionAllBranchId      unionAllBranchIdForPhysicalAndFinancialSettlement = 5;
    InventLedgerConflictContract        inventLedgerConflictContract;
    DimensionAttributeValue             dimAttrValueMainAccount;
    CostReconciliationMethodStrategy    reconciliationMethodStrategy;

    private MainAccountNum mainAccount, offsetAccount;
    private Map itemIdToItemTypeCache = new Map(Types::String, Types::Enum);
    private Map itemModelGroupCache = new Map(Types::String, Types::Record);
    private Map ledgerDimensionToMainAccountIdCache = new Map(Types::Int64, Types::String);

    private InventTransOrigin   inventTransOrigin;
    private InventTransPosting  inventTransPostingSearchCriteria;
    private VendParameters      vendParameter = VendParameters::find();
    private SalesParameters     salesParameter = SalesParameters::find();
    private InventTransferLine  inventTransferLine;
    private InventTransferTable inventTransferTable;
    private boolean             isReferenceCategoryTransferOrJournal;

    private readOnly boolean isCountryRegion_IN = SysCountryRegionCode::isLegalEntityInCountryRegion([#isoIN]);

    #define.CurrentVersion(1)

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>accountRuleItem</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies that a conflict has occurred on the account and the offset account for the transaction. If
    ///    a conflict occurred, a conflict message is added to the specified list of conflicts.
    /// </summary>
    /// <param name="_conflicts">
    ///    The list of conflicts to which to add the conflict message.
    /// </param>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <remarks>
    ///    This rule can only be applied for <c>Item</c> item type.
    /// </remarks>
    protected void accountRuleItem(
        List                        _conflicts,
        InventValueTransUnionAll    _inventValueTransUnionAll)
    {
        if (_inventValueTransUnionAll.InventTransPostingType != InventTransPostingType::PhysicalRevenue
            && _inventValueTransUnionAll.IsPosted)
        {
            boolean isAccountInventory = this.isInventoryAccount(this.getMainAccountIdFromLedgerDimension(_inventValueTransUnionAll.LedgerDimension));
            boolean isAccountOffsetInventory = this.isInventoryAccount(this.getMainAccountIdFromLedgerDimension(_inventValueTransUnionAll.LedgerDimensionOffset));

            if (!isAccountInventory && isAccountOffsetInventory)
            {
                // For this specific conflict, the amount for the transaction must be doubled or zero.
                // If the postingtype is blank and financial, the amount should be 0; otherwise doubled
                if (this.postingRuleBlankPostingTypeFinancial(_inventValueTransUnionAll))
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317349", _inventValueTransUnionAll.PostingType), 0));
                }
                else
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317349", _inventValueTransUnionAll.PostingType), 2));
                }
                _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317350", _inventValueTransUnionAll.PostingTypeOffset)));
            }
            if (!isAccountInventory && !isAccountOffsetInventory)
            {
                // <GIN>
                if (!this.isStockTransferInventory_IN(_inventValueTransUnionAll))
                {
                    // </GIN>
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317349", _inventValueTransUnionAll.PostingType)));
                    // <GIN>
                }
                // </GIN>
            }
            if (isAccountInventory && isAccountOffsetInventory)
            {
                // A specific posting for standard cost items are not considered to be an error
                // The posting is not an error if postingtype=PurchReceipt and postiungtypeoffset=PurchPckSlp
                if (this.isPurchLedgerPostingType(_inventValueTransUnionAll.PostingType, _inventValueTransUnionAll.PostingTypeOffset))
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317350", _inventValueTransUnionAll.PostingTypeOffset)));
                }
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isPurchLedgerPostingType</Name>
				<Source><![CDATA[
    protected boolean isPurchLedgerPostingType(LedgerPostingType _ledgerPostingType, LedgerPostingType _ledgerPostingTypeOffset)
    {
        return _ledgerPostingType != LedgerPostingType::PurchReceipt
            || _ledgerPostingTypeOffset != LedgerPostingType::PurchPckSlp;
    }

]]></Source>
			</Method>
			<Method>
				<Name>accountRuleService</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies that a conflict occurred on the account and the offset account for the transaction. If a
    ///    conflict occurred, a conflict message is added to the specified list of conflicts.
    /// </summary>
    /// <param name="_conflicts">
    ///    The list of conflicts to which to add the conflict message.
    /// </param>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <remarks>
    ///    This rule can only be applied for the <c>Item</c> item type.
    /// </remarks>
    protected void accountRuleService(
        List                        _conflicts,
        InventValueTransUnionAll    _inventValueTransUnionAll)
    {
        if (_inventValueTransUnionAll.InventTransPostingType != InventTransPostingType::PhysicalRevenue &&
            _inventValueTransUnionAll.IsPosted)
        {
            boolean isAccountInventory = this.isInventoryAccount(this.getMainAccountIdFromLedgerDimension(_inventValueTransUnionAll.LedgerDimension));
            boolean isAccountOffsetInventory = this.isInventoryAccount(this.getMainAccountIdFromLedgerDimension(_inventValueTransUnionAll.LedgerDimensionOffset));

            if (!isAccountInventory && isAccountOffsetInventory)
            {
                _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317348", _inventValueTransUnionAll.PostingTypeOffset), -1));
            }
            if (isAccountInventory && !isAccountOffsetInventory)
            {
                _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317348", _inventValueTransUnionAll.PostingType), -1));
            }
            if (isAccountInventory && isAccountOffsetInventory)
            {
                _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317348", _inventValueTransUnionAll.PostingType), -1));
                _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317348", _inventValueTransUnionAll.PostingTypeOffset), -1));
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConflictMessage</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a conflict message for the corresponding <c>InventTransPostingType</c>.
    /// </summary>
    /// <param name = "_conflicts">A <c>List</c> with conflict details.</param>
    /// <param name = "_inventValueTransUnionAll">An <c>InventValueTransUnionAll</c> object.</param>
    /// <param name = "_itemGroupId">An <c>InventModelGroupId</c> value.</param>
    [Replaceable]
    protected void addConflictMessage(
        List                        _conflicts,
        InventValueTransUnionAll    _inventValueTransUnionAll,
        InventModelGroupId          _itemGroupId)
    {
        if (_inventValueTransUnionAll.InventTransPostingType == InventTransPostingType::Financial)
        {
            this.addConflictMessageFinancial(_conflicts, _inventValueTransUnionAll, _itemGroupId);
        }
        else
        {
            this.addConflictMessagePhysical(_conflicts, _inventValueTransUnionAll, _itemGroupId);
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConflictMessageFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a conflict message to a specified list of conflicts.
    /// </summary>
    /// <param name="_conflicts">
    ///    The list of conflicts to add the conflict message to.
    /// </param>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <param name="_itemGroupId">
    ///    The item group for the conflicting transaction.
    /// </param>
    /// <remarks>
    ///    This method is called when a conflict is detected on a financial transaction. This method does not
    ///    verify that a conflict occurred. This verification must be done before this method is called.
    /// </remarks>
    protected void addConflictMessageFinancial(
        List                        _conflicts,
        InventValueTransUnionAll    _inventValueTransUnionAll,
        InventModelGroupId          _itemGroupId)
    {
        NoYes postOnhandFinancial = this.getItemModelGroup(_itemGroupId).PostOnhandFinancial;

        if (postOnhandFinancial == NoYes::No ||
            _inventValueTransUnionAll.PostingType == LedgerPostingType::None)
        {
            _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317352", _itemGroupId)));
        }
        else
        {
            _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317351", _itemGroupId)));
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>addConflictMessagePhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Adds a conflict message to the specified list of conflicts if a conflict has been detected on a
    ///    physical transaction.
    /// </summary>
    /// <param name="_conflicts">
    ///    The list of conflicts to which to add the conflict messages.
    /// </param>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer that has inventory transaction data.
    /// </param>
    /// <param name="_modelGroupId">
    ///    The item group for the conflicting transaction.
    /// </param>
    /// <remarks>
    ///    This method does not indicate that a conflict has occurred. This must be checked before the method
    ///    is called.
    /// </remarks>
    protected void addConflictMessagePhysical(
        List                        _conflicts,
        InventValueTransUnionAll    _inventValueTransUnionAll,
        InventModelGroupId          _modelGroupId)
    {
        // Apply site name to message if prodparameters are site specific
        String255 applySiteName(
            ProdParametersDim   _prodParametersDim,
            String255           _siteMessage,
            String255           _noSiteMessage)
        {
            String255   retVal;

            if (ProdParameters::find().ProdParamInventDimLookup == ProdParamInventDimLookup::Company)
            {
                retVal = _noSiteMessage;
            }
            else
            {
                retVal = strFmt(_siteMessage, _prodParametersDim.siteName());
            }

            return retVal;
        }

        NoYes postOnHandPhysical = this.getItemModelGroup(_modelGroupId).PostOnhandPhysical;

        // Always add this message
        if (postOnHandPhysical == NoYes::No)
        {
            _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317333", _modelGroupId)));
        }
        else
        {
            _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(strFmt("@SYS317332", _modelGroupId)));
        }

        switch (_inventValueTransUnionAll.ReferenceCategory)
        {
            case InventTransType::Purch:
                if (vendParameter.PostPackingSlip == NoYes::No)
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm("@SYS317329"));
                }
                else
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm("@SYS317353"));
                }
                break;
            case InventTransType::Sales:
                if (salesParameter.PostPackingSlip == NoYes::No)
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm("@SYS317331"));
                }
                else
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm("@SYS317330"));
                }
                break;
            case InventTransType::ProdLine:
                ProdParametersDim prodParametersDim = ProdParametersDim::find(_inventValueTransUnionAll.InventDimId);
                if (prodParametersDim.PostPickList == NoYes::No)
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(applySiteName(prodParametersDim, "@SYS317336", "@SYS317337")));
                }
                else
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(applySiteName(prodParametersDim, "@SYS317334", "@SYS317335")));
                }
                break;
            case InventTransType::Production:
                prodParametersDim = ProdParametersDim::find(_inventValueTransUnionAll.InventDimId);
                if (prodParametersDim.PostReportedFinished == NoYes::No)
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(applySiteName(prodParametersDim, "@SYS317341", "@SYS317342")));
                }
                else
                {
                    _conflicts.addEnd(InventLedgerConflictMessage::newFromParm(applySiteName(prodParametersDim, "@SYS317338", "@SYS317340")));
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildQuery</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Builds a query that finds inventory transactions in a given period.
    /// </summary>
    /// <returns>
    ///    A query that finds inventory transactions.
    /// </returns>
    protected Query buildQuery()
    {
        Query                   query = new Query();

        QueryBuildDataSource qbdsInventValueTransUnionAll = query.addDataSource(tableNum(InventValueTransUnionAll));
        qbdsInventValueTransUnionAll.addRange(fieldNum(InventValueTransUnionAll, TransDate)).value(SysQuery::range(
            inventLedgerConflictContract.parmInventCostDateCodeContract().parmFromDate(),
            inventLedgerConflictContract.parmInventCostDateCodeContract().parmToDate()));

        qbdsInventValueTransUnionAll.addSelectionField(fieldNum(InventValueTransUnionAll, Amount), SelectionField::Sum);

        qbdsInventValueTransUnionAll.orderMode(OrderMode::GroupBy);
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, TransDate));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, InventTransId));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, ItemId));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, IsPosted));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, PostingType));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, PostingTypeOffset));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, ReferenceCategory));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, InventTransPostingType));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, LedgerDimension));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, LedgerDimensionOffset));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, InventDimId));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, Voucher));
        qbdsInventValueTransUnionAll.addGroupByField(fieldNum(InventValueTransUnionAll, UnionAllBranchId));

        qbdsInventValueTransUnionAll.addRange(fieldNum(InventValueTransUnionAll, Amount)).value(
            strFmt('( (%1 != %2) || (%3 != %4) )',
                   fieldStr(InventValueTransUnionAll, Amount), 0,
                   fieldStr(InventValueTransUnionAll, IsPosted), any2int(NoYes::No)));
        
        if (inventLedgerConflictContract.parmExcludePhysicalToLedger() == NoYes::Yes)
        {
            // Transactions that are physical and not posted should be excluded
            // This is achieved by adding this range:
            // InventTransPostingType != InventTransPostingType::Physical or IsPosted != NoYes::No
            qbdsInventValueTransUnionAll.addRange(fieldNum(InventValueTransUnionAll, InventTransPostingType)).value(
                strFmt('( (%1 != %2) || (%3 != %4) )',
                fieldStr(InventValueTransUnionAll, InventTransPostingType),
                any2int(InventTransPostingType::Physical),
                fieldStr(InventValueTransUnionAll, IsPosted),
                any2int(NoYes::No)));
        }

        QueryBuildDataSource qbdsInventTable = qbdsInventValueTransUnionAll.addDataSource(tableNum(InventTable));
        qbdsInventTable.addGroupByField(fieldNum(InventTable, ItemType));
        qbdsInventTable.addLink(fieldNum(InventValueTransUnionAll, ItemId), fieldNum(InventTable, ItemId));
        qbdsInventTable.joinMode(JoinMode::InnerJoin);
        qbdsInventTable.fetchMode(QueryFetchMode::One2One);

        QueryBuildDataSource qbdsInventModelGroupItem = qbdsInventTable.addDataSource(tableNum(InventModelGroupItem));
        qbdsInventModelGroupItem.joinMode(JoinMode::OuterJoin);
        qbdsInventModelGroupItem.fetchMode(QueryFetchMode::One2One);
        qbdsInventModelGroupItem.relations(true);
        qbdsInventModelGroupItem.addGroupByField(fieldNum(InventModelGroupItem, ModelGroupId));

        // Filter on dimension attribute if selected in the dialog
        if (inventLedgerConflictContract.parmDimensionAttribute())
        {
            QueryBuildDataSource qbdsDimAttrValueComb = qbdsInventValueTransUnionAll.addDataSource(tableNum(DimensionAttributeValueCombination));
            qbdsDimAttrValueComb.addLink(fieldNum(InventValueTransUnionAll, LedgerDimension), fieldNum(DimensionAttributeValueCombination, RecId));
            if (inventLedgerConflictContract.parmIncludeBlankDimensions())
            {
                qbdsDimAttrValueComb.joinMode(JoinMode::OuterJoin);
            }
            else
            {
                qbdsDimAttrValueComb.joinMode(JoinMode::InnerJoin);
            }
            qbdsDimAttrValueComb.fetchMode(QueryFetchMode::One2One);
            qbdsDimAttrValueComb.addGroupByField(fieldNum(DimensionAttributeValueCombination, TableId)); // Trick to avoid selection of fields
            QueryBuildDataSource qbdsDimAttrLevelValueView = qbdsDimAttrValueComb.addDataSource(tableNum(DimensionAttributeLevelValueView));
            qbdsDimAttrLevelValueView.addLink(fieldNum(DimensionAttributeValueCombination, RecId), fieldNum(DimensionAttributeLevelValueView, ValueCombinationRecId));
            qbdsDimAttrLevelValueView.fetchMode(QueryFetchMode::One2One);
            qbdsDimAttrLevelValueView.addRange(fieldNum(DimensionAttributeLevelValueView, DimensionAttribute)).value(queryValue(inventLedgerConflictContract.parmDimensionAttribute()));
            if (inventLedgerConflictContract.parmIncludeBlankDimensions())
            {
                qbdsDimAttrLevelValueView.joinMode(JoinMode::NoExistsJoin);
            }
            else
            {
                qbdsDimAttrLevelValueView.joinMode(JoinMode::InnerJoin);
                qbdsDimAttrLevelValueView.addRange(fieldNum(DimensionAttributeLevelValueView, EntityInstance)).value(queryValue(inventLedgerConflictContract.parmEntityInstance()));
            }
            qbdsDimAttrValueComb.addGroupByField(fieldNum(DimensionAttributeLevelValueView, TableId)); // Trick to avoid selection of fields
        }

        return query;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkForConflicts</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Checks for conflicts in inventory transactions. The inventory transactions are stored in the
    ///    <c>InventValueTransUnionAll</c> view buffer.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <param name="_itemType">
    ///    The item type for the transaction.
    /// </param>
    /// <param name="_itemGroupId">
    ///    The item group for the transaction.
    /// </param>
    /// <returns>
    ///    A list of conflict messages if any conflicts were detected.
    /// </returns>
    protected List checkForConflicts(
        InventValueTransUnionAll    _inventValueTransUnionAll,
        ItemType                    _itemType,
        ItemGroupId                 _itemGroupId)
    {
        List    retVal = new List(Types::Class);
        boolean conflict;

        // Apply posting rules
        void postingConflict()
        {
            if (_itemType == ItemType::Item)
            {
                conflict = this.postingRuleNotTransferOrJournalFinancial(_inventValueTransUnionAll) ||
                           this.postingRuleNotTransferOrJournalPhysical(_inventValueTransUnionAll) ||
                           this.postingRuleTransferOrJournalFinancial(_inventValueTransUnionAll) ||
                           this.postingRuleTransferOrJournalPhysical(_inventValueTransUnionAll) ||
                           this.postingRuleBlankPostingTypeFinancial(_inventValueTransUnionAll);

                if (conflict)
                {
                    this.addConflictMessage(retVal, _inventValueTransUnionAll, _itemGroupId);
                }
            }
        }

        // Apply main account rules
        void accountConflict()
        {
            if (_itemType == ItemType::Item)
            {
                this.accountRuleItem(retVal, _inventValueTransUnionAll);
            }
            if (_itemType == ItemType::Service)
            {
                this.accountRuleService(retVal, _inventValueTransUnionAll);
            }
        }

        isReferenceCategoryTransferOrJournal = this.isReferenceCategoryTransferOrJournal(_inventValueTransUnionAll);

        // Apply rules
        accountConflict();
        postingConflict();

        // All transactions with blank dimensions should have a conflict message
        if (inventLedgerConflictContract.parmIncludeBlankDimensions())
        {
            retVal.addEnd(InventLedgerConflictMessage::newFromParm("@SYS332489"));
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isInventoryAccount</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a specified account number is an inventory account.
    /// </summary>
    /// <param name="_mainAccountId">
    ///    The account number to check.
    /// </param>
    /// <returns>
    ///    true if the account number is an inventory account; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The test is made by a lookup in the <c>LedgerTableInterval</c> table. This table is set
    ///    "cacheTable=EntireTable", therefore, no data is cached locally in this class.
    /// </remarks>
    protected boolean isInventoryAccount(MainAccountNum _mainAccountId)
    {
        if (!reconciliationMethodStrategy)
        {
            reconciliationMethodStrategy = CostReconciliationMethodStrategy::newFromParameters();
        }
        return reconciliationMethodStrategy.isInventoryAccount(_mainAccountId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isReferenceCategoryTransferOrJournal</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the reference category of the inventory transaction is a transfer or a journal
    ///    type.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <returns>
    ///    true if the inventory transaction is a transfer or a journal type; otherwise false.
    /// </returns>
    protected boolean isReferenceCategoryTransferOrJournal(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        inventTransOrigin.ReferenceCategory = _inventValueTransUnionAll.ReferenceCategory;
        return inventTransOrigin.isTransfer() ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::InventTransaction ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::InventLossProfit ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::BOMLine ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::BOMMain ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::WMSOrder ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::Project ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::InventCounting ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::WMSTransport ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::Asset ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::TransferOrderScrap ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::SalesQuotation ||
               _inventValueTransUnionAll.ReferenceCategory == InventTransType::QualityOrder;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettlement</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a <c>InventValueTransUnionAll</c> table originates from a settlement.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The <c>InventValueReportLine</c> table to check.
    /// </param>
    /// <returns>
    ///    true if the <c>InventValueTransUnionAll</c> table originates from a settlement; otherwise false.
    /// </returns>
    protected boolean isSettlement(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        // Settlements comes from the view InventValuePhysicalAndFinancialSettlement
        return (_inventValueTransUnionAll.UnionAllBranchId == unionAllBranchIdForPhysicalAndFinancialSettlement);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isStockTransferInventory_IN</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>InventValueTransUnionAll</c> is from a stock transfer with specific posting type.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <returns>
    ///    true if the <c>InventValueTransUnionAll</c> is from a stock transfer with specific posting type; otherwise, false.
    /// </returns>
    protected boolean isStockTransferInventory_IN(InventValueTransUnionAll   _inventValueTransUnionAll)
    {
        if (!isCountryRegion_IN)
        {
            return false;
        }

        boolean              retVal = false;

        select firstOnly RecId from inventTransferTable
            where inventTransferTable.TransferType_IN == TransferType_IN::StockTransfer
            exists join inventTransferLine
            where inventTransferLine.TransferId == inventTransferTable.TransferId
                && inventTransferLine.InventTransIdScrap == _inventValueTransUnionAll.InventTransId;
        if (inventTransferTable.RecId)
        {
            retVal = true;
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>pack</Name>
				<Source><![CDATA[
    public container  pack()
    {
        return [#CurrentVersion, inventLedgerConflictContract.pack()];
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventLedgerConflictContract</Name>
				<Source><![CDATA[
    public InventLedgerConflictContract parmInventLedgerConflictContract(InventLedgerConflictContract _inventLedgerConflictContract = inventLedgerConflictContract)
    {
        inventLedgerConflictContract = _inventLedgerConflictContract;

        return inventLedgerConflictContract;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingRuleBlankPostingTypeFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    /// Indicates whether there is a conflict with blank posting type on a financial transaction.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    /// A view buffer that has inventory transaction data.
    /// </param>
    /// <returns>
    /// true if there is a conflict; otherwise, false.
    /// </returns>
    protected boolean postingRuleBlankPostingTypeFinancial(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        boolean             retVal = false;

        if (_inventValueTransUnionAll.InventTransPostingType == InventTransPostingType::Financial &&
            _inventValueTransUnionAll.PostingType == LedgerPostingType::None)
        {
            if (isReferenceCategoryTransferOrJournal &&
                this.isSettlement(_inventValueTransUnionAll))
            {
                retVal = this.isSettlementPosted(_inventValueTransUnionAll);
            }
            else
            {
                retVal = true;
            }
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingRuleNotTransferOrJournalFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a conflict has occurred on a non-transfer or non-journal financial transaction.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    A view buffer that has inventory transaction data.
    /// </param>
    /// <returns>
    ///    true if a conflict has been detected; otherwise, false.
    /// </returns>
    protected boolean postingRuleNotTransferOrJournalFinancial(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        return !isReferenceCategoryTransferOrJournal &&
               _inventValueTransUnionAll.InventTransPostingType == InventTransPostingType::Financial &&
               !_inventValueTransUnionAll.IsPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingRuleNotTransferOrJournalPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Verifies whether a conflict has occurred on a non-transfer or non-journal physical transaction.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    A view buffer that has inventory transaction data.
    /// </param>
    /// <returns>
    ///    true if a conflict has been detected; otherwise, false.
    /// </returns>
    protected boolean postingRuleNotTransferOrJournalPhysical(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        return !isReferenceCategoryTransferOrJournal &&
               _inventValueTransUnionAll.InventTransPostingType != InventTransPostingType::Financial &&
               !_inventValueTransUnionAll.IsPosted;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingRuleTransferOrJournalFinancial</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a conflict has occurred on a transfer financial transaction or a journal
    ///    financial transaction.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <returns>
    ///    true if a conflict has been detected; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    To determine whether this is a conflict, the posted flags on both the <c>InventTransPosting</c>
    ///    table and the <c>InventSettlement</c> table have to be evaluated. The posted flag on the
    ///    <c>InventTransPosting</c> table is not present in the inventory transaction data view and cannot be
    ///    added. Therefore, to do this check, the <c>InventTransPosting</c> table data is found by using
    ///    lookups in the <c>InventSettlement</c> table and <c>InventTrans</c> table.
    /// </remarks>
    protected boolean postingRuleTransferOrJournalFinancial(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        boolean             retVal = false;

        if (isReferenceCategoryTransferOrJournal &&
            this.isSettlement(_inventValueTransUnionAll) &&
            _inventValueTransUnionAll.InventTransPostingType == InventTransPostingType::Financial &&
            !_inventValueTransUnionAll.IsPosted)
        {
            retVal = this.isSettlementPosted(_inventValueTransUnionAll);
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>postingRuleTransferOrJournalPhysical</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether a conflict has occurred on a transfer physical transaction or a journal physical
    ///    transaction.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer that has inventory transaction data.
    /// </param>
    /// <returns>
    ///    true if a conflict has been detected; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    To determine whether this is a conflict, the posted flags on both the <c>InventTransPosting</c>
    ///    table and the <c>InventSettlement</c> table have to be evaluated. The posted flag on the
    ///    <c>InventTransPosting</c> table is not present in the inventory transaction data view and cannot be
    ///    added. Therefore, to do this check, the <c>InventTransPosting</c> table data is found by using
    ///    lookups in the <c>InventSettlement</c> table and <c>InventTrans</c> table.
    /// </remarks>
    protected boolean postingRuleTransferOrJournalPhysical(InventValueTransUnionAll _inventValueTransUnionAll)
    {
        boolean             retVal = false;

        if (isReferenceCategoryTransferOrJournal &&
            this.isSettlement(_inventValueTransUnionAll) &&
            _inventValueTransUnionAll.InventTransPostingType != InventTransPostingType::Financial &&
            !_inventValueTransUnionAll.IsPosted)
        {
            retVal = this.isSettlementPosted(_inventValueTransUnionAll, false);
        }

        return retVal;
    }

]]></Source>
			</Method>
			<Method>
				<Name>printAsterisk</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether an asterisk must be printed instead of an amount.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer with inventory transaction data.
    /// </param>
    /// <param name="_noOfConflicts">
    ///    The number of conflicts for the current transaction.
    /// </param>
    /// <param name="_currentConflict">
    ///    The current conflict message.
    /// </param>
    /// <returns>
    ///    true if an asterisk must be printed instead of an amount; otherwise, false.
    /// </returns>
    /// <remarks>
    ///    The current implementation on invoice and return scenarios causes some problems when reporting the
    ///    correct imbalance value.Also, all transactions with only a blank dimension conflict, should not
    ///    print an amount.
    /// </remarks>
    protected NoYes printAsterisk(
        InventValueTransUnionAll    _inventValueTransUnionAll,
        int                         _noOfConflicts,
        str                         _currentConflict
        )
    {
        return (_inventValueTransUnionAll.PostingType == LedgerPostingType::PurchConsump ||
                _inventValueTransUnionAll.PostingType == LedgerPostingType::SalesConsump ||
                (_noOfConflicts == 1 && _currentConflict == "@SYS332489")) ? NoYes::Yes : NoYes::No;
    }

]]></Source>
			</Method>
			<Method>
				<Name>run</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Executes the data collection that includes extraction and verification, of the inventory
    ///    transactions and calculates the balance for inventory.
    /// </summary>
    public void run()
    {
        SRSDynaLink                         dynaLink = new SRSDynaLink();
        AmountMST                           balance = 0;
        InventLedgerConflictTmpBalance      inventLedgerConflictTmpBalance;
        InventLedgerConflictTmpConflict     inventLedgerConflictTmpConflict;
        Map                                 inventoryRelevantFields = new Map(Types::String, Types::Container);

        // Prepare drillThrough string
        dynaLink.context(SRSDynaLink::getReportRunContext(inventLedgerConflictContract.parmSRSPrintMediumType()));
        dynaLink.clientMenuFunction(menuitemDisplayStr(InventTransVoucher), MenuItemType::Display);
        dynaLink.tableId(tableNum(InventTransOrigin));

        Query query = this.buildQuery();

        // Fields from the temporary table that are relevant to the Inventory query are applied
        inventoryRelevantFields.insert(fieldStr(InventLedgerConflictTmpConflict, ItemId),
                                    [fieldNum(InventValueTransUnionAll, ItemId),
                                    tableNum(InventValueTransUnionAll)]);

        inventoryRelevantFields.insert(fieldStr(InventLedgerConflictTmpConflict, ReferenceCategory),
                                    [fieldNum(InventValueTransUnionAll, ReferenceCategory),
                                    tableNum(InventValueTransUnionAll)]);

        inventoryRelevantFields.insert(fieldStr(InventLedgerConflictTmpConflict, InventTransId),
                                    [fieldNum(InventValueTransUnionAll, InventTransId),
                                    tableNum(InventValueTransUnionAll)]);

        InventLedgerConflictInit::applyInputQuery(inventoryRelevantFields, inventLedgerConflictContract.parmQuery(), query);
        QueryRun queryRun = new QueryRun(query);

        ttsbegin;
        InventValueTransUnionAll inventValueTransUnionAll;
        InventTable              inventTable;
        InventModelGroupItem     inventModelGroupItem;

        if (queryRun.next())
        {
            inventValueTransUnionAll = queryRun.get(tableNum(InventValueTransUnionAll));
            inventTable              = queryRun.get(tableNum(InventTable));
            inventModelGroupItem     = queryRun.get(tableNum(InventModelGroupItem));
        }

        while (inventValueTransUnionAll)
        {
            List comments = this.checkForConflicts(inventValueTransUnionAll, inventTable.ItemType, inventModelGroupItem.ModelGroupId);
            if (comments.elements() > 0)
            {
                ListEnumerator listEnumerator = comments.getEnumerator();
                int messageNumber = 1;
                while (listEnumerator.moveNext())
                {
                    dynaLink.recordKey(queryValue(fieldNum(InventTransOrigin, RecId)) + ':' + queryValue(InventTransOrigin::findByInventTransId(inventValueTransUnionAll.InventTransId).RecId));
                    InventLedgerConflictMessage inventLedgerConflictMessage = listEnumerator.current();

                    boolean printAsterisk = this.printAsterisk(inventValueTransUnionAll, comments.elements(), inventLedgerConflictMessage.parmMessage());
                    inventLedgerConflictTmpConflict.ItemId					= inventValueTransUnionAll.ItemId;

                    if (printAsterisk || messageNumber > 1)
                    {
                        inventLedgerConflictTmpConflict.Amount				= 0;
                    }
                    else
                    {
                        inventLedgerConflictTmpConflict.Amount				= inventLedgerConflictMessage.parmAmountMultiplier() * inventValueTransUnionAll.Amount;
                    }

                    inventLedgerConflictTmpConflict.InventTransId			= inventValueTransUnionAll.InventTransId;
                    inventLedgerConflictTmpConflict.ReferenceCategory		= inventValueTransUnionAll.ReferenceCategory;
                    inventLedgerConflictTmpConflict.TransDate				= inventValueTransUnionAll.TransDate;
                    inventLedgerConflictTmpConflict.PrintAsterisk			= printAsterisk;
                    inventLedgerConflictTmpConflict.DrillThroughAction		= dynaLink.url();
                    inventLedgerConflictTmpConflict.MessageNumber			= messageNumber;
                    inventLedgerConflictTmpConflict.Comment					= inventLedgerConflictMessage.parmMessage();
                    inventLedgerConflictTmpConflict.SessionId				= inventLedgerConflictContract.parmSessionId();
                    inventLedgerConflictTmpConflict.ReportId				= inventLedgerConflictContract.parmReportId();
                    inventLedgerConflictTmpConflict.ReportDate				= inventLedgerConflictContract.parmReportDate();
                    inventLedgerConflictTmpConflict.insert();

                    messageNumber++;
                }
            }

            // Service items are not part of the balance
            if (inventTable.ItemType != ItemType::Service)
            {
                balance += inventValueTransUnionAll.Amount;
            }

            next inventValueTransUnionAll;
        }

        inventLedgerConflictTmpBalance.Balance					= balance;
        inventLedgerConflictTmpBalance.Module					= InventLedgerConflictModule::Inventory;
        inventLedgerConflictTmpBalance.SessionId				= inventLedgerConflictContract.parmSessionId();
        inventLedgerConflictTmpBalance.ReportId					= inventLedgerConflictContract.parmReportId();
        inventLedgerConflictTmpBalance.ReportDate				= inventLedgerConflictContract.parmReportDate();
        inventLedgerConflictTmpBalance.insert();

        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>unpack</Name>
				<Source><![CDATA[
    public boolean unpack(container _packedClass)
    {
        int         version = RunBase::getVersion(_packedClass);
        container   packedInventLedgerConflictContract;

        switch (version)
        {
            case #CurrentVersion:
                [version, packedInventLedgerConflictContract] = _packedClass;
                if (packedInventLedgerConflictContract)
                {
                    inventLedgerConflictContract = InventLedgerConflictContract::construct();
                    return inventLedgerConflictContract.unpack(packedInventLedgerConflictContract);
                }
                break;
            default:
                return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runAsync</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates and runs as an asynchronous task.
    /// </summary>
    /// <returns>The created asynchronous task.</returns>
    public System.Threading.Tasks.Task runAsync()
    {
        System.Threading.Tasks.Task threadTask = runAsync(classNum(InventLedgerConflictInventory),
                                                          staticMethodStr(InventLedgerConflictInventory, runOperationAsync),
                                                          [this.pack()]);

        return threadTask;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runOperationAsync</Name>
				<Source><![CDATA[
    private static void runOperationAsync(container params, System.Threading.CancellationToken cancellationToken)
    {
        InventLedgerConflictInventory   dataCollectionTask = new InventLedgerConflictInventory();
        container                       packedDataCollectionTask;

        [packedDataCollectionTask] = params;
        dataCollectionTask.unpack(packedDataCollectionTask);

        dataCollectionTask.run();
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static InventLedgerConflictInventory construct()
    {
        return new InventLedgerConflictInventory();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSettlementPosted</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Indicates whether the <c>InventSettlement</c> record has been posted or not.
    /// </summary>
    /// <param name="_inventValueTransUnionAll">
    ///    The view buffer that has inventory transaction data.
    /// </param>
    /// <param name="_useFinancialDate">
    ///    The flag indicates that whether financial or physical date from inventory transaction is used to search <c>InventTransPosting</c> record; optional.
    /// </param>
    /// <returns>
    ///    true if the <c>InventSettlement</c> record is posted; otherwise, false.
    /// </returns>
    protected boolean isSettlementPosted(InventValueTransUnionAll _inventValueTransUnionAll, boolean _useFinancialDate = true)
    {
        InventSettlement    inventSettlement;

        select firstonly inventSettlement
                   where inventSettlement.Voucher       == _inventValueTransUnionAll.Voucher
                      && inventSettlement.TransDate     == _inventValueTransUnionAll.TransDate
                      && inventSettlement.InventTransId == _inventValueTransUnionAll.InventTransId;

        if (inventSettlement)
        {
            InventTrans inventTrans = InventTrans::findRecId(inventSettlement.TransRecId);
            if (inventTrans)
            {
                InventTransPosting inventTransPosting = InventTransPosting::findByNaturalKey(this.initializeInventTransPostingSearchParameters(inventTrans, _inventValueTransUnionAll, _useFinancialDate));
                if (inventTransPosting && inventTransPosting.IsPosted)
                {
                    return true;
                }
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>initializeInventTransPostingSearchParameters</Name>
				<Source><![CDATA[
    /// <summary>
    /// Initializes the search parameters for finding the <c>InventTransPosting</c> table.
    /// </summary>
    /// <param name = "_inventTrans">The <c>InventTrans</c> record related to the <c>InventSettlement</c>.</param>
    /// <param name = "_inventValueTransUnionAll">The view buffer that has inventory transaction data..</param>
    /// <param name = "_useFinancialDate">The flag indicates that whether financial or physical date from inventory transaction is used to search <c>InventTransPosting</c> record.</param>
    /// <returns>The search parameters.</returns>
    protected InventTransPosting initializeInventTransPostingSearchParameters(
        InventTrans                 _inventTrans,
        InventValueTransUnionAll    _inventValueTransUnionAll, 
        boolean                     _useFinancialDate)
    {
        if (_useFinancialDate)
        {
            inventTransPostingSearchCriteria.TransDate = _inventTrans.DateFinancial;
        }
        else
        {
            inventTransPostingSearchCriteria.TransDate = _inventTrans.DatePhysical;
        }

        inventTransPostingSearchCriteria.Voucher = _inventTrans.Voucher;
        inventTransPostingSearchCriteria.InventTransOrigin = _inventTrans.InventTransOrigin;
        inventTransPostingSearchCriteria.InventTransPostingType = _inventValueTransUnionAll.InventTransPostingType;

        return inventTransPostingSearchCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemType</Name>
				<Source><![CDATA[
    private ItemType getItemType(ItemId _itemId)
    {
        if (itemIdToItemTypeCache.exists(_itemId))
        {
            return itemIdToItemTypeCache.lookup(_itemId);
        }
        else
        {
            ItemType itemType = InventTable::find(_itemId).ItemType;
            itemIdToItemTypeCache.add(_itemId, itemType);
            return itemType;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getMainAccountIdFromLedgerDimension</Name>
				<Source><![CDATA[
    private MainAccountNum getMainAccountIdFromLedgerDimension(LedgerDimensionBase _ledgerDimension)
    {
        if (ledgerDimensionToMainAccountIdCache.exists(_ledgerDimension))
        {
            return ledgerDimensionToMainAccountIdCache.lookup(_ledgerDimension);
        }
        else
        {
            MainAccountNum mainAccountId = LedgerDimensionFacade::getMainAccountIdFromLedgerDimension(_ledgerDimension);
            ledgerDimensionToMainAccountIdCache.add(_ledgerDimension, mainAccountId);
            return mainAccountId;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemModelGroup</Name>
				<Source><![CDATA[
    private InventModelGroup getItemModelGroup(InventModelGroupId _itemModelGroupId)
    {
        if (itemModelGroupCache.exists(_itemModelGroupId))
        {
            return itemModelGroupCache.lookup(_itemModelGroupId);
        }
        else
        {
            InventModelGroup itemModelGroup = InventModelGroup::find(_itemModelGroupId);
            itemModelGroupCache.add(_itemModelGroupId, itemModelGroup);
            return itemModelGroup;
        }
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>