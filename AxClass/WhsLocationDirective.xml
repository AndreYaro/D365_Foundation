<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>WHSLocationDirective</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
/// The <c>WhsLocationDirective</c> class is used to find pick/put location using location directives.
/// </summary>
public class WhsLocationDirective
{
    #WHSBuildQty
    #TimeConstants

    InventQty                           unitizeQty;

    WHSLocDirTable                      locDirTable;
    WHSLocSeqNum                        locSeqNumLocDirTable;
    WHSLocSeqNum                        locSeqNumLocDirLine;
    WHSLocSeqNum                        locSeqNumLocDirAction;

    WHSWorkBuildId                      workBuildId;
    WHSOriginType                       originType;
    WHSOriginRefId                      originRefId;
    WHSTmpWorkLine                      tmpWorkLine;
    WHSWaveExecutionID                  waveExecutionId;
    WHSWorkTransType                    workTransType;
    WHSWorkType                         workType;

    InventQty                           replenAvailQty;
    UnitOfMeasureSymbol                 replenRoundingUOM;
    WHSReplenishmentTemplateLine        replenishmentTemplateLine;
    InventDim                           replenInventDim;
    WHSFEFOBatchId                      parmFEFOBatchId;
    WHSLicensePlateId                   parmLocatedLP;

    boolean                             batchControlled;
    InventDim                           prevDimensions;
    WMSLocation                         location;
    WHSLicensePlateId                   curLPId;
    InventBatchId                       inventBatchId;
    ItemId                              itemId;
    WHSInventStatusId                   statusId;
    CustVendAC                          custVendAccount;
    Qty                                 availQty;
    Qty                                 inventFindQty;
    InventQty                           inventQty;
    UnitOfMeasureSymbol                 inventUOM;
    UnitOfMeasureSymbol                 locatedUOM;
    UnitOfMeasureSymbol                 allowedUnitId;
    Qty                                 allowedQty;
    boolean                             isStagingWorkLine;
    boolean                             isFinalPutWorkLine;
    Map                                 fullyAllocatedLocationsMap;
    boolean                             isWorkHistoryLogEnabled;
    WHSLicensePlateId                   targetLicensePlateId;
    WHSShipmentId                       shipmentId;
    boolean                             usedLocateByLP;
    WHSReleaseToWarehouseId             releaseToWarehouseId;
    boolean                             usedImmedReplen;
    Qty                                 immedReplenUsedExistingReplen;
    boolean                             onlyExistingImmedReplenUsed;

    WHSLicensePlateLocDirInformation    lpInformation;
    WHSLocDirName                       locDirNameAction;

    private WHSWorkId                   originWorkId;
    private WHSWorkId                   clusteredWorkId;
    private boolean                     skipImmedReplen;

    private List                        productDimEnabledFieldList;
    private WhsLocationDirectiveMatch   latestMatchingDirective;

    private WHSInstrumentationLogger    instrumentationLogger;

    static EcoResReleasedProductUnitConverter releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();

    private InventTestAssociationTableRecId inventTestAssociationTableRecId;
    private WHSInstrumentationFindPickPutLocationPerformanceTask findPickPutLocationPerformanceTask;

    private InventDimId initialInventDimId;
    private boolean isAcceptanceTest;
    private WHSLocationDirectiveCache locDirCache = WHSLocationDirectiveCache::construct();
    private WHSOrderNum orderNum;
    private Map locationTotalCapacityForItemMap;
    private Qty locationStockLimitQty;
    private boolean useStockingLimits;

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    public void new()
    {
        fullyAllocatedLocationsMap = new Map(Types::String, Types::Class);
        isWorkHistoryLogEnabled = WHSParameters::find().isWorkCreateHistoryLogEnabled();
        productDimEnabledFieldList = InventDim::dimProductDimensionEnabledFieldList();

        instrumentationLogger = WHSInstrumentationLogger::createLogger(classId2Name(classIdGet(this)));
    }

]]></Source>
			</Method>
			<Method>
				<Name>clearCache</Name>
				<Source><![CDATA[
    [PostHandlerFor(classStr(SysTestCleanup), staticMethodStr(SysTestCleanup, ClearGlobalObjectCache))]
    public static void clearCache(XppPrePostArgs _args)
    {
        releasedProductUnitConverter = EcoResReleasedProductUnitConverter::construct();
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleasedProductUnitConverter</Name>
				<Source><![CDATA[
    public static EcoResReleasedProductUnitConverter parmReleasedProductUnitConverter()
    {
        return releasedProductUnitConverter;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsWorkHistoryLogEnabled</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmIsWorkHistoryLogEnabled(boolean _isWorkHistoryLogEnabled = isWorkHistoryLogEnabled)
    {
        isWorkHistoryLogEnabled = _isWorkHistoryLogEnabled;
        return isWorkHistoryLogEnabled;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsAcceptanceTest</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmIsAcceptanceTest(boolean _isAcceptanceTest = isAcceptanceTest)
    {
        isAcceptanceTest = _isAcceptanceTest;
        return isAcceptanceTest;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOrderNum</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WHSOrderNum parmOrderNum(WHSOrderNum _orderNum = orderNum)
    {
        orderNum = _orderNum;
        return orderNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmItemId</Name>
				<Source><![CDATA[
    public ItemId parmItemId()
    {
        return itemId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmAvailQty</Name>
				<Source><![CDATA[
    public Qty parmAvailQty(Qty _availQty = availQty)
    {
        availQty = _availQty;
        return availQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmMatchingDirective</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal WhsLocationDirectiveMatch parmMatchingDirective()
    {
        return latestMatchingDirective;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmSkipImmedReplen</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean parmSkipImmedReplen(boolean _skipImmedReplen = skipImmedReplen)
    {
        skipImmedReplen = _skipImmedReplen;

        return skipImmedReplen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsedImmedReplen</Name>
				<Source><![CDATA[
    public boolean parmUsedImmedReplen(boolean _usedImmedReplen = usedImmedReplen)
    {
        usedImmedReplen = _usedImmedReplen;

        return usedImmedReplen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventFindQty</Name>
				<Source><![CDATA[
    public Qty parmInventFindQty(Qty _inventFindQty = inventFindQty)
    {
        inventFindQty = _inventFindQty;
        return inventFindQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReleaseToWarehouseId</Name>
				<Source><![CDATA[
    public WHSReleaseToWarehouseId parmReleaseToWarehouseId(WHSReleaseToWarehouseId _releaseToWarehouseId = releaseToWarehouseId)
    {
        releaseToWarehouseId = _releaseToWarehouseId;
        return releaseToWarehouseId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFullyAllocatedLocationsMap</Name>
				<Source><![CDATA[
    public Map parmFullyAllocatedLocationsMap(Map _fullyAllocatedLocationsMap = fullyAllocatedLocationsMap)
    {
        fullyAllocatedLocationsMap = _fullyAllocatedLocationsMap;
        return fullyAllocatedLocationsMap;
    }

]]></Source>
			</Method>
			<Method>
				<Name>doesStrategyRelyBelowLocationDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether the current strategy relies on dimensions below location.
    /// </summary>
    /// <param name="_strategy">
    /// The <c>WHSLocDirStrategy</c> to check.
    /// </param>
    /// <returns>
    /// true if strategy relies on dimensions below location; otherwise, false.
    /// </returns>
    private boolean doesStrategyRelyBelowLocationDimension(WHSLocDirStrategy _strategy)
    {
        WhsLocationDirectiveStrategy strategy = WhsLocationDirectiveStrategy::singletonFromStrategy(_strategy);

        if (strategy)
        {
            return strategy.reliesOnDimensionsBelowLocation();
        }
        
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseVolumetricsOptimization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the volumetric optimization should be enabled.
    /// </summary>
    /// <returns>
    /// true, if volumetric optimization should be enabled; otherwise, false.
    /// </returns>
    protected boolean shouldUseVolumetricsOptimization()
    {
        // we should always perform the optimization.
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldUseMixedLocationOptimization</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the mixed location optimization should be enabled.
    /// </summary>
    /// <returns>
    /// true, if mixed location optimization should be enabled; otherwise, false.
    /// </returns>
    [Hookable(false)]
    protected boolean shouldUseMixedLocationOptimization()
    {
        if (isWorkHistoryLogEnabled)
        {
            // when work history log is enabled we want to provide log messages for
            // every location that fails due to mixed constraints
            // so we don't want to pre-filter such locations in the query
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>workTransactionType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Returns a work transaction type for the current work trans type.
    /// </summary>
    /// <param name="_parameters">The location directive query parameters.</param>
    /// <returns>A <c>WhsWorkTransactionType</c> instance for the current work trans type.</returns>
    protected WhsWorkTransactionType workTransactionType(WhsLocationDirectiveTableQueryParameters _parameters)
    {
        return WhsWorkTransactionType::singletonFromType(workTransType);
    }

]]></Source>
			</Method>
			<Method>
				<Name>addRangeByTransType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Adds a range to the LocationDirective query based on the work trans type.
    /// </summary>
    /// <param name="_parameters">The location directive query parameters.</param>
    private void addRangeByTransType(WhsLocationDirectiveTableQueryParameters _parameters)
    {
        WhsWorkTransactionType workTransactionType = this.workTransactionType(_parameters);

        if (workTransactionType)
        {
            if (orderNum && 
                locDirTable.Scope == WhsLocationDirectiveScope::SingleOrder)
            {
                workTransactionType.buildLocationDirectiveQuerySingleOrder(_parameters);
            }
            else
            {
                workTransactionType.buildLocationDirectiveQuery(_parameters);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDifferenceBetweenDates</Name>
				<Source><![CDATA[
    private real getDifferenceBetweenDates(Date _date1, Date _date2)
    {
        utcdatetime date1Utc = DateTimeUtil::newDateTime(_date1, 0);
        utcdatetime date2Utc = DateTimeUtil::newDateTime(_date2, 0);
        real diffInSeconds = DateTimeUtil::getDifference(date1Utc, date2Utc);
        real diffInDays = diffInSeconds / #secondsPerDay;
        return abs(trunc(diffInDays));
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkBatchDays</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks whether batch can be located in a specific location by checking "days to mix" parameter defined for the item.
    /// </summary>
    /// <param name="_inventSiteId">
    /// Site id of the location.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location.
    /// </param>
    /// <param name="_wmsLocationId">
    /// Location id within the warehouse.
    /// </param>
    /// <param name="_itemId">
    /// Item id.
    /// </param>
    /// <param name="_vendAccount">
    /// Vendor account.
    /// </param>
    /// <param name="_expDate">
    /// Item expiration date.
    /// </param>
    /// <param name="_inventBatchId">
    /// Batch id of the item.
    /// </param>
    /// <returns>
    /// True if batch can be located in a specific location.
    /// </returns>
    boolean checkBatchDays(InventSiteId         _inventSiteId,
                           InventLocationId     _inventLocationId,
                           WMSLocationId        _wmsLocationId,
                           ItemId               _itemId,
                           VendAccount          _vendAccount,
                           InventBatchExpDate   _expDate,
                           InventBatchId        _inventBatchId)
    {
        InventBatch     inventBatch;
        WHSFilter       filter = new WHSFilter();
        InventDim       inventDim;
        InventSum       inventSum;
        VendTable       vendTable;
        RefRecId        vendGroupRecId;
        boolean         ret = true;
        Days            daysToMix;
        real            diff;
        WHSWorkTable    worktable;
        WHSWorkLine     workLine;

        // If this location's profile is setup to ignore batch dates, just return true.
        if (WHSLocationProfile::find(WMSLocation::find(_wmsLocationId, _inventLocationId).LocProfileId).IgnoreBatchDates)
        {
            return ret;
        }

        ttsbegin;

        vendTable = VendTable::find(_vendAccount);

        // Check Customer
        daysToMix = filter.findFilterMatch(tableNum(VendTable), vendTable.RecId, _itemId).NumDaysToMix;

        // Check Customer Group
        if (!daysToMix)
        {
            vendGroupRecId = VendGroup::find(vendTable.VendGroup).RecId;
            daysToMix = filter.findFilterMatch(tableNum(VendGroup), vendGroupRecId, _itemId).NumDaysToMix;
        }

        if (!WHSFilterGenerallyAvailDaysCheckRemoveFlight::instance().isEnabled())
        {
            // Check Generally Available Customer
            if (!daysToMix)
            {
                daysToMix = filter.findFilterMatch(tableNum(WHSFilterGenerallyAvail), enum2int(WHSFilterModule::Customer), _itemId).NumDaysToMix;
            }

            // Check Generally Available All
            if (!daysToMix)
            {
                daysToMix = filter.findFilterMatch(tableNum(WHSFilterGenerallyAvail), enum2int(WHSFilterModule::All), _itemId).NumDaysToMix;
            }
        }

        // Check Number of days to mix batches All
        if (!daysToMix)
        {
            daysToMix = filter.findFilterMatch(tableNum(WHSFilterBatchNumDaysToMix), enum2int(WHSFilterModule::All), _itemId).NumDaysToMix;

            // Get the Parameter if nothing else was found
            if (!daysToMix)
            {
                daysToMix = WHSParameters::find().NumDaysToMix;
            }
        }


        // If we have a value to check against, do the check
        if (daysToMix)
        {
            if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                // Get the oldest expiration date in the location
                select firstonly ExpDate from inventBatch
                order by ExpDate asc
                where inventBatch.itemId == _itemId
                join inventSum
                where inventSum.InventBatchId       == inventBatch.InventBatchId    &&
                      inventSum.InventBatchId       != _inventBatchId               &&
                      inventSum.InventLocationId    == _inventLocationId            &&
                      inventSum.wmsLocationId       == _wmsLocationId               &&
                      inventSum.ItemId              == inventBatch.ItemId           &&
                      inventSum.ClosedQty           == NoYes::No                    &&
                      inventSum.PhysicalInvent      > 0;
            }
            else
            {
                // Get the oldest expiration date in the location
                select firstonly ExpDate from inventBatch
                order by ExpDate asc
                where inventBatch.itemId == _itemId
                join inventDim
                where inventDim.InventBatchId       == inventBatch.InventBatchId    &&
                      inventDim.InventBatchId       != _inventBatchId               &&
                      inventDim.InventLocationId    == _inventLocationId            &&
                      inventDim.wmsLocationId       == _wmsLocationId
                    join inventSum
                    where inventSum.InventDimId     == inventDim.InventDimId        &&
                          inventSum.ItemId          == inventBatch.ItemId           &&
                          inventSum.ClosedQty       == NoYes::No                    &&
                          inventSum.PhysicalInvent   > 0;
            }

            // Only do the check if there's another batch in the location
            if (inventBatch.ExpDate)
            {
                // Get the difference between the two expiration dates
                diff = this.getDifferenceBetweenDates(inventBatch.ExpDate, _expDate);

                // If the difference between the two expiration dates is greater than what's allowed
                // to mix, return false
                if (diff > daysToMix)
                {
                    ret = false;
                }
            }

            if (ret)
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    // Get the oldest expiration date pointed to the location from work
                    select firstonly ExpDate from inventBatch
                    order by ExpDate asc
                        where inventBatch.itemId == _itemId
                    join workLine
                    where workLine.ItemId           == inventBatch.ItemId           &&
                          workLine.WorkType         == WHSWorkType::Put             &&
                          workLine.WorkStatus       == WHSWorkStatus::Open          &&
                          workLine.wmsLocationId    == _wmsLocationId
                        join worktable
                        where worktable.WorkId   == workLine.WorkId
                            join inventSum
                            where inventSum.LicensePlateId      == worktable.TargetLicensePlateId   &&
                                  inventSum.InventBatchId       == inventBatch.InventBatchId        &&
                                  inventSum.InventBatchId       != _inventBatchId                   &&
                                  inventSum.InventLocationId    == _inventLocationId                &&
                                  inventSum.ItemId              == inventBatch.ItemId               &&
                                  inventSum.ClosedQty           == NoYes::No                        &&
                                  inventSum.PhysicalInvent      > 0;
                }
                else
                {
                    // Get the oldest expiration date pointed to the location from work
                    select firstonly ExpDate from inventBatch
                        order by ExpDate asc
                        where inventBatch.itemId == _itemId
                    join workLine
                    where workLine.ItemId           == inventBatch.ItemId           &&
                          workLine.WorkType         == WHSWorkType::Put             &&
                          workLine.WorkStatus       == WHSWorkStatus::Open          &&
                          workLine.wmsLocationId    == _wmsLocationId
                        join worktable
                        where worktable.WorkId   == workLine.WorkId
                            join inventDim
                            where inventDim.LicensePlateId      == worktable.TargetLicensePlateId       &&
                                  inventDim.InventBatchId       == inventBatch.InventBatchId            &&
                                  inventDim.InventBatchId       != _inventBatchId                       &&
                                  inventDim.InventLocationId    == _inventLocationId
                                join inventSum
                                where inventSum.InventDimId     == inventDim.InventDimId        &&
                                      inventSum.ItemId          == inventBatch.ItemId           &&
                                      inventSum.ClosedQty       == NoYes::No                    &&
                                      inventSum.PhysicalInvent   > 0;
                }

                // Only do the check if there's another batch in the location
                if (inventBatch.ExpDate)
                {
                    // Get the difference between the two expiration dates
                    diff = this.getDifferenceBetweenDates(inventBatch.ExpDate, _expDate);

                    // If the difference between the two expiration dates is greater than what's allowed
                    // to mix, return false
                    if (diff > daysToMix)
                    {
                        ret = false;
                    }
                }
            }

            if (ret)
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    // Get the newest expiration date in the location
                    select firstonly ExpDate from inventBatch
                        order by ExpDate desc
                        where inventBatch.itemId == _itemId
                    join inventSum
                    where inventSum.InventBatchId       == inventBatch.InventBatchId    &&
                          inventSum.InventBatchId       != _inventBatchId               &&
                          inventSum.InventLocationId    == _inventLocationId            &&
                          inventSum.wmsLocationId       == _wmsLocationId               &&
                          inventSum.ItemId              == inventBatch.ItemId           &&
                          inventSum.ClosedQty           == NoYes::No                    &&
                          inventSum.PhysicalInvent      > 0;
                }
                else
                {
                    // Get the newest expiration date in the location
                    select firstonly ExpDate from inventBatch
                        order by ExpDate desc
                        where inventBatch.itemId == _itemId
                    join inventDim
                    where inventDim.InventBatchId       == inventBatch.InventBatchId    &&
                          inventDim.InventBatchId       != _inventBatchId               &&
                          inventDim.InventLocationId    == _inventLocationId            &&
                          inventDim.wmsLocationId       == _wmsLocationId
                        join inventSum
                        where inventSum.InventDimId     == inventDim.InventDimId        &&
                              inventSum.ItemId          == inventBatch.ItemId           &&
                              inventSum.ClosedQty       == NoYes::No                    &&
                              inventSum.PhysicalInvent   > 0;
                }

                // Only do the check if there's another batch in the location
                if (inventBatch.ExpDate)
                {
                    // Get the difference between the two expiration dates
                    diff = this.getDifferenceBetweenDates(inventBatch.ExpDate, _expDate);

                    // If the difference between the two expiration dates is greater than what's allowed
                    // to mix, return false
                    if (diff > daysToMix)
                    {
                        ret = false;
                    }
                }
            }

            if (ret)
            {
                if (InventUseDimOfInventSumToggle::instance().isEnabled())
                {
                    // Get the newest expiration date pointed to the location from work
                    select firstonly ExpDate from inventBatch
                        order by ExpDate desc
                        where inventBatch.itemId == _itemId
                    join ItemId, WorkType, WorkStatus, wmsLocationId, WorkId from workLine
                    where workLine.ItemId           == inventBatch.ItemId           &&
                          workLine.WorkType         == WHSWorkType::Put             &&
                          workLine.WorkStatus       == WHSWorkStatus::Open          &&
                          workLine.wmsLocationId    == _wmsLocationId
                        join WorkId, TargetLicensePlateId from worktable
                        where worktable.WorkId   == workLine.WorkId
                            join TableId from inventSum
                            where inventSum.LicensePlateId      == worktable.TargetLicensePlateId   &&
                                  inventSum.InventBatchId       == inventBatch.InventBatchId        &&
                                  inventSum.InventBatchId       != _inventBatchId                   &&
                                  inventSum.InventLocationId    == _inventLocationId                &&
                                  inventSum.ItemId              == inventBatch.ItemId               &&
                                  inventSum.ClosedQty           == NoYes::No                        &&
                                  inventSum.PhysicalInvent      > 0;
                }
                else
                {
                    // Get the newest expiration date pointed to the location from work
                    select firstonly ExpDate from inventBatch
                        order by ExpDate desc
                        where inventBatch.itemId == _itemId
                    join ItemId, WorkType, WorkStatus, wmsLocationId, WorkId from workLine
                    where workLine.ItemId           == inventBatch.ItemId           &&
                          workLine.WorkType         == WHSWorkType::Put             &&
                          workLine.WorkStatus       == WHSWorkStatus::Open          &&
                          workLine.wmsLocationId    == _wmsLocationId
                        join WorkId, TargetLicensePlateId from worktable
                        where worktable.WorkId   == workLine.WorkId
                            join LicensePlateId, InventBatchId, InventSiteId, InventLocationId, InventDimId from inventDim
                            where inventDim.LicensePlateId      == worktable.TargetLicensePlateId    &&
                                  inventDim.InventBatchId       == inventBatch.InventBatchId            &&
                                  inventDim.InventBatchId       != _inventBatchId                       &&
                                  inventDim.InventLocationId    == _inventLocationId
                                join InventDimId, ItemId, PhysicalInvent from inventSum
                                where inventSum.InventDimId     == inventDim.InventDimId        &&
                                      inventSum.ItemId          == inventBatch.ItemId           &&
                                      inventSum.ClosedQty       == NoYes::No                    &&
                                      inventSum.PhysicalInvent   > 0;
                }

                // Only do the check if there's another batch in the location
                if (inventBatch.ExpDate)
                {
                    // Get the difference between the two expiration dates
                    diff = this.getDifferenceBetweenDates(inventBatch.ExpDate, _expDate);

                    // If the difference between the two expiration dates is greater than what's allowed
                    // to mix, return false
                    if (diff > daysToMix)
                    {
                        ret = false;
                    }
                }
            }
        }

        ttscommit;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkExcludedLocations</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if the current location is in a list of locations to exclude.
    /// </summary>
    /// <param name="_excludeLocationId">
    /// A <c>Set</c> of WMSLocationIds which should be excluded from location directives.
    /// </param>
    /// <returns>
    /// true if the location is not an excluded location, otherwise, false.
    /// </returns>
    private boolean checkExcludedLocations(Set    _excludeLocationId)
    {
        boolean     ret = true;

        // Check to see if this location should be excluded.
        if (_excludeLocationId && _excludeLocationId.in(location.wmsLocationId))
        {
            this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX1743", location.wmsLocationId), true, statusId);
            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.checkExcludedLocations();
            }
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFinalPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the final put location meets requirements.
    /// </summary>
    /// <returns>
    /// true if the location for the final put work line meets all validation requirements; otherwise, false.
    /// </returns>
    private boolean checkFinalPutLocation()
    {
        boolean             ret = true;
        str                 errorText;

        // The final Put location for transfer order issue and sales order work must be validated.
        if (isFinalPutWorkLine)
        {
            [ret, errorText] = WHSLocationDirective::validateFinalPutLocationRequirements(location, workTransType);
        }

        if (!ret)
        {
            this.createWorkHistoryLine(itemId,
                                       inventQty,
                                       inventUOM,
                                       errorText,
                                       true,
                                       statusId);

            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.checkFinalPutLocation();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixedLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to make sure the location is a fixed location for the item if needed.
    /// </summary>
    /// <param name="_useFixedLocations">
    /// Determines if we must use fixed locations or not.
    /// </param>
    /// <returns>
    /// true if the location is a fixed location for the item or if we are not using fixed locations; otherwise, false.
    /// </returns>
    private boolean checkFixedLocation(boolean _useFixedLocations)
    {
        boolean     ret = true;

        // Check to see if we should be using Fixed Locations
        if (_useFixedLocations)
        {
            if (!WHSInventFixedLocation::exist(itemId, location.InventLocationId, location.inventSiteId(), location.wmsLocationId))
            {
                this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX1744", location.wmsLocationId), true, statusId);

                if (findPickPutLocationPerformanceTask)
                {
                    findPickPutLocationPerformanceTask.checkFixedLocation();
                }

                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkLocAllowMultiSku</Name>
				<Source><![CDATA[
    private boolean checkLocAllowMultiSku()
    {
        boolean ret = true;

        // Skip Non-Multi SKU locations
        if (!WHSLocationProfile::find(location.LocProfileId).AllowMixedItems)
        {
            this.createWorkHistoryLine('', 0, '', strFmt("@WAX1749", location.wmsLocationId), true);

            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.checkLocAllowMultiSku();
            }

            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>mustCheckNonLPLocation</Name>
				<Source><![CDATA[
    private boolean mustCheckNonLPLocation(WHSLocDirStrategy _strategy)
    {
        WhsLocationDirectiveStrategy strategy = WhsLocationDirectiveStrategy::singletonFromStrategy(_strategy);

        if (strategy)
        {
            return strategy.mustCheckNonLPLocation();
        }
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkNonLPLocation</Name>
				<Source><![CDATA[
    private boolean checkNonLPLocation(
        WHSLocDirStrategy   _strategy,
        InventDim           _inventDim)
    {
        boolean ret = true;

        if (workType == WHSWorkType::Pick &&
            this.mustCheckNonLPLocation(_strategy))
        {
            curLPId = _inventDim.LicensePlateId;
            // Skip non-lp controlled locations.
            if (!curLPId)
            {
                this.createWorkHistoryLine(itemId,
                                            inventQty,
                                            inventUOM,
                                            strFmt("@WAX4305", location.wmsLocationId),
                                            true,
                                            statusId);

                if (findPickPutLocationPerformanceTask)
                {
                    findPickPutLocationPerformanceTask.checkNonLPLocation();
                }

                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>populatedInventDimForCurrentLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Event raised when the inventory dimension record is populated for the current location.
    /// </summary>
    /// <param name = "_locationDirective">The calling location directive class.</param>
    /// <param name = "_inventDim">The inventory dimension record.</param>
    delegate void populatedInventDimForCurrentLocation(WhsLocationDirective _locationDirective, InventDim _inventDim)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>populateInventDimForCurrentLocation</Name>
				<Source><![CDATA[
    private InventDim populateInventDimForCurrentLocation()
    {
        InventDim inventDim;

        inventDim.InventBatchId = inventBatchId;
        inventDim.LicensePlateId = curLPId;
        inventDim.WMSLocationId = location.WMSLocationId;
        InventDim.InventLocationId = location.InventLocationId;

        this.populatedInventDimForCurrentLocation(this, inventDim);

        return InventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>areDimensionsIdenticalToPreviousDimension</Name>
				<Source><![CDATA[
    private boolean areDimensionsIdenticalToPreviousDimension(InventDim _inventDim, Set _dimesionSet)
    {
        var enumerator = _dimesionSet.getEnumerator();

        while (enumerator.moveNext())
        {
            FieldName dimensionName = enumerator.current();
            if (_inventDim.getFieldValue(dimensionName) !=
                prevDimensions.getFieldValue(dimensionName))
            {
                return false;
            }
        }
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkRepeatDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks if the inventory dimensions set we are checking is a repeat of the previous dimensions we are concerned with.
    /// </summary>
    /// <param name="_strategy">
    /// The <c>WHSLocDirStrategy</c> being used that determines what dimension we are concerned with.
    /// </param>
    /// <returns>
    /// true if the dimensions are not repeated, otherwise, false.
    /// </returns>
    private boolean checkRepeatDimensions(WHSLocDirStrategy   _strategy)
    {
        boolean ret = true;
        InventDim inventDim = this.populateInventDimForCurrentLocation();

        WhsLocationDirectiveStrategy strategy = WhsLocationDirectiveStrategy::singletonFromStrategy(_strategy);

        if (strategy)
        {
            Set dimensionSet = strategy.dimensionsRequiredToChange();

            // For some strategies we don't skip when location is the same unless other criteria also matches.
            if (this.areDimensionsIdenticalToPreviousDimension(inventDim, dimensionSet))
            {
                if (findPickPutLocationPerformanceTask)
                {
                    findPickPutLocationPerformanceTask.checkRepeatDimensionsIdentical();
                }

                ret = false;
            }
        }
        else if (inventDim.WMSLocationId == prevDimensions.WMSLocationId)
        {
            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.checkRepeatLocationIdentical();
            }

            ret = false;
        }
        
        prevDimensions = inventDim;

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStagingLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the staging location meets requirements.
    /// </summary>
    /// <returns>
    /// true if the work line is either not a staging work line or is an lp controlled location; otherwise, false.
    /// </returns>
    public boolean checkStagingLocation()
    {
        boolean             ret = true;

        if (isStagingWorkLine
        &&  !location.whsLocationIsLPControlled())
        {
            ret = false;

            this.createWorkHistoryLine(itemId,
                                       inventQty,
                                       inventUOM,
                                       strFmt("@WAX5832", location.wmsLocationId),
                                       true,
                                       statusId);

            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.checkStagingLocation();
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkStatus</Name>
				<Source><![CDATA[
    private boolean checkStatus(
        WHSInventStatusId   _statusId,
        WHSLocationProfile  _locationProfile,
        InventTransId       _inventTransId = null)
    {
        boolean         ret = true;
        WHSTmpWorkLine  statusTmpWorkLine;
        InventDim       inventDim;
        
        if (!_locationProfile.AllowMixedStatus
            && !(workTransType == WHSWorkTransType::Replenishment
                 && WHSSkipInventStatusCheckReplenPutContext::currentIsZoneReplenishmentParameter()))
        {
            // First, check what is physically in the location
            ret = WHSInvent::allowMixedStatus(_statusId, location.InventLocationId, location.wmsLocationId);

            if (ret)
            {
                // Then, check what is in the temp workLine table
                select firstonly RecId from statusTmpWorkLine
                    exists join inventDim
                    where statusTmpWorkLine.InventDimId == inventDim.InventDimId
                        && statusTmpWorkLine.InventLocationId == location.InventLocationId
                        && statusTmpWorkLine.wmsLocationId == location.wmsLocationId
                        && inventDim.InventStatusId != _statusId;

                if (statusTmpWorkLine.RecId != 0)
                {
                    ret = false;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkTargetLPContainerType</Name>
				<Source><![CDATA[
    /// <summary>
    /// Check if the container type for the target license plate is allowed on the location profile.
    /// </summary>
    /// <param name="_locationProfile">
    /// The location profile for the potential put location.
    /// </param>
    /// <returns>
    /// true if the container type can be put on a location; otherwise, false.
    /// </returns>
    private boolean checkTargetLPContainerType(WHSLocationProfile _locationProfile)
    {
        boolean ret = true;

        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(workTransType);

        if (workTransactionType)
        {
            if (workTransactionType.isInbound())
            {
                ret = WHSAllowedContainerType::validateContainerTypeOnLocationProfile(_locationProfile, WHSLicensePlate::find(targetLicensePlateId).ContainerTypeCode);
            }
        }
        
        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkUserLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to make sure the current location isn't a user location.
    /// </summary>
    /// <returns>
    /// true if the location is not a user location; otherwise, false
    /// </returns>
    private boolean checkUserLocation()
    {
        boolean             ret = true;
        WHSLocProfileId     userLocationProfileId;

        userLocationProfileId = WHSParameters::find().UserLocType;

        // Skip user locations
        if (location.LocProfileId == userLocationProfileId)
        {
            this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX1745", location.wmsLocationId), true, statusId);

            if (WHSShowAdditionalInfoLocationDirectiveFailUserLocationFlight::instance().isEnabled())
            {
                this.createWorkHistoryLine(itemId, inventQty, inventUOM, "@WAX:CheckUserLocationProfileSetup", true, statusId);
            }

            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.checkUserLocation();
            }

            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>countUniqueLPInLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Counts unique license plates in specific location in warehouse.
    /// </summary>
    /// <param name="_inventLocationId">
    /// Warehouse id.
    /// </param>
    /// <param name="_inventSiteId">
    /// Site id.
    /// </param>
    /// <param name="_locationId">
    /// Location id.
    /// </param>
    /// <returns>
    /// The number of unique license plates in the location.
    /// </returns>
    int countUniqueLPInLocation(InventLocationId    _inventLocationId,
                                InventSiteId        _inventSiteId,
                                WMSLocationId       _locationId)
    {
        return this.countUniqueLicensePlatesInLocation(_inventLocationId, _inventSiteId, _locationId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>countUniqueLicensePlatesInLocation</Name>
				<Source><![CDATA[
    private int countUniqueLicensePlatesInLocation(
        InventLocationId    _inventLocationId,
        InventSiteId        _inventSiteId,
        WMSLocationId       _locationId)
    {
        int lpCount;

        if (InventUseDimOfInventSumToggle::instance().isEnabled())
        {
            InventSum inventSum;

            while select TableId from inventSum
            group by LicensePlateId
            where  inventSum.InventLocationId == _inventLocationId
                && inventSum.wmsLocationId == _locationId
                && inventSum.LicensePlateId != ''
                && inventSum.ClosedQty == NoYes::No
                && inventSum.PhysicalInvent > 0
            {
                lpCount++;
            }
        }
        else
        {
            InventDim inventDim;
            InventSum inventSum;

            while select TableId from inventDim
                group by LicensePlateId
                where  inventDim.InventLocationId   == _inventLocationId
                    && inventDim.InventSiteId       == _inventSiteId
                    && inventDim.wmsLocationId      == _locationId
                    && inventDim.LicensePlateId     != ''
                exists join inventSum
                    where  inventSum.InventDimId    == inventDim.InventDimId
                        && inventSum.ClosedQty      == NoYes::No
                        && inventSum.PhysicalInvent > 0
            {
                lpCount++;
            }
        }

        return lpCount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>onWorkHistoryLineCreated</Name>
				<Source><![CDATA[
    delegate void onWorkHistoryLineCreated(ItemId _itemId, Qty _qty, UnitOfMeasureSymbol _unitId, WHSMessage _message, boolean _fail, WHSInventStatusId _statusId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>createWorkHistoryLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates a <c>WHSWorkCreateHistory</c> record.
    /// </summary>
    /// <param name="_itemId">
    /// Item id of the record.
    /// </param>
    /// <param name="_qty">
    /// Quantity of the record.
    /// </param>
    /// <param name="_unitId">
    /// Unit id of the record.
    /// </param>
    /// <param name="_message">
    /// Message of the record.
    /// </param>
    /// <param name="_fail">
    /// Fail status of the record.
    /// </param>
    /// <param name="_statusId">
    /// Inventory status id of the record.
    /// </param>
    public void createWorkHistoryLine(ItemId _itemId, Qty _qty, UnitOfMeasureSymbol _unitId, WHSMessage _message, boolean _fail, WHSInventStatusId _statusId = '')
    {
        if (workBuildId)
        {
            WHSWorkCreateHistory workCreateHistory = this.initWorkHistoryLine();
            workCreateHistory.InventStatusId    = _statusId;
            workCreateHistory.Message           = _message;
            workCreateHistory.ItemId            = _itemId;
            workCreateHistory.Qty               = _qty;
            workCreateHistory.UnitID            = _unitId;
            workCreateHistory.Fail              = _fail;

            WHSWorkCreationLogApplicationInsightsLogEvent::trackEvent(workCreateHistory);

            if (isWorkHistoryLogEnabled)
            {
                UserConnection conn = new UserConnection();

                try
                {
                    ttsbegin;

                    workCreateHistory.setConnection(conn);
                    workCreateHistory.insert();

                    ttscommit;
                }
                finally
                {
                    conn.finalize();
                }
            }
        }
        this.onWorkHistoryLineCreated(_itemId, _qty, _unitId, _message, _fail, _statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>initWorkHistoryLine</Name>
				<Source><![CDATA[
    protected WHSWorkCreateHistory initWorkHistoryLine()
    {
        WHSWorkCreateHistory workCreateHistory;

        workCreateHistory.WorkBuildId       = workBuildId;
        workCreateHistory.OriginType        = originType;
        workCreateHistory.OriginRefId       = originRefId;
        workCreateHistory.OrderNum          = tmpWorkLine.OrderNum;
        workCreateHistory.ShipmentId        = tmpWorkLine.ShipmentId;
        workCreateHistory.LoadId            = tmpWorkLine.LoadId;
        workCreateHistory.InventLocationId  = tmpWorkLine.InventLocationId;
        workCreateHistory.TransDateTime     = DateTimeUtil::utcNow();

        return workCreateHistory;
    }

]]></Source>
			</Method>
			<Method>
				<Name>buildLocDirTableQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Builds the location directive table query.
    /// </summary>
    /// <param name="_parameters">The location directive query parameters.</param>
    [Hookable]
    protected void buildLocDirTableQuery(WhsLocationDirectiveTableQueryParameters _parameters)
    {
        this.addRangeByTransType(_parameters);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logLocDirTableNullQueryError</Name>
				<Source><![CDATA[
    private void logLocDirTableNullQueryError(
        WHSLocDirTable _locDirTable, 
        ItemId _itemId, 
        Qty _qty, 
        UnitOfMeasureSymbol _unitId, 
        WHSInventStatusId _statusId)
    {
        WHSInstrumentationLogger logger = WHSInstrumentationLogger::createLogger(classStr(WhsLocationDirective));
        logger.logError(strFmt("@WAX:InvalidLocationDirectiveQuery", _locDirTable.RecId, "@WAX395"));
        this.createWorkHistoryLine(_itemId,
                                        _qty,
                                        _unitId,
                                        strFmt("@WAX:InvalidLocationDirectiveQuery", _locDirTable.LocDirName, "@WAX395"),
                                        true,
                                        _statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLocationDirectiveVisited</Name>
				<Source><![CDATA[
    delegate void onLocationDirectiveVisited(WHSLocDirTable _locationDirective)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLocationDirectiveLineVisited</Name>
				<Source><![CDATA[
    delegate void onLocationDirectiveLineVisited(WHSLocDirLine _locationDirectiveLine)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLocationDirectiveActionVisited</Name>
				<Source><![CDATA[
    delegate void onLocationDirectiveActionVisited(WHSLocDirAction _locationDirectiveAction)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLocationEvaluated</Name>
				<Source><![CDATA[
    delegate void onLocationEvaluated(WMSLocation _location)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>onLocationFound</Name>
				<Source><![CDATA[
    delegate void onLocationFound(WMSLocationId _locationId)
    {
    }

]]></Source>
			</Method>
			<Method>
				<Name>hasLocDirMatches</Name>
				<Source><![CDATA[
    private boolean hasLocDirMatches(ItemId _itemId = '', InventTransId _inventTransId = '', InventDim _inventDim = null)
    {
        if (locDirTable.Scope == WhsLocationDirectiveScope::All)
        {
            // Query is not editable -> match is guaranteed
            return true;
        }
        boolean locDirMatches = locDirCache.locDirTableHasDefaultQuery(locDirTable);

        if (!locDirMatches)
        {
            if (locDirTable.LocDirQuery)
            {
                QueryRun queryRunLocDirTable = new QueryRun(locDirTable.LocDirQuery);

                if (locDirTable.LocateBy == WHSLocDirLocateBy::Cluster
                            && (!WHSLocationDirective::isLocatingWholeLPSupported(locDirTable.WorkTransType)
                               || !this.isLocatingWholeLP()))
                {
                    // Set range for locating clustered work.
                    SysQuery::findOrCreateRange(queryRunLocDirTable.query().dataSourceTable(tableNum(WHSWorkTable)), fieldNum(WHSWorkTable, WorkId)).value(queryValue(clusteredWorkId));
                }
                else
                {
                    WhsLocationDirectiveTableQueryParameters parameters = WhsLocationDirectiveTableQueryParameters::construct();
                    parameters.query = queryRunLocDirTable.query();
                    parameters.locationDirective = this;
                    parameters.locDirTable = locDirTable;
                    parameters.inventTransId = _inventTransId;
                    parameters.shipmentId = shipmentId;
                    parameters.targetLicensePlateId = targetLicensePlateId;
                    parameters.itemId = itemId;
                    parameters.inventBatchId = inventBatchId;
                    parameters.inventTestAssociationTableRecId = inventTestAssociationTableRecId;
                    parameters.originRefId = originRefId;
                    parameters.orderNum = orderNum;
                    parameters.originWorkId = originWorkId;

                    this.buildLocDirTableQuery(parameters);                   
                }

                locDirMatches = queryRunLocDirTable.next();
            }
            else
            {
                this.logLocDirTableNullQueryError(locDirTable,
                                            _itemId,
                                            inventQty,
                                            inventUOM,
                                            _inventDim.InventStatusId);

                throw error(strFmt("@WAX:InvalidLocationDirectiveQuery", locDirTable.LocDirName, "@WAX395"));
            }
        }
        return locDirMatches;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findOrderNumFromTmpWorkLine</Name>
				<Source><![CDATA[
    [SysObsolete('This is only used when WHSLocationDirectiveOrderNumProviderFlight is disabled. Delete this method with the flight.', false, 15\9\2023)]
    private WHSOrderNum findOrderNumFromTmpWorkLine()
    {
        WHSWorkId workId = tmpWorkLine.WorkId;

        if (!workId)
        {
            workId = WhsLocationDirectiveWorkIdProvider::currentWorkId();
        }

        // Find the order number by navigating the 1:n relationships: Work -> Load -> Order. 
        // These are only set when n = 1
        if (workId)
        {
            WHSWorkTable work = WHSWorkTable::find(workId);
            if (work.LoadId)
            {
                WHSLoadTable load = WHSLoadTable::find(work.LoadId);
                if (load)
                {
                    return load.OrderNum;
                }
            }
            return '';
        }
        return tmpWorkLine.OrderNum;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// This method uses location directives to find the first acceptable location to create work
    /// </summary>
    /// <param name="_inventTransId">
    /// The invent trans id passed in used to lookup the location
    /// </param>
    /// <param name="_inventDimId">
    /// The invent dim id passed in used to lookup the location
    /// </param>
    /// <param name="_itemId">
    /// The item id passed in used to lookup the location
    /// </param>
    /// <param name="_locDirHintCode">
    /// The location directive code id passed in used to lookup the location
    /// </param>
    /// <param name="_dispositionCode">
    /// The disposition code passed in used to lookup the location directive
    /// </param>
    /// <param name="_packingQty">
    /// The packing qty of the item
    /// </param>
    /// <param name="_restart">
    /// A parameter used to determine if the location directive variables should be reset
    /// </param>
    /// <param name="_guidedLicensePlates">
    /// A list of license plates which need to be picked - only valid for location directive strategy GuidedLPLocate
    /// </param>
    /// <param name="_inventSiteId">
    /// The site which is used to query location directive when _inventDimId is AllBlank dimensions.
    /// </param>
    /// <param name="_inventLocationId">
    /// The warehouse which is used to query location directive when _inventDimId is AllBlank dimensions.
    /// </param>
    /// <returns>
    /// A <c>WhsLocationDirectiveMatch</c> class with the results.
    /// </returns>
    protected WhsLocationDirectiveMatch findLocation(
        InventTransId      _inventTransId,
        InventDimId        _inventDimId,
        ItemId             _itemId,
        WHSLocDirHintCode  _locDirHintCode,
        WHSDispositionCode _dispositionCode,
        WHSPackingQty      _packingQty,
        boolean            _restart,
        List               _guidedLicensePlates = null,
        InventSiteId       _inventSiteId = '',
        InventLocationId   _inventLocationId = '')
    {
        using (var x = instrumentationLogger.locationDirectiveActivities().findLocation(_restart))
        {
            InventDim               inventDim = InventDim::find(_inventDimId);
            InventSiteId            inventSiteId = inventDim.InventSiteId ? inventDim.InventSiteId : _inventSiteId;
            InventLocationId        tmpInventLocationId = inventDim.InventLocationId ? inventDim.InventLocationId : _inventLocationId;
            QueryRun                queryRunLocDirTable;
            UnitOfMeasureSymbol     locateUOM = inventUOM;
            Qty                     locateQty = inventQty;
            container               buildQty;
            WhsLocationDirectiveMatch matchingDirective;

            ttsbegin;

            buildQty = WHSInventTable::buildQty(_itemId, locateQty, locateUOM, _inventDimId);

            if (_restart)
            {
                locSeqNumLocDirLine   = 0;
                locSeqNumLocDirTable  = 0;
                locSeqNumLocDirAction = 0;
            }

            while select locDirTable
                order by locDirTable.LocSeqNum, locDirTable.DispositionCode desc
                where locDirTable.WorkType          == workType             &&
                      locDirTable.WorkTransType     == workTransType        &&
                      ((locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::Warehouse && locDirTable.InventSiteId == inventSiteId && locDirTable.InventLocationId  == tmpInventLocationId) ||
                       (locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::Group) ||
                       (locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::All)) &&
                      locDirTable.LocDirHintCode    == _locDirHintCode      &&
                      (locDirTable.MultiSKU         == NoYes::No ||
                       locDirTable.Scope            == WhsLocationDirectiveScope::SingleItem || 
                       locDirTable.Scope            == WhsLocationDirectiveScope::SingleOrder ||
                       locDirTable.Scope            == WhsLocationDirectiveScope::All)          &&
                      locDirTable.LocSeqNum         >  locSeqNumLocDirTable &&
                      ((locDirTable.ApplicableDispositionCodeRule == WHSApplicableDispositionCodeRule::ExactMatch &&
                        locDirTable.DispositionCode   == _dispositionCode) ||
                       (locDirTable.ApplicableDispositionCodeRule == WHSApplicableDispositionCodeRule::AnyDispositionCode)) &&
                      (clusteredWorkId                                      ||
                       locDirTable.LocateBy != WHSLocDirLocateBy::Cluster)
            {
                if (locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::Group &&
                    !WhsWarehouseGroup::containsWarehouse(locDirTable.WarehouseGroupId, tmpInventLocationId))
                {
                    continue;
                }


                // Set previously mandatory fields, to avoid impacting downstream consumers
                locDirTable.InventSiteId = inventSiteId;
                locDirTable.InventLocationId = tmpInventLocationId;               

                this.onLocationDirectiveVisited(locDirTable);

                if (!this.isLocationDirectiveApplicable(locDirTable, _itemId, _dispositionCode))
                {
                    continue;
                }

                if (findPickPutLocationPerformanceTask)
                {
                    findPickPutLocationPerformanceTask.locDirVisited(locDirTable.Scope);
                }

                if (!lpInformation
                    &&  WHSLocationDirective::isLocatingWholeLPSupported(locDirTable.WorkTransType)
                    &&  this.isLocatingWholeLP())
                {
                    WHSLocDirLocateBy locateBy = WHSLicensePlateLocDirInformation::isWholeLPAvailable(targetLicensePlateId, shipmentId);

                    // If the location directive locateBy matches the type of license plate
                    // continue checking location directive
                    if (locateBy == locDirTable.LocateBy)
                    {
                        // Only need to initiate this class once
                        using (var context = WHSTransferReceiptASNFlight::instance().isEnabled() ? WHSLicensePlateLocDirInformationContext::construct(this.getWHSModule(locDirTable.WorkTransType)) : null)
                        {
                            lpInformation = WHSLicensePlateLocDirInformation::newLicensePlate(locateBy, targetLicensePlateId, shipmentId);
                        }
                    }
                    else
                    {
                        continue;
                    }
                }

                if (this.hasLocDirMatches(_itemId, _inventTransId, inventDim))
                {
                    matchingDirective = this.loopLocDirLines(locateQty, locateUOM, _inventTransId, inventDim, buildQty, _guidedLicensePlates);

                    if (matchingDirective)
                    {
                        usedLocateByLP = this.isLocatingWholeLP();
                        break;
                    }
                }
                else
                {
                    this.createWorkHistoryLine(_itemId,
                                               locateQty,
                                               locateUOM,
                                               strFmt("@WAX1741", locDirTable.LocDirName),
                                               true,
                                               inventDim.InventStatusId);
                }

                locSeqNumLocDirTable    = locDirTable.LocSeqNum;
                locSeqNumLocDirLine     = 0;
                locSeqNumLocDirAction   = 0;
            }

            ttscommit;

            return matchingDirective;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>getWHSModule</Name>
				<Source><![CDATA[
    private WHSModule getWHSModule(WHSWorkTransType _workTransType)
    {
        switch (_workTransType)
        {
            case WHSWorkTransType::Purch:
                return WHSModule::Purch;
            case WHSWorkTransType::TransferReceipt:
                return WHSModule::Transfer;
            default:
                return WHSModule::Purch;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocationDirectiveApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Defines if <paramref name="_locDirTable"/> is applicable for finding a location directive match.
    /// </summary>
    /// <param name = "_locDirTable">A location directory table instance.</param>
    /// <param name = "_itemId">The item ID of the <c>WHSInventTable</c>.</param>
    /// <param name = "_dispositionCode">A disposition code.</param>
    /// <returns>true if <paramref name="_locDirTable"/> is applicable for finding location directive match; otherwise, false.</returns>
    /// <remarks>Can be used to filter the original query.</remarks>
    protected boolean isLocationDirectiveApplicable(WHSLocDirTable _locDirTable, ItemId _itemId, WHSDispositionCode _dispositionCode)
    {
        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findLocationEnumeratorMultiSKU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a multi-sku location defined in location directives that is created for a specific type of work.
    /// </summary>
    /// <param name="_inventSiteId">
    /// Site id of the location.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location.
    /// </param>
    /// <param name="_workType">
    /// Type of the work.
    /// </param>
    /// <param name="_workTransType">
    /// Transaction type of the work.
    /// </param>
    /// <param name="_locDirHintCode">
    /// Location directives hint code.
    /// </param>
    /// <param name="_dispositionCode">
    /// Disposition code defined in location directives.
    /// </param>
    /// <param name="_restart">
    /// Determines whether the search for location should be started from beginning.
    /// </param>
    /// <returns>
    /// An enumerator of the locations that are defined in location directive.
    /// </returns>
    protected WhsLocationDirectiveActionQueryEnumerator findLocationEnumeratorMultiSKU(InventSiteId         _inventSiteId,
                                   InventLocationId     _inventLocationId,
                                   WHSWorkType          _workType,
                                   WHSWorkTransType     _workTransType,
                                   WHSLocDirHintCode    _locDirHintCode,
                                   WHSDispositionCode   _dispositionCode,
                                   boolean              _restart)
    {
        if (_restart)
        {
            locSeqNumLocDirLine   = 0;
            locSeqNumLocDirTable  = 0;
            locSeqNumLocDirAction = 0;
        }
        
        boolean isSingleOrder = orderNum != '';

        while select locDirTable
            order by locDirTable.LocSeqNum
            where locDirTable.WorkType          == _workType            &&
                  locDirTable.WorkTransType     == _workTransType       &&
                  ((locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::Warehouse && locDirTable.InventSiteId == _inventSiteId && locDirTable.InventLocationId == _inventLocationId) ||
                   (locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::Group) ||
                   (locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::All)) &&
                  locDirTable.LocDirHintCode    == _locDirHintCode      &&
                  (locDirTable.MultiSKU         == NoYes::Yes           || 
                   locDirTable.Scope             == WhsLocationDirectiveScope::All ||
                   locDirTable.Scope             == WhsLocationDirectiveScope::MultiItem ||
                  (isSingleOrder && locDirTable.Scope == WhsLocationDirectiveScope::SingleOrder))        &&
                  locDirTable.LocSeqNum          > locSeqNumLocDirTable &&
                  (!_dispositionCode                                    ||
                   locDirTable.DispositionCode  == _dispositionCode)    &&
                  (!clusteredWorkId                                     ||
                   locDirTable.LocateBy         == WHSLocDirLocateBy::Cluster)
        {
            if (locDirTable.WarehouseGroupAll == WhsWarehouseGroupAll::Group &&
                !WhsWarehouseGroup::containsWarehouse(locDirTable.WarehouseGroupId, _inventLocationId))
            {
                continue;
            }

            // Set previously mandatory fields, to avoid impacting downstream consumers
            locDirTable.InventSiteId = _inventSiteId;
            locDirTable.InventLocationId = _inventLocationId;

            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.locDirVisited(locDirTable.Scope);
            }

            if (isSingleOrder && 
                locDirTable.Scope == WhsLocationDirectiveScope::SingleOrder)
            {
                if (!this.hasLocDirMatches())
                {
                    continue;
                }
            }

            WHSLocDirLine locDirLine;

            while select locDirLine
                order by locDirLine.LocSeqNum
                where locDirLine.RefRecId       == locDirTable.RecId &&
                      locDirLine.LocSeqNum      >  locSeqNumLocDirLine
            {
                if (findPickPutLocationPerformanceTask)
                {
                    findPickPutLocationPerformanceTask.locDirLineVisited();
                }

                WHSLocDirAction locDirAction;

                while select locDirAction
                    order by locDirAction.LocSeqNum
                    where locDirAction.RefRecId     == locDirLine.RecId &&
                            locDirAction.LocSeqNum    >  locSeqNumLocDirAction
                {
                    if (findPickPutLocationPerformanceTask)
                    {
                        findPickPutLocationPerformanceTask.locDirActionVisited();
                    }

                    WhsLocationDirectiveMultiSkuActionQuery actionQuery = WhsLocationDirectiveMultiSkuActionQuery::newFromParameters(
                        locDirTable,
                        locDirLine,
                        locDirAction);

                    WhsLocationDirectiveActionQueryEnumerator enumerator = actionQuery.getEnumerator();
                    if (enumerator.hasHits())
                    {
                        locSeqNumLocDirAction = locDirAction.LocSeqNum;
                        locDirNameAction = locDirAction.LocDirName;
                        return enumerator;
                    }
                }

                locSeqNumLocDirLine = locDirLine.LocSeqNum;
                locSeqNumLocDirAction = 0;
            }

            locSeqNumLocDirTable  = locDirTable.LocSeqNum;
            locSeqNumLocDirLine  = 0;
            locSeqNumLocDirAction = 0;
        }
        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the pick and put locations based on location directives
    /// </summary>
    /// <param name="_inventDimId">
    /// The invent dim id passed in used to lookup the location
    /// </param>
    /// <param name="_inventTransId">
    /// The invent trans id passed in used to lookup the location
    /// </param>
    /// <param name="_itemId">
    /// The item id passed in used to lookup the location
    /// </param>
    /// <param name="_inventQty">
    /// The quantity for which pick/put should be performed
    /// </param>
    /// <param name="_workTransType">
    /// The <c>WHSWorkTransType</c> for the work
    /// </param>
    /// <param name="_workType">
    /// The <c>WHSWorkType</c> for the work
    /// </param>
    /// <param name="_locDirHintCode">
    /// The location directive code  id passed in used to lookup the location
    /// </param>
    /// <param name="_packingQty">
    /// The packing qty of the item
    /// </param>
    /// <param name="_excludeLocationId">
    /// The locations that should be excluded
    /// </param>
    /// <param name="_account">
    /// The customer/vendor account associated
    /// </param>
    /// <param name="_inventBatchId">
    /// The invent batch id passed in used to lookup the location
    /// </param>
    /// <param name="_dispositionCode">
    /// The disposition code passed in used to lookup the location directive
    /// </param>
    /// <param name="_guidedLicensePlates">
    /// A list of license plates which need to be picked - only valid for location directive strategy GuidedLPLocate
    /// </param>
    /// <param name="_targetLicensePlateId">
    /// The target license plate Id from the work.
    /// </param>
    /// <param name="_inventSiteId">
    /// The site which is used to query location directive when _inventDimId is AllBlank dimensions.
    /// </param>
    /// <param name="_inventLocationId">
    /// The warehouse which is used to query location directive when _inventDimId is AllBlank dimensions.
    /// </param>
    /// <returns>
    /// A container with the location, quantity and unit of measure found after executing location directives
    /// </returns>
    container findPickPutLocation(
        InventDimId         _inventDimId,
        InventTransId       _inventTransId,
        ItemId              _itemId,
        WHSInventQty        _inventQty,
        WHSWorkTransType    _workTransType,
        WHSWorkType         _workType,
        WHSLocDirHintCode   _locDirHintCode,
        WHSPackingQty       _packingQty,
        Set                 _excludeLocationId = null,
        CustVendAC          _account = '',
        InventBatchId       _inventBatchId = '',
        WHSDispositionCode  _dispositionCode = '',
        List                _guidedLicensePlates = null,
        WHSLicensePlateId   _targetLicensePlateId = '',
        InventSiteId        _inventSiteId = '',
        InventLocationId    _inventLocationId = '')
    {
        boolean                 noLocation  = true;
        Qty                     inWorkQty;
        InventDimId             checkFullAllocationDimId;
        WMSLocationId           finalLocationId;
        Qty                     tmpQty;
        Qty                     finalQty;
        Qty                     finalInventQty;
        UnitOfMeasureSymbol     finalUOM;
        boolean                 canConvertStockingUOM;
        WHSLocationProfile      locationProfile;
        boolean                 isContainerLimit;
        boolean                 useExistLimitContext = WHSLocationDirectiveStockLimitZeroQtyV2Flight::instance().isEnabled();

        if (!_itemId)
        {
            throw error("@WAX774");
        }

        if (_workType != WHSWorkType::Pick && _workType != WHSWorkType::Put)
        {
            throw error("@WAX754");
        }

        var inventDim = InventDim::find(_inventDimId);
        var item = InventTable::find(_itemId);
        InventLocationId inventLocationId = inventDim.InventLocationId ? inventDim.InventLocationId : _inventLocationId;
        var warehouse = InventLocation::find(InventLocationId);

        using (var perfTask = WHSInstrumentationFindPickPutLocationPerformanceTask::newFindPickPutLocation(warehouse, item, _workType, _workTransType, isAcceptanceTest))
        using (var appInsightsActivity = WHSLocationDirectiveFindLocationApplicationInsightsActivity::newFromParameters(_workTransType, _workType, item, workBuildId, tmpWorkLine.OrderNum, tmpWorkLine.LoadId, shipmentId, _inventQty))
        {
            findPickPutLocationPerformanceTask = perfTask;

            ttsbegin;

            // Set global values
            inventQty       = _inventQty;
            workType        = _workType;
            workTransType   = _workTransType;
            itemId          = _itemId;
            inventUOM       = WHSCatchWeightHelper::inventHandlingUnitId(itemId);
            inventBatchId   = _inventBatchId;
            custVendAccount = _account;
            statusId        = inventDim.InventStatusId; // Used for Work Creation History Log.
            batchControlled = item.whsBatchActive();

            WHSCreateRemainingLinesCommonDimensionsContext remainingLinesCommonDimensionsContext = WHSCreateRemainingLinesCommonDimensionsContext::current();
            if (remainingLinesCommonDimensionsContext && !statusId)
            {
                statusId = remainingLinesCommonDimensionsContext.parmInventStatusId();
            }

            initialInventDimId = _inventDimId;

            targetLicensePlateId    = _targetLicensePlateId;
            latestMatchingDirective = null;

            prevDimensions.clear();
            this.parmFEFOBatchId('');
            this.parmLocatedLP('');

            WHSContainerTypeCode containerTypeCode = WHSLicensePlate::find(targetLicensePlateId).ContainerTypeCode;

            WhsLocationDirectiveMatch matchingDirective = this.findLocation(
                                                                    _inventTransId,
                                                                    _inventDimId,
                                                                    _itemId,
                                                                    _locDirHintCode,
                                                                    _dispositionCode,
                                                                    _packingQty,
                                                                    true,
                                                                    _guidedLicensePlates,
                                                                    _inventSiteId,
                                                                    _inventLocationId);

            real roundingUnit = 1;
            if(replenRoundingUOM)
            {
                int decimals = UnitOfMeasure::findBySymbol(replenRoundingUOM).DecimalPrecision;
                roundingUnit = 1 / power(10, decimals);
            }
   
            WhsLocationDirectiveConcurrencyFilter concurrencyFilter = WhsLocationDirectiveConcurrencyFilter::construct();

            while (matchingDirective && noLocation)
            {
                latestMatchingDirective = matchingDirective;
                perfTask.locDirActionExecuted();

                boolean lockAcquired;
                str lockName;
                InventHandlingQty originalInventQty = inventQty;

                using (var locationDirectiveActivityContext = instrumentationLogger.locationDirectiveActivities().executeLocationDirective(matchingDirective.strategy))
                {
                    concurrencyFilter.init(
                                    this.shouldLocationBeLockedForLocDirStrategy(matchingDirective.strategy),
                                    perfTask,
                                    matchingDirective,
                                    this);

					while (matchingDirective.enumerator.moveNext() && noLocation)
                    {
                        perfTask.locationEvaluated();
                        appInsightsActivity.locationEvaluated();

                        // Release lock for previous location
                        if (lockAcquired)
                        {
                            ReqReaderWriterLock::releaseSQLLock(lockName);
                            lockAcquired = false;
                        }

                        concurrencyFilter.applicableLocationRejected();

                        location = matchingDirective.enumerator.currentWmsLocation();
                        this.onLocationEvaluated(location);


                        if (workType == WHSWorkType::Pick)
                        {
                            inventDim = matchingDirective.enumerator.currentInventDim();
                            inventBatchId = inventDim.InventBatchId;

                            // Check if location is already empty
                            // If strategy requires more than location, check the found inventDim
                            if (this.doesStrategyRelyBelowLocationDimension(matchingDirective.strategy))
                            {
                                checkFullAllocationDimId = inventDim.inventDimId;
                            }
                            else
                            {
                                checkFullAllocationDimId = _inventDimId;
                            }

                            if (this.isLocationFullyAllocated(checkFullAllocationDimId, location.wmsLocationId, itemId))
                            {
                                continue;
                            }
                        }

                        if (!this.validateCurrentLocation(matchingDirective.strategy, inventDim, matchingDirective.useFixedProductLocations, _excludeLocationId, matchingDirective.useFixedVariantLocations, _inventDimId))
                        {
                            continue;
                        }

                        inventDim.clear();
                        inventDim = InventDim::find(_inventDimId);

                        // If the location directive allow for negative, check if location profile and item do too.
                        if (_workType == WHSWorkType::Pick && matchingDirective.allowNegative)
                        {
                            if (location.whsLocationProfile().AllowNegative && InventTable::find(_itemId).whsAllowPhysNeg())
                            {
                                finalLocationId = location.wmsLocationId;
                                finalQty = inventQty;
                                finalUOM = inventUOM;
                                finalInventQty = inventQty;
                                noLocation = false;
                                break;
                            }
                        }

                        // Start checking the quantities
                        tmpQty = conPeek(conPeek(matchingDirective.buildQty, 1), #BuildQtyQty);
                        locatedUOM = conPeek(conPeek(matchingDirective.buildQty, 1), #BuildQtyUOM);

                        // Convert findQty to the Invent UOM
                        inventFindQty = releasedProductUnitConverter.convertGivenUnitSymbols(tmpQty,
                                                        locatedUOM,
                                                        inventUOM,
                                                        NoYes::No,
                                                        _itemId,
                                                        _inventDimId,
                                                        NoYes::No);

                        boolean isLocationLimitSet;

                        if (_workType == WHSWorkType::Pick)
                        {
                            inventDim.clearInventDimId();
                            inventDim.wmsLocationId = location.wmsLocationId;
                            
                            if (_workTransType == WHSWorkTransType::Replenishment)
                            {
                                WhsLocationDirectiveStrategy strategyClass = WhsLocationDirectiveStrategy::singletonFromStrategy(matchingDirective.strategy);

                                if (strategyClass && strategyClass.requiresBatchDimension())
                                {
                                    inventDim.inventBatchId = inventBatchId;
                                }

                                inventDim = this.getReplenAboveLocDim(inventDim, _itemId, inventQty);
                                // Set replenishment InventDim to the filled dim but without location.
                                replenInventDim.data(inventDim);
                                replenInventDim.wmsLocationId = '';
                                replenInventDim = InventDim::findOrCreate(replenInventDim);
                            }
                    
                            availQty = this.calculateAvailableQuantityForSpecificDimension(_itemId, inventDim);
                        }
                        else //puts
                        {
                            locationProfile = location.whsLocationProfile();

                            // Check target LP container type
                            if (!this.checkTargetLPContainerType(locationProfile))
                            {
                                this.createWorkHistoryLine(_itemId, inventQty, inventUOM, strFmt("@WAX:ErrorContainerTypeLocationDirectiveFailure", location.wmsLocationId), true, statusId);
                                perfTask.containerTypeFailed();
                                continue;
                            }

                            using (var context = useExistLimitContext ? WHSLocationDirectiveIsLocationLimitSetContext::construct() : null)
                            {
                                [allowedQty, allowedUnitId, isContainerLimit] = WHSLocationLimit::retrieveQty(location.InventLocationId,
                                                                                        location.wmsLocationId,
                                                                                        _itemId,
                                                                                        inventUOM,
                                                                                        false, //if no limit is found allowedQty is zero
                                                                                        _inventDimId,
                                                                                        containerTypeCode);

                                isLocationLimitSet = useExistLimitContext ? context.parmExistLocationLimit() : allowedQty != 0;
                            }

                            inventFindQty = this.determineInventQtyForReplenishment(_inventDimId, inventFindQty, inventUOM, roundingUnit);

                            if (workTransType == WHSWorkTransType::Replenishment
                                && originType == WHSOriginType::Wave)
                            {
                                inventQty = inventFindQty;
                            }

                            canConvertStockingUOM = releasedProductUnitConverter.canBeConvertedGivenUnitSymbols(allowedUnitId,
                                                                                            inventUOM,
                                                                                            _itemId,
                                                                                            _inventDimId);

                            //if no limit is found we can get 0; if we found a limit and it allowed unlimited qty we get real max.
                            useStockingLimits = isLocationLimitSet && allowedQty != Global::realMax();

                            if (useStockingLimits)
                            {
                                perfTask.increaseStockingLimitsCounter();                                
                            }

                            if (useStockingLimits)
                            {
                                if (canConvertStockingUOM)
                                {
                                    locationStockLimitQty = releasedProductUnitConverter.convertGivenUnitSymbols(allowedQty,
                                                                                                            allowedUnitId,
                                                                                                            inventUOM,
                                                                                                            NoYes::No,
                                                                                                            _itemId,
                                                                                                            _inventDimId);
                                }
                                else
                                {
                                    locationStockLimitQty = allowedQty;
                                }
                            }
                            else
                            {
                                locationStockLimitQty = Global::realMax();
                            }                            

                            WhsLocationDirectiveConcurrencyFilterParameters parameters = this.createConcurrencyFilterParameters(inventDim.inventBatchId, canConvertStockingUOM, useStockingLimits);

                            if (!concurrencyFilter.isLocationApplicable(parameters))
                            {
                                continue;
                            }
    

                            if (isContainerLimit && !this.validateContainerLimit(containerTypeCode))
                            {
                                perfTask.containerLimitFailed();
                                continue;
                            }

                            // If we can convert from the stocking UOM to the inventory UOM for the item then we convert availQty so it will in the same UOM as
                            if (canConvertStockingUOM)
                            {
                                availQty = releasedProductUnitConverter.convertGivenUnitSymbols(availQty,
                                                                            allowedUnitId,
                                                                            inventUOM,
                                                                            NoYes::No,
                                                                            _itemId,
                                                                            _inventDimId);
                            }
                        }

                        // Get the total quantity currently in the temp table; returned in the inventUOM.
                        inWorkQty = WHSLocationDirective::getTotalInTempTable(location.inventLocationId,
                                                                                location.wmsLocationId,
                                                                                inventDim,
                                                                                inventUOM,
                                                                                _itemId,
                                                                                _workType);

                        availQty -= inWorkQty;

                        InventQty maxAvailabilityForBatchItems = this.calculateMaxAvailabilityForBatchItems(item, inventDim, _inventTransId, _account, matchingDirective);
                        availQty = min(availQty, maxAvailabilityForBatchItems);

                        // Use location directive strategies.
                        if (!this.performStrategy(matchingDirective.strategy, inventDim, inWorkQty))
                        {
                            this.createWorkHistoryLine(_itemId, inventQty, inventUOM, strFmt("@WAX2092", location.wmsLocationId), true, statusId);
                            perfTask.strategyFailed();
                            continue;
                        }

                        // If no stocking limits were specified, use volumetric for locating put
                        if (!isLocationLimitSet && _workType == WHSWorkType::Put)
                        {
                            boolean isVolumetricsEnabledForLocation = WHSLocationProfile::isVolumetricsEnabledForProfileId(location.LocProfileId);
                            
                            if (isVolumetricsEnabledForLocation)
                            {
                                using (var volumetricsActivityContext = instrumentationLogger.locationDirectiveActivities().volumetricsCalculation())
                                {
                                    perfTask.increaseVolumetricsCounter();

                                    if (WHSVolumetricsPutawayValidator::canLocationBeSkippedAsItCannotFitAnyQtyForThisItem(location, _itemId, _inventDimId))
                                    {
                                        perfTask.volumetricsSkipped();
                                        continue;
                                    }                            

                                    availQty = this.validateVolumetricsHandlingUnit(location.wmsLocationId,
                                                                        location.InventLocationId,
                                                                        _itemId,
                                                                        inventQty,
                                                                        matchingDirective.allowSplit,
                                                                        _inventDimId,
                                                                        WHSCatchWeightHelper::inventHandlingUnitId(_itemId),
                                                                        '');

                                    boolean skipVolumetricsFailure = tmpWorkLine.isReplenishmentOverflowWorkLine(location);

                                    if (!availQty && !skipVolumetricsFailure)
                                    {
                                        perfTask.volumetricsFailed();
                                        continue;
                                    }
                                }
                            }
                            else
                            {
                                availQty = inventQty;

                                if (!availQty)
                                {
                                    continue;
                                }
                            }
                        }

                        // If the strategy requires more than location must insert appropriate dim.
                        if (_workType == WHSWorkType::Pick
                            && availQty  <= 0)
                        {
                            this.insertFullyAllocatedLocation(checkFullAllocationDimId, location.wMSLocationId, itemId);
                        }

                        using (var volumetricsActivityContext = instrumentationLogger.locationDirectiveActivities().getFinalLocationAndQuantity())
                        {
                            boolean skipCurrentLocationDirective = false;
                            [finalLocationId, finalQty, finalUOM, finalInventQty, skipCurrentLocationDirective] = this.getFinalLocationAndQuantity(
                                                                                                                                        _inventDimId,
                                                                                                                                        _itemId,
                                                                                                                                        matchingDirective,
                                                                                                                                        _packingQty,
                                                                                                                                        canConvertStockingUOM);
                
                            if (skipCurrentLocationDirective)
                            {
                                continue;
                            }
                        }

                        if (finalQty)
                        {
                            noLocation = false;
                        }

                        // Check Batch requirements
                        if (!noLocation && batchControlled)
                        {
                            // If the location doesn't allow for mixed batches, make sure there isn't
                            // another batch already in this location.
                            if (_workType == WHSWorkType::Put
                                &&  !this.validateBatchMixingOnLocation(_itemId, _inventBatchId, _inventTransId, finalLocationId))
                            {
                                finalLocationId = '';
                                finalInventQty  = 0;
                                finalQty        = 0;
                                finalUOM        = '';
                                noLocation = true;
                                this.createWorkHistoryLine(_itemId, inventQty, inventUOM, strFmt("@WAX1748", location.wmsLocationId), true, statusId);
                                perfTask.batchMixingFailed();
                                continue;
                            }
                        }

                        // Check Dock Management Rules
                        if (!this.isDockManagmentMixingValidForPutLocation(noLocation, _workType))
                        {
                            finalLocationId = '';
                            finalInventQty  = 0;
                            finalQty        = 0;
                            finalUOM        = '';
                            noLocation = true;
                            this.createWorkHistoryLine(_itemId, inventQty, inventUOM, strFmt("@WAX3913", location.wmsLocationId), true, statusId);
                            perfTask.dockManagementMixingFailed();
                        }

                        if (!noLocation)
                        {
                            this.createWorkHistoryLine(_itemId, inventQty, inventUOM,
                                                        strFmt("@WAX1750", finalLocationId, finalQty, finalUOM),
                                                        false,
                                                        statusId);
                            break;
                        }
                    }
                }

                // If not enough quantity check for immediate replenishment
                if (noLocation
                &&  matchingDirective.immediateReplenishmentTemplateId
                &&  !skipImmedReplen)
                {
                    this.logLocationDirectiveHasImmediateReplenishmentWorkHistoryLine(_workTransType);
                    
                    [finalLocationId, finalQty, finalUOM, finalInventQty, noLocation] = this.runImmediateDemandReplen(matchingDirective, _inventDimId);
                    perfTask.locDirActionHasImmediateReplenishment()
                        .setImmediateReplenishmentSucceeded(!noLocation);
                }
   
                if (noLocation)
                {
                    prevDimensions.clear();
                    this.parmFEFOBatchId('');
                    this.parmLocatedLP('');

                    // Release lock for the location
                    if (lockAcquired)
                    {
                        ReqReaderWriterLock::releaseSQLLock(lockName);
                        lockAcquired = false;
                    }

                    concurrencyFilter.applicableLocationRejected();

                    if (workTransType == WHSWorkTransType::Replenishment
                        && originType == WHSOriginType::Wave
                        && _workType == WHSWorkType::Put)
                    {
                        // For replenishment put, the variable inventQty can have its value overridden based on a calculation specific for a location.
                        // In case that location is not selected as replenishment put location, when changing the matchingDirective variable,
                        // the system should reset the value of the variable inventQty to its original value
                        // so it is avoided that a previous location calculation is determining the quantity for a different location.

                        inventQty = originalInventQty;
                    }

                    matchingDirective = this.findLocation(
                        _inventTransId,
                        _inventDimId,
                        _itemId,
                        _locDirHintCode,
                        _dispositionCode,
                        _packingQty,
                        false);
                }
            }

            if (finalLocationId)
            {
                this.onLocationFound(finalLocationId);
            }
            else
            {
                this.logWorkCreateHistoryItemAllocationFailures(_itemId, _workTransType, _workType);

                if (waveExecutionId)
                {
                    WHSPostEngine::createWaveExecutionHistoryLine(tmpWorkLine.WaveId, waveExecutionId, strFmt("@WAX2620", _itemId), true, tmpWorkLine);
                }
            }

            ttscommit;

            findPickPutLocationPerformanceTask = null;

            appInsightsActivity.addFoundLocationIdProperty(finalLocationId);
            appInsightsActivity.addFoundInventoryQuantityProperty(finalInventQty);
            appInsightsActivity.addFoundQuantityProperty(finalQty);
            appInsightsActivity.addFoundUnitOfMeasureProperty(finalUOM);
        }

        return [finalLocationId, finalQty, finalUOM, finalInventQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>createConcurrencyFilterParameters</Name>
				<Source><![CDATA[
    private WhsLocationDirectiveConcurrencyFilterParameters createConcurrencyFilterParameters(InventBatchId _inventBatchId, boolean _canConvertStockingUOM, boolean _useStockingLimits)
    {
        WhsLocationDirectiveConcurrencyFilterParameters parameters = WhsLocationDirectiveConcurrencyFilterParameters::construct();
        parameters.shouldLocationBeLockedForDockMgmtValidation = this.shouldLocationBeLockedForDockMgmtValidation();
        parameters.shouldLocationBeLockedForMixedConstraint = this.shouldLocationBeLockedForImmediateReplenishmentPut();
        parameters.itemBatchStatusCombination = this.getItemStatusBatchCombination(_inventBatchId);
        parameters.canConvertStockingUOM = _canConvertStockingUOM;
        parameters.useStockingLimits = _useStockingLimits;
        parameters.location = location;
        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createConcurrencyFilterParametersMultiSKU</Name>
				<Source><![CDATA[
    private WhsLocationDirectiveConcurrencyFilterParameters createConcurrencyFilterParametersMultiSKU()
    {
        WhsLocationDirectiveConcurrencyFilterParameters parameters = WhsLocationDirectiveConcurrencyFilterParameters::construct();

        parameters.isMultiSKU = true;
        parameters.shouldLocationBeLockedForDockMgmtValidation = this.shouldLocationBeLockedForDockMgmtValidation();
        parameters.location = location;

        return parameters;
    }

]]></Source>
			</Method>
			<Method>
				<Name>testLocationMixingConstraintsInCommittedDelta</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal boolean testLocationMixingConstraintsInCommittedDelta(
        WHSInstrumentationFindPickPutLocationPerformanceTask _perfTask,
        WhsLocationDirectiveMatch _matchingDirective,
        boolean _canConvertStockingUOM,
        boolean _useStockingLimits)
    {
        var locationProfile = location.whsLocationProfile();

        if (!this.checkStatus(statusId, locationProfile))
        {
            this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX3388", location.wmsLocationId), true, statusId);
            _perfTask.statusMixingFailed();
            return false;
        }

        if (!this.validateMixingRulesAndStockingLimitInternal(itemId, initialInventDimId, locationProfile, _matchingDirective.allowSplit, allowedQty, allowedUnitId, inventFindQty, inventUOM, _canConvertStockingUOM, _useStockingLimits))
        {
            _perfTask.mixingRulesStockingLimitFailed();
            return false;
        }

        if (!this.validateIsItemMixTmpWorkLine(InventDim::find(initialInventDimId)))
        {
            _perfTask.itemMixTmpWorkLineFailed();
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createMixingRulesViolationWorkHistoryLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void createMixingRulesViolationWorkHistoryLine()
    {
        this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX:LocationSkippedViolateMixingRules", location.wmsLocationId), true, statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createLockStrategyViolationWorkHistoryLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void createLockStrategyViolationWorkHistoryLine()
    {
        this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX:LocationSkippedAnotherWorker", location.wmsLocationId), true, statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDockManagementViolationWorkHistoryLine</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal void createDockManagementViolationWorkHistoryLine()
    {
        this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX:LocationSkippedDockManagementValidation", location.wmsLocationId), true, statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>createDockManagementViolationWorkHistoryLineMultiSKU</Name>
				<Source><![CDATA[
    internal void createDockManagementViolationWorkHistoryLineMultiSKU()
    {
        this.createWorkHistoryLine('', inventQty, inventUOM, strFmt("@WAX3913", location.wmsLocationId), true);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateAvailableQuantityForSpecificDimension</Name>
				<Source><![CDATA[
    /// <summary>
    /// Calculates the available quantity for an item with given dimensions.
    /// </summary>
    /// <param name = "_itemId">The item.</param>
    /// <param name = "_inventDim">The item dimensions.</param>
    /// <returns>The available quantity.</returns>
    protected InventQty calculateAvailableQuantityForSpecificDimension(ItemId _itemId, InventDim _inventDim)
    {
        return WHSInventOnHand::getWorkPhysicalAvailHandlingQtyByInventDim(_itemId, _inventDim, false);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateMaxAvailabilityForBatchItems</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventQty calculateMaxAvailabilityForBatchItems(
        InventTable                 _item,
        InventDim                   _inventDim,
        InventTransId               _inventTransId,
        CustVendAC                  _account,
        WhsLocationDirectiveMatch   _matchingDirective)
    {
        // Find the available quantity for batch enabled items based on expiration date.
        if (this.isAvailableQuantityExpirationDateControlled(_inventTransId, workTransType, workType))
        {
            InventDim inventDimCriteria = this.inventDimCriteriaForValidSellableDaysQty(_matchingDirective, _item.ItemId, location, inventBatchId);
            
            inventDimCriteria.initProductDimensionsFromInventTable(_item, _inventDim);
            inventDimCriteria = inventDim::findOrCreate(inventDimCriteria);

            return this.getValidSellableDaysQty(_item, _inventDim, inventDimCriteria, _account);
        }

        //No restrictions
        return maxInt();
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLocationBeLockedForLocDirStrategy</Name>
				<Source><![CDATA[
    private boolean shouldLocationBeLockedForLocDirStrategy(WHSLocDirStrategy _strategy)
    {
        return workType == WHSWorkType::Put &&
               _strategy== WHSLocDirStrategy::UnallocatedLocation;
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLocationBeLockedForImmediateReplenishmentPut</Name>
				<Source><![CDATA[
    private boolean shouldLocationBeLockedForImmediateReplenishmentPut()
    {
        WHSLocationProfile locationProfile = location.whsLocationProfile();
        WHSRunImmediateReplenishmentContext context = WHSRunImmediateReplenishmentContext::current();

        return context 
                && context.runImmediateReplenishment
                && workType == WHSWorkType::Put
                && workTransType == WHSWorkTransType::Replenishment
                && (!locationProfile.AllowMixedItems
                    || !locationProfile.AllowMixedBatches
                    || !locationProfile.AllowMixedStatus);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getItemStatusBatchCombination</Name>
				<Source><![CDATA[
    private str getItemStatusBatchCombination(InventBatchId _inventBatchId)
    {
        WHSLocationProfile locationProfile = location.whsLocationProfile();

        return strFmt('%1_%2_%3',
            locationProfile.AllowMixedItems ? '' : itemId,
            locationProfile.AllowMixedBatches ? '' : _inventBatchId,
            locationProfile.AllowMixedStatus ? '' : statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>shouldLocationBeLockedForDockMgmtValidation</Name>
				<Source><![CDATA[
    private boolean shouldLocationBeLockedForDockMgmtValidation()
    {
        if (workType == WHSWorkType::Put)
        {
            WHSParameters      parameters      = WHSParameters::find();
            WHSLocationProfile locationProfile = WHSLocationProfile::find(location.LocProfileId);

            if ((locationProfile.LocType == parameters.StageLocType || locationProfile.LocType == parameters.ShipFinalLocType)
                && locationProfile.DockMgmtProfileId
                && !locationProfile.whsDockMgmtProfile().AssumeEmptyForWave)
            {
                return true;
            }
        }

        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>logLocationDirectiveHasImmediateReplenishmentWorkHistoryLine</Name>
				<Source><![CDATA[
    private void logLocationDirectiveHasImmediateReplenishmentWorkHistoryLine(WHSWorkTransType _workTransType)
    {
        WHSWorkCreateHistory::createWorkHistoryLineFromTmpWorkLine(workBuildId,
            strFmt("@WAX:WHSLocationDirectiveHasImmediateReplenishment", _workTransType),
            false,
            tmpWorkLine);
    }

]]></Source>
			</Method>
			<Method>
				<Name>logWorkCreateHistoryItemAllocationFailures</Name>
				<Source><![CDATA[
    private void logWorkCreateHistoryItemAllocationFailures(ItemId _itemId, WHSWorkTransType _workTransType, WHSWorkType _workType)
    {
        this.createWorkHistoryLine(itemId,
                                    inventQty,
                                    inventUOM,
                                    strFmt("@WAX:WHSItemAllocationFailedForWorkOrderType", _itemId, _workTransType, _workType),
                                    true,
                                    statusId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isAvailableQuantityExpirationDateControlled</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the available quantity must be controlled by the expiration date.
    /// </summary>
    /// <param name="_inventTransId">
    /// The invent trans id for the work.
    /// </param>
    /// <param name="_workTransType">
    /// The <c>WHSWorkTransType</c> for the work.
    /// </param>
    /// <param name="_workType">
    /// The <c>WHSWorkType</c> for the work.
    /// </param>
    /// <returns>true if the available quantity must be controlled by the expiration date; otherwise, false.</returns>
    protected boolean isAvailableQuantityExpirationDateControlled(InventTransId _inventTransId, WHSWorkTransType _workTransType, WHSWorkType _workType)
    {
        return batchControlled &&
               availQty > 0 &&
               _workTransType == WHSWorkTransType::Sales &&
               _workType == WHSWorkType::Pick;
    }

]]></Source>
			</Method>
			<Method>
				<Name>runImmediateDemandReplen</Name>
				<Source><![CDATA[
    private container runImmediateDemandReplen(
        WhsLocationDirectiveMatch _matchingDirective,
        InventDimId               _inventDimId)
    {
        WMSLocationId       localFinalLocationId;
        Qty                 workCreatedQty;
        boolean             noLocation = true;

        // If immediate replenishment already ran for the same tmpWorkLine the fields are still set and need to be removed.
        tmpWorkLine.WMSLocationId = '';
        tmpWorkLine.ExtraInventHandlingQty = 0;

        container con = WhsWorkCreateReplenishment::runImmediateDemandReplen(tmpWorkLine,
                                                                             _matchingDirective,
                                                                             _inventDimId,
                                                                             releaseToWarehouseId,
                                                                             waveExecutionId);

        if (con != conNull())
        {
            [tmpWorkLine,
             localFinalLocationId,
             noLocation,
             workCreatedQty,
             usedImmedReplen,
             immedReplenUsedExistingReplen,
             onlyExistingImmedReplenUsed] = con;

            availQty += workCreatedQty;
        }

        return [localFinalLocationId,
                tmpWorkLine.DirectiveQty,
                tmpWorkLine.DirectiveUOM,
                tmpWorkLine.InventQty,
                noLocation];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getFinalLocationAndQuantity</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks a location using a location directive.
    /// </summary>
    /// <param name = "_inventDimId">The invent dim id passed in used to lookup the location.</param>
    /// <param name = "_itemId">The item id passed in used to lookup the location.</param>
    /// <param name = "_matchingDirective"> A matching location directive.</param>
    /// <param name = "_packingQty">The packing qty of the item.</param>
    /// <param name = "_canConvertStockingUOM">A boolean indicating whether it's allowed to convert from the stocking UOM to the inventory UOM for the item.</param>
    /// <returns>A container with the location, quantity ,unit of measure and whether to skip the current directive.</returns>
    [Replaceable]
    protected container getFinalLocationAndQuantity(
        InventDimId               _inventDimId,
        ItemId                    _itemId,
        WhsLocationDirectiveMatch _matchingDirective,
        Qty                       _packingQty,
        boolean                   _canConvertStockingUOM)
    {
        WMSLocationId       finalLocationId;
        Qty                 finalQty;
        UnitOfMeasureSymbol finalUOM;
        Qty                 finalInventQty;
        boolean             skipCurrentLocationDirective = false;

        if (this.quantityFitsInOneLocation(_canConvertStockingUOM))
        {
            if (_canConvertStockingUOM
                    &&  this.isLocatingWholeLP()
                    &&  availQty < lpInformation.getQtyOnLicensePlate())
            {
                this.createWorkHistoryLine(_itemId, inventQty, inventUOM, strFmt("@WAX:LocateWholeLPLocationDirectiveFailure", location.wMSLocationId), true, statusId);
            }

            if (!_matchingDirective.locatePackingQty || (_matchingDirective.locatePackingQty && !_packingQty))
            {
                finalQty = releasedProductUnitConverter.convertGivenUnitSymbols(inventFindQty,
                                                                        inventUOM,
                                                                        locatedUOM,
                                                                        NoYes::No,
                                                                        _itemId,
                                                                        _inventDimId,
                                                                        NoYes::No);
            }
            else if (inventFindQty >= _packingQty)
            {
                finalQty = releasedProductUnitConverter.convertGivenUnitSymbols(_packingQty,
                                                                        inventUOM,
                                                                        locatedUOM,
                                                                        NoYes::No,
                                                                        _itemId,
                                                                        _inventDimId,
                                                                        NoYes::No);
            }

            // When using restrict by UOM we must keep values as whole numbers; otherwise round value based on locatedUOM decimal precision
            finalQty = _matchingDirective.restrictByUOM ? trunc(finalQty) : roundDownDec(finalQty, UnitOfMeasure::findBySymbol(locatedUOM).DecimalPrecision);

            if (finalQty)
            {
                finalInventQty = releasedProductUnitConverter.convertGivenUnitSymbols(finalQty,
                                                                          locatedUOM,
                                                                          inventUOM,
                                                                          NoYes::No,
                                                                          _itemId,
                                                                          _inventDimId,
                                                                          NoYes::No);
                finalUOM        = locatedUOM;
                finalLocationId = location.wmsLocationId;
            }
        }
        else if (tmpWorkLine.isReplenishmentOverflowWorkLine(location))
        {
            Qty pickingQty = inventFindQty;

            if (_matchingDirective.allowSplit)
            {
                if (availQty > 0)
                {
                    pickingQty = availQty;
                }
                else
                {
                    // returns realMax() if no limits set
                    Qty locationTotalCapacity = this.getLocationTotalCapacityForItem(_itemId);

                    if (locationTotalCapacity <= inventFindQty ||
                        replenishmentTemplateLine.ReplenishmentStrategy == WHSReplenishmentStrategy::WaveDemandMaximumLocationCapacity)
                    {
                        pickingQty = locationTotalCapacity;
                    }
                    else if (replenishmentTemplateLine.ReplenishmentStrategy == WHSReplenishmentStrategy::WaveDemandQuantity)
                    {
                        pickingQty = inventFindQty;
                    }
                }

            }

            finalQty = releasedProductUnitConverter.convertGivenUnitSymbols(pickingQty,
                                                                            inventUOM,
                                                                            locatedUOM,
                                                                            NoYes::No,
                                                                            _itemId,
                                                                            _inventDimId,
                                                                            NoYes::No);

            // When using restrict by UOM we must keep values as whole numbers; otherwise round value based on locatedUOM decimal precision
            finalQty = _matchingDirective.restrictByUOM ? trunc(finalQty) : roundDownDec(finalQty, UnitOfMeasure::findBySymbol(locatedUOM).DecimalPrecision);

            if (finalQty)
            {
                finalInventQty = releasedProductUnitConverter.convertGivenUnitSymbols(finalQty,
                                                                                      locatedUOM,
                                                                                      inventUOM,
                                                                                      NoYes::No,
                                                                                      _itemId,
                                                                                      _inventDimId,
                                                                                      NoYes::No);

                finalUOM        = locatedUOM;
                finalLocationId = location.wmsLocationId;
            }
        }
        else if (!_matchingDirective.allowSplit)
        {
            if (availQty > 0)
            {
                this.createWorkHistoryLine(_itemId, inventQty, inventUOM, strFmt("@WAX1747", location.wmsLocationId), true, statusId);
            }
            skipCurrentLocationDirective = true;
        }
        else if (availQty > 0)
        {
            Qty pickingQty;

            if (!_matchingDirective.locatePackingQty || (_matchingDirective.locatePackingQty && !_packingQty))
            {
                pickingQty = releasedProductUnitConverter.convertGivenUnitSymbols(availQty,
                                                                          inventUOM,
                                                                          locatedUOM,
                                                                          NoYes::No,
                                                                          _itemId,
                                                                          _inventDimId,
                                                                          NoYes::No);
            }
            else if (availQty >= _packingQty)
            {
                pickingQty = releasedProductUnitConverter.convertGivenUnitSymbols(_packingQty,
                                                                          inventUOM,
                                                                          locatedUOM,
                                                                          NoYes::No,
                                                                          _itemId,
                                                                          _inventDimId,
                                                                          NoYes::No);
            }

            if (pickingQty)
            {
                // When using restrict by UOM we must keep values as whole numbers; otherwise round value based on locatedUOM decimal precision
                finalQty = _matchingDirective.restrictByUOM ? trunc(pickingQty) : roundDownDec(pickingQty, UnitOfMeasure::findBySymbol(locatedUOM).DecimalPrecision);

                if (finalQty)
                {
                    finalInventQty  = releasedProductUnitConverter.convertGivenUnitSymbols(finalQty,
                                                                          locatedUOM,
                                                                          inventUOM,
                                                                          NoYes::No,
                                                                          _itemId,
                                                                          _inventDimId,
                                                                          NoYes::No);
                    finalUOM        = locatedUOM;
                    finalLocationId = location.wmsLocationId;
                }
            }
        }

        return [finalLocationId, finalQty, finalUOM, finalInventQty, skipCurrentLocationDirective];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLocationTotalCapacityForItem</Name>
				<Source><![CDATA[
    private Qty getLocationTotalCapacityForItem(ItemId _itemId)
    {
        if (locationTotalCapacityForItemMap == null)
        {
            locationTotalCapacityForItemMap = new Map(Types::Container, Types::Real);
        }

        if (locationTotalCapacityForItemMap.exists([location.RecId, _itemId]))
        {
            return locationTotalCapacityForItemMap.lookup([location.RecId, _itemId]);
        }

        Qty locationCapacity = this.calculateLocationTotalCapacityForItem(_itemId);

        locationTotalCapacityForItemMap.insert([location.RecId, _itemId], locationCapacity);

        return locationCapacity;        
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateLocationTotalCapacityForItem</Name>
				<Source><![CDATA[
    private Qty calculateLocationTotalCapacityForItem(ItemId _itemId)
    {
        if (useStockingLimits)
        {
            return locationStockLimitQty;
        }

        return this.calculateVolumetricsLocationCapacity(_itemId, inventUOM);
    }

]]></Source>
			</Method>
			<Method>
				<Name>calculateVolumetricsLocationCapacity</Name>
				<Source><![CDATA[
    private Qty calculateVolumetricsLocationCapacity(ItemId _itemId, UnitOfMeasureSymbol _unitId)
    {
        Qty     maxWeightQuantity = realMax();
        Qty     maxVolumeQuantity = realMax();

        WHSPhysDimUOM physicalDimensions = WHSPhysDimUOM::getPhysDimUOMByItem(_itemId, _unitId);
        WHSLocationProfile profile = WHSLocationProfile::find(location.LocProfileId);

        if (profile.MaxWeight && physicalDimensions.Weight)
        {
            maxWeightQuantity = profile.MaxWeight / physicalDimensions.Weight;
        }

        if (profile.isVolumeConstraintEnabled())
        {            
            Volume physicalDimensionsVolume = physicalDimensions.displayVolume();
            Volume locationMaxFillVolume = profile.maxFillVolume();

            if (physicalDimensionsVolume && locationMaxFillVolume)
            {
                maxVolumeQuantity = locationMaxFillVolume / physicalDimensionsVolume;
            }
        }

        return min(maxVolumeQuantity, maxWeightQuantity);
    }

]]></Source>
			</Method>
			<Method>
				<Name>quantityFitsInOneLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines whether the quantity of that item would fit in one location.
    /// </summary>
    /// <param name = "_canConvertStockingUOM">A boolean indicating whether it's allowed to convert from the stocking UOM to the inventory UOM for the item.</param>
    /// <returns>true if the  quantity of that item would fit in one location; otherwise, false.</returns>
    protected boolean quantityFitsInOneLocation(boolean _canConvertStockingUOM)
    {
        return availQty >= inventFindQty || (workType == WHSWorkType::Put && !_canConvertStockingUOM);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isDockManagmentMixingValidForPutLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates a dock location for a give work type by checking if there is any mixing with the item to be stored in dock.
    /// </summary>
    /// <param name = "_noLocation">A Boolean value that indicates whether the location was found.</param>
    /// <param name = "_workType">The work type.</param>
    /// <returns>true if there is no mixing for the item; otherwise false.</returns>
    protected boolean isDockManagmentMixingValidForPutLocation(boolean _noLocation, WHSWorkType _workType)
    {
        if (!_noLocation && _workType == WHSWorkType::Put)
        {
            if (!WHSDockManagement::validateDockMgmtMixing(location, tmpWorkLine))
            {
                return false;
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>insertFullyAllocatedLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Inserts a fully allocated location to the map.
    /// </summary>
    /// <param name="_inventDimIdRequested">
    /// An inventDimId for the above location dimensions.
    /// </param>
    /// <param name="_locationId">
    /// The <c>WMSLocationId</c> that has been fully allocated.
    /// </param>
    /// <param name="_itemId">
    /// The <c>ItemId</c> related to the allocated location.
    /// </param>
    private void insertFullyAllocatedLocation(
        InventDimId     _inventDimIdRequested,
        WMSLocationId   _locationId,
        ItemId          _itemId)
    {
        Set set = new Set(Types::Container);

        if (fullyAllocatedLocationsMap == null)
        {
            fullyAllocatedLocationsMap = new Map(Types::String, Types::Class);
        }
        else if (fullyAllocatedLocationsMap.exists(_locationId))
        {
            set = fullyAllocatedLocationsMap.lookup(_locationId);
        }

        set.add([_itemId, _inventDimIdRequested]);

        fullyAllocatedLocationsMap.insert(_locationId, set);
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocatingWholeLP</Name>
				<Source><![CDATA[
    private boolean isLocatingWholeLP()
    {
        return locDirTable.isLocatingWholeLP();
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocationFullyAllocated</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to see if the location has already been evaluated as fully allocated for the item and above location dimension set.
    /// </summary>
    /// <param name="_inventDimIdRequested">
    /// An inventDimId for the above location dimensions.
    /// </param>
    /// <param name="_locationId">
    /// The <c>WMSLocationId</c> to search through the map.
    /// </param>
    /// <param name="_itemId">
    /// The <c>ItemId</c> to search for.
    /// </param>
    /// <returns>
    /// true if the item is in the map and should be skipped because it is fully allocated; otherwise, false.
    /// </returns>
    private boolean isLocationFullyAllocated(
        InventDimId     _inventDimIdRequested,
        WMSLocationId   _locationId,
        ItemId          _itemId)
    {
        boolean         full;

        if (fullyAllocatedLocationsMap != null
        &&  fullyAllocatedLocationsMap.exists(_locationId))
        {
            full = fullyAllocatedLocationsMap.lookup(_locationId).in([_itemId, _inventDimIdRequested]);
        }

        return full;
    }

]]></Source>
			</Method>
			<Method>
				<Name>findPickPutLocationMultiSKU</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds a pick/put location using location directives that has multiple SKU enabled.
    /// </summary>
    /// <param name="_inventLocationId">
    /// Warehouse id of the location directives.
    /// </param>
    /// <param name="_workTransType">
    /// Work transaction type of the location directives.
    /// </param>
    /// <param name="_workType">
    /// Work type of the location directives.
    /// </param>
    /// <param name="_locDirHintCode">
    /// Location directives hint code.
    /// </param>
    /// <param name="_excludeLocationId">
    /// Location id to be excluded from the query result set.
    /// </param>
    /// <param name="_dispositionCode">
    /// Disposition codes defined in location directives.
    /// </param>
    /// <param name="_targetLicensePlateId">
    ///  The target license plate Id from the work.
    /// </param>
    /// <returns>
    /// A container containing the found pick/put location information.
    /// </returns>
    /// <exception cref="Exception::Error">
    /// Exception is thrown when the work type is neither pick or put.
    /// </exception>
    container findPickPutLocationMultiSKU(
        InventLocationId      _inventLocationId,
        WHSWorkTransType      _workTransType,
        WHSWorkType           _workType,
        WHSLocDirHintCode     _locDirHintCode,
        Set                   _excludeLocationId = null,
        WHSDispositionCode    _dispositionCode = '',
        WHSLicensePlateId     _targetLicensePlateId = '')
    {
        container               packedQuery;
        boolean                 noLocation  = true;
        boolean                 restart     = true;
        QueryRun                queryRun;
        WMSLocationId           finalLocationId;
        Qty                     finalQty;
        Qty                     finalInventQty;
        UnitOfMeasureSymbol     finalUOM;
        UnitOfMeasureSymbol     defaultLPUnitId = WHSParameters::find().DefaultLPUOM;
        InventLocation			warehouse = InventLocation::find(_inventLocationId);
        InventSiteId            inventSiteId = warehouse.InventSiteId;
        boolean                 isContainerLimit;
        boolean                 useConcurrencyFilterMultiSKU = _workType == WHSWorkType::Put && WHSLocationDirectiveConcurrencyFilterMultiSKUFlight::instance().isEnabled();

        if (_workType != WHSWorkType::Pick && _workType != WHSWorkType::Put)
        {
            throw error("@WAX754");
        }

        using (var perfTask = WHSInstrumentationFindPickPutLocationPerformanceTask::newFindPickPutLocationMultiSKU(warehouse, _workType, _workTransType))
        {
            findPickPutLocationPerformanceTask = perfTask;

            ttsbegin;

            workType = _workType;
            workTransType = _workTransType;
            targetLicensePlateId = _targetLicenseplateId;

            WhsLocationDirectiveActionQueryEnumerator enumerator = this.findLocationEnumeratorMultiSKU(inventSiteId,
                _inventLocationId,
                _workType,
                _workTransType,
                _locDirHintCode,
                _dispositionCode,
                true);
        
            WHSContainerTypeCode containerTypeCode = WHSLicensePlate::find(targetLicensePlateId).ContainerTypeCode;
            
            WhsLocationDirectiveConcurrencyFilter concurrencyFilter = WhsLocationDirectiveConcurrencyFilter::construct();

            if (useConcurrencyFilterMultiSKU)
            {
                concurrencyFilter.init(false, perfTask, null, this);
            }

            while (enumerator && noLocation)
            {
                perfTask.locDirActionExecuted();

                while (enumerator.moveNext() && noLocation)
                {
                    if (useConcurrencyFilterMultiSKU)
                    {
                        concurrencyFilter.applicableLocationRejected();
                    }

                    perfTask.locationEvaluated();

                    location = enumerator.currentWMSLocation();

                    if (!this.validateCurrentLocationMultiSku(_excludeLocationId))
                    {
                        perfTask.multiSKUFailed();
                        continue;
                    }

                    // If this is a Put, get our stocking limit and subtract what is already there.
                    if (_workType == WHSWorkType::Put)
                    {
                        [allowedQty, allowedUnitId, isContainerLimit] = WHSLocationLimit::retrieveQty(_inventLocationId,
                                                                                    location.wmsLocationId,
                                                                                    '',
                                                                                    defaultLPUnitId,
                                                                                    true,
                                                                                    '',
                                                                                    containerTypeCode);

                        if (isContainerLimit && !this.validateContainerLimit(containerTypeCode))
                        {
                            perfTask.containerLimitFailed();
                            continue;
                        }

                        if (useConcurrencyFilterMultiSKU)
                        {
                            // Acquires lock for Dock management validation
                            WhsLocationDirectiveConcurrencyFilterParameters parameters = this.createConcurrencyFilterParametersMultiSKU();

                            if (!concurrencyFilter.isLocationApplicable(parameters))
                            {
                                continue;
                            }
                        }
                    }

                    if (allowedQty == realMax())
                    {
                        finalQty        = 1;
                        finalInventQty  = 1;
                        finalUOM        = defaultLPUnitId;
                        finalLocationId = location.wmsLocationId;
                        noLocation      = false;
                    }
                    else
                    {
                        // Get how many unique license plates are in the location
                        availQty = this.countUniqueLPInLocation(_inventLocationId, inventSiteId, location.wmsLocationId);
                        availQty = allowedQty - availQty;

                        if (availQty >= 1)
                        {
                            finalQty        = 1;
                            finalInventQty  = 1;
                            finalUOM        = defaultLPUnitId;
                            finalLocationId = location.wmsLocationId;
                            noLocation      = false;
                        }
                    }

                    if (!this.isDockManagmentMixingValidForPutLocation(noLocation, _workType))
                    {
                        finalLocationId = '';
                        finalInventQty  = 0;
                        finalQty        = 0;
                        finalUOM        = '';
                        noLocation = true;
                        this.createWorkHistoryLine('', inventQty, inventUOM, strFmt("@WAX3913", location.wmsLocationId), true);
                        perfTask.dockManagementMixingFailed();
                    }
                }

                if (noLocation)
                {
                    if (useConcurrencyFilterMultiSKU)
                    {
                        concurrencyFilter.applicableLocationRejected();
                    }

                    restart = false;

                    enumerator = this.findLocationEnumeratorMultiSKU(inventSiteId,
                                                            _inventLocationId,
                                                            _workType,
                                                            _workTransType,
                                                            _locDirHintCode,
                                                            _dispositionCode,
                                                            restart);
                }
            }

            ttscommit;

            findPickPutLocationPerformanceTask = null;
        }

        return [finalLocationId, finalQty, finalUOM, finalInventQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>getQuantitiesAndInventDimIdFromOrderLine</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal container getQuantitiesAndInventDimIdFromOrderLine(Common _common)
    {
        switch (_common.TableId)
        {
            case tableNum(PurchLine):
                PurchLine purchLine = _common;

                if (PdsGlobal::pdsIsCWItem(purchLine.ItemId))
                {
                    return [purchLine.PdsCWRemainInventPhysical, purchLine.PdsCWQty, purchLine.pdsCWUnitId(), purchLine.InventDimId];
                }
                else
                {
                    return [purchLine.RemainPurchPhysical, purchLine.PurchQty, purchLine.PurchUnit, purchLine.InventDimId];
                }
        }

        return conNull();
    }

]]></Source>
			</Method>
			<Method>
				<Name>getLocateQtyByStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the qty to locate for orders based on the locate qty strategy.
    /// </summary>
    /// <param name="_locateQty">
    /// The locate qty strategy.
    /// </param>
    /// <param name="_inventQty">
    /// The current qty to locate.
    /// </param>
    /// <param name="_inventUOM">
    /// The invent unit of measure.
    /// </param>
    /// <param name="_common">
    /// A common record which is being evaluated.
    /// </param>
    /// <returns>
    /// The qty to locate based on the locate qty strategy.
    /// </returns>
    private Qty getLocateQtyByStrategy(
        WHSLocateQty        _locateQty,
        InventQty           _inventQty,
        UnitOfMeasureSymbol _inventUOM,
        Common              _common)
    {
        Qty                     locateQty;
        UnitOfMeasureSymbol     locateUOM = _inventUOM;
        Qty                     remainQty;
        Qty                     orderQty;
        UnitOfMeasureSymbol     orderUOM;
        InventDimId             inventDimId;

        [remainQty, orderQty, orderUOM, inventDimId] = this.getQuantitiesAndInventDimIdFromOrderLine(_common);

        switch (_locateQty)
        {
            case WHSLocateQty::None,
                 WHSLocateQty::LicensePlateQty:
                locateQty   = _inventQty;
                break;

            case WHSLocateQty::UnitizedQty:
                locateQty   = unitizeQty;
                break;

            case WHSLocateQty::RemainingQty:
                locateQty   = releasedProductUnitConverter.convertGivenUnitSymbols(remainQty,
                                                                   orderUOM,
                                                                   locateUOM,
                                                                   NoYes::No,
                                                                   itemId,
                                                                   inventDimId,
                                                                   NoYes::No);
                break;

            case WHSLocateQty::ExpectedQty:
                locateQty   = releasedProductUnitConverter.convertGivenUnitSymbols(orderQty,
                                                                   orderUOM,
                                                                   locateUOM,
                                                                   NoYes::No,
                                                                   itemId,
                                                                   inventDimId,
                                                                   NoYes::No);
                break;

            default:
                locateQty   = this.getDefaultLocateQtyByStrategy(_locateQty, _inventQty, _inventUOM, _common);
                break;
        }

        return locateQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDefaultLocateQtyByStrategy</Name>
				<Source><![CDATA[
    protected Qty getDefaultLocateQtyByStrategy(
        WHSLocateQty        _locateQty,
        InventQty           _inventQty,
        UnitOfMeasureSymbol _inventUOM,
        Common              _common)
    {
        return _inventQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getReplenAboveLocDim</Name>
				<Source><![CDATA[
    /// <summary>
    /// Method which fills all above location dimensions for replenishment work creation
    /// </summary>
    /// <param name="_inventDimCriteria">
    /// The current dimension set location directives is using. InventDimID can be blank.
    /// </param>
    /// <param name="_itemId">
    /// The item currently being located, used to obtain reservation hierarchy data
    /// </param>
    /// <param name="_qty">
    /// The amount of qty currently being located by location directives
    /// </param>
    /// <returns>
    /// An updated dimension set with all above location dimensions filled
    /// </returns>
    public InventDim getReplenAboveLocDim(
        InventDim       _inventDimCriteria,
        ItemId          _itemId,
        Qty             _qty)
    {
        InventDimParm criteriaDimParm;                         
        InventDim inventDimCriteria = _inventDimCriteria;
        
        InventDimParm locLevelDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmLocationAndAbove(InventTable::find(_itemId));
        inventDimCriteria.clearBelowLocationDim(_itemId);
        criteriaDimParm.initFromInventDim(inventDimCriteria);

        // Only use auto dim filling logic if we are missing any above location dimensions
        if (InventDimParm::isInventDimParmEqual(locLevelDimParm, criteriaDimParm, InventDim::dimEnabledFieldList()))
        {
            return _inventDimCriteria;
        }

        WHSReservationHierarchyProvider reservationHierarchyProvider = WHSReservationHierarchyProvider::construct();

        // Concerned only with location level reservations when creating work
        WHSReservationHierarchyLevel reservationHierarchyLevel =  reservationHierarchyProvider.getLocationHierarchyLevel(InventTable::find(_itemId));

        WHSInventReservationQueryBuilder inventReservationQueryBuilder = WHSInventReserveQueryBuilder::newFromParameters(_itemId,
                                                                                        inventDimCriteria,
                                                                                        criteriaDimParm,
                                                                                        reservationHierarchyLevel,
                                                                                        false,
                                                                                        true,
                                                                                        false);

        WHSInventOnHandCollectionEnumerator inventOnHandCollectionEnumerator = WHSInventReserveQueryCollection::newFromQuery(inventReservationQueryBuilder.buildOnHandQuery(),inventReservationQueryBuilder.sumTableId()).getEnumerator() as WHSInventOnHandCollectionEnumerator;

        boolean isWHSFindPickLocationReplenAboveLocDimCheckFlightEnabled = WHSFindPickLocationReplenAboveLocDimCheckFlight::instance().isEnabled();
        boolean isWHSFindPickLocationReplenAboveLocDimCheckQtyConditionFlightEnabled = isWHSFindPickLocationReplenAboveLocDimCheckFlightEnabled && WHSFindPickLocationReplenAboveLocDimCheckQtyConditionFlight::instance().isEnabled();

        InventDim inventDim;

        while (inventOnHandCollectionEnumerator.moveNext())
        {
            WHSInventOnHandData inventOnHandData = inventOnHandCollectionEnumerator.current();
            inventDim = inventOnHandData.parmInventDim();

            WHSTmpWorkLine sumTmpWorkLine;
            if (isWHSFindPickLocationReplenAboveLocDimCheckFlightEnabled)
            {                    
                InventDim       sumInventDim;
                InventDimParm   sumInventDimParm;                   

                sumInventDimParm.initFromInventDim(inventDim);
                //wmsLocationId is cleared before it is written to the work line dimension
                sumInventDimParm.WMSLocationIdFlag = false;

                select sum(InventQty) from sumTmpWorkLine
                    where sumTmpWorkLine.wmsLocationId     == inventDim.wMSLocationId
                    &&    sumTmpWorkLine.InventLocationId  == inventDim.inventLocationId
                    &&    sumTmpWorkLine.ItemId            == _itemId
                    &&    sumTmpWorkLine.WorkType          == WHSWorkType::Pick
                #InventDimExistsJoin(sumTmpWorkLine.inventDimId, sumInventDim, inventDim, sumInventDimParm);   
            }
            else
            {
                select sum (InventQty) from sumTmpWorkLine
                    where sumTmpWorkLine.InventDimId    == inventDim.InventDimId
                    &&    sumTmpWorkLine.ItemId         == _itemId;
            }

            Qty qtyToLocate;
            if (isWHSFindPickLocationReplenAboveLocDimCheckQtyConditionFlightEnabled)
            {
                qtyToLocate = min(_qty, inventOnHandData.parmAvailPhysicalHandlingQty() - sumTmpWorkLine.InventQty);
            }
            else
            {
                qtyToLocate = min(_qty, inventOnHandData.parmAvailPhysicalHandlingQty());
                qtyToLocate -= sumTmpWorkLine.InventQty;
            }

            if (qtyToLocate > 0)
            {
                break;
            }
            else
            {
                inventDim.clear();
            }
        }

        return inventDim.RecId != 0 ? inventDim : _inventDimCriteria;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createActionQuery</Name>
				<Source><![CDATA[
    /// <summary>
    /// Instantiates a <c>WhsLocationDirectiveActionQuery</c> class.
    /// </summary>
    /// <param name = "_locDirAction">The location action record with the query.</param>
    /// <param name = "_locDirLine">The location directive line.</param>
    /// <param name = "_inventDim">The dimensions of the item to be located.</param>
    /// <param name = "_locateUOM">The unit of measure of the quantity to locate.</param>
    /// <param name = "_locateQty">The quantity to locate.</param>
    /// <param name = "_guidedLicensePlates">A list of license plates to use for locating.</param>
    /// <returns>A new instance of the <c>WhsLocationDirectiveActionQuery</c> class.</returns>
    protected WhsLocationDirectiveActionQuery createActionQuery(
        WHSLocDirAction     _locDirAction,
        WHSLocDirLine       _locDirLine,
        InventDim           _inventDim,
        UnitOfMeasureSymbol _locateUOM,
        Qty                 _locateQty,
        List                _guidedLicensePlates)
    {
        WhsLocationDirectiveActionQuery locDirActionQuery =  WhsLocationDirectiveActionQuery::newFromParameters(
                            _locDirAction,
                            locDirTable.WorkType,
                            itemId,
                            _inventDim.InventDimId,
                            _guidedLicensePlates,
                            _locateQty,
                            _locateUOM,
                            _locDirLine.AllowSplit,
                            !this.shouldUseVolumetricsOptimization(),
                            this.isLocatingWholeLP(),
                            lpInformation
                            );
        
        locDirActionQuery.parmSkipMixedLocationOptimizations(!this.shouldUseMixedLocationOptimization());
        locDirActionQuery.parmIsWorkHistoryLogEnabled(isWorkHistoryLogEnabled);
        switch (locDirTable.WarehouseGroupAll)
        {
            case WhsWarehouseGroupAll::Group:
            case WhsWarehouseGroupAll::All:
                locDirActionQuery.parmWarehouseId(locDirTable.InventLocationId);
                break;
        }

        return locDirActionQuery;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getOrderLineByInventTransId</Name>
				<Source><![CDATA[
    private Common getOrderLineByInventTransId(WHSWorkTransType _workTransType, InventTransId _InventTransId)
    {
        return WhsWorkTransactionType::singletonFromTypeOrDefault(_workTransType).findSourceOrderLineByInventTransId(_InventTransId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>loopLocDirLines</Name>
				<Source><![CDATA[
    /// <summary>
    /// Loops over <c>WHCLocDirLine</c> for the selected <c>WHSLocDirTable</c> and tries to determine if any location can be found.
    /// </summary>
    /// <param name="_inventQty">
    /// The qty to lookup the location.
    /// </param>
    /// <param name="_inventUOM">
    /// The UOM to lookup the location.
    /// </param>
    /// <param name="_inventTransId">
    /// The invent trans id to lookup the location.
    /// </param>
    /// <param name="_inventDim">
    /// The invent dim to lookup the location.
    /// </param>
    /// <param name="_buildQty">
    /// A container of UOM conversion and their factors from lowest to highest.
    /// </param>
    /// <param name="_guidedLicensePlates">
    /// List of license plates that need to be picked - valid only for location directive strategy GuidedLPLocate
    /// </param>
    /// <returns>
    /// A <c>WhsLocationDirectiveMatch</c> class with the results.
    /// </returns>
    protected WhsLocationDirectiveMatch loopLocDirLines(
        Qty                 _inventQty,
        UnitOfMeasureSymbol _inventUOM,
        InventTransId       _inventTransId,
        InventDim           _inventDim,
        container           _buildQty,
        List                _guidedLicensePlates = null)
    {
        WHSLocDirLine locDirLine;

        while select locDirLine
            order by locDirLine.LocSeqNum
            where locDirLine.RefRecId       == locDirTable.RecId
                && locDirLine.LocSeqNum      > locSeqNumLocDirLine
        {
            this.onLocationDirectiveLineVisited(locDirLine);

            if (findPickPutLocationPerformanceTask)
            {
                findPickPutLocationPerformanceTask.locDirLineVisited();
            }

            container finalBuildQty = conNull();
            container tmpQtyContainer = conNull();
            UnitOfMeasureSymbol locateUOM = _inventUOM;
            Qty locateQty = _inventQty;

            // For external inbound orders, use the Locate Qty enum to
            // get the correct quantity and unit of measure.
            if (WHSLocationDirective::isLocatingWholeLPSupported(locDirTable.WorkTransType))
            {
                switch (locDirTable.LocateBy)
                {
                    case WHSLocDirLocateBy::ASN:
                    case WHSLocDirLocateBy::MixedLP:
                        locateQty = lpInformation.getQtyOnLicensePlate();
                        break;

                    default:
                        locateQty = this.getLocateQtyByStrategy(locDirLine.LocateQty, locateQty, locateUOM, this.getOrderLineByInventTransId(locDirTable.WorkTransType, _inventTransId));
                        break;
                }
            }

            if (locDirLine.UnitID)
            {
                // If a UOM was defined and we can't convert to it, skip this line.
                if (!releasedProductUnitConverter.canBeConvertedGivenUnitSymbols(locateUOM,
                                                                 locDirLine.UnitID,
                                                                 itemId,
                                                                 _inventDim.InventDimId))
                {
                    continue;
                }
                else
                {
                    locateQty = releasedProductUnitConverter.convertGivenUnitSymbols(locateQty,
                                                                    locateUOM,
                                                                    locDirLine.UnitID,
                                                                    NoYes::No,
                                                                    itemId,
                                                                    _inventDim.InventDimId,
                                                                    NoYes::No);
                    locateUOM = locDirLine.UnitID;
                }
            }

            if (this.isLocatingWholeLP()
            || locDirLine.isApplicableForQuantity(locateQty))
            {
                if (locDirLine.RestrictByUOM)
                {
                    int length = conLen(_buildQty);

                    for (int i = 1; i <= length; ++i)
                    {
                        if ((conPeek(conPeek(_buildQty, i), #BuildQtyQty) >= 1
                            || locDirLine.RoundUpToHandlingUnit)
                        && WHSLocDirLineUOM::exist(locDirLine.RecId, conPeek(conPeek(_buildQty, i), #BuildQtyUOM)))
                        {
                            Qty adjustedBuildQty;

                            if (locDirLine.RoundUpToHandlingUnit)
                            {
                                adjustedBuildQty =  roundUp(conPeek(conPeek(_buildQty, i), #BuildQtyQty), 1);
                            }
                            else
                            {
                                adjustedBuildQty = trunc(conPeek(conPeek(_buildQty, i), #BuildQtyQty));
                            }

                            tmpQtyContainer = conIns(tmpQtyContainer,
                                                 conLen(tmpQtyContainer) + 1,
                                                 conPeek(conPeek(_buildQty, i), #BuildQtyUOM),
                                                 adjustedBuildQty);

                            finalBuildQty = conIns(finalBuildQty,
                                               conLen(finalBuildQty) + 1,
                                               tmpQtyContainer);
                        }
                    }
                }
                else
                {
                    tmpQtyContainer = conIns(tmpQtyContainer,
                                                1,
                                                _inventUOM,        // Unit
                                                _inventQty);       // Qty
                    finalBuildQty = conIns(finalBuildQty, 1, tmpQtyContainer);
                }

                if (finalBuildQty != conNull())
                {
                    WHSLocDirAction locDirAction;

                    while select locDirAction
                        order by locDirAction.LocSeqNum
                        where locDirAction.RefRecId         == locDirLine.RecId
                        &&    locDirAction.LocSeqNum        >  locSeqNumLocDirAction
                        &&    (locDirTable.WorkType         == WHSWorkType::Put
                        ||    locDirAction.BatchEnabled     == batchControlled)
                    {
                        this.onLocationDirectiveActionVisited(locDirAction);

                        if (findPickPutLocationPerformanceTask)
                        {
                            findPickPutLocationPerformanceTask.locDirActionVisited();
                        }

                        if (locDirTable.WorkType == WHSWorkType::Pick
                            && !this.validateLocDirAction(itemId, locateQty, locateUOM, locDirAction, _guidedLicensePlates))
                        {
                            continue;
                        }

                        if (!this.isLocationDirectiveActionApplicable(locDirAction, itemId, _inventDim, locateQty, locatedUOM))
                        {
                            continue;
                        }

                        var actionQuery = this.createActionQuery(locDirAction, locDirLine, _inventDim, locateUOM, locateQty, _guidedLicensePlates);

                        WhsLocationDirectiveActionQueryEnumerator actionEnumerator = actionQuery.getEnumerator();

                        if (actionEnumerator.hasHits())
                        {
                            var matchingDirective = WhsLocationDirectiveMatch::newFromParameters(actionEnumerator, finalBuildQty, locDirLine, locDirAction,
                                                                                                 locDirTable.WorkType == WHSWorkType::Pick ? locDirAction.isLastActionWithinSameBatchEnabledState() : false);

                            locSeqNumLocDirAction = locDirAction.LocSeqNum;
                            locDirNameAction      = locDirAction.LocDirName;

                            this.createWorkHistoryLine(itemId,
                                       locateQty,
                                       locateUOM,
                                       strFmt("@WAX1751", locDirTable.LocDirName, locDirLine.LocSeqNum, locDirAction.LocDirName),
                                       false,
                                       _inventDim.InventStatusId);

                            if (actionQuery.parmVolumetricsPutawayOptimizationApplied() &&
                                actionQuery.getExcludedLocationsStr())
                            {
                                this.createWorkHistoryLine(itemId,
                                       locateQty,
                                       locateUOM,
                                       strFmt("@WAX:WhsLocationDirective_VolumetricsPutawayOptimization_ExcludedLocationsMessage", locDirTable.LocDirName, locDirLine.LocSeqNum, locDirAction.LocDirName, actionQuery.getExcludedLocationsStr()),
                                       false,
                                       _inventDim.InventStatusId);
                            }

                            return matchingDirective;
                        }
                        // If the location directive line is using immediate replenishment, we want to use the line whether the enumerator has hits or not for the last action.
                        else if (locDirLine.ImmediateReplenishmentTemplateId
                             &&  locDirTable.WorkType == WHSWorkType::Pick
                             &&  locDirAction.isLastActionWithinSameBatchEnabledState())
                        {
                            this.createWorkHistoryLine(itemId,
                                       locateQty,
                                       locateUOM,
                                       strFmt("@WAX:WhsLocationDirective_ImmediateReplenishmentMessage", locDirTable.LocDirName, locDirLine.LocSeqNum, locDirAction.LocDirName, locDirLine.ImmediateReplenishmentTemplateId),
                                       false,
                                       _inventDim.InventStatusId);
                           
                            var matchingDirective = WhsLocationDirectiveMatch::newFromParameters(actionEnumerator, finalBuildQty, locDirLine, locDirAction, true);

                            locSeqNumLocDirAction = locDirAction.LocSeqNum;
                            locDirNameAction      = locDirAction.LocDirName;

                            return matchingDirective;
                        }
                    }

                    locSeqNumLocDirLine   = locDirLine.LocSeqNum;
                    locSeqNumLocDirAction = 0;
                }
            }
            else
            {
                this.createWorkHistoryLine(itemId,
                                            locateQty,
                                            locateUOM,
                                            strFmt("@WAX1742", locDirTable.LocDirName, locDirLine.LocSeqNum, locDirLine.FromQty, locDirLine.ToQty),
                                            true,
                                            _inventDim.InventStatusId);
            }
        }

        return null;
    }

]]></Source>
			</Method>
			<Method>
				<Name>determineInventQtyForReplenishment</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines the quantity at the inventory for replenishment.
    /// </summary>
    /// <param name="_inventDimId">
    /// The inventDimId for the inventDim criteria we are using to locate inventory.
    /// </param>
    /// <param name="_inventFindQty">
    /// The inventory quantity we are trying to find a location for.
    /// </param>
    /// <param name="_inventUOM">
    /// The inventory UOM we are locating in.
    /// </param>
    /// <param name="_roundingUnit">
    /// The rounding unit; optional.
    /// </param>
    /// <returns>
    /// The quantity at the inventory for replenishment.
    /// </returns>
    protected InventQty determineInventQtyForReplenishment(
        InventDimId         _inventDimId,
        InventQty           _inventFindQty,
        UnitOfMeasureSymbol _inventUOM,
        real _roundingUnit = 1)
    {
        InventQty newInventFindQty = _inventFindQty;

        // Find avail qty in location we are replenishing so we can use that to satisfy demand Qty
        if (workTransType == WHSWorkTransType::Replenishment)
        {
            if (originType == WHSOriginType::Wave
                && !isStagingWorkLine)
            {
                replenAvailQty = WHSReplenQtyCalculator::calculateAvailableInventQty(workBuildId, _inventDimId, location, itemId);

                if (newInventFindQty > replenAvailQty)
                {
                    newInventFindQty -= replenAvailQty;
                }
                else
                {
                    newInventFindQty = 0;
                }
            }

            if (replenRoundingUOM)
            {
                if (releasedProductUnitConverter.canBeConvertedGivenUnitSymbols(_inventUOM,
                                                                replenRoundingUOM,
                                                                itemId,
                                                                _inventDimId))
                {
                    Qty roundingQty = releasedProductUnitConverter.convertGivenUnitSymbols(newInventFindQty,
                                                                        _inventUOM,
                                                                        replenRoundingUOM,
                                                                        NoYes::No,
                                                                        itemId,
                                                                        _inventDimId,
                                                                        NoYes::No);
                    roundingQty = Global::roundUp(roundingQty, _roundingUnit);
                    newInventFindQty = releasedProductUnitConverter.convertGivenUnitSymbols(roundingQty,
                                                                    replenRoundingUOM,
                                                                    _inventUOM,
                                                                    NoYes::No,
                                                                    itemId,
                                                                    _inventDimId,
                                                                    NoYes::No);
                }
                else
                {
                    warning(strFmt("@WAX4054", _inventUOM, replenRoundingUOM, itemId));
                }
            }
        }

        return newInventFindQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmFEFOBatchId</Name>
				<Source><![CDATA[
    InventBatchId parmFEFOBatchId(WHSFEFOBatchId _fefoBatchId = parmFEFOBatchId)
    {
        parmFEFOBatchId = _fefoBatchId;

        return parmFEFOBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsFinalPutWorkLine</Name>
				<Source><![CDATA[
    public boolean parmIsFinalPutWorkLine(boolean _isFinalPutWorkLine = isFinalPutWorkLine)
    {
        isFinalPutWorkLine = _isFinalPutWorkLine;

        return isFinalPutWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmIsStagingWorkLine</Name>
				<Source><![CDATA[
    public boolean parmIsStagingWorkLine(boolean _isStagingWorkLine = isStagingWorkLine)
    {
        isStagingWorkLine = _isStagingWorkLine;

        return isStagingWorkLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmTargetLicensePlateId</Name>
				<Source><![CDATA[
    public WHSLicensePlateId parmTargetLicensePlateId(WHSLicensePlateId _targetLicensePlateId = targetLicensePlateId)
    {
        targetLicensePlateId = _targetLicensePlateId;
        return targetLicensePlateId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmLocatedLP</Name>
				<Source><![CDATA[
    WHSLicensePlateId parmLocatedLP(WHSLicensePlateId _locatedLP = parmLocatedLP)
    {
        parmLocatedLP = _locatedLP;

        return parmLocatedLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenAvailQty</Name>
				<Source><![CDATA[
    InventQty parmReplenAvailQty(InventQty _qty = replenAvailQty)
    {
        replenAvailQty = _qty;

        return replenAvailQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmImmedReplenUsedExistingReplen</Name>
				<Source><![CDATA[
    public Qty parmImmedReplenUsedExistingReplen(Qty _immedReplenUsedExistingReplen = immedReplenUsedExistingReplen)
    {
        immedReplenUsedExistingReplen = _immedReplenUsedExistingReplen;
        
        return immedReplenUsedExistingReplen;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmOnlyExistingImmedReplenUsed</Name>
				<Source><![CDATA[
    public boolean parmOnlyExistingImmedReplenUsed(boolean _onlyExistingImmedReplenUsed = onlyExistingImmedReplenUsed)
    {
        onlyExistingImmedReplenUsed = _onlyExistingImmedReplenUsed;

        return onlyExistingImmedReplenUsed;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenInventDim</Name>
				<Source><![CDATA[
    public InventDim parmReplenInventDim(InventDim  _replenInventDim = replenInventDim)
    {
        replenInventDim = _replenInventDim;

        return replenInventDim;
    }

]]></Source>
			</Method>
			<Method>
				<Name>resetImmediateReplenishment</Name>
				<Source><![CDATA[
    public void resetImmediateReplenishment()
    {
        usedImmedReplen               = false;
        immedReplenUsedExistingReplen = 0;
        onlyExistingImmedReplenUsed   = false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenishmentTemplateLine</Name>
				<Source><![CDATA[
    public WHSReplenishmentTemplateLine parmReplenishmentTemplateLine(WHSReplenishmentTemplateLine  _replenishmentTemplateLine = replenishmentTemplateLine)
    {
        replenishmentTemplateLine = _replenishmentTemplateLine;

        return replenishmentTemplateLine;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmReplenRoundingUOM</Name>
				<Source><![CDATA[
    UnitOfMeasureSymbol parmReplenRoundingUOM(UnitOfMeasureSymbol _replenRoundingUOM = replenRoundingUOM)
    {
        replenRoundingUOM = _replenRoundingUOM;

        return replenRoundingUOM;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmShipmentId</Name>
				<Source><![CDATA[
    public WHSShipmentId parmShipmentId(WHSShipmentId _shipmentId = shipmentId)
    {
        shipmentId = _shipmentId;

        return shipmentId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUsedLocateByLP</Name>
				<Source><![CDATA[
    public boolean parmUsedLocateByLP(boolean _usedLocateByLP = usedLocateByLP)
    {
        usedLocateByLP = _usedLocateByLP;

        return usedLocateByLP;
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmUnitizeQty</Name>
				<Source><![CDATA[
    InventQty parmUnitizeQty(InventQty _unitizeQty)
    {
        unitizeQty = _unitizeQty;

        return unitizeQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>performStrategy</Name>
				<Source><![CDATA[
    /// <summary>
    /// Runs the location directive strategy logic.
    /// </summary>
    /// <param name="_strategy">
    /// The location directive strategy to be run.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimensions of the item be located.
    /// </param>
    /// <param name="_inWorkQty">
    /// Quantity that is currently in the <c>WHSTmpWorkLine</c> table.
    /// </param>
    /// <returns>
    /// true if the strategy is successful; otherwise, false.
    /// </returns>
    private boolean performStrategy(
        WHSLocDirStrategy   _strategy,
        InventDim           _inventDim,
        Qty                 _inWorkQty = 0)
    {
        WhsLocationDirectiveStrategy strategyClass = WhsLocationDirectiveStrategy::singletonFromStrategy(_strategy);
        boolean strategyResult = true;

        if (strategyClass)
        {
            var parameters = WhsLocationDirectiveStrategyParameters::construct();
            parameters.ItemId = itemId;
            parameters.WorkType = workType;
            parameters.Location = location;
            parameters.InventBatchId = inventBatchId;
            parameters.InventUOM = inventUOM;
            parameters.AvailQty = availQty;
            parameters.InventFindQty = inventFindQty;
            parameters.InventDim = _inventDim;
            parameters.CurrentLPId = curLPId;
            parameters.InWorkQty = _inWorkQty;

            parameters.onInitialized(this);

            if (strategyClass.isApplicableForParameters(parameters))
            {
                strategyResult = strategyClass.performStrategy(this, parameters);
            }
        }

        return strategyResult;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setPutawayClusterWorkId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets clustered work ID variable, used to find the locate by cluster directive.
    /// </summary>
    /// <param name = "_clusteredWorkId">The work ID to set the value.</param>
    [Hookable(false)]
    internal final void setPutawayClusterWorkId(WHSWorkId _clusteredWorkId)
    {
        clusteredWorkId = _clusteredWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setGlobals</Name>
				<Source><![CDATA[
    /// <summary>
    /// Sets values to variables of the instance for use from each method.
    /// </summary>
    /// <param name="_workBuildId">
    /// Work build id to be set.
    /// </param>
    /// <param name="_originType">
    /// Origin type to be set.
    /// </param>
    /// <param name="_originRefId">
    /// Origin reference id to be set.
    /// </param>
    /// <param name="_tmpWorkLine">
    /// Temporary work line to be set.
    /// </param>
    /// <param name="_waveExecutionId">
    /// Wave execution id to be set.
    /// </param>
    public void setGlobals(
                    WHSWorkBuildId      _workBuildId,
                    WHSOriginType       _originType,
                    WHSOriginRefId      _originRefId,
                    WHSTmpWorkLine      _tmpWorkLine,
                    WHSWaveExecutionID  _waveExecutionId = '')
    {
        workBuildId     = _workBuildId;
        originType      = _originType;
        originRefId     = _originRefId;
        tmpWorkLine     = _tmpWorkLine;
        waveExecutionId = _waveExecutionId;

        orderNum = WhsLocationDirectiveOrderNumProvider::currentOrderNum();
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateBatchMixingOnLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if placing a batch (batches) on a location would not violate batch mixing rules.
    /// </summary>
    /// <param name="_itemId">
    /// Item ID to be checked.
    /// </param>
    /// <param name="_inventBatchId">
    /// Batch number ID to be checked.
    /// </param>
    /// <param name="_inventTransId">
    /// Inventory transaction ID to be used for finding batches if a batch number ID is not passed.
    /// </param>
    /// <param name="_locationId">
    /// Warehouse location ID to be be checked.
    /// </param>
    /// <returns>
    /// true if batch mixing rules would not be violated; otherwise, false.
    /// </returns>
    protected boolean validateBatchMixingOnLocation(
        ItemId          _itemId,
        InventBatchId   _inventBatchId,
        InventTransId   _inventTransId,
        WMSLocationId   _locationId)
    {
        if (!WHSLocationProfile::find(location.LocProfileId).AllowMixedBatches)
        {
            if (_inventBatchId)
            {
                return WHSInvent::allowMixedBatch(_itemId, _inventBatchId, location.InventLocationId, _locationId);
            }
            else if (_inventTransId)
            {
                // Batch number might not be stamped on the work line. Try to find batches by the inventory transaction.
                InventDim           inventDimBatch;
                InventTrans         inventTransBatch;
                InventTransOrigin   inventTransOriginBatch;

                while select InventBatchId from inventDimBatch
                    group by InventBatchId
                    where inventDimBatch.InventBatchId
                    exists join inventTransBatch
                        where inventTransBatch.InventDimId == inventDimBatch.InventDimId
                        exists join inventTransOriginBatch
                            where inventTransOriginBatch.RecId          == inventTransBatch.InventTransOrigin
                                && inventTransOriginBatch.InventTransId == _inventTransId
                {
                    if (!WHSInvent::allowMixedBatch(_itemId, inventDimBatch.InventBatchId, location.InventLocationId, _locationId))
                    {
                        return false;
                    }
                }
            }
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateContainerLimit</Name>
				<Source><![CDATA[
    /// <summary>
    ///  Validates a container limit for a warehouse location.
    /// </summary>
    /// <param name="_containerTypeCode">
    ///  The container type.
    /// </param>
    /// <returns>
    ///  true if no mixing rules or stocking limits are violated; otherwise, false.
    /// </returns>
    private boolean validateContainerLimit(WHSContainerTypeCode _containerTypeCode)
    {
        boolean ret = true;

        WHSContainerTypeLocationLimitValidator containerTypeLocationLimitValidator = WHSContainerTypeLocationLimitValidator::newFromParameters(location.inventLocationId,
                                                                                                                                               location.wmsLocationId,
                                                                                                                                               allowedQty,
                                                                                                                                               allowedUnitId,
                                                                                                                                               _containerTypeCode);

        if (!containerTypeLocationLimitValidator.validate())
        {
            this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX:ErrorContainerTypeStockingLimitsExceeded", Location.wMSLocationId), true, statusId);
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrentLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the location should be skipped before checking for available inventory.
    /// </summary>
    /// <param name="_strategy">
    /// The location directive strategy being used.
    /// </param>
    /// <param name="_inventDim">
    /// The inventory dimension criteria being used for locating inventory.
    /// </param>
    /// <param name="_useFixedLocations">
    /// A Boolean that determines if we are using only fixed product locations.
    /// </param>
    /// <param name="_excludeLocationId">
    /// A Set of WMSLocationIds we must not locate to.
    /// </param>
    /// <param name="_useFixedVariantLocations">
    /// A Boolean that determines if we are using only fixed variant locations.
    /// </param>
    /// <param name="_workLineInventDimId">
    /// Inventory dimension ID from the work line.
    /// </param>
    /// <returns>
    /// true if the location if valid; otherwise, false.
    /// </returns>
    protected boolean validateCurrentLocation(
        WHSLocDirStrategy   _strategy,
        InventDim           _inventDim,
        boolean             _useFixedLocations,
        Set                 _excludeLocationId,
        boolean             _useFixedVariantLocations = false,
        InventDimId         _workLineInventDimId = '')
    {
        boolean     ret = true;

        ret = this.checkNonLPLocation(_strategy, _inventDim);

        if (ret)
        {
            ret = this.checkRepeatDimensions(_strategy);
        }

        if (ret)
        {
            ret = this.checkExcludedLocations(_excludeLocationId);
        }

        if (ret)
        {
            ret = this.checkFinalPutLocation();
        }

        if (ret)
        {
            ret = this.checkStagingLocation();
        }

        if (ret)
        {
            ret = this.checkFixedLocation(_useFixedLocations);
        }

        if (ret)
        {
            ret = this.checkFixedVariantLocation(_useFixedVariantLocations, _workLineInventDimId);
        }

        if (ret)
        {
            ret = this.checkUserLocation();
        }

        // Check to see if the batch fits in the expiration date range
        if (ret && workType == WHSWorkType::Put && inventBatchId)
        {
            TransDate batchExpDate = InventBatch::find(inventBatchId, itemId).ExpDate;
            if (batchExpDate && !this.checkBatchDays(location.inventSiteId(),
                                        location.InventLocationId,
                                        location.wmsLocationId,
                                        itemId,
                                        custVendAccount,
                                        batchExpDate,
                                        inventBatchId))
            {
                this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX1816", location.wmsLocationId), true, statusId);
                ret = false;
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateCurrentLocationMultiSku</Name>
				<Source><![CDATA[
    private boolean validateCurrentLocationMultiSku(Set _excludeLocationId)
    {
        boolean ret = true;

        ret = this.checkExcludedLocations(_excludeLocationId);

        if (ret)
        {
            ret = this.checkFinalPutLocation();
        }

        if (ret)
        {
            ret = this.checkStagingLocation();
        }

        if (ret)
        {
            ret = this.checkUserLocation();
        }

        if (ret)
        {
            ret = this.checkLocAllowMultiSku();
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateIsItemMixTmpWorkLine</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that the item mixing rule is not being violated in the <c>WHSTmpWorkLine</c> table.
    /// </summary>
    /// <param name="_inventDim">
    /// The inventDim criteria being used to locate.
    /// </param>
    /// <returns>
    /// true if no item mixing rule is violated; otherwise, false.
    /// </returns>
    protected boolean validateIsItemMixTmpWorkLine(InventDim _inventDim)
    {
        boolean                                 ret = true;
        WHSLocationMixingConstraintValidator    mixCheck;
        InventDim                               inventDimCheck;

        inventDimCheck.initFromInventDim(_inventDim);
        inventDimCheck.wMSLocationId = location.wMSLocationId;
        inventDimCheck.InventLocationId = location.inventLocationId;

        mixCheck = WHSLocationMixingConstraintValidator::construct();
        mixCheck.parmCheckTmpWorkLine(true);
        mixCheck.parmCheckInventory(false);
        mixCheck.parmCheckWork(false);
        mixCheck.parmReceiptInventDim(inventDimCheck);
        mixCheck.parmReceiptItemId(itemId);

        if (!mixCheck.isItemMixValid())
        {
            this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX1749", location.wmsLocationId), true, statusId);
            ret = false;
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMixingRulesAndStockingLimitInternal</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the mixing rules and stocking limits are not being violated.
    /// </summary>
    /// <param name="_itemId">
    /// The item Id of the item that is being located.
    /// </param>
    /// <param name="_inventDimId">
    /// The inventDimId of the inventDim criteria being used to locate.
    /// </param>
    /// <param name="_locationProfile">
    /// Location profile of the location where the mixing rules need to be validated.
    /// </param>
    /// <param name="_allowSplit">
    /// A Boolean determining if we allowed to split the find quantity.
    /// </param>
    /// <param name="_stockingLimitQty">
    /// The allowed stocking limit quantity in the location.
    /// </param>
    /// <param name="_stockingLimitUOM">
    /// The unit of the allowed stocking limit quantity.
    /// </param>
    /// <param name="_inventFindQty">
    /// The quantity in inventory unit that a location should be found for.
    /// </param>
    /// <param name="_inventUOM">
    /// The inventory unit of the quantity that a location should be found for.
    /// </param>
    /// <param name="_canConvertFromAllowedUnitToInventUnit">
    /// A Boolean that determines if unit conversion from the stocking limit unit to the inventory unit is possible.
    /// </param>
    /// <param name="_useStockingLimits">
    /// A Boolean that determines if stocking limits should be used.
    /// </param>
    /// <returns>
    /// true if no mixing rules or stocking limits are violated; otherwise, false.
    /// </returns>
    private boolean validateMixingRulesAndStockingLimitInternal(
        ItemId              _itemId,
        InventDimId         _inventDimId,
        WHSLocationProfile  _locationProfile,
        boolean             _allowSplit,
        Qty                 _stockingLimitQty,
        UnitOfMeasureSymbol _stockingLimitUOM,
        InventQty           _inventFindQty,
        UnitOfMeasureSymbol _inventUOM,
        boolean             _canConvertFromAllowedUnitToInventUnit,
        boolean             _useStockingLimits)
    {
        // If our Dock Management Profile Assumes Empty, don't do this check.
        if (_locationProfile.whsDockMgmtProfile().AssumeEmptyForWave)
        {
            availQty = _stockingLimitQty;
            return true;
        }

        WhsLocationDirectiveLocationRulesLimitValidationParameters parameters = WhsLocationDirectiveLocationRulesLimitValidationParameters::construct();

        parameters.itemId = _itemId;
        parameters.inventDimId = _inventDimId;
        parameters.locationProfile = _locationProfile;
        parameters.allowSplit = _allowSplit;
        parameters.stockingLimitQty = _stockingLimitQty;
        parameters.stockingLimitUOM = _stockingLimitUOM;
        parameters.inventFindQty = _inventFindQty;
        parameters.inventUOM = _inventUOM;
        parameters.canConvertFromAllowedUnitToInventUnit = _canConvertFromAllowedUnitToInventUnit;
        parameters.useStockingLimits = _useStockingLimits;

        WhsLocationDirectiveLocationRulesLimitValidationResult result = this.validateMixingRulesAndStockingLimit(parameters);

        if (result.isValid)
        {
            availQty = _stockingLimitQty - result.quantityInLocation;
        }

        return result.isValid;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateMixingRulesAndStockingLimit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates the mixing rules and stocking limits are not being violated.
    /// </summary>
    /// <param name="_parameters">
    /// The parameters for the validation.
    /// </param>
    /// <returns>
    /// true if no mixing rules or stocking limits are violated; otherwise, false.
    /// </returns>
    protected WhsLocationDirectiveLocationRulesLimitValidationResult validateMixingRulesAndStockingLimit(WhsLocationDirectiveLocationRulesLimitValidationParameters _parameters)
    {
        WhsLocationDirectiveLocationRulesLimitValidationResult result = WhsLocationDirectiveLocationRulesLimitValidationResult::construct();
        boolean allowMultiSku = _parameters.locationProfile.AllowMixedItems;

        //If location does not allow multi sku or there is stocking limit, perform inventory summation
        if (!allowMultiSku || _parameters.useStockingLimits)
        {
            //bail out early if we found a location where we cannot fit in due to the stocking limit
            if (!_parameters.allowSplit && _parameters.useStockingLimits && _parameters.canConvertFromAllowedUnitToInventUnit)
            {
                InventQty allowedQtyInInventUnit = releasedProductUnitConverter.convertGivenUnitSymbols(
                        _parameters.stockingLimitQty,
                        _parameters.stockingLimitUOM,
                        _parameters.inventUOM,
                        NoYes::No,
                        _parameters.itemId,
                        _parameters.inventDimId,
                        NoYes::No);

                if (allowedQtyInInventUnit < _parameters.inventFindQty)
                {
                    this.createWorkHistoryLine(_parameters.itemId, _parameters.inventFindQty, _parameters.inventUOM, strFmt("@WAX:LocationDirectiveFailStockingLimitExceeded",
                                location.wmsLocationId, _parameters.itemId, _parameters.stockingLimitQty, _parameters.stockingLimitUOM, _parameters.inventFindQty, _parameters.inventUOM), true, statusId);
                    //exit here to avoid doing the subsequent calls since they can be performance intensive
                    result.isValid = false;
                    return result;
                }
            }

            ItemId      itemIdInLocation;
            InventDimId inventDimInLocation; // Holds product dimensions of inventory in the location.
            Qty         qtyInLocation;

            boolean allowMixedInventBatch = !InventDim::find(_parameters.inventDimId).inventBatchId
                                            || location.whsLocationProfile().AllowMixedBatches;

			[itemIdInLocation, inventDimInLocation, qtyInLocation] = WHSLocationDirective::getTotalQtyInLocation(location.InventLocationId,
                                                                                                                 location.wmsLocationId,
                                                                                                                 _parameters.stockingLimitUOM,
                                                                                                                 allowMultiSku,
																												 allowMixedInventBatch);

            if (this.checkItemAlreadyExistsInLocation(_parameters, itemIdInLocation, inventDimInLocation,  !allowMultiSku && qtyInLocation))
            {
                this.createWorkHistoryLine(_parameters.itemId, inventQty, _parameters.inventUOM, strFmt("@WAX1746", location.wmsLocationId), true, statusId);
                result.isValid = false;
                return result;

            }

            if (!allowMixedInventBatch
                && this.checkMixBatchConstraints(_parameters, itemIdInLocation, inventDimInLocation, !allowMixedInventBatch && qtyInLocation != 0))
            {
                this.createWorkHistoryLine(_parameters.itemId, inventQty, _parameters.inventUOM, strFmt("@WAX1748", location.wmsLocationId), true, statusId);
                result.isValid = false;
                return result;
            }

            result.quantityInLocation = qtyInLocation;
        }
        result.isValid = true;
        return result;
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkMixBatchConstraints</Name>
				<Source><![CDATA[
    private boolean checkMixBatchConstraints(
        WhsLocationDirectiveLocationRulesLimitValidationParameters  _parameters,
        ItemId                                                      _itemIdInLocation,
        InventDimId                                                 _inventDimInLocation,
        boolean                                                     _quantityExistsInLocation)
    {
        return !_parameters.locationProfile.AllowMixedBatches
			&& _itemIdInLocation
            && _quantityExistsInLocation
            && _inventDimInLocation
			&& !WHSLocationDirective::compareBatches(_inventDimInLocation, _parameters.inventDimId);
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkItemAlreadyExistsInLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if item already exists in location and location is not multi SKU.
    /// InventDim in location contains the product / item dimension id (e.g. Product dimensions or AllBlank).
    /// If inventDimInLocation is empty then multiple mixed dimensions was found
    /// </summary>
    /// <param name = "_parameters">The parameters for the validation.</param>
    /// <param name = "_itemIdInLocation">The work line item number of inventory in the location.</param>
    /// <param name = "_inventDimInLocation">The product dimensions of inventory in the location.</param>
    /// <param name = "_quantityInLocation">The work line total quantity of inventory in the location.</param>
    /// <returns>true if the criteria is fulfilled; otherwise, false.</returns>
    protected boolean checkItemAlreadyExistsInLocation(
        WhsLocationDirectiveLocationRulesLimitValidationParameters  _parameters,
        ItemId                                                      _itemIdInLocation,
        InventDimId                                                 _inventDimInLocation,
        Qty                                                         _quantityInLocation)
    {
        return (!_parameters.locationProfile.AllowMixedItems &&
                ((!_itemIdInLocation && _quantityInLocation) ||
                 (_itemIdInLocation && _itemIdInLocation != _parameters.itemId) ||
                 (!_inventDimInLocation && _quantityInLocation && !_parameters.locationProfile.EnableLocationProductDimensionSpecificMixing) ||
                 (_inventDimInLocation && !_parameters.locationProfile.EnableLocationProductDimensionSpecificMixing && !WHSLocationDirective::compareProductDimensions(_inventDimInLocation, _parameters.inventDimId, _parameters.itemId)) ||
                 (_parameters.locationProfile.EnableLocationProductDimensionSpecificMixing && 
                  !WHSLocationProductDimensionMixingValidator::newFromProductAndLocation(location, _parameters.itemId, InventDim::find(_parameters.inventDimId)).validateLocationProductDimensionMixingParameters())));
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetrics</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the required quantity of the item can fit the specified location.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// Location in a warehouse.
    /// </param>
    /// <param name="_inventLocationId">
    /// Identify the warehouse.
    /// </param>
    /// <param name="_itemId">
    /// Identify item.
    /// </param>
    /// <param name="_qty">
    /// Number of units.
    /// </param>
    /// <param name="_allowSplit">
    /// Indicates if quantity can be split.
    /// </param>
    /// <param name="_inventDimId">
    /// Identifies inventory dimensions.
    /// </param>
    /// <param name="_currentUOM">
    /// Identifies current unit of adjustment in item.
    /// </param>
    /// <param name="_containerTypeCode">
    /// The container type code.
    /// </param>
    /// <returns>
    /// Quantity that can fit the specified location.
    /// </returns>
    public Qty validateVolumetrics(
        WMSLocationId           _wmsLocationId,
        InventLocationId        _inventLocationId,
        ItemId                  _itemId,
        Qty                     _qty,
        boolean                 _allowSplit,
        InventDimId             _inventDimId    = '',
        UnitOfMeasureSymbol     _currentUOM     = InventTableModule::find(_itemId, ModuleInventPurchSales::Invent).UnitId,
        WHSContainerTypeCode    _containerTypeCode = '')
    {
        return this.validateVolumetricsAllUnits(_wmsLocationId,
                                                _inventLocationId,
                                                _itemId,
                                                _qty,
                                                _allowSplit,
                                                _inventDimId,
                                                _currentUOM,
                                                _containerTypeCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetricsHandlingUnit</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate if the required quantity of the item can fit the specified location.
    /// </summary>
    /// <param name="_wmsLocationId">
    /// Location in a warehouse.
    /// </param>
    /// <param name="_inventLocationId">
    /// Identify the warehouse.
    /// </param>
    /// <param name="_itemId">
    /// Identify item.
    /// </param>
    /// <param name="_handlingQty">
    /// Number of units.
    /// </param>
    /// <param name="_allowSplit">
    /// Indicates if quantity can be split.
    /// </param>
    /// <param name="_inventDimId">
    /// Identifies inventory dimensions.
    /// </param>
    /// <param name="_currentUOM">
    /// Identifies current unit of adjustment in item.
    /// </param>
    /// <param name="_containerTypeCode">
    /// The container type code.
    /// </param>
    /// <returns>
    /// Quantity that can fit the specified location.
    /// </returns>
    [Hookable(false)]
    internal Qty validateVolumetricsHandlingUnit(
        WMSLocationId           _wmsLocationId,
        InventLocationId        _inventLocationId,
        ItemId                  _itemId,
        InventHandlingQty       _handlingQty,
        boolean                 _allowSplit,
        InventDimId             _inventDimId,
        UnitOfMeasureSymbol     _currentUOM,
        WHSContainerTypeCode    _containerTypeCode)
    {
        if (!WHSCatchWeightConfigurationKeyManager::instance().mustExecuteNonCatchWeightItemLogic(funcName(), _itemId))
        {
            return this.validateVolumetricsAllUnits(_wmsLocationId,
                                                    _inventLocationId,
                                                    _itemId,
                                                    _handlingQty,
                                                    _allowSplit,
                                                    _inventDimId,
                                                    _currentUOM,
                                                    _containerTypeCode);
        }

        return this.validateVolumetrics(_wmsLocationId,
                                        _inventLocationId,
                                        _itemId,
                                        _handlingQty,
                                        _allowSplit,
                                        _inventDimId,
                                        _currentUOM,
                                        _containerTypeCode);
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateVolumetricsAllUnits</Name>
				<Source><![CDATA[
    private Qty validateVolumetricsAllUnits(
        WMSLocationId           _wmsLocationId,
        InventLocationId        _inventLocationId,
        ItemId                  _itemId,
        InventHandlingQty       _handlingQty,
        boolean                 _allowSplit,
        InventDimId             _inventDimId,
        UnitOfMeasureSymbol     _currentUOM,
        WHSContainerTypeCode    _containerTypeCode)
    {
        Qty returnQty;

        WMSLocation wmsLocation = WMSLocation::find(_wmsLocationId, _inventLocationId);

        if (WHSLocationProfile::isVolumetricsEnabledForProfileId(wmsLocation.LocProfileId))
        {
            WHSVolumetricsPutawayValidator validator = WHSVolumetricsPutawayValidator::newPutaway(
                _itemId,
                _inventDimId,
                _handlingQty,
                _currentUOM,
                _allowSplit);
            validator.parmReleasedProductUnitConverter(releasedProductUnitConverter);

            // Only use lp information if locate by is either ASN or mixed LP
            if (this.isLocatingWholeLP())
            {
                validator.parmLPInformation(lpInformation);
            }

            if (targetLicensePlateId != '')
            {
                validator.parmContainerTypeCode(WHSLicensePlate::find(targetLicensePlateId).ContainerTypeCode);
            }
            else if (_containerTypeCode != '')
            {
                validator.parmContainerTypeCode(_containerTypeCode);
            }

            returnQty = validator.validateLocation(wmsLocation);

            if (validator.validateLocationErrorMessage())
            {
                this.createWorkHistoryLine(_itemId, _handlingQty, _currentUOM, validator.validateLocationErrorMessage(), true);
            }
        }
        else
        {
            returnQty = _handlingQty;
        }

        return returnQty;
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareProductDimensions</Name>
				<Source><![CDATA[
    /// <summary>
    /// Compares the product dimensions between to inventDims.
    /// </summary>
    /// <param name="_inventDimId1">
    /// InventDimId value one.
    /// </param>
    /// <param name="_inventDimId2">
    /// InventDimId value two.
    /// </param>
    /// <param name="_itemId">
    /// The itemId used to determine the product dimension setup.
    /// </param>
    /// <returns>
    /// true if both inventDims have the same product dimension values; otherwise, false
    /// </returns>
    public static boolean compareProductDimensions(
        InventDimId _inventDimId1,
        InventDimId _inventDimId2,
        ItemId      _itemId)
    {
        InventDim   inventDim1;
        InventDim   inventDim2;

        inventDim1 = InventDim::find(_inventDimId1);
        inventDim2 = InventDim::find(_inventDimId2);

        return inventDim1
            && inventDim2
            && InventDim::isInventDimEqualProductDim(EcoResProductDimGroupSetup::newItemId(_itemId), inventDim1, inventDim2);
    }

]]></Source>
			</Method>
			<Method>
				<Name>compareBatches</Name>
				<Source><![CDATA[
    private static boolean compareBatches(InventDimId _inventDimId1, InventDimId _inventDimId2)
    {
        InventDim inventDim1 = InventDim::find(_inventDimId1);
        InventDim inventDim2 = InventDim::find(_inventDimId2);

        return inventDim1
            && inventDim2
            && inventDim1.InventBatchId == inventDim2.InventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getAllocAndAvailPhysicalQtyInTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Get the sum of quantity already allocated for picking and the available physical quantity in the <c>WHSTmpWorkLine</c> table.
    /// </summary>
    /// <param name="_inventDimId">
    /// Identification of dimensions for the item that is picked.
    /// </param>
    /// <param name="_inventLocationId">
    /// Warehouse in which the picking occurs.
    /// </param>
    /// <param name="_locationId">
    /// Location in a warehouse in which the picking occurs.
    /// </param>
    /// <param name="_itemId">
    /// Item number for which the already allocated picking quantity is checked.
    /// </param>
    /// <returns>
    /// Quantity already allocated for picking in the <c>WHSTmpWorkLine</c> table for the specified parameters.
    /// </returns>
    /// <remarks>
    /// We take pick quantity from all the waves, not only the current one. The reason for that is that
    /// we want to be pessimistic - better create extra replenishment work (if the other wave processing failed/canceled)
    /// than fail the wave later on because 2 waves would try to consume the same quantity.
    /// </remarks>
    public static InventQty getAllocAndAvailPhysicalQtyInTempTable(InventDimId            _inventDimId,
                                                                   InventLocationId       _inventLocationId,
                                                                   WMSLocationId          _locationId,
                                                                   ItemId                 _itemId)
    {
        WHSTmpWorkLine  tmpWorkLine;
        InventDim       inventDim;
        InventDimParm   inventDimParm;
        InventDim       inventDimCriteria = InventDim::find(_inventDimId);

        inventDimParm.initFromInventDim(inventDimCriteria);

        select sum(InventQty), sum(AvailPhysical) from tmpWorkLine
            where tmpWorkLine.wmsLocationId     == _locationId
            &&    tmpWorkLine.InventLocationId  == _inventLocationId
            &&    tmpWorkLine.ItemId            == _itemId
            &&    tmpWorkLine.WorkType          == WHSWorkType::Pick
                #InventDimExistsJoin(tmpWorkLine.inventDimId, inventDim, inventDimCriteria, inventDimParm);

        return tmpWorkLine.InventQty + tmpWorkLine.AvailPhysical;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalInTempTable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total quantity currently in the <c>WHSTmpWorkLine</c> table for a Pick or Put.
    /// </summary>
    /// <param name="_inventLocationId">
    /// The inventory location Id we are checking for tmpWorkLines.
    /// </param>
    /// <param name="_wmsLocationId">
    /// The wms location Id we are checking for tmpWorkLines.
    /// </param>
    /// <param name="_inventDim">
    /// The inventDim criteria for inventory we are checking in the location.
    /// </param>
    /// <param name="_unitId">
    /// The Unit of measure that the value should be returned in.
    /// </param>
    /// <param name="_itemId">
    /// The item we are checking for tmpWorkLines.
    /// </param>
    /// <param name="_workType">
    /// Determines if we are checking for a Pick or a Put work line.
    /// </param>
    /// <param name="_fefoBatchId">
    /// The batch for FEFO batch reservation strategy that is being checked.
    /// </param>
    /// <param name="_lpLocate">
    /// The LicensePlate for LP Round up strategy that is being checked.
    /// </param>
    /// <returns>
    /// Qty in the specified unit that is currently in the <c>WHSTmpWorkLine</c> table for the criteria.
    /// </returns>
    public static Qty getTotalInTempTable(
        InventLocationId      _inventLocationId,
        WMSLocationId         _wmsLocationId,
        InventDim             _inventDim,
        UnitOfMeasureSymbol   _unitId,
        ItemId                _itemId,
        WHSWorkType           _workType,
        WHSFEFOBatchId        _fefoBatchId = '',
        WHSLicensePlateId     _lpLocate = '')
    {
        if (WHSLocationDirectiveAcceptanceTestContext::isActive())
        {
            // Acceptance tests should not be impacted by on going activity in the temp table.
            return 0;
        }

        WHSTmpWorkLine  tmpWorkLine;
        Qty             qtyInWork;
        InventDim       inventDim;
        InventDimParm   inventDimParm;
        InventTable     inventTable;
        UnitOfMeasureRecId toUnitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(_unitId);

        if (_workType == WHSWorkType::Pick)
        {
            inventTable = InventTable::find(_itemId);
            inventDimParm = WHSReservationHierarchyInventDimUtil::initInventDimParmAboveLocation(inventTable);
            if (inventTable.isProductVariantUnitConversionEnabled())
            {
                // Get the total qty of pick tmpWorkLine records for an item that meet the inventDimCriteria for location level and above.
                while select DirectiveUOM, sum(DirectiveQty), InventDimId from tmpWorkLine
                    group by InventDimId, DirectiveUOM
                    where tmpWorkLine.ItemId            == _itemId
                    &&    tmpWorkLine.wmsLocationId     == _wmsLocationId
                    &&    tmpWorkLine.InventLocationId  == _inventLocationId
                    &&    tmpWorkLine.WorkType          == _workType
                    &&    !tmpWorkLine.OrderCommittedInventDimId
                    &&    (tmpWorkLine.fefoBatchId      == _fefoBatchId
                    ||    !_fefoBatchId)
                    &&    (tmpWorkLine.LocatedLPId      == _lpLocate
                    ||    !_lpLocate)
                        #InventDimExistsJoin(tmpWorkLine.inventDimId, inventDim, _inventDim, inventDimParm)
                {
                    qtyInWork += WHSLocationDirective::convertQty(
                        releasedProductUnitConverter,
                        tmpWorkLine.DirectiveQty,
                        UnitOfMeasure::unitOfMeasureIdBySymbol(tmpWorkLine.DirectiveUOM),
                        toUnitOfMeasureRecId,
                        _itemId,
                        tmpWorkLine.InventDimId);
                }
            }
            else
            {
                // Get the total qty of pick tmpWorkLine records for an item that meet the inventDimCriteria for location level and above.
                while select DirectiveUOM, sum(DirectiveQty) from tmpWorkLine
                    group by DirectiveUOM
                    where tmpWorkLine.ItemId            == _itemId
                    &&    tmpWorkLine.wmsLocationId     == _wmsLocationId
                    &&    tmpWorkLine.InventLocationId  == _inventLocationId
                    &&    tmpWorkLine.WorkType          == _workType
                    &&    !tmpWorkLine.OrderCommittedInventDimId
                    &&    (tmpWorkLine.fefoBatchId      == _fefoBatchId
                    ||    !_fefoBatchId)
                    &&    (tmpWorkLine.LocatedLPId      == _lpLocate
                    ||    !_lpLocate)
                        #InventDimExistsJoin(tmpWorkLine.inventDimId, inventDim, _inventDim, inventDimParm)
                {
                    qtyInWork += WHSLocationDirective::convertQty(
                        releasedProductUnitConverter,
                        tmpWorkLine.DirectiveQty,
                        UnitOfMeasure::unitOfMeasureIdBySymbol(tmpWorkLine.DirectiveUOM),
                        toUnitOfMeasureRecId,
                        _itemId);
                }
            }

            // Deduct the immediate replenishment quantities
            select sum(AvailPhysical), sum(InventQty) from tmpWorkLine
                where tmpWorkLine.ItemId            == _itemId
                &&    tmpWorkLine.wmsLocationId     == _wmsLocationId
                &&    tmpWorkLine.InventLocationId  == _inventLocationId
                &&    tmpWorkLine.WorkType          == _workType
                &&    !tmpWorkLine.OrderCommittedInventDimId
                &&    tmpWorkLine.ReplenDemand 
                &&    tmpWorkLine.ImmediateReplenishmentUnitId
                &&    (tmpWorkLine.fefoBatchId      == _fefoBatchId
                ||    !_fefoBatchId)
                &&    (tmpWorkLine.LocatedLPId      == _lpLocate
                ||    !_lpLocate)
                    #InventDimExistsJoin(tmpWorkLine.inventDimId, inventDim, _inventDim, inventDimParm);

            qtyInWork -= (tmpWorkLine.InventQty - tmpWorkLine.AvailPhysical);
        }
        else if (_workType == WHSWorkType::Put)
        {
            // Get the total qty of put tmpWorkLine records for the location.
            while select DirectiveUOM, ItemId, sum(DirectiveQty), InventDimId from tmpWorkLine
                group by ItemId, InventDimId, DirectiveUOM
                where tmpWorkLine.InventLocationId  == _inventDim.InventLocationId
                &&    tmpWorkLine.wmsLocationId     == _wmsLocationId
                &&    tmpWorkLine.InventLocationId  == _inventLocationId
                &&    tmpWorkLine.WorkType          == _workType
            {
                qtyInWork += WHSLocationDirective::convertQty(
                    releasedProductUnitConverter,
                    tmpWorkLine.DirectiveQty,
                    UnitOfMeasure::unitOfMeasureIdBySymbol(tmpWorkLine.DirectiveUOM),
                    toUnitOfMeasureRecId,
                    _itemId,
                    tmpWorkLine.InventDimId);
            }
        }

        return qtyInWork;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getTotalQtyInLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Retrieves the total quantity of any item in a location
    /// </summary>
    /// <param name="_inventLocationId">
    /// The inventory location ID.
    /// </param>
    /// <param name="_locationId">
    /// The warehouse location ID.
    /// </param>
    /// <param name="_unitId">
    /// The Unit of measure that the value should be returned in.
    /// </param>
    /// <param name="_allowMixedItems">
    /// A Boolean value indicating whether the location allows mixed items.
    /// </param>
    /// <param name="_allowMixedBatches">
    /// A Boolean value indicating whether the location allows mixed batches; optional.
    /// </param>
    /// <returns>
    /// Qty in the specified unit that is currently in the location for the criteria.
    /// </returns>
    public static container getTotalQtyInLocation(
        InventLocationId    _inventLocationId,
        WMSLocationId       _locationId,
        UnitOfMeasureSymbol _unitId,
        boolean             _allowMixedItems,
        boolean             _allowMixedBatches  = true)
    {
        WHSWorkTable                                workTable;
        WHSWorkLine                                 workLine;
        InventTable                                 workInventTable;
        UnitOfMeasure                               workUnitOfMeasure;
        WHSLocationOnHandConstraintQueryType        queryType;
        WHSLocationOnHandConstraintQryEnumerator    onHandEnumerator;
        InventDim                                   onHandInventDim;
        InventDimId                                 inventDimId;
        InventDimId                                 tmpInventDimId;
        ItemId                                      itemId;
        ItemId                                      tmpItemId;
        UnitOfMeasureRecId                          unitOfMeasureRecId;
        boolean                                     canConvert;

        EcoResReleasedProductUnitConverter          releasedProductUnitConverterSkippingProductMasterCheck = EcoResReleasedProductUnitConverter::construct();

        releasedProductUnitConverterSkippingProductMasterCheck.parmSkipProductMasterCheck(true); // we can skip the product master check since we know that the inventory dimensions are coming from on hand and source documents and thus contain all product dimensions

        unitOfMeasureRecId = UnitOfMeasure::unitOfMeasureIdBySymbol(_unitId);

        queryType = WHSLocationOnHandConstraintQueryType::newNoDelta();
        queryType.parmGroupByItem(true);
        queryType.parmGroupByVariant(true);

        // If mixed items are allowed, then mixed batches should also be allowed, so there is no need to group by batch
        if (!_allowMixedItems && !_allowMixedBatches)
        {
            queryType.parmGroupByBatch(true);
        }

        onHandEnumerator = WHSLocationOnHandConstraintQuery::getEnumeratorByLocationId(queryType, _inventLocationId, _locationId);

        Qty currentQty;
        Qty convertedQty;

        while (onHandEnumerator.moveNext())
        {
            onHandInventDim = InventDim::findOrCreate(onHandEnumerator.currentInventDim());

            [canConvert, convertedQty] = releasedProductUnitConverterSkippingProductMasterCheck.tryConvert(
                                                            onHandEnumerator.currentHandlingPhysicalInvent(),
                                                            onHandEnumerator.currentHandlingUnitOfMeasureRecId(),
                                                            unitOfMeasureRecId,
                                                            NoYes::No, // round absolute value
                                                            onHandEnumerator.currentItemId(),
                                                            onHandInventDim.InventDimId,
                                                            NoYes::No); // apply rounding

            if (canConvert)
            {
                currentQty += convertedQty;
            }

            if (!_allowMixedItems)
            {
                // If mixed items or batches are not allowed, the query will only iterate once in this loop
                // because previous transactions could not have violated the mixed item or batches constraint on the location.
                itemId = onHandEnumerator.currentItemId();
                tmpItemId = itemId;
                inventDimId = onHandInventDim.InventDimId;
                tmpInventDimId = inventDimId;
            }
        }

        Qty workByUnitQty;

        // Qty that's placed in the location for other work in process
        while select ItemId, InventDimId, QtyWork from workLine
            join Product from workInventTable
                where workInventTable.ItemId == workLine.ItemId
            join RecId from workUnitOfMeasure
                where workUnitOfMeasure.Symbol == workLine.UnitId
            exists join workTable
                where (workLine.WorkStatus == WHSWorkStatus::Open || workLine.WorkStatus == WHSWorkStatus::InProcess)
                    && workLine.WorkType == WHSWorkType::Put
                    && workLine.wmsLocationId == _locationId
                    && workTable.InventLocationId == _inventLocationId
                    && workLine.UnitId != ''
                    && workLine.WorkId == workTable.WorkId
        {
            [canConvert, convertedQty] = releasedProductUnitConverterSkippingProductMasterCheck.tryConvert(workLine.QtyWork,
                                                                  workUnitOfMeasure.RecId,
                                                                  unitOfMeasureRecId,
                                                                  NoYes::No, // round absolute value
                                                                  workLine.ItemId,
                                                                  workLine.InventDimId,
                                                                  NoYes::No); // apply rounding
            if (canConvert)
            {
                workByUnitQty += convertedQty;
            }

            if (!_allowMixedItems)
            {
                if (tmpItemId && tmpItemId != workLine.ItemId)
                {
                    itemId = '';
                }
                else
                {
                    itemId = workLine.ItemId;
                }

                if (tmpInventDimId && !WHSLocationDirective::compareProductDimensions(tmpInventDimId, workLine.InventDimId, workLine.ItemId))
                {
                    inventDimId = '';
                }
                else
                {
                    inventDimId = workLine.InventDimId;
                }

                tmpItemId = workLine.ItemId;
                tmpInventDimId = workLine.InventDimId;
            }
        }

        Qty totalQty = currentQty + workByUnitQty;

        return [itemId, inventDimId, totalQty];
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateFinalPutLocationRequirements</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates that all requirements are met by the location for a final put work line.
    /// </summary>
    /// <param name="_location">
    /// The location to validate.
    /// </param>
    /// <param name="_workTransType">
    /// The workTransType of the work being validated.
    /// </param>
    /// <param name="_locationProfile">
    /// The location profile of the location being validated; optional.
    /// </param>
    /// <returns>
    /// A container with a boolean of true if all validation requirements are met; otherwise, false, and an error message.
    /// </returns>
    public static container validateFinalPutLocationRequirements(
        WMSLocation         _location,
        WHSWorkTransType    _workTransType,
        WHSLocationProfile  _locationProfile = null)
    {
        boolean             ret = true;
        str                 errorText;

        WhsWorkTransactionType workTransactionType = WhsWorkTransactionType::singletonFromType(_workTransType);

        if (workTransactionType)
        {
            WHSLocationProfile  locationProfile = _locationProfile;
            if (!locationProfile)
            {
                locationProfile = _location.whsLocationProfile();
            }

            errorText = workTransactionType.validateFinalPutLocationRequirements(_location, locationProfile);
            if (errorText)
            {
                ret = false;
            }
        }

        return [ret, errorText];
    }

]]></Source>
			</Method>
			<Method>
				<Name>checkFixedVariantLocation</Name>
				<Source><![CDATA[
    /// <summary>
    /// Checks to make sure the location is a fixed location for the product variant if needed.
    /// </summary>
    /// <param name="_useFixedVariantLocations">
    /// Determines if we must use fixed locations or not.
    /// </param>
    /// <param name="_inventDimId">
    /// Inventory dimension ID for the dimension criteria.
    /// </param>
    /// <returns>
    /// true if the location is a fixed location for the product variant or if we are not using fixed locations; otherwise, false.
    /// </returns>
    private boolean checkFixedVariantLocation(boolean _useFixedVariantLocations, InventDimId _inventDimId)
    {
        boolean                 ret = true;
        InventDim               inventDim;
        InventDim               productDims;
        EcoResProduct           ecoResProduct;

        if (_useFixedVariantLocations)
        {
            inventDim = InventDim::find(_inventDimId);
            if (!inventDim.anyProductDimensionSpecified())
            {
                this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@WAX1744", location.wmsLocationId), true, statusId);

                if (findPickPutLocationPerformanceTask)
                {
                    findPickPutLocationPerformanceTask.checkFixedVariantLocationProduct();
                }

                ret = false;
            }
            else
            {
                productDims.initFromInventDim(inventDim, InventDim::dimProductDimensionEnabledFieldList());
                productDims = InventDim::findOrCreate(productDims);

                if (!WHSProductVariantFixedLocation::exist(itemId, productDims.InventDimId, location.InventLocationId, location.wmsLocationId))
                {
                    ecoResProduct = EcoResProduct::find(InventDimCombination::findByInventDim(itemId, productDims).DistinctProductVariant);
                    this.createWorkHistoryLine(itemId, inventQty, inventUOM, strFmt("@SYP4980045", location.wmsLocationId, ecoResProduct.DisplayProductNumber), true, statusId);

                    if (findPickPutLocationPerformanceTask)
                    {
                        findPickPutLocationPerformanceTask.checkFixedVariantLocation();
                    }

                    ret = false;
                }
            }
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>validateLocDirAction</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validates if the location directive action is valid and can be used to find a location
    /// </summary>
    /// <param name="_itemId">
    /// The item for which location directive should be found.
    /// </param>
    /// <param name="_qty">
    /// The qty used to lookup the location.
    /// </param>
    /// <param name="_uom">
    /// The unit of measure used to lookup the location.
    /// </param>
    /// <param name="_locDirAction">
    /// The location directive action to be validated.
    /// </param>
    /// <param name="_guideLicensePlates">
    /// List of license plates that need to be picked - valid only for location directive strategy GuidedLPLocate
    /// </param>
    /// <returns>
    /// true if the location directive action is valid; otherwise false.
    /// </returns>
    protected boolean validateLocDirAction(ItemId _itemId, Qty _qty, UnitOfMeasureSymbol _uom, WHSLocDirAction _locDirAction, List _guideLicensePlates = null)
    {
        boolean ret = true;

        if ((_locDirAction.LocDirStrategy == WHSLocDirStrategy::GuidedLPLocate) &&
            (!_guideLicensePlates || (_guideLicensePlates.elements() == 0)))
        {
            ret = false;
            this.createWorkHistoryLine(_itemId, _qty, _uom, strFmt("@SYP5070007", _locDirAction.LocDirName), true);
        }

        return ret;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocationDirectiveActionApplicable</Name>
				<Source><![CDATA[
    /// <summary>
    /// Determines if the current location directive action applies for the specified product and quantity
    /// </summary>
    /// <param name = "_locDirAction">The location directive action to evaluate.</param>
    /// <param name = "_itemId">The item number, for which we are searching for a location.</param>
    /// <param name = "_inventDim">The product dimensions of the item. Note, that the record holds more than just the product dimensions.</param>
    /// <param name = "_qty">The quantity being processed.</param>
    /// <param name = "_uom">The unit of measure being processed.</param>
    /// <returns>true, if the location directive action applies for the specified product and quantity; otherwise, false.</returns>
    protected boolean isLocationDirectiveActionApplicable(WHSLocDirAction _locDirAction, ItemId _itemId, InventDim _inventDim, Qty _qty, UnitOfMeasureSymbol _uom)
    {
        switch (_locDirAction.UseInventFixedLocation)
        {
            case WHSUseFixedLocations::ProductVariantFixed:
                return this.isProductApplicableForProductVariantFixedLocDirAction(_locDirAction, _itemId, _inventDim, _qty, _uom);

            case WHSUseFixedLocations::ProductFixed:
                if (!WHSInventFixedLocation::existsForItemInWarehouse(_itemId, locDirTable.InventLocationId))
                {
                    this.createWorkHistoryLine(_itemId, _qty, _uom, strFmt("@WAX:LocDirActionFail_NoFixedLoc", _locDirAction.LocDirName, _itemId, locDirTable.InventLocationId), true);
                    return false;
                }
                break;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isProductApplicableForProductVariantFixedLocDirAction</Name>
				<Source><![CDATA[
    private boolean isProductApplicableForProductVariantFixedLocDirAction(WHSLocDirAction _locDirAction, ItemId _itemId, InventDim _inventDim, Qty _qty, UnitOfMeasureSymbol _uom)
    {
        if (!InventTable::find(_itemId).Product().isProductMaster())
        {
            this.createWorkHistoryLine(_itemId, _qty, _uom, strFmt("@WAX:LocDirActionFail_FixedProductVariantForDistinctProduct", _locDirAction.LocDirName, _itemId), true);
            return false;
        }
                
        InventDim productDim;
        productDim.initFromInventDim(_inventDim, productDimEnabledFieldList);
        productDim = InventDim::findOrCreate(productDim);

        if (!WHSProductVariantFixedLocation::existsForProductVariantInWarehouse(_itemId, productDim.inventDimId, locDirTable.InventLocationId))
        {
            this.createWorkHistoryLine(_itemId, _qty, _uom, strFmt("@WAX:LocDirActionFail_NoVariantFixedLoc", _locDirAction.LocDirName, _itemId, productDim.preFix(productDimEnabledFieldList), locDirTable.InventLocationId), true);
            return false;
        }

        return true;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a real value measured in one unit of measure to the real value measured in another unit of measure.
    /// </summary>
    /// <param name="_releasedProductUnitConverter">
    /// The unit converter.
    /// </param>
    /// <param name="_qty">
    /// A real value measured in the unit of measure to convert from.
    /// </param>
    /// <param name="_fromUnitOfMeasure">
    /// A unit of measure ID to convert from.
    /// </param>
    /// <param name="_toUnitOfMeasure">
    /// A unit of measure ID to convert to.
    /// </param>
    /// <param name="_itemId">
    /// A item ID.
    /// </param>
    /// <param name="_inventDimId">
    /// The dimensions for the item; optional.
    /// </param>
    /// <returns>
    /// The converted value; zero, if no conversion between the units of measure exists.
    /// </returns>
    public static Qty convertQty(
        EcoResReleasedProductUnitConverter  _releasedProductUnitConverter,
        Qty                                 _qty,
        UnitOfMeasureRecId                  _fromUnitOfMeasure,
        UnitOfMeasureRecId                  _toUnitOfMeasure,
        ItemId                              _itemId,
        InventDimId                         _inventDimId = '')
    {
        if (_releasedProductUnitConverter.canBeConverted(_fromUnitOfMeasure,
                                                         _toUnitOfMeasure,
                                                         _itemId,
                                                         _inventDimId))
        {
            return _releasedProductUnitConverter.convert(_qty,
                                                         _fromUnitOfMeasure,
                                                         _toUnitOfMeasure,
                                                         NoYes::No,
                                                         _itemId,
                                                         _inventDimId,
                                                         NoYes::No);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>convertQtyGivenUnitSymbols</Name>
				<Source><![CDATA[
    /// <summary>
    /// Converts a real value measured in one unit of measure to the real value measured in another unit of measure.
    /// </summary>
    /// <param name="_releasedProductUnitConverter">
    /// The unit converter.
    /// </param>
    /// <param name="_qty">
    /// A real value measured in the unit of measure to convert from.
    /// </param>
    /// <param name="_fromUnitOfMeasure">
    /// A unit of measure ID to convert from.
    /// </param>
    /// <param name="_toUnitOfMeasure">
    /// A unit of measure ID to convert to.
    /// </param>
    /// <param name="_itemId">
    /// A item ID.
    /// </param>
    /// <param name="_inventDimId">
    /// The dimensions for the item; optional.
    /// </param>
    /// <returns>
    /// The converted value; zero, if no conversion between the units of measure exists.
    /// </returns>
    public static Qty convertQtyGivenUnitSymbols(
        EcoResReleasedProductUnitConverter  _releasedProductUnitConverter,
        Qty                                 _qty,
        UnitOfMeasureSymbol                 _fromUnitOfMeasure,
        UnitOfMeasureSymbol                 _toUnitOfMeasure,
        ItemId                              _itemId,
        InventDimId                         _inventDimId = '')
    {
        if (_releasedProductUnitConverter.canBeConvertedGivenUnitSymbols(_fromUnitOfMeasure,
                                                         _toUnitOfMeasure,
                                                         _itemId,
                                                         _inventDimId))
        {
            return _releasedProductUnitConverter.convertGivenUnitSymbols(_qty,
                                                         _fromUnitOfMeasure,
                                                         _toUnitOfMeasure,
                                                         NoYes::No,
                                                         _itemId,
                                                         _inventDimId,
                                                         NoYes::No);
        }
        return 0;
    }

]]></Source>
			</Method>
			<Method>
				<Name>inventDimCriteriaForValidSellableDaysQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Creates the dimension criteria for finding the amount of inventory for an item that is valid based on sellable days.
    /// </summary>
    /// <param name = "_matchingDirective">The matching directive.</param>
    /// <param name = "_itemId">The item to validate.</param>
    /// <param name = "_location">The location to validate.</param>
    /// <param name = "_batchId">The specific batch to validate.</param>
    /// <returns>The criteria.</returns>
    protected InventDim inventDimCriteriaForValidSellableDaysQty(
        WhsLocationDirectiveMatch   _matchingDirective,
        ItemId                      _itemId,
        WMSLocation                 _location,
        InventBatchId               _batchId)
    {
        InventDim inventDimCriteria;
        inventDimCriteria.InventLocationId = _location.inventLocationId;
        inventDimCriteria.wmsLocationId = _location.wmslocationId;
        
        if (_batchId)
        {
            // For FEFO batch strategy pass in the batch Id so it only the current batch is accounted for.
            WhsLocationDirectiveStrategy strategyClass = WhsLocationDirectiveStrategy::singletonFromStrategy(_matchingDirective.strategy);
            if (strategyClass && strategyClass.requiresBatchDimension())
            {
                inventDimCriteria.inventBatchId = _batchId;
            }
            else if (WHSReservationHierarchyInventDimUtil::isBatchAboveLocation(InventTable::find(_itemId)))
            {
                inventDimCriteria.inventBatchId = _batchId;
            }
        }
        return inventDim::findOrCreate(inventDimCriteria);
    }

]]></Source>
			</Method>
			<Method>
				<Name>getValidSellableDaysQty</Name>
				<Source><![CDATA[
    /// <summary>
    /// Finds the amount of inventory for a criteria for an item that is valid based on sellable days.
    /// </summary>
    /// <param name="_item">
    /// The item to find.
    /// </param>
    /// <param name="_itemDim">
    /// The inventory dimensions associated with the item.
    /// </param>
    /// <param name="_inventDimCriteria">
    /// The inventory dimension criteria that is being validated.
    /// </param>
    /// <param name="_custAccount">
    /// Optional; the customer associated with the work.
    /// </param>
    /// <returns>
    /// The inventory that is valid based on batch expiration date.
    /// </returns>
    private InventQty getValidSellableDaysQty(
        InventTable     _item,
        InventDim       _itemDim,
        InventDim       _inventDimCriteria,
        CustAccount     _custAccount = '')
    {
        InventQty       validAmount;

        boolean includeDeltaRecords = InventUpdateOnhandGlobal::mustAddInventSumDeltaOnhand(_item.ItemId);

        using (var locationDirectiveActivityContext = instrumentationLogger.locationDirectiveActivities().getValidSellableDaysQty(includeDeltaRecords))
        {
            List reservationHiearchyListAllFields = WHSreservationHierarchyProvider::construct().getDimListAllFromInventTable(
                                                                       _item,
                                                                       WHSReservationHierarchySortOrder::BottomUp);

            int iterations = 0;
                   
            if (!_item.isShelfLifeItem())
            {
                WHSReservationHierarchyLevel deepestLevel = WHSReservationHierarchyInventDimUtil::deepestLevelFromInventDimParm(reservationHiearchyListAllFields, _inventDimCriteria.toDimParm());

                validAmount = WHSInventOnHand::getAvailPhysicalHandlingQuantityForLevel(_item.ItemId,
                                                                                        _inventDimCriteria,
                                                                                        deepestLevel,
                                                                                        includeDeltaRecords);
            }
            else if (InventUseDimOfInventSumToggle::instance().isEnabled())
            {
                InventSum inventSum;
                Map validatedBatches = new Map(Types::String, Types::Enum);
                date expiryDate = this.calcDateToCheckExpiryDate();

                while select PhysicalInvent, InventDimId, #InventDimGroupAllFields from inventSum
                where inventSum.ItemId           == _item.ItemId
                   && inventSum.PhysicalInvent   >  0
                   && inventSum.ClosedQty        == NoYes::No
                   && #InventDimFieldsFilter(inventSum, _inventDimCriteria, _inventDimCriteria.toDimParm())
                   && inventSum.inventBatchId != ''
                {
                    boolean isBatchValid;
                    iterations++;

                    if (validatedBatches.exists(inventSum.inventBatchId))
                    {
                        isBatchValid = validatedBatches.lookup(inventSum.inventBatchId);
                    }

                    else
                    {
                        isBatchValid = InventBatch::pdsCheckExpiryDate(inventSum.inventBatchId, _item.ItemId, expiryDate, false, _custAccount, false, _itemDim);
                        validatedBatches.insert(inventSum.inventBatchId, isBatchValid);
                    }

                    if (isBatchValid)
                    {
                        InventDim inventDim;
                        inventDim.initFromInventSum(inventSum);
                        // By looping through the physical inventory we get the dimensions on the deepest level in the hierarchy since this is where the actual on-hand is.
                        // We need to take reservations into account. We do not know if the caller has a reservations above the deepest level,
                        // e.g. on the location so we can only check the deepest level to avoid conflicting with the callers own reservations.
                        WHSReservationHierarchyLevel deepestLevel = WHSReservationHierarchyInventDimUtil::deepestLevelFromInventDimParm(reservationHiearchyListAllFields, inventDim.toDimParm());
                        validAmount += WHSInventOnHand::getAvailPhysicalHandlingQuantityForLevel(_item.ItemId,
                                                                                             inventDim,
                                                                                             deepestLevel,
                                                                                             includeDeltaRecords);


                        if (validAmount >= availQty)
                        {
                            break;
                        }
                    }
                }
            }
            else
            {
                InventDim inventDim;
                InventSum inventSum;
                date expiryDate = this.calcDateToCheckExpiryDate();

                while select PhysicalInvent, InventDimId from inventSum
                where inventSum.ItemId           == _item.ItemId
                   && inventSum.PhysicalInvent   >  0
                   && inventSum.ClosedQty        == NoYes::No
                #InventDimInnerJoin(inventSum.inventDimId, inventDim, _inventDimCriteria, _inventDimCriteria.toDimParm())
                && inventDim.inventBatchId != ''
                {
                    iterations++;

                    if (InventBatch::pdsCheckExpiryDate(inventDim.inventBatchId, _item.ItemId, expiryDate, false, _custAccount, false, _itemDim))
                    {
                        // By looping through the physical inventory we get the dimensions on the deepest level in the hierarchy since this is where the actual on-hand is.
                        // We need to take reservations into account. We do not know if the caller has a reservations above the deepest level,
                        // e.g. on the location so we can only check the deepest level to avoid conflicting with the callers own reservations.
                        WHSReservationHierarchyLevel deepestLevel = WHSReservationHierarchyInventDimUtil::deepestLevelFromInventDimParm(reservationHiearchyListAllFields, inventDim.toDimParm());

                        validAmount += WHSInventOnHand::getAvailPhysicalHandlingQuantityForLevel(_item.ItemId,
                                                                                             inventDim,
                                                                                             deepestLevel,
                                                                                             includeDeltaRecords);

                        if (validAmount >= availQty)
                        {
                            break;
                        }
                    }
                }
            }
            instrumentationLogger.logInformation(strFmt('%1: %2', instrumentationLogger.properties().Iterations, iterations));
        }

        return validAmount;
    }

]]></Source>
			</Method>
			<Method>
				<Name>supportSearchBasedOnDispositionCode</Name>
				<Source><![CDATA[
    /// <summary>
    /// Validate whether the transaction type supports location directive for disposition code.
    /// </summary>
    /// <param name="_workTransType">
    /// The workTransType of the work being validated.
    /// </param>
    /// <returns>
    /// true if search based on disposition code is supporter; otherwise, false.
    /// </returns>
    public static boolean supportSearchBasedOnDispositionCode(WHSWorkTransType _workTransType)
    {
        switch(_workTransType)
        {
            case WHSWorkTransType::Purch:
            case WHSWorkTransType::ReturnOrder:
            case WHSWorkTransType::KanbanPick:
            case WHSWorkTransType::KanbanPut:
            case WHSWorkTransType::ProdPut:
                return true;
            default:
                return false;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>assignInventTestAssociationTableReferenceId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Assign the quality association reference record ID.
    /// </summary>
    /// <param name = "_inventTestAssociationTableRecId">The <c>InventTestAssociationTable</c> record ID.</param>
    [Hookable(false)]
    final internal void assignInventTestAssociationTableReferenceId(InventTestAssociationTableRecId _inventTestAssociationTableRecId)
    {
        inventTestAssociationTableRecId = _inventTestAssociationTableRecId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOriginWorkId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set origin work id 
    /// </summary>
    /// <param name = "_originWorkId">Origin work id to set</param>
    [Hookable(false)]
    final internal void setOriginWorkId(WhsWorkId _originWorkId)
    {
        originWorkId = _originWorkId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>setOriginRefId</Name>
				<Source><![CDATA[
    /// <summary>
    /// Set origin reference id
    /// </summary>
    /// <param name = "_originRefId">Origin work id to set</param>
    [Hookable(false)]
    final internal void setOriginRefId(WHSOriginRefId _originRefId)
    {
        originRefId = _originRefId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>calcDateToCheckExpiryDate</Name>
				<Source><![CDATA[
    private date calcDateToCheckExpiryDate()
    {
        if (tmpWorkLine.OrderNum
            && tmpWorkLine.WorkTransType == WHSWorkTransType::Sales)
        {
            return SalesLine::findInventTransId(tmpWorkLine.InventTransId).getExpiryCheckDate();
        }
        else
        {
            return DateTimeUtil::getSystemDate(DateTimeUtil::getUserPreferredTimeZone());
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>parmInventBatchId</Name>
				<Source><![CDATA[
    [Hookable(false)]
    internal InventBatchId parmInventBatchId(InventBatchId _inventBatchId = inventBatchId)
    {
        inventBatchId = _inventBatchId;
        return inventBatchId;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isLocatingWholeLPSupported</Name>
				<Source><![CDATA[
    [Wrappable(true)]
    internal static boolean isLocatingWholeLPSupported(WHSWorkTransType _workTransType)
    {
        return _workTransType == WHSWorkTransType::Purch
            || (_workTransType == WHSWorkTransType::TransferReceipt && WHSTransferReceiptASNFlight::instance().isEnabled());
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>