<?xml version="1.0" encoding="utf-8"?>
<AxClass xmlns:i="http://www.w3.org/2001/XMLSchema-instance">
	<Name>ProjSplitTransaction</Name>
	<SourceCode>
		<Declaration><![CDATA[
/// <summary>
///		Used to split posted project transactions.
/// </summary>
class ProjSplitTransaction
{

}
]]></Declaration>
		<Methods>
			<Method>
				<Name>main</Name>
				<Source><![CDATA[
    public static void main(Args _args)
    {
        if (!_args)
        {
            throw error("@SYS25407");
        }

        ProjSplitTransaction projSplitTransaction = ProjSplitTransaction::construct();
        if (!projSplitTransaction.isSupportedDataSet(_args.record()))
        {
            throw error("@Proj:UnsupportedDataset");
        }

        projSplitTransaction.process(_args);
    }

]]></Source>
			</Method>
			<Method>
				<Name>construct</Name>
				<Source><![CDATA[
    public static ProjSplitTransaction construct()
    {
        return new ProjSplitTransaction();
    }

]]></Source>
			</Method>
			<Method>
				<Name>new</Name>
				<Source><![CDATA[
    protected void new()
    {
        super();
    }

]]></Source>
			</Method>
			<Method>
				<Name>canRunInNewSession</Name>
				<Source><![CDATA[
    protected boolean canRunInNewSession()
    {
        return false;
    }

]]></Source>
			</Method>
			<Method>
				<Name>description</Name>
				<Source><![CDATA[
    public static ClassDescription description()
    {
        return "@Proj:SplitProjectTransaction";
    }

]]></Source>
			</Method>
			<Method>
				<Name>process</Name>
				<Source><![CDATA[
    /// <summary>
    /// Process the recordset of the calling object.
    /// </summary>
    /// <param name="_args">
    /// The args object sent by the calling object.
    /// </param>
	protected void process(Args _args)
    {
        FormDataSource formDataSource;
        Integer TransactionsNotSplitable = 0;

        formDataSource = FormDataUtil::getFormDataSource(_args.record());

        DictTable dictTable = new DictTable(_args.record().TableId);
        Common transaction = dictTable.makeRecord();

        if (formDataSource)
        {
			transaction = formDataSource.getFirst(true) ? formDataSource.getFirst(true) : formDataSource.cursor();
        }
		else
        {
            transaction = _args.record();
        }
		while (transaction)
        {
            if (ProjSplitTransaction::canSplitTransaction(transaction))
            {
                this.createNewTransaction(transaction);
            }
            else
            {
                TransactionsNotSplitable += 1;
            }
            if (formDataSource)
            {
				transaction = formDataSource.getNext();
            }
			else
            {
                transaction.clear();
            }
        }

        if (TransactionsNotSplitable > 0)
        {
            warning("@Proj:TransactionsCannotBeSplit");
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateCostSalesPrices</Name>
				<Source><![CDATA[
    /// <summary>
    /// Update the unit price on the cost and sales records for the transaction.
    /// </summary>
    /// <param name="_transId">
    /// The ID of the transaction whose cost and sales prices will be updated.
    /// </param>
    /// <param name="_TransType">
    /// The type of the transaction.
    /// </param>
    protected void updateCostSalesPrices(ProjTransIdBase _transId, ProjTransType _TransType)
    {
        // Only Item transactions have a unit price rounding factor.
        ttsbegin;
		switch (_TransType)
        {
            case ProjTransType::Cost:
                ProjCostTrans projCostTrans = ProjCostTrans::find(_transId);
                ProjCostTransCost projCostTransCost;
				while select forupdate projCostTransCost where ProjCostTransCost.TransId == _transId
                {
                    projCostTransCost.CostPrice = round(projCostTransCost.LineAmount / projCostTrans.Qty, 0.01);
                    projCostTransCost.update();
                }

                ProjCostTransSale projCostTransSale;
                while select forupdate projCostTransSale where projCostTransSale.TransId == _transId
                {
                    projCostTransSale.SalesPrice = round(projCostTransSale.LineAmount / projCostTrans.Qty, 0.01);
                    projCostTransSale.update();
                }
                break;

            case ProjTransType::Hour:
                ProjEmplTrans projEmplTrans = ProjEmplTrans::find(_transId);
                ProjEmplTransCost projEmplTransCost;
                while select forupdate projEmplTransCost where projEmplTransCost.TransId == _transId
                {
                    projEmplTransCost.CostPrice = round(projEmplTransCost.LineAmount / projEmplTrans.Qty, 0.01);
                    projEmplTransCost.update();
                }

                ProjEmplTransSale projEmplTransSale;
                while select forupdate projEmplTransSale where projEmplTransSale.TransId == _transId
                {
                    projEmplTransSale.SalesPrice = round(projEmplTransSale.LineAmount / projEmplTrans.Qty, 0.01);
                    projEmplTransSale.update();
                }         
               break;
  		
            case ProjTransType::Item:
                ProjItemTrans projItemTrans = ProjItemTrans::find(_transId);
                RoundOff roundOff = this.getDecimalRounding(projItemTrans.SalesUnit);
				
                ProjItemTransSale projItemTransSale;
                while select forupdate projItemTransSale where projItemTransSale.ProjTransId == _transId
                {
                    projItemTransSale.SalesPrice = round(projItemTransSale.LineAmount / projItemTrans.Qty, roundOff);
                    projItemTransSale.update();
                }
                break;
    
            case ProjTransType::Revenue:
				ProjRevenueTrans projRevenueTrans = ProjRevenueTrans::find(_transId);
				ProjRevenueTransSale projRevenueTransSale;
                while select forupdate projRevenueTransSale where projRevenueTransSale.TransId == _transId
				{
                    projRevenueTransSale.SalesPrice = round(projRevenueTransSale.LineAmount / projRevenueTrans.Qty, 0.01);
                    projRevenueTransSale.update();
				}
				break;

            // On-Account Transactions do not have a Qty or Unit Price for calculation
      }
      ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new project transaction record from an existing posted transaction
    ///		consisting of the non-invoiced funding sources.
    /// </summary>
    /// <param name="_transaction">
    ///		The original transaction.
    /// </param>
    protected void createNewTransaction(Common _transaction)
    {
        switch (_transaction.TableId)
        {
            case tableNum(ProjCostTrans):
                this.createNewCostTrans(_transaction);
                break;

            case tableNum(ProjEmplTrans):
                this.createNewEmplTrans(_transaction);
                break;

            case tableNum(ProjItemTrans):
                this.createNewItemTrans(_transaction);
                break;

            case tableNum(ProjRevenueTrans):
                this.createNewRevenueTrans(_transaction);
                break;

            case tableNum(ProjOnAccTrans):
                this.createNewOnAccTrans(_transaction);
                break;

            case tableNum(ProjPostTransView):
                ProjPostTransView projPostTransView = _transaction as ProjPostTransView;
                switch (projPostTransView.ProjTransType)
                {
                    case ProjTransType::Cost:
                        ProjCostTrans projCostTrans = ProjCostTrans::find(ProjPostTransView.TransId);
                        this.createNewCostTrans(projCostTrans);
                        break;

                    case ProjTransType::Hour:
                        ProjEmplTrans projEmplTrans = ProjEmplTrans::find(ProjPostTransView.TransId);
                        this.createNewEmplTrans(projEmplTrans);
                        break;

                    case ProjTransType::Item:
                        ProjItemTrans projItemTrans = ProjItemTrans::find(ProjPostTransView.TransId);
                        this.createNewItemTrans(projItemTrans);
                        break;
 
                    case ProjTransType::Revenue:
                        ProjRevenuetrans projRevenueTrans = ProjRevenueTrans::find(ProjPostTransView.TransId);
                        this.createNewRevenueTrans(projRevenueTrans);
                        break;
  
                    case ProjTransType::OnAccount:
                        ProjOnAccTrans projOnAccTrans = ProjOnAccTrans::find(ProjPostTransView.TransId);
                        this.createNewOnAccTrans(projOnAccTrans);
                        break;
                }
                break;
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>canSplitTransaction</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the record meets the requirments to be split.
    /// </summary>
    /// <returns>
    ///    true if the record meets the requirements; otherwise, false.
    /// </returns>
    public static boolean canSplitTransaction(Common _Transaction)
    {
        boolean returnValue = false;

        switch (_Transaction.TableId)
        {
            case tableNum(ProjCostTrans):
                ProjCostTrans projCostTrans = _Transaction as ProjCostTrans;
                returnValue = projCostTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
							  projCostTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
							  projCostTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                if (returnValue)
                {
                    // Verifiy not select for credit memo or on a proposal
                    ProjCostTransSale projCostTransSale;
                    select RecId from projCostTransSale
                        where projCostTransSale.TransId == projCostTrans.TransId &&
                            (projCostTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
                            projCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
                            projCostTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                    if (projCostTransSale)
                    {
                        returnValue = false;
                    }
                }
                break;

            case tableNum(ProjEmplTrans):
                ProjEmplTrans projEmplTrans = _Transaction as ProjEmplTrans;
                returnValue = projEmplTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
							  projEmplTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
							  projEmplTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                if (returnValue)
                {
                    // Verifiy not select for credit memo or on a proposal
                    ProjEmplTransSale projEmplTransSale;
                    select RecId from projEmplTransSale
                        where projEmplTransSale.TransId == projEmplTrans.TransId &&
                            (projEmplTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
                            projEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
                            projEmplTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                    if (projEmplTransSale)
                    {
                        returnValue = false;
                    }
                }
                break;

            case tableNum(ProjItemTrans):
                ProjItemTrans projItemTrans = _Transaction as ProjItemTrans;
                returnValue = projItemTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
							  projItemTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
							  projItemTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                if (returnValue)
                {
                    // Verifiy not select for credit memo or on a proposal
                    ProjItemTransSale projItemTransSale;
                    select RecId from projItemTransSale
                        where projItemTransSale.ProjTransId == projItemTrans.ProjTransId &&
                            (projItemTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
                            projItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
                            projItemTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                    if (projItemTransSale)
                    {
                        returnValue = false;
                    }
                }
                break;

            case tableNum(ProjRevenueTrans):
                ProjRevenueTrans projRevenueTrans = _Transaction as ProjRevenueTrans;
                returnValue = projRevenueTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
							  projRevenueTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
							  projRevenueTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                if (returnValue)
                {
                    // Verifiy not select for credit memo or on a proposal
                    ProjRevenueTransSale projRevenueTransSale;
                    select RecId from projRevenueTransSale
                        where projRevenueTransSale.TransId == projRevenueTrans.TransId &&
                            (projRevenueTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
                            projRevenueTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
                            projRevenueTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                    if (projRevenueTransSale)
                    {
                        returnValue = false;
                    }
                }
                break;

            case tableNum(ProjOnAccTrans):
                ProjOnAccTrans projOnAccTrans = _Transaction as ProjOnAccTrans;
                returnValue = projOnAccTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
							  projOnAccTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
							  projOnAccTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                if (returnValue)
                {
                    // Verifiy not select for credit memo or on a proposal
                    ProjOnAccTransSale projOnAccTransSale;
                    select RecId from projOnAccTransSale
                        where projOnAccTransSale.TransId == projOnAccTrans.TransId &&
                            (projOnAccTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
                            projOnAccTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
                            projOnAccTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                    if (projOnAccTransSale)
                    {
                        returnValue = false;
                    }
                }
                break;

            case tableNum(ProjPostTransView):
                ProjPostTransView projPostTransView = _Transaction as ProjPostTransView;
                switch (projPostTransView.ProjTransType)
                {
                    case ProjTransType::Cost:
                        ProjCostTrans viewProjCostTrans = ProjCostTrans::find(projPostTransView.TransId);
                        returnValue = viewProjCostTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold ||
									  viewProjCostTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
									  viewProjCostTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                        if (returnValue)
                        {
                            // Verifiy not select for credit memo or on a proposal
                            ProjCostTransSale viewProjCostTransSale;
                            select RecId from viewProjCostTransSale
								where viewProjCostTransSale.TransId == viewProjCostTrans.TransId &&
									(viewProjCostTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
									viewProjCostTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
									viewProjCostTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                            if (viewProjCostTransSale)
                            {
                                returnValue = false;
                            }
                        }
                        break;

                    case ProjTransType::Hour:
                        ProjEmplTrans viewProjEmplTrans = ProjEmplTrans::find(projPostTransView.TransId);
                        returnValue = viewProjEmplTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
									  viewProjEmplTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||							
									  viewProjEmplTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                        if (returnValue)
                        {
                            // Verifiy not select for credit memo or on a proposal
                            ProjEmplTransSale viewProjEmplTransSale;
                            select RecId from viewProjEmplTransSale
								where viewProjEmplTransSale.TransId == viewProjEmplTrans.TransId &&
									(viewProjEmplTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
									viewProjEmplTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
									viewProjEmplTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                            if (viewProjEmplTransSale)
                            {
                                returnValue = false;
                            }
                        }
                        break;

                    case ProjTransType::Item:
                        ProjItemTrans viewProjItemTrans = ProjItemTrans::find(projPostTransView.TransId);
                        returnValue = viewProjItemTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
									  viewProjItemTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
									  viewProjItemTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                        if (returnValue)
                        {
                            // Verifiy not select for credit memo or on a proposal
                            ProjItemTransSale viewProjItemTransSale;
                            select RecId from viewProjItemTransSale
								where viewProjItemTransSale.ProjTransId == viewProjItemTrans.ProjTransId &&
									(viewProjItemTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
									viewProjItemTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
									viewProjItemTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                            if (viewProjItemTransSale)
                            {
                                returnValue = false;
                            }
                        }
                        break;

                    case ProjTransType::Revenue:
                        ProjRevenueTrans viewProjRevenueTrans = ProjRevenueTrans::find(projPostTransView.TransId);
                        returnValue = viewProjRevenueTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold ||
									  viewProjRevenueTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
									  viewProjRevenueTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                        if (returnValue)
                        {
                            // Verifiy not select for credit memo or on a proposal
                            ProjRevenueTransSale viewProjRevenueTransSale;
                            select RecId from viewProjRevenueTransSale
                                where viewProjRevenueTransSale.TransId == viewProjRevenueTrans.TransId &&
									(viewProjRevenueTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
									viewProjRevenueTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
									viewProjRevenueTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                            if (viewProjRevenueTransSale)
                            {
                                returnValue = false;
                            }
                        }
                        break;

                    case ProjTransType::OnAccount:
                        ProjOnAccTrans viewProjOnAccTrans = ProjOnAccTrans::find(projPostTransView.TransId);
                        returnValue = viewProjOnAccTrans.projInvoiceStatus() == ProjInvoiceStatus::FullyInvoicedWithOnhold || 
									  viewProjOnAccTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoiced ||
									  viewProjOnAccTrans.projInvoiceStatus() == ProjInvoiceStatus::PartiallyInvoicedWithOnhold;
                        if (returnValue)
                        {
                            // Verifiy not select for credit memo or on a proposal
                            ProjOnAccTransSale viewProjOnAccTransSale;
                            select RecId from viewProjOnAccTransSale
                                where viewProjOnAccTransSale.TransId == viewProjOnAccTrans.TransId &&
									(viewProjOnAccTransSale.TransStatus == ProjTransStatus::MarkedCreditnote ||
									viewProjOnAccTransSale.TransStatus == ProjTransStatus::CreditnoteProposal ||
									viewProjOnAccTransSale.TransStatus == ProjTransStatus::InvoiceProposal) ;
                            if (viewProjOnAccTransSale)
                            {
                                returnValue = false;
                            }
                        }
                        break;
                }
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>isSupportedDataSet</Name>
				<Source><![CDATA[
    /// <summary>
    ///    Determines whether the record set provided is supported by this class.
    /// </summary>
    /// <param name="_dataSet">
    ///		Record to be validated.
    /// </param>
    /// <returns>
    ///    true if the record set is supported by this class; otherwise, false.
    /// </returns>
    protected boolean isSupportedDataSet(Common _dataSet)
    {
        boolean returnValue = false;

        if (_dataSet is ProjCostTrans ||
            _dataSet is ProjEmplTrans ||
            _dataSet is ProjItemTrans ||
            _dataSet is ProjRevenueTrans ||
            _dataSet is ProjOnAccTrans ||
            _dataSet is ProjPostedTransTable ||  //Denormalized transaction data
            _dataSet.TableId ==  tableNum(ProjPostTransView)) // View using denormalized data table
        {
            returnValue = true;
        }

        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>getDecimalRounding</Name>
				<Source><![CDATA[
    protected RoundOff getDecimalRounding(UnitOfMeasureSymbol _unitOfMeasure)
    {
        RoundOff returnValue;

		UnitOfMeasureDecimalPrecision   decimalPrecision;
        decimalPrecision = UnitOfMeasure::findBySymbol(_unitOfMeasure).DecimalPrecision;
		switch (decimalPrecision)
		{
			case 1:
                returnValue = 0.1;
				break;

			case 2:
                returnValue = 0.01;
				break;

			default:
                returnValue = 1.0;
		}
        return returnValue;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateIndirectComponentPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Update existing indirect component records with the new transaction id
    /// </summary>
    /// <param name="_origTransId">
    ///		The original transaction Id.
    /// </param>
    /// <param name="_fundingSource">
    ///		The project funding source reference.
    /// </param>
    /// <param name="_newTransId">
    ///		The new transaction Id.
    /// </param>
    protected void updateIndirectComponentPosting(ProjTransIdBase _origTransId, ProjFundingSourceRefId _fundingSource, ProjTransIdBase _newTransId)
    {
        ttsbegin;
        PSAIndirectComponentTrans psaIndirectComponentTrans;
        update_recordset psaIndirectComponentTrans
            setting TransId = _newTransId
        where psaIndirectComponentTrans.TransId == _origTransId &&
              psaIndirectComponentTrans.ProjFundingSource == _fundingSource;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateProjTransPosting</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Update existing project posted transactions records with the new transaction id
    /// </summary>
    /// <param name="_origTransId">
    ///		The original transaction Id.
    /// </param>
    /// <param name="_fundingSource">
    ///		The project funding source reference.
    /// </param>
    /// <param name="_newTransId">
    ///		The new transaction Id.
    /// </param>
    protected void updateProjTransPosting(ProjTransIdBase _origTransId, ProjFundingSourceRefId _fundingSource, ProjTransIdBase _newTransId)
    {
        ttsbegin;
        ProjTransPosting projTransPosting;
        update_recordset projTransPosting
            setting TransId = _newTransId
        where projTransPosting.TransId == _origTransId &&
              projTransPosting.ProjFundingSource == _fundingSource;
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewEmplTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new project transaction record from an existing posted hour transaction
    ///		consisting of the non-invoiced funding sources.
    /// </summary>
    /// <param name="_recordToSplit">
    ///		The original transaction.
    /// </param>
    protected void createNewEmplTrans(ProjEmplTrans _recordToSplit)
    {
        ProjTransIdBase originalTransId = _recordToSplit.TransId;

        // Clone the existing transaction.  This will be the Invoiced transaction
        ProjTransIdBase cloneTransId = this.cloneEmplTransaction(originalTransId);

        if (cloneTransId != '')
        {
			// Moved the non-invoiced lines to another transactions
			ProjTransIdBase newTransId = ProjParameters::newTransId();
			ProjEmplTrans newEmplTrans = _recordToSplit.data();
			newEmplTrans.TransId = newTransId;
            newEmplTrans.AdjRefTransId = originalTransId;
            newEmplTrans.PSAProjOrigTransId = originalTransId;
            newEmplTrans.TransIdRef = originalTransId;

            //Clear the totals as they are updated by the cost/sale insert methods
			newEmplTrans.TotalCostAmountCur = 0;
			newEmplTrans.TotalSalesAmountCur = 0;
			if (newEmplTrans.validateWrite())
            {
                ttsbegin;
                newEmplTrans.selectForUpdate(true);
                newEmplTrans.insert();

                // Transfer the non-invoiced sublines
                ProjEmplTransSale projEmplTransSale;
                while select forupdate projEmplTransSale
                    where projEmplTransSale.TransId == cloneTransId &&
                          projEmplTransSale.TransStatus != ProjTransStatus::Invoiced
                {
					// Create the sales record.
					projEmplTransSale newProjEmplTransSale = projEmplTransSale.data();
                    newProjEmplTransSale.TransId = newTransId;
					newProjEmplTransSale.insert();

					// Create the cooresponding cost record
					ProjEmplTransCost projEmplTransCost;
					select forupdate projEmplTransCost
						where projEmplTransCost.TransId == projEmplTransSale.TransId &&
															projEmplTransCost.FundingSource == projEmplTransSale.FundingSource;
					ProjEmplTransCost newProjEmplTransCost = projEmplTransCost.data();
					newProjEmplTransCost.TransId = newTransId;
					newProjEmplTransCost.insert();

					// Update project transaction posting records
                    this.updateProjTransPosting(originalTransId, projEmplTransSale.FundingSource, newTransId);

					// Update indirect cost component records
					this.updateIndirectComponentPosting(projEmplTransSale.TransId, projEmplTransSale.FundingSource, newTransId);
                
                    projEmplTransSale.delete();
                    projEmplTransCost.delete();
                }

                // Update the ProjTransPosting record to the remaining cloned values
                while select FundingSource from projEmplTransSale where projEmplTransSale.TransId == cloneTransId
                {
                    this.updateProjTransPosting(originalTransId, projEmplTransSale.FundingSource, cloneTransId);
                }

                // Update Qty for non-invoived transaction
                newEmplTrans = ProjEmplTrans::find(newTransId, true);
                real percentageOfOriginal;
                if (_recordToSplit.TotalSalesAmountCur)
                {
                    percentageOfOriginal = newEmplTrans.TotalSalesAmountCur / _recordToSplit.TotalSalesAmountCur;
                }
                else
                {
                    percentageOfOriginal = newEmplTrans.TotalCostAmountCur / _recordToSplit.TotalCostAmountCur;
                }
                newEmplTrans.Qty = round(_recordToSplit.Qty * percentageOfOriginal, 0.01);
                if (newEmplTrans.Qty == 0.0)
                {
                    newEmplTrans.Qty = 0.01;
                }
                newEmplTrans.update();

                // Update Qty for invoiced transaction
                ProjEmplTrans cloneEmplTrans = ProjEmplTrans::find(cloneTransId, true);
                cloneEmplTrans.Qty -= newEmplTrans.Qty;
                if (cloneEmplTrans.Qty == 0.0)
                {
                    cloneEmplTrans.Qty = 0.01;
                }
                cloneEmplTrans.AdjRefTransId = originalTransId;
                cloneEmplTrans.PSAProjOrigTransId = originalTransId;
                cloneEmplTrans.TransIdRef = originalTransId;
                cloneEmplTrans.update();
                ttscommit;

				// Set the original transaction as Adjusted
                this.setTransactionAsAdjusted(originalTransId, ProjTransType::Hour);

				// Set denomalized table as split
                this.setSplitTransaction(originalTransId);

				// Update prices
                this.updateCostSalesPrices(cloneTransId, ProjTransType::Hour);
				this.updateCostSalesPrices(newTransId, ProjTransType::Hour);

                // Update Invoice proposals and Invoice RefRecIds
                this.updateInvoiceProposalRefRecIds(ProjTransType::Hour, originalTransId, cloneTransId);
                this.updateInvoiceRefRecIds(ProjTransType::Hour, originalTransId, cloneTransId);

				// Update Invoice proposals and Invoices TransIds
                this.updateInvoiceProposalTransId(ProjTransType::Hour, originalTransId, cloneTransId);
				this.updateInvoiceTransId(ProjTransType::Hour, originalTransId, cloneTransId);
           }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewCostTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new project transaction record from an existing posted expense transaction
    ///		consisting of the non-invoiced funding sources.
    /// </summary>
    /// <param name="_recordToSplit">
    ///		The original transaction.
    /// </param>
    protected void createNewCostTrans(ProjCostTrans _recordToSplit)
    {
        ProjTransIdBase originalTransId = _recordToSplit.TransId;

		// Clone the existing transaction
        ProjTransIdBase cloneTransId = this.cloneCostTransaction(_recordToSplit.TransId);

        if (cloneTransId != '')
        {
			// Create transaction without invoiced sales records
			ProjTransIdBase newTransId = ProjParameters::newTransId();
			ProjCostTrans newCostTrans = _recordToSplit.data();
			newCostTrans.TransId = newTransId;
            newCostTrans.AdjRefTransId = originalTransId;
            newCostTrans.PSAProjOrigTransId = originalTransId;
            newCostTrans.TransIdRef = originalTransId;

			//Clear the totals as they are updated by the cost/sale insert methods
			newCostTrans.TotalCostAmountCur = 0;
			newCostTrans.TotalSalesAmountCur = 0;
			if (newCostTrans.validateWrite())
			{
				ttsbegin;
				newCostTrans.selectForUpdate(true);
				newCostTrans.insert();

				// Transfer the non-invoiced sublines
				ProjCostTransSale projCostTransSale;
				while select forupdate projCostTransSale
                    where projCostTransSale.TransId == cloneTransId &&
						  projCostTransSale.TransStatus != ProjTransStatus::Invoiced
				{
					// Create the sales record.
					projCostTransSale newProjCostTransSale = projCostTransSale.data();
					newProjCostTransSale.TransId = newTransId;
					newProjCostTransSale.insert();

					// Create the cooresponding cost record
					ProjCostTransCost projCostTransCost;
					select forupdate projCostTransCost
						where projCostTransCost.TransId == projCostTransSale.TransId &&
														   projCostTransCost.FundingSource == projCostTransSale.FundingSource;
					ProjCostTransCost newProjCostTransCost = projCostTransCost.data();
					newProjCostTransCost.TransId = newTransId;
					newProjCostTransCost.insert();

					// Update project transaction posting records
                    this.updateProjTransPosting(originalTransId, projCostTransSale.FundingSource, newTransId);
                
					// Remove the funding sources from the origninal transaction
					projCostTransSale.delete();
					projCostTransCost.delete();
				}

                // Update the ProjTransPosting record to the remaining cloned values
                while select FundingSource from projCostTransSale where projCostTransSale.TransId == cloneTransId
                {
                    this.updateProjTransPosting(originalTransId, projCostTransSale.FundingSource, cloneTransId);
                }

				// Update Qty fields
				newCostTrans = ProjCostTrans::find(newTransId, true);
				real percentageOfOriginal;
				if (_recordToSplit.TotalSalesAmountCur)
				{
					percentageOfOriginal = newCostTrans.TotalSalesAmountCur / _recordToSplit.TotalSalesAmountCur;
				}
				else
				{
					percentageOfOriginal = newCostTrans.TotalCostAmountCur / _recordToSplit.TotalCostAmountCur;
				}
				newCostTrans.Qty = round(_recordToSplit.Qty * percentageOfOriginal, 0.01);
				if (newCostTrans.Qty == 0.0)
				{
					newCostTrans.Qty = 0.01;
				}
				newCostTrans.update();

                ProjCostTrans cloneCostTrans = ProjCostTrans::find(cloneTransId, true);
                cloneCostTrans.Qty -= newCostTrans.Qty;
                if (cloneCostTrans.Qty == 0.0)
				{
                    cloneCostTrans.Qty = 0.01;
				}

                cloneCostTrans.AdjRefTransId = originalTransId;
                cloneCostTrans.PSAProjOrigTransId = originalTransId;
                cloneCostTrans.TransIdRef = originalTransId;
                cloneCostTrans.update();
                ttscommit;

				// Set the original transaction as invoiced
                this.setTransactionAsAdjusted(originalTransId, ProjTransType::Cost);

                // Set denomalized table as split
                this.setSplitTransaction(originalTransId);

				// Update prices
                this.updateCostSalesPrices(cloneTransId, ProjTransType::Cost);
				this.updateCostSalesPrices(newTransId, ProjTransType::Cost);

                // Update Invoice proposals and Invoice RefRecIds
                this.updateInvoiceProposalRefRecIds(ProjTransType::Cost, originalTransId, cloneTransId);
                this.updateInvoiceRefRecIds(ProjTransType::Cost, originalTransId, cloneTransId);

				// Update Invoice proposals and Invoices TransIds
                this.updateInvoiceProposalTransId(ProjTransType::Cost, originalTransId, cloneTransId);
                this.updateInvoiceTransId(ProjTransType::Cost, originalTransId, cloneTransId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewItemTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new project transaction record from an existing posted item transaction
    ///		consisting of the non-invoiced funding sources.
    /// </summary>
    /// <param name="_recordToSplit">
    ///		The original transaction.
    /// </param>
    protected void createNewItemTrans(ProjItemTrans _recordToSplit)
    {
        ProjTransIdBase originalTransId = _recordToSplit.ProjTransId;

        // Clone the existing transaction
        ProjTransIdBase cloneTransId = this.cloneItemTransaction(_recordToSplit.ProjTransId);

        if (cloneTransId != '')
        {
			ProjTransIdBase newTransId = ProjParameters::newTransId();
			ProjItemTrans newItemTrans = _recordToSplit.data();
			newItemTrans.ProjTransId = newTransId;
            newItemTrans.AdjRefTransId = originalTransId;
            newItemTrans.PSAProjOrigTransId = originalTransId;
            newItemTrans.ProjTransIdRef = originalTransId;

			//Clear the totals as they are updated by the cost/sale insert methods
			newItemTrans.TotalCostAmountCur = 0;
			newItemTrans.TotalSalesAmountCur = 0;
			if (newItemTrans.validateWrite())
			{
				ttsbegin;
				newItemTrans.selectForUpdate(true);
				newItemTrans.insert();

				// Transfer the non-invoiced sublines
				ProjItemTransSale projItemTransSale;
				while select forupdate projItemTransSale
                    where projItemTransSale.ProjTransId == cloneTransId &&
						  projItemTransSale.TransStatus != ProjTransStatus::Invoiced
				{
					// Create the sales record.
					projItemTransSale newProjItemTransSale = projItemTransSale.data();
					newProjItemTransSale.ProjTransId = newTransId;
					newProjItemTransSale.insert();

					// Create the cooresponding cost record
					ProjItemTransCost projItemTransCost;
					select forupdate projItemTransCost
						where projItemTransCost.InventTransId == _recordToSplit.InventTransId &&
							  projItemTransCost.FundingSource == projItemTransSale.FundingSource;
					ProjItemTransCost newProjItemTransCost = projItemTransCost.data();
                    newProjItemTransCost.ProjAdjustRefId = originalTransId;
					newProjItemTransCost.insert();

					// Update project transaction posting records
					this.updateProjTransPosting(projItemTransSale.ProjTransId, projItemTransSale.FundingSource, newTransId);
                
					// Remove the funding sources from the origninal transaction
					projItemTransSale.delete();
					projItemTransCost.delete();
				}

                // Update the ProjTransPosting record to the remaining cloned value
                while select FundingSource from projItemTransSale where projItemTransSale.ProjTransId == cloneTransId
                {
                    this.updateProjTransPosting(originalTransId, projItemTransSale.FundingSource, cloneTransId);
                }

				// Update Qty fields
				newItemTrans = ProjItemTrans::find(newTransId, true);
				RoundOff roundOff = this.getDecimalRounding(_recordToSplit.SalesUnit);
				real percentageOfOriginal;
				{
					percentageOfOriginal = newItemTrans.TotalCostAmountCur / _recordToSplit.TotalCostAmountCur;
				}
				newItemTrans = ProjItemTrans::find(newTransId, true);
				newItemTrans.Qty = round(_recordToSplit.Qty * percentageOfOriginal, roundOff);
				if (newItemTrans.Qty == 0.0)
				{
					newItemTrans.Qty =roundOff;
				}
				newItemTrans.update();

				ProjItemTrans cloneItemTrans = ProjItemTrans::find(cloneTransId, true);
                cloneItemTrans.Qty -= newItemTrans.Qty;
                if (cloneItemTrans.Qty == 0.0)
				{
                    cloneItemTrans.Qty = roundOff;
				}
                cloneItemTrans.AdjRefTransId = originalTransId;
                cloneItemTrans.PSAProjOrigTransId = originalTransId;
                cloneItemTrans.ProjTransIdRef = originalTransId;
                cloneItemTrans.update();
				ttscommit;

                // Set the original transaction as invoiced
                this.setTransactionAsAdjusted(originalTransId, ProjTransType::Item);

                // Set denomalized table as split
                this.setSplitTransaction(originalTransId);

				// Update prices
                this.updateCostSalesPrices(cloneTransId, ProjTransType::Item);
				this.updateCostSalesPrices(newTransId, ProjTransType::Item);

                // Update Invoice proposals and Invoice RefRecIds
                this.updateInvoiceProposalRefRecIds(ProjTransType::Item, originalTransId, cloneTransId);
                this.updateInvoiceRefRecIds(ProjTransType::Item, originalTransId, cloneTransId);

				// Update Invoice proposals and Invoices TransIds
                this.updateInvoiceProposalTransId(ProjTransType::Item, originalTransId, cloneTransId);
                this.updateInvoiceTransId(ProjTransType::Item, originalTransId, cloneTransId);
			}
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewOnAccTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new project transaction record from an existing posted On-account transaction
    ///		consisting of the non-invoiced funding sources.
    /// </summary>
    /// <param name="_recordToSplit">
    ///		The original transaction.
    /// </param>
    protected void createNewOnAccTrans(ProjOnAccTrans _recordToSplit)
    {
        ProjTransIdBase originalTransId = _recordToSplit.TransId;

        // Clone the existing transaction
        ProjTransIdBase cloneTransId = this.cloneOnAccTransaction(_recordToSplit.TransId);
        if (cloneTransId != '')
        {
            //
            // Patch TransIdRef on the fly for records created prior to field being added.
            // This is only used by the adjustment trace
            //
            if (_recordToSplit.TransIdRef == '')
            {
                ttsbegin;
                _recordToSplit.selectForUpdate(true);
                _recordToSplit.TransIdRef = _recordToSplit.TransId;
                _recordToSplit.doUpdate(); // Don't want event or logging to executed.
                ttscommit;
            }
			ProjTransIdBase newTransId = ProjParameters::newTransId();
			ProjOnAccTrans newOnAccTrans = _recordToSplit.data();
			newOnAccTrans.TransId = newTransId;
            newOnAccTrans.AdjRefTransId = originalTransId;
            newOnAccTrans.TransIdRef = originalTransId;

			//Clear the totals as they are updated by the cost/sale insert methods
			newOnAccTrans.TotalSalesAmountCur = 0;
			if (newOnAccTrans.validateWrite())
			{
				ttsbegin;
				newOnAccTrans.selectForUpdate(true);
				newOnAccTrans.insert();

				// Transfer the non-invoiced sublines
				ProjOnAccTransSale projOnAccTransSale;
				while select forupdate projOnAccTransSale
                    where projOnAccTransSale.TransId == cloneTransId &&
						  projOnAccTransSale.TransStatus != ProjTransStatus::Invoiced
				{
					// Create the sales record.
					projOnAccTransSale newProjOnAccTransSale = projOnAccTransSale.data();
					newProjOnAccTransSale.TransId = newTransId;
					newProjOnAccTransSale.insert();

					// Update project transaction posting records
					this.updateProjTransPosting(projOnAccTransSale.TransId, projOnAccTransSale.FundingSource, newTransId);
                
					// Remove the funding sources from the origninal transaction
					projOnAccTransSale.delete();
				}

                // Update the ProjTransPosting record to the remaining cloned values
                while select FundingSource from projOnAccTransSale where projOnAccTransSale.TransId == cloneTransId
                {
                    this.updateProjTransPosting(originalTransId, projOnAccTransSale.FundingSource, cloneTransId);
                }

                ProjOnAccTrans cloneOnAccTrans = ProjOnAccTrans::find(cloneTransId, true);
                cloneOnAccTrans.AdjRefTransId = originalTransId;
                cloneOnAccTrans.TransIdRef = originalTransId;
                cloneOnAccTrans.update();
                ttscommit;

                // Set the original transaction as invoiced
                this.setTransactionAsAdjusted(originalTransId, ProjTransType::OnAccount);

                // Set denomalized table as split
                this.setSplitTransaction(originalTransId);

                // Update Invoice proposals and Invoice RefRecIds
                this.updateInvoiceProposalRefRecIds(ProjTransType::OnAccount, originalTransId, cloneTransId);
                this.updateInvoiceRefRecIds(ProjTransType::OnAccount, originalTransId, cloneTransId);

				// Update Invoice proposals and Invoices TransIds
                this.updateInvoiceProposalTransId(ProjTransType::OnAccount, originalTransId, cloneTransId);
                this.updateInvoiceTransId(ProjTransType::OnAccount, originalTransId, cloneTransId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>createNewRevenueTrans</Name>
				<Source><![CDATA[
    /// <summary>
    ///		Creates a new project transaction record from an existing posted fee transaction
    ///		consisting of the non-invoiced funding sources.
    /// </summary>
    /// <param name="_recordToSplit">
    ///		The original transaction.
    /// </param>
    protected void createNewRevenueTrans(ProjRevenueTrans _recordToSplit)
    {
        ProjTransIdBase originalTransId = _recordToSplit.TransId;

        // Clone the existing transaction
        ProjTransIdBase cloneTransId = this.cloneRevenueTransaction(_recordToSplit.TransId);

        if (cloneTransId != '')
        {
			ProjTransIdBase newTransId = ProjParameters::newTransId();
			ProjRevenueTrans newRevenueTrans = _recordToSplit.data();
			newRevenueTrans.TransId = newTransId;
            newRevenueTrans.AdjRefTransId = originalTransId;
            newRevenueTrans.PSAProjOrigTransId = originalTransId;
            newRevenueTrans.TransIdRef = originalTransId;

			//Clear the totals as they are updated by the cost/sale insert methods
			newRevenueTrans.TotalSalesAmountCur = 0;
			if (newRevenueTrans.validateWrite())
			{
				ttsbegin;
				newRevenueTrans.selectForUpdate(true);
				newRevenueTrans.insert();

				// Transfer the non-invoiced sublines
				ProjRevenueTransSale projRevenueTransSale;
				while select forupdate projRevenueTransSale
                    where projRevenueTransSale.TransId == cloneTransId &&
						  projRevenueTransSale.TransStatus != ProjTransStatus::Invoiced
				{
					// Create the sales record.
					projRevenueTransSale newProjRevenueTransSale = projRevenueTransSale.data();
					newProjRevenueTransSale.TransId = newTransId;
					newProjRevenueTransSale.insert();

					// Update project transaction posting records
                    this.updateProjTransPosting(originalTransId, projRevenueTransSale.FundingSource, newTransId);
                
					// Remove the funding sources from the origninal transaction
					projRevenueTransSale.delete();
				}

                // Update the ProjTransPosting record to the remaining cloned values
                while select FundingSource from projRevenueTransSale where projRevenueTransSale.TransId == cloneTransId
                {
                    this.updateProjTransPosting(originalTransId, projRevenueTransSale.FundingSource, cloneTransId);
                }

                // Set the adjustment references for the cloned transaction
                ProjRevenueTrans cloneRevenueTrans = ProjRevenueTrans::find(cloneTransId, true);
                cloneRevenueTrans.AdjRefTransId = originalTransId;
                cloneRevenueTrans.PSAProjOrigTransId = originalTransId;
                cloneRevenueTrans.TransIdRef = originalTransId;
                cloneRevenueTrans.update();
				ttscommit;

                // Set the original transaction as invoiced
                this.setTransactionAsAdjusted(originalTransId, ProjTransType::Revenue);

                // Set denomalized table as split
                this.setSplitTransaction(originalTransId);

				// Update prices
                this.updateCostSalesPrices(cloneTransId, ProjTransType::Revenue);
				this.updateCostSalesPrices(newTransId, ProjTransType::Revenue);

                // Update Invoice proposals and Invoice RefRecIds
                this.updateInvoiceProposalRefRecIds(ProjTransType::Revenue, originalTransId, cloneTransId);
                this.updateInvoiceRefRecIds(ProjTransType::Revenue, originalTransId, cloneTransId);

				// Update Invoice proposals and Invoices TransIds
                this.updateInvoiceProposalTransId(ProjTransType::Revenue, originalTransId, cloneTransId);
                this.updateInvoiceTransId(ProjTransType::Revenue, originalTransId, cloneTransId);
            }
        }
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneCostTransaction</Name>
				<Source><![CDATA[
    protected ProjTransIdBase cloneCostTransaction(ProjTransIdBase _transactionId)
    {
        // Clone the existing transaction
        ProjTransIdBase cloneTransId = ProjParameters::newTransId();

        ttsbegin;
        ProjCostTrans cloneCostTrans = ProjCostTrans::find(_transactionId);;
        cloneCostTrans.TransId = cloneTransId;
        //Clear the totals as they are updated by the cost/sale insert methods
        cloneCostTrans.TotalCostAmountCur = 0;
        cloneCostTrans.TotalSalesAmountCur = 0;
        if (cloneCostTrans.validateWrite())
        {
            cloneCostTrans.insert();

            // clone the cost records
            ProjCostTransCost projCostTransCost;
            ProjCostTransCost cloneCostTransCost;
            while select projCostTransCost
                where projCostTransCost.TransId == _transactionId
            {
                cloneCostTransCost.clear();
                cloneCostTransCost = projCostTransCost.data();
                cloneCostTransCost.TransId = cloneTransId;
                cloneCostTransCost.insert();
            }

            // clone the sales records
            ProjCostTransSale projCostTransSale;
            ProjCostTransSale cloneCostTransSale;
            while select projCostTransSale
                where projCostTransSale.TransId == _transactionId
            {
                cloneCostTransSale.clear();
                cloneCostTransSale = projCostTransSale.data();
                cloneCostTransSale.TransId = cloneTransId;
                cloneCostTransSale.insert();
            }

        }
        ttscommit;

        return cloneCostTrans.RecId ? cloneTransId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneEmplTransaction</Name>
				<Source><![CDATA[
    protected ProjTransIdBase cloneEmplTransaction(ProjTransIdBase _transactionId)
    {
        // Clone the existing transaction
        ProjTransIdBase cloneTransId = ProjParameters::newTransId();

        ttsbegin;
        ProjEmplTrans cloneEmplTrans = ProjEmplTrans::find(_transactionId);;
        cloneEmplTrans.TransId = cloneTransId;
        //Clear the totals as they are updated by the cost/sale insert methods
        cloneEmplTrans.TotalCostAmountCur = 0;
        cloneEmplTrans.TotalSalesAmountCur = 0;
        if (cloneEmplTrans.validateWrite())
        {
            cloneEmplTrans.insert();

            // clone the cost records
            ProjEmplTransCost projEmplTransCost;
            ProjEmplTransCost cloneEmplTransCost;
            while select projEmplTransCost
                where projEmplTransCost.TransId == _transactionId
            {
                cloneEmplTransCost.clear();
                cloneEmplTransCost = projEmplTransCost.data();
                cloneEmplTransCost.TransId = cloneTransId;
                cloneEmplTransCost.insert();
            }

            // clone the sales records
            ProjEmplTransSale projEmplTransSale;
            ProjEmplTransSale cloneEmplTransSale;
            while select projEmplTransSale
                where projEmplTransSale.TransId == _transactionId
            {
                cloneEmplTransSale.clear();
                cloneEmplTransSale = projEmplTransSale.data();
                cloneEmplTransSale.TransId = cloneTransId;
                cloneEmplTransSale.insert();
            }

        }

        // Clone the indirect component records
        PSAIndirectComponentTrans originalIndirectCompenentTrans;
        PSAIndirectComponentTrans cloneIndirecCompoenentTrans;
        while select originalIndirectCompenentTrans where originalIndirectCompenentTrans.TransId == _transactionId
        {
            cloneIndirecCompoenentTrans = originalIndirectCompenentTrans.data();
            cloneIndirecCompoenentTrans.TransId = cloneTransId;
            if (cloneIndirecCompoenentTrans.validateWrite())
            {
                cloneIndirecCompoenentTrans.insert();
            }
        }
        ttscommit;

        return cloneEmplTrans.RecId ? cloneTransId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneItemTransaction</Name>
				<Source><![CDATA[
    protected ProjTransIdBase cloneItemTransaction(ProjTransIdBase _transactionId)
    {
        // Clone the existing transaction
        ProjTransIdBase cloneTransId = ProjParameters::newTransId();

        ttsbegin;
        ProjItemTrans cloneItemTrans = ProjItemTrans::find(_transactionId);;
        cloneItemTrans.ProjTransId = cloneTransId;
        //Clear the totals as they are updated by the cost/sale insert methods
        cloneItemTrans.TotalCostAmountCur = 0;
        cloneItemTrans.TotalSalesAmountCur = 0;
        if (cloneItemTrans.validateWrite())
        {
            cloneItemTrans.insert();

            // clone the cost records
            ProjItemTransCost projItemTransCost;
            ProjItemTransCost cloneItemTransCost;
            while select projItemTransCost
                where projItemTransCost.InventTransId == cloneItemTrans.InventTransId &&
                      projItemTransCost.ProjAdjustRefId == cloneItemTrans.ProjAdjustRefId
            {
                cloneItemTransCost.clear();
                cloneItemTransCost = projItemTransCost.data();
                cloneItemTransCost.insert();
            }

            // clone the sales records
            ProjItemTransSale projItemTransSale;
            ProjItemTransSale cloneItemTransSale;
            while select projItemTransSale
                where projItemTransSale.ProjTransId == _transactionId
            {
                cloneItemTransSale.clear();
                cloneItemTransSale = projItemTransSale.data();
                cloneItemTransSale.ProjTransId = cloneTransId;
                cloneItemTransSale.insert();
            }

        }
        ttscommit;

        return cloneItemTrans.RecId ? cloneTransId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneRevenueTransaction</Name>
				<Source><![CDATA[
    protected ProjTransIdBase cloneRevenueTransaction(ProjTransIdBase _transactionId)
    {
        // Clone the existing transaction
        ProjTransIdBase cloneTransId = ProjParameters::newTransId();

        ttsbegin;
        ProjRevenueTrans cloneRevenueTrans = ProjRevenueTrans::find(_transactionId);;
        cloneRevenueTrans.TransId = cloneTransId;
        //Clear the total as it is updated by the sale insert methods
        cloneRevenueTrans.TotalSalesAmountCur = 0;
        if (cloneRevenueTrans.validateWrite())
        {
            cloneRevenueTrans.insert();

           // clone the sales records
            ProjRevenueTransSale projRevenueTransSale;
            ProjRevenueTransSale cloneRevenueTransSale;
            while select projRevenueTransSale
                where projRevenueTransSale.TransId == _transactionId
            {
                cloneRevenueTransSale.clear();
                cloneRevenueTransSale = projRevenueTransSale.data();
                cloneRevenueTransSale.TransId = cloneTransId;
                cloneRevenueTransSale.insert();
            }

        }
        ttscommit;

        return cloneRevenueTrans.RecId ? cloneTransId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>cloneOnAccTransaction</Name>
				<Source><![CDATA[
    protected ProjTransIdBase cloneOnAccTransaction(ProjTransIdBase _transactionId)
    {
        // Clone the existing transaction
        ProjTransIdBase cloneTransId = ProjParameters::newTransId();

        ttsbegin;
        ProjOnAccTrans cloneOnAccTrans = ProjOnAccTrans::find(_transactionId);;
        cloneOnAccTrans.TransId = cloneTransId;
        //Clear the total as it is updated by the sale insert methods
        cloneOnAccTrans.TotalSalesAmountCur = 0;
        if (cloneOnAccTrans.validateWrite())
        {
            cloneOnAccTrans.insert();

            // clone the sales records
            ProjOnAccTransSale projOnAccTransSale;
            ProjOnAccTransSale cloneOnaccTransSale;
            while select projOnAccTransSale
                where projOnAccTransSale.TransId == _transactionId
            {
                cloneOnaccTransSale.clear();
                cloneOnaccTransSale = projOnAccTransSale.data();
                cloneOnaccTransSale.TransId = cloneTransId;
                cloneOnaccTransSale.insert();
            }

        }
        ttscommit;

        return cloneOnAccTrans.RecId ? cloneTransId : '';
    }

]]></Source>
			</Method>
			<Method>
				<Name>setTransactionAsAdjusted</Name>
				<Source><![CDATA[
    private void setTransactionAsAdjusted(ProjTransIdBase _transactionId, ProjTransType _transactionType)
    {
		switch (_transactionType)
        {
            case ProjTransType::Hour:
                ProjEmplTransCost projEmplTransCost;
				update_recordset projEmplTransCost
                    setting TransStatus = ProjTransStatus::Adjusted
                where projEmplTransCost.TransId == _transactionId;

                ProjEmplTransSale projEmplTransSale;
                update_recordset projEmplTransSale
                    setting TransStatus = ProjTransStatus::Adjusted
                where projEmplTransSale.TransId == _transactionId;
                break;

            case ProjTransType::Cost:
                ProjCostTransCost projCostTransCost;
                update_recordset projCostTransCost
                    setting TransStatus = ProjTransStatus::Adjusted
                where projCostTransCost.TransId == _transactionId;

                ProjCostTransSale projCostTransSale;
                update_recordset projCostTransSale
                    setting TransStatus = ProjTransStatus::Adjusted
                where projCostTransSale.TransId == _transactionId;
                break;

            case ProjTransType::Item:
                ProjItemTrans projItemTrans = ProjItemTrans::find(_transactionId);

                ProjItemTransCost projItemTransCost;
                update_recordset projItemTransCost
                    setting TransStatus = ProjTransStatus::Adjusted
                where projItemTransCost.InventTransId == projItemTrans.InventTransId;

                ProjItemTransSale projItemTransSale;
                update_recordset projItemTransSale
                    setting TransStatus = ProjTransStatus::Adjusted
                where projItemTransSale.ProjTransId == _transactionId;

                break;

            case ProjTransType::Revenue:
                ProjRevenueTransSale projRevenueTransSale;
                update_recordset projRevenueTransSale
                    setting TransStatus = ProjTransStatus::Adjusted
                where projRevenueTransSale.TransId ==_transactionId;
                break;

            case ProjTransType::OnAccount:
                ProjOnAccTransSale projOnAccTransSale;
                update_recordset projOnAccTransSale
                    setting TransStatus = ProjTransStatus::Adjusted
                where projOnAccTransSale.TransId ==_transactionId;
                break;
       }
    }

]]></Source>
			</Method>
			<Method>
				<Name>setSplitTransaction</Name>
				<Source><![CDATA[
    private void setSplitTransaction(ProjTransIdBase _transId)
    {
        ProjPostedTransTable projPostedTransTable;

        ttsbegin;
        projPostedTransTable = ProjPostedTransTable::findByTransId(_transId, true);
        if (projPostedTransTable)
        {
            projPostedTransTable.IsSplitTransaction = NoYes::Yes;
            projPostedTransTable.update();
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceProposalTransId</Name>
				<Source><![CDATA[
	private void updateInvoiceProposalTransId(ProjTransType _transType, ProjTransIdBase _originalTrandId, ProjTransIdBase _newTransId)
    {
        ttsbegin;
		switch (_transType)
        {
            case ProjTransType::Hour:
				ProjProposalEmpl projProposalEmpl;
				update_recordset projProposalEmpl
					setting TransId = _newTransId
					where projProposalEmpl.TransId == _originalTrandId;
                break;

            case ProjTransType::Cost:
				ProjProposalCost projProposalCost;
				update_recordset projProposalCost
					setting TransId = _newTransId
                    where projProposalCost.TransId == _originalTrandId;
                break;
                
        //TODO: InventTransId;
			case ProjTransType::Item:
				ProjProposalItem projProposalItem;
				update_recordset projProposalItem
                    setting ProjTransId = _newTransId
                    where projProposalItem.ProjTransId == _originalTrandId;
                break;

            case ProjTransType::Revenue:
				ProjProposalRevenue projProposalRevenue;
				update_recordset projProposalRevenue
                    setting TransId = _newTransId
                    where projProposalRevenue.TransId == _originalTrandId;
                break;
        
            case ProjTransType::OnAccount:
				ProjProposalOnAcc projProposalOnAcc;
				update_recordset projProposalOnAcc
					setting TransId = _newTransId
					where projProposalOnAcc.TransId == _originalTrandId;
                break;
		}
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceProposalRefRecIds</Name>
				<Source><![CDATA[
    private void updateInvoiceProposalRefRecIds(ProjTransType _transType, ProjTransIdBase _originalTrandId, ProjTransIdBase _newTransId)
    {
        ttsbegin;
        switch (_transType)
        {
            case ProjTransType::Hour:
                ProjProposalEmpl ProjProposalEmpl;
                ProjProposalEmplDetail projProposalEmplDetail;
                while select forupdate projProposalEmplDetail 
                    exists join ProjProposalEmpl
                    where projProposalEmplDetail.ProposalRefRecId == ProjProposalEmpl.RecId &&
                          ProjProposalEmpl.TransId == _originalTrandId
                {
                    ProjEmplTransSale originalProjEmplTransSale = ProjEmplTransSale::find(projProposalEmplDetail.SaleRefRecId);
                    ProjEmplTransSale newProjEmplTransSale;
                    select RecId from newProjEmplTransSale
                        where newProjEmplTransSale.TransId == _newTransId &&
                              newProjEmplTransSale.FundingSource == originalProjEmplTransSale.FundingSource;

                    projProposalEmplDetail.SaleRefRecId = newProjEmplTransSale.RecId;
                    projProposalEmplDetail.update();
                }
                break;

            case ProjTransType::Cost:
                ProjProposalCost ProjProposalCost;
                ProjProposalCostDetail projProposalCostDetail;
                while select forupdate projProposalCostDetail
                    exists join ProjProposalCost
                    where projProposalCostDetail.ProposalRefRecId == ProjProposalCost.RecId &&
                          ProjProposalCost.TransId == _originalTrandId
                {
                    ProjCostTransSale originalProjCostTransSale = ProjCostTransSale::find(projProposalCostDetail.SaleRefRecId);
                    ProjCostTransSale newProjCostTransSale;
                    select RecId from newProjCostTransSale
                        where newProjCostTransSale.TransId == _newTransId &&
                              newProjCostTransSale.FundingSource == originalProjCostTransSale.FundingSource;

                    projProposalCostDetail.SaleRefRecId = newProjCostTransSale.RecId;
                    projProposalCostDetail.update();
                }
                break;
                
            case ProjTransType::Item:
                ProjProposalItem ProjProposalItem;
                ProjProposalItemDetail projProposalItemDetail;
                while select forupdate projProposalItemDetail
                    exists join ProjProposalItem
                    where projProposalItemDetail.ProposalRefRecId == ProjProposalItem.RecId &&
                          ProjProposalItem.ProjTransId == _originalTrandId
                {
                    ProjItemTransSale originalProjItemTransSale = ProjItemTransSale::find(projProposalItemDetail.SaleRefRecId);
                    ProjItemTransSale newProjItemTransSale;
                    select RecId from newProjItemTransSale
                        where newProjItemTransSale.ProjTransId == _newTransId &&
                              newProjItemTransSale.FundingSource == originalProjItemTransSale.FundingSource;

                    projProposalItemDetail.SaleRefRecId = newProjItemTransSale.RecId;
                    projProposalItemDetail.update();
                }
                break;

            case ProjTransType::Revenue:
                ProjProposalRevenue ProjProposalRevenue;
                ProjProposalRevenueDetail projProposalRevenueDetail;
                while select forupdate projProposalRevenueDetail
                    exists join ProjProposalRevenue
                    where projProposalRevenueDetail.ProposalRefRecId == ProjProposalRevenue.RecId &&
                          ProjProposalRevenue.TransId == _originalTrandId
                {
                    ProjRevenueTransSale originalProjRevenueTransSale = ProjRevenueTransSale::find(projProposalRevenueDetail.SaleRefRecId);
                    ProjRevenueTransSale newProjRevenueTransSale;
                    select RecId from newProjRevenueTransSale
                        where newProjRevenueTransSale.TransId == _newTransId &&
                              newProjRevenueTransSale.FundingSource == originalProjRevenueTransSale.FundingSource;

                    projProposalRevenueDetail.SaleRefRecId = newProjRevenueTransSale.RecId;
                    projProposalRevenueDetail.update();
                }
                break;
        
            case ProjTransType::OnAccount:
                ProjProposalOnAcc ProjProposalOnAcc;
                ProjProposalOnAccDetail projProposalOnAccDetail;
                while select forupdate projProposalOnAccDetail
                    exists join ProjProposalOnAcc
                    where projProposalOnAccDetail.ProposalRefRecId == ProjProposalOnAcc.RecId &&
                          ProjProposalOnAcc.TransId == _originalTrandId
                {
                    ProjOnAccTransSale originalProjOnAccTransSale = ProjOnAccTransSale::find(projProposalOnAccDetail.SaleRefRecId);
                    ProjOnAccTransSale newProjOnAccTransSale;
                    select RecId from newProjOnAccTransSale
                        where newProjOnAccTransSale.TransId == _newTransId &&
                              newProjOnAccTransSale.FundingSource == originalProjOnAccTransSale.FundingSource;

                    projProposalOnAccDetail.SaleRefRecId = newProjOnAccTransSale.RecId;
                    projProposalOnAccDetail.update();
                }
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceRefRecIds</Name>
				<Source><![CDATA[
    private void updateInvoiceRefRecIds(ProjTransType _transType, ProjTransIdBase _originalTrandId, ProjTransIdBase _newTransId)
    {
        ttsbegin;
        switch (_transType)
        {
            case ProjTransType::Hour:
                ProjInvoiceEmpl ProjInvoiceEmpl;
                ProjInvoiceEmplDetail projInvoiceEmplDetail;
                while select forupdate projInvoiceEmplDetail
                    exists join ProjInvoiceEmpl
                    where projInvoiceEmplDetail.InvoiceRefRecId == ProjInvoiceEmpl.RecId &&
                          ProjInvoiceEmpl.TransId == _originalTrandId
                {
                    ProjEmplTransSale originalProjEmplTransSale = ProjEmplTransSale::find(projInvoiceEmplDetail.SaleRefRecId);
                    ProjEmplTransSale newProjEmplTransSale;
                    select RecId from newProjEmplTransSale
                        where newProjEmplTransSale.TransId == _newTransId &&
                              newProjEmplTransSale.FundingSource == originalProjEmplTransSale.FundingSource;

                    projInvoiceEmplDetail.SaleRefRecId = newProjEmplTransSale.RecId;
                    projInvoiceEmplDetail.update();
                }
                break;

            case ProjTransType::Cost:
                ProjInvoiceCost ProjInvoiceCost;
                ProjInvoiceCostDetail projInvoiceCostDetail;
                while select forupdate projInvoiceCostDetail
                    exists join ProjInvoiceCost
                    where projInvoiceCostDetail.InvoiceRefRecId == ProjInvoiceCost.RecId &&
                          ProjInvoiceCost.TransId == _originalTrandId
                {
                    ProjCostTransSale originalProjCostTransSale = ProjCostTransSale::find(projInvoiceCostDetail.SaleRefRecId);
                    ProjCostTransSale newProjCostTransSale;
                    select RecId from newProjCostTransSale
                        where newProjCostTransSale.TransId == _newTransId &&
                              newProjCostTransSale.FundingSource == originalProjCostTransSale.FundingSource;

                    projInvoiceCostDetail.SaleRefRecId = newProjCostTransSale.RecId;
                    projInvoiceCostDetail.update();
                }
                break;
                
            case ProjTransType::Item:
                ProjInvoiceItem projInvoiceItem;
                ProjInvoiceItemDetail projInvoiceItemDetail;
                while select forupdate projInvoiceItemDetail
                    exists join projInvoiceItem
                    where projInvoiceItemDetail.InvoiceRefRecId == projInvoiceItem.RecId &&
                          projInvoiceItem.InventTransId == _originalTrandId
                {
                    ProjItemTransSale originalProjItemTransSale = ProjItemTransSale::find(projInvoiceItemDetail.SaleRefRecId);
                    ProjItemTransSale newProjItemTransSale;
                    select RecId from newProjItemTransSale
                        where newProjItemTransSale.ProjTransId == _newTransId &&
                              newProjItemTransSale.FundingSource == originalProjItemTransSale.FundingSource;

                    projInvoiceItemDetail.SaleRefRecId = newProjItemTransSale.RecId;
                    projInvoiceItemDetail.update();
                }
                break;

            case ProjTransType::Revenue:
                ProjInvoiceRevenue projInvoiceRevenue;
                ProjInvoiceRevenueDetail projInvoiceRevenueDetail;
                while select forupdate projInvoiceRevenueDetail
                    exists join projInvoiceRevenue
                    where projInvoiceRevenueDetail.InvoiceRefRecId == projInvoiceRevenue.RecId &&
                          projInvoiceRevenue.TransId == _originalTrandId
                {
                    ProjRevenueTransSale originalProjRevenueTransSale = ProjRevenueTransSale::find(projInvoiceRevenueDetail.SaleRefRecId);
                    ProjRevenueTransSale newProjRevenueTransSale;
                    select RecId from newProjRevenueTransSale
                        where newProjRevenueTransSale.TransId == _newTransId &&
                              newProjRevenueTransSale.FundingSource == originalProjRevenueTransSale.FundingSource;

                    projInvoiceRevenueDetail.SaleRefRecId = newProjRevenueTransSale.RecId;
                    projInvoiceRevenueDetail.update();
                }
               break;
        
            case ProjTransType::OnAccount:
                ProjInvoiceOnAcc projInvoiceOnAcc;
                ProjInvoiceOnAccDetail projInvoiceOnAccDetail;
                while select forupdate projInvoiceOnAccDetail
                    exists join projInvoiceOnAcc
                    where projInvoiceOnAccDetail.InvoiceRefRecId == projInvoiceOnAcc.RecId &&
                          projInvoiceOnAcc.TransId == _originalTrandId
                {
                    ProjOnAccTransSale originalProjOnAccTransSale = ProjOnAccTransSale::find(projInvoiceOnAccDetail.SaleRefRecId);
                    ProjOnAccTransSale newProjOnAccTransSale;
                    select RecId from newProjOnAccTransSale
                        where newProjOnAccTransSale.TransId == _newTransId &&
                              newProjOnAccTransSale.FundingSource == originalProjOnAccTransSale.FundingSource;

                    projInvoiceOnAccDetail.SaleRefRecId = newProjOnAccTransSale.RecId;
                    projInvoiceOnAccDetail.update();
                }
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
			<Method>
				<Name>updateInvoiceTransId</Name>
				<Source><![CDATA[
	private void updateInvoiceTransId(ProjTransType _transType, ProjTransIdBase _originalTrandId, ProjTransIdBase _newTransId)
    {
        ttsbegin;
		switch (_transType)
        {
			case ProjTransType::Hour:
				ProjInvoiceEmpl projInvoiceEmpl;
				update_recordset projInvoiceEmpl
					setting TransId = _newTransId
					where projInvoiceEmpl.TransId == _originalTrandId;
                break;

            case ProjTransType::Cost:
				ProjInvoiceCost projInvoiceCost;
				update_recordset projInvoiceCost
					setting TransId = _newTransId
					where projInvoiceCost.TransId == _originalTrandId;
                break;

			//TODO: InventTransId;
            case ProjTransType::Item:
				ProjInvoiceItem projInvoiceItem;
				update_recordset projInvoiceItem
					setting ProjTransId = _newTransId
					where projInvoiceItem.ProjTransId == _originalTrandId;
                break;

            case ProjTransType::Revenue:
				ProjInvoiceRevenue projInvoiceRevenue;
				update_recordset projInvoiceRevenue
					setting TransId = _newTransId
					where projInvoiceRevenue.TransId == _originalTrandId;
                break;
        
            case ProjTransType::OnAccount:
				ProjInvoiceOnAcc projInvoiceOnAcc;
				update_recordset projInvoiceOnAcc
					setting TransId = _newTransId
					where projInvoiceOnAcc.TransId == _originalTrandId;
                break;
        }
        ttscommit;
    }

]]></Source>
			</Method>
		</Methods>
	</SourceCode>
</AxClass>